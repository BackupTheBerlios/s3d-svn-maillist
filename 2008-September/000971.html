<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [S3d-svn] r991 - in trunk: Documentation/libs3d	Documentation/manpages/man3 libs3d
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/s3d-svn/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r991%20-%20in%20trunk%3A%20Documentation/libs3d%0A%09Documentation/manpages/man3%20libs3d&In-Reply-To=%3C200809042336.m84Na4IE005186%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000970.html">
   <LINK REL="Next"  HREF="000972.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[S3d-svn] r991 - in trunk: Documentation/libs3d	Documentation/manpages/man3 libs3d</H1>
    <B>lazhur at BerliOS</B> 
    <A HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r991%20-%20in%20trunk%3A%20Documentation/libs3d%0A%09Documentation/manpages/man3%20libs3d&In-Reply-To=%3C200809042336.m84Na4IE005186%40sheep.berlios.de%3E"
       TITLE="[S3d-svn] r991 - in trunk: Documentation/libs3d	Documentation/manpages/man3 libs3d">lazhur at mail.berlios.de
       </A><BR>
    <I>Fri Sep  5 01:36:04 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000970.html">[S3d-svn] r990 - in trunk: Documentation Documentation/libs3dw	Documentation/manpages/man3 libs3d libs3dw
</A></li>
        <LI>Next message: <A HREF="000972.html">[S3d-svn] r992 - in trunk/Documentation: . manpages/man3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#971">[ date ]</a>
              <a href="thread.html#971">[ thread ]</a>
              <a href="subject.html#971">[ subject ]</a>
              <a href="author.html#971">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lazhur
Date: 2008-09-05 01:36:02 +0200 (Fri, 05 Sep 2008)
New Revision: 991

Modified:
   trunk/Documentation/libs3d/functions.docbook
   trunk/Documentation/manpages/man3/s3d_delete_event.3
   trunk/Documentation/manpages/man3/s3d_flags_off.3
   trunk/Documentation/manpages/man3/s3d_flags_on.3
   trunk/Documentation/manpages/man3/s3d_mainloop.3
   trunk/Documentation/manpages/man3/s3d_pep_line_normals.3
   trunk/Documentation/manpages/man3/s3d_push_material.3
   trunk/Documentation/manpages/man3/s3d_push_polygon.3
   trunk/Documentation/manpages/man3/s3d_push_polygons.3
   trunk/Documentation/manpages/man3/s3d_push_vertex.3
   trunk/Documentation/manpages/man3/s3d_push_vertices.3
   trunk/Documentation/manpages/man3/s3d_quit.3
   trunk/Documentation/manpages/man3/s3d_rotate.3
   trunk/Documentation/manpages/man3/s3d_set_callback.3
   trunk/libs3d/callback.c
   trunk/libs3d/event.c
   trunk/libs3d/io.c
   trunk/libs3d/proto_out.c
Log:
Begin sentences in detaildescriptions with capital letters

Modified: trunk/Documentation/libs3d/functions.docbook
===================================================================
--- trunk/Documentation/libs3d/functions.docbook	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/libs3d/functions.docbook	2008-09-04 23:36:02 UTC (rev 991)
@@ -7,18 +7,18 @@
          }
          return(0);
  }
-&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_quit&quot;&gt;&lt;title&gt;s3d_quit&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_quit&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;closes the connection and cleares the event-stack. it can also be used to leave the s3d_mainloop().         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_mainloop&quot;&gt;&lt;title&gt;s3d_mainloop&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_mainloop&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void(*)(void) &lt;parameter&gt;f&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;takes a function as argument. it will loop this function until a quit-event is received. you can pass NULL if you have no function to be looped, but its better to sleep some time if you have nothing to do anyway to save cpu-time.&lt;/para&gt;&lt;programlisting&gt; void mainloop(void)
+&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_quit&quot;&gt;&lt;title&gt;s3d_quit&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_quit&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Closes the connection and cleares the event-stack. It can also be used to leave the s3d_mainloop().         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_mainloop&quot;&gt;&lt;title&gt;s3d_mainloop&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_mainloop&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void(*)(void) &lt;parameter&gt;f&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Takes a function as argument. It will loop this function until a quit-event is received. You can pass NULL if you have no function to be looped, but its better to sleep some time if you have nothing to do anyway to save cpu-time.&lt;/para&gt;&lt;programlisting&gt; void mainloop(void)
  {
          usleep(1000); // sleep 1 ms in every cycle
  }
  ...
 
  s3d_mainloop(mainloop());
-&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_vertex&quot;&gt;&lt;title&gt;s3d_push_vertex&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_vertex&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;pushes a vertex onto the vertex stack. make sure that you count how many vertices you've pushed because you'll need that for referencing when you push your polygons.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_vertices&quot;&gt;&lt;title&gt;s3d_push_vertices&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_vertices&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;vbuf&lt;/parameter&gt;&lt;/paramdef!
 &gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;push some vertices from an array. that's much better for performing than using s3d_push_vertex() if you have a lot of vertices (and that's probably the usual case). &lt;/para&gt;&lt;programlisting&gt; float vertices[] = { 0.0, 0.0, 0.0,
+&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_vertex&quot;&gt;&lt;title&gt;s3d_push_vertex&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_vertex&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pushes a vertex onto the vertex stack. make sure that you count how many vertices you've pushed because you'll need that for referencing when you push your polygons.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_vertices&quot;&gt;&lt;title&gt;s3d_push_vertices&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_vertices&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;vbuf&lt;/parameter&gt;&lt;/paramdef!
 &gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Push some vertices from an array. that's much better for performing than using s3d_push_vertex() if you have a lot of vertices (and that's probably the usual case). &lt;/para&gt;&lt;programlisting&gt; float vertices[] = { 0.0, 0.0, 0.0,
                       1.0, 2.0, 3.0,
                       3.0, 2.0, 1.0};
  s3d_push_vertices(object, vertices, 3); // pushing 3 vertices
-&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_material&quot;&gt;&lt;title&gt;s3d_push_material&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_material&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;pushes a material for an object. you will have to count them yourself too, as polygons will ask for the material index number. the material properties are given!
  in rgb (red/green/blue) color codes, in float. 0.0 is the minimum, 1.0 is the maximum a color value can be. the specular color is the color which is directly reflected from the light source. the diffuse color is the color which can be seen in the bright side of the object, and the ambience color is the color of the shadow side of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_material&quot;&gt;&lt;title&gt;s3d_pep_material&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;paramete!
 r&gt;diff_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff!
 _g&lt;/para
meter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Overwriting the latest pushed Material, overwriting the current value with the specified one. See s3d_pep_materials_a if you want to pep more materials.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_material_a&quot;&gt;&lt;title&gt;s3d_push_material_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_material_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_a&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_a&lt;/parameter!
 &gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_a&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Same as s3d_push_material, but color has alpha value added. Use s3d_push_materials_a() if you have a lot of materials to push.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_materials_a&quot;&gt;&lt;title&gt;s3d_push_materials_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_materials_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;mbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pushes a buffer of Materials. Those Materials are in the format float[n*12], with
+&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_material&quot;&gt;&lt;title&gt;s3d_push_material&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_material&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pushes a material for an object. you will have to count them yourself too, as polygons will ask for the material index number. the material properties are given!
  in rgb (red/green/blue) color codes, in float. 0.0 is the minimum, 1.0 is the maximum a color value can be. The specular color is the color which is directly reflected from the light source. the diffuse color is the color which can be seen in the bright side of the object, and the ambience color is the color of the shadow side of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_material&quot;&gt;&lt;title&gt;s3d_pep_material&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;paramete!
 r&gt;diff_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff!
 _g&lt;/para
meter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Overwriting the latest pushed Material, overwriting the current value with the specified one. See s3d_pep_materials_a if you want to pep more materials.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_material_a&quot;&gt;&lt;title&gt;s3d_push_material_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_material_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_a&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_a&lt;/parameter!
 &gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_a&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Same as s3d_push_material, but color has alpha value added. Use s3d_push_materials_a() if you have a lot of materials to push.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_materials_a&quot;&gt;&lt;title&gt;s3d_push_materials_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_materials_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;mbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pushes a buffer of Materials. Those Materials are in the format float[n*12], with
 &lt;/para&gt;&lt;para&gt;mbuf[n*12 + 0-3] - ambience&lt;/para&gt;&lt;para&gt;mbuf[n*12 + 4-7] - specular&lt;/para&gt;&lt;para&gt;mbuf[n *12 + 8-11] - diffusion values
 &lt;/para&gt;&lt;para&gt;of each entry. n is the number of materials pushed. The values are in the order r,g,b,a. If you only want to push one material, use the more easy s3d_push_material_a() function.&lt;/para&gt;&lt;programlisting&gt; // each line has r,g,b,a value
  float bla[24]=
@@ -30,14 +30,14 @@
           0, 1, 1, 1};
 
  s3d_push_materials_a(object, mbuf, 2); // push a red and a cyan material
-&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_material_a&quot;&gt;&lt;title&gt;s3d_pep_material_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_a&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_a&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_a&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynop!
 sis&gt;&lt;para&gt;Overwriting the latest pushed Material, overwriting the current value with the specified one, with alpha value in contrast to s3d_pep_material See s3d_push_materials_a if you want to pep more materials.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_materials_a&quot;&gt;&lt;title&gt;s3d_pep_materials_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_materials_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;mbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Alters the last n pushed Materials. See s3d_push_materials_a() for more information how mbuf should look like. Use s3d_pep_material_a() if you only want to alter the latest material.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_materials_a&quot;&gt;&lt;title&gt;s3d_load_materials_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;!
 /funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_lo!
 ad_mater
ials_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;mbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;start&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Loads n materials starting from index position start into the Material stack. See s3d_push_materials_a for more informatino about the values in mbuf.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_polygon&quot;&gt;&lt;title&gt;s3d_push_polygon&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_polygon&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;v1&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;v2&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;v3&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;material&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;!
 push one polygon on the polygonstack of the object. it takes 3 vertex-index numbers and one material material-index-nr. as argument.&lt;/para&gt;&lt;programlisting&gt; int oid = s3d_new_object();   // create a new object
+&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_material_a&quot;&gt;&lt;title&gt;s3d_pep_material_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;amb_a&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;spec_a&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_r&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_g&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;diff_a&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynop!
 sis&gt;&lt;para&gt;Overwriting the latest pushed Material, overwriting the current value with the specified one, with alpha value in contrast to s3d_pep_material See s3d_push_materials_a if you want to pep more materials.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_materials_a&quot;&gt;&lt;title&gt;s3d_pep_materials_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_materials_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;mbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Alters the last n pushed Materials. See s3d_push_materials_a() for more information how mbuf should look like. Use s3d_pep_material_a() if you only want to alter the latest material.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_materials_a&quot;&gt;&lt;title&gt;s3d_load_materials_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;!
 /funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_lo!
 ad_mater
ials_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;mbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;start&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Loads n materials starting from index position start into the Material stack. See s3d_push_materials_a for more informatino about the values in mbuf.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_polygon&quot;&gt;&lt;title&gt;s3d_push_polygon&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_polygon&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;v1&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;v2&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;v3&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;material&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;!
 Push one polygon on the polygonstack of the object. it takes 3 vertex-index numbers and one material material-index-nr. as argument.&lt;/para&gt;&lt;programlisting&gt; int oid = s3d_new_object();   // create a new object
  s3d_push_vertex(oid, 0.0, 0.0, 0.0);
  s3d_push_vertex(oid, 0.0, 1.0, 0.0);
  s3d_push_vertex(oid, 1.0, 0.0, 0.0);
  s3d_push_material(oid, 0.3, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0);
  s3d_push_polygon(oid, 0, 1, 2, 0);
  // this will create a red polygon
-&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_polygons&quot;&gt;&lt;title&gt;s3d_push_polygons&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_polygons&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const uint32_t *&lt;parameter&gt;pbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;as for vertices, you can push arrays of polygons to have greater performance. the pbuf should contain n polygons which consist of 4 uint32_t values of 3 vertices indices and 1 material index.&lt;/para&gt;&lt;programlisting&gt; uint32_t pbuf[] = { 0, 1, 2, 0};
+&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_polygons&quot;&gt;&lt;title&gt;s3d_push_polygons&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_polygons&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const uint32_t *&lt;parameter&gt;pbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;As for vertices, you can push arrays of polygons to have greater performance. The pbuf should contain n polygons which consist of 4 uint32_t values of 3 vertices indices and 1 material index.&lt;/para&gt;&lt;programlisting&gt; uint32_t pbuf[] = { 0, 1, 2, 0};
  int oid = s3d_new_object();   // create a new object
  s3d_push_vertex(oid, 0.0, 0.0, 0.0);
  s3d_push_vertex(oid, 0.0, 1.0, 0.0);
@@ -45,14 +45,14 @@
  s3d_push_material(oid, 0.3, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0);
  s3d_push_polygons(oid, pbuf, 1);
  // push one polygon with the pbuf data
-&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_line&quot;&gt;&lt;title&gt;s3d_push_line&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_line&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;v1&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;v2&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;material&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Push one line on the linestack of the object. It takes 2 vertex-index- numbers and one material material-index-nr. as argument. If you have a lot of lines to push, use s3d_push_lines()         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_lines&quot;&gt;&lt;title&gt;s3d_push_lines&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_lines&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const uint32_t *&lt;parameter&gt;l!
 buf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pushing n lines on the linestack of the object, each lbuf has a size of n*3, each entry has the index number of the first vertex, second vertex and material number just as in s3d_push_line().         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_texture&quot;&gt;&lt;title&gt;s3d_push_texture&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_texture&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;w&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;h&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Adds a new texture with height w and height h on the texturestack.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_textures&quot;&gt;&lt;title&gt;s3d_push_textures&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;!
 int &lt;function&gt;s3d_push_textures&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;!
 int &lt;par
ameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const uint16_t *&lt;parameter&gt;tbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;As for vertices, you can push arrays of textures on the texture stack to have greater performance. The tbuf should contain n texture sizes which consist of 2 uint16_t values for width and height for each texture.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_vertex&quot;&gt;&lt;title&gt;s3d_pop_vertex&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_vertex&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes the latest n vertices from the vertex stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_polygon&quot;&gt;&lt;title&gt;s3d_pop_polygon&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsi!
 sinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_polygon&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes the latest n polygon from the polygon stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_material&quot;&gt;&lt;title&gt;s3d_pop_material&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_material&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes the latest n material from the material stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_texture&quot;&gt;&lt;title&gt;s3d_pop_texture&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_texture&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;paramete!
 r&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;n!
 &lt;/parame
ter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes the latest n textures from the texture stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_line&quot;&gt;&lt;title&gt;s3d_pop_line&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_line&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes the latest n lines from the line stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_line_normals&quot;&gt;&lt;title&gt;s3d_pep_line_normals&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_line_normals&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;!
 &lt;para&gt;Adds normal information to lines, giving each vertex of a line a normal information. This makes lines somewhat nicer, you'll need that especially when you're going to build wireframe models.&lt;/para&gt;&lt;para&gt;nbuf should contain n * 6 float values, for each vertex a normal vector (x,y,z), and you have 2 Vertices for each line so that makes 6 float values per line in Total.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_polygon_normals&quot;&gt;&lt;title&gt;s3d_pep_polygon_normals&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_normals&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Adds normal information to polygons, giving each vertex of a polygon a normal information. With this, you can achieve smoothed edge effects.&lt;/para&gt;&lt;para&gt;n!
 buf should contain n * 9 float values, for each vertex a norma!
 l vector
 (x,y,z), and you have 3 Vertices for each Polygon so that makes 9 float values per Polygon in Total. Don't worry if you don't use this, it's kind of hard to calculate and the server will always use some proper normal values (same for every vertex, calculated by the plane which is defined by the 3 points of the polygon.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_polygon_tex_coord&quot;&gt;&lt;title&gt;s3d_pep_polygon_tex_coord&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_tex_coord&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x1&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y1&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x2&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y2&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x3&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y3&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pimp t!
 he last polygon pushed with some textures coordinates, x and y values for each vertex point respectively. Those values may be between 0 and 1 and are vertex points on the texture defined in the material of the polygon. If you have more polygons which should get a texture, use s3d_pep_polygon_tex_coords()         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_polygon_tex_coords&quot;&gt;&lt;title&gt;s3d_pep_polygon_tex_coords&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_tex_coords&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;tbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pimp the latest n polygons with texture coordinates. tbuf has 6*n float values for its entries, which are supplied in the order as in s3d_pep_polygon_tex_coord()         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_material_te!
 xture&quot;&gt;&lt;title&gt;s3d_pep_material_texture&lt;/title&gt;&lt;funcsynopsis&gt;&lt;f!
 uncsynop
sisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material_texture&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;tex&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Assign the latest material a texture referenced by the index tex. Of course, you will have pushed this texture with s3d_push_texture()         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_vertex&quot;&gt;&lt;title&gt;s3d_pep_vertex&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_vertex&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Alter the latest pushed vertex, overwriting with the supplied values.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3!
 d_pep_vertices&quot;&gt;&lt;title&gt;s3d_pep_vertices&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_vertices&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;vbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Alter the latest n pushed vertex. vbuf holds the values which are used to overwrite the old data, n entries with each 3 floats specifying x,y,z of the vertices.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_line&quot;&gt;&lt;title&gt;s3d_pep_line&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_line&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;v1&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;v2&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;material&lt;/parameter&gt;&lt;/paramd!
 ef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Alter the latest pushe!
 d line, 
overwriting with the supplied values.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_lines&quot;&gt;&lt;title&gt;s3d_pep_lines&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_lines&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const uint32_t *&lt;parameter&gt;lbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Alter the latest n pushed lines. lbuf holds the values which are used to overwrite the old data, n entries with each 3 uint32_t specifying first, second vertex and material of each line.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_line_normals&quot;&gt;&lt;title&gt;s3d_load_line_normals&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_line_normals&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter!
 &gt;nbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;start&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Just as s3d_pep_line_normals(), with the difference you won't alter the latest n lines but n lines starting with index start.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_polygon_normals&quot;&gt;&lt;title&gt;s3d_load_polygon_normals&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_polygon_normals&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;start&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Just as s3d_pep_polygon_normals(), with the difference you won't alter the latest n polygons but n polygons starting with index start.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 i!
 d=&quot;s3d_load_polygon_tex_coords&quot;&gt;&lt;title&gt;s3d_load_polygon_tex_co!
 ords&lt;/ti
tle&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_polygon_tex_coords&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;tbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;start&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Just as s3d_pep_polygon_tex_coords(), with the difference you won't alter the latest n polygons but n polygons starting with index start.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_texture&quot;&gt;&lt;title&gt;s3d_load_texture&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_texture&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;tex&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;xpos&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parame!
 ter&gt;ypos&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;w&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;h&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const uint8_t *&lt;parameter&gt;data&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Creates a new object, returning the object id.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Of course, you won't forget to toggle it visible, won't you? 
+&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_line&quot;&gt;&lt;title&gt;s3d_push_line&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_line&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;v1&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;v2&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;material&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Push one line on the linestack of the object. It takes 2 vertex-index- numbers and one material material-index-nr. as argument. If you have a lot of lines to push, use s3d_push_lines()         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_lines&quot;&gt;&lt;title&gt;s3d_push_lines&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_lines&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const uint32_t *&lt;parameter&gt;l!
 buf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pushing n lines on the linestack of the object, each lbuf has a size of n*3, each entry has the index number of the first vertex, second vertex and material number just as in s3d_push_line().         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_texture&quot;&gt;&lt;title&gt;s3d_push_texture&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_texture&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;w&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;h&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Adds a new texture with height w and height h on the texturestack.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_textures&quot;&gt;&lt;title&gt;s3d_push_textures&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;!
 int &lt;function&gt;s3d_push_textures&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;!
 int &lt;par
ameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const uint16_t *&lt;parameter&gt;tbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;As for vertices, you can push arrays of textures on the texture stack to have greater performance. The tbuf should contain n texture sizes which consist of 2 uint16_t values for width and height for each texture.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_vertex&quot;&gt;&lt;title&gt;s3d_pop_vertex&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_vertex&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes the latest n vertices from the vertex stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_polygon&quot;&gt;&lt;title&gt;s3d_pop_polygon&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsi!
 sinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_polygon&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes the latest n polygon from the polygon stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_material&quot;&gt;&lt;title&gt;s3d_pop_material&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_material&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes the latest n material from the material stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_texture&quot;&gt;&lt;title&gt;s3d_pop_texture&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_texture&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;paramete!
 r&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;n!
 &lt;/parame
ter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes the latest n textures from the texture stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_line&quot;&gt;&lt;title&gt;s3d_pop_line&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_line&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes the latest n lines from the line stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_line_normals&quot;&gt;&lt;title&gt;s3d_pep_line_normals&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_line_normals&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;!
 &lt;para&gt;Adds normal information to lines, giving each vertex of a line a normal information. This makes lines somewhat nicer, you'll need that especially when you're going to build wireframe models.&lt;/para&gt;&lt;para&gt;nbuf should contain n * 6 float values, for each vertex a normal vector (x,y,z), and you have 2 Vertices for each line so that makes 6 float values per line in total.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_polygon_normals&quot;&gt;&lt;title&gt;s3d_pep_polygon_normals&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_normals&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Adds normal information to polygons, giving each vertex of a polygon a normal information. With this, you can achieve smoothed edge effects.&lt;/para&gt;&lt;para&gt;n!
 buf should contain n * 9 float values, for each vertex a norma!
 l vector
 (x,y,z), and you have 3 Vertices for each Polygon so that makes 9 float values per Polygon in Total. Don't worry if you don't use this, it's kind of hard to calculate and the server will always use some proper normal values (same for every vertex, calculated by the plane which is defined by the 3 points of the polygon.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_polygon_tex_coord&quot;&gt;&lt;title&gt;s3d_pep_polygon_tex_coord&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_tex_coord&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x1&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y1&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x2&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y2&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x3&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y3&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pimp t!
 he last polygon pushed with some textures coordinates, x and y values for each vertex point respectively. Those values may be between 0 and 1 and are vertex points on the texture defined in the material of the polygon. If you have more polygons which should get a texture, use s3d_pep_polygon_tex_coords()         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_polygon_tex_coords&quot;&gt;&lt;title&gt;s3d_pep_polygon_tex_coords&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_tex_coords&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;tbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pimp the latest n polygons with texture coordinates. tbuf has 6*n float values for its entries, which are supplied in the order as in s3d_pep_polygon_tex_coord()         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_material_te!
 xture&quot;&gt;&lt;title&gt;s3d_pep_material_texture&lt;/title&gt;&lt;funcsynopsis&gt;&lt;f!
 uncsynop
sisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material_texture&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;tex&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Assign the latest material a texture referenced by the index tex. Of course, you will have pushed this texture with s3d_push_texture()         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_vertex&quot;&gt;&lt;title&gt;s3d_pep_vertex&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_vertex&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Alter the latest pushed vertex, overwriting with the supplied values.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3!
 d_pep_vertices&quot;&gt;&lt;title&gt;s3d_pep_vertices&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_vertices&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;vbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Alter the latest n pushed vertex. vbuf holds the values which are used to overwrite the old data, n entries with each 3 floats specifying x,y,z of the vertices.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_line&quot;&gt;&lt;title&gt;s3d_pep_line&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_line&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;v1&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;v2&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;material&lt;/parameter&gt;&lt;/paramd!
 ef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Alter the latest pushe!
 d line, 
overwriting with the supplied values.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_lines&quot;&gt;&lt;title&gt;s3d_pep_lines&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_lines&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const uint32_t *&lt;parameter&gt;lbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Alter the latest n pushed lines. lbuf holds the values which are used to overwrite the old data, n entries with each 3 uint32_t specifying first, second vertex and material of each line.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_line_normals&quot;&gt;&lt;title&gt;s3d_load_line_normals&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_line_normals&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter!
 &gt;nbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;start&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Just as s3d_pep_line_normals(), with the difference you won't alter the latest n lines but n lines starting with index start.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_polygon_normals&quot;&gt;&lt;title&gt;s3d_load_polygon_normals&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_polygon_normals&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;start&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Just as s3d_pep_polygon_normals(), with the difference you won't alter the latest n polygons but n polygons starting with index start.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 i!
 d=&quot;s3d_load_polygon_tex_coords&quot;&gt;&lt;title&gt;s3d_load_polygon_tex_co!
 ords&lt;/ti
tle&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_polygon_tex_coords&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const float *&lt;parameter&gt;tbuf&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;start&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Just as s3d_pep_polygon_tex_coords(), with the difference you won't alter the latest n polygons but n polygons starting with index start.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_texture&quot;&gt;&lt;title&gt;s3d_load_texture&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_texture&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;tex&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;xpos&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parame!
 ter&gt;ypos&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;w&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint16_t &lt;parameter&gt;h&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;const uint8_t *&lt;parameter&gt;data&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Creates a new object, returning the object id.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Of course, you won't forget to toggle it visible, won't you? 
         &lt;/para&gt;&lt;/warning&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_new_object&quot;&gt;&lt;title&gt;s3d_new_object&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_new_object&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Creates a new object, returning the object id.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Of course, you won't forget to toggle it visible, won't you? 
-        &lt;/para&gt;&lt;/warning&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_del_object&quot;&gt;&lt;title&gt;s3d_del_object&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_del_object&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes the object referenced by oid.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_clone&quot;&gt;&lt;title&gt;s3d_clone&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_clone&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Clones an already exisiting object. They get just look the same as the parent-object and will change when the parent-object changes. Cloning especially makes sense if you want to use the same object a lot of times. Move and transform is independent from the parent. The function returns the childs object id.         &lt;/para&gt;&lt;/sec!
 t2&gt;&lt;sect2 id=&quot;s3d_clone_target&quot;&gt;&lt;title&gt;s3d_clone_target&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_clone_target&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;toid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Changes the clone target of oid to another object (toid). This assumes you've got oid from s3d_clone before.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_link&quot;&gt;&lt;title&gt;s3d_link&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_link&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid_from&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid_to&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;A linked object will move along with it's link parent. For example if you have a book on a table, you can link the book to the table so the book will &quot;keep on the table&amp;!
 quot; if you move the table around in space. It will also rota!
 te with 
the table etc.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_unlink&quot;&gt;&lt;title&gt;s3d_unlink&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_unlink&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Remove the link of object oid to its target.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_flags_on&quot;&gt;&lt;title&gt;s3d_flags_on&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_flags_on&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;flags&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;turn some flags on for object.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;If you don't toggle OF_VISIBLE on, you won't see your object. usually you want this. (at least after you *push()d all your content) 
-        &lt;/para&gt;&lt;/warning&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_flags_off&quot;&gt;&lt;title&gt;s3d_flags_off&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_flags_off&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;flags&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;turn some flags off for object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_translate&quot;&gt;&lt;title&gt;s3d_translate&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_translate&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Move the object to some position in space. when you create an object, it's always located at 0.0 , 0.0, 0.0.&lt;!
 /para&gt;&lt;warning&gt;&lt;para&gt;Translation is absolute, not relative!
+        &lt;/para&gt;&lt;/warning&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_del_object&quot;&gt;&lt;title&gt;s3d_del_object&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_del_object&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes the object referenced by oid.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_clone&quot;&gt;&lt;title&gt;s3d_clone&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_clone&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Clones an already exisiting object. They get just look the same as the parent-object and will change when the parent-object changes. Cloning especially makes sense if you want to use the same object a lot of times. Move and transform is independent from the parent. The function returns the childs object id.         &lt;/para&gt;&lt;/sec!
 t2&gt;&lt;sect2 id=&quot;s3d_clone_target&quot;&gt;&lt;title&gt;s3d_clone_target&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_clone_target&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;toid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Changes the clone target of oid to another object (toid). This assumes you've got oid from s3d_clone before.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_link&quot;&gt;&lt;title&gt;s3d_link&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_link&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid_from&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid_to&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;A linked object will move along with it's link parent. For example if you have a book on a table, you can link the book to the table so the book will &quot;keep on the table&amp;!
 quot; if you move the table around in space. It will also rota!
 te with 
the table etc.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_unlink&quot;&gt;&lt;title&gt;s3d_unlink&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_unlink&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Remove the link of object oid to its target.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_flags_on&quot;&gt;&lt;title&gt;s3d_flags_on&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_flags_on&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;flags&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Turn some flags on for object.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;If you don't toggle OF_VISIBLE on, you won't see your object. usually you want this. (at least after you *push()d all your content) 
+        &lt;/para&gt;&lt;/warning&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_flags_off&quot;&gt;&lt;title&gt;s3d_flags_off&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_flags_off&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;uint32_t &lt;parameter&gt;flags&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Turn some flags off for object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_translate&quot;&gt;&lt;title&gt;s3d_translate&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_translate&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Move the object to some position in space. when you create an object, it's always located at 0.0 , 0.0, 0.0.&lt;!
 /para&gt;&lt;warning&gt;&lt;para&gt;Translation is absolute, not relative!
 &lt;/para&gt;&lt;/warning&gt;&lt;programlisting&gt; s3d_translate(object, 2, 0, 0);
  s3d_translate(object, 4, 0, 0);
  // object will end up at 4,0,0 and not 6,0,0!!
-&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_rotate&quot;&gt;&lt;title&gt;s3d_rotate&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_rotate&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;rotate an object around the x, y and z-axis respectively. x,y,z may have values between [0,360] degrees.&lt;/para&gt;&lt;para&gt;You will usually only rotate around one axis, leaving the unused fields on 0, I guess. If you want to rotate around more than one axis, please note: The order of the rotation applies is y-axis, x-axis, and then z-axis. You can think of it as the earth position coordinates: x is the longitude, y is the latitude, and z is the rotation at this point of the earth around your bodies axis. (I wonder if that makes i!
 t any clearer ;)&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Rotate is absolute, not relative!
+&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_rotate&quot;&gt;&lt;title&gt;s3d_rotate&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_rotate&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;x&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;y&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Rotate an object around the x, y and z-axis respectively. x,y,z may have values between [0,360] degrees.&lt;/para&gt;&lt;para&gt;You will usually only rotate around one axis, leaving the unused fields on 0, I guess. If you want to rotate around more than one axis, please note: The order of the rotation applies is y-axis, x-axis, and then z-axis. You can think of it as the earth position coordinates: x is the longitude, y is the latitude, and z is the rotation at this point of the earth around your bodies axis. (I wonder if that makes i!
 t any clearer ;)&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Rotate is absolute, not relative!
 &lt;/para&gt;&lt;/warning&gt;&lt;programlisting&gt; s3d_rotate(object, 90,  0, 0);
  s3d_rotate(object, 180, 0, 0);
  // object will be rotated 180 degrees around the x-axis, not 270 degress!
@@ -66,7 +66,7 @@
  s3d_draw_string(str, len);
 
  // not interested in the length? do that: s3d_draw_string(str, NULL);
-&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_strlen&quot;&gt;&lt;title&gt;s3d_strlen&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_strlen&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const char *&lt;parameter&gt;str&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Returns the length of the string if it were rendered with the currently selected font. That might be useful to estimate the size used for a text and render the background or bounding box before inserting the text.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_length&quot;&gt;&lt;title&gt;s3d_vector_length&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_vector_length&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Calculates and returns the length of the given vector (which should be of the type float[3]). More info on wikipedia <A HREF="http://!">http://!</A>
 en.wikipedia.org/wiki/Vector_(spatial)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_dot_product&quot;&gt;&lt;title&gt;s3d_vector_dot_product&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_vector_dot_product&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector2&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Calculates and returns the dot product of vector1 and vector2. All vectors should have the format float[3]. More info on wikipedia. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_subtract&quot;&gt;&lt;title&gt;s3d_vector_subtract&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_vector_subtract&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector2&lt;/param!
 eter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;result_vector&lt;/pa!
 rameter&gt;
[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Subtracts vector1 from vector2, writing result into result_vector. All vectors should have the format float[3]. More info on wikipedia. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_angle&quot;&gt;&lt;title&gt;s3d_vector_angle&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_vector_angle&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector2&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Calculates and returns the angle between vector1 and vector2. Please note that the resulting angle is between 0 and PI, therefore not covering the whole period! To convert in degrees just do result*180/M_PI. All vectors should have the format float[3]. More info on wikipedia. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;!
 s3d_angle_to_cam&quot;&gt;&lt;title&gt;s3d_angle_to_cam&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_angle_to_cam&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;obj_pos&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;cam_pos&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;float *&lt;parameter&gt;angle_rad&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Given obj_pos and cam_pos in the format float[3], angle_rad about which angle the object should be rotated around the y-axis so that it faces the camera. This might become handy if you have some text floating in space and want it to face the camera. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_cross_product&quot;&gt;&lt;title&gt;s3d_vector_cross_product&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_vector_cross_product&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;!
 const float &lt;parameter&gt;vector1&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramd!
 ef&gt;const
 float &lt;parameter&gt;vector2&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;result_vector&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Calculates and returns the cross product of vector1 and vector2. All vectors should have the format float[3]. More info on wikipedia. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_event&quot;&gt;&lt;title&gt;s3d_push_event&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_push_event&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;struct s3d_evt *&lt;parameter&gt;newevt&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pushes an event onto the event-stack. Usually you don't need to do this manually.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_event&quot;&gt;&lt;title&gt;s3d_pop_event&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;struct s3d_evt * &lt;function&gt;s3d_pop_event&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;v!
 oid&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pops the latest event from the stack. Don't forget to free() both the event and its buffer! Returns a pointer to struct s3d_evt.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_find_event&quot;&gt;&lt;title&gt;s3d_find_event&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;struct s3d_evt * &lt;function&gt;s3d_find_event&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Finds the latest occurence of an event, giving the event type as argument. Returns a pointer to struct s3d_evt.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_delete_event&quot;&gt;&lt;title&gt;s3d_delete_event&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_delete_event&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const struct s3d_evt *&lt;parameter&gt;devt&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;deletes an event, the argu!
 ment is the pointer to the event which is to be deleted (maybe!
  obtaine
d from s3d_find_event).         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_set_callback&quot;&gt;&lt;title&gt;s3d_set_callback&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_set_callback&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;s3d_cb &lt;parameter&gt;func&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;sets a callback for a certain event. this is very useful for event-oriented applications. event callbacks will not interrupt each other or the mainloop.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Defining callbacks will only work after calling s3d_init()
+&lt;/programlisting&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_strlen&quot;&gt;&lt;title&gt;s3d_strlen&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_strlen&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const char *&lt;parameter&gt;str&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Returns the length of the string if it were rendered with the currently selected font. That might be useful to estimate the size used for a text and render the background or bounding box before inserting the text.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_length&quot;&gt;&lt;title&gt;s3d_vector_length&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_vector_length&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Calculates and returns the length of the given vector (which should be of the type float[3]). More info on wikipedia <A HREF="http://!">http://!</A>
 en.wikipedia.org/wiki/Vector_(spatial)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_dot_product&quot;&gt;&lt;title&gt;s3d_vector_dot_product&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_vector_dot_product&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector2&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Calculates and returns the dot product of vector1 and vector2. All vectors should have the format float[3]. More info on wikipedia. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_subtract&quot;&gt;&lt;title&gt;s3d_vector_subtract&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_vector_subtract&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector2&lt;/param!
 eter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;result_vector&lt;/pa!
 rameter&gt;
[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Subtracts vector1 from vector2, writing result into result_vector. All vectors should have the format float[3]. More info on wikipedia. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_angle&quot;&gt;&lt;title&gt;s3d_vector_angle&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_vector_angle&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector2&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Calculates and returns the angle between vector1 and vector2. Please note that the resulting angle is between 0 and PI, therefore not covering the whole period! To convert in degrees just do result*180/M_PI. All vectors should have the format float[3]. More info on wikipedia. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;!
 s3d_angle_to_cam&quot;&gt;&lt;title&gt;s3d_angle_to_cam&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_angle_to_cam&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;obj_pos&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;cam_pos&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;float *&lt;parameter&gt;angle_rad&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Given obj_pos and cam_pos in the format float[3], angle_rad about which angle the object should be rotated around the y-axis so that it faces the camera. This might become handy if you have some text floating in space and want it to face the camera. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_cross_product&quot;&gt;&lt;title&gt;s3d_vector_cross_product&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_vector_cross_product&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;!
 const float &lt;parameter&gt;vector1&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramd!
 ef&gt;const
 float &lt;parameter&gt;vector2&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;paramdef&gt;float &lt;parameter&gt;result_vector&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Calculates and returns the cross product of vector1 and vector2. All vectors should have the format float[3]. More info on wikipedia. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_event&quot;&gt;&lt;title&gt;s3d_push_event&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_push_event&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;struct s3d_evt *&lt;parameter&gt;newevt&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pushes an event onto the event-stack. Usually you don't need to do this manually.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_event&quot;&gt;&lt;title&gt;s3d_pop_event&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;struct s3d_evt * &lt;function&gt;s3d_pop_event&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;v!
 oid&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Pops the latest event from the stack. Don't forget to free() both the event and its buffer! Returns a pointer to struct s3d_evt.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_find_event&quot;&gt;&lt;title&gt;s3d_find_event&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;struct s3d_evt * &lt;function&gt;s3d_find_event&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Finds the latest occurence of an event, giving the event type as argument. Returns a pointer to struct s3d_evt.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_delete_event&quot;&gt;&lt;title&gt;s3d_delete_event&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_delete_event&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const struct s3d_evt *&lt;parameter&gt;devt&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Deletes an event, the argu!
 ment is the pointer to the event which is to be deleted (maybe!
  obtaine
d from s3d_find_event).         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_set_callback&quot;&gt;&lt;title&gt;s3d_set_callback&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_set_callback&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;&lt;paramdef&gt;s3d_cb &lt;parameter&gt;func&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;Sets a callback for a certain event. this is very useful for event-oriented applications. event callbacks will not interrupt each other or the mainloop.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Defining callbacks will only work after calling s3d_init()
 &lt;/para&gt;&lt;/warning&gt;&lt;programlisting&gt; #include &lt;inttypes.h&gt;
 
  void obj_click(struct s3d_evt event)

Modified: trunk/Documentation/manpages/man3/s3d_delete_event.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_delete_event.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_delete_event.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -11,5 +11,5 @@
 .fi 
 .SH &quot;Description&quot; 
 .PP 
-deletes an event, the argument is the pointer to the event which is to be deleted (maybe obtained from s3d_find_event).          
+Deletes an event, the argument is the pointer to the event which is to be deleted (maybe obtained from s3d_find_event).          
 .\&quot; created by instant / docbook-to-man

Modified: trunk/Documentation/manpages/man3/s3d_flags_off.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_flags_off.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_flags_off.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -12,5 +12,5 @@
 .fi 
 .SH &quot;Description&quot; 
 .PP 
-turn some flags off for object.          
+Turn some flags off for object.          
 .\&quot; created by instant / docbook-to-man

Modified: trunk/Documentation/manpages/man3/s3d_flags_on.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_flags_on.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_flags_on.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -12,7 +12,7 @@
 .fi 
 .SH &quot;Description&quot; 
 .PP 
-turn some flags on for object. 
+Turn some flags on for object. 
 .PP 
 .RS 
 \fBWarning:   

Modified: trunk/Documentation/manpages/man3/s3d_mainloop.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_mainloop.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_mainloop.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -11,7 +11,7 @@
 .fi 
 .SH &quot;Description&quot; 
 .PP 
-takes a function as argument. it will loop this function until a quit-event is received. you can pass NULL if you have no function to be looped, but its better to sleep some time if you have nothing to do anyway to save cpu-time. 
+Takes a function as argument. It will loop this function until a quit-event is received. You can pass NULL if you have no function to be looped, but its better to sleep some time if you have nothing to do anyway to save cpu-time. 
 .PP 
 .nf 
 void mainloop(void) 

Modified: trunk/Documentation/manpages/man3/s3d_pep_line_normals.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_pep_line_normals.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_pep_line_normals.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -15,5 +15,5 @@
 .PP 
 Adds normal information to lines, giving each vertex of a line a normal information. This makes lines somewhat nicer, you'll need that especially when you're going to build wireframe models. 
 .PP 
-nbuf should contain n * 6 float values, for each vertex a normal vector (x,y,z), and you have 2 Vertices for each line so that makes 6 float values per line in Total.          
+nbuf should contain n * 6 float values, for each vertex a normal vector (x,y,z), and you have 2 Vertices for each line so that makes 6 float values per line in total.          
 .\&quot; created by instant / docbook-to-man

Modified: trunk/Documentation/manpages/man3/s3d_push_material.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_push_material.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_push_material.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -20,5 +20,5 @@
 .fi 
 .SH &quot;Description&quot; 
 .PP 
-pushes a material for an object. you will have to count them yourself too, as polygons will ask for the material index number. the material properties are given in rgb (red/green/blue) color codes, in float. 0.0 is the minimum, 1.0 is the maximum a color value can be. the specular color is the color which is directly reflected from the light source. the diffuse color is the color which can be seen in the bright side of the object, and the ambience color is the color of the shadow side of the object.          
+Pushes a material for an object. you will have to count them yourself too, as polygons will ask for the material index number. the material properties are given in rgb (red/green/blue) color codes, in float. 0.0 is the minimum, 1.0 is the maximum a color value can be. The specular color is the color which is directly reflected from the light source. the diffuse color is the color which can be seen in the bright side of the object, and the ambience color is the color of the shadow side of the object.          
 .\&quot; created by instant / docbook-to-man

Modified: trunk/Documentation/manpages/man3/s3d_push_polygon.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_push_polygon.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_push_polygon.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -15,7 +15,7 @@
 .fi 
 .SH &quot;Description&quot; 
 .PP 
-push one polygon on the polygonstack of the object. it takes 3 vertex-index numbers and one material material-index-nr. as argument. 
+Push one polygon on the polygonstack of the object. it takes 3 vertex-index numbers and one material material-index-nr. as argument. 
 .PP 
 .nf 
 int oid = s3d_new_object();   // create a new object 

Modified: trunk/Documentation/manpages/man3/s3d_push_polygons.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_push_polygons.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_push_polygons.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -13,7 +13,7 @@
 .fi 
 .SH &quot;Description&quot; 
 .PP 
-as for vertices, you can push arrays of polygons to have greater performance. the pbuf should contain n polygons which consist of 4 uint32_t values of 3 vertices indices and 1 material index. 
+As for vertices, you can push arrays of polygons to have greater performance. The pbuf should contain n polygons which consist of 4 uint32_t values of 3 vertices indices and 1 material index. 
 .PP 
 .nf 
 uint32_t pbuf[] = { 0, 1, 2, 0}; 

Modified: trunk/Documentation/manpages/man3/s3d_push_vertex.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_push_vertex.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_push_vertex.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -14,5 +14,5 @@
 .fi 
 .SH &quot;Description&quot; 
 .PP 
-pushes a vertex onto the vertex stack. make sure that you count how many vertices you've pushed because you'll need that for referencing when you push your polygons.          
+Pushes a vertex onto the vertex stack. make sure that you count how many vertices you've pushed because you'll need that for referencing when you push your polygons.          
 .\&quot; created by instant / docbook-to-man

Modified: trunk/Documentation/manpages/man3/s3d_push_vertices.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_push_vertices.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_push_vertices.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -13,7 +13,7 @@
 .fi 
 .SH &quot;Description&quot; 
 .PP 
-push some vertices from an array. that's much better for performing than using s3d_push_vertex() if you have a lot of vertices (and that's probably the usual case).  
+Push some vertices from an array. that's much better for performing than using s3d_push_vertex() if you have a lot of vertices (and that's probably the usual case).  
 .PP 
 .nf 
 float vertices[] = { 0.0, 0.0, 0.0, 

Modified: trunk/Documentation/manpages/man3/s3d_quit.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_quit.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_quit.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -11,5 +11,5 @@
 .fi 
 .SH &quot;Description&quot; 
 .PP 
-closes the connection and cleares the event-stack. it can also be used to leave the s3d_mainloop().          
+Closes the connection and cleares the event-stack. It can also be used to leave the s3d_mainloop().          
 .\&quot; created by instant / docbook-to-man

Modified: trunk/Documentation/manpages/man3/s3d_rotate.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_rotate.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_rotate.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -14,7 +14,7 @@
 .fi 
 .SH &quot;Description&quot; 
 .PP 
-rotate an object around the x, y and z-axis respectively. x,y,z may have values between [0,360] degrees. 
+Rotate an object around the x, y and z-axis respectively. x,y,z may have values between [0,360] degrees. 
 .PP 
 You will usually only rotate around one axis, leaving the unused fields on 0, I guess. If you want to rotate around more than one axis, please note: The order of the rotation applies is y-axis, x-axis, and then z-axis. You can think of it as the earth position coordinates: x is the longitude, y is the latitude, and z is the rotation at this point of the earth around your bodies axis. (I wonder if that makes it any clearer ;) 
 .PP 

Modified: trunk/Documentation/manpages/man3/s3d_set_callback.3
===================================================================
--- trunk/Documentation/manpages/man3/s3d_set_callback.3	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/Documentation/manpages/man3/s3d_set_callback.3	2008-09-04 23:36:02 UTC (rev 991)
@@ -12,7 +12,7 @@
 .fi 
 .SH &quot;Description&quot; 
 .PP 
-sets a callback for a certain event. this is very useful for event-oriented applications. event callbacks will not interrupt each other or the mainloop. 
+Sets a callback for a certain event. this is very useful for event-oriented applications. event callbacks will not interrupt each other or the mainloop. 
 .PP 
 .RS 
 \fBWarning:   

Modified: trunk/libs3d/callback.c
===================================================================
--- trunk/libs3d/callback.c	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/libs3d/callback.c	2008-09-04 23:36:02 UTC (rev 991)
@@ -59,7 +59,7 @@
 
 /** \brief sets a callback
  *
- * sets a callback for a certain event. this is very useful for event-oriented
+ * Sets a callback for a certain event. this is very useful for event-oriented
  * applications. event callbacks will not interrupt each other or the mainloop.
  *
  * \remarks Defining callbacks will only work after calling s3d_init()

Modified: trunk/libs3d/event.c
===================================================================
--- trunk/libs3d/event.c	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/libs3d/event.c	2008-09-04 23:36:02 UTC (rev 991)
@@ -93,7 +93,7 @@
 
 /** \brief delete event from stack
  *
- * deletes an event, the argument is the pointer to the event which is to be
+ * Deletes an event, the argument is the pointer to the event which is to be
  * deleted (maybe obtained from s3d_find_event).
  */
 int s3d_delete_event(const struct s3d_evt *devt)

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/libs3d/io.c	2008-09-04 23:36:02 UTC (rev 991)
@@ -192,7 +192,7 @@
 
 /** \brief shutdown s3d library
  *
- * closes the connection and cleares the event-stack. it can also be used to
+ * Closes the connection and cleares the event-stack. It can also be used to
  * leave the s3d_mainloop().
  */
 int s3d_quit(void)
@@ -228,8 +228,8 @@
 
 /** \brief set mainloop of program
  *
- * takes a function as argument. it will loop this function until a quit-event
- * is received. you can pass NULL if you have no function to be looped, but its
+ * Takes a function as argument. It will loop this function until a quit-event
+ * is received. You can pass NULL if you have no function to be looped, but its
  * better to sleep some time if you have nothing to do anyway to save cpu-time.
  *
  * \code

Modified: trunk/libs3d/proto_out.c
===================================================================
--- trunk/libs3d/proto_out.c	2008-09-04 23:35:44 UTC (rev 990)
+++ trunk/libs3d/proto_out.c	2008-09-04 23:36:02 UTC (rev 991)
@@ -127,7 +127,7 @@
 
 /** \brief push vertex
  *
- * pushes a vertex onto the vertex stack. make sure that you count how many
+ * Pushes a vertex onto the vertex stack. make sure that you count how many
  * vertices you've pushed because you'll need that for referencing when you push
  * your polygons.
  */
@@ -151,7 +151,7 @@
 
 /** \brief push many vertices
  *
- * push some vertices from an array. that's much better for performing than
+ * Push some vertices from an array. that's much better for performing than
  * using s3d_push_vertex() if you have a lot of vertices (and that's probably
  * the usual case).
  * \code
@@ -188,10 +188,10 @@
 
 /** \brief push material
  *
- * pushes a material for an object. you will have to count them yourself too,
+ * Pushes a material for an object. you will have to count them yourself too,
  * as polygons will ask for the material index number. the material properties
  * are given in rgb (red/green/blue) color codes, in float. 0.0 is the minimum,
- * 1.0 is the maximum a color value can be. the specular color is the color
+ * 1.0 is the maximum a color value can be. The specular color is the color
  * which is directly reflected from the light source. the diffuse color is the
  * color which can be seen in the bright side of the object, and the ambience
  * color is the color of the shadow side of the object.
@@ -337,7 +337,7 @@
 
 /** \brief push polygon
  *
- * push one polygon on the polygonstack of the object. it takes 3 vertex-index
+ * Push one polygon on the polygonstack of the object. it takes 3 vertex-index
  * numbers and one material material-index-nr. as argument.
  *
  * \code
@@ -396,7 +396,7 @@
 
 /** \brief push many polygons
  *
- * as for vertices, you can push arrays of polygons to have greater performance. the pbuf should contain n polygons which consist of 4 uint32_t values of 3 vertices indices and 1 material index.
+ * As for vertices, you can push arrays of polygons to have greater performance. The pbuf should contain n polygons which consist of 4 uint32_t values of 3 vertices indices and 1 material index.
  *
  * \code
  * uint32_t pbuf[] = { 0, 1, 2, 0};
@@ -742,7 +742,7 @@
  *
  * nbuf should contain n * 6 float values, for each vertex a normal vector
  * (x,y,z), and you have 2 Vertices for each line so that makes 6 float values
- * per line in Total.
+ * per line in total.
  */
 int s3d_pep_line_normals(int object, const float *nbuf, uint16_t n)
 {
@@ -1105,7 +1105,7 @@
 
 /** \brief enable flags of object
  *
- * turn some flags on for object.
+ * Turn some flags on for object.
  *
  * \remarks If you don't toggle OF_VISIBLE on, you won't see your object. usually
  * you want this. (at least after you *push()d all your content)
@@ -1128,7 +1128,7 @@
 
 /** \brief disable flags of object
  *
- * turn some flags off for object.
+ * Turn some flags off for object.
  */
 int s3d_flags_off(int object, uint32_t flags)
 {
@@ -1179,7 +1179,7 @@
 
 /** \brief rotate object
  *
- * rotate an object around the x, y and z-axis respectively. x,y,z may have
+ * Rotate an object around the x, y and z-axis respectively. x,y,z may have
  * values between [0,360] degrees.
  *
  * You will usually only rotate around one axis, leaving the unused fields on 0,


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000970.html">[S3d-svn] r990 - in trunk: Documentation Documentation/libs3dw	Documentation/manpages/man3 libs3d libs3dw
</A></li>
	<LI>Next message: <A HREF="000972.html">[S3d-svn] r992 - in trunk/Documentation: . manpages/man3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#971">[ date ]</a>
              <a href="thread.html#971">[ thread ]</a>
              <a href="subject.html#971">[ subject ]</a>
              <a href="author.html#971">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/s3d-svn">More information about the S3d-svn
mailing list</a><br>
</body></html>
