<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [S3d-svn] r980 - in trunk: Documentation Documentation/libs3d	Documentation/libs3dw libs3d libs3dw
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/s3d-svn/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r980%20-%20in%20trunk%3A%20Documentation%20Documentation/libs3d%0A%09Documentation/libs3dw%20libs3d%20libs3dw&In-Reply-To=%3C200808312219.m7VMJLd4015599%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000961.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[S3d-svn] r980 - in trunk: Documentation Documentation/libs3d	Documentation/libs3dw libs3d libs3dw</H1>
    <B>lazhur at BerliOS</B> 
    <A HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r980%20-%20in%20trunk%3A%20Documentation%20Documentation/libs3d%0A%09Documentation/libs3dw%20libs3d%20libs3dw&In-Reply-To=%3C200808312219.m7VMJLd4015599%40sheep.berlios.de%3E"
       TITLE="[S3d-svn] r980 - in trunk: Documentation Documentation/libs3d	Documentation/libs3dw libs3d libs3dw">lazhur at mail.berlios.de
       </A><BR>
    <I>Mon Sep  1 00:19:21 CEST 2008</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000961.html">[S3d-svn] r981 - trunk/Documentation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#960">[ date ]</a>
              <a href="thread.html#960">[ thread ]</a>
              <a href="subject.html#960">[ subject ]</a>
              <a href="author.html#960">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lazhur
Date: 2008-09-01 00:19:18 +0200 (Mon, 01 Sep 2008)
New Revision: 980

Added:
   trunk/Documentation/extractdefinitions.py
   trunk/Documentation/libs3d/functions.docbook
   trunk/Documentation/libs3d/structs.docbook
   trunk/Documentation/libs3d/typedefs.docbook
   trunk/Documentation/libs3dw/functions.docbook
   trunk/Documentation/libs3dw/structs.docbook
   trunk/Documentation/libs3dw/typedefs.docbook
   trunk/Documentation/xml.doxygen
Modified:
   trunk/Documentation/CMakeLists.txt
   trunk/Documentation/libs3d/libs3d.docbook
   trunk/Documentation/libs3dw/libs3dw.docbook
   trunk/Documentation/s3d.docbook
   trunk/libs3d/callback.c
   trunk/libs3d/event.c
   trunk/libs3d/freetype.c
   trunk/libs3d/io.c
   trunk/libs3d/modelread.c
   trunk/libs3d/network.c
   trunk/libs3d/proto_out.c
   trunk/libs3d/s3d.h
   trunk/libs3d/vector.c
   trunk/libs3dw/animate.c
   trunk/libs3dw/button.c
   trunk/libs3dw/event.c
   trunk/libs3dw/input.c
   trunk/libs3dw/label.c
   trunk/libs3dw/root.c
   trunk/libs3dw/s3dw.h
   trunk/libs3dw/surface.c
   trunk/libs3dw/textbox.c
   trunk/libs3dw/widget.c
Log:
Generate documentation from source code

Most updates of the documentation could automatically be done when we extract
the informations out of the source code. For this we need to insert the
detailed description of a function into a documentation block before the
function and let another tool extract them. For this purpose doxygen provided
a output plugin for xml which extracts as much information as possible for all
files and outputs all related informations in specific files. So we have
a s3d(w)_8h.xml with all informations to the public api functions in a
doxygen scheme. Another tool can now parse this xml data and transform it into
a partial docbook file with all functions.

Steps to be taken when generating an updated documentation are:
- $ doxygen xml.doxygen
- $ ./extractdefinitions.py
- running docbook2html as part of the normal build process

Currently only doxygen 1.5.6 and python 2.5.2 were tested and so these steps
should not be part of the normal build process.

To have the descriptions near to code should be lowering the barriers to update
them and results in a better overall documentation quality.

Modified: trunk/Documentation/CMakeLists.txt
===================================================================
--- trunk/Documentation/CMakeLists.txt	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/Documentation/CMakeLists.txt	2008-08-31 22:19:18 UTC (rev 980)
@@ -14,7 +14,13 @@
 			${Documentation_SOURCE_DIR}/bookinfo.docbook
 			${Documentation_SOURCE_DIR}/server/server.docbook
 			${Documentation_SOURCE_DIR}/libs3dw/libs3dw.docbook
+			${Documentation_SOURCE_DIR}/libs3dw/functions.docbook
+			${Documentation_SOURCE_DIR}/libs3dw/structs.docbook
+			${Documentation_SOURCE_DIR}/libs3dw/typedefs.docbook
 			${Documentation_SOURCE_DIR}/libs3d/libs3d.docbook
+			${Documentation_SOURCE_DIR}/libs3d/functions.docbook
+			${Documentation_SOURCE_DIR}/libs3d/structs.docbook
+			${Documentation_SOURCE_DIR}/libs3d/typedefs.docbook
 		COMMENT &quot;Build s3d documentation&quot;
 	)
 

Added: trunk/Documentation/extractdefinitions.py
===================================================================
--- trunk/Documentation/extractdefinitions.py	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/Documentation/extractdefinitions.py	2008-08-31 22:19:18 UTC (rev 980)
@@ -0,0 +1,406 @@
+#!/usr/bin/python
+# -*- coding: utf-8; -*-
+
+import xml.dom.minidom
+from xml.dom.minidom import Node
+import os
+
+class Callable:
+    def __init__(self, func):
+        self.__call__ = func
+
+def main():
+	print 'reading with &quot;doxygen xml.doxygen&quot; generated files'
+
+	libs3d = xml.dom.minidom.parse(&quot;xml/s3d_8h.xml&quot;)
+	libs3dw = xml.dom.minidom.parse(&quot;xml/s3dw_8h.xml&quot;)
+
+	libs3d_func = extract_functions(libs3d)
+	libs3dw_func = extract_functions(libs3dw)
+
+	libs3d_struct = extract_structs(libs3d)
+	libs3dw_struct = extract_structs(libs3dw)
+
+	libs3d_typedef = extract_typedefs(libs3d)
+	libs3dw_typedef = extract_typedefs(libs3dw)
+
+	docbook_functions.generate('libs3d', &quot;s3d.h&quot;, libs3d_func)
+	docbook_functions.generate('libs3dw', &quot;s3dw.h&quot;, libs3dw_func)
+
+	docbook_structs.generate('libs3d', libs3d_struct)
+	docbook_structs.generate('libs3dw', libs3dw_struct)
+
+	docbook_typedefs.generate('libs3d', libs3d_typedef)
+	docbook_typedefs.generate('libs3dw', libs3dw_typedef)
+
+&quot;&quot;&quot;
+Generate text from all childNodes
+&quot;&quot;&quot;
+def get_text(node):
+	t = ''
+	for node in node.childNodes:
+		if node.nodeType == Node.TEXT_NODE:
+			t += node.data
+		else:
+			t += get_text(node)
+	return t
+
+
+&quot;&quot;&quot;
+Generate linear list of text and section types
+&quot;&quot;&quot;
+def get_text_complex(node):
+	t = []
+	for node in node.childNodes:
+		if node.nodeType == Node.TEXT_NODE:
+			t.append(node.data)
+		else:
+			if node.nodeName == 'sp':
+				t.append(&quot; &quot;)
+			elif node.nodeName == 'para':
+				t.append({'type': 'para', 'text': ''})
+				t += get_text_complex(node)
+			elif node.nodeName == 'programlisting':
+				t.append({'type': 'programlisting', 'text': ''})
+				t += get_text_complex(node)
+				t.append({'type': 'para', 'text': ''})
+			elif node.nodeName == 'simplesect':
+				if node.attributes['kind'].nodeValue == 'remark':
+					t.append({'type': 'warning', 'text': ''})
+					t += get_text_complex(node)
+					t.append({'type': 'para', 'text': ''})
+				else:
+					t.append({'type': 'para', 'text': ''})
+					t += get_text_complex(node)
+			else:
+				t += get_text_complex(node)
+	return t
+
+&quot;&quot;&quot;
+Convert linear list of text and section types to list of section types with corresponding text
+&quot;&quot;&quot;
+def complex2simplearray(objects):
+	cur_object = 0
+	array = []
+	for element in objects:
+		if type(element) != dict:
+			# add text to last section type
+			if cur_object == 0:
+				array.append({'type': 'para', 'text': element})
+				cur_object = array[0]
+			else:
+				cur_object['text'] += element
+		else:
+			# add new section type
+			if element['type'] == 'para' and len(array) != 0 and array[-1]['type'] in ['warning']:
+				# ignore para inside warning and add text to last section type
+				cur_object['text'] += element['text']
+			else:
+				cur_object = element
+				array.append(element)
+
+	return array
+
+def remove_exportdefinitions(function_return):
+	exports = [&quot;S3DEXPORT&quot;, &quot;S3DWEXPORT&quot;]
+	for export in exports:
+		if function_return[:len(export)] == export:
+			return function_return[len(export):].strip()
+
+&quot;&quot;&quot;
+Create new node with tag name node_type and add it to father
+&quot;&quot;&quot;
+def create_append(document, father, node_type):
+	t = document.createElement(node_type)
+	father.appendChild(t)
+	return t
+
+&quot;&quot;&quot;
+Create new text node with text and add it to father
+&quot;&quot;&quot;
+def create_append_text(document, father, text):
+	t = document.createTextNode(text)
+	father.appendChild(t)
+	return t
+
+&quot;&quot;&quot;
+Append complex help section to sect
+&quot;&quot;&quot;
+def help_append(sgml, sect, help):
+	for p in help:
+		if p['text'] != '':
+			if p['type'] in ['warning']:
+				# add para in warning before adding help text
+				extra_para = create_append(sgml, sect, p['type'])
+				para = create_append(sgml, extra_para, 'para')
+				create_append_text(sgml, para, p['text'])
+			else:
+				para = create_append(sgml, sect, p['type'])
+				create_append_text(sgml, para, p['text'])
+
+&quot;&quot;&quot;
+Extract function informations from doxygen dom
+&quot;&quot;&quot;
+def extract_functions(dom):
+	functionlist = []
+	for node in dom.getElementsByTagName(&quot;memberdef&quot;):
+		# find nodes with functions information
+		if node.attributes['kind'].nodeValue != 'function':
+			continue
+
+		function = {'return': '', 'name': '', 'param': [], 'help': []}
+		for node2 in node.childNodes:
+			if node2.nodeName == &quot;name&quot;:
+				function['name'] = get_text(node2)
+
+			if node2.nodeName == &quot;type&quot;:
+				function['return'] = remove_exportdefinitions(get_text(node2))
+
+			if node2.nodeName == &quot;param&quot;:
+				param = {'type' : '', 'declname' : '', 'array' : ''}
+				for n in node2.childNodes:
+					if n.nodeName == 'type':
+						param['type'] = get_text(n)
+
+					if n.nodeName == 'declname':
+						param['declname'] = get_text(n)
+
+					if n.nodeName == 'array':
+						param['array'] = get_text(n)
+
+				function['param'].append(param)
+
+			if node2.nodeName == 'detaileddescription':
+				help = get_text_complex(node2)
+				function['help'] = complex2simplearray(help)
+
+		functionlist.append(function)
+
+	return functionlist
+
+&quot;&quot;&quot;
+Extract struct informations from doxygen dom
+&quot;&quot;&quot;
+def extract_structs(dom):
+	structlist = []
+	# find refs (names of xml files) of structs
+	for node in dom.getElementsByTagName(&quot;innerclass&quot;):
+		struct = {'name': '', 'ref': '', 'elements': [], 'help': []}
+		struct['name'] = get_text(node)
+		struct['ref'] = node.attributes['refid'].nodeValue
+		structlist.append(struct)
+
+	# open xml files and extract informations from them
+	for struct in structlist:
+		dom = xml.dom.minidom.parse(&quot;xml/&quot;+struct['ref']+&quot;.xml&quot;)
+
+		for node in dom.getElementsByTagName('compounddef')[0].childNodes:
+			if node.nodeName == 'detaileddescription':
+				help = get_text_complex(node)
+				struct['help'] = complex2simplearray(help)
+
+		for node in dom.getElementsByTagName(&quot;memberdef&quot;):
+			element = {'type': '', 'name' : '', 'help': []}
+			for node2 in node.childNodes:
+				if node2.nodeName == &quot;name&quot;:
+					element['name'] = get_text(node2)
+
+				if node2.nodeName == &quot;type&quot;:
+					element['type'] = get_text(node2)
+
+				if node2.nodeName == 'detaileddescription':
+					help = get_text_complex(node2)
+					element['help'] = complex2simplearray(help)
+
+			struct['elements'].append(element)
+
+	return structlist
+
+&quot;&quot;&quot;
+Extract typedef informations from doxygen dom
+&quot;&quot;&quot;
+def extract_typedefs(dom):
+	typedeflist = []
+	for node in dom.getElementsByTagName(&quot;memberdef&quot;):
+		# find nodes with typedef information
+		if node.attributes['kind'].nodeValue != 'typedef':
+			continue
+
+		typedef = {'name': '', 'definition': '', 'help': []}
+		for node2 in node.childNodes:
+			if node2.nodeName == 'name':
+				typedef['name'] = get_text(node2)
+
+			if node2.nodeName == 'definition':
+				typedef['definition'] = get_text(node2)
+
+			if node2.nodeName == 'detaileddescription':
+				help = get_text_complex(node2)
+				typedef['help'] = complex2simplearray(help)
+
+		typedeflist.append(typedef)
+
+	return typedeflist
+
+class docbook_functions:
+	&quot;&quot;&quot;
+	Generate docbook file with informations to all functions
+	&quot;&quot;&quot;
+	def generate(name, synopsis, functionlist):
+		func_file = open(name+'/functions.docbook', &quot;w&quot;)
+		for func in functionlist:
+			sgml = docbook_functions.generate_sgml(func, synopsis)
+			sgml.writexml(func_file)
+		func_file.close()
+
+	&quot;&quot;&quot;
+	Generate docbook sect2 dom with informations to a specific function
+	&quot;&quot;&quot;
+	def generate_sgml(function, synopsis):
+		sgml = xml.dom.minidom.Document()
+		sect2 = create_append(sgml, sgml, 'sect2')
+		sect2.setAttribute('id', function['name'])
+
+		title = create_append(sgml, sect2, 'title')
+		create_append_text(sgml, title, function['name'])
+
+		# synopsis
+		funcsynopsis = create_append(sgml, sect2, 'funcsynopsis')
+		funcsynopsisinfo = create_append(sgml, funcsynopsis, 'funcsynopsisinfo')
+		create_append_text(sgml, funcsynopsisinfo, &quot;#include &lt;&quot;+synopsis+&quot;&gt;&quot;)
+
+		# prototype
+		funcprototype = create_append(sgml, funcsynopsis, 'funcprototype')
+
+		funcdef = create_append(sgml, funcprototype, 'funcdef')
+		create_append_text(sgml, funcdef, function['return']+&quot; &quot;)
+
+		func = create_append(sgml, funcdef, 'function')
+		create_append_text(sgml, func, function['name'])
+
+		# add parameter to function definition
+		paramdef = create_append(sgml, funcprototype, 'paramdef')
+		param_num = len(function['param'])
+		for i in range(0, param_num):
+			if i != 0:
+				create_append_text(sgml, paramdef, &quot;, &quot;)
+
+			create_append_text(sgml, paramdef, function['param'][i]['type'])
+
+			if function['param'][i]['declname'] != '':
+				if function['param'][i]['type'][-1:] != &quot;*&quot;:
+					# dont add space between * and name
+					create_append_text(sgml, paramdef, &quot; &quot;)
+				parameter = create_append(sgml, paramdef, 'parameter')
+				create_append_text(sgml, parameter, function['param'][i]['declname'])
+
+			if function['param'][i]['array'] != '':
+				create_append_text(sgml, paramdef, function['param'][i]['array'])
+
+		# add help to function
+		help_append(sgml, sect2, function['help'])
+
+		return sect2
+
+	# make functions &quot;static&quot;
+	generate = Callable(generate)
+	generate_sgml = Callable(generate_sgml)
+
+class docbook_structs:
+	&quot;&quot;&quot;
+	Generate docbook file with informations to all structs
+	&quot;&quot;&quot;
+	def generate(name, structlist):
+		struct_file = open(name+'/structs.docbook', &quot;w&quot;)
+		for struct in structlist:
+			sgml = docbook_structs.generate_sgml(struct)
+			sgml.writexml(struct_file)
+		struct_file.close()
+
+	&quot;&quot;&quot;
+	Generate docbook sect2 dom with informations to a specific struct
+	&quot;&quot;&quot;
+	def generate_sgml(struct):
+		sgml = xml.dom.minidom.Document()
+		sect2 = create_append(sgml, sgml, 'sect2')
+		sect2.setAttribute('id', 'struct'+struct['name'])
+
+		title = create_append(sgml, sect2, 'title')
+		create_append_text(sgml, title, 'struct '+struct['name'])
+
+		# add definition of struct
+		programlisting = create_append(sgml, sect2, 'programlisting')
+		create_append_text(sgml, programlisting, 'struct '+struct['name']+' {\n')
+		for element in struct['elements']:
+			create_append_text(sgml, programlisting, '\t'+element['type'])
+			if element['type'][-1:] != &quot;*&quot;:
+				# dont add space between * and name
+				create_append_text(sgml, programlisting, &quot; &quot;)
+			create_append_text(sgml, programlisting, element['name']+';\n')
+		create_append_text(sgml, programlisting, '}')
+
+		# add help to struct
+		help_append(sgml, sect2, struct['help'])
+
+		# add list of struct members with their help
+		variablelist = create_append(sgml, sect2, 'variablelist')
+		for element in struct['elements']:
+			# ignore members with empty help texts
+			if len(element['help']) == 1 and element['help'][0]['text'].strip() == '':
+				continue
+
+			varlistentry = create_append(sgml, variablelist, 'varlistentry')
+			term = create_append(sgml, varlistentry, 'term')
+			create_append_text(sgml, term, element['name'])
+			listitem = create_append(sgml, varlistentry, 'listitem')
+
+			# add help to struct member
+			help_append(sgml, listitem, element['help'])
+
+		# remove empty variablelist
+		if len(variablelist.childNodes) == 0:
+			sect2.removeChild(variablelist)
+
+		return sect2
+
+	# make functions &quot;static&quot;
+	generate = Callable(generate)
+	generate_sgml = Callable(generate_sgml)
+
+class docbook_typedefs:
+	&quot;&quot;&quot;
+	Generate docbook file with informations to all typedefs
+	&quot;&quot;&quot;
+	def generate(name, typedeflist):
+		typedef_file = open(name+'/typedefs.docbook', &quot;w&quot;)
+		for typedef in typedeflist:
+			sgml = docbook_typedefs.generate_sgml(typedef)
+			sgml.writexml(typedef_file)
+		typedef_file.close()
+
+	&quot;&quot;&quot;
+	Generate docbook sect2 dom with informations to a specific typedef
+	&quot;&quot;&quot;
+	def generate_sgml(typedef):
+		sgml = xml.dom.minidom.Document()
+		sect2 = create_append(sgml, sgml, 'sect2')
+		sect2.setAttribute('id', typedef['name'])
+
+		title = create_append(sgml, sect2, 'title')
+		create_append_text(sgml, title, 'typedef '+typedef['name'])
+
+		# add definition of typedef
+		programlisting = create_append(sgml, sect2, 'programlisting')
+		create_append_text(sgml, programlisting, typedef['definition'])
+
+		# add help to typedef
+		help_append(sgml, sect2, typedef['help'])
+
+		return sect2
+
+	# make functions &quot;static&quot;
+	generate = Callable(generate)
+	generate_sgml = Callable(generate_sgml)
+
+if __name__ == '__main__':
+	main()


Property changes on: trunk/Documentation/extractdefinitions.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/Documentation/libs3d/functions.docbook
===================================================================
--- trunk/Documentation/libs3d/functions.docbook	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/Documentation/libs3d/functions.docbook	2008-08-31 22:19:18 UTC (rev 980)
@@ -0,0 +1,153 @@
+&lt;sect2 id=&quot;s3d_usage&quot;&gt;&lt;title&gt;s3d_usage&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_usage&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Prints the possible parameter for the client library (which can be passed in s3d_init())         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_init&quot;&gt;&lt;title&gt;s3d_init&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_init&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int *&lt;parameter&gt;argc&lt;/parameter&gt;, char ***&lt;parameter&gt;argv&lt;/parameter&gt;, const char *&lt;parameter&gt;name&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;This will initialize the s3d-library and the connection to the Server. It will return 0 on success in Server initializion. name specifies the your programs name.&lt;/para&gt;&lt;programlisting&gt; int main(char argc, char **argv)
+ {
+         if (!s3d_init(&amp;argc, &amp;argv, &quot;Hello world&quot;))
+         {
+                 ...
+                 s3d_quit();
+         }
+         return(0);
+ }
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_quit&quot;&gt;&lt;title&gt;s3d_quit&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_quit&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;closes the connection and cleares the event-stack. it can also be used to leave the s3d_mainloop().         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_mainloop&quot;&gt;&lt;title&gt;s3d_mainloop&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_mainloop&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void(*)(void) &lt;parameter&gt;f&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;takes a function as argument. it will loop this function until a quit-event is received. you can pass NULL if you have no function to be looped, but its better to sleep some time if you have nothing to do anyway to save cpu-time.&lt;/para&gt;&lt;programlisting&gt; void mainloop(void)
+ {
+         usleep(1000); // sleep 1 ms in every cycle
+ }
+ ...
+
+ s3d_mainloop(mainloop());
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_vertex&quot;&gt;&lt;title&gt;s3d_push_vertex&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_vertex&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float &lt;parameter&gt;x&lt;/parameter&gt;, float &lt;parameter&gt;y&lt;/parameter&gt;, float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;pushes a vertex onto the vertex stack. make sure that you count how many vertices you've pushed because you'll need that for referencing when you push your polygons.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_vertices&quot;&gt;&lt;title&gt;s3d_push_vertices&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_vertices&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const float *&lt;parameter&gt;vbuf&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;push some vertices from an array. that's much better for performing than using s3d_push_vertex() if you have a lot of vertices (and that's probably the usual case). &lt;/para&gt;&lt;programlisting&gt; float vertices[] = { 0.0, 0.0, 0.0,
+                      1.0, 2.0, 3.0,
+                      3.0, 2.0, 1.0};
+ s3d_push_vertices(object, vertices, 3); // pushing 3 vertices
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_material&quot;&gt;&lt;title&gt;s3d_push_material&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_material&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float &lt;parameter&gt;amb_r&lt;/parameter&gt;, float &lt;parameter&gt;amb_g&lt;/parameter&gt;, float &lt;parameter&gt;amb_b&lt;/parameter&gt;, float &lt;parameter&gt;spec_r&lt;/parameter&gt;, float &lt;parameter&gt;spec_g&lt;/parameter&gt;, float &lt;parameter&gt;spec_b&lt;/parameter&gt;, float &lt;parameter&gt;diff_r&lt;/parameter&gt;, float &lt;parameter&gt;diff_g&lt;/parameter&gt;, float &lt;parameter&gt;diff_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;pushes a material for an object. you will have to count them yourself too, as polygons will ask for the material index number. the material properties are given in rgb (red/green/blue) color codes, in float. 0.0 is the minimum, 1.0 is the maximum a color value can be. the specular color is the color which is directly reflected from the light source. the diffuse color is the color which can be seen in the bright side of the object, and the ambience color is the color of the shadow side of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_material&quot;&gt;&lt;title&gt;s3d_pep_material&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float &lt;parameter&gt;amb_r&lt;/parameter&gt;, float &lt;parameter&gt;amb_g&lt;/parameter&gt;, float &lt;parameter&gt;amb_b&lt;/parameter&gt;, float &lt;parameter&gt;spec_r&lt;/parameter&gt;, float &lt;parameter&gt;spec_g&lt;/parameter&gt;, float &lt;param!
 eter&gt;spec_b&lt;/parameter&gt;, float &lt;parameter&gt;diff_r&lt;/parameter&gt;, float &lt;parameter&gt;diff_g&lt;/parameter&gt;, float &lt;parameter&gt;diff_b&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Overwriting the latest pushed Material, overwriting the current value with the specified one. See s3d_pep_materials_a if you want to pep more materials.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_material_a&quot;&gt;&lt;title&gt;s3d_push_material_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_material_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float &lt;parameter&gt;amb_r&lt;/parameter&gt;, float &lt;parameter&gt;amb_g&lt;/parameter&gt;, float &lt;parameter&gt;amb_b&lt;/parameter&gt;, float &lt;parameter&gt;amb_a&lt;/parameter&gt;, float &lt;parameter&gt;spec_r&lt;/parameter&gt;, float &lt;parameter&gt;spec_g&lt;/parameter&gt;, float &lt;parameter&gt;spec_b&lt;/parameter&gt;, float &lt;parameter&gt;spec_a&lt;/parameter&gt;, float &lt;parameter&gt;diff_r&lt;/parameter&gt;, float &lt;parameter&gt;diff_g&lt;/parameter&gt;, float &lt;parameter&gt;diff_b&lt;/parameter&gt;, float &lt;parameter&gt;diff_a&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Same as s3d_push_material, but color has alpha value added. Use s3d_push_materials_a() if you have a lot of materials to push.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_materials_a&quot;&gt;&lt;title&gt;s3d_push_materials_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_materials_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const float *&lt;parameter&gt;mbuf&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Pushes a buffer of Materials. Those Materials are in the format float[n*12], with
+&lt;/para&gt;&lt;para&gt;mbuf[n*12 + 0-3] - ambience&lt;/para&gt;&lt;para&gt;mbuf[n*12 + 4-7] - specular&lt;/para&gt;&lt;para&gt;mbuf[n *12 + 8-11] - diffusion values
+&lt;/para&gt;&lt;para&gt;of each entry. n is the number of materials pushed. The values are in the order r,g,b,a. If you only want to push one material, use the more easy s3d_push_material_a() function.&lt;/para&gt;&lt;programlisting&gt; // each line has r,g,b,a value
+ float bla[24]=
+         {1, 0, 0, 1,
+          1, 0, 0, 1,
+          1, 0, 0, 1,
+          0, 1, 1, 1,
+          0, 1, 1, 1,
+          0, 1, 1, 1};
+
+ s3d_push_materials_a(object, mbuf, 2); // push a red and a cyan material
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_material_a&quot;&gt;&lt;title&gt;s3d_pep_material_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float &lt;parameter&gt;amb_r&lt;/parameter&gt;, float &lt;parameter&gt;amb_g&lt;/parameter&gt;, float &lt;parameter&gt;amb_b&lt;/parameter&gt;, float &lt;parameter&gt;amb_a&lt;/parameter&gt;, float &lt;parameter&gt;spec_r&lt;/parameter&gt;, float &lt;parameter&gt;spec_g&lt;/parameter&gt;, float &lt;parameter&gt;spec_b&lt;/parameter&gt;, float &lt;parameter&gt;spec_a&lt;/parameter&gt;, float &lt;parameter&gt;diff_r&lt;/parameter&gt;, float &lt;parameter&gt;diff_g&lt;/parameter&gt;, float &lt;parameter&gt;diff_b&lt;/parameter&gt;, float &lt;parameter&gt;diff_a&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Overwriting the latest pushed Material, overwriting the current value with the specified one, with alpha value in contrast to s3d_pep_material See s3d_push_materials_a if you want to pep more materials.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_materials_a&quot;&gt;&lt;title&gt;s3d_pep_materials_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_materials_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const float *&lt;parameter&gt;mbuf&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Alters the last n pushed Materials. See s3d_push_materials_a() for more information how mbuf should look like. Use s3d_pep_material_a() if you only want to alter the latest material.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_materials_a&quot;&gt;&lt;title&gt;s3d_load_materials_a&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_materials_a&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const float *&lt;parameter&gt;mbuf&lt;/parameter&gt;, uint32_t &lt;parameter&gt;start&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Loads n materials starting from index position start into the Material stack. See s3d_push_materials_a for more informatino about the values in mbuf.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_polygon&quot;&gt;&lt;title&gt;s3d_push_polygon&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_polygon&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, uint32_t &lt;parameter&gt;v1&lt;/parameter&gt;, uint32_t &lt;parameter&gt;v2&lt;/parameter&gt;, uint32_t &lt;parameter&gt;v3&lt;/parameter&gt;, uint32_t &lt;parameter&gt;material&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;push one polygon on the polygonstack of the object. it takes 3 vertex-index numbers and one material material-index-nr. as argument.&lt;/para&gt;&lt;programlisting&gt; int oid = s3d_new_object();   // create a new object
+ s3d_push_vertex(oid, 0.0, 0.0, 0.0);
+ s3d_push_vertex(oid, 0.0, 1.0, 0.0);
+ s3d_push_vertex(oid, 1.0, 0.0, 0.0);
+ s3d_push_material(oid, 0.3, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0);
+ s3d_push_polygon(oid, 0, 1, 2, 0);
+ // this will create a red polygon
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_polygons&quot;&gt;&lt;title&gt;s3d_push_polygons&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_polygons&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const uint32_t *&lt;parameter&gt;pbuf&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;as for vertices, you can push arrays of polygons to have greater performance. the pbuf should contain n polygons which consist of 4 uint32_t values of 3 vertices indices and 1 material index.&lt;/para&gt;&lt;programlisting&gt; uint32_t pbuf[] = { 0, 1, 2, 0};
+ int oid = s3d_new_object();   // create a new object
+ s3d_push_vertex(oid, 0.0, 0.0, 0.0);
+ s3d_push_vertex(oid, 0.0, 1.0, 0.0);
+ s3d_push_vertex(oid, 1.0, 0.0, 0.0);
+ s3d_push_material(oid, 0.3, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0);
+ s3d_push_polygons(oid, pbuf, 1);
+ // push one polygon with the pbuf data
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_line&quot;&gt;&lt;title&gt;s3d_push_line&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_line&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, uint32_t &lt;parameter&gt;v1&lt;/parameter&gt;, uint32_t &lt;parameter&gt;v2&lt;/parameter&gt;, uint32_t &lt;parameter&gt;material&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Push one line on the linestack of the object. It takes 2 vertex-index- numbers and one material material-index-nr. as argument. If you have a lot of lines to push, use s3d_push_lines()         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_lines&quot;&gt;&lt;title&gt;s3d_push_lines&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_lines&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const uint32_t *&lt;parameter&gt;lbuf&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Pushing n lines on the linestack of the object, each lbuf has a size of n*3, each entry has the index number of the first vertex, second vertex and material number just as in s3d_push_line().         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_texture&quot;&gt;&lt;title&gt;s3d_push_texture&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_texture&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, uint16_t &lt;parameter&gt;w&lt;/parameter&gt;, uint16_t &lt;parameter&gt;h&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Adds a new texture with height w and height h on the texturestack.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_textures&quot;&gt;&lt;title&gt;s3d_push_textures&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_push_textures&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const uint16_t *&lt;parameter&gt;tbuf&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;As for vertices, you can push arrays of textures on the texture stack to have greater performance. The tbuf should contain n texture sizes which consist of 2 uint16_t values for width and height for each texture.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_vertex&quot;&gt;&lt;title&gt;s3d_pop_vertex&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_vertex&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Deletes the latest n vertices from the vertex stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_polygon&quot;&gt;&lt;title&gt;s3d_pop_polygon&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_polygon&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Deletes the latest n polygon from the polygon stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_material&quot;&gt;&lt;title&gt;s3d_pop_material&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_material&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Deletes the latest n material from the material stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_texture&quot;&gt;&lt;title&gt;s3d_pop_texture&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_texture&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Deletes the latest n textures from the texture stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_line&quot;&gt;&lt;title&gt;s3d_pop_line&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pop_line&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Deletes the latest n lines from the line stack of the object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_line_normals&quot;&gt;&lt;title&gt;s3d_pep_line_normals&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_line_normals&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Adds normal information to lines, giving each vertex of a line a normal information. This makes lines somewhat nicer, you'll need that especially when you're going to build wireframe models.&lt;/para&gt;&lt;para&gt;nbuf should contain n * 6 float values, for each vertex a normal vector (x,y,z), and you have 2 Vertices for each line so that makes 6 float values per line in Total.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_polygon_normals&quot;&gt;&lt;title&gt;s3d_pep_polygon_normals&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_normals&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Adds normal information to polygons, giving each vertex of a polygon a normal information. With this, you can achieve smoothed edge effects.&lt;/para&gt;&lt;para&gt;nbuf should contain n * 9 float values, for each vertex a normal vector (x,y,z), and you have 3 Vertices for each Polygon so that makes 9 float values per Polygon in Total. Don't worry if you don't use this, it's kind of hard to calculate and the server will always use some proper normal values (same for every vertex, calculated by the plane which is defined by the 3 points of the polygon.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_polygon_tex_coord&quot;&gt;&lt;title&gt;s3d_pep_polygon_tex_coord&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_tex_coord&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float &lt;parameter&gt;x1&lt;/parameter&gt;, float &lt;parameter&gt;y1&lt;/parameter&gt;, float &lt;parameter&gt;x2&lt;/parameter&gt;, float &lt;parameter&gt;y2&lt;/parame!
 ter&gt;, float &lt;parameter&gt;x3&lt;/parameter&gt;, float &lt;parameter&gt;y3&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Pimp the last polygon pushed with some textures coordinates, x and y values for each vertex point respectively. Those values may be between 0 and 1 and are vertex points on the texture defined in the material of the polygon. If you have more polygons which should get a texture, use s3d_pep_polygon_tex_coords()         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_polygon_tex_coords&quot;&gt;&lt;title&gt;s3d_pep_polygon_tex_coords&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_tex_coords&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const float *&lt;parameter&gt;tbuf&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Pimp the latest n polygons with texture coordinates. tbuf has 6*n float values for its entries, which are supplied in the order as in s3d_pep_polygon_tex_coord()         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_material_texture&quot;&gt;&lt;title&gt;s3d_pep_material_texture&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material_texture&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, uint32_t &lt;parameter&gt;tex&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Assign the latest material a texture referenced by the index tex. Of course, you will have pushed this texture with s3d_push_texture()         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_vertex&quot;&gt;&lt;title&gt;s3d_pep_vertex&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_vertex&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float &lt;parameter&gt;x&lt;/parameter&gt;, float &lt;parameter&gt;y&lt;/parameter&gt;, float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Alter the latest pushed vertex, overwriting with the supplied values.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_vertices&quot;&gt;&lt;title&gt;s3d_pep_vertices&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_vertices&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const float *&lt;parameter&gt;vbuf&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Alter the latest n pushed vertex. vbuf holds the values which are used to overwrite the old data, n entries with each 3 floats specifying x,y,z of the vertices.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_line&quot;&gt;&lt;title&gt;s3d_pep_line&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_line&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, int &lt;parameter&gt;v1&lt;/parameter&gt;, int &lt;parameter&gt;v2&lt;/parameter&gt;, int &lt;parameter&gt;material&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Alter the latest pushed line, overwriting with the supplied values.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pep_lines&quot;&gt;&lt;title&gt;s3d_pep_lines&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_pep_lines&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const uint32_t *&lt;parameter&gt;lbuf&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Alter the latest n pushed lines. lbuf holds the values which are used to overwrite the old data, n entries with each 3 uint32_t specifying first, second vertex and material of each line.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_line_normals&quot;&gt;&lt;title&gt;s3d_load_line_normals&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_line_normals&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;, uint32_t &lt;parameter&gt;start&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Just as s3d_pep_line_normals(), with the difference you won't alter the latest n lines but n lines starting with index start.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_polygon_normals&quot;&gt;&lt;title&gt;s3d_load_polygon_normals&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_polygon_normals&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;, uint32_t &lt;parameter&gt;start&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Just as s3d_pep_polygon_normals(), with the difference you won't alter the latest n polygons but n polygons starting with index start.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_polygon_tex_coords&quot;&gt;&lt;title&gt;s3d_load_polygon_tex_coords&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_polygon_tex_coords&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const float *&lt;parameter&gt;tbuf&lt;/parameter&gt;, uint32_t &lt;parameter&gt;start&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Just as s3d_pep_polygon_tex_coords(), with the difference you won't alter the latest n polygons but n polygons starting with index start.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_load_texture&quot;&gt;&lt;title&gt;s3d_load_texture&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_load_texture&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, uint32_t &lt;parameter&gt;tex&lt;/parameter&gt;, uint16_t &lt;parameter&gt;xpos&lt;/parameter&gt;, uint16_t &lt;parameter&gt;ypos&lt;/parameter&gt;, uint16_t &lt;parameter&gt;w&lt;/parameter&gt;, uint16_t &lt;parameter&gt;h&lt;/parameter&gt;, const uint8_t *&lt;parameter&gt;data&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Creates a new object, returning the object id.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Of course, you won't forget to toggle it visible, won't you? 
+        &lt;/para&gt;&lt;/warning&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_new_object&quot;&gt;&lt;title&gt;s3d_new_object&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_new_object&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Creates a new object, returning the object id.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Of course, you won't forget to toggle it visible, won't you? 
+        &lt;/para&gt;&lt;/warning&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_del_object&quot;&gt;&lt;title&gt;s3d_del_object&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_del_object&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Deletes the object referenced by oid.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_clone&quot;&gt;&lt;title&gt;s3d_clone&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_clone&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Clones an already exisiting object. They get just look the same as the parent-object and will change when the parent-object changes. Cloning especially makes sense if you want to use the same object a lot of times. Move and transform is independent from the parent. The function returns the childs object id.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_clone_target&quot;&gt;&lt;title&gt;s3d_clone_target&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_clone_target&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;, int &lt;parameter&gt;toid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Changes the clone target of oid to another object (toid). This assumes you've got oid from s3d_clone before.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_link&quot;&gt;&lt;title&gt;s3d_link&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_link&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid_from&lt;/parameter&gt;, int &lt;parameter&gt;oid_to&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;A linked object will move along with it's link parent. For example if you have a book on a table, you can link the book to the table so the book will &quot;keep on the table&quot; if you move the table around in space. It will also rotate with the table etc.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_unlink&quot;&gt;&lt;title&gt;s3d_unlink&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_unlink&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Remove the link of object oid to its target.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_flags_on&quot;&gt;&lt;title&gt;s3d_flags_on&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_flags_on&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, uint32_t &lt;parameter&gt;flags&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;turn some flags on for object.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;If you don't toggle OF_VISIBLE on, you won't see your object. usually you want this. (at least after you *push()d all your content) 
+        &lt;/para&gt;&lt;/warning&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_flags_off&quot;&gt;&lt;title&gt;s3d_flags_off&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_flags_off&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, uint32_t &lt;parameter&gt;flags&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;turn some flags off for object.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_translate&quot;&gt;&lt;title&gt;s3d_translate&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_translate&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float &lt;parameter&gt;x&lt;/parameter&gt;, float &lt;parameter&gt;y&lt;/parameter&gt;, float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Move the object to some position in space. when you create an object, it's always located at 0.0 , 0.0, 0.0.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Translation is absolute, not relative!
+&lt;/para&gt;&lt;/warning&gt;&lt;programlisting&gt; s3d_translate(object, 2, 0, 0);
+ s3d_translate(object, 4, 0, 0);
+ // object will end up at 4,0,0 and not 6,0,0!!
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_rotate&quot;&gt;&lt;title&gt;s3d_rotate&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_rotate&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float &lt;parameter&gt;x&lt;/parameter&gt;, float &lt;parameter&gt;y&lt;/parameter&gt;, float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;rotate an object around the x, y and z-axis respectively. x,y,z may have values between [0,360] degrees.&lt;/para&gt;&lt;para&gt;You will usually only rotate around one axis, leaving the unused fields on 0, I guess. If you want to rotate around more than one axis, please note: The order of the rotation applies is y-axis, x-axis, and then z-axis. You can think of it as the earth position coordinates: x is the longitude, y is the latitude, and z is the rotation at this point of the earth around your bodies axis. (I wonder if that makes it any clearer ;)&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Rotate is absolute, not relative!
+&lt;/para&gt;&lt;/warning&gt;&lt;programlisting&gt; s3d_rotate(object, 90,  0, 0);
+ s3d_rotate(object, 180, 0, 0);
+ // object will be rotated 180 degrees around the x-axis, not 270 degress!
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_scale&quot;&gt;&lt;title&gt;s3d_scale&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_scale&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float &lt;parameter&gt;s&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Scales the object. about factor s. s=1 will be the original size, -1 will mirror it.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;s=0 is forbidden and will be ignored! s3d_scale is also absolute, not relative! 
+        &lt;/para&gt;&lt;/warning&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_import_model_file&quot;&gt;&lt;title&gt;s3d_import_model_file&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_import_model_file&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const char *&lt;parameter&gt;fname&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Imports an 3d object file and returns the object number. Quite a number of formats are supported, like 3D Studio (.3ds, .prj), Lightwave (.lw, .lwb, .lwo), Quake Models (.md3), or simply everything libg3d supports. :)&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Of course, you won't forget to toggle it visible, won't you? 
+        &lt;/para&gt;&lt;/warning&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_open_file&quot;&gt;&lt;title&gt;s3d_open_file&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_open_file&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const char *&lt;parameter&gt;fname&lt;/parameter&gt;, char **&lt;parameter&gt;pointer&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;This opens the file fname, setting *pointer to it's memory position. the function will return the size of buffer. you can free() the pointer when you're finished.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_select_font&quot;&gt;&lt;title&gt;s3d_select_font&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_select_font&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const char *&lt;parameter&gt;mask&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;This selects a font for the s3d_draw_string() function.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Of course, you won't forget to toggle it visible, won't you?
+&lt;/para&gt;&lt;/warning&gt;&lt;programlisting&gt; s3d_select_font(&quot;vera&quot;); // will use the vera font face
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_draw_string&quot;&gt;&lt;title&gt;s3d_draw_string&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_draw_string&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const char *&lt;parameter&gt;str&lt;/parameter&gt;, float *&lt;parameter&gt;xlen&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Renders the string str with in Truetype format with the height 1, returns the length of the rendered string in *xlen (or set len=NULL to disable this).&lt;/para&gt;&lt;programlisting&gt; char str=&quot;hello world!&quot;;
+ float len;
+ s3d_select_font(&quot;vera&quot;);
+ s3d_draw_string(str, len);
+
+ // not interested in the length? do that: s3d_draw_string(str, NULL);
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_strlen&quot;&gt;&lt;title&gt;s3d_strlen&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_strlen&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const char *&lt;parameter&gt;str&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Returns the length of the string if it were rendered with the currently selected font. That might be useful to estimate the size used for a text and render the background or bounding box before inserting the text.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_length&quot;&gt;&lt;title&gt;s3d_vector_length&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_vector_length&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Calculates and returns the length of the given vector (which should be of the type float[3]). More info on wikipedia <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_dot_product&quot;&gt;&lt;title&gt;s3d_vector_dot_product&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_vector_dot_product&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[], const float &lt;parameter&gt;vector2&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Calculates and returns the dot product of vector1 and vector2. All vectors should have the format float[3]. More info on wikipedia. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_subtract&quot;&gt;&lt;title&gt;s3d_vector_subtract&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_vector_subtract&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[], const float &lt;parameter&gt;vector2&lt;/parameter&gt;[], float &lt;parameter&gt;result_vector&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Subtracts vector1 from vector2, writing result into result_vector. All vectors should have the format float[3]. More info on wikipedia. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_angle&quot;&gt;&lt;title&gt;s3d_vector_angle&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_vector_angle&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[], const float &lt;parameter&gt;vector2&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Calculates and returns the angle between vector1 and vector2. Please note that the resulting angle is between 0 and PI, therefore not covering the whole period! To convert in degrees just do result*180/M_PI. All vectors should have the format float[3]. More info on wikipedia. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_angle_to_cam&quot;&gt;&lt;title&gt;s3d_angle_to_cam&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;float &lt;function&gt;s3d_angle_to_cam&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;obj_pos&lt;/parameter&gt;[], const float &lt;parameter&gt;cam_pos&lt;/parameter&gt;[], float *&lt;parameter&gt;angle_rad&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Given obj_pos and cam_pos in the format float[3], angle_rad about which angle the object should be rotated around the y-axis so that it faces the camera. This might become handy if you have some text floating in space and want it to face the camera. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_vector_cross_product&quot;&gt;&lt;title&gt;s3d_vector_cross_product&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_vector_cross_product&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[], const float &lt;parameter&gt;vector2&lt;/parameter&gt;[], float &lt;parameter&gt;result_vector&lt;/parameter&gt;[]&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Calculates and returns the cross product of vector1 and vector2. All vectors should have the format float[3]. More info on wikipedia. <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_push_event&quot;&gt;&lt;title&gt;s3d_push_event&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_push_event&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;struct s3d_evt *&lt;parameter&gt;newevt&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Pushes an event onto the event-stack. Usually you don't need to do this manually.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_pop_event&quot;&gt;&lt;title&gt;s3d_pop_event&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;struct s3d_evt * &lt;function&gt;s3d_pop_event&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Pops the latest event from the stack. Don't forget to free() both the event and its buffer! Returns a pointer to struct s3d_evt.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_find_event&quot;&gt;&lt;title&gt;s3d_find_event&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;struct s3d_evt * &lt;function&gt;s3d_find_event&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Finds the latest occurence of an event, giving the event type as argument. Returns a pointer to struct s3d_evt.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_delete_event&quot;&gt;&lt;title&gt;s3d_delete_event&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_delete_event&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const struct s3d_evt *&lt;parameter&gt;devt&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;deletes an event, the argument is the pointer to the event which is to be deleted (maybe obtained from s3d_find_event).         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_set_callback&quot;&gt;&lt;title&gt;s3d_set_callback&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_set_callback&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;, s3d_cb &lt;parameter&gt;func&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;sets a callback for a certain event. this is very useful for event-oriented applications. event callbacks will not interrupt each other or the mainloop.&lt;/para&gt;&lt;warning&gt;&lt;para&gt;Defining callbacks will only work after calling s3d_init()
+&lt;/para&gt;&lt;/warning&gt;&lt;programlisting&gt; #include &lt;inttypes.h&gt;
+
+ void obj_click(struct s3d_evt event)
+ {
+         printf(&quot;object id %&quot;PRIu32&quot; got clicked&quot;, *((uint32_t *)event-&gt;buf));
+ }
+ ...
+ s3d_set_callback(S3D_EVENT_NEW_OBJECT, obj_click);
+ // this will tell you when a object got clicked
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_clear_callback&quot;&gt;&lt;title&gt;s3d_clear_callback&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_clear_callback&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Clears the callback which is associated with the event.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_ignore_callback&quot;&gt;&lt;title&gt;s3d_ignore_callback&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_ignore_callback&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Sets the callback on ignore, that means it won't be queued up for later use. An incoming event of this type will simply be skipped.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_get_callback&quot;&gt;&lt;title&gt;s3d_get_callback&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;s3d_cb &lt;function&gt;s3d_get_callback&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Returns the Callback-function of the event.&lt;/para&gt;&lt;programlisting&gt; struct s3d_evt e;
+ ...
+ s3d_get_callback(S3D_EVENT_KEY)(e);
+ // will call the key-handling function with argument e.
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_process_stack&quot;&gt;&lt;title&gt;s3d_process_stack&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3d_process_stack&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;This function goes through all function of the event-stack and will call functions. this is useful when you define a new function but still have a lot of events of this type on the stack.&lt;/para&gt;&lt;para&gt;Deprecated&lt;/para&gt;&lt;para&gt;This is probably obsolete         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_mcp_focus&quot;&gt;&lt;title&gt;s3d_mcp_focus&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_mcp_focus&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;This is an mcp-only function. It gives focus (for receiving key-strokes etc.) to an app referenced by it's mcp-object-id.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3d_net_check&quot;&gt;&lt;title&gt;s3d_net_check&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3d.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3d_net_check&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;This functions is for programs which do not employ a mainloop, hence they need to check for new events on their own. Programs like these must make sure to call this function from time to time to convince the server that they did not freeze or bail out.         &lt;/para&gt;&lt;/sect2&gt;
\ No newline at end of file

Modified: trunk/Documentation/libs3d/libs3d.docbook
===================================================================
--- trunk/Documentation/libs3d/libs3d.docbook	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/Documentation/libs3d/libs3d.docbook	2008-08-31 22:19:18 UTC (rev 980)
@@ -41,1499 +41,15 @@
 &lt;sect1 id=&quot;functions&quot;&gt;
 &lt;title&gt;function reference&lt;/title&gt;
 
-&lt;sect2 id=&quot;s3d_init&quot;&gt;
-&lt;title&gt;s3d_init&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_init&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int *&lt;parameter&gt;argc&lt;/parameter&gt;,
-char ***&lt;parameter&gt;argv&lt;/parameter&gt;,
-const char *&lt;parameter&gt;name&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-This will initialize the &lt;application&gt;s3d&lt;/application&gt;-library and the connection to the Server. It will return 0 on
-success in Server initializion. name specifies the your programs name.
-&lt;/para&gt;
-&lt;programlisting&gt;
-int main(char argc, char **argv)
-{
-	if (!&lt;emphasis&gt;s3d_init(&lt;![CDATA[&amp;argc, &amp;argv]]&gt;, &quot;Hello world&quot;)&lt;/emphasis&gt;) 
-	{
-		...
-		&lt;link linkend=&quot;s3d_quit&quot;&gt;s3d_quit()&lt;/link&gt;;
-	}
-	return(0);
-}
-			   
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3d_quit&quot;&gt;
-&lt;title&gt;s3d_quit&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_quit&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;void&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-closes the connection and cleares the event-stack. it can also be used to leave
-the &lt;link linkend=&quot;s3d_mainloop&quot;&gt;s3d_mainloop&lt;/link&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_usage&quot;&gt;
-&lt;title&gt;s3d_usage&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3d_usage&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;void&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Prints the possible parameter for the client library (which can be passed in 
-&lt;link linkend=&quot;s3d_init&quot;&gt;s3d_init()&lt;/link&gt;)
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_mainloop&quot;&gt;
-&lt;title&gt;s3d_mainloop&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_mainloop&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;void (*&lt;parameter&gt;f&lt;/parameter&gt;)(void)&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-takes a function as argument. it will loop this function until a quit-event is
-received. you can pass NULL if you have no function to be looped, but its
-better to sleep some time if you have nothing to do anyway to save cpu-time.
-&lt;/para&gt;
-&lt;programlisting&gt;
-void mainloop()
-{
-    usleep(1000); // sleep 1 ms in every cycle
-}
-...
-
-&lt;emphasis&gt;s3d_mainloop&lt;/emphasis&gt;(mainloop());
-
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3d_push_vertex&quot;&gt;
-&lt;title&gt;s3d_push_vertex&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_push_vertex&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float &lt;parameter&gt;x&lt;/parameter&gt;, float &lt;parameter&gt;y&lt;/parameter&gt;, float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-pushes a vertex onto the vertex stack. make sure that you count how many
-vertices you've pushed because you'll need that for referencing when you push
-your polygons.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_push_vertices&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_push_vertices&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, const float *&lt;parameter&gt;vbuf&lt;/parameter&gt;, uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-push some vertices from an array. that's much better for performing than
-using &lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex()&lt;/link&gt; if you have a lot of vertices (and that's probably the
-usual case).
-&lt;/para&gt;
-&lt;programlisting&gt;
-float vertices[] = { 0.0, 0.0, 0.0,
-                     1.0, 2.0, 3.0,
-                     3.0, 2.0, 1.0};
-&lt;emphasis&gt;s3d_push_vertices&lt;/emphasis&gt;(object, vertices, 3); /* pushing 3 vertices */
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3d_push_material&quot;&gt;
-&lt;title&gt;s3d_push_material&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_push_material&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-float &lt;parameter&gt;amb_r&lt;/parameter&gt;,
-float &lt;parameter&gt;amb_g&lt;/parameter&gt;,
-float &lt;parameter&gt;amb_b&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_r&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_g&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_b&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_r&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_g&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_b&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-pushes a material for an object. you will have to count them yourself too, as
-polygons will ask for the material index number. the material properties are
-given in rgb (red/green/blue) color codes, in float. 0.0 is the minimum,
-1.0 is the maximum a color value can be.
-the specular color is the color which is directly reflected from the light
-source. the diffuse color is the color which can be seen in the bright side
-of the object, and the ambience color is the color of the shadow side of the
-object.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_push_material_a&quot;&gt;
-&lt;title&gt;s3d_push_material_a&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_push_material_a&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-float &lt;parameter&gt;amb_r&lt;/parameter&gt;,
-float &lt;parameter&gt;amb_g&lt;/parameter&gt;,
-float &lt;parameter&gt;amb_b&lt;/parameter&gt;,
-float &lt;parameter&gt;amb_a&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_r&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_g&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_b&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_a&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_r&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_g&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_b&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_a&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Same as &lt;link linkend=&quot;s3d_push_material&quot;&gt;s3d_push_material&lt;/link&gt;, but color has &lt;link linkend=&quot;alpha&quot;&gt;alpha value&lt;/link&gt; added.
-Use &lt;link linkend=&quot;s3d_push_materials_a&quot;&gt;s3d_push_materials_a()&lt;/link&gt; if you have a lot of materials to push.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3d_push_materials_a&quot;&gt;
-&lt;title&gt;s3d_push_materials_a&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_push_materials_a&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const float *&lt;parameter&gt;mbuf&lt;/parameter&gt;, 
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Pushes a buffer of Materials. Those Materials are in the format float[n*12], with
-&lt;itemizedlist&gt;
-&lt;listitem&gt;&lt;para&gt;mbuf[n*12 + 0-3] - ambience&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;mbuf[n*12 + 4-7] - specular&lt;/para&gt;&lt;/listitem&gt;
-&lt;listitem&gt;&lt;para&gt;mbuf[n *12 + 8-11] - diffusion values &lt;/para&gt;&lt;/listitem&gt;
-&lt;/itemizedlist&gt;
-of each entry. n is the number of materials pushed. The values are in the order r,g,b,a.
-If you only want to push one material, use the more easy &lt;link linkend=&quot;s3d_push_material_a&quot;&gt;s3d_push_material_a()&lt;/link&gt;
-function.
-&lt;/para&gt;
-&lt;programlisting&gt;
-/* each line has r,g,b,a value */
-float bla[24]=
-	{1, 0, 0, 1,
-	 1, 0, 0, 1,
-	 1, 0, 0, 1,
-	 0, 1, 1, 1,
-	 0, 1, 1, 1,
-	 0, 1, 1, 1};
-
-s3d_push_materials_a(object, mbuf, 2); /* push a red and a cyan material */
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_push_polygon&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_push_polygon&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-uint32_t &lt;parameter&gt;v1&lt;/parameter&gt;,
-uint32_t &lt;parameter&gt;v2&lt;/parameter&gt;,
-uint32_t &lt;parameter&gt;v3&lt;/parameter&gt;,
-uint32_t &lt;parameter&gt;material&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-push one polygon on the polygonstack of the object. it takes 3 vertex-index-
-numbers and one material material-index-nr. as argument.
-&lt;/para&gt;
-&lt;programlisting&gt;
-int oid=&lt;link linkend=&quot;s3d_new_object&quot;&gt;s3d_new_object&lt;/link&gt;();   /* create a new object */
-&lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex&lt;/link&gt;(oid, 0.0, 0.0, 0.0);
-&lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex&lt;/link&gt;(oid, 0.0, 1.0, 0.0);
-&lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex&lt;/link&gt;(oid, 1.0, 0.0, 0.0);
-&lt;link linkend=&quot;s3d_push_material&quot;&gt;s3d_push_material&lt;/link&gt;(oid, 0.3, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0);
-&lt;emphasis&gt;s3d_push_polygon&lt;/emphasis&gt;(oid, 0, 1, 2, 0);
-/* this will create a red polygon */
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_push_polygons&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_push_polygons&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const uint32_t *&lt;parameter&gt;pbuf&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-as for vertices, you can push arrays of polygons to have greater performance.
-the pbuf should contain n polygons which consist of 4 uint32_t values
-of 3 vertices indices and 1 material index.
-&lt;/para&gt;
-&lt;programlisting&gt;
-uint32_t pbuf[] = { 0, 1, 2, 0};
-int oid=&lt;link linkend=&quot;s3d_new_object&quot;&gt;s3d_new_object&lt;/link&gt;();   /* create a new object */
-&lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex&lt;/link&gt;(oid, 0.0, 0.0, 0.0);
-&lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex&lt;/link&gt;(oid, 0.0, 1.0, 0.0);
-&lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex&lt;/link&gt;(oid, 1.0, 0.0, 0.0);
-&lt;link linkend=&quot;s3d_push_material&quot;&gt;s3d_push_material&lt;/link&gt;(oid, 0.3, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0);
-&lt;emphasis&gt;s3d_push_polygons&lt;/emphasis&gt;(oid, pbuf, 1);
-/* push one polygon with the pbuf data */
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3d_push_line&quot;&gt;
-&lt;title&gt;s3d_push_line&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_push_line&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-uint32_t &lt;parameter&gt;v1&lt;/parameter&gt;,
-uint32_t &lt;parameter&gt;v2&lt;/parameter&gt;,
-uint32_t &lt;parameter&gt;material&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Push one line on the linestack of the object. It takes 2 vertex-index-
-numbers and one material material-index-nr. as argument. If you have
-a lot of lines to push, use &lt;link linkend=&quot;s3d_push_lines&quot;&gt;s3d_push_lines()&lt;/link&gt;
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_push_lines&quot;&gt;
-&lt;title&gt;s3d_push_lines&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_push_lines&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const uint32_t *&lt;parameter&gt;lbuf&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Pushing n lines on the linestack of the object, each lbuf has a size of n*3,
-each entry has the index number of the first vertex, second vertex and material number just
-as in &lt;link linkend=&quot;s3d_push_line&quot;&gt;s3d_push_line()&lt;/link&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_push_texture&quot;&gt;
-&lt;title&gt;s3d_push_texture&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_push_texture&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;w&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;h&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Adds a new texture with height w and height h on the texturestack.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_push_textures&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_push_textures&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const uint16_t *&lt;parameter&gt;tbuf&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-As for vertices, you can push arrays of textures on the texture stack 
-to have greater performance.
-The tbuf should contain n texture sizes which consist of 2 uint16_t values
-for width and height for each texture. 
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_pop_vertex&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pop_vertex&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Deletes the latest n vertices from the vertex stack of the object.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_pop_polygon&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pop_polygon&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Deletes the latest n polygon from the polygon stack of the object.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_pop_material&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pop_material&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Deletes the latest n material from the material stack of the object.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_pop_texture&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pop_texture&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Deletes the latest n textures from the texture stack of the object.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_pop_line&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pop_line&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-uint32_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Deletes the latest n lines from the line stack of the object.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_pep_polygon_normals&quot;&gt;
-&lt;title&gt;s3d_pep_polygon_normals&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_normals&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Adds normal information to polygons, giving each vertex of a polygon a normal information. With this, you can
-achieve smoothed edge effects. 
-&lt;/para&gt;
-&lt;para&gt;
-nbuf should contain n * 9 float values, for each vertex a normal vector (x,y,z), and you have 
-3 Vertices for each Polygon so that makes 9 float values per Polygon in Total.	
-Don't worry if you don't use this, it's kind of hard to calculate and the server will always use some
-proper normal values (same for every vertex, calculated by the plane which is defined by the 3 points of the polygon.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_pep_polygon_tex_coord&quot;&gt;
-&lt;title&gt;s3d_pep_polygon_tex_coord&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_tex_coord&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-float &lt;parameter&gt;x1&lt;/parameter&gt;, 
-float &lt;parameter&gt;y1&lt;/parameter&gt;, 
-float &lt;parameter&gt;x2&lt;/parameter&gt;, 
-float &lt;parameter&gt;y2&lt;/parameter&gt;, 
-float &lt;parameter&gt;x3&lt;/parameter&gt;, 
-float &lt;parameter&gt;y3&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Pimp the last polygon pushed with some textures coordinates, x and y values for each vertex point respectively.
-Those values may be between 0 and 1 and are vertex points on the &lt;link linkend=&quot;s3d_pep_material_texture&quot;&gt;
-texture defined in the material&lt;/link&gt; of the polygon. If you have more polygons which should get a texture, use
-&lt;link linkend=&quot;s3d_pep_polygon_tex_coords&quot;&gt;s3d_pep_polygon_tex_coords()&lt;/link&gt;
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_pep_polygon_tex_coords&quot;&gt;
-&lt;title&gt;s3d_pep_polygon_tex_coords&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_tex_coords&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const float *&lt;parameter&gt;tbuf&lt;/parameter&gt;, 
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Pimp the latest n polygons with texture coordinates. tbuf has 6*n float values for its entries, which are supplied in the order
-as in &lt;link linkend=&quot;s3d_pep_polygon_tex_coord&quot;&gt;s3d_pep_polygon_tex_coord()&lt;/link&gt;
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_pep_material_texture&quot;&gt;
-&lt;title&gt;s3d_pep_material_texture&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material_texture&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-uint32_t &lt;parameter&gt;tex&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Assign the latest material a texture referenced by the index tex. Of course, you will
-have pushed this texture with &lt;link linkend=&quot;s3d_push_texture&quot;&gt;s3d_push_texture&lt;/link&gt;
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3d_pep_vertex&quot;&gt;
-&lt;title&gt;s3d_pep_vertex&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pep_vertex&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-float &lt;parameter&gt;x&lt;/parameter&gt;,
-float &lt;parameter&gt;y&lt;/parameter&gt;,
-float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Alter the latest pushed vertex, overwriting with the supplied values.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_pep_vertices&quot;&gt;
-&lt;title&gt;s3d_pep_vertices&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pep_vertices&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const float *&lt;parameter&gt;vbuf&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Alter the latest n pushed vertex. vbuf holds the values which
-are used to overwrite the old data, n entries with each 3 floats
-specifying x,y,z of the vertices.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_pep_line&quot;&gt;
-&lt;title&gt;s3d_pep_line&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pep_line&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-int &lt;parameter&gt;v1&lt;/parameter&gt;,
-int &lt;parameter&gt;v2&lt;/parameter&gt;,
-int &lt;parameter&gt;material&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Alter the latest pushed line, overwriting with the supplied values.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_pep_lines&quot;&gt;
-&lt;title&gt;s3d_pep_lines&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pep_lines&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const uint32_t *&lt;parameter&gt;lbuf&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Alter the latest n pushed lines. lbuf holds the values which
-are used to overwrite the old data, n entries with each 3 uint32_t
-specifying first, second vertex and material of each line.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_pep_line_normals&quot;&gt;
-&lt;title&gt;s3d_pep_line_normals&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pep_line_normals&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Adds normal information to lines, giving each vertex of a line a normal information. This makes 
-lines somewhat nicer, you'll need that especially when you're going to build wireframe models.
-&lt;/para&gt;
-&lt;para&gt;
-nbuf should contain n * 6 float values, for each vertex a normal vector (x,y,z), and you have 
-2 Vertices for each line so that makes 6 float values per line in Total.	
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_load_line_normals&quot;&gt;
-&lt;title&gt;s3d_load_line_normals&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_load_line_normals&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;,
-uint32_t &lt;parameter&gt;start&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Just as &lt;link linkend=&quot;s3d_pep_line_normals&quot;&gt;s3d_pep_line_normals()&lt;/link&gt;, with the difference you won't alter 
-the latest n lines but n lines starting with index start.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3d_pep_material&quot;&gt;
-&lt;title&gt;s3d_pep_material&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-float &lt;parameter&gt;amb_r&lt;/parameter&gt;,
-float &lt;parameter&gt;amb_g&lt;/parameter&gt;,
-float &lt;parameter&gt;amb_b&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_r&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_g&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_b&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_r&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_g&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_b&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Overwriting the latest pushed Material, overwriting the current value with the specified one.
-See &lt;link linkend=&quot;s3d_pep_materials_a&quot;&gt;s3d_pep_materials_a&lt;/link&gt; if you want to pep more materials.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-
-&lt;sect2 id=&quot;s3d_pep_material_a&quot;&gt;
-&lt;title&gt;s3d_pep_material_a&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material_a&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-float &lt;parameter&gt;amb_r&lt;/parameter&gt;,
-float &lt;parameter&gt;amb_g&lt;/parameter&gt;,
-float &lt;parameter&gt;amb_b&lt;/parameter&gt;,
-float &lt;parameter&gt;amb_a&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_r&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_g&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_b&lt;/parameter&gt;,
-float &lt;parameter&gt;spec_a&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_r&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_g&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_b&lt;/parameter&gt;,
-float &lt;parameter&gt;diff_a&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Overwriting the latest pushed Material, overwriting the current value with the specified one, with 
-&lt;link linkend=&quot;alpha&quot;&gt;alpha value&lt;/link&gt; in contrast to &lt;link linkend=&quot;s3d_pep_material&quot;&gt;s3d_pep_material&lt;/link&gt;
-See &lt;link linkend=&quot;s3d_pep_materials_a&quot;&gt;s3d_push_materials_a&lt;/link&gt; if you want to pep more materials.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_pep_materials_a&quot;&gt;
-&lt;title&gt;s3d_pep_materials_a&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_pep_materials_a&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const float *&lt;parameter&gt;mbuf&lt;/parameter&gt;, 
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Alters the last n pushed Materials. See &lt;link linkend=&quot;s3d_push_materials_a&quot;&gt;s3d_push_materials_a()&lt;/link&gt; for
-more information how mbuf should look like. Use &lt;link linkend=&quot;s3d_pep_material_a&quot;&gt;s3d_pep_material_a()&lt;/link&gt;
-if you only want to alter the latest material.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_load_materials_a&quot;&gt;
-&lt;title&gt;s3d_load_materials_a&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_load_materials_a&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const float *&lt;parameter&gt;mbuf&lt;/parameter&gt;,
-uint32_t &lt;parameter&gt;start&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Loads n materials starting from index position start into the Material stack.
-See &lt;link linkend=&quot;s3d_push_materials_a&quot;&gt;s3d_push_materials_a&lt;/link&gt; for more informatino about the values in mbuf.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-
-&lt;sect2 id=&quot;s3d_load_polygon_normals&quot;&gt;
-&lt;title&gt;s3d_load_polygon_normals&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_load_polygon_normals&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const float *&lt;parameter&gt;nbuf&lt;/parameter&gt;,
-uint32_t &lt;parameter&gt;start&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Just as &lt;link linkend=&quot;s3d_pep_polygon_normals&quot;&gt;s3d_pep_polygon_normals()&lt;/link&gt;, with the difference you won't alter 
-the latest n polygons but n polygons starting with index start.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3d_load_polygon_tex_coords&quot;&gt;
-&lt;title&gt;s3d_load_polygon_tex_coords&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_load_polygon_tex_coords&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-const float *&lt;parameter&gt;tbuf&lt;/parameter&gt;, 
-uint32_t &lt;parameter&gt;start&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Just as &lt;link linkend=&quot;s3d_pep_polygon_tex_coords&quot;&gt;s3d_pep_polygon_tex_coords()&lt;/link&gt;, with the difference you won't alter 
-the latest n polygons but n polygons starting with index start.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_load_texture&quot;&gt;
-&lt;title&gt;s3d_load_texture&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_load_texture&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
-uint32_t &lt;parameter&gt;tex&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;xpos&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;ypos&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;w&lt;/parameter&gt;,
-uint16_t &lt;parameter&gt;h&lt;/parameter&gt;,
-const uint8_t *&lt;parameter&gt;data&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-This will load an 32bit rgba image supplied in data at position xpos,ypos of the texture tex. The image has
-the width w and height h. This can be used to update only parts of the texture. It's no problem to supply big textures,
-as the image will be sent to server in fragments. Of course, you will have created the texture with 
-&lt;link linkend=&quot;s3d_push_texture&quot;&gt;s3d_push_texture&lt;/link&gt;, have an material assigned to the texture with &lt;link linkend=&quot;s3d_pep_material_texture&quot;&gt;
-s3d_pep_material_texture()&lt;/link&gt; and have your polygons set sane polygon texture coords 
-using &lt;link linkend=&quot;s3d_pep_polygon_tex_coord&quot;&gt;s3d_pep_polygon_tex_coord()&lt;/link&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3d_new_object&quot;&gt;
-&lt;title&gt;s3d_new_object&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_new_object&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;void&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Creates a new object, returning the object id.
-&lt;warning&gt;&lt;para&gt;Of course, you won't forget to &lt;link linkend=&quot;s3d_flags_on&quot;&gt;toggle&lt;/link&gt; it &lt;link linkend=&quot;S3D_OF_VISIBLE&quot;&gt;visible&lt;/link&gt;, won't you?&lt;/para&gt;&lt;/warning&gt;
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_del_object&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_del_object&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Deletes the object referenced by oid.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3d_clone&quot;&gt;
-&lt;title&gt;s3d_clone&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_clone&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Clones an already exisiting object. They get just look the same as the
-parent-object and will change when the parent-object changes.
-Cloning especially makes sense if you want to use the same object a lot of
-times. Move and transform is independent from the parent.
-The function returns the childs object id.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_clone_target&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_clone_target&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;,
-int &lt;parameter&gt;toid&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Changes the clone target of oid to another object (toid). This assumes you've got
-oid from &lt;link linkend=&quot;s3d_clone&quot;&gt;s3d_clone&lt;/link&gt; before.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_link&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_link&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;oid_from&lt;/parameter&gt;,
-int &lt;parameter&gt;oid_to&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-A linked object will move along with it's link parent. For example if you have
-a book on a table, you can link the book to the table so the book will 
-&quot;keep on the table&quot; if you move the table around in space.
-It will also rotate with the table etc.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_unlink&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_unlink&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;oid&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Remove the link of object oid to its target.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_import_model_file&quot;&gt;
-&lt;title&gt;s3d_import_model_file&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_import_model_file&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const char *&lt;parameter&gt;fname&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Imports an 3d object file and returns the object number. Quite a number of formats are supported, like 3D Studio (.3ds, .prj), Lightwave (.lw, .lwb, .lwo), Quake Models (.md3),
-		or simply everything &lt;ulink url=&quot;<A HREF="http://automagically.de/?g3dviewer">http://automagically.de/?g3dviewer</A>&quot;&gt;libg3d&lt;/ulink&gt; supports. :)
-&lt;/para&gt;
-&lt;warning&gt;&lt;para&gt;Of course, you won't forget to &lt;link linkend=&quot;s3d_flags_on&quot;&gt;toggle&lt;/link&gt; it &lt;link linkend=&quot;S3D_OF_VISIBLE&quot;&gt;visible&lt;/link&gt;, won't you?&lt;/para&gt;&lt;/warning&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3d_select_font&quot;&gt;
-&lt;title&gt;s3d_select_font&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_select_font&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const char *&lt;parameter&gt;mask&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-This selects a font for the &lt;link linkend=&quot;s3d_draw_string&quot;&gt;s3d_draw_string()&lt;/link&gt; function.
-&lt;/para&gt;
-&lt;warning&gt;&lt;para&gt;Of course, you won't forget to &lt;link linkend=&quot;s3d_flags_on&quot;&gt;toggle&lt;/link&gt; it &lt;link linkend=&quot;S3D_OF_VISIBLE&quot;&gt;visible&lt;/link&gt;, won't you?&lt;/para&gt;&lt;/warning&gt;
-&lt;programlisting&gt;
-    s3d_select_font(&quot;vera&quot;); /* will use the vera font face */
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3d_draw_string&quot;&gt;
-&lt;title&gt;s3d_draw_string&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_draw_string&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const char *&lt;parameter&gt;str&lt;/parameter&gt;,
-float *&lt;parameter&gt;xlen&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Renders the string str with in Truetype format with the height 1, returns
-the length of the rendered string in *xlen (or set len=NULL to disable this).
-
-&lt;/para&gt;
-&lt;programlisting&gt;
-	char str=&quot;hello world!&quot;;
-	float len;
-	&lt;link linkend=&quot;s3d_select_font&quot;&gt;s3d_select_font&lt;/link&gt;(&quot;vera&quot;);
-	&lt;emphasis&gt;s3d_draw_string&lt;/emphasis&gt;(str, len);
-
-	/* not interested in the length? do that:
-	 * &lt;emphasis&gt;s3d_draw_string&lt;/emphasis&gt;(str, NULL); */
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_strlen&quot;&gt;
-&lt;title&gt;s3d_strlen&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;float &lt;function&gt;s3d_strlen&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const char *&lt;parameter&gt;str&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Returns the length of the string if it were rendered with the currently &lt;link linkend=&quot;s3d_select_font&quot;&gt;selected font&lt;/link&gt;.
-		That might be useful to estimate the size used for a text and render the background or bounding box before inserting the text.
-
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_open_file&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_open_file&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const char *&lt;parameter&gt;fname&lt;/parameter&gt;,
-char **&lt;parameter&gt;pointer&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-This opens the file fname, setting *pointer to it's memory position. the
-function will return the size of buffer. you can free() the pointer when
-you're finished.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-
-&lt;sect2 id=&quot;s3d_flags_on&quot;&gt;
-&lt;title&gt;s3d_flags_on&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_flags_on&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;,
-uint32_t &lt;parameter&gt;flags&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-turn some flags on for object.
-&lt;/para&gt;
-&lt;warning&gt;&lt;para&gt;if you don't toggle OF_VISIBLE on, you won't see your object. usually you want this. 
-(at least after you *push()d all your content)&lt;/para&gt;&lt;/warning&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_flags_off&quot;&gt;
-&lt;title&gt;s3d_flags_off&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_flags_off&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;,
-uint32_t &lt;parameter&gt;flags&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-turn some flags off for object.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_translate&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_translate&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;,
-float &lt;parameter&gt;x&lt;/parameter&gt;,
-float &lt;parameter&gt;y&lt;/parameter&gt;,
-float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Move the object to some position in space. when you create an object, it's 
-always located at 0.0 , 0.0, 0.0.
-&lt;/para&gt;
-&lt;important&gt;&lt;para&gt;Translation is absolute, not relative!&lt;/para&gt;&lt;/important&gt;
-&lt;programlisting&gt;
-&lt;emphasis&gt;s3d_translate&lt;/emphasis&gt;(object, 2, 0, 0);
-&lt;emphasis&gt;s3d_translate&lt;/emphasis&gt;(object, 4, 0, 0);
-/* object will end up at 4,0,0 and not 6,0,0!! */
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_rotate&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_rotate&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;,
-float &lt;parameter&gt;x&lt;/parameter&gt;,
-float &lt;parameter&gt;y&lt;/parameter&gt;,
-float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-rotate an object around the x, y and z-axis respectively. x,y,z may have values
-between [0,360] degrees. 
-&lt;/para&gt;
-&lt;para&gt;
-You will usually only rotate around one axis, leaving the unused fields on 0, I guess. 
-If you want to rotate around more than one axis, please note: The order of the rotation
-applies is y-axis, x-axis, and then z-axis. You can think of it as the earth position coordinates:
-x is the longitude, y is the latitude, and z is the rotation at this point of the earth around your
-bodies axis. (I wonder if that makes it any clearer ;)
-&lt;/para&gt;
-&lt;important&gt;&lt;para&gt;Rotate is absolute, not relative!&lt;/para&gt;&lt;/important&gt;
-&lt;programlisting&gt;
-&lt;emphasis&gt;s3d_rotate&lt;/emphasis&gt;(object, 90,  0, 0);
-&lt;emphasis&gt;s3d_rotate&lt;/emphasis&gt;(object, 180, 0, 0);
-/* object will be rotated 180 degrees around the x-axis, not 270 degress! */
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_scale&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_scale&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;,
-float &lt;parameter&gt;s&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Scales the object. about factor s. s=1 will be the original size, -1 will mirror it.
-&lt;/para&gt;
-&lt;important&gt;&lt;para&gt;s=0 is forbidden and will be ignored! s3d_scale is also absolute, not relative!&lt;/para&gt;&lt;/important&gt;
-&lt;/sect2&gt;
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_push_event&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3d_push_event&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;struct s3d_evt *&lt;parameter&gt;newevt&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Pushes an &lt;link linkend=&quot;s3d_evt&quot;&gt;event&lt;/link&gt; onto the event-stack. Usually you don't need to do this manually.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_pop_event&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;struct s3d_evt *&lt;function&gt;s3d_pop_event&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;void&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Pops the latest event from the stack. Don't forget to free() both the event
-and its buffer! Returns a pointer to &lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt&lt;/link&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_find_event&quot;&gt;
-&lt;title&gt;s3d_find_event&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;struct s3d_evt *&lt;function&gt;s3d_find_event&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Finds the latest occurence of an event, giving the event type as argument.
-Returns a pointer to &lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt&lt;/link&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_delete_event&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_delete_event&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const struct s3d_evt *&lt;parameter&gt;devt&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-deletes an event, the argument is the pointer to the &lt;link linkend=&quot;s3d_evt&quot;&gt;event&lt;/link&gt; which is to be 
-deleted (maybe obtained from &lt;link linkend=&quot;s3d_find_event&quot;&gt;s3d_find_event&lt;/link&gt;).
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_set_callback&quot;&gt;
-&lt;title&gt;s3d_set_callback&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3d_set_callback&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;,
-s3d_cb &lt;parameter&gt;func&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-sets a &lt;link linkend=&quot;s3d_cb&quot;&gt;callback&lt;/link&gt; for a certain event. this is very useful for event-oriented 
-applications. event callbacks will not interrupt each other or the mainloop.
-&lt;/para&gt;
-&lt;important&gt;&lt;para&gt;Defining callbacks will only work after calling &lt;link linkend=&quot;s3d_init&quot;&gt;s3d_init()&lt;/link&gt;&lt;/para&gt;&lt;/important&gt;
-&lt;programlisting&gt;
- &lt;![CDATA[#include &lt;inttypes.h&gt;]]&gt;
-
-void obj_click(&lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt&lt;/link&gt; event)
-{
-	printf(&quot;object id %&quot;PRIu32&quot; got clicked&quot;, *((uint32_t *)event-&gt;buf));
-}
-...
-	&lt;link linkend=&quot;s3d_set_callback&quot;&gt;s3d_set_callback&lt;/link&gt;(&lt;link linkend=&quot;S3D_EVENT_NEW_OBJECT&quot;&gt;S3D_EVENT_NEW_OBJECT&lt;/link&gt;, obj_click);
-
-/* this will tell you when a object got clicked */
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_ignore_callback&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3d_ignore_callback&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Sets the callback on ignore, that means it won't be queued up for later use.
-An incoming event of this type will simply be skipped.
-
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_clear_callback&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3d_clear_callback&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Clears the callback which is associated with the event.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_get_callback&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;s3d_cb &lt;function&gt;s3d_get_callback&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;uint8_t &lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Returns the &lt;link linkend=&quot;s3d_cb&quot;&gt;Callback-function&lt;/link&gt; of the event.
-&lt;/para&gt;
-&lt;programlisting&gt;
-	&lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt&lt;/link&gt; e;
-	...
-	&lt;emphasis&gt;s3d_get_callback&lt;/emphasis&gt;(&lt;link linkend=&quot;S3D_EVENT_KEY&quot;&gt;S3D_EVENT_KEY&lt;/link&gt;)(e);
-	/* will call the key-handling function with argument e.  */
-
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_process_stack&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3d_process_stack&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;void&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-This function goes through all function of the event-stack and will call 
-functions. this is useful when you define a new function but still have a lot 
-of events of this type on the stack. 
-&lt;/para&gt;
-&lt;note&gt;&lt;para&gt;This is probably obsolete&lt;/para&gt;&lt;/note&gt;
-&lt;/sect2&gt;
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_vector_length&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;float &lt;function&gt;s3d_vector_length&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const float &lt;parameter&gt;vector&lt;/parameter&gt;[]&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Calculates and returns the length of the given vector (which should be of the type float[3]).
-More info &lt;ulink url=&quot;<A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Length_of_a_vector">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Length_of_a_vector</A>&quot;&gt;on wikipedia&lt;/ulink&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_vector_subtract&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3d_vector_subtract&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[],
-const float &lt;parameter&gt;vector2&lt;/parameter&gt;[],
-float &lt;parameter&gt;result_vector&lt;/parameter&gt;[]&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Subtracts vector1 from vector2, writing result into result_vector.
-All vectors should have the format  float[3].
-More info &lt;ulink url=&quot;<A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction</A>&quot;&gt;on wikipedia&lt;/ulink&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_vector_dot_product&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;float &lt;function&gt;s3d_vector_dot_product&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[],
-const float &lt;parameter&gt;vector2&lt;/parameter&gt;[]&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Calculates and returns the dot product of vector1 and vector2.
-All vectors should have the format  float[3].
-More info &lt;ulink url=&quot;<A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product</A>&quot;&gt;on wikipedia&lt;/ulink&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_vector_cross_product&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3d_vector_cross_product&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[],
-const float &lt;parameter&gt;vector2&lt;/parameter&gt;[],
-float &lt;parameter&gt;result_vector&lt;/parameter&gt;[]&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Calculates and returns the cross product of vector1 and vector2.
-All vectors should have the format  float[3].
-More info &lt;ulink url=&quot;<A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Cross_product">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Cross_product</A>&quot;&gt;on wikipedia&lt;/ulink&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_vector_angle&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;float &lt;function&gt;s3d_vector_angle&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const float &lt;parameter&gt;vector1&lt;/parameter&gt;[],
-const float &lt;parameter&gt;vector2&lt;/parameter&gt;[]&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Calculates and returns the angle between vector1 and vector2. Please note that the resulting angle is between 0 and PI, therefore not covering the whole period! To convert in degrees just do result*180/M_PI.
-All vectors should have the format  float[3].
-More info &lt;ulink url=&quot;<A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product</A>&quot;&gt;on wikipedia&lt;/ulink&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_angle_to_cam&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;float &lt;function&gt;s3d_angle_to_cam&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const float &lt;parameter&gt;obj_pos&lt;/parameter&gt;[],
-const float &lt;parameter&gt;cam_pos&lt;/parameter&gt;[],
-float *&lt;parameter&gt;angle_rad&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-Given obj_pos and cam_pos in the format float[3], angle_rad about which angle the object should be rotated around the y-axis
-so that it faces the camera. This might become handy if you have some text floating in space and want it to face the camera.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_mcp_focus&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_mcp_focus&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-This is an mcp-only function. It gives focus (for receiving key-strokes etc.)
-to an app referenced by it's mcp-object-id. 
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2&gt;
-&lt;title&gt;s3d_net_check&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3d_net_check&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;void&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		This functions is for programs which do not employ a mainloop, hence they need to check
-		for new events on their own. Programs like these must make sure to call this function
-		from time to time to convince the server that they did not freeze or bail out.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
+&amp;libs3d_func;
 &lt;/sect1&gt;
 
 
 &lt;sect1 id=&quot;data_types&quot;&gt;
 &lt;title&gt;Data types&lt;/title&gt;
 
-&lt;sect2 id=&quot;s3d_obj_info&quot;&gt;
-&lt;title&gt;struct s3d_but_info&lt;/title&gt;
-&lt;programlisting&gt;
-struct s3d_obj_info {
-	uint32_t object;
-	uint32_t flags;
-	float trans_x, trans_y, trans_z;
-	float rot_x, rot_y, rot_z;
-	float scale;
-	float r;
-	char name[256];
-};
-&lt;/programlisting&gt;
-&lt;para&gt;
-Can be used on the buffer of an &lt;link linkend=&quot;s3d_evt&quot;&gt;event&lt;/link&gt; of type &lt;link linkend=&quot;S3D_EVENT_OBJ_INFO&quot;&gt;S3D_EVENT_OBJ_INFO&lt;/link&gt;.
-name will usually contain nothing for usual objects, but mcp objects will contain the applications names here. r is the radius of the convex sphere
-an object, which will also be interesting for the mcp.
-&lt;/para&gt;
-&lt;para&gt;
-Special objects like camera, pointer will have the &quot;sys_&quot; prefix in the name and will be named &quot;pointer0&quot;, &quot;pointer1&quot; ... or &quot;cam0&quot;, &quot;cam1&quot; ...
-For cam object, scale will contain the aspect ratio.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-
-&lt;sect2 id=&quot;s3d_but_info&quot;&gt;
-&lt;title&gt;struct s3d_but_info&lt;/title&gt;
-&lt;programlisting&gt;
-struct s3d_but_info {
-	uint8_t button;
-	uint8_t state;
-};
-&lt;/programlisting&gt;
-&lt;para&gt;
-Can be used on the buffer of an &lt;link linkend=&quot;s3d_evt&quot;&gt;event&lt;/link&gt; of type &lt;link linkend=&quot;S3D_EVENT_MBUTTON&quot;&gt;S3D_EVENT_MBUTTON&lt;/link&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;mcp_object&quot;&gt;
-&lt;title&gt;struct mcp_object&lt;/title&gt;
-&lt;programlisting&gt;
-struct mcp_object {
-	uint32_t object;
-	float trans_x, trans_y, trans_z;
-	float r;
-	char name[256];
-};
-
-&lt;/programlisting&gt;
-&lt;para&gt;
-obsolete, deprecated, don't use, to be removed soon (use &lt;link linkend=&quot;s3d_but_info&quot;&gt;struct s3d_but_info&lt;/link&gt;). ;)
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_evt&quot;&gt;
-&lt;title&gt;struct s3d_evt&lt;/title&gt;
-&lt;programlisting&gt;
-struct s3d_evt {
-	uint8_t event;
-	int length;
-	char *buf;
-	struct s3d_evt *next;
-};
-&lt;/programlisting&gt;
-&lt;para&gt;
-
-This is the event information holder. 
-&lt;variablelist&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;event&lt;/term&gt;
-&lt;listitem&gt;&lt;para&gt;gives the &lt;link linkend=&quot;s3d_events&quot;&gt;event type&lt;/link&gt;&lt;/para&gt;&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;length&lt;/term&gt;
-&lt;listitem&gt;&lt;para&gt;gives the length of the buffer *buf&lt;/para&gt;&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;*buf&lt;/term&gt;
-&lt;listitem&gt;&lt;para&gt;is the pointer to the multiple purpose buffer, which will have more specific information about the object&lt;/para&gt;&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;varlistentry&gt;
-&lt;term&gt;*next&lt;/term&gt;
-&lt;listitem&gt;&lt;para&gt;can be safely ignored ;)&lt;/para&gt;&lt;/listitem&gt;
-&lt;/varlistentry&gt;
-&lt;/variablelist&gt;
-
-Depending on the event, buf can contain the keycode pressed on keyboard event, the &lt;link linkend=&quot;s3d_but_info&quot;&gt;mouse button state&lt;/link&gt; on a mouse event, &lt;link linkend=&quot;s3d_obj_info&quot;&gt;object information&lt;/link&gt; etc.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3d_cb&quot;&gt;
-&lt;title&gt;typedef s3d_cb&lt;/title&gt;
-&lt;programlisting&gt;
-typedef void (*&lt;emphasis&gt;s3d_cb&lt;/emphasis&gt;)(&lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt&lt;/link&gt; *);
-&lt;/programlisting&gt;
-&lt;para&gt;
-This defines the callback format. Each callback should return void and take an argument of &lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt *&lt;/link&gt;.
-Callbacks can be defined with &lt;link linkend=&quot;s3d_set_callback&quot;&gt;s3d_set_callback()&lt;/link&gt;.
-&lt;/para&gt;
-&lt;programlisting&gt;
-/* a callback handler could look like this: */
-void my_key_handler(struct s3d_evt *event_data)
-{
-	...
-}
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
+&amp;libs3d_struct;
+&amp;libs3d_typedef;
 &lt;/sect1&gt;
 
 
@@ -1548,7 +64,7 @@
 &lt;sect2 id=&quot;s3d_events&quot;&gt;
 &lt;title&gt;S3D events&lt;/title&gt;
 &lt;para&gt;
-This defines the callback format. Each callback should return void and take an argument of &lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt *&lt;/link&gt;.
+This defines the callback format. Each callback should return void and take an argument of &lt;link linkend=&quot;structs3d_evt&quot;&gt;struct s3d_evt *&lt;/link&gt;.
 Callbacks can be defined with &lt;link linkend=&quot;s3d_set_callback&quot;&gt;s3d_set_callback()&lt;/link&gt;.
 &lt;variablelist&gt;
 
@@ -1571,7 +87,7 @@
 &lt;varlistentry&gt;
 &lt;term&gt;&lt;anchor id=&quot;S3D_EVENT_MBUTTON&quot;/&gt;S3D_EVENT_MBUTTON&lt;/term&gt;
 &lt;listitem&gt;&lt;para&gt;
-A mouse button was clicked. Use &lt;link linkend=&quot;s3d_but_info&quot;&gt;struct s3d_but_info&lt;/link&gt; on buf to get more info.
+A mouse button was clicked. Use &lt;link linkend=&quot;structs3d_but_info&quot;&gt;struct s3d_but_info&lt;/link&gt; on buf to get more info.
 &lt;/para&gt;&lt;/listitem&gt;
 &lt;/varlistentry&gt;
 
@@ -1595,7 +111,7 @@
 &lt;term&gt;&lt;anchor id=&quot;S3D_MCP_OBJECT&quot;/&gt;S3D_MCP_OBJECT&lt;/term&gt;
 &lt;listitem&gt;&lt;para&gt;
 As the name suggests, those will only happen to the MCP. 
-This tells it about new/changed application object. &lt;link linkend=&quot;mcp_object&quot;&gt;struct mcp_object&lt;/link&gt;
+This tells it about new/changed application object. &lt;link linkend=&quot;structmcp_object&quot;&gt;struct mcp_object&lt;/link&gt;
 can be used on buf. To be removed in the future.
 &lt;/para&gt;&lt;/listitem&gt;
 &lt;/varlistentry&gt;
@@ -1604,7 +120,7 @@
 &lt;term&gt;&lt;anchor id=&quot;S3D_MCP_DEL_OBJECT&quot;/&gt;S3D_MCP_DEL_OBJECT&lt;/term&gt;
 &lt;listitem&gt;&lt;para&gt;
 As the name suggests, those will only happen to the MCP. 
-This tells it about deleted application object. &lt;link linkend=&quot;mcp_object&quot;&gt;struct mcp_object&lt;/link&gt;
+This tells it about deleted application object. &lt;link linkend=&quot;structmcp_object&quot;&gt;struct mcp_object&lt;/link&gt;
 can be used on buf. To be removed in the future.
 &lt;/para&gt;&lt;/listitem&gt;
 &lt;/varlistentry&gt;

Added: trunk/Documentation/libs3d/structs.docbook
===================================================================
--- trunk/Documentation/libs3d/structs.docbook	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/Documentation/libs3d/structs.docbook	2008-08-31 22:19:18 UTC (rev 980)
@@ -0,0 +1,42 @@
+&lt;sect2 id=&quot;structs3d_evt&quot;&gt;&lt;title&gt;struct s3d_evt&lt;/title&gt;&lt;programlisting&gt;struct s3d_evt {
+	uint8_t event;
+	int length;
+	char *buf;
+	struct s3d_evt *next;
+}&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;This is the event information holder.     &lt;/para&gt;&lt;variablelist&gt;&lt;varlistentry&gt;&lt;term&gt;event&lt;/term&gt;&lt;listitem&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;gives the event type         &lt;/para&gt;&lt;/listitem&gt;&lt;/varlistentry&gt;&lt;varlistentry&gt;&lt;term&gt;length&lt;/term&gt;&lt;listitem&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;gives the length of the buffer *buf         &lt;/para&gt;&lt;/listitem&gt;&lt;/varlistentry&gt;&lt;varlistentry&gt;&lt;term&gt;buf&lt;/term&gt;&lt;listitem&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;is the pointer to the multiple purpose buffer, which will have more specific information about the object         &lt;/para&gt;&lt;/listitem&gt;&lt;/varlistentry&gt;&lt;varlistentry&gt;&lt;term&gt;next&lt;/term&gt;&lt;listitem&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;can be safely ignored ;)         &lt;/para&gt;&lt;/listitem&gt;&lt;/varlistentry&gt;&lt;/variablelist&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;structmcp_object&quot;&gt;&lt;title&gt;struct mcp_object&lt;/title&gt;&lt;programlisting&gt;struct mcp_object {
+	uint32_t object;
+	float trans_x;
+	float trans_y;
+	float trans_z;
+	float r;
+	char name;
+}&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Deprecated&lt;/para&gt;&lt;para&gt;don't use, to be removed soon (use struct s3d_but_info). ;)     &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;structs3d_obj_info&quot;&gt;&lt;title&gt;struct s3d_obj_info&lt;/title&gt;&lt;programlisting&gt;struct s3d_obj_info {
+	uint32_t object;
+	uint32_t flags;
+	float trans_x;
+	float trans_y;
+	float trans_z;
+	float rot_x;
+	float rot_y;
+	float rot_z;
+	float scale;
+	float r;
+	char name;
+}&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Can be used on the buffer of an event of type S3D_EVENT_OBJ_INFO. name will usually contain nothing for usual objects, but mcp objects will contain the applications names here. r is the radius of the convex sphere an object, which will also be interesting for the mcp.&lt;/para&gt;&lt;para&gt;Special objects like camera, pointer will have the &quot;sys_&quot; prefix in the name and will be named &quot;pointer0&quot;, &quot;pointer1&quot; ... or &quot;cam0&quot;, &quot;cam1&quot; ... For cam object, scale will contain the aspect ratio.     &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;structs3d_but_info&quot;&gt;&lt;title&gt;struct s3d_but_info&lt;/title&gt;&lt;programlisting&gt;struct s3d_but_info {
+	uint8_t button;
+	uint8_t state;
+}&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Can be used on the buffer of an event of type S3D_EVENT_MBUTTON.     &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;structs3d_key_event&quot;&gt;&lt;title&gt;struct s3d_key_event&lt;/title&gt;&lt;programlisting&gt;struct s3d_key_event {
+	uint16_t keysym;
+	uint16_t unicode;
+	uint16_t modifier;
+	uint16_t state;
+}&lt;/programlisting&gt;&lt;para&gt;
+    &lt;/para&gt;&lt;/sect2&gt;
\ No newline at end of file

Added: trunk/Documentation/libs3d/typedefs.docbook
===================================================================
--- trunk/Documentation/libs3d/typedefs.docbook	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/Documentation/libs3d/typedefs.docbook	2008-08-31 22:19:18 UTC (rev 980)
@@ -0,0 +1,2 @@
+&lt;sect2 id=&quot;s3d_cb&quot;&gt;&lt;title&gt;typedef s3d_cb&lt;/title&gt;&lt;programlisting&gt;typedef int(* s3d_cb)(struct s3d_evt *)&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;This defines the callback format. Each callback should return void and take an argument of struct s3d_evt *. Callbacks can be defined with s3d_set_callback().         &lt;/para&gt;&lt;/sect2&gt;
\ No newline at end of file

Added: trunk/Documentation/libs3dw/functions.docbook
===================================================================
--- trunk/Documentation/libs3dw/functions.docbook	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/Documentation/libs3dw/functions.docbook	2008-08-31 22:19:18 UTC (rev 980)
@@ -0,0 +1,70 @@
+&lt;sect2 id=&quot;s3dw_button_new&quot;&gt;&lt;title&gt;s3dw_button_new&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;s3dw_button * &lt;function&gt;s3dw_button_new&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const s3dw_surface *&lt;parameter&gt;surface&lt;/parameter&gt;, const char *&lt;parameter&gt;text&lt;/parameter&gt;, float &lt;parameter&gt;posx&lt;/parameter&gt;, float &lt;parameter&gt;posy&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Creates a new button on the surface, with &quot;text&quot; written on it and the upper left corner at (posx,posy) on the surface.&lt;/para&gt;&lt;para&gt;See s3dw_button for information about callbacks which may be defined.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_label_new&quot;&gt;&lt;title&gt;s3dw_label_new&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;s3dw_label * &lt;function&gt;s3dw_label_new&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const s3dw_surface *&lt;parameter&gt;surface&lt;/parameter&gt;, const char *&lt;parameter&gt;text&lt;/parameter&gt;, float &lt;parameter&gt;posx&lt;/parameter&gt;, float &lt;parameter&gt;posy&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Creates a new label on the surface, with &quot;text&quot; written on it and the upper left corner at (posx,posy) on the surface.&lt;/para&gt;&lt;para&gt;See s3dw_label for information about callbacks which may be defined.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_input_new&quot;&gt;&lt;title&gt;s3dw_input_new&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;s3dw_input * &lt;function&gt;s3dw_input_new&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const s3dw_surface *&lt;parameter&gt;surface&lt;/parameter&gt;, float &lt;parameter&gt;width&lt;/parameter&gt;, float &lt;parameter&gt;posx&lt;/parameter&gt;, float &lt;parameter&gt;posy&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Creates a new input-box on the surface with a input width of &quot;width&quot;, the upper left corner at (posx,posy) on the surface. The input-box is empty on creation and can be change with s3dw_input_change_text, and received with s3dw_input_gettext&lt;/para&gt;&lt;para&gt;See s3dw_input for information about callbacks which may be defined.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_textbox_new&quot;&gt;&lt;title&gt;s3dw_textbox_new&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;s3dw_textbox * &lt;function&gt;s3dw_textbox_new&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const s3dw_surface *&lt;parameter&gt;surface&lt;/parameter&gt;, const char *&lt;parameter&gt;text&lt;/parameter&gt;, float &lt;parameter&gt;posx&lt;/parameter&gt;, float &lt;parameter&gt;posy&lt;/parameter&gt;, float &lt;parameter&gt;width&lt;/parameter&gt;, float &lt;parameter&gt;height&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Creates a new textbox on the surface, with &quot;text&quot; written on it and the upper left corner at (posx,posy) on the surface. Width and height define the size of the textbox including scrollbars which are rendered around the textfield.&lt;/para&gt;&lt;para&gt;See s3dw_textbox for information about callbacks which may be defined.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_input_gettext&quot;&gt;&lt;title&gt;s3dw_input_gettext&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;char * &lt;function&gt;s3dw_input_gettext&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_input *&lt;parameter&gt;input&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Returns the text which is currently entered in the referenced input-box.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_input_change_text&quot;&gt;&lt;title&gt;s3dw_input_change_text&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_input_change_text&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_input *&lt;parameter&gt;input&lt;/parameter&gt;, const char *&lt;parameter&gt;text&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Change the text in the referenced input-box to the specified text.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_label_change_text&quot;&gt;&lt;title&gt;s3dw_label_change_text&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_label_change_text&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_label *&lt;parameter&gt;label&lt;/parameter&gt;, const char *&lt;parameter&gt;text&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Change the text in the referenced label to the specified text.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_surface_new&quot;&gt;&lt;title&gt;s3dw_surface_new&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;s3dw_surface * &lt;function&gt;s3dw_surface_new&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const char *&lt;parameter&gt;title&lt;/parameter&gt;, float &lt;parameter&gt;width&lt;/parameter&gt;, float &lt;parameter&gt;height&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Creates a new surface (a new window) with title &quot;title&quot; and dimension &quot;width&quot; x &quot;height&quot;.&lt;/para&gt;&lt;para&gt;See s3dw_surface for information about callbacks which may be defined.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_getroot&quot;&gt;&lt;title&gt;s3dw_getroot&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;s3dw_widget * &lt;function&gt;s3dw_getroot&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Returns the root-widget, which holds all the surfaces. E.g. if you want to move all widgets at once, adjust the root-widgets x,y,z and use s3dw_moveit()&lt;/para&gt;&lt;programlisting&gt; s3dw_widget *root = s3dw_getroot();
+ // move widget center to (0,5,0). upon creation, it's centered at (0,0,0),
+ // so this might move it up
+ root-&gt;x=0;
+ root-&gt;y=5;
+ root-&gt;z=0;
+ s3dw_moveit(root);
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_moveit&quot;&gt;&lt;title&gt;s3dw_moveit&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_moveit&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_widget *&lt;parameter&gt;widget&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Moves/translates the widget as you specified in it's private s3dw_widget structure. Should be casted with S3DWIDGET().         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_delete&quot;&gt;&lt;title&gt;s3dw_delete&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_delete&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_widget *&lt;parameter&gt;widget&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Deletes any widget. Should be casted with S3DWIDGET().         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_show&quot;&gt;&lt;title&gt;s3dw_show&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_show&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_widget *&lt;parameter&gt;widget&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Switches a widget visible. Should be casted with S3DWIDGET().         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_focus&quot;&gt;&lt;title&gt;s3dw_focus&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_focus&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_widget *&lt;parameter&gt;focus&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Gives focus to the widget, relative to its parent. That means you can focus a surface, and each surface can focus one of its element, e.g. an input field. Should be casted with S3DWIDGET().         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_textbox_scrollup&quot;&gt;&lt;title&gt;s3dw_textbox_scrollup&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_textbox_scrollup&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_textbox *&lt;parameter&gt;textbox&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Scrolls the text in the textbox up by one line, if possible.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_textbox_scrolldown&quot;&gt;&lt;title&gt;s3dw_textbox_scrolldown&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_textbox_scrolldown&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_textbox *&lt;parameter&gt;textbox&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Scrolls the text in the textbox down by one line, if possible.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_textbox_scrollleft&quot;&gt;&lt;title&gt;s3dw_textbox_scrollleft&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_textbox_scrollleft&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_textbox *&lt;parameter&gt;textbox&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Scrolls the text in the textbox to the left by one character, if possible.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_textbox_scrollright&quot;&gt;&lt;title&gt;s3dw_textbox_scrollright&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_textbox_scrollright&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_textbox *&lt;parameter&gt;textbox&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Scrolls the text in the textbox to the right by one character, if possible.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_textbox_scrollto&quot;&gt;&lt;title&gt;s3dw_textbox_scrollto&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_textbox_scrollto&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_textbox *&lt;parameter&gt;textbox&lt;/parameter&gt;, int &lt;parameter&gt;x&lt;/parameter&gt;, int &lt;parameter&gt;y&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Scrolls the text in the textbox so that the character in row y, column x is in the top left corner of the textbox.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_textbox_change_text&quot;&gt;&lt;title&gt;s3dw_textbox_change_text&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_textbox_change_text&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;s3dw_textbox *&lt;parameter&gt;textbox&lt;/parameter&gt;, const char *&lt;parameter&gt;text&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Change the text in the referenced textbox to the specified text.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_handle_click&quot;&gt;&lt;title&gt;s3dw_handle_click&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3dw_handle_click&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const struct s3d_evt *&lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;If you want your widgets on mouseclicks (believe me, you want that), you have to call this either in your clickhandler-function or specifiy it itself as the clickhandler.&lt;/para&gt;&lt;programlisting&gt; // way 1:
+ s3d_set_callback(S3D_EVENT_OBJ_CLICK,s3dw_handle_click);
+
+ // way 2:
+ ...
+ void click(struct s3d_evt *evt)
+ {
+         s3dw_handle_click(evt);
+         ....
+         // your own clickhandler code
+         ...
+ }
+ ....
+ s3d_set_callback(S3D_EVENT_OBJ_CLICK,click);
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_handle_key&quot;&gt;&lt;title&gt;s3dw_handle_key&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3dw_handle_key&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;const struct s3d_evt *&lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;This is somehow useful to call in your keyhandler functions if you want to have input-boxes work. ;)&lt;/para&gt;&lt;programlisting&gt; // way 1:
+ s3d_set_callback(S3D_EVENT_KEY,s3dw_handle_key);
+
+ // way 2:
+ ...
+ void key(struct s3d_evt *evt)
+ {
+         s3dw_handle_key(evt);
+         ....
+         // your own keyhandler code
+         ...
+ }
+ ....
+ s3d_set_callback(S3D_EVENT_KEY,key);
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_object_info&quot;&gt;&lt;title&gt;s3dw_object_info&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;int &lt;function&gt;s3dw_object_info&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;struct s3d_evt *&lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;This can be used to let s3dw handle S3D_EVENT_OBJ_INFO-events. With this, s3dw can consider the camera position and makes things like following the camera possible.         &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_ani_mate&quot;&gt;&lt;title&gt;s3dw_ani_mate&lt;/title&gt;&lt;funcsynopsis&gt;&lt;funcsynopsisinfo&gt;#include &lt;s3dw.h&gt;&lt;/funcsynopsisinfo&gt;&lt;funcprototype&gt;&lt;funcdef&gt;void &lt;function&gt;s3dw_ani_mate&lt;/function&gt;&lt;/funcdef&gt;&lt;paramdef&gt;void&lt;/paramdef&gt;&lt;/funcprototype&gt;&lt;/funcsynopsis&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;Just call this in your mainloop if you want some nice window sliding animations. it's somewhat bloating, but you don't want to miss it ;)&lt;/para&gt;&lt;programlisting&gt; #include &lt;time.h&gt;   // nanosleep()
+ static struct timespec t={0.33*1000*1000}; // 33 mili seconds
+ void mainloop()
+ {
+         // keep this in your mainloop. this will do smooth animations for you ...
+         s3dw_ani_mate();
+         nanosleep(&amp;t,NULL);
+ }
+
+ ....
+ s3d_mainloop(mainloop);
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;
\ No newline at end of file

Modified: trunk/Documentation/libs3dw/libs3dw.docbook
===================================================================
--- trunk/Documentation/libs3dw/libs3dw.docbook	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/Documentation/libs3dw/libs3dw.docbook	2008-08-31 22:19:18 UTC (rev 980)
@@ -1,6 +1,6 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
 &lt;chapter id=&quot;libs3dw&quot;&gt;
-&lt;title&gt;libs3wd - The S3D Widget Library&lt;/title&gt;
+&lt;title&gt;libs3dw - The S3D Widget Library&lt;/title&gt;
 &lt;sect1 id=&quot;using_3dw&quot;&gt;
 &lt;title&gt;Using the &lt;application&gt;s3d&lt;/application&gt; widget library&lt;/title&gt;
 &lt;sect2 id=&quot;gettingstarted_s3dw&quot;&gt;
@@ -26,671 +26,16 @@
 &lt;sect1 id=&quot;functions_s3dw&quot;&gt;
 &lt;title&gt;function reference&lt;/title&gt;
 
+&amp;libs3dw_func;
 
-
-&lt;sect2 id=&quot;s3dw_surface_new&quot;&gt;
-&lt;title&gt;s3dw_surface_new&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;s3dw_surface *&lt;function&gt;s3dw_surface_new&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const char         *&lt;parameter&gt;title&lt;/parameter&gt;,
-float		  &lt;parameter&gt;width&lt;/parameter&gt;,
-float		  &lt;parameter&gt;height&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Creates a new surface (a new window) with title &quot;title&quot; and dimension &quot;width&quot; x &quot;height&quot;.
-&lt;/para&gt;
-&lt;para&gt;
-		See &lt;link linkend=&quot;s3dw_surface&quot;&gt;s3dw_surface&lt;/link&gt; for information about callbacks which may be defined.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3dw_button_new&quot;&gt;
-&lt;title&gt;s3dw_button_new&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;s3dw_button *&lt;function&gt;s3dw_button_new&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const s3dw_surface *&lt;parameter&gt;surface&lt;/parameter&gt;,
-const char         *&lt;parameter&gt;text&lt;/parameter&gt;,
-float		  &lt;parameter&gt;posx&lt;/parameter&gt;,
-float		  &lt;parameter&gt;posy&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Creates a new button on the &lt;link linkend=&quot;s3dw_surface&quot;&gt;surface&lt;/link&gt;, 
-		with &quot;text&quot; written on it and the upper left 
-		corner at (posx,posy) on the &lt;link linkend=&quot;s3dw_surface&quot;&gt;surface&lt;/link&gt;.
-&lt;/para&gt;
-&lt;para&gt;
-		See &lt;link linkend=&quot;s3dw_button&quot;&gt;s3dw_button&lt;/link&gt; for information about callbacks which may be defined.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_input_new&quot;&gt;
-&lt;title&gt;s3dw_input_new&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;s3dw_input *&lt;function&gt;s3dw_input_new&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const s3dw_surface *&lt;parameter&gt;surface&lt;/parameter&gt;,
-float		  &lt;parameter&gt;width&lt;/parameter&gt;,
-float		  &lt;parameter&gt;posx&lt;/parameter&gt;,
-float		  &lt;parameter&gt;posy&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Creates a new input-box on the &lt;link linkend=&quot;s3dw_surface&quot;&gt;surface&lt;/link&gt; with a input width of &quot;width&quot;,
-		the upper left  corner at (posx,posy) on the &lt;link linkend=&quot;s3dw_surface&quot;&gt;surface&lt;/link&gt;.
-		The input-box is empty on creation and can be change with &lt;link linkend=&quot;s3dw_input_change_text&quot;&gt;s3dw_input_change_text&lt;/link&gt;,
-		and received with &lt;link linkend=&quot;s3dw_input_gettext&quot;&gt;s3dw_input_gettext&lt;/link&gt;
-&lt;/para&gt;
-&lt;para&gt;
-		See &lt;link linkend=&quot;s3dw_input&quot;&gt;s3dw_input&lt;/link&gt; for information about callbacks which may be defined.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_label_new&quot;&gt;
-&lt;title&gt;s3dw_label_new&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;s3dw_label *&lt;function&gt;s3dw_label_new&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const s3dw_surface *&lt;parameter&gt;surface&lt;/parameter&gt;,
-const char         *&lt;parameter&gt;text&lt;/parameter&gt;,
-float		  &lt;parameter&gt;posx&lt;/parameter&gt;,
-float		  &lt;parameter&gt;posy&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Creates a new label on the &lt;link linkend=&quot;s3dw_surface&quot;&gt;surface&lt;/link&gt;, 
-		with &quot;text&quot; written on it and the upper left 
-		corner at (posx,posy) on the &lt;link linkend=&quot;s3dw_surface&quot;&gt;surface&lt;/link&gt;.
-&lt;/para&gt;
-&lt;para&gt;
-		See &lt;link linkend=&quot;s3dw_label&quot;&gt;s3dw_label&lt;/link&gt; for information about callbacks which may be defined.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_textbox_new&quot;&gt;
-&lt;title&gt;s3dw_textbox_new&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;s3dw_textbox *&lt;function&gt;s3dw_textbox_new&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const s3dw_surface *&lt;parameter&gt;surface&lt;/parameter&gt;,
-const char         *&lt;parameter&gt;text&lt;/parameter&gt;,
-float		  &lt;parameter&gt;posx&lt;/parameter&gt;,
-float		  &lt;parameter&gt;posy&lt;/parameter&gt;,
-float		  &lt;parameter&gt;width&lt;/parameter&gt;,
-float		  &lt;parameter&gt;height&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Creates a new textbox on the &lt;link linkend=&quot;s3dw_surface&quot;&gt;surface&lt;/link&gt;,
-		with &quot;text&quot; written on it and the upper left
-		corner at (posx,posy) on the &lt;link linkend=&quot;s3dw_surface&quot;&gt;surface&lt;/link&gt;.
-		Width and height define the size of the textbox including scrollbars which
-		are rendered around the textfield.
-&lt;/para&gt;
-&lt;para&gt;
-		See &lt;link linkend=&quot;s3dw_textbox&quot;&gt;s3dw_textbox&lt;/link&gt; for information about callbacks which may be defined.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_textbox_scrollup&quot;&gt;
-&lt;title&gt;s3dw_textbox_scrollup&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_textbox_scrollup&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_textbox *&lt;parameter&gt;textbox&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Scrolls the text in the textbox up by one line, if possible.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_textbox_scrolldown&quot;&gt;
-&lt;title&gt;s3dw_textbox_scrolldown&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_textbox_scrolldown&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_textbox *&lt;parameter&gt;textbox&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Scrolls the text in the textbox down by one line, if possible.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_textbox_scrollleft&quot;&gt;
-&lt;title&gt;s3dw_textbox_scrollleft&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_textbox_scrollleft&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_textbox *&lt;parameter&gt;textbox&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Scrolls the text in the textbox to the left by one character, if possible.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_textbox_scrollright&quot;&gt;
-&lt;title&gt;s3dw_textbox_scrollright&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_textbox_scrollright&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_textbox *&lt;parameter&gt;textbox&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Scrolls the text in the textbox to the right by one character, if possible.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_textbox_scrollto&quot;&gt;
-&lt;title&gt;s3dw_textbox_scrollto&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_textbox_scrollto&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_textbox *&lt;parameter&gt;textbox&lt;/parameter&gt;,
-int &lt;parameter&gt;x&lt;/parameter&gt;,
-int &lt;parameter&gt;y&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Scrolls the text in the textbox so that the character in row y, column x is in the
-		top left corner of the textbox.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-
-&lt;sect2 id=&quot;s3dw_getroot&quot;&gt;
-&lt;title&gt;s3dw_getroot&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-	&lt;funcdef&gt;s3dw_widget *&lt;function&gt;s3dw_getroot&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;void&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Returns the root-&lt;link linkend=&quot;s3dw_widget&quot;&gt;widget&lt;/link&gt;, which holds all the surfaces. E.g. if you want
-		to move all widgets at once, adjust the root-widgets x,y,z and use &lt;link linkend=&quot;s3dw_moveit&quot;&gt;s3dw_moveit()&lt;/link&gt;
-&lt;/para&gt;
-&lt;programlisting&gt;
-		&lt;link linkend=&quot;s3dw_widget&quot;&gt;s3dw_widget&lt;/link&gt; *root = &lt;emphasis&gt;s3dw_getroot&lt;/emphasis&gt;();
-		/* move &lt;link linkend=&quot;s3dw_widget&quot;&gt;widget&lt;/link&gt; center to (0,5,0). upon creation, it's centered at (0,0,0), 
-		 * so this might move it up */
-		root-&gt;x=0;
-		root-&gt;y=5;
-		root-&gt;z=0;
-		&lt;link linkend=&quot;s3dw_moveit&quot;&gt;s3dw_moveit&lt;/link&gt;(root);
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3dw_input_gettext&quot;&gt;
-&lt;title&gt;s3dw_input_gettext&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;char *&lt;function&gt;s3dw_input_gettext&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_input *&lt;parameter&gt;input&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Returns the text which is currently entered in the referenced &lt;link linkend=&quot;s3dw_input&quot;&gt;input-box&lt;/link&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_input_change_text&quot;&gt;
-&lt;title&gt;s3dw_input_change_text&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_input_change_text&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_input *&lt;parameter&gt;input&lt;/parameter&gt;,
-const 		char *&lt;parameter&gt;text&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Change the text in the referenced &lt;link linkend=&quot;s3dw_input&quot;&gt;input-box&lt;/link&gt; to the specified text.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_label_change_text&quot;&gt;
-&lt;title&gt;s3dw_label_change_text&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_label_change_text&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_label *&lt;parameter&gt;label&lt;/parameter&gt;,
-const 		char *&lt;parameter&gt;text&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Change the text in the referenced &lt;link linkend=&quot;s3dw_label&quot;&gt;label&lt;/link&gt; to the specified text.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_textbox_change_text&quot;&gt;
-&lt;title&gt;s3dw_textbox_change_text&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_textbox_change_text&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_textbox *&lt;parameter&gt;textbox&lt;/parameter&gt;,
-const 		char *&lt;parameter&gt;text&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Change the text in the referenced &lt;link linkend=&quot;s3dw_textbox&quot;&gt;textbox&lt;/link&gt; to the specified text.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3dw_delete&quot;&gt;
-&lt;title&gt;s3dw_delete&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_delete&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_widget *&lt;parameter&gt;widget&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-	Deletes any widget. Should be casted with &lt;link linkend=&quot;S3DWIDGET&quot;&gt;S3DWIDGET()&lt;/link&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_moveit&quot;&gt;
-&lt;title&gt;s3dw_moveit&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_moveit&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_widget *&lt;parameter&gt;widget&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Moves/translates the widget as you specified in it's private &lt;link linkend=&quot;s3dw_widget&quot;&gt;s3dw_widget structure&lt;/link&gt;.
-		Should be casted with &lt;link linkend=&quot;S3DWIDGET&quot;&gt;S3DWIDGET()&lt;/link&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_show&quot;&gt;
-&lt;title&gt;s3dw_show&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_show&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_widget *&lt;parameter&gt;widget&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Switches a &lt;link linkend=&quot;s3dw_widget&quot;&gt;widget&lt;/link&gt; visible. Should be casted with &lt;link linkend=&quot;S3DWIDGET&quot;&gt;S3DWIDGET()&lt;/link&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_focus&quot;&gt;
-&lt;title&gt;s3dw_focus&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_focus&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;s3dw_widget *&lt;parameter&gt;focus&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		Gives focus to the &lt;link linkend=&quot;s3dw_widget&quot;&gt;widget&lt;/link&gt;, relative to its parent. That means you can focus a 
-		&lt;link linkend=&quot;s3dw_surface&quot;&gt;surface&lt;/link&gt;, and each &lt;link linkend=&quot;s3dw_surface&quot;&gt;surface&lt;/link&gt; can focus 
-		one of its element, e.g. an input field. 
-		Should be casted with &lt;link linkend=&quot;S3DWIDGET&quot;&gt;S3DWIDGET()&lt;/link&gt;.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_handle_click&quot;&gt;
-&lt;title&gt;s3dw_handle_click&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3dw_handle_click&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const		struct s3d_evt *&lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-	If you want your widgets on mouseclicks (believe me, you want that), you have to call this
-	either in your clickhandler-function or specifiy it itself as the clickhandler.
-&lt;/para&gt;
-&lt;programlisting&gt;
-/* way 1: */
-&lt;link linkend=&quot;s3d_set_callback&quot;&gt;s3d_set_callback&lt;/link&gt;(&lt;link linkend=&quot;S3D_EVENT_OBJ_CLICK&quot;&gt;S3D_EVENT_OBJ_CLICK&lt;/link&gt;,&lt;emphasis&gt;s3dw_handle_click&lt;/emphasis&gt;);
-
-/* way 2: */
-...
-void click(&lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt&lt;/link&gt; *evt)
-{
-	&lt;emphasis&gt;s3dw_handle_click&lt;/emphasis&gt;(evt);
-	.... 
-	/* your own clickhandler code */
-	...
-}
-....
-&lt;link linkend=&quot;s3d_set_callback&quot;&gt;s3d_set_callback&lt;/link&gt;(&lt;link linkend=&quot;S3D_EVENT_OBJ_CLICK&quot;&gt;S3D_EVENT_OBJ_CLICK&lt;/link&gt;,click);
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3dw_handle_key&quot;&gt;
-&lt;title&gt;s3dw_handle_key&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3dw_handle_key&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;const		struct s3d_evt *&lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-	This is somehow useful to call in your keyhandler functions if you want to 
-	have input-boxes work. ;)
-&lt;/para&gt;
-&lt;programlisting&gt;
-/* way 1: */
-&lt;link linkend=&quot;s3d_set_callback&quot;&gt;s3d_set_callback&lt;/link&gt;(&lt;link linkend=&quot;S3D_EVENT_KEY&quot;&gt;S3D_EVENT_KEY&lt;/link&gt;,&lt;emphasis&gt;s3dw_handle_key&lt;/emphasis&gt;);
-
-/* way 2: */
-...
-void key(&lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt&lt;/link&gt; *evt)
-{
-	&lt;emphasis&gt;s3dw_handle_key&lt;/emphasis&gt;(evt);
-	.... 
-	/* your own keyhandler code */
-	...
-}
-....
-&lt;link linkend=&quot;s3d_set_callback&quot;&gt;s3d_set_callback&lt;/link&gt;(&lt;link linkend=&quot;S3D_EVENT_KEY&quot;&gt;S3D_EVENT_KEY&lt;/link&gt;,key);
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_object_info&quot;&gt;
-&lt;title&gt;s3dw_object_info&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;int &lt;function&gt;s3dw_object_info&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;struct s3d_evt *&lt;parameter&gt;event&lt;/parameter&gt;&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-		This can be used to let s3dw handle S3D_EVENT_OBJ_INFO-events. With this,
-		s3dw can consider the camera position and makes things like following the
-		camera possible.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_ani_mate&quot;&gt;
-&lt;title&gt;s3dw_ani_mate&lt;/title&gt;
-&lt;funcsynopsis&gt;
-&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3dw.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
-&lt;funcprototype&gt;
-&lt;funcdef&gt;void &lt;function&gt;s3dw_ani_mate&lt;/function&gt;&lt;/funcdef&gt;
-&lt;paramdef&gt;void&lt;/paramdef&gt;
-&lt;/funcprototype&gt;
-&lt;/funcsynopsis&gt;
-&lt;para&gt;
-	Just call this in your mainloop if you want
-	some nice window sliding animations. it's somewhat bloating, but you don't want to miss it ;)
-&lt;/para&gt;
-&lt;programlisting&gt;
-&lt;![CDATA[#include &lt;time.h&gt;]]&gt;   /* nanosleep() */
-static struct timespec t={0,33*1000*1000}; /* 33 mili seconds */
-void mainloop()
-{
-    /* keep this in your mainloop. this will do smooth animations for you ... */
-    s3dw_ani_mate();
-    nanosleep(&lt;![CDATA[&amp;t,NULL]]&gt;);
-}
-
-....
-&lt;link linkend=&quot;s3d_mainloop&quot;&gt;s3d_mainloop&lt;/link&gt;(mainloop);
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
 &lt;/sect1&gt;
 &lt;sect1 id=&quot;data_types_s3dw&quot;&gt;
 &lt;title&gt;Data types&lt;/title&gt;
 
 
 
-&lt;sect2 id=&quot;s3dw_widget&quot;&gt;
-&lt;title&gt;s3dw_widget&lt;/title&gt;
-&lt;programlisting&gt;
-struct _s3dw_widget {
-	/* private .. */
-	int         type;
-	s3dw_widget *parent;
-	s3dw_style  *style;
-	int         nobj;          /* number of children objects */
-	s3dw_widget **pobj;        /* pointer to list of children objects */
-	int         focus;         /* index of the widget focused in pobj */
-	int         flags;         /* flags like visibility */
-	float       ax, ay, az;    /* current position for animation */
-	float       as;            /* current scale factor */
-	float       arx, ary, arz; /* current rotation */
-	float       width, height; /* width and height of the widget, outer size */
-	uint32_t    oid;           /* the main object which is used for transformations etc ...*/
-	/* public */
-	void        *ptr;          /* a pointer to a user structure, to use in callbacks etc */
-	float       x, y, z;       /* position, relative to the surface usually */
-	float       s;             /* scale factor */
-	float       rx, ry, rz;    /* rotation around the axis */
-};
-typedef struct _s3dw_widget     s3dw_widget;
+&amp;libs3dw_struct;
+&amp;libs3dw_typedef;
 
-/* type may be one of the following ... */		
-
-enum {
-	S3DW_TROOT,
-	S3DW_TCAM,
-	S3DW_TSURFACE,
-	S3DW_TBUTTON,
-	S3DW_TLABEL,
-	S3DW_TINPUT,
-	S3DW_TTEXTBOX,
-	S3DW_TSCROLLBAR,
-	S3DW_NTYPES
-};
-&lt;anchor id=&quot;S3DWIDGET&quot;/&gt;
-#define     S3DWIDGET(x)    ((s3dw_widget *)x)
-						
-&lt;/programlisting&gt;
-&lt;para&gt;
-		This is the most basic widget type, it contains all the &quot;general&quot; widget information. If you want to move a widget, you'd
-		change x,y,z,s and rx,ry,rz and call &lt;link linkend=&quot;s3dw_moveit&quot;&gt;s3dw_moveit&lt;/link&gt; to turn your action reality. Every other
-		widget has this type as first entry, so a simple typecast to &lt;emphasis&gt;s3dw_widget&lt;/emphasis&gt; will give you the widgets &quot;general&quot;
-		information. For typecast, you may use S3DWIDGET().
-&lt;/para&gt;
-&lt;para&gt;
-		The pointer ptr allows linking to user-specific datastructures. That comes in handy if the widget is called back by an event,
-		and the program must now find out on which data the user reacted.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_button&quot;&gt;
-&lt;title&gt;s3dw_button&lt;/title&gt;
-&lt;programlisting&gt;
-typedef struct _s3dw_button     s3dw_button;
-struct _s3dw_button {
-    /* private */
-	&lt;link linkend=&quot;s3dw_widget&quot;&gt;s3dw_widget&lt;/link&gt;      widget;
-	char            *text;
-	uint32_t    oid_text;
-	/* public */
-	&lt;link linkend=&quot;s3dw_callback&quot;&gt;s3dw_callback&lt;/link&gt;    onclick;
-};
-&lt;/programlisting&gt;
-&lt;para&gt;
-	The buttons is just a button as you would expect it in a 2D widget library. It only reacts on clicks.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3dw_input&quot;&gt;
-&lt;title&gt;s3dw_input&lt;/title&gt;
-&lt;programlisting&gt;
-typedef struct _s3dw_input     s3dw_input;
-struct _s3dw_input {
-    /* private */
-	&lt;link linkend=&quot;s3dw_widget&quot;&gt;s3dw_widget&lt;/link&gt;      widget;
-	char            *text;
-	uint32_t    oid_text;
-	/* public */
-	&lt;link linkend=&quot;s3dw_callback&quot;&gt;s3dw_callback&lt;/link&gt;    onclick;
-	&lt;link linkend=&quot;s3dw_callback&quot;&gt;s3dw_callback&lt;/link&gt;    onedit;
-};
-&lt;/programlisting&gt;
-&lt;para&gt;
-		The inputs is an input-field where a user may type things. onclick reacts on click in the field,
-		onedit notifies you when someone writes in the field.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_textbox&quot;&gt;
-&lt;title&gt;s3dw_textbox&lt;/title&gt;
-&lt;programlisting&gt;
-typedef struct _s3dw_textbox     s3dw_textbox;
-struct _s3dw_textbox {
-    /* private */
-	&lt;link linkend=&quot;s3dw_widget&quot;&gt;s3dw_widget&lt;/link&gt;      widget;
-	&lt;link linkend=&quot;s3dw_widget&quot;&gt;s3dw_scrollbar&lt;/link&gt;      *scroll_vertical, *scroll_horizontal;
-	char            *text;
-	int				n_lineoids, *p_lineoids;
-	int 			window_x, window_y;
-	/* public */
-	&lt;link linkend=&quot;s3dw_callback&quot;&gt;s3dw_callback&lt;/link&gt;    onclick;
-};
-&lt;/programlisting&gt;
-&lt;para&gt;
-	A textbox shows some text with scrollbars to scroll around. It can currently only react to a click event.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_scrollbar&quot;&gt;
-&lt;title&gt;s3dw_scrollbar&lt;/title&gt;
-&lt;programlisting&gt;
-typedef struct _s3dw_scrollbar     s3dw_scrollbar;
-struct _s3dw_scrollbar {
-    /* private */
-	&lt;link linkend=&quot;s3dw_widget&quot;&gt;s3dw_widget&lt;/link&gt;      widget;
-	float			pos, max;
-	int				type;  /* 0 = horizontal, 1 = vertical */
-	int 			loid, roid, baroid;
-	/* public */
-	&lt;link linkend=&quot;s3dw_callback&quot;&gt;s3dw_callback&lt;/link&gt;    lonclick, ronclick;
-};
-&lt;/programlisting&gt;
-&lt;para&gt;
-		The Scrollbar should be placed around scrollable content. Currently only the
-		left and right icons are clickable (lonclick and ronclick callbacks), in
-		vertical mode lonclick is the callback for the up icon,
-		ronclick the callback for the down icon.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-
-&lt;sect2 id=&quot;s3dw_label&quot;&gt;
-&lt;title&gt;s3dw_label&lt;/title&gt;
-&lt;programlisting&gt;
-typedef struct _s3dw_label     s3dw_label;
-struct _s3dw_label {
-    /* private */
-	&lt;link linkend=&quot;s3dw_widget&quot;&gt;s3dw_widget&lt;/link&gt;      widget;
-	char            *text;
-	/* public */
-	&lt;link linkend=&quot;s3dw_callback&quot;&gt;s3dw_callback&lt;/link&gt;    onclick;
-};
-&lt;/programlisting&gt;
-&lt;para&gt;
-		The labels is an label-field where a user may type things. onclick reacts on click in the field,
-		onedit notifies you when someone writes in the field.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_surface&quot;&gt;
-&lt;title&gt;s3dw_surface&lt;/title&gt;
-&lt;programlisting&gt;
-typedef struct _s3dw_surface     s3dw_surface;
-struct _s3dw_surface {
-    /* private */
-	&lt;link linkend=&quot;s3dw_widget&quot;&gt;s3dw_widget&lt;/link&gt;      widget;
-	uint32_t         oid_title;
-	uint32_t         oid_tbar;
-	char            *title;
-};
-&lt;/programlisting&gt;
-&lt;para&gt;
-	A surface is the window of this widget library, holding all of our elements like &lt;link linkend=&quot;s3dw_button&quot;&gt;buttons&lt;/link&gt;, 
-	&lt;link linkend=&quot;s3dw_input&quot;&gt;inputfields&lt;/link&gt; etc ...
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-
-&lt;sect2 id=&quot;s3dw_style&quot;&gt;
-&lt;title&gt;s3dw_style&lt;/title&gt;
-&lt;programlisting&gt;
-typedef struct _s3dw_style     s3dw_style;
-/* style */
-struct _s3dw_style {
-    char *name;                 /* name of the style ... kind of redundant */
-    char *fontface;             /* font face for all used fonts */
-    float surface_mat[12];      /* material for the surface background */
-    float input_mat[12];        /* material for buttonboxes and other widgets */
-    float inputback_mat[12];    /* material for inputfield background */
-    float text_mat[12];         /* material for the text on buttons and inputs */
-    float title_mat[12];        /* material for the title bar */
-    float title_text_mat[12];   /* material for the text on the title bar */
-};
-
-&lt;/programlisting&gt;
-&lt;para&gt;
-	With s3dw_style you can change the colors/materials of your widgets. materials are in the same as in 
-	&lt;link linkend=&quot;s3d_push_materials_a&quot;&gt;s3d_push_materials_a&lt;/link&gt;, that means red,green,blue and alpha float values 
-	(between 0.0 and 1.0) for Ambience, Specular and Diffuse Color.
-&lt;/para&gt;
-&lt;/sect2&gt;
-
-&lt;sect2 id=&quot;s3dw_callback&quot;&gt;
-&lt;title&gt;s3dw_callback&lt;/title&gt;
-&lt;programlisting&gt;
-typedef void (*s3dw_callback)(s3dw_widget *);
-
-&lt;/programlisting&gt;
-&lt;para&gt;
-	The callback type. Receive the widget which is affected as argument.
-&lt;/para&gt;
-&lt;programlisting&gt;
-/* example */
-void my_handler(&lt;link linkend=&quot;s3dw_widget&quot;&gt;s3dw_widget&lt;/link&gt; *widget)
-{
-	/* do something with the widget */
-	...
-}
-&lt;/programlisting&gt;
-&lt;/sect2&gt;
-
-
 &lt;/sect1&gt;
 &lt;/chapter&gt;

Added: trunk/Documentation/libs3dw/structs.docbook
===================================================================
--- trunk/Documentation/libs3dw/structs.docbook	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/Documentation/libs3dw/structs.docbook	2008-08-31 22:19:18 UTC (rev 980)
@@ -0,0 +1,92 @@
+&lt;sect2 id=&quot;struct_s3dw_style&quot;&gt;&lt;title&gt;struct _s3dw_style&lt;/title&gt;&lt;programlisting&gt;struct _s3dw_style {
+	char *name;
+	char *fontface;
+	float surface_mat;
+	float input_mat;
+	float inputback_mat;
+	float text_mat;
+	float title_mat;
+	float title_text_mat;
+}&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;With s3dw_style you can change the colors/materials of your widgets. materials are in the same as in s3d_push_materials_a, that means red,green,blue and alpha float values (between 0.0 and 1.0) for Ambience, Specular and Diffuse Color.     &lt;/para&gt;&lt;variablelist&gt;&lt;varlistentry&gt;&lt;term&gt;name&lt;/term&gt;&lt;listitem&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;name of the style ... kind of redundant         &lt;/para&gt;&lt;/listitem&gt;&lt;/varlistentry&gt;&lt;varlistentry&gt;&lt;term&gt;fontface&lt;/term&gt;&lt;listitem&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;font face for all used fonts         &lt;/para&gt;&lt;/listitem&gt;&lt;/varlistentry&gt;&lt;varlistentry&gt;&lt;term&gt;surface_mat&lt;/term&gt;&lt;listitem&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;material for the surface background         &lt;/para&gt;&lt;/listitem&gt;&lt;/varlistentry&gt;&lt;varlistentry&gt;&lt;term&gt;input_mat&lt;/term&gt;&lt;listitem&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;material for buttonboxes and other widgets         &lt;/para&gt;&lt;/listitem&gt;&lt;/varlistentry&gt;&lt;varlistentry&gt;&lt;term&gt;inputback_mat&lt;/term&gt;&lt;listitem&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;material for inputfield background         &lt;/para&gt;&lt;/listitem&gt;&lt;/varlistentry&gt;&lt;varlistentry&gt;&lt;term&gt;text_mat&lt;/term&gt;&lt;listitem&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;material for the text on buttons and inputs         &lt;/para&gt;&lt;/listitem&gt;&lt;/varlistentry&gt;&lt;varlistentry&gt;&lt;term&gt;title_mat&lt;/term&gt;&lt;listitem&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;material for the title bar         &lt;/para&gt;&lt;/listitem&gt;&lt;/varlistentry&gt;&lt;varlistentry&gt;&lt;term&gt;title_text_mat&lt;/term&gt;&lt;listitem&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;material for the text on the title bar         &lt;/para&gt;&lt;/listitem&gt;&lt;/varlistentry&gt;&lt;/variablelist&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;struct_s3dw_widget&quot;&gt;&lt;title&gt;struct _s3dw_widget&lt;/title&gt;&lt;programlisting&gt;struct _s3dw_widget {
+	int type;
+	s3dw_widget *parent;
+	s3dw_style *style;
+	int nobj;
+	s3dw_widget **pobj;
+	int focus;
+	int flags;
+	float ax;
+	float ay;
+	float az;
+	float as;
+	float arx;
+	float ary;
+	float arz;
+	float width;
+	float height;
+	uint32_t oid;
+	void *ptr;
+	float x;
+	float y;
+	float z;
+	float s;
+	float rx;
+	float ry;
+	float rz;
+}&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;This is the most basic widget type, it contains all the &quot;general&quot; widget information. If you want to move a widget, you'd change x,y,z,s and rx,ry,rz and call s3dw_moveit to turn your action reality. Every other widget has this type as first entry, so a simple typecast to s3dw_widget will give you the widgets &quot;general&quot; information. For typecast, you may use S3DWIDGET().&lt;/para&gt;&lt;para&gt;The pointer ptr allows linking to user-specific datastructures. That comes in handy if the widget is called back by an event, and the program must now find out on which data the user reacted.     &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;struct_s3dw_button&quot;&gt;&lt;title&gt;struct _s3dw_button&lt;/title&gt;&lt;programlisting&gt;struct _s3dw_button {
+	s3dw_widget widget;
+	char *text;
+	uint32_t oid_text;
+	s3dw_callback onclick;
+}&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;The buttons is just a button as you would expect it in a 2D widget library. It only reacts on clicks.     &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;struct_s3dw_label&quot;&gt;&lt;title&gt;struct _s3dw_label&lt;/title&gt;&lt;programlisting&gt;struct _s3dw_label {
+	s3dw_widget widget;
+	char *text;
+	s3dw_callback onclick;
+}&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;The labels is an label-field where a user may type things. onclick reacts on click in the field, onedit notifies you when someone writes in the field.     &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;struct_s3dw_scrollbar&quot;&gt;&lt;title&gt;struct _s3dw_scrollbar&lt;/title&gt;&lt;programlisting&gt;struct _s3dw_scrollbar {
+	s3dw_widget widget;
+	float pos;
+	float max;
+	int type;
+	int loid;
+	int roid;
+	int baroid;
+	s3dw_callback lonclick;
+	s3dw_callback ronclick;
+}&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;The Scrollbar should be placed around scrollable content. Currently only the left and right icons are clickable (lonclick and ronclick callbacks), in vertical mode lonclick is the callback for the up icon, ronclick the callback for the down icon.     &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;struct_s3dw_textbox&quot;&gt;&lt;title&gt;struct _s3dw_textbox&lt;/title&gt;&lt;programlisting&gt;struct _s3dw_textbox {
+	s3dw_widget widget;
+	s3dw_scrollbar *scroll_vertical;
+	s3dw_scrollbar *scroll_horizontal;
+	char *text;
+	int n_lineoids;
+	int *p_lineoids;
+	int window_x;
+	int window_y;
+	s3dw_callback onclick;
+}&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;A textbox shows some text with scrollbars to scroll around. It can currently only react to a click event.     &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;struct_s3dw_input&quot;&gt;&lt;title&gt;struct _s3dw_input&lt;/title&gt;&lt;programlisting&gt;struct _s3dw_input {
+	s3dw_widget widget;
+	char *text;
+	uint32_t oid_text;
+	s3dw_callback onclick;
+	s3dw_callback onedit;
+}&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;The inputs is an input-field where a user may type things. onclick reacts on click in the field, onedit notifies you when someone writes in the field.     &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;struct_s3dw_surface&quot;&gt;&lt;title&gt;struct _s3dw_surface&lt;/title&gt;&lt;programlisting&gt;struct _s3dw_surface {
+	s3dw_widget widget;
+	uint32_t oid_title;
+	uint32_t oid_tbar;
+	char *title;
+}&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;A surface is the window of this widget library, holding all of our elements like buttons, inputfields etc ...     &lt;/para&gt;&lt;/sect2&gt;
\ No newline at end of file

Added: trunk/Documentation/libs3dw/typedefs.docbook
===================================================================
--- trunk/Documentation/libs3dw/typedefs.docbook	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/Documentation/libs3dw/typedefs.docbook	2008-08-31 22:19:18 UTC (rev 980)
@@ -0,0 +1,16 @@
+&lt;sect2 id=&quot;s3dw_widget&quot;&gt;&lt;title&gt;typedef s3dw_widget&lt;/title&gt;&lt;programlisting&gt;typedef struct _s3dw_widget s3dw_widget&lt;/programlisting&gt;&lt;para&gt;
+        &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_button&quot;&gt;&lt;title&gt;typedef s3dw_button&lt;/title&gt;&lt;programlisting&gt;typedef struct _s3dw_button s3dw_button&lt;/programlisting&gt;&lt;para&gt;
+        &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_label&quot;&gt;&lt;title&gt;typedef s3dw_label&lt;/title&gt;&lt;programlisting&gt;typedef struct _s3dw_label s3dw_label&lt;/programlisting&gt;&lt;para&gt;
+        &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_textbox&quot;&gt;&lt;title&gt;typedef s3dw_textbox&lt;/title&gt;&lt;programlisting&gt;typedef struct _s3dw_textbox s3dw_textbox&lt;/programlisting&gt;&lt;para&gt;
+        &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_scrollbar&quot;&gt;&lt;title&gt;typedef s3dw_scrollbar&lt;/title&gt;&lt;programlisting&gt;typedef struct _s3dw_scrollbar s3dw_scrollbar&lt;/programlisting&gt;&lt;para&gt;
+        &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_input&quot;&gt;&lt;title&gt;typedef s3dw_input&lt;/title&gt;&lt;programlisting&gt;typedef struct _s3dw_input s3dw_input&lt;/programlisting&gt;&lt;para&gt;
+        &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_surface&quot;&gt;&lt;title&gt;typedef s3dw_surface&lt;/title&gt;&lt;programlisting&gt;typedef struct _s3dw_surface s3dw_surface&lt;/programlisting&gt;&lt;para&gt;
+        &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_style&quot;&gt;&lt;title&gt;typedef s3dw_style&lt;/title&gt;&lt;programlisting&gt;typedef struct _s3dw_style s3dw_style&lt;/programlisting&gt;&lt;para&gt;
+        &lt;/para&gt;&lt;/sect2&gt;&lt;sect2 id=&quot;s3dw_callback&quot;&gt;&lt;title&gt;typedef s3dw_callback&lt;/title&gt;&lt;programlisting&gt;typedef void(* s3dw_callback)(s3dw_widget *)&lt;/programlisting&gt;&lt;para&gt;
+&lt;/para&gt;&lt;para&gt;The callback type. Receive the widget which is affected as argument.&lt;/para&gt;&lt;programlisting&gt; // example
+ void my_handler(s3dw_widget *widget)
+ {
+         // do something with the widget
+         ...
+ }
+&lt;/programlisting&gt;&lt;para&gt;         &lt;/para&gt;&lt;/sect2&gt;
\ No newline at end of file

Modified: trunk/Documentation/s3d.docbook
===================================================================
--- trunk/Documentation/s3d.docbook	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/Documentation/s3d.docbook	2008-08-31 22:19:18 UTC (rev 980)
@@ -6,6 +6,12 @@
   &lt;!ENTITY server SYSTEM &quot;server/server.docbook&quot;&gt;
   &lt;!ENTITY libs3d SYSTEM &quot;libs3d/libs3d.docbook&quot;&gt;
   &lt;!ENTITY libs3dw SYSTEM &quot;libs3dw/libs3dw.docbook&quot;&gt;
+  &lt;!ENTITY libs3d_func SYSTEM &quot;libs3d/functions.docbook&quot;&gt;
+  &lt;!ENTITY libs3d_struct SYSTEM &quot;libs3d/structs.docbook&quot;&gt;
+  &lt;!ENTITY libs3d_typedef SYSTEM &quot;libs3d/typedefs.docbook&quot;&gt;
+  &lt;!ENTITY libs3dw_func SYSTEM &quot;libs3dw/functions.docbook&quot;&gt;
+  &lt;!ENTITY libs3dw_struct SYSTEM &quot;libs3dw/structs.docbook&quot;&gt;
+  &lt;!ENTITY libs3dw_typedef SYSTEM &quot;libs3dw/typedefs.docbook&quot;&gt;
 ]&gt;
 &lt;book id=&quot;s3d&quot; lang=&quot;en&quot;&gt;
 &bookinfo;

Added: trunk/Documentation/xml.doxygen
===================================================================
--- trunk/Documentation/xml.doxygen	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/Documentation/xml.doxygen	2008-08-31 22:19:18 UTC (rev 980)
@@ -0,0 +1,136 @@
+# Doxyfile 1.5.6
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+DOXYFILE_ENCODING      = UTF-8
+PROJECT_NAME           = libs3d
+PROJECT_NUMBER         = 0.2.1
+OUTPUT_DIRECTORY       = .
+CREATE_SUBDIRS         = NO
+OUTPUT_LANGUAGE        = English
+BRIEF_MEMBER_DESC      = YES
+REPEAT_BRIEF           = YES
+ABBREVIATE_BRIEF       = &quot;The $name class&quot; \
+                         &quot;The $name widget&quot; \
+                         &quot;The $name file&quot; \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+ALWAYS_DETAILED_SEC    = NO
+INLINE_INHERITED_MEMB  = NO
+FULL_PATH_NAMES        = YES
+STRIP_FROM_PATH        = 
+STRIP_FROM_INC_PATH    = 
+SHORT_NAMES            = NO
+JAVADOC_AUTOBRIEF      = NO
+QT_AUTOBRIEF           = NO
+MULTILINE_CPP_IS_BRIEF = NO
+DETAILS_AT_TOP         = NO
+INHERIT_DOCS           = YES
+SEPARATE_MEMBER_PAGES  = NO
+TAB_SIZE               = 3
+ALIASES                = 
+OPTIMIZE_OUTPUT_FOR_C  = YES
+OPTIMIZE_OUTPUT_JAVA   = NO
+OPTIMIZE_FOR_FORTRAN   = NO
+OPTIMIZE_OUTPUT_VHDL   = NO
+BUILTIN_STL_SUPPORT    = NO
+CPP_CLI_SUPPORT        = NO
+SIP_SUPPORT            = NO
+IDL_PROPERTY_SUPPORT   = YES
+DISTRIBUTE_GROUP_DOC   = NO
+SUBGROUPING            = YES
+TYPEDEF_HIDES_STRUCT   = NO
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+EXTRACT_ALL            = NO
+EXTRACT_PRIVATE        = NO
+EXTRACT_STATIC         = NO
+EXTRACT_LOCAL_CLASSES  = YES
+EXTRACT_LOCAL_METHODS  = NO
+EXTRACT_ANON_NSPACES   = NO
+HIDE_UNDOC_MEMBERS     = YES
+HIDE_UNDOC_CLASSES     = YES
+HIDE_FRIEND_COMPOUNDS  = NO
+HIDE_IN_BODY_DOCS      = NO
+INTERNAL_DOCS          = NO
+CASE_SENSE_NAMES       = YES
+HIDE_SCOPE_NAMES       = NO
+SHOW_INCLUDE_FILES     = YES
+INLINE_INFO            = YES
+SORT_MEMBER_DOCS       = YES
+SORT_BRIEF_DOCS        = NO
+SORT_GROUP_NAMES       = NO
+SORT_BY_SCOPE_NAME     = NO
+GENERATE_TODOLIST      = YES
+GENERATE_TESTLIST      = YES
+GENERATE_BUGLIST       = YES
+GENERATE_DEPRECATEDLIST= YES
+ENABLED_SECTIONS       = 
+MAX_INITIALIZER_LINES  = 30
+SHOW_USED_FILES        = NO
+SHOW_DIRECTORIES       = NO
+SHOW_FILES             = NO
+SHOW_NAMESPACES        = NO
+FILE_VERSION_FILTER    = 
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+QUIET                  = NO
+WARNINGS               = YES
+WARN_IF_UNDOCUMENTED   = YES
+WARN_IF_DOC_ERROR      = YES
+WARN_NO_PARAMDOC       = NO
+WARN_FORMAT            = &quot;$file:$line: $text&quot;
+WARN_LOGFILE           = 
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+INPUT                  = ../libs3d \
+                         ../libs3dw
+INPUT_ENCODING         = UTF-8
+FILE_PATTERNS          = *.c \
+                         *.h
+RECURSIVE              = NO
+EXCLUDE                = 
+EXCLUDE_SYMLINKS       = NO
+EXCLUDE_PATTERNS       = 
+EXCLUDE_SYMBOLS        = 
+EXAMPLE_PATH           = 
+EXAMPLE_PATTERNS       = *
+EXAMPLE_RECURSIVE      = NO
+IMAGE_PATH             = 
+INPUT_FILTER           = 
+FILTER_PATTERNS        = 
+FILTER_SOURCE_FILES    = NO
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+GENERATE_XML           = YES
+XML_OUTPUT             = xml
+XML_SCHEMA             = 
+XML_DTD                = 
+XML_PROGRAMLISTING     = NO
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+ENABLE_PREPROCESSING   = YES
+MACRO_EXPANSION        = NO
+EXPAND_ONLY_PREDEF     = NO
+SEARCH_INCLUDES        = YES
+INCLUDE_PATH           = 
+INCLUDE_FILE_PATTERNS  = 
+PREDEFINED             = 
+EXPAND_AS_DEFINED      = 
+SKIP_FUNCTION_MACROS   = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+SEARCHENGINE           = NO

Modified: trunk/libs3d/callback.c
===================================================================
--- trunk/libs3d/callback.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3d/callback.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -56,22 +56,58 @@
 	/* do plain nothing */
 	return(0);
 }
-/*  sets a callback */
+
+/**
+ * sets a callback for a certain event. this is very useful for event-oriented
+ * applications. event callbacks will not interrupt each other or the mainloop.
+ *
+ * \remarks Defining callbacks will only work after calling s3d_init()
+ *
+ * \code
+ * #include &lt;inttypes.h&gt;
+ *
+ * void obj_click(struct s3d_evt event)
+ * {
+ *         printf(&quot;object id %&quot;PRIu32&quot; got clicked&quot;, *((uint32_t *)event-&gt;buf));
+ * }
+ * ...
+ * s3d_set_callback(S3D_EVENT_NEW_OBJECT, obj_click);
+ * // this will tell you when a object got clicked
+ * \endcode
+ */
 void s3d_set_callback(uint8_t event, s3d_cb func)
 {
 	s3d_cb_list[(int)event] = func;
 	s3d_process_stack();
 }
-/*  clears a callback, same as s3d_set_callback(event, (s3d_cb) S3D_CBNIL); */
+
+/**
+ * Clears the callback which is associated with the event.
+ */
 void s3d_clear_callback(uint8_t event)
 {
 	s3d_cb_list[(int)event] = S3D_CBNIL;
 }
-/* ignores an event ... */
+
+/**
+ * Sets the callback on ignore, that means it won't be queued up for later use.
+ * An incoming event of this type will simply be skipped.
+ */
 void s3d_ignore_callback(uint8_t event)
 {
 	s3d_set_callback(event, _s3d_ignore);
 }
+
+/**
+ * Returns the Callback-function of the event.
+ *
+ * \code
+ * struct s3d_evt e;
+ * ...
+ * s3d_get_callback(S3D_EVENT_KEY)(e);
+ * // will call the key-handling function with argument e.
+ * \endcode
+ */
 s3d_cb s3d_get_callback(uint8_t event)
 {
 	return(s3d_cb_list[(int)event]);

Modified: trunk/libs3d/event.c
===================================================================
--- trunk/libs3d/event.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3d/event.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -29,6 +29,11 @@
 
 static struct s3d_evt *s3d_stack;
 int cb_lock = 2;  /*  callback lock */
+
+/**
+ * Pushes an event onto the event-stack. Usually you don't need to do this
+ * manually.
+ */
 void s3d_push_event(struct s3d_evt *newevt)
 {
 	struct s3d_evt *p;
@@ -56,12 +61,22 @@
 	} else
 		s3d_stack = newevt;
 }
+
+/**
+ * Pops the latest event from the stack. Don't forget to free() both the event
+ * and its buffer! Returns a pointer to struct s3d_evt.
+ */
 struct s3d_evt *s3d_pop_event(void) {
 	struct s3d_evt *ret;
 	if ((ret = s3d_stack) != NULL)
 		s3d_stack = s3d_stack-&gt;next;
 	return ret;
 }
+
+/**
+ * Finds the latest occurence of an event, giving the event type as argument.
+ * Returns a pointer to struct s3d_evt.
+ */
 struct s3d_evt *s3d_find_event(uint8_t event) {
 	struct s3d_evt *p;
 	p = s3d_stack;
@@ -72,6 +87,11 @@
 	}
 	return(NULL);
 }
+
+/**
+ * deletes an event, the argument is the pointer to the event which is to be
+ * deleted (maybe obtained from s3d_find_event).
+ */
 int s3d_delete_event(const struct s3d_evt *devt)
 {
 	struct s3d_evt *previous = NULL;
@@ -93,7 +113,14 @@
 	}
 	return(-1);
 }
-/*  this function checks the stack for callbacks. */
+
+/**
+ * This function goes through all function of the event-stack and will call
+ * functions. this is useful when you define a new function but still have a lot
+ * of events of this type on the stack.
+ *
+ * \deprecated This is probably obsolete
+ */
 void s3d_process_stack(void)
 {
 	struct s3d_evt *p;

Modified: trunk/libs3d/freetype.c
===================================================================
--- trunk/libs3d/freetype.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3d/freetype.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -301,6 +301,16 @@
 	*xoff += tess_buf[a].xoff;  /*  xoffset */
 	return(0);
 }
+
+/**
+ * This selects a font for the s3d_draw_string() function.
+ *
+ * \remarks Of course, you won't forget to toggle it visible, won't you?
+ *
+ * \code
+ * s3d_select_font(&quot;vera&quot;); // will use the vera font face
+ * \endcode
+ */
 int s3d_select_font(const char *path)
 {
 	char    *oldfont = memory_font;
@@ -337,7 +347,19 @@
 	return(-1);
 }
 
-/*  draws a simple string. */
+/**
+ * Renders the string str with in Truetype format with the height 1, returns the
+ * length of the rendered string in *xlen (or set len=NULL to disable this).
+ *
+ * \code
+ * char str=&quot;hello world!&quot;;
+ * float len;
+ * s3d_select_font(&quot;vera&quot;);
+ * s3d_draw_string(str, len);
+ *
+ * // not interested in the length? do that: s3d_draw_string(str, NULL);
+ * \endcode
+ */
 int s3d_draw_string(const char *str, float *xlen)
 {
 	int i;
@@ -366,7 +388,12 @@
 	if (xlen != NULL) *xlen = xoff;
 	return(f_oid);
 }
-/* get the string length before actually drawing it. */
+
+/**
+ * Returns the length of the string if it were rendered with the currently
+ * selected font. That might be useful to estimate the size used for a text and
+ * render the background or bounding box before inserting the text.
+ */
 float s3d_strlen(const char *str)
 {
 	int i;

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3d/io.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -64,6 +64,11 @@
 }
 
 #endif
+
+/**
+ * Prints the possible parameter for the client library (which can be passed in
+ * s3d_init())
+ */
 void s3d_usage(void)
 {
 	printf(&quot;s3d-parameters:\n&quot;);
@@ -110,6 +115,23 @@
 	return(0);
 }
 /*  external functions go here ... */
+/**
+ * This will initialize the s3d-library and the connection to the Server. It
+ * will return 0 on success in Server initializion. name specifies the your
+ * programs name.
+ *
+ * \code
+ * int main(char argc, char **argv)
+ * {
+ *         if (!s3d_init(&amp;argc, &amp;argv, &quot;Hello world&quot;))
+ *         {
+ *                 ...
+ *                 s3d_quit();
+ *         }
+ *         return(0);
+ * }
+ * \endcode
+ */
 int s3d_init(int *argc, char ***argv, const char *name)
 {
 	char     *s;
@@ -165,7 +187,11 @@
 	}
 	return(-1);
 }
-/*  shuts down the socket, clearing the stack */
+
+/**
+ * closes the connection and cleares the event-stack. it can also be used to
+ * leave the s3d_mainloop().
+ */
 int s3d_quit(void)
 {
 	struct s3d_evt *ret;
@@ -196,8 +222,23 @@
 	}
 	return(0);
 }
-/*  apps should use that as main loop for their programs. */
-int s3d_mainloop(void (*f)())
+
+/**
+ * takes a function as argument. it will loop this function until a quit-event
+ * is received. you can pass NULL if you have no function to be looped, but its
+ * better to sleep some time if you have nothing to do anyway to save cpu-time.
+ *
+ * \code
+ * void mainloop(void)
+ * {
+ *         usleep(1000); // sleep 1 ms in every cycle
+ * }
+ * ...
+ *
+ * s3d_mainloop(mainloop());
+ * \endcode
+ */
+int s3d_mainloop(void (*f)(void))
 {
 	while (con_type != CON_NULL) {
 		cb_lock++;   /* no callbacks while we are in mainloop */
@@ -208,8 +249,12 @@
 	}
 	return(0);
 }
-/*  opens a file returning it's filesize  */
-/*  and setting *pointer to the buffer. to be freed */
+
+/**
+ * This opens the file fname, setting *pointer to it's memory position. the
+ * function will return the size of buffer. you can free() the pointer when
+ * you're finished.
+ */
 int s3d_open_file(const char *fname, char **pointer)
 {
 	FILE *fp;

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3d/modelread.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -42,7 +42,13 @@
 
 #define MAXSTRN  20
 static int model_load(char *file);
-/*  just a helper function for reading from file instead of memory. */
+/**
+ * Imports an 3d object file and returns the object number. Quite a number of
+ * formats are supported, like 3D Studio (.3ds, .prj), Lightwave (.lw, .lwb,
+ * .lwo), Quake Models (.md3), or simply everything libg3d supports. :)
+ *
+ * \remarks Of course, you won't forget to toggle it visible, won't you?
+ */
 int s3d_import_model_file(const char *fname)
 {
 	char *buf, *ptr, *next;

Modified: trunk/libs3d/network.c
===================================================================
--- trunk/libs3d/network.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3d/network.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -65,6 +65,12 @@
 	return(_s3d_tcp_net_receive());
 }
 #endif
+/**
+ * This functions is for programs which do not employ a mainloop, hence they
+ * need to check for new events on their own. Programs like these must make sure
+ * to call this function from time to time to convince the server that they did
+ * not freeze or bail out.
+ */
 int s3d_net_check(void)
 {
 	switch (con_type) {

Modified: trunk/libs3d/proto_out.c
===================================================================
--- trunk/libs3d/proto_out.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3d/proto_out.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -37,7 +37,12 @@
 #endif
 
 #define MF_LEN 65530  /*  maximum fragmentation length */
-/*  creates a new object */
+
+/**
+ * Creates a new object, returning the object id.
+ *
+ * \remarks Of course, you won't forget to toggle it visible, won't you?
+ */
 int s3d_new_object(void)
 {
 	int oid;
@@ -47,7 +52,14 @@
 	cb_lock--; /* no new callbacks and nothing happened */
 	return(oid);
 }
-/*  clones an object */
+
+/**
+ * Clones an already exisiting object. They get just look the same as the
+ * parent-object and will change when the parent-object changes. Cloning
+ * especially makes sense if you want to use the same object a lot of times.
+ * Move and transform is independent from the parent. The function returns the
+ * childs object id.
+ */
 int s3d_clone(int oid)
 {
 	uint32_t res;
@@ -56,7 +68,10 @@
 	return(res);
 }
 
-/*  changes the target of a clone-object */
+/**
+ * Changes the clone target of oid to another object (toid). This assumes you've
+ * got oid from s3d_clone before.
+ */
 int s3d_clone_target(int oid, int toid)
 {
 	uint32_t buf[2];
@@ -66,15 +81,23 @@
 	/*  s3dprintf(MED,&quot;... changed clone-target of object %d to %d&quot;, oid, toid); */
 	return oid;
 }
-/*  deletes an object */
+
+/**
+ * Deletes the object referenced by oid.
+ */
 int s3d_del_object(int oid)
 {
 	uint32_t res = htonl(oid);
 	net_send(S3D_P_C_DEL_OBJ, (char *)&amp;res, 4);
 	return oid;
 }
-/*  creates a link from object oid_from to object oid_to in order to copy */
-/*  translations/rotations */
+
+/**
+ * A linked object will move along with it's link parent. For example if you
+ * have a book on a table, you can link the book to the table so the book will
+ * &quot;keep on the table&quot; if you move the table around in space. It will also
+ * rotate with the table etc.
+ */
 int s3d_link(int oid_from, int oid_to)
 {
 	uint32_t buf[2];
@@ -83,7 +106,10 @@
 	net_send(S3D_P_C_LINK, (char *)buf, 8);
 	return(0);
 }
-/*  remove the link to another object */
+
+/**
+ * Remove the link of object oid to its target.
+ */
 int s3d_unlink(int oid)
 {
 	uint32_t buf;
@@ -93,7 +119,11 @@
 }
 /*  pushing functions */
 
-/*  has float always the same size? i'm not quite sure ... */
+/**
+ * pushes a vertex onto the vertex stack. make sure that you count how many
+ * vertices you've pushed because you'll need that for referencing when you push
+ * your polygons.
+ */
 int s3d_push_vertex(int object, float x, float y, float z)
 {
 	char    buf[4+3*4], *ptr;
@@ -111,8 +141,18 @@
 	net_send(S3D_P_C_PUSH_VERTEX, buf, len);
 	return(0);
 }
-/*  like vertex add, but you can add a lot of vertices with this. */
-/*  it's to be used for file readers or fast coders :) */
+
+/**
+ * push some vertices from an array. that's much better for performing than
+ * using s3d_push_vertex() if you have a lot of vertices (and that's probably
+ * the usual case).
+ * \code
+ * float vertices[] = { 0.0, 0.0, 0.0,
+ *                      1.0, 2.0, 3.0,
+ *                      3.0, 2.0, 1.0};
+ * s3d_push_vertices(object, vertices, 3); // pushing 3 vertices
+ * \endcode
+ */
 int s3d_push_vertices(int object, const float *vbuf, uint16_t n)
 {
 	char    buf[MF_LEN+4], *ptr;
@@ -138,8 +178,15 @@
 	return(0);
 }
 
-/*  pushes a new material onto the stack */
-/*  a vectored version of this would be wise ... */
+/**
+ * pushes a material for an object. you will have to count them yourself too,
+ * as polygons will ask for the material index number. the material properties
+ * are given in rgb (red/green/blue) color codes, in float. 0.0 is the minimum,
+ * 1.0 is the maximum a color value can be. the specular color is the color
+ * which is directly reflected from the light source. the diffuse color is the
+ * color which can be seen in the bright side of the object, and the ambience
+ * color is the color of the shadow side of the object.
+ */
 int s3d_push_material(int object,
                       float amb_r, float amb_g, float amb_b,
                       float spec_r, float spec_g, float spec_b,
@@ -181,7 +228,11 @@
 	net_send(S3D_P_C_PUSH_MAT, buf, len);
 	return(0);  /*  nothing yet */
 }
-/*  same as s3d_push_material, but with values for alpha */
+
+/**
+ * Same as s3d_push_material, but color has alpha value added. Use
+ * s3d_push_materials_a() if you have a lot of materials to push.
+ */
 int s3d_push_material_a(int object,
                         float amb_r, float amb_g, float amb_b, float amb_a,
                         float spec_r, float spec_g, float spec_b, float spec_a,
@@ -223,7 +274,31 @@
 	net_send(S3D_P_C_PUSH_MAT, buf, len);
 	return(0);  /*  nothing yet */
 }
-/*  push a material array (with alpha information!) */
+
+/**
+ * Pushes a buffer of Materials. Those Materials are in the format float[n*12],
+ * with
+ * - mbuf[n*12 + 0-3] - ambience
+ * - mbuf[n*12 + 4-7] - specular
+ * - mbuf[n *12 + 8-11] - diffusion values
+ *
+ * of each entry. n is the number of materials pushed. The values are in the
+ * order r,g,b,a. If you only want to push one material, use the more easy
+ * s3d_push_material_a() function.
+ *
+ * \code
+ * // each line has r,g,b,a value
+ * float bla[24]=
+ *         {1, 0, 0, 1,
+ *          1, 0, 0, 1,
+ *          1, 0, 0, 1,
+ *          0, 1, 1, 1,
+ *          0, 1, 1, 1,
+ *          0, 1, 1, 1};
+ *
+ * s3d_push_materials_a(object, mbuf, 2); // push a red and a cyan material
+ * \endcode
+ */
 int s3d_push_materials_a(int object, const float *mbuf, uint16_t n)
 {
 	char    buf[MF_LEN+4], *ptr;
@@ -248,6 +323,21 @@
 	/*  free(buf); */
 	return(0);
 }
+
+/**
+ * push one polygon on the polygonstack of the object. it takes 3 vertex-index
+ * numbers and one material material-index-nr. as argument.
+ *
+ * \code
+ * int oid = s3d_new_object();   // create a new object
+ * s3d_push_vertex(oid, 0.0, 0.0, 0.0);
+ * s3d_push_vertex(oid, 0.0, 1.0, 0.0);
+ * s3d_push_vertex(oid, 1.0, 0.0, 0.0);
+ * s3d_push_material(oid, 0.3, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0);
+ * s3d_push_polygon(oid, 0, 1, 2, 0);
+ * // this will create a red polygon
+ * \endcode
+ */
 int s3d_push_polygon(int object, uint32_t v1, uint32_t v2, uint32_t v3, uint32_t material)
 {
 	char    buf[4+4*4], *ptr;
@@ -267,6 +357,12 @@
 	net_send(S3D_P_C_PUSH_POLY, buf, len);
 	return(0);
 }
+
+/**
+ * Push one line on the linestack of the object. It takes 2 vertex-index-
+ * numbers and one material material-index-nr. as argument. If you have a lot of
+ * lines to push, use s3d_push_lines()
+ */
 int s3d_push_line(int object, uint32_t v1, uint32_t v2, uint32_t material)
 {
 	char    buf[4+3*4], *ptr;
@@ -285,8 +381,20 @@
 	return(0);
 }
 
-/*  this is the polygon array version */
-/*  assumes to have a list of polys which consists of v1,v2,v3,material */
+/**
+ * as for vertices, you can push arrays of polygons to have greater performance. the pbuf should contain n polygons which consist of 4 uint32_t values of 3 vertices indices and 1 material index.
+ *
+ * \code
+ * uint32_t pbuf[] = { 0, 1, 2, 0};
+ * int oid = s3d_new_object();   // create a new object
+ * s3d_push_vertex(oid, 0.0, 0.0, 0.0);
+ * s3d_push_vertex(oid, 0.0, 1.0, 0.0);
+ * s3d_push_vertex(oid, 1.0, 0.0, 0.0);
+ * s3d_push_material(oid, 0.3, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0);
+ * s3d_push_polygons(oid, pbuf, 1);
+ * // push one polygon with the pbuf data
+ * \endcode
+ */
 int s3d_push_polygons(int object, const uint32_t *pbuf, uint16_t n)
 {
 	uint32_t  buf[(MF_LEN+4)/4];
@@ -312,6 +420,12 @@
 	}
 	return(0);
 }
+
+/**
+ * Pushing n lines on the linestack of the object, each lbuf has a size of n*3,
+ * each entry has the index number of the first vertex, second vertex and
+ * material number just as in s3d_push_line().
+ */
 int s3d_push_lines(int object, const uint32_t *lbuf, uint16_t n)
 {
 	uint32_t  buf[(MF_LEN+4)/4];
@@ -339,6 +453,10 @@
 	}
 	return(0);
 }
+
+/**
+ * Adds a new texture with height w and height h on the texturestack.
+ */
 int s3d_push_texture(int object, uint16_t w, uint16_t h)
 {
 	char    buf[4+2*2], *ptr;
@@ -353,6 +471,12 @@
 	net_send(S3D_P_C_PUSH_TEX, buf, len);
 	return(0);
 }
+
+/**
+ * As for vertices, you can push arrays of textures on the texture stack to have
+ * greater performance. The tbuf should contain n texture sizes which consist of
+ * 2 uint16_t values for width and height for each texture.
+ */
 int s3d_push_textures(int object, const uint16_t *tbuf, uint16_t n)
 {
 	uint32_t  buf[(MF_LEN+4)/4];
@@ -382,7 +506,9 @@
 }
 /*  popping functions  */
 
-/*  delete n vertices */
+/**
+ * Deletes the latest n vertices from the vertex stack of the object.
+ */
 int s3d_pop_vertex(int object, uint32_t n)
 {
 	uint32_t  buf[2];
@@ -392,7 +518,10 @@
 	return(0);
 
 }
-/*  delete n materials */
+
+/**
+ * Deletes the latest n material from the material stack of the object.
+ */
 int s3d_pop_material(int object, uint32_t n)
 {
 	uint32_t  buf[2];
@@ -402,7 +531,10 @@
 	return(0);
 
 }
-/*  delete n polygons */
+
+/**
+ * Deletes the latest n polygon from the polygon stack of the object.
+ */
 int s3d_pop_polygon(int object, uint32_t n)
 {
 	uint32_t  buf[2];
@@ -412,7 +544,10 @@
 	return(0);
 
 }
-/*  delete n lines */
+
+/**
+ * Deletes the latest n lines from the line stack of the object.
+ */
 int s3d_pop_line(int object, uint32_t n)
 {
 	uint32_t  buf[2];
@@ -422,7 +557,10 @@
 	return(0);
 
 }
-/*  delete n polygons */
+
+/**
+ * Deletes the latest n textures from the texture stack of the object.
+ */
 int s3d_pop_texture(int object, uint32_t n)
 {
 	uint32_t  buf[2];
@@ -434,7 +572,10 @@
 }
 /*  pepping/loading functions */
 
-/*  overwrites the last material with this one */
+/**
+ * Overwriting the latest pushed Material, overwriting the current value with
+ * the specified one. See s3d_pep_materials_a if you want to pep more materials.
+ */
 int s3d_pep_material(int object,
                      float amb_r, float amb_g, float amb_b,
                      float spec_r, float spec_g, float spec_b,
@@ -476,7 +617,12 @@
 	net_send(S3D_P_C_PEP_MAT, buf, len);
 	return(0);  /*  nothing yet */
 }
-/*  same as above, with alpha */
+
+/**
+ * Overwriting the latest pushed Material, overwriting the current value with
+ * the specified one, with alpha value in contrast to s3d_pep_material See
+ * s3d_push_materials_a if you want to pep more materials.
+ */
 int s3d_pep_material_a(int object,
                        float amb_r, float amb_g, float amb_b, float amb_a,
                        float spec_r, float spec_g, float spec_b, float spec_a,
@@ -518,6 +664,12 @@
 	net_send(S3D_P_C_PEP_MAT, buf, len);
 	return(0);  /*  nothing yet */
 }
+
+/**
+ * Alters the last n pushed Materials. See s3d_push_materials_a() for more
+ * information how mbuf should look like. Use s3d_pep_material_a() if you only
+ * want to alter the latest material.
+ */
 int s3d_pep_materials_a(int object, const float *mbuf, uint16_t n)
 {
 	char    buf[MF_LEN+4];
@@ -531,7 +683,17 @@
 	return(0);
 }
 
-/*  adds normal information to the last n polygons. */
+/**
+ * Adds normal information to polygons, giving each vertex of a polygon a normal
+ * information. With this, you can achieve smoothed edge effects.
+ *
+ * nbuf should contain n * 9 float values, for each vertex a normal vector
+ * (x,y,z), and you have 3 Vertices for each Polygon so that makes 9 float
+ * values per Polygon in Total. Don't worry if you don't use this, it's kind of
+ * hard to calculate and the server will always use some proper normal values
+ * (same for every vertex, calculated by the plane which is defined by the 3
+ * points of the polygon.
+ */
 int s3d_pep_polygon_normals(int object, const float *nbuf, uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
@@ -545,7 +707,16 @@
 	return(0);
 
 }
-/*  adds normal information to the last n line. */
+
+/**
+ * Adds normal information to lines, giving each vertex of a line a normal
+ * information. This makes lines somewhat nicer, you'll need that especially
+ * when you're going to build wireframe models.
+ *
+ * nbuf should contain n * 6 float values, for each vertex a normal vector
+ * (x,y,z), and you have 2 Vertices for each line so that makes 6 float values
+ * per line in Total.
+ */
 int s3d_pep_line_normals(int object, const float *nbuf, uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
@@ -559,7 +730,10 @@
 	return(0);
 
 }
-/*  replaces the last vertex. */
+
+/**
+ * Alter the latest pushed vertex, overwriting with the supplied values.
+ */
 int s3d_pep_vertex(int object, float x, float y, float z)
 {
 	char    buf[4+3*4], *ptr;
@@ -577,7 +751,10 @@
 	net_send(S3D_P_C_PEP_VERTEX, buf, len);
 	return(0);
 }
-/* replaces the last line */
+
+/**
+ * Alter the latest pushed line, overwriting with the supplied values.
+ */
 int s3d_pep_line(int object, int v1, int v2, int material)
 {
 	char    buf[4+3*4], *ptr;
@@ -597,7 +774,11 @@
 }
 
 
-/*  replaces the last n lines. */
+/**
+ * Alter the latest n pushed lines. lbuf holds the values which are used to
+ * overwrite the old data, n entries with each 3 uint32_t specifying first,
+ * second vertex and material of each line.
+ */
 int s3d_pep_lines(int object, const uint32_t *lbuf, uint16_t n)
 {
 	uint32_t  buf[MF_LEN+4];
@@ -613,7 +794,12 @@
 	return(0);
 
 }
-/*  replaces the last n vertices. */
+
+/**
+ * Alter the latest n pushed vertex. vbuf holds the values which are used to
+ * overwrite the old data, n entries with each 3 floats specifying x,y,z of the
+ * vertices.
+ */
 int s3d_pep_vertices(int object, const float *vbuf, uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
@@ -627,7 +813,14 @@
 	return(0);
 
 }
-/*  peps the last polygon with some texture coords */
+
+/**
+ * Pimp the last polygon pushed with some textures coordinates, x and y values
+ * for each vertex point respectively. Those values may be between 0 and 1 and
+ * are vertex points on the  texture defined in the material of the polygon. If
+ * you have more polygons which should get a texture, use
+ * s3d_pep_polygon_tex_coords()
+ */
 int s3d_pep_polygon_tex_coord(int object, float x1, float y1, float x2, float y2, float x3, float y3)
 {
 	char *ptr, buf[4*6+4];
@@ -649,7 +842,12 @@
 	net_send(S3D_P_C_PEP_POLY_TEXC, (char *)buf, 6*4 + 4);
 	return(0);
 }
-/*  adds texture coordinates to the last n polygons. */
+
+/**
+ * Pimp the latest n polygons with texture coordinates. tbuf has 6*n float
+ * values for its entries, which are supplied in the order as in
+ * s3d_pep_polygon_tex_coord()
+ */
 int s3d_pep_polygon_tex_coords(int object, const float *tbuf, uint16_t n)
 {
 	char buf[MF_LEN+4];
@@ -662,7 +860,11 @@
 	net_send(S3D_P_C_PEP_POLY_TEXC, (char *)buf, n*6*sizeof(float) + 4);
 	return(0);
 }
-/*  adds normal information to the last n polygons. */
+
+/**
+ * Just as s3d_pep_polygon_normals(), with the difference you won't alter the
+ * latest n polygons but n polygons starting with index start.
+ */
 int s3d_load_polygon_normals(int object, const float *nbuf, uint32_t start, uint16_t n)
 {
 	char    buf[MF_LEN+4], *ptr;
@@ -690,7 +892,11 @@
 	}
 	return(0);
 }
-/*  adds normal information to the last n polygons. */
+
+/**
+ * Just as s3d_pep_line_normals(), with the difference you won't alter the
+ * latest n lines but n lines starting with index start.
+ */
 int s3d_load_line_normals(int object, const float *nbuf, uint32_t start, uint16_t n)
 {
 	char    buf[MF_LEN+4], *ptr;
@@ -718,7 +924,11 @@
 	}
 	return(0);
 }
-/*  adds texture coordinates to the last n polygons. */
+
+/**
+ * Just as s3d_pep_polygon_tex_coords(), with the difference you won't alter the
+ * latest n polygons but n polygons starting with index start.
+ */
 int s3d_load_polygon_tex_coords(int object, const float *tbuf, uint32_t start, uint16_t n)
 {
 	char    buf[MF_LEN+4], *ptr;
@@ -746,7 +956,11 @@
 	}
 	return(0);
 }
-/*  load n materials at position start, overwriting old ones */
+
+/**
+ * Loads n materials starting from index position start into the Material stack.
+ * See s3d_push_materials_a for more informatino about the values in mbuf.
+ */
 int s3d_load_materials_a(int object, const float *mbuf, uint32_t start, uint16_t n)
 {
 	char    buf[MF_LEN+4], *ptr;
@@ -774,6 +988,11 @@
 	}
 	return(0);
 }
+
+/**
+ * Assign the latest material a texture referenced by the index tex. Of course,
+ * you will have pushed this texture with s3d_push_texture()
+ */
 int s3d_pep_material_texture(int object, uint32_t tex)
 {
 	char    buf[4*2], *ptr;
@@ -805,7 +1024,12 @@
 	return(0);
 
 }
-/*  load data (which has width w and height h) into object, texture tex at position (xpos,ypos) */
+
+/**
+ * Creates a new object, returning the object id.
+ *
+ * \remarks Of course, you won't forget to toggle it visible, won't you?
+ */
 int s3d_load_texture(int object, uint32_t tex, uint16_t xpos, uint16_t ypos, uint16_t w, uint16_t h, const uint8_t *data)
 {
 	char    buf[MF_LEN+4], *ptr;
@@ -839,6 +1063,13 @@
 	}
 	return(0);
 }
+
+/**
+ * turn some flags on for object.
+ *
+ * \remarks If you don't toggle OF_VISIBLE on, you won't see your object. usually
+ * you want this. (at least after you *push()d all your content)
+ */
 int s3d_flags_on(int object, uint32_t flags)
 {
 	char    buf[4+1+4], *ptr;
@@ -854,6 +1085,10 @@
 	net_send(S3D_P_C_TOGGLE_FLAGS, buf, len);
 	return(0);
 }
+
+/**
+ * turn some flags off for object.
+ */
 int s3d_flags_off(int object, uint32_t flags)
 {
 	char    buf[4+1+4], *ptr;
@@ -869,6 +1104,19 @@
 	net_send(S3D_P_C_TOGGLE_FLAGS, buf, len);
 	return(0);
 }
+
+/**
+ * Move the object to some position in space. when you create an object, it's
+ * always located at 0.0 , 0.0, 0.0.
+ *
+ * \remarks Translation is absolute, not relative!
+ *
+ * \code
+ * s3d_translate(object, 2, 0, 0);
+ * s3d_translate(object, 4, 0, 0);
+ * // object will end up at 4,0,0 and not 6,0,0!!
+ * \endcode
+ */
 int s3d_translate(int object, float x, float y, float z)
 {
 	char    buf[4+4*3], *ptr;
@@ -886,7 +1134,26 @@
 	return(0);
 
 }
-/*  rotation about the x-axis, y-axis and z-axis */
+
+/**
+ * rotate an object around the x, y and z-axis respectively. x,y,z may have
+ * values between [0,360] degrees.
+ *
+ * You will usually only rotate around one axis, leaving the unused fields on 0,
+ * I guess. If you want to rotate around more than one axis, please note: The
+ * order of the rotation applies is y-axis, x-axis, and then z-axis. You can
+ * think of it as the earth position coordinates: x is the longitude, y is the
+ * latitude, and z is the rotation at this point of the earth around your bodies
+ * axis. (I wonder if that makes it any clearer ;)
+ *
+ * \remarks Rotate is absolute, not relative!
+ *
+ * \code
+ * s3d_rotate(object, 90,  0, 0);
+ * s3d_rotate(object, 180, 0, 0);
+ * // object will be rotated 180 degrees around the x-axis, not 270 degress!
+ * \endcode
+ */
 int s3d_rotate(int object, float x, float y, float z)
 {
 	char    buf[4+4*3], *ptr;
@@ -903,8 +1170,14 @@
 	net_send(S3D_P_C_ROTATE, buf, len);
 	return(0);
 }
-/*  scale the object .. */
 
+/**
+ * Scales the object. about factor s. s=1 will be the original size, -1 will
+ * mirror it.
+ *
+ * \remarks s=0 is forbidden and will be ignored! s3d_scale is also absolute,
+ * not relative!
+ */
 int s3d_scale(int object, float s)
 {
 	char    buf[4+4], *ptr;
@@ -916,7 +1189,11 @@
 	net_send(S3D_P_C_SCALE, buf, len);
 	return(0);
 }
-/*  sets the focused app through it's mcp object number */
+
+/**
+ * This is an mcp-only function. It gives focus (for receiving key-strokes etc.)
+ * to an app referenced by it's mcp-object-id.
+ */
 int s3d_mcp_focus(int object)
 {
 	uint32_t buf = htonl(object);

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3d/s3d.h	2008-08-31 22:19:18 UTC (rev 980)
@@ -21,6 +21,8 @@
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
+
+
 #ifndef LIBS3D_H
 #define LIBS3D_H
 
@@ -32,13 +34,23 @@
 
 #include &lt;stdint.h&gt;  /* [u]intXX_t type definitions*/
 /* definitions */
+
+/**
+ * This is the event information holder.
+ */
 struct s3d_evt {
-	uint8_t event;
-	int length;
-	char *buf;
-	struct s3d_evt *next;
+	uint8_t event; /**&lt; gives the event type */
+	int length; /**&lt; gives the length of the buffer *buf */
+	char *buf; /**&lt; is the pointer to the multiple purpose buffer,
+             *  which will have more specific information about the object */
+	struct s3d_evt *next; /**&lt; can be safely ignored ;) */
 };
 
+/**
+ * This defines the callback format. Each callback should return void and take
+ * an argument of struct s3d_evt *. Callbacks can be defined with
+ * s3d_set_callback().
+ */
 typedef int (*s3d_cb)(struct s3d_evt *);
 
 #define S3D_EVENT_OBJ_CLICK  1
@@ -60,6 +72,10 @@
 #define S3D_OF_VISIBLE   0x00000001
 #define S3D_OF_SELECTABLE  0x00000002
 #define S3D_OF_POINTABLE  0x00000004
+
+/**
+ *  \deprecated don't use, to be removed soon (use struct s3d_but_info). ;)
+ */
 struct mcp_object {
 	uint32_t object;
 	float trans_x, trans_y, trans_z;
@@ -67,6 +83,16 @@
 #define MCP_NEW_OBJECT 1
 	char name[256];
 };
+/**
+ * Can be used on the buffer of an event of type S3D_EVENT_OBJ_INFO. name will
+ * usually contain nothing for usual objects, but mcp objects will contain the
+ * applications names here. r is the radius of the convex sphere an object,
+ * which will also be interesting for the mcp.
+ *
+ * Special objects like camera, pointer will have the &quot;sys_&quot; prefix in the name
+ * and will be named &quot;pointer0&quot;, &quot;pointer1&quot; ... or &quot;cam0&quot;, &quot;cam1&quot; ... For cam
+ * object, scale will contain the aspect ratio.
+ */
 struct s3d_obj_info {
 	uint32_t object;
 	uint32_t flags;
@@ -76,6 +102,10 @@
 	float r;
 	char name[256];
 };
+
+/**
+ * Can be used on the buffer of an event of type S3D_EVENT_MBUTTON.
+ */
 struct s3d_but_info {
 	uint8_t button; /* 0 = left, 1 = middle, 2 = right */
 	uint8_t state;  /* 0 = down, 1 = up, 2 = moving */
@@ -96,7 +126,7 @@
 	S3DEXPORT void s3d_usage(void);
 	S3DEXPORT int s3d_init(int *argc, char ***argv, const char *name);
 	S3DEXPORT int s3d_quit(void);
-	S3DEXPORT int s3d_mainloop(void (*f)(void));
+	S3DEXPORT int s3d_mainloop(void(*f)(void));
 
 	/* object manipulations */
 	S3DEXPORT int s3d_push_vertex(int object, float x, float y, float z);

Modified: trunk/libs3d/vector.c
===================================================================
--- trunk/libs3d/vector.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3d/vector.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -26,16 +26,11 @@
 #include &lt;math.h&gt;  /* sqrt() */
 #include &quot;s3d.h&quot;
 
-/***
- *
- * calculate length of a vector =&gt; <A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Length_of_a_vector">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Length_of_a_vector</A>
- *
- *   vector   =&gt;   given vector
- *
- *   return length
- *
- ***/
-
+/**
+ * Calculates and returns the length of the given vector (which should be of the
+ * type float[3]). More info on wikipedia
+ * <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)
+ */
 float s3d_vector_length(const float vector[])
 {
 
@@ -43,17 +38,11 @@
 
 }
 
-
-/***
- *
- * substract vector1 from vector2 =&gt; <A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction</A>
- *
- *   vector1         =&gt;   given vector1
- *   vector2         =&gt;   given vector2
- *   result_vector   =&gt;   save resulting vector here
- *
- ***/
-
+/**
+ * Subtracts vector1 from vector2, writing result into result_vector. All vectors
+ * should have the format float[3]. More info on wikipedia.
+ * <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)
+ */
 void s3d_vector_subtract(const float vector1[], const float vector2[], float result_vector[])
 {
 
@@ -63,52 +52,35 @@
 
 }
 
-/***
- *
- * calculate dot product of 2 vectors =&gt; <A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product</A>
- *
- *   vector1   =&gt;   given vector1
- *   vector2   =&gt;   given vector2
- *
- *   return dot product
- *
- ***/
-
+/**
+ * Calculates and returns the dot product of vector1 and vector2. All vectors
+ * should have the format float[3]. More info on wikipedia.
+ * <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)
+ */
 float s3d_vector_dot_product(const float vector1[], const float vector2[])
 {
 	return (vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2]);
 }
 
-/***
- *
- * calculate cross product of 2 vectors =&gt; <A HREF="http://en.wikipedia.org/wiki/Cross_product">http://en.wikipedia.org/wiki/Cross_product</A>
- *
- *   vector1         =&gt;   given vector1
- *   vector2         =&gt;   given vector2
- *  result_vector   =&gt;   save resulting vector here
- *   return dot product
- *
- ***/
-
+/**
+ * Calculates and returns the cross product of vector1 and vector2. All vectors
+ * should have the format float[3]. More info on wikipedia.
+ * <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)
+ */
 void s3d_vector_cross_product(const float vector1[], const float vector2[], float result_vector[])
 {
 	result_vector[0] = vector1[1] * vector2[2] - vector1[2] * vector2[1];
 	result_vector[1] = vector1[2] * vector2[0] - vector1[0] * vector2[2];
 	result_vector[2] = vector1[0] * vector2[1] - vector1[1] * vector2[0];
 }
-/***
- *
- * calculate angle between 2 vectors =&gt; <A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product</A>
- *
- *   vector1   =&gt;   given vector1
- *   vector2   =&gt;   given vector2
- *
- *   return angle
- *
- *   NOTE: angle is between 0 and PI, therefore not covering the whole period!
- *
- ***/
 
+/**
+ * Calculates and returns the angle between vector1 and vector2. Please note that
+ * the resulting angle is between 0 and PI, therefore not covering the whole
+ * period! To convert in degrees just do result*180/M_PI. All vectors should
+ * have the format float[3]. More info on wikipedia.
+ * <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)
+ */
 float s3d_vector_angle(const float vector1[], const float vector2[])
 {
 
@@ -116,18 +88,13 @@
 
 }
 
-/***
- *
- * rotate e.g. description text so that it is always readable
- *
- *   obj_id    =&gt;   id of object
- *   obj_pos   =&gt;   position vector (x,y,z) of object
- *   cam_pos   =&gt;   position vector (x,y,z) of camera
- *
- *   return degree to rotate
- *
- ***/
-
+/**
+ * Given obj_pos and cam_pos in the format float[3], angle_rad about which angle
+ * the object should be rotated around the y-axis so that it faces the camera.
+ * This might become handy if you have some text floating in space and want it
+ * to face the camera.
+ * <A HREF="http://en.wikipedia.org/wiki/Vector_(spatial">http://en.wikipedia.org/wiki/Vector_(spatial</A>)
+ */
 float s3d_angle_to_cam(const float obj_pos[], const float cam_pos[], float *angle_rad)
 {
 

Modified: trunk/libs3dw/animate.c
===================================================================
--- trunk/libs3dw/animate.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3dw/animate.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -143,7 +143,24 @@
 
 }
 
-/* doing the whole animation thing */
+/**
+ * Just call this in your mainloop if you want some nice window sliding
+ * animations. it's somewhat bloating, but you don't want to miss it ;)
+ *
+ * \code
+ * #include &lt;time.h&gt;   // nanosleep()
+ * static struct timespec t={0.33*1000*1000}; // 33 mili seconds
+ * void mainloop()
+ * {
+ *         // keep this in your mainloop. this will do smooth animations for you ...
+ *         s3dw_ani_mate();
+ *         nanosleep(&amp;t,NULL);
+ * }
+ *
+ * ....
+ * s3d_mainloop(mainloop);
+ * \endcode
+ */
 void s3dw_ani_mate(void)
 {
 	int i;

Modified: trunk/libs3dw/button.c
===================================================================
--- trunk/libs3dw/button.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3dw/button.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -86,7 +86,12 @@
 	widget-&gt;height = 2;
 }
 
-/* create a new button in the surface */
+/**
+ * Creates a new button on the surface, with &quot;text&quot; written on it and the upper
+ * left corner at (posx,posy) on the surface.
+ *
+ * See s3dw_button for information about callbacks which may be defined.
+ */
 s3dw_button *s3dw_button_new(const s3dw_surface *surface, const char *text, float posx, float posy)
 {
 	s3dw_button *button;

Modified: trunk/libs3dw/event.c
===================================================================
--- trunk/libs3dw/event.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3dw/event.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -25,17 +25,66 @@
 #include &lt;s3dw.h&gt;
 #include &lt;s3dw_int.h&gt;
 
+/**
+ * If you want your widgets on mouseclicks (believe me, you want that), you have
+ * to call this either in your clickhandler-function or specifiy it itself as
+ * the clickhandler.
+ *
+ * \code
+ * // way 1:
+ * s3d_set_callback(S3D_EVENT_OBJ_CLICK,s3dw_handle_click);
+ *
+ * // way 2:
+ * ...
+ * void click(struct s3d_evt *evt)
+ * {
+ *         s3dw_handle_click(evt);
+ *         ....
+ *         // your own clickhandler code
+ *         ...
+ * }
+ * ....
+ * s3d_set_callback(S3D_EVENT_OBJ_CLICK,click);
+ * \endcode
+ */
 int s3dw_handle_click(const struct s3d_evt *evt)
 {
 	uint32_t oid = *((uint32_t *)evt-&gt;buf);
 	return(s3dw_widget_event_click(s3dw_getroot(), oid));
 }
+
+/**
+ * This is somehow useful to call in your keyhandler functions if you want to
+ * have input-boxes work. ;)
+ *
+ * \code
+ * // way 1:
+ * s3d_set_callback(S3D_EVENT_KEY,s3dw_handle_key);
+ *
+ * // way 2:
+ * ...
+ * void key(struct s3d_evt *evt)
+ * {
+ *         s3dw_handle_key(evt);
+ *         ....
+ *         // your own keyhandler code
+ *         ...
+ * }
+ * ....
+ * s3d_set_callback(S3D_EVENT_KEY,key);
+ * \endcode
+ */
 int s3dw_handle_key(const struct s3d_evt *evt)
 {
 	struct s3d_key_event *keys = (struct s3d_key_event *)evt-&gt;buf;
 	return(s3dw_widget_event_key(s3dw_getroot(), keys));
 }
 
+/**
+ * This can be used to let s3dw handle S3D_EVENT_OBJ_INFO-events. With this,
+ * s3dw can consider the camera position and makes things like following the
+ * camera possible.
+ */
 int s3dw_object_info(struct s3d_evt *evt)
 {
 	struct s3d_obj_info *info = (struct s3d_obj_info *)evt-&gt;buf;

Modified: trunk/libs3dw/input.c
===================================================================
--- trunk/libs3dw/input.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3dw/input.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -137,7 +137,15 @@
 	s3d_flags_off(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 	s3d_flags_off(input-&gt;oid_text, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
-/* create a new input in the surface */
+
+/**
+ * Creates a new input-box on the surface with a input width of &quot;width&quot;, the
+ * upper left corner at (posx,posy) on the surface. The input-box is empty on
+ * creation and can be change with s3dw_input_change_text, and received with
+ * s3dw_input_gettext
+ *
+ * See s3dw_input for information about callbacks which may be defined.
+ */
 s3dw_input *s3dw_input_new(const s3dw_surface *surface, float width, float posx, float posy)
 {
 	s3dw_input *input;
@@ -172,7 +180,10 @@
 	free(input-&gt;text);
 	free(input);
 }
-/* changes the text of the input */
+
+/**
+ * Change the text in the referenced input-box to the specified text.
+ */
 void s3dw_input_change_text(s3dw_input *input, const char *text)
 {
 	s3dw_widget *widget = (s3dw_widget *)input;
@@ -232,6 +243,10 @@
 	}
 	return(0);
 }
+
+/**
+ * Returns the text which is currently entered in the referenced input-box.
+ */
 char *s3dw_input_gettext(s3dw_input *input)
 {
 	return(strdup(input-&gt;text));

Modified: trunk/libs3dw/label.c
===================================================================
--- trunk/libs3dw/label.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3dw/label.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -49,7 +49,10 @@
 {
 	s3d_flags_off(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
-/* change label text */
+
+/**
+ * Change the text in the referenced label to the specified text.
+ */
 void s3dw_label_change_text(s3dw_label *label, const char *text)
 {
 	s3dw_widget *widget = (s3dw_widget *)label;
@@ -63,8 +66,12 @@
 		s3dw_label_show(widget);
 }
 
-
-/* create a new label in the surface */
+/**
+ * Creates a new label on the surface, with &quot;text&quot; written on it and the upper
+ * left corner at (posx,posy) on the surface.
+ *
+ * See s3dw_label for information about callbacks which may be defined.
+ */
 s3dw_label *s3dw_label_new(const s3dw_surface *surface, const char *text, float posx, float posy)
 {
 	s3dw_label *label;

Modified: trunk/libs3dw/root.c
===================================================================
--- trunk/libs3dw/root.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3dw/root.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -76,7 +76,20 @@
 	return(NULL);
 }
 
-/* get the root .... if it's NULL, the lib is not initialized, so do this too ... */
+/**
+ * Returns the root-widget, which holds all the surfaces. E.g. if you want to
+ * move all widgets at once, adjust the root-widgets x,y,z and use s3dw_moveit()
+ *
+ * \code
+ * s3dw_widget *root = s3dw_getroot();
+ * // move widget center to (0,5,0). upon creation, it's centered at (0,0,0),
+ * // so this might move it up
+ * root-&gt;x=0;
+ * root-&gt;y=5;
+ * root-&gt;z=0;
+ * s3dw_moveit(root);
+ * \endcode
+ */
 s3dw_widget* s3dw_getroot(void)
 {
 	if (root == NULL) {

Modified: trunk/libs3dw/s3dw.h
===================================================================
--- trunk/libs3dw/s3dw.h	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3dw/s3dw.h	2008-08-31 22:19:18 UTC (rev 980)
@@ -70,10 +70,36 @@
 typedef struct _s3dw_input   s3dw_input;
 typedef struct _s3dw_surface   s3dw_surface;
 typedef struct _s3dw_style   s3dw_style;
-typedef void (*s3dw_callback)(s3dw_widget *);
 
+/**
+ * With s3dw_style you can change the colors/materials of your widgets.
+ * materials are in the same as in s3d_push_materials_a, that means
+ * red,green,blue and alpha float values (between 0.0 and 1.0) for Ambience,
+ * Specular and Diffuse Color.
+ */
+struct _s3dw_style {
+	char *name;     /**&lt; name of the style ... kind of redundant */
+	char *fontface;    /**&lt; font face for all used fonts */
+	float surface_mat[12];  /**&lt; material for the surface background */
+	float input_mat[12];  /**&lt; material for buttonboxes and other widgets */
+	float inputback_mat[12]; /**&lt; material for inputfield background */
+	float text_mat[12];   /**&lt; material for the text on buttons and inputs */
+	float title_mat[12];  /**&lt; material for the title bar */
+	float title_text_mat[12]; /**&lt; material for the text on the title bar */
+};
 
-struct _s3dw_widget {
+/**
+ * This is the most basic widget type, it contains all the &quot;general&quot; widget
+ * information. If you want to move a widget, you'd change x,y,z,s and rx,ry,rz
+ * and call s3dw_moveit to turn your action reality. Every other widget has this
+ * type as first entry, so a simple typecast to s3dw_widget will give you the
+ * widgets &quot;general&quot; information. For typecast, you may use S3DWIDGET().
+ *
+ * The pointer ptr allows linking to user-specific datastructures. That comes in
+ * handy if the widget is called back by an event, and the program must now find
+ * out on which data the user reacted.
+ */
+ struct _s3dw_widget {
 	/* private .. */
 	int      type;
 	s3dw_widget *parent;
@@ -94,7 +120,24 @@
 	float    rx, ry, rz;  /* rotation around the axis */
 };
 
+/**
+ * The callback type. Receive the widget which is affected as argument.
+ *
+ * \code
+ * // example
+ * void my_handler(s3dw_widget *widget)
+ * {
+ *         // do something with the widget
+ *         ...
+ * }
+ * \endcode
+ */
+typedef void (*s3dw_callback)(s3dw_widget *);
 
+/**
+ * The buttons is just a button as you would expect it in a 2D widget library.
+ * It only reacts on clicks.
+ */
 struct _s3dw_button {
 	/* private */
 	s3dw_widget   widget;
@@ -103,14 +146,25 @@
 	/* public */
 	s3dw_callback   onclick;
 };
+
+/**
+ * The labels is an label-field where a user may type things. onclick reacts on
+ * click in the field, onedit notifies you when someone writes in the field.
+ */
 struct _s3dw_label {
 	/* private */
 	s3dw_widget   widget;
 	char    *text;
 	/* public */
 	s3dw_callback   onclick;
+};
 
-};
+/**
+ * The Scrollbar should be placed around scrollable content. Currently only the
+ * left and right icons are clickable (lonclick and ronclick callbacks), in
+ * vertical mode lonclick is the callback for the up icon, ronclick the callback
+ * for the down icon.
+ */
 struct _s3dw_scrollbar {
 	/* private */
 	s3dw_widget   widget;
@@ -123,6 +177,10 @@
 
 };
 
+/**
+ * A textbox shows some text with scrollbars to scroll around. It can currently
+ * only react to a click event.
+ */
 struct _s3dw_textbox {
 	/* private */
 	s3dw_widget   widget;
@@ -136,6 +194,10 @@
 
 };
 
+/**
+ * The inputs is an input-field where a user may type things. onclick reacts on
+ * click in the field, onedit notifies you when someone writes in the field.
+ */
 struct _s3dw_input {
 	/* private */
 	s3dw_widget   widget;
@@ -146,6 +208,10 @@
 	s3dw_callback   onedit;
 };
 
+/**
+ * A surface is the window of this widget library, holding all of our elements
+ * like buttons, inputfields etc ...
+ */
 struct _s3dw_surface {
 	/* private */
 	s3dw_widget     widget;
@@ -154,18 +220,6 @@
 	char     *title;
 };
 
-/* style */
-struct _s3dw_style {
-	char *name;     /* name of the style ... kind of redundant */
-	char *fontface;    /* font face for all used fonts */
-	float surface_mat[12];  /* material for the surface background */
-	float input_mat[12];  /* material for buttonboxes and other widgets */
-	float inputback_mat[12]; /* material for inputfield background */
-	float text_mat[12];   /* material for the text on buttons and inputs */
-	float title_mat[12];  /* material for the title bar */
-	float title_text_mat[12]; /* material for the text on the title bar */
-};
-
 #if defined(__cplusplus) || defined(c_plusplus)
 extern &quot;C&quot;
 {

Modified: trunk/libs3dw/surface.c
===================================================================
--- trunk/libs3dw/surface.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3dw/surface.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -125,7 +125,13 @@
 	s3d_flags_off(surface-&gt;oid_title, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 	s3d_flags_off(surface-&gt;oid_tbar, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
-/* create a new surface */
+
+/**
+ * Creates a new surface (a new window) with title &quot;title&quot; and dimension &quot;width&quot;
+ * x &quot;height&quot;.
+ *
+ * See s3dw_surface for information about callbacks which may be defined.
+ */
 s3dw_surface *s3dw_surface_new(const char *title, float width, float height)
 {
 	s3dw_surface *surface;

Modified: trunk/libs3dw/textbox.c
===================================================================
--- trunk/libs3dw/textbox.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3dw/textbox.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -195,7 +195,13 @@
 	s3dw_textbox_scrollright((s3dw_textbox *)widget-&gt;parent);
 }
 
-/* create a new textbox in the surface */
+/**
+ * Creates a new textbox on the surface, with &quot;text&quot; written on it and the upper
+ * left corner at (posx,posy) on the surface. Width and height define the size
+ * of the textbox including scrollbars which are rendered around the textfield.
+ *
+ * See s3dw_textbox for information about callbacks which may be defined.
+ */
 s3dw_textbox *s3dw_textbox_new(const s3dw_surface *surface, const char *text, float posx, float posy, float width, float height)
 {
 	s3dw_textbox *textbox;
@@ -232,29 +238,49 @@
 		s3dw_textbox_show(widget);
 }
 
+/**
+ * Scrolls the text in the textbox up by one line, if possible.
+ */
 void s3dw_textbox_scrollup(s3dw_textbox *textbox)
 {
 	if (textbox-&gt;window_y &gt; 0)
 		textbox-&gt;window_y--;
 	s3dw_textbox_redraw(S3DWIDGET(textbox));
 }
+
+/**
+ * Scrolls the text in the textbox down by one line, if possible.
+ */
 void s3dw_textbox_scrolldown(s3dw_textbox *textbox)
 {
 	textbox-&gt;window_y++;
 	s3dw_textbox_redraw(S3DWIDGET(textbox));
 
 }
+
+/**
+ * Scrolls the text in the textbox to the left by one character, if possible.
+ */
 void s3dw_textbox_scrollleft(s3dw_textbox *textbox)
 {
 	if (textbox-&gt;window_x &gt; 0)
 		textbox-&gt;window_x--;
 	s3dw_textbox_redraw(S3DWIDGET(textbox));
 }
+
+/**
+ * Scrolls the text in the textbox to the right by one character, if possible.
+ */
 void s3dw_textbox_scrollright(s3dw_textbox *textbox)
 {
 	textbox-&gt;window_x++;
 	s3dw_textbox_redraw(S3DWIDGET(textbox));
 }
+
+/**
+ * Scrolls the text in the textbox so that the character in row y, column x is
+ * in the top left corner of the textbox.
+ */
 void s3dw_textbox_scrollto(s3dw_textbox *textbox, int x, int y)
 {
 	s3dw_widget *widget = (s3dw_widget *)textbox;
@@ -265,6 +291,9 @@
 	s3dw_textbox_redraw(widget);
 }
 
+/**
+ * Change the text in the referenced textbox to the specified text.
+ */
 void s3dw_textbox_change_text(s3dw_textbox *textbox, const char *text)
 {
 	s3dw_widget *widget = (s3dw_widget *)textbox;

Modified: trunk/libs3dw/widget.c
===================================================================
--- trunk/libs3dw/widget.c	2008-08-29 17:00:25 UTC (rev 979)
+++ trunk/libs3dw/widget.c	2008-08-31 22:19:18 UTC (rev 980)
@@ -97,7 +97,10 @@
 			parent-&gt;nobj--;
 		}
 }
-/* properly delete the object, removing kids, own structure and link from parent. */
+
+/**
+ * Deletes any widget. Should be casted with S3DWIDGET().
+ */
 void s3dw_delete(s3dw_widget *widget)
 {
 	s3dw_widget_remove(widget);
@@ -107,12 +110,21 @@
 	free(widget-&gt;pobj);
 	s3dwcb_destroy[widget-&gt;type](widget); /* type-specific destroy */
 }
-/* toggle a widget visible and show it */
+
+/**
+ * Switches a widget visible. Should be casted with S3DWIDGET().
+ */
 void s3dw_show(s3dw_widget *widget)
 {
 	widget-&gt;flags |= S3DW_VISIBLE;
 	s3dw_widget_visible(widget);
 }
+
+/**
+ * Gives focus to the widget, relative to its parent. That means you can focus a
+ * surface, and each surface can focus one of its element, e.g. an input field.
+ * Should be casted with S3DWIDGET().
+ */
 void s3dw_focus(s3dw_widget *focus)
 {
 	int i;
@@ -136,7 +148,11 @@
 	widget-&gt;flags |= S3DW_ONSCREEN;
 	s3dwcb_show[widget-&gt;type](widget);
 }
-/* apply the moves ... */
+
+/**
+ * Moves/translates the widget as you specified in it's private s3dw_widget
+ * structure. Should be casted with S3DWIDGET().
+ */
 void     s3dw_moveit(s3dw_widget *widget)
 {
 	s3dw_ani_add(widget);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000961.html">[S3d-svn] r981 - trunk/Documentation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#960">[ date ]</a>
              <a href="thread.html#960">[ thread ]</a>
              <a href="subject.html#960">[ subject ]</a>
              <a href="author.html#960">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/s3d-svn">More information about the S3d-svn
mailing list</a><br>
</body></html>
