<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [S3d-svn] r295 - in trunk: . example libg3d libg3d/doc libg3d/doc/api libs3d
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/s3d-svn/2006-May/index.html" >
   <LINK REL="made" HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r295%20-%20in%20trunk%3A%20.%20example%20libg3d%20libg3d/doc%20libg3d/doc/api%20libs3d&In-Reply-To=%3C200605251712.k4PHCBvK011288%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000287.html">
   <LINK REL="Next"  HREF="000289.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[S3d-svn] r295 - in trunk: . example libg3d libg3d/doc libg3d/doc/api libs3d</H1>
    <B>dotslash at BerliOS</B> 
    <A HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r295%20-%20in%20trunk%3A%20.%20example%20libg3d%20libg3d/doc%20libg3d/doc/api%20libs3d&In-Reply-To=%3C200605251712.k4PHCBvK011288%40sheep.berlios.de%3E"
       TITLE="[S3d-svn] r295 - in trunk: . example libg3d libg3d/doc libg3d/doc/api libs3d">dotslash at berlios.de
       </A><BR>
    <I>Thu May 25 19:12:11 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000287.html">[S3d-svn] r294 - in trunk: . apps/s3dfm
</A></li>
        <LI>Next message: <A HREF="000289.html">[S3d-svn] r296 - in trunk: . libg3d/include libg3d/include/g3d libs3dw
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#288">[ date ]</a>
              <a href="thread.html#288">[ thread ]</a>
              <a href="subject.html#288">[ subject ]</a>
              <a href="author.html#288">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dotslash
Date: 2006-05-25 19:11:46 +0200 (Thu, 25 May 2006)
New Revision: 295

Added:
   trunk/libs3d/
   trunk/libs3d/3dsread.c
   trunk/libs3d/Makefile.am
   trunk/libs3d/TODO
   trunk/libs3d/callback.c
   trunk/libs3d/config.h
   trunk/libs3d/error.c
   trunk/libs3d/event.c
   trunk/libs3d/fontselect.c
   trunk/libs3d/freetype.c
   trunk/libs3d/io.c
   trunk/libs3d/lgpl.txt
   trunk/libs3d/network.c
   trunk/libs3d/object_queue.c
   trunk/libs3d/proto_in.c
   trunk/libs3d/proto_out.c
   trunk/libs3d/s3d.h
   trunk/libs3d/s3d_keysym.h
   trunk/libs3d/s3dlib.h
   trunk/libs3d/sei_construct.c
   trunk/libs3d/sei_interface.h
   trunk/libs3d/sei_misc.c
   trunk/libs3d/sei_monotone.c
   trunk/libs3d/sei_tri.c
   trunk/libs3d/sei_triangulate.h
   trunk/libs3d/shm.c
   trunk/libs3d/shm_ringbuf.c
   trunk/libs3d/tcp.c
   trunk/libs3d/vector.c
Removed:
   trunk/client/
   trunk/libg3d/Makefile
   trunk/libg3d/config.log
   trunk/libg3d/config.status
   trunk/libg3d/doc/Makefile
   trunk/libg3d/doc/api/Makefile
   trunk/libg3d/doc/api/html/
   trunk/libg3d/doc/api/xml/
Modified:
   trunk/
   trunk/configure.ac
   trunk/example/widgets.c
Log:
 <A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">r613 at balthasar</A>:  dotslash | 2006-05-25 19:08:08 +0200
 - libg3d cleanup
 - &quot;client&quot; is now &quot;libs3d&quot;



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:583
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:613

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/configure.ac	2006-05-25 17:11:46 UTC (rev 295)
@@ -169,7 +169,8 @@
 AC_CONFIG_FILES([
 	Makefile
 	server/Makefile
-	client/Makefile
+	libs3d/Makefile
+	libs3dw/Makefile
 	apps/Makefile
 	apps/olsrs3d/Makefile
 	apps/s3d_x11gate/Makefile

Modified: trunk/example/widgets.c
===================================================================
--- trunk/example/widgets.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/example/widgets.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -27,14 +27,23 @@
 #include &lt;s3d.h&gt;
 #include &lt;stdio.h&gt;  /* NULL */
 #include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
-int i,oid;
+#include &lt;stdlib.h&gt; /* malloc() */
+#include &lt;string.h&gt; /* strdup() */
+
 #define		S3DW_VISIBLE	1
 #define 	S3DW_CLICKABLE	2
 
+enum {
+	S3DW_TSURFACE,
+	S3DW_TBUTTON,
+	S3DW_TINPUT
+};
+
 struct s3dw_button {
 	char *_text;
 	int   _flags;
+	int   _oid_text;
+	int   _oid_box;
 };
 struct s3dw_input {
 	char *_text;
@@ -43,65 +52,181 @@
 
 struct s3dw_object {
 	int type;
-	int posx,posy,width,height;
+	float posx,posy,width,height;
 	union {
 		struct s3dw_button *button;
 		struct s3dw_input  *input;
-	};
+	} object;
 };
 
 struct s3dw_surface {
-	int _oid;
-	int _nobj;
-	int _flags;
-	struct obj *_pobj;
+	int 				  _oid;
+	int 				  _flags;
+	int 				  _nobj;
+	struct s3dw_object 	**_pobj;
+	struct s3dw_style 	 *_style;
 };
-void mainloop()
+
+/* style */
+struct s3dw_style {
+	char *name;
+	float surface_mat[12];
+	float input_mat[12];
+	float text_mat[12];
+};
+
+/* default style */
+struct s3dw_style def_style={&quot;default&quot;,
+/* surface_mat */
+{0.5,0.5,0.5,1.0, 
+0.5,0.5,0.5,1.0, 
+0.5,0.5,0.5,1.0}
+,
+/* input_mat */
+{0.5,0.5,0.5,1.0,
+ 0.5,0.5,0.5,1.0,
+ 0.5,0.5,0.5,1.0
+},
+/* text_mat */
 {
-	s3d_rotate(oid,0,i,0);
-	i++;
-	nanosleep(&amp;t,NULL); 
-}
-void object_click(struct s3d_evt *evt)
-{
-	s3d_quit();
-}
-	
+ 0.0,0.0,0.0,1.0,
+ 1.0,1.0,1.0,1.0,
+ 0.0,0.0,0.0,1.0
+}};
+
+
+		
+/* create a new surface */
 struct s3dw_surface *s3dw_surface_new()
 {
 	struct s3dw_surface *ret;
 	ret=(struct s3dw_surface *)malloc(sizeof(struct s3dw_surface));
-	ret-&gt;_oid=-1;
+	ret-&gt;_oid=s3d_new_object();
 	ret-&gt;_flags=0;
 	ret-&gt;_nobj=0;
 	ret-&gt;_pobj=NULL;
+	ret-&gt;_style=&amp;def_style;
+	return(ret);
 }
+void s3dw_button_destroy(struct s3dw_button *button)
+{
+	s3d_del_object(button-&gt;_oid_text);
+	s3d_del_object(button-&gt;_oid_box);
+	free(button-&gt;_text);
+	free(button);
+}
+/* destroy the surface */
 void s3dw_surface_destroy(struct s3dw_surface *surface)
 {
+	int i;
+	s3d_del_object(surface-&gt;_oid);
+	if (surface-&gt;_nobj&gt;0)
+	{
+		for (i=0;i&lt;surface-&gt;_nobj;i++)
+		{
+			switch (surface-&gt;_pobj[i]-&gt;type)
+			{
+				case S3DW_TBUTTON:
+						s3dw_button_destroy(surface-&gt;_pobj[i]-&gt;object.button);
+						free(surface-&gt;_pobj[i]);
+						break;
+				default:
+						printf(&quot;can't free this type (yet) - memory leak\n&quot;);
+			}
+		}
+		free(surface-&gt;_pobj);
+	}
 	free(surface);
 }
-void s3dw_surface_append_obj(struct s3dw_surface *surface, struct s3dw_object *object, int posx, int posy)
+/* append an object */
+void s3dw_surface_append_obj(struct s3dw_surface *surface, struct s3dw_object *object)
 {
-	
+	surface-&gt;_nobj++;
+	surface-&gt;_pobj=realloc(surface-&gt;_pobj,sizeof(struct s3dw_object *)*surface-&gt;_nobj);
+	surface-&gt;_pobj[surface-&gt;_nobj-1]=object;
 }
+/* create a new button in the surface */
 struct s3dw_button *s3dw_button_new(struct s3dw_surface *surface, char *text, int posx, int posy)
 {
 	struct s3dw_button *button;
 	struct s3dw_object *object;
+	float length;
+	float vertices[8*3];
+	unsigned long polygons[10*4]={
+			0,4,5,0,
+			0,5,1,0,
+			1,5,6,0,
+			1,6,2,0,
+			2,6,7,0,
+			2,7,3,0,
+			3,7,4,0,
+			3,4,0,0,
+			4,7,6,0,
+			4,6,5,0
+	};
 	button=(struct s3dw_button *)malloc(sizeof(struct s3dw_button));
 	object=(struct s3dw_object *)malloc(sizeof(struct s3dw_object));
+	object-&gt;type=S3DW_TBUTTON;
+	/* draw button */
 	button-&gt;_text=strdup(text);
 	button-&gt;_flags=0;
-	object-&gt;_type=S3DW_TBUTTON;
+	s3d_select_font(&quot;vera&quot;);
+	button-&gt;_oid_text=s3d_draw_string(button-&gt;_text,&amp;length);
+	s3d_pep_materials_a(button-&gt;_oid_text,surface-&gt;_style-&gt;text_mat,1);
+	button-&gt;_oid_box=s3d_new_object();
+	/* width of the button depends on the length of the text */
+	vertices[0*3+0]=0.0;			vertices[0*3+1]=0.0;		vertices[0*3+2]=0.0;	
+	vertices[1*3+0]=0.0;			vertices[1*3+1]=-2.0;		vertices[1*3+2]=0.0;	
+	vertices[2*3+0]=length+1;		vertices[2*3+1]=-2.0;		vertices[2*3+2]=0.0;	
+	vertices[3*3+0]=length+1;		vertices[3*3+1]=0.0;		vertices[3*3+2]=0.0;	
+	vertices[4*3+0]=0.25;			vertices[4*3+1]=-0.25;		vertices[4*3+2]=0.25;	
+	vertices[5*3+0]=0.25;			vertices[5*3+1]=-1.75;		vertices[5*3+2]=0.25;	
+	vertices[6*3+0]=length+0.75;	vertices[6*3+1]=-1.75;		vertices[6*3+2]=0.25;	
+	vertices[7*3+0]=length+0.75;	vertices[7*3+1]=-0.25;		vertices[7*3+2]=0.25;	
+	s3d_push_materials_a(button-&gt;_oid_box,surface-&gt;_style-&gt;input_mat,1);
+	s3d_push_vertices   (button-&gt;_oid_box,vertices,8);
+	s3d_push_polygons   (button-&gt;_oid_box,polygons,10);
+	s3d_link(		   button-&gt;_oid_box,surface-&gt;_oid);
+	s3d_link(		   button-&gt;_oid_text,button-&gt;_oid_box);
+	s3d_translate(button-&gt;_oid_text,0.5,-1.5,0.30);
+	s3d_translate(button-&gt;_oid_box,posx,-posy,0);
 	object-&gt;posx=posx;
 	object-&gt;posy=posy;
-	object-&gt;width=5;
-	object-&gt;height=1;
+	object-&gt;width=length+1;
+	object-&gt;height=2;
+    s3d_flags_on(button-&gt;_oid_box,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+    s3d_flags_on(button-&gt;_oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+
 	s3dw_surface_append_obj(surface, object);
 	return(button);
 }
+
+
+/* application stuff */
+
+static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+void mainloop()
+{
+	nanosleep(&amp;t,NULL); 
+}
+void object_click(struct s3d_evt *evt)
+{
+	s3d_quit();
+}
+	
+
 int main (int argc, char **argv)
 {
+	struct s3dw_surface *surface;
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;widgettest&quot;))	
+	{
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
+		surface=s3dw_surface_new(&quot;Testsurface&quot;,10,10);
+		s3dw_button_new(surface,&quot;Hello world&quot;,1,1);
+		s3d_mainloop(mainloop);
+		s3d_quit();
+	}
+
 	return(0);
 }
 

Deleted: trunk/libg3d/Makefile
===================================================================
--- trunk/libg3d/Makefile	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libg3d/Makefile	2006-05-25 17:11:46 UTC (rev 295)
@@ -1,584 +0,0 @@
-# Makefile.in generated by automake 1.7.9 from Makefile.am.
-# Makefile.  Generated from Makefile.in by configure.
-
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
-# Free Software Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-
-
-srcdir = .
-top_srcdir = .
-
-pkgdatadir = $(datadir)/libg3d
-pkglibdir = $(libdir)/libg3d
-pkgincludedir = $(includedir)/libg3d
-top_builddir = .
-
-am__cd = CDPATH=&quot;$${ZSH_VERSION+.}$(PATH_SEPARATOR)&quot; &amp;&amp; cd
-INSTALL = /usr/bin/install -c
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-host_triplet = i686-pc-linux-gnu
-ACLOCAL = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run aclocal-1.7
-AMDEP_FALSE = #
-AMDEP_TRUE = 
-AMTAR = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run tar
-AR = ar
-AUTOCONF = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run autoconf
-AUTOHEADER = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run autoheader
-AUTOMAKE = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run automake-1.7
-AWK = mawk
-CC = gcc
-CCDEPMODE = depmode=gcc3
-CFLAGS = -g -O2
-CPP = gcc -E
-CPPFLAGS = 
-CXX = g++
-CXXCPP = g++ -E
-CXXDEPMODE = depmode=gcc3
-CXXFLAGS = -g -O2
-CYGPATH_W = echo
-DBG_CFLAGS = -O2
-DEBUG = 0
-DEFS = -DHAVE_CONFIG_H
-DEPDIR = .deps
-ECHO = echo
-ECHO_C = 
-ECHO_N = -n
-ECHO_T = 
-EGREP = grep -E
-ENABLE_GTK_DOC_FALSE = 
-ENABLE_GTK_DOC_TRUE = #
-EXEEXT = 
-F77 = 
-FFLAGS = 
-GDKPIXBUF_CFLAGS = 
-GDKPIXBUF_LIBS = 
-GLIB_CFLAGS = -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
-GLIB_GENMARSHAL = glib-genmarshal
-GLIB_LIBS = -Wl,--export-dynamic -lgmodule-2.0 -ldl -lgobject-2.0 -lglib-2.0  
-GLIB_MKENUMS = glib-mkenums
-GOBJECT_QUERY = gobject-query
-GTK_CFLAGS = 
-GTK_DOC_USE_LIBTOOL_FALSE = #
-GTK_DOC_USE_LIBTOOL_TRUE = 
-GTK_LIBS = 
-HAVE_GDKPIXBUF_FALSE = 
-HAVE_GDKPIXBUF_TRUE = #
-HTML_DIR = ${datadir}/gtk-doc/html
-INSTALL_DATA = ${INSTALL} -m 644
-INSTALL_PROGRAM = ${INSTALL}
-INSTALL_SCRIPT = ${INSTALL}
-INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
-LDFLAGS = 
-LEX = flex
-LEXLIB = -lfl
-LEX_OUTPUT_ROOT = lex.yy
-LIBOBJS = 
-LIBS = 
-LIBTOOL = $(SHELL) $(top_builddir)/libtool
-LN_S = ln -s
-LTLIBOBJS = 
-MAKEINFO = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run makeinfo
-OBJEXT = o
-PACKAGE = libg3d
-PACKAGE_BUGREPORT = 
-PACKAGE_NAME = 
-PACKAGE_STRING = 
-PACKAGE_TARNAME = 
-PACKAGE_VERSION = 
-PATH_SEPARATOR = :
-PKG_CONFIG = /usr/bin/pkg-config
-PLUGINS_LDFLAGS = -avoid-version -export-dynamic
-RANLIB = ranlib
-SET_MAKE = 
-SHELL = /bin/sh
-STRIP = strip
-VERSION = 0.0.3
-ac_ct_AR = ar
-ac_ct_CC = gcc
-ac_ct_CXX = g++
-ac_ct_F77 = 
-ac_ct_RANLIB = ranlib
-ac_ct_STRIP = strip
-am__fastdepCC_FALSE = #
-am__fastdepCC_TRUE = 
-am__fastdepCXX_FALSE = #
-am__fastdepCXX_TRUE = 
-am__include = include
-am__leading_dot = .
-am__quote = 
-bindir = ${exec_prefix}/bin
-build = i686-pc-linux-gnu
-build_alias = 
-build_cpu = i686
-build_os = linux-gnu
-build_vendor = pc
-datadir = ${prefix}/share
-exec_prefix = ${prefix}
-host = i686-pc-linux-gnu
-host_alias = 
-host_cpu = i686
-host_os = linux-gnu
-host_vendor = pc
-includedir = ${prefix}/include
-infodir = ${prefix}/info
-install_sh = /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/install-sh
-libdir = ${exec_prefix}/lib
-libexecdir = ${exec_prefix}/libexec
-localstatedir = ${prefix}/var
-mandir = ${prefix}/man
-oldincludedir = /usr/include
-prefix = /usr/local
-program_transform_name = s,x,x,
-sbindir = ${exec_prefix}/sbin
-sharedstatedir = ${prefix}/com
-sysconfdir = ${prefix}/etc
-target_alias = 
-SUBDIRS = . doc m4 include plugins src tests
-
-pkgconfigdir = ${libdir}/pkgconfig
-
-pkgconfig_DATA = libg3d.pc
-subdir = .
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/include/g3d/config.h
-CONFIG_CLEAN_FILES = libg3d.pc
-DIST_SOURCES =
-DATA = $(pkgconfig_DATA)
-
-
-RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
-	ps-recursive install-info-recursive uninstall-info-recursive \
-	all-recursive install-data-recursive install-exec-recursive \
-	installdirs-recursive install-recursive uninstall-recursive \
-	check-recursive installcheck-recursive
-DIST_COMMON = README $(srcdir)/Makefile.in $(srcdir)/configure AUTHORS \
-	COPYING ChangeLog INSTALL Makefile.am NEWS aclocal.m4 \
-	config/compile config/config.guess config/config.sub \
-	config/depcomp config/install-sh config/ltmain.sh \
-	config/missing config/mkinstalldirs configure.in libg3d.pc.in
-DIST_SUBDIRS = $(SUBDIRS)
-all: all-recursive
-
-.SUFFIXES:
-
-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
- configure.lineno
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
-	cd $(top_srcdir) &amp;&amp; \
-	  $(AUTOMAKE) --gnu  Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status $@ $(am__depfiles_maybe)
-
-$(top_builddir)/config.status: $(srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	$(SHELL) ./config.status --recheck
-$(srcdir)/configure:  $(srcdir)/configure.in $(ACLOCAL_M4) $(CONFIGURE_DEPENDENCIES)
-	cd $(srcdir) &amp;&amp; $(AUTOCONF)
-
-$(ACLOCAL_M4):  configure.in 
-	cd $(srcdir) &amp;&amp; $(ACLOCAL) $(ACLOCAL_AMFLAGS)
-libg3d.pc: $(top_builddir)/config.status libg3d.pc.in
-	cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status $@
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool
-uninstall-info-am:
-pkgconfigDATA_INSTALL = $(INSTALL_DATA)
-install-pkgconfigDATA: $(pkgconfig_DATA)
-	@$(NORMAL_INSTALL)
-	$(mkinstalldirs) $(DESTDIR)$(pkgconfigdir)
-	@list='$(pkgconfig_DATA)'; for p in $$list; do \
-	  if test -f &quot;$$p&quot;; then d=; else d=&quot;$(srcdir)/&quot;; fi; \
-	  f=&quot;`echo $$p | sed -e 's|^.*/||'`&quot;; \
-	  echo &quot; $(pkgconfigDATA_INSTALL) $$d$$p $(DESTDIR)$(pkgconfigdir)/$$f&quot;; \
-	  $(pkgconfigDATA_INSTALL) $$d$$p $(DESTDIR)$(pkgconfigdir)/$$f; \
-	done
-
-uninstall-pkgconfigDATA:
-	@$(NORMAL_UNINSTALL)
-	@list='$(pkgconfig_DATA)'; for p in $$list; do \
-	  f=&quot;`echo $$p | sed -e 's|^.*/||'`&quot;; \
-	  echo &quot; rm -f $(DESTDIR)$(pkgconfigdir)/$$f&quot;; \
-	  rm -f $(DESTDIR)$(pkgconfigdir)/$$f; \
-	done
-
-# This directory's subdirectories are mostly independent; you can cd
-# into them and run `make' without going through this Makefile.
-# To change the values of `make' variables: instead of editing Makefiles,
-# (1) if the variable is set in `config.status', edit `config.status'
-#     (which will cause the Makefiles to be regenerated when you run `make');
-# (2) otherwise, pass the desired values on the `make' command line.
-$(RECURSIVE_TARGETS):
-	@set fnord $$MAKEFLAGS; amf=$$2; \
-	dot_seen=no; \
-	target=`echo $@ | sed s/-recursive//`; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  echo &quot;Making $$target in $$subdir&quot;; \
-	  if test &quot;$$subdir&quot; = &quot;.&quot;; then \
-	    dot_seen=yes; \
-	    local_target=&quot;$$target-am&quot;; \
-	  else \
-	    local_target=&quot;$$target&quot;; \
-	  fi; \
-	  (cd $$subdir &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case &quot;$$amf&quot; in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
-	done; \
-	if test &quot;$$dot_seen&quot; = &quot;no&quot;; then \
-	  $(MAKE) $(AM_MAKEFLAGS) &quot;$$target-am&quot; || exit 1; \
-	fi; test -z &quot;$$fail&quot;
-
-mostlyclean-recursive clean-recursive distclean-recursive \
-maintainer-clean-recursive:
-	@set fnord $$MAKEFLAGS; amf=$$2; \
-	dot_seen=no; \
-	case &quot;$@&quot; in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	rev=''; for subdir in $$list; do \
-	  if test &quot;$$subdir&quot; = &quot;.&quot;; then :; else \
-	    rev=&quot;$$subdir $$rev&quot;; \
-	  fi; \
-	done; \
-	rev=&quot;$$rev .&quot;; \
-	target=`echo $@ | sed s/-recursive//`; \
-	for subdir in $$rev; do \
-	  echo &quot;Making $$target in $$subdir&quot;; \
-	  if test &quot;$$subdir&quot; = &quot;.&quot;; then \
-	    local_target=&quot;$$target-am&quot;; \
-	  else \
-	    local_target=&quot;$$target&quot;; \
-	  fi; \
-	  (cd $$subdir &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case &quot;$$amf&quot; in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
-	done &amp;&amp; test -z &quot;$$fail&quot;
-tags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test &quot;$$subdir&quot; = . || (cd $$subdir &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) tags); \
-	done
-ctags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test &quot;$$subdir&quot; = . || (cd $$subdir &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) ctags); \
-	done
-
-ETAGS = etags
-ETAGSFLAGS =
-
-CTAGS = ctags
-CTAGSFLAGS =
-
-tags: TAGS
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	mkid -fID $$unique
-
-TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	if (etags --etags-include --version) &gt;/dev/null 2&gt;&amp;1; then \
-	  include_option=--etags-include; \
-	else \
-	  include_option=--include; \
-	fi; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  if test &quot;$$subdir&quot; = .; then :; else \
-	    test -f $$subdir/TAGS &amp;&amp; \
-	      tags=&quot;$$tags $$include_option=$$here/$$subdir/TAGS&quot;; \
-	  fi; \
-	done; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	test -z &quot;$(ETAGS_ARGS)$$tags$$unique&quot; \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	     $$tags $$unique
-
-ctags: CTAGS
-CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	test -z &quot;$(CTAGS_ARGS)$$tags$$unique&quot; \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$tags $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) &amp;&amp; pwd` \
-	  &amp;&amp; cd $(top_srcdir) \
-	  &amp;&amp; gtags -i $(GTAGS_ARGS) $$here
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = .
-distdir = $(PACKAGE)-$(VERSION)
-
-am__remove_distdir = \
-  { test ! -d $(distdir) \
-    || { find $(distdir) -type d ! -perm -200 -exec chmod u+w {} ';' \
-         &amp;&amp; rm -fr $(distdir); }; }
-
-GZIP_ENV = --best
-distuninstallcheck_listfiles = find . -type f -print
-distcleancheck_listfiles = find . -type f -print
-
-distdir: $(DISTFILES)
-	$(am__remove_distdir)
-	mkdir $(distdir)
-	$(mkinstalldirs) $(distdir)/. $(distdir)/config
-	@srcdirstrip=`echo &quot;$(srcdir)&quot; | sed 's|.|.|g'`; \
-	topsrcdirstrip=`echo &quot;$(top_srcdir)&quot; | sed 's|.|.|g'`; \
-	list='$(DISTFILES)'; for file in $$list; do \
-	  case $$file in \
-	    $(srcdir)/*) file=`echo &quot;$$file&quot; | sed &quot;s|^$$srcdirstrip/||&quot;`;; \
-	    $(top_srcdir)/*) file=`echo &quot;$$file&quot; | sed &quot;s|^$$topsrcdirstrip/|$(top_builddir)/|&quot;`;; \
-	  esac; \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  dir=`echo &quot;$$file&quot; | sed -e 's,/[^/]*$$,,'`; \
-	  if test &quot;$$dir&quot; != &quot;$$file&quot; &amp;&amp; test &quot;$$dir&quot; != &quot;.&quot;; then \
-	    dir=&quot;/$$dir&quot;; \
-	    $(mkinstalldirs) &quot;$(distdir)$$dir&quot;; \
-	  else \
-	    dir=''; \
-	  fi; \
-	  if test -d $$d/$$file; then \
-	    if test -d $(srcdir)/$$file &amp;&amp; test $$d != $(srcdir); then \
-	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
-	    fi; \
-	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
-	  else \
-	    test -f $(distdir)/$$file \
-	    || cp -p $$d/$$file $(distdir)/$$file \
-	    || exit 1; \
-	  fi; \
-	done
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  if test &quot;$$subdir&quot; = .; then :; else \
-	    test -d $(distdir)/$$subdir \
-	    || mkdir $(distdir)/$$subdir \
-	    || exit 1; \
-	    (cd $$subdir &amp;&amp; \
-	      $(MAKE) $(AM_MAKEFLAGS) \
-	        top_distdir=&quot;$(top_distdir)&quot; \
-	        distdir=../$(distdir)/$$subdir \
-	        distdir) \
-	      || exit 1; \
-	  fi; \
-	done
-	-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \; -o \
-	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
-	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
-	  ! -type d ! -perm -444 -exec $(SHELL) $(install_sh) -c -m a+r {} {} \; \
-	|| chmod -R a+r $(distdir)
-dist-gzip: distdir
-	$(AMTAR) chof - $(distdir) | GZIP=$(GZIP_ENV) gzip -c &gt;$(distdir).tar.gz
-	$(am__remove_distdir)
-
-dist dist-all: distdir
-	$(AMTAR) chof - $(distdir) | GZIP=$(GZIP_ENV) gzip -c &gt;$(distdir).tar.gz
-	$(am__remove_distdir)
-
-# This target untars the dist file and tries a VPATH configuration.  Then
-# it guarantees that the distribution is self-contained by making another
-# tarfile.
-distcheck: dist
-	$(am__remove_distdir)
-	GZIP=$(GZIP_ENV) gunzip -c $(distdir).tar.gz | $(AMTAR) xf -
-	chmod -R a-w $(distdir); chmod a+w $(distdir)
-	mkdir $(distdir)/_build
-	mkdir $(distdir)/_inst
-	chmod a-w $(distdir)
-	dc_install_base=`$(am__cd) $(distdir)/_inst &amp;&amp; pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
-	  &amp;&amp; dc_destdir=&quot;$${TMPDIR-/tmp}/am-dc-$$$$/&quot; \
-	  &amp;&amp; cd $(distdir)/_build \
-	  &amp;&amp; ../configure --srcdir=.. --prefix=&quot;$$dc_install_base&quot; \
-	    $(DISTCHECK_CONFIGURE_FLAGS) \
-	  &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) \
-	  &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) dvi \
-	  &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) check \
-	  &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) install \
-	  &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) installcheck \
-	  &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) uninstall \
-	  &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir=&quot;$$dc_install_base&quot; \
-	        distuninstallcheck \
-	  &amp;&amp; chmod -R a-w &quot;$$dc_install_base&quot; \
-	  &amp;&amp; ({ \
-	       (cd ../.. &amp;&amp; $(mkinstalldirs) &quot;$$dc_destdir&quot;) \
-	       &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) DESTDIR=&quot;$$dc_destdir&quot; install \
-	       &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) DESTDIR=&quot;$$dc_destdir&quot; uninstall \
-	       &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) DESTDIR=&quot;$$dc_destdir&quot; \
-	            distuninstallcheck_dir=&quot;$$dc_destdir&quot; distuninstallcheck; \
-	      } || { rm -rf &quot;$$dc_destdir&quot;; exit 1; }) \
-	  &amp;&amp; rm -rf &quot;$$dc_destdir&quot; \
-	  &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) dist-gzip \
-	  &amp;&amp; rm -f $(distdir).tar.gz \
-	  &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) distcleancheck
-	$(am__remove_distdir)
-	@echo &quot;$(distdir).tar.gz is ready for distribution&quot; | \
-	  sed 'h;s/./=/g;p;x;p;x'
-distuninstallcheck:
-	@cd $(distuninstallcheck_dir) \
-	&amp;&amp; test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \
-	   || { echo &quot;ERROR: files left after uninstall:&quot; ; \
-	        if test -n &quot;$(DESTDIR)&quot;; then \
-	          echo &quot;  (check DESTDIR support)&quot;; \
-	        fi ; \
-	        $(distuninstallcheck_listfiles) ; \
-	        exit 1; } &gt;&amp;2
-distcleancheck: distclean
-	@if test '$(srcdir)' = . ; then \
-	  echo &quot;ERROR: distcleancheck can only run from a VPATH build&quot; ; \
-	  exit 1 ; \
-	fi
-	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
-	  || { echo &quot;ERROR: files left in build directory after distclean:&quot; ; \
-	       $(distcleancheck_listfiles) ; \
-	       exit 1; } &gt;&amp;2
-check-am: all-am
-check: check-recursive
-all-am: Makefile $(DATA)
-installdirs: installdirs-recursive
-installdirs-am:
-	$(mkinstalldirs) $(DESTDIR)$(pkgconfigdir)
-
-install: install-recursive
-install-exec: install-exec-recursive
-install-data: install-data-recursive
-uninstall: uninstall-recursive
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-recursive
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=&quot;$(INSTALL_STRIP_PROGRAM)&quot; \
-	  install_sh_PROGRAM=&quot;$(INSTALL_STRIP_PROGRAM)&quot; INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo &quot;INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'&quot;` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-rm -f $(CONFIG_CLEAN_FILES)
-
-maintainer-clean-generic:
-	@echo &quot;This command is intended for maintainers to use&quot;
-	@echo &quot;it deletes files that may require special tools to rebuild.&quot;
-clean: clean-recursive
-
-clean-am: clean-generic clean-libtool mostlyclean-am
-
-distclean: distclean-recursive
-	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-	-rm -f Makefile
-distclean-am: clean-am distclean-generic distclean-libtool \
-	distclean-tags
-
-dvi: dvi-recursive
-
-dvi-am:
-
-info: info-recursive
-
-info-am:
-
-install-data-am: install-pkgconfigDATA
-
-install-exec-am:
-
-install-info: install-info-recursive
-
-install-man:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-recursive
-	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-	-rm -rf $(top_srcdir)/autom4te.cache
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-recursive
-
-mostlyclean-am: mostlyclean-generic mostlyclean-libtool
-
-pdf: pdf-recursive
-
-pdf-am:
-
-ps: ps-recursive
-
-ps-am:
-
-uninstall-am: uninstall-info-am uninstall-pkgconfigDATA
-
-uninstall-info: uninstall-info-recursive
-
-.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am clean \
-	clean-generic clean-libtool clean-recursive ctags \
-	ctags-recursive dist dist-all dist-gzip distcheck distclean \
-	distclean-generic distclean-libtool distclean-recursive \
-	distclean-tags distcleancheck distdir distuninstallcheck dvi \
-	dvi-am dvi-recursive info info-am info-recursive install \
-	install-am install-data install-data-am install-data-recursive \
-	install-exec install-exec-am install-exec-recursive \
-	install-info install-info-am install-info-recursive install-man \
-	install-pkgconfigDATA install-recursive install-strip \
-	installcheck installcheck-am installdirs installdirs-am \
-	installdirs-recursive maintainer-clean maintainer-clean-generic \
-	maintainer-clean-recursive mostlyclean mostlyclean-generic \
-	mostlyclean-libtool mostlyclean-recursive pdf pdf-am \
-	pdf-recursive ps ps-am ps-recursive tags tags-recursive \
-	uninstall uninstall-am uninstall-info-am \
-	uninstall-info-recursive uninstall-pkgconfigDATA \
-	uninstall-recursive
-
-
-deb:
-	fakeroot dpkg-buildpackage
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:

Deleted: trunk/libg3d/config.log
===================================================================
--- trunk/libg3d/config.log	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libg3d/config.log	2006-05-25 17:11:46 UTC (rev 295)
@@ -1,946 +0,0 @@
-This file contains any messages produced by compilers while
-running configure, to aid debugging if configure makes a mistake.
-
-It was created by configure, which was
-generated by GNU Autoconf 2.59.  Invocation command line was
-
-  $ ./configure 
-
-## --------- ##
-## Platform. ##
-## --------- ##
-
-hostname = turgot
-uname -m = i686
-uname -r = 2.6.15-1-686
-uname -s = Linux
-uname -v = #2 Mon Mar 6 15:27:08 UTC 2006
-
-/usr/bin/uname -p = unknown
-/bin/uname -X     = unknown
-
-/bin/arch              = i686
-/usr/bin/arch -k       = unknown
-/usr/convex/getsysinfo = unknown
-hostinfo               = unknown
-/bin/machine           = unknown
-/usr/bin/oslevel       = unknown
-/bin/universe          = unknown
-
-PATH: /usr/local/bin
-PATH: /usr/bin
-PATH: /bin
-PATH: /usr/bin/X11
-PATH: /usr/games
-
-
-## ----------- ##
-## Core tests. ##
-## ----------- ##
-
-configure:1545: checking for a BSD-compatible install
-configure:1600: result: /usr/bin/install -c
-configure:1611: checking whether build environment is sane
-configure:1654: result: yes
-configure:1687: checking for gawk
-configure:1716: result: no
-configure:1687: checking for mawk
-configure:1703: found /usr/bin/mawk
-configure:1713: result: mawk
-configure:1723: checking whether make sets $(MAKE)
-configure:1743: result: yes
-configure:1949: checking for gcc
-configure:1965: found /usr/bin/gcc
-configure:1975: result: gcc
-configure:2219: checking for C compiler version
-configure:2222: gcc --version &lt;/dev/null &gt;&amp;5
-gcc (GCC) 4.0.4 20060507 (prerelease) (Debian 4.0.3-3)
-Copyright (C) 2006 Free Software Foundation, Inc.
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-
-configure:2225: $? = 0
-configure:2227: gcc -v &lt;/dev/null &gt;&amp;5
-Using built-in specs.
-Target: i486-linux-gnu
-Configured with: ../src/configure -v --enable-languages=c,c++,java,f95,objc,ada,treelang --prefix=/usr --enable-shared --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --enable-nls --program-suffix=-4.0 --enable-__cxa_atexit --enable-clocale=gnu --enable-libstdcxx-debug --enable-java-awt=gtk-default --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.4.2-gcj-4.0-1.4.2.0/jre --enable-mpfr --disable-werror --with-tune=i686 --enable-checking=release i486-linux-gnu
-Thread model: posix
-gcc version 4.0.4 20060507 (prerelease) (Debian 4.0.3-3)
-configure:2230: $? = 0
-configure:2232: gcc -V &lt;/dev/null &gt;&amp;5
-gcc: '-V' option must have argument
-configure:2235: $? = 1
-configure:2258: checking for C compiler default output file name
-configure:2261: gcc    conftest.c  &gt;&amp;5
-configure:2264: $? = 0
-configure:2310: result: a.out
-configure:2315: checking whether the C compiler works
-configure:2321: ./a.out
-configure:2324: $? = 0
-configure:2341: result: yes
-configure:2348: checking whether we are cross compiling
-configure:2350: result: no
-configure:2353: checking for suffix of executables
-configure:2355: gcc -o conftest    conftest.c  &gt;&amp;5
-configure:2358: $? = 0
-configure:2383: result: 
-configure:2389: checking for suffix of object files
-configure:2410: gcc -c   conftest.c &gt;&amp;5
-configure:2413: $? = 0
-configure:2435: result: o
-configure:2439: checking whether we are using the GNU C compiler
-configure:2463: gcc -c   conftest.c &gt;&amp;5
-configure:2469: $? = 0
-configure:2472: test -z 			 || test ! -s conftest.err
-configure:2475: $? = 0
-configure:2478: test -s conftest.o
-configure:2481: $? = 0
-configure:2494: result: yes
-configure:2500: checking whether gcc accepts -g
-configure:2521: gcc -c -g  conftest.c &gt;&amp;5
-configure:2527: $? = 0
-configure:2530: test -z 			 || test ! -s conftest.err
-configure:2533: $? = 0
-configure:2536: test -s conftest.o
-configure:2539: $? = 0
-configure:2550: result: yes
-configure:2567: checking for gcc option to accept ANSI C
-configure:2637: gcc  -c -g -O2  conftest.c &gt;&amp;5
-configure:2643: $? = 0
-configure:2646: test -z 			 || test ! -s conftest.err
-configure:2649: $? = 0
-configure:2652: test -s conftest.o
-configure:2655: $? = 0
-configure:2673: result: none needed
-configure:2691: gcc -c -g -O2  conftest.c &gt;&amp;5
-conftest.c:2: error: syntax error before 'me'
-configure:2697: $? = 1
-configure: failed program was:
-| #ifndef __cplusplus
-|   choke me
-| #endif
-configure:2838: checking for style of include used by make
-configure:2866: result: GNU
-configure:2894: checking dependency style of gcc
-configure:2977: result: gcc3
-configure:2999: checking for flex
-configure:3015: found /usr/bin/flex
-configure:3025: result: flex
-configure:3038: checking for yywrap in -lfl
-configure:3068: gcc -o conftest -g -O2   conftest.c -lfl   &gt;&amp;5
-configure:3074: $? = 0
-configure:3077: test -z 			 || test ! -s conftest.err
-configure:3080: $? = 0
-configure:3083: test -s conftest
-configure:3086: $? = 0
-configure:3099: result: yes
-configure:3176: checking lex output file root
-configure:3187: flex conftest.l
-configure:3190: $? = 0
-configure:3202: result: lex.yy
-configure:3207: checking whether yytext is a pointer
-configure:3223: gcc -o conftest -g -O2   conftest.c  -lfl &gt;&amp;5
-configure:3229: $? = 0
-configure:3232: test -z 			 || test ! -s conftest.err
-configure:3235: $? = 0
-configure:3238: test -s conftest
-configure:3241: $? = 0
-configure:3255: result: yes
-configure:3274: checking how to run the C preprocessor
-configure:3309: gcc -E  conftest.c
-configure:3315: $? = 0
-configure:3347: gcc -E  conftest.c
-conftest.c:10:28: error: ac_nonexistent.h: No such file or directory
-configure:3353: $? = 1
-configure: failed program was:
-| /* confdefs.h.  */
-| 
-| #define PACKAGE_NAME &quot;&quot;
-| #define PACKAGE_TARNAME &quot;&quot;
-| #define PACKAGE_VERSION &quot;&quot;
-| #define PACKAGE_STRING &quot;&quot;
-| #define PACKAGE_BUGREPORT &quot;&quot;
-| #define YYTEXT_POINTER 1
-| /* end confdefs.h.  */
-| #include &lt;ac_nonexistent.h&gt;
-configure:3392: result: gcc -E
-configure:3416: gcc -E  conftest.c
-configure:3422: $? = 0
-configure:3454: gcc -E  conftest.c
-conftest.c:10:28: error: ac_nonexistent.h: No such file or directory
-configure:3460: $? = 1
-configure: failed program was:
-| /* confdefs.h.  */
-| 
-| #define PACKAGE_NAME &quot;&quot;
-| #define PACKAGE_TARNAME &quot;&quot;
-| #define PACKAGE_VERSION &quot;&quot;
-| #define PACKAGE_STRING &quot;&quot;
-| #define PACKAGE_BUGREPORT &quot;&quot;
-| #define YYTEXT_POINTER 1
-| /* end confdefs.h.  */
-| #include &lt;ac_nonexistent.h&gt;
-configure:3504: checking for egrep
-configure:3514: result: grep -E
-configure:3519: checking for ANSI C header files
-configure:3544: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:3550: $? = 0
-configure:3553: test -z 			 || test ! -s conftest.err
-configure:3556: $? = 0
-configure:3559: test -s conftest.o
-configure:3562: $? = 0
-configure:3651: gcc -o conftest -g -O2   conftest.c  &gt;&amp;5
-conftest.c: In function 'main':
-conftest.c:27: warning: incompatible implicit declaration of built-in function 'exit'
-configure:3654: $? = 0
-configure:3656: ./conftest
-configure:3659: $? = 0
-configure:3674: result: yes
-configure:3764: checking build system type
-configure:3782: result: i686-pc-linux-gnu
-configure:3790: checking host system type
-configure:3804: result: i686-pc-linux-gnu
-configure:3812: checking for a sed that does not truncate output
-configure:3866: result: /bin/sed
-configure:3880: checking for ld used by gcc
-configure:3947: result: /usr/bin/ld
-configure:3956: checking if the linker (/usr/bin/ld) is GNU ld
-configure:3971: result: yes
-configure:3976: checking for /usr/bin/ld option to reload object files
-configure:3983: result: -r
-configure:3992: checking for BSD-compatible nm
-configure:4034: result: /usr/bin/nm -B
-configure:4038: checking whether ln -s works
-configure:4042: result: yes
-configure:4049: checking how to recognise dependent libraries
-configure:4223: result: pass_all
-configure:4444: checking for sys/types.h
-configure:4460: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:4466: $? = 0
-configure:4469: test -z 			 || test ! -s conftest.err
-configure:4472: $? = 0
-configure:4475: test -s conftest.o
-configure:4478: $? = 0
-configure:4489: result: yes
-configure:4444: checking for sys/stat.h
-configure:4460: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:4466: $? = 0
-configure:4469: test -z 			 || test ! -s conftest.err
-configure:4472: $? = 0
-configure:4475: test -s conftest.o
-configure:4478: $? = 0
-configure:4489: result: yes
-configure:4444: checking for stdlib.h
-configure:4460: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:4466: $? = 0
-configure:4469: test -z 			 || test ! -s conftest.err
-configure:4472: $? = 0
-configure:4475: test -s conftest.o
-configure:4478: $? = 0
-configure:4489: result: yes
-configure:4444: checking for string.h
-configure:4460: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:4466: $? = 0
-configure:4469: test -z 			 || test ! -s conftest.err
-configure:4472: $? = 0
-configure:4475: test -s conftest.o
-configure:4478: $? = 0
-configure:4489: result: yes
-configure:4444: checking for memory.h
-configure:4460: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:4466: $? = 0
-configure:4469: test -z 			 || test ! -s conftest.err
-configure:4472: $? = 0
-configure:4475: test -s conftest.o
-configure:4478: $? = 0
-configure:4489: result: yes
-configure:4444: checking for strings.h
-configure:4460: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:4466: $? = 0
-configure:4469: test -z 			 || test ! -s conftest.err
-configure:4472: $? = 0
-configure:4475: test -s conftest.o
-configure:4478: $? = 0
-configure:4489: result: yes
-configure:4444: checking for inttypes.h
-configure:4460: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:4466: $? = 0
-configure:4469: test -z 			 || test ! -s conftest.err
-configure:4472: $? = 0
-configure:4475: test -s conftest.o
-configure:4478: $? = 0
-configure:4489: result: yes
-configure:4444: checking for stdint.h
-configure:4460: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:4466: $? = 0
-configure:4469: test -z 			 || test ! -s conftest.err
-configure:4472: $? = 0
-configure:4475: test -s conftest.o
-configure:4478: $? = 0
-configure:4489: result: yes
-configure:4444: checking for unistd.h
-configure:4460: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:4466: $? = 0
-configure:4469: test -z 			 || test ! -s conftest.err
-configure:4472: $? = 0
-configure:4475: test -s conftest.o
-configure:4478: $? = 0
-configure:4489: result: yes
-configure:4515: checking dlfcn.h usability
-configure:4527: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:4533: $? = 0
-configure:4536: test -z 			 || test ! -s conftest.err
-configure:4539: $? = 0
-configure:4542: test -s conftest.o
-configure:4545: $? = 0
-configure:4555: result: yes
-configure:4559: checking dlfcn.h presence
-configure:4569: gcc -E  conftest.c
-configure:4575: $? = 0
-configure:4595: result: yes
-configure:4630: checking for dlfcn.h
-configure:4637: result: yes
-configure:4702: checking for g++
-configure:4718: found /usr/bin/g++
-configure:4728: result: g++
-configure:4744: checking for C++ compiler version
-configure:4747: g++ --version &lt;/dev/null &gt;&amp;5
-g++ (GCC) 4.0.4 20060507 (prerelease) (Debian 4.0.3-3)
-Copyright (C) 2006 Free Software Foundation, Inc.
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-
-configure:4750: $? = 0
-configure:4752: g++ -v &lt;/dev/null &gt;&amp;5
-Using built-in specs.
-Target: i486-linux-gnu
-Configured with: ../src/configure -v --enable-languages=c,c++,java,f95,objc,ada,treelang --prefix=/usr --enable-shared --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --enable-nls --program-suffix=-4.0 --enable-__cxa_atexit --enable-clocale=gnu --enable-libstdcxx-debug --enable-java-awt=gtk-default --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.4.2-gcj-4.0-1.4.2.0/jre --enable-mpfr --disable-werror --with-tune=i686 --enable-checking=release i486-linux-gnu
-Thread model: posix
-gcc version 4.0.4 20060507 (prerelease) (Debian 4.0.3-3)
-configure:4755: $? = 0
-configure:4757: g++ -V &lt;/dev/null &gt;&amp;5
-g++: '-V' option must have argument
-configure:4760: $? = 1
-configure:4763: checking whether we are using the GNU C++ compiler
-configure:4787: g++ -c   conftest.cc &gt;&amp;5
-configure:4793: $? = 0
-configure:4796: test -z 			 || test ! -s conftest.err
-configure:4799: $? = 0
-configure:4802: test -s conftest.o
-configure:4805: $? = 0
-configure:4818: result: yes
-configure:4824: checking whether g++ accepts -g
-configure:4845: g++ -c -g  conftest.cc &gt;&amp;5
-configure:4851: $? = 0
-configure:4854: test -z 			 || test ! -s conftest.err
-configure:4857: $? = 0
-configure:4860: test -s conftest.o
-configure:4863: $? = 0
-configure:4874: result: yes
-configure:4916: g++ -c -g -O2  conftest.cc &gt;&amp;5
-configure:4922: $? = 0
-configure:4925: test -z 			 || test ! -s conftest.err
-configure:4928: $? = 0
-configure:4931: test -s conftest.o
-configure:4934: $? = 0
-configure:4960: g++ -c -g -O2  conftest.cc &gt;&amp;5
-conftest.cc: In function 'int main()':
-conftest.cc:25: error: 'exit' was not declared in this scope
-configure:4966: $? = 1
-configure: failed program was:
-| /* confdefs.h.  */
-| 
-| #define PACKAGE_NAME &quot;&quot;
-| #define PACKAGE_TARNAME &quot;&quot;
-| #define PACKAGE_VERSION &quot;&quot;
-| #define PACKAGE_STRING &quot;&quot;
-| #define PACKAGE_BUGREPORT &quot;&quot;
-| #define YYTEXT_POINTER 1
-| #define STDC_HEADERS 1
-| #define HAVE_SYS_TYPES_H 1
-| #define HAVE_SYS_STAT_H 1
-| #define HAVE_STDLIB_H 1
-| #define HAVE_STRING_H 1
-| #define HAVE_MEMORY_H 1
-| #define HAVE_STRINGS_H 1
-| #define HAVE_INTTYPES_H 1
-| #define HAVE_STDINT_H 1
-| #define HAVE_UNISTD_H 1
-| #define HAVE_DLFCN_H 1
-| /* end confdefs.h.  */
-| 
-| int
-| main ()
-| {
-| exit (42);
-|   ;
-|   return 0;
-| }
-configure:4916: g++ -c -g -O2  conftest.cc &gt;&amp;5
-configure:4922: $? = 0
-configure:4925: test -z 			 || test ! -s conftest.err
-configure:4928: $? = 0
-configure:4931: test -s conftest.o
-configure:4934: $? = 0
-configure:4960: g++ -c -g -O2  conftest.cc &gt;&amp;5
-configure:4966: $? = 0
-configure:4969: test -z 			 || test ! -s conftest.err
-configure:4972: $? = 0
-configure:4975: test -s conftest.o
-configure:4978: $? = 0
-configure:5003: checking dependency style of g++
-configure:5086: result: gcc3
-configure:5108: checking how to run the C++ preprocessor
-configure:5139: g++ -E  conftest.cc
-configure:5145: $? = 0
-configure:5177: g++ -E  conftest.cc
-conftest.cc:24:28: error: ac_nonexistent.h: No such file or directory
-configure:5183: $? = 1
-configure: failed program was:
-| /* confdefs.h.  */
-| 
-| #define PACKAGE_NAME &quot;&quot;
-| #define PACKAGE_TARNAME &quot;&quot;
-| #define PACKAGE_VERSION &quot;&quot;
-| #define PACKAGE_STRING &quot;&quot;
-| #define PACKAGE_BUGREPORT &quot;&quot;
-| #define YYTEXT_POINTER 1
-| #define STDC_HEADERS 1
-| #define HAVE_SYS_TYPES_H 1
-| #define HAVE_SYS_STAT_H 1
-| #define HAVE_STDLIB_H 1
-| #define HAVE_STRING_H 1
-| #define HAVE_MEMORY_H 1
-| #define HAVE_STRINGS_H 1
-| #define HAVE_INTTYPES_H 1
-| #define HAVE_STDINT_H 1
-| #define HAVE_UNISTD_H 1
-| #define HAVE_DLFCN_H 1
-| #ifdef __cplusplus
-| extern &quot;C&quot; void std::exit (int) throw (); using std::exit;
-| #endif
-| /* end confdefs.h.  */
-| #include &lt;ac_nonexistent.h&gt;
-configure:5222: result: g++ -E
-configure:5246: g++ -E  conftest.cc
-configure:5252: $? = 0
-configure:5284: g++ -E  conftest.cc
-conftest.cc:24:28: error: ac_nonexistent.h: No such file or directory
-configure:5290: $? = 1
-configure: failed program was:
-| /* confdefs.h.  */
-| 
-| #define PACKAGE_NAME &quot;&quot;
-| #define PACKAGE_TARNAME &quot;&quot;
-| #define PACKAGE_VERSION &quot;&quot;
-| #define PACKAGE_STRING &quot;&quot;
-| #define PACKAGE_BUGREPORT &quot;&quot;
-| #define YYTEXT_POINTER 1
-| #define STDC_HEADERS 1
-| #define HAVE_SYS_TYPES_H 1
-| #define HAVE_SYS_STAT_H 1
-| #define HAVE_STDLIB_H 1
-| #define HAVE_STRING_H 1
-| #define HAVE_MEMORY_H 1
-| #define HAVE_STRINGS_H 1
-| #define HAVE_INTTYPES_H 1
-| #define HAVE_STDINT_H 1
-| #define HAVE_UNISTD_H 1
-| #define HAVE_DLFCN_H 1
-| #ifdef __cplusplus
-| extern &quot;C&quot; void std::exit (int) throw (); using std::exit;
-| #endif
-| /* end confdefs.h.  */
-| #include &lt;ac_nonexistent.h&gt;
-configure:5385: checking for g77
-configure:5414: result: no
-configure:5385: checking for f77
-configure:5414: result: no
-configure:5385: checking for xlf
-configure:5414: result: no
-configure:5385: checking for frt
-configure:5414: result: no
-configure:5385: checking for pgf77
-configure:5414: result: no
-configure:5385: checking for fort77
-configure:5414: result: no
-configure:5385: checking for fl32
-configure:5414: result: no
-configure:5385: checking for af77
-configure:5414: result: no
-configure:5385: checking for f90
-configure:5414: result: no
-configure:5385: checking for xlf90
-configure:5414: result: no
-configure:5385: checking for pgf90
-configure:5414: result: no
-configure:5385: checking for epcf90
-configure:5414: result: no
-configure:5385: checking for f95
-configure:5414: result: no
-configure:5385: checking for fort
-configure:5414: result: no
-configure:5385: checking for xlf95
-configure:5414: result: no
-configure:5385: checking for ifc
-configure:5414: result: no
-configure:5385: checking for efc
-configure:5414: result: no
-configure:5385: checking for pgf95
-configure:5414: result: no
-configure:5385: checking for lf95
-configure:5414: result: no
-configure:5385: checking for gfortran
-configure:5414: result: no
-configure:5426: checking for Fortran 77 compiler version
-configure:5429:  --version &lt;/dev/null &gt;&amp;5
-./configure: line 5430: --version: command not found
-configure:5432: $? = 127
-configure:5434:  -v &lt;/dev/null &gt;&amp;5
-./configure: line 5435: -v: command not found
-configure:5437: $? = 127
-configure:5439:  -V &lt;/dev/null &gt;&amp;5
-./configure: line 5440: -V: command not found
-configure:5442: $? = 127
-configure:5450: checking whether we are using the GNU Fortran 77 compiler
-configure:5464:  -c  conftest.F &gt;&amp;5
-./configure: line 5465: -c: command not found
-configure:5470: $? = 127
-configure: failed program was:
-|       program main
-| #ifndef __GNUC__
-|        choke me
-| #endif
-| 
-|       end
-configure:5495: result: no
-configure:5501: checking whether  accepts -g
-configure:5513:  -c -g conftest.f &gt;&amp;5
-./configure: line 5514: -c: command not found
-configure:5519: $? = 127
-configure: failed program was:
-|       program main
-| 
-|       end
-configure:5543: result: no
-configure:5573: checking the maximum length of command line arguments
-configure:5638: result: 32768
-configure:5649: checking command to parse /usr/bin/nm -B output from gcc object
-configure:5738: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:5741: $? = 0
-configure:5745: /usr/bin/nm -B conftest.o \| sed -n -e 's/^.*[ 	]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ 	][ 	]*\(\)\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2\3 \3/p' \&gt; conftest.nm
-configure:5748: $? = 0
-configure:5800: gcc -o conftest -g -O2   conftest.c conftstm.o &gt;&amp;5
-configure:5803: $? = 0
-configure:5841: result: ok
-configure:5845: checking for objdir
-configure:5860: result: .libs
-configure:5950: checking for ar
-configure:5966: found /usr/bin/ar
-configure:5977: result: ar
-configure:6030: checking for ranlib
-configure:6046: found /usr/bin/ranlib
-configure:6057: result: ranlib
-configure:6110: checking for strip
-configure:6126: found /usr/bin/strip
-configure:6137: result: strip
-configure:6399: checking if gcc static flag  works
-configure:6422: result: yes
-configure:6440: checking if gcc supports -fno-rtti -fno-exceptions
-configure:6458: gcc -c -g -O2  -fno-rtti -fno-exceptions conftest.c &gt;&amp;5
-cc1: warning: command line option &quot;-fno-rtti&quot; is valid for C++/ObjC++ but not for C
-configure:6462: $? = 0
-configure:6473: result: no
-configure:6488: checking for gcc option to produce PIC
-configure:6665: result: -fPIC
-configure:6673: checking if gcc PIC flag -fPIC works
-configure:6691: gcc -c -g -O2  -fPIC -DPIC conftest.c &gt;&amp;5
-configure:6695: $? = 0
-configure:6706: result: yes
-configure:6730: checking if gcc supports -c -o file.o
-configure:6751: gcc -c -g -O2  -o out/conftest2.o conftest.c &gt;&amp;5
-configure:6755: $? = 0
-configure:6775: result: yes
-configure:6801: checking whether the gcc linker (/usr/bin/ld) supports shared libraries
-configure:7648: result: yes
-configure:7674: checking whether -lc should be explicitly linked in
-configure:7679: gcc -c -g -O2  conftest.c &gt;&amp;5
-configure:7682: $? = 0
-configure:7696: gcc -shared conftest.o  -v -Wl,-soname -Wl,conftest -o conftest 2\&gt;\&amp;1 \| grep  -lc  \&gt;/dev/null 2\&gt;\&amp;1
-configure:7699: $? = 0
-configure:7711: result: no
-configure:7719: checking dynamic linker characteristics
-configure:8271: result: GNU/Linux ld.so
-configure:8275: checking how to hardcode library paths into programs
-configure:8300: result: immediate
-configure:8314: checking whether stripping libraries is possible
-configure:8319: result: yes
-configure:9142: checking if libtool supports shared libraries
-configure:9144: result: yes
-configure:9147: checking whether to build shared libraries
-configure:9205: result: yes
-configure:9208: checking whether to build static libraries
-configure:9212: result: no
-configure:9304: creating libtool
-configure:9851: checking for ld used by g++
-configure:9918: result: /usr/bin/ld
-configure:9927: checking if the linker (/usr/bin/ld) is GNU ld
-configure:9942: result: yes
-configure:9993: checking whether the g++ linker (/usr/bin/ld) supports shared libraries
-configure:10819: result: yes
-configure:10837: g++ -c -g -O2  conftest.cc &gt;&amp;5
-configure:10840: $? = 0
-configure:10936: checking for g++ option to produce PIC
-configure:11188: result: -fPIC
-configure:11196: checking if g++ PIC flag -fPIC works
-configure:11214: g++ -c -g -O2  -fPIC -DPIC conftest.cc &gt;&amp;5
-configure:11218: $? = 0
-configure:11229: result: yes
-configure:11253: checking if g++ supports -c -o file.o
-configure:11274: g++ -c -g -O2  -o out/conftest2.o conftest.cc &gt;&amp;5
-configure:11278: $? = 0
-configure:11298: result: yes
-configure:11324: checking whether the g++ linker (/usr/bin/ld) supports shared libraries
-configure:11352: result: yes
-configure:11423: checking dynamic linker characteristics
-configure:11975: result: GNU/Linux ld.so
-configure:11979: checking how to hardcode library paths into programs
-configure:12004: result: immediate
-configure:12018: checking whether stripping libraries is possible
-configure:12023: result: yes
-configure:19394: checking for pkg-config
-configure:19412: found /usr/bin/pkg-config
-configure:19425: result: /usr/bin/pkg-config
-configure:19448: checking for GLIB - version &gt;= 2.0.0
-configure:19567: gcc -o conftest -g -O2 -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include     conftest.c -Wl,--export-dynamic -lgmodule-2.0 -ldl -lgobject-2.0 -lglib-2.0    &gt;&amp;5
-configure:19570: $? = 0
-configure:19572: ./conftest
-configure:19575: $? = 0
-configure:19593: result: yes (version 2.10.2)
-configure:19712: checking for pkg-config
-configure:19743: result: /usr/bin/pkg-config
-configure:19764: checking for GTK+ - version &gt;= 2.0.0
-configure:19909: result: no
-configure:19942: gcc -o conftest -g -O2    conftest.c   &gt;&amp;5
-conftest.c:25:21: error: gtk/gtk.h: No such file or directory
-conftest.c: In function 'main':
-conftest.c:31: error: 'gtk_major_version' undeclared (first use in this function)
-conftest.c:31: error: (Each undeclared identifier is reported only once
-conftest.c:31: error: for each function it appears in.)
-conftest.c:31: error: 'gtk_minor_version' undeclared (first use in this function)
-conftest.c:31: error: 'gtk_micro_version' undeclared (first use in this function)
-configure:19948: $? = 1
-configure: failed program was:
-| /* confdefs.h.  */
-| 
-| #define PACKAGE_NAME &quot;&quot;
-| #define PACKAGE_TARNAME &quot;&quot;
-| #define PACKAGE_VERSION &quot;&quot;
-| #define PACKAGE_STRING &quot;&quot;
-| #define PACKAGE_BUGREPORT &quot;&quot;
-| #define YYTEXT_POINTER 1
-| #define STDC_HEADERS 1
-| #define HAVE_SYS_TYPES_H 1
-| #define HAVE_SYS_STAT_H 1
-| #define HAVE_STDLIB_H 1
-| #define HAVE_STRING_H 1
-| #define HAVE_MEMORY_H 1
-| #define HAVE_STRINGS_H 1
-| #define HAVE_INTTYPES_H 1
-| #define HAVE_STDINT_H 1
-| #define HAVE_UNISTD_H 1
-| #define HAVE_DLFCN_H 1
-| #ifdef __cplusplus
-| extern &quot;C&quot; void std::exit (int) throw (); using std::exit;
-| #endif
-| /* end confdefs.h.  */
-| 
-| #include &lt;gtk/gtk.h&gt;
-| #include &lt;stdio.h&gt;
-| 
-| int
-| main ()
-| {
-|  return ((gtk_major_version) || (gtk_minor_version) || (gtk_micro_version));
-|   ;
-|   return 0;
-| }
-configure:20010: checking for debug level
-configure:20019: result: 0
-configure:20184: creating ./config.status
-
-## ---------------------- ##
-## Running config.status. ##
-## ---------------------- ##
-
-This file was extended by config.status, which was
-generated by GNU Autoconf 2.59.  Invocation command line was
-
-  CONFIG_FILES    = 
-  CONFIG_HEADERS  = 
-  CONFIG_LINKS    = 
-  CONFIG_COMMANDS = 
-  $ ./config.status 
-
-on turgot
-
-config.status:784: creating Makefile
-config.status:784: creating doc/Makefile
-config.status:784: creating doc/api/Makefile
-config.status:784: creating include/Makefile
-config.status:784: creating include/g3d/Makefile
-config.status:784: creating m4/Makefile
-config.status:784: creating plugins/Makefile
-config.status:784: creating plugins/image/Makefile
-config.status:784: creating plugins/import/Makefile
-config.status:784: creating src/Makefile
-config.status:784: creating tests/Makefile
-config.status:784: creating libg3d.pc
-config.status:850: creating include/g3d/config.h
-config.status:1138: executing depfiles commands
-
-## ---------------- ##
-## Cache variables. ##
-## ---------------- ##
-
-ac_cv_build=i686-pc-linux-gnu
-ac_cv_build_alias=i686-pc-linux-gnu
-ac_cv_c_compiler_gnu=yes
-ac_cv_cxx_compiler_gnu=yes
-ac_cv_env_CC_set=
-ac_cv_env_CC_value=
-ac_cv_env_CFLAGS_set=
-ac_cv_env_CFLAGS_value=
-ac_cv_env_CPPFLAGS_set=
-ac_cv_env_CPPFLAGS_value=
-ac_cv_env_CPP_set=
-ac_cv_env_CPP_value=
-ac_cv_env_CXXCPP_set=
-ac_cv_env_CXXCPP_value=
-ac_cv_env_CXXFLAGS_set=
-ac_cv_env_CXXFLAGS_value=
-ac_cv_env_CXX_set=
-ac_cv_env_CXX_value=
-ac_cv_env_F77_set=
-ac_cv_env_F77_value=
-ac_cv_env_FFLAGS_set=
-ac_cv_env_FFLAGS_value=
-ac_cv_env_LDFLAGS_set=
-ac_cv_env_LDFLAGS_value=
-ac_cv_env_build_alias_set=
-ac_cv_env_build_alias_value=
-ac_cv_env_host_alias_set=
-ac_cv_env_host_alias_value=
-ac_cv_env_target_alias_set=
-ac_cv_env_target_alias_value=
-ac_cv_exeext=
-ac_cv_f77_compiler_gnu=no
-ac_cv_header_dlfcn_h=yes
-ac_cv_header_inttypes_h=yes
-ac_cv_header_memory_h=yes
-ac_cv_header_stdc=yes
-ac_cv_header_stdint_h=yes
-ac_cv_header_stdlib_h=yes
-ac_cv_header_string_h=yes
-ac_cv_header_strings_h=yes
-ac_cv_header_sys_stat_h=yes
-ac_cv_header_sys_types_h=yes
-ac_cv_header_unistd_h=yes
-ac_cv_host=i686-pc-linux-gnu
-ac_cv_host_alias=i686-pc-linux-gnu
-ac_cv_lib_fl_yywrap=yes
-ac_cv_objext=o
-ac_cv_path_PKG_CONFIG=/usr/bin/pkg-config
-ac_cv_path_install='/usr/bin/install -c'
-ac_cv_prog_AWK=mawk
-ac_cv_prog_CPP='gcc -E'
-ac_cv_prog_CXXCPP='g++ -E'
-ac_cv_prog_LEX=flex
-ac_cv_prog_ac_ct_AR=ar
-ac_cv_prog_ac_ct_CC=gcc
-ac_cv_prog_ac_ct_CXX=g++
-ac_cv_prog_ac_ct_RANLIB=ranlib
-ac_cv_prog_ac_ct_STRIP=strip
-ac_cv_prog_cc_g=yes
-ac_cv_prog_cc_stdc=
-ac_cv_prog_cxx_g=yes
-ac_cv_prog_egrep='grep -E'
-ac_cv_prog_f77_g=no
-ac_cv_prog_lex_root=lex.yy
-ac_cv_prog_lex_yytext_pointer=yes
-ac_cv_prog_make_make_set=yes
-am_cv_CC_dependencies_compiler_type=gcc3
-am_cv_CXX_dependencies_compiler_type=gcc3
-lt_cv_deplibs_check_method=pass_all
-lt_cv_file_magic_cmd='$MAGIC_CMD'
-lt_cv_file_magic_test_file=
-lt_cv_ld_reload_flag=-r
-lt_cv_objdir=.libs
-lt_cv_path_LD=/usr/bin/ld
-lt_cv_path_LDCXX=/usr/bin/ld
-lt_cv_path_NM='/usr/bin/nm -B'
-lt_cv_path_SED=/bin/sed
-lt_cv_prog_compiler_c_o=yes
-lt_cv_prog_compiler_c_o_CXX=yes
-lt_cv_prog_compiler_rtti_exceptions=no
-lt_cv_prog_gnu_ld=yes
-lt_cv_prog_gnu_ldcxx=yes
-lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[ 	]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ 	][ 	]*\(\)\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2\3 \3/p'\'''
-lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\) $/  {\&quot;\1\&quot;, (lt_ptr) 0},/p'\'' -e '\''s/^[BCDEGRST] \([^ ]*\) \([^ ]*\)$/  {&quot;\2&quot;, (lt_ptr) \&amp;\2},/p'\'''
-lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^. .* \(.*\)$/extern int \1;/p'\'''
-lt_cv_sys_max_cmd_len=32768
-lt_lt_cv_prog_compiler_c_o='&quot;yes&quot;'
-lt_lt_cv_prog_compiler_c_o_CXX='&quot;yes&quot;'
-lt_lt_cv_sys_global_symbol_pipe='&quot;sed -n -e '\''s/^.*[ 	]\\([ABCDGIRSTW][ABCDGIRSTW]*\\)[ 	][ 	]*\\(\\)\\([_A-Za-z][_A-Za-z0-9]*\\)\$/\\1 \\2\\3 \\3/p'\''&quot;'
-lt_lt_cv_sys_global_symbol_to_c_name_address='&quot;sed -n -e '\''s/^: \\([^ ]*\\) \$/  {\\\&quot;\\1\\\&quot;, (lt_ptr) 0},/p'\'' -e '\''s/^[BCDEGRST] \\([^ ]*\\) \\([^ ]*\\)\$/  {\&quot;\\2\&quot;, (lt_ptr) \\&amp;\\2},/p'\''&quot;'
-lt_lt_cv_sys_global_symbol_to_cdecl='&quot;sed -n -e '\''s/^. .* \\(.*\\)\$/extern int \\1;/p'\''&quot;'
-
-## ----------------- ##
-## Output variables. ##
-## ----------------- ##
-
-ACLOCAL='${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run aclocal-1.7'
-AMDEPBACKSLASH='\'
-AMDEP_FALSE='#'
-AMDEP_TRUE=''
-AMTAR='${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run tar'
-AR='ar'
-AUTOCONF='${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run autoconf'
-AUTOHEADER='${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run autoheader'
-AUTOMAKE='${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run automake-1.7'
-AWK='mawk'
-CC='gcc'
-CCDEPMODE='depmode=gcc3'
-CFLAGS='-g -O2'
-CPP='gcc -E'
-CPPFLAGS=''
-CXX='g++'
-CXXCPP='g++ -E'
-CXXDEPMODE='depmode=gcc3'
-CXXFLAGS='-g -O2'
-CYGPATH_W='echo'
-DBG_CFLAGS='-O2'
-DEBUG='0'
-DEFS='-DHAVE_CONFIG_H'
-DEPDIR='.deps'
-ECHO='echo'
-ECHO_C=''
-ECHO_N='-n'
-ECHO_T=''
-EGREP='grep -E'
-ENABLE_GTK_DOC_FALSE=''
-ENABLE_GTK_DOC_TRUE='#'
-EXEEXT=''
-F77=''
-FFLAGS=''
-GDKPIXBUF_CFLAGS=''
-GDKPIXBUF_LIBS=''
-GLIB_CFLAGS='-I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  '
-GLIB_GENMARSHAL='glib-genmarshal'
-GLIB_LIBS='-Wl,--export-dynamic -lgmodule-2.0 -ldl -lgobject-2.0 -lglib-2.0  '
-GLIB_MKENUMS='glib-mkenums'
-GOBJECT_QUERY='gobject-query'
-GTK_CFLAGS=''
-GTK_DOC_USE_LIBTOOL_FALSE='#'
-GTK_DOC_USE_LIBTOOL_TRUE=''
-GTK_LIBS=''
-HAVE_GDKPIXBUF_FALSE=''
-HAVE_GDKPIXBUF_TRUE='#'
-HTML_DIR='${datadir}/gtk-doc/html'
-INSTALL_DATA='${INSTALL} -m 644'
-INSTALL_PROGRAM='${INSTALL}'
-INSTALL_SCRIPT='${INSTALL}'
-INSTALL_STRIP_PROGRAM='${SHELL} $(install_sh) -c -s'
-LDFLAGS=''
-LEX='flex'
-LEXLIB='-lfl'
-LEX_OUTPUT_ROOT='lex.yy'
-LIBOBJS=''
-LIBS=''
-LIBTOOL='$(SHELL) $(top_builddir)/libtool'
-LN_S='ln -s'
-LTLIBOBJS=''
-MAKEINFO='${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run makeinfo'
-OBJEXT='o'
-PACKAGE='libg3d'
-PACKAGE_BUGREPORT=''
-PACKAGE_NAME=''
-PACKAGE_STRING=''
-PACKAGE_TARNAME=''
-PACKAGE_VERSION=''
-PATH_SEPARATOR=':'
-PKG_CONFIG='/usr/bin/pkg-config'
-PLUGINS_LDFLAGS='-avoid-version -export-dynamic'
-RANLIB='ranlib'
-SET_MAKE=''
-SHELL='/bin/sh'
-STRIP='strip'
-VERSION='0.0.3'
-ac_ct_AR='ar'
-ac_ct_CC='gcc'
-ac_ct_CXX='g++'
-ac_ct_F77=''
-ac_ct_RANLIB='ranlib'
-ac_ct_STRIP='strip'
-am__fastdepCC_FALSE='#'
-am__fastdepCC_TRUE=''
-am__fastdepCXX_FALSE='#'
-am__fastdepCXX_TRUE=''
-am__include='include'
-am__leading_dot='.'
-am__quote=''
-bindir='${exec_prefix}/bin'
-build='i686-pc-linux-gnu'
-build_alias=''
-build_cpu='i686'
-build_os='linux-gnu'
-build_vendor='pc'
-datadir='${prefix}/share'
-exec_prefix='${prefix}'
-host='i686-pc-linux-gnu'
-host_alias=''
-host_cpu='i686'
-host_os='linux-gnu'
-host_vendor='pc'
-includedir='${prefix}/include'
-infodir='${prefix}/info'
-install_sh='/home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/install-sh'
-libdir='${exec_prefix}/lib'
-libexecdir='${exec_prefix}/libexec'
-localstatedir='${prefix}/var'
-mandir='${prefix}/man'
-oldincludedir='/usr/include'
-prefix='/usr/local'
-program_transform_name='s,x,x,'
-sbindir='${exec_prefix}/sbin'
-sharedstatedir='${prefix}/com'
-sysconfdir='${prefix}/etc'
-target_alias=''
-
-## ----------- ##
-## confdefs.h. ##
-## ----------- ##
-
-#define HAVE_DLFCN_H 1
-#define HAVE_INTTYPES_H 1
-#define HAVE_MEMORY_H 1
-#define HAVE_STDINT_H 1
-#define HAVE_STDLIB_H 1
-#define HAVE_STRINGS_H 1
-#define HAVE_STRING_H 1
-#define HAVE_SYS_STAT_H 1
-#define HAVE_SYS_TYPES_H 1
-#define HAVE_UNISTD_H 1
-#define PACKAGE_BUGREPORT &quot;&quot;
-#define PACKAGE_NAME &quot;&quot;
-#define PACKAGE_STRING &quot;&quot;
-#define PACKAGE_TARNAME &quot;&quot;
-#define PACKAGE_VERSION &quot;&quot;
-#define PLUGIN_DIR &quot;/usr/local/lib/libg3d/plugins&quot;
-#define STDC_HEADERS 1
-#define YYTEXT_POINTER 1
-#endif
-#ifdef __cplusplus
-extern &quot;C&quot; void std::exit (int) throw (); using std::exit;
-
-configure: exit 0

Deleted: trunk/libg3d/config.status
===================================================================
--- trunk/libg3d/config.status	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libg3d/config.status	2006-05-25 17:11:46 UTC (rev 295)
@@ -1,1235 +0,0 @@
-#! /bin/sh
-# Generated by configure.
-# Run this file to recreate the current configuration.
-# Compiler output produced by configure, useful for debugging
-# configure, is in config.log if it exists.
-
-debug=false
-ac_cs_recheck=false
-ac_cs_silent=false
-SHELL=${CONFIG_SHELL-/bin/sh}
-## --------------------- ##
-## M4sh Initialization.  ##
-## --------------------- ##
-
-# Be Bourne compatible
-if test -n &quot;${ZSH_VERSION+set}&quot; &amp;&amp; (emulate sh) &gt;/dev/null 2&gt;&amp;1; then
-  emulate sh
-  NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+&quot;$@&quot;}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+&quot;$@&quot;}'='&quot;$@&quot;'
-elif test -n &quot;${BASH_VERSION+set}&quot; &amp;&amp; (set -o posix) &gt;/dev/null 2&gt;&amp;1; then
-  set -o posix
-fi
-DUALCASE=1; export DUALCASE # for MKS sh
-
-# Support unset when possible.
-if ( (MAIL=60; unset MAIL) || exit) &gt;/dev/null 2&gt;&amp;1; then
-  as_unset=unset
-else
-  as_unset=false
-fi
-
-
-# Work around bugs in pre-3.0 UWIN ksh.
-$as_unset ENV MAIL MAILPATH
-PS1='$ '
-PS2='&gt; '
-PS4='+ '
-
-# NLS nuisances.
-for as_var in \
-  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
-  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
-  LC_TELEPHONE LC_TIME
-do
-  if (set +x; test -z &quot;`(eval $as_var=C; export $as_var) 2&gt;&amp;1`&quot;); then
-    eval $as_var=C; export $as_var
-  else
-    $as_unset $as_var
-  fi
-done
-
-# Required to use basename.
-if expr a : '\(a\)' &gt;/dev/null 2&gt;&amp;1; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename /) &gt;/dev/null 2&gt;&amp;1 &amp;&amp; test &quot;X`basename / 2&gt;&amp;1`&quot; = &quot;X/&quot;; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-
-# Name of the executable.
-as_me=`$as_basename &quot;$0&quot; ||
-$as_expr X/&quot;$0&quot; : '.*/\([^/][^/]*\)/*$' \| \
-	 X&quot;$0&quot; : 'X\(//\)$' \| \
-	 X&quot;$0&quot; : 'X\(/\)$' \| \
-	 .     : '\(.\)' 2&gt;/dev/null ||
-echo X/&quot;$0&quot; |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
-  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\/\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-
-
-# PATH needs CR, and LINENO needs CR and PATH.
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-# The user is always right.
-if test &quot;${PATH_SEPARATOR+set}&quot; != set; then
-  echo &quot;#! /bin/sh&quot; &gt;conf$$.sh
-  echo  &quot;exit 0&quot;   &gt;&gt;conf$$.sh
-  chmod +x conf$$.sh
-  if (PATH=&quot;/nonexistent;.&quot;; conf$$.sh) &gt;/dev/null 2&gt;&amp;1; then
-    PATH_SEPARATOR=';'
-  else
-    PATH_SEPARATOR=:
-  fi
-  rm -f conf$$.sh
-fi
-
-
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  as_lineno_3=`(expr $as_lineno_1 + 1) 2&gt;/dev/null`
-  test &quot;x$as_lineno_1&quot; != &quot;x$as_lineno_2&quot; &amp;&amp;
-  test &quot;x$as_lineno_3&quot;  = &quot;x$as_lineno_2&quot;  || {
-  # Find who we are.  Look in the path if we contain no path at all
-  # relative or not.
-  case $0 in
-    *[\\/]* ) as_myself=$0 ;;
-    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
-  test -r &quot;$as_dir/$0&quot; &amp;&amp; as_myself=$as_dir/$0 &amp;&amp; break
-done
-
-       ;;
-  esac
-  # We did not find ourselves, most probably we were run as `sh COMMAND'
-  # in which case we are not to be found in the path.
-  if test &quot;x$as_myself&quot; = x; then
-    as_myself=$0
-  fi
-  if test ! -f &quot;$as_myself&quot;; then
-    { { echo &quot;$as_me:$LINENO: error: cannot find myself; rerun with an absolute path&quot; &gt;&amp;5
-echo &quot;$as_me: error: cannot find myself; rerun with an absolute path&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; }
-  fi
-  case $CONFIG_SHELL in
-  '')
-    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
-do
-  IFS=$as_save_IFS
-  test -z &quot;$as_dir&quot; &amp;&amp; as_dir=.
-  for as_base in sh bash ksh sh5; do
-	 case $as_dir in
-	 /*)
-	   if (&quot;$as_dir/$as_base&quot; -c '
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  as_lineno_3=`(expr $as_lineno_1 + 1) 2&gt;/dev/null`
-  test &quot;x$as_lineno_1&quot; != &quot;x$as_lineno_2&quot; &amp;&amp;
-  test &quot;x$as_lineno_3&quot;  = &quot;x$as_lineno_2&quot; ') 2&gt;/dev/null; then
-	     $as_unset BASH_ENV || test &quot;${BASH_ENV+set}&quot; != set || { BASH_ENV=; export BASH_ENV; }
-	     $as_unset ENV || test &quot;${ENV+set}&quot; != set || { ENV=; export ENV; }
-	     CONFIG_SHELL=$as_dir/$as_base
-	     export CONFIG_SHELL
-	     exec &quot;$CONFIG_SHELL&quot; &quot;$0&quot; ${1+&quot;$@&quot;}
-	   fi;;
-	 esac
-       done
-done
-;;
-  esac
-
-  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
-  # uniformly replaced by the line number.  The first 'sed' inserts a
-  # line-number line before each line; the second 'sed' does the real
-  # work.  The second script uses 'N' to pair each line-number line
-  # with the numbered line, and appends trailing '-' during
-  # substitution so that $LINENO is not a special case at line end.
-  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
-  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
-  sed '=' &lt;$as_myself |
-    sed '
-      N
-      s,$,-,
-      : loop
-      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
-      t loop
-      s,-$,,
-      s,^['$as_cr_digits']*\n,,
-    ' &gt;$as_me.lineno &amp;&amp;
-  chmod +x $as_me.lineno ||
-    { { echo &quot;$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell&quot; &gt;&amp;5
-echo &quot;$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; }
-
-  # Don't try to exec as it changes $[0], causing all sort of problems
-  # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensible to this).
-  . ./$as_me.lineno
-  # Exit status is that of the last command.
-  exit
-}
-
-
-case `echo &quot;testing\c&quot;; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
-  *c*,-n*) ECHO_N= ECHO_C='
-' ECHO_T='	' ;;
-  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
-  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
-esac
-
-if expr a : '\(a\)' &gt;/dev/null 2&gt;&amp;1; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-rm -f conf$$ conf$$.exe conf$$.file
-echo &gt;conf$$.file
-if ln -s conf$$.file conf$$ 2&gt;/dev/null; then
-  # We could just check for DJGPP; but this test a) works b) is more generic
-  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
-  if test -f conf$$.exe; then
-    # Don't use ln at all; we don't have any links
-    as_ln_s='cp -p'
-  else
-    as_ln_s='ln -s'
-  fi
-elif ln conf$$.file conf$$ 2&gt;/dev/null; then
-  as_ln_s=ln
-else
-  as_ln_s='cp -p'
-fi
-rm -f conf$$ conf$$.exe conf$$.file
-
-if mkdir -p . 2&gt;/dev/null; then
-  as_mkdir_p=:
-else
-  test -d ./-p &amp;&amp; rmdir ./-p
-  as_mkdir_p=false
-fi
-
-as_executable_p=&quot;test -f&quot;
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp=&quot;eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'&quot;
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh=&quot;eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'&quot;
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.
-as_nl='
-'
-IFS=&quot; 	$as_nl&quot;
-
-# CDPATH.
-$as_unset CDPATH
-
-exec 6&gt;&amp;1
-
-# Open the log real soon, to keep \$[0] and so on meaningful, and to
-# report actual input values of CONFIG_FILES etc. instead of their
-# values after options handling.  Logging --version etc. is OK.
-exec 5&gt;&gt;config.log
-{
-  echo
-  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' &lt;&lt;_ASBOX
-## Running $as_me. ##
-_ASBOX
-} &gt;&amp;5
-cat &gt;&amp;5 &lt;&lt;_CSEOF
-
-This file was extended by $as_me, which was
-generated by GNU Autoconf 2.59.  Invocation command line was
-
-  CONFIG_FILES    = $CONFIG_FILES
-  CONFIG_HEADERS  = $CONFIG_HEADERS
-  CONFIG_LINKS    = $CONFIG_LINKS
-  CONFIG_COMMANDS = $CONFIG_COMMANDS
-  $ $0 $@
-
-_CSEOF
-echo &quot;on `(hostname || uname -n) 2&gt;/dev/null | sed 1q`&quot; &gt;&amp;5
-echo &gt;&amp;5
-config_files=&quot; Makefile doc/Makefile doc/api/Makefile include/Makefile include/g3d/Makefile m4/Makefile plugins/Makefile plugins/image/Makefile plugins/import/Makefile src/Makefile tests/Makefile libg3d.pc&quot;
-config_headers=&quot; include/g3d/config.h&quot;
-config_commands=&quot; depfiles&quot;
-
-ac_cs_usage=&quot;\
-\`$as_me' instantiates files from templates according to the
-current configuration.
-
-Usage: $0 [OPTIONS] [FILE]...
-
-  -h, --help       print this help, then exit
-  -V, --version    print version number, then exit
-  -q, --quiet      do not print progress messages
-  -d, --debug      don't remove temporary files
-      --recheck    update $as_me by reconfiguring in the same conditions
-  --file=FILE[:TEMPLATE]
-		   instantiate the configuration file FILE
-  --header=FILE[:TEMPLATE]
-		   instantiate the configuration header FILE
-
-Configuration files:
-$config_files
-
-Configuration headers:
-$config_headers
-
-Configuration commands:
-$config_commands
-
-Report bugs to &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">bug-autoconf at gnu.org</A>&gt;.&quot;
-ac_cs_version=&quot;\
-config.status
-configured by ./configure, generated by GNU Autoconf 2.59,
-  with options \&quot;\&quot;
-
-Copyright (C) 2003 Free Software Foundation, Inc.
-This config.status script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it.&quot;
-srcdir=.
-INSTALL=&quot;/usr/bin/install -c&quot;
-# If no file are specified by the user, then we need to provide default
-# value.  By we need to know if files were specified by the user.
-ac_need_defaults=:
-while test $# != 0
-do
-  case $1 in
-  --*=*)
-    ac_option=`expr &quot;x$1&quot; : 'x\([^=]*\)='`
-    ac_optarg=`expr &quot;x$1&quot; : 'x[^=]*=\(.*\)'`
-    ac_shift=:
-    ;;
-  -*)
-    ac_option=$1
-    ac_optarg=$2
-    ac_shift=shift
-    ;;
-  *) # This is not an option, so the user has probably given explicit
-     # arguments.
-     ac_option=$1
-     ac_need_defaults=false;;
-  esac
-
-  case $ac_option in
-  # Handling of the options.
-  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-    ac_cs_recheck=: ;;
-  --version | --vers* | -V )
-    echo &quot;$ac_cs_version&quot;; exit 0 ;;
-  --he | --h)
-    # Conflict between --help and --header
-    { { echo &quot;$as_me:$LINENO: error: ambiguous option: $1
-Try \`$0 --help' for more information.&quot; &gt;&amp;5
-echo &quot;$as_me: error: ambiguous option: $1
-Try \`$0 --help' for more information.&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; };;
-  --help | --hel | -h )
-    echo &quot;$ac_cs_usage&quot;; exit 0 ;;
-  --debug | --d* | -d )
-    debug=: ;;
-  --file | --fil | --fi | --f )
-    $ac_shift
-    CONFIG_FILES=&quot;$CONFIG_FILES $ac_optarg&quot;
-    ac_need_defaults=false;;
-  --header | --heade | --head | --hea )
-    $ac_shift
-    CONFIG_HEADERS=&quot;$CONFIG_HEADERS $ac_optarg&quot;
-    ac_need_defaults=false;;
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil | --si | --s)
-    ac_cs_silent=: ;;
-
-  # This is an error.
-  -*) { { echo &quot;$as_me:$LINENO: error: unrecognized option: $1
-Try \`$0 --help' for more information.&quot; &gt;&amp;5
-echo &quot;$as_me: error: unrecognized option: $1
-Try \`$0 --help' for more information.&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; } ;;
-
-  *) ac_config_targets=&quot;$ac_config_targets $1&quot; ;;
-
-  esac
-  shift
-done
-
-ac_configure_extra_args=
-
-if $ac_cs_silent; then
-  exec 6&gt;/dev/null
-  ac_configure_extra_args=&quot;$ac_configure_extra_args --silent&quot;
-fi
-
-if $ac_cs_recheck; then
-  echo &quot;running /bin/sh ./configure &quot;  $ac_configure_extra_args &quot; --no-create --no-recursion&quot; &gt;&amp;6
-  exec /bin/sh ./configure  $ac_configure_extra_args --no-create --no-recursion
-fi
-
-#
-# INIT-COMMANDS section.
-#
-
-AMDEP_TRUE=&quot;&quot; ac_aux_dir=&quot;config&quot;
-
-for ac_config_target in $ac_config_targets
-do
-  case &quot;$ac_config_target&quot; in
-  # Handling of arguments.
-  &quot;Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES Makefile&quot; ;;
-  &quot;doc/Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES doc/Makefile&quot; ;;
-  &quot;doc/api/Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES doc/api/Makefile&quot; ;;
-  &quot;include/Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES include/Makefile&quot; ;;
-  &quot;include/g3d/Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES include/g3d/Makefile&quot; ;;
-  &quot;m4/Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES m4/Makefile&quot; ;;
-  &quot;plugins/Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES plugins/Makefile&quot; ;;
-  &quot;plugins/image/Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES plugins/image/Makefile&quot; ;;
-  &quot;plugins/import/Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES plugins/import/Makefile&quot; ;;
-  &quot;src/Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES src/Makefile&quot; ;;
-  &quot;tests/Makefile&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES tests/Makefile&quot; ;;
-  &quot;libg3d.pc&quot; ) CONFIG_FILES=&quot;$CONFIG_FILES libg3d.pc&quot; ;;
-  &quot;depfiles&quot; ) CONFIG_COMMANDS=&quot;$CONFIG_COMMANDS depfiles&quot; ;;
-  &quot;include/g3d/config.h&quot; ) CONFIG_HEADERS=&quot;$CONFIG_HEADERS include/g3d/config.h&quot; ;;
-  *) { { echo &quot;$as_me:$LINENO: error: invalid argument: $ac_config_target&quot; &gt;&amp;5
-echo &quot;$as_me: error: invalid argument: $ac_config_target&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; };;
-  esac
-done
-
-# If the user did not use the arguments to specify the items to instantiate,
-# then the envvar interface is used.  Set only those that are not.
-# We use the long form for the default assignment because of an extremely
-# bizarre bug on SunOS 4.1.3.
-if $ac_need_defaults; then
-  test &quot;${CONFIG_FILES+set}&quot; = set || CONFIG_FILES=$config_files
-  test &quot;${CONFIG_HEADERS+set}&quot; = set || CONFIG_HEADERS=$config_headers
-  test &quot;${CONFIG_COMMANDS+set}&quot; = set || CONFIG_COMMANDS=$config_commands
-fi
-
-# Have a temporary directory for convenience.  Make it in the build tree
-# simply because there is no reason to put it here, and in addition,
-# creating and moving files from /tmp can sometimes cause problems.
-# Create a temporary directory, and hook for its removal unless debugging.
-$debug ||
-{
-  trap 'exit_status=$?; rm -rf $tmp &amp;&amp; exit $exit_status' 0
-  trap '{ (exit 1); exit 1; }' 1 2 13 15
-}
-
-# Create a (secure) tmp directory for tmp files.
-
-{
-  tmp=`(umask 077 &amp;&amp; mktemp -d -q &quot;./confstatXXXXXX&quot;) 2&gt;/dev/null` &amp;&amp;
-  test -n &quot;$tmp&quot; &amp;&amp; test -d &quot;$tmp&quot;
-}  ||
-{
-  tmp=./confstat$$-$RANDOM
-  (umask 077 &amp;&amp; mkdir $tmp)
-} ||
-{
-   echo &quot;$me: cannot create a temporary directory in .&quot; &gt;&amp;2
-   { (exit 1); exit 1; }
-}
-
-
-#
-# CONFIG_FILES section.
-#
-
-# No need to generate the scripts if there are no CONFIG_FILES.
-# This happens for instance when ./config.status config.h
-if test -n &quot;$CONFIG_FILES&quot;; then
-  # Protect against being on the right side of a sed subst in config.status.
-  sed 's/,@/@@/; s/@,/@@/; s/,;t t$/@;t t/; /@;t t$/s/[\\&amp;,]/\\&amp;/g;
-   s/@@/,@/; s/@@/@,/; s/@;t t$/,;t t/' &gt;$tmp/subs.sed &lt;&lt;\CEOF
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at SHELL</A>@,/bin/sh,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at PATH_SEPARATOR</A>@,:,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at PACKAGE_NAME</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at PACKAGE_TARNAME</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at PACKAGE_VERSION</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at PACKAGE_STRING</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at PACKAGE_BUGREPORT</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at exec_prefix</A>@,${prefix},;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at prefix</A>@,/usr/local,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at program_transform_name</A>@,s,x,x,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at bindir</A>@,${exec_prefix}/bin,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at sbindir</A>@,${exec_prefix}/sbin,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at libexecdir</A>@,${exec_prefix}/libexec,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at datadir</A>@,${prefix}/share,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at sysconfdir</A>@,${prefix}/etc,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at sharedstatedir</A>@,${prefix}/com,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at localstatedir</A>@,${prefix}/var,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at libdir</A>@,${exec_prefix}/lib,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at includedir</A>@,${prefix}/include,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at oldincludedir</A>@,/usr/include,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at infodir</A>@,${prefix}/info,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at mandir</A>@,${prefix}/man,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at build_alias</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at host_alias</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at target_alias</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at DEFS</A>@,-DHAVE_CONFIG_H,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ECHO_C</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ECHO_N</A>@,-n,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ECHO_T</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at LIBS</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at INSTALL_PROGRAM</A>@,${INSTALL},;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at INSTALL_SCRIPT</A>@,${INSTALL},;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at INSTALL_DATA</A>@,${INSTALL} -m 644,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at CYGPATH_W</A>@,echo,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at PACKAGE</A>@,libg3d,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at VERSION</A>@,0.0.3,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ACLOCAL</A>@,${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run aclocal-1.7,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at AUTOCONF</A>@,${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run autoconf,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at AUTOMAKE</A>@,${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run automake-1.7,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at AUTOHEADER</A>@,${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run autoheader,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at MAKEINFO</A>@,${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run makeinfo,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at AMTAR</A>@,${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run tar,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at install_sh</A>@,/home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/install-sh,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at STRIP</A>@,strip,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ac_ct_STRIP</A>@,strip,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at INSTALL_STRIP_PROGRAM</A>@,${SHELL} $(install_sh) -c -s,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at AWK</A>@,mawk,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at SET_MAKE</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at am__leading_dot</A>@,.,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at CC</A>@,gcc,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at CFLAGS</A>@,-g -O2,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at LDFLAGS</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at CPPFLAGS</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ac_ct_CC</A>@,gcc,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at EXEEXT</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at OBJEXT</A>@,o,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at DEPDIR</A>@,.deps,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at am__include</A>@,include,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at am__quote</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at AMDEP_TRUE</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at AMDEP_FALSE</A>@,#,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at AMDEPBACKSLASH</A>@,\,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at CCDEPMODE</A>@,depmode=gcc3,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at am__fastdepCC_TRUE</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at am__fastdepCC_FALSE</A>@,#,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at LEX</A>@,flex,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at LEXLIB</A>@,-lfl,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at LEX_OUTPUT_ROOT</A>@,lex.yy,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at CPP</A>@,gcc -E,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at EGREP</A>@,grep -E,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at build</A>@,i686-pc-linux-gnu,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at build_cpu</A>@,i686,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at build_vendor</A>@,pc,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at build_os</A>@,linux-gnu,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at host</A>@,i686-pc-linux-gnu,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at host_cpu</A>@,i686,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at host_vendor</A>@,pc,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at host_os</A>@,linux-gnu,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at LN_S</A>@,ln -s,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ECHO</A>@,echo,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at AR</A>@,ar,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ac_ct_AR</A>@,ar,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at RANLIB</A>@,ranlib,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ac_ct_RANLIB</A>@,ranlib,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at CXX</A>@,g++,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at CXXFLAGS</A>@,-g -O2,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ac_ct_CXX</A>@,g++,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at CXXDEPMODE</A>@,depmode=gcc3,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at am__fastdepCXX_TRUE</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at am__fastdepCXX_FALSE</A>@,#,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at CXXCPP</A>@,g++ -E,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at F77</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at FFLAGS</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ac_ct_F77</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at LIBTOOL</A>@,$(SHELL) $(top_builddir)/libtool,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at HTML_DIR</A>@,${datadir}/gtk-doc/html,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at PKG_CONFIG</A>@,/usr/bin/pkg-config,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ENABLE_GTK_DOC_TRUE</A>@,#,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at ENABLE_GTK_DOC_FALSE</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at GTK_DOC_USE_LIBTOOL_TRUE</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at GTK_DOC_USE_LIBTOOL_FALSE</A>@,#,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at GLIB_CFLAGS</A>@,-I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  ,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at GLIB_LIBS</A>@,-Wl,--export-dynamic -lgmodule-2.0 -ldl -lgobject-2.0 -lglib-2.0  ,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at GLIB_GENMARSHAL</A>@,glib-genmarshal,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at GOBJECT_QUERY</A>@,gobject-query,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at GLIB_MKENUMS</A>@,glib-mkenums,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at GTK_CFLAGS</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at GTK_LIBS</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at GDKPIXBUF_CFLAGS</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at GDKPIXBUF_LIBS</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at HAVE_GDKPIXBUF_TRUE</A>@,#,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at HAVE_GDKPIXBUF_FALSE</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at DEBUG</A>@,0,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at DBG_CFLAGS</A>@,-O2,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at PLUGINS_LDFLAGS</A>@,-avoid-version -export-dynamic,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at LIBOBJS</A>@,,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at LTLIBOBJS</A>@,,;t t
-CEOF
-
-  # Split the substitutions into bite-sized pieces for seds with
-  # small command number limits, like on Digital OSF/1 and HP-UX.
-  ac_max_sed_lines=48
-  ac_sed_frag=1 # Number of current file.
-  ac_beg=1 # First line for current file.
-  ac_end=$ac_max_sed_lines # Line after last line for current file.
-  ac_more_lines=:
-  ac_sed_cmds=
-  while $ac_more_lines; do
-    if test $ac_beg -gt 1; then
-      sed &quot;1,${ac_beg}d; ${ac_end}q&quot; $tmp/subs.sed &gt;$tmp/subs.frag
-    else
-      sed &quot;${ac_end}q&quot; $tmp/subs.sed &gt;$tmp/subs.frag
-    fi
-    if test ! -s $tmp/subs.frag; then
-      ac_more_lines=false
-    else
-      # The purpose of the label and of the branching condition is to
-      # speed up the sed processing (if there are no `@' at all, there
-      # is no need to browse any of the substitutions).
-      # These are the two extra sed commands mentioned above.
-      (echo ':t
-  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' &amp;&amp; cat $tmp/subs.frag) &gt;$tmp/subs-$ac_sed_frag.sed
-      if test -z &quot;$ac_sed_cmds&quot;; then
-	ac_sed_cmds=&quot;sed -f $tmp/subs-$ac_sed_frag.sed&quot;
-      else
-	ac_sed_cmds=&quot;$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed&quot;
-      fi
-      ac_sed_frag=`expr $ac_sed_frag + 1`
-      ac_beg=$ac_end
-      ac_end=`expr $ac_end + $ac_max_sed_lines`
-    fi
-  done
-  if test -z &quot;$ac_sed_cmds&quot;; then
-    ac_sed_cmds=cat
-  fi
-fi # test -n &quot;$CONFIG_FILES&quot;
-
-for ac_file in : $CONFIG_FILES; do test &quot;x$ac_file&quot; = x: &amp;&amp; continue
-  # Support &quot;outfile[:infile[:infile...]]&quot;, defaulting infile=&quot;outfile.in&quot;.
-  case $ac_file in
-  - | *:- | *:-:* ) # input from stdin
-	cat &gt;$tmp/stdin
-	ac_file_in=`echo &quot;$ac_file&quot; | sed 's,[^:]*:,,'`
-	ac_file=`echo &quot;$ac_file&quot; | sed 's,:.*,,'` ;;
-  *:* ) ac_file_in=`echo &quot;$ac_file&quot; | sed 's,[^:]*:,,'`
-	ac_file=`echo &quot;$ac_file&quot; | sed 's,:.*,,'` ;;
-  * )   ac_file_in=$ac_file.in ;;
-  esac
-
-  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
-  ac_dir=`(dirname &quot;$ac_file&quot;) 2&gt;/dev/null ||
-$as_expr X&quot;$ac_file&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X&quot;$ac_file&quot; : 'X\(//\)[^/]' \| \
-	 X&quot;$ac_file&quot; : 'X\(//\)$' \| \
-	 X&quot;$ac_file&quot; : 'X\(/\)' \| \
-	 .     : '\(.\)' 2&gt;/dev/null ||
-echo X&quot;$ac_file&quot; |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-  { if $as_mkdir_p; then
-    mkdir -p &quot;$ac_dir&quot;
-  else
-    as_dir=&quot;$ac_dir&quot;
-    as_dirs=
-    while test ! -d &quot;$as_dir&quot;; do
-      as_dirs=&quot;$as_dir $as_dirs&quot;
-      as_dir=`(dirname &quot;$as_dir&quot;) 2&gt;/dev/null ||
-$as_expr X&quot;$as_dir&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X&quot;$as_dir&quot; : 'X\(//\)[^/]' \| \
-	 X&quot;$as_dir&quot; : 'X\(//\)$' \| \
-	 X&quot;$as_dir&quot; : 'X\(/\)' \| \
-	 .     : '\(.\)' 2&gt;/dev/null ||
-echo X&quot;$as_dir&quot; |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-    done
-    test ! -n &quot;$as_dirs&quot; || mkdir $as_dirs
-  fi || { { echo &quot;$as_me:$LINENO: error: cannot create directory \&quot;$ac_dir\&quot;&quot; &gt;&amp;5
-echo &quot;$as_me: error: cannot create directory \&quot;$ac_dir\&quot;&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; }; }
-
-  ac_builddir=.
-
-if test &quot;$ac_dir&quot; != .; then
-  ac_dir_suffix=/`echo &quot;$ac_dir&quot; | sed 's,^\.[\\/],,'`
-  # A &quot;../&quot; for each directory in $ac_dir_suffix.
-  ac_top_builddir=`echo &quot;$ac_dir_suffix&quot; | sed 's,/[^\\/]*,../,g'`
-else
-  ac_dir_suffix= ac_top_builddir=
-fi
-
-case $srcdir in
-  .)  # No --srcdir option.  We are building in place.
-    ac_srcdir=.
-    if test -z &quot;$ac_top_builddir&quot;; then
-       ac_top_srcdir=.
-    else
-       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
-    fi ;;
-  [\\/]* | ?:[\\/]* )  # Absolute path.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir ;;
-  *) # Relative path.
-    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_builddir$srcdir ;;
-esac
-
-# Do not use `cd foo &amp;&amp; pwd` to compute absolute paths, because
-# the directories may not exist.
-case `pwd` in
-.) ac_abs_builddir=&quot;$ac_dir&quot;;;
-*)
-  case &quot;$ac_dir&quot; in
-  .) ac_abs_builddir=`pwd`;;
-  [\\/]* | ?:[\\/]* ) ac_abs_builddir=&quot;$ac_dir&quot;;;
-  *) ac_abs_builddir=`pwd`/&quot;$ac_dir&quot;;;
-  esac;;
-esac
-case $ac_abs_builddir in
-.) ac_abs_top_builddir=${ac_top_builddir}.;;
-*)
-  case ${ac_top_builddir}. in
-  .) ac_abs_top_builddir=$ac_abs_builddir;;
-  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
-  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
-  esac;;
-esac
-case $ac_abs_builddir in
-.) ac_abs_srcdir=$ac_srcdir;;
-*)
-  case $ac_srcdir in
-  .) ac_abs_srcdir=$ac_abs_builddir;;
-  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
-  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
-  esac;;
-esac
-case $ac_abs_builddir in
-.) ac_abs_top_srcdir=$ac_top_srcdir;;
-*)
-  case $ac_top_srcdir in
-  .) ac_abs_top_srcdir=$ac_abs_builddir;;
-  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
-  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
-  esac;;
-esac
-
-
-  case $INSTALL in
-  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
-  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
-  esac
-
-  # Let's still pretend it is `configure' which instantiates (i.e., don't
-  # use $as_me), people would be surprised to read:
-  #    /* config.h.  Generated by config.status.  */
-  if test x&quot;$ac_file&quot; = x-; then
-    configure_input=
-  else
-    configure_input=&quot;$ac_file.  &quot;
-  fi
-  configure_input=$configure_input&quot;Generated from `echo $ac_file_in |
-				     sed 's,.*/,,'` by configure.&quot;
-
-  # First look for the input files in the build tree, otherwise in the
-  # src tree.
-  ac_file_inputs=`IFS=:
-    for f in $ac_file_in; do
-      case $f in
-      -) echo $tmp/stdin ;;
-      [\\/$]*)
-	 # Absolute (can't be DOS-style, as IFS=:)
-	 test -f &quot;$f&quot; || { { echo &quot;$as_me:$LINENO: error: cannot find input file: $f&quot; &gt;&amp;5
-echo &quot;$as_me: error: cannot find input file: $f&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; }
-	 echo &quot;$f&quot;;;
-      *) # Relative
-	 if test -f &quot;$f&quot;; then
-	   # Build tree
-	   echo &quot;$f&quot;
-	 elif test -f &quot;$srcdir/$f&quot;; then
-	   # Source tree
-	   echo &quot;$srcdir/$f&quot;
-	 else
-	   # /dev/null tree
-	   { { echo &quot;$as_me:$LINENO: error: cannot find input file: $f&quot; &gt;&amp;5
-echo &quot;$as_me: error: cannot find input file: $f&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; }
-	 fi;;
-      esac
-    done` || { (exit 1); exit 1; }
-
-  if test x&quot;$ac_file&quot; != x-; then
-    { echo &quot;$as_me:$LINENO: creating $ac_file&quot; &gt;&amp;5
-echo &quot;$as_me: creating $ac_file&quot; &gt;&amp;6;}
-    rm -f &quot;$ac_file&quot;
-  fi
-  sed &quot;/^[	 ]*VPATH[	 ]*=/{
-s/:*\$(srcdir):*/:/;
-s/:*\${srcdir}:*/:/;
-s/:*@srcdir@:*/:/;
-s/^\([^=]*=[	 ]*\):*/\1/;
-s/:*$//;
-s/^[^=]*=[	 ]*$//;
-}
-
-:t
-/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at configure_input</A>@,$configure_input,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at srcdir</A>@,$ac_srcdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at abs_srcdir</A>@,$ac_abs_srcdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at top_srcdir</A>@,$ac_top_srcdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at abs_top_srcdir</A>@,$ac_abs_top_srcdir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at builddir</A>@,$ac_builddir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at abs_builddir</A>@,$ac_abs_builddir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at top_builddir</A>@,$ac_top_builddir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at abs_top_builddir</A>@,$ac_abs_top_builddir,;t t
<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">-s, at INSTALL</A>@,$ac_INSTALL,;t t
-&quot; $ac_file_inputs | (eval &quot;$ac_sed_cmds&quot;) &gt;$tmp/out
-  rm -f $tmp/stdin
-  if test x&quot;$ac_file&quot; != x-; then
-    mv $tmp/out $ac_file
-  else
-    cat $tmp/out
-    rm -f $tmp/out
-  fi
-
-done
-
-#
-# CONFIG_HEADER section.
-#
-
-# These sed commands are passed to sed as &quot;A NAME B NAME C VALUE D&quot;, where
-# NAME is the cpp macro being defined and VALUE is the value it is being given.
-#
-# ac_d sets the value in &quot;#define NAME VALUE&quot; lines.
-ac_dA='s,^\([	 ]*\)#\([	 ]*define[	 ][	 ]*\)'
-ac_dB='[	 ].*$,\1#\2'
-ac_dC=' '
-ac_dD=',;t'
-# ac_u turns &quot;#undef NAME&quot; without trailing blanks into &quot;#define NAME VALUE&quot;.
-ac_uA='s,^\([	 ]*\)#\([	 ]*\)undef\([	 ][	 ]*\)'
-ac_uB='$,\1#\2define\3'
-ac_uC=' '
-ac_uD=',;t'
-
-for ac_file in : $CONFIG_HEADERS; do test &quot;x$ac_file&quot; = x: &amp;&amp; continue
-  # Support &quot;outfile[:infile[:infile...]]&quot;, defaulting infile=&quot;outfile.in&quot;.
-  case $ac_file in
-  - | *:- | *:-:* ) # input from stdin
-	cat &gt;$tmp/stdin
-	ac_file_in=`echo &quot;$ac_file&quot; | sed 's,[^:]*:,,'`
-	ac_file=`echo &quot;$ac_file&quot; | sed 's,:.*,,'` ;;
-  *:* ) ac_file_in=`echo &quot;$ac_file&quot; | sed 's,[^:]*:,,'`
-	ac_file=`echo &quot;$ac_file&quot; | sed 's,:.*,,'` ;;
-  * )   ac_file_in=$ac_file.in ;;
-  esac
-
-  test x&quot;$ac_file&quot; != x- &amp;&amp; { echo &quot;$as_me:$LINENO: creating $ac_file&quot; &gt;&amp;5
-echo &quot;$as_me: creating $ac_file&quot; &gt;&amp;6;}
-
-  # First look for the input files in the build tree, otherwise in the
-  # src tree.
-  ac_file_inputs=`IFS=:
-    for f in $ac_file_in; do
-      case $f in
-      -) echo $tmp/stdin ;;
-      [\\/$]*)
-	 # Absolute (can't be DOS-style, as IFS=:)
-	 test -f &quot;$f&quot; || { { echo &quot;$as_me:$LINENO: error: cannot find input file: $f&quot; &gt;&amp;5
-echo &quot;$as_me: error: cannot find input file: $f&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; }
-	 # Do quote $f, to prevent DOS paths from being IFS'd.
-	 echo &quot;$f&quot;;;
-      *) # Relative
-	 if test -f &quot;$f&quot;; then
-	   # Build tree
-	   echo &quot;$f&quot;
-	 elif test -f &quot;$srcdir/$f&quot;; then
-	   # Source tree
-	   echo &quot;$srcdir/$f&quot;
-	 else
-	   # /dev/null tree
-	   { { echo &quot;$as_me:$LINENO: error: cannot find input file: $f&quot; &gt;&amp;5
-echo &quot;$as_me: error: cannot find input file: $f&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; }
-	 fi;;
-      esac
-    done` || { (exit 1); exit 1; }
-  # Remove the trailing spaces.
-  sed 's/[	 ]*$//' $ac_file_inputs &gt;$tmp/in
-
-  # Handle all the #define templates only if necessary.
-  if grep &quot;^[	 ]*#[	 ]*define&quot; $tmp/in &gt;/dev/null; then
-  # If there are no defines, we may have an empty if/fi
-  :
-  cat &gt;$tmp/defines.sed &lt;&lt;CEOF
-/^[	 ]*#[	 ]*define/!b
-t clr
-: clr
-${ac_dA}PACKAGE_NAME${ac_dB}PACKAGE_NAME${ac_dC}&quot;&quot;${ac_dD}
-${ac_dA}PACKAGE_TARNAME${ac_dB}PACKAGE_TARNAME${ac_dC}&quot;&quot;${ac_dD}
-${ac_dA}PACKAGE_VERSION${ac_dB}PACKAGE_VERSION${ac_dC}&quot;&quot;${ac_dD}
-${ac_dA}PACKAGE_STRING${ac_dB}PACKAGE_STRING${ac_dC}&quot;&quot;${ac_dD}
-${ac_dA}PACKAGE_BUGREPORT${ac_dB}PACKAGE_BUGREPORT${ac_dC}&quot;&quot;${ac_dD}
-${ac_dA}YYTEXT_POINTER${ac_dB}YYTEXT_POINTER${ac_dC}1${ac_dD}
-${ac_dA}STDC_HEADERS${ac_dB}STDC_HEADERS${ac_dC}1${ac_dD}
-${ac_dA}HAVE_SYS_TYPES_H${ac_dB}HAVE_SYS_TYPES_H${ac_dC}1${ac_dD}
-${ac_dA}HAVE_SYS_STAT_H${ac_dB}HAVE_SYS_STAT_H${ac_dC}1${ac_dD}
-${ac_dA}HAVE_STDLIB_H${ac_dB}HAVE_STDLIB_H${ac_dC}1${ac_dD}
-${ac_dA}HAVE_STRING_H${ac_dB}HAVE_STRING_H${ac_dC}1${ac_dD}
-${ac_dA}HAVE_MEMORY_H${ac_dB}HAVE_MEMORY_H${ac_dC}1${ac_dD}
-${ac_dA}HAVE_STRINGS_H${ac_dB}HAVE_STRINGS_H${ac_dC}1${ac_dD}
-${ac_dA}HAVE_INTTYPES_H${ac_dB}HAVE_INTTYPES_H${ac_dC}1${ac_dD}
-${ac_dA}HAVE_STDINT_H${ac_dB}HAVE_STDINT_H${ac_dC}1${ac_dD}
-${ac_dA}HAVE_UNISTD_H${ac_dB}HAVE_UNISTD_H${ac_dC}1${ac_dD}
-${ac_dA}HAVE_DLFCN_H${ac_dB}HAVE_DLFCN_H${ac_dC}1${ac_dD}
-${ac_dA}PLUGIN_DIR${ac_dB}PLUGIN_DIR${ac_dC}&quot;/usr/local/lib/libg3d/plugins&quot;${ac_dD}
-CEOF
-  sed -f $tmp/defines.sed $tmp/in &gt;$tmp/out
-  rm -f $tmp/in
-  mv $tmp/out $tmp/in
-
-  fi # grep
-
-  # Handle all the #undef templates
-  cat &gt;$tmp/undefs.sed &lt;&lt;CEOF
-/^[	 ]*#[	 ]*undef/!b
-t clr
-: clr
-${ac_uA}PACKAGE_NAME${ac_uB}PACKAGE_NAME${ac_uC}&quot;&quot;${ac_uD}
-${ac_uA}PACKAGE_TARNAME${ac_uB}PACKAGE_TARNAME${ac_uC}&quot;&quot;${ac_uD}
-${ac_uA}PACKAGE_VERSION${ac_uB}PACKAGE_VERSION${ac_uC}&quot;&quot;${ac_uD}
-${ac_uA}PACKAGE_STRING${ac_uB}PACKAGE_STRING${ac_uC}&quot;&quot;${ac_uD}
-${ac_uA}PACKAGE_BUGREPORT${ac_uB}PACKAGE_BUGREPORT${ac_uC}&quot;&quot;${ac_uD}
-${ac_uA}YYTEXT_POINTER${ac_uB}YYTEXT_POINTER${ac_uC}1${ac_uD}
-${ac_uA}STDC_HEADERS${ac_uB}STDC_HEADERS${ac_uC}1${ac_uD}
-${ac_uA}HAVE_SYS_TYPES_H${ac_uB}HAVE_SYS_TYPES_H${ac_uC}1${ac_uD}
-${ac_uA}HAVE_SYS_STAT_H${ac_uB}HAVE_SYS_STAT_H${ac_uC}1${ac_uD}
-${ac_uA}HAVE_STDLIB_H${ac_uB}HAVE_STDLIB_H${ac_uC}1${ac_uD}
-${ac_uA}HAVE_STRING_H${ac_uB}HAVE_STRING_H${ac_uC}1${ac_uD}
-${ac_uA}HAVE_MEMORY_H${ac_uB}HAVE_MEMORY_H${ac_uC}1${ac_uD}
-${ac_uA}HAVE_STRINGS_H${ac_uB}HAVE_STRINGS_H${ac_uC}1${ac_uD}
-${ac_uA}HAVE_INTTYPES_H${ac_uB}HAVE_INTTYPES_H${ac_uC}1${ac_uD}
-${ac_uA}HAVE_STDINT_H${ac_uB}HAVE_STDINT_H${ac_uC}1${ac_uD}
-${ac_uA}HAVE_UNISTD_H${ac_uB}HAVE_UNISTD_H${ac_uC}1${ac_uD}
-${ac_uA}HAVE_DLFCN_H${ac_uB}HAVE_DLFCN_H${ac_uC}1${ac_uD}
-${ac_uA}PLUGIN_DIR${ac_uB}PLUGIN_DIR${ac_uC}&quot;/usr/local/lib/libg3d/plugins&quot;${ac_uD}
-s,^[	 ]*#[	 ]*undef[	 ][	 ]*[a-zA-Z_][a-zA-Z_0-9]*,/* &amp; */,
-CEOF
-  sed -f $tmp/undefs.sed $tmp/in &gt;$tmp/out
-  rm -f $tmp/in
-  mv $tmp/out $tmp/in
-
-  # Let's still pretend it is `configure' which instantiates (i.e., don't
-  # use $as_me), people would be surprised to read:
-  #    /* config.h.  Generated by config.status.  */
-  if test x&quot;$ac_file&quot; = x-; then
-    echo &quot;/* Generated by configure.  */&quot; &gt;$tmp/config.h
-  else
-    echo &quot;/* $ac_file.  Generated by configure.  */&quot; &gt;$tmp/config.h
-  fi
-  cat $tmp/in &gt;&gt;$tmp/config.h
-  rm -f $tmp/in
-  if test x&quot;$ac_file&quot; != x-; then
-    if diff $ac_file $tmp/config.h &gt;/dev/null 2&gt;&amp;1; then
-      { echo &quot;$as_me:$LINENO: $ac_file is unchanged&quot; &gt;&amp;5
-echo &quot;$as_me: $ac_file is unchanged&quot; &gt;&amp;6;}
-    else
-      ac_dir=`(dirname &quot;$ac_file&quot;) 2&gt;/dev/null ||
-$as_expr X&quot;$ac_file&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X&quot;$ac_file&quot; : 'X\(//\)[^/]' \| \
-	 X&quot;$ac_file&quot; : 'X\(//\)$' \| \
-	 X&quot;$ac_file&quot; : 'X\(/\)' \| \
-	 .     : '\(.\)' 2&gt;/dev/null ||
-echo X&quot;$ac_file&quot; |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-      { if $as_mkdir_p; then
-    mkdir -p &quot;$ac_dir&quot;
-  else
-    as_dir=&quot;$ac_dir&quot;
-    as_dirs=
-    while test ! -d &quot;$as_dir&quot;; do
-      as_dirs=&quot;$as_dir $as_dirs&quot;
-      as_dir=`(dirname &quot;$as_dir&quot;) 2&gt;/dev/null ||
-$as_expr X&quot;$as_dir&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X&quot;$as_dir&quot; : 'X\(//\)[^/]' \| \
-	 X&quot;$as_dir&quot; : 'X\(//\)$' \| \
-	 X&quot;$as_dir&quot; : 'X\(/\)' \| \
-	 .     : '\(.\)' 2&gt;/dev/null ||
-echo X&quot;$as_dir&quot; |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-    done
-    test ! -n &quot;$as_dirs&quot; || mkdir $as_dirs
-  fi || { { echo &quot;$as_me:$LINENO: error: cannot create directory \&quot;$ac_dir\&quot;&quot; &gt;&amp;5
-echo &quot;$as_me: error: cannot create directory \&quot;$ac_dir\&quot;&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; }; }
-
-      rm -f $ac_file
-      mv $tmp/config.h $ac_file
-    fi
-  else
-    cat $tmp/config.h
-    rm -f $tmp/config.h
-  fi
-# Compute $ac_file's index in $config_headers.
-_am_stamp_count=1
-for _am_header in $config_headers :; do
-  case $_am_header in
-    $ac_file | $ac_file:* )
-      break ;;
-    * )
-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
-  esac
-done
-echo &quot;timestamp for $ac_file&quot; &gt;`(dirname $ac_file) 2&gt;/dev/null ||
-$as_expr X$ac_file : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X$ac_file : 'X\(//\)[^/]' \| \
-	 X$ac_file : 'X\(//\)$' \| \
-	 X$ac_file : 'X\(/\)' \| \
-	 .     : '\(.\)' 2&gt;/dev/null ||
-echo X$ac_file |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`/stamp-h$_am_stamp_count
-done
-
-#
-# CONFIG_COMMANDS section.
-#
-for ac_file in : $CONFIG_COMMANDS; do test &quot;x$ac_file&quot; = x: &amp;&amp; continue
-  ac_dest=`echo &quot;$ac_file&quot; | sed 's,:.*,,'`
-  ac_source=`echo &quot;$ac_file&quot; | sed 's,[^:]*:,,'`
-  ac_dir=`(dirname &quot;$ac_dest&quot;) 2&gt;/dev/null ||
-$as_expr X&quot;$ac_dest&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X&quot;$ac_dest&quot; : 'X\(//\)[^/]' \| \
-	 X&quot;$ac_dest&quot; : 'X\(//\)$' \| \
-	 X&quot;$ac_dest&quot; : 'X\(/\)' \| \
-	 .     : '\(.\)' 2&gt;/dev/null ||
-echo X&quot;$ac_dest&quot; |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-  { if $as_mkdir_p; then
-    mkdir -p &quot;$ac_dir&quot;
-  else
-    as_dir=&quot;$ac_dir&quot;
-    as_dirs=
-    while test ! -d &quot;$as_dir&quot;; do
-      as_dirs=&quot;$as_dir $as_dirs&quot;
-      as_dir=`(dirname &quot;$as_dir&quot;) 2&gt;/dev/null ||
-$as_expr X&quot;$as_dir&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X&quot;$as_dir&quot; : 'X\(//\)[^/]' \| \
-	 X&quot;$as_dir&quot; : 'X\(//\)$' \| \
-	 X&quot;$as_dir&quot; : 'X\(/\)' \| \
-	 .     : '\(.\)' 2&gt;/dev/null ||
-echo X&quot;$as_dir&quot; |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-    done
-    test ! -n &quot;$as_dirs&quot; || mkdir $as_dirs
-  fi || { { echo &quot;$as_me:$LINENO: error: cannot create directory \&quot;$ac_dir\&quot;&quot; &gt;&amp;5
-echo &quot;$as_me: error: cannot create directory \&quot;$ac_dir\&quot;&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; }; }
-
-  ac_builddir=.
-
-if test &quot;$ac_dir&quot; != .; then
-  ac_dir_suffix=/`echo &quot;$ac_dir&quot; | sed 's,^\.[\\/],,'`
-  # A &quot;../&quot; for each directory in $ac_dir_suffix.
-  ac_top_builddir=`echo &quot;$ac_dir_suffix&quot; | sed 's,/[^\\/]*,../,g'`
-else
-  ac_dir_suffix= ac_top_builddir=
-fi
-
-case $srcdir in
-  .)  # No --srcdir option.  We are building in place.
-    ac_srcdir=.
-    if test -z &quot;$ac_top_builddir&quot;; then
-       ac_top_srcdir=.
-    else
-       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
-    fi ;;
-  [\\/]* | ?:[\\/]* )  # Absolute path.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir ;;
-  *) # Relative path.
-    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_builddir$srcdir ;;
-esac
-
-# Do not use `cd foo &amp;&amp; pwd` to compute absolute paths, because
-# the directories may not exist.
-case `pwd` in
-.) ac_abs_builddir=&quot;$ac_dir&quot;;;
-*)
-  case &quot;$ac_dir&quot; in
-  .) ac_abs_builddir=`pwd`;;
-  [\\/]* | ?:[\\/]* ) ac_abs_builddir=&quot;$ac_dir&quot;;;
-  *) ac_abs_builddir=`pwd`/&quot;$ac_dir&quot;;;
-  esac;;
-esac
-case $ac_abs_builddir in
-.) ac_abs_top_builddir=${ac_top_builddir}.;;
-*)
-  case ${ac_top_builddir}. in
-  .) ac_abs_top_builddir=$ac_abs_builddir;;
-  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
-  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
-  esac;;
-esac
-case $ac_abs_builddir in
-.) ac_abs_srcdir=$ac_srcdir;;
-*)
-  case $ac_srcdir in
-  .) ac_abs_srcdir=$ac_abs_builddir;;
-  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
-  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
-  esac;;
-esac
-case $ac_abs_builddir in
-.) ac_abs_top_srcdir=$ac_top_srcdir;;
-*)
-  case $ac_top_srcdir in
-  .) ac_abs_top_srcdir=$ac_abs_builddir;;
-  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
-  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
-  esac;;
-esac
-
-
-  { echo &quot;$as_me:$LINENO: executing $ac_dest commands&quot; &gt;&amp;5
-echo &quot;$as_me: executing $ac_dest commands&quot; &gt;&amp;6;}
-  case $ac_dest in
-    depfiles ) test x&quot;$AMDEP_TRUE&quot; != x&quot;&quot; || for mf in $CONFIG_FILES; do
-  # Strip MF so we end up with the name of the file.
-  mf=`echo &quot;$mf&quot; | sed -e 's/:.*$//'`
-  # Check whether this is an Automake generated Makefile or not.
-  # We used to match only the files named `Makefile.in', but
-  # some people rename them; so instead we look at the file content.
-  # Grep'ing the first line is not enough: some people post-process
-  # each Makefile.in and add a new line on top of each file to say so.
-  # So let's grep whole file.
-  if grep '^#.*generated by automake' $mf &gt; /dev/null 2&gt;&amp;1; then
-    dirpart=`(dirname &quot;$mf&quot;) 2&gt;/dev/null ||
-$as_expr X&quot;$mf&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X&quot;$mf&quot; : 'X\(//\)[^/]' \| \
-	 X&quot;$mf&quot; : 'X\(//\)$' \| \
-	 X&quot;$mf&quot; : 'X\(/\)' \| \
-	 .     : '\(.\)' 2&gt;/dev/null ||
-echo X&quot;$mf&quot; |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-  else
-    continue
-  fi
-  grep '^DEP_FILES *= *[^ #]' &lt; &quot;$mf&quot; &gt; /dev/null || continue
-  # Extract the definition of DEP_FILES from the Makefile without
-  # running `make'.
-  DEPDIR=`sed -n -e '/^DEPDIR = / s///p' &lt; &quot;$mf&quot;`
-  test -z &quot;$DEPDIR&quot; &amp;&amp; continue
-  # When using ansi2knr, U may be empty or an underscore; expand it
-  U=`sed -n -e '/^U = / s///p' &lt; &quot;$mf&quot;`
-  test -d &quot;$dirpart/$DEPDIR&quot; || mkdir &quot;$dirpart/$DEPDIR&quot;
-  # We invoke sed twice because it is the simplest approach to
-  # changing $(DEPDIR) to its actual value in the expansion.
-  for file in `sed -n -e '
-    /^DEP_FILES = .*\\\\$/ {
-      s/^DEP_FILES = //
-      :loop
-	s/\\\\$//
-	p
-	n
-	/\\\\$/ b loop
-      p
-    }
-    /^DEP_FILES = / s/^DEP_FILES = //p' &lt; &quot;$mf&quot; | \
-       sed -e 's/\$(DEPDIR)/'&quot;$DEPDIR&quot;'/g' -e 's/\$U/'&quot;$U&quot;'/g'`; do
-    # Make sure the directory exists.
-    test -f &quot;$dirpart/$file&quot; &amp;&amp; continue
-    fdir=`(dirname &quot;$file&quot;) 2&gt;/dev/null ||
-$as_expr X&quot;$file&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X&quot;$file&quot; : 'X\(//\)[^/]' \| \
-	 X&quot;$file&quot; : 'X\(//\)$' \| \
-	 X&quot;$file&quot; : 'X\(/\)' \| \
-	 .     : '\(.\)' 2&gt;/dev/null ||
-echo X&quot;$file&quot; |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-    { if $as_mkdir_p; then
-    mkdir -p $dirpart/$fdir
-  else
-    as_dir=$dirpart/$fdir
-    as_dirs=
-    while test ! -d &quot;$as_dir&quot;; do
-      as_dirs=&quot;$as_dir $as_dirs&quot;
-      as_dir=`(dirname &quot;$as_dir&quot;) 2&gt;/dev/null ||
-$as_expr X&quot;$as_dir&quot; : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X&quot;$as_dir&quot; : 'X\(//\)[^/]' \| \
-	 X&quot;$as_dir&quot; : 'X\(//\)$' \| \
-	 X&quot;$as_dir&quot; : 'X\(/\)' \| \
-	 .     : '\(.\)' 2&gt;/dev/null ||
-echo X&quot;$as_dir&quot; |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
-    done
-    test ! -n &quot;$as_dirs&quot; || mkdir $as_dirs
-  fi || { { echo &quot;$as_me:$LINENO: error: cannot create directory $dirpart/$fdir&quot; &gt;&amp;5
-echo &quot;$as_me: error: cannot create directory $dirpart/$fdir&quot; &gt;&amp;2;}
-   { (exit 1); exit 1; }; }; }
-
-    # echo &quot;creating $dirpart/$file&quot;
-    echo '# dummy' &gt; &quot;$dirpart/$file&quot;
-  done
-done
- ;;
-  esac
-done
-
-{ (exit 0); exit 0; }

Deleted: trunk/libg3d/doc/Makefile
===================================================================
--- trunk/libg3d/doc/Makefile	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libg3d/doc/Makefile	2006-05-25 17:11:46 UTC (rev 295)
@@ -1,453 +0,0 @@
-# Makefile.in generated by automake 1.7.9 from Makefile.am.
-# doc/Makefile.  Generated from Makefile.in by configure.
-
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
-# Free Software Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-
-
-srcdir = .
-top_srcdir = ..
-
-pkgdatadir = $(datadir)/libg3d
-pkglibdir = $(libdir)/libg3d
-pkgincludedir = $(includedir)/libg3d
-top_builddir = ..
-
-am__cd = CDPATH=&quot;$${ZSH_VERSION+.}$(PATH_SEPARATOR)&quot; &amp;&amp; cd
-INSTALL = /usr/bin/install -c
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-host_triplet = i686-pc-linux-gnu
-ACLOCAL = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run aclocal-1.7
-AMDEP_FALSE = #
-AMDEP_TRUE = 
-AMTAR = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run tar
-AR = ar
-AUTOCONF = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run autoconf
-AUTOHEADER = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run autoheader
-AUTOMAKE = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run automake-1.7
-AWK = mawk
-CC = gcc
-CCDEPMODE = depmode=gcc3
-CFLAGS = -g -O2
-CPP = gcc -E
-CPPFLAGS = 
-CXX = g++
-CXXCPP = g++ -E
-CXXDEPMODE = depmode=gcc3
-CXXFLAGS = -g -O2
-CYGPATH_W = echo
-DBG_CFLAGS = -O2
-DEBUG = 0
-DEFS = -DHAVE_CONFIG_H
-DEPDIR = .deps
-ECHO = echo
-ECHO_C = 
-ECHO_N = -n
-ECHO_T = 
-EGREP = grep -E
-ENABLE_GTK_DOC_FALSE = 
-ENABLE_GTK_DOC_TRUE = #
-EXEEXT = 
-F77 = 
-FFLAGS = 
-GDKPIXBUF_CFLAGS = 
-GDKPIXBUF_LIBS = 
-GLIB_CFLAGS = -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
-GLIB_GENMARSHAL = glib-genmarshal
-GLIB_LIBS = -Wl,--export-dynamic -lgmodule-2.0 -ldl -lgobject-2.0 -lglib-2.0  
-GLIB_MKENUMS = glib-mkenums
-GOBJECT_QUERY = gobject-query
-GTK_CFLAGS = 
-GTK_DOC_USE_LIBTOOL_FALSE = #
-GTK_DOC_USE_LIBTOOL_TRUE = 
-GTK_LIBS = 
-HAVE_GDKPIXBUF_FALSE = 
-HAVE_GDKPIXBUF_TRUE = #
-HTML_DIR = ${datadir}/gtk-doc/html
-INSTALL_DATA = ${INSTALL} -m 644
-INSTALL_PROGRAM = ${INSTALL}
-INSTALL_SCRIPT = ${INSTALL}
-INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
-LDFLAGS = 
-LEX = flex
-LEXLIB = -lfl
-LEX_OUTPUT_ROOT = lex.yy
-LIBOBJS = 
-LIBS = 
-LIBTOOL = $(SHELL) $(top_builddir)/libtool
-LN_S = ln -s
-LTLIBOBJS = 
-MAKEINFO = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run makeinfo
-OBJEXT = o
-PACKAGE = libg3d
-PACKAGE_BUGREPORT = 
-PACKAGE_NAME = 
-PACKAGE_STRING = 
-PACKAGE_TARNAME = 
-PACKAGE_VERSION = 
-PATH_SEPARATOR = :
-PKG_CONFIG = /usr/bin/pkg-config
-PLUGINS_LDFLAGS = -avoid-version -export-dynamic
-RANLIB = ranlib
-SET_MAKE = 
-SHELL = /bin/sh
-STRIP = strip
-VERSION = 0.0.3
-ac_ct_AR = ar
-ac_ct_CC = gcc
-ac_ct_CXX = g++
-ac_ct_F77 = 
-ac_ct_RANLIB = ranlib
-ac_ct_STRIP = strip
-am__fastdepCC_FALSE = #
-am__fastdepCC_TRUE = 
-am__fastdepCXX_FALSE = #
-am__fastdepCXX_TRUE = 
-am__include = include
-am__leading_dot = .
-am__quote = 
-bindir = ${exec_prefix}/bin
-build = i686-pc-linux-gnu
-build_alias = 
-build_cpu = i686
-build_os = linux-gnu
-build_vendor = pc
-datadir = ${prefix}/share
-exec_prefix = ${prefix}
-host = i686-pc-linux-gnu
-host_alias = 
-host_cpu = i686
-host_os = linux-gnu
-host_vendor = pc
-includedir = ${prefix}/include
-infodir = ${prefix}/info
-install_sh = /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/install-sh
-libdir = ${exec_prefix}/lib
-libexecdir = ${exec_prefix}/libexec
-localstatedir = ${prefix}/var
-mandir = ${prefix}/man
-oldincludedir = /usr/include
-prefix = /usr/local
-program_transform_name = s,x,x,
-sbindir = ${exec_prefix}/sbin
-sharedstatedir = ${prefix}/com
-sysconfdir = ${prefix}/etc
-target_alias = 
-SUBDIRS = api
-subdir = doc
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/include/g3d/config.h
-CONFIG_CLEAN_FILES =
-DIST_SOURCES =
-
-RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
-	ps-recursive install-info-recursive uninstall-info-recursive \
-	all-recursive install-data-recursive install-exec-recursive \
-	installdirs-recursive install-recursive uninstall-recursive \
-	check-recursive installcheck-recursive
-DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
-DIST_SUBDIRS = $(SUBDIRS)
-all: all-recursive
-
-.SUFFIXES:
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
-	cd $(top_srcdir) &amp;&amp; \
-	  $(AUTOMAKE) --gnu  doc/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool
-uninstall-info-am:
-
-# This directory's subdirectories are mostly independent; you can cd
-# into them and run `make' without going through this Makefile.
-# To change the values of `make' variables: instead of editing Makefiles,
-# (1) if the variable is set in `config.status', edit `config.status'
-#     (which will cause the Makefiles to be regenerated when you run `make');
-# (2) otherwise, pass the desired values on the `make' command line.
-$(RECURSIVE_TARGETS):
-	@set fnord $$MAKEFLAGS; amf=$$2; \
-	dot_seen=no; \
-	target=`echo $@ | sed s/-recursive//`; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  echo &quot;Making $$target in $$subdir&quot;; \
-	  if test &quot;$$subdir&quot; = &quot;.&quot;; then \
-	    dot_seen=yes; \
-	    local_target=&quot;$$target-am&quot;; \
-	  else \
-	    local_target=&quot;$$target&quot;; \
-	  fi; \
-	  (cd $$subdir &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case &quot;$$amf&quot; in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
-	done; \
-	if test &quot;$$dot_seen&quot; = &quot;no&quot;; then \
-	  $(MAKE) $(AM_MAKEFLAGS) &quot;$$target-am&quot; || exit 1; \
-	fi; test -z &quot;$$fail&quot;
-
-mostlyclean-recursive clean-recursive distclean-recursive \
-maintainer-clean-recursive:
-	@set fnord $$MAKEFLAGS; amf=$$2; \
-	dot_seen=no; \
-	case &quot;$@&quot; in \
-	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
-	  *) list='$(SUBDIRS)' ;; \
-	esac; \
-	rev=''; for subdir in $$list; do \
-	  if test &quot;$$subdir&quot; = &quot;.&quot;; then :; else \
-	    rev=&quot;$$subdir $$rev&quot;; \
-	  fi; \
-	done; \
-	rev=&quot;$$rev .&quot;; \
-	target=`echo $@ | sed s/-recursive//`; \
-	for subdir in $$rev; do \
-	  echo &quot;Making $$target in $$subdir&quot;; \
-	  if test &quot;$$subdir&quot; = &quot;.&quot;; then \
-	    local_target=&quot;$$target-am&quot;; \
-	  else \
-	    local_target=&quot;$$target&quot;; \
-	  fi; \
-	  (cd $$subdir &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case &quot;$$amf&quot; in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
-	done &amp;&amp; test -z &quot;$$fail&quot;
-tags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test &quot;$$subdir&quot; = . || (cd $$subdir &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) tags); \
-	done
-ctags-recursive:
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  test &quot;$$subdir&quot; = . || (cd $$subdir &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) ctags); \
-	done
-
-ETAGS = etags
-ETAGSFLAGS =
-
-CTAGS = ctags
-CTAGSFLAGS =
-
-tags: TAGS
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	mkid -fID $$unique
-
-TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	if (etags --etags-include --version) &gt;/dev/null 2&gt;&amp;1; then \
-	  include_option=--etags-include; \
-	else \
-	  include_option=--include; \
-	fi; \
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  if test &quot;$$subdir&quot; = .; then :; else \
-	    test -f $$subdir/TAGS &amp;&amp; \
-	      tags=&quot;$$tags $$include_option=$$here/$$subdir/TAGS&quot;; \
-	  fi; \
-	done; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	test -z &quot;$(ETAGS_ARGS)$$tags$$unique&quot; \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	     $$tags $$unique
-
-ctags: CTAGS
-CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f &quot;$$i&quot;; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	test -z &quot;$(CTAGS_ARGS)$$tags$$unique&quot; \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$tags $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) &amp;&amp; pwd` \
-	  &amp;&amp; cd $(top_srcdir) \
-	  &amp;&amp; gtags -i $(GTAGS_ARGS) $$here
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo &quot;$(srcdir)&quot; | sed 's|.|.|g'`; \
-	topsrcdirstrip=`echo &quot;$(top_srcdir)&quot; | sed 's|.|.|g'`; \
-	list='$(DISTFILES)'; for file in $$list; do \
-	  case $$file in \
-	    $(srcdir)/*) file=`echo &quot;$$file&quot; | sed &quot;s|^$$srcdirstrip/||&quot;`;; \
-	    $(top_srcdir)/*) file=`echo &quot;$$file&quot; | sed &quot;s|^$$topsrcdirstrip/|$(top_builddir)/|&quot;`;; \
-	  esac; \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  dir=`echo &quot;$$file&quot; | sed -e 's,/[^/]*$$,,'`; \
-	  if test &quot;$$dir&quot; != &quot;$$file&quot; &amp;&amp; test &quot;$$dir&quot; != &quot;.&quot;; then \
-	    dir=&quot;/$$dir&quot;; \
-	    $(mkinstalldirs) &quot;$(distdir)$$dir&quot;; \
-	  else \
-	    dir=''; \
-	  fi; \
-	  if test -d $$d/$$file; then \
-	    if test -d $(srcdir)/$$file &amp;&amp; test $$d != $(srcdir); then \
-	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
-	    fi; \
-	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
-	  else \
-	    test -f $(distdir)/$$file \
-	    || cp -p $$d/$$file $(distdir)/$$file \
-	    || exit 1; \
-	  fi; \
-	done
-	list='$(SUBDIRS)'; for subdir in $$list; do \
-	  if test &quot;$$subdir&quot; = .; then :; else \
-	    test -d $(distdir)/$$subdir \
-	    || mkdir $(distdir)/$$subdir \
-	    || exit 1; \
-	    (cd $$subdir &amp;&amp; \
-	      $(MAKE) $(AM_MAKEFLAGS) \
-	        top_distdir=&quot;$(top_distdir)&quot; \
-	        distdir=../$(distdir)/$$subdir \
-	        distdir) \
-	      || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-recursive
-all-am: Makefile
-installdirs: installdirs-recursive
-installdirs-am:
-
-install: install-recursive
-install-exec: install-exec-recursive
-install-data: install-data-recursive
-uninstall: uninstall-recursive
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-recursive
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=&quot;$(INSTALL_STRIP_PROGRAM)&quot; \
-	  install_sh_PROGRAM=&quot;$(INSTALL_STRIP_PROGRAM)&quot; INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo &quot;INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'&quot;` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-rm -f $(CONFIG_CLEAN_FILES)
-
-maintainer-clean-generic:
-	@echo &quot;This command is intended for maintainers to use&quot;
-	@echo &quot;it deletes files that may require special tools to rebuild.&quot;
-clean: clean-recursive
-
-clean-am: clean-generic clean-libtool mostlyclean-am
-
-distclean: distclean-recursive
-	-rm -f Makefile
-distclean-am: clean-am distclean-generic distclean-libtool \
-	distclean-tags
-
-dvi: dvi-recursive
-
-dvi-am:
-
-info: info-recursive
-
-info-am:
-
-install-data-am:
-
-install-exec-am:
-
-install-info: install-info-recursive
-
-install-man:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-recursive
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-recursive
-
-mostlyclean-am: mostlyclean-generic mostlyclean-libtool
-
-pdf: pdf-recursive
-
-pdf-am:
-
-ps: ps-recursive
-
-ps-am:
-
-uninstall-am: uninstall-info-am
-
-uninstall-info: uninstall-info-recursive
-
-.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am clean \
-	clean-generic clean-libtool clean-recursive ctags \
-	ctags-recursive distclean distclean-generic distclean-libtool \
-	distclean-recursive distclean-tags distdir dvi dvi-am \
-	dvi-recursive info info-am info-recursive install install-am \
-	install-data install-data-am install-data-recursive \
-	install-exec install-exec-am install-exec-recursive \
-	install-info install-info-am install-info-recursive install-man \
-	install-recursive install-strip installcheck installcheck-am \
-	installdirs installdirs-am installdirs-recursive \
-	maintainer-clean maintainer-clean-generic \
-	maintainer-clean-recursive mostlyclean mostlyclean-generic \
-	mostlyclean-libtool mostlyclean-recursive pdf pdf-am \
-	pdf-recursive ps ps-am ps-recursive tags tags-recursive \
-	uninstall uninstall-am uninstall-info-am \
-	uninstall-info-recursive uninstall-recursive
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:

Deleted: trunk/libg3d/doc/api/Makefile
===================================================================
--- trunk/libg3d/doc/api/Makefile	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libg3d/doc/api/Makefile	2006-05-25 17:11:46 UTC (rev 295)
@@ -1,491 +0,0 @@
-# Makefile.in generated by automake 1.7.9 from Makefile.am.
-# doc/api/Makefile.  Generated from Makefile.in by configure.
-
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
-# Free Software Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-
-
-# -*- mode: makefile -*-
-
-####################################
-# Everything below here is generic #
-####################################
-
-srcdir = .
-top_srcdir = ../..
-
-pkgdatadir = $(datadir)/libg3d
-pkglibdir = $(libdir)/libg3d
-pkgincludedir = $(includedir)/libg3d
-top_builddir = ../..
-
-am__cd = CDPATH=&quot;$${ZSH_VERSION+.}$(PATH_SEPARATOR)&quot; &amp;&amp; cd
-INSTALL = /usr/bin/install -c
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-host_triplet = i686-pc-linux-gnu
-ACLOCAL = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run aclocal-1.7
-AMDEP_FALSE = #
-AMDEP_TRUE = 
-AMTAR = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run tar
-AR = ar
-AUTOCONF = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run autoconf
-AUTOHEADER = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run autoheader
-AUTOMAKE = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run automake-1.7
-AWK = mawk
-CC = gcc
-CCDEPMODE = depmode=gcc3
-CFLAGS = -g -O2
-CPP = gcc -E
-CPPFLAGS = 
-CXX = g++
-CXXCPP = g++ -E
-CXXDEPMODE = depmode=gcc3
-CXXFLAGS = -g -O2
-CYGPATH_W = echo
-DBG_CFLAGS = -O2
-DEBUG = 0
-DEFS = -DHAVE_CONFIG_H
-DEPDIR = .deps
-ECHO = echo
-ECHO_C = 
-ECHO_N = -n
-ECHO_T = 
-EGREP = grep -E
-ENABLE_GTK_DOC_FALSE = 
-ENABLE_GTK_DOC_TRUE = #
-EXEEXT = 
-F77 = 
-FFLAGS = 
-GDKPIXBUF_CFLAGS = 
-GDKPIXBUF_LIBS = 
-GLIB_CFLAGS = -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
-GLIB_GENMARSHAL = glib-genmarshal
-GLIB_LIBS = -Wl,--export-dynamic -lgmodule-2.0 -ldl -lgobject-2.0 -lglib-2.0  
-GLIB_MKENUMS = glib-mkenums
-GOBJECT_QUERY = gobject-query
-GTK_CFLAGS = 
-GTK_DOC_USE_LIBTOOL_FALSE = #
-GTK_DOC_USE_LIBTOOL_TRUE = 
-GTK_LIBS = 
-HAVE_GDKPIXBUF_FALSE = 
-HAVE_GDKPIXBUF_TRUE = #
-HTML_DIR = ${datadir}/gtk-doc/html
-INSTALL_DATA = ${INSTALL} -m 644
-INSTALL_PROGRAM = ${INSTALL}
-INSTALL_SCRIPT = ${INSTALL}
-INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
-LDFLAGS = 
-LEX = flex
-LEXLIB = -lfl
-LEX_OUTPUT_ROOT = lex.yy
-LIBOBJS = 
-LIBS = 
-LIBTOOL = $(SHELL) $(top_builddir)/libtool
-LN_S = ln -s
-LTLIBOBJS = 
-MAKEINFO = ${SHELL} /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/missing --run makeinfo
-OBJEXT = o
-PACKAGE = libg3d
-PACKAGE_BUGREPORT = 
-PACKAGE_NAME = 
-PACKAGE_STRING = 
-PACKAGE_TARNAME = 
-PACKAGE_VERSION = 
-PATH_SEPARATOR = :
-PKG_CONFIG = /usr/bin/pkg-config
-PLUGINS_LDFLAGS = -avoid-version -export-dynamic
-RANLIB = ranlib
-SET_MAKE = 
-SHELL = /bin/sh
-STRIP = strip
-VERSION = 0.0.3
-ac_ct_AR = ar
-ac_ct_CC = gcc
-ac_ct_CXX = g++
-ac_ct_F77 = 
-ac_ct_RANLIB = ranlib
-ac_ct_STRIP = strip
-am__fastdepCC_FALSE = #
-am__fastdepCC_TRUE = 
-am__fastdepCXX_FALSE = #
-am__fastdepCXX_TRUE = 
-am__include = include
-am__leading_dot = .
-am__quote = 
-bindir = ${exec_prefix}/bin
-build = i686-pc-linux-gnu
-build_alias = 
-build_cpu = i686
-build_os = linux-gnu
-build_vendor = pc
-datadir = ${prefix}/share
-exec_prefix = ${prefix}
-host = i686-pc-linux-gnu
-host_alias = 
-host_cpu = i686
-host_os = linux-gnu
-host_vendor = pc
-includedir = ${prefix}/include
-infodir = ${prefix}/info
-install_sh = /home/bigm/Desktop/libg3d-0.0.3/libg3d-0.0.3/config/install-sh
-libdir = ${exec_prefix}/lib
-libexecdir = ${exec_prefix}/libexec
-localstatedir = ${prefix}/var
-mandir = ${prefix}/man
-oldincludedir = /usr/include
-prefix = /usr/local
-program_transform_name = s,x,x,
-sbindir = ${exec_prefix}/sbin
-sharedstatedir = ${prefix}/com
-sysconfdir = ${prefix}/etc
-target_alias = 
-AUTOMAKE_OPTIONS = 1.6
-
-DOC_MODULE = libg3d
-
-DOC_MAIN_SGML_FILE = $(DOC_MODULE)-docs.sgml
-
-DOC_SOURCE_DIR = ../../include/g3d
-
-SCANGOBJ_OPTIONS = 
-
-SCAN_OPTIONS = 
-
-MKDB_OPTIONS = --sgml-mode --output-format=xml
-
-MKTMPL_OPTIONS = 
-
-FIXXREF_OPTIONS = 
-
-CFILE_GLOB = 
-HFILE_GLOB = 
-
-IGNORE_HFILES = 
-
-HTML_IMAGES = 
-
-content_files = 
-
-expand_content_files = 
-
-AM_CFLAGS = -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
-INCLUDES = -I$(top_srcdir)/include
-GTKDOC_LIBS = -Wl,--export-dynamic -lgmodule-2.0 -ldl -lgobject-2.0 -lglib-2.0  
-#GTKDOC_CC = $(CC) $(INCLUDES) $(AM_CFLAGS) $(CFLAGS)
-
-GTKDOC_CC = $(LIBTOOL) --mode=compile $(CC) $(INCLUDES) $(AM_CFLAGS) $(CFLAGS)
-#GTKDOC_LD = $(CC) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS)
-GTKDOC_LD = $(LIBTOOL) --mode=link $(CC) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS)
-
-# We set GPATH here; this gives us semantics for GNU make
-# which are more like other make's VPATH, when it comes to
-# whether a source that is a target of one rule is then
-# searched for in VPATH/GPATH.
-#
-GPATH = $(srcdir)
-
-TARGET_DIR = $(HTML_DIR)/$(DOC_MODULE)
-
-EXTRA_DIST = \
-	$(content_files)		\
-	$(HTML_IMAGES)			\
-	$(DOC_MAIN_SGML_FILE)		\
-	$(DOC_MODULE)-sections.txt	\
-	$(DOC_MODULE)-overrides.txt\
-
-
-DOC_STAMPS = scan-build.stamp tmpl-build.stamp sgml-build.stamp html-build.stamp \
-	   $(srcdir)/tmpl.stamp $(srcdir)/sgml.stamp $(srcdir)/html.stamp
-
-
-SCANOBJ_FILES = \
-	$(DOC_MODULE).args 	 \
-	$(DOC_MODULE).hierarchy  \
-	$(DOC_MODULE).interfaces \
-	$(DOC_MODULE).prerequisites \
-	$(DOC_MODULE).signals
-
-
-CLEANFILES = $(SCANOBJ_FILES) $(DOC_MODULE)-unused.txt $(DOC_STAMPS)
-subdir = doc/api
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/include/g3d/config.h
-CONFIG_CLEAN_FILES =
-DIST_SOURCES =
-DIST_COMMON = $(srcdir)/Makefile.in $(top_srcdir)/gtk-doc.make \
-	Makefile.am
-all: all-am
-
-.SUFFIXES:
-$(srcdir)/Makefile.in:  Makefile.am $(top_srcdir)/gtk-doc.make $(top_srcdir)/configure.in $(ACLOCAL_M4)
-	cd $(top_srcdir) &amp;&amp; \
-	  $(AUTOMAKE) --gnu  doc/api/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool
-uninstall-info-am:
-tags: TAGS
-TAGS:
-
-ctags: CTAGS
-CTAGS:
-
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
-
-distdir: $(DISTFILES)
-	$(mkinstalldirs) $(distdir)/../..
-	@srcdirstrip=`echo &quot;$(srcdir)&quot; | sed 's|.|.|g'`; \
-	topsrcdirstrip=`echo &quot;$(top_srcdir)&quot; | sed 's|.|.|g'`; \
-	list='$(DISTFILES)'; for file in $$list; do \
-	  case $$file in \
-	    $(srcdir)/*) file=`echo &quot;$$file&quot; | sed &quot;s|^$$srcdirstrip/||&quot;`;; \
-	    $(top_srcdir)/*) file=`echo &quot;$$file&quot; | sed &quot;s|^$$topsrcdirstrip/|$(top_builddir)/|&quot;`;; \
-	  esac; \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  dir=`echo &quot;$$file&quot; | sed -e 's,/[^/]*$$,,'`; \
-	  if test &quot;$$dir&quot; != &quot;$$file&quot; &amp;&amp; test &quot;$$dir&quot; != &quot;.&quot;; then \
-	    dir=&quot;/$$dir&quot;; \
-	    $(mkinstalldirs) &quot;$(distdir)$$dir&quot;; \
-	  else \
-	    dir=''; \
-	  fi; \
-	  if test -d $$d/$$file; then \
-	    if test -d $(srcdir)/$$file &amp;&amp; test $$d != $(srcdir); then \
-	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
-	    fi; \
-	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
-	  else \
-	    test -f $(distdir)/$$file \
-	    || cp -p $$d/$$file $(distdir)/$$file \
-	    || exit 1; \
-	  fi; \
-	done
-	$(MAKE) $(AM_MAKEFLAGS) \
-	  top_distdir=&quot;$(top_distdir)&quot; distdir=&quot;$(distdir)&quot; \
-	  dist-hook
-check-am: all-am
-check: check-am
-all-am: Makefile all-local
-
-installdirs:
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=&quot;$(INSTALL_STRIP_PROGRAM)&quot; \
-	  install_sh_PROGRAM=&quot;$(INSTALL_STRIP_PROGRAM)&quot; INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo &quot;INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'&quot;` install
-mostlyclean-generic:
-
-clean-generic:
-	-test -z &quot;$(CLEANFILES)&quot; || rm -f $(CLEANFILES)
-
-distclean-generic:
-	-rm -f $(CONFIG_CLEAN_FILES)
-
-maintainer-clean-generic:
-	@echo &quot;This command is intended for maintainers to use&quot;
-	@echo &quot;it deletes files that may require special tools to rebuild.&quot;
-clean: clean-am
-
-clean-am: clean-generic clean-libtool clean-local mostlyclean-am
-
-distclean: distclean-am
-	-rm -f Makefile
-distclean-am: clean-am distclean-generic distclean-libtool
-
-dvi: dvi-am
-
-dvi-am:
-
-info: info-am
-
-info-am:
-
-install-data-am: install-data-local
-
-install-exec-am:
-
-install-info: install-info-am
-
-install-man:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic \
-	maintainer-clean-local
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-generic mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-info-am uninstall-local
-
-.PHONY: all all-am all-local check check-am clean clean-generic \
-	clean-libtool clean-local distclean distclean-generic \
-	distclean-libtool distdir dvi dvi-am info info-am install \
-	install-am install-data install-data-am install-data-local \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	maintainer-clean-local mostlyclean mostlyclean-generic \
-	mostlyclean-libtool pdf pdf-am ps ps-am uninstall uninstall-am \
-	uninstall-info-am uninstall-local
-
-
-#all-local: html-build.stamp
-
-#### scan ####
-
-#scan-build.stamp: $(HFILE_GLOB) $(CFILE_GLOB)
-#	@echo '*** Scanning header files ***'
-#	@-chmod -R u+w $(srcdir)
-#	if grep -l '^..*$$' $(srcdir)/$(DOC_MODULE).types &gt; /dev/null 2&gt;&amp;1 ; then \
-#	    CC=&quot;$(GTKDOC_CC)&quot; LD=&quot;$(GTKDOC_LD)&quot; CFLAGS=&quot;$(GTKDOC_CFLAGS)&quot; LDFLAGS=&quot;$(GTKDOC_LIBS)&quot; gtkdoc-scangobj $(SCANGOBJ_OPTIONS) --module=$(DOC_MODULE) --output-dir=$(srcdir) ; \
-#	else \
-#	    cd $(srcdir) ; \
-#	    for i in $(SCANOBJ_FILES) ; do \
-#               test -f $$i || touch $$i ; \
-#	    done \
-#	fi
-#	cd $(srcdir) &amp;&amp; \
-#	  gtkdoc-scan --module=$(DOC_MODULE) --source-dir=$(DOC_SOURCE_DIR) --ignore-headers=&quot;$(IGNORE_HFILES)&quot; $(SCAN_OPTIONS) $(EXTRA_HFILES)
-#	touch scan-build.stamp
-
-#$(DOC_MODULE)-decl.txt $(SCANOBJ_FILES): scan-build.stamp
-#	@true
-
-#### templates ####
-
-#tmpl-build.stamp: $(DOC_MODULE)-decl.txt $(SCANOBJ_FILES) $(DOC_MODULE)-sections.txt $(DOC_MODULE)-overrides.txt
-#	@echo '*** Rebuilding template files ***'
-#	@-chmod -R u+w $(srcdir)
-#	cd $(srcdir) &amp;&amp; gtkdoc-mktmpl --module=$(DOC_MODULE) $(MKTMPL_OPTIONS)
-#	touch tmpl-build.stamp
-
-#tmpl.stamp: tmpl-build.stamp
-#	@true
-
-#### xml ####
-
-#sgml-build.stamp: tmpl.stamp $(CFILE_GLOB) $(srcdir)/tmpl/*.sgml $(expand_content_files)
-#	@echo '*** Building XML ***'
-#	@-chmod -R u+w $(srcdir)
-#	cd $(srcdir) &amp;&amp; \
-#	gtkdoc-mkdb --module=$(DOC_MODULE) --source-dir=$(DOC_SOURCE_DIR) --output-format=xml --expand-content-files=&quot;$(expand_content_files)&quot; $(MKDB_OPTIONS)
-#	touch sgml-build.stamp
-
-#sgml.stamp: sgml-build.stamp
-#	@true
-
-#### html ####
-
-#html-build.stamp: sgml.stamp $(DOC_MAIN_SGML_FILE) $(content_files)
-#	@echo '*** Building HTML ***'
-#	@-chmod -R u+w $(srcdir)
-#	rm -rf $(srcdir)/html 
-#	mkdir $(srcdir)/html
-#	cd $(srcdir)/html &amp;&amp; gtkdoc-mkhtml $(DOC_MODULE) ../$(DOC_MAIN_SGML_FILE)
-#	test &quot;x$(HTML_IMAGES)&quot; = &quot;x&quot; || ( cd $(srcdir) &amp;&amp; cp $(HTML_IMAGES) html )
-#	@echo '-- Fixing Crossreferences' 
-#	cd $(srcdir) &amp;&amp; gtkdoc-fixxref --module-dir=html --html-dir=$(HTML_DIR) $(FIXXREF_OPTIONS)
-#	touch html-build.stamp
-all-local:
-
-##############
-
-clean-local:
-	rm -f *~ *.bak
-	rm -rf .libs
-
-maintainer-clean-local: clean
-	cd $(srcdir) &amp;&amp; rm -rf xml html $(DOC_MODULE)-decl-list.txt $(DOC_MODULE)-decl.txt
-
-install-data-local:
-	installfiles=`echo $(srcdir)/html/*`; \
-	if test &quot;$$installfiles&quot; = '$(srcdir)/html/*'; \
-	then echo '-- Nothing to install' ; \
-	else \
-	  $(mkinstalldirs) $(DESTDIR)$(TARGET_DIR); \
-	  for i in $$installfiles; do \
-	    echo '-- Installing '$$i ; \
-	    $(INSTALL_DATA) $$i $(DESTDIR)$(TARGET_DIR); \
-	  done; \
-	  echo '-- Installing $(srcdir)/html/index.sgml' ; \
-	  $(INSTALL_DATA) $(srcdir)/html/index.sgml $(DESTDIR)$(TARGET_DIR) || :; \
-	fi
-
-uninstall-local:
-	rm -f $(DESTDIR)$(TARGET_DIR)/*
-
-#
-# Require gtk-doc when making dist
-#
-#dist-check-gtkdoc:
-dist-check-gtkdoc:
-	@echo &quot;*** gtk-doc must be installed and enabled in order to make dist&quot;
-	@false
-
-dist-hook: dist-check-gtkdoc dist-hook-local
-	mkdir $(distdir)/tmpl
-	mkdir $(distdir)/xml
-	mkdir $(distdir)/html
-	-cp $(srcdir)/tmpl/*.sgml $(distdir)/tmpl
-	-cp $(srcdir)/xml/*.xml $(distdir)/xml
-	-cp $(srcdir)/html/* $(distdir)/html
-	if test -f $(srcdir)/$(DOC_MODULE).types; then \
-	  cp $(srcdir)/$(DOC_MODULE).types $(distdir)/$(DOC_MODULE).types; \
-	fi
-
-.PHONY : dist-hook-local
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:

Added: trunk/libs3d/3dsread.c
===================================================================
--- trunk/libs3d/3dsread.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/3dsread.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,547 @@
+/*
+ * 3dsread.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &lt;stdlib.h&gt; 	 /*  exit(), malloc() */
+#include &lt;math.h&gt;		 /*  sqrt() */
+#include &lt;string.h&gt; 	 /*  strncpy() */
+#include &lt;errno.h&gt; 		 /*  errno */
+#define MAXSTRN		20
+/*  just a helper function for reading from file instead of memory. */
+int s3d_import_3ds_file(char *fname)
+{
+	char *buf,*ptr,*next;
+	char searchpath[1024];
+	char path[1024];
+#ifndef OBJSDIR
+#define OBJSDIR 	&quot;./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/&quot;
+#endif
+	
+	strncpy(searchpath,OBJSDIR,1023);
+	searchpath[1023]=0;							/* just in case */
+	next=ptr=searchpath;
+	while (next!=NULL)
+	{
+		next=NULL;
+		
+		if (NULL!=(next=strchr(ptr,':')))
+		{
+			*next=0; 							/* clear the delimiter */
+			next+=1;							/* move to the beginner of the next dir */
+		}
+		if ((strlen(ptr)+strlen(fname))&lt;1024) 	/* only try if this fits */
+		{
+			strcpy(path,ptr); 					/* can use &quot;unsafe&quot; functions because size was verified above */
+			strcat(path,fname);
+			if (s3d_open_file(path,&amp;buf)!=-1)  /* found something */
+				return(s3d_import_3ds(buf));
+		}
+		if (next!=NULL)
+			ptr=next;							/* move pointer to the next position */
+	}
+	errds(LOW,&quot;s3d_import_3ds_file()&quot;,&quot;Could not open %s&quot;, fname);
+	return(-1); /* nothing in search path ... */
+}
+static void normal(float *p0, float *p1, float *p2, float *r)
+{
+	float a[3],b[3],n[3];
+	float len;
+	a[0]=p1[0]-p0[0];
+	a[1]=p1[1]-p0[1];
+	a[2]=p1[2]-p0[2];
+	b[0]=p2[0]-p0[0];
+	b[1]=p2[1]-p0[1];
+	b[2]=p2[2]-p0[2];
+	n[0]=a[1]*b[2] - a[2]*b[1];
+	n[1]=a[2]*b[0] - a[0]*b[2];
+	n[2]=a[0]*b[1] - a[1]*b[0];
+
+	len=sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);
+	if (len!=0.0F)
+	{
+		r[0]=n[0]/len;
+		r[1]=n[1]/len;
+		r[2]=n[2]/len;
+	} else {
+		dprintf(VLOW,&quot;normal(): couldn't calc normal&quot;);
+		r[0]=r[1]=r[2]=0.0F;
+	}
+}
+void sort_poly(unsigned long *smooth_list, unsigned long *poly_buf,int polynum)
+{
+	unsigned long min,minv,i;
+	unsigned long polyel[4];
+	minv=-1;
+	min=0;
+	for (i=0;i&lt;polynum;i++)
+	{
+		if (smooth_list[i]&lt;minv) 
+		{
+			min=i;
+			minv=smooth_list[i];
+		}
+	}
+	if (min!=0)  /*  swap */
+	{
+#define EL	4*sizeof(unsigned long)
+		memcpy(polyel,poly_buf,EL);  /* save */
+		memcpy(poly_buf,poly_buf+4*min,EL);  /* put at first place */
+		memcpy(poly_buf+4*min,polyel,EL); 
+		 /*  now the same with smooth_list */
+		i=smooth_list[0];
+		smooth_list[0]=smooth_list[min];
+		smooth_list[min]=i;
+#undef EL
+	}
+	if (polynum&gt;1)
+	{
+		sort_poly(smooth_list+1,poly_buf+4,polynum-1);
+	}
+	
+}
+struct t_vertex_normal
+{
+	float n[3];
+	unsigned long g,num;
+};
+/*  this functions takes a shitload of arguments, but that's because of optimization.  */
+/*  we add normals of the polygons's vertices so each vertex will finally have */
+/*  the sum of the polygons normals where the vertex is part of. */
+static int smooth(float *vbuf,int voff, unsigned long *pbuf, float *pnbuf, float *nbuf, struct t_vertex_normal *v_t_buf, int pnum, int g)
+{
+	int i,j,n;
+	unsigned long k;
+	float len;
+	 /*  run1: add normals on themselves into the v_t_buf */
+	for (i=0;i&lt;pnum;i++)
+	{
+		for (j=0;j&lt;3;j++)
+		{
+			k=pbuf[i*4+j]-voff;
+			if (v_t_buf[k].g!=g)  /*  not added in this group yet */
+			{
+				for (n=0;n&lt;3;n++)
+					v_t_buf[k].n[n]=(pnbuf+i*3)[n];
+				v_t_buf[k].num=1;
+				v_t_buf[k].g=g;  /*  now it's  in our group. */
+			} else {
+				for (n=0;n&lt;3;n++)
+					v_t_buf[k].n[n]+=(pnbuf+i*3)[n];
+				v_t_buf[k].num++;
+			}
+		}
+	}
+	 /*  run2: apply to the final vertex buffer */
+	for (i=0;i&lt;pnum;i++)
+	{
+		for (j=0;j&lt;3;j++)
+		{
+			k=pbuf[i*4+j]-voff;
+			if (v_t_buf[k].num&gt;1)  /*  if more than 1, normalize. */
+			{
+				len=sqrt(v_t_buf[k].n[0]*v_t_buf[k].n[0]+v_t_buf[k].n[1]*v_t_buf[k].n[1]+v_t_buf[k].n[2]*v_t_buf[k].n[2]);
+				if (len==0.0F)   /*  this should not happen. well ... */
+				{
+					for (n=0;n&lt;3;n++)
+						v_t_buf[k].n[n]=0;
+					v_t_buf[k].g=-1;  /*  we're telling this by setting group to -1 */
+				}
+				else 
+					for (n=0;n&lt;3;n++)
+						v_t_buf[k].n[n]/=len;
+				v_t_buf[k].num=1;
+			}
+			if (v_t_buf[k].g==g)  /*  just making sure, or for the case of bad normals. */
+				memcpy(nbuf+i*9+j*3,v_t_buf[k].n,sizeof(float)*3);  /*  finally, we save the normal in our normal buffer */
+			else  /*  use the pbuf normal */
+			{
+				memcpy(nbuf+i*9+j*3,pnbuf+i*3,sizeof(float)*3);
+			}
+		}
+	}
+	return(0);
+}
+/*  calculates the normals: */
+static float *calc_normals(float *vertex_buf, int vertexnum, unsigned long *poly_buf,
+				int polynum, int voff,unsigned long *smooth_list)
+{
+	int i,j,n=0;
+	float *pnormal_list, *nbuf;  /*  pnormal_list has the space for normals per polygon, */
+								 /*  nbuf has 3 normals per polygon for each vertex */
+	struct t_vertex_normal *v_t_buf;
+								 /*  this buffer will save temporary normals for each vector */
+								 /*  along with the information of group (each group might */
+								 /*  have another normal for a certain vertex) and of polygons */
+								 /*  sharing this vertex. */
+	unsigned long v[3];
+	unsigned long lg,g;  /*  last group and group */
+	lg=-1;g=0;
+	pnormal_list=malloc(sizeof(float)*3*polynum);
+	nbuf=malloc(sizeof(float)*3*3*polynum);
+	v_t_buf=malloc(sizeof(struct t_vertex_normal)*vertexnum);
+	memset(v_t_buf,0,sizeof(struct t_vertex_normal)*vertexnum);
+	sort_poly(smooth_list, poly_buf, polynum);
+	for (i=0;i&lt;polynum;i++)
+	{
+		g=smooth_list[i];
+		if (lg!=g)  /*  a different group */
+		{
+			if (n&gt;0)  /*  that should only be false in the first loop */
+			{
+				smooth(vertex_buf,voff,poly_buf+(i-n)*4,pnormal_list+(i-n)*3, nbuf+(i-n)*9,v_t_buf,n,g);
+			}
+			n=0;  /*  no elements so far in the new group */
+		}
+		for (j=0;j&lt;3;j++)
+		{
+			v[j]=poly_buf[i*4+j]-voff;
+			if (v[j]&gt;=vertexnum)  /*  bad input */
+			{
+				errds(VHIGH,&quot;calc_normals()&quot;,&quot;bad input, polygon vertex index out of range&quot;);
+				return(NULL);
+			}
+		}
+		 /* dprintf(LOW,&quot;polygon [%d/%d]: %d %d %d is in smoothlist %d&quot;,i,polynum,v[0],v[1],v[2],g); */
+		
+		normal(	vertex_buf+v[0]*3,
+				vertex_buf+v[1]*3,
+				vertex_buf+v[2]*3,
+				pnormal_list+i*3);
+		lg=g; 	 /*  save the last group */
+		n++;	 /*  save the number of how much elements are in the group now. */
+	}
+
+
+
+	 /* dprintf(MED,&quot;processing the final group ... %d (%d members)&quot;,g,n); */
+	smooth(vertex_buf,voff,poly_buf+(i-n)*4,pnormal_list+(i-n)*3, nbuf+(i-n)*9,v_t_buf,n,g);
+/*	for (i=0;i&lt;polynum;i++)
+	{
+		for (j=0;j&lt;3;j++)
+			dprintf(MED,&quot;poly[%d/%d],point[%d/3]: %f %f %f&quot;,i,polynum,j,
+							nbuf[i*9+j*3],
+							nbuf[i*9+j*3+1],
+							nbuf[i*9+j*3+2]);
+	}*/
+	free(pnormal_list);
+	free(v_t_buf);
+	return(nbuf);
+}
+/* get the intergers in the right order */
+unsigned short gints(char *ptr)
+{
+	register unsigned short i;
+	i= ((unsigned char )ptr[0]);
+	i+=((unsigned char )ptr[1])*0x100;
+	return i;
+}
+unsigned long gintl(char *ptr)
+{
+	register unsigned long i;
+	i= ((unsigned char )ptr[0]);
+	i+=((unsigned char )ptr[1])*0x100;
+	i+=((unsigned char )ptr[2])*0x10000;
+	i+=((unsigned char )ptr[3])*0x1000000;
+	return i;
+}
+/*  imports a 3ds file as ONE object, even it virtually contains more. */
+/*  it returns the object id ... */
+int s3d_import_3ds(char *buf)
+{
+	char *ptr,*ptr2,*mesh_end=NULL;
+	int i,j,polynum=0,vertexnum=0;
+	char ostr[MAXSTRN+1];
+	char materials[256][MAXSTRN+1];
+	int clen,cid;
+	int filesize=1;  /*  just so it hops above the main chunk ... */
+	int vertex_offset=0; 
+	int v=0;
+	int col_obj=-1;
+	unsigned long *poly_buf=NULL,*tpbuf,*smooth_list=NULL;
+	unsigned char r1,g1,b1,r2,g2,b2,r3,g3,b3;
+	unsigned char r_amb=255,g_amb=255,b_amb=255,
+				  r_diff=255,g_diff=255,b_diff=255,
+				  r_spec=255,g_spec=255,b_spec=255;
+	unsigned char color=0;
+	unsigned short nfaces;
+	float *vertex_buf=NULL, *nbuf=NULL,*tnbuf;
+	int cur_oid=-1;
+	if (buf==NULL) return(-1);
+	ptr=buf;
+	while (((ptr)&gt;=buf) &amp;&amp; ((ptr)&lt;(buf+filesize)))
+	{
+		cid=gints(ptr);
+		clen=gintl(ptr+2);
+		
+		dprintf (VLOW,&quot;[pos %x]: \t%04x [len:%d]&quot;,(ptr-buf),cid,(clen-6));
+		if ((ptr==buf) &amp;&amp; (cid!=0x4d4d))
+		{
+			errs(&quot;3d_import_3ds()&quot;,&quot;file doesn't start with 0x4d4d, maybe file corrupt?&quot;);
+			return(-1);
+		}
+		ptr=ptr+6;  /*  point to the data .. */
+		switch (cid)
+		{
+		  case 0x4d4d: 
+			  dprintf(VLOW,&quot;-- the main chunk!!&quot;);
+			  filesize=clen;
+			  if (cur_oid==-1)
+			  {
+				  cur_oid=s3d_new_object();
+				   /*  standard material for fallback reasons */
+			      s3d_push_material(cur_oid,0.2,0.2,0,0.2,0.2,0,0.2,0.2,0);
+				  col_obj++;
+			  }
+
+           	  break;
+		  case 0x3D3D:
+			  dprintf(VLOW,&quot;-- the 3d editor chunk!&quot;);
+			  break;
+		  case 0x4000:
+			  dprintf(VLOW,&quot;-- an object block. let's see ...&quot;);
+			  strncpy((char *)ostr,(char *)ptr,MAXSTRN);
+			  vertex_offset+=v;
+			  v=0;
+			  ptr=(ptr+strlen(ostr)+1);
+			  break;
+		  case 0x4100:
+			  dprintf(VLOW,&quot;-- Triangular mesh&quot;);
+			  smooth_list=NULL;
+			  mesh_end=ptr+(clen-6);
+			  break;
+		  case 0x4110: 
+			  vertexnum=gints(ptr);
+			  ptr+=sizeof(unsigned short);
+			  dprintf(VLOW,&quot;-- vertices list!! number of vertices: %d&quot;,vertexnum);
+			  vertex_buf=malloc(sizeof(float)*3*vertexnum);
+			  if (vertex_buf==NULL) break;
+/* 			  memcpy(vertex_buf,ptr,sizeof(float)*3*i); */
+			  for (j=0; j&lt;vertexnum; j++)
+		 	  {
+				*(vertex_buf+j*3+0)=*((float *)ptr+0);
+				*(vertex_buf+j*3+1)=*((float *)ptr+2);
+				*(vertex_buf+j*3+2)=-*((float *)ptr+1);
+				ptr+=sizeof(float)*3;
+			  }
+			  v+=vertexnum;  /*  for the correct vertex offset */
+			break;
+		  case 0x4120:
+			polynum=gints(ptr);
+			ptr+=sizeof(unsigned short);
+			dprintf(VLOW,&quot;-- polygon list!! number of polygons: %d&quot;,polynum);
+			poly_buf=malloc(sizeof(unsigned long)*4*polynum);
+			if (poly_buf==NULL) break;
+		    for (j=0; j&lt;polynum; j++)
+			{
+				poly_buf[j*4+0]=vertex_offset+gints(ptr+0); 
+				poly_buf[j*4+1]=vertex_offset+gints(ptr+2);
+				poly_buf[j*4+2]=vertex_offset+gints(ptr+4);
+				poly_buf[j*4+3]=col_obj;  /*  we should have a default material .... */
+				ptr+=sizeof(unsigned short)*4;
+		    }
+			break;
+		  case 0x4130:
+			ptr2=(char *)ptr+(clen-6);  /*  backup our endpointer ... */
+			dprintf(VLOW,&quot;-- material information for faces .....&quot;);
+			strncpy((char *)ostr,(char *)ptr,MAXSTRN);
+			ptr+=strlen(ptr)+1;
+			dprintf(VLOW,&quot;.. material string name is %s&quot;,ostr);
+			col_obj=0;
+			while (col_obj&lt;256 &amp;&amp; (strncmp(ostr,materials[col_obj],MAXSTRN)!=0)) col_obj++;
+			if (col_obj&gt;=256)
+			{
+				errds(MED,&quot;s3d_import_3ds()&quot;,&quot;couldn't find material %s&quot;,ostr);
+				col_obj=0;
+			}
+			nfaces=gints(ptr);
+			ptr+=2;
+			for (i=0;i&lt;nfaces;i++)
+			{
+				j=gints(ptr+2*i);
+				if (j&gt;=0 &amp;&amp; j&lt;polynum)
+					poly_buf[gints(ptr+2*i)*4+3]=col_obj; 
+				else {
+					errds(MED,&quot;s3d_import_3ds()&quot;,&quot;polygon %d out of range!&quot;,j);
+				}
+			}
+			ptr=ptr2;
+			break;
+		  case 0x4150:
+			dprintf(VLOW,&quot;-- smoothing group information (length %d [%d])&quot;, clen,clen/4);
+			smooth_list=(unsigned long *)ptr;
+			for (j=0;j&lt;(clen/4);j++)
+			{
+				smooth_list[j]=gintl(ptr+j*4);
+			}
+
+			ptr=(char *)ptr+(clen-6);
+			break;
+		  case 0x4160:
+			  dprintf(VLOW,&quot;-- translation matrix&quot;);
+			  for (j=0; j&lt;4; j++)
+		 	  {
+				dprintf(VLOW,&quot;[%f:%f:%f:%f]&quot;,
+								*((float *)ptr),
+								*((float *)ptr+1),
+								*((float *)ptr+2),
+								((j==3)?1.0:0.0)
+								);
+				ptr+=sizeof(float)*3;
+			  }
+			  break;
+		  case 0xafff:
+			  dprintf(VLOW,&quot;-- material chunk O_o&quot;);
+			  break;
+		  case 0xa000:
+			  strncpy((char *)ostr,(char *)ptr,MAXSTRN);
+			  dprintf(VLOW,&quot;-- material string name is %s&quot;,ostr);
+			  ptr=(char *)ptr+(clen-6);
+			  color|=8;
+			  break;
+		  case 0xa010:
+			  r1=(unsigned char)*(ptr);
+			  g1=(unsigned char)*(ptr+1);
+			  b1=(unsigned char)*(ptr+2);
+			  r2=(unsigned char)*(ptr+3);
+			  g2=(unsigned char)*(ptr+4);
+			  b2=(unsigned char)*(ptr+5);
+			  r3=(unsigned char)*(ptr+6);
+			  g3=(unsigned char)*(ptr+7);
+			  b3=(unsigned char)*(ptr+8);
+			  dprintf(VLOW,&quot;-- ambient color 3:&gt;&gt; [rgb] [%x %x %x]&quot;,r3,g3,b3);
+			  r_amb=r3;g_amb=g3;b_amb=b3;
+			  color=color|1;
+			  ptr=(char *)ptr+(clen-6);
+			  break;
+		  case 0xa020:
+			  r1=(unsigned char)*(ptr);
+			  g1=(unsigned char)*(ptr+1);
+			  b1=(unsigned char)*(ptr+2);
+			  r2=(unsigned char)*(ptr+3);
+			  g2=(unsigned char)*(ptr+4);
+			  b2=(unsigned char)*(ptr+5);
+			  r3=(unsigned char)*(ptr+6);
+			  g3=(unsigned char)*(ptr+7);
+			  b3=(unsigned char)*(ptr+8);
+			  dprintf(VLOW,&quot;-- diffuse color 3:&gt;&gt; [rgb] [%x %x %x]&quot;,r3,g3,b3);
+			  r_diff=r3;g_diff=g3;b_diff=b3;
+			  color=color|2;
+			  ptr=(char *)ptr+(clen-6);
+			  break;
+		  case 0xa030:
+			  r1=(unsigned char)*(ptr);
+			  g1=(unsigned char)*(ptr+1);
+			  b1=(unsigned char)*(ptr+2);
+			  r2=(unsigned char)*(ptr+3);
+			  g2=(unsigned char)*(ptr+4);
+			  b2=(unsigned char)*(ptr+5);
+			  r3=(unsigned char)*(ptr+6);
+			  g3=(unsigned char)*(ptr+7);
+			  b3=(unsigned char)*(ptr+8);
+			  dprintf(VLOW,&quot;-- spec color 3:&gt;&gt; [rgb] [%x %x %x]&quot;,r3,g3,b3);
+			  r_spec=r3;g_spec=g3;b_spec=b3;
+			  color=color|4;
+			  ptr=(char *)ptr+(clen-6);
+			  break;
+		  default:
+			ptr=(char *)ptr+(clen-6);
+		}
+		 /*  color finished? then upload. I know, this is not real implementation ... */
+		if (color==15)
+		{
+			col_obj++;
+			if (col_obj&lt;256)  /*  TODO: we currently don't support  */
+							  /*  more than 256 materials ...  */
+							  /*  that's just because i'm lazy */
+			{
+				strncpy(materials[col_obj],ostr,MAXSTRN);
+				dprintf(VLOW,&quot;assigned material %s on position %d&quot;,
+								materials[col_obj],col_obj);
+			}
+			dprintf(VLOW,&quot;-- [%d]colors... amb: %d %d %d, spec %d %d %d, diff %d %d %d&quot;,col_obj,
+							r_amb,g_amb,b_amb,
+							r_spec,g_spec,b_spec,
+							r_diff,g_diff,b_diff
+				   );
+			s3d_push_material(cur_oid,
+							r_amb/255.0,g_amb/255.0,b_amb/255.0,
+							r_spec/255.0,g_spec/255.0,b_spec/255.0,
+							r_diff/255.0,g_diff/255.0,b_diff/255.0
+							);
+			color=0;
+		}
+		if ((mesh_end!=NULL) &amp;&amp; (ptr&gt;=mesh_end))
+		{
+			mesh_end=NULL;
+			if ((vertex_buf!=NULL))
+			    s3d_push_vertices(cur_oid, vertex_buf, vertexnum); 
+			if (poly_buf!=NULL)
+			{
+				if (smooth_list!=NULL)
+					nbuf=calc_normals(vertex_buf,vertexnum,poly_buf,polynum,vertex_offset,smooth_list);
+
+				 /*  do in 1000 chunks */
+				dprintf(LOW,&quot;committing %d polys&quot;,polynum);
+				tnbuf=nbuf;
+				tpbuf=poly_buf;
+#define CSIZE	1000
+				while (polynum&gt;CSIZE)
+				{
+					s3d_push_polygons(cur_oid, tpbuf, CSIZE);
+					if (nbuf!=NULL)
+						s3d_pep_polygon_normals(cur_oid,tnbuf, CSIZE);
+					tnbuf+=	CSIZE*9;
+					tpbuf+=	CSIZE*4;
+					polynum-=CSIZE;
+				}
+				s3d_push_polygons(cur_oid, tpbuf, polynum);
+				if (nbuf!=NULL)
+					s3d_pep_polygon_normals(cur_oid,tnbuf, polynum);
+			}
+
+
+			 /*  clean things up */
+			if (vertex_buf!=NULL)
+			{
+				free(vertex_buf);vertex_buf=NULL;
+			}
+			if (poly_buf!=NULL)
+			{
+				free(poly_buf);poly_buf=NULL;
+			}
+			if (smooth_list!=NULL)
+			{
+				free(smooth_list);smooth_list=NULL;
+			}
+			if (nbuf!=NULL)
+			{
+				free(nbuf);nbuf=NULL;
+			}
+		}
+	}
+	dprintf(VLOW,&quot;-- done [ptr:%010p,buf:%010p]...&quot;,ptr,buf);
+	free(buf);
+	return(cur_oid);
+}

Added: trunk/libs3d/Makefile.am
===================================================================
--- trunk/libs3d/Makefile.am	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/Makefile.am	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,15 @@
+lib_LTLIBRARIES=	libs3d.la
+
+libs3d_la_SOURCES=	3dsread.c callback.c error.c event.c fontselect.c \
+			freetype.c io.c network.c object_queue.c proto_in.c \
+			proto_out.c shm.c shm_ringbuf.c tcp.c \
+			sei_construct.c sei_misc.c sei_monotone.c sei_tri.c vector.c
+			
+include_HEADERS= s3d.h s3d_keysym.h
+noinst_HEADERS=		config.h s3dlib.h sei_triangulate.h sei_interface.h
+
+libs3d_la_CPPFLAGS=	-I${top_srcdir}/server
+libs3d_la_CFLAGS=	@FONTCONFIG_CFLAGS@ @FREETYPE_CFLAGS@ 
+libs3d_la_LIBADD=	@FONTCONFIG_LIBS@ @FREETYPE_LIBS@ @LIBM@
+
+EXTRA_DIST=		lgpl.txt

Added: trunk/libs3d/TODO
===================================================================
--- trunk/libs3d/TODO	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/TODO	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,6 @@
+TODO:
+- texture support for 3ds
+- shmat() return (char *) -1 or NULL?! data_ctos/data_stoc should
+  really not be 0x0
+- 3ds reader won't work on linux ppc, probably lots of memory leaks
+- .max, .x, .obj files

Added: trunk/libs3d/callback.c
===================================================================
--- trunk/libs3d/callback.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/callback.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,74 @@
+/*
+ * callback.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+static void _s3d_ignore(struct s3d_evt *evt);
+/*  the s3d callback list */
+s3d_cb s3d_cb_list[MAX_CB]={
+			NULL,_s3d_ignore,_s3d_ignore,_s3d_ignore, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+			_s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL
+			};
+/* the ignore-handler ;) */
+static void _s3d_ignore(struct s3d_evt *evt)
+{
+	/* do plain nothing */
+}
+/*  sets a callback */
+void s3d_set_callback(unsigned char event, s3d_cb func)
+{
+	s3d_cb_list[(int)event]=func;
+	s3d_process_stack();
+}
+/*  clears a callback, same as s3d_set_callback(event, (s3d_cb) NULL); */
+void s3d_clear_callback(unsigned char event)
+{
+	s3d_cb_list[(int)event]=NULL;
+}
+/* ignores an event ... */
+void s3d_ignore_callback(unsigned char event)
+{
+	s3d_set_callback(event,_s3d_ignore);
+}
+s3d_cb s3d_get_callback(unsigned char event)
+{
+	return(s3d_cb_list[(int)event]);
+}

Added: trunk/libs3d/config.h
===================================================================
--- trunk/libs3d/config.h	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/config.h	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,31 @@
+/*
+ * config.h
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+/*  this is definitly the better way to pick fonts. */
+
+#define WITH_FONTCONFIG
+/*  our level of debug messages */
+#define DEBUG			LOW /*  standard debug level */
+#define SHM_MAX_IDLE	200	/* maximum wait for server timeout */
+#define	SEI_SS			200	/* seidel algorithm maximum point number */

Added: trunk/libs3d/error.c
===================================================================
--- trunk/libs3d/error.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/error.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,70 @@
+/*
+ * error.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &lt;stdarg.h&gt;		 /*  va_list */
+#include &lt;stdio.h&gt; 		 /*  perror(),fprintf() */
+#include &lt;string.h&gt; 	 /*  sterror */
+/*  dprintf is only for internal use. */
+#ifdef DEBUG
+void dprintf(int relevance, const char *fmt, ...) {
+	char dbm[DBM_MAX];
+	va_list args;
+	if (relevance &gt;= DEBUG )
+	{
+		va_start(args,fmt);
+		vsnprintf((char *)&amp;dbm,DBM_MAX,fmt,args);
+		va_end(args);
+	
+		fprintf(stderr,&quot;s3dlib: %s\n&quot;,(char *)&amp;dbm);
+	}
+}
+void errdn(int relevance, char *func,int en) {
+	if (relevance &gt;= DEBUG )
+		 fprintf(stderr,&quot;s3dlib error: %s: (%d) %s\n&quot;,func,en, strerror(en));
+}
+
+void errds(int relevance,char *func, const char *fmt, ...)
+{
+	char dbm[DBM_MAX];
+	va_list args;
+	if (relevance &gt;= DEBUG )
+	{
+		va_start(args,fmt);
+		vsnprintf((char *)&amp;dbm,DBM_MAX,fmt,args);
+		va_end(args);
+	
+		fprintf(stderr,&quot;s3dlib error: %s:%s\n&quot;,func,(char *)&amp;dbm);
+	}
+}
+#endif
+void errn(char *func,int en) {
+	fprintf(stderr,&quot;s3dlib error: %s: (%d) %s\n&quot;,func,en, strerror(en));
+}
+void errs(char *func, char *msg) {
+	fprintf(stderr,&quot;s3dlib error: %s: %s\n&quot;,func,msg);
+}
+
+

Added: trunk/libs3d/event.c
===================================================================
--- trunk/libs3d/event.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/event.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,137 @@
+/*
+ * event.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &quot;proto.h&quot;
+#include &lt;stdlib.h&gt;		 /*  malloc(), free() */
+
+struct s3d_evt *s3d_stack;
+static int cb_lock=0;	 /*  callback lock */
+void s3d_push_event(struct s3d_evt *newevt)
+{
+	struct s3d_evt *p;
+	s3d_cb cb;
+	 /*  this will always be called for S3D_EVENT_NEW_OBJECT!! */
+	if (newevt-&gt;event==S3D_EVENT_NEW_OBJECT)
+	{
+		_queue_new_object(*((unsigned int *)newevt-&gt;buf));	
+	}
+	if (cb_lock)  /*  no recursive event-callbacks, please! */
+	{	
+		cb_lock=2;  /*  we want our event processed after this finishs */
+	} else 	{
+		if (NULL!=(cb=s3d_get_callback(newevt-&gt;event)))
+		{
+			cb_lock=1;		 /*  on our way! lock it.. */
+			cb(newevt);		 /*  .. and call it! */
+			if (cb_lock==2)  /*  there were other callbacks? we process: */
+				s3d_process_stack();
+			cb_lock=0;
+			free(newevt);
+			return;
+		}
+	}
+	newevt-&gt;next=NULL;
+	if (s3d_stack!=NULL)
+	{
+		for (p=s3d_stack;p-&gt;next!=NULL;p=p-&gt;next);  /*  go to the end */
+		p-&gt;next=newevt;
+	} else
+		s3d_stack=newevt;
+}
+struct s3d_evt *s3d_pop_event()
+{
+	struct s3d_evt *ret;
+	if ((ret=s3d_stack)!=NULL)
+		s3d_stack=s3d_stack-&gt;next;
+	return ret;
+}
+struct s3d_evt *s3d_find_event(unsigned char event)
+{
+	struct s3d_evt *p;
+	p=s3d_stack;
+	while (p!=NULL)
+	{
+		if (p-&gt;event==event)
+			return(p);
+		p=p-&gt;next;
+	}
+	return(NULL);
+}
+int s3d_delete_event(struct s3d_evt *devt)
+{
+	struct s3d_evt *previous=NULL;
+	struct s3d_evt *p=s3d_stack;
+	while (p!=NULL)
+	{
+		 /* if ((p-&gt;event==devt-&gt;event) &amp;&amp; (p-&gt;length==devt-&gt;length)) */
+		 /* 	if (0==memcmp(p-&gt;buf,devt-&gt;buf)) */
+		if (p==devt)
+			{
+				if (p-&gt;length&gt;0) 
+					free(p-&gt;buf);
+				if (previous==NULL) 
+					s3d_stack=p-&gt;next;  /*  the first element!! */
+				else
+					previous-&gt;next=p-&gt;next;  /*  unlink */
+				free(p);
+			}
+		previous=p;
+		p=p-&gt;next;
+	}
+	return(-1);
+}
+/*  this function checks the stack for callbacks. */
+void s3d_process_stack()
+{
+	struct s3d_evt *p,*pre,*t;
+	s3d_cb cb;
+	p=s3d_stack;
+	pre=NULL;
+	while (p!=NULL)
+	{
+		
+		if ((cb=s3d_get_callback(p-&gt;event))!=NULL)
+		{
+			cb(p);
+			if (pre!=NULL)   /*  there is a previous element */
+				pre-&gt;next=p-&gt;next;
+			else			 /*  it's the first element */
+				s3d_stack=p-&gt;next;
+			t=p-&gt;next;
+			 /*  free */
+			if (p-&gt;length&gt;0) 
+				free(p-&gt;buf);
+			free(p);	
+			p=t;
+			
+		}
+		else 
+		{
+			pre=p;
+			p=p-&gt;next;
+		}
+	}
+}

Added: trunk/libs3d/fontselect.c
===================================================================
--- trunk/libs3d/fontselect.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/fontselect.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,113 @@
+/*
+ * fontselect.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+/*  here we select our truetype font. I'd recommend the fontconfig way,  */
+/*  as it always gives the best matching font. a xft version and a win32 */
+/*  version would be nice too, to be implemented :) */
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &lt;dirent.h&gt; 	 /*  dirent */
+#include &lt;X11/Xlib.h&gt;  /*  Display type, XOpenDisplay(), XCloseDIsplay etc. */
+#ifdef WITH_FONTCONFIG
+#include &quot;ft2build.h&quot;
+#include FT_FREETYPE_H
+#include &lt;fontconfig/fontconfig.h&gt;
+#endif
+#include &lt;stdlib.h&gt;    /*  malloc(), free() */
+#include &lt;string.h&gt;    /*  strlen(), strncasecmp(), strncmp() */
+
+
+#ifdef WITH_FONTCONFIG
+char *s3d_findfont(char *mask)
+{
+  FcPattern *pattern = 0, *match = 0;
+  FcChar8 *file = 0;
+
+  pattern = FcNameParse((FcChar8 *)mask);
+  FcConfigSubstitute(0,pattern,FcMatchPattern);
+  FcDefaultSubstitute(pattern);
+  if (!(match=FcFontMatch(0,pattern,0))) 
+	return NULL;
+  if (FcPatternGetString(match,FC_FILE,0,&amp;file)!=FcResultMatch)
+	return NULL;
+  return (char *)file;
+}
+#else 
+/*  this uses the xserver to get a font-path and scan it for ttf-fonts. */
+/*  if it matches, give it out ... it's not nice, right, and might not */
+/*  work on your place. */
+char *s3d_findfont(char *mask)
+{
+    char **flist = NULL; int fnum = 0;
+	char *disp=NULL;
+	int n;
+	char *fname;
+	char *good=NULL;
+	struct dirent **namelist;
+	Display *dpy;
+
+	dpy = XOpenDisplay(disp);  /*  Open display and check for success */
+	if (dpy == NULL) 
+	  errds(VHIGH, &quot;s3d_findfont()&quot;,&quot;unable to open display %s&quot;, XDisplayName (disp));
+	else 
+	{
+		if (!(flist = XGetFontPath (dpy, &amp;fnum)))
+		{
+		    errds(VHIGH, &quot;s3d_findfont():XGetFontPath()&quot;,&quot;unable to get font path.&quot;);
+		}
+		else 
+		while (fnum--)
+		{
+			 /*  now scan the directories	 */
+    		n =  scandir(flist[fnum], &amp;namelist, 0, alphasort);
+        	while(n--&gt;0) 
+			{
+				fname=namelist[n]-&gt;d_name;
+				if (strlen(fname)&gt;(strlen(mask)+3))  /*  there should be enough space for the .ttf ending */
+				{
+					 /*  check for the first n characters */
+					if (0==strncasecmp(fname,mask,strlen(mask)))
+					{
+						 /*  name matches! now check for the end... */
+						if (0==strncasecmp(fname+(strlen(fname)-3),&quot;ttf&quot;,3)) /*  check if it has a ttf-ending */
+						{
+							if (good==NULL)
+								good=malloc(256);
+							strncpy(good,flist[fnum],255);
+							good[256]=0; 									/* just in case */
+							strncat(good,fname,255-strlen(good));
+							if ((strlen(mask)+4)==strlen(fname))
+							{
+								return(good);
+							}
+						}
+					}
+				}
+			}
+		}
+		XCloseDisplay (dpy);
+	}
+	return(good);
+}
+#endif

Added: trunk/libs3d/freetype.c
===================================================================
--- trunk/libs3d/freetype.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/freetype.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,381 @@
+/*
+ * freetype.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+/*  this file should render truetype fonts as objects */
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &quot;sei_interface.h&quot;	/* sei_triangulate_polygon() */
+#include &lt;stdlib.h&gt;    		/*  malloc(), free() */
+#include &lt;math.h&gt;			/*  atan2() */
+#include &quot;ft2build.h&quot;
+#include FT_FREETYPE_H
+#ifndef CALLBACK 
+#define CALLBACK
+#endif
+/*  bad global vars ... */
+static FT_Library 	library;
+static FT_Face		face;
+static unsigned char *memory_font=NULL;		 /*  the font file in memory */
+static int memory_font_size=0;	 /*  and it's size, to reduce load times. */
+static int ft_init=0;
+static int face_init=0;
+
+static int v_off; 	 /*  the vertex number offset, to have the right vertex numbers for each character */
+static int f_oid;	 /*  the oid of our font string */
+static int ch;
+struct t_buf tess_buf[256];
+
+
+
+/*  initialize truetype and tess_buf ... */
+int s3d_ft_init()
+{
+	int error= FT_Init_FreeType( &amp;library);
+	int i;
+	if (error)
+		return (-1);
+    ft_init=1;
+	for (i=0; i&lt;256;i++)
+	{
+		tess_buf[i].vbuf=NULL;
+		tess_buf[i].pbuf=NULL;
+	}
+
+	return(0);
+}
+
+int s3d_ft_load_font()
+{
+	FT_Error error;
+	if ((memory_font==NULL) || (memory_font_size==0))
+	{
+		errds(HIGH,&quot;s3d_ft_load_font()&quot;,&quot;there is no font in memory, breaking&quot;);
+		return(-1);
+	}
+	face_init=0;
+	error= FT_New_Memory_Face(library,memory_font,memory_font_size,0,&amp;face);
+	switch (error)
+	{
+		case 0:
+				face_init=1;
+				break;
+		case FT_Err_Unknown_File_Format:
+				errds(HIGH,&quot;s3d_ft_load_font()&quot;,&quot;bad font file format&quot;);
+				return(-1);
+				break;
+		default:
+				errds(HIGH,&quot;s3d_ft_load_font()&quot;,&quot;couldn't load font for some reason (error %d)&quot;,error);
+				return(-1);
+				break;
+	}
+	return(0);
+}
+
+int _s3d_clear_tessbuf()
+{
+	int i;
+	for (i=0; i&lt;256;i++)
+	{
+		if (tess_buf[i].vbuf!=NULL) free(tess_buf[i].vbuf);
+		if (tess_buf[i].pbuf!=NULL) free(tess_buf[i].pbuf);
+	}
+	return(0);
+}
+
+
+/* renders a character with seidels algorithm and stores it in the tess_buf for later
+ * usage */
+int _s3d_add_tessbuf(unsigned short a)
+{
+	float norm,ar,xa,ya;
+	int i,j,k,c,n,start,outl,s,e;
+	int np,pos;
+	int triangles[SEI_SS*2][3]; /* more than enough ... */
+	int ncontours,ncon;
+	int cntr[SEI_SS];
+	int ncntr[SEI_SS];
+	int csta[SEI_SS],ncsta[SEI_SS];
+	int perm[SEI_SS];
+	float area[SEI_SS];
+	double vertices[SEI_SS+1][2];
+	double nvertices[SEI_SS+1][2];
+	
+
+	if (FT_Load_Char(face,a,	FT_LOAD_NO_BITMAP|FT_LOAD_NO_SCALE))
+	{
+		errds(VHIGH,&quot;s3d_add_tessbuf():FT_Load_Char()&quot;,&quot;can't load character&quot;);
+		return(-1);
+	} 
+	dprintf(VLOW,&quot;[T]riangulating character %c&quot;,a);
+	norm=1.0/face-&gt;glyph-&gt;metrics.vertAdvance;
+	ch=a;
+	v_off=0;
+	if ((face-&gt;glyph-&gt;outline.n_points&gt;0) &amp;&amp; (face-&gt;glyph-&gt;outline.n_points&lt;SEI_SS))
+	{
+		tess_buf[a].vn=face-&gt;glyph-&gt;outline.n_points;
+		tess_buf[a].vbuf=malloc(sizeof(float)*face-&gt;glyph-&gt;outline.n_points*3);
+		
+		j=0;
+		ncontours=face-&gt;glyph-&gt;outline.n_contours;
+		for (c=0;c&lt;ncontours;c++)
+		{
+			start=j; 	/* first point */
+			i=0;
+			ncon=face-&gt;glyph-&gt;outline.contours[c]; /* position of the end of ths contour */
+			cntr[c]=ncon-j+1;					   /* how many points do we have here? */
+			csta[c]=j+1;
+			ar=0.0f;
+			while (j&lt;(ncon+1))
+			{
+				/* vertices have reverse order in seidels algorithm, outer contours go anticlockwise, inner contours clockwise */
+				/* calculate the area */
+				k=((j+2-csta[c])%(cntr[c]))+csta[c]-1;
+				ar-=face-&gt;glyph-&gt;outline.points[j].x * face-&gt;glyph-&gt;outline.points[k].y;
+				ar+=face-&gt;glyph-&gt;outline.points[k].x * face-&gt;glyph-&gt;outline.points[j].y;
+
+				pos=ncon-i;
+				vertices[pos+1][0]=face-&gt;glyph-&gt;outline.points[j].x*norm;
+				vertices[pos+1][1]=face-&gt;glyph-&gt;outline.points[j].y*norm;
+				j++;
+				i++;
+			}
+			ar=0.5f*norm*norm*ar;
+			dprintf(VLOW,&quot;contour %d has area of %3.3f, cntr is %d, contour starts at %d, ncon %d&quot;,c,ar,cntr[c], csta[c], ncon);
+			area[c]=ar; /* save the area */
+		}
+		/* now as we have the areas and sizes of the contours, we need to order our contours so that 
+		 * the outlines and their holes are grouped together */
+		n=ncontours;
+		for (i=0;i&lt;n;i++)
+			perm[i]=i; /* initialise permutation */
+		while (n!=0)
+		{
+			outl=-1;
+			/* find an outline */
+			for (i=0;i&lt;n;i++)
+				if (area[perm[i]]&gt;0)
+				{
+					outl=i; /* found. that was easy ;) */
+					break;
+				}
+			if (outl==-1)
+			{
+				dprintf(HIGH,&quot;hole without outline found, exiting ... %c&quot;,a);
+				return(-1);
+			}
+			for (i=0;i&lt;n;i++)
+			{
+				if (area[perm[i]]&lt;0)
+				{
+					/* test for a hole inside by taking one (the first) point of the hole and doing the test */
+					xa=vertices[csta[perm[i]]][0];
+					ya=vertices[csta[perm[i]]][1];
+					s=csta[perm[outl]];							/* start point of outline */
+					e=(csta[perm[outl]]+cntr[perm[outl]])-1;		/* end point */
+					ar=0;
+					for (j=s;j&lt;e;j++)
+					{ /* for all points of the outline, sum: */
+						ar+=atan2((vertices[j+1][1]-ya)*(vertices[j][0]-xa)-(vertices[j+1][0]-xa)*(vertices[j][1]-ya),
+								  (vertices[j+1][0]-xa)*(vertices[j][0]-xa)+(vertices[j+1][1]-ya)*(vertices[j][1]-ya));
+					}
+					/* dont forget the start/end-point connection*/
+					ar+=atan2((vertices[s][1]-ya)*(vertices[e][0]-xa)-(vertices[s][0]-xa)*(vertices[e][1]-ya),
+							  (vertices[s][0]-xa)*(vertices[e][0]-xa)+(vertices[s][1]-ya)*(vertices[e][1]-ya));
+					if (fabsf(ar)&gt;1)						/* if ar = 0.0, it's outside, elseway it's a multiple of pi. this check should be
+															 * very generous to roundoff errors */
+					{
+						dprintf(VLOW,&quot;hole %d (%d) in %d (%d): interior angle sum %f (n=%d)&quot;,i,perm[i],outl, perm[outl],ar,n);
+						j=perm[n-1];	/* swap our hole to the end */
+						perm[n-1]=perm[i];
+						perm[i]=j;
+						if (outl==n-1)
+							outl=i;		/* outline got swapped */
+						n--;			/* we don't care for the hole at the end anymore as it's found */
+						i--;			/* check again for the just-swapped value in the next
+										 * loop iteration */
+					}
+				}
+			}
+			/* all the holes should be behind n-i, if so, so we swap our outline to the end now */
+			j=perm[n-1];	/* swap our hole to the end */
+			perm[n-1]=perm[outl];
+			perm[outl]=j;
+			n--;			/* we don't care for the hole at the end anymore as it's found */
+		}
+		/* finished the permutation, now apply the new order .... */
+		n=1;
+		for (c=0;c&lt;ncontours;c++)
+		{
+			ncsta[c]=n-1;
+			for (j=csta[perm[c]];j&lt;(csta[perm[c]]+cntr[perm[c]]);j++)
+			{
+				nvertices[n][0]=vertices[j][0];
+				nvertices[n][1]=vertices[j][1];
+				tess_buf[a].vbuf[(n-1)*3]	=nvertices[n][0];
+				tess_buf[a].vbuf[(n-1)*3+1]	=nvertices[n][1];
+				tess_buf[a].vbuf[(n-1)*3+2]	=0;
+				n++;
+			}
+			ncntr[c]=cntr[perm[c]];
+		}
+		n=0;
+		tess_buf[a].pbuf=malloc(sizeof(unsigned long)*4*(face-&gt;glyph-&gt;outline.n_points+2*face-&gt;glyph-&gt;outline.n_contours)); 
+		k=0;
+		for (c=ncontours-1;c&gt;=0;c--)
+		{
+			n++;				 /* count out and inlines ... */
+			if (area[perm[c]]&gt;0) /* outline? start! */
+			{
+				dprintf(VLOW,&quot;[T]riangulation from outline %d (%d contours, area = %f)&quot;,perm[c],n,area[perm[c]]);
+				np=sei_triangulate_polygon(n, ncntr+c, nvertices+(ncsta[c]), triangles);
+				for (i=0;i&lt;np;i++)
+				{
+					tess_buf[a].pbuf[k*4]=  triangles[i][0]+ncsta[c]-1;
+					tess_buf[a].pbuf[k*4+1]=triangles[i][1]+ncsta[c]-1;
+					tess_buf[a].pbuf[k*4+2]=triangles[i][2]+ncsta[c]-1;
+					tess_buf[a].pbuf[k*4+3]=0;
+					k++;
+				}
+				n=0;
+			}
+		}
+		tess_buf[a].pn=k;
+	}
+	tess_buf[a].xoff=1.0*face-&gt;glyph-&gt;metrics.horiAdvance*norm;
+	return(0);
+}
+
+int _s3d_draw_tessbuf(int oid,unsigned short a,int *voff, float *xoff)
+{
+	float *vbuf;
+	unsigned long *pbuf;
+	int i;
+	if (!(tess_buf[a].vbuf &amp;&amp; tess_buf[a].pbuf))
+		_s3d_add_tessbuf(a);
+	vbuf=malloc(sizeof(float)*3*tess_buf[a].vn);
+	pbuf=malloc(sizeof(unsigned long)*4*tess_buf[a].pn);
+	memcpy(vbuf,tess_buf[a].vbuf,sizeof(float)*3*tess_buf[a].vn);
+	memcpy(pbuf,tess_buf[a].pbuf,sizeof(unsigned long)*4*tess_buf[a].pn);
+	 /*  prepare the buffs ... */
+/* 	dprintf(LOW,&quot;drawing [%c] (%d vertices, %d polys&quot;,a,tess_buf[a].vn,tess_buf[a].pn); */
+	for (i=0;i&lt;tess_buf[a].vn;i++)
+	{
+		vbuf[i*3]+=*xoff;
+/*		dprintf(LOW,&quot;vertex [%c:%d] %f %f %f&quot;,a,i,
+						vbuf[i*3],
+						vbuf[i*3+1],
+						vbuf[i*3+2]);*/
+	}
+	for (i=0;i&lt;tess_buf[a].pn;i++)
+	{
+		pbuf[i*4]+=*voff;
+		pbuf[i*4+1]+=*voff;
+		pbuf[i*4+2]+=*voff;
+/*		dprintf(LOW,&quot;poly [%c:%d] %d %d %d | %d (voff %d)&quot;,a,i,
+						pbuf[i*4],
+						pbuf[i*4+1],
+						pbuf[i*4+2],
+						pbuf[i*4+3],*voff);*/
+	}
+	dprintf(VLOW,&quot;commiting %d vertices, %d polygons&quot;,tess_buf[a].vn,tess_buf[a].pn);
+	s3d_push_vertices(oid,vbuf,tess_buf[a].vn);
+	s3d_push_polygons(oid,pbuf,tess_buf[a].pn);
+	*xoff+=tess_buf[a].xoff;  /*  xoffset */
+	*voff+=tess_buf[a].vn;
+	free(vbuf);
+	free(pbuf);
+	return(0);
+}
+int s3d_select_font(char *path)
+{
+	unsigned char *oldfont=memory_font;
+	int oldsize=memory_font_size;
+	char *c;
+	if (!ft_init)
+		if (s3d_ft_init())
+		{
+			errds(VHIGH,&quot;s3d_select_font()&quot;,&quot;error in initializtation (ft_init())&quot;);
+			return(-1);
+		}
+
+	 /*  yse (system-specific?!) font grabber */
+	if (((c=s3d_findfont(path))!=NULL))
+	{
+		if ((memory_font_size=s3d_open_file(c,(char **)&amp;memory_font))&gt;0)
+		{
+			if (!s3d_ft_load_font())
+			{
+				_s3d_clear_tessbuf();
+				if (oldfont!=NULL)
+					free(oldfont);
+				return(0);
+			}
+		}
+	}
+
+	 /*  failed too. restore and return */
+	memory_font_size=	oldsize;
+	memory_font=		oldfont;
+	return(-1);
+}
+
+/*  draws a simple string. */
+int s3d_draw_string( char *str,float *xlen)
+{
+	int i;
+	float xoff;
+	int voff;
+	int len;
+	if (!ft_init)
+		if (s3d_ft_init())
+		{
+			errds(VHIGH,&quot;s3d_draw_string()&quot;,&quot;error in initializtation (ft_init())&quot;);
+			return(-1);
+		}
+	if (!face_init)
+	{
+		errds(VHIGH,&quot;s3d_draw_string()&quot;,&quot;no font to draw with&quot;);
+		return(-1);
+	}
+	f_oid=s3d_new_object(); 
+	 /*  standard material */
+	s3d_push_material(f_oid,1.0,1.0,1.0,		1.0,1.0,1.0,	1.0,1.0,1.0);
+	xoff=0;
+	voff=0; 
+	len=strlen(str);
+	for (i=0;i&lt;len; i++)
+		_s3d_draw_tessbuf(f_oid,(unsigned char )str[i],&amp;voff,&amp;xoff);
+	 /*  s3d_ft_quit(); */
+	if (xlen!=NULL) *xlen=xoff;
+	return(f_oid);
+}
+int s3d_ft_quit()
+{
+	_s3d_clear_tessbuf();
+	FT_Done_FreeType(library);
+	ft_init=0;
+	return(0);
+}
+
+

Added: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/io.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,239 @@
+/*
+ * io.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &quot;proto.h&quot;
+#include &lt;stdio.h&gt;  	 /*  fopen(),fclose(),fileno() */
+#include &lt;string.h&gt; 	 /*  strncpy(),strncmp(),memcpy() */
+#include &lt;stdlib.h&gt;		 /*  atoi(),malloc(),free() */
+#include &lt;sys/stat.h&gt;	 /*  fstat() */
+#include &lt;unistd.h&gt;		 /*  getpid(), fstat() */
+#include &lt;errno.h&gt;		 /*  errno */
+#include &lt;sys/socket.h&gt;  /*  socket() */
+#include &lt;getopt.h&gt;		 /*  getopt() */
+#include &lt;fcntl.h&gt;		 /*  fcntl() */
+#ifdef SIGS
+#include &lt;signal.h&gt;		 /*  signal.h, SIG_PIPE */
+#endif
+#include &lt;netinet/in.h&gt;  /*  htons(),htonl() */
+#ifndef WIN32
+	#include &lt;netdb.h&gt;		 /*  gethostbyname()  */
+#endif
+
+static char				*url=NULL;
+extern int 				con_type;
+/*  this file is the client-lib-implementation which holds the function to connect and control the server. */
+#ifdef SIGS
+int _s3d_sigio=0;
+void sigpipe_handler(int sig, int code)  /*  ... ? */
+{
+	errs(&quot;sigpipe_handler()&quot;,&quot;there is a broken pipe somewhere&quot;);
+}
+void sigio_handler(int sig, int code)  /*  ... ? */
+{
+	_s3d_sigio=1;
+}
+void sigint_handler(int sig, int code)  /*  ... ? */
+{
+	/*s3d_quit();*/ /* TODO: sometimes no clean quit ?!*/
+	exit(-1);
+}
+
+#endif
+void s3d_usage()
+{
+	printf(&quot;s3d-parameters:\n&quot;);
+	printf(&quot; --s3d-url &lt;url&gt;: skip S3D enviroment and connect to this url\n&quot;);
+	printf(&quot; --help, -?, -h, --s3d-help: this helpful text\n&quot;);
+}
+
+static int parse_args(int *argc, char ***argv)
+{
+	char				 c;
+	int					 lopt_idx;
+	struct option long_options[] =
+	{
+		{&quot;s3d-url&quot;,1,0,0},
+		{&quot;help&quot;,0,0,'h'},
+		{&quot;s3d-help&quot;,0,0,'h'},
+		{0,0,0,0}
+	};
+	while (-1!=(c=getopt_long(*argc,*argv,&quot;?h&quot;,long_options,&amp;lopt_idx)))
+	{
+		switch (c)
+		{
+		case 0:
+			if (0==strcmp(long_options[lopt_idx].name,&quot;s3d-url&quot;))
+			{
+				if (optarg)
+				{
+					url=optarg;
+					dprintf(HIGH,&quot;connecting to %s&quot;,url);
+				}
+			}
+			break;
+		case '?':
+		case 'h':
+			printf(&quot;usage: %s [options]&quot;,(*argv)[0]);
+			s3d_usage();
+			return(-1);
+		}
+	}
+	if (*argc&gt;0)
+	{
+		*argc-=(optind-1); 				 /*  hide s3d-options */
+		(*argv)[optind-1]=(*argv)[0]; 	 /*  restore program path */
+		*argv+=(optind-1); 				 /*  set the string pointer at the right position */
+	}
+	return(0);
+}
+/*  external functions go here ... */
+int s3d_init(int *argc, char ***argv, char *name)
+{
+	char 				*s;
+	char 				 urlc[256];		 /*  this should be enough for an url */
+	char 				 buf[258]; 		 /*  server buffer */
+/*	int 				 i;*/
+	 /*  null the callback table */
+/*	for (i=0;i&lt;MAX_CB;i++)
+	{
+		s3d_cb_list[i]=NULL;
+	}*/
+	/* ignore some things ... */
+	/*
+	s3d_ignore_callback(S3D_EVENT_KEY);
+	s3d_ignore_callback(S3D_EVENT_OBJ_CLICK);
+	s3d_ignore_callback(S3D_EVENT_OBJ_INFO);
+	s3d_ignore_callback(S3D_EVENT_NEW_OBJECT);
+*/
+	if (NULL!=(s=getenv(&quot;S3D&quot;)))
+	{
+		dprintf(VLOW,&quot;at least we have the enviroment variable ... %s&quot;,s);
+		url=s;
+	}
+	parse_args(argc,argv);
+	if (url==NULL) /* no url specified or obtained through arguments */
+	{
+		/* trying standard ways to connect */
+		strncpy(urlc,&quot;s3<A HREF="d:///tmp/.s3d:shm/">d:///tmp/.s3d:shm/</A>&quot;,256);
+		if (s3d_net_init(urlc)==CON_NULL)
+		{
+			strncpy(urlc,&quot;s3<A HREF="d://127.0.0.1:6066/">d://127.0.0.1:6066/</A>&quot;,256);
+			if (s3d_net_init(urlc)==CON_NULL)
+				return(-1);
+		}
+	} else {
+		strncpy(urlc,url,256);	 /*  this should keep buffer overflows away, maybe */
+		urlc[256]=0;			 /*  just to make sure */
+		if (!strncmp(urlc, &quot;s3<A HREF="d://">d://</A> &quot;,6))
+		{
+			if (s3d_net_init(urlc)==CON_NULL) return(-1);
+		} else {
+			errs(&quot;s3d_init()&quot;,&quot;invalid url&quot;);
+			  return(-1);
+		}
+	}
+	strncpy(buf,name,256);  /*  copy the name ... */
+	net_send(S3D_P_C_INIT,buf,strlen(buf));
+
+	 /*  TODO: we should wait for the INIT-event here before proceeding. */
+	_queue_init();
+#ifdef SIGS
+    if (signal(SIGINT, (sig_t)sigint_handler) == SIG_ERR)
+		errdn(LOW,&quot;s3d_init():signal()&quot;,errno);
+    if (signal(SIGTERM, (sig_t)sigint_handler) == SIG_ERR)
+		errdn(LOW,&quot;s3d_init():signal()&quot;,errno);
+
+#endif
+	return(0);
+}
+/*  shuts down the socket, clearing the stack */
+int s3d_quit()
+{
+	struct s3d_evt *ret;
+	net_send(S3D_P_C_QUIT,NULL,0);
+	switch (con_type)
+	{
+#ifdef TCP
+		case CON_TCP:_tcp_quit();break;
+#endif
+#ifdef SHM
+		case CON_SHM:_shm_quit();break;
+#endif
+	}
+	con_type=CON_NULL;
+	_queue_quit();
+	while (NULL!=(ret=s3d_pop_event())) s3d_delete_event(ret);  /*  clear the stack ... */
+	ret=malloc(sizeof(struct s3d_evt));
+	ret-&gt;event=S3D_EVENT_QUIT;
+	ret-&gt;length=0;
+	s3d_push_event(ret);
+	return(0);
+}
+/*  apps should use that as main loop for their programs. */
+int s3d_mainloop(void (*f)())
+{
+	while (con_type!=CON_NULL)
+	{
+		if (f!=NULL)
+			f();
+		s3d_net_check();
+	}
+	return(0);
+}
+/*  opens a file returning it's filesize  */
+/*  and setting *pointer to the buffer. to be freed */
+int s3d_open_file(char *fname, char **pointer)
+{
+	FILE *fp;
+	char *buf=NULL;
+	int filesize;
+	struct stat bf;
+	*pointer=NULL;
+/*	if ((fp = fopen(fname, &quot;rt&quot;)) == NULL)
+	{ errn(&quot;s3d_open_file():fopen()&quot;,errno); return(0);}
+	if (fseek(fp, 0, SEEK_END) != 0)
+	{ errn(&quot;s3d_open_file():fseek()&quot;,errno); return(0);}
+	if ((filesize = (int)ftell(fp)) == (long)-1)
+	{ errn(&quot;s3d_open_file():ftell()&quot;,errno); return(0);}
+	if (fseek(fp, 0, SEEK_SET) != 0)
+	{ errn(&quot;s3d_open_file():fseek()&quot;,errno); return(0);}*/
+
+	if ((fp = fopen(fname, &quot;rt&quot;)) == NULL)
+	{ errdn(VLOW,&quot;s3d_open_file():fopen()&quot;,errno); return(-1);}
+	if (fstat(fileno(fp),&amp;bf))
+	{ errdn(VLOW,&quot;s3d_open_file():fstat()&quot;,errno); return(-1);}
+	filesize=bf.st_size;
+	dprintf(VLOW, &quot;opening %s, filesize is %d&quot;,fname, filesize);
+	if ((buf=malloc(filesize))==NULL)
+	{
+		errn(&quot;s3d_open_3ds_file():malloc()&quot;,errno);
+		exit(-1);
+	}
+	fread(buf, filesize, 1, fp);
+	fclose(fp);
+	*pointer=buf;
+	return(filesize);
+}

Added: trunk/libs3d/lgpl.txt
===================================================================
--- trunk/libs3d/lgpl.txt	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/lgpl.txt	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,504 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the &quot;Lesser&quot; General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+&quot;work based on the library&quot; and a &quot;work that uses the library&quot;.  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called &quot;this License&quot;).
+Each licensee is addressed as &quot;you&quot;.
+
+  A &quot;library&quot; means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The &quot;Library&quot;, below, refers to any such software library or work
+which has been distributed under these terms.  A &quot;work based on the
+Library&quot; means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term &quot;modification&quot;.)
+
+  &quot;Source code&quot; for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a &quot;work that uses the Library&quot;.  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a &quot;work that uses the Library&quot; with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a &quot;work that uses the
+library&quot;.  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a &quot;work that uses the Library&quot; uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a &quot;work that uses the Library&quot; with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable &quot;work that
+    uses the Library&quot;, as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the &quot;work that uses the
+Library&quot; must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+&quot;any later version&quot;, you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY &quot;AS IS&quot; WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+&quot;copyright&quot; line and a pointer to where the full notice is found.
+
+    &lt;one line to give the library's name and a brief idea of what it does.&gt;
+    Copyright (C) &lt;year&gt;  &lt;name of author&gt;
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a &quot;copyright disclaimer&quot; for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  &lt;signature of Ty Coon&gt;, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+

Added: trunk/libs3d/network.c
===================================================================
--- trunk/libs3d/network.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/network.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,165 @@
+/*
+ * network.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &lt;string.h&gt; 	 /*  memcpy() */
+#include &lt;stdlib.h&gt;		 /*  malloc(), free() */
+#include &lt;unistd.h&gt;		 /*  read(), write() */
+#include &lt;errno.h&gt;		 /*  errno */
+#include &lt;netinet/in.h&gt;  /*  htons(),htonl() */
+#ifdef SIGS
+extern int _s3d_sigio;
+#endif
+int con_type=CON_NULL;
+#ifdef TCP
+static int _s3d_net_receive();
+#endif
+
+int net_send(unsigned char opcode, char *buf, unsigned short length)
+{
+	char *ptr;
+/* 	char *buff; */
+	char buff[65536];  /*  unsigned short really shouldn't be bigger ;) */
+	*(buff)=opcode; 
+	ptr=buff+1;
+	*((unsigned short *) ptr)=htons(length);
+	memcpy(buff+3,buf,length);
+	switch (con_type)
+	{
+#ifdef SHM
+		case CON_SHM:shm_writen(buff,length+3);break;
+#endif
+#ifdef TCP		
+		case CON_TCP:tcp_writen(buff,length+3);break;
+#endif
+	}
+	return(0);
+}
+/* handler for socket based connection types */
+#ifdef TCP
+int _s3d_net_receive()
+{
+	return(_s3d_tcp_net_receive());
+	return(0);
+}
+#endif
+int s3d_net_check()
+{
+	switch (con_type)
+	{
+#ifdef TCP
+		case CON_TCP:
+#ifdef SIGS
+		if (_s3d_sigio)
+		{
+#endif
+			while (_s3d_net_receive());
+#ifdef SIGS
+			_s3d_sigio=0;
+		}	
+#endif
+			break;
+#endif
+#ifdef SHM
+		case CON_SHM:
+			while(_shm_net_receive());
+			break;
+#endif
+	}
+	return(0);
+}
+int s3d_net_init(char *urlc)
+{
+	char				*s,*sv,*port=NULL;
+	char				*first_slash=NULL;
+#ifdef TCP
+	int					 pn=0;
+#endif
+	int					 tcp,shm;
+	tcp=shm=1; /* everything is possible, yet */
+	
+	 /*  doing a very bad server/port extraction, but I think it'll work ... */
+	s=sv=urlc+6;  /*  getting to the &quot;real&quot; thing */
+	 /* while (((*s!='/') &amp;&amp; (*s!=0)) &amp;&amp; (s&lt;(urlc-6))) */
+	while (*s!=0)
+	{
+		if (*s=='/')
+		{
+			if (first_slash==NULL)
+				first_slash=s;
+			if (port!=NULL)
+				break;
+		}
+		if (*s==':')  /*  there is a port in here */
+		{
+			port=s+1;
+			*s=0;	 /*  NULL the port  */
+		}
+		s++;
+	}
+
+	*s=0;
+	if (port==NULL)
+	{
+		shm=0;
+		if (first_slash!=NULL)
+			*first_slash=0;
+	} else {
+		if (first_slash&lt;port)
+			tcp=0;
+		else 
+			if (first_slash!=NULL)
+				*first_slash=0;
+		if (!strncmp(port, &quot;shm&quot;,3))
+		{
+			tcp=0; /* null the others */
+		} else {
+			shm=0;
+		}
+	}
+#ifdef SHM
+	if (shm)
+	{
+		if (!strncmp(port, &quot;shm&quot;,3))
+			if (!_shm_init(sv)) return(con_type=CON_SHM);
+	}
+#endif
+#ifdef TCP
+	if (tcp)
+	{
+		pn=6066;
+		if (port!=NULL)
+		{
+			if (!(pn=atoi(port)))  /*  I hope atoi is safe enough. */
+			{
+				errn(&quot;s3d_init():atoi()&quot;,errno);
+				pn=6066;
+			} 
+		}
+		if (!_tcp_init(sv,pn)) return(con_type=CON_TCP);
+	}
+#endif
+	return(CON_NULL);
+}

Added: trunk/libs3d/object_queue.c
===================================================================
--- trunk/libs3d/object_queue.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/object_queue.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,125 @@
+/*
+ * object_queue.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &quot;proto.h&quot;	 
+#include &lt;stdlib.h&gt;	 /*  malloc(),free(), realloc() */
+#include &lt;time.h&gt;		 /* nanosleep() */
+
+/*  objects are requested before beeing used for having fast  */
+/*  access when needed. this also makes things more asynchronous, */
+/*  therefore faster (I hope). */
+
+#define Q_UNUSED	-1				 /*  unused slot magic number */
+#define MAX_REQ		100				 /*  don't request more than that. */
+static unsigned int *queue;			 /*  the object id's */
+static int queue_size=0;			 /*  the size of the object queue */
+static int requested;				 /*  counter of how many addtional */
+									 /*  objects have been requested */
+/*  initializes the object queue */
+int _queue_init()
+{
+	int i;
+	queue_size=1;
+	requested=0;
+	queue=malloc(sizeof(unsigned int)*queue_size);
+	for (i=0;i&lt;queue_size;i++)
+	{
+		queue[i]=Q_UNUSED;
+	}
+	_queue_fill();
+	return(0);
+}
+/*  checks the queue empty slots and requests new ones if needed */
+int _queue_fill()
+{
+	int i;
+	for (i=0;i&lt;queue_size;i++)
+		if (queue[i]==Q_UNUSED)
+			net_send(S3D_P_C_NEW_OBJ,NULL,0);
+	return(0);
+}
+/*  we have a new object from the server, trying to find a place for it */
+int _queue_new_object(unsigned int oid)
+{
+	int i;
+/* 	dprintf(LOW,&quot;having a new object (%d) in the queue!!&quot;,oid); */
+	for (i=0;i&lt;queue_size;i++)
+		if (queue[i]==Q_UNUSED)
+		{
+/* 			dprintf(LOW,&quot;placing it at position %d&quot;,i); */
+			queue[i]=oid;
+			return(0);
+		}
+	if (queue_size==0) return(-1);  /*  already quit. */
+	 /*  if we reach here, all slots all taken.  */
+/* 	dprintf(LOW,&quot;no place for object, resizing stack.&quot;,i); */
+	queue=realloc(queue,sizeof(unsigned int)*(queue_size+1));
+	queue_size+=1;
+	queue[queue_size-1]=oid;
+	return(0);
+}
+static struct timespec t={0,10*1000}; /* 10 micro seconds */
+/*  an object is requested!! give one out: */
+unsigned int _queue_want_object()
+{
+	unsigned int ret;
+	int i;
+	do {
+	for (i=0;i&lt;queue_size;i++)
+		if (queue[i]!=Q_UNUSED)
+		{
+			ret=queue[i];
+			queue[i]=Q_UNUSED;
+			net_send(S3D_P_C_NEW_OBJ,NULL,0);  /*  we already can request a new one. */
+			return(ret);
+		}
+	 /*  if we reach this point, our queue is empty. */
+	 /*  as other request should have sent S3D_P_C_NEW_OBJ-requests,  */
+	 /*  we request one more object than needed to satisfy more load in future. */
+	if (queue_size==0) return(-1);  /*  already quit. */
+	if (requested&lt;MAX_REQ)
+	{
+		net_send(S3D_P_C_NEW_OBJ,NULL,0);
+		requested++;
+	}
+	s3d_net_check();
+	nanosleep(&amp;t,NULL); 
+	} while(i++&lt;TIMEOUT);
+
+	errds(LOW,&quot;_queue_want_object()&quot;,&quot;timeout is reached. server is extremly slow/laggy or dead&quot;);	
+	return(-1);
+}
+/*  cleans up */
+int _queue_quit()
+{
+	if (queue!=NULL)
+	{
+		free(queue);
+		queue=NULL;
+	}
+	queue_size=0;
+	return(0);
+}

Added: trunk/libs3d/proto_in.c
===================================================================
--- trunk/libs3d/proto_in.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/proto_in.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,171 @@
+/*
+ * proto_in.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &lt;proto.h&gt;
+#include &lt;netinet/in.h&gt;  /*  htons(),htonl() */
+#include &lt;errno.h&gt;		 /*  errno */
+#include &lt;stdlib.h&gt;		 /*  malloc(), free() */
+
+/*  this proccesses the commands and pushes s3d-events, or does other things ;) */
+int net_prot_in(uint8_t opcode, uint16_t length, char *buf)
+{
+	uint32_t oid=-1;
+	struct s3d_evt *s3devt=NULL;
+	struct mcp_object *mo;
+	struct s3d_obj_info *oi;
+	switch (opcode)
+	{
+		case S3D_P_S_INIT:
+			dprintf(MED,&quot;S3D_P_S_INIT: init!!&quot;);
+			break;
+		case S3D_P_S_QUIT:
+			dprintf(MED,&quot;S3D_P_S_QUIT: server wants us to go. well ...&quot;);
+			s3d_quit();
+			break;	
+		case S3D_P_S_CLICK:
+			if (length==4) 
+			{
+				oid=ntohl(*((uint32_t *)buf));
+				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
+				{
+					*((uint32_t *)buf)=oid;  /*  reuse buffer ... */
+					s3devt-&gt;event=S3D_EVENT_OBJ_CLICK;
+					s3devt-&gt;length=4;
+					s3devt-&gt;buf=buf;
+				}
+				dprintf(MED,&quot;S3D_P_S_CLICK: %d got clicked ....&quot;,oid);
+			}
+			break;
+		case S3D_P_S_NEWOBJ:
+			if (length==4) 
+			{
+				oid=ntohl(*((uint32_t *)buf));
+				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
+				{
+					*((uint32_t *)buf)=oid;  /*  reuse buffer ... */
+					s3devt-&gt;event=S3D_EVENT_NEW_OBJECT;
+					s3devt-&gt;length=4;
+					s3devt-&gt;buf=buf;
+				}
+				dprintf(VLOW,&quot;S3D_P_S_NEWOBJ: new object %d&quot;,oid);
+			}
+			break;
+		case S3D_P_S_KEY:
+			if (length==2)
+			{
+				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
+				{
+					s3devt-&gt;event=S3D_EVENT_KEY;
+					s3devt-&gt;length=2;
+					*((uint16_t *)buf)=
+							ntohs(*((uint16_t *)buf));
+					s3devt-&gt;buf=buf;
+				}
+				dprintf(VLOW,&quot;S3D_P_S_KEY: key %d hit!!&quot;,*((uint16_t *)s3devt-&gt;buf));
+			}
+			break;
+		case S3D_P_S_MBUTTON:
+			if (length==2)
+			{
+				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
+				{
+					s3devt-&gt;event=S3D_EVENT_MBUTTON;
+					s3devt-&gt;length=2;
+					s3devt-&gt;buf=buf;
+				}
+				dprintf(VLOW,&quot;S3D_P_S_MBUTTON: mbutton %d, state %d !!&quot;,*((uint8_t *)s3devt-&gt;buf), *(1+(uint8_t *)s3devt-&gt;buf));
+			}
+			break;
+		case S3D_P_MCP_OBJECT:
+			if (length==sizeof(struct mcp_object))
+			{
+/* 				oid=htonl(*((unsigned long *)buf)); */
+				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
+				{
+/* 					*((unsigned long *)buf)=oid;  / *  reuse buffer ... * / */
+					s3devt-&gt;event=S3D_MCP_OBJECT;
+					s3devt-&gt;length=length;
+					mo=(struct mcp_object *)buf;
+					*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
+
+					buf[length-1]='\0';  /*  put a null byte at the end  */
+										 /*  for the not so careful users */
+					s3devt-&gt;buf=buf;
+					dprintf(VLOW,&quot;S3D_P_MCP_OBEJCT: something is happening to object %d, name %s&quot;, 	mo-&gt;object, mo-&gt;name);
+
+				}
+			} else dprintf(MED,&quot;wrong length for S3D_P_MCP_OBJECT length %d != %d&quot;,length,sizeof(struct mcp_object));
+			break;
+		case S3D_P_S_OINFO:
+			if (length==sizeof(struct s3d_obj_info))
+			{
+/* 				oid=htonl(*((unsigned long *)buf)); */
+				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
+				{
+/* 					*((unsigned long *)buf)=oid;  / *  reuse buffer ... * / */
+					s3devt-&gt;event=S3D_EVENT_OBJ_INFO;
+					s3devt-&gt;length=length;
+					oi=(struct s3d_obj_info *)buf;
+					oi-&gt;object	=ntohl(oi-&gt;object);
+					oi-&gt;flags	=ntohl(oi-&gt;flags);
+
+					buf[length-1]='\0';  /*  put a null byte at the end  */
+										 /*  for the not so careful users */
+					s3devt-&gt;buf=buf;
+					dprintf(VLOW,&quot;S3D_P_S_OINFO: something is happening to object %d, name %s&quot;, 
+								oi-&gt;object,
+								oi-&gt;name
+								);
+
+				}
+			} else dprintf(MED,&quot;wrong length for S3D_P_S_OINFO length %d != %d&quot;,length,sizeof(struct s3d_obj_info));
+			break;
+
+		case S3D_P_MCP_DEL_OBJECT:
+			if (length==4)
+			{
+				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
+				{
+					s3devt-&gt;event=S3D_MCP_DEL_OBJECT;
+					s3devt-&gt;length=length;
+					*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
+					dprintf(MED,&quot;S3D_P_MCP_DEL_OBEJCT: deleting object %d&quot;,*((uint32_t *)buf));
+					s3devt-&gt;buf=buf;
+				}
+			}
+			break;
+		default:
+			dprintf(MED,&quot;don't know command %d&quot;,opcode);
+			if (buf!=NULL) free(buf);
+	}
+	if (s3devt!=NULL)
+	{
+			
+		s3d_push_event(s3devt);
+	}
+	return(0);
+}
+

Added: trunk/libs3d/proto_out.c
===================================================================
--- trunk/libs3d/proto_out.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/proto_out.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,795 @@
+/*
+ * proto_out.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &lt;proto.h&gt;
+#include &lt;string.h&gt; 	 /*  memset(),strncpy(),strncmp(),memcpy() */
+#include &lt;errno.h&gt;		 /*  errno */
+#include &lt;netinet/in.h&gt;  /*  htons(),htonl() */
+#include &lt;unistd.h&gt;		 /*  select() */
+#include &lt;stdlib.h&gt;		 /*  getenv(),atoi(), malloc() */
+#ifdef WIN32
+	#define uint32_t unsigned long  /*  sohn */
+#else
+	#include &lt;netdb.h&gt;		 /*  gethostbyname()  */
+#endif
+
+#define MF_LEN	65530	 /*  maximum fragmentation length */
+/*  creates a new object */
+int s3d_new_object()
+{
+	return(_queue_want_object());  /*  TODO: well ... */
+}
+/*  clones an object */
+int s3d_clone(int oid)
+{
+	uint32_t res;
+	res=s3d_new_object();
+	s3d_clone_target(res,oid);
+	return(res);
+}
+
+/*  changes the target of a clone-object */
+int s3d_clone_target(int oid, int toid)
+{
+	uint32_t buf[2];
+	buf[0]=htonl(oid);
+	buf[1]=htonl(toid);
+	net_send(S3D_P_C_CLONE,(char *)&amp;buf,8);
+/* 	dprintf(MED,&quot;... changed clone-target of object %d to %d&quot;, oid, toid); */
+	return oid;
+}
+/*  deletes an object */
+int s3d_del_object(int oid)
+{
+	uint32_t res=htonl(oid);
+	net_send(S3D_P_C_DEL_OBJ,(char *)&amp;res,4);
+	return oid;
+}
+/*  creates a link from object oid_from to object oid_to in order to copy */
+/*  translations/rotations */
+int s3d_link(int oid_from, int oid_to)
+{
+	uint32_t buf[2];
+	buf[0]=htonl(oid_from);
+	buf[1]=htonl(oid_to);
+	net_send(S3D_P_C_LINK,(char *)buf,8);
+	return(0);
+}
+/*  remove the link to another object */
+int s3d_unlink(int oid)
+{
+	uint32_t buf;
+	buf=htonl(oid);
+	net_send(S3D_P_C_LINK,(char *)&amp;buf,4);
+	return(0);
+}
+/*  pushing functions */
+
+/*  has float always the same size? i'm not quite sure ... */
+int s3d_push_vertex(int object, float x, float y, float z)
+{
+	char				buf[4+3*4],*ptr;
+	int					len=4+3*4;
+
+	ptr=buf;
+	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=x;					ptr+=sizeof(float);
+	*((float *)ptr)=y;					ptr+=sizeof(float);
+	*((float *)ptr)=z;					ptr+=sizeof(float);
+	net_send(S3D_P_C_PUSH_VERTEX, buf, len);
+	return(0);
+}
+/*  like vertex add, but you can add a lot of vertices with this. */
+/*  it's to be used for file readers or fast coders :) */
+int s3d_push_vertices(int object, float *vbuf, unsigned short n)
+{
+	char				buf[MF_LEN+4],*ptr;
+	int					f,i,len=n*4*3;
+	int					flen,stepl;
+	if (n&lt;1)
+		return(-1);
+	stepl=((int)((MF_LEN-4)/(4*3)))*(4*3);
+	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
+/* 	buf=malloc(f&gt;1?MF_LEN:len+4); */
+	for (i=0;i&lt;f;i++)
+	{
+		ptr=buf;
+		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+		if (len-i*stepl&gt;stepl)
+			flen=stepl;
+		else
+			flen=(len-i*stepl);
+		memcpy(ptr,(char *)vbuf+i*stepl,flen);
+		net_send(S3D_P_C_PUSH_VERTEX,buf,flen+4);
+	}
+/* 	free(buf); */
+	return(0);
+}
+
+/*  pushes a new material onto the stack */
+/*  a vectored version of this would be wise ... */
+int s3d_push_material( int object, 
+						float amb_r, float amb_g, float amb_b,
+						float spec_r, float spec_g, float spec_b,
+						float diff_r, float diff_g, float diff_b
+						)
+{
+	char				buf[4+4*12];
+	char				*ptr;
+	int					len=4+4*12;
+/* 	dprintf(LOW, &quot;adding a new material...&quot;); */
+	ptr=buf;
+	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=amb_r;				ptr+=sizeof(float);
+	*((float *)ptr)=amb_g;				ptr+=sizeof(float);
+	*((float *)ptr)=amb_b;				ptr+=sizeof(float);
+	*((float *)ptr)=1.0;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_r;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_g;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_b;				ptr+=sizeof(float);
+	*((float *)ptr)=1.0;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_r;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_g;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_b;				ptr+=sizeof(float);
+	*((float *)ptr)=1.0;				ptr+=sizeof(float);
+
+	net_send(S3D_P_C_PUSH_MAT,buf,len);
+	return(0);  /*  nothing yet */
+}
+/*  same as s3d_push_material, but with values for alpha */
+int s3d_push_material_a( int object, 
+						float amb_r, float amb_g, float amb_b, float amb_a,
+						float spec_r, float spec_g, float spec_b, float spec_a,
+						float diff_r, float diff_g, float diff_b, float diff_a
+						)
+{
+	char				buf[4+4*12];
+	char				*ptr;
+	int					len=4+4*12;
+/* 	dprintf(LOW, &quot;adding a new material...&quot;); */
+	ptr=buf;
+	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=amb_r;				ptr+=sizeof(float);
+	*((float *)ptr)=amb_g;				ptr+=sizeof(float);
+	*((float *)ptr)=amb_b;				ptr+=sizeof(float);
+	*((float *)ptr)=amb_a;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_r;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_g;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_b;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_a;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_r;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_g;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_b;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_a;				ptr+=sizeof(float);
+
+	net_send(S3D_P_C_PUSH_MAT,buf,len);
+	return(0);  /*  nothing yet */
+}
+/*  push a material array (with alpha information!) */
+int s3d_push_materials_a(int object, float *mbuf, unsigned short n)
+{
+	char				buf[MF_LEN+4],*ptr;
+	int					f,i,len=n*4*12;
+	int					flen,stepl;
+	if (n&lt;1)
+		return(-1);
+	stepl=((int)((MF_LEN-4)/(4*12)))*(4*12);
+	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
+/* 	buf=malloc(f&gt;1?MF_LEN:len+4); */
+	for (i=0;i&lt;f;i++)
+	{
+		ptr=buf;
+		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+		if (len-i*stepl&gt;stepl)
+			flen=stepl;
+		else
+			flen=(len-i*stepl);
+		memcpy(ptr,(char *)mbuf+i*stepl,flen);
+		net_send(S3D_P_C_PUSH_MAT,buf,flen+4);
+	}
+/* 	free(buf); */
+	return(0);
+}
+int s3d_push_polygon(int object, unsigned long v1, unsigned long v2, unsigned long v3, unsigned long material)
+{
+	char				buf[4+4*4],*ptr;
+	int					len=4+4*4;
+	ptr=buf;
+	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint32_t *)ptr)=htonl(v1);				ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(v2);				ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(v3);				ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(material);			ptr+=sizeof(uint32_t);
+
+	net_send(S3D_P_C_PUSH_POLY,buf,len);
+	return(0);
+}
+int s3d_push_line(int object, unsigned long v1, unsigned long v2, unsigned long material)
+{
+	char				buf[4+3*4],*ptr;
+	int					len=4+3*4;
+	ptr=buf;
+	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint32_t *)ptr)=htonl(v1);				ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(v2);				ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(material);			ptr+=sizeof(uint32_t);
+
+	net_send(S3D_P_C_PUSH_LINE,buf,len);
+	return(0);
+}
+
+/*  this is the polygon array version */
+/*  assumes to have a list of polys which consists of v1,v2,v3,material */
+int s3d_push_polygons(int object, unsigned long *pbuf, unsigned short n)
+{
+	unsigned long		buf[(MF_LEN+4)/4];
+	unsigned long		*s,*d;
+	int					f,i,j,len=n*4*4;
+	int					flen,stepl;
+	if (n&lt;1)
+		return(-1);
+	stepl=((int)((MF_LEN-4)/(4*4)))*(4*4);
+	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
+
+	buf[0]=htonl(object);
+	d=buf+1;
+	for (i=0;i&lt;f;i++)
+	{
+		if (len-i*stepl&gt;stepl)			flen=stepl;
+		else							flen=(len-i*stepl);
+
+		s=pbuf+i*stepl/4;
+		for (j=0;j&lt;flen/4;j++)
+			d[j]=htonl(s[j]);
+		net_send(S3D_P_C_PUSH_POLY,(char *)buf,flen+4);
+	}
+	return(0);
+}
+int s3d_push_lines(int object, unsigned long *lbuf, unsigned short n)
+{
+	unsigned long		buf[(MF_LEN+4)/4];
+	unsigned long		*s,*d;
+	int					f,i,j,len=n*4*3;
+	int					flen,stepl;
+	if (n&lt;1)
+		return(-1);
+	stepl=((int)((MF_LEN-4)/(4*3)))*(4*3);
+	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
+
+	buf[0]=htonl(object);
+	d=buf+1;
+
+	for (i=0;i&lt;f;i++)
+	{
+		if (len-i*stepl&gt;stepl)			flen=stepl;
+		else							flen=(len-i*stepl);
+
+		s=lbuf+i*stepl/4;
+		for (j=0;j&lt;flen/4;j++)
+			d[j]=htonl(s[j]);
+
+		net_send(S3D_P_C_PUSH_LINE,(char *)buf,flen+4);
+	}
+	return(0);
+}
+int s3d_push_texture(int object, unsigned short w, unsigned short h)
+{
+	char				buf[4+2*2],*ptr;
+	int					len=4+2*2;
+	ptr=buf;
+	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint16_t *)ptr)=htons(w);				ptr+=sizeof(uint16_t);
+	*((uint16_t *)ptr)=htons(h);				
+
+	net_send(S3D_P_C_PUSH_TEX,buf,len);
+	return(0);
+}
+int s3d_push_textures(int object, unsigned short *tbuf, unsigned short n)
+{
+	unsigned short		buf[(MF_LEN+4)/2];
+	unsigned short		*s,*d;
+
+	int					f,i,j,len=n*2*2;
+	int					flen,stepl;
+	if (n&lt;1)
+		return(-1);
+	stepl=((int)((MF_LEN-4)/(2*2)))*(2*2);
+	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
+
+	*((unsigned long *)buf)=htonl(object);
+	d=buf+2;
+
+	for (i=0;i&lt;f;i++)
+	{
+		if (len-i*stepl&gt;stepl)			flen=stepl;
+		else							flen=(len-i*stepl);
+
+		s=tbuf+i*stepl/2;
+		for (j=0;j&lt;flen/2;j++)
+			d[j]=htons(s[j]);
+		net_send(S3D_P_C_PUSH_POLY,(char *)buf,flen+4);
+	}
+	return(0);
+}
+/*  popping functions  */
+
+/*  delete n vertices */
+int s3d_pop_vertex(int object, unsigned long n)
+{
+	uint32_t		buf[2];
+	buf[0]=htonl(object);
+	buf[1]=htonl(n);
+	net_send(S3D_P_C_DEL_VERTEX,(char *)buf,4*2);
+	return(0);
+	
+}
+/*  delete n materials */
+int s3d_pop_material(int object, unsigned long n)
+{
+	uint32_t		buf[2];
+	buf[0]=htonl(object);
+	buf[1]=htonl(n);
+	net_send(S3D_P_C_DEL_MAT,(char *)buf,4*2);
+	return(0);
+	
+}
+/*  delete n polygons */
+int s3d_pop_polygon(int object, unsigned long n)
+{
+	uint32_t		buf[2];
+	buf[0]=htonl(object);
+	buf[1]=htonl(n);
+	net_send(S3D_P_C_DEL_POLY,(char *)buf,4*2);
+	return(0);
+	
+}
+/*  delete n lines */
+int s3d_pop_line(int object, unsigned long n)
+{
+	uint32_t		buf[2];
+	buf[0]=htonl(object);
+	buf[1]=htonl(n);
+	net_send(S3D_P_C_DEL_LINE,(char *)buf,4*2);
+	return(0);
+	
+}
+/*  delete n polygons */
+int s3d_pop_texture(int object, unsigned long n)
+{
+	uint32_t		buf[2];
+	buf[0]=htonl(object);
+	buf[1]=htonl(n);
+	net_send(S3D_P_C_DEL_TEX,(char *)buf,4*2);
+	return(0);
+	
+}
+/*  pepping/loading functions */
+
+/*  overwrites the last material with this one */
+int s3d_pep_material( int object, 
+						float amb_r, float amb_g, float amb_b,
+						float spec_r, float spec_g, float spec_b,
+						float diff_r, float diff_g, float diff_b
+						)
+{
+	char				buf[4+4*12];
+	char				*ptr;
+	int					len=4+4*12;
+/* 	dprintf(LOW, &quot;adding a new material...&quot;); */
+	ptr=buf;
+	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=amb_r;				ptr+=sizeof(float);
+	*((float *)ptr)=amb_g;				ptr+=sizeof(float);
+	*((float *)ptr)=amb_b;				ptr+=sizeof(float);
+	*((float *)ptr)=1.0;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_r;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_g;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_b;				ptr+=sizeof(float);
+	*((float *)ptr)=1.0;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_r;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_g;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_b;				ptr+=sizeof(float);
+	*((float *)ptr)=1.0;				ptr+=sizeof(float);
+
+	net_send(S3D_P_C_PEP_MAT,buf,len);
+	return(0);  /*  nothing yet */
+}
+/*  same as above, with alpha */
+int s3d_pep_material_a( int object, 
+						float amb_r, float amb_g, float amb_b, float amb_a,
+						float spec_r, float spec_g, float spec_b, float spec_a,
+						float diff_r, float diff_g, float diff_b, float diff_a
+						)
+{
+	char				buf[4+4*12];
+	char				*ptr;
+	int					len=4+4*12;
+/* 	dprintf(LOW, &quot;adding a new material...&quot;); */
+	ptr=buf;
+	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=amb_r;				ptr+=sizeof(float);
+	*((float *)ptr)=amb_g;				ptr+=sizeof(float);
+	*((float *)ptr)=amb_b;				ptr+=sizeof(float);
+	*((float *)ptr)=amb_a;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_r;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_g;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_b;				ptr+=sizeof(float);
+	*((float *)ptr)=spec_a;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_r;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_g;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_b;				ptr+=sizeof(float);
+	*((float *)ptr)=diff_a;				ptr+=sizeof(float);
+
+	net_send(S3D_P_C_PEP_MAT,buf,len);
+	return(0);  /*  nothing yet */
+}
+int s3d_pep_materials_a(int object, float *mbuf, unsigned short n)
+{
+	char				buf[MF_LEN+4];
+	if ((n*12*sizeof(float)+4)&gt;MF_LEN)
+	{
+		errds(MED,&quot;s3d_pep_materials_a()&quot;,&quot;too much data&quot;);
+		return(-1);  /*  impossible */
+	}
+	*((uint32_t *)buf)=htonl(object);			 /*  object id */
+	memcpy(buf+4,mbuf,12*n*sizeof(float));
+	net_send(S3D_P_C_PEP_MAT,buf,n*12*sizeof(float)+4);
+	return(0);
+}
+
+/*  adds normal information to the last n polygons. */
+int s3d_pep_polygon_normals(int object, float *nbuf,unsigned short n)
+{
+	unsigned char buf[MF_LEN+4];
+	if ((n*9*sizeof(float)+4)&gt;MF_LEN) 
+	{
+		errds(MED,&quot;s3d_pep_polygon_normals()&quot;,&quot;too much data&quot;);
+		return(-1);  /*  impossible */
+	}
+	*((uint32_t *)buf)=htonl(object);
+	memcpy(buf+4,nbuf,9*n*sizeof(float));
+	net_send(S3D_P_C_PEP_POLY_NORMAL,(char *)buf,n*9*sizeof(float)+4);
+	return(0);
+	
+}
+/*  adds normal information to the last n line. */
+int s3d_pep_line_normals(int object, float *nbuf,unsigned short n)
+{
+	unsigned char buf[MF_LEN+4];
+	if ((n*9*sizeof(float)+4)&gt;MF_LEN) 
+	{
+		errds(MED,&quot;s3d_pep_line_normals()&quot;,&quot;too much data&quot;);
+		return(-1);  /*  impossible */
+	}
+	*((uint32_t *)buf)=htonl(object);
+	memcpy(buf+4,nbuf,6*n*sizeof(float));
+	net_send(S3D_P_C_PEP_LINE_NORMAL,(char *)buf,n*6*sizeof(float)+4);
+	return(0);
+	
+}
+/*  replaces the last vertex. */
+int s3d_pep_vertex(int object, float x, float y, float z)
+{
+	char				buf[4+3*4],*ptr;
+	int					len=4+3*4;
+
+	ptr=buf;
+	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=x;					ptr+=sizeof(float);
+	*((float *)ptr)=y;					ptr+=sizeof(float);
+	*((float *)ptr)=z;					ptr+=sizeof(float);
+	net_send(S3D_P_C_PEP_VERTEX, buf, len);
+	return(0);
+}
+/* replaces the last line */
+int s3d_pep_line(int object, int v1, int v2, int material)
+{
+	char				buf[4+3*4],*ptr;
+	int					len=4+3*4;
+	ptr=buf;
+	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint32_t *)ptr)=htonl(v1);				ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(v2);				ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(material);			ptr+=sizeof(uint32_t);
+
+	net_send(S3D_P_C_PEP_LINE,buf,len);
+	return(0);
+}
+
+
+/*  replaces the last n lines. */
+int s3d_pep_lines(int object, unsigned long *lbuf,unsigned short n)
+{
+	unsigned long 	buf[MF_LEN+4];
+	int				i;
+	if ((n*3*4+4)&gt;MF_LEN) 
+	{
+		errds(MED,&quot;s3d_pep_lines()&quot;,&quot;too much data&quot;);
+		return(-1);  /*  impossible */
+	}
+	buf[0]=htonl(object);
+	for (i=0;i&lt;3*n;i++)
+		buf[i+1]=htonl(lbuf[0]);
+	net_send(S3D_P_C_PEP_LINE, (char *)buf,n*3*4+4);
+	return(0);
+	
+}
+/*  replaces the last n vertices. */
+int s3d_pep_vertices(int object, float *vbuf,unsigned short n)
+{
+	unsigned char buf[MF_LEN+4];
+	if ((n*3*sizeof(float)+4)&gt;MF_LEN) 
+	{
+		errds(MED,&quot;s3d_pep_vertices()&quot;,&quot;too much data&quot;);
+		return(-1);  /*  impossible */
+	}
+	*((uint32_t *)buf)=htonl(object);
+	memcpy(buf+4,vbuf,3*n*sizeof(float));
+	net_send(S3D_P_C_PEP_VERTEX,(char *)buf,n*3*sizeof(float)+4);
+	return(0);
+	
+}
+/*  peps the last polygon with some texture coords */
+int s3d_pep_polygon_tex_coord(int object, float x1, float y1, float x2, float y2, float x3, float y3)
+{
+	char *ptr,buf[4*6+4];
+	ptr=buf;
+	*((uint32_t *)buf)=htonl(object);		ptr+=4;
+	*((float *)ptr)=x1;						ptr+=4;
+	*((float *)ptr)=y1;						ptr+=4;
+	*((float *)ptr)=x2;						ptr+=4;
+	*((float *)ptr)=y2;						ptr+=4;
+	*((float *)ptr)=x3;						ptr+=4;
+	*((float *)ptr)=y3;						ptr+=4;
+	net_send(S3D_P_C_PEP_POLY_TEXC,(char *)buf,6*4+4);
+	return(0);
+}
+/*  adds texture coordinates to the last n polygons. */
+int s3d_pep_polygon_tex_coords(int object, float *tbuf,unsigned short n)
+{
+	char buf[MF_LEN+4];
+	if ((n*6*sizeof(float))&gt;MF_LEN) 
+	{
+		errds(MED,&quot;s3d_pep_polygon_tex_coords()&quot;,&quot;too much data&quot;);
+		return(-1);  /*  impossible */
+	}
+	*((uint32_t *)buf)=htonl(object);
+	memcpy(buf+4,tbuf,6*n*sizeof(float));
+	net_send(S3D_P_C_PEP_POLY_TEXC,(char *)buf,n*6*sizeof(float)+4);
+	return(0);
+}
+/*  adds normal information to the last n polygons. */
+int s3d_load_polygon_normals(int object, float *nbuf,unsigned long start, unsigned short n)
+{
+	char				buf[MF_LEN+4],*ptr;
+	int					f,i,len=n*9*4;
+	int					flen,stepl;
+	uint32_t			mstart;
+	if (n&lt;1)
+		return(-1);
+	mstart=start;
+	stepl=((int)((MF_LEN-8)/(9*4)))*(9*4);
+	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
+	for (i=0;i&lt;f;i++)
+	{
+		ptr=buf;
+		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(mstart);			ptr+=sizeof(uint32_t);		  /*  start */
+		if (len-i*stepl&gt;stepl)
+			flen=stepl;
+		else
+			flen=(len-i*stepl);
+		memcpy(ptr,(char *)nbuf+i*stepl,flen);
+		net_send(S3D_P_C_PEP_POLY_NORMAL,buf,flen+8);
+		mstart+=stepl;
+	}
+	return(0);
+}
+/*  adds normal information to the last n polygons. */
+int s3d_load_line_normals(int object, float *nbuf,unsigned long start, unsigned short n)
+{
+	char				buf[MF_LEN+4],*ptr;
+	int					f,i,len=n*6*4;
+	int					flen,stepl;
+	uint32_t			mstart;
+	if (n&lt;1)
+		return(-1);
+	mstart=start;
+	stepl=((int)((MF_LEN-8)/(6*4)))*(6*4);
+	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
+	for (i=0;i&lt;f;i++)
+	{
+		ptr=buf;
+		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(mstart);			ptr+=sizeof(uint32_t);		  /*  start */
+		if (len-i*stepl&gt;stepl)
+			flen=stepl;
+		else
+			flen=(len-i*stepl);
+		memcpy(ptr,(char *)nbuf+i*stepl,flen);
+		net_send(S3D_P_C_PEP_LINE_NORMAL,buf,flen+8);
+		mstart+=stepl;
+	}
+	return(0);
+}
+/*  adds texture coordinates to the last n polygons. */
+int s3d_load_polygon_tex_coords(int object, float *tbuf, unsigned long start, unsigned short n)
+{
+	char				buf[MF_LEN+4],*ptr;
+	int					f,i,len=n*6*4;
+	int					flen,stepl;
+	uint32_t			mstart;
+	if (n&lt;1)
+		return(-1);
+	mstart=start;
+	stepl=((int)((MF_LEN-8)/(6*4)))*(6*4);
+	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
+	for (i=0;i&lt;f;i++)
+	{
+		ptr=buf;
+		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(mstart);			ptr+=sizeof(uint32_t);		  /*  start */
+		if (len-i*stepl&gt;stepl)
+			flen=stepl;
+		else
+			flen=(len-i*stepl);
+		memcpy(ptr,(char *)tbuf+i*stepl,flen);
+		net_send(S3D_P_C_PEP_POLY_TEXC,buf,flen+8);
+		mstart+=stepl;
+	}
+	return(0);
+}
+/*  load n materials at position start, overwriting old ones */
+int s3d_load_materials_a(int object, float *mbuf, unsigned long start, unsigned short n)
+{
+	char				buf[MF_LEN+4],*ptr;
+	int					f,i,len=n*12*4;
+	int					flen,stepl;
+	uint32_t			mstart;
+	if (n&lt;1)
+		return(-1);
+	mstart=start;
+	stepl=((int)((MF_LEN-8)/(12*4)))*(12*4);
+	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
+	for (i=0;i&lt;f;i++)
+	{
+		ptr=buf;
+		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(mstart);			ptr+=sizeof(uint32_t);		  /*  start */
+		if (len-i*stepl&gt;stepl)
+			flen=stepl;
+		else
+			flen=(len-i*stepl);
+		memcpy(ptr,(char *)mbuf+i*stepl,flen);
+		net_send(S3D_P_C_PEP_MAT,buf,flen+8);
+		mstart+=stepl;
+	}
+	return(0);
+}
+int s3d_pep_material_texture(int object, unsigned long tex)
+{
+	char				buf[4*2],*ptr;
+	ptr=buf;
+	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint32_t *)ptr)=htonl(tex);				ptr+=sizeof(uint32_t);		 	 /*  texture index numer */
+	net_send(S3D_P_C_PEP_MAT_TEX,buf,8);
+	return(0);
+}
+/*  load data (which has width w and height h) into object, texture tex at position (xpos,ypos) */
+int s3d_load_texture(int object, unsigned long tex, unsigned short xpos, unsigned short ypos, unsigned short w, unsigned short h, unsigned char *data)
+{
+	char				buf[MF_LEN+4],*ptr;
+	int 				linestep,lines,i;
+	linestep=(MF_LEN-16)/(w*4);
+	if (linestep==0)
+		return(-1);  /*  won't do that. .. yet */
+	for (i=0;i&lt;h;i+=linestep)
+	{
+		ptr=buf;
+		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(tex);				ptr+=sizeof(uint32_t);		  /*  texture number */
+		*((uint16_t *)ptr)=htons(xpos);				ptr+=sizeof(uint16_t);		  /*  xpos */
+		*((uint16_t *)ptr)=htons(ypos+i);			ptr+=sizeof(uint16_t);		  /*  ypos */
+		*((uint16_t *)ptr)=htons(w);				ptr+=sizeof(uint16_t);		  /*  width */
+		if ((h-i)&gt;linestep)		lines=linestep;
+		else					lines=h-i;
+		*((uint16_t *)ptr)=htons(lines);			ptr+=sizeof(uint16_t);		  /*  height */
+		memcpy(ptr,data+(i*w*4),lines*w*4);
+		net_send(S3D_P_C_LOAD_TEX,buf,16+lines*w*4);
+	}
+	return(0);
+}
+int s3d_flags_on(int object, unsigned long flags)
+{
+	char				buf[4+1+4],*ptr;
+	int					len=4+1+4;
+	ptr=buf;
+/* 	dprintf(VLOW, &quot;toggling flags on .. %010x&quot;, flags); */
+	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
+	*ptr=OF_TURN_ON;							ptr+=1;
+	*((uint32_t *)ptr)=htonl(flags);			ptr+=4;		
+	net_send(S3D_P_C_TOGGLE_FLAGS,buf,len);
+	return(0);
+}
+int s3d_flags_off(int object, unsigned long flags)
+{
+	char				buf[4+1+4],*ptr;
+	int					len=4+1+4;
+	ptr=buf;
+/* 	dprintf(VLOW, &quot;toggling flags off .. %010x&quot;, flags); */
+	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
+	*ptr=OF_TURN_OFF;							ptr+=1;
+	*((uint32_t *)ptr)=htonl(flags);			ptr+=4;		 
+	net_send(S3D_P_C_TOGGLE_FLAGS,buf,len);
+	return(0);
+}
+int s3d_translate(int object, float x, float y, float z)
+{
+	char				buf[4+4*3],*ptr;
+	int					len=4+4*3;
+	ptr=buf;
+/* 	dprintf(VLOW, &quot;translating object to  .. %f, %f, %f&quot;, x,y,z); */
+	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
+	*((float *)ptr)=x;							ptr+=4;
+	*((float *)ptr)=y;							ptr+=4;
+	*((float *)ptr)=z;
+	net_send(S3D_P_C_TRANSLATE,buf,len);
+	return(0);
+
+}
+/*  rotation about the x-axis, y-axis and z-axis */
+int s3d_rotate(int object, float x, float y, float z)
+{
+	char				buf[4+4*3],*ptr;
+	int					len=4+4*3;
+	ptr=buf;
+/* 	dprintf(VLOW, &quot;rotating object to  .. %f, %f, %f&quot;, x,y,z); */
+	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
+	*((float *)ptr)=x;							ptr+=4;
+	*((float *)ptr)=y;							ptr+=4;
+	*((float *)ptr)=z;
+	net_send(S3D_P_C_ROTATE,buf,len);
+	return(0);
+}
+/*  scale the object .. */
+
+int s3d_scale(int object, float s)
+{
+	char				buf[4+4],*ptr;
+	int					len=4+4;
+	ptr=buf;
+	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
+	*((float *)ptr)=s;						
+	net_send(S3D_P_C_SCALE,buf,len);
+	return(0);
+}
+/*  sets the focused app through it's mcp object number */
+int s3d_mcp_focus(int object)
+{
+	uint32_t buf=htonl(object);
+	net_send(S3D_P_MCP_FOCUS,(char *)&amp;buf,4);
+	return(0);
+}

Added: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/s3d.h	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,171 @@
+/*
+ * s3d.h
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/* definitions */
+struct s3d_evt {
+	unsigned char event;
+	int length;
+	char *buf;
+	struct s3d_evt *next;
+};
+
+typedef void (*s3d_cb)(struct s3d_evt *);
+
+#define S3D_EVENT_OBJ_CLICK		1
+#define S3D_EVENT_KEY			2
+#define S3D_EVENT_MBUTTON		3
+#define S3D_EVENT_NEW_OBJECT	16
+#define S3D_EVENT_OBJ_INFO		17
+
+#define S3D_EVENT_QUIT			255
+
+/* TODO: don't keep _MCP_ events .. they're ugly */
+#define S3D_MCP_OBJECT			32
+#define S3D_MCP_DEL_OBJECT		33
+
+#define S3D_PORT				6066
+
+#define	S3D_OF_VISIBLE			0x00000001
+#define	S3D_OF_SELECTABLE		0x00000002
+#define S3D_OF_POINTABLE		0x00000004
+struct mcp_object 
+{
+	unsigned long object;
+	float trans_x,trans_y,trans_z;
+	float r;
+#define MCP_NEW_OBJECT	1
+	char name[256]; 
+};
+struct s3d_obj_info 
+{
+	unsigned long object;
+	unsigned long flags;
+	float trans_x,trans_y,trans_z;
+	float rot_x,rot_y,rot_z;
+	float scale;
+	float r;
+	char name[256]; 
+};
+struct s3d_but_info
+{
+	unsigned char button, state;
+};
+/* framework functions */
+void s3d_usage();
+int s3d_init(int *argc, char ***argv, char *name);
+int s3d_quit();
+int s3d_mainloop(void (*f)());
+
+/* object manipulations */
+int s3d_push_vertex(int object, float x, float y, float z);
+int s3d_push_vertices(int object, float *vbuf, unsigned short n);
+int s3d_push_material( int object, 
+						float amb_r, float amb_g, float amb_b,
+						float spec_r, float spec_g, float spec_b,
+						float diff_r, float diff_g, float diff_b);
+int s3d_pep_material( int object, 
+						float amb_r, float amb_g, float amb_b,
+						float spec_r, float spec_g, float spec_b,
+						float diff_r, float diff_g, float diff_b);
+int s3d_push_material_a( int object, 
+						float amb_r, float amb_g, float amb_b, float amb_a,
+						float spec_r, float spec_g, float spec_b, float spec_a,
+						float diff_r, float diff_g, float diff_b, float diff_a);
+int s3d_push_materials_a(int object, float *mbuf, unsigned short n);
+int s3d_pep_material_a( int object, 
+						float amb_r, float amb_g, float amb_b, float amb_a,
+						float spec_r, float spec_g, float spec_b, float spec_a,
+						float diff_r, float diff_g, float diff_b, float diff_a);
+
+int s3d_pep_materials_a(int object, float *mbuf, unsigned short n);
+int s3d_load_materials_a(int object, float *mbuf, unsigned long start, unsigned short n);
+int s3d_push_polygon(int object, unsigned long v1, unsigned long v2, unsigned long v3, unsigned long material);
+int s3d_push_polygons(int object, unsigned long *pbuf, unsigned short n);
+int s3d_push_line(int object, unsigned long v1, unsigned long v2, unsigned long material);
+int s3d_push_lines(int object, unsigned long *lbuf, unsigned short n);
+int s3d_push_texture(int object, unsigned short w, unsigned short h);
+int s3d_push_textures(int object, unsigned short *tbuf, unsigned short n);
+int s3d_pop_vertex(int object, unsigned long n);
+int s3d_pop_polygon(int object, unsigned long n);
+int s3d_pop_material(int object, unsigned long n);
+int s3d_pop_texture(int object, unsigned long n);
+int s3d_pop_polygon(int object, unsigned long n);
+int s3d_pop_line(int object, unsigned long n);
+int s3d_pep_line_normals(int object, float *nbuf,unsigned short n);
+int s3d_pep_polygon_normals(int object, float *nbuf,unsigned short n);
+int s3d_pep_polygon_tex_coord(int object, float x1, float y1, float x2, float y2, float x3, float y3);
+int s3d_pep_polygon_tex_coords(int object, float *tbuf,unsigned short n);
+int s3d_pep_material_texture(int object, unsigned long tex);
+int s3d_pep_vertex(int object, float x, float y, float z);
+int s3d_pep_vertices(int object, float *vbuf,unsigned short n);
+int s3d_pep_line(int object, int v1, int v2, int material);
+int s3d_pep_lines(int object, unsigned long *lbuf,unsigned short n);
+int s3d_load_line_normals(int object, float *nbuf,unsigned long start, unsigned short n);
+int s3d_load_polygon_normals(int object, float *nbuf,unsigned long start, unsigned short n);
+int s3d_load_polygon_tex_coords(int object, float *tbuf, unsigned long start, unsigned short n);
+int s3d_load_texture(int object, unsigned long tex, unsigned short xpos, unsigned short ypos, unsigned short w, unsigned short h, unsigned char *data);
+
+int s3d_new_object();
+int s3d_del_object(int oid);
+
+int s3d_clone(int oid);
+int s3d_clone_target(int oid, int toid);
+
+int s3d_link(int oid_from, int oid_to);
+int s3d_unlink(int oid);
+
+int s3d_flags_on(int object, unsigned long flags);
+int s3d_flags_off(int object, unsigned long flags);
+int s3d_translate(int object, float x, float y, float z);
+int s3d_rotate(int object, float x, float y, float z);
+int s3d_scale(int object, float s);
+
+/* high-level object creating */
+int s3d_import_3ds_file(char *fname);
+int s3d_import_3ds(char *buf);
+int s3d_open_file(char *fname, char **pointer);
+int s3d_select_font(char *mask);
+int s3d_draw_string( char *str, float *xlen);
+
+/* some vector calculation helpers */
+
+float s3d_vector_length( float vector[] );
+float s3d_vector_dot_product( float vector1[], float vector2[] );
+void s3d_vector_substract( float vector1[], float vector2[], float result_vector[] );
+float s3d_vector_angle( float vector1[], float vector2[] );
+
+/* event handlers */
+void s3d_push_event(struct s3d_evt *newevt);
+struct s3d_evt *s3d_pop_event();
+struct s3d_evt *s3d_find_event(unsigned char event);
+int s3d_delete_event(struct s3d_evt *devt);
+
+void s3d_set_callback(unsigned char event, s3d_cb func);
+void s3d_clear_callback(unsigned char event);
+void s3d_ignore_callback(unsigned char event);
+s3d_cb s3d_get_callback(unsigned char event);
+void s3d_process_stack();
+
+/* mcp special */
+int s3d_mcp_focus(int object);
+

Added: trunk/libs3d/s3d_keysym.h
===================================================================
--- trunk/libs3d/s3d_keysym.h	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/s3d_keysym.h	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,314 @@
+/*
+ * s3d_keysym.h
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ * Copyright (C) 1997-2004 Sam Lantinga &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">slouken at libsdl.org</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/* this is just a copy of SDL_keysym.sh from the SDL Simple DirectMedia Layer Package,
+ * which seems to have a pretty useful Key definition base.
+ * For more Information about SDL, check <A HREF="http://sdlorg*/">http://sdlorg*/</A>
+
+
+/* What we really want is a mapping of every raw key on the keyboard.
+   To support international keyboards, we use the range 0xA1 - 0xFF
+   as international virtual keycodes.  We'll follow in the footsteps of X11...
+   The names of the keys
+ */
+ 
+typedef enum {
+	/* The keyboard syms have been cleverly chosen to map to ASCII */
+	S3DK_UNKNOWN		= 0,
+	S3DK_FIRST		= 0,
+	S3DK_BACKSPACE		= 8,
+	S3DK_TAB		= 9,
+	S3DK_CLEAR		= 12,
+	S3DK_RETURN		= 13,
+	S3DK_PAUSE		= 19,
+	S3DK_ESCAPE		= 27,
+	S3DK_SPACE		= 32,
+	S3DK_EXCLAIM		= 33,
+	S3DK_QUOTEDBL		= 34,
+	S3DK_HASH		= 35,
+	S3DK_DOLLAR		= 36,
+	S3DK_AMPERSAND		= 38,
+	S3DK_QUOTE		= 39,
+	S3DK_LEFTPAREN		= 40,
+	S3DK_RIGHTPAREN		= 41,
+	S3DK_ASTERISK		= 42,
+	S3DK_PLUS		= 43,
+	S3DK_COMMA		= 44,
+	S3DK_MINUS		= 45,
+	S3DK_PERIOD		= 46,
+	S3DK_SLASH		= 47,
+	S3DK_0			= 48,
+	S3DK_1			= 49,
+	S3DK_2			= 50,
+	S3DK_3			= 51,
+	S3DK_4			= 52,
+	S3DK_5			= 53,
+	S3DK_6			= 54,
+	S3DK_7			= 55,
+	S3DK_8			= 56,
+	S3DK_9			= 57,
+	S3DK_COLON		= 58,
+	S3DK_SEMICOLON		= 59,
+	S3DK_LESS		= 60,
+	S3DK_EQUALS		= 61,
+	S3DK_GREATER		= 62,
+	S3DK_QUESTION		= 63,
+	S3DK_AT			= 64,
+	/* 
+	   Skip uppercase letters
+	 */
+	S3DK_LEFTBRACKET	= 91,
+	S3DK_BACKSLASH		= 92,
+	S3DK_RIGHTBRACKET	= 93,
+	S3DK_CARET		= 94,
+	S3DK_UNDERSCORE		= 95,
+	S3DK_BACKQUOTE		= 96,
+	S3DK_a			= 97,
+	S3DK_b			= 98,
+	S3DK_c			= 99,
+	S3DK_d			= 100,
+	S3DK_e			= 101,
+	S3DK_f			= 102,
+	S3DK_g			= 103,
+	S3DK_h			= 104,
+	S3DK_i			= 105,
+	S3DK_j			= 106,
+	S3DK_k			= 107,
+	S3DK_l			= 108,
+	S3DK_m			= 109,
+	S3DK_n			= 110,
+	S3DK_o			= 111,
+	S3DK_p			= 112,
+	S3DK_q			= 113,
+	S3DK_r			= 114,
+	S3DK_s			= 115,
+	S3DK_t			= 116,
+	S3DK_u			= 117,
+	S3DK_v			= 118,
+	S3DK_w			= 119,
+	S3DK_x			= 120,
+	S3DK_y			= 121,
+	S3DK_z			= 122,
+	S3DK_DELETE		= 127,
+	/* End of ASCII mapped keysyms */
+
+	/* International keyboard syms */
+	S3DK_WORLD_0		= 160,		/* 0xA0 */
+	S3DK_WORLD_1		= 161,
+	S3DK_WORLD_2		= 162,
+	S3DK_WORLD_3		= 163,
+	S3DK_WORLD_4		= 164,
+	S3DK_WORLD_5		= 165,
+	S3DK_WORLD_6		= 166,
+	S3DK_WORLD_7		= 167,
+	S3DK_WORLD_8		= 168,
+	S3DK_WORLD_9		= 169,
+	S3DK_WORLD_10		= 170,
+	S3DK_WORLD_11		= 171,
+	S3DK_WORLD_12		= 172,
+	S3DK_WORLD_13		= 173,
+	S3DK_WORLD_14		= 174,
+	S3DK_WORLD_15		= 175,
+	S3DK_WORLD_16		= 176,
+	S3DK_WORLD_17		= 177,
+	S3DK_WORLD_18		= 178,
+	S3DK_WORLD_19		= 179,
+	S3DK_WORLD_20		= 180,
+	S3DK_WORLD_21		= 181,
+	S3DK_WORLD_22		= 182,
+	S3DK_WORLD_23		= 183,
+	S3DK_WORLD_24		= 184,
+	S3DK_WORLD_25		= 185,
+	S3DK_WORLD_26		= 186,
+	S3DK_WORLD_27		= 187,
+	S3DK_WORLD_28		= 188,
+	S3DK_WORLD_29		= 189,
+	S3DK_WORLD_30		= 190,
+	S3DK_WORLD_31		= 191,
+	S3DK_WORLD_32		= 192,
+	S3DK_WORLD_33		= 193,
+	S3DK_WORLD_34		= 194,
+	S3DK_WORLD_35		= 195,
+	S3DK_WORLD_36		= 196,
+	S3DK_WORLD_37		= 197,
+	S3DK_WORLD_38		= 198,
+	S3DK_WORLD_39		= 199,
+	S3DK_WORLD_40		= 200,
+	S3DK_WORLD_41		= 201,
+	S3DK_WORLD_42		= 202,
+	S3DK_WORLD_43		= 203,
+	S3DK_WORLD_44		= 204,
+	S3DK_WORLD_45		= 205,
+	S3DK_WORLD_46		= 206,
+	S3DK_WORLD_47		= 207,
+	S3DK_WORLD_48		= 208,
+	S3DK_WORLD_49		= 209,
+	S3DK_WORLD_50		= 210,
+	S3DK_WORLD_51		= 211,
+	S3DK_WORLD_52		= 212,
+	S3DK_WORLD_53		= 213,
+	S3DK_WORLD_54		= 214,
+	S3DK_WORLD_55		= 215,
+	S3DK_WORLD_56		= 216,
+	S3DK_WORLD_57		= 217,
+	S3DK_WORLD_58		= 218,
+	S3DK_WORLD_59		= 219,
+	S3DK_WORLD_60		= 220,
+	S3DK_WORLD_61		= 221,
+	S3DK_WORLD_62		= 222,
+	S3DK_WORLD_63		= 223,
+	S3DK_WORLD_64		= 224,
+	S3DK_WORLD_65		= 225,
+	S3DK_WORLD_66		= 226,
+	S3DK_WORLD_67		= 227,
+	S3DK_WORLD_68		= 228,
+	S3DK_WORLD_69		= 229,
+	S3DK_WORLD_70		= 230,
+	S3DK_WORLD_71		= 231,
+	S3DK_WORLD_72		= 232,
+	S3DK_WORLD_73		= 233,
+	S3DK_WORLD_74		= 234,
+	S3DK_WORLD_75		= 235,
+	S3DK_WORLD_76		= 236,
+	S3DK_WORLD_77		= 237,
+	S3DK_WORLD_78		= 238,
+	S3DK_WORLD_79		= 239,
+	S3DK_WORLD_80		= 240,
+	S3DK_WORLD_81		= 241,
+	S3DK_WORLD_82		= 242,
+	S3DK_WORLD_83		= 243,
+	S3DK_WORLD_84		= 244,
+	S3DK_WORLD_85		= 245,
+	S3DK_WORLD_86		= 246,
+	S3DK_WORLD_87		= 247,
+	S3DK_WORLD_88		= 248,
+	S3DK_WORLD_89		= 249,
+	S3DK_WORLD_90		= 250,
+	S3DK_WORLD_91		= 251,
+	S3DK_WORLD_92		= 252,
+	S3DK_WORLD_93		= 253,
+	S3DK_WORLD_94		= 254,
+	S3DK_WORLD_95		= 255,		/* 0xFF */
+
+	/* Numeric keypad */
+	S3DK_KP0		= 256,
+	S3DK_KP1		= 257,
+	S3DK_KP2		= 258,
+	S3DK_KP3		= 259,
+	S3DK_KP4		= 260,
+	S3DK_KP5		= 261,
+	S3DK_KP6		= 262,
+	S3DK_KP7		= 263,
+	S3DK_KP8		= 264,
+	S3DK_KP9		= 265,
+	S3DK_KP_PERIOD		= 266,
+	S3DK_KP_DIVIDE		= 267,
+	S3DK_KP_MULTIPLY	= 268,
+	S3DK_KP_MINUS		= 269,
+	S3DK_KP_PLUS		= 270,
+	S3DK_KP_ENTER		= 271,
+	S3DK_KP_EQUALS		= 272,
+
+	/* Arrows + Home/End pad */
+	S3DK_UP			= 273,
+	S3DK_DOWN		= 274,
+	S3DK_RIGHT		= 275,
+	S3DK_LEFT		= 276,
+	S3DK_INSERT		= 277,
+	S3DK_HOME		= 278,
+	S3DK_END		= 279,
+	S3DK_PAGEUP		= 280,
+	S3DK_PAGEDOWN		= 281,
+
+	/* Function keys */
+	S3DK_F1			= 282,
+	S3DK_F2			= 283,
+	S3DK_F3			= 284,
+	S3DK_F4			= 285,
+	S3DK_F5			= 286,
+	S3DK_F6			= 287,
+	S3DK_F7			= 288,
+	S3DK_F8			= 289,
+	S3DK_F9			= 290,
+	S3DK_F10		= 291,
+	S3DK_F11		= 292,
+	S3DK_F12		= 293,
+	S3DK_F13		= 294,
+	S3DK_F14		= 295,
+	S3DK_F15		= 296,
+
+	/* Key state modifier keys */
+	S3DK_NUMLOCK		= 300,
+	S3DK_CAPSLOCK		= 301,
+	S3DK_SCROLLOCK		= 302,
+	S3DK_RSHIFT		= 303,
+	S3DK_LSHIFT		= 304,
+	S3DK_RCTRL		= 305,
+	S3DK_LCTRL		= 306,
+	S3DK_RALT		= 307,
+	S3DK_LALT		= 308,
+	S3DK_RMETA		= 309,
+	S3DK_LMETA		= 310,
+	S3DK_LSUPER		= 311,		/* Left &quot;Windows&quot; key */
+	S3DK_RSUPER		= 312,		/* Right &quot;Windows&quot; key */
+	S3DK_MODE		= 313,		/* &quot;Alt Gr&quot; key */
+	S3DK_COMPOSE		= 314,		/* Multi-key compose key */
+
+	/* Miscellaneous function keys */
+	S3DK_HELP		= 315,
+	S3DK_PRINT		= 316,
+	S3DK_SYSREQ		= 317,
+	S3DK_BREAK		= 318,
+	S3DK_MENU		= 319,
+	S3DK_POWER		= 320,		/* Power Macintosh power key */
+	S3DK_EURO		= 321,		/* Some european keyboards */
+	S3DK_UNDO		= 322,		/* Atari keyboard has Undo */
+
+	/* Add any other keys here */
+
+	S3DK_LAST
+} S3DKey;
+
+/* Enumeration of valid key mods (possibly OR'd together) */
+typedef enum {
+	S3D_KMOD_NONE  = 0x0000,
+	S3D_KMOD_LSHIFT= 0x0001,
+	S3D_KMOD_RSHIFT= 0x0002,
+	S3D_KMOD_LCTRL = 0x0040,
+	S3D_KMOD_RCTRL = 0x0080,
+	S3D_KMOD_LALT  = 0x0100,
+	S3D_KMOD_RALT  = 0x0200,
+	S3D_KMOD_LMETA = 0x0400,
+	S3D_KMOD_RMETA = 0x0800,
+	S3D_KMOD_NUM   = 0x1000,
+	S3D_KMOD_CAPS  = 0x2000,
+	S3D_KMOD_MODE  = 0x4000,
+	S3D_KMOD_RESERVED = 0x8000
+} S3DMod;
+
+#define S3D_KMOD_CTRL	(KMOD_LCTRL|KMOD_RCTRL)
+#define S3D_KMOD_SHIFT	(KMOD_LSHIFT|KMOD_RSHIFT)
+#define S3D_KMOD_ALT	(KMOD_LALT|KMOD_RALT)
+#define S3D_KMOD_META	(KMOD_LMETA|KMOD_RMETA)
+

Added: trunk/libs3d/s3dlib.h
===================================================================
--- trunk/libs3d/s3dlib.h	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/s3dlib.h	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,116 @@
+/*
+ * s3dlib.h
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &lt;stdint.h&gt;
+#include &quot;../config.h&quot;
+#define VLOW	1
+#define	LOW		2
+#define MED		3
+#define HIGH	4
+#define	VHIGH	5
+
+#define DBM_MAX			1024	 /*  maximum size of a debug message string */
+#define S3D_NAME_MAX	256		 /*  limit for names [e.g. process names] */
+#define OF_TURN_ON 		1		 /*  logical or */
+#define OF_TURN_OFF 	2		 /*  logical ?! */
+#define OF_TURN_SWAP 	3		 /*  logical ?! */
+#define TIMEOUT			1000
+#define MAX_CB			256		 /*  as much as there are callbacks */
+#ifndef NULL
+	#define NULL	0
+#endif
+#define CON_NULL	0
+#define CON_SHM		1
+#define CON_TCP		2
+#define SHM_SIZE 	sizeof(key_t)*2  		/* space for the keys */
+#define RB_STD_SIZE		1024*512
+#define RB_OVERHEAD		sizeof(struct buf_t)
+/*  the callback buiffer: */
+extern s3d_cb s3d_cb_list[MAX_CB];
+/*  some local prototypes: */
+/*  char *s3d_open_file(char *fname); */
+int net_prot_in(uint8_t opcode, uint16_t length, char *buf);
+void dprintf(int relevance, const char *fmt, ...);
+void errn(char *func,int en);
+void errs(char *func, char *msg);
+void errdn(int relevance, char *func,int en); 
+void errds(int relevance,char *func, const char *fmt, ...);
+/*  fontselect.c */
+char *s3d_findfont(char *mask);
+/*  object_queue.c */
+int _queue_init();
+int _queue_fill();
+int _queue_new_object(unsigned int oid);
+unsigned int _queue_want_object();
+int _queue_quit();
+/*  network.c */
+int s3d_net_check();
+int net_send(unsigned char opcode, char *buf, unsigned short length);
+int s3d_net_init(char *urlc);
+#ifdef TCP
+/* tcp.c */
+int _tcp_init();
+int _tcp_quit();
+int _s3d_tcp_net_receive();
+int tcp_writen(char *str,int s);
+int tcp_readn(char *str,int s);
+#endif
+/* shm_ringbuf.c */
+#ifdef SHM
+struct buf_t
+{
+	uint32_t start,end,bufsize;	/* start/end of the data */
+};
+int shm_write(struct buf_t *rb,char *buf, int n);
+int shm_read(struct buf_t *rb,char *buf, int n);
+/* shm.c */
+int _shm_init(char *ftoken);
+int _shm_quit();
+int _shm_net_receive();
+int shm_writen(char *str,int s);
+int shm_readn(char *str,int s);
+#endif
+/* freetype.c */
+struct t_buf
+{
+	float *vbuf;
+	unsigned long *pbuf;
+	int pn,vn;
+	float xoff;
+};
+
+/* tesselate.c */
+struct tessp_t
+{
+	int next,prev,done;
+};
+int _s3d_tesselate(struct tessp_t *t,struct t_buf *b);
+
+#include &quot;config.h&quot;
+#ifndef DEBUG
+#define dprintf(...) /* nothing */
+#define errdn(...) /* nothing */
+#define errds(...) /* nothing */
+#endif
+

Added: trunk/libs3d/sei_construct.c
===================================================================
--- trunk/libs3d/sei_construct.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/sei_construct.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,1099 @@
+/*
+ * sei_construct.c
+ * 
+ * Copyright (C) 2006 Simon Wunderlich
+ * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
+ * for public domain: 
+ * &lt;snip&gt;
+ *
+ * This code is in the public domain. Specifically, we give to the public
+ * domain all rights for future licensing of the source code, all resale
+ * rights, and all publishing rights.
+ *
+ * UNC-CH GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE SOFTWARE
+ * AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION, WARRANTY
+ * OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *
+ *                                 - Atul Narkhede (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">narkhede at cs.unc.edu</A>)
+ * &lt;/snip&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &lt;sei_triangulate.h&gt;
+#include &lt;math.h&gt;
+#include &lt;string.h&gt; /* memset() */
+
+
+node_t qs[QSIZE];		/* Query structure */
+trap_t tr[TRSIZE];		/* Trapezoid structure */
+segment_t seg[SEGSIZE];		/* Segment table */
+
+static int q_idx;
+static int tr_idx;
+
+/* Return a new node to be added into the query tree */
+static int newnode()
+{
+  if (q_idx &lt; QSIZE)
+    return q_idx++;
+  else
+    {
+      errs(&quot;sei:newnode()&quot;,&quot;Query-table overflow&quot;);
+      return -1;
+    }
+}
+
+/* Return a free trapezoid */
+static int newtrap()
+{
+  if (tr_idx &lt; TRSIZE)
+    {
+      tr[tr_idx].lseg = -1;
+      tr[tr_idx].rseg = -1;
+      tr[tr_idx].state = ST_VALID;
+      return tr_idx++;
+    }
+  else
+    {
+      errs(&quot;sei:newtrap()&quot;,&quot;Trapezoid-table overflow&quot;);
+      return -1;
+    }
+}
+
+
+/* Return the maximum of the two points into the yval structure */
+static int _max(yval, v0, v1)
+     point_t *yval;
+     point_t *v0;
+     point_t *v1;
+{
+  if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
+    *yval = *v0;
+  else if (FP_EQUAL(v0-&gt;y, v1-&gt;y))
+    {
+      if (v0-&gt;x &gt; v1-&gt;x + C_EPS)
+	*yval = *v0;
+      else
+	*yval = *v1;
+    }
+  else
+    *yval = *v1;
+  
+  return 0;
+}
+
+
+/* Return the minimum of the two points into the yval structure */
+static int _min(yval, v0, v1)
+     point_t *yval;
+     point_t *v0;
+     point_t *v1;
+{
+  if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
+    *yval = *v0;
+  else if (FP_EQUAL(v0-&gt;y, v1-&gt;y))
+    {
+      if (v0-&gt;x &lt; v1-&gt;x)
+	*yval = *v0;
+      else
+	*yval = *v1;
+    }
+  else
+    *yval = *v1;
+  
+  return 0;
+}
+
+
+int _greater_than(v0, v1)
+     point_t *v0;
+     point_t *v1;
+{
+  if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
+    return TRUE;
+  else if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
+    return FALSE;
+  else
+    return (v0-&gt;x &gt; v1-&gt;x);
+}
+
+
+int _equal_to(v0, v1)
+     point_t *v0;
+     point_t *v1;
+{
+  return (FP_EQUAL(v0-&gt;y, v1-&gt;y) &amp;&amp; FP_EQUAL(v0-&gt;x, v1-&gt;x));
+}
+
+int _greater_than_equal_to(v0, v1)
+     point_t *v0;
+     point_t *v1;
+{
+  if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
+    return TRUE;
+  else if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
+    return FALSE;
+  else
+    return (v0-&gt;x &gt;= v1-&gt;x);
+}
+
+int _less_than(v0, v1)
+     point_t *v0;
+     point_t *v1;
+{
+  if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
+    return TRUE;
+  else if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
+    return FALSE;
+  else
+    return (v0-&gt;x &lt; v1-&gt;x);
+}
+
+
+/* Initilialise the query structure (Q) and the trapezoid table (T) 
+ * when the first segment is added to start the trapezoidation. The
+ * query-tree starts out with 4 trapezoids, one S-node and 2 Y-nodes
+ *    
+ *                4
+ *   -----------------------------------
+ *  		  \
+ *  	1	   \        2
+ *  		    \
+ *   -----------------------------------
+ *                3
+ */
+
+static int init_query_structure(segnum)
+     int segnum;
+{
+  int i1, i2, i3, i4, i5, i6, i7, root;
+  int t1, t2, t3, t4;
+  segment_t *s = &amp;seg[segnum];
+
+  q_idx = tr_idx = 1;
+  memset((void *)tr, 0, sizeof(tr));
+  memset((void *)qs, 0, sizeof(qs));
+
+  i1 = newnode();
+  qs[i1].nodetype = T_Y;
+  _max(&amp;qs[i1].yval, &amp;s-&gt;v0, &amp;s-&gt;v1); /* root */
+  root = i1;
+
+  qs[i1].right = i2 = newnode();
+  qs[i2].nodetype = T_SINK;
+  qs[i2].parent = i1;
+
+  qs[i1].left = i3 = newnode();
+  qs[i3].nodetype = T_Y;
+  _min(&amp;qs[i3].yval, &amp;s-&gt;v0, &amp;s-&gt;v1); /* root */
+  qs[i3].parent = i1;
+  
+  qs[i3].left = i4 = newnode();
+  qs[i4].nodetype = T_SINK;
+  qs[i4].parent = i3;
+  
+  qs[i3].right = i5 = newnode();
+  qs[i5].nodetype = T_X;
+  qs[i5].segnum = segnum;
+  qs[i5].parent = i3;
+  
+  qs[i5].left = i6 = newnode();
+  qs[i6].nodetype = T_SINK;
+  qs[i6].parent = i5;
+
+  qs[i5].right = i7 = newnode();
+  qs[i7].nodetype = T_SINK;
+  qs[i7].parent = i5;
+
+  t1 = newtrap();		/* middle left */
+  t2 = newtrap();		/* middle right */
+  t3 = newtrap();		/* bottom-most */
+  t4 = newtrap();		/* topmost */
+
+  tr[t1].hi = tr[t2].hi = tr[t4].lo = qs[i1].yval;
+  tr[t1].lo = tr[t2].lo = tr[t3].hi = qs[i3].yval;
+  tr[t4].hi.y = (double) (INFINITY);
+  tr[t4].hi.x = (double) (INFINITY);
+  tr[t3].lo.y = (double) -1* (INFINITY);
+  tr[t3].lo.x = (double) -1* (INFINITY);
+  tr[t1].rseg = tr[t2].lseg = segnum;
+  tr[t1].u0 = tr[t2].u0 = t4;
+  tr[t1].d0 = tr[t2].d0 = t3;
+  tr[t4].d0 = tr[t3].u0 = t1;
+  tr[t4].d1 = tr[t3].u1 = t2;
+  
+  tr[t1].sink = i6;
+  tr[t2].sink = i7;
+  tr[t3].sink = i4;
+  tr[t4].sink = i2;
+
+  tr[t1].state = tr[t2].state = ST_VALID;
+  tr[t3].state = tr[t4].state = ST_VALID;
+
+  qs[i2].trnum = t4;
+  qs[i4].trnum = t3;
+  qs[i6].trnum = t1;
+  qs[i7].trnum = t2;
+
+  s-&gt;is_inserted = TRUE;
+  return root;
+}
+
+
+/* Retun TRUE if the vertex v is to the left of line segment no.
+ * segnum. Takes care of the degenerate cases when both the vertices
+ * have the same y--cood, etc.
+ */
+
+static int is_left_of(segnum, v)
+     int segnum;
+     point_t *v;
+{
+  segment_t *s = &amp;seg[segnum];
+  double area;
+  
+  if (_greater_than(&amp;s-&gt;v1, &amp;s-&gt;v0)) /* seg. going upwards */
+    {
+      if (FP_EQUAL(s-&gt;v1.y, v-&gt;y))
+	{
+	  if (v-&gt;x &lt; s-&gt;v1.x)
+	    area = 1.0;
+	  else
+	    area = -1.0;
+	}
+      else if (FP_EQUAL(s-&gt;v0.y, v-&gt;y))
+	{
+	  if (v-&gt;x &lt; s-&gt;v0.x)
+	    area = 1.0;
+	  else
+	    area = -1.0;
+	}
+      else
+	area = CROSS(s-&gt;v0, s-&gt;v1, (*v));
+    }
+  else				/* v0 &gt; v1 */
+    {
+      if (FP_EQUAL(s-&gt;v1.y, v-&gt;y))
+	{
+	  if (v-&gt;x &lt; s-&gt;v1.x)
+	    area = 1.0;
+	  else
+	    area = -1.0;
+	}
+      else if (FP_EQUAL(s-&gt;v0.y, v-&gt;y))
+	{
+	  if (v-&gt;x &lt; s-&gt;v0.x)
+	    area = 1.0;
+	  else
+	    area = -1.0;
+	}
+      else
+	area = CROSS(s-&gt;v1, s-&gt;v0, (*v));
+    }
+  
+  if (area &gt; 0.0)
+    return TRUE;
+  else 
+    return FALSE;
+}
+
+
+
+/* Returns true if the corresponding endpoint of the given segment is */
+/* already inserted into the segment tree. Use the simple test of */
+/* whether the segment which shares this endpoint is already inserted */
+
+static int inserted(segnum, whichpt)
+     int segnum;
+     int whichpt;
+{
+  if (whichpt == FIRSTPT)
+    return seg[seg[segnum].prev].is_inserted;
+  else
+    return seg[seg[segnum].next].is_inserted;
+}
+
+/* This is query routine which determines which trapezoid does the 
+ * point v lie in. The return value is the trapezoid number. 
+ */
+
+int locate_endpoint(v, vo, r)
+     point_t *v;
+     point_t *vo;
+     int r;
+{
+  node_t *rptr = &amp;qs[r];
+  
+  switch (rptr-&gt;nodetype)
+    {
+    case T_SINK:
+      return rptr-&gt;trnum;
+      
+    case T_Y:
+      if (_greater_than(v, &amp;rptr-&gt;yval)) /* above */
+	return locate_endpoint(v, vo, rptr-&gt;right);
+      else if (_equal_to(v, &amp;rptr-&gt;yval)) /* the point is already */
+	{			          /* inserted. */
+	  if (_greater_than(vo, &amp;rptr-&gt;yval)) /* above */
+	    return locate_endpoint(v, vo, rptr-&gt;right);
+	  else 
+	    return locate_endpoint(v, vo, rptr-&gt;left); /* below */	    
+	}
+      else
+	return locate_endpoint(v, vo, rptr-&gt;left); /* below */
+
+    case T_X:
+      if (_equal_to(v, &amp;seg[rptr-&gt;segnum].v0) || 
+	       _equal_to(v, &amp;seg[rptr-&gt;segnum].v1))
+	{
+	  if (FP_EQUAL(v-&gt;y, vo-&gt;y)) /* horizontal segment */
+	    {
+	      if (vo-&gt;x &lt; v-&gt;x)
+		return locate_endpoint(v, vo, rptr-&gt;left); /* left */
+	      else
+		return locate_endpoint(v, vo, rptr-&gt;right); /* right */
+	    }
+
+	  else if (is_left_of(rptr-&gt;segnum, vo))
+	    return locate_endpoint(v, vo, rptr-&gt;left); /* left */
+	  else
+	    return locate_endpoint(v, vo, rptr-&gt;right); /* right */
+	}
+      else if (is_left_of(rptr-&gt;segnum, v))
+	return locate_endpoint(v, vo, rptr-&gt;left); /* left */
+      else
+	return locate_endpoint(v, vo, rptr-&gt;right); /* right */	
+
+    default:
+      errs(&quot;sei:locate_endpoint()&quot;,&quot;Haggu!!!! (whatever)&quot;);
+      break;
+    }
+  return(-1);
+}
+
+
+/* Thread in the segment into the existing trapezoidation. The 
+ * limiting trapezoids are given by tfirst and tlast (which are the
+ * trapezoids containing the two endpoints of the segment. Merges all
+ * possible trapezoids which flank this segment and have been recently
+ * divided because of its insertion
+ */
+
+static int merge_trapezoids(segnum, tfirst, tlast, side)
+     int segnum;
+     int tfirst;
+     int tlast;
+     int side;
+{
+  int t, tnext, cond;
+  int ptnext;
+
+  /* First merge polys on the LHS */
+  t = tfirst;
+  while ((t &gt; 0) &amp;&amp; _greater_than_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo))
+    {
+      if (side == S_LEFT)
+	cond = ((((tnext = tr[t].d0) &gt; 0) &amp;&amp; (tr[tnext].rseg == segnum)) ||
+		(((tnext = tr[t].d1) &gt; 0) &amp;&amp; (tr[tnext].rseg == segnum)));
+      else
+	cond = ((((tnext = tr[t].d0) &gt; 0) &amp;&amp; (tr[tnext].lseg == segnum)) ||
+		(((tnext = tr[t].d1) &gt; 0) &amp;&amp; (tr[tnext].lseg == segnum)));
+      
+      if (cond)
+	{
+	  if ((tr[t].lseg == tr[tnext].lseg) &amp;&amp;
+	      (tr[t].rseg == tr[tnext].rseg)) /* good neighbours */
+	    {			              /* merge them */
+	      /* Use the upper node as the new node i.e. t */
+	      
+	      ptnext = qs[tr[tnext].sink].parent;
+	      
+	      if (qs[ptnext].left == tr[tnext].sink)
+		qs[ptnext].left = tr[t].sink;
+	      else
+		qs[ptnext].right = tr[t].sink;	/* redirect parent */
+	      
+	      
+	      /* Change the upper neighbours of the lower trapezoids */
+	      
+	      if ((tr[t].d0 = tr[tnext].d0) &gt; 0)
+		  {
+			if (tr[tr[t].d0].u0 == tnext)
+			  tr[tr[t].d0].u0 = t;
+			else if (tr[tr[t].d0].u1 == tnext)
+			  tr[tr[t].d0].u1 = t;
+		  }
+	      
+	      if ((tr[t].d1 = tr[tnext].d1) &gt; 0)
+		  {
+			if (tr[tr[t].d1].u0 == tnext)
+			  tr[tr[t].d1].u0 = t;
+			else if (tr[tr[t].d1].u1 == tnext)
+			  tr[tr[t].d1].u1 = t;
+		  }
+	      
+	      tr[t].lo = tr[tnext].lo;
+	      tr[tnext].state = ST_INVALID; /* invalidate the lower */
+				            /* trapezium */
+	    }
+	  else		    /* not good neighbours */
+	    t = tnext;
+	}
+      else		    /* do not satisfy the outer if */
+	t = tnext;
+      
+    } /* end-while */
+       
+  return 0;
+}
+
+
+/* Add in the new segment into the trapezoidation and update Q and T
+ * structures. First locate the two endpoints of the segment in the
+ * Q-structure. Then start from the topmost trapezoid and go down to
+ * the  lower trapezoid dividing all the trapezoids in between .
+ */
+
+static int add_segment(segnum)
+     int segnum;
+{
+  segment_t s;
+  int tu, tl, sk, tfirst, tlast;
+  int tfirstr = 0, tlastr = 0, tfirstl, tlastl;
+  int i1, i2, t, tn;
+  point_t tpt;
+  int tritop = 0, tribot = 0, is_swapped = 0;
+  int tmptriseg;
+  int tmpseg = 1;
+
+  s = seg[segnum];
+  if (_greater_than(&amp;s.v1, &amp;s.v0)) /* Get higher vertex in v0 */
+    {
+      int tmp;
+      tpt = s.v0;
+      s.v0 = s.v1;
+      s.v1 = tpt;
+      tmp = s.root0;
+      s.root0 = s.root1;
+      s.root1 = tmp;
+      is_swapped = TRUE;
+    }
+
+  if ((is_swapped) ? !inserted(segnum, LASTPT) :
+       !inserted(segnum, FIRSTPT))     /* insert v0 in the tree */
+    {
+      int tmp_d;
+
+      tu = locate_endpoint(&amp;s.v0, &amp;s.v1, s.root0);
+      tl = newtrap();		/* tl is the new lower trapezoid */
+      tr[tl].state = ST_VALID;
+      tr[tl] = tr[tu];
+      tr[tu].lo.y = tr[tl].hi.y = s.v0.y;
+      tr[tu].lo.x = tr[tl].hi.x = s.v0.x;
+      tr[tu].d0 = tl;      
+      tr[tu].d1 = 0;
+      tr[tl].u0 = tu;
+      tr[tl].u1 = 0;
+
+      if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
+	tr[tmp_d].u0 = tl;
+      if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
+	tr[tmp_d].u1 = tl;
+
+      if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
+	tr[tmp_d].u0 = tl;
+      if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
+	tr[tmp_d].u1 = tl;
+
+      /* Now update the query structure and obtain the sinks for the */
+      /* two trapezoids */ 
+      
+      i1 = newnode();		/* Upper trapezoid sink */
+      i2 = newnode();		/* Lower trapezoid sink */
+      sk = tr[tu].sink;
+      
+      qs[sk].nodetype = T_Y;
+      qs[sk].yval = s.v0;
+      qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
+      qs[sk].left = i2;
+      qs[sk].right = i1;
+
+      qs[i1].nodetype = T_SINK;
+      qs[i1].trnum = tu;
+      qs[i1].parent = sk;
+
+      qs[i2].nodetype = T_SINK;
+      qs[i2].trnum = tl;
+      qs[i2].parent = sk;
+
+      tr[tu].sink = i1;
+      tr[tl].sink = i2;
+      tfirst = tl;
+    }
+  else				/* v0 already present */
+    {       /* Get the topmost intersecting trapezoid */
+      tfirst = locate_endpoint(&amp;s.v0, &amp;s.v1, s.root0);
+      tritop = 1;
+    }
+
+
+  if ((is_swapped) ? !inserted(segnum, FIRSTPT) :
+       !inserted(segnum, LASTPT))     /* insert v1 in the tree */
+    {
+      int tmp_d;
+
+      tu = locate_endpoint(&amp;s.v1, &amp;s.v0, s.root1);
+
+      tl = newtrap();		/* tl is the new lower trapezoid */
+      tr[tl].state = ST_VALID;
+      tr[tl] = tr[tu];
+      tr[tu].lo.y = tr[tl].hi.y = s.v1.y;
+      tr[tu].lo.x = tr[tl].hi.x = s.v1.x;
+      tr[tu].d0 = tl;      
+      tr[tu].d1 = 0;
+      tr[tl].u0 = tu;
+      tr[tl].u1 = 0;
+
+      if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
+	tr[tmp_d].u0 = tl;
+      if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
+	tr[tmp_d].u1 = tl;
+
+      if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
+	tr[tmp_d].u0 = tl;
+      if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
+	tr[tmp_d].u1 = tl;
+      
+      /* Now update the query structure and obtain the sinks for the */
+      /* two trapezoids */ 
+      
+      i1 = newnode();		/* Upper trapezoid sink */
+      i2 = newnode();		/* Lower trapezoid sink */
+      sk = tr[tu].sink;
+      
+      qs[sk].nodetype = T_Y;
+      qs[sk].yval = s.v1;
+      qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
+      qs[sk].left = i2;
+      qs[sk].right = i1;
+
+      qs[i1].nodetype = T_SINK;
+      qs[i1].trnum = tu;
+      qs[i1].parent = sk;
+
+      qs[i2].nodetype = T_SINK;
+      qs[i2].trnum = tl;
+      qs[i2].parent = sk;
+
+      tr[tu].sink = i1;
+      tr[tl].sink = i2;
+      tlast = tu;
+    }
+  else				/* v1 already present */
+    {       /* Get the lowermost intersecting trapezoid */
+      tlast = locate_endpoint(&amp;s.v1, &amp;s.v0, s.root1);
+      tribot = 1;
+    }
+  
+  /* Thread the segment into the query tree creating a new X-node */
+  /* First, split all the trapezoids which are intersected by s into */
+  /* two */
+
+  t = tfirst;			/* topmost trapezoid */
+  
+  while ((t &gt; 0) &amp;&amp; 
+	 _greater_than_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo))
+				/* traverse from top to bot */
+    {
+      int t_sav, tn_sav;
+      sk = tr[t].sink;
+      i1 = newnode();		/* left trapezoid sink */
+      i2 = newnode();		/* right trapezoid sink */
+      
+      qs[sk].nodetype = T_X;
+      qs[sk].segnum = segnum;
+      qs[sk].left = i1;
+      qs[sk].right = i2;
+
+      qs[i1].nodetype = T_SINK;	/* left trapezoid (use existing one) */
+      qs[i1].trnum = t;
+      qs[i1].parent = sk;
+
+      qs[i2].nodetype = T_SINK;	/* right trapezoid (allocate new) */
+      qs[i2].trnum = tn = newtrap();
+      tr[tn].state = ST_VALID;
+      qs[i2].parent = sk;
+
+      if (t == tfirst)
+	tfirstr = tn;
+      if (_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo))
+	tlastr = tn;
+
+      tr[tn] = tr[t];
+      tr[t].sink = i1;
+      tr[tn].sink = i2;
+      t_sav = t;
+      tn_sav = tn;
+
+      /* error */
+
+      if ((tr[t].d0 &lt;= 0) &amp;&amp; (tr[t].d1 &lt;= 0)) /* case cannot arise */
+	{
+      errs(&quot;sei:add_segment()&quot;,&quot;error&quot;);
+	  break;
+	}
+      
+      /* only one trapezoid below. partition t into two and make the */
+      /* two resulting trapezoids t and tn as the upper neighbours of */
+      /* the sole lower trapezoid */
+      
+      else if ((tr[t].d0 &gt; 0) &amp;&amp; (tr[t].d1 &lt;= 0))
+	{			/* Only one trapezoid below */
+	  if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0))
+	    {			/* continuation of a chain from abv. */
+	      if (tr[t].usave &gt; 0) /* three upper neighbours */
+		{
+		  if (tr[t].uside == S_LEFT)
+		    {
+		      tr[tn].u0 = tr[t].u1;
+		      tr[t].u1 = -1;
+		      tr[tn].u1 = tr[t].usave;
+		      
+		      tr[tr[t].u0].d0 = t;
+		      tr[tr[tn].u0].d0 = tn;
+		      tr[tr[tn].u1].d0 = tn;
+		    }
+		  else		/* intersects in the right */
+		    {
+		      tr[tn].u1 = -1;
+		      tr[tn].u0 = tr[t].u1;
+		      tr[t].u1 = tr[t].u0;
+		      tr[t].u0 = tr[t].usave;
+
+		      tr[tr[t].u0].d0 = t;
+		      tr[tr[t].u1].d0 = t;
+		      tr[tr[tn].u0].d0 = tn;		      
+		    }
+		  
+		  tr[t].usave = tr[tn].usave = 0;
+		}
+	      else		/* No usave.... simple case */
+		{
+		  tr[tn].u0 = tr[t].u1;
+		  tr[t].u1 = tr[tn].u1 = -1;
+		  tr[tr[tn].u0].d0 = tn;
+		}
+	    }
+	  else 
+	    {			/* fresh seg. or upward cusp */
+	      int tmp_u = tr[t].u0;
+	      int td0, td1;
+	      if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp; 
+		  ((td1 = tr[tmp_u].d1) &gt; 0))
+		{		/* upward cusp */
+		  if ((tr[td0].rseg &gt; 0) &amp;&amp;
+		      !is_left_of(tr[td0].rseg, &amp;s.v1))
+		    {
+		      tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
+		      tr[tr[tn].u0].d1 = tn;
+		    }
+		  else		/* cusp going leftwards */
+		    { 
+		      tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
+		      tr[tr[t].u0].d0 = t;
+		    }
+		}
+	      else		/* fresh segment */
+		{
+		  tr[tr[t].u0].d0 = t;
+		  tr[tr[t].u0].d1 = tn;
+		}	      
+	    }
+	  
+	  if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp; 
+	      FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot)
+	    {		/* bottom forms a triangle */
+
+	      if (is_swapped)	
+		tmptriseg = seg[segnum].prev;
+	      else
+		tmptriseg = seg[segnum].next;
+	      
+	      if ((tmptriseg &gt; 0) &amp;&amp; is_left_of(tmptriseg, &amp;s.v0))
+		{
+				/* L-R downward cusp */
+		  tr[tr[t].d0].u0 = t;
+		  tr[tn].d0 = tr[tn].d1 = -1;
+		}
+	      else
+		{
+				/* R-L downward cusp */
+		  tr[tr[tn].d0].u1 = tn;
+		  tr[t].d0 = tr[t].d1 = -1;
+		}
+	    }
+	  else
+	    {
+	      if ((tr[tr[t].d0].u0 &gt; 0) &amp;&amp; (tr[tr[t].d0].u1 &gt; 0))
+		{
+		  if (tr[tr[t].d0].u0 == t) /* passes thru LHS */
+		    {
+		      tr[tr[t].d0].usave = tr[tr[t].d0].u1;
+		      tr[tr[t].d0].uside = S_LEFT;
+		    }
+		  else
+		    {
+		      tr[tr[t].d0].usave = tr[tr[t].d0].u0;
+		      tr[tr[t].d0].uside = S_RIGHT;
+		    }		    
+		}
+	      tr[tr[t].d0].u0 = t;
+	      tr[tr[t].d0].u1 = tn;
+	    }
+	  
+	  t = tr[t].d0;
+	}
+
+
+      else if ((tr[t].d0 &lt;= 0) &amp;&amp; (tr[t].d1 &gt; 0))
+	{			/* Only one trapezoid below */
+	  if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0))
+	    {			/* continuation of a chain from abv. */
+	      if (tr[t].usave &gt; 0) /* three upper neighbours */
+		{
+		  if (tr[t].uside == S_LEFT)
+		    {
+		      tr[tn].u0 = tr[t].u1;
+		      tr[t].u1 = -1;
+		      tr[tn].u1 = tr[t].usave;
+		      
+		      tr[tr[t].u0].d0 = t;
+		      tr[tr[tn].u0].d0 = tn;
+		      tr[tr[tn].u1].d0 = tn;
+		    }
+		  else		/* intersects in the right */
+		    {
+		      tr[tn].u1 = -1;
+		      tr[tn].u0 = tr[t].u1;
+		      tr[t].u1 = tr[t].u0;
+		      tr[t].u0 = tr[t].usave;
+
+		      tr[tr[t].u0].d0 = t;
+		      tr[tr[t].u1].d0 = t;
+		      tr[tr[tn].u0].d0 = tn;		      
+		    }
+		  
+		  tr[t].usave = tr[tn].usave = 0;
+		}
+	      else		/* No usave.... simple case */
+		{
+		  tr[tn].u0 = tr[t].u1;
+		  tr[t].u1 = tr[tn].u1 = -1;
+		  tr[tr[tn].u0].d0 = tn;
+		}
+	    }
+	  else 
+	    {			/* fresh seg. or upward cusp */
+	      int tmp_u = tr[t].u0;
+	      int td0, td1;
+	      if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp; 
+		  ((td1 = tr[tmp_u].d1) &gt; 0))
+		{		/* upward cusp */
+		  if ((tr[td0].rseg &gt; 0) &amp;&amp;
+		      !is_left_of(tr[td0].rseg, &amp;s.v1))
+		    {
+		      tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
+		      tr[tr[tn].u0].d1 = tn;
+		    }
+		  else 
+		    {
+		      tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
+		      tr[tr[t].u0].d0 = t;
+		    }
+		}
+	      else		/* fresh segment */
+		{
+		  tr[tr[t].u0].d0 = t;
+		  tr[tr[t].u0].d1 = tn;
+		}
+	    }
+	  
+	  if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp; 
+	      FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot)
+	    {		/* bottom forms a triangle */
+
+	      if (is_swapped)	
+			tmptriseg = seg[segnum].prev;
+	      else
+			tmptriseg = seg[segnum].next;
+
+	      if ((tmpseg &gt; 0) &amp;&amp; is_left_of(tmpseg, &amp;s.v0))
+		{
+		  /* L-R downward cusp */
+		  tr[tr[t].d1].u0 = t;
+		  tr[tn].d0 = tr[tn].d1 = -1;
+		}
+	      else
+		{
+		  /* R-L downward cusp */
+		  tr[tr[tn].d1].u1 = tn;
+		  tr[t].d0 = tr[t].d1 = -1;
+		}
+	    }		
+	  else
+	    {
+	      if ((tr[tr[t].d1].u0 &gt; 0) &amp;&amp; (tr[tr[t].d1].u1 &gt; 0))
+		{
+		  if (tr[tr[t].d1].u0 == t) /* passes thru LHS */
+		    {
+		      tr[tr[t].d1].usave = tr[tr[t].d1].u1;
+		      tr[tr[t].d1].uside = S_LEFT;
+		    }
+		  else
+		    {
+		      tr[tr[t].d1].usave = tr[tr[t].d1].u0;
+		      tr[tr[t].d1].uside = S_RIGHT;
+		    }		    
+		}
+	      tr[tr[t].d1].u0 = t;
+	      tr[tr[t].d1].u1 = tn;
+	    }
+	  
+	  t = tr[t].d1;
+	}
+
+      /* two trapezoids below. Find out which one is intersected by */
+      /* this segment and proceed down that one */
+      
+      else
+	{
+	  double y0, yt;
+	  point_t tmppt;
+	  int tnext, i_d0, i_d1;
+	  tmpseg = tr[tr[t].d0].rseg;
+
+	  i_d0 = i_d1 = FALSE;
+	  if (FP_EQUAL(tr[t].lo.y, s.v0.y))
+	    {
+	      if (tr[t].lo.x &gt; s.v0.x)
+		i_d0 = TRUE;
+	      else
+		i_d1 = TRUE;
+	    }
+	  else
+	    {
+	      tmppt.y = y0 = tr[t].lo.y;
+	      yt = (y0 - s.v0.y)/(s.v1.y - s.v0.y);
+	      tmppt.x = s.v0.x + yt * (s.v1.x - s.v0.x);
+	      
+	      if (_less_than(&amp;tmppt, &amp;tr[t].lo))
+		i_d0 = TRUE;
+	      else
+		i_d1 = TRUE;
+	    }
+	  
+	  /* check continuity from the top so that the lower-neighbour */
+	  /* values are properly filled for the upper trapezoid */
+
+	  if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0))
+	    {			/* continuation of a chain from abv. */
+	      if (tr[t].usave &gt; 0) /* three upper neighbours */
+		{
+		  if (tr[t].uside == S_LEFT)
+		    {
+		      tr[tn].u0 = tr[t].u1;
+		      tr[t].u1 = -1;
+		      tr[tn].u1 = tr[t].usave;
+		      
+		      tr[tr[t].u0].d0 = t;
+		      tr[tr[tn].u0].d0 = tn;
+		      tr[tr[tn].u1].d0 = tn;
+		    }
+		  else		/* intersects in the right */
+		    {
+		      tr[tn].u1 = -1;
+		      tr[tn].u0 = tr[t].u1;
+		      tr[t].u1 = tr[t].u0;
+		      tr[t].u0 = tr[t].usave;
+
+		      tr[tr[t].u0].d0 = t;
+		      tr[tr[t].u1].d0 = t;
+		      tr[tr[tn].u0].d0 = tn;		      
+		    }
+		  
+		  tr[t].usave = tr[tn].usave = 0;
+		}
+	      else		/* No usave.... simple case */
+		{
+		  tr[tn].u0 = tr[t].u1;
+		  tr[tn].u1 = -1;
+		  tr[t].u1 = -1;
+		  tr[tr[tn].u0].d0 = tn;
+		}
+	    }
+	  else 
+	    {			/* fresh seg. or upward cusp */
+	      int tmp_u = tr[t].u0;
+	      int td0, td1;
+	      if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp; 
+		  ((td1 = tr[tmp_u].d1) &gt; 0))
+		{		/* upward cusp */
+		  if ((tr[td0].rseg &gt; 0) &amp;&amp;
+		      !is_left_of(tr[td0].rseg, &amp;s.v1))
+		    {
+		      tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
+		      tr[tr[tn].u0].d1 = tn;
+		    }
+		  else 
+		    {
+		      tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
+		      tr[tr[t].u0].d0 = t;
+		    }
+		}
+	      else		/* fresh segment */
+		{
+		  tr[tr[t].u0].d0 = t;
+		  tr[tr[t].u0].d1 = tn;
+		}
+	    }
+	  
+	  if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp; 
+	      FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot)
+	    {
+	      /* this case arises only at the lowest trapezoid.. i.e.
+		 tlast, if the lower endpoint of the segment is
+		 already inserted in the structure */
+	      
+	      tr[tr[t].d0].u0 = t;
+	      tr[tr[t].d0].u1 = -1;
+	      tr[tr[t].d1].u0 = tn;
+	      tr[tr[t].d1].u1 = -1;
+
+	      tr[tn].d0 = tr[t].d1;
+	      tr[t].d1 = tr[tn].d1 = -1;
+	      
+	      tnext = tr[t].d1;	      
+	    }
+	  else if (i_d0)
+				/* intersecting d0 */
+	    {
+	      tr[tr[t].d0].u0 = t;
+	      tr[tr[t].d0].u1 = tn;
+	      tr[tr[t].d1].u0 = tn;
+	      tr[tr[t].d1].u1 = -1;
+	      
+	      /* new code to determine the bottom neighbours of the */
+	      /* newly partitioned trapezoid */
+	      
+	      tr[t].d1 = -1;
+
+	      tnext = tr[t].d0;
+	    }
+	  else			/* intersecting d1 */
+	    {
+	      tr[tr[t].d0].u0 = t;
+	      tr[tr[t].d0].u1 = -1;
+	      tr[tr[t].d1].u0 = t;
+	      tr[tr[t].d1].u1 = tn;
+
+	      /* new code to determine the bottom neighbours of the */
+	      /* newly partitioned trapezoid */
+	      
+	      tr[tn].d0 = tr[t].d1;
+	      tr[tn].d1 = -1;
+	      
+	      tnext = tr[t].d1;
+	    }	    
+	  
+	  t = tnext;
+	}
+      
+      tr[t_sav].rseg = tr[tn_sav].lseg  = segnum;
+    } /* end-while */
+  
+  /* Now combine those trapezoids which share common segments. We can */
+  /* use the pointers to the parent to connect these together. This */
+  /* works only because all these new trapezoids have been formed */
+  /* due to splitting by the segment, and hence have only one parent */
+
+  tfirstl = tfirst; 
+  tlastl = tlast;
+  merge_trapezoids(segnum, tfirstl, tlastl, S_LEFT);
+  merge_trapezoids(segnum, tfirstr, tlastr, S_RIGHT);
+
+  seg[segnum].is_inserted = TRUE;
+  return 0;
+}
+
+
+/* Update the roots stored for each of the endpoints of the segment.
+ * This is done to speed up the location-query for the endpoint when
+ * the segment is inserted into the trapezoidation subsequently
+ */
+static int find_new_roots(segnum)
+     int segnum;
+{
+  segment_t *s = &amp;seg[segnum];
+  
+  if (s-&gt;is_inserted)
+    return 0;
+
+  s-&gt;root0 = locate_endpoint(&amp;s-&gt;v0, &amp;s-&gt;v1, s-&gt;root0);
+  s-&gt;root0 = tr[s-&gt;root0].sink;
+
+  s-&gt;root1 = locate_endpoint(&amp;s-&gt;v1, &amp;s-&gt;v0, s-&gt;root1);
+  s-&gt;root1 = tr[s-&gt;root1].sink;  
+  return 0;
+}
+
+
+/* Main routine to perform trapezoidation */
+int construct_trapezoids(nseg)
+     int nseg;
+{
+  register int i;
+  int root, h;
+  
+  /* Add the first segment and get the query structure and trapezoid */
+  /* list initialised */
+
+  root = init_query_structure(choose_segment());
+
+  for (i = 1; i &lt;= nseg; i++)
+    seg[i].root0 = seg[i].root1 = root;
+  
+  for (h = 1; h &lt;= math_logstar_n(nseg); h++)
+    {
+      for (i = math_N(nseg, h -1) + 1; i &lt;= math_N(nseg, h); i++)
+	add_segment(choose_segment());
+      
+      /* Find a new root for each of the segment endpoints */
+      for (i = 1; i &lt;= nseg; i++)
+	find_new_roots(i);
+    }
+  
+  for (i = math_N(nseg, math_logstar_n(nseg)) + 1; i &lt;= nseg; i++)
+    add_segment(choose_segment());
+
+  return 0;
+}
+
+

Added: trunk/libs3d/sei_interface.h
===================================================================
--- trunk/libs3d/sei_interface.h	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/sei_interface.h	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,49 @@
+/*
+ * sei_interface.h
+ * 
+ * Copyright (C) 2006 Simon Wunderlich
+ * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
+ * for public domain: 
+ * &lt;snip&gt;
+ *
+ * This code is in the public domain. Specifically, we give to the public
+ * domain all rights for future licensing of the source code, all resale
+ * rights, and all publishing rights.
+ *
+ * UNC-CH GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE SOFTWARE
+ * AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION, WARRANTY
+ * OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *
+ *                                 - Atul Narkhede (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">narkhede at cs.unc.edu</A>)
+ * &lt;/snip&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#ifndef __interface_h
+#define __interface_h
+
+#define TRUE 1
+#define FALSE 0
+
+extern int sei_triangulate_polygon(int, int *, double (*)[2], int (*)[3]);
+extern int is_point_inside_polygon(double *);
+
+#endif /* __interface_h */

Added: trunk/libs3d/sei_misc.c
===================================================================
--- trunk/libs3d/sei_misc.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/sei_misc.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,111 @@
+/*
+ * sei_misc.c
+ * 
+ * Copyright (C) 2006 Simon Wunderlich
+ * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
+ * for public domain: 
+ * &lt;snip&gt;
+ *
+ * This code is in the public domain. Specifically, we give to the public
+ * domain all rights for future licensing of the source code, all resale
+ * rights, and all publishing rights.
+ *
+ * UNC-CH GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE SOFTWARE
+ * AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION, WARRANTY
+ * OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *
+ *                                 - Atul Narkhede (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">narkhede at cs.unc.edu</A>)
+ * &lt;/snip&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &lt;sei_triangulate.h&gt;
+#include &lt;sys/time.h&gt;
+#include &lt;math.h&gt;
+
+
+static int choose_idx;
+static int permute[SEGSIZE];
+double mlog2(double x) {
+  return log(x)/log(2);
+}
+
+/* Generate a random permutation of the segments 1..n */
+int generate_random_ordering(n)
+     int n;
+{
+  struct timeval tval;
+  register int i;
+  int m, st[SEGSIZE], *p;
+  
+  choose_idx = 1;
+  gettimeofday(&amp;tval, NULL);
+  srand48(tval.tv_sec);
+
+  for (i = 0; i &lt;= n; i++)
+    st[i] = i;
+
+  p = st;
+  for (i = 1; i &lt;= n; i++, p++)
+    {
+      m = lrand48() % (n + 1 - i) + 1;
+      permute[i] = p[m];
+      if (m != 1)
+	p[m] = p[1];
+    }
+  return 0;
+}
+
+  
+/* Return the next segment in the generated random ordering of all the */
+/* segments in S */
+int choose_segment()
+{
+  errds(VLOW,&quot;sei:choose_segment()&quot;,&quot;%d&quot;, permute[choose_idx]);
+  return permute[choose_idx++];
+}
+
+/* Get log*n for given n */
+int math_logstar_n(n)
+     int n;
+{
+  register int i;
+  double v;
+  
+  for (i = 0, v = (double) n; v &gt;= 1; i++)
+    v = mlog2(v);
+  
+  return (i - 1);
+}
+  
+
+int math_N(n, h)
+     int n;
+     int h;
+{
+  register int i;
+  double v;
+
+  for (i = 0, v = (int) n; i &lt; h; i++)
+    v = mlog2(v);
+  
+  return (int) ceil((double) 1.0*n/v);
+}

Added: trunk/libs3d/sei_monotone.c
===================================================================
--- trunk/libs3d/sei_monotone.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/sei_monotone.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,759 @@
+/*
+ * sei_monotone.c
+ * 
+ * Copyright (C) 2006 Simon Wunderlich
+ * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
+ * for public domain: 
+ * &lt;snip&gt;
+ *
+ * This code is in the public domain. Specifically, we give to the public
+ * domain all rights for future licensing of the source code, all resale
+ * rights, and all publishing rights.
+ *
+ * UNC-CH GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE SOFTWARE
+ * AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION, WARRANTY
+ * OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *
+ *                                 - Atul Narkhede (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">narkhede at cs.unc.edu</A>)
+ * &lt;/snip&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &lt;sei_triangulate.h&gt;
+#include &lt;math.h&gt;
+#include &lt;string.h&gt; /* memset() */
+
+#define CROSS_SINE(v0, v1) ((v0).x * (v1).y - (v1).x * (v0).y)
+#define LENGTH(v0) (sqrt((v0).x * (v0).x + (v0).y * (v0).y))
+
+static monchain_t mchain[TRSIZE]; /* Table to hold all the monotone */
+				  /* polygons . Each monotone polygon */
+				  /* is a circularly linked list */
+
+static vertexchain_t vert[SEGSIZE]; /* chain init. information. This */
+				    /* is used to decide which */
+				    /* monotone polygon to split if */
+				    /* there are several other */
+				    /* polygons touching at the same */
+				    /* vertex  */
+
+static int mon[SEGSIZE];	/* contains position of any vertex in */
+				/* the monotone chain for the polygon */
+static int visited[TRSIZE];
+static int chain_idx, op_idx, mon_idx;
+
+
+static int triangulate_single_polygon(int, int, int, int (*)[3]);
+static int traverse_polygon(int, int, int, int);
+
+/* Function returns TRUE if the trapezoid lies inside the polygon */
+static int inside_polygon(t)
+     trap_t *t;
+{
+  int rseg = t-&gt;rseg;
+
+  if (t-&gt;state == ST_INVALID)
+    return 0;
+
+  if ((t-&gt;lseg &lt;= 0) || (t-&gt;rseg &lt;= 0))
+    return 0;
+  
+  if (((t-&gt;u0 &lt;= 0) &amp;&amp; (t-&gt;u1 &lt;= 0)) || 
+      ((t-&gt;d0 &lt;= 0) &amp;&amp; (t-&gt;d1 &lt;= 0))) /* triangle */
+    return (_greater_than(&amp;seg[rseg].v1, &amp;seg[rseg].v0));
+  
+  return 0;
+}
+
+
+/* return a new mon structure from the table */
+static int newmon()
+{
+  return ++mon_idx;
+}
+
+
+/* return a new chain element from the table */
+static int new_chain_element()
+{
+  return ++chain_idx;
+}
+
+
+static double get_angle(vp0, vpnext, vp1)
+     point_t *vp0;
+     point_t *vpnext;
+     point_t *vp1;
+{
+  point_t v0, v1;
+  
+  v0.x = vpnext-&gt;x - vp0-&gt;x;
+  v0.y = vpnext-&gt;y - vp0-&gt;y;
+
+  v1.x = vp1-&gt;x - vp0-&gt;x;
+  v1.y = vp1-&gt;y - vp0-&gt;y;
+
+  if (CROSS_SINE(v0, v1) &gt;= 0)	/* sine is positive */
+    return DOT(v0, v1)/LENGTH(v0)/LENGTH(v1);
+  else
+    return (-1.0 * DOT(v0, v1)/LENGTH(v0)/LENGTH(v1) - 2);
+}
+
+
+/* (v0, v1) is the new diagonal to be added to the polygon. Find which */
+/* chain to use and return the positions of v0 and v1 in p and q */ 
+static int get_vertex_positions(v0, v1, ip, iq)
+     int v0;
+     int v1;
+     int *ip;
+     int *iq;
+{
+  vertexchain_t *vp0, *vp1;
+  register int i;
+  double angle, temp;
+  int tp, tq;
+
+  tp = tq = 0;
+  
+  vp0 = &amp;vert[v0];
+  vp1 = &amp;vert[v1];
+  
+  /* p is identified as follows. Scan from (v0, v1) rightwards till */
+  /* you hit the first segment starting from v0. That chain is the */
+  /* chain of our interest */
+  
+  angle = -4.0;
+  for (i = 0; i &lt; 4; i++)
+    {
+      if (vp0-&gt;vnext[i] &lt;= 0)
+	continue;
+      if ((temp = get_angle(&amp;vp0-&gt;pt, &amp;(vert[vp0-&gt;vnext[i]].pt), 
+			    &amp;vp1-&gt;pt)) &gt; angle)
+	{
+	  angle = temp;
+	  tp = i;
+	}
+    }
+
+  *ip = tp;
+
+  /* Do similar actions for q */
+
+  angle = -4.0;
+  for (i = 0; i &lt; 4; i++)
+    {
+      if (vp1-&gt;vnext[i] &lt;= 0)
+	continue;      
+      if ((temp = get_angle(&amp;vp1-&gt;pt, &amp;(vert[vp1-&gt;vnext[i]].pt), 
+			    &amp;vp0-&gt;pt)) &gt; angle)
+	{
+	  angle = temp;
+	  tq = i;
+	}
+    }
+
+  *iq = tq;
+
+  return 0;
+}
+
+  
+/* v0 and v1 are specified in anti-clockwise order with respect to 
+ * the current monotone polygon mcur. Split the current polygon into 
+ * two polygons using the diagonal (v0, v1) 
+ */
+static int make_new_monotone_poly(mcur, v0, v1)
+     int mcur;
+     int v0;
+     int v1;
+{
+  int p, q, ip, iq;
+  int mnew = newmon();
+  int i, j, nf0, nf1;
+  vertexchain_t *vp0, *vp1;
+  
+  vp0 = &amp;vert[v0];
+  vp1 = &amp;vert[v1];
+
+  get_vertex_positions(v0, v1, &amp;ip, &amp;iq);
+
+  p = vp0-&gt;vpos[ip];
+  q = vp1-&gt;vpos[iq];
+
+  /* At this stage, we have got the positions of v0 and v1 in the */
+  /* desired chain. Now modify the linked lists */
+
+  i = new_chain_element();	/* for the new list */
+  j = new_chain_element();
+
+  mchain[i].vnum = v0;
+  mchain[j].vnum = v1;
+
+  mchain[i].next = mchain[p].next;
+  mchain[mchain[p].next].prev = i;
+  mchain[i].prev = j;
+  mchain[j].next = i;
+  mchain[j].prev = mchain[q].prev;
+  mchain[mchain[q].prev].next = j;
+
+  mchain[p].next = q;
+  mchain[q].prev = p;
+
+  nf0 = vp0-&gt;nextfree;
+  nf1 = vp1-&gt;nextfree;
+
+  vp0-&gt;vnext[ip] = v1;
+
+  vp0-&gt;vpos[nf0] = i;
+  vp0-&gt;vnext[nf0] = mchain[mchain[i].next].vnum;
+  vp1-&gt;vpos[nf1] = j;
+  vp1-&gt;vnext[nf1] = v0;
+
+  vp0-&gt;nextfree++;
+  vp1-&gt;nextfree++;
+
+  errds(VLOW,&quot;sei:make_poly()&quot;,&quot;: mcur = %d, (v0, v1) = (%d, %d)&quot;, mcur, v0, v1);
+  errds(VLOW,&quot;sei:make_poly()&quot;,&quot;next posns = (p, q) = (%d, %d)&quot;, p, q);
+
+  mon[mcur] = p;
+  mon[mnew] = i;
+  return mnew;
+}
+
+/* Main routine to get monotone polygons from the trapezoidation of 
+ * the polygon.
+ */
+
+int monotonate_trapezoids(n)
+     int n;
+{
+  register int i;
+  int tr_start;
+
+  memset((void *)vert, 0, sizeof(vert));
+  memset((void *)visited, 0, sizeof(visited));
+  memset((void *)mchain, 0, sizeof(mchain));
+  memset((void *)mon, 0, sizeof(mon));
+  
+  /* First locate a trapezoid which lies inside the polygon */
+  /* and which is triangular */
+  for (i = 0; i &lt; TRSIZE; i++)
+    if (inside_polygon(&amp;tr[i]))
+      break;
+  tr_start = i;
+  
+  /* Initialise the mon data-structure and start spanning all the */
+  /* trapezoids within the polygon */
+
+#if 0
+  for (i = 1; i &lt;= n; i++)
+    {
+      mchain[i].prev = i - 1;
+      mchain[i].next = i + 1;
+      mchain[i].vnum = i;
+      vert[i].pt = seg[i].v0;
+      vert[i].vnext[0] = i + 1;	/* next vertex */
+      vert[i].vpos[0] = i;	/* locn. of next vertex */
+      vert[i].nextfree = 1;
+    }
+  mchain[1].prev = n;
+  mchain[n].next = 1;
+  vert[n].vnext[0] = 1;
+  vert[n].vpos[0] = n;
+  chain_idx = n;
+  mon_idx = 0;
+  mon[0] = 1;			/* position of any vertex in the first */
+				/* chain  */
+
+#else
+
+  for (i = 1; i &lt;= n; i++)
+    {
+      mchain[i].prev = seg[i].prev;
+      mchain[i].next = seg[i].next;
+      mchain[i].vnum = i;
+      vert[i].pt = seg[i].v0;
+      vert[i].vnext[0] = seg[i].next; /* next vertex */
+      vert[i].vpos[0] = i;	/* locn. of next vertex */
+      vert[i].nextfree = 1;
+    }
+
+  chain_idx = n;
+  mon_idx = 0;
+  mon[0] = 1;			/* position of any vertex in the first */
+				/* chain  */
+
+#endif
+  
+  /* traverse the polygon */
+  if (tr[tr_start].u0 &gt; 0)
+    traverse_polygon(0, tr_start, tr[tr_start].u0, TR_FROM_UP);
+  else if (tr[tr_start].d0 &gt; 0)
+    traverse_polygon(0, tr_start, tr[tr_start].d0, TR_FROM_DN);
+  
+  /* return the number of polygons created */
+  return newmon();
+}
+
+
+/* recursively visit all the trapezoids */
+static int traverse_polygon(mcur, trnum, from, dir)
+     int mcur;
+     int trnum;
+     int from;
+     int dir;
+{
+  trap_t *t = &amp;tr[trnum];
+  int mnew;
+  int v0, v1;
+  int retval = -1;
+  int do_switch = FALSE;
+
+  if ((trnum &lt;= 0) || visited[trnum])
+    return 0;
+
+  visited[trnum] = TRUE;
+  
+  /* We have much more information available here. */
+  /* rseg: goes upwards   */
+  /* lseg: goes downwards */
+
+  /* Initially assume that dir = TR_FROM_DN (from the left) */
+  /* Switch v0 and v1 if necessary afterwards */
+
+
+  /* special cases for triangles with cusps at the opposite ends. */
+  /* take care of this first */
+  if ((t-&gt;u0 &lt;= 0) &amp;&amp; (t-&gt;u1 &lt;= 0))
+    {
+      if ((t-&gt;d0 &gt; 0) &amp;&amp; (t-&gt;d1 &gt; 0)) /* downward opening triangle */
+	{
+	  v0 = tr[t-&gt;d1].lseg;
+	  v1 = t-&gt;lseg;
+	  if (from == t-&gt;d1)
+	    {
+	      do_switch = TRUE;
+	      mnew = make_new_monotone_poly(mcur, v1, v0);
+	      traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+	      traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);	    
+	    }
+	  else
+	    {
+	      mnew = make_new_monotone_poly(mcur, v0, v1);
+	      traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+	      traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+	    }
+	}
+      else
+	{
+	  retval = SP_NOSPLIT;	/* Just traverse all neighbours */
+	  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+	  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+	  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+	  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+	}
+    }
+  
+  else if ((t-&gt;d0 &lt;= 0) &amp;&amp; (t-&gt;d1 &lt;= 0))
+    {
+      if ((t-&gt;u0 &gt; 0) &amp;&amp; (t-&gt;u1 &gt; 0)) /* upward opening triangle */
+	{
+	  v0 = t-&gt;rseg;
+	  v1 = tr[t-&gt;u0].rseg;
+	  if (from == t-&gt;u1)
+	    {
+	      do_switch = TRUE;
+	      mnew = make_new_monotone_poly(mcur, v1, v0);
+	      traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+	      traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);	    
+	    }
+	  else
+	    {
+	      mnew = make_new_monotone_poly(mcur, v0, v1);
+	      traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+	      traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+	    }
+	}
+      else
+	{
+	  retval = SP_NOSPLIT;	/* Just traverse all neighbours */
+	  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+	  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+	  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+	  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+	}
+    }
+  
+  else if ((t-&gt;u0 &gt; 0) &amp;&amp; (t-&gt;u1 &gt; 0)) 
+    {
+      if ((t-&gt;d0 &gt; 0) &amp;&amp; (t-&gt;d1 &gt; 0)) /* downward + upward cusps */
+	{
+	  v0 = tr[t-&gt;d1].lseg;
+	  v1 = tr[t-&gt;u0].rseg;
+	  retval = SP_2UP_2DN;
+	  if (((dir == TR_FROM_DN) &amp;&amp; (t-&gt;d1 == from)) ||
+	      ((dir == TR_FROM_UP) &amp;&amp; (t-&gt;u1 == from)))
+	    {
+	      do_switch = TRUE;
+	      mnew = make_new_monotone_poly(mcur, v1, v0);
+	      traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+	      traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+	      traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+	      traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+	    }
+	  else
+	    {
+	      mnew = make_new_monotone_poly(mcur, v0, v1);
+	      traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+	      traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+	      traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+	      traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);	      
+	    }
+	}
+      else			/* only downward cusp */
+	{
+	  if (_equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;lseg].v1))
+	    {
+	      v0 = tr[t-&gt;u0].rseg;
+	      v1 = seg[t-&gt;lseg].next;
+
+	      retval = SP_2UP_LEFT;
+	      if ((dir == TR_FROM_UP) &amp;&amp; (t-&gt;u0 == from))
+		{
+		  do_switch = TRUE;
+		  mnew = make_new_monotone_poly(mcur, v1, v0);
+		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+		}
+	      else
+		{
+		  mnew = make_new_monotone_poly(mcur, v0, v1);
+		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+		}
+	    }
+	  else
+	    {
+	      v0 = t-&gt;rseg;
+	      v1 = tr[t-&gt;u0].rseg;	
+	      retval = SP_2UP_RIGHT;
+	      if ((dir == TR_FROM_UP) &amp;&amp; (t-&gt;u1 == from))
+		{
+		  do_switch = TRUE;
+		  mnew = make_new_monotone_poly(mcur, v1, v0);
+		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+		}
+	      else
+		{
+		  mnew = make_new_monotone_poly(mcur, v0, v1);
+		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+		}
+	    }
+	}
+    }
+  else if ((t-&gt;u0 &gt; 0) || (t-&gt;u1 &gt; 0)) /* no downward cusp */
+    {
+      if ((t-&gt;d0 &gt; 0) &amp;&amp; (t-&gt;d1 &gt; 0)) /* only upward cusp */
+	{
+	  if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;lseg].v0))
+	    {
+	      v0 = tr[t-&gt;d1].lseg;
+	      v1 = t-&gt;lseg;
+	      retval = SP_2DN_LEFT;
+	      if (!((dir == TR_FROM_DN) &amp;&amp; (t-&gt;d0 == from)))
+		{
+		  do_switch = TRUE;
+		  mnew = make_new_monotone_poly(mcur, v1, v0);
+		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+		}
+	      else
+		{
+		  mnew = make_new_monotone_poly(mcur, v0, v1);
+		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);	      
+		}
+	    }
+	  else
+	    {
+	      v0 = tr[t-&gt;d1].lseg;
+	      v1 = seg[t-&gt;rseg].next;
+
+	      retval = SP_2DN_RIGHT;	    
+	      if ((dir == TR_FROM_DN) &amp;&amp; (t-&gt;d1 == from))
+		{
+		  do_switch = TRUE;
+		  mnew = make_new_monotone_poly(mcur, v1, v0);
+		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+		}
+	      else
+		{
+		  mnew = make_new_monotone_poly(mcur, v0, v1);
+		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+		}
+	    }
+	}
+      else			/* no cusp */
+	{
+	  if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;lseg].v0) &amp;&amp;
+	      _equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;rseg].v0))
+	    {
+	      v0 = t-&gt;rseg;
+	      v1 = t-&gt;lseg;
+	      retval = SP_SIMPLE_LRDN;
+	      if (dir == TR_FROM_UP)
+		{
+		  do_switch = TRUE;
+		  mnew = make_new_monotone_poly(mcur, v1, v0);
+		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+		}
+	      else
+		{
+		  mnew = make_new_monotone_poly(mcur, v0, v1);
+		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+		}
+	    }
+	  else if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;rseg].v1) &amp;&amp;
+		   _equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;lseg].v1))
+	    {
+	      v0 = seg[t-&gt;rseg].next;
+	      v1 = seg[t-&gt;lseg].next;
+
+	      retval = SP_SIMPLE_LRUP;
+	      if (dir == TR_FROM_UP)
+		{
+		  do_switch = TRUE;
+		  mnew = make_new_monotone_poly(mcur, v1, v0);
+		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+		}
+	      else
+		{
+		  mnew = make_new_monotone_poly(mcur, v0, v1);
+		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+		}
+	    }
+	  else			/* no split possible */
+	    {
+	      retval = SP_NOSPLIT;
+	      traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+	      traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+	      traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+	      traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);	      	      
+	    }
+	}
+    }
+
+  return retval;
+}
+
+
+/* For each monotone polygon, find the ymax and ymin (to determine the */
+/* two y-monotone chains) and pass on this monotone polygon for greedy */
+/* triangulation. */
+/* Take care not to triangulate duplicate monotone polygons */
+
+int triangulate_monotone_polygons(nvert, nmonpoly, op)
+     int nvert;
+     int nmonpoly;
+     int op[][3];
+{
+  register int i;
+  point_t ymax, ymin;
+  int p, vfirst, posmax, posmin, v;
+  int vcount, processed;
+
+
+  op_idx = 0;
+  for (i = 0; i &lt; nmonpoly; i++)
+    {
+      vcount = 1;
+      processed = FALSE;
+      vfirst = mchain[mon[i]].vnum;
+      ymax = ymin = vert[vfirst].pt;
+      posmax = posmin = mon[i];
+      mchain[mon[i]].marked = TRUE;
+      p = mchain[mon[i]].next;
+      while ((v = mchain[p].vnum) != vfirst)
+	{
+	 if (mchain[p].marked)
+	   {
+	     processed = TRUE;
+	     break;		/* break from while */
+	   }
+	 else
+	   mchain[p].marked = TRUE;
+
+	  if (_greater_than(&amp;vert[v].pt, &amp;ymax))
+	    {
+	      ymax = vert[v].pt;
+	      posmax = p;
+	    }
+	  if (_less_than(&amp;vert[v].pt, &amp;ymin))
+	    {
+	      ymin = vert[v].pt;
+	      posmin = p;
+	    }
+	  p = mchain[p].next;
+	  vcount++;
+       }
+
+      if (processed)		/* Go to next polygon */
+	continue;
+      
+      if (vcount == 3)		/* already a triangle */
+	{
+	  op[op_idx][0] = mchain[p].vnum;
+	  op[op_idx][1] = mchain[mchain[p].next].vnum;
+	  op[op_idx][2] = mchain[mchain[p].prev].vnum;
+	  op_idx++;
+	}
+      else			/* triangulate the polygon */
+	{
+	  v = mchain[mchain[posmax].next].vnum;
+	  if (_equal_to(&amp;vert[v].pt, &amp;ymin))
+	    {			/* LHS is a single line */
+	      triangulate_single_polygon(nvert, posmax, TRI_LHS, op);
+	    }
+	  else
+	    triangulate_single_polygon(nvert, posmax, TRI_RHS, op);
+	}
+    }
+  
+  for (i = 0; i &lt; op_idx; i++)
+    errds(VLOW,&quot;sei:triangulate_monotone_polygons()&quot;,&quot;tri #%d: (%d, %d, %d)\n&quot;, i, op[i][0], op[i][1],
+	   op[i][2]);
+  return op_idx;
+}
+
+
+/* A greedy corner-cutting algorithm to triangulate a y-monotone 
+ * polygon in O(n) time.
+ * Joseph O-Rourke, Computational Geometry in C.
+ */
+static int triangulate_single_polygon(nvert, posmax, side, op)
+     int nvert;
+     int posmax;
+     int side;
+     int op[][3];
+{
+  register int v;
+  int rc[SEGSIZE], ri = 0;	/* reflex chain */
+  int endv, tmp, vpos;
+  
+  if (side == TRI_RHS)		/* RHS segment is a single segment */
+    {
+      rc[0] = mchain[posmax].vnum;
+      tmp = mchain[posmax].next;
+      rc[1] = mchain[tmp].vnum;
+      ri = 1;
+      
+      vpos = mchain[tmp].next;
+      v = mchain[vpos].vnum;
+      
+      if ((endv = mchain[mchain[posmax].prev].vnum) == 0)
+	endv = nvert;
+    }
+  else				/* LHS is a single segment */
+    {
+      tmp = mchain[posmax].next;
+      rc[0] = mchain[tmp].vnum;
+      tmp = mchain[tmp].next;
+      rc[1] = mchain[tmp].vnum;
+      ri = 1;
+
+      vpos = mchain[tmp].next;
+      v = mchain[vpos].vnum;
+
+      endv = mchain[posmax].vnum;
+    }
+  
+  while ((v != endv) || (ri &gt; 1))
+    {
+      if (ri &gt; 0)		/* reflex chain is non-empty */
+	{
+	  if (CROSS(vert[v].pt, vert[rc[ri - 1]].pt, 
+		    vert[rc[ri]].pt) &gt; 0)
+	    {			/* convex corner: cut if off */
+	      op[op_idx][0] = rc[ri - 1];
+	      op[op_idx][1] = rc[ri];
+	      op[op_idx][2] = v;
+	      op_idx++;	     
+	      ri--;
+	    }
+	  else		/* non-convex */
+	    {		/* add v to the chain */
+	      ri++;
+	      rc[ri] = v;
+	      vpos = mchain[vpos].next;
+	      v = mchain[vpos].vnum;
+	    }
+	}
+      else			/* reflex-chain empty: add v to the */
+	{			/* reflex chain and advance it  */
+	  rc[++ri] = v;
+	  vpos = mchain[vpos].next;
+	  v = mchain[vpos].vnum;
+	}
+    } /* end-while */
+  
+  /* reached the bottom vertex. Add in the triangle formed */
+  op[op_idx][0] = rc[ri - 1];
+  op[op_idx][1] = rc[ri];
+  op[op_idx][2] = v;
+  op_idx++;	     
+  ri--;
+  
+  return 0;
+}
+
+

Added: trunk/libs3d/sei_tri.c
===================================================================
--- trunk/libs3d/sei_tri.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/sei_tri.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,171 @@
+/*
+ * sei_tri.c
+ *
+ * Copyright (C) 2006 Simon Wunderlich
+ * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
+ * for public domain: 
+ * &lt;snip&gt;
+ *
+ * This code is in the public domain. Specifically, we give to the public
+ * domain all rights for future licensing of the source code, all resale
+ * rights, and all publishing rights.
+ *
+ * UNC-CH GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE SOFTWARE
+ * AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION, WARRANTY
+ * OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *
+ *                                 - Atul Narkhede (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">narkhede at cs.unc.edu</A>)
+ * &lt;/snip&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &lt;sei_triangulate.h&gt;
+#include &lt;sys/time.h&gt;
+#include &lt;string.h&gt; /* memset() */
+
+
+static int initialise(n)
+     int n;
+{
+  register int i;
+
+  for (i = 1; i &lt;= n; i++)
+    seg[i].is_inserted = FALSE;
+
+  generate_random_ordering(n);
+  
+  return 0;
+}
+
+/* Input specified as contours.
+ * Outer contour must be anti-clockwise.
+ * All inner contours must be clockwise.
+ *  
+ * Every contour is specified by giving all its points in order. No
+ * point shoud be repeated. i.e. if the outer contour is a square,
+ * only the four distinct endpoints shopudl be specified in order.
+ *  
+ * ncontours: #contours
+ * cntr: An array describing the number of points in each
+ *	 contour. Thus, cntr[i] = #points in the i'th contour.
+ * vertices: Input array of vertices. Vertices for each contour
+ *           immediately follow those for previous one. Array location
+ *           vertices[0] must NOT be used (i.e. i/p starts from
+ *           vertices[1] instead. The output triangles are
+ *	     specified  w.r.t. the indices of these vertices.
+ * triangles: Output array to hold triangles.
+ *  
+ * Enough space must be allocated for all the arrays before calling
+ * this routine
+ */
+
+
+int sei_triangulate_polygon(ncontours, cntr, vertices, triangles)
+     int ncontours;
+     int cntr[];
+     double (*vertices)[2];
+     int (*triangles)[3];
+{
+  register int i;
+  int nmonpoly, ccount, npoints, genus;
+  int n;
+
+  memset((void *)seg, 0, sizeof(seg));
+  ccount = 0;
+  i = 1;
+  
+  while (ccount &lt; ncontours)
+    {
+      int j;
+      int first, last;
+
+      npoints = cntr[ccount];
+      first = i;
+      last = first + npoints - 1;
+      for (j = 0; j &lt; npoints; j++, i++)
+	{
+	  seg[i].v0.x = vertices[i][0];
+	  seg[i].v0.y = vertices[i][1];
+
+	  if (i == last)
+	    {
+	      seg[i].next = first;
+	      seg[i].prev = i-1;
+	      seg[i-1].v1 = seg[i].v0;
+	    }
+	  else if (i == first)
+	    {
+	      seg[i].next = i+1;
+	      seg[i].prev = last;
+	      seg[last].v1 = seg[i].v0;
+	    }
+	  else
+	    {
+	      seg[i].prev = i-1;
+	      seg[i].next = i+1;
+	      seg[i-1].v1 = seg[i].v0;
+	    }
+	  
+	  seg[i].is_inserted = FALSE;
+	}
+      
+      ccount++;
+    }
+  
+  genus = ncontours - 1;
+  n = i-1;
+
+  initialise(n);
+  construct_trapezoids(n);
+  nmonpoly = monotonate_trapezoids(n);
+  return(triangulate_monotone_polygons(n, nmonpoly, triangles));
+}
+
+
+/* This function returns TRUE or FALSE depending upon whether the 
+ * vertex is inside the polygon or not. The polygon must already have
+ * been triangulated before this routine is called.
+ * This routine will always detect all the points belonging to the 
+ * set (polygon-area - polygon-boundary). The return value for points 
+ * on the boundary is not consistent!!!
+ */
+
+int is_point_inside_polygon(vertex)
+     double vertex[2];
+{
+  point_t v;
+  int trnum, rseg;
+  trap_t *t;
+
+  v.x = vertex[0];
+  v.y = vertex[1];
+  
+  trnum = locate_endpoint(&amp;v, &amp;v, 1);
+  t = &amp;tr[trnum];
+  
+  if (t-&gt;state == ST_INVALID)
+    return FALSE;
+  
+  if ((t-&gt;lseg &lt;= 0) || (t-&gt;rseg &lt;= 0))
+    return FALSE;
+  rseg = t-&gt;rseg;
+  return _greater_than_equal_to(&amp;seg[rseg].v1, &amp;seg[rseg].v0);
+}

Added: trunk/libs3d/sei_triangulate.h
===================================================================
--- trunk/libs3d/sei_triangulate.h	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/sei_triangulate.h	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,202 @@
+/*
+ * sei_triangulate.h
+ * 
+ * Copyright (C) 2006 Simon Wunderlich
+ * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
+ * for public domain: 
+ * &lt;snip&gt;
+ *
+ * This code is in the public domain. Specifically, we give to the public
+ * domain all rights for future licensing of the source code, all resale
+ * rights, and all publishing rights.
+ *
+ * UNC-CH GIVES NO WARRANTY, EXPRESSED OR IMPLIED, FOR THE SOFTWARE
+ * AND/OR DOCUMENTATION PROVIDED, INCLUDING, WITHOUT LIMITATION, WARRANTY
+ * OF MERCHANTABILITY AND WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *
+ *                                 - Atul Narkhede (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">narkhede at cs.unc.edu</A>)
+ * &lt;/snip&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#ifndef _triangulate_h
+#define _triangulate_h
+
+#include &lt;sys/types.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+
+typedef struct {
+  double x, y;
+} point_t, vector_t;
+
+
+/* Segment attributes */
+
+typedef struct {	
+  point_t v0, v1;		/* two endpoints */
+  int is_inserted;		/* inserted in trapezoidation yet ? */
+  int root0, root1;		/* root nodes in Q */
+  int next;			/* Next logical segment */
+  int prev;			/* Previous segment */
+} segment_t;
+
+
+/* Trapezoid attributes */
+
+typedef struct {
+  int lseg, rseg;		/* two adjoining segments */
+  point_t hi, lo;		/* max/min y-values */
+  int u0, u1;
+  int d0, d1;
+  int sink;			/* pointer to corresponding in Q */
+  int usave, uside;		/* I forgot what this means */
+  int state;
+} trap_t;
+
+
+/* Node attributes for every node in the query structure */
+
+typedef struct {
+  int nodetype;			/* Y-node or S-node */
+  int segnum;
+  point_t yval;
+  int trnum;
+  int parent;			/* doubly linked DAG */
+  int left, right;		/* children */
+} node_t;
+
+
+typedef struct {
+  int vnum;
+  int next;			/* Circularly linked list  */
+  int prev;			/* describing the monotone */
+  int marked;			/* polygon */
+} monchain_t;			
+
+
+typedef struct {
+  point_t pt;
+  int vnext[4];			/* next vertices for the 4 chains */
+  int vpos[4];			/* position of v in the 4 chains */
+  int nextfree;
+} vertexchain_t;
+
+#ifdef DEBUG
+#undef DEBUG
+#endif
+/* Node types */
+
+#define T_X     1
+#define T_Y     2
+#define T_SINK  3
+
+
+#define SEGSIZE SEI_SS	/* max# of segments. Determines how */
+						/* many points can be specified as */
+						/* input. If your datasets have large */
+						/* number of points, increase this */
+						/* value accordingly. */
+
+#define QSIZE   8*SEGSIZE	/* maximum table sizes */
+#define TRSIZE  4*SEGSIZE	/* max# trapezoids */
+
+
+#define TRUE  1
+#define FALSE 0
+
+
+#define FIRSTPT 1		/* checking whether pt. is inserted */ 
+#define LASTPT  2
+
+
+#define INFINITY 1&lt;&lt;30
+#define C_EPS 1.0e-7		/* tolerance value: Used for making */
+							/* all decisions about collinearity or */
+							/* left/right of segment. Decrease */
+							/* this value if the input points are */
+							/* spaced very close together */
+
+
+#define S_LEFT 1		/* for merge-direction */
+#define S_RIGHT 2
+
+
+#define ST_VALID 1		/* for trapezium state */
+#define ST_INVALID 2
+
+
+#define SP_SIMPLE_LRUP 1	/* for splitting trapezoids */
+#define SP_SIMPLE_LRDN 2
+#define SP_2UP_2DN     3
+#define SP_2UP_LEFT    4
+#define SP_2UP_RIGHT   5
+#define SP_2DN_LEFT    6
+#define SP_2DN_RIGHT   7
+#define SP_NOSPLIT    -1	
+
+#define TR_FROM_UP 1		/* for traverse-direction */
+#define TR_FROM_DN 2
+
+#define TRI_LHS 1
+#define TRI_RHS 2
+
+
+#define MAX(a, b) (((a) &gt; (b)) ? (a) : (b))
+#define MIN(a, b) (((a) &lt; (b)) ? (a) : (b))
+
+#define CROSS(v0, v1, v2) (((v1).x - (v0).x)*((v2).y - (v0).y) - \
+			   ((v1).y - (v0).y)*((v2).x - (v0).x))
+
+#define DOT(v0, v1) ((v0).x * (v1).x + (v0).y * (v1).y)
+
+#define FP_EQUAL(s, t) (fabs(s - t) &lt;= C_EPS)
+
+
+
+/* Global variables */
+
+extern node_t qs[QSIZE];		/* Query structure */
+extern trap_t tr[TRSIZE];		/* Trapezoid structure */
+extern segment_t seg[SEGSIZE];		/* Segment table */
+
+
+/* Functions */
+
+extern int monotonate_trapezoids(int);
+extern int triangulate_monotone_polygons(int, int, int (*)[3]);
+
+extern int _greater_than(point_t *, point_t *);
+extern int _equal_to(point_t *, point_t *);
+extern int _greater_than_equal_to(point_t *, point_t *);
+extern int _less_than(point_t *, point_t *);
+extern int locate_endpoint(point_t *, point_t *, int);
+extern int construct_trapezoids(int);
+
+extern int generate_random_ordering(int);
+extern int choose_segment(void);
+extern int read_segments(char *, int *);
+extern int math_logstar_n(int);
+extern int math_N(int, int);
+
+#endif /* triangulate_h */

Added: trunk/libs3d/shm.c
===================================================================
--- trunk/libs3d/shm.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/shm.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,201 @@
+/*
+ * shm.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &lt;stdlib.h&gt; 	/* malloc() */
+#include &lt;sys/types.h&gt;
+#include &lt;sys/ipc.h&gt;
+#include &lt;sys/shm.h&gt;
+#include &lt;netinet/in.h&gt;	/* ntohs() */
+#include &lt;errno.h&gt; 		/* errno */
+#include &lt;time.h&gt;		/* nanosleep() */
+#ifdef SHM
+
+#define SHM_SIZE 		sizeof(key_t)*2  		/* space for the keys */
+#define SHM_MAXLOOP		10000
+#define RB_STD_SIZE		1024*512
+
+static struct buf_t *data_in,*data_out;
+static int shmid_in, shmid_out;
+static int shm_idle=0;
+struct timespec t={0,1*1000}; /* 1 micro second */
+/* char ftoken[]=&quot;/tmp/.s3d_shm&quot;;*/
+
+int _shm_init(char *ftoken)
+{
+	int shmid;
+	uint32_t *next_key;
+/*	struct shmid_ds *buf; */
+	key_t key,key_out,key_in;
+	
+	dprintf(MED,&quot;connecting to shm token %s&quot;,ftoken);
+	/* make the key: */
+	if ((key = ftok(ftoken, 'R')) == -1) {
+		errn(&quot;shm_init():ftok()&quot;,errno);
+		return(1);
+	}
+	dprintf(MED,&quot;init key is 0x%08x&quot;,key);
+	
+	/* connect to the segment: */
+	if ((shmid = shmget(key, SHM_SIZE, 0644 )) == -1) {
+		errn(&quot;shm_init():shmget()&quot;,errno);
+		return(1);
+	}
+
+	/* attach to the segment to get a pointer to it: */
+	next_key = shmat(shmid, (void *)0, 0);
+	if (next_key == (uint32_t *)(-1)) {
+		errn(&quot;shm_init():shmat()&quot;,errno);
+		return(1);
+	}
+	dprintf(MED,&quot;right now, next_keys are: %08x, %08x&quot;,next_key[0],next_key[1]);
+	while ((0==(key_in=next_key[1])) || (0==(key_out=next_key[0])));
+	next_key[0]=next_key[1]=0;
+	dprintf(MED,&quot;right now, next_keys are: %08x, %08x&quot;,key_in,key_out);
+	/* as we have the new key, we  can detach here now. */
+	if (shmdt(next_key) == -1) { 
+		errn(&quot;shm_init():shmdt()&quot;,errno);
+		return(1);
+	}
+	/* get input buffer */
+	if ((shmid_in = shmget(key_in, RB_STD_SIZE, 0644 )) == -1) {
+		errn(&quot;shm_init():shmget()&quot;,errno);
+		return(1);
+	}
+	/* attach to the  in segment to get a pointer to it: */
+	data_in = (struct buf_t *) shmat(shmid_in, (void *)0, 0);
+	if (data_in == (struct buf_t *)(-1)) {
+		errn(&quot;shm_init():shmat()&quot;,errno);
+		return(1);
+	}
+	/* get output buffer */
+	if ((shmid_out = shmget(key_out, RB_STD_SIZE, 0644 )) == -1) {
+		errn(&quot;shm_init():shmget()&quot;,errno);
+		return(1);
+	}
+	/* attach to the out segment to get a pointer to it: */
+	data_out = (struct buf_t *) shmat(shmid_out, (void *)0, 0);
+	if (data_out == (struct buf_t *)(-1)) {
+		errn(&quot;shm_init():shmat()&quot;,errno);
+		return(1);
+	}
+	return(0);	
+}
+int _shm_quit()
+{
+	/* detach from the segment: */
+	if (shmdt(data_in) == -1) {
+		errn(&quot;shm_init():shmdt()&quot;,errno);
+		return(1);
+	}
+	if (shmdt(data_out) == -1) {
+		errn(&quot;shm_init():shmdt()&quot;,errno);
+		return(1);
+	}
+	data_in=data_out=NULL;
+	return(0);
+}
+int shm_writen(char *str, int s)
+{
+	int no_left,no_written,wait=0;
+	no_left = s;
+	while (no_left &gt; 0) 
+    { 
+		no_written = shm_write(data_out,str,no_left);
+ 		if (no_written &lt;0)  
+			return(no_written);
+		no_left -= no_written;
+		str += no_written;
+		if (wait++&gt;SHM_MAXLOOP) 
+		{
+			dprintf(HIGH,&quot;shm_writen():waited too long ...&quot;);
+			return(-1);
+		}
+		if (wait&gt;10)
+			nanosleep(&amp;t,NULL); 
+	}
+	return(s - no_left);
+}
+int shm_readn(char *str,int s)
+{
+	int no_left,no_read,wait=0;
+	no_left = s;
+	while (no_left &gt; 0) 
+	{ 
+		no_read = shm_read(data_in,str,no_left);
+		if(no_read &lt;0)  
+			return(no_read);
+		if (no_read == 0) 
+			break;
+		no_left -= no_read;
+		str += no_read;
+		if (wait++&gt;SHM_MAXLOOP) 
+		{
+			dprintf(HIGH,&quot;shm_readn():waited too long ...&quot;);
+			return(-1);
+		}
+		if (wait&gt;10)
+			nanosleep(&amp;t,NULL); 
+	}
+	return(s - no_left);
+}
+int _shm_net_receive()
+{
+	int 				 found=0;
+	char				 opcode,*buf;
+	unsigned short		 length;
+	struct shmid_ds		 d;
+	
+	if (data_in==NULL)
+		return(found);
+	if (data_in-&gt;start!=data_in-&gt;end)
+	{
+		if (1==shm_readn(&amp;opcode,1))
+		{
+			shm_readn((char *)&amp;length,2);
+			length=ntohs(length);
+			buf=malloc(length);
+			shm_readn(buf,length);
+			net_prot_in(opcode,length,buf);
+			found=1;
+		} else {
+			dprintf(HIGH,&quot;socket seems to be dead ...&quot;);
+			s3d_quit();
+		}
+	} else {
+		if (shm_idle++&gt;SHM_MAX_IDLE)
+		{
+			shmctl(shmid_in,IPC_STAT,&amp;d);
+			if (d.shm_nattch==1) /* we're all alone ... remove it!! */
+			{
+				dprintf(MED,&quot;server vanished ... &quot;);
+				s3d_quit();
+			} else 
+				shm_idle=0;
+		}
+	}
+	return(found);
+}
+#endif

Added: trunk/libs3d/shm_ringbuf.c
===================================================================
--- trunk/libs3d/shm_ringbuf.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/shm_ringbuf.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,105 @@
+/*
+ * shm_ringbuf.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &lt;stdint.h&gt; /* uint32_t */
+#include &lt;string.h&gt;	/* memcpy() */
+#ifdef SHM
+int shm_write(struct buf_t *rb,char *buf, int n)
+{
+	int wrap=0;
+	int rs;
+	uint32_t e,s,size;
+	char *data;
+
+	e=rb-&gt;end;
+	s=rb-&gt;start;
+	size=rb-&gt;bufsize;
+	data=((char *)rb)+sizeof(struct buf_t);
+	if (e&lt;s) {
+		wrap=1;
+	} 
+	while ((((s+size*(1-wrap))-e)&lt;(n+1))) /* checking free space */
+	{
+		if /*((size*2)&gt;RB_MAX_SIZE)*/ (1)
+		{
+	/*		dprintf(MED,&quot;buffer reached maxsize, no resizing possible&quot;);*/
+			return(0);
+		}
+/*		printf(&quot;buffer full!! resizing ... (to size %d)&quot;,(int)size*2);
+		if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
+		{
+			printf(&quot;realloc failed - fatal!!&quot;);
+			return(-1);
+		}
+		if (wrap)
+		{
+			memcpy(data+size,data,e);
+			e+=size;
+			wrap=0;
+		}
+		size=rb-&gt;bufsize=size*2;
+		rb-&gt;end=e;*/
+	}
+	if ((e+n)&gt;size)
+	{
+		rs=size-e;
+		memcpy(data+e,buf,rs);			/* copy the first part ... */
+		memcpy(data,buf+rs,n-rs); 		/* .. end the rest */
+	} else {
+		memcpy(data+e,buf,n);			/* plain copy */
+	}
+	rb-&gt;end=e+n;	/* update end of the buffer */
+	if (rb-&gt;end&gt;=rb-&gt;bufsize) rb-&gt;end-=rb-&gt;bufsize;
+	return(n);
+}
+int shm_read(struct buf_t *rb,char *buf, int n)
+{
+	int wrap=0;
+	int mn=n;
+	int rs;
+	uint32_t e,s,size;
+	char *data;
+
+	e=rb-&gt;end;
+	s=rb-&gt;start;
+	size=rb-&gt;bufsize;
+	data=((char *)rb)+sizeof(struct buf_t);
+	if (e&lt;s) wrap=1;
+	rs=(e+wrap*size-s);
+	mn=(n&gt;rs)?rs:n;
+	if ((wrap) &amp;&amp; (mn&gt;(size-s))) 
+	{
+		rs=size-s;	/* size of the first part */
+		memcpy(buf,data+s,rs);
+		memcpy(buf+rs,data,mn-rs);
+	} else { /* no wrap (needed)*/
+		memcpy(buf,data+s,mn);
+	}
+	rb-&gt;start=s+mn;
+	if (rb-&gt;start&gt;=rb-&gt;bufsize) rb-&gt;start-=rb-&gt;bufsize;
+	return(mn);
+}
+#endif

Added: trunk/libs3d/tcp.c
===================================================================
--- trunk/libs3d/tcp.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/tcp.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,166 @@
+/*
+ * tcp.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+#include &lt;sys/types.h&gt;
+#include &lt;stdlib.h&gt;		 /*  malloc(), free() */
+#include &lt;unistd.h&gt;		 /*  read(), write() */
+#include &lt;errno.h&gt;		 /*  errno */
+
+#include &lt;string.h&gt; 	 /*  memcpy() */
+#include &lt;sys/socket.h&gt;
+#include &lt;netinet/in.h&gt;  /*  htons(),htonl() */
+#ifndef WIN32
+	#include &lt;sys/select.h&gt;
+	#include &lt;netdb.h&gt;		 /*  gethostbyname()  */
+#endif
+int s3d_socket;		 /*  this is the socket which holds the tcp-socket .... */
+int _tcp_init(char *sv, int pn)
+{
+	int 	 			 sd;
+	int 				 res;
+/*	char			 	*port=NULL;*/
+	struct sockaddr_in 	 sock;
+	struct hostent 		*server=0;
+#ifdef WITH_SIGNALS
+	_s3d_sigio=0;
+#endif
+#ifdef WIN32 
+   WSADATA datainfo;
+   if (WSAStartup(257, &amp;datainfo) != 0)
+   {
+     errn(&quot;s3d_init():startup()&quot;, errno);
+	 return(-1);
+   }
+#endif 
+	if ((sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) {
+	  errn(&quot;s3d_init():socket()&quot;,errno);
+	  return (-1);
+	}
+	sock.sin_family = AF_INET;
+	if (*sv==0)  /*  no server argument */
+		sv=&quot;127.0.0.1&quot;;
+	if ((server = gethostbyname(sv)))
+      memcpy(&amp;sock.sin_addr.s_addr, server-&gt;h_addr_list[0], 4);
+	else 
+	{
+		errn(&quot;s3d_init():gethostbyname()&quot;,errno);
+		return(-1);
+	}
+	sock.sin_port = htons(pn); 
+
+	res = connect(sd, (struct sockaddr *) &amp;sock, sizeof(struct sockaddr_in));
+	if (res &lt; 0 ) {
+	  errn(&quot;s3d_init():connect()&quot;,errno);
+	  return(-1);
+	}
+/*    if ( fcntl(sd, F_SETFL, O_ASYNC | O_NONBLOCK) &lt; 0 ) */
+/* 		errn(&quot;fcntl()&quot;,errno); */
+#ifdef WITH_SIGNALS
+   if ( fcntl(sd, F_SETFL, O_ASYNC ) &lt; 0 )
+		errn(&quot;fcntl()&quot;,errno);
+   if ( fcntl(sd, F_SETOWN, getpid()) &lt; 0 )
+		errn(&quot;fcntl()&quot;,errno);
+    if (signal(SIGPIPE, (sig_t)sigpipe_handler) == SIG_ERR) 
+		errn(&quot;_tcp_init():signal()&quot;,errno);
+    if (signal(SIGIO, (sig_t)sigio_handler) == SIG_ERR) 
+		errn(&quot;_tcp_init():signal()&quot;,errno);
+#endif
+	s3d_socket=sd;
+	dprintf(MED,&quot;connection to %s:%d established&quot;, sv, pn);
+	return(0);
+}
+int _tcp_quit()
+{
+	if (s3d_socket)
+	{
+		dprintf(MED,&quot;closing socket %d&quot;,s3d_socket);
+		close(s3d_socket);
+		s3d_socket=0;
+	}
+	return(0);
+}
+int tcp_readn(char *str,int s)
+{         int no_left,no_read;
+          no_left = s;
+          while (no_left &gt; 0) 
+                     { no_read = read(s3d_socket,str,no_left);
+                       if(no_read &lt;0)  return(no_read);
+                       if (no_read == 0) break;
+                       no_left -= no_read;
+                       str += no_read;
+                     }
+          return(s - no_left);
+}
+int tcp_writen(char *str,int s)
+{         int no_left,no_written;
+          no_left = s;
+          while (no_left &gt; 0) 
+                     { no_written = write(s3d_socket,str,no_left);
+                       if(no_written &lt;=0)  return(no_written);
+                       no_left -= no_written;
+                       str += no_written;
+                     }
+          return(s - no_left);
+}
+int _s3d_tcp_net_receive()
+{
+	fd_set				 fs_proc; 	 /*  filedescriptor set for listening port(s) */
+	struct timeval		 tv;		 /*  time structure */
+	int 				 found=0;
+	char				 opcode,*buf;
+	unsigned short		 length;
+	
+	
+	if (s3d_socket!=-1)
+	{
+		FD_ZERO(&amp;fs_proc);
+		tv.tv_sec=tv.tv_usec=0;
+		FD_SET(s3d_socket,&amp;fs_proc);
+	
+		 /* dprintf(LOW,&quot;Added %d procceses into file descriptor ...&quot;, n); */
+		if (select(FD_SETSIZE, &amp;fs_proc, NULL,NULL,&amp;tv) ==-1) 
+		{
+			errn(&quot;select()&quot;,errno); 
+		} else {
+			 /*  data is available */
+			if (FD_ISSET(s3d_socket,&amp;fs_proc))
+			{
+				if (1==tcp_readn(&amp;opcode,1))
+				{
+					tcp_readn((char *)&amp;length,2);
+					length=ntohs(length);
+					buf=malloc(length);
+					tcp_readn(buf,length);
+					net_prot_in(opcode,length,buf);
+					found=1;
+				} else {
+					dprintf(HIGH,&quot;socket seems to be dead ...&quot;);
+					s3d_quit();
+				}
+			}
+		}
+	}
+	return(found);
+}

Added: trunk/libs3d/vector.c
===================================================================
--- trunk/libs3d/vector.c	2006-05-25 17:11:20 UTC (rev 294)
+++ trunk/libs3d/vector.c	2006-05-25 17:11:46 UTC (rev 295)
@@ -0,0 +1,92 @@
+/*
+ * vector.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ *                         Marek Lindner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lindner_marek at yahoo.de</A>&gt;
+ *                         Andreas Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">andreas_lbg at gmx.de</A>&gt;
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
+ * 
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ * 
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include &lt;math.h&gt;		/* sqrt() */
+
+/***
+ *
+ * calculate length of a vector =&gt; <A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Length_of_a_vector">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Length_of_a_vector</A>
+ *
+ *   vector   =&gt;   given vector
+ *
+ *   return length
+ *
+ ***/
+
+float s3d_vector_length( float vector[] ) {
+	return ( sqrt( vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2] ) );
+
+}
+
+
+/***
+ *
+ * substract vector1 from vector2 =&gt; <A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction</A>
+ *
+ *   vector1         =&gt;   given vector1
+ *   vector2         =&gt;   given vector2
+ *   result_vector   =&gt;   save resulting vector here
+ *
+ ***/
+
+void s3d_vector_substract( float vector1[], float vector2[], float result_vector[] ) {
+
+	result_vector[0] = vector2[0] - vector1[0];
+	result_vector[1] = vector2[1] - vector1[1];
+	result_vector[2] = vector2[2] - vector1[2];
+}
+
+/***
+ *
+ * calculate dot product of 2 vectors =&gt; <A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product</A>
+ *
+ *   vector1   =&gt;   given vector1
+ *   vector2   =&gt;   given vector2
+ *
+ *   return dot product
+ *
+ ***/
+
+float s3d_vector_dot_product( float vector1[], float vector2[] ) {
+	return ( vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2] );
+}
+
+/***
+ *
+ * calculate angle between 2 vectors =&gt; <A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product</A>
+ *
+ *   vector1   =&gt;   given vector1
+ *   vector2   =&gt;   given vector2
+ *
+ *   return angle
+ *
+ *   NOTE: angle is between 0 and PI, therefore not covering the whole period!
+ *
+ ***/
+
+float s3d_vector_angle( float vector1[], float vector2[] ) {
+	return ( acos( s3d_vector_dot_product( vector1, vector2 ) / ( s3d_vector_length( vector1 ) * s3d_vector_length( vector2 ) ) ) );
+
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000287.html">[S3d-svn] r294 - in trunk: . apps/s3dfm
</A></li>
	<LI>Next message: <A HREF="000289.html">[S3d-svn] r296 - in trunk: . libg3d/include libg3d/include/g3d libs3dw
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#288">[ date ]</a>
              <a href="thread.html#288">[ thread ]</a>
              <a href="subject.html#288">[ subject ]</a>
              <a href="author.html#288">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/s3d-svn">More information about the S3d-svn
mailing list</a><br>
</body></html>
