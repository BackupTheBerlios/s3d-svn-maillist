From lazhur at mail.berlios.de  Fri Nov  2 17:56:12 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Fri, 2 Nov 2007 17:56:12 +0100
Subject: [S3d-svn] r833 - in trunk: . cmake/modules
Message-ID: <200711021656.lA2GuCT1029352@sheep.berlios.de>

Author: lazhur
Date: 2007-11-02 17:56:11 +0100 (Fri, 02 Nov 2007)
New Revision: 833

Removed:
   trunk/cmake/modules/FindGLIB.cmake
Modified:
   trunk/ConfigureChecks.cmake
Log:
Remove direct dependency to glib-2.0


Modified: trunk/ConfigureChecks.cmake
===================================================================
--- trunk/ConfigureChecks.cmake	2007-10-30 18:17:48 UTC (rev 832)
+++ trunk/ConfigureChecks.cmake	2007-11-02 16:56:11 UTC (rev 833)
@@ -20,16 +20,6 @@
 endif (FONTCONFIG_FOUND)
 
 
-# find required lib and add include dir for GLIB
-find_package(GLIB)
-if (GLIB2_FOUND)
-	include_directories(${GLIB2_INCLUDE_DIR})
-	add_definitions(${GLIB2_DEFINITIONS})
-else (GLIB2_FOUND)
-	PkgError_Later("Could not find GLIB (pkg name: libglib-dev)")
-endif (GLIB2_FOUND)
-
-
 # find required lib and add include dir for G3D
 find_package(G3D)
 if (G3D_FOUND)

Deleted: trunk/cmake/modules/FindGLIB.cmake
===================================================================
--- trunk/cmake/modules/FindGLIB.cmake	2007-10-30 18:17:48 UTC (rev 832)
+++ trunk/cmake/modules/FindGLIB.cmake	2007-11-02 16:56:11 UTC (rev 833)
@@ -1,69 +0,0 @@
-# Try to find GLIB2
-#  GLIB2_FOUND - If false, do not try to use GLIB2.
-#  GLIB2_INCLUDE_DIR - where to find glib.h and glibconfig.h, etc.
-#  GLIB2_LIBRARIES - the libraries to link against
-#  GLIB2_DEFINITIONS - switches required for GLIB2
-
-
-if (GLIB2_LIBRARIES AND GLIB2_INCLUDE_DIR)
-	# path set by user or was found in the past
-	set(GLIB2_FOUND TRUE)
-else (GLIB2_LIBRARIES AND GLIB2_INCLUDE_DIR)
-	include(UsePkgConfig)
-
-	pkgconfig(glib-2.0 _IncDir _LinkDir _LinkFlags _CFlags)
-	set(GLIB2_DEFINITIONS ${_CFlags})
-
-	find_path(GLIB2_INCLUDE_DIR
-		NAMES glib.h
-		PATHS
-			${_IncDir}
-			${_IncDir}/glib-2.0
-			${_IncDir}/glib-2.0/include
-	)
-
-	find_path(GLIBCONFIG_INCLUDE_DIR
-		NAMES glibconfig.h
-		PATHS
-			${_IncDir}
-			${_IncDir}/glib-2.0
-			${_IncDir}/glib-2.0/include
-			${_LinkDir}/glib-2.0
-			${_LinkDir}/glib-2.0/include
-	)
-
-	find_library(GLIB2_LIBRARIES
-		NAMES glib-2.0
-		PATHS ${_LinkDir}
-	)
-
-	if (GLIB2_INCLUDE_DIR AND GLIBCONFIG_INCLUDE_DIR)
-		list(APPEND GLIB2_INCLUDE_DIR ${GLIBCONFIG_INCLUDE_DIR})
-	else (GLIB2_INCLUDE_DIR AND GLIBCONFIG_INCLUDE_DIR)
-		set(GLIB2_INCLUDE_DIR)
-	endif (GLIB2_INCLUDE_DIR AND GLIBCONFIG_INCLUDE_DIR)
-
-	if (GLIB2_INCLUDE_DIR AND GLIB2_LIBRARIES)
-		set(GLIB2_FOUND TRUE)
-	endif (GLIB2_INCLUDE_DIR AND GLIB2_LIBRARIES)
-
-	if (GLIB2_FOUND)
-		if (NOT GLIB2_FIND_QUIETLY)
-			message(STATUS "Found GLIB2: ${GLIB2_LIBRARIES}")
-		endif (NOT GLIB2_FIND_QUIETLY)
-	else (GLIB2_FOUND)
-		if (GLIB2_FIND_REQUIRED)
-			message(FATAL_ERROR "Could not find GLIB2")
-		endif (GLIB2_FIND_REQUIRED)
-	endif (GLIB2_FOUND)
-
-	# set visibility in cache
-	set(GLIB2_INCLUDE_DIR ${GLIB2_INCLUDE_DIR} CACHE PATH "Path to a file." FORCE)
-	set(GLIB2_LIBRARIES ${GLIB2_LIBRARIES} CACHE FILEPATH "Path to a library." FORCE)
-	set(GLIB2_DEFINITIONS ${GLIB2_DEFINITIONS} CACHE STRING "Defines for compilation." FORCE)
-	mark_as_advanced(GLIB2_INCLUDE_DIR GLIB2_LIBRARIES GLIB2_DEFINITIONS)
-
-	# mark as internal
-	set(GLIBCONFIG_INCLUDE_DIR ${GLIBCONFIG_INCLUDE_DIR} CACHE INTERNAL "Path to a config file." FORCE)
-
-endif (GLIB2_LIBRARIES AND GLIB2_INCLUDE_DIR)



From lazhur at mail.berlios.de  Fri Nov  2 17:56:28 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Fri, 2 Nov 2007 17:56:28 +0100
Subject: [S3d-svn] r834 - trunk/extras/distro/gentoo/media-gfx/s3d-svn
Message-ID: <200711021656.lA2GuS3Q029398@sheep.berlios.de>

Author: lazhur
Date: 2007-11-02 17:56:27 +0100 (Fri, 02 Nov 2007)
New Revision: 834

Modified:
   trunk/extras/distro/gentoo/media-gfx/s3d-svn/Manifest
   trunk/extras/distro/gentoo/media-gfx/s3d-svn/s3d-svn-9999.ebuild
Log:
Remove direct dependency to glib from svn ebuild


Modified: trunk/extras/distro/gentoo/media-gfx/s3d-svn/Manifest
===================================================================
--- trunk/extras/distro/gentoo/media-gfx/s3d-svn/Manifest	2007-11-02 16:56:11 UTC (rev 833)
+++ trunk/extras/distro/gentoo/media-gfx/s3d-svn/Manifest	2007-11-02 16:56:27 UTC (rev 834)
@@ -1,7 +1,7 @@
-EBUILD s3d-svn-9999.ebuild 1080 RMD160 dc3c9fe70997bf2496a0c2edccd2cc51681dbeeb SHA1 03cfd6342ee586319d88ddfe8ee92cb2cdf4dcab SHA256 a38520cb14c71bce43bd711c02b58bff8dbd20851e22bd29ca08cd3a544ec07a
-MD5 460aeebf714955e28675ff46157bfc83 s3d-svn-9999.ebuild 1080
-RMD160 dc3c9fe70997bf2496a0c2edccd2cc51681dbeeb s3d-svn-9999.ebuild 1080
-SHA256 a38520cb14c71bce43bd711c02b58bff8dbd20851e22bd29ca08cd3a544ec07a s3d-svn-9999.ebuild 1080
+EBUILD s3d-svn-9999.ebuild 1061 RMD160 81acf0f98dc368f04501e8afc7c66891de33cd39 SHA1 4c572320e14913fe400819ec815f9e234a7658c1 SHA256 8e1755c6bb0b1f4ed4a6af2670f8e39726afb1143e4c8d224501ff95d740d48b
+MD5 f957f6fc776836e338ad33af8076ee78 s3d-svn-9999.ebuild 1061
+RMD160 81acf0f98dc368f04501e8afc7c66891de33cd39 s3d-svn-9999.ebuild 1061
+SHA256 8e1755c6bb0b1f4ed4a6af2670f8e39726afb1143e4c8d224501ff95d740d48b s3d-svn-9999.ebuild 1061
 MISC ChangeLog 717 RMD160 732719801434d2f34762040a3d76224a376eafe9 SHA1 e3f6ae8c96e94d078c05f06a26c4671126bf2ae0 SHA256 50813962433038ee35016fdbd5a738f99f8ef5da1dbb6db01c35b258ca180587
 MD5 29def1ab7084d3f1a14f46b8e18774a9 ChangeLog 717
 RMD160 732719801434d2f34762040a3d76224a376eafe9 ChangeLog 717

Modified: trunk/extras/distro/gentoo/media-gfx/s3d-svn/s3d-svn-9999.ebuild
===================================================================
--- trunk/extras/distro/gentoo/media-gfx/s3d-svn/s3d-svn-9999.ebuild	2007-11-02 16:56:11 UTC (rev 833)
+++ trunk/extras/distro/gentoo/media-gfx/s3d-svn/s3d-svn-9999.ebuild	2007-11-02 16:56:27 UTC (rev 834)
@@ -19,7 +19,6 @@
 RDEPEND="!media-gfx/s3d
 	>=media-libs/libsdl-1.2.7
 	>=media-libs/freetype-2
-	>=dev-libs/glib-2
 	dev-libs/libxml2
 	media-fonts/ttf-bitstream-vera
 	media-libs/fontconfig



From lazhur at mail.berlios.de  Fri Nov  2 18:00:18 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Fri, 2 Nov 2007 18:00:18 +0100
Subject: [S3d-svn] r835 - in trunk: . cmake/modules
Message-ID: <200711021700.lA2H0INA029688@sheep.berlios.de>

Author: lazhur
Date: 2007-11-02 18:00:18 +0100 (Fri, 02 Nov 2007)
New Revision: 835

Added:
   trunk/cmake/modules/FindGLIB.cmake
Modified:
   trunk/ConfigureChecks.cmake
Log:
Revert "Remove direct dependency to glib-2.0"

Dependency is needed for g3d header files


Modified: trunk/ConfigureChecks.cmake
===================================================================
--- trunk/ConfigureChecks.cmake	2007-11-02 16:56:27 UTC (rev 834)
+++ trunk/ConfigureChecks.cmake	2007-11-02 17:00:18 UTC (rev 835)
@@ -20,6 +20,16 @@
 endif (FONTCONFIG_FOUND)
 
 
+# find required lib and add include dir for GLIB
+find_package(GLIB)
+if (GLIB2_FOUND)
+	include_directories(${GLIB2_INCLUDE_DIR})
+	add_definitions(${GLIB2_DEFINITIONS})
+else (GLIB2_FOUND)
+	PkgError_Later("Could not find GLIB2 (pkg name: libglib2.0-dev)")
+endif (GLIB2_FOUND)
+
+
 # find required lib and add include dir for G3D
 find_package(G3D)
 if (G3D_FOUND)

Added: trunk/cmake/modules/FindGLIB.cmake
===================================================================
--- trunk/cmake/modules/FindGLIB.cmake	2007-11-02 16:56:27 UTC (rev 834)
+++ trunk/cmake/modules/FindGLIB.cmake	2007-11-02 17:00:18 UTC (rev 835)
@@ -0,0 +1,69 @@
+# Try to find GLIB2
+#  GLIB2_FOUND - If false, do not try to use GLIB2.
+#  GLIB2_INCLUDE_DIR - where to find glib.h and glibconfig.h, etc.
+#  GLIB2_LIBRARIES - the libraries to link against
+#  GLIB2_DEFINITIONS - switches required for GLIB2
+
+
+if (GLIB2_LIBRARIES AND GLIB2_INCLUDE_DIR)
+	# path set by user or was found in the past
+	set(GLIB2_FOUND TRUE)
+else (GLIB2_LIBRARIES AND GLIB2_INCLUDE_DIR)
+	include(UsePkgConfig)
+
+	pkgconfig(glib-2.0 _IncDir _LinkDir _LinkFlags _CFlags)
+	set(GLIB2_DEFINITIONS ${_CFlags})
+
+	find_path(GLIB2_INCLUDE_DIR
+		NAMES glib.h
+		PATHS
+			${_IncDir}
+			${_IncDir}/glib-2.0
+			${_IncDir}/glib-2.0/include
+	)
+
+	find_path(GLIBCONFIG_INCLUDE_DIR
+		NAMES glibconfig.h
+		PATHS
+			${_IncDir}
+			${_IncDir}/glib-2.0
+			${_IncDir}/glib-2.0/include
+			${_LinkDir}/glib-2.0
+			${_LinkDir}/glib-2.0/include
+	)
+
+	find_library(GLIB2_LIBRARIES
+		NAMES glib-2.0
+		PATHS ${_LinkDir}
+	)
+
+	if (GLIB2_INCLUDE_DIR AND GLIBCONFIG_INCLUDE_DIR)
+		list(APPEND GLIB2_INCLUDE_DIR ${GLIBCONFIG_INCLUDE_DIR})
+	else (GLIB2_INCLUDE_DIR AND GLIBCONFIG_INCLUDE_DIR)
+		set(GLIB2_INCLUDE_DIR)
+	endif (GLIB2_INCLUDE_DIR AND GLIBCONFIG_INCLUDE_DIR)
+
+	if (GLIB2_INCLUDE_DIR AND GLIB2_LIBRARIES)
+		set(GLIB2_FOUND TRUE)
+	endif (GLIB2_INCLUDE_DIR AND GLIB2_LIBRARIES)
+
+	if (GLIB2_FOUND)
+		if (NOT GLIB2_FIND_QUIETLY)
+			message(STATUS "Found GLIB2: ${GLIB2_LIBRARIES}")
+		endif (NOT GLIB2_FIND_QUIETLY)
+	else (GLIB2_FOUND)
+		if (GLIB2_FIND_REQUIRED)
+			message(FATAL_ERROR "Could not find GLIB2")
+		endif (GLIB2_FIND_REQUIRED)
+	endif (GLIB2_FOUND)
+
+	# set visibility in cache
+	set(GLIB2_INCLUDE_DIR ${GLIB2_INCLUDE_DIR} CACHE PATH "Path to a file." FORCE)
+	set(GLIB2_LIBRARIES ${GLIB2_LIBRARIES} CACHE FILEPATH "Path to a library." FORCE)
+	set(GLIB2_DEFINITIONS ${GLIB2_DEFINITIONS} CACHE STRING "Defines for compilation." FORCE)
+	mark_as_advanced(GLIB2_INCLUDE_DIR GLIB2_LIBRARIES GLIB2_DEFINITIONS)
+
+	# mark as internal
+	set(GLIBCONFIG_INCLUDE_DIR ${GLIBCONFIG_INCLUDE_DIR} CACHE INTERNAL "Path to a config file." FORCE)
+
+endif (GLIB2_LIBRARIES AND GLIB2_INCLUDE_DIR)



From lazhur at mail.berlios.de  Fri Nov  2 23:04:22 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Fri, 2 Nov 2007 23:04:22 +0100
Subject: [S3d-svn] r836 - trunk/cmake/modules
Message-ID: <200711022204.lA2M4MMh030162@sheep.berlios.de>

Author: lazhur
Date: 2007-11-02 23:04:21 +0100 (Fri, 02 Nov 2007)
New Revision: 836

Added:
   trunk/cmake/modules/FindBluetooth.cmake
Modified:
   trunk/cmake/modules/FindCWiid.cmake
Log:
Added cmake test for libbluetooth


Added: trunk/cmake/modules/FindBluetooth.cmake
===================================================================
--- trunk/cmake/modules/FindBluetooth.cmake	2007-11-02 17:00:18 UTC (rev 835)
+++ trunk/cmake/modules/FindBluetooth.cmake	2007-11-02 22:04:21 UTC (rev 836)
@@ -0,0 +1,36 @@
+# Try to find Bluetooth
+#  BLUETOOTH_FOUND - If false, do not try to use Bluetooth.
+#  BLUETOOTH_INCLUDE_DIR - where to find bluetooth/bluetooth.h
+#  BLUETOOTH_LIBRARIES - the libraries to link against
+
+
+if (BLUETOOTH_LIBRARIES AND BLUETOOTH_INCLUDE_DIR)
+	# path set by user or was found in the past
+	set(BLUETOOTH_FOUND TRUE)
+else (BLUETOOTH_LIBRARIES AND BLUETOOTH_INCLUDE_DIR)
+	find_path(BLUETOOTH_INCLUDE_DIR
+		NAMES bluetooth/bluetooth.h
+	)
+
+	find_library(BLUETOOTH_LIBRARIES
+		NAMES bluetooth
+	)
+
+	if (BLUETOOTH_INCLUDE_DIR AND BLUETOOTH_LIBRARIES)
+		set(BLUETOOTH_FOUND TRUE)
+	endif (BLUETOOTH_INCLUDE_DIR AND BLUETOOTH_LIBRARIES)
+
+	if (BLUETOOTH_FOUND)
+		if (NOT BLUETOOTH_FIND_QUIETLY)
+			message(STATUS "Found Bluetooth: ${BLUETOOTH_LIBRARIES}")
+		endif (NOT BLUETOOTH_FIND_QUIETLY)
+	else (BLUETOOTH_FOUND)
+		if (BLUETOOTH_FIND_REQUIRED)
+			message(FATAL_ERROR "Could not find Bluetooth")
+		endif (BLUETOOTH_FIND_REQUIRED)
+	endif (BLUETOOTH_FOUND)
+
+	# set visibility in cache
+	mark_as_advanced(BLUETOOTH_INCLUDE_DIR BLUETOOTH_LIBRARIES)
+
+endif (BLUETOOTH_LIBRARIES AND BLUETOOTH_INCLUDE_DIR)

Modified: trunk/cmake/modules/FindCWiid.cmake
===================================================================
--- trunk/cmake/modules/FindCWiid.cmake	2007-11-02 17:00:18 UTC (rev 835)
+++ trunk/cmake/modules/FindCWiid.cmake	2007-11-02 22:04:21 UTC (rev 836)
@@ -3,11 +3,12 @@
 #  CWIID_INCLUDE_DIR - where to find cwiid.h
 #  CWIID_LIBRARIES - the libraries to link against
 
+find_package(Bluetooth)
 
-if (CWIID_LIBRARIES AND CWIID_INCLUDE_DIR)
+if (CWIID_LIBRARIES AND CWIID_INCLUDE_DIR AND BLUETOOTH_FOUND)
 	# path set by user or was found in the past
 	set(CWIID_FOUND TRUE)
-else (CWIID_LIBRARIES AND CWIID_INCLUDE_DIR)
+else (CWIID_LIBRARIES AND CWIID_INCLUDE_DIR AND BLUETOOTH_FOUND)
 	find_path(CWIID_INCLUDE_DIR
 		NAMES cwiid.h
 	)
@@ -16,9 +17,9 @@
 		NAMES cwiid
 	)
 
-	if (CWIID_INCLUDE_DIR AND CWIID_LIBRARIES)
+	if (CWIID_INCLUDE_DIR AND CWIID_LIBRARIES AND BLUETOOTH_FOUND)
 		set(CWIID_FOUND TRUE)
-	endif (CWIID_INCLUDE_DIR AND CWIID_LIBRARIES)
+	endif (CWIID_INCLUDE_DIR AND CWIID_LIBRARIES AND BLUETOOTH_FOUND)
 
 	if (CWIID_FOUND)
 		if (NOT CWIID_FIND_QUIETLY)
@@ -26,11 +27,15 @@
 		endif (NOT CWIID_FIND_QUIETLY)
 	else (CWIID_FOUND)
 		if (CWIID_FIND_REQUIRED)
-			message(FATAL_ERROR "Could not find CWiid")
+			if (NOT BLUETOOTH_FOUND)
+				message(FATAL_ERROR "Could not find dependency Bluetooth for CWiid")
+			else (NOT BLUETOOTH_FOUND)
+				message(FATAL_ERROR "Could not find CWiid")
+			endif (NOT BLUETOOTH_FOUND)
 		endif (CWIID_FIND_REQUIRED)
 	endif (CWIID_FOUND)
 
 	# set visibility in cache
 	mark_as_advanced(CWIID_INCLUDE_DIR CWIID_LIBRARIES)
 
-endif (CWIID_LIBRARIES AND CWIID_INCLUDE_DIR)
+endif (CWIID_LIBRARIES AND CWIID_INCLUDE_DIR AND BLUETOOTH_FOUND)



From dotslash at mail.berlios.de  Sat Nov  3 00:28:18 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 3 Nov 2007 00:28:18 +0100
Subject: [S3d-svn] r837 - in trunk/svnonly: . comptest
Message-ID: <200711022328.lA2NSIbN000817@sheep.berlios.de>

Author: dotslash
Date: 2007-11-03 00:28:18 +0100 (Sat, 03 Nov 2007)
New Revision: 837

Modified:
   trunk/svnonly/CMakeLists.txt
   trunk/svnonly/comptest/comptest.c
Log:
- change copyright statement (comptest is not olsrs3d! O_o)


Modified: trunk/svnonly/CMakeLists.txt
===================================================================
--- trunk/svnonly/CMakeLists.txt	2007-11-02 22:04:21 UTC (rev 836)
+++ trunk/svnonly/CMakeLists.txt	2007-11-02 23:28:18 UTC (rev 837)
@@ -1,3 +1,4 @@
 add_subdirectory(comptest)
 add_subdirectory(olsrs3d)
 add_subdirectory(testvis)
+add_subdirectory(wiitest)

Modified: trunk/svnonly/comptest/comptest.c
===================================================================
--- trunk/svnonly/comptest/comptest.c	2007-11-02 22:04:21 UTC (rev 836)
+++ trunk/svnonly/comptest/comptest.c	2007-11-02 23:28:18 UTC (rev 837)
@@ -6,18 +6,18 @@
  * This file is part of comptest, a proof-of-concept composite manager hack.
  * See http://s3d.berlios.de/ for more updates.
  *
- * olsrs3d is free software; you can redistribute it and/or modify
+ * comptest is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * olsrs3d is distributed in the hope that it will be useful,
+ * comptest is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with olsrs3d; if not, write to the Free Software
+ * along with comptest; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 



From dotslash at mail.berlios.de  Sat Nov  3 00:30:39 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 3 Nov 2007 00:30:39 +0100
Subject: [S3d-svn] r838 - in trunk/svnonly: . wiitest
Message-ID: <200711022330.lA2NUdIj002293@sheep.berlios.de>

Author: dotslash
Date: 2007-11-03 00:30:38 +0100 (Sat, 03 Nov 2007)
New Revision: 838

Added:
   trunk/svnonly/wiitest/
   trunk/svnonly/wiitest/CMakeLists.txt
   trunk/svnonly/wiitest/wiitest.c
Log:
- commit wiitest, which is just a demo program and moves/rotates an object
  according to the accelerator data


Added: trunk/svnonly/wiitest/CMakeLists.txt
===================================================================
--- trunk/svnonly/wiitest/CMakeLists.txt	2007-11-02 23:28:18 UTC (rev 837)
+++ trunk/svnonly/wiitest/CMakeLists.txt	2007-11-02 23:30:38 UTC (rev 838)
@@ -0,0 +1,18 @@
+project(wiitest C)
+
+if (CWIID_FOUND)
+	include_directories(${s3d_SOURCE_DIR}/libs3d ${CWIID_INCLUDE_DIR})
+
+	add_executable(wiitest wiitest.c)
+	target_link_libraries(wiitest s3d ${CWIID_LIBRARIES})
+
+	# install
+	install(TARGETS wiitest RUNTIME DESTINATION bin)
+else (CWIID_FOUND)
+	if (NOT CWIID_FOUND)
+		PkgStatus_Later("libcwiid (pkg name: libcwiid1-dev)")
+	endif (NOT CWIID_FOUND)
+	
+	# print late status
+	Collected_PkgStatus("wiitest")
+endif (CWIID_FOUND)

Added: trunk/svnonly/wiitest/wiitest.c
===================================================================
--- trunk/svnonly/wiitest/wiitest.c	2007-11-02 23:28:18 UTC (rev 837)
+++ trunk/svnonly/wiitest/wiitest.c	2007-11-02 23:30:38 UTC (rev 838)
@@ -0,0 +1,128 @@
+/*
+ * wiitest.c
+ *
+ * Copyright (C) 2007 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of wiitest, ripped from wmdemo.c to 
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * wiitest is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * wiitest is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with wiitest; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <cwiid.h>
+#include <s3d.h>
+#include <math.h> /* sin() */
+#include <time.h> /* nanosleep() */
+
+static struct timespec t = {
+	0, 10*1000*1000
+}; /* 10 mili seconds */
+
+
+float x[3] = {0,0,0};
+float move[3] = {0,0,0};
+
+cwiid_err_t err;
+static int oid_head;
+static cwiid_wiimote_t *wiimote;	/* wiimote handle */
+
+void err(cwiid_wiimote_t *wiimote, const char *s, va_list ap)
+{
+	if (wiimote) printf("%d:", cwiid_get_id(wiimote));
+	else printf("-1:");
+	vprintf(s, ap);
+	printf("\n");
+}
+static void mainloop(void)
+{
+	float pos;
+	struct cwiid_state state;	/* wiimote state */
+	cwiid_get_state(wiimote, &state);
+	float z_normvec[3] = {-1, 0, 0};
+	float x_normvec[3] = { 0, 1, 0};
+	float xrot, zrot;
+	float y[3];
+	
+	y[0] = (state.acc[CWIID_X]-128)/128.0; 
+	y[1] = (state.acc[CWIID_Y]-128)/128.0; 
+	y[2] = (state.acc[CWIID_Z]-128)/128.0; 
+
+	/* smooth it */
+	x[0] = (x[0]*9 + y[0])/10;
+	x[1] = (x[1]*9 + y[1])/10;
+	x[2] = (x[2]*9 + y[2])/10;
+
+	move[0] = ((x[0] - y[0] ) + move[0]*9)/10;
+	move[1] = ((x[2] - y[2] ) + move[1]*9)/10;
+	move[2] = ((y[1] - x[1] ) + move[2]*9)/10;
+
+	xrot = s3d_vector_angle(x_normvec, x);
+	xrot = 90 - (180.0 / M_PI * xrot);
+
+/*	z_normvec[0] = -cos(xrot * M_PI/180) ;
+	z_normvec[1] = 0;
+	z_normvec[2] = +sin(xrot * M_PI/180) ;
+	printf("zn = %3.3f %3.3f %3.3f    ", z_normvec[0], z_normvec[1], z_normvec[2]);*/
+
+	zrot = s3d_vector_angle(z_normvec, x);
+	/* take care of inverse cosinus */
+	if (x[2] > 0) 					zrot = 180 - (180.0 / M_PI * zrot);
+	 else 							zrot = 180 + (180.0 / M_PI * zrot);
+	zrot-= 90;
+
+	printf("%3.3f %3.3f %3.3f, zrot = %3.3f, xrot = %3.3f\n", x[0], x[1], x[2], zrot, xrot);
+
+	s3d_rotate(oid_head, xrot, 0, zrot);
+	s3d_translate(oid_head, move[0]*10, move[1]*10, move[2]*10);
+
+	nanosleep(&t, NULL);
+}
+
+int main(int argc, char *argv[])
+{
+	bdaddr_t bdaddr;	/* bluetooth device address */
+
+	cwiid_set_err(err);
+
+	/* Connect to address given on command-line, if present */
+	if (argc > 1) {
+		str2ba(argv[1], &bdaddr);
+	}
+	else {
+		bdaddr = *BDADDR_ANY;
+	}
+
+	/* Connect to the wiimote */
+	printf("Put Wiimote in discoverable mode now (press 1+2)...\n");
+
+	if (!(wiimote = cwiid_open(&bdaddr, 0))) {
+		fprintf(stderr, "Unable to connect to wiimote\n");
+		return -1;
+	}
+
+	cwiid_set_rpt_mode(wiimote, CWIID_RPT_BTN | CWIID_RPT_ACC| CWIID_RPT_IR| CWIID_RPT_NUNCHUK | CWIID_RPT_CLASSIC);
+
+
+	if (!s3d_init(&argc, &argv, "wiitest")) {
+		oid_head = s3d_import_model_file("objs/snow_head.3ds");
+		s3d_flags_on(oid_head, S3D_OF_VISIBLE);
+		s3d_mainloop(mainloop);
+		s3d_quit();
+	}
+
+}
+



From lazhur at mail.berlios.de  Sat Nov  3 09:54:40 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 3 Nov 2007 09:54:40 +0100
Subject: [S3d-svn] r839 - trunk/svnonly/wiitest
Message-ID: <200711030854.lA38seS4029965@sheep.berlios.de>

Author: lazhur
Date: 2007-11-03 09:54:39 +0100 (Sat, 03 Nov 2007)
New Revision: 839

Modified:
   trunk/svnonly/wiitest/CMakeLists.txt
Log:
wiitest: Inform user about missing bluetooth dependency of cwiid


Modified: trunk/svnonly/wiitest/CMakeLists.txt
===================================================================
--- trunk/svnonly/wiitest/CMakeLists.txt	2007-11-02 23:30:38 UTC (rev 838)
+++ trunk/svnonly/wiitest/CMakeLists.txt	2007-11-03 08:54:39 UTC (rev 839)
@@ -10,6 +10,10 @@
 	install(TARGETS wiitest RUNTIME DESTINATION bin)
 else (CWIID_FOUND)
 	if (NOT CWIID_FOUND)
+		if (NOT BLUETOOTH_FOUND)
+			PkgStatus_Later("libbluetooth (pkg name: libbluetooth-dev)")
+		endif (NOT BLUETOOTH_FOUND)
+
 		PkgStatus_Later("libcwiid (pkg name: libcwiid1-dev)")
 	endif (NOT CWIID_FOUND)
 	



From lazhur at mail.berlios.de  Sat Nov  3 09:54:50 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 3 Nov 2007 09:54:50 +0100
Subject: [S3d-svn] r840 - trunk/svnonly/wiitest
Message-ID: <200711030854.lA38som8030003@sheep.berlios.de>

Author: lazhur
Date: 2007-11-03 09:54:50 +0100 (Sat, 03 Nov 2007)
New Revision: 840

Modified:
   trunk/svnonly/wiitest/wiitest.c
Log:
wiitest: do not declare variables after code


Modified: trunk/svnonly/wiitest/wiitest.c
===================================================================
--- trunk/svnonly/wiitest/wiitest.c	2007-11-03 08:54:39 UTC (rev 839)
+++ trunk/svnonly/wiitest/wiitest.c	2007-11-03 08:54:50 UTC (rev 840)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
- * This file is part of wiitest, ripped from wmdemo.c to 
+ * This file is part of wiitest, ripped from wmdemo.c to
  * See http://s3d.berlios.de/ for more updates.
  *
  * wiitest is free software; you can redistribute it and/or modify
@@ -33,12 +33,12 @@
 }; /* 10 mili seconds */
 
 
-float x[3] = {0,0,0};
-float move[3] = {0,0,0};
+float x[3] = {0, 0, 0};
+float move[3] = {0, 0, 0};
 
 cwiid_err_t err;
 static int oid_head;
-static cwiid_wiimote_t *wiimote;	/* wiimote handle */
+static cwiid_wiimote_t *wiimote; /* wiimote handle */
 
 void err(cwiid_wiimote_t *wiimote, const char *s, va_list ap)
 {
@@ -49,40 +49,40 @@
 }
 static void mainloop(void)
 {
-	float pos;
-	struct cwiid_state state;	/* wiimote state */
-	cwiid_get_state(wiimote, &state);
-	float z_normvec[3] = {-1, 0, 0};
+	struct cwiid_state state; /* wiimote state */
+	float z_normvec[3] = { -1, 0, 0};
 	float x_normvec[3] = { 0, 1, 0};
 	float xrot, zrot;
 	float y[3];
-	
-	y[0] = (state.acc[CWIID_X]-128)/128.0; 
-	y[1] = (state.acc[CWIID_Y]-128)/128.0; 
-	y[2] = (state.acc[CWIID_Z]-128)/128.0; 
 
+	cwiid_get_state(wiimote, &state);
+
+	y[0] = (state.acc[CWIID_X] - 128) / 128.0;
+	y[1] = (state.acc[CWIID_Y] - 128) / 128.0;
+	y[2] = (state.acc[CWIID_Z] - 128) / 128.0;
+
 	/* smooth it */
-	x[0] = (x[0]*9 + y[0])/10;
-	x[1] = (x[1]*9 + y[1])/10;
-	x[2] = (x[2]*9 + y[2])/10;
+	x[0] = (x[0] * 9 + y[0]) / 10;
+	x[1] = (x[1] * 9 + y[1]) / 10;
+	x[2] = (x[2] * 9 + y[2]) / 10;
 
-	move[0] = ((x[0] - y[0] ) + move[0]*9)/10;
-	move[1] = ((x[2] - y[2] ) + move[1]*9)/10;
-	move[2] = ((y[1] - x[1] ) + move[2]*9)/10;
+	move[0] = ((x[0] - y[0]) + move[0] * 9) / 10;
+	move[1] = ((x[2] - y[2]) + move[1] * 9) / 10;
+	move[2] = ((y[1] - x[1]) + move[2] * 9) / 10;
 
 	xrot = s3d_vector_angle(x_normvec, x);
 	xrot = 90 - (180.0 / M_PI * xrot);
 
-/*	z_normvec[0] = -cos(xrot * M_PI/180) ;
-	z_normvec[1] = 0;
-	z_normvec[2] = +sin(xrot * M_PI/180) ;
-	printf("zn = %3.3f %3.3f %3.3f    ", z_normvec[0], z_normvec[1], z_normvec[2]);*/
+	/* z_normvec[0] = -cos(xrot * M_PI/180) ;
+	 z_normvec[1] = 0;
+	 z_normvec[2] = +sin(xrot * M_PI/180) ;
+	 printf("zn = %3.3f %3.3f %3.3f    ", z_normvec[0], z_normvec[1], z_normvec[2]);*/
 
 	zrot = s3d_vector_angle(z_normvec, x);
 	/* take care of inverse cosinus */
-	if (x[2] > 0) 					zrot = 180 - (180.0 / M_PI * zrot);
-	 else 							zrot = 180 + (180.0 / M_PI * zrot);
-	zrot-= 90;
+	if (x[2] > 0)      zrot = 180 - (180.0 / M_PI * zrot);
+	else        zrot = 180 + (180.0 / M_PI * zrot);
+	zrot -= 90;
 
 	printf("%3.3f %3.3f %3.3f, zrot = %3.3f, xrot = %3.3f\n", x[0], x[1], x[2], zrot, xrot);
 
@@ -94,15 +94,14 @@
 
 int main(int argc, char *argv[])
 {
-	bdaddr_t bdaddr;	/* bluetooth device address */
+	bdaddr_t bdaddr; /* bluetooth device address */
 
 	cwiid_set_err(err);
 
 	/* Connect to address given on command-line, if present */
 	if (argc > 1) {
 		str2ba(argv[1], &bdaddr);
-	}
-	else {
+	} else {
 		bdaddr = *BDADDR_ANY;
 	}
 
@@ -114,7 +113,7 @@
 		return -1;
 	}
 
-	cwiid_set_rpt_mode(wiimote, CWIID_RPT_BTN | CWIID_RPT_ACC| CWIID_RPT_IR| CWIID_RPT_NUNCHUK | CWIID_RPT_CLASSIC);
+	cwiid_set_rpt_mode(wiimote, CWIID_RPT_BTN | CWIID_RPT_ACC | CWIID_RPT_IR | CWIID_RPT_NUNCHUK | CWIID_RPT_CLASSIC);
 
 
 	if (!s3d_init(&argc, &argv, "wiitest")) {
@@ -124,5 +123,6 @@
 		s3d_quit();
 	}
 
+	return 0;
 }
 



From lazhur at mail.berlios.de  Sat Nov  3 09:55:00 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 3 Nov 2007 09:55:00 +0100
Subject: [S3d-svn] r841 - trunk/svnonly/wiitest
Message-ID: <200711030855.lA38t0FU030036@sheep.berlios.de>

Author: lazhur
Date: 2007-11-03 09:55:00 +0100 (Sat, 03 Nov 2007)
New Revision: 841

Modified:
   trunk/svnonly/wiitest/wiitest.c
Log:
wiitest: Mark local used, global defined variables/functions as static


Modified: trunk/svnonly/wiitest/wiitest.c
===================================================================
--- trunk/svnonly/wiitest/wiitest.c	2007-11-03 08:54:50 UTC (rev 840)
+++ trunk/svnonly/wiitest/wiitest.c	2007-11-03 08:55:00 UTC (rev 841)
@@ -33,14 +33,14 @@
 }; /* 10 mili seconds */
 
 
-float x[3] = {0, 0, 0};
-float move[3] = {0, 0, 0};
+static float x[3] = {0, 0, 0};
+static float move[3] = {0, 0, 0};
 
-cwiid_err_t err;
+static cwiid_err_t err;
 static int oid_head;
 static cwiid_wiimote_t *wiimote; /* wiimote handle */
 
-void err(cwiid_wiimote_t *wiimote, const char *s, va_list ap)
+static void err(cwiid_wiimote_t *wiimote, const char *s, va_list ap)
 {
 	if (wiimote) printf("%d:", cwiid_get_id(wiimote));
 	else printf("-1:");



From lazhur at mail.berlios.de  Sat Nov  3 09:55:06 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 3 Nov 2007 09:55:06 +0100
Subject: [S3d-svn] r842 - trunk/svnonly/testvis
Message-ID: <200711030855.lA38t6Is030065@sheep.berlios.de>

Author: lazhur
Date: 2007-11-03 09:55:06 +0100 (Sat, 03 Nov 2007)
New Revision: 842

Modified:
   trunk/svnonly/testvis/testvis.c
Log:
testvis: Use ansi declaration of main


Modified: trunk/svnonly/testvis/testvis.c
===================================================================
--- trunk/svnonly/testvis/testvis.c	2007-11-03 08:55:00 UTC (rev 841)
+++ trunk/svnonly/testvis/testvis.c	2007-11-03 08:55:06 UTC (rev 842)
@@ -154,7 +154,7 @@
 	return NULL;
 }
 
-int main()
+int main(void)
 {
 	char buffer[BUFFER_SIZE];
 	char *tmp_buffer;



From lazhur at mail.berlios.de  Sat Nov  3 09:55:11 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 3 Nov 2007 09:55:11 +0100
Subject: [S3d-svn] r843 - trunk/svnonly/testvis
Message-ID: <200711030855.lA38tBZH030089@sheep.berlios.de>

Author: lazhur
Date: 2007-11-03 09:55:11 +0100 (Sat, 03 Nov 2007)
New Revision: 843

Modified:
   trunk/svnonly/testvis/testvis.c
Log:
testvis: Mark only local used functions as static


Modified: trunk/svnonly/testvis/testvis.c
===================================================================
--- trunk/svnonly/testvis/testvis.c	2007-11-03 08:55:06 UTC (rev 842)
+++ trunk/svnonly/testvis/testvis.c	2007-11-03 08:55:11 UTC (rev 843)
@@ -25,7 +25,7 @@
 };
 
 
-void list_data(struct data *head, struct data *end)
+static void list_data(struct data *head, struct data *end)
 {
 	struct data *tmp;
 
@@ -34,7 +34,7 @@
 	}
 }
 
-void rem_data(int index, struct data *head, struct data *end)
+static void rem_data(int index, struct data *head, struct data *end)
 {
 	struct data *tmp, *prev = head;
 
@@ -55,7 +55,7 @@
 	return;
 }
 
-void dea_data(int index, struct data *head, struct data *end)
+static void dea_data(int index, struct data *head, struct data *end)
 {
 	struct data *tmp;
 
@@ -70,7 +70,7 @@
 	return;
 }
 
-void act_data(int index, struct data *head, struct data *end)
+static void act_data(int index, struct data *head, struct data *end)
 {
 	struct data *tmp;
 
@@ -90,7 +90,7 @@
 	return;
 }
 
-void *server(void *args)
+static void *server(void *args)
 {
 	struct t_data *t = (struct t_data*)args;
 	int listen_fd, yes = 1;



From lazhur at mail.berlios.de  Sat Nov  3 10:12:02 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 3 Nov 2007 10:12:02 +0100
Subject: [S3d-svn] r844 - trunk
Message-ID: <200711030912.lA39C2hn030886@sheep.berlios.de>

Author: lazhur
Date: 2007-11-03 10:12:01 +0100 (Sat, 03 Nov 2007)
New Revision: 844

Modified:
   trunk/INSTALL
   trunk/README
Log:
Update ReadMe

- Remove trailing spaces
- Sort team by surname
- Remove olsrs3d from license list


Modified: trunk/INSTALL
===================================================================
--- trunk/INSTALL	2007-11-03 08:55:11 UTC (rev 843)
+++ trunk/INSTALL	2007-11-03 09:12:01 UTC (rev 844)
@@ -98,5 +98,3 @@
 $ s3d
 
 (note, this time without --no-rc)
-
-

Modified: trunk/README
===================================================================
--- trunk/README	2007-11-03 08:55:11 UTC (rev 843)
+++ trunk/README	2007-11-03 09:12:01 UTC (rev 844)
@@ -21,11 +21,11 @@
 desktops.
 
 I think a 3d desktop would/could be a very interesting thing (when it works :),
-since it gives so many new possibility's in GUI design (or possibilitys in 
-confusing users, depends on readers view). 
-there are/were other projects like 3dwm which died somehow (3dwm.org is not 
-accessable, for me), and I did not understand it's system thou ... looking 
-glass from sun seems to be very interesting too, but I haven't tried it out 
+since it gives so many new possibility's in GUI design (or possibilitys in
+confusing users, depends on readers view).
+there are/were other projects like 3dwm which died somehow (3dwm.org is not
+accessable, for me), and I did not understand it's system thou ... looking
+glass from sun seems to be very interesting too, but I haven't tried it out
 yet ... so my ignorance and stupidity were reasons for this project as well :)
 
 2.INSTALL
@@ -37,7 +37,7 @@
 -----------
 
 I've written this program to satisfy myself (in some way), so please don't
-assume that it could have ANY USEFULNESS. I just published it because I 
+assume that it could have ANY USEFULNESS. I just published it because I
 thought someone might find it interesting, but there is no warranty for
 anything. if you find bugs or you have ideas what you would like to see
 implemented, or patches, please drop me a line.
@@ -45,19 +45,18 @@
 4. LICENSE
 ----------
 
-All those things are published under the GPLv2 or later at your option. 
-The Library is licensed under the GNU Lesser GPL (LGPL), so you can 
-also write close-sourced thing which links to the library (if you 
+All those things are published under the GPLv2 or later at your option.
+The Library is licensed under the GNU Lesser GPL (LGPL), so you can
+also write close-sourced thing which links to the library (if you
 really have to ...).
 COPYING for the GPLv2 and COPYING.LESSER for the LGPLv2.1 are included too.
-if I'm mistaken in any ownership-concerns, please tell me and don't be 
+if I'm mistaken in any ownership-concerns, please tell me and don't be
 too mad at me, as I have had no idea of licensing at all.
 
 Applications (GPLv2 or later):
 * apps/dot_mcp
 * apps/kism3d
 * apps/meshs3d
-* apps/olsrs3d
 * apps/s3d_x11gate
 * apps/s3dfm
 * apps/s3dosm
@@ -87,10 +86,9 @@
 -------
 	Sven Eckelmann <ecsv at hrz.tu-chemnitz.de>
 	Mike Graenz <mog at users.berlios.de>
+	Andreas Kohn <andreas at syndrom23.de>
 	Andreas Langer <andreas_lbg at gmx.de>
 	Marek Lindner <lindner_marek at yahoo.de>
-	Andreas Kohn <andreas at syndrom23.de>
 	Timo Schneider <timos at hrz.tu-chemnitz.de>
 	Christiane Weidauer <yd at freakkind.de>
 	Simon Wunderlich <dotslash at packetmixer.de>
-	



From dotslash at mail.berlios.de  Wed Nov  7 19:52:59 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 7 Nov 2007 19:52:59 +0100
Subject: [S3d-svn] r845 - trunk/server
Message-ID: <200711071852.lA7IqxGF031071@sheep.berlios.de>

Author: dotslash
Date: 2007-11-07 19:52:59 +0100 (Wed, 07 Nov 2007)
New Revision: 845

Modified:
   trunk/server/THREADS
Log:
- update lock proposal for the thread implementation, probably incomplete


Modified: trunk/server/THREADS
===================================================================
--- trunk/server/THREADS	2007-11-03 09:12:01 UTC (rev 844)
+++ trunk/server/THREADS	2007-11-07 18:52:59 UTC (rev 845)
@@ -26,20 +26,58 @@
 		
 idea:
 -----
-TODO: formulate locks
+NEW: 
+  process states:
+  UNINITIALIZED:    process has just been created, probably waiting for INIT from client
+  GOT_INIT:         received the INIT, waiting for cleanup thread to set it up (mcp etc)
+  RUNNING:          everything is set up
+  WAIT_TO_DIE:      tells the client to quit as soon as possible.
+  THREAD_LEFT:      client thread left, 
+  
+
 process threads:
 each process has its own thread, blocking in tcp_proc_com_in if TCP, or simply sleeping in SHM 
-(pollin will be done in network thread)
+(polling will be done in network thread):
+* block in read()
+* if process->state == WAIT_TO_DIE, set process->state = THREAD_LEFT and thread is removed
+* lock processlist readonly
+* handle incoming packet
+* maybe send reply
 
-network thread:
+
+network/cleanup thread:
 does tcp_pollport, spawning new process-threads. After select times out, it polls all SHM 
 connections if there is new data and wakes process threads up if there is anything to do.
+* block for some time (200ms?), select() for incoming tcp connection
+* if new connection, 
+  * lock proccess list writeonly
+  * setup new process, add mcp-things etc
+  * unlock processlist
+* lock processlist readonly
+* iterate over processes, if SHM-connection and there is new data available wake it up (send condition-signal)
+* if one process wants to quit (process->state == THREAD_LEFT), remember it for deletion
+* unlock processlist
+* if a process wants to quit
+  * lock processlist writeonly
+  * remove the process(es)
+  * unlock processlist
 
 graphic thread:
 draws a frame and sleeps until it wakes up. processes make wake it up when new data was
 received, or user events (pick object, window was resized/damaged).
+* wait for signal to draw, or sleep 1 second (don't update too often, check for last update)
+* lock processlist readonly
+* render_by_mcp() locks mcp
+   * obj_render() locks further objects
+* unlock processlist
 
 user/event thread:
 processes events from outside (via SDL), send notifications to the processes
 
-
+* block for the next SDL event (SDL_WaitEvent)
+* lock processlist readonly
+* when clicking, do as in graphic thread
+* lock the process which receives the event
+* send the event
+* unlock process
+* unlock processlist



From dotslash at mail.berlios.de  Thu Nov  8 21:31:03 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 8 Nov 2007 21:31:03 +0100
Subject: [S3d-svn] r846 - trunk/server
Message-ID: <200711082031.lA8KV3dI012504@sheep.berlios.de>

Author: dotslash
Date: 2007-11-08 21:31:03 +0100 (Thu, 08 Nov 2007)
New Revision: 846

Modified:
   trunk/server/event.c
   trunk/server/global.h
   trunk/server/graphics.c
   trunk/server/mcp.c
   trunk/server/object.c
   trunk/server/process.c
Log:
- don't store pids or oids in variables like n_vertex or n_mat. 


Modified: trunk/server/event.c
===================================================================
--- trunk/server/event.c	2007-11-07 18:52:59 UTC (rev 845)
+++ trunk/server/event.c	2007-11-08 20:31:03 UTC (rev 846)
@@ -53,7 +53,7 @@
 	k[2] = htons(mod);
 	k[3] = htons(state);
 	if (OBJ_VALID(get_proc_by_pid(MCP), focus_oid, o))
-		prot_com_out(get_proc_by_pid(o->n_mat), S3D_P_S_KEY, (uint8_t *)k, 8);
+		prot_com_out(get_proc_by_pid(o->virtual_pid), S3D_P_S_KEY, (uint8_t *)k, 8);
 	prot_com_out(get_proc_by_pid(MCP), S3D_P_S_KEY, (uint8_t *)k, 8); /* mcp always gets a copy */
 	return(0);
 }
@@ -67,7 +67,7 @@
 	b[0] = button;
 	b[1] = state;
 	if (OBJ_VALID(get_proc_by_pid(MCP), focus_oid, o))
-		prot_com_out(get_proc_by_pid(o->n_mat), S3D_P_S_MBUTTON, (uint8_t *)&b, 2);
+		prot_com_out(get_proc_by_pid(o->virtual_pid), S3D_P_S_MBUTTON, (uint8_t *)&b, 2);
 	prot_com_out(get_proc_by_pid(MCP), S3D_P_S_MBUTTON, (uint8_t *)&b, 2); /* mcp always gets a copy */
 	return(0);
 }
@@ -95,7 +95,7 @@
 	p = get_proc_by_pid(MCP);
 	event_obj_info(p, 0);
 	if (OBJ_VALID(p, focus_oid, o))
-		event_obj_info(get_proc_by_pid(o->n_mat), 0);
+		event_obj_info(get_proc_by_pid(o->virtual_pid), 0);
 	return(0);
 }
 /* same for the mouse movement! */
@@ -106,7 +106,7 @@
 	p = get_proc_by_pid(MCP);
 	event_obj_info(p, get_pointer(p));
 	if (OBJ_VALID(p, focus_oid, o)) {
-		p = get_proc_by_pid(o->n_mat); /* focused program pointer*/
+		p = get_proc_by_pid(o->virtual_pid); /* focused program pointer*/
 		event_obj_info(p, get_pointer(p));
 	}
 	return(0);
@@ -135,7 +135,7 @@
 		memset(mo.name, 0, S3D_NAME_MAX);
 		switch (o->oflags&OF_TYPE) {
 		case OF_VIRTUAL:
-			ap = get_proc_by_pid(o->n_mat);
+			ap = get_proc_by_pid(o->virtual_pid);
 			strncpy(mo.name, ap->name, S3D_NAME_MAX);
 			break;
 		case OF_CAM:

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2007-11-07 18:52:59 UTC (rev 845)
+++ trunk/server/global.h	2007-11-08 20:31:03 UTC (rev 846)
@@ -141,10 +141,10 @@
 #define OF_3DPOINTER 0xB0000000
 
 #define OF_MASK   0x00FFFFFF
+	int32_t virtual_pid;		/* if virtual, this contains the pid */
+	int32_t clone_ooid;			/* if clone, this contains the oid of the original */
+
 	int32_t n_vertex, n_mat, n_poly, n_tex, n_line;
-	/*  if OF_VIRTUAL is set, n_mat contains the pid */
-	/*  if OF_CLONE is set, n_vertex contains the original oid */
-	/*  I know this is dirty, but it would a waste of data if I don't do so ... */
 	int32_t dplist;   /*  opengl display list number */
 	int32_t linkid;   /*  linking target, -1 if there is none */
 	int32_t lsub, lnext, lprev;

Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2007-11-07 18:52:59 UTC (rev 845)
+++ trunk/server/graphics.c	2007-11-08 20:31:03 UTC (rev 846)
@@ -125,7 +125,7 @@
 	glMultMatrixf(o->m);
 	glGetFloatv(GL_MODELVIEW_MATRIX, m);
 	cull_get_planes();
-	if (NULL == (ap = get_proc_by_pid(o->n_mat))) { /*  the clean way */
+	if (NULL == (ap = get_proc_by_pid(o->virtual_pid))) { /*  the clean way */
 		errds(HIGH, "render_by_mcp()", "not existing pid (%d) referenced by mcp-object!!", o);
 	} else {
 		/*  now go throu the objects of our app  */
@@ -197,12 +197,12 @@
 							}
 						}
 					}
-				} else if ((o->oflags&OF_CLONE) && (p->object[o->n_vertex]->oflags&OF_VIRTUAL)) { /* it's a clone of an app */
+				} else if ((o->oflags&OF_CLONE) && (p->object[o->clone_ooid]->oflags&OF_VIRTUAL)) { /* it's a clone of an app */
 					if (select_mode == 1)
-						glLoadName(o->n_vertex);/*TODO: what to do if a clone is selected?! */
+						glLoadName(o->clone_ooid);/*TODO: what to do if a clone is selected?! */
 					glPushMatrix();
 					render_virtual_object(o);
-					render_virtual_object(p->object[o->n_vertex]);
+					render_virtual_object(p->object[o->clone_ooid]);
 					glPopMatrix();
 				} else { /* it's a "regular" mcp object */
 					if (select_mode == 1) {
@@ -309,8 +309,8 @@
 			if ((names > 1) && ((mcp_o >= 0) && (mcp_o < p->n_obj))) { /* it's an usual object */
 				s3dprintf(LOW, "clicked on mcp-object %d, object %d", mcp_o, o);
 				if (p->object[mcp_o] != NULL) { /*  that shouldn't happen anyways ... */
-					obj_debug(get_proc_by_pid(p->object[mcp_o]->n_mat), o);
-					event_obj_click(get_proc_by_pid(p->object[mcp_o]->n_mat), o);
+					obj_debug(get_proc_by_pid(p->object[mcp_o]->virtual_pid), o);
+					event_obj_click(get_proc_by_pid(p->object[mcp_o]->virtual_pid), o);
 				}
 			}
 	}

Modified: trunk/server/mcp.c
===================================================================
--- trunk/server/mcp.c	2007-11-07 18:52:59 UTC (rev 845)
+++ trunk/server/mcp.c	2007-11-08 20:31:03 UTC (rev 846)
@@ -74,7 +74,7 @@
 	mo.trans_z = p->object[mcp_oid]->translate.z;
 	mo.r = p->object[mcp_oid]->r;
 	/*  mo.event=MCP_NEW_OBJECT; */
-	ap = get_proc_by_pid(p->object[mcp_oid]->n_mat);
+	ap = get_proc_by_pid(p->object[mcp_oid]->virtual_pid);
 	strncpy(mo.name, ap->name, S3D_NAME_MAX);
 	prot_com_out(p, S3D_P_MCP_OBJECT, (uint8_t *)&mo, sizeof(struct mcp_object));
 	return(0);

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-11-07 18:52:59 UTC (rev 845)
+++ trunk/server/object.c	2007-11-08 20:31:03 UTC (rev 846)
@@ -51,8 +51,8 @@
 		if (o->oflags&OF_SYSTEM) {
 			s3dprintf(HIGH, "it's a system object!!");
 		} else if (o->oflags&OF_CLONE) {
-			s3dprintf(HIGH, "it's a clone linking to %d", o->n_vertex);
-			obj_debug(p, o->n_vertex);
+			s3dprintf(HIGH, "it's a clone linking to %d", o->clone_ooid);
+			obj_debug(p, o->clone_ooid);
 		}
 	} else {
 		s3dprintf(HIGH, "can't get oid %d pid %d", oid, p->id);
@@ -569,7 +569,7 @@
 			is_clnsrc = 0;
 			for (i = 0;i < p->n_obj;i++) {
 				if (p->object[i] != NULL) {
-					if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex == oid)) { /* if it's pointing to our object ... */
+					if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->clone_ooid == oid)) { /* if it's pointing to our object ... */
 						is_clnsrc = 1;
 						p->object[i]->r = obj->r * (p->object[i]->r / obj->scale); /* give it the new radius too! */
 						obj_check_biggest_object(p, i);
@@ -1184,7 +1184,7 @@
 		vp = o->p_vertex;
 		vn = o->n_vertex;
 		if (o->oflags&OF_CLONE) {
-			o2 = p->object[o->n_vertex];  /*  get the target into o2*/
+			o2 = p->object[o->clone_ooid];  /*  get the target into o2*/
 			o->r = o2->r * (o->scale / o2->scale);
 			obj_check_biggest_object(p, oid);
 			return;
@@ -1203,7 +1203,7 @@
 				is_clnsrc = 0;
 				for (i = 0;i < p->n_obj;i++) {
 					if (p->object[i] != NULL) {
-						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex == oid)) { /* if it's pointing to our object ... */
+						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->clone_ooid == oid)) { /* if it's pointing to our object ... */
 							is_clnsrc = 1;
 							p->object[i]->r = o->r * (p->object[i]->r / o->scale); /* give it the new radius too! */
 							obj_check_biggest_object(p, i);
@@ -1348,7 +1348,7 @@
 		if (o->oflags&OF_SYSTEM) /* TODO: what will we do if $sys_object is linked to another? */
 		{ /* a system object changed position? let's update the focus'ed sys-objects */
 			if (OBJ_VALID(p, focus_oid, ao))
-				if (NULL != (ap = get_proc_by_pid(ao->n_mat))) {
+				if (NULL != (ap = get_proc_by_pid(ao->virtual_pid))) {
 					if (OF_POINTER == (o->oflags&0xF0000000)) { /* we dont have to do that much in this case ... */
 						if (OBJ_VALID(ap, get_pointer(ap), ao)) { /* we can redefine ao here -> ao = focused app's pointer*/
 							ao->rotate.x = o->rotate.x;
@@ -1573,7 +1573,7 @@
 	glMultMatrixf(obj->m);
 	/* into_position(p,obj,0);*/
 	if (obj->oflags&OF_SYSTEM)  return(-1);      /* can't render system objects */
-	if (obj->oflags&OF_CLONE)  obj = p->object[obj->n_vertex];  /* it's a clone - draw the clone! */
+	if (obj->oflags&OF_CLONE)  obj = p->object[obj->clone_ooid];  /* it's a clone - draw the clone! */
 	if (!obj->dplist) {
 		texture_gen(obj);
 		obj->dplist = glGenLists(1);
@@ -1818,6 +1818,8 @@
 	obj->translate.x = obj->translate.y = obj->translate.z = 0.0F;
 	obj->scale = 1.0F;
 	obj->n_vertex = obj->n_poly = obj->n_mat = obj->n_tex = 0;
+	obj->clone_ooid = 0;
+	obj->virtual_pid = 0;
 	obj->r = obj->or = 0.0F;
 	obj->m_uptodate = 0;
 	memcpy(obj->m, Identity, sizeof(t_mtrx));
@@ -1869,7 +1871,7 @@
 					is_clnsrc = 0;
 					for (i = 0;i < p->n_obj;i++)
 						if (p->object[i] != NULL)
-							if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex == oid)) { /*  it's linking to our object! */
+							if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->clone_ooid == oid)) { /*  it's linking to our object! */
 								errds(VHIGH, "obj_clone_change()", "couldn't clone %d from %d (on pid %d): object %d is already cloning from object %d.",
 								      oid, toid, p->id, oid, i, oid);
 								return(-1);
@@ -1883,7 +1885,7 @@
 			if (oid != toid) { /*  don't looplink */
 				o->oflags |= OF_CLONE;
 				no->oflags |= OF_CLONE_SRC;
-				o->n_vertex = toid;  /*  n_vertex is not used for this as it's just cloned, so we can use it ... */
+				o->clone_ooid = toid;  
 				obj_size_update(p, oid);
 				s3dprintf(LOW, "changed clone-target of obj %d to %d of process %d", oid, toid, p->id);
 				if (p->id != MCP) obj_check_biggest_object(p, oid);
@@ -1920,8 +1922,8 @@
 
 		if (p->id == MCP) {
 			if (o->oflags&OF_VIRTUAL) { /*  only delete if virtual */
-				s3dprintf(HIGH, "the mcp wants %d to be closed", o->n_mat);
-				event_quit(get_proc_by_pid(o->n_mat));
+				s3dprintf(HIGH, "the mcp wants %d to be closed", o->virtual_pid);
+				event_quit(get_proc_by_pid(o->virtual_pid));
 				return(0);
 			}
 		} else
@@ -1949,9 +1951,9 @@
 			if (o->oflags&OF_CLONE_SRC)
 				for (i = 0;i < p->n_obj;i++)
 					if (p->object[i] != NULL)
-						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex == oid)) { /*  it's linking to our object! */
+						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->clone_ooid == oid)) { /*  it's linking to our object! */
 							p->object[i]->oflags &= ~OF_CLONE;  /*  disable clone flag */
-							p->object[i]->n_vertex = 0;   /*  and "clone reference" to 0 */
+							p->object[i]->clone_ooid = -1;   /*  and "clone reference" to 0 */
 							p->object[i]->r = 0.0F;   /*  empty object, so radius is zero! */
 							if (p->id != MCP) obj_check_biggest_object(p, i);
 						}

Modified: trunk/server/process.c
===================================================================
--- trunk/server/process.c	2007-11-07 18:52:59 UTC (rev 845)
+++ trunk/server/process.c	2007-11-08 20:31:03 UTC (rev 846)
@@ -70,7 +70,7 @@
 		/* register the new process in the mcp */
 		if (-1 != (mcp_oid = obj_new(&procs_p[MCP]))) {
 			mcp_p->object[mcp_oid]->oflags |= OF_VIRTUAL | OF_VISIBLE | OF_SELECTABLE;
-			mcp_p->object[mcp_oid]->n_mat = p->id;
+			mcp_p->object[mcp_oid]->virtual_pid = p->id;
 
 			/*   mcp_p->object[mcp_oid]->p_mat=(struct t_material *)new_p; */
 			/*  dirty, but it's just a pointer after all ... */
@@ -167,7 +167,7 @@
 		memcpy(&procs_p[pid], &procs_p[procs_n-1], sizeof(struct t_process));
 		procs_p[pid].id = pid; /* change the pid of the new procs_p */
 		if (procs_p[pid].mcp_oid != -1) /* the last process could just appear without initializing yet ... */
-			procs_p[0].object[procs_p[pid].mcp_oid]->n_mat = pid;
+			procs_p[0].object[procs_p[pid].mcp_oid]->virtual_pid = pid;
 		/* change the mcp-objects pid-pointer to the right position! */
 		/* this is kind of pointer madness */
 	}
@@ -190,9 +190,9 @@
 		if (p->mcp_oid != -1) {
 			for (j = 0;j < mcp_p->n_obj;j++)  /*  remove clones and links pointing on this app-object ... */
 				if (mcp_p->object[j] != NULL) {
-					if ((mcp_p->object[j]->oflags&OF_CLONE) && (mcp_p->object[j]->n_vertex == p->mcp_oid)) { /*  it's linking to our object! */
+					if ((mcp_p->object[j]->oflags&OF_CLONE) && (mcp_p->object[j]->clone_ooid == p->mcp_oid)) { /*  it's linking to our object! */
 						mcp_p->object[j]->oflags &= ~OF_CLONE;  /*  disable clone flag */
-						mcp_p->object[j]->n_vertex = 0;   /*  and "clone reference" to 0 */
+						mcp_p->object[j]->clone_ooid = 0;   /*  and "clone reference" to 0 */
 						mcp_p->object[j]->r = 0.0F;   /*  empty object, so radius is zero! */
 					}
 				}



From dotslash at mail.berlios.de  Thu Nov  8 21:40:41 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 8 Nov 2007 21:40:41 +0100
Subject: [S3d-svn] r847 - trunk/server
Message-ID: <200711082040.lA8KefVO013120@sheep.berlios.de>

Author: dotslash
Date: 2007-11-08 21:40:41 +0100 (Thu, 08 Nov 2007)
New Revision: 847

Modified:
   trunk/server/object.c
Log:
- don't use ugly log() to get the next power of 2 for the texture size


Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-11-08 20:31:03 UTC (rev 846)
+++ trunk/server/object.c	2007-11-08 20:40:41 UTC (rev 847)
@@ -255,7 +255,6 @@
 int obj_push_tex(struct t_process *p, int32_t oid, uint16_t *x, int32_t n)
 {
 	int32_t i, m;
-	double d;
 	struct t_tex *p_tex;
 	struct t_obj *obj;
 	uint16_t *px, hm;
@@ -280,26 +279,27 @@
 				obj->p_tex[m+i].th = *(px++);
 				if ((obj->p_tex[m+i].tw <= TEXTURE_MAX_W) && (obj->p_tex[m+i].th <= TEXTURE_MAX_H) &&
 				                (obj->p_tex[m+i].tw > 0) && (obj->p_tex[m+i].th > 0)) {
-					d = log((double)obj->p_tex[m+i].tw) / log(2.0);
-					hm = pow(2, floor(d));
+					/* find the next power of 2 that can hold the width of the texture */
+					for (hm = 1; hm < obj->p_tex[m+i].tw; hm *= 2);
 					s3dprintf(MED, "hm %d, tw %d", hm, obj->p_tex[m+i].tw);
-					if (hm != obj->p_tex[m+i].tw)  {
-						obj->p_tex[m+i].w = hm * 2;
+					if (hm == obj->p_tex[m+i].tw)  {
+						obj->p_tex[m+i].xs = 1.0;
+						obj->p_tex[m+i].w = hm;
+
+					} else {
+						obj->p_tex[m+i].w = hm;
 						obj->p_tex[m+i].xs = (float)((double)obj->p_tex[m+i].tw) / ((double)obj->p_tex[m+i].w);
-					} else {
-						obj->p_tex[m+i].xs = 1.0;
-						obj->p_tex[m+i].w = obj->p_tex[m+i].tw;
 					}
-					d = log((double)obj->p_tex[m+i].th) / log(2.0);
-					hm = pow(2, floor(d));
+					/* find the next power of 2 that can hold the height of the texture */
+					for (hm = 1; hm < obj->p_tex[m+i].th; hm *= 2);
 					s3dprintf(MED, "hm %d, th %d", hm, obj->p_tex[m+i].th);
 
-					if (hm != obj->p_tex[m+i].th)  {
-						obj->p_tex[m+i].h = hm * 2;
-						obj->p_tex[m+i].ys = (float)((double)obj->p_tex[m+i].th) / ((double)obj->p_tex[m+i].h);
-					} else  {
+					if (hm == obj->p_tex[m+i].th)  {
 						obj->p_tex[m+i].ys = 1.0;
 						obj->p_tex[m+i].h = obj->p_tex[m+i].th;
+					} else  {
+						obj->p_tex[m+i].h = hm;
+						obj->p_tex[m+i].ys = (float)((double)obj->p_tex[m+i].th) / ((double)obj->p_tex[m+i].h);
 					}
 					obj->p_tex[m+i].buf = malloc(obj->p_tex[m+i].h * obj->p_tex[m+i].w * 4);
 					memset(obj->p_tex[m+i].buf, 0, obj->p_tex[m+i].h*obj->p_tex[m+i].w*4);



From dotslash at mail.berlios.de  Thu Nov  8 22:20:39 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 8 Nov 2007 22:20:39 +0100
Subject: [S3d-svn] r848 - trunk/svnonly/comptest
Message-ID: <200711082120.lA8LKdQH015219@sheep.berlios.de>

Author: dotslash
Date: 2007-11-08 22:20:39 +0100 (Thu, 08 Nov 2007)
New Revision: 848

Modified:
   trunk/svnonly/comptest/comptest.c
Log:
- print BadMatch Errors
- remove some of them


Modified: trunk/svnonly/comptest/comptest.c
===================================================================
--- trunk/svnonly/comptest/comptest.c	2007-11-08 20:40:41 UTC (rev 847)
+++ trunk/svnonly/comptest/comptest.c	2007-11-08 21:20:39 UTC (rev 848)
@@ -103,6 +103,12 @@
 {
 	char *name = "unknown";
 	switch (event->type & 0x7f) {
+	case CreateNotify:
+		name = "Create";
+		break;
+	case DestroyNotify:
+		name = "Destroy";
+		break;
 	case Expose:
 		name = "Expose";
 		break;
@@ -181,7 +187,13 @@
 	default:
 		break;
 	}
+	switch (event->error_code) {
+	case BadMatch:
+		name = "BadMatch";
+		break;
+	}
 
+
 	printf("error %d (name: %s) request %d minor %d serial %d\n",
 	       event->error_code, name, event->request_code, event->minor_code, (int)event->serial);
 	return(0);
@@ -459,6 +471,15 @@
 	char *bitmap;
 	XImage *image;
 
+	if (win->attr.map_state == IsUnmapped)	/* not mapped images can't be grabbed */
+		return;
+
+	if (win->attr.class == InputOnly)		/* can't grab image from this source */
+	{
+		printf("inputonly window\n");
+		return;
+	}
+
 	/* update the whole window for now. */
 	/* x = 50;
 	 y = 50;
@@ -485,8 +506,9 @@
 		if (xright > (x + width))
 			xright = x + width;
 		chunk_width = xright - xleft;
+/*		printf("map-state = %d, backing_store = %d\n", win->attr.map_state);
 		printf("request image: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d, ~TEXW = %08x\n",
-		       xleft, xright, width, x, y, width, height, ~TEXW);
+		       xleft, xright, width, x, y, width, height, ~TEXW);*/
 		image = XGetImage(dpy, win->id, xleft, y, chunk_width, height, AllPlanes, ZPixmap);
 		if (!image)
 			return;



From dotslash at mail.berlios.de  Thu Nov  8 23:18:15 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 8 Nov 2007 23:18:15 +0100
Subject: [S3d-svn] r849 - trunk/svnonly/comptest
Message-ID: <200711082218.lA8MIFR3018150@sheep.berlios.de>

Author: dotslash
Date: 2007-11-08 23:18:15 +0100 (Thu, 08 Nov 2007)
New Revision: 849

Modified:
   trunk/svnonly/comptest/comptest.c
Log:
- handle window-create and destroy events


Modified: trunk/svnonly/comptest/comptest.c
===================================================================
--- trunk/svnonly/comptest/comptest.c	2007-11-08 21:20:39 UTC (rev 848)
+++ trunk/svnonly/comptest/comptest.c	2007-11-08 22:18:15 UTC (rev 849)
@@ -126,22 +126,13 @@
 		break;
 	}
 	if (event->type == xdamage.event + XDamageNotify) {
-		/* XDamageNotifyEvent *e = (XDamageNotifyEvent*) event; */
-		/* e->drawable is the window ID of the damaged window
-		   e->geometry is the geometry of the damaged window
-		   e->area     is the bounding rect for the damaged area
-		   e->damage   is the damage handle returned by XDamageCreate() */
-
-		/* Subtract all the damage, repairing the window. */
 		name = "Damage!!";
+		return(0); /* don't report this. */
 	} else if (event->type == ConfigureNotify) {
-		/* XConfigureEvent *e = &event->xconfigure; */
-		/* The windows size, position or Z index in the stacking
-		   order has changed */
 		name = "Configure!!";
 	}
 
-	/* printf("Event: %s\n", name);*/
+	printf("Event: %s\n", name);
 	return(0);
 }
 
@@ -266,6 +257,8 @@
 	int vindex, voffset, pindex;
 	int xpos, ypos;
 
+	printf("draw new deco_box!!\n");
+
 	win->oid = s3d_new_object();
 	/*
 	 for (i = 0;i < 8;i++) {
@@ -320,6 +313,7 @@
 		}
 		vindex++;
 	}
+	printf("win->no == %d\n", win->no);
 	s3d_translate(win->oid, win->attr.x / 20, -win->attr.y / 20, 1 * win->no);
 	/*  push data on texture 0 position (0,0) */
 	s3d_flags_on(win->oid, S3D_OF_VISIBLE);
@@ -339,7 +333,7 @@
 static void window_add(Display *dpy, Window id)
 {
 	struct window *win;
-	win = malloc(sizeof(*win));
+	win = malloc(sizeof(struct window));
 	if (!win)
 		return;
 	win->id = id;
@@ -347,32 +341,51 @@
 
 	win->no = win_no++;
 	/* XSelectInput(dpy, win->id, ExposureMask|ButtonPressMask|KeyPressMask*/
-	XSelectInput(dpy, win->id, ExposureMask
-	             | SubstructureNotifyMask | ExposureMask | StructureNotifyMask | PropertyChangeMask);
-	/* XSelectInput(dpy, win->id, ExposureMask);*/
+/*	XSelectInput(dpy, win->id, SubstructureNotifyMask | ExposureMask | StructureNotifyMask | PropertyChangeMask);*/
+	XSelectInput(dpy, win->id, 0);
+
+	win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty);
 	win->format = XRenderFindVisualFormat(dpy, win->attr.visual);
 
 	if (win->format != NULL) {
 		/* printf("add window: %d:%d size: %dx%d\n", win->attr.x, win->attr.y, win->attr.width, win->attr.height);*/
-		win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty);
-
 		win->pa.subwindow_mode = IncludeInferiors;
 		win->picture = XRenderCreatePicture(dpy, win->id, win->format, CPSubwindowMode, &win->pa);
+	} else {
+		printf("Format = 0, no damage created\n");
+	}
+	win->oid = -1;
+	win->next = window_head;
+	window_head = win;
+	win->already_updated = 0;
+	window_update_content(win, 0, 0, win->attr.width, win->attr.height);
 
-		win->oid = -1;
-		win->already_updated = 0;
 
-		window_update_content(win, 0, 0, win->attr.width, win->attr.height);
 
-		win->next = window_head;
-		window_head = win;
-	}
 }
 
-static void window_remove(struct window *win)
+static void window_remove(Window id)
 {
+	struct window *window, *h;
+	if (window_head == NULL)
+		return;
+	if (window_head->id == id) {
+		window = window_head;
+		window_head = window_head->next;
+	} else {
+		for (window = window_head; window != NULL; window = window->next) {
+			if ((window->next != NULL) && (window->next->id == id)) {
+				h = window;
+				h->next = h->next->next;
+				window = window->next;
+			}
+		}
+		printf("not found (window %d) for removal.\n", (int)id);
+		return;
+	}
+
 	/* TODO */
-	free(win);
+	free(window);
 }
 
 static void window_update_geometry(struct window *win, int x, int y, int width, int height)
@@ -546,7 +559,8 @@
 	for (i = 0; i < MAXEVENTS && XPending(dpy); i++) {
 		XNextEvent(dpy, &event);
 		print_event(dpy, &event);
-		if (event.type == xdamage.event + XDamageNotify) {
+		switch (event.type - xdamage.event) {
+		case XDamageNotify:{
 			XDamageNotifyEvent *e = (XDamageNotifyEvent*) & event;
 			/*   printf("window = %d, geometry = %d:%d (at %d:%d), area = %d:%d (at %d:%d)\n",
 			          (int)e->drawable, e->geometry.width, e->geometry.height, e->geometry.x, e->geometry.y,
@@ -555,7 +569,12 @@
 			window = window_find(e->drawable);
 			if (window != NULL)
 				window_update_content(window, e->area.x, e->area.y, e->area.width, e->area.height);
-		} else if (event.type == ConfigureNotify) {
+			break;
+		   }
+
+		}
+		switch (event.type) {
+		case ConfigureNotify:{
 			XConfigureEvent *e = &event.xconfigure;
 			window = window_find(e->window);
 			if (window != NULL) {
@@ -565,6 +584,19 @@
 			} else {
 				printf("Configure: Could not find window to configure.\n");
 			}
+			break;
+			 }
+		case CreateNotify:{
+			XCreateWindowEvent *e = &event.xcreatewindow;
+			window_add(e->display, e->window);
+			printf("window added!!\n");
+			break;
+			}
+		case DestroyNotify:{
+			XDestroyWindowEvent *e = &event.xdestroywindow;
+			window_remove(e->window);
+			break;
+		   }
 		}
 	}
 }



From dotslash at mail.berlios.de  Fri Nov  9 00:10:20 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Fri, 9 Nov 2007 00:10:20 +0100
Subject: [S3d-svn] r850 - trunk/svnonly/comptest
Message-ID: <200711082310.lA8NAKbl021079@sheep.berlios.de>

Author: dotslash
Date: 2007-11-09 00:10:19 +0100 (Fri, 09 Nov 2007)
New Revision: 850

Modified:
   trunk/svnonly/comptest/comptest.c
Log:
- use correct z-order as we get it from configureevent 


Modified: trunk/svnonly/comptest/comptest.c
===================================================================
--- trunk/svnonly/comptest/comptest.c	2007-11-08 22:18:15 UTC (rev 849)
+++ trunk/svnonly/comptest/comptest.c	2007-11-08 23:10:19 UTC (rev 850)
@@ -82,6 +82,7 @@
 
 int xinit(void);
 void window_update_content(struct window *win, int x, int y, int width, int height);
+static void window_set_position(struct window *win);
 static int print_event(Display *dpy, XEvent *event);
 void event();
 
@@ -126,10 +127,10 @@
 		break;
 	}
 	if (event->type == xdamage.event + XDamageNotify) {
-		name = "Damage!!";
+		name = "Damage";
 		return(0); /* don't report this. */
 	} else if (event->type == ConfigureNotify) {
-		name = "Configure!!";
+		name = "Configure";
 	}
 
 	printf("Event: %s\n", name);
@@ -221,6 +222,11 @@
 	return(0);
 }
 
+static void window_set_position(struct window *win) {
+	s3d_translate(win->oid, win->attr.x / 20, -win->attr.y / 20, -0.01 * win->no);
+}
+
+
 static void deco_box(struct window *win)
 {
 	/* float vertices[8*3] = {
@@ -313,12 +319,46 @@
 		}
 		vindex++;
 	}
-	printf("win->no == %d\n", win->no);
-	s3d_translate(win->oid, win->attr.x / 20, -win->attr.y / 20, 1 * win->no);
+	window_set_position(win);
 	/*  push data on texture 0 position (0,0) */
 	s3d_flags_on(win->oid, S3D_OF_VISIBLE);
 }
-static struct window *window_find(Window id) {
+
+void window_restack(struct window *win, Window above) 
+{
+	struct window **wp;
+	Window old_above;
+	int i;
+	if (win->next == NULL)		old_above = None;
+	else						old_above = win->next->id;
+
+	if (old_above == above)		return;
+
+	/* unlink from list */
+	for (wp = &window_head; *wp != NULL; wp = &(*wp)->next) 
+		if (*wp == win)
+			break;
+
+	if (*wp == NULL) return;
+	*wp = win->next;
+
+	/* relink in front of the new "above" window */
+	for (wp = &window_head; *wp != NULL; wp = &(*wp)->next) 
+		if ((*wp)->id == above)
+			break;
+
+	win->next = *wp;
+	*wp = win;
+
+	for (i=0, wp = &window_head; *wp != NULL; wp = &(*wp)->next, i++)
+		if (i != (*wp)->no) {
+			(*wp)->no = i;
+			if ((*wp)->oid != -1)
+				window_set_position(*wp);
+		}
+}
+static struct window *window_find(Window id) 
+{
 	struct window *window;
 	for (window = window_head; window != NULL; window = window->next) {
 		if (window->id == id)
@@ -378,6 +418,7 @@
 				h = window;
 				h->next = h->next->next;
 				window = window->next;
+				break;
 			}
 		}
 		printf("not found (window %d) for removal.\n", (int)id);
@@ -387,7 +428,6 @@
 	/* TODO */
 	free(window);
 }
-
 static void window_update_geometry(struct window *win, int x, int y, int width, int height)
 {
 
@@ -408,7 +448,7 @@
 		} else {
 			win->attr.x = x;
 			win->attr.y = y;
-			s3d_translate(win->oid, win->attr.x / 20, -win->attr.y / 20, 1 * win->no);
+			window_set_position(win);
 		}
 	} else {
 		win->attr.x = x;
@@ -580,6 +620,7 @@
 			if (window != NULL) {
 				/*    printf("Configure: window = %d, geometry = %d:%d (at %d:%d)\n",
 				           (int)e->window, e->width, e->height, e->x, e->y);*/
+				window_restack(window, e->above);
 				window_update_geometry(window, e->x, e->y, e->width, e->height);
 			} else {
 				printf("Configure: Could not find window to configure.\n");



From dotslash at mail.berlios.de  Fri Nov  9 17:54:05 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Fri, 9 Nov 2007 17:54:05 +0100
Subject: [S3d-svn] r851 - trunk/svnonly/wiitest
Message-ID: <200711091654.lA9Gs5SW030589@sheep.berlios.de>

Author: dotslash
Date: 2007-11-09 17:54:05 +0100 (Fri, 09 Nov 2007)
New Revision: 851

Modified:
   trunk/svnonly/wiitest/wiitest.c
Log:
- wiitest: fixed rotation calculation
- smooth over the last N_SMOOTH entries
- code cleanup


Modified: trunk/svnonly/wiitest/wiitest.c
===================================================================
--- trunk/svnonly/wiitest/wiitest.c	2007-11-08 23:10:19 UTC (rev 850)
+++ trunk/svnonly/wiitest/wiitest.c	2007-11-09 16:54:05 UTC (rev 851)
@@ -27,19 +27,29 @@
 #include <s3d.h>
 #include <math.h> /* sin() */
 #include <time.h> /* nanosleep() */
+#define N_SMOOTH		8		/* how much data is used to normalize */
 
 static struct timespec t = {
 	0, 10*1000*1000
 }; /* 10 mili seconds */
 
 
-static float x[3] = {0, 0, 0};
-static float move[3] = {0, 0, 0};
+/* "public" wii-data */
+static float wii_x[3] = {0, 0, 0};
+static float wii_move[3] = {0, 0, 0};
+static float wii_xrot = 0;
+static float wii_zrot = 0;
 
+/* private wii-data */
+static float x_data[N_SMOOTH][3];
+static float move_data[N_SMOOTH][3];
+static int dataindex;
+
 static cwiid_err_t err;
-static int oid_head;
 static cwiid_wiimote_t *wiimote; /* wiimote handle */
 
+static int oid_head;
+
 static void err(cwiid_wiimote_t *wiimote, const char *s, va_list ap)
 {
 	if (wiimote) printf("%d:", cwiid_get_id(wiimote));
@@ -47,75 +57,111 @@
 	vprintf(s, ap);
 	printf("\n");
 }
-static void mainloop(void)
+
+
+int wii_init(char *addr) 
 {
+	int i,j;
+	bdaddr_t bdaddr; /* bluetooth device address */
+	cwiid_set_err(err);
+
+	/* Connect to address given on command-line, if present */
+	if (addr != NULL) {
+		str2ba(addr, &bdaddr);
+	} else {
+		bdaddr = *BDADDR_ANY;
+	}
+
+	/* Connect to the wiimote */
+	printf("Put Wiimote in discoverable mode now (press 1+2)...\n");
+
+	if (!(wiimote = cwiid_open(&bdaddr, 0))) {
+		fprintf(stderr, "Unable to connect to wiimote\n");
+		return -1;
+	}
+
+	cwiid_set_rpt_mode(wiimote, CWIID_RPT_BTN | CWIID_RPT_ACC | CWIID_RPT_IR | CWIID_RPT_NUNCHUK | CWIID_RPT_CLASSIC);
+
+	for (i = 0; i < N_SMOOTH; i++)
+		for (j = 0; j < 3; j++) {
+			x_data[i][j] = 0;
+			move_data[i][j] = 0;
+		}
+	dataindex = 0;
+	return(0);
+
+}
+void wii_calcdata() 
+{
 	struct cwiid_state state; /* wiimote state */
-	float z_normvec[3] = { -1, 0, 0};
-	float x_normvec[3] = { 0, 1, 0};
-	float xrot, zrot;
+	float z_normvec[3] = { 0, -1, 0};
+	float x_normvec[3] = { 0, 0, 1};
 	float y[3];
+	int i,j;
+	int lastindex;
 
 	cwiid_get_state(wiimote, &state);
 
-	y[0] = (state.acc[CWIID_X] - 128) / 128.0;
-	y[1] = (state.acc[CWIID_Y] - 128) / 128.0;
-	y[2] = (state.acc[CWIID_Z] - 128) / 128.0;
+	x_data[dataindex][0] = (state.acc[CWIID_X] - 128) / 128.0;
+	x_data[dataindex][2] = (state.acc[CWIID_Y] - 128) / 128.0;
+	x_data[dataindex][1] = (state.acc[CWIID_Z] - 128) / 128.0;
 
+	lastindex = (dataindex + N_SMOOTH - 1) % MAXNORM;
+	move_data[dataindex][0] =   x_data[lastindex][0] - x_data[dataindex][0];
+	move_data[dataindex][1] =   x_data[lastindex][1] - x_data[dataindex][1];
+	move_data[dataindex][2] = - x_data[lastindex][2] + x_data[dataindex][2];
+	dataindex = (dataindex + 1)%N_SMOOTH;
 	/* smooth it */
-	x[0] = (x[0] * 9 + y[0]) / 10;
-	x[1] = (x[1] * 9 + y[1]) / 10;
-	x[2] = (x[2] * 9 + y[2]) / 10;
+	for (j = 0; j < 3; j++) {
+		wii_x[j] = 0;
+		wii_move[j] = 0;
+	}
+	for (i = 0; i< N_SMOOTH; i++) 
+		for (j = 0; j < 3; j++) {
+			wii_x[j] +=    x_data[i][j];
+			wii_move[j] += move_data[i][j];
+	}
+	for (j = 0; j< 3; j++) {
+		wii_x[j] /= N_SMOOTH;
+		wii_move[j] /= N_SMOOTH;
+	}
 
-	move[0] = ((x[0] - y[0]) + move[0] * 9) / 10;
-	move[1] = ((x[2] - y[2]) + move[1] * 9) / 10;
-	move[2] = ((y[1] - x[1]) + move[2] * 9) / 10;
+	wii_xrot = s3d_vector_angle(x_normvec, wii_x);
+	wii_xrot = 90 - (180.0 / M_PI * wii_xrot);
 
-	xrot = s3d_vector_angle(x_normvec, x);
-	xrot = 90 - (180.0 / M_PI * xrot);
+	y[0] = wii_x[0];
+	y[1] = wii_x[1];
+	y[2] = 0;
 
-	/* z_normvec[0] = -cos(xrot * M_PI/180) ;
-	 z_normvec[1] = 0;
-	 z_normvec[2] = +sin(xrot * M_PI/180) ;
-	 printf("zn = %3.3f %3.3f %3.3f    ", z_normvec[0], z_normvec[1], z_normvec[2]);*/
-
-	zrot = s3d_vector_angle(z_normvec, x);
+	wii_zrot = s3d_vector_angle(z_normvec, y);
 	/* take care of inverse cosinus */
-	if (x[2] > 0)      zrot = 180 - (180.0 / M_PI * zrot);
-	else        zrot = 180 + (180.0 / M_PI * zrot);
-	zrot -= 90;
+	if (wii_x[0] < 0)   wii_zrot = 180 - (180.0 / M_PI * wii_zrot);
+	else        		wii_zrot = 180 + (180.0 / M_PI * wii_zrot);
+}
 
-	printf("%3.3f %3.3f %3.3f, zrot = %3.3f, xrot = %3.3f\n", x[0], x[1], x[2], zrot, xrot);
 
-	s3d_rotate(oid_head, xrot, 0, zrot);
-	s3d_translate(oid_head, move[0]*10, move[1]*10, move[2]*10);
+static void mainloop(void)
+{
+	wii_calcdata();
 
+	s3d_rotate(oid_head, wii_xrot, 0, wii_zrot);
+	s3d_translate(oid_head, wii_move[0]*10, wii_move[1]*10, wii_move[2]*10);
+
 	nanosleep(&t, NULL);
 }
 
 int main(int argc, char *argv[])
 {
-	bdaddr_t bdaddr; /* bluetooth device address */
+	char *addr;
 
-	cwiid_set_err(err);
+	if (argc > 1)
+		addr = argv[1];
+	else
+		addr = NULL;
 
-	/* Connect to address given on command-line, if present */
-	if (argc > 1) {
-		str2ba(argv[1], &bdaddr);
-	} else {
-		bdaddr = *BDADDR_ANY;
-	}
+	if (wii_init(addr))
+		return(-1);
 
-	/* Connect to the wiimote */
-	printf("Put Wiimote in discoverable mode now (press 1+2)...\n");
-
-	if (!(wiimote = cwiid_open(&bdaddr, 0))) {
-		fprintf(stderr, "Unable to connect to wiimote\n");
-		return -1;
-	}
-
-	cwiid_set_rpt_mode(wiimote, CWIID_RPT_BTN | CWIID_RPT_ACC | CWIID_RPT_IR | CWIID_RPT_NUNCHUK | CWIID_RPT_CLASSIC);
-
-
 	if (!s3d_init(&argc, &argv, "wiitest")) {
 		oid_head = s3d_import_model_file("objs/snow_head.3ds");
 		s3d_flags_on(oid_head, S3D_OF_VISIBLE);



From dotslash at mail.berlios.de  Fri Nov  9 18:00:15 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Fri, 9 Nov 2007 18:00:15 +0100
Subject: [S3d-svn] r852 - trunk/svnonly/wiitest
Message-ID: <200711091700.lA9H0FY8031159@sheep.berlios.de>

Author: dotslash
Date: 2007-11-09 18:00:14 +0100 (Fri, 09 Nov 2007)
New Revision: 852

Modified:
   trunk/svnonly/wiitest/wiitest.c
Log:
- it's N_SMOOTH, damnit


Modified: trunk/svnonly/wiitest/wiitest.c
===================================================================
--- trunk/svnonly/wiitest/wiitest.c	2007-11-09 16:54:05 UTC (rev 851)
+++ trunk/svnonly/wiitest/wiitest.c	2007-11-09 17:00:14 UTC (rev 852)
@@ -106,7 +106,7 @@
 	x_data[dataindex][2] = (state.acc[CWIID_Y] - 128) / 128.0;
 	x_data[dataindex][1] = (state.acc[CWIID_Z] - 128) / 128.0;
 
-	lastindex = (dataindex + N_SMOOTH - 1) % MAXNORM;
+	lastindex = (dataindex + N_SMOOTH - 1) % N_SMOOTH;
 	move_data[dataindex][0] =   x_data[lastindex][0] - x_data[dataindex][0];
 	move_data[dataindex][1] =   x_data[lastindex][1] - x_data[dataindex][1];
 	move_data[dataindex][2] = - x_data[lastindex][2] + x_data[dataindex][2];



From dotslash at mail.berlios.de  Tue Nov 13 10:50:45 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 13 Nov 2007 10:50:45 +0100
Subject: [S3d-svn] r853 - trunk/svnonly/comptest
Message-ID: <200711130950.lAD9oj5x000626@sheep.berlios.de>

Author: dotslash
Date: 2007-11-13 10:50:44 +0100 (Tue, 13 Nov 2007)
New Revision: 853

Modified:
   trunk/svnonly/comptest/comptest.c
Log:
- update debug output, use XGetErrorText()


Modified: trunk/svnonly/comptest/comptest.c
===================================================================
--- trunk/svnonly/comptest/comptest.c	2007-11-09 17:00:14 UTC (rev 852)
+++ trunk/svnonly/comptest/comptest.c	2007-11-13 09:50:44 UTC (rev 853)
@@ -24,6 +24,7 @@
 #include <stdio.h>
 #include <stdlib.h>        /* malloc(), free() */
 #include <time.h>         /* nanosleep() */
+#include <errno.h>			/* errno */
 #include <s3d.h>
 #include <X11/Xlib.h>       /* Ximage, Display, X*() */
 #include <X11/Xutil.h>       /* XDestroyImage() */
@@ -133,7 +134,7 @@
 		name = "Configure";
 	}
 
-	printf("Event: %s\n", name);
+	printf("Event: %s (%d)\n", name, event->type);
 	return(0);
 }
 
@@ -141,6 +142,7 @@
 static int error(Display *COMPUNUSED(dpy), XErrorEvent *event)
 {
 	char *name = "";
+	char buf[256];
 	int     o;
 
 	o = event->error_code - xfixes.error;
@@ -180,14 +182,20 @@
 		break;
 	}
 	switch (event->error_code) {
+	case BadWindow:
+		name = "BadWindow";
+		break;
+	case BadDrawable:
+		name = "BadDrawable";
+		break;
 	case BadMatch:
 		name = "BadMatch";
+		return(0);
 		break;
 	}
-
-
-	printf("error %d (name: %s) request %d minor %d serial %d\n",
-	       event->error_code, name, event->request_code, event->minor_code, (int)event->serial);
+	XGetErrorText(dpy, event->error_code, buf, 256);
+	printf("error %d (name: %s) request %d minor %d serial %d: %s\n",
+	       event->error_code, name, event->request_code, event->minor_code, (int)event->serial, buf);
 	return(0);
 }
 
@@ -391,8 +399,6 @@
 		/* printf("add window: %d:%d size: %dx%d\n", win->attr.x, win->attr.y, win->attr.width, win->attr.height);*/
 		win->pa.subwindow_mode = IncludeInferiors;
 		win->picture = XRenderCreatePicture(dpy, win->id, win->format, CPSubwindowMode, &win->pa);
-	} else {
-		printf("Format = 0, no damage created\n");
 	}
 	win->oid = -1;
 	win->next = window_head;
@@ -528,10 +534,7 @@
 		return;
 
 	if (win->attr.class == InputOnly)		/* can't grab image from this source */
-	{
-		printf("inputonly window\n");
 		return;
-	}
 
 	/* update the whole window for now. */
 	/* x = 50;
@@ -563,8 +566,11 @@
 		printf("request image: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d, ~TEXW = %08x\n",
 		       xleft, xright, width, x, y, width, height, ~TEXW);*/
 		image = XGetImage(dpy, win->id, xleft, y, chunk_width, height, AllPlanes, ZPixmap);
-		if (!image)
+		if (!image) {
+/*			printf("XGetImage Error: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d\n",
+							xleft, xright, width, x, y, width, height);*/
 			return;
+		}
 		if (win->oid == -1)
 			deco_box(win);
 		/*  printf("image_convert\n");*/



From dotslash at mail.berlios.de  Tue Nov 13 10:57:41 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 13 Nov 2007 10:57:41 +0100
Subject: [S3d-svn] r854 - trunk/server
Message-ID: <200711130957.lAD9vfkh001749@sheep.berlios.de>

Author: dotslash
Date: 2007-11-13 10:57:41 +0100 (Tue, 13 Nov 2007)
New Revision: 854

Modified:
   trunk/server/graphics.c
   trunk/server/process.c
Log:
- FIX: memory leak which was caused by a not-commented else 
- graphics.c does not need anything from stdlib.h anymore


Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2007-11-13 09:50:44 UTC (rev 853)
+++ trunk/server/graphics.c	2007-11-13 09:57:41 UTC (rev 854)
@@ -22,7 +22,6 @@
  */
 
 #include "global.h"
-#include <stdlib.h>   /*  malloc() */
 #include <string.h>   /*  memcpy() */
 
 #include <GL/gl.h>   /*  GLint */

Modified: trunk/server/process.c
===================================================================
--- trunk/server/process.c	2007-11-13 09:50:44 UTC (rev 853)
+++ trunk/server/process.c	2007-11-13 09:57:41 UTC (rev 854)
@@ -198,13 +198,13 @@
 				}
 			obj_free(mcp_p, p->mcp_oid);  /*  free the mcp-app-object. */
 			mcp_del_object(p->mcp_oid);   /*  tell MCP that it's object is beeing deleted. */
-		} else /*
+		} /* else 
    errs("p_del()","bad mcp_oid, unable to free mcp object");*/
-			if (i > 0) {
-				for (i = 0;i < p->n_obj;i++)
-					if (p->object[i]) obj_free(p, i);
-				free(p->object);
-			}
+		if (i > 0) {
+			for (i = 0;i < p->n_obj;i++)
+				if (p->object[i]) obj_free(p, i);
+			free(p->object);
+		}
 	} else {
 		/*  the mcp keeps in our memory ... */
 		/*  so we just delete the objects added */



From dotslash at mail.berlios.de  Tue Nov 13 11:24:39 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 13 Nov 2007 11:24:39 +0100
Subject: [S3d-svn] r855 - trunk/svnonly/comptest
Message-ID: <200711131024.lADAOdls004390@sheep.berlios.de>

Author: dotslash
Date: 2007-11-13 11:24:39 +0100 (Tue, 13 Nov 2007)
New Revision: 855

Modified:
   trunk/svnonly/comptest/comptest.c
Log:
- cleanup window after removal


Modified: trunk/svnonly/comptest/comptest.c
===================================================================
--- trunk/svnonly/comptest/comptest.c	2007-11-13 09:57:41 UTC (rev 854)
+++ trunk/svnonly/comptest/comptest.c	2007-11-13 10:24:39 UTC (rev 855)
@@ -126,6 +126,10 @@
 	case CirculateNotify:
 		name = "Circulate";
 		break;
+	case PropertyNotify:
+		name = "PropertyNotify";
+		return(0);
+		break;
 	}
 	if (event->type == xdamage.event + XDamageNotify) {
 		name = "Damage";
@@ -138,7 +142,6 @@
 	return(0);
 }
 
-/*static int error(Display *COMPUNUSED(dpy), XErrorEvent *COMPUNUSED(event))*/
 static int error(Display *COMPUNUSED(dpy), XErrorEvent *event)
 {
 	char *name = "";
@@ -271,8 +274,6 @@
 	int vindex, voffset, pindex;
 	int xpos, ypos;
 
-	printf("draw new deco_box!!\n");
-
 	win->oid = s3d_new_object();
 	/*
 	 for (i = 0;i < 8;i++) {
@@ -372,7 +373,6 @@
 		if (window->id == id)
 			return(window);
 	}
-	printf("not found (window %d). ;(\n", (int)id);
 	return(NULL);
 
 }
@@ -384,6 +384,11 @@
 	win = malloc(sizeof(struct window));
 	if (!win)
 		return;
+
+	if (window_find(id) != NULL) {
+		printf("!!!! Window already added\n");
+		return;
+	}
 	win->id = id;
 	XGetWindowAttributes(dpy, win->id, &win->attr);
 
@@ -405,6 +410,7 @@
 	window_head = win;
 	win->already_updated = 0;
 	window_update_content(win, 0, 0, win->attr.width, win->attr.height);
+	printf("window (%d) added\n", (int)id);
 
 
 
@@ -412,26 +418,28 @@
 
 static void window_remove(Window id)
 {
-	struct window *window, *h;
-	if (window_head == NULL)
+	struct window **wp, *window;
+	for (wp = &window_head; *wp != NULL; wp = &(*wp)->next) 
+		if ((*wp)->id == id)
+			break;
+
+	if (*wp == NULL) {
+		printf("!!!! not found (window %d) for removal.\n", (int)id);
 		return;
-	if (window_head->id == id) {
-		window = window_head;
-		window_head = window_head->next;
-	} else {
-		for (window = window_head; window != NULL; window = window->next) {
-			if ((window->next != NULL) && (window->next->id == id)) {
-				h = window;
-				h->next = h->next->next;
-				window = window->next;
-				break;
-			}
-		}
-		printf("not found (window %d) for removal.\n", (int)id);
-		return;
 	}
+	window = *wp;
+	*wp = window->next;
 
-	/* TODO */
+	printf("window (%d) removed\n", id);
+
+	/* TODO: properly cleanup */
+	if (window->oid != -1)
+		s3d_del_object(window->oid);
+	if (window->picture)
+		XRenderFreePicture(dpy, window->picture);
+	if (window->damage)
+		XDamageDestroy(dpy, window->damage);
+
 	free(window);
 }
 static void window_update_geometry(struct window *win, int x, int y, int width, int height)
@@ -636,7 +644,6 @@
 		case CreateNotify:{
 			XCreateWindowEvent *e = &event.xcreatewindow;
 			window_add(e->display, e->window);
-			printf("window added!!\n");
 			break;
 			}
 		case DestroyNotify:{



From dotslash at mail.berlios.de  Tue Nov 13 11:42:26 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 13 Nov 2007 11:42:26 +0100
Subject: [S3d-svn] r856 - trunk/svnonly/comptest
Message-ID: <200711131042.lADAgQZJ006147@sheep.berlios.de>

Author: dotslash
Date: 2007-11-13 11:42:25 +0100 (Tue, 13 Nov 2007)
New Revision: 856

Added:
   trunk/svnonly/comptest/comptest.h
   trunk/svnonly/comptest/window.c
   trunk/svnonly/comptest/x11.c
Modified:
   trunk/svnonly/comptest/CMakeLists.txt
   trunk/svnonly/comptest/comptest.c
Log:
- split comptest into multiple files


Modified: trunk/svnonly/comptest/CMakeLists.txt
===================================================================
--- trunk/svnonly/comptest/CMakeLists.txt	2007-11-13 10:24:39 UTC (rev 855)
+++ trunk/svnonly/comptest/CMakeLists.txt	2007-11-13 10:42:25 UTC (rev 856)
@@ -3,7 +3,7 @@
 if (XCOMPOSITE_FOUND AND XDAMAGE_FOUND AND XFIXES_FOUND AND XRENDER_FOUND)
 	include_directories(${s3d_SOURCE_DIR}/libs3d)
 
-	add_executable(comptest comptest.c)
+	add_executable(comptest comptest.c window.c x11.c)
 	target_link_libraries(comptest s3d ${XCOMPOSITE_LIBRARIES}
 		${XFIXES_LIBRARIES} ${XDAMAGE_LIBRARIES} ${XRENDER_LIBRARIES})
 

Modified: trunk/svnonly/comptest/comptest.c
===================================================================
--- trunk/svnonly/comptest/comptest.c	2007-11-13 10:24:39 UTC (rev 855)
+++ trunk/svnonly/comptest/comptest.c	2007-11-13 10:42:25 UTC (rev 856)
@@ -21,225 +21,28 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
+#include "comptest.h"
 #include <stdio.h>
 #include <stdlib.h>        /* malloc(), free() */
 #include <time.h>         /* nanosleep() */
 #include <errno.h>			/* errno */
-#include <s3d.h>
-#include <X11/Xlib.h>       /* Ximage, Display, X*() */
-#include <X11/Xutil.h>       /* XDestroyImage() */
-#include <X11/Xatom.h>
-#include <X11/extensions/Xcomposite.h>
-#include <X11/extensions/Xdamage.h>
-#include <X11/extensions/Xrender.h>
-#include <config-s3d.h>
 
-#ifndef COMPUNUSED
-#if defined(UNUSEDPARAM_ATTRIBUTE)
-#define COMPUNUSED(x) (x)__attribute__((unused))
-#elif defined(UNUSEDPARAM_OMIT)
-#define COMPUNUSED(x) /* x */
-#else
-#define COMPUNUSED(x) x
-#endif
-#endif
 
-#define MAXEVENTS 50  /* maximum events per loop. */
 
-/* must be 2^x */
-#define TEXW 256
-#define TEXH 256
-#define TEXNUM(win, x, y) \
-  ((((win->attr.height + TEXH - 1)& ~(TEXH-1))/TEXH) * ((int)(x/TEXH)) + ((int)(y/TEXW)))
 
-struct extension {
-	int event, error;
-};
 
-struct window {
-	Window        id;
-	XWindowAttributes    attr;   /* position, size etc. */
-	XImage      *image;
-	Damage       damage;  /* damage notification */
-	XRenderPictureAttributes  pa;
-	XRenderPictFormat    *format;
-	Picture       picture;
-	int     already_updated;
-	int        oid;
-	int        no;
-
-	struct window     *next;
-};
-
-static struct extension    xrender, xcomposite, xdamage, xfixes;
-static struct window   *window_head = NULL;
-static Display       *dpy;
-static char    *display = NULL;
-
-static int     win_no = 0;    /* XXX: REMOVE */
 static struct timespec t = {
 	0, 50*1000*1000
 }; /* 50 mili seconds */
 
-int xinit(void);
-void window_update_content(struct window *win, int x, int y, int width, int height);
-static void window_set_position(struct window *win);
-static int print_event(Display *dpy, XEvent *event);
-void event();
-
 static void mainloop(void)
 {
 	event();
 	nanosleep(&t, NULL);
 }
 
-static int get_shift(unsigned long t)
+void deco_box(struct window *win)
 {
-	int i;
-	for (i = 0; t ; i++)
-		t >>= 1;
-	return(i);
-}
-
-static int print_event(Display *COMPUNUSED(dpy), XEvent *event)
-{
-	char *name = "unknown";
-	switch (event->type & 0x7f) {
-	case CreateNotify:
-		name = "Create";
-		break;
-	case DestroyNotify:
-		name = "Destroy";
-		break;
-	case Expose:
-		name = "Expose";
-		break;
-	case MapNotify:
-		name = "Map";
-		break;
-	case UnmapNotify:
-		name = "Unmap";
-		break;
-	case ReparentNotify:
-		name = "Reparent";
-		break;
-	case CirculateNotify:
-		name = "Circulate";
-		break;
-	case PropertyNotify:
-		name = "PropertyNotify";
-		return(0);
-		break;
-	}
-	if (event->type == xdamage.event + XDamageNotify) {
-		name = "Damage";
-		return(0); /* don't report this. */
-	} else if (event->type == ConfigureNotify) {
-		name = "Configure";
-	}
-
-	printf("Event: %s (%d)\n", name, event->type);
-	return(0);
-}
-
-static int error(Display *COMPUNUSED(dpy), XErrorEvent *event)
-{
-	char *name = "";
-	char buf[256];
-	int     o;
-
-	o = event->error_code - xfixes.error;
-	switch (o) {
-	case BadRegion:
-		name = "BadRegion";
-		break;
-	default:
-		break;
-	}
-	o = event->error_code - xdamage.error;
-	switch (o) {
-	case BadDamage:
-		name = "BadDamage";
-		break;
-	default:
-		break;
-	}
-	o = event->error_code - xrender.error;
-	switch (o) {
-	case BadPictFormat:
-		name = "BadPictFormat";
-		break;
-	case BadPicture:
-		name = "BadPicture";
-		break;
-	case BadPictOp:
-		name = "BadPictOp";
-		break;
-	case BadGlyphSet:
-		name = "BadGlyphSet";
-		break;
-	case BadGlyph:
-		name = "BadGlyph";
-		break;
-	default:
-		break;
-	}
-	switch (event->error_code) {
-	case BadWindow:
-		name = "BadWindow";
-		break;
-	case BadDrawable:
-		name = "BadDrawable";
-		break;
-	case BadMatch:
-		name = "BadMatch";
-		return(0);
-		break;
-	}
-	XGetErrorText(dpy, event->error_code, buf, 256);
-	printf("error %d (name: %s) request %d minor %d serial %d: %s\n",
-	       event->error_code, name, event->request_code, event->minor_code, (int)event->serial, buf);
-	return(0);
-}
-
-
-int xinit(void)
-{
-	dpy = XOpenDisplay(display);
-	if (!dpy) {
-		fprintf(stderr, "Can't open display\n");
-		return(1);
-	}
-	if (!XRenderQueryExtension(dpy, &xrender.event, &xrender.error)) {
-		fprintf(stderr, "No render extension\n");
-		return(1);
-	}
-	/*    XCompositeQueryVersion (dpy, &composite_major, &composite_minor); */
-
-	if (!XCompositeQueryExtension(dpy, &xcomposite.event, &xcomposite.error)) {
-		fprintf(stderr, "No composite extension\n");
-		return(1);
-	}
-
-	if (!XDamageQueryExtension(dpy, &xdamage.event, &xdamage.error)) {
-		fprintf(stderr, "No damage extension\n");
-		return(1);
-	}
-	if (!XFixesQueryExtension(dpy, &xfixes.event, &xfixes.error)) {
-		fprintf(stderr, "No XFixes extension\n");
-		return(1);
-	}
-	XSetErrorHandler(error);
-	return(0);
-}
-
-static void window_set_position(struct window *win) {
-	s3d_translate(win->oid, win->attr.x / 20, -win->attr.y / 20, -0.01 * win->no);
-}
-
-
-static void deco_box(struct window *win)
-{
 	/* float vertices[8*3] = {
 	  0, 0, 0,
 	  1, 0, 0,
@@ -333,329 +136,6 @@
 	s3d_flags_on(win->oid, S3D_OF_VISIBLE);
 }
 
-void window_restack(struct window *win, Window above) 
-{
-	struct window **wp;
-	Window old_above;
-	int i;
-	if (win->next == NULL)		old_above = None;
-	else						old_above = win->next->id;
-
-	if (old_above == above)		return;
-
-	/* unlink from list */
-	for (wp = &window_head; *wp != NULL; wp = &(*wp)->next) 
-		if (*wp == win)
-			break;
-
-	if (*wp == NULL) return;
-	*wp = win->next;
-
-	/* relink in front of the new "above" window */
-	for (wp = &window_head; *wp != NULL; wp = &(*wp)->next) 
-		if ((*wp)->id == above)
-			break;
-
-	win->next = *wp;
-	*wp = win;
-
-	for (i=0, wp = &window_head; *wp != NULL; wp = &(*wp)->next, i++)
-		if (i != (*wp)->no) {
-			(*wp)->no = i;
-			if ((*wp)->oid != -1)
-				window_set_position(*wp);
-		}
-}
-static struct window *window_find(Window id) 
-{
-	struct window *window;
-	for (window = window_head; window != NULL; window = window->next) {
-		if (window->id == id)
-			return(window);
-	}
-	return(NULL);
-
-}
-
-
-static void window_add(Display *dpy, Window id)
-{
-	struct window *win;
-	win = malloc(sizeof(struct window));
-	if (!win)
-		return;
-
-	if (window_find(id) != NULL) {
-		printf("!!!! Window already added\n");
-		return;
-	}
-	win->id = id;
-	XGetWindowAttributes(dpy, win->id, &win->attr);
-
-	win->no = win_no++;
-	/* XSelectInput(dpy, win->id, ExposureMask|ButtonPressMask|KeyPressMask*/
-/*	XSelectInput(dpy, win->id, SubstructureNotifyMask | ExposureMask | StructureNotifyMask | PropertyChangeMask);*/
-	XSelectInput(dpy, win->id, 0);
-
-	win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty);
-	win->format = XRenderFindVisualFormat(dpy, win->attr.visual);
-
-	if (win->format != NULL) {
-		/* printf("add window: %d:%d size: %dx%d\n", win->attr.x, win->attr.y, win->attr.width, win->attr.height);*/
-		win->pa.subwindow_mode = IncludeInferiors;
-		win->picture = XRenderCreatePicture(dpy, win->id, win->format, CPSubwindowMode, &win->pa);
-	}
-	win->oid = -1;
-	win->next = window_head;
-	window_head = win;
-	win->already_updated = 0;
-	window_update_content(win, 0, 0, win->attr.width, win->attr.height);
-	printf("window (%d) added\n", (int)id);
-
-
-
-}
-
-static void window_remove(Window id)
-{
-	struct window **wp, *window;
-	for (wp = &window_head; *wp != NULL; wp = &(*wp)->next) 
-		if ((*wp)->id == id)
-			break;
-
-	if (*wp == NULL) {
-		printf("!!!! not found (window %d) for removal.\n", (int)id);
-		return;
-	}
-	window = *wp;
-	*wp = window->next;
-
-	printf("window (%d) removed\n", id);
-
-	/* TODO: properly cleanup */
-	if (window->oid != -1)
-		s3d_del_object(window->oid);
-	if (window->picture)
-		XRenderFreePicture(dpy, window->picture);
-	if (window->damage)
-		XDamageDestroy(dpy, window->damage);
-
-	free(window);
-}
-static void window_update_geometry(struct window *win, int x, int y, int width, int height)
-{
-
-	printf("window_update_geometry()\n");
-	if (win->oid == -1) {
-		win->attr.x = x;
-		win->attr.y = y;
-		win->attr.width = width;
-		win->attr.height = height;
-
-		window_update_content(win, 0, 0, width, height);
-		return;
-	}
-	if ((win->attr.width == width) && (win->attr.height == height)) {
-		if ((win->attr.x == x) && (win->attr.y == y)) {
-			printf("position did not change\n");
-			return;
-		} else {
-			win->attr.x = x;
-			win->attr.y = y;
-			window_set_position(win);
-		}
-	} else {
-		win->attr.x = x;
-		win->attr.y = y;
-		win->attr.width = width;
-		win->attr.height = height;
-
-		s3d_del_object(win->oid); /* delete the window and redraw */
-		win->oid = -1;
-		window_update_content(win, 0, 0, width, height);
-
-	}
-}
-/* convert X-format to s3ds RGBA 32bit format */
-static int image_convert(XImage *image, char *bitmap)
-{
-	int x, y;
-	int rs, gs, bs;
-	int bpp;
-	char *img_ptr, *bmp_ptr;
-	unsigned long *s;
-	uint32_t *t;
-
-
-	if (image->format == ZPixmap) {
-		/*  printf("XImage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n",
-		         image->width, image->height, image->format,
-		         ZPixmap, image->bits_per_pixel, image->depth, image->bitmap_pad);*/
-		rs = get_shift(image->red_mask) - 8;
-		gs = get_shift(image->green_mask) - 8;
-		bs = get_shift(image->blue_mask) - 8;
-
-		bpp = (image->bits_per_pixel / 8);
-		/* rgb is not bgr */
-		rs = rs;
-		gs = gs - 8;
-		bs = bs - 16;
-		/*  printf("Ximage: rgb: %d|%d|%d\n", rs, gs, bs);;*/
-		/*  printf("red: size %d, offset %d\n",rs,roff);
-		  printf("green: size %d, offset %d\n",gs,goff);
-		  printf("blue: size %d, offset %d\n",bs,boff);
-		  printf("bits per pixel:%d\n",bpp);*/
-		for (y = 0; y < image->height ; y++) {
-			img_ptr = image->data + (y * image->width) * bpp;
-			bmp_ptr = bitmap + (y * image->width) * sizeof(uint32_t);
-			for (x = 0; x < image->width; x++) {
-				s = (unsigned long *) img_ptr;
-				t = (uint32_t *)  bmp_ptr;
-				/*    bmp_ptr[0] = (rs > 0 ? ((*d & image->red_mask) >> rs)  : ((*d  & image->red_mask) << -rs)) ;
-				 bmp_ptr[1] = (gs > 0 ? ((*d & image->green_mask) >> gs) : ((*d  & image->green_mask) << -gs)) ;
-				 bmp_ptr[2] = (bs > 0 ? ((*d & image->blue_mask) >> bs)  : ((*d  & image->blue_mask) << -bs));
-				 bmp_ptr[3] = 255 ;*/
-				*t = (rs > 0 ? ((*s & image->red_mask) >> rs)  : ((*s  & image->red_mask) << -rs)) |
-				     (gs > 0 ? ((*s & image->green_mask) >> gs) : ((*s  & image->green_mask) << -gs)) |
-				     (bs > 0 ? ((*s & image->blue_mask) >> bs)  : ((*s  & image->blue_mask) << -bs)) |
-				     255 << 24;
-
-				bmp_ptr += sizeof(uint32_t);
-				img_ptr += bpp;
-			}
-		}
-		return(0);
-	}
-	return(-1);
-}
-
-/* takes a bounding box and updates its window contents */
-void window_update_content(struct window *win, int x, int y, int width, int height)
-{
-	int chunk_width, chunk_height;
-	int xleft, xright;
-	int ytop, ybottom;
-	char *bitmap;
-	XImage *image;
-
-	if (win->attr.map_state == IsUnmapped)	/* not mapped images can't be grabbed */
-		return;
-
-	if (win->attr.class == InputOnly)		/* can't grab image from this source */
-		return;
-
-	/* update the whole window for now. */
-	/* x = 50;
-	 y = 50;
-	 width = win->attr.width;
-	 height = win->attr.height;*/
-	if (x < 0) x = 0;
-	if (y < 0) y = 0;
-	if (width > win->attr.width - x)   width = win->attr.width - x;
-	if (height > win->attr.height - y)   height = win->attr.height - y;
-
-	if (x == 0 && y == 0 && width == win->attr.width && height == win->attr.height) {
-		if (win->already_updated)
-			return;
-		else
-			win->already_updated = 1;
-	}
-
-	/* if (!win->oid)
-	  deco_box(win);
-	*/
-	bitmap = malloc(TEXW * height * sizeof(uint32_t));
-	for (xleft = x; xleft < x + width ; xleft = xright) {
-		xright = (xleft + TEXW) & ~(TEXW - 1);
-		if (xright > (x + width))
-			xright = x + width;
-		chunk_width = xright - xleft;
-/*		printf("map-state = %d, backing_store = %d\n", win->attr.map_state);
-		printf("request image: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d, ~TEXW = %08x\n",
-		       xleft, xright, width, x, y, width, height, ~TEXW);*/
-		image = XGetImage(dpy, win->id, xleft, y, chunk_width, height, AllPlanes, ZPixmap);
-		if (!image) {
-/*			printf("XGetImage Error: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d\n",
-							xleft, xright, width, x, y, width, height);*/
-			return;
-		}
-		if (win->oid == -1)
-			deco_box(win);
-		/*  printf("image_convert\n");*/
-		image_convert(image, bitmap);
-		/*  printf("load textures ...\n");*/
-		for (ytop = y; ytop < y + height; ytop = ybottom) {
-			ybottom = (ytop + TEXH) & ~(TEXH - 1);
-			if (ybottom > y + height)
-				ybottom = y + height;
-			chunk_height = ybottom - ytop;
-			s3d_load_texture(win->oid, TEXNUM(win, xleft, ytop), xleft % TEXW, ytop % TEXH,
-			                 chunk_width, chunk_height, (unsigned char *)bitmap + chunk_width * (ytop - y) * 4);
-			/*   printf("s3d_load_texture(%d, %d, %d, %d, %d, %d, %010p);\n",
-			       win->oid, TEXNUM(win, xleft, ytop), xleft % TEXW, ytop % TEXH,
-			        chunk_width, chunk_height, (unsigned char *)bitmap + chunk_width * (ytop - y) * 4);*/
-		}
-		/*  printf("done loading textures\n"); */
-		XDestroyImage(image);
-	}
-	free(bitmap);
-}
-
-
-void event(void)
-{
-	XEvent event;
-	struct window *window;
-	int i;
-	for (window = window_head; window != NULL; window = window->next)
-		window->already_updated = 0;
-
-	for (i = 0; i < MAXEVENTS && XPending(dpy); i++) {
-		XNextEvent(dpy, &event);
-		print_event(dpy, &event);
-		switch (event.type - xdamage.event) {
-		case XDamageNotify:{
-			XDamageNotifyEvent *e = (XDamageNotifyEvent*) & event;
-			/*   printf("window = %d, geometry = %d:%d (at %d:%d), area = %d:%d (at %d:%d)\n",
-			          (int)e->drawable, e->geometry.width, e->geometry.height, e->geometry.x, e->geometry.y,
-			          e->area.width, e->area.height, e->area.x, e->area.y);*/
-			XDamageSubtract(dpy, e->damage, None, None);
-			window = window_find(e->drawable);
-			if (window != NULL)
-				window_update_content(window, e->area.x, e->area.y, e->area.width, e->area.height);
-			break;
-		   }
-
-		}
-		switch (event.type) {
-		case ConfigureNotify:{
-			XConfigureEvent *e = &event.xconfigure;
-			window = window_find(e->window);
-			if (window != NULL) {
-				/*    printf("Configure: window = %d, geometry = %d:%d (at %d:%d)\n",
-				           (int)e->window, e->width, e->height, e->x, e->y);*/
-				window_restack(window, e->above);
-				window_update_geometry(window, e->x, e->y, e->width, e->height);
-			} else {
-				printf("Configure: Could not find window to configure.\n");
-			}
-			break;
-			 }
-		case CreateNotify:{
-			XCreateWindowEvent *e = &event.xcreatewindow;
-			window_add(e->display, e->window);
-			break;
-			}
-		case DestroyNotify:{
-			XDestroyWindowEvent *e = &event.xdestroywindow;
-			window_remove(e->window);
-			break;
-		   }
-		}
-	}
-}
-
-
 int main(int argc, char **argv)
 {
 	Window        root_return, parent_return;
@@ -666,7 +146,7 @@
 
 	if (xinit())
 		return(1);
-	if (!s3d_init(&argc, &argv, "compotest")) {
+	if (!s3d_init(&argc, &argv, "comptest")) {
 		for (scr_no = 0; scr_no < ScreenCount(dpy); scr_no++) {
 			XCompositeRedirectSubwindows(dpy, RootWindow(dpy, scr_no), CompositeRedirectAutomatic);
 			/*   XCompositeRedirectSubwindows(dpy, RootWindow(dpy, scr_no), CompositeRedirectManual);*/

Added: trunk/svnonly/comptest/comptest.h
===================================================================
--- trunk/svnonly/comptest/comptest.h	2007-11-13 10:24:39 UTC (rev 855)
+++ trunk/svnonly/comptest/comptest.h	2007-11-13 10:42:25 UTC (rev 856)
@@ -0,0 +1,62 @@
+#include <s3d.h>
+#include <X11/Xlib.h>       /* Ximage, Display, X*() */
+#include <X11/Xutil.h>       /* XDestroyImage() */
+#include <X11/Xatom.h>
+#include <config-s3d.h>
+#include <X11/extensions/Xcomposite.h>
+#include <X11/extensions/Xdamage.h>
+#include <X11/extensions/Xrender.h>
+#ifndef COMPUNUSED
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define COMPUNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define COMPUNUSED(x) /* x */
+#else
+#define COMPUNUSED(x) x
+#endif
+#endif
+
+#define MAXEVENTS 50  /* maximum events per loop. */
+
+/* must be 2^x */
+#define TEXW 256
+#define TEXH 256
+#define TEXNUM(win, x, y) \
+  ((((win->attr.height + TEXH - 1)& ~(TEXH-1))/TEXH) * ((int)(x/TEXH)) + ((int)(y/TEXW)))
+
+
+struct window {
+	Window        id;
+	XWindowAttributes    attr;   /* position, size etc. */
+	XImage      *image;
+	Damage       damage;  /* damage notification */
+	XRenderPictureAttributes  pa;
+	XRenderPictFormat    *format;
+	Picture       picture;
+	int     already_updated;
+	int        oid;
+	int		   no;
+
+	struct window     *next;
+};
+
+/* comptest.c */
+void deco_box(struct window *win);
+/* window.c */
+void window_update_content(struct window *win, int x, int y, int width, int height);
+void window_set_position(struct window *win);
+void window_restack(struct window *win, Window above);
+struct window *window_find(Window id);
+struct window *window_find(Window id);
+void window_add(Display *dpy, Window id);
+void window_remove(Window id);
+void window_update_content(struct window *win, int x, int y, int width, int height);
+void window_update_geometry(struct window *win, int x, int y, int width, int height);
+
+extern struct window   *window_head;
+/* x11.c */
+void event(void);
+int xinit(void);
+int error(Display *COMPUNUSED(dpy), XErrorEvent *event);
+int print_event(Display *COMPUNUSED(dpy), XEvent *event);
+extern Display *dpy;

Added: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-13 10:24:39 UTC (rev 855)
+++ trunk/svnonly/comptest/window.c	2007-11-13 10:42:25 UTC (rev 856)
@@ -0,0 +1,306 @@
+/*
+ * window.c
+ *
+ * Copyright (C) 2007 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of comptest, a proof-of-concept composite manager hack.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * comptest is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * comptest is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with comptest; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "comptest.h"
+#include <stdlib.h>	/* malloc(), free() */
+#include <stdio.h>	/* printf() */
+struct window   *window_head = NULL;
+
+void window_set_position(struct window *win) {
+	s3d_translate(win->oid, win->attr.x / 20, -win->attr.y / 20, -0.01 * win->no);
+}
+
+void window_restack(struct window *win, Window above) 
+{
+	struct window **wp;
+	Window old_above;
+	int i;
+	if (win->next == NULL)		old_above = None;
+	else						old_above = win->next->id;
+
+	if (old_above == above)		return;
+
+	/* unlink from list */
+	for (wp = &window_head; *wp != NULL; wp = &(*wp)->next) 
+		if (*wp == win)
+			break;
+
+	if (*wp == NULL) return;
+	*wp = win->next;
+
+	/* relink in front of the new "above" window */
+	for (wp = &window_head; *wp != NULL; wp = &(*wp)->next) 
+		if ((*wp)->id == above)
+			break;
+
+	win->next = *wp;
+	*wp = win;
+
+	for (i=0, wp = &window_head; *wp != NULL; wp = &(*wp)->next, i++)
+		if (i != (*wp)->no) {
+			(*wp)->no = i;
+			if ((*wp)->oid != -1)
+				window_set_position(*wp);
+		}
+}
+struct window *window_find(Window id) 
+{
+	struct window *window;
+	for (window = window_head; window != NULL; window = window->next) {
+		if (window->id == id)
+			return(window);
+	}
+	return(NULL);
+
+}
+
+void window_add(Display *dpy, Window id)
+{
+	struct window *win;
+	win = malloc(sizeof(struct window));
+	if (!win)
+		return;
+
+	if (window_find(id) != NULL) {
+		printf("!!!! Window already added\n");
+		return;
+	}
+	win->id = id;
+	XGetWindowAttributes(dpy, win->id, &win->attr);
+
+	/* XSelectInput(dpy, win->id, ExposureMask|ButtonPressMask|KeyPressMask*/
+/*	XSelectInput(dpy, win->id, SubstructureNotifyMask | ExposureMask | StructureNotifyMask | PropertyChangeMask);*/
+	XSelectInput(dpy, win->id, 0);
+
+	win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty);
+	win->format = XRenderFindVisualFormat(dpy, win->attr.visual);
+
+	if (win->format != NULL) {
+		/* printf("add window: %d:%d size: %dx%d\n", win->attr.x, win->attr.y, win->attr.width, win->attr.height);*/
+		win->pa.subwindow_mode = IncludeInferiors;
+		win->picture = XRenderCreatePicture(dpy, win->id, win->format, CPSubwindowMode, &win->pa);
+	}
+	win->no = 0;
+	win->oid = -1;
+	win->next = window_head;
+	window_head = win;
+	win->already_updated = 0;
+	window_update_content(win, 0, 0, win->attr.width, win->attr.height);
+	printf("window (%d) added\n", (int)id);
+}
+
+void window_remove(Window id)
+{
+	struct window **wp, *window;
+	for (wp = &window_head; *wp != NULL; wp = &(*wp)->next) 
+		if ((*wp)->id == id)
+			break;
+
+	if (*wp == NULL) {
+		printf("!!!! not found (window %d) for removal.\n", (int)id);
+		return;
+	}
+	window = *wp;
+	*wp = window->next;
+
+	printf("window (%d) removed\n", (int)id);
+
+	/* TODO: properly cleanup */
+	if (window->oid != -1)
+		s3d_del_object(window->oid);
+	if (window->picture)
+		XRenderFreePicture(dpy, window->picture);
+	if (window->damage)
+		XDamageDestroy(dpy, window->damage);
+
+	free(window);
+}
+void window_update_geometry(struct window *win, int x, int y, int width, int height)
+{
+
+	printf("window_update_geometry()\n");
+	if (win->oid == -1) {
+		win->attr.x = x;
+		win->attr.y = y;
+		win->attr.width = width;
+		win->attr.height = height;
+
+		window_update_content(win, 0, 0, width, height);
+		return;
+	}
+	if ((win->attr.width == width) && (win->attr.height == height)) {
+		if ((win->attr.x == x) && (win->attr.y == y)) {
+			printf("position did not change\n");
+			return;
+		} else {
+			win->attr.x = x;
+			win->attr.y = y;
+			window_set_position(win);
+		}
+	} else {
+		win->attr.x = x;
+		win->attr.y = y;
+		win->attr.width = width;
+		win->attr.height = height;
+
+		s3d_del_object(win->oid); /* delete the window and redraw */
+		win->oid = -1;
+		window_update_content(win, 0, 0, width, height);
+
+	}
+}
+
+static int get_shift(unsigned long t)
+{
+	int i;
+	for (i = 0; t ; i++)
+		t >>= 1;
+	return(i);
+}
+
+
+/* convert X-format to s3ds RGBA 32bit format */
+static int image_convert(XImage *image, char *bitmap)
+{
+	int x, y;
+	int rs, gs, bs;
+	int bpp;
+	char *img_ptr, *bmp_ptr;
+	unsigned long *s;
+	uint32_t *t;
+
+
+	if (image->format == ZPixmap) {
+		/*  printf("XImage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n",
+		         image->width, image->height, image->format,
+		         ZPixmap, image->bits_per_pixel, image->depth, image->bitmap_pad);*/
+		rs = get_shift(image->red_mask) - 8;
+		gs = get_shift(image->green_mask) - 8;
+		bs = get_shift(image->blue_mask) - 8;
+
+		bpp = (image->bits_per_pixel / 8);
+		/* rgb is not bgr */
+		rs = rs;
+		gs = gs - 8;
+		bs = bs - 16;
+		/*  printf("Ximage: rgb: %d|%d|%d\n", rs, gs, bs);;*/
+		/*  printf("red: size %d, offset %d\n",rs,roff);
+		  printf("green: size %d, offset %d\n",gs,goff);
+		  printf("blue: size %d, offset %d\n",bs,boff);
+		  printf("bits per pixel:%d\n",bpp);*/
+		for (y = 0; y < image->height ; y++) {
+			img_ptr = image->data + (y * image->width) * bpp;
+			bmp_ptr = bitmap + (y * image->width) * sizeof(uint32_t);
+			for (x = 0; x < image->width; x++) {
+				s = (unsigned long *) img_ptr;
+				t = (uint32_t *)  bmp_ptr;
+				/*    bmp_ptr[0] = (rs > 0 ? ((*d & image->red_mask) >> rs)  : ((*d  & image->red_mask) << -rs)) ;
+				 bmp_ptr[1] = (gs > 0 ? ((*d & image->green_mask) >> gs) : ((*d  & image->green_mask) << -gs)) ;
+				 bmp_ptr[2] = (bs > 0 ? ((*d & image->blue_mask) >> bs)  : ((*d  & image->blue_mask) << -bs));
+				 bmp_ptr[3] = 255 ;*/
+				*t = (rs > 0 ? ((*s & image->red_mask) >> rs)  : ((*s  & image->red_mask) << -rs)) |
+				     (gs > 0 ? ((*s & image->green_mask) >> gs) : ((*s  & image->green_mask) << -gs)) |
+				     (bs > 0 ? ((*s & image->blue_mask) >> bs)  : ((*s  & image->blue_mask) << -bs)) |
+				     255 << 24;
+
+				bmp_ptr += sizeof(uint32_t);
+				img_ptr += bpp;
+			}
+		}
+		return(0);
+	}
+	return(-1);
+}
+
+/* takes a bounding box and updates its window contents */
+void window_update_content(struct window *win, int x, int y, int width, int height)
+{
+	int chunk_width, chunk_height;
+	int xleft, xright;
+	int ytop, ybottom;
+	char *bitmap;
+	XImage *image;
+
+	if (win->attr.map_state == IsUnmapped)	/* not mapped images can't be grabbed */
+		return;
+
+	if (win->attr.class == InputOnly)		/* can't grab image from this source */
+		return;
+
+	/* update the whole window for now. */
+	/* x = 50;
+	 y = 50;
+	 width = win->attr.width;
+	 height = win->attr.height;*/
+	if (x < 0) x = 0;
+	if (y < 0) y = 0;
+	if (width > win->attr.width - x)   width = win->attr.width - x;
+	if (height > win->attr.height - y)   height = win->attr.height - y;
+
+	if (x == 0 && y == 0 && width == win->attr.width && height == win->attr.height) {
+		if (win->already_updated)
+			return;
+		else
+			win->already_updated = 1;
+	}
+
+	/* if (!win->oid)
+	  deco_box(win);
+	*/
+	bitmap = malloc(TEXW * height * sizeof(uint32_t));
+	for (xleft = x; xleft < x + width ; xleft = xright) {
+		xright = (xleft + TEXW) & ~(TEXW - 1);
+		if (xright > (x + width))
+			xright = x + width;
+		chunk_width = xright - xleft;
+/*		printf("map-state = %d, backing_store = %d\n", win->attr.map_state);
+		printf("request image: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d, ~TEXW = %08x\n",
+		       xleft, xright, width, x, y, width, height, ~TEXW);*/
+		image = XGetImage(dpy, win->id, xleft, y, chunk_width, height, AllPlanes, ZPixmap);
+		if (!image) {
+/*			printf("XGetImage Error: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d\n",
+							xleft, xright, width, x, y, width, height);*/
+			return;
+		}
+		if (win->oid == -1)
+			deco_box(win);
+		/*  printf("image_convert\n");*/
+		image_convert(image, bitmap);
+		/*  printf("load textures ...\n");*/
+		for (ytop = y; ytop < y + height; ytop = ybottom) {
+			ybottom = (ytop + TEXH) & ~(TEXH - 1);
+			if (ybottom > y + height)
+				ybottom = y + height;
+			chunk_height = ybottom - ytop;
+			s3d_load_texture(win->oid, TEXNUM(win, xleft, ytop), xleft % TEXW, ytop % TEXH,
+			                 chunk_width, chunk_height, (unsigned char *)bitmap + chunk_width * (ytop - y) * 4);
+			/*   printf("s3d_load_texture(%d, %d, %d, %d, %d, %d, %010p);\n",
+			       win->oid, TEXNUM(win, xleft, ytop), xleft % TEXW, ytop % TEXH,
+			        chunk_width, chunk_height, (unsigned char *)bitmap + chunk_width * (ytop - y) * 4);*/
+		}
+		/*  printf("done loading textures\n"); */
+		XDestroyImage(image);
+	}
+	free(bitmap);
+}
+

Added: trunk/svnonly/comptest/x11.c
===================================================================
--- trunk/svnonly/comptest/x11.c	2007-11-13 10:24:39 UTC (rev 855)
+++ trunk/svnonly/comptest/x11.c	2007-11-13 10:42:25 UTC (rev 856)
@@ -0,0 +1,220 @@
+/*
+ * x11.c
+ *
+ * Copyright (C) 2007 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of comptest, a proof-of-concept composite manager hack.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * comptest is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * comptest is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with comptest; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "comptest.h"
+#include <stdio.h>		/* printf() */
+
+struct extension {
+	int event, error;
+};
+static struct extension    xrender, xcomposite, xdamage, xfixes;
+Display       *dpy;
+static char    *display = NULL;
+
+int print_event(Display *COMPUNUSED(dpy), XEvent *event)
+{
+	char *name = "unknown";
+	switch (event->type & 0x7f) {
+	case CreateNotify:
+		name = "Create";
+		break;
+	case DestroyNotify:
+		name = "Destroy";
+		break;
+	case Expose:
+		name = "Expose";
+		break;
+	case MapNotify:
+		name = "Map";
+		break;
+	case UnmapNotify:
+		name = "Unmap";
+		break;
+	case ReparentNotify:
+		name = "Reparent";
+		break;
+	case CirculateNotify:
+		name = "Circulate";
+		break;
+	case PropertyNotify:
+		name = "PropertyNotify";
+		return(0);
+		break;
+	}
+	if (event->type == xdamage.event + XDamageNotify) {
+		name = "Damage";
+		return(0); /* don't report this. */
+	} else if (event->type == ConfigureNotify) {
+		name = "Configure";
+	}
+
+	printf("Event: %s (%d)\n", name, event->type);
+	return(0);
+}
+
+int error(Display *COMPUNUSED(dpy), XErrorEvent *event)
+{
+	char *name = "";
+	char buf[256];
+	int     o;
+
+	o = event->error_code - xfixes.error;
+	switch (o) {
+	case BadRegion:
+		name = "BadRegion";
+		break;
+	default:
+		break;
+	}
+	o = event->error_code - xdamage.error;
+	switch (o) {
+	case BadDamage:
+		name = "BadDamage";
+		break;
+	default:
+		break;
+	}
+	o = event->error_code - xrender.error;
+	switch (o) {
+	case BadPictFormat:
+		name = "BadPictFormat";
+		break;
+	case BadPicture:
+		name = "BadPicture";
+		break;
+	case BadPictOp:
+		name = "BadPictOp";
+		break;
+	case BadGlyphSet:
+		name = "BadGlyphSet";
+		break;
+	case BadGlyph:
+		name = "BadGlyph";
+		break;
+	default:
+		break;
+	}
+	switch (event->error_code) {
+	case BadWindow:
+		name = "BadWindow";
+		break;
+	case BadDrawable:
+		name = "BadDrawable";
+		break;
+	case BadMatch:
+		name = "BadMatch";
+		return(0);
+		break;
+	}
+	XGetErrorText(dpy, event->error_code, buf, 256);
+	printf("error %d (name: %s) request %d minor %d serial %d: %s\n",
+	       event->error_code, name, event->request_code, event->minor_code, (int)event->serial, buf);
+	return(0);
+}
+
+
+int xinit(void)
+{
+	dpy = XOpenDisplay(display);
+	if (!dpy) {
+		fprintf(stderr, "Can't open display\n");
+		return(1);
+	}
+	if (!XRenderQueryExtension(dpy, &xrender.event, &xrender.error)) {
+		fprintf(stderr, "No render extension\n");
+		return(1);
+	}
+	/*    XCompositeQueryVersion (dpy, &composite_major, &composite_minor); */
+
+	if (!XCompositeQueryExtension(dpy, &xcomposite.event, &xcomposite.error)) {
+		fprintf(stderr, "No composite extension\n");
+		return(1);
+	}
+
+	if (!XDamageQueryExtension(dpy, &xdamage.event, &xdamage.error)) {
+		fprintf(stderr, "No damage extension\n");
+		return(1);
+	}
+	if (!XFixesQueryExtension(dpy, &xfixes.event, &xfixes.error)) {
+		fprintf(stderr, "No XFixes extension\n");
+		return(1);
+	}
+	XSetErrorHandler(error);
+	return(0);
+}
+
+
+void event(void)
+{
+	XEvent event;
+	struct window *window;
+	int i;
+	for (window = window_head; window != NULL; window = window->next)
+		window->already_updated = 0;
+
+	for (i = 0; i < MAXEVENTS && XPending(dpy); i++) {
+		XNextEvent(dpy, &event);
+		print_event(dpy, &event);
+		switch (event.type - xdamage.event) {
+		case XDamageNotify:{
+			XDamageNotifyEvent *e = (XDamageNotifyEvent*) & event;
+			/*   printf("window = %d, geometry = %d:%d (at %d:%d), area = %d:%d (at %d:%d)\n",
+			          (int)e->drawable, e->geometry.width, e->geometry.height, e->geometry.x, e->geometry.y,
+			          e->area.width, e->area.height, e->area.x, e->area.y);*/
+			XDamageSubtract(dpy, e->damage, None, None);
+			window = window_find(e->drawable);
+			if (window != NULL)
+				window_update_content(window, e->area.x, e->area.y, e->area.width, e->area.height);
+			break;
+		   }
+
+		}
+		switch (event.type) {
+		case ConfigureNotify:{
+			XConfigureEvent *e = &event.xconfigure;
+			window = window_find(e->window);
+			if (window != NULL) {
+				/*    printf("Configure: window = %d, geometry = %d:%d (at %d:%d)\n",
+				           (int)e->window, e->width, e->height, e->x, e->y);*/
+				window_restack(window, e->above);
+				window_update_geometry(window, e->x, e->y, e->width, e->height);
+			} else {
+				printf("Configure: Could not find window to configure.\n");
+			}
+			break;
+			 }
+		case CreateNotify:{
+			XCreateWindowEvent *e = &event.xcreatewindow;
+			window_add(e->display, e->window);
+			break;
+			}
+		case DestroyNotify:{
+			XDestroyWindowEvent *e = &event.xdestroywindow;
+			window_remove(e->window);
+			break;
+		   }
+		}
+	}
+}
+
+



From dotslash at mail.berlios.de  Thu Nov 15 14:32:20 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 15 Nov 2007 14:32:20 +0100
Subject: [S3d-svn] r857 - trunk/svnonly/comptest
Message-ID: <200711151332.lAFDWK51024146@sheep.berlios.de>

Author: dotslash
Date: 2007-11-15 14:32:20 +0100 (Thu, 15 Nov 2007)
New Revision: 857

Modified:
   trunk/svnonly/comptest/window.c
Log:
- don't XRenderCreatePicture as we don't use it.


Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-13 10:42:25 UTC (rev 856)
+++ trunk/svnonly/comptest/window.c	2007-11-15 13:32:20 UTC (rev 857)
@@ -93,13 +93,13 @@
 	XSelectInput(dpy, win->id, 0);
 
 	win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty);
-	win->format = XRenderFindVisualFormat(dpy, win->attr.visual);
+/*	win->format = XRenderFindVisualFormat(dpy, win->attr.visual);
 
 	if (win->format != NULL) {
-		/* printf("add window: %d:%d size: %dx%d\n", win->attr.x, win->attr.y, win->attr.width, win->attr.height);*/
+		/ * printf("add window: %d:%d size: %dx%d\n", win->attr.x, win->attr.y, win->attr.width, win->attr.height);* /
 		win->pa.subwindow_mode = IncludeInferiors;
 		win->picture = XRenderCreatePicture(dpy, win->id, win->format, CPSubwindowMode, &win->pa);
-	}
+	}*/
 	win->no = 0;
 	win->oid = -1;
 	win->next = window_head;



From dotslash at mail.berlios.de  Mon Nov 19 19:28:31 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 19 Nov 2007 19:28:31 +0100
Subject: [S3d-svn] r858 - trunk/svnonly/comptest
Message-ID: <200711191828.lAJISVAv002148@sheep.berlios.de>

Author: dotslash
Date: 2007-11-19 19:28:31 +0100 (Mon, 19 Nov 2007)
New Revision: 858

Modified:
   trunk/svnonly/comptest/comptest.c
   trunk/svnonly/comptest/comptest.h
   trunk/svnonly/comptest/window.c
Log:
- pressing return puts camera into fullscreen position
- try to use XCompositeNameWindowPixmap, but it does not work as expected .. :/


Modified: trunk/svnonly/comptest/comptest.c
===================================================================
--- trunk/svnonly/comptest/comptest.c	2007-11-15 13:32:20 UTC (rev 857)
+++ trunk/svnonly/comptest/comptest.c	2007-11-19 18:28:31 UTC (rev 858)
@@ -22,6 +22,7 @@
  */
 
 #include "comptest.h"
+#include <s3d_keysym.h>
 #include <stdio.h>
 #include <stdlib.h>        /* malloc(), free() */
 #include <time.h>         /* nanosleep() */
@@ -78,6 +79,7 @@
 	int xpos, ypos;
 
 	win->oid = s3d_new_object();
+	s3d_link(win->oid, screen_oid);
 	/*
 	 for (i = 0;i < 8;i++) {
 	  sver[i*3 + 0] = vertices[i*3+0] * win->attr.width / 20;
@@ -107,16 +109,16 @@
 
 	for (y = 0; y < win->attr.height;  y += TEXH) { /* the first column */
 		ypos = (y + TEXH > win->attr.height) ? win->attr.height : y + TEXH ;
-		s3d_push_vertex(win->oid, 0, -((float)ypos) / 20, -1);
+		s3d_push_vertex(win->oid, 0, -((float)ypos) , -1);
 		voffset++;
 	}
 	for (x = 0; x < win->attr.width; x += TEXW) { /* the first row */
 		xpos = (x + TEXW > win->attr.width) ? win->attr.width : x + TEXW ;
-		s3d_push_vertex(win->oid, ((float)xpos) / 20, 0, -1);
+		s3d_push_vertex(win->oid, ((float)xpos) , 0, -1);
 
 		for (y = 0; y < win->attr.height; y += TEXH) {
 			ypos = (y + TEXH > win->attr.height) ? win->attr.height : y + TEXH  ;
-			s3d_push_vertex(win->oid, ((float)xpos) / 20, -((float)ypos) / 20, -1);
+			s3d_push_vertex(win->oid, ((float)xpos) , -((float)ypos) , -1);
 			s3d_push_material_a(win->oid,
 			                    0.0, 0.8, 0.0 , 1.0,
 			                    1.0, 1.0, 1.0 , 1.0,
@@ -136,8 +138,28 @@
 	s3d_flags_on(win->oid, S3D_OF_VISIBLE);
 }
 
+static int key(struct s3d_evt *evt)
+{
+	struct s3d_key_event *key = (struct s3d_key_event *)evt->buf;
+	if (key->keysym == S3DK_RETURN) {
+		printf("camera into position ...\n");
+
+		s3d_translate(0, 0,0, SCREEN_SCALE);
+		s3d_rotate(0,0,0,0);
+
+		
+
+	}
+	return(0);
+
+}
+int screen_width = 0;
+int screen_height = 0;
+int screen_oid = -1;
+
 int main(int argc, char **argv)
 {
+	XWindowAttributes    attr;
 	Window        root_return, parent_return;
 	unsigned int     nchildren;
 	Window       *children;
@@ -146,7 +168,15 @@
 
 	if (xinit())
 		return(1);
+	XGetWindowAttributes(dpy, RootWindow(dpy, 0), &attr);
+	screen_width = attr.width;
+	screen_height = attr.height;
+
 	if (!s3d_init(&argc, &argv, "comptest")) {
+		s3d_set_callback(S3D_EVENT_KEY, key);
+		screen_oid = s3d_new_object();
+		s3d_translate(screen_oid, -SCREEN_SCALE * (float)screen_width/((float) screen_height), SCREEN_SCALE, 0);
+		s3d_scale(screen_oid, 2* SCREEN_SCALE/((float)screen_height));
 		for (scr_no = 0; scr_no < ScreenCount(dpy); scr_no++) {
 			XCompositeRedirectSubwindows(dpy, RootWindow(dpy, scr_no), CompositeRedirectAutomatic);
 			/*   XCompositeRedirectSubwindows(dpy, RootWindow(dpy, scr_no), CompositeRedirectManual);*/

Modified: trunk/svnonly/comptest/comptest.h
===================================================================
--- trunk/svnonly/comptest/comptest.h	2007-11-15 13:32:20 UTC (rev 857)
+++ trunk/svnonly/comptest/comptest.h	2007-11-19 18:28:31 UTC (rev 858)
@@ -17,6 +17,7 @@
 #endif
 
 #define MAXEVENTS 50  /* maximum events per loop. */
+#define SCREEN_SCALE	5.0
 
 /* must be 2^x */
 #define TEXW 256
@@ -32,6 +33,7 @@
 	Damage       damage;  /* damage notification */
 	XRenderPictureAttributes  pa;
 	XRenderPictFormat    *format;
+	Pixmap			pix;
 	Picture       picture;
 	int     already_updated;
 	int        oid;
@@ -41,6 +43,9 @@
 };
 
 /* comptest.c */
+extern int screen_width;
+extern int screen_height;
+extern int screen_oid;
 void deco_box(struct window *win);
 /* window.c */
 void window_update_content(struct window *win, int x, int y, int width, int height);

Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-15 13:32:20 UTC (rev 857)
+++ trunk/svnonly/comptest/window.c	2007-11-19 18:28:31 UTC (rev 858)
@@ -27,7 +27,7 @@
 struct window   *window_head = NULL;
 
 void window_set_position(struct window *win) {
-	s3d_translate(win->oid, win->attr.x / 20, -win->attr.y / 20, -0.01 * win->no);
+	s3d_translate(win->oid, win->attr.x, -win->attr.y, -0.01 * win->no);
 }
 
 void window_restack(struct window *win, Window above) 
@@ -100,13 +100,14 @@
 		win->pa.subwindow_mode = IncludeInferiors;
 		win->picture = XRenderCreatePicture(dpy, win->id, win->format, CPSubwindowMode, &win->pa);
 	}*/
+	win->pix = None;
 	win->no = 0;
 	win->oid = -1;
 	win->next = window_head;
 	window_head = win;
 	win->already_updated = 0;
 	window_update_content(win, 0, 0, win->attr.width, win->attr.height);
-	printf("window (%d) added\n", (int)id);
+/*	printf("window (%d) added\n", (int)id);*/
 }
 
 void window_remove(Window id)
@@ -118,6 +119,7 @@
 
 	if (*wp == NULL) {
 		printf("!!!! not found (window %d) for removal.\n", (int)id);
+		exit(-1);
 		return;
 	}
 	window = *wp;
@@ -144,7 +146,9 @@
 		win->attr.y = y;
 		win->attr.width = width;
 		win->attr.height = height;
+		printf("new XCompositeNameWindowPixmap\n");
 
+
 		window_update_content(win, 0, 0, width, height);
 		return;
 	}
@@ -163,6 +167,10 @@
 		win->attr.width = width;
 		win->attr.height = height;
 
+		printf("new XCompositeNameWindowPixmap\n");
+		XFreePixmap(dpy, win->pix);
+		win->pix = XCompositeNameWindowPixmap(dpy, win->id);
+
 		s3d_del_object(win->oid); /* delete the window and redraw */
 		win->oid = -1;
 		window_update_content(win, 0, 0, width, height);
@@ -189,7 +197,6 @@
 	unsigned long *s;
 	uint32_t *t;
 
-
 	if (image->format == ZPixmap) {
 		/*  printf("XImage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n",
 		         image->width, image->height, image->format,
@@ -277,14 +284,23 @@
 		printf("request image: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d, ~TEXW = %08x\n",
 		       xleft, xright, width, x, y, width, height, ~TEXW);*/
 		image = XGetImage(dpy, win->id, xleft, y, chunk_width, height, AllPlanes, ZPixmap);
+/*		if (win->pix == None)
+			XFreePixmap(dpy, win->pix);
+		win->pix = XCompositeNameWindowPixmap(dpy, win->id);*/
+
+		image = XGetImage(dpy, win->pix, xleft, y, chunk_width, height, AllPlanes, ZPixmap);
 		if (!image) {
 /*			printf("XGetImage Error: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d\n",
 							xleft, xright, width, x, y, width, height);*/
+			if (win->oid != -1) {
+				s3d_del_object(win->oid);
+				win->oid = -1;
+			}
+				
 			return;
 		}
 		if (win->oid == -1)
 			deco_box(win);
-		/*  printf("image_convert\n");*/
 		image_convert(image, bitmap);
 		/*  printf("load textures ...\n");*/
 		for (ytop = y; ytop < y + height; ytop = ybottom) {



From lazhur at mail.berlios.de  Mon Nov 19 23:09:43 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 19 Nov 2007 23:09:43 +0100
Subject: [S3d-svn] r859 - trunk/svnonly/comptest
Message-ID: <200711192209.lAJM9hNn015753@sheep.berlios.de>

Author: lazhur
Date: 2007-11-19 23:09:43 +0100 (Mon, 19 Nov 2007)
New Revision: 859

Modified:
   trunk/svnonly/comptest/x11.c
Log:
comptest: Query composite version as mentioned in xcomposite specs


Modified: trunk/svnonly/comptest/x11.c
===================================================================
--- trunk/svnonly/comptest/x11.c	2007-11-19 18:28:31 UTC (rev 858)
+++ trunk/svnonly/comptest/x11.c	2007-11-19 22:09:43 UTC (rev 859)
@@ -135,6 +135,8 @@
 
 int xinit(void)
 {
+	int composite_major, composite_minor;
+
 	dpy = XOpenDisplay(display);
 	if (!dpy) {
 		fprintf(stderr, "Can't open display\n");
@@ -144,13 +146,17 @@
 		fprintf(stderr, "No render extension\n");
 		return(1);
 	}
-	/*    XCompositeQueryVersion (dpy, &composite_major, &composite_minor); */
 
 	if (!XCompositeQueryExtension(dpy, &xcomposite.event, &xcomposite.error)) {
 		fprintf(stderr, "No composite extension\n");
 		return(1);
 	}
 
+	if (!XCompositeQueryVersion(dpy, &composite_major, &composite_minor)) {
+		fprintf(stderr, "Could not check composite version\n");
+		return(1);
+	}
+
 	if (!XDamageQueryExtension(dpy, &xdamage.event, &xdamage.error)) {
 		fprintf(stderr, "No damage extension\n");
 		return(1);



From lazhur at mail.berlios.de  Mon Nov 19 23:09:54 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 19 Nov 2007 23:09:54 +0100
Subject: [S3d-svn] r860 - trunk/svnonly/comptest
Message-ID: <200711192209.lAJM9sjO015775@sheep.berlios.de>

Author: lazhur
Date: 2007-11-19 23:09:53 +0100 (Mon, 19 Nov 2007)
New Revision: 860

Modified:
   trunk/svnonly/comptest/x11.c
Log:
comptest: Check for XComposite 0.2 or better for XCompositeNameWindowPixmap


Modified: trunk/svnonly/comptest/x11.c
===================================================================
--- trunk/svnonly/comptest/x11.c	2007-11-19 22:09:43 UTC (rev 859)
+++ trunk/svnonly/comptest/x11.c	2007-11-19 22:09:53 UTC (rev 860)
@@ -24,6 +24,8 @@
 #include "comptest.h"
 #include <stdio.h>		/* printf() */
 
+#define XCOMPOSITE_VERSION_0_2 200
+
 struct extension {
 	int event, error;
 };
@@ -157,6 +159,11 @@
 		return(1);
 	}
 
+	if (XCompositeVersion() < XCOMPOSITE_VERSION_0_2) {
+		fprintf(stderr, "Could not find composite version 0.2 or better\n");
+		return(1);
+	}
+
 	if (!XDamageQueryExtension(dpy, &xdamage.event, &xdamage.error)) {
 		fprintf(stderr, "No damage extension\n");
 		return(1);



From lazhur at mail.berlios.de  Tue Nov 20 21:43:39 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Tue, 20 Nov 2007 21:43:39 +0100
Subject: [S3d-svn] r861 - trunk/svnonly/comptest
Message-ID: <200711202043.lAKKhdoV018195@sheep.berlios.de>

Author: lazhur
Date: 2007-11-20 21:43:38 +0100 (Tue, 20 Nov 2007)
New Revision: 861

Modified:
   trunk/svnonly/comptest/window.c
Log:
comptest: Read current window image from pixmap


Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-19 22:09:53 UTC (rev 860)
+++ trunk/svnonly/comptest/window.c	2007-11-20 20:43:38 UTC (rev 861)
@@ -198,9 +198,9 @@
 	uint32_t *t;
 
 	if (image->format == ZPixmap) {
-		/*  printf("XImage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n",
+		/* printf("XImage: %dx%d, format %x (%x), bpp: %d, depth %d, pad %d\n",
 		         image->width, image->height, image->format,
-		         ZPixmap, image->bits_per_pixel, image->depth, image->bitmap_pad);*/
+		         ZPixmap, image->bits_per_pixel, image->depth, image->bitmap_pad); */
 		rs = get_shift(image->red_mask) - 8;
 		gs = get_shift(image->green_mask) - 8;
 		bs = get_shift(image->blue_mask) - 8;
@@ -283,10 +283,10 @@
 /*		printf("map-state = %d, backing_store = %d\n", win->attr.map_state);
 		printf("request image: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d, ~TEXW = %08x\n",
 		       xleft, xright, width, x, y, width, height, ~TEXW);*/
-		image = XGetImage(dpy, win->id, xleft, y, chunk_width, height, AllPlanes, ZPixmap);
-/*		if (win->pix == None)
+		/* image = XGetImage(dpy, win->id, xleft, y, chunk_width, height, AllPlanes, ZPixmap); */
+		if (win->pix != None)
 			XFreePixmap(dpy, win->pix);
-		win->pix = XCompositeNameWindowPixmap(dpy, win->id);*/
+		win->pix = XCompositeNameWindowPixmap(dpy, win->id);
 
 		image = XGetImage(dpy, win->pix, xleft, y, chunk_width, height, AllPlanes, ZPixmap);
 		if (!image) {



From lazhur at mail.berlios.de  Tue Nov 20 21:43:53 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Tue, 20 Nov 2007 21:43:53 +0100
Subject: [S3d-svn] r862 - trunk/svnonly/comptest
Message-ID: <200711202043.lAKKhrFI018219@sheep.berlios.de>

Author: lazhur
Date: 2007-11-20 21:43:52 +0100 (Tue, 20 Nov 2007)
New Revision: 862

Modified:
   trunk/svnonly/comptest/window.c
Log:
comptest: Workaround to show dotslash the source of missing window image


Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-20 20:43:38 UTC (rev 861)
+++ trunk/svnonly/comptest/window.c	2007-11-20 20:43:52 UTC (rev 862)
@@ -229,7 +229,9 @@
 				     (gs > 0 ? ((*s & image->green_mask) >> gs) : ((*s  & image->green_mask) << -gs)) |
 				     (bs > 0 ? ((*s & image->blue_mask) >> bs)  : ((*s  & image->blue_mask) << -bs)) |
 				     255 << 24;
+				*t = *s;
 
+
 				bmp_ptr += sizeof(uint32_t);
 				img_ptr += bpp;
 			}



From dotslash at mail.berlios.de  Tue Nov 20 22:10:18 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 20 Nov 2007 22:10:18 +0100
Subject: [S3d-svn] r863 - trunk/svnonly/comptest
Message-ID: <200711202110.lAKLAIFr019850@sheep.berlios.de>

Author: dotslash
Date: 2007-11-20 22:10:18 +0100 (Tue, 20 Nov 2007)
New Revision: 863

Modified:
   trunk/svnonly/comptest/window.c
Log:
- fix and cleanup the conversion (only for 32bit now). Thanks Sven!


Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-20 20:43:52 UTC (rev 862)
+++ trunk/svnonly/comptest/window.c	2007-11-20 21:10:18 UTC (rev 863)
@@ -178,64 +178,52 @@
 	}
 }
 
-static int get_shift(unsigned long t)
-{
-	int i;
-	for (i = 0; t ; i++)
-		t >>= 1;
-	return(i);
-}
-
-
 /* convert X-format to s3ds RGBA 32bit format */
 static int image_convert(XImage *image, char *bitmap)
 {
 	int x, y;
-	int rs, gs, bs;
-	int bpp;
 	char *img_ptr, *bmp_ptr;
-	unsigned long *s;
-	uint32_t *t;
+	char *sc, *tc;
 
-	if (image->format == ZPixmap) {
-		/* printf("XImage: %dx%d, format %x (%x), bpp: %d, depth %d, pad %d\n",
-		         image->width, image->height, image->format,
-		         ZPixmap, image->bits_per_pixel, image->depth, image->bitmap_pad); */
-		rs = get_shift(image->red_mask) - 8;
-		gs = get_shift(image->green_mask) - 8;
-		bs = get_shift(image->blue_mask) - 8;
+	if (image->format != ZPixmap) 
+		return(-1);
+	switch (image->bits_per_pixel) {
+		case 32:
+			for (y = 0; y < image->height ; y++) {
+				img_ptr = image->data + (y * image->width) * 4;
+				bmp_ptr = bitmap + (y * image->width) * 4;
+				for (x = 0; x < image->width; x++) {
+					sc = (unsigned long *) img_ptr;
+					tc = (uint32_t *)  bmp_ptr;
+	
+					tc[0] = sc[2];
+					tc[1] = sc[1];
+					tc[2] = sc[0];
+					tc[3] = 255;
 
-		bpp = (image->bits_per_pixel / 8);
-		/* rgb is not bgr */
-		rs = rs;
-		gs = gs - 8;
-		bs = bs - 16;
-		/*  printf("Ximage: rgb: %d|%d|%d\n", rs, gs, bs);;*/
-		/*  printf("red: size %d, offset %d\n",rs,roff);
-		  printf("green: size %d, offset %d\n",gs,goff);
-		  printf("blue: size %d, offset %d\n",bs,boff);
-		  printf("bits per pixel:%d\n",bpp);*/
-		for (y = 0; y < image->height ; y++) {
-			img_ptr = image->data + (y * image->width) * bpp;
-			bmp_ptr = bitmap + (y * image->width) * sizeof(uint32_t);
-			for (x = 0; x < image->width; x++) {
-				s = (unsigned long *) img_ptr;
-				t = (uint32_t *)  bmp_ptr;
-				/*    bmp_ptr[0] = (rs > 0 ? ((*d & image->red_mask) >> rs)  : ((*d  & image->red_mask) << -rs)) ;
-				 bmp_ptr[1] = (gs > 0 ? ((*d & image->green_mask) >> gs) : ((*d  & image->green_mask) << -gs)) ;
-				 bmp_ptr[2] = (bs > 0 ? ((*d & image->blue_mask) >> bs)  : ((*d  & image->blue_mask) << -bs));
-				 bmp_ptr[3] = 255 ;*/
-				*t = (rs > 0 ? ((*s & image->red_mask) >> rs)  : ((*s  & image->red_mask) << -rs)) |
-				     (gs > 0 ? ((*s & image->green_mask) >> gs) : ((*s  & image->green_mask) << -gs)) |
-				     (bs > 0 ? ((*s & image->blue_mask) >> bs)  : ((*s  & image->blue_mask) << -bs)) |
-				     255 << 24;
-				*t = *s;
 
+					bmp_ptr += 4;
+					img_ptr += 4;
+				}
+			}
+			break;
+		default:
+			/* not implemented. draw a red image. */
+			for (y = 0; y < image->height ; y++) {
+				bmp_ptr = bitmap + (y * image->width) * 4;
+				for (x = 0; x < image->width; x++) {
+					tc = (uint32_t *)  bmp_ptr;
+	
+					tc[0] = 255;
+					tc[1] = 0;
+					tc[2] = 0;
+					tc[3] = 255;
 
-				bmp_ptr += sizeof(uint32_t);
-				img_ptr += bpp;
+					bmp_ptr += 4;
+				}
 			}
-		}
+			break;
+
 		return(0);
 	}
 	return(-1);



From dotslash at mail.berlios.de  Tue Nov 20 22:46:15 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 20 Nov 2007 22:46:15 +0100
Subject: [S3d-svn] r864 - trunk/svnonly/comptest
Message-ID: <200711202146.lAKLkF0B021947@sheep.berlios.de>

Author: dotslash
Date: 2007-11-20 22:46:15 +0100 (Tue, 20 Nov 2007)
New Revision: 864

Modified:
   trunk/svnonly/comptest/comptest.c
Log:
- fix distance to screen


Modified: trunk/svnonly/comptest/comptest.c
===================================================================
--- trunk/svnonly/comptest/comptest.c	2007-11-20 21:10:18 UTC (rev 863)
+++ trunk/svnonly/comptest/comptest.c	2007-11-20 21:46:15 UTC (rev 864)
@@ -144,7 +144,7 @@
 	if (key->keysym == S3DK_RETURN) {
 		printf("camera into position ...\n");
 
-		s3d_translate(0, 0,0, SCREEN_SCALE);
+		s3d_translate(0, 0,0, SCREEN_SCALE * ( 1 - 1/100.0));
 		s3d_rotate(0,0,0,0);
 
 		



From dotslash at mail.berlios.de  Tue Nov 20 23:01:52 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 20 Nov 2007 23:01:52 +0100
Subject: [S3d-svn] r865 - trunk/svnonly/comptest
Message-ID: <200711202201.lAKM1qlS022631@sheep.berlios.de>

Author: dotslash
Date: 2007-11-20 23:01:51 +0100 (Tue, 20 Nov 2007)
New Revision: 865

Modified:
   trunk/svnonly/comptest/window.c
Log:
- only update pixmap on configure events (update_geometry -> remove, update_content -> create)
- have some reasonable stacking in the beginning


Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-20 21:46:15 UTC (rev 864)
+++ trunk/svnonly/comptest/window.c	2007-11-20 22:01:51 UTC (rev 865)
@@ -93,19 +93,19 @@
 	XSelectInput(dpy, win->id, 0);
 
 	win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty);
-/*	win->format = XRenderFindVisualFormat(dpy, win->attr.visual);
-
-	if (win->format != NULL) {
-		/ * printf("add window: %d:%d size: %dx%d\n", win->attr.x, win->attr.y, win->attr.width, win->attr.height);* /
-		win->pa.subwindow_mode = IncludeInferiors;
-		win->picture = XRenderCreatePicture(dpy, win->id, win->format, CPSubwindowMode, &win->pa);
-	}*/
 	win->pix = None;
 	win->no = 0;
 	win->oid = -1;
 	win->next = window_head;
 	window_head = win;
 	win->already_updated = 0;
+	if (win->next == NULL) 
+		window_restack(win, None);
+	else
+		window_restack(win, win->next->id);
+	
+
+
 	window_update_content(win, 0, 0, win->attr.width, win->attr.height);
 /*	printf("window (%d) added\n", (int)id);*/
 }
@@ -128,10 +128,10 @@
 	printf("window (%d) removed\n", (int)id);
 
 	/* TODO: properly cleanup */
+	if (window->pix != None)
+		XFreePixmap(dpy, window->pix);
 	if (window->oid != -1)
 		s3d_del_object(window->oid);
-	if (window->picture)
-		XRenderFreePicture(dpy, window->picture);
 	if (window->damage)
 		XDamageDestroy(dpy, window->damage);
 
@@ -146,12 +146,15 @@
 		win->attr.y = y;
 		win->attr.width = width;
 		win->attr.height = height;
-		printf("new XCompositeNameWindowPixmap\n");
 
-
 		window_update_content(win, 0, 0, width, height);
 		return;
 	}
+	if (win->pix != None) {
+		XFreePixmap(dpy, win->pix);
+		win->pix = None;
+	}
+
 	if ((win->attr.width == width) && (win->attr.height == height)) {
 		if ((win->attr.x == x) && (win->attr.y == y)) {
 			printf("position did not change\n");
@@ -167,10 +170,6 @@
 		win->attr.width = width;
 		win->attr.height = height;
 
-		printf("new XCompositeNameWindowPixmap\n");
-		XFreePixmap(dpy, win->pix);
-		win->pix = XCompositeNameWindowPixmap(dpy, win->id);
-
 		s3d_del_object(win->oid); /* delete the window and redraw */
 		win->oid = -1;
 		window_update_content(win, 0, 0, width, height);
@@ -274,9 +273,8 @@
 		printf("request image: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d, ~TEXW = %08x\n",
 		       xleft, xright, width, x, y, width, height, ~TEXW);*/
 		/* image = XGetImage(dpy, win->id, xleft, y, chunk_width, height, AllPlanes, ZPixmap); */
-		if (win->pix != None)
-			XFreePixmap(dpy, win->pix);
-		win->pix = XCompositeNameWindowPixmap(dpy, win->id);
+		if (win->pix == None)
+			win->pix = XCompositeNameWindowPixmap(dpy, win->id);
 
 		image = XGetImage(dpy, win->pix, xleft, y, chunk_width, height, AllPlanes, ZPixmap);
 		if (!image) {



From dotslash at mail.berlios.de  Tue Nov 20 23:04:27 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 20 Nov 2007 23:04:27 +0100
Subject: [S3d-svn] r866 - trunk/svnonly/comptest
Message-ID: <200711202204.lAKM4Rwt022801@sheep.berlios.de>

Author: dotslash
Date: 2007-11-20 23:04:26 +0100 (Tue, 20 Nov 2007)
New Revision: 866

Modified:
   trunk/svnonly/comptest/comptest.h
   trunk/svnonly/comptest/window.c
Log:
- remove unused fields in struct window
- uint8_t for the conversion, silence warnings


Modified: trunk/svnonly/comptest/comptest.h
===================================================================
--- trunk/svnonly/comptest/comptest.h	2007-11-20 22:01:51 UTC (rev 865)
+++ trunk/svnonly/comptest/comptest.h	2007-11-20 22:04:26 UTC (rev 866)
@@ -31,10 +31,7 @@
 	XWindowAttributes    attr;   /* position, size etc. */
 	XImage      *image;
 	Damage       damage;  /* damage notification */
-	XRenderPictureAttributes  pa;
-	XRenderPictFormat    *format;
 	Pixmap			pix;
-	Picture       picture;
 	int     already_updated;
 	int        oid;
 	int		   no;

Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-20 22:01:51 UTC (rev 865)
+++ trunk/svnonly/comptest/window.c	2007-11-20 22:04:26 UTC (rev 866)
@@ -182,7 +182,7 @@
 {
 	int x, y;
 	char *img_ptr, *bmp_ptr;
-	char *sc, *tc;
+	uint8_t *sc, *tc;
 
 	if (image->format != ZPixmap) 
 		return(-1);
@@ -192,8 +192,8 @@
 				img_ptr = image->data + (y * image->width) * 4;
 				bmp_ptr = bitmap + (y * image->width) * 4;
 				for (x = 0; x < image->width; x++) {
-					sc = (unsigned long *) img_ptr;
-					tc = (uint32_t *)  bmp_ptr;
+					sc = (uint8_t *) img_ptr;
+					tc = (uint8_t *) bmp_ptr;
 	
 					tc[0] = sc[2];
 					tc[1] = sc[1];
@@ -211,7 +211,7 @@
 			for (y = 0; y < image->height ; y++) {
 				bmp_ptr = bitmap + (y * image->width) * 4;
 				for (x = 0; x < image->width; x++) {
-					tc = (uint32_t *)  bmp_ptr;
+					tc = (uint8_t *)  bmp_ptr;
 	
 					tc[0] = 255;
 					tc[1] = 0;



From dotslash at mail.berlios.de  Tue Nov 20 23:28:40 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 20 Nov 2007 23:28:40 +0100
Subject: [S3d-svn] r867 - trunk/svnonly/comptest
Message-ID: <200711202228.lAKMSed6023771@sheep.berlios.de>

Author: dotslash
Date: 2007-11-20 23:28:40 +0100 (Tue, 20 Nov 2007)
New Revision: 867

Modified:
   trunk/svnonly/comptest/window.c
   trunk/svnonly/comptest/x11.c
Log:
- don't add a window if it's already removed (hackish)


Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-20 22:04:26 UTC (rev 866)
+++ trunk/svnonly/comptest/window.c	2007-11-20 22:28:40 UTC (rev 867)
@@ -86,19 +86,29 @@
 		return;
 	}
 	win->id = id;
-	XGetWindowAttributes(dpy, win->id, &win->attr);
+	win->next = window_head;
+	window_head = win;
+	win->damage = None;
+	win->pix = None;
+	win->no = 0;
+	win->oid = -1;
+	win->already_updated = 0;
 
+	/* TODO: at my place, windows are created and destroyed in the same moment. so this 
+	 * function fails sometimes. 
+	 * maybe there is a function asking something like "is there really a window with id ;win->id'...". 
+	 * that would help here. */
+	if (!XGetWindowAttributes(dpy, win->id, &win->attr)) {
+		/* window does not exit, next event is probably it's removal ... */
+		return;
+	}
+	
+
 	/* XSelectInput(dpy, win->id, ExposureMask|ButtonPressMask|KeyPressMask*/
 /*	XSelectInput(dpy, win->id, SubstructureNotifyMask | ExposureMask | StructureNotifyMask | PropertyChangeMask);*/
 	XSelectInput(dpy, win->id, 0);
 
 	win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty);
-	win->pix = None;
-	win->no = 0;
-	win->oid = -1;
-	win->next = window_head;
-	window_head = win;
-	win->already_updated = 0;
 	if (win->next == NULL) 
 		window_restack(win, None);
 	else
@@ -243,11 +253,6 @@
 	if (win->attr.class == InputOnly)		/* can't grab image from this source */
 		return;
 
-	/* update the whole window for now. */
-	/* x = 50;
-	 y = 50;
-	 width = win->attr.width;
-	 height = win->attr.height;*/
 	if (x < 0) x = 0;
 	if (y < 0) y = 0;
 	if (width > win->attr.width - x)   width = win->attr.width - x;
@@ -269,17 +274,14 @@
 		if (xright > (x + width))
 			xright = x + width;
 		chunk_width = xright - xleft;
-/*		printf("map-state = %d, backing_store = %d\n", win->attr.map_state);
-		printf("request image: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d, ~TEXW = %08x\n",
-		       xleft, xright, width, x, y, width, height, ~TEXW);*/
-		/* image = XGetImage(dpy, win->id, xleft, y, chunk_width, height, AllPlanes, ZPixmap); */
+
 		if (win->pix == None)
 			win->pix = XCompositeNameWindowPixmap(dpy, win->id);
-
 		image = XGetImage(dpy, win->pix, xleft, y, chunk_width, height, AllPlanes, ZPixmap);
 		if (!image) {
-/*			printf("XGetImage Error: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d\n",
-							xleft, xright, width, x, y, width, height);*/
+			printf("XGetImage Error: xleft = %d, xright = %d, width = %d, x:y = %d:%d, width:height = %d:%d\n",
+							xleft, xright, width, x, y, width, height);
+			exit(-1);
 			if (win->oid != -1) {
 				s3d_del_object(win->oid);
 				win->oid = -1;

Modified: trunk/svnonly/comptest/x11.c
===================================================================
--- trunk/svnonly/comptest/x11.c	2007-11-20 22:04:26 UTC (rev 866)
+++ trunk/svnonly/comptest/x11.c	2007-11-20 22:28:40 UTC (rev 867)
@@ -218,6 +218,7 @@
 			 }
 		case CreateNotify:{
 			XCreateWindowEvent *e = &event.xcreatewindow;
+			printf("override_redirect = %d\n", (int)e->override_redirect);
 			window_add(e->display, e->window);
 			break;
 			}



From dotslash at mail.berlios.de  Wed Nov 21 01:03:17 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 21 Nov 2007 01:03:17 +0100
Subject: [S3d-svn] r868 - trunk/svnonly/comptest
Message-ID: <200711210003.lAL03H5L006613@sheep.berlios.de>

Author: dotslash
Date: 2007-11-21 01:03:16 +0100 (Wed, 21 Nov 2007)
New Revision: 868

Modified:
   trunk/svnonly/comptest/comptest.c
   trunk/svnonly/comptest/comptest.h
   trunk/svnonly/comptest/window.c
   trunk/svnonly/comptest/x11.c
Log:
- clean up errorhandling
- refactor some functions


Modified: trunk/svnonly/comptest/comptest.c
===================================================================
--- trunk/svnonly/comptest/comptest.c	2007-11-20 22:28:40 UTC (rev 867)
+++ trunk/svnonly/comptest/comptest.c	2007-11-21 00:03:16 UTC (rev 868)
@@ -157,37 +157,31 @@
 int screen_height = 0;
 int screen_oid = -1;
 
+void set_screenpos() {
+	XWindowAttributes    attr;
+	XGetWindowAttributes(dpy, RootWindow(dpy, 0), &attr);
+	screen_width = attr.width;
+	screen_height = attr.height;
+
+	screen_oid = s3d_new_object();
+	s3d_translate(screen_oid, -SCREEN_SCALE * (float)screen_width/((float) screen_height), SCREEN_SCALE, 0);
+	s3d_scale(screen_oid, 2* SCREEN_SCALE/((float)screen_height));
+
+}
+
 int main(int argc, char **argv)
 {
-	XWindowAttributes    attr;
-	Window        root_return, parent_return;
-	unsigned int     nchildren;
-	Window       *children;
-	int     i, scr_no;
 
 
 	if (xinit())
 		return(1);
-	XGetWindowAttributes(dpy, RootWindow(dpy, 0), &attr);
-	screen_width = attr.width;
-	screen_height = attr.height;
 
 	if (!s3d_init(&argc, &argv, "comptest")) {
 		s3d_set_callback(S3D_EVENT_KEY, key);
-		screen_oid = s3d_new_object();
-		s3d_translate(screen_oid, -SCREEN_SCALE * (float)screen_width/((float) screen_height), SCREEN_SCALE, 0);
-		s3d_scale(screen_oid, 2* SCREEN_SCALE/((float)screen_height));
-		for (scr_no = 0; scr_no < ScreenCount(dpy); scr_no++) {
-			XCompositeRedirectSubwindows(dpy, RootWindow(dpy, scr_no), CompositeRedirectAutomatic);
-			/*   XCompositeRedirectSubwindows(dpy, RootWindow(dpy, scr_no), CompositeRedirectManual);*/
-			XSelectInput(dpy, RootWindow(dpy, scr_no),
-			             SubstructureNotifyMask | ExposureMask | StructureNotifyMask | PropertyChangeMask);
 
-			XQueryTree(dpy, RootWindow(dpy, scr_no), &root_return, &parent_return, &children, &nchildren);
-			for (i = 0; i < (int)nchildren; i++)
-				window_add(dpy, children[i]);
-			XFree(children);
-		}
+		set_screenpos();
+
+		x11_addwindows();
 		s3d_mainloop(mainloop);
 	}
 

Modified: trunk/svnonly/comptest/comptest.h
===================================================================
--- trunk/svnonly/comptest/comptest.h	2007-11-20 22:28:40 UTC (rev 867)
+++ trunk/svnonly/comptest/comptest.h	2007-11-21 00:03:16 UTC (rev 868)
@@ -61,4 +61,5 @@
 int xinit(void);
 int error(Display *COMPUNUSED(dpy), XErrorEvent *event);
 int print_event(Display *COMPUNUSED(dpy), XEvent *event);
+void x11_addwindows();
 extern Display *dpy;

Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-20 22:28:40 UTC (rev 867)
+++ trunk/svnonly/comptest/window.c	2007-11-21 00:03:16 UTC (rev 868)
@@ -102,7 +102,6 @@
 		/* window does not exit, next event is probably it's removal ... */
 		return;
 	}
-	
 
 	/* XSelectInput(dpy, win->id, ExposureMask|ButtonPressMask|KeyPressMask*/
 /*	XSelectInput(dpy, win->id, SubstructureNotifyMask | ExposureMask | StructureNotifyMask | PropertyChangeMask);*/

Modified: trunk/svnonly/comptest/x11.c
===================================================================
--- trunk/svnonly/comptest/x11.c	2007-11-20 22:28:40 UTC (rev 867)
+++ trunk/svnonly/comptest/x11.c	2007-11-21 00:03:16 UTC (rev 868)
@@ -23,11 +23,12 @@
 
 #include "comptest.h"
 #include <stdio.h>		/* printf() */
+#include <X11/Xproto.h>	/* X_* request defines */
 
 #define XCOMPOSITE_VERSION_0_2 200
 
 struct extension {
-	int event, error;
+	int event, error, request;
 };
 static struct extension    xrender, xcomposite, xdamage, xfixes;
 Display       *dpy;
@@ -37,31 +38,14 @@
 {
 	char *name = "unknown";
 	switch (event->type & 0x7f) {
-	case CreateNotify:
-		name = "Create";
-		break;
-	case DestroyNotify:
-		name = "Destroy";
-		break;
-	case Expose:
-		name = "Expose";
-		break;
-	case MapNotify:
-		name = "Map";
-		break;
-	case UnmapNotify:
-		name = "Unmap";
-		break;
-	case ReparentNotify:
-		name = "Reparent";
-		break;
-	case CirculateNotify:
-		name = "Circulate";
-		break;
-	case PropertyNotify:
-		name = "PropertyNotify";
-		return(0);
-		break;
+	case CreateNotify:		name = "Create";			break;
+	case DestroyNotify:		name = "Destroy";			break;
+	case Expose:			name = "Expose";			break;
+	case MapNotify:			name = "Map";				break;
+	case UnmapNotify:		name = "Unmap";				break;
+	case ReparentNotify:	name = "Reparent";			break;
+	case CirculateNotify:	name = "Circulate";			break;
+	case PropertyNotify:	name = "PropertyNotify";	return(0);	break;
 	}
 	if (event->type == xdamage.event + XDamageNotify) {
 		name = "Damage";
@@ -76,61 +60,65 @@
 
 int error(Display *COMPUNUSED(dpy), XErrorEvent *event)
 {
-	char *name = "";
+	char *name;
 	char buf[256];
-	int     o;
+	char buf_req[256];
+	char *req;
 
-	o = event->error_code - xfixes.error;
-	switch (o) {
-	case BadRegion:
-		name = "BadRegion";
-		break;
-	default:
-		break;
+	XGetErrorText(dpy, event->error_code, buf, 256);
+	name = buf;
+
+	switch (event->error_code - xfixes.error) {
+	case BadRegion:		name = "BadRegion";		break;
+	default:			break;
 	}
-	o = event->error_code - xdamage.error;
-	switch (o) {
-	case BadDamage:
-		name = "BadDamage";
-		break;
-	default:
-		break;
+	switch (event->error_code - xdamage.error) {
+	case BadDamage:		name = "BadDamage";		break;
+	default:			break;
 	}
-	o = event->error_code - xrender.error;
-	switch (o) {
-	case BadPictFormat:
-		name = "BadPictFormat";
-		break;
-	case BadPicture:
-		name = "BadPicture";
-		break;
-	case BadPictOp:
-		name = "BadPictOp";
-		break;
-	case BadGlyphSet:
-		name = "BadGlyphSet";
-		break;
-	case BadGlyph:
-		name = "BadGlyph";
-		break;
-	default:
-		break;
+	switch (event->error_code - xrender.error) {
+	case BadPictFormat:	name = "BadPictFormat";		break;
+	case BadPicture:	name = "BadPicture";		break;
+	case BadPictOp:		name = "BadPictOp";			break;
+	case BadGlyphSet:	name = "BadGlyphSet";		break;
+	case BadGlyph:		name = "BadGlyph";			break;
+	default:			break;
 	}
-	switch (event->error_code) {
-	case BadWindow:
-		name = "BadWindow";
-		break;
-	case BadDrawable:
-		name = "BadDrawable";
-		break;
-	case BadMatch:
-		name = "BadMatch";
-		return(0);
-		break;
+
+	/* request code */
+	sprintf(buf_req, "unknown (request %d, minor %d)", event->request_code, event->minor_code);
+	req = buf_req;
+
+	switch (event->request_code) {
+	case X_GetWindowAttributes:	req = "XGetWindowAttributes()";	break;
+	case X_GetImage:			req = "XGetImage()";			break;
+	default:				break;
 	}
-	XGetErrorText(dpy, event->error_code, buf, 256);
-	printf("error %d (name: %s) request %d minor %d serial %d: %s\n",
-	       event->error_code, name, event->request_code, event->minor_code, (int)event->serial, buf);
+	if (event->request_code == xcomposite.request) {
+		switch (event->minor_code) {
+		case X_CompositeRedirectWindow:			req = "XCompositeRedirectWindow()";			break;
+		case X_CompositeNameWindowPixmap:		req = "XCompositeNameWindowPixmap()";		break;
+		default:				
+			sprintf(buf_req, "XComposite?? unknown (request %d, minor %d)", event->request_code, event->minor_code);
+			req = buf_req;
+			break;
+		}
+	}
+
+	if (event->request_code == xdamage.request) {
+		switch (event->minor_code) {
+		case X_DamageAdd:			req = "XDamageAdd()";			break;
+		case X_DamageCreate:		req = "XDamageCreate()";		break;
+		case X_DamageDestroy:		req = "XDamageDestroy()";		break;
+		case X_DamageSubtract:		req = "XDamageSubtract()";		break;
+		default:				
+			sprintf(buf_req, "XDamage?? unknown (request %d, minor %d)", event->request_code, event->minor_code);
+			req = buf_req;
+			break;
+		}
+	}
+
+	printf("ERROR at request %s [%d]: %s\n", req, event->error_code, name);
 	return(0);
 }
 
@@ -140,38 +128,38 @@
 	int composite_major, composite_minor;
 
 	dpy = XOpenDisplay(display);
+
 	if (!dpy) {
 		fprintf(stderr, "Can't open display\n");
 		return(1);
 	}
-	if (!XRenderQueryExtension(dpy, &xrender.event, &xrender.error)) {
+	if (!XQueryExtension (dpy, COMPOSITE_NAME, &xcomposite.request, &xcomposite.event, &xcomposite.error)) {
+		fprintf(stderr, "No composite extension\n");
+	    return(1);
+	}
+	if (!XQueryExtension (dpy, RENDER_NAME, &xrender.request, &xrender.event, &xrender.error)) {
 		fprintf(stderr, "No render extension\n");
-		return(1);
+	    return(1);
 	}
-
-	if (!XCompositeQueryExtension(dpy, &xcomposite.event, &xcomposite.error)) {
-		fprintf(stderr, "No composite extension\n");
-		return(1);
+	if (!XQueryExtension (dpy, DAMAGE_NAME, &xdamage.request, &xdamage.event, &xdamage.error)) {
+		fprintf(stderr, "No damage extension\n");
+	    return(1);
 	}
+	if (!XQueryExtension (dpy, XFIXES_NAME, &xfixes.request, &xfixes.event, &xfixes.error)) {
+		fprintf(stderr, "No fixes extension\n");
+	    return(1);
+	}
 
+
 	if (!XCompositeQueryVersion(dpy, &composite_major, &composite_minor)) {
 		fprintf(stderr, "Could not check composite version\n");
 		return(1);
 	}
-
 	if (XCompositeVersion() < XCOMPOSITE_VERSION_0_2) {
 		fprintf(stderr, "Could not find composite version 0.2 or better\n");
 		return(1);
 	}
 
-	if (!XDamageQueryExtension(dpy, &xdamage.event, &xdamage.error)) {
-		fprintf(stderr, "No damage extension\n");
-		return(1);
-	}
-	if (!XFixesQueryExtension(dpy, &xfixes.event, &xfixes.error)) {
-		fprintf(stderr, "No XFixes extension\n");
-		return(1);
-	}
 	XSetErrorHandler(error);
 	return(0);
 }
@@ -218,7 +206,6 @@
 			 }
 		case CreateNotify:{
 			XCreateWindowEvent *e = &event.xcreatewindow;
-			printf("override_redirect = %d\n", (int)e->override_redirect);
 			window_add(e->display, e->window);
 			break;
 			}
@@ -231,4 +218,22 @@
 	}
 }
 
+void x11_addwindows() 
+{
+	Window        root_return, parent_return;
+	unsigned int     nchildren;
+	Window       *children;
+	int     i, scr_no;
 
+	for (scr_no = 0; scr_no < ScreenCount(dpy); scr_no++) {
+		XCompositeRedirectSubwindows(dpy, RootWindow(dpy, scr_no), CompositeRedirectAutomatic);
+		/*   XCompositeRedirectSubwindows(dpy, RootWindow(dpy, scr_no), CompositeRedirectManual);*/
+		XSelectInput(dpy, RootWindow(dpy, scr_no),
+					 SubstructureNotifyMask | ExposureMask | StructureNotifyMask | PropertyChangeMask);
+	
+		XQueryTree(dpy, RootWindow(dpy, scr_no), &root_return, &parent_return, &children, &nchildren);
+		for (i = 0; i < (int)nchildren; i++)
+			window_add(dpy, children[i]);
+		XFree(children);
+	}
+}



From dotslash at mail.berlios.de  Wed Nov 21 01:56:28 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 21 Nov 2007 01:56:28 +0100
Subject: [S3d-svn] r869 - trunk/svnonly/comptest
Message-ID: <200711210056.lAL0uSeF016342@sheep.berlios.de>

Author: dotslash
Date: 2007-11-21 01:56:28 +0100 (Wed, 21 Nov 2007)
New Revision: 869

Modified:
   trunk/svnonly/comptest/window.c
   trunk/svnonly/comptest/x11.c
Log:
- use XCompositeRedirectWindow() to in window_add to have it redirected once it
  comes available
- only update contents after all requests were answered


Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-21 00:03:16 UTC (rev 868)
+++ trunk/svnonly/comptest/window.c	2007-11-21 00:56:28 UTC (rev 869)
@@ -115,6 +115,7 @@
 	
 
 
+	XCompositeRedirectWindow(dpy, id, CompositeRedirectAutomatic);
 	window_update_content(win, 0, 0, win->attr.width, win->attr.height);
 /*	printf("window (%d) added\n", (int)id);*/
 }
@@ -149,7 +150,6 @@
 void window_update_geometry(struct window *win, int x, int y, int width, int height)
 {
 
-	printf("window_update_geometry()\n");
 	if (win->oid == -1) {
 		win->attr.x = x;
 		win->attr.y = y;

Modified: trunk/svnonly/comptest/x11.c
===================================================================
--- trunk/svnonly/comptest/x11.c	2007-11-21 00:03:16 UTC (rev 868)
+++ trunk/svnonly/comptest/x11.c	2007-11-21 00:56:28 UTC (rev 869)
@@ -170,10 +170,12 @@
 	XEvent event;
 	struct window *window;
 	int i;
-	for (window = window_head; window != NULL; window = window->next)
-		window->already_updated = 0;
+	int ret;
+/*	for (window = window_head; window != NULL; window = window->next)
+		window->already_updated = 0;*/
 
-	for (i = 0; i < MAXEVENTS && XPending(dpy); i++) {
+	while (XPending(dpy)) {
+/*	for (i = 0; i < MAXEVENTS && XPending(dpy); i++) {*/
 		XNextEvent(dpy, &event);
 		print_event(dpy, &event);
 		switch (event.type - xdamage.event) {
@@ -185,7 +187,10 @@
 			XDamageSubtract(dpy, e->damage, None, None);
 			window = window_find(e->drawable);
 			if (window != NULL)
-				window_update_content(window, e->area.x, e->area.y, e->area.width, e->area.height);
+				window->already_updated = 0;
+				/* TODO: remember the rect damaged, and only update this part later. merge it if there was
+				 * already damage. */
+/*				window_update_content(window, e->area.x, e->area.y, e->area.width, e->area.height);*/
 			break;
 		   }
 
@@ -216,6 +221,12 @@
 		   }
 		}
 	}
+	for (window = window_head; window != NULL; window = window->next)
+		if (window->already_updated == 0) {
+			window_update_content(window, 0,0, window->attr.width, window->attr.height);
+			window->already_updated = 1;
+		}
+
 }
 
 void x11_addwindows() 



From dotslash at mail.berlios.de  Wed Nov 21 12:56:43 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 21 Nov 2007 12:56:43 +0100
Subject: [S3d-svn] r870 - trunk/svnonly/comptest
Message-ID: <200711211156.lALBuhON015806@sheep.berlios.de>

Author: dotslash
Date: 2007-11-21 12:56:27 +0100 (Wed, 21 Nov 2007)
New Revision: 870

Modified:
   trunk/svnonly/comptest/comptest.h
   trunk/svnonly/comptest/window.c
   trunk/svnonly/comptest/x11.c
Log:
- split updated flags into geometry_update_needed and content_update_needed,
  process both after all pending events were dealt with
- some cleanup, print statistics about the time usage


Modified: trunk/svnonly/comptest/comptest.h
===================================================================
--- trunk/svnonly/comptest/comptest.h	2007-11-21 00:56:28 UTC (rev 869)
+++ trunk/svnonly/comptest/comptest.h	2007-11-21 11:56:27 UTC (rev 870)
@@ -24,6 +24,8 @@
 #define TEXH 256
 #define TEXNUM(win, x, y) \
   ((((win->attr.height + TEXH - 1)& ~(TEXH-1))/TEXH) * ((int)(x/TEXH)) + ((int)(y/TEXW)))
+#define MIN(x,y)	(((x)<(y))?(x):(y))
+#define MAX(x,y)	(((x)>(y))?(x):(y))
 
 
 struct window {
@@ -32,7 +34,9 @@
 	XImage      *image;
 	Damage       damage;  /* damage notification */
 	Pixmap			pix;
-	int     already_updated;
+	int			geometry_update_needed;
+	int     	content_update_needed;
+	XRectangle	content_update;
 	int        oid;
 	int		   no;
 
@@ -45,15 +49,14 @@
 extern int screen_oid;
 void deco_box(struct window *win);
 /* window.c */
-void window_update_content(struct window *win, int x, int y, int width, int height);
 void window_set_position(struct window *win);
 void window_restack(struct window *win, Window above);
 struct window *window_find(Window id);
 struct window *window_find(Window id);
 void window_add(Display *dpy, Window id);
 void window_remove(Window id);
-void window_update_content(struct window *win, int x, int y, int width, int height);
-void window_update_geometry(struct window *win, int x, int y, int width, int height);
+void window_update_content(struct window *win);
+void window_update_geometry(struct window *win);
 
 extern struct window   *window_head;
 /* x11.c */

Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-21 00:56:28 UTC (rev 869)
+++ trunk/svnonly/comptest/window.c	2007-11-21 11:56:27 UTC (rev 870)
@@ -92,8 +92,15 @@
 	win->pix = None;
 	win->no = 0;
 	win->oid = -1;
-	win->already_updated = 0;
+	win->content_update_needed = 1;
+	win->geometry_update_needed = 0;
+	win->content_update.x = 0;
+	win->content_update.y = 0;
+	win->content_update.width = 0;
+	win->content_update.height = 0;
 
+
+
 	/* TODO: at my place, windows are created and destroyed in the same moment. so this 
 	 * function fails sometimes. 
 	 * maybe there is a function asking something like "is there really a window with id ;win->id'...". 
@@ -102,22 +109,21 @@
 		/* window does not exit, next event is probably it's removal ... */
 		return;
 	}
+	win->content_update.width = win->attr.width;
+	win->content_update.height = win->attr.height;
 
 	/* XSelectInput(dpy, win->id, ExposureMask|ButtonPressMask|KeyPressMask*/
 /*	XSelectInput(dpy, win->id, SubstructureNotifyMask | ExposureMask | StructureNotifyMask | PropertyChangeMask);*/
 	XSelectInput(dpy, win->id, 0);
 
-	win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty);
+	if (win->attr.class != InputOnly)		/* don't create damage on these windows */
+		win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty);
 	if (win->next == NULL) 
 		window_restack(win, None);
 	else
 		window_restack(win, win->next->id);
 	
-
-
 	XCompositeRedirectWindow(dpy, id, CompositeRedirectAutomatic);
-	window_update_content(win, 0, 0, win->attr.width, win->attr.height);
-/*	printf("window (%d) added\n", (int)id);*/
 }
 
 void window_remove(Window id)
@@ -142,48 +148,43 @@
 		XFreePixmap(dpy, window->pix);
 	if (window->oid != -1)
 		s3d_del_object(window->oid);
-	if (window->damage)
-		XDamageDestroy(dpy, window->damage);
+/*  Damage is automatically destroyed */
+/*	if (window->damage != None)
+		XDamageDestroy(dpy, window->damage);	*/
 
 	free(window);
 }
-void window_update_geometry(struct window *win, int x, int y, int width, int height)
+void window_update_geometry(struct window *win)
 {
+	XWindowAttributes attr;	
+	win->geometry_update_needed = 0;
 
-	if (win->oid == -1) {
-		win->attr.x = x;
-		win->attr.y = y;
-		win->attr.width = width;
-		win->attr.height = height;
-
-		window_update_content(win, 0, 0, width, height);
+	if (!XGetWindowAttributes(dpy, win->id, &attr))
 		return;
-	}
-	if (win->pix != None) {
-		XFreePixmap(dpy, win->pix);
-		win->pix = None;
-	}
 
-	if ((win->attr.width == width) && (win->attr.height == height)) {
-		if ((win->attr.x == x) && (win->attr.y == y)) {
+	if (win->oid == -1) {
+		win->content_update_needed = 1;
+	} 
+
+	if ((win->attr.width == attr.width) && (win->attr.height == attr.height)) {
+		if ((win->attr.x == attr.x) && (win->attr.y == attr.y)) {
 			printf("position did not change\n");
-			return;
 		} else {
-			win->attr.x = x;
-			win->attr.y = y;
+			memcpy(&win->attr, &attr, sizeof(attr));
 			window_set_position(win);
+			return;
 		}
 	} else {
-		win->attr.x = x;
-		win->attr.y = y;
-		win->attr.width = width;
-		win->attr.height = height;
+		if (win->pix != None) {
+			XFreePixmap(dpy, win->pix);
+			win->pix = None;
+		}
 
 		s3d_del_object(win->oid); /* delete the window and redraw */
 		win->oid = -1;
-		window_update_content(win, 0, 0, width, height);
-
+		win->content_update_needed = 1;
 	}
+	memcpy(&win->attr, &attr, sizeof(attr));
 }
 
 /* convert X-format to s3ds RGBA 32bit format */
@@ -238,14 +239,25 @@
 }
 
 /* takes a bounding box and updates its window contents */
-void window_update_content(struct window *win, int x, int y, int width, int height)
+void window_update_content(struct window *win)
 {
+	int x, y, width, height;
 	int chunk_width, chunk_height;
 	int xleft, xright;
 	int ytop, ybottom;
 	char *bitmap;
 	XImage *image;
 
+	x = win->content_update.x;
+	y = win->content_update.y;
+	width = win->content_update.width;
+	height = win->content_update.height;
+
+	/* done with updating, or at least we tried */
+	win->content_update.width = 0;
+	win->content_update.height = 0;
+	win->content_update_needed = 0;
+
 	if (win->attr.map_state == IsUnmapped)	/* not mapped images can't be grabbed */
 		return;
 
@@ -257,16 +269,6 @@
 	if (width > win->attr.width - x)   width = win->attr.width - x;
 	if (height > win->attr.height - y)   height = win->attr.height - y;
 
-	if (x == 0 && y == 0 && width == win->attr.width && height == win->attr.height) {
-		if (win->already_updated)
-			return;
-		else
-			win->already_updated = 1;
-	}
-
-	/* if (!win->oid)
-	  deco_box(win);
-	*/
 	bitmap = malloc(TEXW * height * sizeof(uint32_t));
 	for (xleft = x; xleft < x + width ; xleft = xright) {
 		xright = (xleft + TEXW) & ~(TEXW - 1);
@@ -290,8 +292,9 @@
 		}
 		if (win->oid == -1)
 			deco_box(win);
+
 		image_convert(image, bitmap);
-		/*  printf("load textures ...\n");*/
+
 		for (ytop = y; ytop < y + height; ytop = ybottom) {
 			ybottom = (ytop + TEXH) & ~(TEXH - 1);
 			if (ybottom > y + height)
@@ -299,11 +302,7 @@
 			chunk_height = ybottom - ytop;
 			s3d_load_texture(win->oid, TEXNUM(win, xleft, ytop), xleft % TEXW, ytop % TEXH,
 			                 chunk_width, chunk_height, (unsigned char *)bitmap + chunk_width * (ytop - y) * 4);
-			/*   printf("s3d_load_texture(%d, %d, %d, %d, %d, %d, %010p);\n",
-			       win->oid, TEXNUM(win, xleft, ytop), xleft % TEXW, ytop % TEXH,
-			        chunk_width, chunk_height, (unsigned char *)bitmap + chunk_width * (ytop - y) * 4);*/
 		}
-		/*  printf("done loading textures\n"); */
 		XDestroyImage(image);
 	}
 	free(bitmap);

Modified: trunk/svnonly/comptest/x11.c
===================================================================
--- trunk/svnonly/comptest/x11.c	2007-11-21 00:56:28 UTC (rev 869)
+++ trunk/svnonly/comptest/x11.c	2007-11-21 11:56:27 UTC (rev 870)
@@ -23,6 +23,7 @@
 
 #include "comptest.h"
 #include <stdio.h>		/* printf() */
+#include <string.h>		/* memcpy() */
 #include <X11/Xproto.h>	/* X_* request defines */
 
 #define XCOMPOSITE_VERSION_0_2 200
@@ -164,18 +165,32 @@
 	return(0);
 }
 
+/* find biggest bounding rect of the two given rects, write it into dest */
+void merge_rect( XRectangle *dest, XRectangle *src) {
+	int max;
+	if (dest->width == 0 || dest->height == 0) {
+		memcpy(dest, src, sizeof(*dest));
+		return;
+	}
+	max = MAX(dest->width + dest->x, src->width + src->x);
+	dest->x = MIN(dest->x, src->x);
+	dest->width = max - dest->x;
 
+	max = MAX(dest->height + dest->y, src->height + src->y);
+	dest->y = MIN(dest->y, src->y);
+	dest->height = max - dest->y;
+}
+
 void event(void)
 {
 	XEvent event;
 	struct window *window;
-	int i;
-	int ret;
-/*	for (window = window_head; window != NULL; window = window->next)
-		window->already_updated = 0;*/
+	struct timeval start, stop;
+	float secs;
 
+
+	gettimeofday(&start, NULL);
 	while (XPending(dpy)) {
-/*	for (i = 0; i < MAXEVENTS && XPending(dpy); i++) {*/
 		XNextEvent(dpy, &event);
 		print_event(dpy, &event);
 		switch (event.type - xdamage.event) {
@@ -186,11 +201,10 @@
 			          e->area.width, e->area.height, e->area.x, e->area.y);*/
 			XDamageSubtract(dpy, e->damage, None, None);
 			window = window_find(e->drawable);
-			if (window != NULL)
-				window->already_updated = 0;
-				/* TODO: remember the rect damaged, and only update this part later. merge it if there was
-				 * already damage. */
-/*				window_update_content(window, e->area.x, e->area.y, e->area.width, e->area.height);*/
+			if (window != NULL) {
+				window->content_update_needed = 1;
+				merge_rect(&window->content_update, &e->area);
+			}
 			break;
 		   }
 
@@ -203,7 +217,7 @@
 				/*    printf("Configure: window = %d, geometry = %d:%d (at %d:%d)\n",
 				           (int)e->window, e->width, e->height, e->x, e->y);*/
 				window_restack(window, e->above);
-				window_update_geometry(window, e->x, e->y, e->width, e->height);
+				window->geometry_update_needed = 1;
 			} else {
 				printf("Configure: Could not find window to configure.\n");
 			}
@@ -221,12 +235,22 @@
 		   }
 		}
 	}
-	for (window = window_head; window != NULL; window = window->next)
-		if (window->already_updated == 0) {
-			window_update_content(window, 0,0, window->attr.width, window->attr.height);
-			window->already_updated = 1;
+	int d;
+	d = 0;
+	for (window = window_head; window != NULL; window = window->next) {
+		if (window->geometry_update_needed) 
+			window_update_geometry(window);
+		if (window->content_update_needed) 
+		{
+			window_update_content(window);
+			d++;
 		}
+	}
 
+	gettimeofday(&stop, NULL);
+	secs = (stop.tv_sec - start.tv_sec) + (stop.tv_usec - start.tv_usec)/1e6;
+	printf("msecs to process events: %3.3f, %d windows updated\n", secs*1e3, d);
+
 }
 
 void x11_addwindows() 



From dotslash at mail.berlios.de  Wed Nov 21 13:33:48 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 21 Nov 2007 13:33:48 +0100
Subject: [S3d-svn] r871 - trunk/svnonly/comptest
Message-ID: <200711211233.lALCXmhR026859@sheep.berlios.de>

Author: dotslash
Date: 2007-11-21 13:33:47 +0100 (Wed, 21 Nov 2007)
New Revision: 871

Modified:
   trunk/svnonly/comptest/comptest.c
   trunk/svnonly/comptest/comptest.h
   trunk/svnonly/comptest/window.c
   trunk/svnonly/comptest/x11.c
Log:
- hide and show windows if they are (un)mapped


Modified: trunk/svnonly/comptest/comptest.c
===================================================================
--- trunk/svnonly/comptest/comptest.c	2007-11-21 11:56:27 UTC (rev 870)
+++ trunk/svnonly/comptest/comptest.c	2007-11-21 12:33:47 UTC (rev 871)
@@ -28,17 +28,23 @@
 #include <time.h>         /* nanosleep() */
 #include <errno.h>			/* errno */
 
+#include <sys/time.h>		/* gettimeofday() */
+#include <time.h>			/* gettimeofday() */
 
 
-
-
 static struct timespec t = {
 	0, 50*1000*1000
 }; /* 50 mili seconds */
 
 static void mainloop(void)
 {
+	struct timeval start, stop;
+	float secs;
+	gettimeofday(&start, NULL);
 	event();
+	gettimeofday(&stop, NULL);
+	secs = (stop.tv_sec - start.tv_sec) + (stop.tv_usec - start.tv_usec)/1e6;
+/*	printf("msecs to process events: %3.3f\n", secs*1e3);*/
 	nanosleep(&t, NULL);
 }
 
@@ -135,7 +141,8 @@
 	}
 	window_set_position(win);
 	/*  push data on texture 0 position (0,0) */
-	s3d_flags_on(win->oid, S3D_OF_VISIBLE);
+	if (win->mapped)
+		s3d_flags_on(win->oid, S3D_OF_VISIBLE);
 }
 
 static int key(struct s3d_evt *evt)

Modified: trunk/svnonly/comptest/comptest.h
===================================================================
--- trunk/svnonly/comptest/comptest.h	2007-11-21 11:56:27 UTC (rev 870)
+++ trunk/svnonly/comptest/comptest.h	2007-11-21 12:33:47 UTC (rev 871)
@@ -39,6 +39,7 @@
 	XRectangle	content_update;
 	int        oid;
 	int		   no;
+	int 		mapped;
 
 	struct window     *next;
 };
@@ -52,8 +53,7 @@
 void window_set_position(struct window *win);
 void window_restack(struct window *win, Window above);
 struct window *window_find(Window id);
-struct window *window_find(Window id);
-void window_add(Display *dpy, Window id);
+struct window *window_add(Display *dpy, Window id);
 void window_remove(Window id);
 void window_update_content(struct window *win);
 void window_update_geometry(struct window *win);

Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-21 11:56:27 UTC (rev 870)
+++ trunk/svnonly/comptest/window.c	2007-11-21 12:33:47 UTC (rev 871)
@@ -23,6 +23,7 @@
 
 #include "comptest.h"
 #include <stdlib.h>	/* malloc(), free() */
+#include <string.h>	/* memcpy() */
 #include <stdio.h>	/* printf() */
 struct window   *window_head = NULL;
 
@@ -74,16 +75,18 @@
 
 }
 
-void window_add(Display *dpy, Window id)
+struct window *window_add(Display *dpy, Window id)
 {
 	struct window *win;
 	win = malloc(sizeof(struct window));
 	if (!win)
-		return;
+		return(NULL);
 
+	printf("window_add(%d)\n", (int) id);
 	if (window_find(id) != NULL) {
 		printf("!!!! Window already added\n");
-		return;
+		free(win);
+		return(NULL);
 	}
 	win->id = id;
 	win->next = window_head;
@@ -92,12 +95,13 @@
 	win->pix = None;
 	win->no = 0;
 	win->oid = -1;
-	win->content_update_needed = 1;
+	win->content_update_needed = 0;
 	win->geometry_update_needed = 0;
 	win->content_update.x = 0;
 	win->content_update.y = 0;
 	win->content_update.width = 0;
 	win->content_update.height = 0;
+	win->mapped = 0;
 
 
 
@@ -107,10 +111,8 @@
 	 * that would help here. */
 	if (!XGetWindowAttributes(dpy, win->id, &win->attr)) {
 		/* window does not exit, next event is probably it's removal ... */
-		return;
+		return(win);
 	}
-	win->content_update.width = win->attr.width;
-	win->content_update.height = win->attr.height;
 
 	/* XSelectInput(dpy, win->id, ExposureMask|ButtonPressMask|KeyPressMask*/
 /*	XSelectInput(dpy, win->id, SubstructureNotifyMask | ExposureMask | StructureNotifyMask | PropertyChangeMask);*/
@@ -124,8 +126,37 @@
 		window_restack(win, win->next->id);
 	
 	XCompositeRedirectWindow(dpy, id, CompositeRedirectAutomatic);
+	return(win);
 }
+void window_map(struct window *win)
+{
+	printf("window_map(%d)\n", win->id);
+	if (win->mapped)
+		return;
 
+	win->mapped = 1;
+	win->content_update_needed = 1;
+	win->content_update.x = 0;
+	win->content_update.y = 0;
+	win->content_update.width = win->attr.width;
+	win->content_update.height = win->attr.height;
+	if (win->oid != -1)
+		s3d_flags_on(win->oid, S3D_OF_VISIBLE);
+
+
+}
+
+void window_unmap(struct window *win)
+{
+	if (!win->mapped)
+		return;
+	win->mapped = 0;
+	if (win->oid != -1)
+		s3d_flags_off(win->oid, S3D_OF_VISIBLE);
+
+	/* TODO: handle */
+}
+
 void window_remove(Window id)
 {
 	struct window **wp, *window;

Modified: trunk/svnonly/comptest/x11.c
===================================================================
--- trunk/svnonly/comptest/x11.c	2007-11-21 11:56:27 UTC (rev 870)
+++ trunk/svnonly/comptest/x11.c	2007-11-21 12:33:47 UTC (rev 871)
@@ -185,11 +185,7 @@
 {
 	XEvent event;
 	struct window *window;
-	struct timeval start, stop;
-	float secs;
 
-
-	gettimeofday(&start, NULL);
 	while (XPending(dpy)) {
 		XNextEvent(dpy, &event);
 		print_event(dpy, &event);
@@ -223,6 +219,22 @@
 			}
 			break;
 			 }
+		case MapNotify:{
+			XMapEvent *e = &event.xmap;
+			window = window_find(e->window);
+			if (window != NULL)
+				window_map(window);
+			break;
+			}
+		case UnmapNotify:{
+			XUnmapEvent *e = &event.xunmap;
+			window = window_find(e->window);
+			if (window != NULL)
+				window_unmap(window);
+			break;
+			}
+
+
 		case CreateNotify:{
 			XCreateWindowEvent *e = &event.xcreatewindow;
 			window_add(e->display, e->window);
@@ -247,9 +259,7 @@
 		}
 	}
 
-	gettimeofday(&stop, NULL);
-	secs = (stop.tv_sec - start.tv_sec) + (stop.tv_usec - start.tv_usec)/1e6;
-	printf("msecs to process events: %3.3f, %d windows updated\n", secs*1e3, d);
+/*	printf("%d windows updated\n", d);*/
 
 }
 
@@ -258,6 +268,7 @@
 	Window        root_return, parent_return;
 	unsigned int     nchildren;
 	Window       *children;
+	struct window *win;
 	int     i, scr_no;
 
 	for (scr_no = 0; scr_no < ScreenCount(dpy); scr_no++) {
@@ -267,8 +278,12 @@
 					 SubstructureNotifyMask | ExposureMask | StructureNotifyMask | PropertyChangeMask);
 	
 		XQueryTree(dpy, RootWindow(dpy, scr_no), &root_return, &parent_return, &children, &nchildren);
-		for (i = 0; i < (int)nchildren; i++)
-			window_add(dpy, children[i]);
+		for (i = 0; i < (int)nchildren; i++) {
+			win = window_add(dpy, children[i]);
+			if (win != NULL && win->attr.map_state != IsUnmapped)
+				window_map(win);
+
+		}
 		XFree(children);
 	}
 }



From lazhur at mail.berlios.de  Wed Nov 21 16:29:40 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Wed, 21 Nov 2007 16:29:40 +0100
Subject: [S3d-svn] r872 - trunk/svnonly/comptest
Message-ID: <200711211529.lALFTe9V011278@sheep.berlios.de>

Author: lazhur
Date: 2007-11-21 16:29:34 +0100 (Wed, 21 Nov 2007)
New Revision: 872

Modified:
   trunk/svnonly/comptest/comptest.c
   trunk/svnonly/comptest/x11.c
Log:
comptest: Convert non-ANSI to ANSI function declaration


Modified: trunk/svnonly/comptest/comptest.c
===================================================================
--- trunk/svnonly/comptest/comptest.c	2007-11-21 12:33:47 UTC (rev 871)
+++ trunk/svnonly/comptest/comptest.c	2007-11-21 15:29:34 UTC (rev 872)
@@ -164,7 +164,7 @@
 int screen_height = 0;
 int screen_oid = -1;
 
-void set_screenpos() {
+static void set_screenpos(void) {
 	XWindowAttributes    attr;
 	XGetWindowAttributes(dpy, RootWindow(dpy, 0), &attr);
 	screen_width = attr.width;

Modified: trunk/svnonly/comptest/x11.c
===================================================================
--- trunk/svnonly/comptest/x11.c	2007-11-21 12:33:47 UTC (rev 871)
+++ trunk/svnonly/comptest/x11.c	2007-11-21 15:29:34 UTC (rev 872)
@@ -166,7 +166,7 @@
 }
 
 /* find biggest bounding rect of the two given rects, write it into dest */
-void merge_rect( XRectangle *dest, XRectangle *src) {
+static void merge_rect( XRectangle *dest, XRectangle *src) {
 	int max;
 	if (dest->width == 0 || dest->height == 0) {
 		memcpy(dest, src, sizeof(*dest));
@@ -263,7 +263,7 @@
 
 }
 
-void x11_addwindows() 
+void x11_addwindows(void)
 {
 	Window        root_return, parent_return;
 	unsigned int     nchildren;



From lazhur at mail.berlios.de  Wed Nov 21 16:30:00 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Wed, 21 Nov 2007 16:30:00 +0100
Subject: [S3d-svn] r873 - trunk/svnonly/comptest
Message-ID: <200711211530.lALFU01I011424@sheep.berlios.de>

Author: lazhur
Date: 2007-11-21 16:30:00 +0100 (Wed, 21 Nov 2007)
New Revision: 873

Modified:
   trunk/svnonly/comptest/comptest.h
Log:
comptest: Declare window_(un)map in header


Modified: trunk/svnonly/comptest/comptest.h
===================================================================
--- trunk/svnonly/comptest/comptest.h	2007-11-21 15:29:34 UTC (rev 872)
+++ trunk/svnonly/comptest/comptest.h	2007-11-21 15:30:00 UTC (rev 873)
@@ -50,6 +50,7 @@
 extern int screen_oid;
 void deco_box(struct window *win);
 /* window.c */
+void window_map(struct window *win);
 void window_set_position(struct window *win);
 void window_restack(struct window *win, Window above);
 struct window *window_find(Window id);
@@ -57,6 +58,7 @@
 void window_remove(Window id);
 void window_update_content(struct window *win);
 void window_update_geometry(struct window *win);
+void window_unmap(struct window *win);
 
 extern struct window   *window_head;
 /* x11.c */



From lazhur at mail.berlios.de  Wed Nov 21 16:30:13 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Wed, 21 Nov 2007 16:30:13 +0100
Subject: [S3d-svn] r874 - trunk/svnonly/comptest
Message-ID: <200711211530.lALFUDXC011497@sheep.berlios.de>

Author: lazhur
Date: 2007-11-21 16:30:13 +0100 (Wed, 21 Nov 2007)
New Revision: 874

Modified:
   trunk/svnonly/comptest/window.c
   trunk/svnonly/comptest/x11.c
Log:
comptest: Don't mix variable declaration and code


Modified: trunk/svnonly/comptest/window.c
===================================================================
--- trunk/svnonly/comptest/window.c	2007-11-21 15:30:00 UTC (rev 873)
+++ trunk/svnonly/comptest/window.c	2007-11-21 15:30:13 UTC (rev 874)
@@ -130,7 +130,7 @@
 }
 void window_map(struct window *win)
 {
-	printf("window_map(%d)\n", win->id);
+	printf("window_map(%d)\n", (int)win->id);
 	if (win->mapped)
 		return;
 

Modified: trunk/svnonly/comptest/x11.c
===================================================================
--- trunk/svnonly/comptest/x11.c	2007-11-21 15:30:00 UTC (rev 873)
+++ trunk/svnonly/comptest/x11.c	2007-11-21 15:30:13 UTC (rev 874)
@@ -185,6 +185,7 @@
 {
 	XEvent event;
 	struct window *window;
+	int d;
 
 	while (XPending(dpy)) {
 		XNextEvent(dpy, &event);
@@ -247,7 +248,6 @@
 		   }
 		}
 	}
-	int d;
 	d = 0;
 	for (window = window_head; window != NULL; window = window->next) {
 		if (window->geometry_update_needed) 



From dotslash at mail.berlios.de  Sun Nov 25 16:59:55 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 25 Nov 2007 16:59:55 +0100
Subject: [S3d-svn] r875 - trunk/server
Message-ID: <200711251559.lAPFxteY016862@sheep.berlios.de>

Author: dotslash
Date: 2007-11-25 16:59:54 +0100 (Sun, 25 Nov 2007)
New Revision: 875

Modified:
   trunk/server/global.h
   trunk/server/object.c
   trunk/server/shm.c
Log:
- prepare server for SHM textures


Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2007-11-21 15:30:13 UTC (rev 874)
+++ trunk/server/global.h	2007-11-25 15:59:54 UTC (rev 875)
@@ -110,6 +110,7 @@
 	uint16_t tw, th;  /*  texture width */
 	uint8_t *buf;   /*  the data */
 	float xs, ys;  /*  scale data for gl-implementations which require 2^x */
+	int shmid;		/* shared memory id, is -1 if it's not attached */
 	/*  texture sizes. */
 	int32_t gl_texnum;  /*  the gl texture number. */
 };
@@ -236,6 +237,7 @@
 int shm_init(void);
 int shm_quit(void);
 int shm_main(void);
+int shm_next_key(void);
 int shm_remove(struct t_process *p);
 int shm_writen(struct buf_t *rb, uint8_t *buf, int n);
 int shm_readn(struct buf_t *rb, uint8_t *buf, int n);

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-11-21 15:30:13 UTC (rev 874)
+++ trunk/server/object.c	2007-11-25 15:59:54 UTC (rev 875)
@@ -30,13 +30,23 @@
 #define _ISOC99_SOURCE
 #endif
 #include <math.h>   /*  sin(),cos() */
+#include <errno.h>	/* errno */
+#ifdef SHM
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#endif
 
+
 #define MAXLOOP 10
 /*  if oid is always unsigned, we don't have to check oid>=0 */
 
 static void obj_update_tex(struct t_tex *tex, u_int16_t x, u_int16_t y, u_int16_t w, u_int16_t h, u_int8_t *pixbuf);
 void obj_sys_update(struct t_process *p, int32_t oid);
 
+int texture_shm_register(struct t_tex *tex, int bufsize);
+void texture_delete(struct t_tex *tex);
+
 /*  debugging function for objects, prints out some stuff known about it... */
 int obj_debug(struct t_process *p, int32_t oid)
 {
@@ -250,6 +260,54 @@
 	}
 	return(0);
 }
+
+/* register the texture, if possible */
+int texture_shm_register(struct t_tex *tex, int bufsize) 
+{
+#ifdef SHM
+	int key;
+	key = shm_next_key();
+	if ((tex->shmid = shmget(key, bufsize, 0644 | IPC_CREAT)) == -1) {
+		errnf("texture_shm_register():shmget()", errno);
+		return(-1);
+	}
+	tex->buf = shmat(tex->shmid, (void *)0, 0);
+	if ((key_t *)tex->buf == (key_t *)(-1)) {
+		errnf("shm_init():shmat()", errno);
+		shmctl(tex->shmid, IPC_RMID, NULL);
+		tex->shmid = -1;
+		return(-1);
+	}
+	return(0);
+#else
+	return(-1);
+#endif
+}
+
+/* delete the texture, eventually detach from the shm segment */
+void texture_delete(struct t_tex *tex) 
+{
+	GLuint t;
+	s3dprintf(HIGH, "texture delete: shmid = %d, buf = %010p\n",tex->shmid, tex->buf);
+#ifdef SHM
+	if (tex->shmid != -1) {
+		if (tex->buf != NULL) {
+			shmdt(tex->buf);
+			tex->buf= NULL;
+		}
+		shmctl(tex->shmid, IPC_RMID, NULL);
+		tex->shmid = -1;
+	}
+#endif
+
+	if (tex->buf != NULL) 
+		free(tex->buf);
+	if (tex->gl_texnum) {
+		t = tex->gl_texnum;
+		glDeleteTextures(1, &t);
+	}
+	
+}
 /* creates n new textures on the texture stack, of object oid, with (w,h)
  * given through *x */
 int obj_push_tex(struct t_process *p, int32_t oid, uint16_t *x, int32_t n)
@@ -258,6 +316,7 @@
 	struct t_tex *p_tex;
 	struct t_obj *obj;
 	uint16_t *px, hm;
+	int bufsize;
 	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
 			errds(MED, "obj_push_tex()", "error: no data on object allowed!");
@@ -275,6 +334,7 @@
 			obj->p_tex = p_tex;
 			for (i = 0;i < n;i++) {
 				obj->p_tex[m+i].gl_texnum = -1;
+				obj->p_tex[m+i].shmid = -1;
 				obj->p_tex[m+i].tw = *(px++);
 				obj->p_tex[m+i].th = *(px++);
 				if ((obj->p_tex[m+i].tw <= TEXTURE_MAX_W) && (obj->p_tex[m+i].th <= TEXTURE_MAX_H) &&
@@ -301,14 +361,22 @@
 						obj->p_tex[m+i].h = hm;
 						obj->p_tex[m+i].ys = (float)((double)obj->p_tex[m+i].th) / ((double)obj->p_tex[m+i].h);
 					}
-					obj->p_tex[m+i].buf = malloc(obj->p_tex[m+i].h * obj->p_tex[m+i].w * 4);
-					memset(obj->p_tex[m+i].buf, 0, obj->p_tex[m+i].h*obj->p_tex[m+i].w*4);
 					errds(LOW, "obj_push_tex()", "setting up %d %d (in mem: %d %d) texture",
 					      obj->p_tex[m+i].tw,
 					      obj->p_tex[m+i].th,
 					      obj->p_tex[m+i].w,
 					      obj->p_tex[m+i].h);
 
+					bufsize = obj->p_tex[m+i].h * obj->p_tex[m+i].w * 4;
+
+					if (texture_shm_register(&(obj->p_tex[m+i]), bufsize) == -1) {
+						obj->p_tex[m+i].buf = malloc(bufsize);
+					}
+					memset(obj->p_tex[m+i].buf, 0, bufsize);
+
+
+
+	
 				} else {
 					errds(MED, "obj_push_tex()", "bad size for texture %d (requested size: %dx%d, max %dx%d)", m + i,
 					      obj->p_tex[m+i].tw, obj->p_tex[m+i].th, TEXTURE_MAX_W, TEXTURE_MAX_H);
@@ -1009,7 +1077,6 @@
 	int32_t i;
 	struct t_tex *p_tex;
 	struct t_obj *obj;
-	GLuint t;
 	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
 			errds(MED, "obj_del_tex()", "error: can't delete textures in this object!");
@@ -1019,28 +1086,15 @@
 		s3dprintf(VLOW, "deleting %d textures of pid %d/ oid %d", n, p->id, oid);
 		m = obj->n_tex;  /*  saving the first number of textures  */
 		if (n >= m) {
-			for (i = 0;i < m;i++) {
-				if ((obj->p_tex[i].buf) != NULL)
-					free(obj->p_tex[i].buf);
-				if (obj->p_tex[i].gl_texnum) {
-					t = obj->p_tex[i].gl_texnum;
-					glDeleteTextures(1, &t);
-				}
-			}
+			for (i = 0;i < m;i++) 
+				texture_delete(&(obj->p_tex[i]));
 			if (m > 0)
 				free(obj->p_tex);
 			obj->n_tex = 0;
 			obj->p_tex = NULL;
 		} else if (n > 0) {
-			for (i = (m - n);i < m;i++) {
-				if (obj->p_tex[i].buf != NULL)
-					free(obj->p_tex[i].buf);
-				if (obj->p_tex[i].gl_texnum) {
-					t = obj->p_tex[i].gl_texnum;
-					glDeleteTextures(1, &t);
-				}
-
-			}
+			for (i = (m - n);i < m;i++) 
+				texture_delete(&(obj->p_tex[i]));
 			if (NULL != (p_tex = realloc(obj->p_tex, sizeof(struct t_tex) * (m - n)))) {
 				if (obj->dplist) {
 					s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
@@ -1967,7 +2021,6 @@
 int obj_free(struct t_process *p, int32_t oid)
 {
 	int32_t i;
-	GLuint t;
 	struct t_obj *o = p->object[oid];
 	s3dprintf(HIGH, "deleting object %d of process %d", oid, p->id);
 
@@ -1987,14 +2040,8 @@
 		if (o->n_vertex > 0) free(o->p_vertex);
 		if (o->n_poly > 0) free(o->p_poly);
 		if (o->n_mat > 0) free(o->p_mat);
-		for (i = 0;i < o->n_tex;i++) {
-			if (o->p_tex[i].buf != NULL)
-				free(o->p_tex[i].buf);
-			if (o->p_tex[i].gl_texnum) {
-				t = o->p_tex[i].gl_texnum;
-				glDeleteTextures(1, &t);
-			}
-		}
+		for (i = 0;i < o->n_tex;i++) 
+			texture_delete(&(o->p_tex[i]));
 		if (o->n_tex > 0) free(o->p_tex);
 
 	}

Modified: trunk/server/shm.c
===================================================================
--- trunk/server/shm.c	2007-11-21 15:30:13 UTC (rev 874)
+++ trunk/server/shm.c	2007-11-25 15:59:54 UTC (rev 875)
@@ -52,9 +52,10 @@
 
 static int shm_new_comblock(key_t *data);
 
-static int next_key(int oldkey)
+int shm_next_key(void)
 {
-	return(oldkey + 1);
+	mkey = mkey + 1;
+	return(mkey);
 }
 int shm_init(void)
 {
@@ -70,7 +71,8 @@
 		return(1);
 	}
 	s3dprintf(LOW, "shm_init(): init key is 0x%08x", key);
-	mkey = next_key(key);
+	mkey = key;
+
 	/* connect to (and possibly create) the segment: */
 	if ((shmid = shmget(key, SHM_SIZE, 0644 | IPC_CREAT)) == -1) {
 		errnf("shm_init():shmget()", errno);
@@ -101,10 +103,8 @@
 	struct t_shmcb *mycb;
 	comblock_init(&waiting_comblock);
 	mycb = &waiting_comblock;
-	mycb->key_stoc = mkey;
-	mkey = next_key(mkey);
-	mycb->key_ctos = mkey;
-	mkey = next_key(mkey);
+	mycb->key_stoc = shm_next_key();
+	mycb->key_ctos = shm_next_key();
 	s3dprintf(MED, "shm_open_comblock():stoc: %08x, ctos: %08x", mycb->key_stoc, mycb->key_ctos);
 	/* connect & create the client to server segment: */
 	if ((mycb->shmid_ctos = shmget(mycb->key_ctos, RB_STD_SIZE, 0644 | IPC_CREAT)) == -1) {



From dotslash at mail.berlios.de  Sun Nov 25 20:30:35 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 25 Nov 2007 20:30:35 +0100
Subject: [S3d-svn] r876 - trunk/server
Message-ID: <200711251930.lAPJUZka022258@sheep.berlios.de>

Author: dotslash
Date: 2007-11-25 20:30:35 +0100 (Sun, 25 Nov 2007)
New Revision: 876

Modified:
   trunk/server/object.c
Log:
- clean up texture size calculation


Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-11-25 15:59:54 UTC (rev 875)
+++ trunk/server/object.c	2007-11-25 19:30:35 UTC (rev 876)
@@ -342,25 +342,22 @@
 					/* find the next power of 2 that can hold the width of the texture */
 					for (hm = 1; hm < obj->p_tex[m+i].tw; hm *= 2);
 					s3dprintf(MED, "hm %d, tw %d", hm, obj->p_tex[m+i].tw);
-					if (hm == obj->p_tex[m+i].tw)  {
+					obj->p_tex[m+i].w = hm;
+					if (hm == obj->p_tex[m+i].tw)  
 						obj->p_tex[m+i].xs = 1.0;
-						obj->p_tex[m+i].w = hm;
-
-					} else {
-						obj->p_tex[m+i].w = hm;
+					 else 
 						obj->p_tex[m+i].xs = (float)((double)obj->p_tex[m+i].tw) / ((double)obj->p_tex[m+i].w);
-					}
+
 					/* find the next power of 2 that can hold the height of the texture */
 					for (hm = 1; hm < obj->p_tex[m+i].th; hm *= 2);
 					s3dprintf(MED, "hm %d, th %d", hm, obj->p_tex[m+i].th);
 
-					if (hm == obj->p_tex[m+i].th)  {
+					obj->p_tex[m+i].h = hm;
+					if (hm == obj->p_tex[m+i].th)  
 						obj->p_tex[m+i].ys = 1.0;
-						obj->p_tex[m+i].h = obj->p_tex[m+i].th;
-					} else  {
-						obj->p_tex[m+i].h = hm;
+					else  
 						obj->p_tex[m+i].ys = (float)((double)obj->p_tex[m+i].th) / ((double)obj->p_tex[m+i].h);
-					}
+
 					errds(LOW, "obj_push_tex()", "setting up %d %d (in mem: %d %d) texture",
 					      obj->p_tex[m+i].tw,
 					      obj->p_tex[m+i].th,



From dotslash at mail.berlios.de  Sun Nov 25 20:39:45 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 25 Nov 2007 20:39:45 +0100
Subject: [S3d-svn] r877 - trunk/server
Message-ID: <200711251939.lAPJdjQE022888@sheep.berlios.de>

Author: dotslash
Date: 2007-11-25 20:39:45 +0100 (Sun, 25 Nov 2007)
New Revision: 877

Modified:
   trunk/server/event.c
   trunk/server/global.h
   trunk/server/object.c
   trunk/server/proto.h
Log:
- send event when texture shm comes available
- move object-info structure into event.c


Modified: trunk/server/event.c
===================================================================
--- trunk/server/event.c	2007-11-25 19:30:35 UTC (rev 876)
+++ trunk/server/event.c	2007-11-25 19:39:45 UTC (rev 877)
@@ -112,10 +112,40 @@
 	return(0);
 }
 
+/* inform client about an available shm-segment for the texture */
+int event_texshm(struct t_process *p, int32_t oid, int32_t tex)
+{
+	struct t_obj *o;
+	struct {
+		int32_t oid, tex;
+		int16_t tw, th, w, h;
+	} __attribute__((__packed__)) shmtex_packet;
+	s3dprintf(HIGH, "informing process about new texture on oid %d, texture %d\n", oid, tex);
+	if (OBJ_VALID(p, oid, o)) {
+		shmtex_packet.oid = htonl(oid);
+		shmtex_packet.tex = htonl(tex);
+		shmtex_packet.tw = htons(o->p_tex[tex].tw);
+		shmtex_packet.th = htons(o->p_tex[tex].th);
+		shmtex_packet.w = htons(o->p_tex[tex].w);
+		shmtex_packet.h = htons(o->p_tex[tex].h);
+		prot_com_out(p, S3D_P_S_SHMTEX, (void *)&shmtex_packet, sizeof(shmtex_packet));
+	}
+	return(0);
+}
+
 /* this should replace the mcp_rep_object() function later ... */
 int event_obj_info(struct t_process *p, int32_t oid)
 {
-	struct t_obj_info mo;
+	struct {
+		int32_t object;
+		uint32_t flags;
+		float trans_x, trans_y, trans_z;
+		float rot_x, rot_y, rot_z;
+		float scale;
+		float r;
+		char name[S3D_NAME_MAX];
+	} __attribute__((__packed__)) mo;
+
 	struct t_process *ap;
 	struct t_obj *o;
 	if (OBJ_VALID(p, oid, o)) {
@@ -147,7 +177,7 @@
 			break;
 
 		}
-		prot_com_out(p, S3D_P_S_OINFO, (uint8_t *)&mo, sizeof(struct t_obj_info));
+		prot_com_out(p, S3D_P_S_OINFO, (uint8_t *)&mo, sizeof(mo));
 	}
 	return(0);
 }

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2007-11-25 19:30:35 UTC (rev 876)
+++ trunk/server/global.h	2007-11-25 19:39:45 UTC (rev 877)
@@ -191,15 +191,6 @@
 #endif
 };
 
-struct t_obj_info {
-	int32_t object;
-	uint32_t flags;
-	float trans_x, trans_y, trans_z;
-	float rot_x, rot_y, rot_z;
-	float scale;
-	float r;
-	char name[S3D_NAME_MAX];
-};
 enum {
 	zero,
 	FRAME_SDL
@@ -255,6 +246,7 @@
 int event_obj_click(struct t_process *p, int32_t oid);
 int event_key_pressed(uint16_t key, uint16_t uni, uint16_t mod, int state);
 int event_mbutton_clicked(uint8_t button, uint8_t state);
+int event_texshm(struct t_process *p, int32_t oid, int32_t tex);
 int event_cam_changed(void);
 int event_ptr_changed(void);
 int event_init(struct t_process *p);

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-11-25 19:30:35 UTC (rev 876)
+++ trunk/server/object.c	2007-11-25 19:39:45 UTC (rev 877)
@@ -366,9 +366,11 @@
 
 					bufsize = obj->p_tex[m+i].h * obj->p_tex[m+i].w * 4;
 
-					if (texture_shm_register(&(obj->p_tex[m+i]), bufsize) == -1) {
+					if (texture_shm_register(&(obj->p_tex[m+i]), bufsize) == 0) 
+						event_texshm(p, oid, m+i);
+					else
 						obj->p_tex[m+i].buf = malloc(bufsize);
-					}
+					
 					memset(obj->p_tex[m+i].buf, 0, bufsize);
 
 

Modified: trunk/server/proto.h
===================================================================
--- trunk/server/proto.h	2007-11-25 19:30:35 UTC (rev 876)
+++ trunk/server/proto.h	2007-11-25 19:39:45 UTC (rev 877)
@@ -171,7 +171,12 @@
 /*  2b: state */
 #define S3D_P_S_MBUTTON 5
 /*  1b: button number */
-/*  2b: butotn state */
+/*  2b: button state */
+#define S3D_P_S_SHMTEX	6
+/*  4b: object id */
+/*  4b: texture number */
+/*  4b: shmid */
+/*  4*2b: width, height, bufwidth, bufheight */
 #define S3D_P_S_NEWOBJ 16
 /*  4b: oid */
 



From dotslash at mail.berlios.de  Sun Nov 25 20:55:48 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 25 Nov 2007 20:55:48 +0100
Subject: [S3d-svn] r878 - in trunk: example libs3d server
Message-ID: <200711251955.lAPJtmrf025228@sheep.berlios.de>

Author: dotslash
Date: 2007-11-25 20:55:47 +0100 (Sun, 25 Nov 2007)
New Revision: 878

Modified:
   trunk/example/texturetest.c
   trunk/libs3d/proto_in.c
   trunk/libs3d/s3dlib.h
   trunk/server/event.c
Log:
- prepare event handling in the client
- send shmid with the event
- change texturetest to non-power-of-2 size, to show mipmap problem


Modified: trunk/example/texturetest.c
===================================================================
--- trunk/example/texturetest.c	2007-11-25 19:39:45 UTC (rev 877)
+++ trunk/example/texturetest.c	2007-11-25 19:55:47 UTC (rev 878)
@@ -37,8 +37,8 @@
 	s3d_rotate(oid, 0, i, 0);
 	nanosleep(&t, NULL);
 }
-#define MAXX 32
-#define MAXY 32
+#define MAXX 24
+#define MAXY 24
 int main(int argc, char **argv)
 {
 	unsigned int x, y;

Modified: trunk/libs3d/proto_in.c
===================================================================
--- trunk/libs3d/proto_in.c	2007-11-25 19:39:45 UTC (rev 877)
+++ trunk/libs3d/proto_in.c	2007-11-25 19:55:47 UTC (rev 878)
@@ -35,6 +35,7 @@
 	struct s3d_evt *s3devt = NULL;
 	struct mcp_object *mo;
 	struct s3d_obj_info *oi;
+	struct s3d_texshm *tshm;
 	switch (opcode) {
 	case S3D_P_S_INIT:
 		s3dprintf(MED, "S3D_P_S_INIT: init!!");
@@ -138,7 +139,27 @@
 			}
 		} else s3dprintf(MED, "wrong length for S3D_P_S_OINFO length %d != %d", length, sizeof(struct s3d_obj_info));
 		break;
+	case S3D_P_S_SHMTEX:
+		if (length == sizeof(struct s3d_texshm)) {
+			tshm = (struct s3d_texshm *)buf;
 
+			/* this is only handled internally ... */
+			tshm->oid = ntohl(tshm->oid);
+			tshm->tex = ntohl(tshm->tex);
+			tshm->shmid = ntohl(tshm->shmid);
+			tshm->tw = ntohs(tshm->tw);
+			tshm->th = ntohs(tshm->th);
+			tshm->w = ntohs(tshm->w);
+			tshm->h = ntohs(tshm->h);
+
+			s3dprintf(MED, "S3D_P_S_SHMTEX: texture %d of object %d is available under shmid %d",
+						tshm->tex, tshm->oid, tshm->shmid);
+
+		} else 
+			s3dprintf(MED, "wrong length for S3D_P_S_SHMTEX length %d != %d", length, sizeof(struct s3d_texshm));
+		break;
+
+
 	case S3D_P_MCP_DEL_OBJECT:
 		if (length == 4) {
 			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {

Modified: trunk/libs3d/s3dlib.h
===================================================================
--- trunk/libs3d/s3dlib.h	2007-11-25 19:39:45 UTC (rev 877)
+++ trunk/libs3d/s3dlib.h	2007-11-25 19:55:47 UTC (rev 878)
@@ -114,6 +114,11 @@
 #ifdef SIGS
 extern int _s3d_sigio;
 #endif
+/* proto_in.c */
+struct s3d_texshm {
+	int32_t oid, tex, shmid;
+	uint16_t tw, th, w, h;
+} __attribute__((__packed__));
 /*  network.c */
 extern int con_type;
 int net_send(uint8_t opcode, char *buf, uint16_t length);

Modified: trunk/server/event.c
===================================================================
--- trunk/server/event.c	2007-11-25 19:39:45 UTC (rev 877)
+++ trunk/server/event.c	2007-11-25 19:55:47 UTC (rev 878)
@@ -117,13 +117,15 @@
 {
 	struct t_obj *o;
 	struct {
-		int32_t oid, tex;
-		int16_t tw, th, w, h;
+		int32_t oid, tex, shmid;
+		uint16_t tw, th, w, h;
 	} __attribute__((__packed__)) shmtex_packet;
-	s3dprintf(HIGH, "informing process about new texture on oid %d, texture %d\n", oid, tex);
 	if (OBJ_VALID(p, oid, o)) {
+		s3dprintf(LOW, "informing process about new texture on oid %d, texture %d, which is available under id %d\n", 
+						oid, tex, o->p_tex[tex].shmid);
 		shmtex_packet.oid = htonl(oid);
 		shmtex_packet.tex = htonl(tex);
+		shmtex_packet.shmid = htonl(o->p_tex[tex].shmid);
 		shmtex_packet.tw = htons(o->p_tex[tex].tw);
 		shmtex_packet.th = htons(o->p_tex[tex].th);
 		shmtex_packet.w = htons(o->p_tex[tex].w);



From dotslash at mail.berlios.de  Sun Nov 25 21:04:45 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 25 Nov 2007 21:04:45 +0100
Subject: [S3d-svn] r879 - trunk/libs3d
Message-ID: <200711252004.lAPK4jXb025711@sheep.berlios.de>

Author: dotslash
Date: 2007-11-25 21:04:45 +0100 (Sun, 25 Nov 2007)
New Revision: 879

Added:
   trunk/libs3d/hash.c
   trunk/libs3d/hash.h
Modified:
   trunk/libs3d/CMakeLists.txt
Log:
- add our hash implementation from batman


Modified: trunk/libs3d/CMakeLists.txt
===================================================================
--- trunk/libs3d/CMakeLists.txt	2007-11-25 19:55:47 UTC (rev 878)
+++ trunk/libs3d/CMakeLists.txt	2007-11-25 20:04:45 UTC (rev 879)
@@ -3,7 +3,7 @@
 add_library(s3d SHARED callback.c error.c event.c fontselect.c freetype.c
 	io.c modelread.c network.c object_queue.c proto_in.c proto_out.c
 	sei_construct.c sei_misc.c sei_monotone.c sei_tri.c shm.c
-	shm_ringbuf.c tcp.c vector.c)
+	shm_ringbuf.c tcp.c vector.c hash.c)
 target_link_libraries(s3d ${G3D_LIBRARIES} ${FONTCONFIG_LIBRARIES})
 
 # install

Added: trunk/libs3d/hash.c
===================================================================
--- trunk/libs3d/hash.c	2007-11-25 19:55:47 UTC (rev 878)
+++ trunk/libs3d/hash.c	2007-11-25 20:04:45 UTC (rev 879)
@@ -0,0 +1,316 @@
+/*
+ * hash.h
+ *
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
+ * 						   Marek Lindner
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <stdio.h>		/* NULL */
+#include <stdlib.h>		/* malloc(), free() */
+#include "hash.h"
+
+
+/* clears the hash */
+void _s3d_hash_init(struct hashtable_t *hash) {
+	int i;
+	hash->elements=0;
+	for (i=0 ; i<hash->size ; i++) {
+		hash->table[i] = NULL;
+	}
+}
+
+
+/* remove the hash structure. if hashdata_free_cb != NULL,
+ * this function will be called to remove the elements inside of the hash.
+ * if you don't remove the elements, memory might be leaked. */
+void _s3d_hash_delete(struct hashtable_t *hash, hashdata_free_cb free_cb) {
+	struct element_t *bucket, *last_bucket;
+	int i;
+
+	for (i=0; i<hash->size; i++) {
+
+		bucket= hash->table[i];
+		while (bucket != NULL) {
+
+			if (free_cb!=NULL)
+				free_cb( bucket->data );
+
+			last_bucket= bucket;
+			bucket= bucket->next;
+			free(last_bucket);
+
+		}
+
+	}
+	_s3d_hash_destroy(hash);
+}
+
+
+
+/* free only the hashtable and the hash itself. */
+void _s3d_hash_destroy(struct hashtable_t *hash) {
+
+	free( hash->table);
+	free( hash);
+
+}
+
+
+
+
+/* iterate though the hash. first element is selected with iter_in NULL.
+ * use the returned iterator to access the elements until hash_it_t returns NULL. */
+struct hash_it_t *_s3d_hash_iterate(struct hashtable_t *hash, struct hash_it_t *iter_in) {
+	struct hash_it_t *iter;
+
+	if (iter_in == NULL) {
+		iter= malloc(sizeof(struct hash_it_t));
+		iter->index =  -1;
+		iter->bucket = NULL;
+		iter->prev_bucket = NULL;
+	} else
+		iter= iter_in;
+
+	/* sanity checks first (if our bucket got deleted in the last iteration): */
+	if (iter->bucket!=NULL) {
+		if (iter->first_bucket != NULL) {
+
+			/* we're on the first element and it got removed after the last iteration. */
+			if ((*iter->first_bucket) != iter->bucket) {
+
+				/* there are still other elements in the list */
+				if ( (*iter->first_bucket) != NULL ) {
+					iter->prev_bucket = NULL;
+					iter->bucket= (*iter->first_bucket);
+					iter->first_bucket = &hash->table[ iter->index ];
+					return(iter);
+				} else {
+					iter->bucket = NULL;
+				}
+
+			}
+
+		} else if ( iter->prev_bucket != NULL ) {
+
+			/* we're not on the first element, and the bucket got removed after the last iteration.
+			* the last bucket's next pointer is not pointing to our actual bucket anymore.
+			* select the next. */
+			if ( iter->prev_bucket->next != iter->bucket )
+				iter->bucket= iter->prev_bucket;
+
+		}
+
+	}
+
+	/* now as we are sane, select the next one if there is some */
+	if (iter->bucket!=NULL) {
+		if (iter->bucket->next!=NULL) {
+			iter->prev_bucket= iter->bucket;
+			iter->bucket= iter->bucket->next;
+			iter->first_bucket = NULL;
+			return(iter);
+		}
+	}
+	/* if not returned yet, we've reached the last one on the index and have to search forward */
+
+	iter->index++;
+	while ( iter->index < hash->size ) {		/* go through the entries of the hash table */
+		if ((hash->table[ iter->index ]) != NULL){
+			iter->prev_bucket = NULL;
+			iter->bucket = hash->table[ iter->index ];
+			iter->first_bucket = &hash->table[ iter->index ];
+			return(iter);						/* if this table entry is not null, return it */
+		} else
+			iter->index++;						/* else, go to the next */
+	}
+	/* nothing to iterate over anymore */
+	free(iter);
+	return(NULL);
+}
+
+
+/* allocates and clears the hash */
+struct hashtable_t *_s3d_hash_new(int size, hashdata_compare_cb compare, hashdata_choose_cb choose) {
+	struct hashtable_t *hash;
+
+	hash= malloc( sizeof(struct hashtable_t));
+	if ( hash == NULL ) 			/* could not allocate the hash control structure */
+		return (NULL);
+
+	hash->size= size;
+	hash->table= malloc( sizeof(struct element_t *) * size);
+	if ( hash->table == NULL ) {	/* could not allocate the table */
+		free(hash);
+		return(NULL);
+	}
+	_s3d_hash_init(hash);
+	hash->compare= compare;
+	hash->choose= choose;
+	return(hash);
+}
+
+
+/* adds data to the hashtable. returns 0 on success, -1 on error */
+int _s3d_hash_add(struct hashtable_t *hash, void *data) {
+	int index;
+	struct element_t *bucket, *prev_bucket = NULL;
+
+	index = hash->choose( data, hash->size );
+	bucket = hash->table[index];
+
+	while ( bucket!=NULL ) {
+		if (0 == hash->compare( bucket->data, data ))
+			return(-1);
+
+		prev_bucket = bucket;
+		bucket= bucket->next;
+	}
+
+	/* found the tail of the list, add new element */
+	if (NULL == (bucket= malloc(sizeof(struct element_t))))
+		return(-1); /* malloc failed */
+
+	bucket->data= data;				/* init the new bucket */
+	bucket->next= NULL;
+
+	/* and link it */
+	if ( prev_bucket == NULL ) {
+		hash->table[index] = bucket;
+	} else {
+		prev_bucket->next = bucket;
+	}
+
+	hash->elements++;
+	return(0);
+
+}
+/* finds data, based on the key in keydata. returns the found data on success, or NULL on error */
+void *_s3d_hash_find(struct hashtable_t *hash, void *keydata) {
+	int index;
+	struct element_t *bucket;
+
+	index = hash->choose( keydata , hash->size );
+	bucket = hash->table[index];
+
+	while ( bucket!=NULL ) {
+		if (0 == hash->compare( bucket->data, keydata ))
+			return( bucket->data );
+
+		bucket= bucket->next;
+	}
+
+	return(NULL);
+
+}
+
+/* remove bucket (this might be used in hash_iterate() if you already found the bucket
+ * you want to delete and don't need the overhead to find it again with hash_remove().
+ * But usually, you don't want to use this function, as it fiddles with hash-internals. */
+void *_s3d_hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t) {
+	void *data_save;
+
+	data_save = hash_it_t->bucket->data;	/* save the pointer to the data */
+
+	if ( hash_it_t->prev_bucket != NULL ) {
+		hash_it_t->prev_bucket->next = hash_it_t->bucket->next;
+	} else if ( hash_it_t->first_bucket != NULL ) {
+		(*hash_it_t->first_bucket) = hash_it_t->bucket->next;
+	}
+
+	free(hash_it_t->bucket);
+
+	hash->elements--;
+	return( data_save );
+
+}
+
+
+/* removes data from hash, if found. returns pointer do data on success,
+ * so you can remove the used structure yourself, or NULL on error .
+ * data could be the structure you use with just the key filled,
+ * we just need the key for comparing. */
+void *_s3d_hash_remove(struct hashtable_t *hash, void *data) {
+	struct hash_it_t hash_it_t;
+
+	hash_it_t.index = hash->choose( data, hash->size );
+	hash_it_t.bucket = hash->table[hash_it_t.index];
+	hash_it_t.prev_bucket = NULL;
+
+	while ( hash_it_t.bucket!=NULL ) {
+		if (0 == hash->compare( hash_it_t.bucket->data, data )) {
+			hash_it_t.first_bucket = (hash_it_t.bucket == hash->table[hash_it_t.index] ? &hash->table[ hash_it_t.index ] : NULL);
+			return( _s3d_hash_remove_bucket(hash, &hash_it_t) );
+		}
+
+		hash_it_t.prev_bucket = hash_it_t.bucket;
+		hash_it_t.bucket= hash_it_t.bucket->next;
+	}
+
+	return(NULL);
+
+}
+
+
+/* resize the hash, returns the pointer to the new hash or NULL on error. removes the old hash on success. */
+struct hashtable_t *_s3d_hash_resize(struct hashtable_t *hash, int size) {
+	struct hashtable_t *new_hash;
+	struct element_t *bucket;
+	int i;
+
+	/* initialize a new hash with the new size */
+	if (NULL == (new_hash= _s3d_hash_new(size, hash->compare, hash->choose)))
+		return(NULL);
+
+	/* copy the elements */
+	for (i=0; i<hash->size; i++) {
+		bucket= hash->table[i];
+		while (bucket != NULL) {
+			_s3d_hash_add( new_hash, bucket->data );
+			bucket= bucket->next;
+		}
+	}
+	_s3d_hash_delete(hash, NULL);	/* remove hash and eventual overflow buckets but not the content itself. */
+
+	return( new_hash);
+
+}
+
+
+/* print the hash table for debugging */
+void _s3d_hash_debug(struct hashtable_t *hash) {
+	int i;
+	struct element_t *bucket;
+
+	for (i=0; i<hash->size;i++) {
+		printf("[%d] ",i);
+		bucket= hash->table[i];
+
+		while (bucket != NULL) {
+			printf("-> [%10p] ", (void *)bucket);
+			bucket= bucket->next;
+		}
+
+		printf("\n");
+
+	}
+	printf("\n");
+}
+

Added: trunk/libs3d/hash.h
===================================================================
--- trunk/libs3d/hash.h	2007-11-25 19:55:47 UTC (rev 878)
+++ trunk/libs3d/hash.h	2007-11-25 20:04:45 UTC (rev 879)
@@ -0,0 +1,99 @@
+/*
+ * hash.h
+ *
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
+ * 						   Marek Lindner
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _S3D_HASH_H
+#define _S3D_HASH_H
+
+
+
+typedef int (*hashdata_compare_cb)(void *, void *);
+typedef int (*hashdata_choose_cb)(void *, int);
+typedef void (*hashdata_free_cb)(void *);
+
+struct element_t {
+	void *data;						/* pointer to the data */
+	struct element_t *next;			/* overflow bucket pointer */
+};
+
+struct hash_it_t {
+	int index;
+	struct element_t *bucket;
+	struct element_t *prev_bucket;
+	struct element_t **first_bucket;
+};
+
+struct hashtable_t {
+	struct element_t **table;					/* the hashtable itself, with the buckets */
+	int elements;								/* number of elements registered */
+	int size;									/* size of hashtable */
+	hashdata_compare_cb compare;			    /* callback to a compare function.
+												 * should compare 2 element datas for their keys,
+												 * return 0 if same and not 0 if not same */
+	hashdata_choose_cb choose;					/* the hashfunction, should return an index based
+												 * on the key in the data of the first argument
+												 * and the size the second */
+};
+
+/* clears the hash */
+void 				 _s3d_hash_init(struct hashtable_t *hash);
+
+/* allocates and clears the hash */
+struct hashtable_t	*_s3d_hash_new(int size, hashdata_compare_cb compare, hashdata_choose_cb choose);
+
+/* remove bucket (this might be used in hash_iterate() if you already found the bucket
+ * you want to delete and don't need the overhead to find it again with hash_remove().
+ * But usually, you don't want to use this function, as it fiddles with hash-internals. */
+void 				*_s3d_hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t);
+
+/* remove the hash structure. if hashdata_free_cb != NULL,
+ * this function will be called to remove the elements inside of the hash.
+ * if you don't remove the elements, memory might be leaked. */
+void 				 _s3d_hash_delete(struct hashtable_t *hash, hashdata_free_cb free_cb);
+
+/* free only the hashtable and the hash itself. */
+void 				 _s3d_hash_destroy(struct hashtable_t *hash);
+
+/* adds data to the hashtable. returns 0 on success, -1 on error */
+int 				 _s3d_hash_add(struct hashtable_t *hash, void *data);
+
+/* removes data from hash, if found. returns pointer do data on success,
+ * so you can remove the used structure yourself, or NULL on error .
+ * data could be the structure you use with just the key filled,
+ * we just need the key for comparing. */
+void 				*_s3d_hash_remove(struct hashtable_t *hash, void *data);
+
+/* finds data, based on the key in keydata. returns the found data on success, or NULL on error */
+void 				*_s3d_hash_find(struct hashtable_t *hash, void *keydata);
+
+/* resize the hash, returns the pointer to the new hash or NULL on error. removes the old hash on success */
+struct hashtable_t	*_s3d_hash_resize(struct hashtable_t *hash, int size);
+
+/* print the hash table for debugging */
+void 				 _s3d_hash_debug( struct hashtable_t *hash);
+
+/* iterate though the hash. first element is selected with iter_in NULL.
+ * use the returned iterator to access the elements until hash_it_t returns NULL. */
+struct hash_it_t 	*_s3d_hash_iterate(struct hashtable_t *hash, struct hash_it_t *iter_in);
+
+#endif



From dotslash at mail.berlios.de  Sun Nov 25 21:08:36 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 25 Nov 2007 21:08:36 +0100
Subject: [S3d-svn] r880 - trunk/libs3d
Message-ID: <200711252008.lAPK8aPK026213@sheep.berlios.de>

Author: dotslash
Date: 2007-11-25 21:08:35 +0100 (Sun, 25 Nov 2007)
New Revision: 880

Modified:
   trunk/libs3d/callback.c
   trunk/libs3d/config.h
   trunk/libs3d/error.c
   trunk/libs3d/event.c
   trunk/libs3d/fontselect.c
   trunk/libs3d/freetype.c
   trunk/libs3d/io.c
   trunk/libs3d/modelread.c
   trunk/libs3d/network.c
   trunk/libs3d/object_queue.c
   trunk/libs3d/proto_in.c
   trunk/libs3d/proto_out.c
   trunk/libs3d/s3d.h
   trunk/libs3d/s3d_keysym.h
   trunk/libs3d/s3dlib.h
   trunk/libs3d/sei_construct.c
   trunk/libs3d/sei_interface.h
   trunk/libs3d/sei_misc.c
   trunk/libs3d/sei_monotone.c
   trunk/libs3d/sei_tri.c
   trunk/libs3d/sei_triangulate.h
   trunk/libs3d/shm.c
   trunk/libs3d/shm_ringbuf.c
   trunk/libs3d/tcp.c
   trunk/libs3d/vector.c
Log:
- update copyright dates


Modified: trunk/libs3d/callback.c
===================================================================
--- trunk/libs3d/callback.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/callback.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * callback.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/config.h
===================================================================
--- trunk/libs3d/config.h	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/config.h	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * config.h
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/error.c
===================================================================
--- trunk/libs3d/error.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/error.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * error.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/event.c
===================================================================
--- trunk/libs3d/event.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/event.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * event.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/fontselect.c
===================================================================
--- trunk/libs3d/fontselect.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/fontselect.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * fontselect.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/freetype.c
===================================================================
--- trunk/libs3d/freetype.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/freetype.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * freetype.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/io.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * io.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/modelread.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * modelread.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/network.c
===================================================================
--- trunk/libs3d/network.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/network.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * network.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/object_queue.c
===================================================================
--- trunk/libs3d/object_queue.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/object_queue.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * object_queue.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/proto_in.c
===================================================================
--- trunk/libs3d/proto_in.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/proto_in.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * proto_in.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/proto_out.c
===================================================================
--- trunk/libs3d/proto_out.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/proto_out.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * proto_out.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/s3d.h	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * s3d.h
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/s3d_keysym.h
===================================================================
--- trunk/libs3d/s3d_keysym.h	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/s3d_keysym.h	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * s3d_keysym.h
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  * Copyright (C) 1997-2004 Sam Lantinga <slouken at libsdl.org>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).

Modified: trunk/libs3d/s3dlib.h
===================================================================
--- trunk/libs3d/s3dlib.h	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/s3dlib.h	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * s3dlib.h
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/sei_construct.c
===================================================================
--- trunk/libs3d/sei_construct.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/sei_construct.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * sei_construct.c
  *
- * Copyright (C) 2006 Simon Wunderlich
+ * Copyright (C) 2006-2007 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
  * for public domain:
  * <snip>

Modified: trunk/libs3d/sei_interface.h
===================================================================
--- trunk/libs3d/sei_interface.h	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/sei_interface.h	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * sei_interface.h
  *
- * Copyright (C) 2006 Simon Wunderlich
+ * Copyright (C) 2006-2007 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
  * for public domain:
  * <snip>

Modified: trunk/libs3d/sei_misc.c
===================================================================
--- trunk/libs3d/sei_misc.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/sei_misc.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * sei_misc.c
  *
- * Copyright (C) 2006 Simon Wunderlich
+ * Copyright (C) 2006-2007 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
  * for public domain:
  * <snip>

Modified: trunk/libs3d/sei_monotone.c
===================================================================
--- trunk/libs3d/sei_monotone.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/sei_monotone.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * sei_monotone.c
  *
- * Copyright (C) 2006 Simon Wunderlich
+ * Copyright (C) 2006-2007 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
  * for public domain:
  * <snip>

Modified: trunk/libs3d/sei_tri.c
===================================================================
--- trunk/libs3d/sei_tri.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/sei_tri.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * sei_tri.c
  *
- * Copyright (C) 2006 Simon Wunderlich
+ * Copyright (C) 2006-2007 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
  * for public domain:
  * <snip>

Modified: trunk/libs3d/sei_triangulate.h
===================================================================
--- trunk/libs3d/sei_triangulate.h	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/sei_triangulate.h	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * sei_triangulate.h
  *
- * Copyright (C) 2006 Simon Wunderlich
+ * Copyright (C) 2006-2007 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
  * for public domain:
  * <snip>

Modified: trunk/libs3d/shm.c
===================================================================
--- trunk/libs3d/shm.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/shm.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * shm.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/shm_ringbuf.c
===================================================================
--- trunk/libs3d/shm_ringbuf.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/shm_ringbuf.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * shm_ringbuf.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/tcp.c
===================================================================
--- trunk/libs3d/tcp.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/tcp.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * tcp.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/libs3d/vector.c
===================================================================
--- trunk/libs3d/vector.c	2007-11-25 20:04:45 UTC (rev 879)
+++ trunk/libs3d/vector.c	2007-11-25 20:08:35 UTC (rev 880)
@@ -1,7 +1,7 @@
 /*
  * vector.c
  *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2004-2007 Simon Wunderlich <dotslash at packetmixer.de>
  *                         Marek Lindner <lindner_marek at yahoo.de>
  *                         Andreas Langer <andreas_lbg at gmx.de>
  *



From dotslash at mail.berlios.de  Sun Nov 25 21:43:21 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 25 Nov 2007 21:43:21 +0100
Subject: [S3d-svn] r881 - trunk/server
Message-ID: <200711252043.lAPKhLWa031713@sheep.berlios.de>

Author: dotslash
Date: 2007-11-25 21:43:20 +0100 (Sun, 25 Nov 2007)
New Revision: 881

Modified:
   trunk/server/object.c
Log:
- shm-errors are not fatal in texture_shm_register()


Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-11-25 20:08:35 UTC (rev 880)
+++ trunk/server/object.c	2007-11-25 20:43:20 UTC (rev 881)
@@ -268,12 +268,12 @@
 	int key;
 	key = shm_next_key();
 	if ((tex->shmid = shmget(key, bufsize, 0644 | IPC_CREAT)) == -1) {
-		errnf("texture_shm_register():shmget()", errno);
+		errn("texture_shm_register():shmget()", errno);
 		return(-1);
 	}
 	tex->buf = shmat(tex->shmid, (void *)0, 0);
 	if ((key_t *)tex->buf == (key_t *)(-1)) {
-		errnf("shm_init():shmat()", errno);
+		errn("shm_init():shmat()", errno);
 		shmctl(tex->shmid, IPC_RMID, NULL);
 		tex->shmid = -1;
 		return(-1);



From dotslash at mail.berlios.de  Sun Nov 25 22:16:03 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 25 Nov 2007 22:16:03 +0100
Subject: [S3d-svn] r882 - trunk/server
Message-ID: <200711252116.lAPLG3Ji000849@sheep.berlios.de>

Author: dotslash
Date: 2007-11-25 22:16:02 +0100 (Sun, 25 Nov 2007)
New Revision: 882

Modified:
   trunk/server/global.h
   trunk/server/object.c
   trunk/server/proto.c
   trunk/server/proto.h
Log:
- add UPDATE call and let obj_update_tex() handle it


Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2007-11-25 20:43:20 UTC (rev 881)
+++ trunk/server/global.h	2007-11-25 21:16:02 UTC (rev 882)
@@ -341,6 +341,7 @@
 int obj_load_poly_texc(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
 int obj_load_mat(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
 int obj_load_tex(struct t_process *p, int32_t oid, int32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf);
+int obj_update_tex(struct t_process *p, int32_t oid, int32_t tid, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf);
 int obj_del_vertex(struct t_process *p, int32_t oid, int32_t n);
 int obj_del_mat(struct t_process *p, int32_t oid, int32_t n);
 int obj_del_poly(struct t_process *p, int32_t oid, int32_t n);

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-11-25 20:43:20 UTC (rev 881)
+++ trunk/server/object.c	2007-11-25 21:16:02 UTC (rev 882)
@@ -41,7 +41,6 @@
 #define MAXLOOP 10
 /*  if oid is always unsigned, we don't have to check oid>=0 */
 
-static void obj_update_tex(struct t_tex *tex, u_int16_t x, u_int16_t y, u_int16_t w, u_int16_t h, u_int8_t *pixbuf);
 void obj_sys_update(struct t_process *p, int32_t oid);
 
 int texture_shm_register(struct t_tex *tex, int bufsize);
@@ -840,10 +839,24 @@
 		return(-1);
 	return(0);
 }
-/* the interal texture updating function ... this is for opengl*/
-static void obj_update_tex(struct t_tex *tex, u_int16_t S3DUNUSED(x), u_int16_t S3DUNUSED(y), u_int16_t S3DUNUSED(w), u_int16_t S3DUNUSED(h), u_int8_t *S3DUNUSED(pixbuf))
+/* notify graphic system that the texture is updated */
+int obj_update_tex(struct t_process *p, int32_t oid, int32_t tid,uint16_t S3DUNUSED(x), uint16_t S3DUNUSED(y), uint16_t S3DUNUSED(w), uint16_t S3DUNUSED(h), uint8_t *S3DUNUSED(pixbuf))
 {
 	GLuint t;
+	struct t_obj *obj;
+	struct t_tex *tex;
+
+	if (OBJ_VALID(p, oid, obj)) {
+		if (obj->oflags&OF_NODATA) {
+			errds(MED, "obj_load_tex()", "error: no data on object allowed!");
+			return(-1);
+		}
+		if ((tid < 0) || (tid >= obj->n_tex)) 
+			return(-1);
+	} else
+		return(-1);
+	tex = &obj->p_tex[tid];
+
 	if ((tex->gl_texnum) != -1) {
 		t = tex->gl_texnum;
 		/* s3dprintf(MED,"updating texture %d at [%d %d] with a [%d %d] pixbuf",t,x,y,w,h); */
@@ -852,6 +865,7 @@
 		glDeleteTextures(1, &t);
 		tex->gl_texnum = -1;
 	}
+	return(0);
 }
 /*  loads some data into the pixbuf */
 int obj_load_tex(struct t_process *p, int32_t oid, int32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf)
@@ -901,7 +915,7 @@
 					       4*p2);
 				}
 				s3dprintf(MED, "updating texture %d\n", t->gl_texnum);
-				obj_update_tex(t, x, y, w, h, pixbuf);
+				obj_update_tex(p, oid, tex, x, y, w, h, pixbuf);
 				return(0);
 			} else {
 				errds(HIGH, "obj_load_tex()", "no buffer to draw to in oid %d, texture %d", oid, tex);

Modified: trunk/server/proto.c
===================================================================
--- trunk/server/proto.c	2007-11-25 20:43:20 UTC (rev 881)
+++ trunk/server/proto.c	2007-11-25 21:16:02 UTC (rev 882)
@@ -282,7 +282,7 @@
 		}
 		break;
 	case S3D_P_C_LOAD_TEX:
-		if (length > 8) {
+		if (length > 16) {
 			oid = ntohl(*((uint32_t *)cptr));
 			cptr += 4;
 			toid = ntohl(*((uint32_t *)cptr));
@@ -296,11 +296,30 @@
 			h = ntohs(*((uint16_t *)cptr));
 			cptr += 2;
 			num = length - 16;
-			s3dprintf(MED, "LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)", length, oid, toid, w, h, x, y, num, w*h*4, num);
+			s3dprintf(MED, "LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)", length, oid, toid, w, h, x, y, num, w*h*4);
 			if ((w*h*4) == num)  /*  check correct size */
 				obj_load_tex(p, oid, toid, x, y, w, h, cptr);
 		}
 		break;
+	case S3D_P_C_UPDATE_TEX:
+		if (length == 16) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			x = ntohs(*((uint16_t *)cptr));
+			cptr += 2;
+			y = ntohs(*((uint16_t *)cptr));
+			cptr += 2;
+			w = ntohs(*((uint16_t *)cptr));
+			cptr += 2;
+			h = ntohs(*((uint16_t *)cptr));
+			cptr += 2;
+			s3dprintf(MED, "UPDATE_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] ", length, oid, toid, w, h, x, y);
+			obj_update_tex(p, oid, toid, x, y, w, h, NULL);
+		}
+		break;
+
 	case S3D_P_C_DEL_VERTEX:
 		if (length == 8) {
 			oid = ntohl(*((uint32_t *)cptr));

Modified: trunk/server/proto.h
===================================================================
--- trunk/server/proto.h	2007-11-25 20:43:20 UTC (rev 881)
+++ trunk/server/proto.h	2007-11-25 21:16:02 UTC (rev 882)
@@ -116,6 +116,10 @@
 /*  4b:  object id */
 /*  4b:  position */
 /*  3*4f: material elements [amb,spec,diff with r,g,b,a] */
+#define S3D_P_C_UPDATE_TEX  29
+/*  4b:    object id */
+/*  4b:    texture id */
+/*  4*2b: xpos,ypos,width,height */
 #define S3D_P_C_LOAD_TEX  28
 /*  4b:  object id */
 /*  4b:  texture number */



From dotslash at mail.berlios.de  Sun Nov 25 22:17:13 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 25 Nov 2007 22:17:13 +0100
Subject: [S3d-svn] r883 - trunk/libs3d
Message-ID: <200711252117.lAPLHDNM000914@sheep.berlios.de>

Author: dotslash
Date: 2007-11-25 22:17:12 +0100 (Sun, 25 Nov 2007)
New Revision: 883

Added:
   trunk/libs3d/texture.c
Modified:
   trunk/libs3d/CMakeLists.txt
   trunk/libs3d/hash.c
   trunk/libs3d/io.c
   trunk/libs3d/proto_in.c
   trunk/libs3d/proto_out.c
   trunk/libs3d/s3dlib.h
   trunk/libs3d/tcp.c
Log:
- add texture.c to handle object-texture hash


Modified: trunk/libs3d/CMakeLists.txt
===================================================================
--- trunk/libs3d/CMakeLists.txt	2007-11-25 21:16:02 UTC (rev 882)
+++ trunk/libs3d/CMakeLists.txt	2007-11-25 21:17:12 UTC (rev 883)
@@ -3,7 +3,7 @@
 add_library(s3d SHARED callback.c error.c event.c fontselect.c freetype.c
 	io.c modelread.c network.c object_queue.c proto_in.c proto_out.c
 	sei_construct.c sei_misc.c sei_monotone.c sei_tri.c shm.c
-	shm_ringbuf.c tcp.c vector.c hash.c)
+	shm_ringbuf.c tcp.c vector.c hash.c texture.c)
 target_link_libraries(s3d ${G3D_LIBRARIES} ${FONTCONFIG_LIBRARIES})
 
 # install

Modified: trunk/libs3d/hash.c
===================================================================
--- trunk/libs3d/hash.c	2007-11-25 21:16:02 UTC (rev 882)
+++ trunk/libs3d/hash.c	2007-11-25 21:17:12 UTC (rev 883)
@@ -290,7 +290,6 @@
 	_s3d_hash_delete(hash, NULL);	/* remove hash and eventual overflow buckets but not the content itself. */
 
 	return( new_hash);
-
 }
 
 

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2007-11-25 21:16:02 UTC (rev 882)
+++ trunk/libs3d/io.c	2007-11-25 21:17:12 UTC (rev 883)
@@ -149,6 +149,7 @@
 	net_send(S3D_P_C_INIT, buf, strlen(buf));
 
 	_queue_init();
+	_s3d_texture_init();
 #ifdef SIGS
 	if (signal(SIGINT, (sig_t)sigint_handler) == SIG_ERR)
 		errdn(LOW, "s3d_init():signal()", errno);
@@ -169,6 +170,7 @@
 int s3d_quit(void)
 {
 	struct s3d_evt *ret;
+	_s3d_texture_quit();
 	if (con_type != CON_NULL && _s3d_ready) {
 		net_send(S3D_P_C_QUIT, NULL, 0);
 		switch (con_type) {

Modified: trunk/libs3d/proto_in.c
===================================================================
--- trunk/libs3d/proto_in.c	2007-11-25 21:16:02 UTC (rev 882)
+++ trunk/libs3d/proto_in.c	2007-11-25 21:17:12 UTC (rev 883)
@@ -154,6 +154,8 @@
 
 			s3dprintf(MED, "S3D_P_S_SHMTEX: texture %d of object %d is available under shmid %d",
 						tshm->tex, tshm->oid, tshm->shmid);
+			_s3d_handle_texshm(tshm);
+			free(buf);
 
 		} else 
 			s3dprintf(MED, "wrong length for S3D_P_S_SHMTEX length %d != %d", length, sizeof(struct s3d_texshm));

Modified: trunk/libs3d/proto_out.c
===================================================================
--- trunk/libs3d/proto_out.c	2007-11-25 21:16:02 UTC (rev 882)
+++ trunk/libs3d/proto_out.c	2007-11-25 21:17:12 UTC (rev 883)
@@ -787,6 +787,10 @@
 {
 	char    buf[MF_LEN+4], *ptr;
 	int     linestep, lines, i;
+	if (_s3d_load_texture_shm(object, tex, xpos, ypos, w, h, data) == 0) {
+		/* TODO: send update event to server */
+		return(0);	/* did it over shm */
+	}
 	linestep = (MF_LEN - 16) / (w * 4);
 	if (linestep == 0)
 		return(-1);  /*  won't do that. .. yet */

Modified: trunk/libs3d/s3dlib.h
===================================================================
--- trunk/libs3d/s3dlib.h	2007-11-25 21:16:02 UTC (rev 882)
+++ trunk/libs3d/s3dlib.h	2007-11-25 21:17:12 UTC (rev 883)
@@ -24,6 +24,7 @@
 
 #include <stdint.h>
 #include "config.h"
+#include "hash.h"
 #ifdef __APPLE__
 #ifdef SHM
 #undef SHM
@@ -77,6 +78,17 @@
 /*  char *s3d_open_file(char *fname); */
 int net_prot_in(uint8_t opcode, uint16_t length, char *buf);
 
+/* what we get from the wires */
+struct s3d_texshm {
+	int32_t oid, tex, shmid;
+	uint16_t tw, th, w, h;
+} __attribute__((__packed__));
+/* for internal use. */
+struct s3d_tex {
+	struct s3d_texshm tshm;
+	char *buf;
+} __attribute__((__packed__));
+
 #ifdef DEBUG
 #ifdef HAVE_GCCVISIBILITY
 #pragma GCC visibility push(default) /* Only export following functions */
@@ -114,11 +126,6 @@
 #ifdef SIGS
 extern int _s3d_sigio;
 #endif
-/* proto_in.c */
-struct s3d_texshm {
-	int32_t oid, tex, shmid;
-	uint16_t tw, th, w, h;
-} __attribute__((__packed__));
 /*  network.c */
 extern int con_type;
 int net_send(uint8_t opcode, char *buf, uint16_t length);
@@ -158,3 +165,9 @@
 	int next, prev, done;
 };
 int _s3d_tesselate(struct tessp_t *t, struct t_buf *b);
+/* texture.c */
+int _s3d_texture_init(void);
+int _s3d_texture_quit(void);
+void _s3d_handle_texshm(struct s3d_texshm *tshm);
+int _s3d_load_texture_shm(int object, uint32_t tid, uint16_t xpos, uint16_t ypos, uint16_t w, uint16_t h, uint8_t *data);
+

Modified: trunk/libs3d/tcp.c
===================================================================
--- trunk/libs3d/tcp.c	2007-11-25 21:16:02 UTC (rev 882)
+++ trunk/libs3d/tcp.c	2007-11-25 21:17:12 UTC (rev 883)
@@ -66,12 +66,12 @@
 #ifdef WIN32
 	WSADATA datainfo;
 	if (WSAStartup(257, &datainfo) != 0) {
-		errn("s3d_init():startup()", errno);
+		errn("_tcp_init()():startup()", errno);
 		return(-1);
 	}
 #endif
 	if ((sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
-		errn("s3d_init():socket()", errno);
+		errn("_tcp_init()():socket()", errno);
 		return (-1);
 	}
 	sock.sin_family = AF_INET;
@@ -80,14 +80,14 @@
 	if ((server = gethostbyname(sv)))
 		memcpy(&sock.sin_addr.s_addr, server->h_addr_list[0], 4);
 	else {
-		errn("s3d_init():gethostbyname()", errno);
+		errn("_tcp_init()():gethostbyname()", errno);
 		return(-1);
 	}
 	sock.sin_port = htons(pn);
 
 	res = connect(sd, (struct sockaddr *) & sock, sizeof(struct sockaddr_in));
 	if (res < 0) {
-		errn("s3d_init():connect()", errno);
+		errn("_tcp_init()():connect()", errno);
 		return(-1);
 	}
 	/*    if ( fcntl(sd, F_SETFL, O_ASYNC | O_NONBLOCK) < 0 ) */

Added: trunk/libs3d/texture.c
===================================================================
--- trunk/libs3d/texture.c	2007-11-25 21:16:02 UTC (rev 882)
+++ trunk/libs3d/texture.c	2007-11-25 21:17:12 UTC (rev 883)
@@ -0,0 +1,143 @@
+/*
+ * texture.c
+ *
+ * Copyright (C) 2007 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of the s3d API, the API of s3d (the 3d network display server).
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * The s3d API is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * The s3d API is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with the s3d API; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "s3d.h"
+#include "s3dlib.h"
+#ifdef SHM
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#endif
+#include <stdlib.h>		/* malloc(), free() */
+#include <errno.h>		/* errno */
+#include <string.h>		/* memcpy() */
+
+static int _s3d_compare_cb(void *d1, void *d2);
+static int _s3d_choose_cb(void *d1, int size);
+static void _s3d_free_s3dtex(void *d1);
+static struct hashtable_t *tex_hash = NULL;
+
+static int _s3d_choose_cb(void *d1, int size) 
+{
+	struct s3d_texshm *t1 = d1;
+	return((t1->oid*32 + t1->tex)%size);
+}
+
+static int _s3d_compare_cb(void *d1, void *d2) 
+{
+	struct s3d_texshm *t1, *t2;
+	t1 = d1;
+	t2 = d2;
+	if ((t1->oid == t2->oid) && (t1->tex == t2->tex))
+		return(0);
+	return(1);
+}
+
+static void _s3d_free_s3dtex(void *d1) 
+{
+	struct s3d_tex *tex = d1;
+#ifdef SHM	
+	if (tex->buf != NULL) {
+		shmdt(tex->buf);
+		tex->buf= NULL;
+	}
+	shmctl(tex->tshm.shmid, IPC_RMID, NULL);
+	free(tex);
+#endif
+	return;
+}
+
+void _s3d_handle_texshm(struct s3d_texshm *tshm) 
+{
+	struct s3d_tex *tex = NULL;
+	if (tex_hash == NULL)
+		return;
+#ifdef SHM
+	tex = _s3d_hash_remove(tex_hash, tshm);
+	if (tex != NULL)
+		_s3d_free_s3dtex(tex);
+	if (tshm->shmid == -1)
+		return;
+
+	tex = malloc(sizeof(*tex));
+	tex->tshm = *tshm;
+	tex->buf = shmat(tex->tshm.shmid, (void *)0, 0);
+    if ((key_t *)tex->buf == (key_t *)(-1)) {
+          errn("shm_init():shmat()", errno);
+		  free(tex);
+          return;
+	}
+	_s3d_hash_add(tex_hash, tex);
+#endif
+	return;
+}
+int _s3d_load_texture_shm(int object, uint32_t tid, uint16_t xpos, uint16_t ypos, uint16_t w, uint16_t h, uint8_t *data)
+{
+	struct s3d_texshm check;
+	struct s3d_tex *tex;
+   	int32_t i, p1, p2, m;
+    int16_t mw, mh; 
+
+	if (tex_hash == NULL)
+		return(-1);
+	check.oid = object;
+	check.tex = tid;
+	tex = _s3d_hash_find(tex_hash, (void *)&check);
+
+	/* found it, assume that it's properly attached. */
+	m = tex->tshm.w * tex->tshm.th + tex->tshm.tw;     /*  maximum: position of the last pixel in the buffer */
+	if ((xpos + w) > tex->tshm.tw)	mw = (tex->tshm.tw - xpos);
+	else							mw = w;
+	if ((ypos + h) > tex->tshm.th)	mh = (tex->tshm.th - ypos);
+	else							mh = h;
+	
+	if (mw <= 0) { /*  nothing to do */
+		return(0);
+	}
+	for (i = 0;i < mh;i++) {
+		p1 = (ypos + i) * tex->tshm.w + xpos;  /*  scanline start position */
+		p2 = mw;  /*  and length */
+		if (p1 > m) {
+			break;   /*  need to break here. */
+		}
+		memcpy(	tex->buf + 4*p1,    /*  draw at p1 position ... */
+				data + 4*i*w,   /*  scanline number i ... */
+				4*p2);
+	}
+	return(0);
+}
+int _s3d_texture_init(void)
+{
+	tex_hash = _s3d_hash_new(256, _s3d_compare_cb, _s3d_choose_cb);
+	if (tex_hash == NULL)
+		return(-1);
+	else
+		return(0);
+}
+int _s3d_texture_quit(void) 
+{
+	if (tex_hash == NULL)
+		return(-1);
+	_s3d_hash_delete(tex_hash, _s3d_free_s3dtex);
+	return(0);
+}



From dotslash at mail.berlios.de  Sun Nov 25 22:53:10 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 25 Nov 2007 22:53:10 +0100
Subject: [S3d-svn] r884 - trunk/libs3d
Message-ID: <200711252153.lAPLrA5n003201@sheep.berlios.de>

Author: dotslash
Date: 2007-11-25 22:53:09 +0100 (Sun, 25 Nov 2007)
New Revision: 884

Modified:
   trunk/libs3d/proto_out.c
   trunk/libs3d/s3dlib.h
   trunk/libs3d/texture.c
Log:
- don't shm-update if not found in hash
- inform server about updates


Modified: trunk/libs3d/proto_out.c
===================================================================
--- trunk/libs3d/proto_out.c	2007-11-25 21:17:12 UTC (rev 883)
+++ trunk/libs3d/proto_out.c	2007-11-25 21:53:09 UTC (rev 884)
@@ -782,6 +782,25 @@
 	net_send(S3D_P_C_PEP_MAT_TEX, buf, 8);
 	return(0);
 }
+int _s3d_update_texture(int object, uint32_t tex, uint16_t xpos, uint16_t ypos, uint16_t w, uint16_t h) {
+	char    buf[16], *ptr;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((uint32_t *)ptr) = htonl(tex);
+	ptr += sizeof(uint32_t);  /*  texture number */
+	*((uint16_t *)ptr) = htons(xpos);
+	ptr += sizeof(uint16_t);  /*  xpos */
+	*((uint16_t *)ptr) = htons(ypos);
+	ptr += sizeof(uint16_t);  /*  ypos */
+	*((uint16_t *)ptr) = htons(w);
+	ptr += sizeof(uint16_t);  /*  width */
+	*((uint16_t *)ptr) = htons(h);
+	ptr += sizeof(uint16_t);  /*  height */
+	net_send(S3D_P_C_UPDATE_TEX, buf, 16);
+	return(0);
+
+}
 /*  load data (which has width w and height h) into object, texture tex at position (xpos,ypos) */
 int s3d_load_texture(int object, uint32_t tex, uint16_t xpos, uint16_t ypos, uint16_t w, uint16_t h, uint8_t *data)
 {
@@ -789,6 +808,7 @@
 	int     linestep, lines, i;
 	if (_s3d_load_texture_shm(object, tex, xpos, ypos, w, h, data) == 0) {
 		/* TODO: send update event to server */
+		_s3d_update_texture(object, tex, xpos, ypos, w, h);
 		return(0);	/* did it over shm */
 	}
 	linestep = (MF_LEN - 16) / (w * 4);

Modified: trunk/libs3d/s3dlib.h
===================================================================
--- trunk/libs3d/s3dlib.h	2007-11-25 21:17:12 UTC (rev 883)
+++ trunk/libs3d/s3dlib.h	2007-11-25 21:53:09 UTC (rev 884)
@@ -130,6 +130,8 @@
 extern int con_type;
 int net_send(uint8_t opcode, char *buf, uint16_t length);
 int s3d_net_init(char *urlc);
+/* proto_out.c */
+int _s3d_update_texture(int object, uint32_t tex, uint16_t xpos, uint16_t ypos, uint16_t w, uint16_t h);
 #ifdef TCP
 /* tcp.c */
 int _tcp_init(char *sv, int pn);

Modified: trunk/libs3d/texture.c
===================================================================
--- trunk/libs3d/texture.c	2007-11-25 21:17:12 UTC (rev 883)
+++ trunk/libs3d/texture.c	2007-11-25 21:53:09 UTC (rev 884)
@@ -70,6 +70,7 @@
 void _s3d_handle_texshm(struct s3d_texshm *tshm) 
 {
 	struct s3d_tex *tex = NULL;
+	s3dprintf(HIGH, "handling new texture ...");
 	if (tex_hash == NULL)
 		return;
 #ifdef SHM
@@ -87,6 +88,7 @@
 		  free(tex);
           return;
 	}
+	s3dprintf(HIGH, "adding new texture ...");
 	_s3d_hash_add(tex_hash, tex);
 #endif
 	return;
@@ -103,7 +105,10 @@
 	check.oid = object;
 	check.tex = tid;
 	tex = _s3d_hash_find(tex_hash, (void *)&check);
-
+	if (tex == NULL)
+		return(-1); /* coudn't find */
+	s3dprintf(VLOW, "texture: oid %d, tex %d, shmid %d, tw %d, th %d, w %d, h %d ...",
+					tex->tshm.oid, tex->tshm.tex, tex->tshm.shmid, tex->tshm.tw, tex->tshm.th, tex->tshm.w, tex->tshm.th);
 	/* found it, assume that it's properly attached. */
 	m = tex->tshm.w * tex->tshm.th + tex->tshm.tw;     /*  maximum: position of the last pixel in the buffer */
 	if ((xpos + w) > tex->tshm.tw)	mw = (tex->tshm.tw - xpos);



From dotslash at mail.berlios.de  Sun Nov 25 23:09:39 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 25 Nov 2007 23:09:39 +0100
Subject: [S3d-svn] r885 - trunk/server
Message-ID: <200711252209.lAPM9dfE004166@sheep.berlios.de>

Author: dotslash
Date: 2007-11-25 23:09:38 +0100 (Sun, 25 Nov 2007)
New Revision: 885

Modified:
   trunk/server/object.c
   trunk/server/proto.c
Log:
- silence debuging a little bit
- remove displaylist in obj_update_tex()
- shared memory textures should work now ;)


Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-11-25 21:53:09 UTC (rev 884)
+++ trunk/server/object.c	2007-11-25 22:09:38 UTC (rev 885)
@@ -857,6 +857,13 @@
 		return(-1);
 	tex = &obj->p_tex[tid];
 
+	if (obj->dplist) {
+		s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+		glDeleteLists(obj->dplist, 1);
+		obj->dplist = 0;
+	}
+
+
 	if ((tex->gl_texnum) != -1) {
 		t = tex->gl_texnum;
 		/* s3dprintf(MED,"updating texture %d at [%d %d] with a [%d %d] pixbuf",t,x,y,w,h); */
@@ -883,12 +890,6 @@
 		if (tex < obj->n_tex) {
 			t = &obj->p_tex[tex];
 			if (t->buf != NULL) {
-				if (obj->dplist) {
-					s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
-					glDeleteLists(obj->dplist, 1);
-					obj->dplist = 0;
-				}
-
 				m = t->w * t->th + t->tw;     /*  maximum: position of the last pixel in the buffer */
 				if ((x + w) > t->tw)
 					mw = (t->tw - x);
@@ -1574,7 +1575,7 @@
 			glGenTextures(1, &t);
 			glBindTexture(GL_TEXTURE_2D, t);
 			tex->gl_texnum = t;
-			s3dprintf(HIGH, "generated texture %d [%dx%d, in memory %dx%d]", t, tex->tw, tex->th, tex->w, tex->h);
+			s3dprintf(LOW, "generated texture %d [%dx%d, in memory %dx%d]", t, tex->tw, tex->th, tex->w, tex->h);
 			/*    for (j=0;j<tex->th;j++)
 			    for (i=0;i<tex->tw;i++)
 			    {

Modified: trunk/server/proto.c
===================================================================
--- trunk/server/proto.c	2007-11-25 21:53:09 UTC (rev 884)
+++ trunk/server/proto.c	2007-11-25 22:09:38 UTC (rev 885)
@@ -315,7 +315,7 @@
 			cptr += 2;
 			h = ntohs(*((uint16_t *)cptr));
 			cptr += 2;
-			s3dprintf(MED, "UPDATE_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] ", length, oid, toid, w, h, x, y);
+			s3dprintf(VLOW, "UPDATE_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] ", length, oid, toid, w, h, x, y);
 			obj_update_tex(p, oid, toid, x, y, w, h, NULL);
 		}
 		break;



