<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [S3d-svn] r665 - in trunk: apps/dot_mcp apps/kism3d apps/meshs3d	apps/olsrs3d apps/s3d_x11gate apps/s3dfm apps/s3dosm	apps/s3dvt example libs3d libs3dw server
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/s3d-svn/2007-September/index.html" >
   <LINK REL="made" HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r665%20-%20in%20trunk%3A%20apps/dot_mcp%20apps/kism3d%20apps/meshs3d%0A%09apps/olsrs3d%20apps/s3d_x11gate%20apps/s3dfm%20apps/s3dosm%0A%09apps/s3dvt%20example%20libs3d%20libs3dw%20server&In-Reply-To=%3C200709171333.l8HDXdqs025921%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000656.html">
   <LINK REL="Next"  HREF="000658.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[S3d-svn] r665 - in trunk: apps/dot_mcp apps/kism3d apps/meshs3d	apps/olsrs3d apps/s3d_x11gate apps/s3dfm apps/s3dosm	apps/s3dvt example libs3d libs3dw server</H1>
    <B>lazhur at BerliOS</B> 
    <A HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r665%20-%20in%20trunk%3A%20apps/dot_mcp%20apps/kism3d%20apps/meshs3d%0A%09apps/olsrs3d%20apps/s3d_x11gate%20apps/s3dfm%20apps/s3dosm%0A%09apps/s3dvt%20example%20libs3d%20libs3dw%20server&In-Reply-To=%3C200709171333.l8HDXdqs025921%40sheep.berlios.de%3E"
       TITLE="[S3d-svn] r665 - in trunk: apps/dot_mcp apps/kism3d apps/meshs3d	apps/olsrs3d apps/s3d_x11gate apps/s3dfm apps/s3dosm	apps/s3dvt example libs3d libs3dw server">lazhur at mail.berlios.de
       </A><BR>
    <I>Mon Sep 17 15:33:39 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000656.html">[S3d-svn] r664 - trunk
</A></li>
        <LI>Next message: <A HREF="000658.html">[S3d-svn] r666 - trunk/apps/s3dosm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#657">[ date ]</a>
              <a href="thread.html#657">[ thread ]</a>
              <a href="subject.html#657">[ subject ]</a>
              <a href="author.html#657">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lazhur
Date: 2007-09-17 15:33:24 +0200 (Mon, 17 Sep 2007)
New Revision: 665

Modified:
   trunk/apps/dot_mcp/dot_mcp.h
   trunk/apps/dot_mcp/main.c
   trunk/apps/dot_mcp/menu.c
   trunk/apps/kism3d/gui.c
   trunk/apps/kism3d/kism3d.c
   trunk/apps/kism3d/list.h
   trunk/apps/meshs3d/allocate.c
   trunk/apps/meshs3d/hash.c
   trunk/apps/meshs3d/main.c
   trunk/apps/meshs3d/meshs3d.h
   trunk/apps/meshs3d/net.c
   trunk/apps/meshs3d/process.c
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/net.c
   trunk/apps/olsrs3d/process.c
   trunk/apps/olsrs3d/search.c
   trunk/apps/olsrs3d/structs.h
   trunk/apps/s3d_x11gate/s3d_x11gate.c
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/event.c
   trunk/apps/s3dfm/fly.c
   trunk/apps/s3dfm/focus.c
   trunk/apps/s3dfm/fs.c
   trunk/apps/s3dfm/icon.c
   trunk/apps/s3dfm/main.c
   trunk/apps/s3dfm/node.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dfm/s3dfm.h
   trunk/apps/s3dfm/string.c
   trunk/apps/s3dosm/db.c
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/gps.c
   trunk/apps/s3dosm/http_error_codes.c
   trunk/apps/s3dosm/http_fetcher.c
   trunk/apps/s3dosm/http_fetcher.h
   trunk/apps/s3dosm/io.c
   trunk/apps/s3dosm/kismet.c
   trunk/apps/s3dosm/main.c
   trunk/apps/s3dosm/nav.c
   trunk/apps/s3dosm/object.c
   trunk/apps/s3dosm/osm.c
   trunk/apps/s3dosm/s3dosm.h
   trunk/apps/s3dosm/structs.h
   trunk/apps/s3dosm/tag.c
   trunk/apps/s3dosm/ui.c
   trunk/apps/s3dvt/main.c
   trunk/apps/s3dvt/s3dvt.h
   trunk/apps/s3dvt/terminal.c
   trunk/example/filebrowser.c
   trunk/example/hudtest.c
   trunk/example/katze.c
   trunk/example/linetest.c
   trunk/example/modelloader.c
   trunk/example/nichtsnutz.c
   trunk/example/ptrtest.c
   trunk/example/radius_test.c
   trunk/example/s3dclock.c
   trunk/example/snowman.c
   trunk/example/strtest.c
   trunk/example/texturetest.c
   trunk/example/widgets.c
   trunk/example/wiresphere.c
   trunk/libs3d/callback.c
   trunk/libs3d/config.h
   trunk/libs3d/error.c
   trunk/libs3d/event.c
   trunk/libs3d/fontselect.c
   trunk/libs3d/freetype.c
   trunk/libs3d/io.c
   trunk/libs3d/modelread.c
   trunk/libs3d/network.c
   trunk/libs3d/object_queue.c
   trunk/libs3d/proto_in.c
   trunk/libs3d/proto_out.c
   trunk/libs3d/s3d.h
   trunk/libs3d/s3d_keysym.h
   trunk/libs3d/s3dlib.h
   trunk/libs3d/sei_construct.c
   trunk/libs3d/sei_interface.h
   trunk/libs3d/sei_misc.c
   trunk/libs3d/sei_monotone.c
   trunk/libs3d/sei_tri.c
   trunk/libs3d/sei_triangulate.h
   trunk/libs3d/shm.c
   trunk/libs3d/shm_ringbuf.c
   trunk/libs3d/tcp.c
   trunk/libs3d/vector.c
   trunk/libs3dw/animate.c
   trunk/libs3dw/arrange.c
   trunk/libs3dw/button.c
   trunk/libs3dw/event.c
   trunk/libs3dw/input.c
   trunk/libs3dw/label.c
   trunk/libs3dw/root.c
   trunk/libs3dw/s3dw.h
   trunk/libs3dw/s3dw_int.h
   trunk/libs3dw/scrollbar.c
   trunk/libs3dw/style.c
   trunk/libs3dw/surface.c
   trunk/libs3dw/textbox.c
   trunk/libs3dw/widget.c
   trunk/server/allocate.c
   trunk/server/allocate.h
   trunk/server/config.h
   trunk/server/cull.c
   trunk/server/error.c
   trunk/server/event.c
   trunk/server/global.h
   trunk/server/graphics.c
   trunk/server/graphics_glut.c
   trunk/server/graphics_sdl.c
   trunk/server/main.c
   trunk/server/matrix.c
   trunk/server/mcp.c
   trunk/server/navigation.c
   trunk/server/network.c
   trunk/server/object.c
   trunk/server/process.c
   trunk/server/proto.c
   trunk/server/proto.h
   trunk/server/shm.c
   trunk/server/shm_ringbuf.c
   trunk/server/tcp.c
   trunk/server/user.c
   trunk/server/user_glut.c
   trunk/server/user_sdl.c
Log:
Reformatted to look like made for the Linux kernel coding style


Modified: trunk/apps/dot_mcp/dot_mcp.h
===================================================================
--- trunk/apps/dot_mcp/dot_mcp.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/dot_mcp/dot_mcp.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * dot_mcp.h
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of dot_mcp, a mcp for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * dot_mcp is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * dot_mcp is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with dot_mcp; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

Modified: trunk/apps/dot_mcp/main.c
===================================================================
--- trunk/apps/dot_mcp/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/dot_mcp/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * main.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of dot_mcp, a mcp for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * dot_mcp is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * dot_mcp is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with dot_mcp; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -32,11 +32,12 @@
 #include &lt;stdio.h&gt;  /*  printf() */
 #include &lt;math.h&gt;	/* sin(), cos() */
 #include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,33*1000*1000}; 
+static struct timespec t= {
+	0,33*1000*1000
+};
 
 #define bsize 	0.2
-struct tver
-{
+struct tver {
 	float x,y,z;
 };
 struct tver campos, camrot;
@@ -48,7 +49,7 @@
 	int init;
 	float trans_x,trans_y,trans_z;
 	float textw;
-	char name[256]; 
+	char name[256];
 	int min_but,close_but,title;
 	int sphere;
 	struct app *next;
@@ -83,12 +84,10 @@
 	r=100; /* inner radius */
 	a=M_PI/180;
 	s3d_push_material_a(o, 0.2,0.6,0.2,0.5,
-						   1  ,1  ,1  ,0.5,
-						   0.2,0.6,0.2,0.5);
-	for (i=0;i&lt;RINGS;i++)
-	{
-		for (j=0;j&lt;SIDES;j++)
-		{
+	                    1  ,1  ,1  ,0.5,
+	                    0.2,0.6,0.2,0.5);
+	for (i=0;i&lt;RINGS;i++) {
+		for (j=0;j&lt;SIDES;j++) {
 			ia=a*((float)i*360.0/RINGS);
 			ja=a*((float)j*360.0/SIDES);
 			iap=a*((float)(i+1)*360.0/RINGS);
@@ -97,14 +96,14 @@
 			v[i*SIDES*3+ j*3 +0]=(R+r*cos(ja))* cos(ia);
 			v[i*SIDES*3+ j*3 +1]=r*sin(ja);
 			v[i*SIDES*3+ j*3 +2]=(R+r*cos(ja))* sin(ia);
-		
+
 			l[i*SIDES*6+ j*6 +0]=i*SIDES+ j;
 			l[i*SIDES*6+ j*6 +1]=i*SIDES+ (j+1)%SIDES;
 			l[i*SIDES*6+ j*6 +2]=0;
 			l[i*SIDES*6+ j*6 +3]=i*SIDES+ j;
 			l[i*SIDES*6+ j*6 +4]=((i+1)%RINGS)*SIDES+ j;
 			l[i*SIDES*6+ j*6 +5]=0;
-			
+
 			n[j*12 +0] =R*r*cos(ja)*    cos(ia) + r*r*cos(ja)* cos(ia)*cos(ia);
 			n[j*12 +1] =R*r*sin(ja)*    cos(ia) + r*r*sin(ja)* cos(ia)*cos(ia);
 			n[j*12 +2] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
@@ -123,8 +122,8 @@
 		s3d_push_lines(o,   &amp;l[i*SIDES*6],SIDES*2);
 		s3d_pep_line_normals(o,n,SIDES*2);
 	}
-/*	s3d_push_vertices(o,v,SIDES*RINGS);
-	s3d_push_lines(o,   l,SIDES*RINGS*2);*/
+	/*	s3d_push_vertices(o,v,SIDES*RINGS);
+		s3d_push_lines(o,   l,SIDES*RINGS*2);*/
 
 	s3d_flags_on(o,S3D_OF_VISIBLE);
 	return(o);
@@ -133,22 +132,20 @@
 {
 	if (focus!=a)
 		/* resetting old focus */
-		if (focus!=NULL)
-		{
+		if (focus!=NULL) {
 			printf(&quot;unfocusing app name %s\n&quot;,focus-&gt;name);
 			s3d_scale(focus-&gt;oid,1/focus-&gt;r);
 			s3d_scale(focus-&gt;sphere,focus-&gt;r);
 
-  			s3d_flags_on(focus-&gt;sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(focus-&gt;sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			s3d_flags_off(focus-&gt;min_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			s3d_translate(	focus-&gt;title,-focus-&gt;textw-1.2,0.0,0);
 			s3d_translate(	focus-&gt;close_but,bsize*focus-&gt;textw/2,1.2,0);
 			s3d_link(		focus-&gt;close_but,focus-&gt;sphere);
-			s3d_link(		focus-&gt;oid,0); 
+			s3d_link(		focus-&gt;oid,0);
 		}
 	focus=a;
-	if (a==NULL)
-	{
+	if (a==NULL) {
 		focus_r=n_app;
 		s3d_mcp_focus(-1);
 		s3d_flags_off(rotate,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
@@ -180,11 +177,9 @@
 int add_app(struct app *a)
 {
 	struct app *prev=NULL,*a2=apps;
-	while ((a2)!=NULL)
-	{
+	while ((a2)!=NULL) {
 		prev=a2;
-		if (a2-&gt;oid==a-&gt;oid)
-		{  /*  already added, so free() and return */
+		if (a2-&gt;oid==a-&gt;oid) { /*  already added, so free() and return */
 			free(a);
 			return(1);
 		}
@@ -193,7 +188,7 @@
 	a-&gt;next=NULL;
 	if (prev==NULL)
 		apps=a;
-	else 
+	else
 		prev-&gt;next=a;
 	n_app+=1;
 	return(0);
@@ -201,8 +196,7 @@
 void *find_app(int oid)
 {
 	struct app *a=apps;
-	while (a!=NULL)
-	{
+	while (a!=NULL) {
 		if (oid==a-&gt;oid)
 			break;
 		a=a-&gt;next;
@@ -212,34 +206,30 @@
 void *del_app(int oid)
 {
 	struct app *prev=NULL,*a=apps;
-	while ((a!=NULL)  &amp;&amp; (a-&gt;oid!=oid))
-	{
+	while ((a!=NULL)  &amp;&amp; (a-&gt;oid!=oid)) {
 		prev=a;
 		a=a-&gt;next;
 	}
-	if (a!=NULL)
-	{  /*  found ... */
-		if (a-&gt;init)
-		{
+	if (a!=NULL) { /*  found ... */
+		if (a-&gt;init) {
 			s3d_del_object(a-&gt;close_but);
 			s3d_del_object(a-&gt;min_but);
 			s3d_del_object(a-&gt;title);
 			s3d_del_object(a-&gt;sphere);
 			s3d_del_object(a-&gt;oid);
 		}
-		if (prev==NULL) 
+		if (prev==NULL)
 			apps=a-&gt;next;  /*  new head */
 		else
 			prev-&gt;next=a-&gt;next;
 		n_app--;
-		if (focus==a)
-		{
+		if (focus==a) {
 			set_focus(NULL);
 			focus=NULL;
 		}
 		free(a);
 		place_apps();
-	} 
+	}
 	return(a);
 }
 int stop()
@@ -252,17 +242,12 @@
 	struct app *a=apps;
 	int j=0;
 	float u[3],v[3],ya,xa;
-	while (a!=NULL)
-	{
-		if (a-&gt;init)	
-		{
-/*			printf(&quot;placing app [%d,'%s'], oid %d, r=%f\n&quot;,j,a-&gt;name,a-&gt;oid,a-&gt;r); */
-			if (focus==a)
-			{
+	while (a!=NULL) {
+		if (a-&gt;init) {
+			/*			printf(&quot;placing app [%d,'%s'], oid %d, r=%f\n&quot;,j,a-&gt;name,a-&gt;oid,a-&gt;r); */
+			if (focus==a) {
 				s3d_translate(a-&gt;close_but,(-left)*zoom-0.4,(-bottom)*zoom-0.4,-zoom);
-			}
-			else 
-			{
+			} else {
 				s3d_translate(	a-&gt;oid,	zoom*(left)+j*2+1.0,zoom*bottom+1.0,-zoom);
 				s3d_rotate(		a-&gt;oid,	0,10,0);
 				j++;
@@ -271,21 +256,26 @@
 		a=a-&gt;next;
 	}
 	s3d_translate(menu,	left*zoom+0.4,(-bottom)*zoom-0.4,-zoom);
-	
-	v[0]=0;				v[1]=0;					v[2]=1;
-	u[0]=left*zoom+0.4; u[1]=0;					u[2]=-zoom;
+
+	v[0]=0;
+	v[1]=0;
+	v[2]=1;
+	u[0]=left*zoom+0.4;
+	u[1]=0;
+	u[2]=-zoom;
 	ya=s3d_vector_angle(v,u);
-	u[0]=0; 			u[1]=(-bottom)*zoom;	u[2]=-zoom;
+	u[0]=0;
+	u[1]=(-bottom)*zoom;
+	u[2]=-zoom;
 	xa=s3d_vector_angle(v,u);
-	s3d_rotate(menu, 0 ,30,0); 
+	s3d_rotate(menu, 0 ,30,0);
 }
 int mcp_object(struct s3d_evt *hrmz)
 {
 	struct mcp_object *mo;
 	struct app *a;
 	mo=(struct mcp_object *)hrmz-&gt;buf;
-	if (NULL==(a=find_app(mo-&gt;object)))
-	{
+	if (NULL==(a=find_app(mo-&gt;object))) {
 		printf(&quot;adding new object ......&quot;);
 		a=malloc(sizeof(struct app));
 		a-&gt;oid=mo-&gt;object;
@@ -296,15 +286,13 @@
 		place_apps();
 		printf(&quot;..%s\n&quot;,a-&gt;name);
 	} else {
-/*		printf(&quot;updating app %d\n&quot;,a-&gt;oid);*/
+		/*		printf(&quot;updating app %d\n&quot;,a-&gt;oid);*/
 		a-&gt;trans_x=mo-&gt;trans_x;
 		a-&gt;trans_y=mo-&gt;trans_y;
 		a-&gt;trans_z=mo-&gt;trans_z;
 		a-&gt;r=mo-&gt;r;
-		if (a-&gt;init)
-		{
-			if (a==focus)
-			{
+		if (a-&gt;init) {
+			if (a==focus) {
 				focus_r=a-&gt;r;
 			} else {
 				s3d_scale(a-&gt;sphere,a-&gt;r);
@@ -324,32 +312,32 @@
 	a-&gt;sphere=s3d_clone(sphere);
 	s3d_scale(		a-&gt;sphere,a-&gt;r);
 	s3d_link(		a-&gt;sphere,a-&gt;oid);
-  	s3d_flags_on(	a-&gt;sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(	a-&gt;sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 
 	a-&gt;title=s3d_draw_string(a-&gt;name,&amp;a-&gt;textw);
 
 	a-&gt;close_but=s3d_clone(close_but);
 	s3d_translate(	a-&gt;close_but,bsize*a-&gt;textw/2.0,1.2f,0.0f);
 	s3d_link(		a-&gt;close_but,a-&gt;sphere);
-  	s3d_flags_on(	a-&gt;close_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(	a-&gt;close_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 
 
 	s3d_translate(	a-&gt;title,-a-&gt;textw-1.2f,0.0f,0.0f);
 	s3d_link(		a-&gt;title,a-&gt;close_but);
-   	s3d_flags_on(	a-&gt;title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	
+	s3d_flags_on(	a-&gt;title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+
 	a-&gt;min_but=s3d_clone(min_but);
 	s3d_link(		a-&gt;min_but,a-&gt;close_but);
-	
-	
+
+
 	s3d_scale(		a-&gt;close_but,bsize);
-	
+
 	s3d_link(		a-&gt;oid,0);
 	a-&gt;init=1;
-/*	if (focus==NULL)
-		set_focus(a);
-	else*/
-		place_apps();
+	/*	if (focus==NULL)
+			set_focus(a);
+		else*/
+	place_apps();
 }
 int mcp_del_object(struct s3d_evt *hrmz)
 {
@@ -363,32 +351,26 @@
 	struct app *a;
 	unsigned int i, oid;
 	oid=*((unsigned int *)hrmz-&gt;buf);
-	a=apps;i=0;
-	if (oid==rotate)
-	{
+	a=apps;
+	i=0;
+	if (oid==rotate) {
 		rot_flag=!rot_flag;
 		return(0);
 	}
-	if (oid==reset)
-	{
+	if (oid==reset) {
 		s3d_translate(0,0.0,0.0,5.0);
 		s3d_rotate(0,0,0,0);
 	}
-	while (a!=NULL)
-	{
-		if (oid==a-&gt;close_but)
-		{
+	while (a!=NULL) {
+		if (oid==a-&gt;close_but) {
 			del_app(a-&gt;oid);
 			return(0);
-		} else 	if (oid==a-&gt;min_but)
-		{
-			if (a==focus)
-			{
+		} else 	if (oid==a-&gt;min_but) {
+			if (a==focus) {
 				set_focus(NULL); /* nothing is focused now */
 			}
 			return(0);
-		} else 	if (((oid==a-&gt;title) || (oid==a-&gt;sphere)) || (oid==a-&gt;oid))
-		{
+		} else 	if (((oid==a-&gt;title) || (oid==a-&gt;sphere)) || (oid==a-&gt;oid)) {
 			printf(&quot;giving focus to [%s], %d\n&quot;,a-&gt;name,oid);
 			set_focus(a);
 			return(0);
@@ -403,8 +385,7 @@
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
-	if (inf-&gt;object==0)
-	{
+	if (inf-&gt;object==0) {
 		campos.x=inf-&gt;trans_x;
 		campos.y=inf-&gt;trans_y;
 		campos.z=inf-&gt;trans_z;
@@ -412,12 +393,10 @@
 		camrot.y=inf-&gt;rot_y;
 		camrot.z=inf-&gt;rot_z;
 
-		if (asp!=inf-&gt;scale)
-		{
+		if (asp!=inf-&gt;scale) {
 			asp=inf-&gt;scale;
 			printf(&quot;screen aspect: %f\n&quot;,asp);
-			if (asp&gt;1.0) /* wide screen */
-			{
+			if (asp&gt;1.0) { /* wide screen */
 				bottom=-1.0;
 				left=-asp;
 			} else {  /* high screen */
@@ -434,16 +413,15 @@
 	struct app *a;
 	float al,r;
 	int i;
-	a=apps;i=0;
-	while (a!=NULL)
-	{
+	a=apps;
+	i=0;
+	while (a!=NULL) {
 		if (!a-&gt;init)
 			app_init(a);
 		i++;
 		a=a-&gt;next;
 	}
-	if (rot_flag)
-	{
+	if (rot_flag) {
 		al=(alpha*M_PI/180);
 		r=(focus_r&gt;20.0)?20.0:focus_r;
 		s3d_translate(0,sin(al)*(r+5),0,cos(al)*(r+5));
@@ -451,10 +429,8 @@
 		alpha=alpha+0.1;
 		if (alpha&gt;360.0) alpha=0.0;
 	}
-	if (ego_mode)
-	{
-		if ((ydif!=0) || (xdif!=0))
-		{
+	if (ego_mode) {
+		if ((ydif!=0) || (xdif!=0)) {
 			campos.x+=ydif*sin((camrot.y*M_PI)/180);
 			campos.z+=ydif*cos((camrot.y*M_PI)/180);
 			campos.x+=xdif*cos((-camrot.y*M_PI)/180);
@@ -463,35 +439,50 @@
 			s3d_translate(	0,campos.x,campos.y,campos.z);
 		}
 	}
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 }
 
 int keydown(struct s3d_evt *event)
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)event-&gt;buf;
-	switch (keys-&gt;keysym)
-	{
-		case S3DK_F2:  ego_mode=(ego_mode+1)%2;
-				 xdif=0;
-			     ydif=0;
-				 printf(&quot;ego mode %d\n&quot;,ego_mode);
-				 break;
-		case 'w':ydif+=-1.0;break;
-		case 'a':xdif+=-1.0;break;
-		case 's':ydif+= 1.0;break;
-		case 'd':xdif+= 1.0;break;
+	switch (keys-&gt;keysym) {
+	case S3DK_F2:
+		ego_mode=(ego_mode+1)%2;
+		xdif=0;
+		ydif=0;
+		printf(&quot;ego mode %d\n&quot;,ego_mode);
+		break;
+	case 'w':
+		ydif+=-1.0;
+		break;
+	case 'a':
+		xdif+=-1.0;
+		break;
+	case 's':
+		ydif+= 1.0;
+		break;
+	case 'd':
+		xdif+= 1.0;
+		break;
 	}
 	return(0);
 }
 int keyup(struct s3d_evt *event)
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)event-&gt;buf;
-	switch (keys-&gt;keysym)
-	{
-		case 'w':ydif-=-1.0;break;
-		case 'a':xdif-=-1.0;break;
-		case 's':ydif-= 1.0;break;
-		case 'd':xdif-= 1.0;break;
+	switch (keys-&gt;keysym) {
+	case 'w':
+		ydif-=-1.0;
+		break;
+	case 'a':
+		xdif-=-1.0;
+		break;
+	case 's':
+		ydif-= 1.0;
+		break;
+	case 'd':
+		xdif-= 1.0;
+		break;
 	}
 	return(0);
 
@@ -507,13 +498,11 @@
 	s3d_set_callback(S3D_EVENT_KEYDOWN,keydown);
 	s3d_set_callback(S3D_EVENT_KEYUP,keyup);
 
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;mcp&quot;))	
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;mcp&quot;)) {
 		if (!((argc&gt;1) &amp;&amp; (0==strcmp(argv[1],&quot;--notorus&quot;))))
-		greentorus(); /* just call ... */
+			greentorus(); /* just call ... */
 
-		if (s3d_select_font(&quot;vera&quot;))
-		{
+		if (s3d_select_font(&quot;vera&quot;)) {
 			printf(&quot;font not found\n&quot;);
 		}
 		min_but=s3d_import_model_file(&quot;objs/btn_minimize.3ds&quot;);

Modified: trunk/apps/dot_mcp/menu.c
===================================================================
--- trunk/apps/dot_mcp/menu.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/dot_mcp/menu.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * menu.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of dot_mcp, a mcp for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * dot_mcp is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * dot_mcp is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with dot_mcp; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,25 +35,19 @@
 };
 static int go=-1;
 static int act;
-static struct menu_entry menu[]={
-		{&quot;objs/comp.3ds&quot;,&quot;terminal&quot;,&quot;s3dvt&quot;,				0,0},
-		{&quot;objs/comp.3ds&quot;,&quot;olsrs3d&quot;,&quot;olsrs3d&quot;,				0,0},
-		{&quot;objs/comp.3ds&quot;,&quot;s3d_x11gate&quot;,&quot;s3d_x11gate&quot;,		0,0},
-		{&quot;objs/comp.3ds&quot;,&quot;filebrowser&quot;,&quot;filebrowser&quot;,		0,0}, 
-		{&quot;objs/comp.3ds&quot;,&quot;logout&quot;,&quot;LOGOUT&quot;,					0,0}, 
+static struct menu_entry menu[]= {
+	{&quot;objs/comp.3ds&quot;,&quot;terminal&quot;,&quot;s3dvt&quot;,				0,0
+	}, {&quot;objs/comp.3ds&quot;,&quot;olsrs3d&quot;,&quot;olsrs3d&quot;,				0,0}, {&quot;objs/comp.3ds&quot;,&quot;s3d_x11gate&quot;,&quot;s3d_x11gate&quot;,		0,0}, {&quot;objs/comp.3ds&quot;,&quot;filebrowser&quot;,&quot;filebrowser&quot;,		0,0}, {&quot;objs/comp.3ds&quot;,&quot;logout&quot;,&quot;LOGOUT&quot;,					0,0},
 };
 void menu_click(int oid)
 {
 	unsigned int i;
 	char exec[256];
 	printf(&quot;%d got clicked\n&quot;,oid);
-	if (oid==go)
-	{
+	if (oid==go) {
 		act=!act;
-		for (i=0;i&lt;(sizeof(menu)/sizeof(struct menu_entry));i++)
-		{
-			if (act)
-			{
+		for (i=0;i&lt;(sizeof(menu)/sizeof(struct menu_entry));i++) {
+			if (act) {
 				s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 				s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			} else {
@@ -64,14 +58,10 @@
 		}
 		return;
 	}
-	if (act)
-	{
-		for (i=0;i&lt;(sizeof(menu)/sizeof(struct menu_entry));i++)
-		{
-			if ((oid==menu[i].icon_oid) || (oid==menu[i].str_oid))
-			{
-				if (0==strncmp(menu[i].path,&quot;LOGOUT&quot;,6))
-				{
+	if (act) {
+		for (i=0;i&lt;(sizeof(menu)/sizeof(struct menu_entry));i++) {
+			if ((oid==menu[i].icon_oid) || (oid==menu[i].str_oid)) {
+				if (0==strncmp(menu[i].path,&quot;LOGOUT&quot;,6)) {
 					s3d_quit();
 					return;
 				}
@@ -92,17 +82,16 @@
 	go=s3d_import_model_file(&quot;objs/s3dstart.3ds&quot;);
 	s3d_flags_on(go,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	s3d_link(go,menu_o);
-	for (i=0;i&lt;(sizeof(menu)/sizeof(struct menu_entry));i++)
-	{
+	for (i=0;i&lt;(sizeof(menu)/sizeof(struct menu_entry));i++) {
 		if (-1==(menu[i].icon_oid=s3d_import_model_file(menu[i].icon)))
-				menu[i].icon_oid=s3d_new_object();
+			menu[i].icon_oid=s3d_new_object();
 		menu[i].str_oid=s3d_draw_string(menu[i].name,NULL);
 		s3d_link(menu[i].str_oid,menu[i].icon_oid);
 		s3d_link(menu[i].icon_oid,menu_o);
 		s3d_translate(menu[i].icon_oid,0,-3+(-3*i),0);
 		s3d_translate(menu[i].str_oid,2,0,0);
-/*		s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);*/
+		/*		s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+				s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);*/
 		printf(&quot;menu item menu[%d], icon_oid=%d, icon_str=%d\n&quot;,i,menu[i].icon_oid,menu[i].str_oid);
 	}
 	return(menu_o);

Modified: trunk/apps/kism3d/gui.c
===================================================================
--- trunk/apps/kism3d/gui.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/kism3d/gui.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -43,7 +43,9 @@
 
 int Client_obj;
 
-struct timespec sleeptime = { 0, 100 * 1000 * 1000 };   /* 100 mili seconds */
+struct timespec sleeptime = {
+	0, 100 * 1000 * 1000
+};   /* 100 mili seconds */
 
 
 
@@ -73,8 +75,7 @@
 	i=0;
 	for (x=0;x&lt;slices;x++) {
 		for (y=0;y&lt;stacks;y++) {
-			if ((y!=0) &amp;&amp; (y!=stacks)) /* no horizontal lines at the poles */
-			{
+			if ((y!=0) &amp;&amp; (y!=stacks)) { /* no horizontal lines at the poles */
 				l[i*3+0]=(x*(stacks+1))+y;
 				l[i*3+1]=(((x+1)%slices)*(stacks+1))+y;
 				l[i*3+2]=0;
@@ -104,8 +105,8 @@
 	}
 	o=s3d_new_object();
 	s3d_push_material(o,0,0,1,
-			  1,0,0,
-			  0,1,0);
+	                  1,0,0,
+	                  0,1,0);
 	s3d_push_vertices(o,v,num_v);
 	s3d_push_lines(o,l,num_l);
 	s3d_load_line_normals(o,n,0,num_l);
@@ -117,7 +118,8 @@
 
 
 
-int handle_networks() {
+int handle_networks()
+{
 
 	struct list_head *network_pos;
 	struct wlan_network *wlan_network;
@@ -244,7 +246,8 @@
 
 
 
-int handle_clients() {
+int handle_clients()
+{
 
 	struct list_head *client_pos;
 	struct wlan_client *wlan_client;
@@ -307,7 +310,8 @@
  *
  ***/
 
-int object_click(struct s3d_evt *evt) {
+int object_click(struct s3d_evt *evt)
+{
 
 	struct list_head *network_pos;
 	struct wlan_network *wlan_network;
@@ -350,7 +354,8 @@
  *
  ***/
 
-int object_info(struct s3d_evt *hrmz) {
+int object_info(struct s3d_evt *hrmz)
+{
 
 	struct s3d_obj_info *inf;
 
@@ -375,7 +380,8 @@
 
 
 
-void mainloop() {
+void mainloop()
+{
 
 	float angle, diff_vec[3], tmp_vec[3] = { 0.0, 0.0, -1.0 };
 
@@ -417,7 +423,8 @@
 
 
 
-void* gui_main( void *unused ) {
+void* gui_main( void *unused )
+{
 
 	if ( !s3d_init( NULL, NULL, &quot;kism3d&quot; ) ) {
 

Modified: trunk/apps/kism3d/kism3d.c
===================================================================
--- trunk/apps/kism3d/kism3d.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/kism3d/kism3d.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -52,7 +52,8 @@
 
 
 
-void *alloc_memory( int len ) {
+void *alloc_memory( int len )
+{
 
 	void *res = malloc( len );
 
@@ -69,7 +70,8 @@
 
 
 
-void *realloc_memory( void *ptr, int len ) {
+void *realloc_memory( void *ptr, int len )
+{
 
 	void *res = realloc( ptr, len );
 
@@ -86,7 +88,8 @@
 
 
 
-unsigned int get_time( void ) {
+unsigned int get_time( void )
+{
 
 	struct timeval tv;
 
@@ -98,7 +101,8 @@
 
 
 
-void parse_buffer( struct kismet_src *kismet_src ) {
+void parse_buffer( struct kismet_src *kismet_src )
+{
 
 	struct wlan_network *wlan_network;
 	struct wlan_client *wlan_client;
@@ -129,44 +133,44 @@
 
 					switch ( kismet_src-&gt;enable_level ) {
 
-						case 0:
-							if ( write( kismet_src-&gt;sock, enable_alert, sizeof( enable_alert ) ) &lt; 0 ) {
+					case 0:
+						if ( write( kismet_src-&gt;sock, enable_alert, sizeof( enable_alert ) ) &lt; 0 ) {
 
-								printf( &quot;Warning - can't send ENABLE ALERT message to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno) );
+							printf( &quot;Warning - can't send ENABLE ALERT message to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno) );
 
-							}
+						}
 
-							break;
+						break;
 
-						case 1:
-							if ( write( kismet_src-&gt;sock, enable_client, sizeof( enable_client ) ) &lt; 0 ) {
+					case 1:
+						if ( write( kismet_src-&gt;sock, enable_client, sizeof( enable_client ) ) &lt; 0 ) {
 
-								printf( &quot;Warning - can't send ENABLE CLIENT message to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno) );
+							printf( &quot;Warning - can't send ENABLE CLIENT message to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno) );
 
-							}
+						}
 
-							break;
+						break;
 
-						case 2:
+					case 2:
 
-							if ( write( kismet_src-&gt;sock, enable_network, sizeof( enable_network ) ) &lt; 0 ) {
+						if ( write( kismet_src-&gt;sock, enable_network, sizeof( enable_network ) ) &lt; 0 ) {
 
-								printf( &quot;Warning - can't send ENABLE NETWORK message to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno) );
+							printf( &quot;Warning - can't send ENABLE NETWORK message to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno) );
 
-							}
+						}
 
-							break;
+						break;
 
-						case 3:
+					case 3:
 
-							if ( !thread_running ) {
+						if ( !thread_running ) {
 
-								thread_running++;
-								pthread_create( &amp;s3d_thread_id, NULL, &amp;gui_main, NULL );
+							thread_running++;
+							pthread_create( &amp;s3d_thread_id, NULL, &amp;gui_main, NULL );
 
-							}
+						}
 
-							break;
+						break;
 
 					}
 
@@ -188,33 +192,33 @@
 
 						switch ( count ) {
 
-							case 0:
-								bssid = parse_begin_ptr;
-								break;
+						case 0:
+							bssid = parse_begin_ptr;
+							break;
 
-							case 1:
-								type = parse_begin_ptr;
-								break;
+						case 1:
+							type = parse_begin_ptr;
+							break;
 
-							case 2:
-								channel = parse_begin_ptr;
-								break;
+						case 2:
+							channel = parse_begin_ptr;
+							break;
 
-							case 3:
-								/* ssids with spaces are quoted by kismet */
-								if ( parse_begin_ptr[0] == '\001' ) {
+						case 3:
+							/* ssids with spaces are quoted by kismet */
+							if ( parse_begin_ptr[0] == '\001' ) {
 
-									parse_begin_ptr++;
+								parse_begin_ptr++;
 
-									parse_end_ptr = strchr( parse_begin_ptr, '\001' );
-									*parse_end_ptr = '\0';
+								parse_end_ptr = strchr( parse_begin_ptr, '\001' );
+								*parse_end_ptr = '\0';
 
-									count++;
+								count++;
 
-								}
+							}
 
-								ssid = parse_begin_ptr;
-								break;
+							ssid = parse_begin_ptr;
+							break;
 
 						}
 
@@ -267,17 +271,17 @@
 
 						switch ( count ) {
 
-							case 0:
-								bssid = parse_begin_ptr;
-								break;
+						case 0:
+							bssid = parse_begin_ptr;
+							break;
 
-							case 1:
-								mac = parse_begin_ptr;
-								break;
+						case 1:
+							mac = parse_begin_ptr;
+							break;
 
-							case 2:
-								ip = parse_begin_ptr;
-								break;
+						case 2:
+							ip = parse_begin_ptr;
+							break;
 
 						}
 
@@ -353,7 +357,8 @@
 
 
 
-int main( int argc, char *argv[] ) {
+int main( int argc, char *argv[] )
+{
 
 	struct in_addr tmp_ip_holder;
 	struct kismet_src *kismet_src;

Modified: trunk/apps/kism3d/list.h
===================================================================
--- trunk/apps/kism3d/list.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/kism3d/list.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -76,8 +76,8 @@
  * the prev/next entries already!
  */
 static inline void __list_add(struct list_head *new,
-			      struct list_head *prev,
-			      struct list_head *next)
+                              struct list_head *prev,
+                              struct list_head *next)
 {
 	next-&gt;prev = new;
 	new-&gt;next = next;

Modified: trunk/apps/meshs3d/allocate.c
===================================================================
--- trunk/apps/meshs3d/allocate.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/meshs3d/allocate.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -34,16 +34,14 @@
 
 struct chunkHeader *chunkList = NULL;
 
-struct chunkHeader
-{
+struct chunkHeader {
 	struct chunkHeader *next;
 	uint32_t length;
 	int32_t tag;
 	uint32_t magicNumber;
 };
 
-struct chunkTrailer
-{
+struct chunkTrailer {
 	uint32_t magicNumber;
 };
 
@@ -54,8 +52,7 @@
 struct memoryUsage *memoryList = NULL;
 
 
-struct memoryUsage
-{
+struct memoryUsage {
 	struct memoryUsage *next;
 	uint32_t length;
 	uint32_t counter;
@@ -63,7 +60,8 @@
 };
 
 
-void addMemory( uint32_t length, int32_t tag ) {
+void addMemory( uint32_t length, int32_t tag )
+{
 
 	struct memoryUsage *walker;
 
@@ -95,7 +93,8 @@
 }
 
 
-void removeMemory( int32_t tag, int32_t freetag ) {
+void removeMemory( int32_t tag, int32_t freetag )
+{
 
 	struct memoryUsage *walker;
 
@@ -154,10 +153,8 @@
 #endif
 
 
-	for (walker = chunkList; walker != NULL; walker = walker-&gt;next)
-	{
-		if (walker-&gt;magicNumber != MAGIC_NUMBER)
-		{
+	for (walker = chunkList; walker != NULL; walker = walker-&gt;next) {
+		if (walker-&gt;magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, &quot;checkIntegrity - invalid magic number in header: %08x, malloc tag = %d\n&quot;, walker-&gt;magicNumber, walker-&gt;tag);
 			exit(1);
 		}
@@ -166,8 +163,7 @@
 
 		chunkTrailer = (struct chunkTrailer *)(memory + sizeof(struct chunkHeader) + walker-&gt;length);
 
-		if (chunkTrailer-&gt;magicNumber != MAGIC_NUMBER)
-		{
+		if (chunkTrailer-&gt;magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, &quot;checkIntegrity - invalid magic number in trailer: %08x, malloc tag = %d\n&quot;, chunkTrailer-&gt;magicNumber, walker-&gt;tag);
 			exit(1);
 		}
@@ -193,8 +189,7 @@
 
 	memory = malloc(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer));
 
-	if (memory == NULL)
-	{
+	if (memory == NULL) {
 		fprintf(stderr, &quot;Cannot allocate %u bytes, malloc tag = %d\n&quot;, (unsigned int)(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer)), tag);
 		exit(1);
 	}
@@ -233,16 +228,14 @@
 		memory = memoryParameter;
 		chunkHeader = (struct chunkHeader *)(memory - sizeof(struct chunkHeader));
 
-		if (chunkHeader-&gt;magicNumber != MAGIC_NUMBER)
-		{
+		if (chunkHeader-&gt;magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, &quot;debugRealloc - invalid magic number in header: %08x, malloc tag = %d\n&quot;, chunkHeader-&gt;magicNumber, chunkHeader-&gt;tag);
 			exit(1);
 		}
 
 		chunkTrailer = (struct chunkTrailer *)(memory + chunkHeader-&gt;length);
 
-		if (chunkTrailer-&gt;magicNumber != MAGIC_NUMBER)
-		{
+		if (chunkTrailer-&gt;magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, &quot;debugRealloc - invalid magic number in trailer: %08x, malloc tag = %d\n&quot;, chunkTrailer-&gt;magicNumber, chunkHeader-&gt;tag);
 			exit(1);
 		}
@@ -275,24 +268,21 @@
 	memory = memoryParameter;
 	chunkHeader = (struct chunkHeader *)(memory - sizeof(struct chunkHeader));
 
-	if (chunkHeader-&gt;magicNumber != MAGIC_NUMBER)
-	{
+	if (chunkHeader-&gt;magicNumber != MAGIC_NUMBER) {
 		fprintf(stderr, &quot;debugFree - invalid magic number in header: %08x, malloc tag = %d, free tag = %d\n&quot;, chunkHeader-&gt;magicNumber, chunkHeader-&gt;tag, tag);
 		exit(1);
 	}
 
 	previous = NULL;
 
-	for (walker = chunkList; walker != NULL; walker = walker-&gt;next)
-	{
+	for (walker = chunkList; walker != NULL; walker = walker-&gt;next) {
 		if (walker == chunkHeader)
 			break;
 
 		previous = walker;
 	}
 
-	if (walker == NULL)
-	{
+	if (walker == NULL) {
 		fprintf(stderr, &quot;Double free detected, malloc tag = %d, free tag = %d\n&quot;, chunkHeader-&gt;tag, tag);
 		exit(1);
 	}
@@ -305,8 +295,7 @@
 
 	chunkTrailer = (struct chunkTrailer *)(memory + chunkHeader-&gt;length);
 
-	if (chunkTrailer-&gt;magicNumber != MAGIC_NUMBER)
-	{
+	if (chunkTrailer-&gt;magicNumber != MAGIC_NUMBER) {
 		fprintf(stderr, &quot;debugFree - invalid magic number in trailer: %08x, malloc tag = %d, free tag = %d\n&quot;, chunkTrailer-&gt;magicNumber, chunkHeader-&gt;tag, tag);
 		exit(1);
 	}
@@ -337,8 +326,7 @@
 
 	result = malloc(length);
 
-	if (result == NULL)
-	{
+	if (result == NULL) {
 		fprintf(stderr, &quot;Cannot allocate %u bytes, malloc tag = %d\n&quot;, length, tag);
 		exit(1);
 	}
@@ -352,8 +340,7 @@
 
 	result = realloc(memory, length);
 
-	if (result == NULL)
-	{
+	if (result == NULL) {
 		fprintf(stderr, &quot;Cannot re-allocate %u bytes, malloc tag = %d\n&quot;, length, tag);
 		exit(1);
 	}

Modified: trunk/apps/meshs3d/hash.c
===================================================================
--- trunk/apps/meshs3d/hash.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/meshs3d/hash.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -24,7 +24,8 @@
 
 
 /* clears the hash */
-void hash_init(struct hashtable_t *hash) {
+void hash_init(struct hashtable_t *hash)
+{
 	int i;
 	hash-&gt;elements=0;
 	for (i=0 ; i&lt;hash-&gt;size ; i++) {
@@ -36,7 +37,8 @@
 /* remove the hash structure. if hashdata_free_cb != NULL,
  * this function will be called to remove the elements inside of the hash.
  * if you don't remove the elements, memory might be leaked. */
-void hash_delete(struct hashtable_t *hash, hashdata_free_cb free_cb) {
+void hash_delete(struct hashtable_t *hash, hashdata_free_cb free_cb)
+{
 	struct element_t *bucket, *last_bucket;
 	int i;
 
@@ -61,7 +63,8 @@
 
 
 /* free only the hashtable and the hash itself. */
-void hash_destroy(struct hashtable_t *hash) {
+void hash_destroy(struct hashtable_t *hash)
+{
 
 	debugFree( hash-&gt;table, 1302 );
 	debugFree( hash, 1303 );
@@ -128,7 +131,7 @@
 
 	iter-&gt;index++;
 	while ( iter-&gt;index &lt; hash-&gt;size ) {		/* go through the entries of the hash table */
-		if ((hash-&gt;table[ iter-&gt;index ]) != NULL){
+		if ((hash-&gt;table[ iter-&gt;index ]) != NULL) {
 			iter-&gt;prev_bucket = NULL;
 			iter-&gt;bucket = hash-&gt;table[ iter-&gt;index ];
 			iter-&gt;first_bucket = &amp;hash-&gt;table[ iter-&gt;index ];
@@ -164,7 +167,8 @@
 
 
 /* adds data to the hashtable. returns 0 on success, -1 on error */
-int hash_add(struct hashtable_t *hash, void *data) {
+int hash_add(struct hashtable_t *hash, void *data)
+{
 	int index;
 	struct element_t *bucket, *prev_bucket = NULL;
 
@@ -198,7 +202,8 @@
 
 }
 /* finds data, based on the key in keydata. returns the found data on success, or NULL on error */
-void *hash_find(struct hashtable_t *hash, void *keydata) {
+void *hash_find(struct hashtable_t *hash, void *keydata)
+{
 	int index;
 	struct element_t *bucket;
 
@@ -219,7 +224,8 @@
 /* remove bucket (this might be used in hash_iterate() if you already found the bucket
  * you want to delete and don't need the overhead to find it again with hash_remove().
  * But usually, you don't want to use this function, as it fiddles with hash-internals. */
-void *hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t) {
+void *hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t)
+{
 	void *data_save;
 
 	data_save = hash_it_t-&gt;bucket-&gt;data;	/* save the pointer to the data */
@@ -242,7 +248,8 @@
  * so you can remove the used structure yourself, or NULL on error .
  * data could be the structure you use with just the key filled,
  * we just need the key for comparing. */
-void *hash_remove(struct hashtable_t *hash, void *data) {
+void *hash_remove(struct hashtable_t *hash, void *data)
+{
 	struct hash_it_t hash_it_t;
 
 	hash_it_t.index = hash-&gt;choose( data, hash-&gt;size );
@@ -290,7 +297,8 @@
 
 
 /* print the hash table for debugging */
-void hash_debug(struct hashtable_t *hash) {
+void hash_debug(struct hashtable_t *hash)
+{
 	int i;
 	struct element_t *bucket;
 

Modified: trunk/apps/meshs3d/main.c
===================================================================
--- trunk/apps/meshs3d/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/meshs3d/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -40,7 +40,9 @@
 
 /* global vars */
 struct glob Global;
-static struct timespec sleep_time = { 0, 100 * 1000 * 1000 };   /* 100 mili seconds */
+static struct timespec sleep_time = {
+	0, 100 * 1000 * 1000
+};   /* 100 mili seconds */
 
 
 void init_globals( void )
@@ -52,7 +54,7 @@
 	Global.obj_btn_close = 0;
 	Global.obj_s3d_url = 0;
 	Global.obj_zero_point = 0;
-		
+
 }
 
 
@@ -98,17 +100,15 @@
 	struct node *node;
 	struct hash_it_t *hashit;
 
-	if( node_hash-&gt;elements == 0 )
+	if ( node_hash-&gt;elements == 0 )
 		return;
 	hashit = NULL;
-	while ( NULL != ( hashit = hash_iterate( node_hash, hashit ) ) )
-	{
+	while ( NULL != ( hashit = hash_iterate( node_hash, hashit ) ) ) {
 		node = (struct node *) hashit-&gt;bucket-&gt;data;
-		if( node-&gt;node_type_modified ) {
-			
+		if ( node-&gt;node_type_modified ) {
+
 			node-&gt;node_type_modified = 0;
-			if ( node-&gt;obj_id != -1 )
-			{
+			if ( node-&gt;obj_id != -1 ) {
 				s3d_del_object( node-&gt;obj_id );
 			}
 
@@ -131,15 +131,16 @@
 
 void mov_add(float mov[], float p[], float fac)
 {
-/*	if (fac&gt;1000)
-		return;
-	fac=1000; */
+	/*	if (fac&gt;1000)
+			return;
+		fac=1000; */
 	mov[0]+=fac*p[0];
 	mov[1]+=fac*p[1];
 	mov[2]+=fac*p[2];
 }
 
-void move_meshnode( struct node *node ) {
+void move_meshnode( struct node *node )
+{
 	float null_vec[3] = {0,0,0};
 	float tmp_mov_vec[3];
 	float distance;
@@ -155,12 +156,13 @@
 			mov_add( node-&gt;pos_vec, node-&gt;mov_vec, 0.1 );
 
 		s3d_translate( node-&gt;obj_id, node-&gt;pos_vec[0], node-&gt;pos_vec[1], node-&gt;pos_vec[2] );
-			/* reset movement vector */
+		/* reset movement vector */
 		node-&gt;mov_vec[0] = node-&gt;mov_vec[1] = node-&gt;mov_vec[2] = 0.0;
 	}
 }
 
-void calc_node_mov( void ) {
+void calc_node_mov( void )
+{
 
 	float distance;
 	float tmp_mov_vec[3],vertex_buf[6];
@@ -170,28 +172,24 @@
 	struct node *first_node, *sec_node;
 	struct hash_it_t *hashit1, *hashit2;
 
-	if( con_hash-&gt;elements == 0 )
+	if ( con_hash-&gt;elements == 0 )
 		return;
 	hashit1 = hashit2 = NULL;
-	while ( NULL != ( hashit1 = hash_iterate( node_hash, hashit1 ) ) )
-	{
+	while ( NULL != ( hashit1 = hash_iterate( node_hash, hashit1 ) ) ) {
 		first_node = (struct node *) hashit1-&gt;bucket-&gt;data;
-		while ( NULL != ( hashit2 = hash_iterate( node_hash, hashit2 ) ) )
-		{
+		while ( NULL != ( hashit2 = hash_iterate( node_hash, hashit2 ) ) ) {
 			sec_node = (struct node *) hashit2-&gt;bucket-&gt;data;
-			if( first_node != sec_node )
-			{
+			if ( first_node != sec_node ) {
 				ip[0] = max(first_node-&gt;ip, sec_node-&gt;ip);
 				ip[1] = min(first_node-&gt;ip, sec_node-&gt;ip);
 				distance = dirt( first_node-&gt;pos_vec, sec_node-&gt;pos_vec, tmp_mov_vec );
-				if( NULL != ( con = hash_find(con_hash, ip ) ) )
-				{
+				if ( NULL != ( con = hash_find(con_hash, ip ) ) ) {
 					/* we have a connection */
 					f = ( ( con-&gt;etx1_sqrt + con-&gt;etx2_sqrt ) / 4.0 ) / distance;
 					mov_add( first_node-&gt;mov_vec, tmp_mov_vec,  1 / f - 1 );
 					mov_add( sec_node-&gt;mov_vec, tmp_mov_vec, -( 1 / f - 1 ) );
 					printf(&quot;------co---------\n%s %.2f %.2f %.2f\n%s %.2f %.2f %.2f\n&quot;, first_node-&gt;ip_string,first_node-&gt;mov_vec[0],first_node-&gt;mov_vec[1],first_node-&gt;mov_vec[2],
-						sec_node-&gt;ip_string,sec_node-&gt;mov_vec[0],sec_node-&gt;mov_vec[1],sec_node-&gt;mov_vec[2]  );
+					       sec_node-&gt;ip_string,sec_node-&gt;mov_vec[0],sec_node-&gt;mov_vec[1],sec_node-&gt;mov_vec[2]  );
 
 					vertex_buf[0] = first_node-&gt;pos_vec[0];
 					vertex_buf[1] = first_node-&gt;pos_vec[1];
@@ -202,10 +200,10 @@
 					s3d_pep_vertices( con-&gt;obj_id, vertex_buf, 2 );
 
 					s3d_pep_material( con-&gt;obj_id,
-						1.0,1.0,1.0,
-						1.0,1.0,1.0,
-						1.0,1.0,1.0
-					);
+					                  1.0,1.0,1.0,
+					                  1.0,1.0,1.0,
+					                  1.0,1.0,1.0
+					                );
 
 				} else {
 					/* we have no connection */
@@ -213,7 +211,7 @@
 					mov_add( first_node-&gt;mov_vec, tmp_mov_vec, 100 / ( distance * distance ) );
 					mov_add( sec_node-&gt;mov_vec, tmp_mov_vec, -100 / ( distance * distance ) );
 					printf(&quot;------nco---------\n%s %.2f %.2f %.2f\n%s %.2f %.2f %.2f\n&quot;, first_node-&gt;ip_string,first_node-&gt;mov_vec[0],first_node-&gt;mov_vec[1],first_node-&gt;mov_vec[2],
-						sec_node-&gt;ip_string,sec_node-&gt;mov_vec[0],sec_node-&gt;mov_vec[1],sec_node-&gt;mov_vec[2]  );
+					       sec_node-&gt;ip_string,sec_node-&gt;mov_vec[0],sec_node-&gt;mov_vec[1],sec_node-&gt;mov_vec[2]  );
 				}
 				move_meshnode( first_node );
 				move_meshnode( sec_node );
@@ -229,7 +227,7 @@
 		 * small factor: fast and strong drift to neighbours
 		 ***/
 		/* if ( f &lt; Factor ) f = Factor; */
-		
+
 	}
 
 }
@@ -254,10 +252,11 @@
 }
 
 
-int main( int argc, char *argv[] ) {
+int main( int argc, char *argv[] )
+{
 	int optchar;
 	char olsr_host[256];
-	
+
 	init_globals();
 	strncpy( olsr_host, &quot;127.0.0.1&quot;, 256 );
 	lbuf[0] = '\0';
@@ -266,18 +265,18 @@
 
 		switch ( optchar ) {
 
-			case 'd':
-				Global.debug = 1;
-				break;
+		case 'd':
+			Global.debug = 1;
+			break;
 
-			case 'H':
-				strncpy( olsr_host, optarg, 256 );
-				break;
+		case 'H':
+			strncpy( olsr_host, optarg, 256 );
+			break;
 
-			case 'h':
-			default:
-				print_usage();
-				return (0);
+		case 'h':
+		default:
+			print_usage();
+			return (0);
 
 		}
 
@@ -301,15 +300,13 @@
 
 	process_init();
 
-	if (!net_init(olsr_host))
-	{
+	if (!net_init(olsr_host)) {
 		/* s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
 		s3d_set_callback(S3D_EVENT_KEY,keypress);
 		s3d_set_callback(S3D_EVENT_QUIT,stop); */
 
-		if (!s3d_init(&amp;argc,&amp;argv,&quot;meshs3d&quot;))
-		{
+		if (!s3d_init(&amp;argc,&amp;argv,&quot;meshs3d&quot;)) {
 
 			if (s3d_select_font(&quot;vera&quot;))
 				printf(&quot;font not found\n&quot;);

Modified: trunk/apps/meshs3d/meshs3d.h
===================================================================
--- trunk/apps/meshs3d/meshs3d.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/meshs3d/meshs3d.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -30,8 +30,7 @@
 #define MAXDATASIZE 100			/* max number of bytes we can get at once  */
 
 /* linked list for the all connections */
-struct node_con
-{
+struct node_con {
 	unsigned int ip[2];
 	float etx1;							/* etx of left olsr node */
 	float etx2;						/* etx of right olsr node */
@@ -43,16 +42,14 @@
 };
 
 /* linked list for the neighbours of each olsr node */
-struct olsr_neigh_list
-{
+struct olsr_neigh_list {
 	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
 	struct olsr_con *olsr_con;							/* pointer to the connection */
 };
 
 
 /* we contruct a binary tree to handle the nodes */
-struct node 
-{
+struct node {
 	unsigned int ip;
 	char ip_string[NAMEMAX];		/* host ip */
 	int node_type;					/* normal = 0, internet gateway = 1, via hna announced network = 2 */
@@ -67,8 +64,7 @@
 };
 
 
-struct obj_to_ip
-{
+struct obj_to_ip {
 	int id;
 	struct olsr_node *olsr_node;
 	struct obj_to_ip *next;

Modified: trunk/apps/meshs3d/net.c
===================================================================
--- trunk/apps/meshs3d/net.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/meshs3d/net.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -43,36 +43,37 @@
 
 int net_init(char *host)
 {
-    struct hostent *he;
-    struct sockaddr_in their_addr; /* connector's address information  */
+	struct hostent *he;
+	struct sockaddr_in their_addr; /* connector's address information  */
 
-    if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
-        herror(&quot;gethostbyname&quot;);
-        return(1);
-    }
+	if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
+		herror(&quot;gethostbyname&quot;);
+		return(1);
+	}
 
-    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
-        perror(&quot;socket&quot;);
-        return(1);
-    }
+	if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
+		perror(&quot;socket&quot;);
+		return(1);
+	}
 
-    their_addr.sin_family = AF_INET;    /* host byte order  */
-    their_addr.sin_port = htons(PORT);  /* short, network byte order  */
-    their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
-    memset(&amp;(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
+	their_addr.sin_family = AF_INET;    /* host byte order  */
+	their_addr.sin_port = htons(PORT);  /* short, network byte order  */
+	their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
+	memset(&amp;(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
 
-    if (connect(sockfd, (struct sockaddr *)&amp;their_addr,
-                                          sizeof(struct sockaddr)) == -1) {
-        perror(&quot;connect&quot;);
-        return(1);
-    }
+	if (connect(sockfd, (struct sockaddr *)&amp;their_addr,
+	                sizeof(struct sockaddr)) == -1) {
+		perror(&quot;connect&quot;);
+		return(1);
+	}
 	fcntl(sockfd,F_SETFL, O_NONBLOCK);
 	return(0);
 }
 
-int net_main() {
+int net_main()
+{
 	static int net_read_count = 0;
-	
+
 	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
 		if (errno==EAGAIN)
 			return(0); /* well, that's okay ... */
@@ -122,9 +123,9 @@
 
 int net_quit()
 {
-    close(sockfd);
+	close(sockfd);
 
-    return 0;
+	return 0;
 }
 
 

Modified: trunk/apps/meshs3d/process.c
===================================================================
--- trunk/apps/meshs3d/process.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/meshs3d/process.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -57,8 +57,7 @@
 	uint32_t hash = 0;
 	size_t i;
 
-	for (i = 0; i &lt; 8; i++)
-	{
+	for (i = 0; i &lt; 8; i++) {
 		hash += key[i];
 		hash += (hash &lt;&lt; 10);
 		hash ^= (hash &gt;&gt; 6);
@@ -124,8 +123,7 @@
 	ip[1] = min(ip1,ip2);
 
 	con = ( struct node_con* ) hash_find( con_hash, ip);
-	if( con == NULL )
-	{
+	if ( con == NULL ) {
 		con = ( struct node_con * ) debugMalloc( sizeof( struct node_con ), 102 );
 		con-&gt;ip[0] = ip[0];
 		con-&gt;ip[1] = ip[1];
@@ -139,8 +137,7 @@
 		hash_add( con_hash, con );
 	}
 
-	if( con-&gt;ip[0] == ip1 )
-	{
+	if ( con-&gt;ip[0] == ip1 ) {
 		con-&gt;etx1 = etx;
 		con-&gt;etx1_sqrt = sqrt( etx );
 	} else {
@@ -149,8 +146,7 @@
 	}
 
 
-	if ( con_hash-&gt;elements * 4 &gt; con_hash-&gt;size )
-	{
+	if ( con_hash-&gt;elements * 4 &gt; con_hash-&gt;size ) {
 		swaphash = hash_resize( con_hash, con_hash-&gt;size * 2 );
 		if ( swaphash == NULL )
 			exit_error(&quot;Couldn't resize hash table \n&quot;);
@@ -164,8 +160,7 @@
 	struct node *orig_node;
 	struct hashtable_t *swaphash;
 
-	if ( node_hash-&gt;elements * 4 &gt; node_hash-&gt;size )
-	{
+	if ( node_hash-&gt;elements * 4 &gt; node_hash-&gt;size ) {
 		swaphash = hash_resize( node_hash, node_hash-&gt;size * 2 );
 		if ( swaphash == NULL )
 			exit_error(&quot;Couldn't resize hash table \n&quot; );
@@ -173,8 +168,7 @@
 	}
 	orig_node = (struct node *) hash_find( node_hash, ip );
 
-	if( NULL == orig_node )
-	{
+	if ( NULL == orig_node ) {
 		orig_node = (struct node *)debugMalloc( sizeof(struct node), 101 );
 		orig_node-&gt;ip = *ip;
 		strncpy( orig_node-&gt;ip_string, ip_string, NAMEMAX );
@@ -213,63 +207,55 @@
 	dn = 0;
 
 
-	while ( (*lbuf_ptr) != '\0' )
-	{
-		if ( (*lbuf_ptr) == '\n' )
-		{
+	while ( (*lbuf_ptr) != '\0' ) {
+		if ( (*lbuf_ptr) == '\n' ) {
 			last_cr_ptr = lbuf_ptr;
 			con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
 			dn = 0;
 		}
 
-		if ( (*lbuf_ptr) == '&quot;' )
-		{
-			switch ( dn )
-			{
-				case 0:
-					con_from = lbuf_ptr + 1;
-					break;
-				case 1:
-					con_from_end = lbuf_ptr;
-					break;
-				case 2:
-					con_to = lbuf_ptr + 1;
-					break;
-				case 3:
-					con_to_end = lbuf_ptr;
-					break;
-				case 4:
-					etx = lbuf_ptr + 1;
-					break;
-				case 5:
-					etx_end = lbuf_ptr;
-					break;
+		if ( (*lbuf_ptr) == '&quot;' ) {
+			switch ( dn ) {
+			case 0:
+				con_from = lbuf_ptr + 1;
+				break;
+			case 1:
+				con_from_end = lbuf_ptr;
+				break;
+			case 2:
+				con_to = lbuf_ptr + 1;
+				break;
+			case 3:
+				con_to_end = lbuf_ptr;
+				break;
+			case 4:
+				etx = lbuf_ptr + 1;
+				break;
+			case 5:
+				etx_end = lbuf_ptr;
+				break;
 			}
 
-			if ( ++dn == 6 )
-			{
+			if ( ++dn == 6 ) {
 
 				(*con_from_end) = (*con_to_end) = (*etx_end) = '\0';
 
 				/* if( Global.debug ) printf( &quot;con_from: %s, con_to: %s, etx: %s\n&quot;, con_from, con_to, etx ); */
 
 				/* announced network via HNA */
-				if ( strncmp( etx, &quot;HNA&quot;, NAMEMAX ) == 0 )
-				{
+				if ( strncmp( etx, &quot;HNA&quot;, NAMEMAX ) == 0 ) {
 
 				} else {
 
 					f = strtod(etx,NULL);
 					if ( f &lt; 1.0 )
 						f = 999.0;
-				
-					if( inet_pton(AF_INET, con_from, &amp;int_con_from ) &lt; 1 )
-					{
+
+					if ( inet_pton(AF_INET, con_from, &amp;int_con_from ) &lt; 1 ) {
 						printf(&quot;%s is not a valid ip address\n&quot;, con_from );
 						continue;
 					}
-					if( inet_pton(AF_INET, con_to, &amp;int_con_to ) &lt; 1 )
-					{
+					if ( inet_pton(AF_INET, con_to, &amp;int_con_to ) &lt; 1 ) {
 						printf(&quot;%s is not a valid ip address\n&quot;, con_to );
 						continue;
 					}

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/olsrs3d/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -41,7 +41,9 @@
 
 #define SPEED		10.0
 
-static struct timespec sleep_time = { 0, 100 * 1000 * 1000 };   /* 100 mili seconds */
+static struct timespec sleep_time = {
+	0, 100 * 1000 * 1000
+};   /* 100 mili seconds */
 
 int Debug = 0;
 
@@ -96,7 +98,8 @@
  *
  ***/
 
-void print_usage( void ) {
+void print_usage( void )
+{
 
 	printf( &quot;Usage is olsrs3d [options] [-- [s3d options]]\n&quot; );
 	printf( &quot;olsrs3d options:\n&quot; );
@@ -108,13 +111,15 @@
 }
 
 
-void close_win(s3dw_widget *button) {
+void close_win(s3dw_widget *button)
+{
 	s3dw_delete(button-&gt;parent); /* parent =surface. this means close containing window */
 }
 
 
 
-void window_help() {
+void window_help()
+{
 
 	s3dw_surface *infwin;
 	s3dw_button  *button;
@@ -149,7 +154,8 @@
 }
 
 
-void window_error(char *msg) {
+void window_error(char *msg)
+{
 
 	s3dw_surface *infwin;
 	s3dw_button  *button;
@@ -170,7 +176,8 @@
  *
  ***/
 
-void out_of_mem( void ) {
+void out_of_mem( void )
+{
 
 	printf( &quot;Sorry - you ran out of memory !\n&quot; );
 	exit(8);
@@ -179,7 +186,8 @@
 
 
 
-unsigned int get_time(void) {
+unsigned int get_time(void)
+{
 
 	struct timeval tv;
 
@@ -258,9 +266,9 @@
 
 void mov_add(float mov[], float p[], float fac)
 {
-/*	if (fac&gt;1000)
-		return;
-	fac=1000; */
+	/*	if (fac&gt;1000)
+			return;
+		fac=1000; */
 	mov[0]+=fac*p[0];
 	mov[1]+=fac*p[1];
 	mov[2]+=fac*p[2];
@@ -276,7 +284,8 @@
  *
  ***/
 
-void handle_olsr_node( struct olsr_node *olsr_node ) {
+void handle_olsr_node( struct olsr_node *olsr_node )
+{
 
 	float distance, angle, angle_rad;
 	float tmp_mov_vec[3], desc_norm_vec[3] = {0,0,-1};
@@ -489,7 +498,8 @@
  *
  ***/
 
-void calc_olsr_node_mov( void ) {
+void calc_olsr_node_mov( void )
+{
 
 	float distance;
 	float tmp_mov_vec[3];
@@ -524,7 +534,8 @@
  *
  ***/
 
-void move_olsr_nodes( void ) {
+void move_olsr_nodes( void )
+{
 
 	float null_vec[3] = {0,0,0}, vertex_buf[6];
 	float tmp_mov_vec[3];
@@ -590,11 +601,11 @@
 			/* HNA */
 			if ( olsr_con-&gt;left_etx == -1000.00 ) {
 
-				if(olsr_con-&gt;color != 1) {
+				if (olsr_con-&gt;color != 1) {
 					s3d_pep_material( olsr_con-&gt;obj_id,
-								   0.0,0.0,1.0,
-								   0.0,0.0,1.0,
-								   0.0,0.0,1.0);
+					                  0.0,0.0,1.0,
+					                  0.0,0.0,1.0,
+					                  0.0,0.0,1.0);
 					olsr_con-&gt;color = 1;
 				}
 
@@ -605,82 +616,82 @@
 				/* very good link - bright blue */
 				if ( ( etx &gt;= 1.0 ) &amp;&amp; ( etx &lt; 1.5 ) ) {
 
-					if(olsr_con-&gt;color != 2) {
+					if (olsr_con-&gt;color != 2) {
 						s3d_pep_material( olsr_con-&gt;obj_id,
-								0.5,1.0,1.0,
-								0.5,1.0,1.0,
-								0.5,1.0,1.0);
+						                  0.5,1.0,1.0,
+						                  0.5,1.0,1.0,
+						                  0.5,1.0,1.0);
 						olsr_con-&gt;color = 2;
 					}
 
-				/* good link - bright yellow */
+					/* good link - bright yellow */
 				} else if ( ( etx &gt;= 1.5 ) &amp;&amp; ( etx &lt; 2.0 ) ) {
 
 					rgb = 2.0 - etx;
-					if( olsr_con-&gt;color != 3 || (olsr_con-&gt;color == 3 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10))) {
+					if ( olsr_con-&gt;color != 3 || (olsr_con-&gt;color == 3 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10))) {
 						s3d_pep_material( olsr_con-&gt;obj_id,
-								1.0,1.0,rgb,
-								1.0,1.0,rgb,
-								1.0,1.0,rgb);
+						                  1.0,1.0,rgb,
+						                  1.0,1.0,rgb,
+						                  1.0,1.0,rgb);
 						olsr_con-&gt;color = 3;
 
 						olsr_con-&gt;rgb =  rgb;
 					}
 
-				/* not so good link - orange */
+					/* not so good link - orange */
 				} else if ( ( etx &gt;= 2.0 ) &amp;&amp; ( etx &lt; 3.0 ) ) {
 
 					rgb = 1.5 - ( etx / 2.0 );
-					if( olsr_con-&gt;color != 4 || (olsr_con-&gt;color == 4 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10))) {
+					if ( olsr_con-&gt;color != 4 || (olsr_con-&gt;color == 4 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10))) {
 						s3d_pep_material( olsr_con-&gt;obj_id,
-								1.0,rgb,0.0,
-								1.0,rgb,0.0,
-								1.0,rgb,0.0);
+						                  1.0,rgb,0.0,
+						                  1.0,rgb,0.0,
+						                  1.0,rgb,0.0);
 						olsr_con-&gt;color = 4;
 
 						olsr_con-&gt;rgb = rgb;
 					}
 
-				/* bad link (almost dead) - brown */
+					/* bad link (almost dead) - brown */
 				} else if ( ( etx &gt;= 3.0 ) &amp;&amp; ( etx &lt; 5.0 ) ) {
 
 					rgb = 1.75 - ( etx / 4.0 );
 
-					if( olsr_con-&gt;color != 5 || (olsr_con-&gt;color == 5 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10)) ) {
+					if ( olsr_con-&gt;color != 5 || (olsr_con-&gt;color == 5 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10)) ) {
 
 						s3d_pep_material( olsr_con-&gt;obj_id,
-								rgb,rgb - 0.5,0.0,
-								rgb,rgb - 0.5,0.0,
-								rgb,rgb - 0.5,0.0);
+						                  rgb,rgb - 0.5,0.0,
+						                  rgb,rgb - 0.5,0.0,
+						                  rgb,rgb - 0.5,0.0);
 						olsr_con-&gt;color = 5;
 
 						olsr_con-&gt;rgb = rgb;
 					}
 
-				/* zombie link - grey */
+					/* zombie link - grey */
 				} else if ( ( etx &gt;= 5.0 ) &amp;&amp; ( etx &lt; 1000.0 ) ) {
 
 					rgb = 1000.0 / ( 1500.0 + etx );
 
-					if( olsr_con-&gt;color != 6 || (olsr_con-&gt;color == 6 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10)) ) {
+					if ( olsr_con-&gt;color != 6 || (olsr_con-&gt;color == 6 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10)) ) {
 
 						s3d_pep_material( olsr_con-&gt;obj_id,
-								rgb,rgb,rgb,
-								rgb,rgb,rgb,
-								rgb,rgb,rgb);
+						                  rgb,rgb,rgb,
+						                  rgb,rgb,rgb,
+						                  rgb,rgb,rgb);
 						olsr_con-&gt;color = 6;
 
 						olsr_con-&gt;rgb = rgb;
 					}
 
-				/* wtf - dark grey */
+					/* wtf - dark grey */
 				} else {
 
-					if(olsr_con-&gt;color != 7) {
+					if (olsr_con-&gt;color != 7) {
 						s3d_pep_material( olsr_con-&gt;obj_id,
-								0.3,0.3,0.3,
-								0.3,0.3,0.3,
-								0.3,0.3,0.3);
+						                  0.3,0.3,0.3,
+						                  0.3,0.3,0.3,
+						                  0.3,0.3,0.3);
 						olsr_con-&gt;color = 7;
 					}
 
@@ -690,11 +701,11 @@
 
 		} else {
 
-			if(olsr_con-&gt;color != 0) {
+			if (olsr_con-&gt;color != 0) {
 				s3d_pep_material( olsr_con-&gt;obj_id,
-							1.0,1.0,1.0,
-							1.0,1.0,1.0,
-							1.0,1.0,1.0);
+				                  1.0,1.0,1.0,
+				                  1.0,1.0,1.0,
+				                  1.0,1.0,1.0);
 				olsr_con-&gt;color = 0;
 			}
 
@@ -709,7 +720,8 @@
 
 
 
-void mainloop() {
+void mainloop()
+{
 
 	int net_result;   /* result of function net_main */
 	char nc_str[20];
@@ -755,7 +767,7 @@
 	}
 
 	/* rotate modus */
-	if(RotateSwitch) {
+	if (RotateSwitch) {
 		Zp_rotate = ( Zp_rotate + RotateSpeed ) &gt; 360 ? 0.0 : ( Zp_rotate + RotateSpeed );
 		s3d_rotate(ZeroPoint,0,Zp_rotate,0);
 	}
@@ -766,16 +778,15 @@
 	CamPosition2[0][2]=  CamPosition[0][0]*sin(Zp_rotate*M_PI/180.0) + CamPosition[0][2] * cos (Zp_rotate*M_PI/180.0);
 
 	/* check search status */
-/*	if( get_search_status() == WIDGET )
-		move_to_search_widget( CamPosition[0], CamPosition[1] );*/
-	if( get_search_status() == FOLLOW )
+	/*	if( get_search_status() == WIDGET )
+			move_to_search_widget( CamPosition[0], CamPosition[1] );*/
+	if ( get_search_status() == FOLLOW )
 		follow_node( CamPosition[0], CamPosition[1], Zp_rotate );
-/*	if( get_search_status() == ABORT )
-		move_to_return_point( CamPosition[0], CamPosition[1] );*/
+	/*	if( get_search_status() == ABORT )
+			move_to_return_point( CamPosition[0], CamPosition[1] );*/
 
 
-	if( Olsr_ip_label_obj != -1 )
-	{
+	if ( Olsr_ip_label_obj != -1 ) {
 		print_etx();
 	}
 	s3dw_ani_mate();
@@ -786,7 +797,8 @@
 
 }
 
-int stop() {
+int stop()
+{
 	s3d_quit();
 	net_quit();
 	return(0);
@@ -798,90 +810,86 @@
  *
  ***/
 
-int keypress(struct s3d_evt *event) {
+int keypress(struct s3d_evt *event)
+{
 
 	struct s3d_key_event *key=(struct s3d_key_event *)event-&gt;buf;
-	if( get_search_status() != WIDGET )
-	{
-		switch(key-&gt;keysym)
-		{
-			case S3DK_F1: /* help */
+	if ( get_search_status() != WIDGET ) {
+		switch (key-&gt;keysym) {
+		case S3DK_F1: /* help */
 
-				window_help();
-				break;
+			window_help();
+			break;
 
-			case S3DK_ESCAPE: /* abort action */
+		case S3DK_ESCAPE: /* abort action */
 
-				set_search_status( get_search_status() == WIDGET ? ABORT : NOTHING );
-				break;
+			set_search_status( get_search_status() == WIDGET ? ABORT : NOTHING );
+			break;
 
-			case S3DK_s: /* move to search widget, give widget focus */
+		case S3DK_s: /* move to search widget, give widget focus */
 
-				set_search_status(WIDGET);							/* set status for mainloop */
-				set_node_root( Olsr_root );
-				show_search_window();
-/*				set_return_point(CamPosition[0],CamPosition[1]);	/ * save the return position * /
-				set_node_root( Olsr_root );*/
+			set_search_status(WIDGET);							/* set status for mainloop */
+			set_node_root( Olsr_root );
+			show_search_window();
+			/*				set_return_point(CamPosition[0],CamPosition[1]);	/ * save the return position * /
+							set_node_root( Olsr_root );*/
 
-				break;
+			break;
 
-			case S3DK_c: /* color on/off */
+		case S3DK_c: /* color on/off */
 
-				ColorSwitch =  ColorSwitch ? 0 : 1;
-				break;
+			ColorSwitch =  ColorSwitch ? 0 : 1;
+			break;
 
-			case S3DK_r: /* rotate start/stop*/
+		case S3DK_r: /* rotate start/stop*/
 
-				RotateSwitch = RotateSwitch ? 0 : 1;
-				break;
+			RotateSwitch = RotateSwitch ? 0 : 1;
+			break;
 
-			case S3DK_PLUS: /* rotate speed increase */
+		case S3DK_PLUS: /* rotate speed increase */
 
-				if(RotateSwitch &amp;&amp; RotateSpeed &lt; 5)
-				{
-					if(RotateSpeed &gt;= 1.0)
-						RotateSpeed += 1.0;
-					else
-						RotateSpeed += 0.1;
-				}
-				break;
+			if (RotateSwitch &amp;&amp; RotateSpeed &lt; 5) {
+				if (RotateSpeed &gt;= 1.0)
+					RotateSpeed += 1.0;
+				else
+					RotateSpeed += 0.1;
+			}
+			break;
 
-			case S3DK_MINUS: /* - -&gt; rotate speed decrease */
+		case S3DK_MINUS: /* - -&gt; rotate speed decrease */
 
-				if(RotateSwitch)
-				{
-					if( RotateSpeed &gt;= 2.0 )
-						RotateSpeed -= 1.0;
-					else {
-						if(RotateSpeed &gt; 0.2)
-							RotateSpeed -= 0.1;
-					}
+			if (RotateSwitch) {
+				if ( RotateSpeed &gt;= 2.0 )
+					RotateSpeed -= 1.0;
+				else {
+					if (RotateSpeed &gt; 0.2)
+						RotateSpeed -= 0.1;
 				}
-				break;
+			}
+			break;
 
-			case S3DK_p: /* strg + p -&gt; reset nodes ( zeroPoint to 0,0,0 ) */
-				if (key-&gt;modifier&amp;(S3D_KMOD_LCTRL|S3D_KMOD_RCTRL))
-				{
-					s3d_rotate(ZeroPoint, 0, 0, 0);
-					Zp_rotate = 0.0;
-				}
-				break;
+		case S3DK_p: /* strg + p -&gt; reset nodes ( zeroPoint to 0,0,0 ) */
+			if (key-&gt;modifier&amp;(S3D_KMOD_LCTRL|S3D_KMOD_RCTRL)) {
+				s3d_rotate(ZeroPoint, 0, 0, 0);
+				Zp_rotate = 0.0;
+			}
+			break;
 
-			case S3DK_PAGEUP: /* change factor in calc_olsr_node_mov */
+		case S3DK_PAGEUP: /* change factor in calc_olsr_node_mov */
 
-				if(Factor &lt; 0.9)
-					Factor += 0.1;
-				break;
+			if (Factor &lt; 0.9)
+				Factor += 0.1;
+			break;
 
-			case S3DK_PAGEDOWN: /* change factor in calc_olsr_node_mov */
+		case S3DK_PAGEDOWN: /* change factor in calc_olsr_node_mov */
 
-				if(Factor &gt; 0.3)
-					Factor -= 0.1;
-				break;
+			if (Factor &gt; 0.3)
+				Factor -= 0.1;
+			break;
 
 		}
 	} else {
-		if( (key-&gt;keysym &gt;= S3DK_PERIOD &amp;&amp; key-&gt;keysym &lt;= S3DK_9) || key-&gt;keysym == S3DK_COMMA || key-&gt;keysym == S3DK_RETURN || key-&gt;keysym == S3DK_BACKSPACE )
+		if ( (key-&gt;keysym &gt;= S3DK_PERIOD &amp;&amp; key-&gt;keysym &lt;= S3DK_9) || key-&gt;keysym == S3DK_COMMA || key-&gt;keysym == S3DK_RETURN || key-&gt;keysym == S3DK_BACKSPACE )
 			search_widget_write( key-&gt;keysym );
 	}
 	return(0);
@@ -895,18 +903,18 @@
 
 int object_click(struct s3d_evt *evt)
 {
-/*	int i
-	char ip_str[50];
-	struct timeval tv;*/
+	/*	int i
+		char ip_str[50];
+		struct timeval tv;*/
 	struct olsr_node *olsr_node;
 	int oid;
 
 	s3dw_handle_click(evt);
-/*	if( get_search_status() == WIDGET )
-	{
-		s3dw_handle_click(evt);
-		return;
-	}*/
+	/*	if( get_search_status() == WIDGET )
+		{
+			s3dw_handle_click(evt);
+			return;
+		}*/
 
 	oid=(int)*((uint32_t *)evt-&gt;buf);
 
@@ -924,55 +932,55 @@
 	Last_Click_Time = get_time();
 
 
-/*	if( oid == Btn_close_id )
-	{
-		s3d_del_object(Btn_close_id);
-		s3d_del_object(Olsr_ip_label_obj);
-		Btn_close_id = Olsr_ip_label_obj = -1;
-		for(i=0; i &lt; Size; i++)
-			s3d_del_object( Olsr_neighbour_label_obj[i] );
-		free(Olsr_neighbour_label_obj);
-		Olsr_neighbour_label_obj = NULL;
-		for(i = 0; i &lt; 4; i++)
+	/*	if( oid == Btn_close_id )
 		{
-			if(Output_border[i] != -1)
-				s3d_del_object(Output_border[i]);
-			Output_border[i] = -1;
+			s3d_del_object(Btn_close_id);
+			s3d_del_object(Olsr_ip_label_obj);
+			Btn_close_id = Olsr_ip_label_obj = -1;
+			for(i=0; i &lt; Size; i++)
+				s3d_del_object( Olsr_neighbour_label_obj[i] );
+			free(Olsr_neighbour_label_obj);
+			Olsr_neighbour_label_obj = NULL;
+			for(i = 0; i &lt; 4; i++)
+			{
+				if(Output_border[i] != -1)
+					s3d_del_object(Output_border[i]);
+				Output_border[i] = -1;
+			}
+			return;
 		}
-		return;
-	}
 
-	Olsr_node_pEtx = *lst_search(oid);
+		Olsr_node_pEtx = *lst_search(oid);
 
-	if( Olsr_node_pEtx != NULL )
-	{
-		if( Btn_close_id == -1 )
+		if( Olsr_node_pEtx != NULL )
 		{
-			Btn_close_id = s3d_clone( Btn_close_obj );
-			s3d_link(Btn_close_id,0);
-			s3d_flags_on(Btn_close_id,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_scale( Btn_close_id, 0.10 );
-			s3d_translate( Btn_close_id,-Left*3.0-0.150, -Bottom*3.0-0.9, -3.0 );
-		}
+			if( Btn_close_id == -1 )
+			{
+				Btn_close_id = s3d_clone( Btn_close_obj );
+				s3d_link(Btn_close_id,0);
+				s3d_flags_on(Btn_close_id,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+				s3d_scale( Btn_close_id, 0.10 );
+				s3d_translate( Btn_close_id,-Left*3.0-0.150, -Bottom*3.0-0.9, -3.0 );
+			}
 
-		if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
-		snprintf( ip_str, 35, &quot;ip: %s&quot;, Olsr_node_pEtx-&gt;ip );
-		Olsr_ip_label_obj = s3d_draw_string( ip_str, &amp;Title_len );
-		s3d_link( Olsr_ip_label_obj, 0 );
-		s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_ip_label_obj, 0.2 );
-		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.2, -3.0 );
+			if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
+			snprintf( ip_str, 35, &quot;ip: %s&quot;, Olsr_node_pEtx-&gt;ip );
+			Olsr_ip_label_obj = s3d_draw_string( ip_str, &amp;Title_len );
+			s3d_link( Olsr_ip_label_obj, 0 );
+			s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
+			s3d_scale( Olsr_ip_label_obj, 0.2 );
+			s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.2, -3.0 );
 
-		cam_go=1;
-		if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
-		snprintf( ip_str, 35, &quot;ip: %s&quot;, Olsr_node_pEtx-&gt;ip );
-		Olsr_ip_label_obj = s3d_draw_string( ip_str, &amp;Title_len );
-		s3d_link( Olsr_ip_label_obj, 0 );
-		s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_ip_label_obj, 0.2 );
-		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
+			cam_go=1;
+			if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
+			snprintf( ip_str, 35, &quot;ip: %s&quot;, Olsr_node_pEtx-&gt;ip );
+			Olsr_ip_label_obj = s3d_draw_string( ip_str, &amp;Title_len );
+			s3d_link( Olsr_ip_label_obj, 0 );
+			s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
+			s3d_scale( Olsr_ip_label_obj, 0.2 );
+			s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
 
-	}*/
+		}*/
 	return(0);
 }
 
@@ -983,10 +991,9 @@
 	int i;
 	float len = 0.0, max_len=0.0;
 
-	if( Olsr_neighbour_label_obj != NULL )
-	{
+	if ( Olsr_neighbour_label_obj != NULL ) {
 		/* int n = sizeof(Olsr_neighbour_label_obj) / sizeof(int);*/
-		for(i=0; i &lt; Size; i++)
+		for (i=0; i &lt; Size; i++)
 			s3d_del_object( Olsr_neighbour_label_obj[i] );
 		free(Olsr_neighbour_label_obj);
 		Olsr_neighbour_label_obj = NULL;
@@ -995,8 +1002,7 @@
 	tmpNeighbour = Olsr_node_pEtx-&gt;olsr_neigh_list;
 
 	Size = 0;
-	while(tmpNeighbour != NULL)
-	{
+	while (tmpNeighbour != NULL) {
 		Size++;
 		tmpNeighbour = tmpNeighbour-&gt;next_olsr_neigh_list;
 	}
@@ -1004,12 +1010,11 @@
 	Olsr_neighbour_label_obj = malloc(Size*sizeof(int));
 	tmpNeighbour = Olsr_node_pEtx-&gt;olsr_neigh_list;
 
-	for(i = 0; i &lt; Size ;i++)
-	{
+	for (i = 0; i &lt; Size ;i++) {
 		char nIpStr[60];
 		float mEtx = ( tmpNeighbour-&gt;olsr_con-&gt;left_etx + tmpNeighbour-&gt;olsr_con-&gt;right_etx ) / 2;
 
-		if( mEtx != -1000 )
+		if ( mEtx != -1000 )
 			snprintf(nIpStr, 60, &quot;%15s --&gt; %.2f&quot;,(strcmp(Olsr_node_pEtx-&gt;ip,tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip)?tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip:tmpNeighbour-&gt;olsr_con-&gt;left_olsr_node-&gt;ip),mEtx);
 		else
 			snprintf(nIpStr, 60, &quot;%15s --&gt; HNA&quot;,(strcmp(Olsr_node_pEtx-&gt;ip,tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip)?tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip:tmpNeighbour-&gt;olsr_con-&gt;left_olsr_node-&gt;ip));
@@ -1026,17 +1031,14 @@
 		/* printf(&quot;title: %f len: %f maxlen: %f %s\n&quot;,Title_len,len,max_len-0.2,nIpStr);*/
 	}
 
-	if( Btn_close_id != -1)
-	{
-		if( Output_border[0] == -1 )
-		{
-			for(i = 0; i &lt; 4; i++)
-			{
+	if ( Btn_close_id != -1) {
+		if ( Output_border[0] == -1 ) {
+			for (i = 0; i &lt; 4; i++) {
 				Output_border[i] = s3d_new_object();
 				s3d_push_material( Output_border[i],
-					1.0,1.0,1.0,
-					1.0,1.0,1.0,
-					1.0,1.0,1.0);
+				                   1.0,1.0,1.0,
+				                   1.0,1.0,1.0,
+				                   1.0,1.0,1.0);
 			}
 			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,			-Bottom*3.0-0.9, -3.0);
 			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
@@ -1098,8 +1100,7 @@
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
 	s3dw_object_info(hrmz);
-	if (inf-&gt;object==0)
-	{
+	if (inf-&gt;object==0) {
 		CamPosition[0][0] = inf-&gt;trans_x;
 		CamPosition[0][1] = inf-&gt;trans_y;
 		CamPosition[0][2] = inf-&gt;trans_z;
@@ -1107,8 +1108,7 @@
 		CamPosition[1][1] = inf-&gt;rot_y;
 		CamPosition[1][2] = inf-&gt;rot_z;
 		Asp=inf-&gt;scale;
-		if (Asp&gt;1.0) /* wide screen */
-		{
+		if (Asp&gt;1.0) { /* wide screen */
 			Bottom=-1.0;
 			Left=-Asp;
 		} else {  /* high screen */
@@ -1130,7 +1130,8 @@
 	return(0);
 }
 
-int main( int argc, char *argv[] ) {
+int main( int argc, char *argv[] )
+{
 
 	int optchar;
 	strncpy( Olsr_host, &quot;127.0.0.1&quot;, 256 );
@@ -1140,18 +1141,18 @@
 
 		switch ( optchar ) {
 
-			case 'd':
-				Debug = 1;
-				break;
+		case 'd':
+			Debug = 1;
+			break;
 
-			case 'H':
-				strncpy( Olsr_host, optarg, 256 );
-				break;
+		case 'H':
+			strncpy( Olsr_host, optarg, 256 );
+			break;
 
-			case 'h':
-			default:
-				print_usage();
-				return (0);
+		case 'h':
+		default:
+			print_usage();
+			return (0);
 
 		}
 
@@ -1174,15 +1175,13 @@
 	optind = 0;
 
 
-	if (!net_init(Olsr_host))
-	{
+	if (!net_init(Olsr_host)) {
 		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
 		s3d_set_callback(S3D_EVENT_KEY,keypress);
 		s3d_set_callback(S3D_EVENT_QUIT,stop);
 
-		if (!s3d_init(&amp;argc,&amp;argv,&quot;olsrs3d&quot;))
-		{
+		if (!s3d_init(&amp;argc,&amp;argv,&quot;olsrs3d&quot;)) {
 
 			if (s3d_select_font(&quot;vera&quot;))
 				printf(&quot;font not found\n&quot;);

Modified: trunk/apps/olsrs3d/net.c
===================================================================
--- trunk/apps/olsrs3d/net.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/olsrs3d/net.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -44,34 +44,35 @@
 int sockfd, numbytes;
 int net_init(char *host)
 {
-    struct hostent *he;
-    struct sockaddr_in their_addr; /* connector's address information  */
+	struct hostent *he;
+	struct sockaddr_in their_addr; /* connector's address information  */
 
-    if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
-        herror(&quot;gethostbyname&quot;);
-        return(1);
-    }
+	if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
+		herror(&quot;gethostbyname&quot;);
+		return(1);
+	}
 
-    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
-        perror(&quot;socket&quot;);
-        return(1);
-    }
+	if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
+		perror(&quot;socket&quot;);
+		return(1);
+	}
 
-    their_addr.sin_family = AF_INET;    /* host byte order  */
-    their_addr.sin_port = htons(PORT);  /* short, network byte order  */
-    their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
-    memset(&amp;(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
+	their_addr.sin_family = AF_INET;    /* host byte order  */
+	their_addr.sin_port = htons(PORT);  /* short, network byte order  */
+	their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
+	memset(&amp;(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
 
-    if (connect(sockfd, (struct sockaddr *)&amp;their_addr,
-                                          sizeof(struct sockaddr)) == -1) {
-        perror(&quot;connect&quot;);
-        return(1);
-    }
+	if (connect(sockfd, (struct sockaddr *)&amp;their_addr,
+	                sizeof(struct sockaddr)) == -1) {
+		perror(&quot;connect&quot;);
+		return(1);
+	}
 	fcntl(sockfd,F_SETFL, O_NONBLOCK);
 	return(0);
 }
 
-int net_main() {
+int net_main()
+{
 
 	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
 		if (errno==EAGAIN)
@@ -121,9 +122,9 @@
 
 int net_quit()
 {
-    close(sockfd);
+	close(sockfd);
 
-    return 0;
+	return 0;
 }
 
 

Modified: trunk/apps/olsrs3d/process.c
===================================================================
--- trunk/apps/olsrs3d/process.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/olsrs3d/process.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -50,7 +50,8 @@
  *
  ***/
 
-int add_olsr_con( struct olsr_node *con_from, struct olsr_node *con_to, float etx ) {
+int add_olsr_con( struct olsr_node *con_from, struct olsr_node *con_to, float etx )
+{
 
 	struct olsr_con **olsr_con = &amp;Con_begin;
 	struct olsr_con *prev_olsr_con = NULL;   /* previous olsr connection */
@@ -95,9 +96,9 @@
 		/* add connection color */
 		(*olsr_con)-&gt;color = 0;
 		s3d_push_material( (*olsr_con)-&gt;obj_id,
-				  1.0,1.0,1.0,
-				  1.0,1.0,1.0,
-				  1.0,1.0,1.0);
+		                   1.0,1.0,1.0,
+		                   1.0,1.0,1.0,
+		                   1.0,1.0,1.0);
 
 		/* add connection endpoints */
 		s3d_push_vertex( (*olsr_con)-&gt;obj_id, (*olsr_con)-&gt;left_olsr_node-&gt;pos_vec[0], (*olsr_con)-&gt;left_olsr_node-&gt;pos_vec[1], (*olsr_con)-&gt;left_olsr_node-&gt;pos_vec[2] );
@@ -163,7 +164,8 @@
  *
  ***/
 
-void *get_olsr_node( struct olsr_node **olsr_node, char *ip ) {
+void *get_olsr_node( struct olsr_node **olsr_node, char *ip )
+{
 
 	int result;   /* result of strcmp */
 
@@ -247,10 +249,11 @@
  *
  */
 
-void lst_initialize() {
+void lst_initialize()
+{
 	Obj_to_ip_head = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
 	Obj_to_ip_end = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	if(Obj_to_ip_head == NULL || Obj_to_ip_end == NULL)
+	if (Obj_to_ip_head == NULL || Obj_to_ip_end == NULL)
 		out_of_mem();
 	Obj_to_ip_head-&gt;id = 0;
 	Obj_to_ip_end-&gt;id = 0;
@@ -267,10 +270,11 @@
  *
  */
 
-void lst_add(int id,struct olsr_node **olsr_node) {
+void lst_add(int id,struct olsr_node **olsr_node)
+{
 	struct Obj_to_ip *new;
 	new = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	if(new == NULL)
+	if (new == NULL)
 		out_of_mem();
 	new-&gt;id = id;
 	new-&gt;olsr_node = *olsr_node;
@@ -289,11 +293,11 @@
  *
  */
 
-void lst_del(int id) {
+void lst_del(int id)
+{
 	struct Obj_to_ip *del;
 	move_lst_ptr(&amp;id);
-	if(id != List_ptr-&gt;id)
-	{
+	if (id != List_ptr-&gt;id) {
 		printf(&quot;obj2ip: remove id %d failed move_lst_ptr return id %d\n&quot;,id,List_ptr-&gt;next-&gt;id);
 	} else {
 		del = List_ptr;
@@ -314,19 +318,19 @@
 struct olsr_node *move_lst_ptr(int *id) {
 	/* printf(&quot;obj2ip: move for %d\n&quot;,*id); */
 	/* head to point at end or id lass then first element in linked list*/
-	if(Obj_to_ip_head-&gt;next == Obj_to_ip_head || *id &lt; Obj_to_ip_head-&gt;next-&gt;id) {
+	if (Obj_to_ip_head-&gt;next == Obj_to_ip_head || *id &lt; Obj_to_ip_head-&gt;next-&gt;id) {
 		List_ptr = Obj_to_ip_head;
 		return NULL;
- 	/* id is greather then last element in linked list */
-	} else if(*id &gt; Obj_to_ip_end-&gt;prev-&gt;id) {
+		/* id is greather then last element in linked list */
+	} else if (*id &gt; Obj_to_ip_end-&gt;prev-&gt;id) {
 		List_ptr = Obj_to_ip_end-&gt;prev;
 		return NULL;
 	} else {
 		/* printf(&quot;obj2ip: ok i search deeper ;-) for id=%d\n&quot;,*id); */
-		if((*id - (int) Obj_to_ip_head-&gt;next-&gt;id) &lt;= ((int)(Obj_to_ip_end-&gt;prev-&gt;id)-*id)) {
+		if ((*id - (int) Obj_to_ip_head-&gt;next-&gt;id) &lt;= ((int)(Obj_to_ip_end-&gt;prev-&gt;id)-*id)) {
 			List_ptr = Obj_to_ip_head;
 			/* printf(&quot;obj2ip: start at head id %d - %d &lt;= %d - %d \n&quot;,*id,Obj_to_ip_head-&gt;next-&gt;id,Obj_to_ip_end-&gt;prev-&gt;id,*id); */
-			while(*id &gt;= List_ptr-&gt;next-&gt;id) {
+			while (*id &gt;= List_ptr-&gt;next-&gt;id) {
 				/* printf(&quot;obj2ip: %d &gt; %d move to &quot;,*id,List_ptr-&gt;id); */
 				List_ptr = List_ptr-&gt;next;
 				/* printf(&quot;%d\n&quot;,List_ptr-&gt;id); */
@@ -335,7 +339,7 @@
 			List_ptr = Obj_to_ip_end;
 			/* printf(&quot;obj2ip: start at end id %d - %d &gt; %d - %d \n&quot;,*id,Obj_to_ip_head-&gt;next-&gt;id,Obj_to_ip_end-&gt;prev-&gt;id,*id);  */
 			/*  do List_ptr = List_ptr-&gt;prev; while(*id &gt; List_ptr-&gt;prev-&gt;id); */
-			while(*id &lt; List_ptr-&gt;prev-&gt;id) {
+			while (*id &lt; List_ptr-&gt;prev-&gt;id) {
 				/* printf(&quot;obj2ip: %d &lt; %d move to &quot;,*id,List_ptr-&gt;id); */
 				List_ptr = List_ptr-&gt;prev;
 				/* printf(&quot;%d\n&quot;,List_ptr-&gt;id); */
@@ -371,16 +375,18 @@
 
 }
 
-void lst_out() {
+void lst_out()
+{
 	struct Obj_to_ip *ptr;
 	ptr = Obj_to_ip_head;
-	while(ptr != ptr-&gt;next) {
+	while (ptr != ptr-&gt;next) {
 		printf(&quot;id-&gt; %d\n&quot;,ptr-&gt;id);
 		ptr = ptr-&gt;next;
 	}
 }
 
-int process_main() {
+int process_main()
+{
 
 	int dn;
 	float f;
@@ -415,24 +421,24 @@
 
 			switch ( dn ) {
 
-				case 0:
-					con_from = lbuf_ptr + 1;
-					break;
-				case 1:
-					con_from_end = lbuf_ptr;
-					break;
-				case 2:
-					con_to = lbuf_ptr + 1;
-					break;
-				case 3:
-					con_to_end = lbuf_ptr;
-					break;
-				case 4:
-					etx = lbuf_ptr + 1;
-					break;
-				case 5:
-					etx_end = lbuf_ptr;
-					break;
+			case 0:
+				con_from = lbuf_ptr + 1;
+				break;
+			case 1:
+				con_from_end = lbuf_ptr;
+				break;
+			case 2:
+				con_to = lbuf_ptr + 1;
+				break;
+			case 3:
+				con_to_end = lbuf_ptr;
+				break;
+			case 4:
+				etx = lbuf_ptr + 1;
+				break;
+			case 5:
+				etx_end = lbuf_ptr;
+				break;
 
 			}
 
@@ -459,11 +465,10 @@
 
 						}
 
-					/* normal HNA */
+						/* normal HNA */
 					} else {
 						memmove(hna_node,con_to,NAMEMAX);
-						if( (tmpChar = strchr(hna_node, (int)'/')))
-						{
+						if ( (tmpChar = strchr(hna_node, (int)'/'))) {
 							tmpChar++;
 							address = (int)-inet_network(tmpChar);
 							sprintf(hna_name,&quot;%d&quot;,(int)(32 - ceil(log(address)/log(2))));
@@ -485,7 +490,7 @@
 
 					}
 
-				/* normal node */
+					/* normal node */
 				} else {
 
 					olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/olsrs3d/search.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -50,10 +50,10 @@
 void follow_node(float cam_position_t[], float cam_position_r[],float rotate)
 {
 	float real_node_pos[3],
-		  cam_target[3],
-		  tmp_vec[3],
-		  diff_vec[3],
-		  angle;
+	cam_target[3],
+	tmp_vec[3],
+	diff_vec[3],
+	angle;
 
 	real_node_pos[0] =  (*search_node)-&gt;pos_vec[0] * cos( rotate * M_PI / 180.0 ) - (*search_node)-&gt;pos_vec[2] * -sin ( rotate * M_PI / 180.0 );
 	real_node_pos[1] =  (*search_node)-&gt;pos_vec[1];
@@ -147,7 +147,9 @@
 /* public */
 void move_search_widget(float x, float y, float z)
 {
-	_search_widget-&gt;x = x; _search_widget-&gt;y = y; _search_widget-&gt;z = z;
+	_search_widget-&gt;x = x;
+	_search_widget-&gt;y = y;
+	_search_widget-&gt;z = z;
 	s3dw_moveit( _search_widget );
 }
 
@@ -164,27 +166,27 @@
 	target = _search_widget-&gt;arx;
 	current = cam_position_r[0];
 
-	if( _search_widget-&gt;arx - cam_position_r[0] &gt; 180 )
+	if ( _search_widget-&gt;arx - cam_position_r[0] &gt; 180 )
 		target -= 360;
-	if( _search_widget-&gt;arx - cam_position_r[0] &lt; -180 )
+	if ( _search_widget-&gt;arx - cam_position_r[0] &lt; -180 )
 		current -= 360;
 	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
 
 	target = _search_widget-&gt;ary;
 	current = cam_position_r[1];
 
-	if( _search_widget-&gt;ary - cam_position_r[1] &gt; 180 )
+	if ( _search_widget-&gt;ary - cam_position_r[1] &gt; 180 )
 		target -= 360;
-	if( _search_widget-&gt;ary - cam_position_r[1] &lt; -180 )
+	if ( _search_widget-&gt;ary - cam_position_r[1] &lt; -180 )
 		current -= 360;
 	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
 
 	target = _search_widget-&gt;arz;
 	current = cam_position_r[2];
 
-	if( _search_widget-&gt;arz - cam_position_r[2] &gt; 180 )
+	if ( _search_widget-&gt;arz - cam_position_r[2] &gt; 180 )
 		target -= 360;
-	if( _search_widget-&gt;arz - cam_position_r[2] &lt; -180 )
+	if ( _search_widget-&gt;arz - cam_position_r[2] &lt; -180 )
 		current -= 360;
 	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
 
@@ -192,9 +194,8 @@
 	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
 
 	if ( sqrt(  (( cam_position_t[0] - _search_widget-&gt;x)*( cam_position_t[0] - _search_widget-&gt;x)) +
-				(( cam_position_t[1] - _search_widget-&gt;y)*( cam_position_t[1] - _search_widget-&gt;y)) +
-				(( cam_position_t[2] - _search_widget-&gt;z)*( cam_position_t[2] - _search_widget-&gt;z)) ) &lt; 0.2 )
-	{
+	                (( cam_position_t[1] - _search_widget-&gt;y)*( cam_position_t[1] - _search_widget-&gt;y)) +
+	                (( cam_position_t[2] - _search_widget-&gt;z)*( cam_position_t[2] - _search_widget-&gt;z)) ) &lt; 0.2 ) {
 		s3d_translate( 0, _search_widget-&gt;x, _search_widget-&gt;y, ( _search_widget-&gt;z - 10 ) );
 		s3d_rotate( 0, _search_widget-&gt;arx, _search_widget-&gt;ary, _search_widget-&gt;arz );
 	}
@@ -212,27 +213,27 @@
 	target = _return_point[1][0];
 	current = cam_position_r[0];
 
-	if( _return_point[1][0] - cam_position_r[0] &gt; 180 )
+	if ( _return_point[1][0] - cam_position_r[0] &gt; 180 )
 		target -= 360;
-	if( _return_point[1][0] - cam_position_r[0] &lt; -180 )
+	if ( _return_point[1][0] - cam_position_r[0] &lt; -180 )
 		current -= 360;
 	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
 
 	target = _return_point[1][1];
 	current = cam_position_r[1];
 
-	if( _return_point[1][1] - cam_position_r[1] &gt; 180 )
+	if ( _return_point[1][1] - cam_position_r[1] &gt; 180 )
 		target -= 360;
-	if( _return_point[1][1] - cam_position_r[1] &lt; -180 )
+	if ( _return_point[1][1] - cam_position_r[1] &lt; -180 )
 		current -= 360;
 	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
 
 	target = _return_point[1][2];
 	current = cam_position_r[2];
 
-	if( _return_point[1][2] - cam_position_r[2] &gt; 180 )
+	if ( _return_point[1][2] - cam_position_r[2] &gt; 180 )
 		target -= 360;
-	if( _return_point[1][2] - cam_position_r[2] &lt; -180 )
+	if ( _return_point[1][2] - cam_position_r[2] &lt; -180 )
 		current -= 360;
 	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
 
@@ -240,9 +241,8 @@
 	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
 
 	if ( sqrt(  (( cam_position_t[0] - _return_point[0][0])*( cam_position_t[0] - _return_point[0][0])) +
-				(( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) +
-				(( cam_position_t[2] - _return_point[0][2])*( cam_position_t[2] - _return_point[0][2])) ) &lt; 0.2 )
-	{
+	                (( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) +
+	                (( cam_position_t[2] - _return_point[0][2])*( cam_position_t[2] - _return_point[0][2])) ) &lt; 0.2 ) {
 		s3d_translate( 0, _return_point[0][0], _return_point[0][1], _return_point[0][2] );
 		s3d_rotate( 0, _return_point[1][0], _return_point[1][1], _return_point[1][2] );
 		set_search_status(NOTHING);
@@ -260,16 +260,14 @@
 	static char s[20];
 	int ln = strlen(s);
 
-	if( key == S3DK_COMMA ) key = S3DK_PERIOD;
+	if ( key == S3DK_COMMA ) key = S3DK_PERIOD;
 
-	if( key != S3DK_RETURN )
-	{
-		if( key == S3DK_BACKSPACE )
-		{
-			if( ln &gt; 0 )
+	if ( key != S3DK_RETURN ) {
+		if ( key == S3DK_BACKSPACE ) {
+			if ( ln &gt; 0 )
 				s[ln-1] = '\0';
 		} else {
-			if( ln &lt; 20 )
+			if ( ln &lt; 20 )
 				s[ln] = key;
 		}
 		s3dw_input_change_text( _search_input, s );
@@ -282,9 +280,9 @@
 void set_return_point(float cam_position_t[], float cam_position_r[])
 {
 	int i;
-	for( i = 0; i &lt; 3; i++ )
+	for ( i = 0; i &lt; 3; i++ )
 		_return_point[0][i] = cam_position_t[i];
-	for( i = 0; i &lt; 3; i++ )
+	for ( i = 0; i &lt; 3; i++ )
 		_return_point[1][i] = cam_position_r[i];
 }
 
@@ -316,8 +314,7 @@
 
 	ip = s3dw_input_gettext( _search_input );
 
-	while ( (*search_node) != NULL )
-	{
+	while ( (*search_node) != NULL ) {
 
 		result = strncmp( (*search_node)-&gt;ip, ip, NAMEMAX );
 
@@ -335,18 +332,16 @@
 	_search_widget=NULL;
 
 
-	if( (*search_node) != NULL )
-	{
+	if ( (*search_node) != NULL ) {
 		set_search_status( FOLLOW );
-	}
-	else
-	{
+	} else {
 		window_error(&quot;Sorry, could not find...&quot;);
 		set_search_status( NOTHING );
 	}
 }
 /* public */
-void follow_node_by_click(struct olsr_node *olsr_node) {
+void follow_node_by_click(struct olsr_node *olsr_node)
+{
 	search_node = &amp;_node_root;
 	(*search_node) = olsr_node;
 	set_search_status( FOLLOW );
@@ -362,8 +357,7 @@
 
 	ip = s3dw_input_gettext( _search_input );
 
-	while ( (*search_node) != NULL )
-	{
+	while ( (*search_node) != NULL ) {
 
 		result = strncmp( (*search_node)-&gt;ip, ip, NAMEMAX );
 
@@ -376,7 +370,7 @@
 			(*search_node) = (*search_node)-&gt;left;
 	}
 
-	if( (*search_node) != NULL )
+	if ( (*search_node) != NULL )
 		set_search_status( FOLLOW );
 }
 

Modified: trunk/apps/olsrs3d/structs.h
===================================================================
--- trunk/apps/olsrs3d/structs.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/olsrs3d/structs.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -28,8 +28,7 @@
 #define MAXDATASIZE 100			/* max number of bytes we can get at once  */
 
 /* linked list for the all connections */
-struct olsr_con 
-{
+struct olsr_con {
 	struct olsr_con *next_olsr_con;			/* pointer to next connection */
 	struct olsr_con *prev_olsr_con;			/* pointer to previous connection */
 	struct olsr_node *left_olsr_node;		/* pointer to left end point of the connection */
@@ -45,16 +44,14 @@
 
 
 /* linked list for the neighbours of each olsr node */
-struct olsr_neigh_list
-{
+struct olsr_neigh_list {
 	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
 	struct olsr_con *olsr_con;							/* pointer to the connection */
 };
 
 
 /* we contruct a binary tree to handle the nodes */
-struct olsr_node 
-{
+struct olsr_node {
 	struct olsr_node *left;
 	struct olsr_node *right;
 	char ip[NAMEMAX];				/* host ip */
@@ -71,8 +68,7 @@
 };
 
 
-struct Obj_to_ip
-{
+struct Obj_to_ip {
 	int id;
 	struct olsr_node *olsr_node;
 	struct Obj_to_ip *next;

Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * s3d_x11gate.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d_x11gate, a 3d gateway for x11 desktops.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d_x11gate is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d_x11gate is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d_x11gate; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,7 +35,9 @@
 #include &lt;sys/time.h&gt; 	/* gettimeofday */
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/shm.h&gt;
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+static struct timespec t= {
+	0,100*1000*1000
+}; /* 100 mili seconds */
 
 int oid;
 XImage *image;
@@ -57,8 +59,7 @@
 int get_shift(unsigned long t)
 {
 	int i=0;
-	while (t)
-	{
+	while (t) {
 		t&gt;&gt;=1;
 		i++;
 	}
@@ -77,16 +78,15 @@
 	start.tv_sec	=end.tv_sec;
 	start.tv_usec 	=end.tv_usec;
 
-/*	image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);*/
+	/*	image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);*/
 	XShmGetImage(dpy, window, image, 0,0,0xffffffff);
 	gettimeofday(&amp;end,NULL);
 	count[1]+=(end.tv_sec-start.tv_sec)*10000000 + end.tv_usec-start.tv_usec;
 	start.tv_sec	=end.tv_sec;
 	start.tv_usec 	=end.tv_usec;
-	if (image-&gt;format==ZPixmap)
-	{
+	if (image-&gt;format==ZPixmap) {
 		printf(&quot;Ximage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n&quot;,image-&gt;width,image-&gt;height,image-&gt;format,ZPixmap,
-					image-&gt;bits_per_pixel,image-&gt;depth,image-&gt;bitmap_pad);
+		       image-&gt;bits_per_pixel,image-&gt;depth,image-&gt;bitmap_pad);
 		rs=get_shift(image-&gt;red_mask)-8;
 		gs=get_shift(image-&gt;green_mask)-8;
 		bs=get_shift(image-&gt;blue_mask)-8;
@@ -97,50 +97,44 @@
 		gs=gs-8;
 		bs=bs-16;
 		printf(&quot;Ximage: rgb: %d|%d|%d\n&quot;,	rs,gs,bs);;
-/*		printf(&quot;red: size %d, offset %d\n&quot;,rs,roff);
-		printf(&quot;green: size %d, offset %d\n&quot;,gs,goff);
-		printf(&quot;blue: size %d, offset %d\n&quot;,bs,boff);
-		printf(&quot;bits per pixel:%d\n&quot;,bpp);*/
+		/*		printf(&quot;red: size %d, offset %d\n&quot;,rs,roff);
+				printf(&quot;green: size %d, offset %d\n&quot;,gs,goff);
+				printf(&quot;blue: size %d, offset %d\n&quot;,bs,boff);
+				printf(&quot;bits per pixel:%d\n&quot;,bpp);*/
 		last_change=-1;
 		start_change=-1;
-		for (y=0;y&lt;height;y++)
-		{
-			
-			for (x=0;x&lt;width;x++)
-			{
+		for (y=0;y&lt;height;y++) {
+
+			for (x=0;x&lt;width;x++) {
 				d=*((unsigned long *)(image-&gt;data+(y*width+x)*bpp));
 				((unsigned long *)tex_image)[(y*width+x)]=
-						(rs&gt;0?((d&amp;image-&gt;red_mask)&gt;&gt;rs):	((d&amp;image-&gt;red_mask)&lt;&lt;-rs))|
-						(gs&gt;0?((d&amp;image-&gt;green_mask)&gt;&gt;gs):	((d&amp;image-&gt;green_mask)&lt;&lt;-gs))|
-						(bs&gt;0?((d&amp;image-&gt;blue_mask)&gt;&gt;bs):	((d&amp;image-&gt;blue_mask)&lt;&lt;-bs))|
-						255&lt;&lt;24;
+				        (rs&gt;0?((d&amp;image-&gt;red_mask)&gt;&gt;rs):	((d&amp;image-&gt;red_mask)&lt;&lt;-rs))|
+				        (gs&gt;0?((d&amp;image-&gt;green_mask)&gt;&gt;gs):	((d&amp;image-&gt;green_mask)&lt;&lt;-gs))|
+				        (bs&gt;0?((d&amp;image-&gt;blue_mask)&gt;&gt;bs):	((d&amp;image-&gt;blue_mask)&lt;&lt;-bs))|
+				        255&lt;&lt;24;
 				if (((unsigned long *)tex_image)[(y*width+x)]!=
-					((unsigned long *)otex_image)[(y*width+x)])
+				                ((unsigned long *)otex_image)[(y*width+x)])
 					last_change=y;
 			}
-			if (last_change!=-1)
-			{
-				if (start_change==-1)
-				{
+			if (last_change!=-1) {
+				if (start_change==-1) {
 					start_change=y;
-/* 					printf(&quot;setting start_change to %d\n&quot;,start_change); */
+					/* 					printf(&quot;setting start_change to %d\n&quot;,start_change); */
 				}
-				if (last_change!=y)
-				{	 /*  last change is already over, post it! */
+				if (last_change!=y) {	 /*  last change is already over, post it! */
 					s3d_load_texture(oid,0,0,start_change,width,last_change-start_change+1,(unsigned char *)tex_image+start_change*width*4);
 					start_change=-1;
 					last_change=-1;
 				}
 			}
 		}
-		 /*  posting the last bit, maybe */
-		if (last_change!=-1)
-		{
-/*			printf(&quot;last one: [%d-%d]&quot;,start_change,last_change);*/
+		/*  posting the last bit, maybe */
+		if (last_change!=-1) {
+			/*			printf(&quot;last one: [%d-%d]&quot;,start_change,last_change);*/
 			s3d_load_texture(oid,0,0,start_change,width,last_change-start_change,(unsigned char *)tex_image+start_change*width*4);
 		}
-/* 		s3d_load_texture(oid,0,0,0,width,height,tex_image); */
-		 /*  swap images */
+		/* 		s3d_load_texture(oid,0,0,0,width,height,tex_image); */
+		/*  swap images */
 		swap_timg=tex_image;
 		tex_image=otex_image;
 		otex_image=swap_timg;
@@ -150,8 +144,8 @@
 	start.tv_sec	=end.tv_sec;
 	start.tv_usec 	=end.tv_usec;
 	iterations++;
-/*	XDestroyImage(image);*/
-/*	nanosleep(&amp;t,NULL); */
+	/*	XDestroyImage(image);*/
+	/*	nanosleep(&amp;t,NULL); */
 }
 int keypress(struct s3d_evt *event)
 {
@@ -159,23 +153,21 @@
 	int kc;
 	key=*((unsigned short *)event-&gt;buf);
 	printf(&quot;received key %d &quot;,key);
-    kc = XKeysymToKeycode(dpy, key);
-	if (kc==0) 
-	{
-	    kc = XKeysymToKeycode(dpy, 0xFF00+ key);
+	kc = XKeysymToKeycode(dpy, key);
+	if (kc==0) {
+		kc = XKeysymToKeycode(dpy, 0xFF00+ key);
 		printf(&quot; (%04x) &quot;,0xFF00+key);
 	}
-	if (kc==0)
-	{
-		if (key==8)
-		{
-			kc=22; printf(&quot;!backspace!&quot;);
+	if (kc==0) {
+		if (key==8) {
+			kc=22;
+			printf(&quot;!backspace!&quot;);
 		}
 	}
 	printf(&quot;using key: %d, keycode %d (%04x)\n&quot;,key,kc,kc);
 	if (kc!=0)
-	    XTestFakeKeyEvent(dpy, kc, 1, 1);
-/*	    XTestFakeKeyEvent(dpy, kc, 0, 1);*/
+		XTestFakeKeyEvent(dpy, kc, 1, 1);
+	/*	    XTestFakeKeyEvent(dpy, kc, 0, 1);*/
 	return(0);
 
 }
@@ -185,7 +177,7 @@
 	printf(&quot;thats it, collecting:\n&quot;);
 	for (i=0;i&lt;3;i++)
 		printf(&quot;[%d] %f\n&quot;,i,count[i]/iterations);
-	exit(0);	
+	exit(0);
 	return(0);
 }
 int main(int argc, char **argv)
@@ -196,15 +188,13 @@
 	if (disp==NULL) disp=getenv(&quot;DISPLAY&quot;);
 	if (disp==NULL) disp=&quot;&quot;;  /*  fallback */
 	dpy = XOpenDisplay(disp);
-	if (!dpy)
-	{
+	if (!dpy) {
 		printf(&quot;couldn't open display\n&quot;);
 		return(-1);
 	}
 	count[0]=count[1]=count[2]=0;
 	iterations=0;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;X11-gate&quot;))
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;X11-gate&quot;)) {
 		scr = DefaultScreen(dpy);
 		window = RootWindow(dpy, scr);
 		width = DisplayWidth(dpy, scr);
@@ -214,23 +204,22 @@
 		XLockDisplay(dpy);
 		xt=XTestQueryExtension(dpy,&amp;a,&amp;b,&amp;c,&amp;d);
 		XUnlockDisplay(dpy);
-		if (xt)
-		{
+		if (xt) {
 			printf(&quot;having xtest extension ...\n&quot;);
 		}
-/* X11 shm - <A HREF="http://www.xfree86.org/current/mit-shm.html">http://www.xfree86.org/current/mit-shm.html</A> */
-		
+		/* X11 shm - <A HREF="http://www.xfree86.org/current/mit-shm.html">http://www.xfree86.org/current/mit-shm.html</A> */
+
 		image= XShmCreateImage(dpy, visual, depth, ZPixmap, NULL, &amp;shminfo, width, height);
 		shminfo.shmid = shmget(IPC_PRIVATE, image-&gt;bytes_per_line * image-&gt;height, IPC_CREAT|0777);
 		shminfo.shmaddr = image-&gt;data = shmat (shminfo.shmid, 0, 0);
 		shmctl(shminfo.shmid, IPC_RMID, 0);
 		shminfo.readOnly= False;
-		if (!XShmAttach(dpy, &amp;shminfo)) 
+		if (!XShmAttach(dpy, &amp;shminfo))
 			printf(&quot;cannot use the shared memory segment .. :( \n&quot;);
 		else
 			printf(&quot;can use share segment :D\n&quot;);
 		XSync(dpy, False);
-		
+
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,mouseclick);
 		s3d_set_callback(S3D_EVENT_KEY,keypress);
 		printf(&quot;screen: %dx%d\n&quot;,width,height);
@@ -244,19 +233,19 @@
 		s3d_push_vertex(oid, 5, 5,0);
 		s3d_push_vertex(oid,-5, 5,0);
 		s3d_push_material_a(oid,
-						0.8,	0.0,	0.0	,1.0,
-						1.0,	1.0,	1.0	,1.0,
-						0.8,	0.0,	0.0	,1.0);
+		                    0.8,	0.0,	0.0	,1.0,
+		                    1.0,	1.0,	1.0	,1.0,
+		                    0.8,	0.0,	0.0	,1.0);
 		s3d_push_polygon(oid,0,2,1,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,1.0, 
-									   1.0,0.0,
-									   1.0,1.0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,1.0,
+		                          1.0,0.0,
+		                          1.0,1.0);
 		s3d_push_polygon(oid,0,3,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,1.0, 
-									   0.0,0.0,
-									   1.0,0.0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,1.0,
+		                          0.0,0.0,
+		                          1.0,0.0);
 		s3d_push_texture(oid,width,height);
-					 /*  push data on texture 0 position (0,0) */
+		/*  push data on texture 0 position (0,0) */
 		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
 		s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 		gettimeofday(&amp;start,NULL);

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/animation.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * animation.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -43,24 +43,21 @@
 /* add an node on the animation stack */
 void ani_add(t_node *f)
 {
-	if (ani_n&lt;MAXANI)
-	{
+	if (ani_n&lt;MAXANI) {
 		if (-1!=ani_onstack(f))
 			return;		/* already in list */
 		ani_s[ani_n]=f;
 		ani_iterate(f);
-	/*	printf(&quot;[A]ni ADD %d\n&quot;,ani_n); */
+		/*	printf(&quot;[A]ni ADD %d\n&quot;,ani_n); */
 		ani_n++;
-	}
-	else /* no place, finish now */
+	} else /* no place, finish now */
 		ani_finish(f,-1);
 }
 /* delete an node from the animation stack */
 void ani_del(int i)
 {
-	if ((i&gt;=0) &amp;&amp; (i&lt;ani_n))
-	{
-/*		printf(&quot;[A]ni DEL %d\n&quot;,i);*/
+	if ((i&gt;=0) &amp;&amp; (i&lt;ani_n)) {
+		/*		printf(&quot;[A]ni DEL %d\n&quot;,i);*/
 		ani_n--;
 		ani_s[i]=ani_s[ani_n]; /* that should also work if i is the last one */
 	} else {
@@ -111,17 +108,14 @@
 	int i;
 	t_node *f;
 	s3dw_ani_mate();
-	for (i=0;i&lt;ani_n;i++)
-	{
+	for (i=0;i&lt;ani_n;i++) {
 		f=ani_s[i];
-		if (f-&gt;oid==-1)
-		{ /* kick out bad animations */
+		if (f-&gt;oid==-1) { /* kick out bad animations */
 			ani_del(i);
 			i--;
 		} else {
 			ani_iterate(f);
-			if (ani_check(f))
-			{
+			if (ani_check(f)) {
 				ani_finish(f,i);
 				i--; /* a new object is here now, take care in the next iteration */
 			} else {

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/box.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * box.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -31,11 +31,11 @@
 	box_buildblock(dir);
 	box_sidelabel(dir);
 	ani_doit(dir);
-    s3d_flags_on(dir-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir-&gt;objs.close,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir-&gt;objs.title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir-&gt;objs.select,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir-&gt;objs.titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(dir-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(dir-&gt;objs.close,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(dir-&gt;objs.title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(dir-&gt;objs.select,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(dir-&gt;objs.titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	dir-&gt;disp=D_DIR;
 	box_draw_icons(dir);
 }
@@ -45,8 +45,7 @@
 {
 	int i;
 	printf(&quot;box_draw_icons(%s, %d subs)\n&quot;,dir-&gt;name, dir-&gt;n_sub);
-	for (i=0;i&lt;dir-&gt;n_sub;i++)
-	{
+	for (i=0;i&lt;dir-&gt;n_sub;i++) {
 		if (dir-&gt;sub[i]-&gt;disp==D_NONE)	icon_draw(dir-&gt;sub[i]);
 	}
 	box_order_icons(dir);
@@ -57,8 +56,7 @@
 void box_sidelabel(t_node *dir)
 {
 	float len;
-	if (dir-&gt;objs.str==-1)
-	{
+	if (dir-&gt;objs.str==-1) {
 		dir-&gt;objs.str=s3d_draw_string(dir-&gt;name,&amp;len);
 		if (len&lt;2) len=2;
 		dir-&gt;objs.strlen=len;
@@ -73,11 +71,11 @@
 /* gives another color for the focused box */
 void box_focus_color(t_node *dir, int on)
 {
-	
+
 	s3d_pep_material(dir-&gt;oid,
-						0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
-						0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
-						0.5+on*0.3,0.5+on*0.3,0.5+on*0.3);
+	                 0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
+	                 0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
+	                 0.5+on*0.3,0.5+on*0.3,0.5+on*0.3);
 
 }
 /* creates a big block which will hold files and subdirs on top */
@@ -86,70 +84,66 @@
 	char fname[30];
 	char *fullname=fname;
 	float len;
-	float vertices[]=
-			{-BHP,0,-BHP,
-			 -BHP,0, BHP,
-			  BHP,0, BHP,
-			  BHP,0,-BHP,
-			 -BHP,BHH,-BHP,
-			 -BHP,BHH, BHP,
-			  BHP,BHH, BHP,
-			  BHP,BHH,-BHP,
-			 -1,0, 0.8,
-			 -1,BOXHEIGHT, 0.8,
-			  1,BOXHEIGHT, 0.8,
-			  1,0, 0.8
-				};
-	float xvertices[]=
-			{
-			  0.8,BHH-0.2, 0.8,
-			  0.8,BHH    , 0.8,
-			  BHP,BHH    , 0.8,
-			  BHP,BHH-0.2, 0.8,
-			  0.8,BHH-0.2, 1.0,
-			  0.8,BHH    , 1.0,
-			  BHP,BHH    , 1.0,
-			  BHP,BHH-0.2, 1.0
-			 };
-	float svertices[]=
-			{
-			  0.6,BHH-0.2, 0.8,
-			  0.6,BHH    , 0.8,
-			  0.8,BHH    , 0.8,
-			  0.8,BHH-0.2, 0.8,
-			  0.6,BHH-0.2, 1.0,
-			  0.6,BHH    , 1.0,
-			  0.8,BHH    , 1.0,
-			  0.8,BHH-0.2, 1.0
-			 };
-	float tvertices[]=
-			{
-			  -BHP,BHH-0.2, 0.8,
-			  -BHP,BHH    , 0.8,
-			  0.6, BHH    , 0.8,
-			  0.6, BHH-0.2, 0.8,
-			  -BHP,BHH-0.2, 1.0,
-			  -BHP,BHH    , 1.0,
-			  0.6, BHH    , 1.0,
-			  0.6, BHH-0.2, 1.0
-			 };
+	float vertices[]= {-BHP,0,-BHP,
+	                   -BHP,0, BHP,
+	                   BHP,0, BHP,
+	                   BHP,0,-BHP,
+	                   -BHP,BHH,-BHP,
+	                   -BHP,BHH, BHP,
+	                   BHP,BHH, BHP,
+	                   BHP,BHH,-BHP,
+	                   -1,0, 0.8,
+	                   -1,BOXHEIGHT, 0.8,
+	                   1,BOXHEIGHT, 0.8,
+	                   1,0, 0.8
+	                  };
+	float xvertices[]= {
+		0.8,BHH-0.2, 0.8,
+		0.8,BHH    , 0.8,
+		BHP,BHH    , 0.8,
+		BHP,BHH-0.2, 0.8,
+		0.8,BHH-0.2, 1.0,
+		0.8,BHH    , 1.0,
+		BHP,BHH    , 1.0,
+		BHP,BHH-0.2, 1.0
+	};
+	float svertices[]= {
+		0.6,BHH-0.2, 0.8,
+		0.6,BHH    , 0.8,
+		0.8,BHH    , 0.8,
+		0.8,BHH-0.2, 0.8,
+		0.6,BHH-0.2, 1.0,
+		0.6,BHH    , 1.0,
+		0.8,BHH    , 1.0,
+		0.8,BHH-0.2, 1.0
+	};
+	float tvertices[]= {
+		-BHP,BHH-0.2, 0.8,
+		-BHP,BHH    , 0.8,
+		0.6, BHH    , 0.8,
+		0.6, BHH-0.2, 0.8,
+		-BHP,BHH-0.2, 1.0,
+		-BHP,BHH    , 1.0,
+		0.6, BHH    , 1.0,
+		0.6, BHH-0.2, 1.0
+	};
 	uint32_t bar_poly[]={
 		4,5,6,0,
 		4,6,7,0,
 		3,7,4,0,
 		3,4,0,0
 	};
-/*	printf(&quot;new block for %s\n&quot;,dir-&gt;name);*/
+	/*	printf(&quot;new block for %s\n&quot;,dir-&gt;name);*/
 
 	dir-&gt;oid=s3d_new_object();
-	
+
 	/* draw block outside */
 	s3d_push_vertices(dir-&gt;oid,vertices,sizeof(vertices)/(3*sizeof(float)));
 	s3d_push_material(dir-&gt;oid,
-						0.5,0.5,0.5,
-						0.5,0.5,0.5,
-						0.5,0.5,0.5
-					);
+	                  0.5,0.5,0.5,
+	                  0.5,0.5,0.5,
+	                  0.5,0.5,0.5
+	                 );
 
 	/* top */
 	s3d_push_polygon(dir-&gt;oid,4,6,5,0);
@@ -162,7 +156,7 @@
 	/* left */
 	s3d_push_polygon(dir-&gt;oid,0,4,5,0);
 	s3d_push_polygon(dir-&gt;oid,0,5,1,0);
-	
+
 	/* back */
 	s3d_push_polygon(dir-&gt;oid,3,7,4,0);
 	s3d_push_polygon(dir-&gt;oid,3,4,0,0);
@@ -170,7 +164,7 @@
 	/* right */
 	s3d_push_polygon(dir-&gt;oid,2,6,7,0);
 	s3d_push_polygon(dir-&gt;oid,2,7,3,0);
-	
+
 	/* front */
 	s3d_push_polygon(dir-&gt;oid,8,9,10,0);
 	s3d_push_polygon(dir-&gt;oid,8,10,11,0);
@@ -192,32 +186,32 @@
 	/* draw the select, close buttons ... */
 	dir-&gt;objs.close=s3d_new_object();
 	s3d_push_material(dir-&gt;objs.close,
-						0.5,0.3,0.3,
-						0.5,0.3,0.3,
-						0.5,0.3,0.3
-					);
+	                  0.5,0.3,0.3,
+	                  0.5,0.3,0.3,
+	                  0.5,0.3,0.3
+	                 );
 	s3d_push_vertices(dir-&gt;objs.close,xvertices,sizeof(xvertices)/(3*sizeof(float)));
 	s3d_push_polygons(dir-&gt;objs.close,bar_poly,sizeof(bar_poly)/(sizeof(uint32_t)*4));
 	s3d_link(dir-&gt;objs.close,dir-&gt;oid);
-	
+
 	dir-&gt;objs.select=s3d_new_object();
 	s3d_push_material(dir-&gt;objs.select,
-						0.1,0.1,0.3,
-						0.1,0.1,0.3,
-						0.1,0.1,0.3
-					);
+	                  0.1,0.1,0.3,
+	                  0.1,0.1,0.3,
+	                  0.1,0.1,0.3
+	                 );
 	s3d_push_vertices(dir-&gt;objs.select,svertices,sizeof(svertices)/(3*sizeof(float)));
 	s3d_push_polygons(dir-&gt;objs.select,bar_poly,sizeof(bar_poly)/(sizeof(uint32_t)*4));
 	s3d_link(dir-&gt;objs.select,dir-&gt;oid);
-	
+
 	/* draw the title string */
-	
+
 	dir-&gt;objs.title=s3d_new_object();
 	s3d_push_material(dir-&gt;objs.title,
-						0.3,0.3,0.3,
-						0.3,0.3,0.3,
-						0.3,0.3,0.3
-					);
+	                  0.3,0.3,0.3,
+	                  0.3,0.3,0.3,
+	                  0.3,0.3,0.3
+	                 );
 	s3d_push_vertices(dir-&gt;objs.title,tvertices,sizeof(tvertices)/(3*sizeof(float)));
 	s3d_push_polygons(dir-&gt;objs.title,bar_poly,sizeof(bar_poly)/(sizeof(uint32_t)*4));
 	s3d_link(dir-&gt;objs.title,dir-&gt;oid);
@@ -227,20 +221,23 @@
 	s3d_translate(dir-&gt;objs.titlestr,-1.0,1.05,1.01);
 	s3d_link(dir-&gt;objs.titlestr,dir-&gt;oid);
 	dir-&gt;disp=D_DIR;
-/*	printf(&quot;FULLNAME is [%s]\n&quot;,fullname);*/
+	/*	printf(&quot;FULLNAME is [%s]\n&quot;,fullname);*/
 	return(0);
 }
 /* display a directoy on the top of another */
 int box_expand(t_node *dir)
 {
 	printf(&quot;box_expand( %s )\n&quot;,dir-&gt;name);
-	switch (dir-&gt;disp)
-	{
-		case D_DIR:			return(0); /* already done */
-		case D_ICON:		icon_undisplay(dir); /* undisplay previously displayed types, like icons etc */
-			break;
-		case D_NONE:		break; /* ignore */
-		default:			return(-1); /* panic */
+	switch (dir-&gt;disp) {
+	case D_DIR:
+		return(0); /* already done */
+	case D_ICON:
+		icon_undisplay(dir); /* undisplay previously displayed types, like icons etc */
+		break;
+	case D_NONE:
+		break; /* ignore */
+	default:
+		return(-1); /* panic */
 	}
 	dir-&gt;dpx=0.0;
 	dir-&gt;dpy=BOXHEIGHT;
@@ -249,8 +246,7 @@
 	box_draw(dir);
 
 	/* initialize position on the parent */
-	if (dir-&gt;parent!=NULL)	
-	{
+	if (dir-&gt;parent!=NULL) {
 		dir-&gt;parent-&gt;dirs_opened++;
 		s3d_link(dir-&gt;oid,dir-&gt;parent-&gt;oid);
 		box_order_subdirs(dir-&gt;parent);
@@ -261,11 +257,25 @@
 int box_undisplay(t_node *dir)
 {
 	printf(&quot;box_undisplay( %s )\n&quot;,dir-&gt;name);
-	if (dir-&gt;objs.close!=-1)		{	s3d_del_object(dir-&gt;objs.close);	dir-&gt;objs.close=-1; }
-	if (dir-&gt;objs.select!=-1)		{	s3d_del_object(dir-&gt;objs.select);	dir-&gt;objs.select=-1; }
-	if (dir-&gt;objs.title!=-1)		{	s3d_del_object(dir-&gt;objs.title);	dir-&gt;objs.title=-1; }
-	if (dir-&gt;objs.titlestr!=-1)		{	s3d_del_object(dir-&gt;objs.titlestr);	dir-&gt;objs.titlestr=-1; }
-	if (dir-&gt;oid!=-1)				{	s3d_del_object(dir-&gt;oid);	}
+	if (dir-&gt;objs.close!=-1)		{
+		s3d_del_object(dir-&gt;objs.close);
+		dir-&gt;objs.close=-1;
+	}
+	if (dir-&gt;objs.select!=-1)		{
+		s3d_del_object(dir-&gt;objs.select);
+		dir-&gt;objs.select=-1;
+	}
+	if (dir-&gt;objs.title!=-1)		{
+		s3d_del_object(dir-&gt;objs.title);
+		dir-&gt;objs.title=-1;
+	}
+	if (dir-&gt;objs.titlestr!=-1)		{
+		s3d_del_object(dir-&gt;objs.titlestr);
+		dir-&gt;objs.titlestr=-1;
+	}
+	if (dir-&gt;oid!=-1)				{
+		s3d_del_object(dir-&gt;oid);
+	}
 	/* keep this. icons also needs the *same* string */
 	/*	if (dir-&gt;objs.str!=-1)			{ 	s3d_del_object(dir-&gt;objs.str); dir-&gt;objs.str=-1;	}*/
 	dir-&gt;disp=D_NONE;
@@ -293,14 +303,12 @@
 	int i;
 	int ret;
 	printf(&quot;box_close( %s )\n&quot;,dir-&gt;name);
-	if (&amp;root==dir)
-	{
+	if (&amp;root==dir) {
 		printf(&quot;won't close down root box ... \n&quot;);
 		return(-1);
 	}
 	if (dir-&gt;detached &amp;&amp; !force)	return(1);
-	if (dir-&gt;disp!=D_DIR) /* that should not be happening ... */
-	{
+	if (dir-&gt;disp!=D_DIR) { /* that should not be happening ... */
 		printf(&quot;[A]lready undisplayed %s, nothing to do ...\n&quot;,dir-&gt;name);
 		return(-1);
 	}
@@ -309,16 +317,14 @@
 	for (i=0;i&lt;dir-&gt;n_sub;i++)
 		if (dir-&gt;sub[i]-&gt;disp==D_DIR)
 			ret|=box_close(dir-&gt;sub[i],force);
-	if (ret &amp;&amp; !force) 
-	{	/* if anything got wrong, return here ... */
+	if (ret &amp;&amp; !force) {	/* if anything got wrong, return here ... */
 		box_order_subdirs(dir);
-		return(ret); 
+		return(ret);
 	} else {
 		/* also remove the icons */
 		if (focus==dir)			focus_set(dir-&gt;parent);
 		for (i=0;i&lt;dir-&gt;n_sub;i++)
-			if (dir-&gt;sub[i]-&gt;disp==D_ICON)
-			{
+			if (dir-&gt;sub[i]-&gt;disp==D_ICON) {
 				icon_undisplay(dir-&gt;sub[i]);
 				dir-&gt;detached=0;
 				if (focus==dir-&gt;sub[i])
@@ -344,42 +350,38 @@
 		}
 	return(0);
 }*/
-/* orders the directory objects on top of its parent objects 
+/* orders the directory objects on top of its parent objects
  * to be called after adding or removing things ...*/
 void box_order_subdirs(t_node *dir)
 {
 	int i,j;
 	printf(&quot;box_order_subdirs( %s ): %d dirs opened\n&quot;,dir-&gt;name,dir-&gt;dirs_opened);
-	switch (dir-&gt;dirs_opened)
-	{
-		case 0: return;
-		case 1:
-			for (i=0;i&lt;dir-&gt;n_sub;i++)
-			{
-				if (dir-&gt;sub[i]-&gt;disp==D_DIR)
-				{
-					dir-&gt;sub[i]-&gt;px=0.0;
-					dir-&gt;sub[i]-&gt;py=BOXHEIGHT+dir-&gt;sub[i]-&gt;detached*DETHEIGHT;
-					dir-&gt;sub[i]-&gt;pz=0.0;
-					dir-&gt;sub[i]-&gt;scale=0.2;
-					ani_add(dir-&gt;sub[i]);
-				}
+	switch (dir-&gt;dirs_opened) {
+	case 0:
+		return;
+	case 1:
+		for (i=0;i&lt;dir-&gt;n_sub;i++) {
+			if (dir-&gt;sub[i]-&gt;disp==D_DIR) {
+				dir-&gt;sub[i]-&gt;px=0.0;
+				dir-&gt;sub[i]-&gt;py=BOXHEIGHT+dir-&gt;sub[i]-&gt;detached*DETHEIGHT;
+				dir-&gt;sub[i]-&gt;pz=0.0;
+				dir-&gt;sub[i]-&gt;scale=0.2;
+				ani_add(dir-&gt;sub[i]);
 			}
-			break;
-		default:
-			j=0;
-			for (i=0;i&lt;dir-&gt;n_sub;i++)
-			{
-				if (dir-&gt;sub[i]-&gt;disp==D_DIR)
-				{
-					dir-&gt;sub[i]-&gt;px=0.8 * sin(((float)j*2*M_PI)/((float)dir-&gt;dirs_opened));
-					dir-&gt;sub[i]-&gt;py=BOXHEIGHT+dir-&gt;sub[i]-&gt;detached*DETHEIGHT;
-					dir-&gt;sub[i]-&gt;pz=0.8 * cos(((float)j*2*M_PI)/((float)dir-&gt;dirs_opened));
-					dir-&gt;sub[i]-&gt;scale=0.2;
-					ani_add(dir-&gt;sub[i]);
-					j++;
-				}
+		}
+		break;
+	default:
+		j=0;
+		for (i=0;i&lt;dir-&gt;n_sub;i++) {
+			if (dir-&gt;sub[i]-&gt;disp==D_DIR) {
+				dir-&gt;sub[i]-&gt;px=0.8 * sin(((float)j*2*M_PI)/((float)dir-&gt;dirs_opened));
+				dir-&gt;sub[i]-&gt;py=BOXHEIGHT+dir-&gt;sub[i]-&gt;detached*DETHEIGHT;
+				dir-&gt;sub[i]-&gt;pz=0.8 * cos(((float)j*2*M_PI)/((float)dir-&gt;dirs_opened));
+				dir-&gt;sub[i]-&gt;scale=0.2;
+				ani_add(dir-&gt;sub[i]);
+				j++;
 			}
+		}
 	}
 }
 /* order the icons properly */
@@ -387,10 +389,8 @@
 {
 	int dps,i;
 	dps=ceil(sqrt(dir-&gt;n_sub)); /* directories per line */
-	for (i=0;i&lt;dir-&gt;n_sub;i++)
-	{
-		if (dir-&gt;sub[i]-&gt;disp == D_ICON)
-		{
+	for (i=0;i&lt;dir-&gt;n_sub;i++) {
+		if (dir-&gt;sub[i]-&gt;disp == D_ICON) {
 			dir-&gt;sub[i]-&gt;px = -1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
 			dir-&gt;sub[i]-&gt;py = 0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
 			dir-&gt;sub[i]-&gt;pz=dir-&gt;sub[i]-&gt;detached*0.2+1.0;

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/dialog.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -51,11 +51,9 @@
 {
 	int i;
 	char *s;
-	for (i=0;i&lt;dir-&gt;n_sub;i++)
-	{
+	for (i=0;i&lt;dir-&gt;n_sub;i++) {
 		if (dir-&gt;sub[i]-&gt;sub!=NULL)	get_selected(fp,dir-&gt;sub[i]); /* scan subdir */
-		if (dir-&gt;sub[i]-&gt;detached)
-		{
+		if (dir-&gt;sub[i]-&gt;detached) {
 			fp-&gt;n++;
 			fp-&gt;p=realloc(fp-&gt;p,sizeof(t_file) * fp-&gt;n);
 			s=malloc(M_DIR);
@@ -67,7 +65,7 @@
 				fp-&gt;p[fp-&gt;n - 1].anode=NULL;
 			fp-&gt;p[fp-&gt;n - 1].size=0; /*TODO: later */
 			fp-&gt;p[fp-&gt;n - 1].state=STATE_NONE;
-	
+
 		}
 	}
 	return(0);
@@ -114,7 +112,7 @@
 {
 	fs_err.state=ESTATE_NONE;
 	s3dw_delete(button-&gt;parent); /* parent =surface. this means close containing window */
-	
+
 }
 void window_fs_errno(char *errmsg)
 {
@@ -134,8 +132,7 @@
 void window_fs_abort(s3dw_widget *button)
 {
 	/* delete a filelist, if there was any */
-	if (fp!=NULL)
-	{
+	if (fp!=NULL) {
 		fl_del(fp);
 		fp=NULL;
 	}
@@ -145,23 +142,22 @@
 }
 void *thread_start(void *ptr)
 {
-	switch (fs_lock)
-	{
-		case TYPE_COPY: 
-			printf(&quot;starting a copy process in the thread ... \n&quot;);
-			destnode=node_getbypath(destdir);
-			fs_fl_copy(fp,destdir);
-			printf(&quot;done\n&quot;);
-			break;
-		case TYPE_UNLINK:
-			printf(&quot;unlinking some files ... \n&quot;);
-			fs_fl_unlink(fp);
-			printf(&quot;done\n&quot;);
-			break;
+	switch (fs_lock) {
+	case TYPE_COPY:
+		printf(&quot;starting a copy process in the thread ... \n&quot;);
+		destnode=node_getbypath(destdir);
+		fs_fl_copy(fp,destdir);
+		printf(&quot;done\n&quot;);
+		break;
+	case TYPE_UNLINK:
+		printf(&quot;unlinking some files ... \n&quot;);
+		fs_fl_unlink(fp);
+		printf(&quot;done\n&quot;);
+		break;
 	}
 	fs_lock=TYPE_FINISHED;
 	return(NULL);
-	
+
 }
 /* start the thread, as filesystem stuff is locked ... */
 void window_fs(s3dw_widget *button)
@@ -177,18 +173,25 @@
 
 	int i,m;
 
-	if (fs_lock) 	{	window_fs_another(); 	return; }
+	if (fs_lock) 	{
+		window_fs_another();
+		return;
+	}
 	fs_lock=TYPE_COPY;
 	fp=malloc(sizeof(filelist));
 	fp-&gt;n=0;
 	fp-&gt;p=NULL;
 	get_selected(fp,&amp;root);
 	printf(&quot;selected %d nodes\n&quot;,fp-&gt;n);
-	if (fp-&gt;n == 0)	{	window_fs_nothing();	free(fp); fp=NULL;return;	}
+	if (fp-&gt;n == 0)	{
+		window_fs_nothing();
+		free(fp);
+		fp=NULL;
+		return;
+	}
 	/* get the longest item on the list */
 	m=10;
-	for (i=0;i&lt;fp-&gt;n;i++)
-	{
+	for (i=0;i&lt;fp-&gt;n;i++) {
 		if (strlen(fp-&gt;p[i].name)&gt;m) m=strlen(fp-&gt;p[i].name);
 		printf(&quot;%d: %s\n&quot;,i,fp-&gt;p[i].name);
 	}
@@ -220,14 +223,22 @@
 
 	int i,m;
 
-	if (fs_lock) 	{	window_fs_another(); 	return; }
+	if (fs_lock) 	{
+		window_fs_another();
+		return;
+	}
 	fs_lock=TYPE_UNLINK;
 	fp=malloc(sizeof(filelist));
 	fp-&gt;n=0;
 	fp-&gt;p=NULL;
 	get_selected(fp,&amp;root);
 	printf(&quot;selected %d nodes\n&quot;,fp-&gt;n);
-	if (fp-&gt;n == 0)	{	window_fs_nothing();	free(fp); fp=NULL;return;	}
+	if (fp-&gt;n == 0)	{
+		window_fs_nothing();
+		free(fp);
+		fp=NULL;
+		return;
+	}
 	/* get the longest item on the list */
 	m=10;
 	for (i=0;i&lt;fp-&gt;n;i++)
@@ -258,12 +269,11 @@
 	else {
 		/* success, now refresh it */
 		item=node_getbypath(dir);
-		if (item==NULL)
-		{
+		if (item==NULL) {
 			printf(&quot;cannot refresh\n&quot;);
 		} else {
 			printf(&quot;refreshing %s\n&quot;,item-&gt;name);
-/*			parse_again(item);*/
+			/*			parse_again(item);*/
 		}
 	}
 	fs_lock=0;
@@ -276,7 +286,10 @@
 	s3dw_button  *okbutton,*abortbutton;
 	char string1[M_DIR];
 	float l;
-	if (fs_lock) {window_fs_another(); return; }
+	if (fs_lock) {
+		window_fs_another();
+		return;
+	}
 	snprintf(string1,M_DIR,&quot;Create Directory in %s&quot;,path);
 	l=strlen(string1)*0.7;
 	infwin=s3dw_surface_new(&quot;Create Directory&quot;,l,8);
@@ -298,7 +311,10 @@
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;
-	if (fs_lock) {window_fs_another(); return; }
+	if (fs_lock) {
+		window_fs_another();
+		return;
+	}
 	infwin=s3dw_surface_new(&quot;Info Window&quot;,20,8);
 	s3dw_label_new(infwin,&quot;Sorry, moving is not implemented yet.. :(&quot;,1,2);
 	button=s3dw_button_new(infwin,&quot;Too bad&quot;,7,5);
@@ -320,9 +336,9 @@
 	fs_approx(path, &amp;f, &amp;d, &amp;b);
 	dotted_int(bd,b);
 	snprintf(string2 ,M_DIR,&quot;%s bytes in %d files and %d Directories&quot;,bd,f,d);
-	
+
 	l=((strlen(string1)&gt;strlen(string2)) ? strlen(string1) :strlen(string2))*0.7;
-	
+
 	infwin=s3dw_surface_new(&quot;Info Window&quot;,l,12);
 
 	s3dw_label_new(infwin,string1,1,2);
@@ -341,8 +357,7 @@
 	t_node *node, dummy;
 	if (fs_lock!=TYPE_NONE)	{
 		/* get current position of our destination node */
-		if (destnode!=NULL)
-		{
+		if (destnode!=NULL) {
 			node=destnode;
 			node_init(&amp;dummy);
 			dummy.parent = node-&gt;parent;
@@ -360,30 +375,28 @@
 		}
 		if (fp!=NULL) {
 			for (i=0;i&lt;fp-&gt;n;i++) {
-				if (fp-&gt;p[i].state==STATE_FINISHED)
-				{ /* we can go and clean up now. */
-					if (NULL!=(node=node_getbypath(fp-&gt;p[i].name)))
-					{
+				if (fp-&gt;p[i].state==STATE_FINISHED) { /* we can go and clean up now. */
+					if (NULL!=(node=node_getbypath(fp-&gt;p[i].name))) {
 						printf(&quot;[CLEANUP] for node %s (%s)\n&quot;,node-&gt;name,fp-&gt;p[i].name);
 						node-&gt;detached=0;
-						if (node-&gt;parent!=NULL)
-						{
+						if (node-&gt;parent!=NULL) {
 							parse_dir(node-&gt;parent);
-							switch (node-&gt;disp)
-							{
-								case D_ICON:	box_order_icons(node-&gt;parent);					break;
-								case D_DIR:		box_order_subdirs(node-&gt;parent);				break;
+							switch (node-&gt;disp) {
+							case D_ICON:
+								box_order_icons(node-&gt;parent);
+								break;
+							case D_DIR:
+								box_order_subdirs(node-&gt;parent);
+								break;
 							}
 						}
-					} else 
+					} else
 						printf(&quot;node %s already vanished ...\n&quot;,fp-&gt;p[i].name);
-							
+
 					fp-&gt;p[i].state=STATE_CLEANED;
 				}
-				if (fp-&gt;p[i].state&gt;STATE_NONE)
-				{
-					if (destnode!=NULL)
-					{
+				if (fp-&gt;p[i].state&gt;STATE_NONE) {
+					if (destnode!=NULL) {
 						fp-&gt;p[i].anode-&gt;px=dummy.px;
 						fp-&gt;p[i].anode-&gt;py=dummy.py;
 						fp-&gt;p[i].anode-&gt;pz=dummy.pz;
@@ -395,23 +408,20 @@
 		}
 		if (fs_lock==TYPE_FINISHED)	{
 			printf(&quot;filesystem stuff is finisheed, cleaning up&quot;);
-			if (fp!=NULL)
-			{
+			if (fp!=NULL) {
 				fl_del(fp);
 				fp=NULL;
 			}
 			typeinput=0;
 			fs_lock=TYPE_NONE;
 			if (destnode!=NULL)
-				if (destnode-&gt;disp==D_DIR) /* it usually is opened */
-				{
+				if (destnode-&gt;disp==D_DIR) { /* it usually is opened */
 					printf(&quot;reordering icons on destnode ...\n&quot;);
-					box_order_icons(destnode);	
+					box_order_icons(destnode);
 				}
 			destnode=NULL;
 		}
-		if (fs_err.state==ESTATE_RISE)
-		{
+		if (fs_err.state==ESTATE_RISE) {
 			s3dw_surface *infwin;
 			s3dw_button  *button;
 			char errmsg[M_DIR];

Modified: trunk/apps/s3dfm/event.c
===================================================================
--- trunk/apps/s3dfm/event.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/event.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * event.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -34,8 +34,7 @@
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
-	if ((inf-&gt;object==0) &amp;&amp; (!ani_onstack(&amp;cam)))
-	{
+	if ((inf-&gt;object==0) &amp;&amp; (!ani_onstack(&amp;cam))) {
 		cam.dpx=inf-&gt;trans_x;
 		cam.dpy=inf-&gt;trans_y;
 		cam.dpz=inf-&gt;trans_z;
@@ -49,71 +48,68 @@
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)evt-&gt;buf;
 	char path[M_DIR];
-	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */	
-			printf(&quot;inputting text ...\n&quot;);
-			s3dw_handle_key(evt); 
-			return(0); 
+	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */
+		printf(&quot;inputting text ...\n&quot;);
+		s3dw_handle_key(evt);
+		return(0);
 	}
 	node_path(node_getdir(focus),path);
-	switch (keys-&gt;keysym)
-	{
-		case 'i':
-		case 'I':
-				{
-				window_info(path);
-				}
-				break;
-		case 'r':
-		case 'R':
-				{/* refresh this window ... */
-					t_node *node;
-					node=node_getdir(focus);
-					printf(&quot;[R]efreshing %s\n&quot;,node-&gt;name);
-					parse_dir(node);
-					box_draw_icons(node);
-					box_order_icons(node);
-					box_order_subdirs(node);
-					
-				}
-				break;
-		case S3DK_F1:
-				window_help();
-				break;
-		case S3DK_F5:
-				window_copy(path);
-				break;
-		case S3DK_F6:
-				window_move(path);
-				break;
-		case S3DK_F7:
-				window_mkdir(path);
-				break;
-		case S3DK_F8:
-				window_unlink();
-				break;
-		case S3DK_F10:
-				/* some debugging stuff */
-				node_getbypath(path);
-				break;
+	switch (keys-&gt;keysym) {
+	case 'i':
+	case 'I': {
+		window_info(path);
+	}
+	break;
+	case 'r':
+	case 'R': {/* refresh this window ... */
+		t_node *node;
+		node=node_getdir(focus);
+		printf(&quot;[R]efreshing %s\n&quot;,node-&gt;name);
+		parse_dir(node);
+		box_draw_icons(node);
+		box_order_icons(node);
+		box_order_subdirs(node);
 
-		case S3DK_UP:
-		case S3DK_LEFT:
-		case S3DK_RIGHT:
-		case S3DK_DOWN:
-				focus_by_key(keys-&gt;keysym);
-				break;
-		case S3DK_RETURN:
-		case S3DK_SPACE:
-				node_select(focus);
-				break;
-		case S3DK_BACKSPACE:
-				if (focus-&gt;disp==D_DIR)
-					box_close(focus,1);
-				else if (focus-&gt;parent!=NULL)
-						box_close(focus-&gt;parent,1);
-				break;
-				
 	}
+	break;
+	case S3DK_F1:
+		window_help();
+		break;
+	case S3DK_F5:
+		window_copy(path);
+		break;
+	case S3DK_F6:
+		window_move(path);
+		break;
+	case S3DK_F7:
+		window_mkdir(path);
+		break;
+	case S3DK_F8:
+		window_unlink();
+		break;
+	case S3DK_F10:
+		/* some debugging stuff */
+		node_getbypath(path);
+		break;
+
+	case S3DK_UP:
+	case S3DK_LEFT:
+	case S3DK_RIGHT:
+	case S3DK_DOWN:
+		focus_by_key(keys-&gt;keysym);
+		break;
+	case S3DK_RETURN:
+	case S3DK_SPACE:
+		node_select(focus);
+		break;
+	case S3DK_BACKSPACE:
+		if (focus-&gt;disp==D_DIR)
+			box_close(focus,1);
+		else if (focus-&gt;parent!=NULL)
+			box_close(focus-&gt;parent,1);
+		break;
+
+	}
 	s3dw_handle_key(evt);
 	return(0);
 }
@@ -125,22 +121,19 @@
 	t_node *f;
 	s3dw_handle_click(evt);
 	oid=(int)*((u_int32_t *)evt-&gt;buf);
-	if (NULL!=(f=node_getbyoid(&amp;root,oid)))
-	{
-		if (f-&gt;objs.close==oid)
-		{
+	if (NULL!=(f=node_getbyoid(&amp;root,oid))) {
+		if (f-&gt;objs.close==oid) {
 			box_close(f,1);
 			return(0);
 		}
-		if (f-&gt;objs.select==oid)
-		{
+		if (f-&gt;objs.select==oid) {
 			printf(&quot;[S]electing %s\n&quot;,f-&gt;name);
 			node_select(f);
 			return(0);
 		}
 		node_select(f);
 	} else {
-/*		printf(&quot;[C]ould not find :/\n&quot;);*/
+		/*		printf(&quot;[C]ould not find :/\n&quot;);*/
 	}
 	return(0);
 }

Modified: trunk/apps/s3dfm/fly.c
===================================================================
--- trunk/apps/s3dfm/fly.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/fly.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * fly.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -36,7 +36,7 @@
 	*/
 	if (f-&gt;parent==NULL)	work-&gt;scale = f-&gt;scale;
 	else					work-&gt;scale = work-&gt;scale * f-&gt;scale;
-	
+
 }
 
 int fly_set_absolute_position(t_node *node)
@@ -51,7 +51,7 @@
 	node-&gt;py=work.py;
 	node-&gt;pz=work.pz;
 	node-&gt;scale=work.scale;
-/*	printf(&quot;node coordinates: %3.3f %3.3f %3.3f %3.3f\n&quot;,node-&gt;px,node-&gt;py,node-&gt;pz,node-&gt;scale);*/
+	/*	printf(&quot;node coordinates: %3.3f %3.3f %3.3f %3.3f\n&quot;,node-&gt;px,node-&gt;py,node-&gt;pz,node-&gt;scale);*/
 	return(0);
 }
 /* create a copy of *node as an icon (block) which can be moved for animation ... */
@@ -75,8 +75,8 @@
 	work-&gt;dpz=work-&gt;pz;
 	work-&gt;dscale=work-&gt;scale;
 	work-&gt;py=2*work-&gt;scale - work-&gt;py; /* invert */
-    s3d_flags_on(work-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(work-&gt;objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(work-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(work-&gt;objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	ani_add(work);
 	return(work);
 }

Modified: trunk/apps/s3dfm/focus.c
===================================================================
--- trunk/apps/s3dfm/focus.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/focus.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * focus.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -31,8 +31,7 @@
 float focus_get_scale(t_node *f)
 {
 	float scale,s;
-	if (f-&gt;disp==D_DIR)
-	{
+	if (f-&gt;disp==D_DIR) {
 		s=0.2;
 		scale=1/s;
 		if (f-&gt;parent!=NULL)
@@ -50,7 +49,7 @@
 		if (f-&gt;parent!=NULL)		return(focus_get_scale(f-&gt;parent));	/* icons etc */
 		else  						return(1.0);						/* that should never happen */
 	}
-	
+
 }
 /* center f for the viewer, therefore moving the root box ... */
 void focus_set(t_node *f)
@@ -59,20 +58,19 @@
 	root.py=0.0;
 	root.pz=0.0;
 	moveon=1;
-/*	printf(&quot;[Z]ooming to %s\n&quot;,f-&gt;name);*/
-/*	box_collapse_grandkids(f);*/
+	/*	printf(&quot;[Z]ooming to %s\n&quot;,f-&gt;name);*/
+	/*	box_collapse_grandkids(f);*/
 	root.scale=focus_get_scale(f);
 	root.py-=1.5;
-/*	printf(&quot;[R]escaling to %f\n&quot;,root.scale);
-	printf(&quot;px: %f py:%f pz: %f\n&quot;,root.px,root.py,root.pz);*/
+	/*	printf(&quot;[R]escaling to %f\n&quot;,root.scale);
+		printf(&quot;px: %f py:%f pz: %f\n&quot;,root.px,root.py,root.pz);*/
 
 	ani_add(&amp;root);
 	node_focus_color(focus,0);
 	node_focus_color(f,1);
 	focus=f;
-	if (((cam.dpx-cam.px)* (cam.dpx-cam.px) + (cam.dpy-cam.py)* (cam.dpy-cam.py) 
-		  + (cam.dpz-cam.pz)* (cam.dpz-cam.pz))	&gt; ( 10 * 10))
-	{
+	if (((cam.dpx-cam.px)* (cam.dpx-cam.px) + (cam.dpy-cam.py)* (cam.dpy-cam.py)
+	                + (cam.dpz-cam.pz)* (cam.dpz-cam.pz))	&gt; ( 10 * 10)) {
 		cam.px=0;
 		cam.py=0;
 		cam.pz=5;
@@ -84,133 +82,120 @@
 void focus_by_key(int keysym)
 {
 	int i,rowsize;
-	if (focus-&gt;pindex!=-1)
-	{
-		switch (focus-&gt;disp)
-		{
-			case D_DIR:
-				switch (keysym)
-				{
-					case S3DK_RIGHT:
-						/* cycle to the next directory on the ring */
-						for (i=focus-&gt;pindex-1;i&gt;=0;i--)
-							if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR)
-							{ /* found a directory before, cycle */
-								focus_set(focus-&gt;parent-&gt;sub[i]);
-								break;
-							}
-						if (i==-1) /* nothing found, wrap to the other side */
-						for (i=focus-&gt;parent-&gt;n_sub-1;i&gt;=focus-&gt;pindex+1;i--)
-							if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR)
-							{ /* found a directory before, cycle */
-								focus_set(focus-&gt;parent-&gt;sub[i]);
-								break;
-							}
+	if (focus-&gt;pindex!=-1) {
+		switch (focus-&gt;disp) {
+		case D_DIR:
+			switch (keysym) {
+			case S3DK_RIGHT:
+				/* cycle to the next directory on the ring */
+				for (i=focus-&gt;pindex-1;i&gt;=0;i--)
+					if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR) { /* found a directory before, cycle */
+						focus_set(focus-&gt;parent-&gt;sub[i]);
 						break;
-					case S3DK_LEFT:
-						/* cycle to the next directory on the ring */
-						for (i=focus-&gt;pindex+1;i&lt;focus-&gt;parent-&gt;n_sub;i++)
-							if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR)
-							{ /* found a directory before, cycle */
-								focus_set(focus-&gt;parent-&gt;sub[i]);
-								break;
-							}
-						if (i==focus-&gt;parent-&gt;n_sub) /* nothing found, wrap to the other side */
-						for (i=0;i&lt;focus-&gt;pindex;i++)
-							if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR)
-							{ /* found a directory before, cycle */
-								focus_set(focus-&gt;parent-&gt;sub[i]);
-								break;
-							}
+					}
+				if (i==-1) /* nothing found, wrap to the other side */
+					for (i=focus-&gt;parent-&gt;n_sub-1;i&gt;=focus-&gt;pindex+1;i--)
+						if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR) { /* found a directory before, cycle */
+							focus_set(focus-&gt;parent-&gt;sub[i]);
+							break;
+						}
+				break;
+			case S3DK_LEFT:
+				/* cycle to the next directory on the ring */
+				for (i=focus-&gt;pindex+1;i&lt;focus-&gt;parent-&gt;n_sub;i++)
+					if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR) { /* found a directory before, cycle */
+						focus_set(focus-&gt;parent-&gt;sub[i]);
 						break;
-					case S3DK_UP:
-						/* go in the first entry of this directory, if possible */
-						if (focus-&gt;n_sub&gt;0)
-							focus_set(focus-&gt;sub[0]);
+					}
+				if (i==focus-&gt;parent-&gt;n_sub) /* nothing found, wrap to the other side */
+					for (i=0;i&lt;focus-&gt;pindex;i++)
+						if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR) { /* found a directory before, cycle */
+							focus_set(focus-&gt;parent-&gt;sub[i]);
+							break;
+						}
+				break;
+			case S3DK_UP:
+				/* go in the first entry of this directory, if possible */
+				if (focus-&gt;n_sub&gt;0)
+					focus_set(focus-&gt;sub[0]);
+				break;
+			case S3DK_DOWN:
+				/* go to first icon entry of parent,  or parent itself */
+				for (i=focus-&gt;parent-&gt;n_sub-1;i&gt;=0;i--)
+					if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_ICON) { /* found a directory before, cycle */
+						focus_set(focus-&gt;parent-&gt;sub[i]);
 						break;
-					case S3DK_DOWN:
-						/* go to first icon entry of parent,  or parent itself */
-						for (i=focus-&gt;parent-&gt;n_sub-1;i&gt;=0;i--)
-							if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_ICON)
-							{ /* found a directory before, cycle */
-								focus_set(focus-&gt;parent-&gt;sub[i]);
-								break;
-							}
-						if (i==0) /* no icons? go to parent. */
-							focus_set(focus-&gt;parent);
-						break;
+					}
+				if (i==0) /* no icons? go to parent. */
+					focus_set(focus-&gt;parent);
+				break;
 
 
 
-				}
+			}
+			break;
+		case D_ICON:
+			switch (keysym) {
+			case S3DK_LEFT:
+				/* search for the next icon on the left side */
+				i=focus-&gt;pindex;
+				do {
+					i--;
+					if (i&lt;0) i=focus-&gt;parent-&gt;n_sub-1;
+				} while (focus-&gt;parent-&gt;sub[i]-&gt;disp!=D_ICON);
+				focus_set(focus-&gt;parent-&gt;sub[i]);
 				break;
-			case D_ICON:
-				switch (keysym)
-				{
-					case S3DK_LEFT:
-						/* search for the next icon on the left side */
-						i=focus-&gt;pindex;
-						do {
-							i--;
-							if (i&lt;0) i=focus-&gt;parent-&gt;n_sub-1;
-						} while (focus-&gt;parent-&gt;sub[i]-&gt;disp!=D_ICON);
-						focus_set(focus-&gt;parent-&gt;sub[i]);
-						break;
-					case S3DK_RIGHT:
-						/* search for the next icon on the right side */
-						i=focus-&gt;pindex;
-						do {
-							i++;
-							if (i&gt;=focus-&gt;parent-&gt;n_sub) i=0;
-						} while (focus-&gt;parent-&gt;sub[i]-&gt;disp!=D_ICON);
-						focus_set(focus-&gt;parent-&gt;sub[i]);
-						break;
-					case S3DK_UP:
-						/* search for the next icon on the left side */
-						i=focus-&gt;pindex;
-						rowsize=ceil(sqrt(focus-&gt;parent-&gt;n_sub)); /* items per line */
-						do {
-							i+=rowsize;
-							if (i&gt;=focus-&gt;parent-&gt;n_sub) break;
-						} while (focus-&gt;parent-&gt;sub[i]-&gt;disp!=D_ICON);
-						if (i&gt;=focus-&gt;parent-&gt;n_sub) 
-						{
-							/* go to the first activated dir above ... */
-							for (i=0;i&lt;focus-&gt;parent-&gt;n_sub;i++)
-								if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR)
-								{ /* found a directory before, cycle */
-									focus_set(focus-&gt;parent-&gt;sub[i]);
-									break;
-								}
-						}
-						else		focus_set(focus-&gt;parent-&gt;sub[i]);
-						break;
-					case S3DK_DOWN:
-						/* search for the next icon on the left side */
-						i=focus-&gt;pindex;
-						rowsize=ceil(sqrt(focus-&gt;parent-&gt;n_sub)); /* items per line */
-						do {
-							i-=rowsize;
-							if (i&lt;0) break;
-						} while (focus-&gt;parent-&gt;sub[i]-&gt;disp!=D_ICON);
-						if (i&lt;0) 
-							focus_set(focus-&gt;parent);
-						else						
+			case S3DK_RIGHT:
+				/* search for the next icon on the right side */
+				i=focus-&gt;pindex;
+				do {
+					i++;
+					if (i&gt;=focus-&gt;parent-&gt;n_sub) i=0;
+				} while (focus-&gt;parent-&gt;sub[i]-&gt;disp!=D_ICON);
+				focus_set(focus-&gt;parent-&gt;sub[i]);
+				break;
+			case S3DK_UP:
+				/* search for the next icon on the left side */
+				i=focus-&gt;pindex;
+				rowsize=ceil(sqrt(focus-&gt;parent-&gt;n_sub)); /* items per line */
+				do {
+					i+=rowsize;
+					if (i&gt;=focus-&gt;parent-&gt;n_sub) break;
+				} while (focus-&gt;parent-&gt;sub[i]-&gt;disp!=D_ICON);
+				if (i&gt;=focus-&gt;parent-&gt;n_sub) {
+					/* go to the first activated dir above ... */
+					for (i=0;i&lt;focus-&gt;parent-&gt;n_sub;i++)
+						if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR) { /* found a directory before, cycle */
 							focus_set(focus-&gt;parent-&gt;sub[i]);
-						break;
-
-				}
+							break;
+						}
+				} else		focus_set(focus-&gt;parent-&gt;sub[i]);
 				break;
+			case S3DK_DOWN:
+				/* search for the next icon on the left side */
+				i=focus-&gt;pindex;
+				rowsize=ceil(sqrt(focus-&gt;parent-&gt;n_sub)); /* items per line */
+				do {
+					i-=rowsize;
+					if (i&lt;0) break;
+				} while (focus-&gt;parent-&gt;sub[i]-&gt;disp!=D_ICON);
+				if (i&lt;0)
+					focus_set(focus-&gt;parent);
+				else
+					focus_set(focus-&gt;parent-&gt;sub[i]);
+				break;
+
+			}
+			break;
 		}
 	} else {
 		/* probably root */
-		switch (keysym)
-		{
-			case S3DK_UP:
-				/* go in the first entry of this directory, if possible */
-				if (focus-&gt;n_sub&gt;0)
-					focus_set(focus-&gt;sub[0]);
-				break;
+		switch (keysym) {
+		case S3DK_UP:
+			/* go in the first entry of this directory, if possible */
+			if (focus-&gt;n_sub&gt;0)
+				focus_set(focus-&gt;sub[0]);
+			break;
 		}
 	}
 

Modified: trunk/apps/s3dfm/fs.c
===================================================================
--- trunk/apps/s3dfm/fs.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/fs.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,20 +1,20 @@
 /*
- * fs.c 
+ * fs.c
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -26,7 +26,7 @@
 #include &lt;stdlib.h&gt;	/*  malloc() */
 
 /* we want GNU version of basename */
-#define _GNU_SOURCE 
+#define _GNU_SOURCE
 #include &lt;string.h&gt;	/*  strlen(), strncmp(), strrchr() */
 #include &lt;libgen.h&gt; /* basename() */
 
@@ -37,7 +37,9 @@
 #include &lt;errno.h&gt; /* errno */
 #include &lt;time.h&gt;	/* nanosleep() */
 
-struct fs_error fs_err={0,0,NULL,NULL};
+struct fs_error fs_err= {
+	0,0,NULL,NULL
+};
 
 
 /* generates the file list */
@@ -51,20 +53,17 @@
 	fl=malloc(sizeof(filelist));
 	fl-&gt;p=NULL;
 	fl-&gt;n=0;
-    n = scandir(path, &amp;namelist, 0, alphasort);
-    if (n &lt;= 2) /* . and .. is always included. */
-	{
+	n = scandir(path, &amp;namelist, 0, alphasort);
+	if (n &lt;= 2) { /* . and .. is always included. */
 		if (n&lt;0)
-	        fs_error(&quot;fl_new():scandir()&quot;,path);
+			fs_error(&quot;fl_new():scandir()&quot;,path);
 	} else {
 		j=0;
 		fl-&gt;n=n-2 ; /* ignore . and .. */
 		fl-&gt;p=malloc(sizeof(t_file)*fl-&gt;n);
-		for (i=0;i&lt;n;i++)
-		{
+		for (i=0;i&lt;n;i++) {
 			name=namelist[i]-&gt;d_name;
-			if (!((strcmp(name,&quot;.&quot;)==0) || (strcmp(name,&quot;..&quot;)==0))) /* ignore */
-			{
+			if (!((strcmp(name,&quot;.&quot;)==0) || (strcmp(name,&quot;..&quot;)==0))) { /* ignore */
 				fl-&gt;p[j].name=malloc(strlen(name)+strlen(path)+2);
 				strcpy(fl-&gt;p[j].name,path);
 				strcat(fl-&gt;p[j].name,&quot;/&quot;);
@@ -77,25 +76,22 @@
 			}
 			free(namelist[i]);
 		}
-		if (j!=fl-&gt;n)
-		{ /* TODO: GUH! don't exit(-1) */
+		if (j!=fl-&gt;n) { /* TODO: GUH! don't exit(-1) */
 			printf(&quot;assertion failed\n&quot;);
 			exit(-1);
 		}
 		free (namelist);
 	}
-	return(fl);	
+	return(fl);
 }
 /* delete the filelist */
 void fl_del(filelist *fl)
 {
 	int i;
-	for (i=0;i&lt;fl-&gt;n;i++)
-	{
+	for (i=0;i&lt;fl-&gt;n;i++) {
 		free(fl-&gt;p[i].name);
-		if (fl-&gt;p[i].anode!=NULL)
-		{
-		/* maybe let node_delete do that? */
+		if (fl-&gt;p[i].anode!=NULL) {
+			/* maybe let node_delete do that? */
 			/*node_delete(fl-&gt;p[i].anode);*/
 			icon_undisplay(fl-&gt;p[i].anode);
 			free(fl-&gt;p[i].anode);
@@ -114,27 +110,26 @@
 	*dirs=	sdirs=	0;
 	*bytes=	sbytes=	0;
 
-/*	printf(&quot;start: %d files, %d dirs, %d bytes in %s\n&quot;,*files,*dirs,*bytes,source);*/
+	/*	printf(&quot;start: %d files, %d dirs, %d bytes in %s\n&quot;,*files,*dirs,*bytes,source);*/
 	if (-1==stat(source,&amp;s))
 		return;
-/*	printf(&quot;%s: %08x (%db)\n&quot;,source,s.st_mode,(int)s.st_size);*/
-	if ((s.st_mode&amp;S_IFMT) == S_IFDIR)
-	{
-		
+	/*	printf(&quot;%s: %08x (%db)\n&quot;,source,s.st_mode,(int)s.st_size);*/
+	if ((s.st_mode&amp;S_IFMT) == S_IFDIR) {
+
 		fl=fl_new(source);
 		if (fl-&gt;n&gt;0)
 			fs_fl_approx(fl,&amp;sfiles,&amp;sdirs,&amp;sbytes);
 		fl_del(fl);
-/*		printf(&quot;%d files, %d dirs, %d bytes in %s\n&quot;,sfiles,sdirs,sbytes,source);*/
+		/*		printf(&quot;%d files, %d dirs, %d bytes in %s\n&quot;,sfiles,sdirs,sbytes,source);*/
 
 		*files=		sfiles;
 		*bytes+=	sbytes;
 		*dirs=		sdirs;
 		*dirs+=		1;
-	} else 
+	} else
 		*files=		1;
 	*bytes+=s.st_size;
-/*	printf(&quot;end: %d files, %d dirs, %d bytes in %s\n&quot;,*files,*dirs,*bytes,source);*/
+	/*	printf(&quot;end: %d files, %d dirs, %d bytes in %s\n&quot;,*files,*dirs,*bytes,source);*/
 }
 /* approximate the heaviness of our source ...*/
 void fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes)
@@ -146,8 +141,7 @@
 	*dirs=0;
 	*bytes=0;
 
-	for (i=0;i&lt;fl-&gt;n;i++)
-	{
+	for (i=0;i&lt;fl-&gt;n;i++) {
 		fs_approx(fl-&gt;p[i].name,&amp;sfiles,&amp;sdirs,&amp;sbytes);
 		*files+=		sfiles;
 		*dirs+=			sdirs;
@@ -164,55 +158,51 @@
 	int n;
 	if (-1==stat(source,&amp;s))
 		return(0);
-	switch (s.st_mode&amp;S_IFMT)
-	{
-		case S_IFDIR:
-			fl=fl_new(source);
-		
-			printf(&quot;mkdir %s\n&quot;,dest);
-			mkdir(dest,0777);
-		
-			fs_fl_copy(fl, dest);
+	switch (s.st_mode&amp;S_IFMT) {
+	case S_IFDIR:
+		fl=fl_new(source);
 
-			fl_del(fl);
-			break;
-		case S_IFIFO:
-			printf(&quot;link the fifo\n&quot;);
+		printf(&quot;mkdir %s\n&quot;,dest);
+		mkdir(dest,0777);
 
-			link(source,dest);
-			break;
-		default:
-			printf(&quot;fs_copy -&gt; atomic copy\n&quot;);
-			printf(&quot;open source...&quot;);
-			if (NULL==(fps=fopen(source,&quot;r&quot;))) 
-			{
-				fs_error(&quot;fs_copy():fopen(source)&quot;,source);
-				return(-1);
-			}
-			printf(&quot;ok\n&quot;);
-			printf(&quot;open dest...&quot;);
-			if (NULL==(fpd=fopen(dest,&quot;w&quot;))) 
-			{
-				fs_error(&quot;fs_copy():fopen(source)&quot;,source);
-				return(-1);
-			}
-			printf(&quot;ok\n&quot;);
-			/* TODO: overwrite protection etc */
-			printf(&quot;copy ...&quot;);
-		
-			while (!feof(fps))
-			{
-				printf(&quot;.&quot;);
-				errno=0;
-				n=fread(buf,1,1024,fps);
-				if (errno)	fs_error(&quot;fs_copy():fread(source)&quot;,source);
-				fwrite(buf,1,n,fpd);
-				if (errno)	fs_error(&quot;fs_copy():fwrite(source)&quot;,source);
-			}
-			printf(&quot;ok\n&quot;);
-			fclose(fps);
-			fclose(fpd);
+		fs_fl_copy(fl, dest);
 
+		fl_del(fl);
+		break;
+	case S_IFIFO:
+		printf(&quot;link the fifo\n&quot;);
+
+		link(source,dest);
+		break;
+	default:
+		printf(&quot;fs_copy -&gt; atomic copy\n&quot;);
+		printf(&quot;open source...&quot;);
+		if (NULL==(fps=fopen(source,&quot;r&quot;))) {
+			fs_error(&quot;fs_copy():fopen(source)&quot;,source);
+			return(-1);
+		}
+		printf(&quot;ok\n&quot;);
+		printf(&quot;open dest...&quot;);
+		if (NULL==(fpd=fopen(dest,&quot;w&quot;))) {
+			fs_error(&quot;fs_copy():fopen(source)&quot;,source);
+			return(-1);
+		}
+		printf(&quot;ok\n&quot;);
+		/* TODO: overwrite protection etc */
+		printf(&quot;copy ...&quot;);
+
+		while (!feof(fps)) {
+			printf(&quot;.&quot;);
+			errno=0;
+			n=fread(buf,1,1024,fps);
+			if (errno)	fs_error(&quot;fs_copy():fread(source)&quot;,source);
+			fwrite(buf,1,n,fpd);
+			if (errno)	fs_error(&quot;fs_copy():fwrite(source)&quot;,source);
+		}
+		printf(&quot;ok\n&quot;);
+		fclose(fps);
+		fclose(fpd);
+
 	}
 	return(0);
 }
@@ -224,8 +214,7 @@
 	char *sdest;
 	char *bname;
 	r=0;
-	for (i=0;i&lt;fl-&gt;n;i++)
-	{
+	for (i=0;i&lt;fl-&gt;n;i++) {
 		fl-&gt;p[i].state=STATE_INUSE;
 		bname=basename(fl-&gt;p[i].name);
 		sdest=malloc(strlen(dest)+strlen(bname)+2);
@@ -246,10 +235,9 @@
 {
 	filelist *fl;
 	struct stat s;
-	
+
 	if (-1==stat(dest,&amp;s))		return(-1);
-	if ((s.st_mode&amp;S_IFMT) == S_IFDIR)
-	{
+	if ((s.st_mode&amp;S_IFMT) == S_IFDIR) {
 		printf(&quot;%s is a dir, removing below ...\n&quot;,dest);
 		fl=fl_new(dest);
 		if (fs_fl_unlink(fl)) {
@@ -258,15 +246,13 @@
 		} else {
 			fl_del(fl);
 			printf(&quot;removing %s\n&quot;,dest);
-			if (rmdir(dest)==-1)
-			{
+			if (rmdir(dest)==-1) {
 				fs_error(&quot;fs_fl_unlink(): rmdir()&quot;,dest);
 				return(-1);
 			}
 		}
 	} else {
-		if (unlink(dest)==-1)
-		{
+		if (unlink(dest)==-1) {
 			fs_error(&quot;fs_fl_unlink(): unlink()&quot;,dest);
 			return(-1);
 		}
@@ -278,8 +264,7 @@
 {
 	int i,r;
 	r=0;
-	for (i=0;i&lt;fl-&gt;n;i++)
-	{
+	for (i=0;i&lt;fl-&gt;n;i++) {
 		fl-&gt;p[i].state=STATE_INUSE;
 		printf(&quot;-&gt; atomic unlink %s\n&quot;,fl-&gt;p[i].name);
 		r|=fs_unlink(fl-&gt;p[i].name);
@@ -290,21 +275,19 @@
 }
 int fs_move(char *source, char *dest)
 {
-	if (!rename(source,dest))
-	{
-		switch (errno)
-		{
-			case EXDEV:
-				fs_copy(source,dest);
-				fs_unlink(source);
-				break;
-			default: 
-				fs_error(&quot;fs_move()&quot;,dest);
-				return(-1); /* can't help it */
-			
+	if (!rename(source,dest)) {
+		switch (errno) {
+		case EXDEV:
+			fs_copy(source,dest);
+			fs_unlink(source);
+			break;
+		default:
+			fs_error(&quot;fs_move()&quot;,dest);
+			return(-1); /* can't help it */
+
 		}
 	}
-	return(0);	
+	return(0);
 }
 
 /* moves the source to the destination */
@@ -315,8 +298,7 @@
 	char *sdest;
 	char *bname;
 	r=0;
-	for (i=0;i&lt;fl-&gt;n;i++)
-	{
+	for (i=0;i&lt;fl-&gt;n;i++) {
 		fl-&gt;p[i].state=STATE_INUSE;
 		bname=basename(fl-&gt;p[i].name);
 		sdest=malloc(strlen(dest)+strlen(bname)+2);
@@ -338,13 +320,15 @@
 /* write an error and wait for a reaction */
 int fs_error(char *message, char *file)
 {
-	static struct timespec t={0,100*1000*1000}; 
+	static struct timespec t= {
+		0,100*1000*1000
+	};
 	fs_err.err=errno;
 	fs_err.message=message;
 	fs_err.file=file;
 	fs_err.state=ESTATE_RISE;
 	printf(&quot;[FS ERROR]: %s %s %s&quot;,message,file,strerror(errno));
-	while (fs_err.state!=ESTATE_NONE) 
+	while (fs_err.state!=ESTATE_NONE)
 		nanosleep(&amp;t,NULL);  /* until situation clear, wait (and don't waste cpu-time) */
 	return(0);
 }

Modified: trunk/apps/s3dfm/icon.c
===================================================================
--- trunk/apps/s3dfm/icon.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/icon.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * icon.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,14 +27,15 @@
 #include &lt;string.h&gt;  /* strlen() */
 #include &lt;stdlib.h&gt;  /* memcpy() */
 float icon_colors[T_TYPENUM][12]={
-		/* T_DUNO */
+	/* T_DUNO */
 	{	0,0,0.5,1.0,
 		0,0,0.5,1.0,
 		0,0,0.5,1.0 },
-		/* T_FOLDER */
+	/* T_FOLDER */
 	{	0.4,0.4,0,1.0,
-		0.4,0.4,0,1.0,
-		0.4,0.4,0,1.0}};
+	  0.4,0.4,0,1.0,
+	  0.4,0.4,0,1.0}
+};
 
 /* gives another color for the focused item */
 void icon_focus_color(t_node *dir, int on)
@@ -42,31 +43,32 @@
 	float color[12];
 	int i;
 	memcpy(color,icon_colors[dir-&gt;type],sizeof(color));
-	if (on) for(i=0;i&lt;3;i++) {
+	if (on) for (i=0;i&lt;3;i++) {
 			color[i*4 + 0]+=0.3;
 			color[i*4 + 1]+=0.3;
 			color[i*4 + 2]+=0.3;
-	}
+		}
 	s3d_pep_materials_a(dir-&gt;oid,color,1);
 }
 /* draws icon dir */
 int icon_draw(t_node *dir)
 {
 	float vertices[]={	-1,-0.5,0,
-						-1, 0.5,0,
-						 1, 0.5,0,
-						 1,-0.5,0,
-						-1,-0.5,-1,
-						-1, 0.5,-1,
-						 1, 0.5,-1,
-						 1,-0.5,-1};
+	                   -1, 0.5,0,
+	                   1, 0.5,0,
+	                   1,-0.5,0,
+	                   -1,-0.5,-1,
+	                   -1, 0.5,-1,
+	                   1, 0.5,-1,
+	                   1,-0.5,-1
+	                 };
 	uint32_t polys[]={
-				1,3,0,0,				2,3,1,0,
-				5,6,2,0,				1,5,2,0,
-				2,6,7,0,				2,7,3,0,
-				0,3,7,0,				0,7,4,0,
-				5,1,0,0,				5,0,4,0	
-				};
+		1,3,0,0,				2,3,1,0,
+		5,6,2,0,				1,5,2,0,
+		2,6,7,0,				2,7,3,0,
+		0,3,7,0,				0,7,4,0,
+		5,1,0,0,				5,0,4,0
+	};
 	float len;
 	/* find position for the new block in our directory box */
 	/* create the block */
@@ -76,8 +78,7 @@
 	s3d_push_polygons(dir-&gt;oid,polys,10);
 
 	/* draw and position the string */
-	if (dir-&gt;objs.str==-1)
-	{
+	if (dir-&gt;objs.str==-1) {
 		dir-&gt;objs.str=s3d_draw_string(dir-&gt;name,&amp;len);
 		if (len&lt;2) len=2;
 		dir-&gt;objs.strlen=len;
@@ -91,13 +92,11 @@
 }
 int icon_undisplay(t_node *dir)
 {
-	if (dir-&gt;oid!=-1)
-	{
+	if (dir-&gt;oid!=-1) {
 		s3d_del_object(dir-&gt;oid);
 		dir-&gt;oid=-1;
 	}
-	if (dir-&gt;objs.str!=-1)
-	{
+	if (dir-&gt;objs.str!=-1) {
 		s3d_del_object(dir-&gt;objs.str);
 		dir-&gt;objs.str=-1;
 	}

Modified: trunk/apps/s3dfm/main.c
===================================================================
--- trunk/apps/s3dfm/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * main.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -25,7 +25,9 @@
 #include &quot;s3dfm.h&quot;
 #include &lt;string.h&gt;  /*  strlen(), strncmp(), strrchr() */
 #include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,33*1000*1000}; 
+static struct timespec t= {
+	0,33*1000*1000
+};
 t_node root,cam,*focus;
 
 void mainloop()
@@ -33,7 +35,7 @@
 	ani_mate();
 	s3dw_ani_mate();
 	window_fsani();
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 }
 int main (int argc, char **argv)
 {
@@ -41,8 +43,7 @@
 	s3d_set_callback(S3D_EVENT_OBJ_CLICK,event_click);
 	s3d_set_callback(S3D_EVENT_OBJ_INFO,event_oinfo);
 	s3d_set_callback(S3D_EVENT_KEY,event_key);
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;s3dfm&quot;))	
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;s3dfm&quot;)) {
 		s3d_select_font(&quot;vera&quot;);
 
 		node_init(&amp;cam); /* a virtual object, just to push the cam throu our animation stack */
@@ -57,9 +58,9 @@
 		box_draw(&amp;root);
 		ani_doit(&amp;root);
 		focus_set(&amp;root);
-		
-		
-		
+
+
+
 		s3d_mainloop(mainloop);
 		s3d_quit();
 	}

Modified: trunk/apps/s3dfm/node.c
===================================================================
--- trunk/apps/s3dfm/node.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/node.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * node.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -32,10 +32,9 @@
 	char *s,*match;
 	t_node *cur;
 	int i;
-	
+
 	if (path==NULL) return NULL;
-	if (path[0]=='/')
-	{
+	if (path[0]=='/') {
 		strncpy(p,path,M_DIR-1);
 		s=p+1;
 		cur=&root;
@@ -44,8 +43,7 @@
 	printf(&quot;processing rest of string %s\n&quot;,s);
 	match=s;
 	while (*s!=0) { /* while search string is not empty */
-		if ((s=index(s,'/'))!=NULL)
-		{
+		if ((s=index(s,'/'))!=NULL) {
 			s[0]=0; /* mark the slash with space */
 			s++;	/* move to the next */
 		} else {
@@ -54,8 +52,7 @@
 		/* parse ... */
 		printf(&quot;looking for a match for %s, rest is %s\n&quot;,match,s);
 		for (i=0;i&lt;cur-&gt;n_sub;i++)
-			if (0==strcmp(cur-&gt;sub[i]-&gt;name,match))
-			{ /* found !! */
+			if (0==strcmp(cur-&gt;sub[i]-&gt;name,match)) { /* found !! */
 				cur=cur-&gt;sub[i]; /* forward */
 				match=s; /* select next */
 				break;
@@ -87,8 +84,7 @@
 /* writes the path of dir into *path. path should be of type path[M_DIR] */
 void node_path(t_node *dir, char *path)
 {
-	if (dir-&gt;parent!=NULL)
-	{
+	if (dir-&gt;parent!=NULL) {
 		node_path(dir-&gt;parent,path);
 		if (dir-&gt;parent-&gt;parent!=NULL)
 			mstrncat(path,&quot;/&quot;,M_DIR);
@@ -110,7 +106,7 @@
 	dir-&gt;objs.title=-1;
 	dir-&gt;objs.titlestr=-1;
 	dir-&gt;objs.strlen=0;
-	
+
 	dir-&gt;disp=D_NONE;
 	dir-&gt;parsed=0;
 
@@ -128,11 +124,15 @@
 /* general undisplay routine. does not handle anything recursively... */
 int node_undisplay(t_node *dir)
 {
-	switch (dir-&gt;disp)
-	{
-		case D_DIR: return(box_undisplay(dir));break;
-		case D_ICON:return(icon_undisplay(dir));break;
-		default:	return(-1);
+	switch (dir-&gt;disp) {
+	case D_DIR:
+		return(box_undisplay(dir));
+		break;
+	case D_ICON:
+		return(icon_undisplay(dir));
+		break;
+	default:
+		return(-1);
 	}
 	dir-&gt;disp=0;
 }
@@ -141,8 +141,7 @@
 int node_delete(t_node *dir)
 {
 	int i;
-	if (dir-&gt;parent==NULL) 
-	{
+	if (dir-&gt;parent==NULL) {
 		printf(&quot;won't delete root window!\n&quot;);
 		return(-1);
 	}
@@ -154,10 +153,11 @@
 	}
 	/* move focus upward, this should go up with the recursion */
 	if (focus==dir)	focus_set(dir-&gt;parent); /* do this before deleting the contents, its better ... */
-	switch (dir-&gt;disp)
-	{
-			case D_DIR:  box_undisplay(dir);
-			case D_ICON: icon_undisplay(dir);
+	switch (dir-&gt;disp) {
+	case D_DIR:
+		box_undisplay(dir);
+	case D_ICON:
+		icon_undisplay(dir);
 	}
 
 	if (-1!=(i=ani_onstack(dir))) ani_del(i); /* tell animation stack too */
@@ -167,40 +167,40 @@
 /* node select handles click on the detach button. selected items can be moved, copied etc.*/
 void node_select(t_node *dir)
 {
-		
+
 	dir-&gt;detached=dir-&gt;detached?0:1; /* swapping, not sure if !dir-&gt;detached would do the same .. */
-	switch (dir-&gt;disp)
-	{
-		case D_DIR:
-			if (focus!=dir)
-			{
-				dir-&gt;detached=dir-&gt;detached?0:1; /* swap again, we actually don't want to have it detachedf now. */
-				focus_set(dir);
-			}
-			if (dir-&gt;parent!=NULL)
-				box_order_subdirs(dir-&gt;parent);
-			break;
-		case D_ICON:
-			if (dir-&gt;type==T_FOLDER)
-			{
-				dir-&gt;detached=0;
-				if (!parse_dir(dir))
-					box_expand(dir);
-			} else {
-				dir-&gt;pz=dir-&gt;detached*0.2+1.0;
-				ani_add(dir);
-			}
+	switch (dir-&gt;disp) {
+	case D_DIR:
+		if (focus!=dir) {
+			dir-&gt;detached=dir-&gt;detached?0:1; /* swap again, we actually don't want to have it detachedf now. */
 			focus_set(dir);
-			break;
+		}
+		if (dir-&gt;parent!=NULL)
+			box_order_subdirs(dir-&gt;parent);
+		break;
+	case D_ICON:
+		if (dir-&gt;type==T_FOLDER) {
+			dir-&gt;detached=0;
+			if (!parse_dir(dir))
+				box_expand(dir);
+		} else {
+			dir-&gt;pz=dir-&gt;detached*0.2+1.0;
+			ani_add(dir);
+		}
+		focus_set(dir);
+		break;
 	}
 }
 /* change color etc if a node is focused */
 void node_focus_color(t_node *node, int on)
 {
-	switch (node-&gt;disp)
-	{
-		case D_DIR:  box_focus_color(node,on);	break;
-		case D_ICON: icon_focus_color(node,on); break;
+	switch (node-&gt;disp) {
+	case D_DIR:
+		box_focus_color(node,on);
+		break;
+	case D_ICON:
+		icon_focus_color(node,on);
+		break;
 	}
 }
 /* get the directory of a node */

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/parse.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * main.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -37,34 +37,30 @@
 	DIR	 *dirhd=NULL;
 	char *ext,*nstr=NULL;
 	char path[M_DIR];
-	char ndir[M_DIR]; 
-	
+	char ndir[M_DIR];
+
 	printf(&quot;parse_dir( %s )\n&quot;,dir-&gt;name);
 	node_path(dir,path);
-	for (i=0;i&lt;dir-&gt;n_sub;i++)
-	{
+	for (i=0;i&lt;dir-&gt;n_sub;i++) {
 		dir-&gt;sub[i]-&gt;check=1;
 	}
-    n = i = scandir(path, &amp;namelist, 0, alphasort);
-    if (n &lt; 0)
-	{
+	n = i = scandir(path, &amp;namelist, 0, alphasort);
+	if (n &lt; 0) {
 		window_fs_errno(path);
 		return(-1);
 	} else {
 		oldn=dir-&gt;n_sub;
-        while(n--) {
+		while (n--) {
 			nstr = namelist[n]-&gt;d_name;
 			/* setup kids in the sub */
 			for (i=0;i&lt;oldn;i++) /* see if it's already there */
 				if (dir-&gt;sub[i])
-				if (0==strcmp(namelist[n]-&gt;d_name,dir-&gt;sub[i]-&gt;name))
-					break;
- 		    if ((0!=strcmp(nstr,&quot;.&quot;)) &amp;&amp; (0!=strcmp(nstr,&quot;..&quot;))) /* we don't care about those */
-			{
-				if (i==oldn)
-				{	/* it's new, add it, initialize it ... */
+					if (0==strcmp(namelist[n]-&gt;d_name,dir-&gt;sub[i]-&gt;name))
+						break;
+			if ((0!=strcmp(nstr,&quot;.&quot;)) &amp;&amp; (0!=strcmp(nstr,&quot;..&quot;))) { /* we don't care about those */
+				if (i==oldn) {	/* it's new, add it, initialize it ... */
 					i=dir-&gt;n_sub;
-					/* i now holds the right index in sub, so we use dir-&gt;sub[i] 
+					/* i now holds the right index in sub, so we use dir-&gt;sub[i]
 					 * to reference the new item now... */
 					dir-&gt;n_sub++;
 					dir-&gt;sub = realloc( dir-&gt;sub , dir-&gt;n_sub * sizeof(t_node *) );
@@ -78,10 +74,9 @@
 				dir-&gt;sub[i]-&gt;pindex=i;
 				ext=strrchr(nstr,'.');
 				strncpy(ndir,path,M_DIR);
-		    	strncat(ndir,namelist[n]-&gt;d_name,M_DIR);
-			    if ((namelist[n]-&gt;d_type==DT_DIR) || ((namelist[n]-&gt;d_type==DT_UNKNOWN)))
-					if ((dirhd=opendir(ndir))!=NULL)
-					{
+				strncat(ndir,namelist[n]-&gt;d_name,M_DIR);
+				if ((namelist[n]-&gt;d_type==DT_DIR) || ((namelist[n]-&gt;d_type==DT_UNKNOWN)))
+					if ((dirhd=opendir(ndir))!=NULL) {
 						dir-&gt;sub[i]-&gt;type=T_FOLDER;
 						closedir(dirhd);
 					} /*else if (ext!=NULL)
@@ -91,13 +86,12 @@
 						   }	*/
 				dir-&gt;sub[i]-&gt;check=0; /* check=0 means we've already processed this item */
 			}
-	   	    free(namelist[n]);
+			free(namelist[n]);
 		}
 		free(namelist);
 		dir-&gt;check=0;
 		for (i=0;i&lt;dir-&gt;n_sub;i++)
-			if (dir-&gt;sub[i]-&gt;check) 
-			{
+			if (dir-&gt;sub[i]-&gt;check) {
 				/* not checked yet... that means the item is not in the reparsed directory, ie vanished.
 				 * so we're removing it from our queue */
 				node_delete(dir-&gt;sub[i]);
@@ -109,7 +103,7 @@
 		/* if we removed something, then shrink the buffer accordingly .. */
 		if (dir-&gt;check)		dir-&gt;sub = realloc( dir-&gt;sub , dir-&gt;n_sub * sizeof(t_node *) );
 		dir-&gt;parsed=1;
-   	}
+	}
 	return(0);
 }
 

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/s3dfm.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * s3dfm.h
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -60,13 +60,13 @@
 	int				 parsed,detached;					/* Flags for parsed/detached (selected) nodes ... */
 	int 			 oid;								/* main oid, e.g the block or icons oid */
 	int 			 pindex;							/* the index in parents structure */
-	struct 			 {	
+	struct 			 {
 		/* some objects which might be used ... if not, should be -1 */
 		int 		 close,select,title,titlestr; /* box decorations. */
 		int 		 str;						  /* the name of the nodeas s3d object */
 		float		 strlen;					  /* the length of this string */
-		
-		
+
+
 	} 				 objs;
 	int 			 check;							    /* check marker, for internal things */
 };
@@ -93,8 +93,8 @@
 	ESTATE_NONE,
 	ESTATE_RISE,
 	ESTATE_WAIT_FOR_CONFIRM
-		/* TODO: more states should be added and handed back to the filesystem processor, like 
-		 * skip, abort, retry ... */
+	/* TODO: more states should be added and handed back to the filesystem processor, like
+	 * skip, abort, retry ... */
 };
 typedef struct _filelist filelist;
 typedef struct _t_node   t_node;

Modified: trunk/apps/s3dfm/string.c
===================================================================
--- trunk/apps/s3dfm/string.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/string.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,30 +5,30 @@
  *
  * This file is part of s3dfm, a s3d file manager.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-/* just a few helper functions which only operate on strings, so we put them 
+/* just a few helper functions which only operate on strings, so we put them
  * here ... */
 
 #include &quot;s3dfm.h&quot;
 #include &lt;string.h&gt; /* strlen(), strncpy() */
 
-/* writes the path of the item d in string str with bufferlength n, 
- * adds some dots to the beginning if its too long */ 
+/* writes the path of the item d in string str with bufferlength n,
+ * adds some dots to the beginning if its too long */
 char *dots_at_start(char *str, unsigned int n, t_node *d)
 {
 	char *s=str;
@@ -37,18 +37,16 @@
 	s[n-1]=0;
 	do {
 		j=strlen(d-&gt;name)-1;
-		if (NULL!=(d-&gt;parent))
-		{
+		if (NULL!=(d-&gt;parent)) {
 			s[i]='/';
 			i--;
 		}
-		while ((i &gt;= 0) &amp;&amp; (j &gt;= 0))
-		{
+		while ((i &gt;= 0) &amp;&amp; (j &gt;= 0)) {
 			s[i]=d-&gt;name[j];
 			j--;
 			i--;
 		}
-		if (i&lt;0) 
+		if (i&lt;0)
 			break;
 	} while ((d=d-&gt;parent)!=NULL);
 	if (i&lt;0)			s[0]=s[1]='.';
@@ -63,8 +61,7 @@
 	int p;
 	p=0;
 	st[0]=0;
-	while (i&gt;0)
-	{
+	while (i&gt;0) {
 		if ((p+1)%4==0) {
 			st[p]='.';
 			p++;
@@ -86,9 +83,8 @@
 	int i,j;
 	dest[n-1]=0;						/* for malformed destinations */
 	j=0;
-	for (i=strlen(dest);i&lt;(n-1);i++)
-	{
-		dest[i]=src[j]; 
+	for (i=strlen(dest);i&lt;(n-1);i++) {
+		dest[i]=src[j];
 		if (dest[i]==0) break;
 		j++;
 	}

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/db.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * db.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -55,13 +55,13 @@
 {
 	char addquery[MAXQ];
 	node-&gt;base.tagid= tagid++;
-	
+
 	if (node-&gt;base.id==0) /* give own id */
 		snprintf(addquery,MAXQ,&quot;INSERT INTO node (layer_id, latitude, longitude, altitude, visible, tag_id) VALUES (%d, %f, %f, %f, %d, %d);&quot;,
-						(int)node-&gt;base.layerid,				node-&gt;lat,		node-&gt;lon,		node-&gt;alt,		node-&gt;visible, 		(int)node-&gt;base.tagid);
+		         (int)node-&gt;base.layerid,				node-&gt;lat,		node-&gt;lon,		node-&gt;alt,		node-&gt;visible, 		(int)node-&gt;base.tagid);
 	else
 		snprintf(addquery,MAXQ,&quot;INSERT INTO node (layer_id, node_id,latitude, longitude, altitude, visible, tag_id) VALUES (%d, %d, %f, %f, %f, %d, %d);&quot;,
-					(int)node-&gt;base.layerid,(int)node-&gt;base.id,	node-&gt;lat,		node-&gt;lon,		node-&gt;alt,		node-&gt;visible, 		(int)node-&gt;base.tagid);
+		         (int)node-&gt;base.layerid,(int)node-&gt;base.id,	node-&gt;lat,		node-&gt;lon,		node-&gt;alt,		node-&gt;visible, 		(int)node-&gt;base.tagid);
 
 	db_exec(addquery, NULL, 0);
 	return(0);
@@ -71,19 +71,18 @@
 {
 	char addquery[MAXQ];
 	seg-&gt;base.tagid=tagid++;
-	
 
-	if (seg-&gt;base.id==0) /* give own id */
-	{
+
+	if (seg-&gt;base.id==0) { /* give own id */
 		printf(&quot;ugh, segment id is 0!\n&quot;);
 		exit(0);
 	}
-/*	if (seg-&gt;base.id==0) / * give own id * /
-		snprintf(addquery,MAXQ,&quot;INSERT INTO segment (layer_id, node_from, node_to, tag_id) VALUES (%d, %d, %d), %d;&quot;,
-						(int)seg-&gt;base.layerid,				(int)seg-&gt;from, (int)seg-&gt;to,	tagid );
-	else*/
-		snprintf(addquery,MAXQ,&quot;INSERT INTO segment (layer_id, seg_id, node_from, node_to, tag_id) VALUES (%d, %d, %d, %d, %d);&quot;,
-						(int)seg-&gt;base.layerid,(int)seg-&gt;base.id,(int)seg-&gt;from, (int)seg-&gt;to,	(int)seg-&gt;base.tagid );
+	/*	if (seg-&gt;base.id==0) / * give own id * /
+			snprintf(addquery,MAXQ,&quot;INSERT INTO segment (layer_id, node_from, node_to, tag_id) VALUES (%d, %d, %d), %d;&quot;,
+							(int)seg-&gt;base.layerid,				(int)seg-&gt;from, (int)seg-&gt;to,	tagid );
+		else*/
+	snprintf(addquery,MAXQ,&quot;INSERT INTO segment (layer_id, seg_id, node_from, node_to, tag_id) VALUES (%d, %d, %d, %d, %d);&quot;,
+	         (int)seg-&gt;base.layerid,(int)seg-&gt;base.id,(int)seg-&gt;from, (int)seg-&gt;to,	(int)seg-&gt;base.tagid );
 	db_exec(addquery, NULL, 0);
 
 	return(0);
@@ -111,21 +110,22 @@
 	char clayer[MAXQ];
 	int layerid=-1;
 	clean_string(clayer,layer_name,MAXQ);
-	
+
 	snprintf(findquery, MAXQ, &quot;SELECT layer_id FROM layer WHERE name='%s';&quot;, clayer);
-    db_exec(findquery, db_getint, &amp;layerid);
-	if (layerid==-1) /* need to add */
-	{
+	db_exec(findquery, db_getint, &amp;layerid);
+	if (layerid==-1) { /* need to add */
 		snprintf(addquery, MAXQ, &quot;INSERT INTO layer(name) VALUES ('%s');&quot;, clayer);
-    	db_exec(addquery, NULL, 0);db_flush();
-    	db_exec(findquery, db_getint, &amp;layerid);
+		db_exec(addquery, NULL, 0);
+		db_flush();
+		db_exec(findquery, db_getint, &amp;layerid);
 	}
 	return(layerid);
 }
 #define MAGIC	1337 /* just to elevate the nodes a little bit */
 static int found=0;
 /* tries to find node coordinates of ip, returns 1 if has found something */
-int db_olsr_check(char *ip, float *pos) {
+int db_olsr_check(char *ip, float *pos)
+{
 	char findquery[MAXQ];
 	char clean_ip[16];
 	float p[6];
@@ -133,11 +133,11 @@
 	clean_string(clean_ip,ip,16);
 	if (NULL!=(s=strchr(clean_ip,'/')))  /* don't process ip's with subnet information */
 		*s=0; /* TERMINATING ZERO!! */
-	
+
 	snprintf(findquery, MAXQ, &quot;SELECT latitude, longitude, altitude FROM node WHERE tag_id=(SELECT tag_id FROM tag WHERE tagkey='ip' AND tagvalue='%s');&quot;, clean_ip);
 	found=MAGIC;
-   	db_exec(findquery, db_getpoint, p);
-	if (found==1) { 
+	db_exec(findquery, db_getpoint, p);
+	if (found==1) {
 		pos[0]=p[0];
 		pos[1]=p[1];
 		pos[2]=p[2];
@@ -145,12 +145,13 @@
 		return(1);
 	}
 	found=0;
-	return(0);	
+	return(0);
 }
 /* initializes the starting point of nodes  by averaging its lon/lat */
-int db_olsr_node_init(float *pos) {
+int db_olsr_node_init(float *pos)
+{
 	found=0;
-   	db_exec(&quot;SELECT AVG(latitude) as latitude, AVG(longitude) as longitude, AVG(altitude) as altitude FROM node WHERE tag_id IN (SELECT tag_id FROM tag WHERE tagkey='ip');&quot;, db_getpoint, pos);
+	db_exec(&quot;SELECT AVG(latitude) as latitude, AVG(longitude) as longitude, AVG(altitude) as altitude FROM node WHERE tag_id IN (SELECT tag_id FROM tag WHERE tagkey='ip');&quot;, db_getpoint, pos);
 	printf(&quot;pos = %3.3f %3.3f %3.3f\n&quot;,pos[0],pos[1],pos[2]);
 	return(0);	/* return 1 if something is found, 0 if pos[0] its still 0 */
 }
@@ -162,15 +163,21 @@
 	float lo=0.0,la=0.0,alt=0.0;
 	float *p=data;
 	int i;
-	for(i=0; i&lt;argc; i++){
+	for (i=0; i&lt;argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],&quot;longitude&quot;))			lo=strtod(argv[i],NULL);
 			else if (0==strcmp(azColName[i],&quot;latitude&quot;))		la=strtod(argv[i],NULL);
 			else if (0==strcmp(azColName[i],&quot;altitude&quot;))		alt=strtod(argv[i],NULL);
 		}
 	}
-	if (lo==0.0)	{	printf(&quot;missing lo\n&quot;);	exit(0);	}
-	if (la==0.0)	{	printf(&quot;missing la\n&quot;);	exit(0); 	}
+	if (lo==0.0)	{
+		printf(&quot;missing lo\n&quot;);
+		exit(0);
+	}
+	if (la==0.0)	{
+		printf(&quot;missing la\n&quot;);
+		exit(0);
+	}
 	if (found==MAGIC) alt=2;
 	calc_earth_to_eukl(la,lo,alt,p);
 	p[3]=la;
@@ -181,14 +188,16 @@
 }
 
 /* sqlite3-callback to get an integer of the database */
-int db_getint(void *tagid, int argc, char **argv, char **azColName){
-  if (argv[0]!=NULL) 
-	  *((int *)tagid)=atoi(argv[0]);
-  return 0;
+int db_getint(void *tagid, int argc, char **argv, char **azColName)
+{
+	if (argv[0]!=NULL)
+		*((int *)tagid)=atoi(argv[0]);
+	return 0;
 }
 
 /* sqlite3-callback to get a string of the database */
-static int db_getstr(void *string, int argc, char **argv, char **azColName) {
+static int db_getstr(void *string, int argc, char **argv, char **azColName)
+{
 	if (argv[0])
 		strncpy((char *)string,argv[0],MAXQ);
 	return(0);
@@ -204,19 +213,20 @@
 	return(target[0]==0);
 }
 
-int callback(void *NotUsed, int argc, char **argv, char **azColName){
-  int i;
-  for(i=0; i&lt;argc; i++){
-    printf(&quot;%s = %s\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;);
-  }
-  printf(&quot;\n&quot;);
-  return 0;
+int callback(void *NotUsed, int argc, char **argv, char **azColName)
+{
+	int i;
+	for (i=0; i&lt;argc; i++) {
+		printf(&quot;%s = %s\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;);
+	}
+	printf(&quot;\n&quot;);
+	return 0;
 }
 static int db_really_exec(const char *query, sqlite3_callback callback, void *arg)
 {
 	char *zErrMsg = 0;
 	int rc;
-	if(SQLITE_OK !=(  rc = sqlite3_exec(db, query, callback, arg, &amp;zErrMsg))) {
+	if (SQLITE_OK !=(  rc = sqlite3_exec(db, query, callback, arg, &amp;zErrMsg))) {
 		fprintf(stderr,&quot;query: %s\n&quot;,query);
 		fprintf(stderr, &quot;SQL error: %s\n&quot;, zErrMsg);
 		exit(-1);
@@ -236,8 +246,7 @@
 {
 	int ret;
 #ifdef DB_STACK
-	if (callback==NULL) /* we can stack it */
-	{
+	if (callback==NULL) { /* we can stack it */
 		int len;
 		len=strlen(query);
 		if (len+qlen&gt;=QBUF)
@@ -245,36 +254,35 @@
 		strncat(qbuf,query,QBUF);
 		qlen+=strlen(query);
 		ret=0;
-	} else 
-#endif
-	{
+	} else
+#endif {
 		ret=db_really_exec(query,callback,arg);		/* pass it to the real function */
-	}
-	return(ret);
 }
+return(ret);
+}
 int db_init(char *dbFile)
 {
-  int rc;
-  tagid=1;
-  qbuf[0]=0;		/* clear querybuffer */
-  qlen=0;
+	int rc;
+	tagid=1;
+	qbuf[0]=0;		/* clear querybuffer */
+	qlen=0;
 
-  unlink(dbFile);	/* remove if already there */
-  rc = sqlite3_open(dbFile, &amp;db);
-  if( rc ){
-    fprintf(stderr, &quot;Can't open database: %s\n&quot;, sqlite3_errmsg(db));
-    sqlite3_close(db);
-    return(-1);
-  }
-  return(0);
+	unlink(dbFile);	/* remove if already there */
+	rc = sqlite3_open(dbFile, &amp;db);
+	if ( rc ) {
+		fprintf(stderr, &quot;Can't open database: %s\n&quot;, sqlite3_errmsg(db));
+		sqlite3_close(db);
+		return(-1);
+	}
+	return(0);
 }
 int db_quit()
 {
-  sqlite3_close(db);
-  if (dbFile!=NULL) 
-	if (unlink(dbFile))
-		perror(&quot;db_quit()&quot;);
-  return(0);
+	sqlite3_close(db);
+	if (dbFile!=NULL)
+		if (unlink(dbFile))
+			perror(&quot;db_quit()&quot;);
+	return(0);
 }
 int db_create()
 {
@@ -283,7 +291,7 @@
 	db_exec(&quot;CREATE TABLE way (layer_id INTEGER, way_id INTEGER, tag_id INT, s3doid INT, PRIMARY KEY(layer_id,way_id));&quot;, NULL, 0);
 	db_exec(&quot;CREATE TABLE layer (layer_id INTEGER, name TEXT, PRIMARY KEY(layer_id));&quot;, NULL, 0);
 	db_exec(&quot;CREATE TABLE tag (tag_id INT, tagkey TEXT, tagvalue TEXT, PRIMARY KEY(tag_id, tagkey));&quot;, NULL, 0);
-	
+
 	/*
 	db_exec(&quot;CREATE UNIQUE INDEX node_id_index ON node (node_id,layer_id);&quot;, NULL, 0);
 	db_exec(&quot;CREATE UNIQUE INDEX segment_id_index ON segment (seg_id,layer_id);&quot;, NULL, 0);

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/draw.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * draw.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -82,17 +82,17 @@
 	x[1]=(ESIZE+alt)*			sin(la);
 	x[2]=(ESIZE+alt)*cos(lo) *cos(la);
 }
-int draw_icon(void *data, int argc, char **argv, char **azColName) 
+int draw_icon(void *data, int argc, char **argv, char **azColName)
 {
 	int i,tagid=-1,oid;
 	int nodeid=-1, layerid=-1;
-/*	char query[MAXQ];*/
+	/*	char query[MAXQ];*/
 	char s[MAXQ];
 	float la, lo, alt;
 	float x[3];
 	la=lo=alt=0.0;
 	num_done++;
-	for(i=0; i&lt;argc; i++) {
+	for (i=0; i&lt;argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],&quot;longitude&quot;))			lo=strtod(argv[i],NULL);
 			else if (0==strcmp(azColName[i],&quot;latitude&quot;))		la=strtod(argv[i],NULL);
@@ -121,11 +121,11 @@
 			s3d_link(oid,oidy);
 			s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			load_update_status((100.0*num_done)/(float)num_max);
-/*			snprintf(query,MAXQ,&quot;UPDATE node SET s3doid=%d WHERE node_id=%d AND layer_id=%d;&quot;,oid,nodeid,layerid);
-			db_exec(query, NULL, 0);*/
+			/*			snprintf(query,MAXQ,&quot;UPDATE node SET s3doid=%d WHERE node_id=%d AND layer_id=%d;&quot;,oid,nodeid,layerid);
+						db_exec(query, NULL, 0);*/
 		}
-				
-	} 
+
+	}
 	return(0);
 }
 /* just fetches node information and puts in the nodelist */
@@ -133,7 +133,7 @@
 {
 	struct nodelist *np=data;	/* get the nodepointer */
 	int i;
-	for(i=0; i&lt;argc; i++){
+	for (i=0; i&lt;argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],&quot;longitude&quot;))			np[nodelist_n].lo=strtod(argv[i],NULL);
 			else if (0==strcmp(azColName[i],&quot;latitude&quot;))		np[nodelist_n].la=strtod(argv[i],NULL);
@@ -145,13 +145,13 @@
 int select_waytype(void *data, int argc, char **argv, char **azColName)
 {
 	int i;
-	for(i=0; i&lt;argc; i++){
+	for (i=0; i&lt;argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(argv[i],&quot;motorway&quot;))				*((int *) data)=5;	
-			else if (0==strcmp(argv[i],&quot;motorway_link&quot;))	*((int *) data)=4;	
-			else if (0==strcmp(argv[i],&quot;primary&quot;))			*((int *) data)=3;	
-			else if (0==strcmp(argv[i],&quot;secondary&quot;))		*((int *) data)=2;	
-			else if (0==strcmp(argv[i],&quot;residential&quot;))		*((int *) data)=1;	
+			if (0==strcmp(argv[i],&quot;motorway&quot;))				*((int *) data)=5;
+			else if (0==strcmp(argv[i],&quot;motorway_link&quot;))	*((int *) data)=4;
+			else if (0==strcmp(argv[i],&quot;primary&quot;))			*((int *) data)=3;
+			else if (0==strcmp(argv[i],&quot;secondary&quot;))		*((int *) data)=2;
+			else if (0==strcmp(argv[i],&quot;residential&quot;))		*((int *) data)=1;
 		}
 	}
 	return(0);
@@ -176,20 +176,25 @@
 
 	if (waylist_n==0)	/* no nodes, no fun */
 		return;
-/*	printf(&quot;way: %d - %d segments\n&quot;,lastid,waylist_n);*/
+	/*	printf(&quot;way: %d - %d segments\n&quot;,lastid,waylist_n);*/
 	way_obj=s3d_new_object();
 	if (lastid!=-1) {
 		snprintf(query,MAXQ,&quot;SELECT tagvalue FROM tag WHERE tag_id=(SELECT tag_id FROM way WHERE way_id=%d AND %s) AND tagkey='highway';&quot;,lastid,filter);
 		db_exec(query, select_waytype, &amp;waytype);
 	}
-	switch (waytype)
-	{
-		case 5:s3d_push_material(way_obj,0.2,0.2,0.6,		1.0,1.0,1.0,	0.3,0.3,1.0);	/* motorway */
-		case 4:s3d_push_material(way_obj,0.3,0.3,0.4,		1.0,1.0,1.0,	0.5,0.5,0.8);	/* motorway_link*/
-		case 3:s3d_push_material(way_obj,0.6,0.3,0.1,		1.0,1.0,1.0, 	1.0,0.6,0.2);	/* primary */
-		case 2:s3d_push_material(way_obj,0.6,0.6,0.0,		1.0,1.0,1.0, 	1.0,1.0,0.0);	/* secondary */
-		case 1:s3d_push_material(way_obj,0.6,0.6,0.6,		1.0,1.0,1.0, 	1.0,1.0,1.0);	/* residential */
-		default:s3d_push_material(way_obj,0.6,0.2,0.6,		1.0,1.0,1.0,	1.0,0.5,1.0); /* default */
+	switch (waytype) {
+	case 5:
+		s3d_push_material(way_obj,0.2,0.2,0.6,		1.0,1.0,1.0,	0.3,0.3,1.0);	/* motorway */
+	case 4:
+		s3d_push_material(way_obj,0.3,0.3,0.4,		1.0,1.0,1.0,	0.5,0.5,0.8);	/* motorway_link*/
+	case 3:
+		s3d_push_material(way_obj,0.6,0.3,0.1,		1.0,1.0,1.0, 	1.0,0.6,0.2);	/* primary */
+	case 2:
+		s3d_push_material(way_obj,0.6,0.6,0.0,		1.0,1.0,1.0, 	1.0,1.0,0.0);	/* secondary */
+	case 1:
+		s3d_push_material(way_obj,0.6,0.6,0.6,		1.0,1.0,1.0, 	1.0,1.0,1.0);	/* residential */
+	default:
+		s3d_push_material(way_obj,0.6,0.2,0.6,		1.0,1.0,1.0,	1.0,0.5,1.0); /* default */
 	}
 	street_width=(0.5+waytype/10)/RESCALE;
 	/* put nodes of the graph into a list */
@@ -200,7 +205,7 @@
 		for (j=0;j&lt;nodelist_n;j++)
 			if (nodelist_p[j].node_id==node_id) break;
 		if (j==nodelist_n) { /* we still need to add this node */
-/*			printf(&quot;[way %d] add node %d to nodelist as %d\n&quot;,lastid, node_id, nodelist_n);*/
+			/*			printf(&quot;[way %d] add node %d to nodelist as %d\n&quot;,lastid, node_id, nodelist_n);*/
 			nodelist_p[j].node_id=node_id;
 			snprintf(query,MAXQ,&quot;SELECT longitude, latitude, altitude FROM node WHERE %s AND node_id=%d;&quot;,filter, node_id);
 			db_exec(query, insert_node,(void *)(nodelist_p));
@@ -210,14 +215,13 @@
 			nodelist_p[j].normal[1]=nodelist_p[j].x[1]/len;
 			nodelist_p[j].normal[2]=nodelist_p[j].x[2]/len;
 			nodelist_n++;
-		} 
+		}
 		if (i%2)				waylist_p[i/2].node_from_int=j;
 		else					waylist_p[i/2].node_to_int=j;
 	}
 	V_COPY(point_zero, nodelist_p[0].x);
 	/* iterate for all nodes */
-	for (i=0;i&lt;nodelist_n;i++)
-	{
+	for (i=0;i&lt;nodelist_n;i++) {
 		/* find adjacent segments */
 		adjlist_n=0;
 		node_id=nodelist_p[i].node_id;
@@ -233,13 +237,10 @@
 			}
 		}
 
-		if (adjlist_n&gt;1)	/* more than one adjacent, need to order and calculate intersections */
-		{
-			if (adjlist_n&gt;2) /* no ordering needed for 2 incoming segments */
-			{
+		if (adjlist_n&gt;1) {	/* more than one adjacent, need to order and calculate intersections */
+			if (adjlist_n&gt;2) { /* no ordering needed for 2 incoming segments */
 				for (j=0;j&lt;adjlist_n-2;j++)
-					for (k=j+2;k&lt;adjlist_n;k++)
-					{
+					for (k=j+2;k&lt;adjlist_n;k++) {
 						float test[3],normal[3],linevector[3];
 						/* (re)calc test direction */
 						V_SUB(nodelist_p[adjlist_p[j].node_id].x,	nodelist_p[adjlist_p[j+1].node_id].x,	linevector);
@@ -248,7 +249,7 @@
 							/* determine on which side the point is. if its between our testvector, we'll need to swap. */
 							V_SUB(nodelist_p[adjlist_p[j].node_id].x,nodelist_p[adjlist_p[k].node_id].x,test);
 							if (s3d_vector_dot_product(normal,test)&gt;0) { /* same side, means adjacent line k is nearer to our point j
-																			than our point j+1 which is supposed to be the nearest point, 
+																			than our point j+1 which is supposed to be the nearest point,
 																			so we swap them and call a break to get the new test-normal */
 								struct adjlist swap;
 								memcpy(&amp;swap,&amp;(adjlist_p[j+1]),sizeof(struct adjlist));
@@ -266,8 +267,7 @@
 			V_NORM(right);
 
 
-			for (j=0;j&lt;adjlist_n;j++)
-			{
+			for (j=0;j&lt;adjlist_n;j++) {
 				swap=left;
 				left=right;			/* use last right segment as new left segment */
 				right=swap;			/* get space for the next right segment */
@@ -285,8 +285,7 @@
 				V_SCAL(n,1/n_len);	/* normalize n first! */
 				scale=V_DOT(n,an);	/* get cos (alpha/2), alpha is opposite angel of left and right segment */
 
-				if ((n_len&lt;0.1) || (fabs(scale)&lt;0.1))
-				{	/* too low, don't use, just have intersection 90 degree of it. */
+				if ((n_len&lt;0.1) || (fabs(scale)&lt;0.1)) {	/* too low, don't use, just have intersection 90 degree of it. */
 					V_SCAL(an, -street_width);		/* S = P + street_width * an */
 					V_ADD(nodelist_p[i].x, an, s);
 
@@ -294,22 +293,22 @@
 					V_SCAL(n,-street_width/scale);
 					V_ADD(s, n, s);
 				}
-				
-				
-/*				printf(&quot;calc intersection: %3.3f %3.3f %3.3f\n&quot;,s[0],s[1],s[2]);*/
-			V_SUB(s,point_zero,s);
+
+
+				/*				printf(&quot;calc intersection: %3.3f %3.3f %3.3f\n&quot;,s[0],s[1],s[2]);*/
+				V_SUB(s,point_zero,s);
 				s3d_push_vertices(way_obj,s,1);
 				adj_seg=adjlist_p[j].seg_id;				/* left segment */
 				if (i==waylist_p[adj_seg].node_from_int)	waylist_p[adj_seg].node_from_r=vert;
-					else									waylist_p[adj_seg].node_to_l=vert;
+				else									waylist_p[adj_seg].node_to_l=vert;
 				adj_seg=adjlist_p[(j+1)%adjlist_n].seg_id;	/* right segment */
 				if (i==waylist_p[adj_seg].node_from_int)	waylist_p[adj_seg].node_from_l=vert;
-					else									waylist_p[adj_seg].node_to_r=vert;
+				else									waylist_p[adj_seg].node_to_r=vert;
 				vert++;
 			}
 			if (adjlist_n&gt;=3) {
 				/* we know that the last adjlist_n vertices set belong to our intersection here .. */
-				for (j=vert-adjlist_n+1;j&lt;(vert-1);j++) 
+				for (j=vert-adjlist_n+1;j&lt;(vert-1);j++)
 					s3d_push_polygon(way_obj, vert-adjlist_n, j, j+1,0 );
 			}
 		} else {
@@ -321,7 +320,7 @@
 
 			V_COPY(s,nodelist_p[i].x);
 			V_ADD(s,an,s);
-			V_SUB(s,point_zero,s); 
+			V_SUB(s,point_zero,s);
 			s3d_push_vertices(way_obj,s,1);
 			j=vert;
 			vert++;
@@ -332,7 +331,7 @@
 			s3d_push_vertices(way_obj,s,1);
 			k=vert;
 			vert++;
-			
+
 			adj_seg=adjlist_p[0].seg_id;
 			if (i==waylist_p[adj_seg].node_from_int)	{
 				waylist_p[adj_seg].node_from_l=j;
@@ -357,7 +356,7 @@
 
 		s3d_push_polygons(way_obj, polys, 2);
 	}
-	s3d_translate(way_obj,point_zero[0], point_zero[1], point_zero[2]); 
+	s3d_translate(way_obj,point_zero[0], point_zero[1], point_zero[2]);
 	s3d_link(way_obj,oidy);
 	s3d_flags_on(way_obj,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	snprintf(query,MAXQ,&quot;UPDATE way SET s3doid=%d WHERE way_id=%d AND %s;&quot;,way_obj,lastid,filter);
@@ -390,7 +389,7 @@
 	p.node_from=p.node_to=0;
 	p.node_to=-1;
 	p.seg_id=-1;
-	for(i=0; i&lt;argc; i++){
+	for (i=0; i&lt;argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],&quot;way_id&quot;))				id=atoi(argv[i]);
 			else if (0==strcmp(azColName[i],&quot;node_from&quot;))		p.node_from=atoi(argv[i]);

Modified: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/gps.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * gps.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -54,7 +54,7 @@
 
 void show_gpsdata(struct gps_data_t *dgps)
 {
-	if (!dgps-&gt;online) 
+	if (!dgps-&gt;online)
 		printf(&quot;WARNING: no connection to gps device\n&quot;);
 #ifdef GPS_NEW
 	printf(&quot;[%d] lat/long: [%f|%f], altitude %f\n&quot;,frame,dgps-&gt;fix.latitude,dgps-&gt;fix.longitude,dgps-&gt;fix.altitude);
@@ -67,22 +67,35 @@
 	printf(&quot;used %d/%d satellits\n&quot;,dgps-&gt;satellites_used,dgps-&gt;satellites);
 
 #endif
-	switch (dgps-&gt;status)
-	{
-		case STATUS_NO_FIX:		printf(&quot;status: no fix\n&quot;);break;
-		case STATUS_FIX:		printf(&quot;status: fix\n&quot;);break;
-		case STATUS_DGPS_FIX:	printf(&quot;status: dgps fix\n&quot;);break;
+	switch (dgps-&gt;status) {
+	case STATUS_NO_FIX:
+		printf(&quot;status: no fix\n&quot;);
+		break;
+	case STATUS_FIX:
+		printf(&quot;status: fix\n&quot;);
+		break;
+	case STATUS_DGPS_FIX:
+		printf(&quot;status: dgps fix\n&quot;);
+		break;
 	}
 #ifdef GPS_NEW
 	switch (dgps-&gt;fix.mode)
-#else 
+#else
 	switch (dgps-&gt;mode)
 #endif
 	{
-		case MODE_NOT_SEEN:	printf(&quot;mode: not seen yet\n&quot;);break;
-		case MODE_NO_FIX:	printf(&quot;mode: no fix\n&quot;);break;
-		case MODE_2D:		printf(&quot;mode: 2d fix\n&quot;);break;
-		case MODE_3D:		printf(&quot;mode: 3d fix\n&quot;);break;
+	case MODE_NOT_SEEN:
+		printf(&quot;mode: not seen yet\n&quot;);
+		break;
+	case MODE_NO_FIX:
+		printf(&quot;mode: no fix\n&quot;);
+		break;
+	case MODE_2D:
+		printf(&quot;mode: 2d fix\n&quot;);
+		break;
+	case MODE_3D:
+		printf(&quot;mode: 3d fix\n&quot;);
+		break;
 	}
 }
 #define BUFSIZE		1024
@@ -92,40 +105,53 @@
 	float la,lo,heading,speed,slen;
 	char buf[BUFSIZE+1];
 #ifdef GPS_NEW
-	if (!dgps-&gt;online) 
+	if (!dgps-&gt;online)
 		fix=0;
-	switch (dgps-&gt;fix.mode)
-	{
-		case MODE_NOT_SEEN:	fix=0;break;
-		case MODE_NO_FIX:	fix=0;break;
+	switch (dgps-&gt;fix.mode) {
+	case MODE_NOT_SEEN:
+		fix=0;
+		break;
+	case MODE_NO_FIX:
+		fix=0;
+		break;
 	}
-	
+
 	la=dgps-&gt;fix.latitude;
 	lo=dgps-&gt;fix.longitude;
 	heading=-dgps-&gt;fix.track;
 	speed=dgps-&gt;fix.speed;
 
 #else
-	if (!dgps-&gt;online) 
+	if (!dgps-&gt;online)
 		fix=0;
-	switch (dgps-&gt;mode)
-	{
-		case MODE_NOT_SEEN:	fix=0;break;
-		case MODE_NO_FIX:	fix=0;break;
+	switch (dgps-&gt;mode) {
+	case MODE_NOT_SEEN:
+		fix=0;
+		break;
+	case MODE_NO_FIX:
+		fix=0;
+		break;
 	}
 	la=dgps-&gt;latitude;
 	lo=dgps-&gt;longitude;
 	heading=-dgps-&gt;track;
 	speed=dgps-&gt;speed*KNOTS_TO_MPH/METERS_TO_MILES/3600; /* speed in knots -&gt; miles per hour -&gt; meter per hour -&gt; meter per secon */
 #endif
-	tlat=la;tlon=lo;
+	tlat=la;
+	tlon=lo;
 	if (fix) {
 		printf(&quot;have a fix\n&quot;);
 		nav_center(la,lo);
 		if (!finitef(heading)) {
 			heading=get_heading(lat_old,lon_old,la,lo);
-			if (!lastfix &amp;&amp; fix) 		{s3d_scale(user_icon,1.0/RESCALE);}
-			if (lastfix &amp;&amp; !fix)		{s3d_scale(user_icon,0.3/RESCALE);lat=tlat;lon=tlon;}
+			if (!lastfix &amp;&amp; fix) 		{
+				s3d_scale(user_icon,1.0/RESCALE);
+			}
+			if (lastfix &amp;&amp; !fix)		{
+				s3d_scale(user_icon,0.3/RESCALE);
+				lat=tlat;
+				lon=tlon;
+			}
 		}
 		if (finitef(heading))		s3d_rotate(user_icon,0,heading,0); /* wrong rotation? */
 		if (finitef(speed)) {
@@ -134,15 +160,15 @@
 			speed_old=speed;
 		} else
 			snprintf(buf,BUFSIZE,&quot;speed: NA (old: %3.2f km/h)&quot;,speed_old*3.6);
-	
+
 		if (gps_info!=-1)	s3d_del_object(gps_info);
 		gps_info=s3d_draw_string(buf,&amp;slen);
 		s3d_translate(gps_info,-slen/2,1,0);
 		s3d_link(gps_info, user_icon);
 		s3d_flags_on(gps_info,S3D_OF_VISIBLE);
 	}
-	
-	
+
+
 	lat_old=la;
 	lon_old=lo;
 	lastfix=fix;
@@ -151,24 +177,38 @@
 {
 	char *err_str;
 	dgps=gps_open(gpshost,&quot;2947&quot;);
-    if (dgps==NULL) {
+	if (dgps==NULL) {
 		switch ( errno ) {
-			case NL_NOSERVICE: 	err_str = &quot;can't get service entry&quot;; break;
-			case NL_NOHOST: 	err_str = &quot;can't get host entry&quot;; break;
-			case NL_NOPROTO: 	err_str = &quot;can't get protocol entry&quot;; break;
-			case NL_NOSOCK: 	err_str = &quot;can't create socket&quot;; break;
-			case NL_NOSOCKOPT: 	err_str = &quot;error SETSOCKOPT SO_REUSEADDR&quot;; break;
-			case NL_NOCONNECT: 	err_str = &quot;can't connect to host&quot;; break;
-			default:           	err_str = &quot;Unknown&quot;; break;
+		case NL_NOSERVICE:
+			err_str = &quot;can't get service entry&quot;;
+			break;
+		case NL_NOHOST:
+			err_str = &quot;can't get host entry&quot;;
+			break;
+		case NL_NOPROTO:
+			err_str = &quot;can't get protocol entry&quot;;
+			break;
+		case NL_NOSOCK:
+			err_str = &quot;can't create socket&quot;;
+			break;
+		case NL_NOSOCKOPT:
+			err_str = &quot;error SETSOCKOPT SO_REUSEADDR&quot;;
+			break;
+		case NL_NOCONNECT:
+			err_str = &quot;can't connect to host&quot;;
+			break;
+		default:
+			err_str = &quot;Unknown&quot;;
+			break;
 		}
-/*		printf(&quot;no connection to gpsd\n&quot;);*/
+		/*		printf(&quot;no connection to gpsd\n&quot;);*/
 		fprintf(stderr, &quot;s3dosm: no gpsd running or network error: %d, %s\n&quot;	,  errno, err_str);
 		return(-1);
 	}
 	user_icon=s3d_clone(icons[ICON_ARROW].oid);
 	user_icon_rotator=s3d_new_object();
 	s3d_link(user_icon,user_icon_rotator);
-	s3d_link(user_icon_rotator,oidy); 
+	s3d_link(user_icon_rotator,oidy);
 	s3d_flags_on(user_icon,S3D_OF_VISIBLE);
 	s3d_scale(user_icon,1.0/RESCALE);
 	tlat=lat=lat_old=0.0;
@@ -179,10 +219,8 @@
 }
 int gps_main()
 {
-	if (gps_active &amp;&amp; ((frame%6)==0))
-	{
-		if (gps_poll(dgps) &lt; 0) 
-		{
+	if (gps_active &amp;&amp; ((frame%6)==0)) {
+		if (gps_poll(dgps) &lt; 0) {
 			printf(&quot;read error on server socket\n&quot;);
 			gps_quit();
 		}
@@ -198,15 +236,17 @@
 			lat=(tlat+lat*7)/8;
 			lon=(tlon+lon*7)/8;
 		}
-	} else { tlat=lat;tlon=lon;}
+	} else {
+		tlat=lat;
+		tlon=lon;
+	}
 	draw_translate_icon(user_icon_rotator,lat,lon);
 	frame++;
 	return(0);
 }
 int gps_quit()
 {
-	if (gps_active)
-	{
+	if (gps_active) {
 		printf(&quot;deactivating gps-connection ...\n&quot;);
 		gps_active=0;
 		gps_close(dgps);

Modified: trunk/apps/s3dosm/http_error_codes.c
===================================================================
--- trunk/apps/s3dosm/http_error_codes.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/http_error_codes.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,6 +1,6 @@
 /* http_error_codes.c - Error code declarations
 
-	HTTP Fetcher 
+	HTTP Fetcher
  	Copyright (C) 2001 Lyle Hanson (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lhanson at cs.nmu.edu</A>)
 
 	This library is free software; you can redistribute it and/or
@@ -17,9 +17,8 @@
  */
 
 
-	/* Note that '%d' cannot be escaped at this time */
-const char *http_errlist[] =
-	{
+/* Note that '%d' cannot be escaped at this time */
+const char *http_errlist[] = {
 	&quot;Success&quot;,										/* HF_SUCCESS		*/
 	&quot;Internal Error. What the hell?!&quot;,				/* HF_METAERROR		*/
 	&quot;Got NULL url&quot;,									/* HF_NULLURL		*/
@@ -29,8 +28,8 @@
 	&quot;Couldn't convert return code in HTTP response&quot;,/* HF_CRETURNCODE	*/
 	&quot;Request returned a status code of %d&quot;,			/* HF_STATUSCODE	*/
 	&quot;Couldn't convert Content-Length to integer&quot;	/* HF_CONTENTLEN	*/
-	};
+};
 
-	/* Used to copy in messages from http_errlist[] and replace %d's with
-	 *	the value of errorInt.  Then we can pass the pointer to THIS */
+/* Used to copy in messages from http_errlist[] and replace %d's with
+ *	the value of errorInt.  Then we can pass the pointer to THIS */
 char convertedError[128];

Modified: trunk/apps/s3dosm/http_fetcher.c
===================================================================
--- trunk/apps/s3dosm/http_fetcher.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/http_fetcher.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -14,10 +14,10 @@
 
 	See included LICENSE file for details
 
-	Changes: 
+	Changes:
 		Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
 		+ added http_setAuth() to support basic http-authentication and some minor fixes
-		
+
  */
 
 #include &lt;stdlib.h&gt;
@@ -48,14 +48,14 @@
 static int freeOldReferer = 0; /* Indicated previous malloc's */
 
 
-	/* 
-	 * Actually downloads the page, registering a hit (donation)
-	 *	If the fileBuf passed in is NULL, the url is downloaded and then
-	 *	freed; otherwise the necessary space is allocated for fileBuf.
-	 *	Returns size of download on success, -1 on error is set, 
-	 */
+/*
+ * Actually downloads the page, registering a hit (donation)
+ *	If the fileBuf passed in is NULL, the url is downloaded and then
+ *	freed; otherwise the necessary space is allocated for fileBuf.
+ *	Returns size of download on success, -1 on error is set,
+ */
 int http_fetch(const char *url_tmp, char **fileBuf)
-	{
+{
 	fd_set rfds;
 	struct timeval tv;
 	char requestBuf[REQUEST_BUF_SIZE];
@@ -65,46 +65,41 @@
 	int ret = -1, i, selectRet;
 
 
-	if(url_tmp == NULL)
-		{
+	if (url_tmp == NULL) {
 		errorSource = FETCHER_ERROR;
 		http_errno = HF_NULLURL;
 		return -1;
-		}
+	}
 
 	/* Copy the url passed in into a buffer we can work with, change, etc. */
 	url = malloc(strlen(url_tmp)+1);
-	if(url == NULL)
-		{
+	if (url == NULL) {
 		errorSource = ERRNO;
 		return -1;
-		}
+	}
 	strncpy(url, url_tmp, strlen(url_tmp) + 1);
-	
+
 	/* Seek to the file path portion of the url */
 	charIndex = strstr(url, &quot;://&quot;);
-	if(charIndex != NULL)
-		{
+	if (charIndex != NULL) {
 		/* url contains a protocol field */
 		charIndex += strlen(&quot;://&quot;);
 		host = charIndex;
 		charIndex = strchr(charIndex, '/');
-		}
-	else
-		{
+	} else {
 		host = (char *)url;
 		charIndex = strchr(url, '/');
-		}
+	}
 
 	/* Compose a request string */
-	if(charIndex == NULL)
+	if (charIndex == NULL)
 		/* The url has no '/' in it, assume the user is making a root-level
-		 *	request */ 
+		 *	request */
 		sprintf(requestBuf, &quot;GET / %s\r\n&quot;, HTTP_VERSION);
 	else
 		sprintf(requestBuf, &quot;GET %s %s\r\n&quot;, charIndex, HTTP_VERSION);
 	/* Null out the end of the hostname if need be */
-	if(charIndex != NULL)
+	if (charIndex != NULL)
 		*charIndex = 0;
 
 	strcat(requestBuf, &quot;Host: &quot;);
@@ -112,29 +107,24 @@
 	strcat(requestBuf, &quot;\r\n&quot;);
 
 
-	if(!hideReferer &amp;&amp; referer != NULL)	/* NO default referer */
-		{
+	if (!hideReferer &amp;&amp; referer != NULL) {	/* NO default referer */
 		strcat(requestBuf, &quot;Referer: &quot;);
 		strcat(requestBuf, referer);
 		strcat(requestBuf, &quot;\r\n&quot;);
-		}
+	}
 
-	if(!hideUserAgent &amp;&amp; userAgent == NULL)
-		{
+	if (!hideUserAgent &amp;&amp; userAgent == NULL) {
 		strcat(requestBuf, &quot;User-Agent: &quot;);
 		strcat(requestBuf, DEFAULT_USER_AGENT);
 		strcat(requestBuf, &quot;/&quot;);
 		strcat(requestBuf, HTTP_FETCHER_VERSION);
 		strcat(requestBuf, &quot;\r\n&quot;);
-		}
-	else if(!hideUserAgent)
-		{
+	} else if (!hideUserAgent) {
 		strcat(requestBuf, &quot;User-Agent: &quot;);
 		strcat(requestBuf, userAgent);
 		strcat(requestBuf, &quot;\r\n&quot;);
-		}
-	if (auth!=NULL)
-	{
+	}
+	if (auth!=NULL) {
 		strcat(requestBuf, &quot;Authorization: Basic &quot;);
 		strcat(requestBuf, auth);
 		strcat(requestBuf, &quot;\r\n&quot;);
@@ -143,104 +133,107 @@
 
 	printf(&quot;[HTTP] creating connection ...\n&quot;);
 	sock = makeSocket(host);			/* errorSource set within makeSocket */
-	if(sock == -1) { free(url); return -1;}
+	if (sock == -1) {
+		free(url);
+		return -1;
+	}
 	printf(&quot;[HTTP] sending request \n&quot;);
-	if(write(sock, requestBuf, strlen(requestBuf)) == -1)
-		{ close(sock); free(url); errorSource = ERRNO; return -1; }
+	if (write(sock, requestBuf, strlen(requestBuf)) == -1) {
+		close(sock);
+		free(url);
+		errorSource = ERRNO;
+		return -1;
+	}
 
 	printf(&quot;[HTTP] receiving header\n&quot;);
 	/* Grab enough of the response to get the metadata */
 	ret = _http_read_header(sock, headerBuf);	/* errorSource set within */
-	if(ret &lt; 0) { close(sock); free(url); return -1; }
+	if (ret &lt; 0) {
+		close(sock);
+		free(url);
+		return -1;
+	}
 	printf(&quot;[HTTP] receiving content\n&quot;);
 
 	/* Get the return code */
 	charIndex = strstr(headerBuf, &quot;HTTP/&quot;);
-	if(charIndex == NULL)
-		{
+	if (charIndex == NULL) {
 		close(sock);
 		free(url);
 		errorSource = FETCHER_ERROR;
 		http_errno = HF_FRETURNCODE;
 		return -1;
-		}
-	while(*charIndex != ' ')
+	}
+	while (*charIndex != ' ')
 		charIndex++;
 	charIndex++;
 
 	ret = sscanf(charIndex, &quot;%i&quot;, &amp;i);
-	if(ret != 1)
-		{
+	if (ret != 1) {
 		close(sock);
 		free(url);
 		errorSource = FETCHER_ERROR;
 		http_errno = HF_CRETURNCODE;
 		return -1;
-		}
-	if(i&lt;200 || i&gt;299)
-		{
+	}
+	if (i&lt;200 || i&gt;299) {
 		close(sock);
 		free(url);
 		errorInt = i;	/* Status code, to be inserted in error string */
 		errorSource = FETCHER_ERROR;
 		http_errno = HF_STATUSCODE;
 		return -1;
-		}
-	
+	}
+
 	/*
 	 * Parse out about how big the data segment is.
 	 *	Note that under current HTTP standards (1.1 and prior), the
-	 *	Content-Length field is not guaranteed to be accurate or even present. 
+	 *	Content-Length field is not guaranteed to be accurate or even present.
 	 *	I just use it here so I can allocate a ballpark amount of memory.
 	 *
 	 * Note that some servers use different capitalization
 	 */
 	charIndex = strstr(headerBuf, &quot;Content-Length:&quot;);
-	if(charIndex == NULL)
+	if (charIndex == NULL)
 		charIndex = strstr(headerBuf, &quot;Content-length:&quot;);
 
-	if(charIndex != NULL)
-		{
+	if (charIndex != NULL) {
 		ret = sscanf(charIndex + strlen(&quot;content-length: &quot;), &quot;%i&quot;,
-			&amp;contentLength);
-		if(ret &lt; 1)
-			{
+		             &amp;contentLength);
+		if (ret &lt; 1) {
 			close(sock);
 			free(url);
 			errorSource = FETCHER_ERROR;
 			http_errno = HF_CONTENTLEN;
 			return -1;
-			}
 		}
-	
+	}
+
 	/* Allocate enough memory to hold the page */
-	if(contentLength == -1)
+	if (contentLength == -1)
 		contentLength = DEFAULT_PAGE_BUF_SIZE;
 
 	pageBuf = (char *)malloc(contentLength+1);
-	if(pageBuf == NULL)
-		{
+	if (pageBuf == NULL) {
 		close(sock);
 		free(url);
 		errorSource = ERRNO;
 		return -1;
-		}
+	}
 
 	/* Begin reading the body of the file */
-	while(ret &gt; 0)
-		{
+	while (ret &gt; 0) {
 		FD_ZERO(&amp;rfds);
 		FD_SET(sock, &amp;rfds);
-		tv.tv_sec = timeout; 
+		tv.tv_sec = timeout;
 		tv.tv_usec = 0;
 
-		if(timeout &gt;= 0)
+		if (timeout &gt;= 0)
 			selectRet = select(sock+1, &amp;rfds, NULL, NULL, &amp;tv);
 		else		/* No timeout, can block indefinately */
 			selectRet = select(sock+1, &amp;rfds, NULL, NULL, NULL);
 
-		if(selectRet == 0 &amp;&amp; timeout &lt; 0)
-			{
+		if (selectRet == 0 &amp;&amp; timeout &lt; 0) {
 			errorSource = FETCHER_ERROR;
 			http_errno = HF_DATATIMEOUT;
 			errorInt = timeout;
@@ -248,65 +241,59 @@
 			free(url);
 			free(pageBuf);
 			return -1;
-			}
-		else if(selectRet == -1)
-			{
+		} else if (selectRet == -1) {
 			close(sock);
 			free(url);
 			free(pageBuf);
 			errorSource = ERRNO;
 			return -1;
-			}
+		}
 
 		ret = read(sock, pageBuf + bytesRead, contentLength);
-		if(ret == -1)
-			{
+		if (ret == -1) {
 			close(sock);
 			free(url);
 			free(pageBuf);
 			errorSource = ERRNO;
 			return -1;
-			}
+		}
 
 		bytesRead += ret;
 
-		if(ret &gt; 0)
-			{
+		if (ret &gt; 0) {
 			/* To be tolerant of inaccurate Content-Length fields, we'll
 			 *	allocate another read-sized chunk to make sure we have
 			 *	enough room.
 			 */
 			pageBuf = (char *)realloc(pageBuf, bytesRead + contentLength);
-			if(pageBuf == NULL)
-				{
+			if (pageBuf == NULL) {
 				close(sock);
 				free(url);
 				free(pageBuf);
 				errorSource = ERRNO;
 				return -1;
-				}
 			}
+		}
 		printf(&quot;[HTTP] read %d bytes\n&quot;,ret);
-		}
-	
+	}
+
 	/*
 	 * The download buffer is too large.  Trim off the safety padding.
 	 */
 	pageBuf = (char *)realloc(pageBuf, bytesRead);
-		/* pageBuf shouldn't be null, since we're _shrinking_ the buffer,
-		 *	and if it DID fail, we could go on with the too-large buffer,
-		 *	but something would DEFINATELY be wrong, so we'll just give
-		 *	an error message */
-	if(pageBuf == NULL)
-		{
+	/* pageBuf shouldn't be null, since we're _shrinking_ the buffer,
+	 *	and if it DID fail, we could go on with the too-large buffer,
+	 *	but something would DEFINATELY be wrong, so we'll just give
+	 *	an error message */
+	if (pageBuf == NULL) {
 		close(sock);
 		free(url);
 		free(pageBuf);
 		errorSource = ERRNO;
 		return -1;
-		}
+	}
 
-	if(fileBuf == NULL)	/* They just wanted us to &quot;hit&quot; the url */
+	if (fileBuf == NULL)	/* They just wanted us to &quot;hit&quot; the url */
 		free(pageBuf);
 	else
 		*fileBuf = pageBuf;
@@ -314,65 +301,65 @@
 	close(sock);
 	free(url);
 	return bytesRead;
-	}
+}
 
 
 
-	/*
-	 * Changes the User Agent.  Returns 0 on success, -1 on error. 
-	 */
+/*
+ * Changes the User Agent.  Returns 0 on success, -1 on error.
+ */
 int http_setUserAgent(const char *newAgent)
-	{
+{
 	char *tmp;
 
-	if(newAgent == NULL)
-		{
-		if(freeOldAgent) free(userAgent);
+	if (newAgent == NULL) {
+		if (freeOldAgent) free(userAgent);
 		userAgent = NULL;
 		hideUserAgent = 1;
+	} else {
+		tmp = (char *)malloc(strlen(newAgent));
+		if (tmp == NULL) {
+			errorSource = ERRNO;
+			return -1;
 		}
-	else
-		{
-		tmp = (char *)malloc(strlen(newAgent));
-		if(tmp == NULL) { errorSource = ERRNO; return -1; }
-		if(freeOldAgent) free(userAgent);
+		if (freeOldAgent) free(userAgent);
 		userAgent = tmp;
 		strcpy(userAgent, newAgent);
 		freeOldAgent = 1;
 		hideUserAgent = 0;
-		}
+	}
 
 	return 0;
-	}
+}
 
 
 
-	/*
-	 * Changes the Referer.  Returns 0 on success, -1 on error
-	 */
+/*
+ * Changes the Referer.  Returns 0 on success, -1 on error
+ */
 int http_setReferer(const char *newReferer)
-	{
+{
 	char *tmp;
 
-	if(newReferer == NULL)
-		{
-		if(freeOldReferer) free(referer);
+	if (newReferer == NULL) {
+		if (freeOldReferer) free(referer);
 		referer = NULL;
 		hideReferer = 1;
+	} else {
+		tmp = (char *)malloc(strlen(newReferer));
+		if (tmp == NULL) {
+			errorSource = ERRNO;
+			return -1;
 		}
-	else
-		{
-		tmp = (char *)malloc(strlen(newReferer));
-		if(tmp == NULL) { errorSource = ERRNO; return -1; }
-		if(freeOldReferer) free(referer);
+		if (freeOldReferer) free(referer);
 		referer = tmp;
 		strcpy(referer, newReferer);
 		freeOldReferer = 1;
 		hideReferer = 0;
-		}
-	
+	}
+
 	return 0;
-	}
+}
 int http_setAuth(const char *user, const char *pass)
 {
 	unsigned char plain[1024];
@@ -380,26 +367,34 @@
 	char *b64;
 	int i,j,c,len,n;
 	char o=0;
-	 /* base64 encode user and pass */
-	if ((user==NULL) || (pass==NULL)) /* bad input or request to clean up */
-	{
+	/* base64 encode user and pass */
+	if ((user==NULL) || (pass==NULL)) { /* bad input or request to clean up */
 		if (auth!=NULL)	free(auth); /* free old auth */
 		auth=NULL;
 		return(-1);
 	}
-	
+
 	snprintf((char *)plain,1024,&quot;%s:%s&quot;,user,pass);
 	len=strlen((char *)plain);
 	b64=malloc(len*4+1);
 	i=j=c=0;
-	while (i&lt;len || c!=0)
-	{
-		switch (c)
-		{
-			case 0:	o=ec64[ n=plain[i] &gt;&gt; 2 ]; i++; break;
-			case 1: o=ec64[ n=((plain[i-1]&amp;0x3)&lt;&lt;4) | (plain[i]&gt;&gt;4) ]; i++; break;
-			case 2: o=(i&gt;=len)?'=':ec64[ n=((plain[i-1]&amp;0xf)&lt;&lt;2) | (plain[i]&gt;&gt;6) ]; break;
-			case 3: o=(i&gt;=len)?'=':ec64[ n=(plain[i]&amp;0x3f) ];i++;break;
+	while (i&lt;len || c!=0) {
+		switch (c) {
+		case 0:
+			o=ec64[ n=plain[i] &gt;&gt; 2 ];
+			i++;
+			break;
+		case 1:
+			o=ec64[ n=((plain[i-1]&amp;0x3)&lt;&lt;4) | (plain[i]&gt;&gt;4) ];
+			i++;
+			break;
+		case 2:
+			o=(i&gt;=len)?'=':ec64[ n=((plain[i-1]&amp;0xf)&lt;&lt;2) | (plain[i]&gt;&gt;6) ];
+			break;
+		case 3:
+			o=(i&gt;=len)?'=':ec64[ n=(plain[i]&amp;0x3f) ];
+			i++;
+			break;
 		}
 		b64[j]=o;
 		c=(c+1)%4;
@@ -408,226 +403,233 @@
 	b64[j]=0;
 	if (auth!=NULL)	free(auth); /* free old auth */
 	auth=b64;
-	return(0);	
+	return(0);
 
-	
+
 }
 
 
 
 
-	/*
-	 * Changes the amount of time that HTTP Fetcher will wait for data
-	 *	before timing out on reads
-	 */
-void http_setTimeout(int seconds) { timeout = seconds; }
+/*
+ * Changes the amount of time that HTTP Fetcher will wait for data
+ *	before timing out on reads
+ */
+void http_setTimeout(int seconds)
+{
+	timeout = seconds;
+}
 
 
 
-	/*
-	 * Puts the filename portion of the url into 'filename'.
-	 * Returns:
-	 *	0 on success
-	 *	1 when url contains no end filename (i.e., 'www.foo.com/'),
-	 *		and **filename should not be assumed to be valid
-	 *	-1 on error
-	 */
+/*
+ * Puts the filename portion of the url into 'filename'.
+ * Returns:
+ *	0 on success
+ *	1 when url contains no end filename (i.e., 'www.foo.com/'),
+ *		and **filename should not be assumed to be valid
+ *	-1 on error
+ */
 int http_parseFilename(const char *url, char **filename)
-	{
+{
 	char *ptr;
 
-	if(url == NULL)
-		{
+	if (url == NULL) {
 		errorSource = FETCHER_ERROR;
 		http_errno = HF_NULLURL;
 		return -1;
-		}
+	}
 
 	ptr = (char *)rindex(url, '/');
-	if(ptr == NULL)
+	if (ptr == NULL)
 		/* Root level request, apparently */
 		return 1;
 
 	ptr++;
-	if(*ptr == '\0') return 1;
+	if (*ptr == '\0') return 1;
 
 	*filename = (char *)malloc(strlen(ptr));
-	if(*filename == NULL) { errorSource = ERRNO; return -1; }
+	if (*filename == NULL) {
+		errorSource = ERRNO;
+		return -1;
+	}
 	strcpy(*filename, ptr);
 
 	return 0;
-	}
+}
 
-	
-	
-	/* Depending on the source of error, calls either perror() or prints
-	 *	an HTTP Fetcher error message to stdout */
+
+
+/* Depending on the source of error, calls either perror() or prints
+ *	an HTTP Fetcher error message to stdout */
 void http_perror(const char *string)
-	{
-	if(errorSource == ERRNO)
+{
+	if (errorSource == ERRNO)
 		perror(string);
-	else if(errorSource == H_ERRNO)
+	else if (errorSource == H_ERRNO)
 		herror(string);
-	else if(errorSource == FETCHER_ERROR)
-		{
+	else if (errorSource == FETCHER_ERROR) {
 		char *stringIndex;
 
-		if(strstr(http_errlist[http_errno], &quot;%d&quot;) == NULL)
-			{
+		if (strstr(http_errlist[http_errno], &quot;%d&quot;) == NULL) {
 			fputs(string, stderr);
 			fputs(&quot;: &quot;, stderr);
 			fputs(http_errlist[http_errno], stderr);
 			fputs(&quot;\n&quot;, stderr);
-			}
-		else
-			{
+		} else {
 			/* The error string has a %d in it, we need to insert errorInt */
 			stringIndex = (char *)http_errlist[http_errno];
-			while(*stringIndex != '%')			/* Print up to the %d */
-				{
+			while (*stringIndex != '%') {		/* Print up to the %d */
 				fputc(*stringIndex, stderr);
 				stringIndex++;
-				}
+			}
 			fprintf(stderr, &quot;%d&quot;, errorInt);	/* Print the number */
 			stringIndex += 2;					/* Skip past the %d */
-			while(*stringIndex != 0)			/* Print up to the end NULL */
-				{
+			while (*stringIndex != 0) {		/* Print up to the end NULL */
 				fputc(*stringIndex, stderr);
 				stringIndex++;
-				}
+			}
 			fputs(&quot;\n&quot;, stderr);
-			}
 		}
 	}
+}
 
 
 
-	/* 
-	 * Returns a pointer to the current error description message. The
-	 *	message pointed to is only good until the next call to http_strerror(),
-	 *	so if you need to hold on to the message for a while you should make
-	 *	a copy of it
-	 */
+/*
+ * Returns a pointer to the current error description message. The
+ *	message pointed to is only good until the next call to http_strerror(),
+ *	so if you need to hold on to the message for a while you should make
+ *	a copy of it
+ */
 const char *http_strerror()
-	{
-	if(errorSource == ERRNO)
+{
+	if (errorSource == ERRNO)
 		return strerror(errno);
-	else if(errorSource == H_ERRNO)
+	else if (errorSource == H_ERRNO)
 		return hstrerror(h_errno);
-	else if(errorSource == FETCHER_ERROR)
-		{
-		if(strstr(http_errlist[http_errno], &quot;%d&quot;) == NULL)
+	else if (errorSource == FETCHER_ERROR) {
+		if (strstr(http_errlist[http_errno], &quot;%d&quot;) == NULL)
 			return http_errlist[http_errno];
-		else
-			{
+		else {
 			/* The error string has a %d in it, we need to insert errorInt.
 			 *	convertedError[128] has been declared for that purpose */
 			char *stringIndex, *originalError;
-		
+
 			originalError = (char *)http_errlist[http_errno];
 			convertedError[0] = 0;		/* Start off with NULL */
 			stringIndex = strstr(originalError, &quot;%d&quot;);
 			strncat(convertedError, originalError,		/* Copy up to %d */
-				abs(stringIndex - originalError));
+			        abs(stringIndex - originalError));
 			sprintf(&amp;convertedError[strlen(convertedError)],&quot;%d&quot;,errorInt);
 			stringIndex += 2;		/* Skip past the %d */
 			strcat(convertedError, stringIndex);
 
 			return convertedError;
-			}
 		}
-		
-	return http_errlist[HF_METAERROR];	/* Should NEVER happen */
 	}
 
-	
-	/*
-	 * Reads the metadata of an HTTP response.
-	 * Perhaps a little inefficient, as it reads 1 byte at a time, but
-	 *	I don't think it's that much of a loss (most headers aren't HUGE).
-	 * Returns:
-	 *	# of bytes read on success, or
-	 *	-1 on error
-	 */
+	return http_errlist[HF_METAERROR];	/* Should NEVER happen */
+}
+
+
+/*
+ * Reads the metadata of an HTTP response.
+ * Perhaps a little inefficient, as it reads 1 byte at a time, but
+ *	I don't think it's that much of a loss (most headers aren't HUGE).
+ * Returns:
+ *	# of bytes read on success, or
+ *	-1 on error
+ */
 int _http_read_header(int sock, char *headerPtr)
-	{
+{
 	fd_set rfds;
 	struct timeval tv;
 	int bytesRead = 0, newlines = 0, ret, selectRet;
 
-	while(newlines != 2 &amp;&amp; bytesRead != HEADER_BUF_SIZE)
-		{
+	while (newlines != 2 &amp;&amp; bytesRead != HEADER_BUF_SIZE) {
 		FD_ZERO(&amp;rfds);
 		FD_SET(sock, &amp;rfds);
-		tv.tv_sec = timeout; 
+		tv.tv_sec = timeout;
 		tv.tv_usec = 0;
 
-		if(timeout &gt;= 0)
+		if (timeout &gt;= 0)
 			selectRet = select(sock+1, &amp;rfds, NULL, NULL, &amp;tv);
 		else		/* No timeout, can block indefinately */
 			selectRet = select(sock+1, &amp;rfds, NULL, NULL, NULL);
-		
-		if(selectRet == 0 &amp;&amp; timeout &lt; 0)
-			{
+
+		if (selectRet == 0 &amp;&amp; timeout &lt; 0) {
 			errorSource = FETCHER_ERROR;
 			http_errno = HF_HEADTIMEOUT;
 			errorInt = timeout;
 			return -1;
-			}
-		else if(selectRet == -1) { errorSource = ERRNO; return -1; }
+		} else if (selectRet == -1) {
+			errorSource = ERRNO;
+			return -1;
+		}
 
 		ret = read(sock, headerPtr, 1);
-		if(ret == -1) { errorSource = ERRNO; return -1; }
+		if (ret == -1) {
+			errorSource = ERRNO;
+			return -1;
+		}
 		bytesRead++;
 
-		if(*headerPtr == '\r')			/* Ignore CR */
-			{
+		if (*headerPtr == '\r') {		/* Ignore CR */
 			/* Basically do nothing special, just don't set newlines
 			 *	to 0 */
 			headerPtr++;
 			continue;
-			}
-		else if(*headerPtr == '\n')		/* LF is the separator */
+		} else if (*headerPtr == '\n')		/* LF is the separator */
 			newlines++;
 		else
 			newlines = 0;
 
 		headerPtr++;
-		}
+	}
 
 	headerPtr -= 3;		/* Snip the trailing LF's */
 	*headerPtr = '\0';
 	return bytesRead;
-	}
+}
 
-	
-	
-	/*
-	 * Opens a TCP socket and returns the descriptor
-	 * Returns:
-	 *	socket descriptor, or
-	 *	-1 on error
-	 */
+
+
+/*
+ * Opens a TCP socket and returns the descriptor
+ * Returns:
+ *	socket descriptor, or
+ *	-1 on error
+ */
 int makeSocket(const char *host)
-	{
+{
 	int sock;										/* Socket descriptor */
 	struct sockaddr_in sa;							/* Socket address */
 	struct hostent *hp;								/* Host entity */
 	int ret;
-	
+
 	hp = gethostbyname(host);
-	if(hp == NULL) { errorSource = H_ERRNO; return -1; }
-		
+	if (hp == NULL) {
+		errorSource = H_ERRNO;
+		return -1;
+	}
+
 	/* Copy host address from hostent to (server) socket address */
 	memcpy((char *)&amp;sa.sin_addr, (char *)hp-&gt;h_addr, hp-&gt;h_length);
 	sa.sin_family = hp-&gt;h_addrtype;		/* Set service sin_family to PF_INET */
 	sa.sin_port = htons(PORT_NUMBER);	/* Put portnum into sockaddr */
 
 	sock = socket(hp-&gt;h_addrtype, SOCK_STREAM, 0);
-	if(sock == -1) { errorSource = ERRNO; return -1; }
+	if (sock == -1) {
+		errorSource = ERRNO;
+		return -1;
+	}
 
 	ret = connect(sock, (struct sockaddr *)&amp;sa, sizeof(sa));
-	if(ret == -1) { errorSource = ERRNO; return -1; }
+	if (ret == -1) {
+		errorSource = ERRNO;
+		return -1;
+	}
 
 	return sock;
-	}
+}

Modified: trunk/apps/s3dosm/http_fetcher.h
===================================================================
--- trunk/apps/s3dosm/http_fetcher.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/http_fetcher.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -15,10 +15,10 @@
 
 	See LICENSE file for details
 
-	Changes: 
+	Changes:
 		Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
 		+ added http_setAuth() to support basic http-authentication and some minor fixes
-									
+
  */
 
 #ifndef HTTP_FETCHER_H
@@ -31,8 +31,8 @@
 #define DEFAULT_USER_AGENT		&quot;HTTP Fetcher&quot;
 #define	HTTP_FETCHER_VERSION	&quot;1.0&quot;
 #define DEFAULT_READ_TIMEOUT	30		/* Seconds to wait before giving up
-										 *	when no data is arriving */
-	 
+*	when no data is arriving */
+
 #define REQUEST_BUF_SIZE 		1024
 #define HEADER_BUF_SIZE 		1024
 #define DEFAULT_PAGE_BUF_SIZE 	1024 * 200	/* 200K should hold most things */
@@ -43,83 +43,83 @@
 /**************** Function declarations and descriptions **********************/
 /******************************************************************************/
 
-/* 
+/*
  * [!!! NOTE !!!]  All HTTP Fetcher functions return -1 on error.  You can
  *	then either call http_perror to print the error message or call
  *	http_strerror to get a pointer to it
  */
 
 
-	/*
-	 * Download the page, registering a hit. If you pass it a NULL for fileBuf,
-	 *	'url' will be requested but will not remain in memory (useful for
-	 *	simply registering a hit).  Otherwise necessary space will be allocated
-	 *	and will be pointed to by fileBuf.
-	 * Returns:
-	 *	# of bytes downloaded, or
-	 *	-1 on error
-	 */
+/*
+ * Download the page, registering a hit. If you pass it a NULL for fileBuf,
+ *	'url' will be requested but will not remain in memory (useful for
+ *	simply registering a hit).  Otherwise necessary space will be allocated
+ *	and will be pointed to by fileBuf.
+ * Returns:
+ *	# of bytes downloaded, or
+ *	-1 on error
+ */
 int http_fetch(const char *url, char **fileBuf);
 
-	/*
-	 * Changes the User Agent (shown to the web server with each request)
-	 *	Send it NULL to avoid telling the server a User Agent
-	 *	By default, the User Agent is sent (The default one unless changed)
-	 * Returns:
-	 *	0 on success, or
-	 *	-1 on error (previous value for agent remains unchanged)
-	 */
+/*
+ * Changes the User Agent (shown to the web server with each request)
+ *	Send it NULL to avoid telling the server a User Agent
+ *	By default, the User Agent is sent (The default one unless changed)
+ * Returns:
+ *	0 on success, or
+ *	-1 on error (previous value for agent remains unchanged)
+ */
 int http_setUserAgent(const char *newAgent);
 
-	/*
-	 * Changes the Referer (shown to the web server with each request)
-	 *	Send it NULL to avoid thelling the server a Referer
-	 *	By default, no Referer is sent
-	 * Returns:
-	 *	0 on success, or
-	 *	-1 on error
-	 */
+/*
+ * Changes the Referer (shown to the web server with each request)
+ *	Send it NULL to avoid thelling the server a Referer
+ *	By default, no Referer is sent
+ * Returns:
+ *	0 on success, or
+ *	-1 on error
+ */
 int http_setReferer(const char *newReferer);
 
-	/*
-	 * Changes the maximum amount of time that HTTP Fetcher will wait on
-	 *	data.  If this many seconds elapses without more data from the
-	 *	server, http_fetch will return with an error.
-	 * If you pass a value less than 0, reads will not time out, potentially
-	 *	waiting forever (or until data shows up, whichever comes first)
-	 */
+/*
+ * Changes the maximum amount of time that HTTP Fetcher will wait on
+ *	data.  If this many seconds elapses without more data from the
+ *	server, http_fetch will return with an error.
+ * If you pass a value less than 0, reads will not time out, potentially
+ *	waiting forever (or until data shows up, whichever comes first)
+ */
 void http_setTimeout(int seconds);
 
-	/*
-	 * Activate authentication for the Request. If user or pass is NULL,
-	 * http_set_Auth assumes a request to cleanup (disable Authentication). 
-	 * Returns 0 on success, and -1 on error or cleanup.
-	 */
+/*
+ * Activate authentication for the Request. If user or pass is NULL,
+ * http_set_Auth assumes a request to cleanup (disable Authentication).
+ * Returns 0 on success, and -1 on error or cleanup.
+ */
 
 int http_setAuth(const char *user, const char *pass);
 
-	/*
-	 * Takes a url and puts the filename portion of it into 'filename'.
-	 * Returns:
-	 *	0 on success, or
-	 *	1 when url contains no end filename (i.e., &quot;www.foo.com/&quot;)
-	 *		and **filename should not be assumed to point to anything), or
-	 *	-1 on error
-	 */
+/*
+ * Takes a url and puts the filename portion of it into 'filename'.
+ * Returns:
+ *	0 on success, or
+ *	1 when url contains no end filename (i.e., &quot;www.foo.com/&quot;)
+ *		and **filename should not be assumed to point to anything), or
+ *	-1 on error
+ */
 int http_parseFilename(const char *url, char **filename);
 
-	/*
-	 * Works like perror.  If an HTTP Fetcher function ever returns an
-	 *	error (-1), this will print a descriptive message to standard output
-	 */
+/*
+ * Works like perror.  If an HTTP Fetcher function ever returns an
+ *	error (-1), this will print a descriptive message to standard output
+ */
 void http_perror(const char *string);
 
-	/*
-	 * Returns a pointer to the current error description message.  The
-	 *	message pointed to is only good until the next call to http_strerror(),
-	 *	so if you need to hold on to the message for a while you should make
-	 *	a copy of it.
-	 */
+/*
+ * Returns a pointer to the current error description message.  The
+ *	message pointed to is only good until the next call to http_strerror(),
+ *	so if you need to hold on to the message for a while you should make
+ *	a copy of it.
+ */
 const char *http_strerror();
 
 
@@ -128,20 +128,20 @@
 /**** The following functions are used INTERNALLY by http_fetcher *************/
 /******************************************************************************/
 
-	/*
-	 * Reads the metadata of an HTTP response.  On success returns the number
-	 * Returns:
-	 *	# of bytes read on success, or
-	 *	-1 on error
-	 */
+/*
+ * Reads the metadata of an HTTP response.  On success returns the number
+ * Returns:
+ *	# of bytes read on success, or
+ *	-1 on error
+ */
 int _http_read_header(int sock, char *headerPtr);
 
-	/*
-	 * Opens a TCP socket and returns the descriptor
-	 * Returns:
-	 *	socket descriptor, or
-	 *	-1 on error
-	 */
+/*
+ * Opens a TCP socket and returns the descriptor
+ * Returns:
+ *	socket descriptor, or
+ *	-1 on error
+ */
 int makeSocket(const char *host);
 
 #endif

Modified: trunk/apps/s3dosm/io.c
===================================================================
--- trunk/apps/s3dosm/io.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/io.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * io.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -38,10 +38,19 @@
 	int filesize;
 	struct stat bf;
 
-	if ((fp = fopen(fname, &quot;rt&quot;)) == NULL)	{ 	fprintf(stderr,&quot;read_file( %s ):fopen(): %s&quot;,fname,strerror(errno)); 		return(NULL);	}
-	if (fstat(fileno(fp),&amp;bf))				{ 	fprintf(stderr,&quot;read_file( %s ):fopen(): %s&quot;,fname,strerror(errno));		return(NULL);	}
+	if ((fp = fopen(fname, &quot;rt&quot;)) == NULL)	{
+		fprintf(stderr,&quot;read_file( %s ):fopen(): %s&quot;,fname,strerror(errno));
+		return(NULL);
+	}
+	if (fstat(fileno(fp),&amp;bf))				{
+		fprintf(stderr,&quot;read_file( %s ):fopen(): %s&quot;,fname,strerror(errno));
+		return(NULL);
+	}
 	filesize=bf.st_size;
-	if ((buf=malloc(filesize))==NULL)		{	fprintf(stderr,&quot;read_file( %s ):malloc(): %s&quot;,fname,strerror(errno));		return(NULL);	}
+	if ((buf=malloc(filesize))==NULL)		{
+		fprintf(stderr,&quot;read_file( %s ):malloc(): %s&quot;,fname,strerror(errno));
+		return(NULL);
+	}
 	fread(buf, filesize, 1, fp);
 	fclose(fp);
 	if (fsize!=NULL) *fsize=filesize;
@@ -54,63 +63,55 @@
 	char				 c;
 	float				 minlat, minlon, maxlat, maxlon;
 	char 				 info[1024];
-	struct option long_options[] = 
-	{
-		{&quot;help&quot;,0,0,'h'},
-		{&quot;osm&quot;,1,0,'o'},
-		{0,0,0,0}
+	struct option long_options[] = {
+		{&quot;help&quot;,0,0,'h'
+		}, {&quot;osm&quot;,1,0,'o'}, {0,0,0,0}
 	};
 	optind=0;
 	opterr=0;
-	while (-1!=(c=getopt_long(argc,argv,&quot;dH:?ho&quot;,long_options,&amp;lopt_idx)))
-	{
-		switch (c)
-		{
-				case 0:break;
-				case 'o':
-					if (4==sscanf(optarg,&quot;%f,%f,%f,%f&quot;,&amp;minlat,&amp;minlon,&amp;maxlat,&amp;maxlon))
-					   	layerset_add(load_osm_web(minlat,minlon,maxlat,maxlon));
-					else {
-						printf(&quot;%s: bad map bounding box&quot;,optarg);
-						return(-1);
-					}
-					break;
-				case 'h':
-				case '?':
-					printf(&quot;\nUSAGE: %s [options] [files]\n\n&quot;,argv[0]);
-					printf(&quot;options:\n&quot;);
-					printf(&quot;\t--osm, -o MINLAT,MINLON,MAXLAT,MAXLON:\n&quot;);
-					printf(&quot;\t\tload a map with the given bounding box\n\t\tfrom the openstreetmap server\n&quot;);
-					printf(&quot;\t--help, -?, -h: this helpful text\n\n&quot;);
-					printf(&quot;supported file types:\n&quot;);
-					printf(&quot;\t+ Kismet .xml Logs\n&quot;);
-					printf(&quot;\t+ Opemstreetmap .osm files\n\n&quot;);
-					s3d_usage();	/* add s3d usage */
-					return(-1);
-				default:
-					break;
+	while (-1!=(c=getopt_long(argc,argv,&quot;dH:?ho&quot;,long_options,&amp;lopt_idx))) {
+		switch (c) {
+		case 0:
+			break;
+		case 'o':
+			if (4==sscanf(optarg,&quot;%f,%f,%f,%f&quot;,&amp;minlat,&amp;minlon,&amp;maxlat,&amp;maxlon))
+				layerset_add(load_osm_web(minlat,minlon,maxlat,maxlon));
+			else {
+				printf(&quot;%s: bad map bounding box&quot;,optarg);
+				return(-1);
+			}
+			break;
+		case 'h':
+		case '?':
+			printf(&quot;\nUSAGE: %s [options] [files]\n\n&quot;,argv[0]);
+			printf(&quot;options:\n&quot;);
+			printf(&quot;\t--osm, -o MINLAT,MINLON,MAXLAT,MAXLON:\n&quot;);
+			printf(&quot;\t\tload a map with the given bounding box\n\t\tfrom the openstreetmap server\n&quot;);
+			printf(&quot;\t--help, -?, -h: this helpful text\n\n&quot;);
+			printf(&quot;supported file types:\n&quot;);
+			printf(&quot;\t+ Kismet .xml Logs\n&quot;);
+			printf(&quot;\t+ Opemstreetmap .osm files\n\n&quot;);
+			s3d_usage();	/* add s3d usage */
+			return(-1);
+		default:
+			break;
 		}
 	}
-	for (i=1;i&lt;argc;i++)
-	{
+	for (i=1;i&lt;argc;i++) {
 		if (strstr(argv[i],&quot;.osm&quot;)-argv[i]==strlen(argv[i])-4) {
 			snprintf(info,1024,&quot;loading OSM-File: %s&quot;,argv[i]);
 			load_window(info);
 			layerset_add(load_osm_file(argv[i]));
-		}
-		else if (strstr(argv[i],&quot;.xml&quot;)-argv[i]==strlen(argv[i])-4) /* might be osm or kismet xml */
-		{
+		} else if (strstr(argv[i],&quot;.xml&quot;)-argv[i]==strlen(argv[i])-4) { /* might be osm or kismet xml */
 			char *file;
 			int fsize;
-			if (NULL==(file=read_file(argv[i],&amp;fsize)))				
+			if (NULL==(file=read_file(argv[i],&amp;fsize)))
 				break;
-			if (NULL!=strstr(file,&quot;&lt;!DOCTYPE detection-run SYSTEM \&quot;<A HREF="http://kismetwireless.net">http://kismetwireless.net</A>&quot;))
-			{
+			if (NULL!=strstr(file,&quot;&lt;!DOCTYPE detection-run SYSTEM \&quot;<A HREF="http://kismetwireless.net">http://kismetwireless.net</A>&quot;)) {
 				snprintf(info,1024,&quot;loading Kismet-File: %s&quot;,argv[i]);
 				load_window(info);
 				layerset_add(parse_kismet(file,fsize));
-			}
-			else if (NULL!=strstr(file,&quot;&lt;osm &quot;)) {
+			} else if (NULL!=strstr(file,&quot;&lt;osm &quot;)) {
 				snprintf(info,1024,&quot;loading OSM-File: %s&quot;,argv[i]);
 				load_window(info);
 				layerset_add(parse_osm(file,fsize));

Modified: trunk/apps/s3dosm/kismet.c
===================================================================
--- trunk/apps/s3dosm/kismet.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/kismet.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * kismet.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -40,12 +40,9 @@
 	node.base.layerid=layerid;
 	node.base.id=0;				/* let database decide */
 	node.visible=2;	/* something special */
-	for (kids=cur-&gt;children;kids;kids=kids-&gt;next)
-	{
-		if (0==strcmp((char *)kids-&gt;name,&quot;gps-info&quot;))
-		{
-			for (gpskids=kids-&gt;children;gpskids;gpskids=gpskids-&gt;next)
-			{
+	for (kids=cur-&gt;children;kids;kids=kids-&gt;next) {
+		if (0==strcmp((char *)kids-&gt;name,&quot;gps-info&quot;)) {
+			for (gpskids=kids-&gt;children;gpskids;gpskids=gpskids-&gt;next) {
 				/* get median value */
 				if (0==strcmp((char *)gpskids-&gt;name,&quot;min-lat&quot;)) 		node.lat=node.lat + strtod((char *)xmlNodeGetContent(gpskids-&gt;children),NULL)/2;
 				if (0==strcmp((char *)gpskids-&gt;name,&quot;max-lat&quot;)) 		node.lat=node.lat + strtod((char *)xmlNodeGetContent(gpskids-&gt;children),NULL)/2;
@@ -61,15 +58,14 @@
 	{
 
 		db_insert_node(&amp;node);
-		for (kids=cur-&gt;children;kids;kids=kids-&gt;next)
-		{
+		for (kids=cur-&gt;children;kids;kids=kids-&gt;next) {
 			if (0==strcmp((char *)kids-&gt;name,&quot;SSID&quot;)) 			db_add_tag(OBJECT_T(&amp;node),&quot;wifi_SSID&quot;,(char *)xmlNodeGetContent(kids-&gt;children));
 			if (0==strcmp((char *)kids-&gt;name,&quot;BSSID&quot;)) 			db_add_tag(OBJECT_T(&amp;node),&quot;wifi_BSSID&quot;,(char *)xmlNodeGetContent(kids-&gt;children));
 		}
-		for (attr=cur-&gt;properties;attr;attr=attr-&gt;next)
-		{
-	/*		if (0==strcmp((char *)attr-&gt;name,&quot;number&quot;)) 		node-&gt;base.id=		strtol((char *)attr-&gt;children-&gt;content,NULL,10);
-			else */if (0==strcmp((char *)attr-&gt;name,&quot;wep&quot;)) 	db_add_tag(OBJECT_T(&amp;node),&quot;wifi_wep&quot;,(char *)attr-&gt;children-&gt;content);
+		for (attr=cur-&gt;properties;attr;attr=attr-&gt;next) {
+			/*		if (0==strcmp((char *)attr-&gt;name,&quot;number&quot;)) 		node-&gt;base.id=		strtol((char *)attr-&gt;children-&gt;content,NULL,10);
+					else */
+			if (0==strcmp((char *)attr-&gt;name,&quot;wep&quot;)) 	db_add_tag(OBJECT_T(&amp;node),&quot;wifi_wep&quot;,(char *)attr-&gt;children-&gt;content);
 			else if (0==strcmp((char *)attr-&gt;name,&quot;type&quot;)) 		db_add_tag(OBJECT_T(&amp;node),&quot;wifi_type&quot;,(char *)attr-&gt;children-&gt;content);
 		}
 
@@ -85,8 +81,8 @@
 	layer_t *layer=layer_new();
 	int i=0;
 	float n=0;
-	
 
+
 	doc = xmlReadMemory(buf, length, &quot;noname.xml&quot;, NULL, 0);
 	if (doc == NULL) {
 		fprintf(stderr,&quot;Document not parsed successfully.\n&quot;);
@@ -100,14 +96,11 @@
 	}
 	layerid=db_insert_layer(&quot;kismet&quot;);
 	for (c=cur-&gt;children;  c!=NULL;   c=c-&gt;next) 		n++; /* count */
-	for (cur=cur-&gt;children;cur!=NULL; cur=cur-&gt;next)
-	{
-		if (cur-&gt;type==XML_ELEMENT_NODE)
-		{
-			if (0==strcmp((char *)cur-&gt;name,&quot;wireless-network&quot;))
-			{
+	for (cur=cur-&gt;children;cur!=NULL; cur=cur-&gt;next) {
+		if (cur-&gt;type==XML_ELEMENT_NODE) {
+			if (0==strcmp((char *)cur-&gt;name,&quot;wireless-network&quot;)) {
 				parse_kismet_node(cur);
-			} 
+			}
 		}
 		if ((i++)%10==0) load_update_status(100*((float)i)/n);
 

Modified: trunk/apps/s3dosm/main.c
===================================================================
--- trunk/apps/s3dosm/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * main.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -31,17 +31,19 @@
 
 void mainloop()
 {
-	struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+	struct timespec t= {
+		0,100*1000*1000
+	}; /* 100 mili seconds */
 	if (ready) {
-		nanosleep(&amp;t,NULL); 
+		nanosleep(&amp;t,NULL);
 		gps_main();
 		nav_main();
 		s3dw_ani_mate();
 	} /* else {
-		s3d_net_check(); / * we are not yet in the mainloop of 
-							s3d_mainloop(), because ready==0, 
+		s3d_net_check(); / * we are not yet in the mainloop of
+							s3d_mainloop(), because ready==0,
 							so we check protocol things ourselves.
-							This just prevents timing out from the server 
+							This just prevents timing out from the server
 							because map loading takes so long, you shouldn't take
 							this as good example and write proper threaded or
 							timesliced loaders :) * /
@@ -63,7 +65,7 @@
 	ready=1;
 	return(0);
 }
-int quit() 
+int quit()
 {
 	ready=0;
 	gps_quit();
@@ -73,8 +75,7 @@
 }
 int main(int argc, char **argv)
 {
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;s3dosm&quot;))
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;s3dosm&quot;)) {
 		if (!init(argc, argv)) s3d_mainloop(mainloop);
 		quit();
 	} else return(-1);

Modified: trunk/apps/s3dosm/nav.c
===================================================================
--- trunk/apps/s3dosm/nav.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/nav.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -28,16 +28,16 @@
 
 	float tmp1[3],tmp2[3];
 	float alpha;
-	
+
 	tmp1[0]=campos[0];
 	tmp1[1]=campos[1] + ESIZE*RESCALE +VIEWHEIGHT;
 	tmp1[2]=campos[2];
-	
+
 	alpha= (90-lat) *M_PI/180.0;
 	tmp2[0]=  tmp1[0];
 	tmp2[1]=  tmp1[1]*cos(alpha) - tmp1[2] * sin (alpha);
 	tmp2[2]=  tmp1[1]*sin(alpha) + tmp1[2] * cos (alpha);
-	
+
 	alpha= lon *M_PI/180.0;
 	tmp1[0]=  tmp2[0]*cos(alpha) + tmp2[2] * sin (alpha);
 	tmp1[1]=  tmp2[1];
@@ -53,17 +53,18 @@
 void nav_main()
 {
 	float x[3];
-	if ((fabs(tlat-lat)&gt;0.00001) &amp;&amp; (fabs(tlon-lon)&gt;0.00001))
-	{
-		if (lat==0.0 &amp;&amp; lon==0.0)
-		{
+	if ((fabs(tlat-lat)&gt;0.00001) &amp;&amp; (fabs(tlon-lon)&gt;0.00001)) {
+		if (lat==0.0 &amp;&amp; lon==0.0) {
 			lat=tlat;
 			lon=tlon;
 		} else {
 			lat=(tlat+lat*15)/16;
 			lon=(tlon+lon*15)/16;
 		}
-	} else { lat=tlat;lon=tlon;}
+	} else {
+		lat=tlat;
+		lon=tlon;
+	}
 	s3d_rotate(oidy,0,-lon,0);
 	s3d_rotate(oidx,-(90-lat),0,0);
 	calc_earth_to_eukl(lon,lat,0,x);
@@ -75,7 +76,7 @@
 	int i;
 	med[0]=0;
 	med[1]=0;
-	for(i=0; i&lt;argc; i++){
+	for (i=0; i&lt;argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],&quot;la&quot;))			med[0]=strtod(argv[i],NULL);
 			else if (0==strcmp(azColName[i],&quot;lo&quot;))		med[1]=strtod(argv[i],NULL);
@@ -84,7 +85,8 @@
 	return(0);
 }
 /* returns the heading in degress of position P1 -&gt; P2 */
-float get_heading(float la1, float lo1, float la2, float lo2) {
+float get_heading(float la1, float lo1, float la2, float lo2)
+{
 	float p1_north[3], p1[3], p2[3];
 	float dir[3],north[3];
 	float angle;

Modified: trunk/apps/s3dosm/object.c
===================================================================
--- trunk/apps/s3dosm/object.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/object.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * object.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -112,7 +112,7 @@
 }
 void way_free(way_t *way)
 {
-	if (way-&gt;seg_n&gt;0) 
+	if (way-&gt;seg_n&gt;0)
 		free(way-&gt;seg_p);
 	free(way);
 }

Modified: trunk/apps/s3dosm/osm.c
===================================================================
--- trunk/apps/s3dosm/osm.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/osm.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * osm.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -34,11 +34,9 @@
 	xmlAttrPtr attr;
 	char *v,*k;
 	v=k=NULL;
-	for (c=cur-&gt;children;c!=NULL; c=c-&gt;next)
-	{
+	for (c=cur-&gt;children;c!=NULL; c=c-&gt;next) {
 		if (0==strcmp((char *)c-&gt;name,&quot;tag&quot;))	{
-			for (attr=c-&gt;properties;attr;attr=attr-&gt;next)
-			{
+			for (attr=c-&gt;properties;attr;attr=attr-&gt;next) {
 				if (0==strcmp((char *)attr-&gt;name,&quot;k&quot;)) 				k=(char *)attr-&gt;children-&gt;content;
 				else if (0==strcmp((char *)attr-&gt;name,&quot;v&quot;)) 		v=(char *)attr-&gt;children-&gt;content;
 			}
@@ -57,14 +55,13 @@
 	int seg;
 
 	way_init(&amp;way);
-	
+
 	way.base.layerid=layerid;
 	for (attr=cur-&gt;properties;attr;attr=attr-&gt;next)
 		if (0==strcmp((char *)attr-&gt;name,&quot;id&quot;)) 			way.base.id=	strtol((char *)attr-&gt;children-&gt;content,NULL,10);
 	db_insert_way_only(&amp;way);
 	parse_osm_tags(OBJECT_T(&amp;way),cur);
-	for (kids=cur-&gt;children;kids!=NULL;kids=kids-&gt;next)
-	{
+	for (kids=cur-&gt;children;kids!=NULL;kids=kids-&gt;next) {
 		if (0==strcmp((char *)kids-&gt;name,&quot;seg&quot;))	{
 			seg=-1;
 			for (kattr=kids-&gt;properties;kattr;kattr=kattr-&gt;next)
@@ -79,11 +76,10 @@
 	xmlAttrPtr attr;
 
 	segment_init(&amp;segment);
-	
+
 	segment.base.layerid=layerid;
-	for (attr=cur-&gt;properties;attr;attr=attr-&gt;next)
-	{
-		
+	for (attr=cur-&gt;properties;attr;attr=attr-&gt;next) {
+
 		if (0==strcmp((char *)attr-&gt;name,&quot;id&quot;)) 			segment.base.id=	strtol((char *)attr-&gt;children-&gt;content,NULL,10);
 		else if (0==strcmp((char *)attr-&gt;name,&quot;from&quot;)) 		segment.from=		strtod((char *)attr-&gt;children-&gt;content,NULL);
 		else if (0==strcmp((char *)attr-&gt;name,&quot;to&quot;)) 		segment.to=			strtod((char *)attr-&gt;children-&gt;content,NULL);
@@ -100,10 +96,9 @@
 
 	node_init(&amp;node);
 	attr=cur-&gt;properties;
-	
+
 	node.base.layerid=layerid;
-	for (attr=cur-&gt;properties;attr;attr=attr-&gt;next)
-	{
+	for (attr=cur-&gt;properties;attr;attr=attr-&gt;next) {
 		if (0==strcmp((char *)attr-&gt;name,&quot;id&quot;)) 			node.base.id=		strtol((char *)attr-&gt;children-&gt;content,NULL,10);
 		else if (0==strcmp((char *)attr-&gt;name,&quot;lat&quot;)) 		node.lat=			strtod((char *)attr-&gt;children-&gt;content,NULL);
 		else if (0==strcmp((char *)attr-&gt;name,&quot;lon&quot;)) 		node.lon=			strtod((char *)attr-&gt;children-&gt;content,NULL);
@@ -124,8 +119,8 @@
 	object_t *obj;
 	float n=0;
 	int i=0;
-	
 
+
 	doc = xmlReadMemory(buf, length, &quot;noname.xml&quot;, NULL, 0);
 	if (doc == NULL) {
 		fprintf(stderr,&quot;Document not parsed successfully.\n&quot;);
@@ -139,10 +134,8 @@
 	}
 	layerid=db_insert_layer(&quot;osm&quot;);
 	for (c=cur-&gt;children;  c!=NULL;   c=c-&gt;next) 		n++; /* count */
-	for (cur=cur-&gt;children;cur!=NULL; cur=cur-&gt;next)
-	{
-		if (cur-&gt;type==XML_ELEMENT_NODE)
-		{
+	for (cur=cur-&gt;children;cur!=NULL; cur=cur-&gt;next) {
+		if (cur-&gt;type==XML_ELEMENT_NODE) {
 			obj=NULL;
 			if (0==strcmp((char *)cur-&gt;name,&quot;node&quot;))				parse_osm_node(cur);
 			else if (0==strcmp((char *)cur-&gt;name,&quot;segment&quot;))		parse_osm_segment(cur);
@@ -168,9 +161,8 @@
 
 	http_setAuth(user,pass);
 	ret = http_fetch(url, &amp;fileBuf);	/* Downloads page */
-	if(ret == -1)
-	{	
-		http_perror(&quot;http_fetch&quot;);	
+	if (ret == -1) {
+		http_perror(&quot;http_fetch&quot;);
 		return(NULL);
 	}
 	layer=parse_osm(fileBuf, ret);

Modified: trunk/apps/s3dosm/s3dosm.h
===================================================================
--- trunk/apps/s3dosm/s3dosm.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/s3dosm.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -4,7 +4,7 @@
 #define	ESIZE	637800		/* earth size */
 #define	RESCALE	1
 #define VIEWHEIGHT 3
-#define MAXQ	4096	
+#define MAXQ	4096
 #define QBUF	1024*128
 
 /* stack it */
@@ -95,7 +95,7 @@
 	float 		 alt;		/* altitude */
 	char 		 visible;	/* node visible? 0 = no, 1 = yes, 2 = some sepcial object */
 	int 		 vid;		/* vertex id */
-/*	time_t time;*/
+	/*	time_t time;*/
 	int 		 adj_n;		/* adjacence list */
 	adj_t 		*adj_p;
 };

Modified: trunk/apps/s3dosm/structs.h
===================================================================
--- trunk/apps/s3dosm/structs.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/structs.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -28,8 +28,7 @@
 #define MAXDATASIZE 100			/* max number of bytes we can get at once  */
 
 /* linked list for the all connections */
-struct olsr_con 
-{
+struct olsr_con {
 	struct olsr_con *next_olsr_con;			/* pointer to next connection */
 	struct olsr_con *prev_olsr_con;			/* pointer to previous connection */
 	struct olsr_node *left_olsr_node;		/* pointer to left end point of the connection */
@@ -45,16 +44,14 @@
 
 
 /* linked list for the neighbours of each olsr node */
-struct olsr_neigh_list
-{
+struct olsr_neigh_list {
 	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
 	struct olsr_con *olsr_con;							/* pointer to the connection */
 };
 
 
 /* we contruct a binary tree to handle the nodes */
-struct olsr_node 
-{
+struct olsr_node {
 	struct olsr_node *left;
 	struct olsr_node *right;
 	char ip[NAMEMAX];				/* host ip */
@@ -72,8 +69,7 @@
 };
 
 
-struct Obj_to_ip
-{
+struct Obj_to_ip {
 	int id;
 	struct olsr_node *olsr_node;
 	struct Obj_to_ip *next;

Modified: trunk/apps/s3dosm/tag.c
===================================================================
--- trunk/apps/s3dosm/tag.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/tag.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * tag.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -29,8 +29,7 @@
 	tag_t *t;
 	obj-&gt;tag_n++;
 	obj-&gt;tag_p=realloc(obj-&gt;tag_p,obj-&gt;tag_n*sizeof(tag_t));
-	if (k!=NULL &amp;&amp; v!=NULL)
-	{
+	if (k!=NULL &amp;&amp; v!=NULL) {
 		t=&amp;(obj-&gt;tag_p[obj-&gt;tag_n-1]);
 		t-&gt;ttype=TAG_UNKNOWN;
 		t-&gt;k=strdup(k);
@@ -42,8 +41,7 @@
 tag_t *tag_get(object_t *obj, char *k)
 {
 	int i;
-	for (i=0;i&lt;obj-&gt;tag_n;i++)
-	{
+	for (i=0;i&lt;obj-&gt;tag_n;i++) {
 		if (0==strcmp(obj-&gt;tag_p[i].k,k)) return(&amp;(obj-&gt;tag_p[i]));
 	}
 	return(NULL);

Modified: trunk/apps/s3dosm/ui.c
===================================================================
--- trunk/apps/s3dosm/ui.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/ui.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * ui.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -28,11 +28,11 @@
 #include &lt;string.h&gt; /* strcmp */
 #include &lt;stdlib.h&gt; /* atoi() */
 icon_t icons[ICON_NUM]={
-		{&quot;objs/accesspoint.3ds&quot;,0},
-		{&quot;objs/noinetwep.3ds&quot;,0},
-		{&quot;objs/noinetwpa.3ds&quot;,0},
-		{&quot;objs/arrow2.3ds&quot;,0}
-	};
+	{&quot;objs/accesspoint.3ds&quot;,0},
+	{&quot;objs/noinetwep.3ds&quot;,0},
+	{&quot;objs/noinetwpa.3ds&quot;,0},
+	{&quot;objs/arrow2.3ds&quot;,0}
+};
 
 /* load icons, we want to clone each of them later */
 void ui_loadicons()
@@ -51,7 +51,8 @@
 	s3dw_delete(button-&gt;parent); /* parent =surface. this means close containing window */
 }
 
-int ui_getinfo_node(void *data, int argc, char **argv, char **azColName) {
+int ui_getinfo_node(void *data, int argc, char **argv, char **azColName)
+{
 	int i,tagid=-1;
 	char type[MAXQ];
 	char name[MAXQ];
@@ -59,14 +60,14 @@
 	s3dw_surface *miniwin;
 	s3dw_button  *button;
 
-	for(i=0; i&lt;argc; i++) {
+	for (i=0; i&lt;argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],&quot;tag_id&quot;)) 			tagid=atoi(argv[i]);
 		}
 	}
 	if (db_gettag(tagid, &quot;amenity&quot;,type)) type[0]=0;
 	if (db_gettag(tagid, &quot;name&quot;,name)) name[0]=0;
-	
+
 	miniwin=s3dw_surface_new(&quot;About node&quot;,30,6);
 	snprintf(string,128,&quot;name: %s&quot;,name);
 	s3dw_label_new(miniwin,string,1,2);
@@ -78,14 +79,15 @@
 
 	return(0);
 }
-int ui_getinfo_way(void *data, int argc, char **argv, char **azColName) {
+int ui_getinfo_way(void *data, int argc, char **argv, char **azColName)
+{
 	int i,tagid=-1;
 	char name[MAXQ];
 	char string[128];
 	s3dw_surface *miniwin;
 	s3dw_button  *button;
 
-	for(i=0; i&lt;argc; i++) {
+	for (i=0; i&lt;argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],&quot;tag_id&quot;)) 			tagid=atoi(argv[i]);
 		}
@@ -117,13 +119,13 @@
 }
 int ui_key(struct s3d_evt *evt)
 {
-/*	struct s3d_key_event *key=(struct s3d_key_event *)evt-&gt;buf;*/
+	/*	struct s3d_key_event *key=(struct s3d_key_event *)evt-&gt;buf;*/
 	if (s3dw_handle_key(evt)) return(0);
 	return(0);
 }
 int ui_oinfo(struct s3d_evt *evt)
 {
-	s3dw_object_info(evt);	
+	s3dw_object_info(evt);
 	return(0);
 }
 int ui_init()
@@ -138,8 +140,7 @@
 /* initialize the loadwindow or change its caption text */
 int load_window(char *text)
 {
-	if (loadwindow==NULL) /* create it */
-	{
+	if (loadwindow==NULL) { /* create it */
 		loadwindow=s3dw_surface_new(&quot;Now loading ...&quot;,20,5);
 		loadlabel=s3dw_label_new(loadwindow,text,1,2);
 		loadstatus=s3dw_label_new(loadwindow,&quot;&quot;,1,3);

Modified: trunk/apps/s3dvt/main.c
===================================================================
--- trunk/apps/s3dvt/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dvt/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,22 +1,22 @@
 /*
  * main.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  * Copyright (C) 2002 Alexander Graf &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">helly at gmx.net</A>&gt;
  *
  * This file is part of s3dvt, a 3d terminal emulator for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dvt is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dvt is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dvt; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,7 +35,9 @@
 #include &lt;s3d.h&gt;		 /*  s3d_* */
 #include &lt;s3d_keysym.h&gt;	 /*  key symbols */
 #include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
 
 
 static int pid;
@@ -67,181 +69,171 @@
 {
 	int iscon=1,ret;
 	char buffer[1024];
-	while(iscon) 
-	{
-		switch (term_mode)
-		{
-			case M_PIPE:
-				ret=read(mpipe_out[0], &amp;buffer, 1000);
-				break;
-			case M_PTY:
-				ret=read(curpty, &amp;buffer, 1000);
-				break;
-			default:
-				ret=-1;
+	while (iscon) {
+		switch (term_mode) {
+		case M_PIPE:
+			ret=read(mpipe_out[0], &amp;buffer, 1000);
+			break;
+		case M_PTY:
+			ret=read(curpty, &amp;buffer, 1000);
+			break;
+		default:
+			ret=-1;
 		}
-		if(ret&gt;0) 
-		{ 
+		if (ret&gt;0) {
 			buffer[ret]='\0';
 			printf(&quot;&lt;&lt;&lt;new data(%d bytes)\n&quot;, ret);
 			AddChar(buffer);
 		} else {
-			if (ret==-1)
-			{
+			if (ret==-1) {
 				perror(&quot;read()&quot;);
-				printf(&quot;Connection to pty lost (ret=%d)\n&quot;,ret); 
+				printf(&quot;Connection to pty lost (ret=%d)\n&quot;,ret);
 				close(mpipe_in[0]);
 				close(mpipe_out[1]);
-		/* 		close(curpty);  */
-		/* 		close(curtty);  */
+				/* 		close(curpty);  */
+				/* 		close(curtty);  */
 				printf(&quot;********CONNECTION TO PTY LOST!*******\n&quot;);
 				sleep(1);
 				s3d_quit();
 				exit(0);
 			}
 		}
-    }
+	}
 	return(NULL); /* huh?! */
 }
 int pty_init_terminal()
 {
-    int i;
-    char buf[256];
-    char tmpstr[1024];
-    int curtty;
-    int uid=0,gid=0;
-    char exe[]=&quot;/bin/bash&quot;;
-    char curchar;
-    char *disp;
-    
-    disp=getenv(&quot;DISPLAY&quot;);
-    uid=getuid();
-    gid=getgid();
+	int i;
+	char buf[256];
+	char tmpstr[1024];
+	int curtty;
+	int uid=0,gid=0;
+	char exe[]=&quot;/bin/bash&quot;;
+	char curchar;
+	char *disp;
+
+	disp=getenv(&quot;DISPLAY&quot;);
+	uid=getuid();
+	gid=getgid();
 	term_mode=M_PTY;
-    for(curchar='p'; curchar&lt;'z';curchar++) 
-	{
-		for(i=0;i &lt; 16;i++) 
-		{
+	for (curchar='p'; curchar&lt;'z';curchar++) {
+		for (i=0;i &lt; 16;i++) {
 			sprintf(buf, &quot;/dev/pty%c%x&quot;, curchar, i);
 			curpty=open(buf, O_RDWR);
-			if (curpty &gt;= 0) 
+			if (curpty &gt;= 0)
 				goto endloop;
 		}
-    }
+	}
 endloop:
-    if(curpty &lt; 0) {
-		printf(&quot;Error opening pty\n&quot;); 
-		return 0; 
+	if (curpty &lt; 0) {
+		printf(&quot;Error opening pty\n&quot;);
+		return 0;
 	}
-/* 	fnctl(F_SETFL,O_NONBLOCK); */
+	/* 	fnctl(F_SETFL,O_NONBLOCK); */
 	signal(SIGCHLD, SIG_IGN);
-    pid = fork();
-	if(!pid) 
-	{
-	    buf[5]='t';
-	    curtty=open(buf, O_RDWR);
-	    if (curtty &lt; 0) { 
-			printf(&quot;Error opening tty\n&quot;); 
-			return 0; 
+	pid = fork();
+	if (!pid) {
+		buf[5]='t';
+		curtty=open(buf, O_RDWR);
+		if (curtty &lt; 0) {
+			printf(&quot;Error opening tty\n&quot;);
+			return 0;
 		}
-	    setuid(uid);
-	    setgid(gid);
-	    if(setsid()&lt;0) 
-			printf(&quot;ERROR (setsid)\n&quot;); 
-	/*     tcflush(curpty, TCIOFLUSH); */
-	    if(ioctl(curtty, TIOCSCTTY, NULL)) 
+		setuid(uid);
+		setgid(gid);
+		if (setsid()&lt;0)
+			printf(&quot;ERROR (setsid)\n&quot;);
+		/*     tcflush(curpty, TCIOFLUSH); */
+		if (ioctl(curtty, TIOCSCTTY, NULL))
 			printf(&quot;ERROR! (ttyflush)\n&quot;);;
-	    dup2(curtty, 0);
-	    dup2(curtty, 1);
-	    dup2(curtty, 2);
-	    sprintf(tmpstr, &quot;%d&quot;, MAX_LINES-1);
-	    setenv(&quot;LINES&quot;, tmpstr, 1);
-	    sprintf(tmpstr, &quot;%d&quot;, MAX_CHARS-1);
-	    setenv(&quot;COLUMNS&quot;, tmpstr, 1);
-	    setenv(&quot;TERM&quot;, &quot;rxvt&quot;, 1);
-	    execl(exe, exe, NULL);
+		dup2(curtty, 0);
+		dup2(curtty, 1);
+		dup2(curtty, 2);
+		sprintf(tmpstr, &quot;%d&quot;, MAX_LINES-1);
+		setenv(&quot;LINES&quot;, tmpstr, 1);
+		sprintf(tmpstr, &quot;%d&quot;, MAX_CHARS-1);
+		setenv(&quot;COLUMNS&quot;, tmpstr, 1);
+		setenv(&quot;TERM&quot;, &quot;rxvt&quot;, 1);
+		execl(exe, exe, NULL);
 		sleep(1);
 		printf(&quot;that's it, exiting&quot;);
 		close(curtty);
 		exit(0);
-	} else if(pid&lt;0) {
+	} else if (pid&lt;0) {
 		printf(&quot;Cant fork()\n&quot;);
 		exit(0);
 	} else {
-    	pthread_create(&amp;term_thread, NULL, thread_terminal, NULL);
+		pthread_create(&amp;term_thread, NULL, thread_terminal, NULL);
 	}
-    return 1;
+	return 1;
 }
 /*  terminal.c */
 void term_addchar(char toprint)
 {
-/*    printf(&quot;sending: %.3d\n&quot;, toprint);*/
-	switch (term_mode)
-	{
-		case M_PIPE:
-			write(mpipe_in[1],&amp;toprint,1);
-			write(mpipe_out[1],&amp;toprint,1);
-			break;
-		case M_PTY:
-			write(curpty, &amp;toprint, 1);
-			break;
+	/*    printf(&quot;sending: %.3d\n&quot;, toprint);*/
+	switch (term_mode) {
+	case M_PIPE:
+		write(mpipe_in[1],&amp;toprint,1);
+		write(mpipe_out[1],&amp;toprint,1);
+		break;
+	case M_PTY:
+		write(curpty, &amp;toprint, 1);
+		break;
 	}
 }
 
 
 int pipe_init_terminal()
 {
-    char buf[256];
-    int uid=0,gid=0;
-    char *exe=&quot;/bin/bash&quot;;
-    char *args=&quot;-i&quot;;
-    char *disp;
+	char buf[256];
+	int uid=0,gid=0;
+	char *exe=&quot;/bin/bash&quot;;
+	char *args=&quot;-i&quot;;
+	char *disp;
 
 	term_mode=M_PIPE;
-	if ((pipe(mpipe_in)==-1) || (pipe(mpipe_out)==-1))
-	{
+	if ((pipe(mpipe_in)==-1) || (pipe(mpipe_out)==-1)) {
 		printf(&quot;pipe failed\n&quot;);
 		return(-1);
 	}
-    disp=getenv(&quot;DISPLAY&quot;);
-    uid=getuid();
-    gid=getgid();
-    pid = fork();
-	if(pid==0) 
-	{  /*  the child */
-	    char tmpstr[1024];
-	    buf[5]='t';
-	    setuid(uid);
-	    setgid(gid);
-	    if(setsid()&lt;0) 
-			printf(&quot;ERROR (setsid)\n&quot;); 
-/*     tcflush(curpty, TCIOFLUSH); */
-/*     if(ioctl(curtty, TIOCSCTTY, NULL)) printf(&quot;ERROR! (ttyflush)\n&quot;);; */
+	disp=getenv(&quot;DISPLAY&quot;);
+	uid=getuid();
+	gid=getgid();
+	pid = fork();
+	if (pid==0) { /*  the child */
+		char tmpstr[1024];
+		buf[5]='t';
+		setuid(uid);
+		setgid(gid);
+		if (setsid()&lt;0)
+			printf(&quot;ERROR (setsid)\n&quot;);
+		/*     tcflush(curpty, TCIOFLUSH); */
+		/*     if(ioctl(curtty, TIOCSCTTY, NULL)) printf(&quot;ERROR! (ttyflush)\n&quot;);; */
 		setvbuf(stdout,(char*)NULL,_IONBF,0);
-	    dup2(mpipe_in[0], fileno(stdin));
-	    dup2(mpipe_out[1], fileno(stdout));
-	    dup2(mpipe_out[1], fileno(stderr));
-		 /*  close unneded things: */
-		close(mpipe_out[0]); 
-		close(mpipe_in[1]); 
-	    sprintf(tmpstr, &quot;%d&quot;, MAX_LINES-1);
-	    setenv(&quot;LINES&quot;, tmpstr, 1);
-	    sprintf(tmpstr, &quot;%d&quot;, MAX_CHARS-1);
-	    setenv(&quot;COLUMNS&quot;, tmpstr, 1);
-	    setenv(&quot;TERM&quot;, &quot;rxvt&quot;, 1);
-	    execl(exe, exe, args,NULL);
+		dup2(mpipe_in[0], fileno(stdin));
+		dup2(mpipe_out[1], fileno(stdout));
+		dup2(mpipe_out[1], fileno(stderr));
+		/*  close unneded things: */
+		close(mpipe_out[0]);
+		close(mpipe_in[1]);
+		sprintf(tmpstr, &quot;%d&quot;, MAX_LINES-1);
+		setenv(&quot;LINES&quot;, tmpstr, 1);
+		sprintf(tmpstr, &quot;%d&quot;, MAX_CHARS-1);
+		setenv(&quot;COLUMNS&quot;, tmpstr, 1);
+		setenv(&quot;TERM&quot;, &quot;rxvt&quot;, 1);
+		execl(exe, exe, args,NULL);
 		printf(&quot;that's it, exiting&quot;);
 		close(curtty);
 		exit(0);
-   } else if(pid&lt;0) {
-    printf(&quot;Cant fork()\n&quot;);
-	exit(0);
-   } else {
-	 /*  close unneded things... */
+	} else if (pid&lt;0) {
+		printf(&quot;Cant fork()\n&quot;);
+		exit(0);
+	} else {
+		/*  close unneded things... */
 		close(mpipe_in[0]);
-	    pthread_create(&amp;term_thread, NULL, thread_terminal, NULL);
-   }
-    return 1;
+		pthread_create(&amp;term_thread, NULL, thread_terminal, NULL);
+	}
+	return 1;
 }
 int init_terminal()
 {
@@ -254,19 +246,18 @@
 void term_unload()
 {
 	printf(&quot;unloading tty!!\n&quot;);
-	switch (term_mode)
-	{
-		case M_PTY:
-			write(curpty, '\0', 1);  /*  send an EOF, just in case */
-		    close(curpty);
-		    close(curtty);
-			 /* kill(pid); */
-			break;
-		case M_PIPE:
-			 /*  bash should fade with &quot;broken pipe&quot; */
-			close(mpipe_in[1]);
-			close(mpipe_out[0]);
-			break;
+	switch (term_mode) {
+	case M_PTY:
+		write(curpty, '\0', 1);  /*  send an EOF, just in case */
+		close(curpty);
+		close(curtty);
+		/* kill(pid); */
+		break;
+	case M_PIPE:
+		/*  bash should fade with &quot;broken pipe&quot; */
+		close(mpipe_in[1]);
+		close(mpipe_out[0]);
+		break;
 	}
 }
 #ifdef M_CHAR
@@ -280,39 +271,34 @@
 
 	s3d_translate(	cursor,cx*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cy*CS + CS*MAX_LINES/2,0);
 	s3d_scale(		cursor,CS);
-	for(cline=0;cline&lt;MAX_LINES;cline++)
-	{
+	for (cline=0;cline&lt;MAX_LINES;cline++) {
 		line_end=0;
-		for (c=0;c&lt;MAX_CHARS;c++)
-		{
+		for (c=0;c&lt;MAX_CHARS;c++) {
 			i=cline*MAX_CHARS+c;			 /*  calculate position */
-			if (((ch=line[cline].chars[c].character)!=(och=last_c[i])))
-			{
-				if (screenbuf[i]==-1)
-				{
+			if (((ch=line[cline].chars[c].character)!=(och=last_c[i]))) {
+				if (screenbuf[i]==-1) {
 					screenbuf[i]=s3d_new_object();
 					s3d_translate(screenbuf[i],c*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cline*CS + CS*MAX_LINES/2,0);
 					s3d_scale(screenbuf[i],CS);
 					s3d_flags_on(screenbuf[i],S3D_OF_VISIBLE);
 				}
-				if ((ch==0) || (line_end))
-				{	/*  the new character is zero! delete! */
+				if ((ch==0) || (line_end)) {	/*  the new character is zero! delete! */
 					line[cline].chars[c].character=0;
 					ci=charbuf[' '];
 					s3d_clone_target(screenbuf[i],ci);
 					line_end=1;
-/* 					printf(&quot;-%03d&quot;,ch); */
+					/* 					printf(&quot;-%03d&quot;,ch); */
 				} else {
 					ci=charbuf[ch];
-/* 					printf(&quot;!%03d&quot;,ch); */
+					/* 					printf(&quot;!%03d&quot;,ch); */
 					s3d_clone_target(screenbuf[i],ci);
 				}
 			} else {
-/* 				printf(&quot;=%03d&quot;,ch); */
-			} 
-			last_c[i]=ch;			
+				/* 				printf(&quot;=%03d&quot;,ch); */
+			}
+			last_c[i]=ch;
 		}
-/* 		printf(&quot;\n&quot;); */
+		/* 		printf(&quot;\n&quot;); */
 	}
 	gotnewdata=0;
 }
@@ -325,47 +311,40 @@
 	int len;
 	int changed;
 	char cl[MAX_CHARS];
-	for(cline=0;cline&lt;MAX_LINES;cline++)
-	{
+	for (cline=0;cline&lt;MAX_LINES;cline++) {
 		len=MAX_CHARS;
 		changed=0;
-		for (c=MAX_CHARS;c&gt;=0;c--)
-		{
+		for (c=MAX_CHARS;c&gt;=0;c--) {
 			cl[c]=line[cline].chars[c].character;
-			if (line[cline].chars[c].character!=line[cline].chars[c].last_c)
-			{
+			if (line[cline].chars[c].character!=line[cline].chars[c].last_c) {
 				changed=c+1;
-/*				printf(&quot;changed [%d/%d] from %d to %d\n&quot;,cline,c,
-								line[cline].chars[c].last_c,
-								line[cline].chars[c].character
-								);*/
+				/*				printf(&quot;changed [%d/%d] from %d to %d\n&quot;,cline,c,
+												line[cline].chars[c].last_c,
+												line[cline].chars[c].character
+												);*/
 				line[cline].chars[c].last_c=line[cline].chars[c].character;
 			}
 			if (cl[c]==0) len=c;
 		}
-		if (changed)
-		{
-		if (len&gt;0)
-		{
-			printf(&quot;[p: line %d [len: %d/changed: %d]\n&quot;,cline,len,changed);
-			oid=s3d_draw_string(cl,NULL);
-			s3d_translate(oid,0,-cline,0);
-			if (lines[cline]!=-1) 
-			{
-				s3d_del_object(lines[cline]);
-				lines[cline]=-1;
+		if (changed) {
+			if (len&gt;0) {
+				printf(&quot;[p: line %d [len: %d/changed: %d]\n&quot;,cline,len,changed);
+				oid=s3d_draw_string(cl,NULL);
+				s3d_translate(oid,0,-cline,0);
+				if (lines[cline]!=-1) {
+					s3d_del_object(lines[cline]);
+					lines[cline]=-1;
+				}
+				s3d_flags_on(oid,S3D_OF_VISIBLE);
+				lines[cline]=oid;
+			} else {
+				if (lines[cline]!=-1) {
+					s3d_del_object(lines[cline]);
+					lines[cline]=-1;
+				}
 			}
-			s3d_flags_on(oid,S3D_OF_VISIBLE);
-			lines[cline]=oid;
-		} else {
-			if (lines[cline]!=-1)
-			{
-				s3d_del_object(lines[cline]);
-				lines[cline]=-1;
-			}
 		}
-		}
-		
+
 	}
 	gotnewdata=0;
 }
@@ -392,98 +371,97 @@
 				screenbuf[MAX_LINES*MAX_CHARS]=oid;
 			 }
 	    }
-/ * 		printf(&quot;\n&quot;); * / 
+/ * 		printf(&quot;\n&quot;); * /
 	}
 }*/
 int keypress(struct s3d_evt *event)
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)event-&gt;buf;
 	int key;
-/*	printf(&quot;received key: %d\n&quot;,key);*/
-	switch (key=keys-&gt;keysym)
-	{
-		case S3DK_F1:
-		case S3DK_F2:
-		case S3DK_F3:
-		case S3DK_F4:
-		case S3DK_F5:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('1');
-			term_addchar(key-S3DK_F1+'1');
-			break;
-		case S3DK_F6:
-		case S3DK_F7:
-		case S3DK_F8:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('1');
-			term_addchar((key-S3DK_F6)+'7');
-			break;
-		case S3DK_F9:
-		case S3DK_F10:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('2');
-			term_addchar((key-S3DK_F9)+'0');
-			break;
-		case S3DK_F11:
-		case S3DK_F12:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('2');
-			term_addchar((key-S3DK_F11)+'3');
-			break;
-		case S3DK_UP:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('A');
-			break;
-		case S3DK_DOWN:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('B');
-			break;
-		case S3DK_RIGHT:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('C');
-			break;
-		case S3DK_LEFT:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('D');
-			break;
-		case S3DK_PAGEUP:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('5');
-			term_addchar('~');
-			break;
-		case S3DK_PAGEDOWN:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('6');
-			term_addchar('~');
-			break;
-		case S3DK_HOME:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('7');
-			term_addchar('~');
-			break;
-		case S3DK_END:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('8');
-			term_addchar('~');
-			break;
-		case 13:
-			term_addchar(10);
-			break;
-		default:
-			if ((char)keys-&gt;unicode)  /*  \0 is no good idea .. */
-				term_addchar((char)keys-&gt;unicode);
+	/*	printf(&quot;received key: %d\n&quot;,key);*/
+	switch (key=keys-&gt;keysym) {
+	case S3DK_F1:
+	case S3DK_F2:
+	case S3DK_F3:
+	case S3DK_F4:
+	case S3DK_F5:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('1');
+		term_addchar(key-S3DK_F1+'1');
+		break;
+	case S3DK_F6:
+	case S3DK_F7:
+	case S3DK_F8:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('1');
+		term_addchar((key-S3DK_F6)+'7');
+		break;
+	case S3DK_F9:
+	case S3DK_F10:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('2');
+		term_addchar((key-S3DK_F9)+'0');
+		break;
+	case S3DK_F11:
+	case S3DK_F12:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('2');
+		term_addchar((key-S3DK_F11)+'3');
+		break;
+	case S3DK_UP:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('A');
+		break;
+	case S3DK_DOWN:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('B');
+		break;
+	case S3DK_RIGHT:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('C');
+		break;
+	case S3DK_LEFT:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('D');
+		break;
+	case S3DK_PAGEUP:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('5');
+		term_addchar('~');
+		break;
+	case S3DK_PAGEDOWN:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('6');
+		term_addchar('~');
+		break;
+	case S3DK_HOME:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('7');
+		term_addchar('~');
+		break;
+	case S3DK_END:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('8');
+		term_addchar('~');
+		break;
+	case 13:
+		term_addchar(10);
+		break;
+	default:
+		if ((char)keys-&gt;unicode)  /*  \0 is no good idea .. */
+			term_addchar((char)keys-&gt;unicode);
 	}
 	return(0);
 
@@ -492,23 +470,19 @@
 void mainloop()
 {
 	usleep(10000);
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 
-	if ((i+=2)&gt;100)
-	{
-		if (i%2)
-		{
+	if ((i+=2)&gt;100) {
+		if (i%2) {
 			s3d_flags_on(cursor,S3D_OF_VISIBLE);
 			i=0;
-		}
-		else
-		{
+		} else {
 			s3d_flags_off(cursor,S3D_OF_VISIBLE);
 			i=1;
 		}
 	}
 	if (gotnewdata) {
-/* 		printf(&quot;got new data,displaying\n&quot;); */
+		/* 		printf(&quot;got new data,displaying\n&quot;); */
 		paintit();
 	}
 }
@@ -526,8 +500,8 @@
 	s3d_push_vertex(b, MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
 	s3d_push_vertex(b,-MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
 	s3d_push_material_a(b,0.5,0.5,0.5,0.7,
-						  1,1,1,0.7,
-						  0,0,0,0.7);
+	                    1,1,1,0.7,
+	                    0,0,0,0.7);
 	s3d_push_polygon(b,1,2,0,0);
 	s3d_push_polygon(b,2,3,0,0);
 	s3d_flags_on(b,S3D_OF_VISIBLE);
@@ -538,13 +512,11 @@
 #ifdef M_CHAR
 	char c[2];
 	c[1]='\0';
-	for (i=0;i&lt;128;i++)
-	{
+	for (i=0;i&lt;128;i++) {
 		c[0]=i;
 		charbuf[i]=s3d_draw_string(c,NULL);
 	}
-	for (i=128;i&lt;256;i++)
-	{
+	for (i=128;i&lt;256;i++) {
 		charbuf[i]=s3d_new_object();
 	}
 	cursor=s3d_new_object();
@@ -556,13 +528,12 @@
 #ifdef M_CHAR
 	int x,y;
 	for (y=0;y&lt;(MAX_LINES);y++)
-	for (x=0;x&lt;(MAX_CHARS);x++)
-	{
-		line[y].chars[x].character=line[y].chars[x].character=0;
-		i=y*MAX_CHARS+x;
-		screenbuf[i]=-1;
-		last_c[i]=0;
-	}
+		for (x=0;x&lt;(MAX_CHARS);x++) {
+			line[y].chars[x].character=line[y].chars[x].character=0;
+			i=y*MAX_CHARS+x;
+			screenbuf[i]=-1;
+			last_c[i]=0;
+		}
 #endif
 #ifdef M_LINE
 	int i;
@@ -574,15 +545,13 @@
 {
 	unsigned int b;
 	chars_init();
-   	init_terminal();
+	init_terminal();
 	s3d_set_callback(S3D_EVENT_QUIT,stop);
 	s3d_set_callback(S3D_EVENT_OBJ_CLICK,stop);
 	s3d_set_callback(S3D_EVENT_KEY,keypress);
 
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;s3dvt&quot;))	
-	{
-		if (s3d_select_font(&quot;vera&quot;))
-		{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;s3dvt&quot;)) {
+		if (s3d_select_font(&quot;vera&quot;)) {
 			printf(&quot;font not found\n&quot;);
 			exit(-1);
 		}

Modified: trunk/apps/s3dvt/s3dvt.h
===================================================================
--- trunk/apps/s3dvt/s3dvt.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dvt/s3dvt.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,22 +1,22 @@
 /*
  * s3dvt.h
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  * Copyright (C) 2002 Alexander Graf &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">helly at gmx.net</A>&gt;
  *
  * This file is part of s3dvt, a 3d terminal emulator for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dvt is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dvt is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dvt; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,16 +35,14 @@
 /* #define M_LINE		1 */
 #define M_CHAR		1
 
-typedef struct char_struct
-{
-    char character;
-    char fgcolor;
-    char bgcolor;
+typedef struct char_struct {
+	char character;
+	char fgcolor;
+	char bgcolor;
 }t_char;
 
-typedef struct line_struct
-{
-    t_char chars[MAX_CHARS+1];
+typedef struct line_struct {
+	t_char chars[MAX_CHARS+1];
 } t_line;
 
 extern t_line line[MAX_LINES+1];

Modified: trunk/apps/s3dvt/terminal.c
===================================================================
--- trunk/apps/s3dvt/terminal.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dvt/terminal.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,22 +1,22 @@
 /*
  * terminal.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  * Copyright (C) 2002 Alexander Graf &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">helly at gmx.net</A>&gt;
  *
  * This file is part of s3dvt, a 3d terminal emulator for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3dvt is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dvt is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dvt; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -48,263 +48,259 @@
 
 void move_all_lines_up()
 {
-    t_line *pfirstline=(t_line*)&line;
-    t_line *psecondline=(t_line*)&amp;line+1;
-    t_line tmpline[MAX_LINES];
-    memcpy(&amp;tmpline, psecondline, (MAX_LINES-1)*sizeof(struct line_struct));
-    memcpy(pfirstline, &amp;tmpline, (MAX_LINES-1)*sizeof(struct line_struct));
+	t_line *pfirstline=(t_line*)&line;
+	t_line *psecondline=(t_line*)&amp;line+1;
+	t_line tmpline[MAX_LINES];
+	memcpy(&amp;tmpline, psecondline, (MAX_LINES-1)*sizeof(struct line_struct));
+	memcpy(pfirstline, &amp;tmpline, (MAX_LINES-1)*sizeof(struct line_struct));
 }
 
 void clear_char(int lineid, int charid)
 {
-    line[lineid].chars[charid].character=0;
-    line[lineid].chars[charid].fgcolor=DEFAULT_FGCOLOR;
-    line[lineid].chars[charid].bgcolor=DEFAULT_BGCOLOR;
+	line[lineid].chars[charid].character=0;
+	line[lineid].chars[charid].fgcolor=DEFAULT_FGCOLOR;
+	line[lineid].chars[charid].bgcolor=DEFAULT_BGCOLOR;
 }
 
 void clear_line(int lineid)
 {
-    int i;
-    for(i=0;i&lt;MAX_CHARS;i++)
+	int i;
+	for (i=0;i&lt;MAX_CHARS;i++)
 		clear_char(lineid, i);
 }
 
 void clear_line_after_lastchar()
 {
-    int i;
-    for(i=cx;i&lt;MAX_CHARS;i++) 
+	int i;
+	for (i=cx;i&lt;MAX_CHARS;i++)
 		clear_char(cy, i);
 }
 
 t_line *line_is_full()
 {
-    t_line *pcurline=(t_line*)&amp;line+cy;
-    cy++;
-    if (cy&gt;=MAX_LINES) {       /*  damn it ... our display is filled ... let's move everything upwards */
+	t_line *pcurline=(t_line*)&amp;line+cy;
+	cy++;
+	if (cy&gt;=MAX_LINES) {       /*  damn it ... our display is filled ... let's move everything upwards */
 		cy=MAX_LINES-1;
 		pcurline=(t_line*)&amp;line+cy;
-        move_all_lines_up();
-        clear_line(cy);
+		move_all_lines_up();
+		clear_line(cy);
 		gotnewdata=1;
-    } else {
-        pcurline=(t_line*)&amp;line+cy;
-    }
+	} else {
+		pcurline=(t_line*)&amp;line+cy;
+	}
 	cx=0;
-    return pcurline;
+	return pcurline;
 }
 
 void add_char_append(char toappend)
 {
-    int shouldinc=1;
-    t_line *pcurline=(t_line*)&amp;line+cy;
-    if (cx==MAX_CHARS-1)
-	{ 
-		pcurline=line_is_full(); 
-		shouldinc=0; 
+	int shouldinc=1;
+	t_line *pcurline=(t_line*)&amp;line+cy;
+	if (cx==MAX_CHARS-1) {
+		pcurline=line_is_full();
+		shouldinc=0;
 	}  /*  our line is full */
-    pcurline-&gt;chars[cx].character=toappend;
-    pcurline-&gt;chars[cx].fgcolor=curfgcolor;
-    pcurline-&gt;chars[cx].bgcolor=curbgcolor;
-    if(shouldinc) 
+	pcurline-&gt;chars[cx].character=toappend;
+	pcurline-&gt;chars[cx].fgcolor=curfgcolor;
+	pcurline-&gt;chars[cx].bgcolor=curbgcolor;
+	if (shouldinc)
 		cx++;
 }
 
 void backspace()
 {
-    if(cx&gt;0)
+	if (cx&gt;0)
 		cx--;
-    else 
+	else
 		cx=0;
 }
 
 void endansi()
 {
-    printf(&quot; [/ANSI(%d)]\n&quot;, isansi2);
-    isansi=0;
-    isansi2=0;
+	printf(&quot; [/ANSI(%d)]\n&quot;, isansi2);
+	isansi=0;
+	isansi2=0;
 }
 
 /*
-              Parameter                              Parameter Meaning                                     
-	      
-	      0                                      Attributes off                                                                                      
-	      1                                      Bold or increased intensity                                                                                       
-	      4                                      Underscore                                                                                            
-	      5                                      Blink                                                                                                     
-	      7                                      Negative (reverse) image                                                                           
-*/	      
+              Parameter                              Parameter Meaning
 
+	      0                                      Attributes off
+	      1                                      Bold or increased intensity
+	      4                                      Underscore
+	      5                                      Blink
+	      7                                      Negative (reverse) image
+*/
+
 void ansi_change_graphic(char **args)
 {
-    int curcol;
-    int i;
-    
-    if (args[0][0]=='\0') 
-	{
+	int curcol;
+	int i;
+
+	if (args[0][0]=='\0') {
 		args[0][0]='0';
 		args[0][1]='\0';
 	}
-    
-    for(i=0;i&lt;5;i++)
-	{
-		if(args[i][0])
-		{
-		    curcol=atoi(args[i]);
-			
-			switch(curcol)
-			{
-			    case 0:
-					curbgcolor=DEFAULT_BGCOLOR;
-					curfgcolor=DEFAULT_FGCOLOR;
-					break;
-			    case 1:	 /*  Bold or increased intensity */
-			    case 4:	 /*  Underscore */
-			    case 5:	 /*  Blink */
-			    case 7:	 /*  Negative (reverse) image */
-			    case 10:	 /*  primary font */
-			    case 11:	 /*  alternate font */
-					break;
-				case 30:
-				case 31:
-				case 32:
-				case 33:
-				case 34:
-				case 35:
-				case 36:
-				case 37:
-					curfgcolor=curcol-30;
-					break;
-			    case 39:
-					curbgcolor=DEFAULT_FGCOLOR;
-					break;
-				case 40:
-				case 41:
-				case 42:
-				case 43:
-				case 44:
-				case 45:
-				case 46:
-				case 47:
-					curbgcolor=curcol-40;
-					break;
-	
-			    case 49:
-					curbgcolor=DEFAULT_BGCOLOR;
-					break;
-	
-			    default:
-					printf(&quot;*** don't know color-code %d\n&quot;, curcol);
-					break;
-		    }
+
+	for (i=0;i&lt;5;i++) {
+		if (args[i][0]) {
+			curcol=atoi(args[i]);
+
+			switch (curcol) {
+			case 0:
+				curbgcolor=DEFAULT_BGCOLOR;
+				curfgcolor=DEFAULT_FGCOLOR;
+				break;
+			case 1:	 /*  Bold or increased intensity */
+			case 4:	 /*  Underscore */
+			case 5:	 /*  Blink */
+			case 7:	 /*  Negative (reverse) image */
+			case 10:	 /*  primary font */
+			case 11:	 /*  alternate font */
+				break;
+			case 30:
+			case 31:
+			case 32:
+			case 33:
+			case 34:
+			case 35:
+			case 36:
+			case 37:
+				curfgcolor=curcol-30;
+				break;
+			case 39:
+				curbgcolor=DEFAULT_FGCOLOR;
+				break;
+			case 40:
+			case 41:
+			case 42:
+			case 43:
+			case 44:
+			case 45:
+			case 46:
+			case 47:
+				curbgcolor=curcol-40;
+				break;
+
+			case 49:
+				curbgcolor=DEFAULT_BGCOLOR;
+				break;
+
+			default:
+				printf(&quot;*** don't know color-code %d\n&quot;, curcol);
+				break;
+			}
 		}
-    }
+	}
 }
 void move_up_x_lines(char *arg)
 {
-    t_line *pfirstline;
-    t_line *psecondline;
-    t_line tmpline[MAX_LINES];
-    int amount;
-    int i;
-    
-    if(arg[0]) amount=atoi(arg); else amount=0;
-    
-    printf(&quot;moving up %d lines&quot;, amount);
-    
-    for(i=0;i&lt;amount;i++)
-	{
-    
+	t_line *pfirstline;
+	t_line *psecondline;
+	t_line tmpline[MAX_LINES];
+	int amount;
+	int i;
+
+	if (arg[0]) amount=atoi(arg);
+	else amount=0;
+
+	printf(&quot;moving up %d lines&quot;, amount);
+
+	for (i=0;i&lt;amount;i++) {
+
 		pfirstline=(t_line*)&amp;line+cy;
 		psecondline=pfirstline+1;
-    
+
 		memcpy(&amp;tmpline, psecondline, (bottom-top)*sizeof(struct line_struct));
 		memcpy(pfirstline, &amp;tmpline,  (bottom-top)*sizeof(struct line_struct));
-    
-    }
+
+	}
 }
 
 void move_down_x_lines(char *arg)
 {
-    t_line *pfirstline;
-    t_line *psecondline;
-    t_line tmpline[MAX_LINES];
-    int amount;
-    int i;
-    
-    if(arg[0]) amount=atoi(arg); else amount=0;
-    
-    printf(&quot;moving down %d lines&quot;, amount);
-    
-    for(i=0;i&lt;amount;i++)
-	{
+	t_line *pfirstline;
+	t_line *psecondline;
+	t_line tmpline[MAX_LINES];
+	int amount;
+	int i;
+
+	if (arg[0]) amount=atoi(arg);
+	else amount=0;
+
+	printf(&quot;moving down %d lines&quot;, amount);
+
+	for (i=0;i&lt;amount;i++) {
 		pfirstline=(t_line*)&amp;line+cy;
 		psecondline=pfirstline+1;
-    
+
 		memcpy(&amp;tmpline, pfirstline, (bottom-top)*sizeof(struct line_struct));
 		memcpy(psecondline, &amp;tmpline,  (bottom-top)*sizeof(struct line_struct));
-    }
+	}
 }
 void delete_x_letters(char *arg1)
 {
-    int tmpint;t_line *pcurline;int i;
-	if(arg1[0]) tmpint=atoi(arg1);
+	int tmpint;
+	t_line *pcurline;
+	int i;
+	if (arg1[0]) tmpint=atoi(arg1);
 	else	    tmpint=1;
 	pcurline=(t_line*)&amp;line+cy;
-	if (tmpint+cx&gt;MAX_CHARS) 
+	if (tmpint+cx&gt;MAX_CHARS)
 		tmpint=MAX_CHARS-cx;
-	for(i=cx;i&lt;cx+tmpint;i++)
-	    clear_char(cy,i);
+	for (i=cx;i&lt;cx+tmpint;i++)
+		clear_char(cy,i);
 }
 void move_x_letters(int mode, char *arg1)
 {
-    int tmpint;t_line *pcurline;int i;
-	if(arg1[0])
-	    tmpint=atoi(arg1);
+	int tmpint;
+	t_line *pcurline;
+	int i;
+	if (arg1[0])
+		tmpint=atoi(arg1);
 	else
-	    tmpint=1;
+		tmpint=1;
 	pcurline=(t_line*)&amp;line+cy;
-	switch(mode) {
-	    case MOVE_RIGHT:
-	        for(i=0;i&lt;tmpint;i++)
-			{
-/*	    	    pcurline-&gt;nextchar++; 
-				lastchar++;*/
-				cx++;
-		    	if (cx==MAX_CHARS) 
-					pcurline=line_is_full();  /*  our line is full */
-			}
-			break;
-	    case MOVE_LEFT:
-	        for(i=0;i&lt;tmpint;i++)
-			{
-				cx--;
-			    if(cx==-1) 
-				{ 
-					cy--; 
-					pcurline=(t_line*)&amp;line+cy; 
-					cx=MAX_CHARS-1; 
-				}  /*  need to go up one line */
-			}
-			break;
-	    case MOVE_UP:
-			cy--;
-			break;
-	    case MOVE_DOWN:
-			line_is_full();
-			break;
-	    default:
-			break;
+	switch (mode) {
+	case MOVE_RIGHT:
+		for (i=0;i&lt;tmpint;i++) {
+			/*	    	    pcurline-&gt;nextchar++;
+							lastchar++;*/
+			cx++;
+			if (cx==MAX_CHARS)
+				pcurline=line_is_full();  /*  our line is full */
+		}
+		break;
+	case MOVE_LEFT:
+		for (i=0;i&lt;tmpint;i++) {
+			cx--;
+			if (cx==-1) {
+				cy--;
+				pcurline=(t_line*)&amp;line+cy;
+				cx=MAX_CHARS-1;
+			}  /*  need to go up one line */
+		}
+		break;
+	case MOVE_UP:
+		cy--;
+		break;
+	case MOVE_DOWN:
+		line_is_full();
+		break;
+	default:
+		break;
 	}
 }
 void remove_beginning_from_curpos()
 {
-    int i,j=cx;
-    for(i=cy;i&lt;MAX_LINES;i++) {
-	for(;j&lt;MAX_CHARS;j++){
-	    clear_char(i,j);
+	int i,j=cx;
+	for (i=cy;i&lt;MAX_LINES;i++) {
+		for (;j&lt;MAX_CHARS;j++) {
+			clear_char(i,j);
+		}
+		j=0;
 	}
-	j=0;
-    }
 }
 
 int parseansi(char curchar)
@@ -318,98 +314,104 @@
 	static char curarg=0;
 	static char *args[]={arg1,arg2,arg3,arg4,arg5};
 	/* 	static char *args[]={&amp;arg1,&amp;arg2,&amp;arg3,&amp;arg4,&amp;arg5}; */
-	    printf(&quot;%c&quot;, curchar);
-	switch (isansi2)
-	{
+	printf(&quot;%c&quot;, curchar);
+	switch (isansi2) {
 	case 1:
-		switch(curchar)
-		{
-		    case '0':
-		    case '1':
-		    case '2':
-		    case '3':
-		    case '4':
-		    case '5':
-		    case '6':
-		    case '7':
-		    case '8':
-		    case '9':  /*  we got an argument */
-				args[(int)curarg][(int)curindex]=curchar;
-				curindex++; 
-				args[(int)curarg][(int)curindex]='\0';
-				break;
-		    case ';':  /*  some arg is finished */
-				curarg++; 
-				curindex=0; 
-				args[(int)curarg][0]='\0';
-				break;
-		    case 'J':  /*  remove beginning from current cursor to end of screen */
-				remove_beginning_from_curpos();
-				gotnewdata=1;
-				break;
-		    case 'K':  /*  remove everything in line beginning from lastchar */
-				clear_line_after_lastchar();
-				break;
-		    case 'H':  /*  move to position x=arg1 y=arg2 */
-				if(arg1[0]) cy=atoi(arg1)-1; 
-					else 	cy=0;
-				if(arg2[0]) cx=atoi(arg2)-1; 
-					else 	cx=0;
-				break;
-		    case 'G':  /*  move to position x=arg1 y=MAX */
-				if(arg1[0]) cx=atoi(arg1)-1; else cx=-1;
-				cy=bottom-1;
-				break;
-		    case 'd':  /*  move to position x=MAX y=arg1 */
-				if(arg1[0]) cy=atoi(arg1)-1; else cy=0;
-				cy=top+cy;
-				cx=MAX_CHARS-1;
-				break;
-		    case 'm':  /*  change graphic */
-				ansi_change_graphic(args);
-				break;
-		    case 'M':  /*  Move memory in range ('r') one uo */
-				move_up_x_lines(arg1);
-				break;
-		    case 'L':  /*  Move memory in range ('r') one down */
-				move_down_x_lines(arg1);
-				break;
-		    case 'l':
-	/*		RM -- Reset Mode
-			
-			ESC [ Ps ; Ps ; . . . ; Ps l                                                                                                          default value: none
-			
-			Resets one or more VT100 modes as specified by each selective parameter in the parameter string. Each mode to be reset is specified by a separate
-			parameter. [See Set Mode (SM) control sequence]. (See Modes following this section).*/
-			
-			 /*  mc only resets the '4' !?! =&gt; IRM (Insert/Replacement-Mode) */
-			 /*  perhaps Set Cursor to Block mode ? */
-				break;
-			case 'r':  /*  define scroll-range  */
-				if(arg1[0]) top=atoi(arg1); else top=0;
-				if(arg2[0]) bottom=atoi(arg2); else bottom=0;
-				cy=0; 
-				cx=0;
-				break;
-			case 'a':
-			case 'A':  /*  move x letters up */
-				move_x_letters(MOVE_UP, arg1);	break;
-			case 'B':  /*  move x letters down */
-				move_x_letters(MOVE_DOWN, arg1);	break;
-			case 'C':  /*  move x letters right */
-				move_x_letters(MOVE_RIGHT, arg1);	break;
-			case 'D':  /*  move x letters left */
-				move_x_letters(MOVE_LEFT, arg1);	break;
-			case 'P':  /*  delete x letters */
-				delete_x_letters(arg1);	break;
-			case '?':
-				isansi2=4;
-				return 0;
-			default:
-				printf(&quot;***unknown***&quot;);
+		switch (curchar) {
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':  /*  we got an argument */
+			args[(int)curarg][(int)curindex]=curchar;
+			curindex++;
+			args[(int)curarg][(int)curindex]='\0';
+			break;
+		case ';':  /*  some arg is finished */
+			curarg++;
+			curindex=0;
+			args[(int)curarg][0]='\0';
+			break;
+		case 'J':  /*  remove beginning from current cursor to end of screen */
+			remove_beginning_from_curpos();
+			gotnewdata=1;
+			break;
+		case 'K':  /*  remove everything in line beginning from lastchar */
+			clear_line_after_lastchar();
+			break;
+		case 'H':  /*  move to position x=arg1 y=arg2 */
+			if (arg1[0]) cy=atoi(arg1)-1;
+			else 	cy=0;
+			if (arg2[0]) cx=atoi(arg2)-1;
+			else 	cx=0;
+			break;
+		case 'G':  /*  move to position x=arg1 y=MAX */
+			if (arg1[0]) cx=atoi(arg1)-1;
+			else cx=-1;
+			cy=bottom-1;
+			break;
+		case 'd':  /*  move to position x=MAX y=arg1 */
+			if (arg1[0]) cy=atoi(arg1)-1;
+			else cy=0;
+			cy=top+cy;
+			cx=MAX_CHARS-1;
+			break;
+		case 'm':  /*  change graphic */
+			ansi_change_graphic(args);
+			break;
+		case 'M':  /*  Move memory in range ('r') one uo */
+			move_up_x_lines(arg1);
+			break;
+		case 'L':  /*  Move memory in range ('r') one down */
+			move_down_x_lines(arg1);
+			break;
+		case 'l':
+			/*		RM -- Reset Mode
+					
+					ESC [ Ps ; Ps ; . . . ; Ps l                                                                                                          default value: none
+					
+					Resets one or more VT100 modes as specified by each selective parameter in the parameter string. Each mode to be reset is specified by a separate
+					parameter. [See Set Mode (SM) control sequence]. (See Modes following this section).*/
+
+			/*  mc only resets the '4' !?! =&gt; IRM (Insert/Replacement-Mode) */
+			/*  perhaps Set Cursor to Block mode ? */
+			break;
+		case 'r':  /*  define scroll-range  */
+			if (arg1[0]) top=atoi(arg1);
+			else top=0;
+			if (arg2[0]) bottom=atoi(arg2);
+			else bottom=0;
+			cy=0;
+			cx=0;
+			break;
+		case 'a':
+		case 'A':  /*  move x letters up */
+			move_x_letters(MOVE_UP, arg1);
+			break;
+		case 'B':  /*  move x letters down */
+			move_x_letters(MOVE_DOWN, arg1);
+			break;
+		case 'C':  /*  move x letters right */
+			move_x_letters(MOVE_RIGHT, arg1);
+			break;
+		case 'D':  /*  move x letters left */
+			move_x_letters(MOVE_LEFT, arg1);
+			break;
+		case 'P':  /*  delete x letters */
+			delete_x_letters(arg1);
+			break;
+		case '?':
+			isansi2=4;
+			return 0;
+		default:
+			printf(&quot;***unknown***&quot;);
 		}
-		if(!((curchar&gt;='0' &amp;&amp; curchar&lt;='9') || curchar==';'))
-		{  /*  clean our args */
+		if (!((curchar&gt;='0' &amp;&amp; curchar&lt;='9') || curchar==';')) { /*  clean our args */
 			args[0][0]='\0';
 			args[1][0]='\0';
 			args[2][0]='\0';
@@ -418,96 +420,98 @@
 			curindex=0;
 			curarg=0;
 			endansi();
-		} 
+		}
 		break;
 	case 0:
-		switch(curchar)
-		{
-		    case '[': isansi2=1; break;
-		    case '(': isansi2=2; break;
-		    case ')': isansi2=3; break;
-		    case ']': isansi2=5; break;
-		    default:
+		switch (curchar) {
+		case '[':
+			isansi2=1;
+			break;
+		case '(':
+			isansi2=2;
+			break;
+		case ')':
+			isansi2=3;
+			break;
+		case ']':
+			isansi2=5;
+			break;
+		default:
 			endansi();
 			break;
 		}
 		break;
 	case 4:
-		if (curchar&gt;'9' || curchar&lt;'0') 
+		if (curchar&gt;'9' || curchar&lt;'0')
 			endansi();
 		break;
 	case 5:
-		if(curchar==7) endansi(); /* FIXME: Window Title*/
+		if (curchar==7) endansi(); /* FIXME: Window Title*/
 		break;
 	default:
 		endansi();
 		break;
-    }
+	}
 	return(0);
 }
 
 void AddChar(char *_toadd)
 {
-    char *toadd;
-    char curchar;
+	char *toadd;
+	char curchar;
 
-    for(toadd=_toadd;toadd[0];toadd++) 
-	{
+	for (toadd=_toadd;toadd[0];toadd++) {
 		curchar=toadd[0];
-	/*	printf(&quot;%.3d (&quot;, curchar);*/
-		if(isansi) 
-			parseansi(curchar); 
-		else
-		{
-			switch(curchar) 
-			{
+		/*	printf(&quot;%.3d (&quot;, curchar);*/
+		if (isansi)
+			parseansi(curchar);
+		else {
+			switch (curchar) {
 			case 7:
-			    printf(&quot;&lt;BEEP&gt;\n&quot;);
-			    break;
+				printf(&quot;&lt;BEEP&gt;\n&quot;);
+				break;
 			case 8:
-			    printf(&quot;&lt;BS&gt;\n&quot;);
-			    backspace();
-			    break;
+				printf(&quot;&lt;BS&gt;\n&quot;);
+				backspace();
+				break;
 			case 27:
-			     /*  ANSI */
-			    printf(&quot;&lt;ESC&gt;[ANSI] &quot;);
-			    isansi=1;
-			    break;
+				/*  ANSI */
+				printf(&quot;&lt;ESC&gt;[ANSI] &quot;);
+				isansi=1;
+				break;
 			case 10:
-			    printf(&quot;&lt;LF&gt;\n&quot;);/* get onto the next line */
-			    line_is_full();
-			    break;
+				printf(&quot;&lt;LF&gt;\n&quot;);/* get onto the next line */
+				line_is_full();
+				break;
 			case 13:
-			    printf(&quot;&lt;CR&gt;\n&quot;);/* carriage return, get back */
-				if (cx==MAX_CHARS-1) 
+				printf(&quot;&lt;CR&gt;\n&quot;);/* carriage return, get back */
+				if (cx==MAX_CHARS-1)
 					line_is_full();
 				cx=0;
-			    break;
+				break;
 			default:
-				if ((curchar&gt;=32) &amp;&amp; (curchar&lt;127))
-				{
-			/*	    printf(&quot;%c&quot;, curchar);*/
-				    add_char_append(curchar);
+				if ((curchar&gt;=32) &amp;&amp; (curchar&lt;127)) {
+					/*	    printf(&quot;%c&quot;, curchar);*/
+					add_char_append(curchar);
 				}
-			    break;
-		    }
-/*	printf(&quot;)\n&quot;);*/
+				break;
+			}
+			/*	printf(&quot;)\n&quot;);*/
 		}
-    }
-    gotnewdata=1;
+	}
+	gotnewdata=1;
 }
 void init_line()
 {
-    int i;
-    for(i=0;i&lt;MAX_LINES;i++){
+	int i;
+	for (i=0;i&lt;MAX_LINES;i++) {
 		clear_line(i);
-    }
+	}
 }
 void term_addstring(char *toprint)
 {
-    char *ns;
-    for(ns=toprint;ns[0];ns++)
-	{
+	char *ns;
+	for (ns=toprint;ns[0];ns++) {
 		term_addchar(ns[0]);
-    }  /*  better method */
+	}  /*  better method */
 }

Modified: trunk/example/filebrowser.c
===================================================================
--- trunk/example/filebrowser.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/filebrowser.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * filebrowser.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -32,7 +32,9 @@
 #include &lt;unistd.h&gt;	 /*  chdir() */
 #include &lt;math.h&gt;	 /*  sin(),cos() */
 #include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+static struct timespec t= {
+	0,100*1000*1000
+}; /* 100 mili seconds */
 
 #define T_DUNO		0
 #define T_LOCALDIR	1
@@ -61,74 +63,82 @@
 	char *nstr;
 	float alpha,al,radius,f;
 	char ndir[M_DIR+1];
-	if (n_item)
-	{
+	if (n_item) {
 		printf(&quot;freeing %d old items\n&quot;,n_item);
-		for (i=0;i&lt;n_item;i++)
-		{
+		for (i=0;i&lt;n_item;i++) {
 			printf(&quot;deleting %d and %d\n&quot;,item[i].icon_oid,	item[i].descr_oid);
 			s3d_del_object(item[i].descr_oid);
 			s3d_del_object(item[i].icon_oid);
 			s3d_del_object(item[i].pie_oid);
 		}
 		free(item);
-		
+
 	}
-    n = i = scandir(dir, &amp;namelist, 0, alphasort);
-    if (n &lt; 0)
-	{
-        perror(&quot;scandir&quot;);
+	n = i = scandir(dir, &amp;namelist, 0, alphasort);
+	if (n &lt; 0) {
+		perror(&quot;scandir&quot;);
 		return(-1);
-	}
-    else {
+	} else {
 		item=malloc(sizeof(struct t_item)*i);
 		n_item=i;
-        while(n--) {
+		while (n--) {
 			item[n].type=T_DUNO;
 			nstr=namelist[n]-&gt;d_name;
 			strncpy(item[n].name,nstr,M_NAME);
- 		    if ((0==strncmp(nstr,&quot;.&quot;,1)) &amp;&amp; (strlen(nstr)==1))
+			if ((0==strncmp(nstr,&quot;.&quot;,1)) &amp;&amp; (strlen(nstr)==1))
 				item[n].type=T_LOCALDIR;
 			else if (0==strncmp(nstr,&quot;..&quot;,strlen(nstr)&lt;2?strlen(nstr):2))
-			   item[n].type=T_BACKDIR;
+				item[n].type=T_BACKDIR;
 			else {
 				ext=strrchr(nstr,'.');
-			    strncpy(ndir,dir,M_DIR);
+				strncpy(ndir,dir,M_DIR);
 				ndir[M_DIR]=0;		/* just in case */
-			    strncat(ndir,&quot;/&quot;,M_DIR-strlen(ndir));
-		    	strncat(ndir,namelist[n]-&gt;d_name,M_DIR-strlen(ndir));
-/* 				printf(&quot;displaying %s\n&quot;,ndir); */
-			    if ((namelist[n]-&gt;d_type==DT_DIR) ||
-					((namelist[n]-&gt;d_type==DT_UNKNOWN) &amp;&amp; (opendir(ndir)!=NULL)))
+				strncat(ndir,&quot;/&quot;,M_DIR-strlen(ndir));
+				strncat(ndir,namelist[n]-&gt;d_name,M_DIR-strlen(ndir));
+				/* 				printf(&quot;displaying %s\n&quot;,ndir); */
+				if ((namelist[n]-&gt;d_type==DT_DIR) ||
+				                ((namelist[n]-&gt;d_type==DT_UNKNOWN) &amp;&amp; (opendir(ndir)!=NULL)))
 					item[n].type=T_FOLDER;
-				else 
-				{
-				   if (ext!=NULL)
-				   {
-					   if (0==strncmp(ext,&quot;.3ds&quot;,strlen(ext)&lt;4?strlen(ext):4))
-							   item[n].type=T_GEOMETRY;
-					   else if (0==strncmp(ext,&quot;.mp3&quot;,strlen(ext)&lt;4?strlen(ext):4))
-							   item[n].type=T_MUSIC;
-					   else if (0==strncmp(ext,&quot;.mpg&quot;,strlen(ext)&lt;4?strlen(ext):4))
-							   item[n].type=T_MOVIE;
+				else {
+					if (ext!=NULL) {
+						if (0==strncmp(ext,&quot;.3ds&quot;,strlen(ext)&lt;4?strlen(ext):4))
+							item[n].type=T_GEOMETRY;
+						else if (0==strncmp(ext,&quot;.mp3&quot;,strlen(ext)&lt;4?strlen(ext):4))
+							item[n].type=T_MUSIC;
+						else if (0==strncmp(ext,&quot;.mpg&quot;,strlen(ext)&lt;4?strlen(ext):4))
+							item[n].type=T_MOVIE;
 
-				   }
+					}
 				}
 			}
-			switch (item[n].type)
-			{
-				case T_LOCALDIR:   	item[n].icon_oid=s3d_clone(dot);break;
-				case T_BACKDIR:   	item[n].icon_oid=s3d_clone(dotdot);break;
-				case T_FOLDER:   	item[n].icon_oid=s3d_clone(folder);
-									break;
-				case T_GEOMETRY:   	item[n].icon_oid=s3d_clone(geometry);break;
-				case T_MUSIC:	   	item[n].icon_oid=s3d_clone(mp3);break;
-				case T_MOVIE:		item[n].icon_oid=s3d_clone(movie);break;
-				default:   			printf(&quot;don't know type, defaulting to duno %d...\n&quot;,duno);
-									item[n].icon_oid=s3d_clone(duno);break;
+			switch (item[n].type) {
+			case T_LOCALDIR:
+				item[n].icon_oid=s3d_clone(dot);
+				break;
+			case T_BACKDIR:
+				item[n].icon_oid=s3d_clone(dotdot);
+				break;
+			case T_FOLDER:
+				item[n].icon_oid=s3d_clone(folder);
+				break;
+			case T_GEOMETRY:
+				item[n].icon_oid=s3d_clone(geometry);
+				break;
+			case T_MUSIC:
+				item[n].icon_oid=s3d_clone(mp3);
+				break;
+			case T_MOVIE:
+				item[n].icon_oid=s3d_clone(movie);
+				break;
+			default:
+				printf(&quot;don't know type, defaulting to duno %d...\n&quot;,duno);
+				item[n].icon_oid=s3d_clone(duno);
+				break;
 			}
 
-			px=posx;py=posy;pz=posz;
+			px=posx;
+			py=posy;
+			pz=posz;
 			alpha=((360.0*n)/((float)i));
 			radius=((n_item*10)/(M_PI*4));
 			if (n_item&lt;5)
@@ -142,39 +152,46 @@
 			item[n].pie_oid=s3d_new_object();
 			s3d_push_vertex(item[n].pie_oid,0,-2,0);
 			al=((360.0*(n-0.5))/((float)i));
-			s3d_push_vertex(item[n].pie_oid,		
-						posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
+			s3d_push_vertex(item[n].pie_oid,
+			                posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
 			al=((360.0*(n+0.5))/((float)i));
-			s3d_push_vertex(item[n].pie_oid,		
-						posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
-			
+			s3d_push_vertex(item[n].pie_oid,
+			                posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
+
 			f=1.0-0.05*(n%2);
-			switch (item[n].type)
-			{
-				case T_LOCALDIR:s3d_push_material(item[n].pie_oid,		0,f,0,			0.5,0.5,0.5,		f,f,f);		break;
-				case T_BACKDIR:	s3d_push_material(item[n].pie_oid,		0,f/2,0,		0.5,0.5,0.5,		f,f,f);		break;
-				case T_FOLDER:	s3d_push_material(item[n].pie_oid,		f,f,0,			0.5,0.5,0.0,		f,f,1);		break;
-				default:		s3d_push_material(item[n].pie_oid,		f,f,f,			0.5,0.5,0.5,		f,f,f);		break;
+			switch (item[n].type) {
+			case T_LOCALDIR:
+				s3d_push_material(item[n].pie_oid,		0,f,0,			0.5,0.5,0.5,		f,f,f);
+				break;
+			case T_BACKDIR:
+				s3d_push_material(item[n].pie_oid,		0,f/2,0,		0.5,0.5,0.5,		f,f,f);
+				break;
+			case T_FOLDER:
+				s3d_push_material(item[n].pie_oid,		f,f,0,			0.5,0.5,0.0,		f,f,1);
+				break;
+			default:
+				s3d_push_material(item[n].pie_oid,		f,f,f,			0.5,0.5,0.5,		f,f,f);
+				break;
 			}
 			s3d_push_polygon(item[n].pie_oid,	0,2,1,	0);
 
 			s3d_push_vertex(item[n].pie_oid,pz,-2,0);
 			s3d_translate(item[n].icon_oid,px,py,pz);
 			s3d_rotate(item[n].icon_oid,0,alpha,0);
-		    s3d_flags_on(item[n].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		    s3d_flags_on(item[n].pie_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(item[n].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(item[n].pie_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			item[n].descr_oid=s3d_draw_string(nstr,NULL);
 			s3d_link(item[n].descr_oid,item[n].icon_oid);
-			s3d_translate(item[n].descr_oid,-1,-2,0); 
-/* 			r=s3d_get_radius(p); */
-/* 			s3d_scale(p,1.0/r,1.0/r,1.0/r); */
-		    s3d_flags_on(item[n].descr_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-            printf(&quot;%s [%d]\n&quot;, nstr,namelist[n]-&gt;d_type);
+			s3d_translate(item[n].descr_oid,-1,-2,0);
+			/* 			r=s3d_get_radius(p); */
+			/* 			s3d_scale(p,1.0/r,1.0/r,1.0/r); */
+			s3d_flags_on(item[n].descr_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			printf(&quot;%s [%d]\n&quot;, nstr,namelist[n]-&gt;d_type);
 			printf(&quot;string %d linked to %d\n&quot;,item[n].descr_oid,item[n].icon_oid);
-        	free(namelist[n]);
-        }
+			free(namelist[n]);
+		}
 		free(namelist);
-   	}
+	}
 	return(0);
 }
 
@@ -184,35 +201,32 @@
 	char execstr[256];
 	oid=(int)*((unsigned long *)evt-&gt;buf);
 	printf(&quot;!!!!!!!!! clicked object %d\n&quot;,oid);
-	for (i=0;i&lt;n_item;i++)
-	{
+	for (i=0;i&lt;n_item;i++) {
 		if (((oid==item[i].icon_oid) || (oid==item[i].descr_oid)) ||
-			(oid==item[i].pie_oid) )
-		{
-			switch (item[i].type)
-			{
-				case T_BACKDIR:
-				case T_FOLDER:
-				case T_LOCALDIR:
-						printf(&quot;going into %s\n&quot;,item[i].name);
-						chdir(item[i].name);
-						display_dir(&quot;.&quot;,0,0,0,0);
-						return(0);
-						break;
-				case T_GEOMETRY:
-						printf(&quot;loading geometry %s\n&quot;,item[i].name);
-						snprintf(execstr,256,&quot;modelloader \&quot;%s\&quot;&amp;\n&quot;,item[i].name);
-						system(execstr);
-						return(0);
-						break;
-				case T_MOVIE:
-						printf(&quot;playing %s\n&quot;,item[i].name);
-						snprintf(execstr,256,&quot;mplayer -vo s3d \&quot;%s\&quot;&amp;\n&quot;,item[i].name);
-						system(execstr);
-						return(0);
-						break;
+		                (oid==item[i].pie_oid) ) {
+			switch (item[i].type) {
+			case T_BACKDIR:
+			case T_FOLDER:
+			case T_LOCALDIR:
+				printf(&quot;going into %s\n&quot;,item[i].name);
+				chdir(item[i].name);
+				display_dir(&quot;.&quot;,0,0,0,0);
+				return(0);
+				break;
+			case T_GEOMETRY:
+				printf(&quot;loading geometry %s\n&quot;,item[i].name);
+				snprintf(execstr,256,&quot;modelloader \&quot;%s\&quot;&amp;\n&quot;,item[i].name);
+				system(execstr);
+				return(0);
+				break;
+			case T_MOVIE:
+				printf(&quot;playing %s\n&quot;,item[i].name);
+				snprintf(execstr,256,&quot;mplayer -vo s3d \&quot;%s\&quot;&amp;\n&quot;,item[i].name);
+				system(execstr);
+				return(0);
+				break;
 
-						
+
 			}
 		}
 	}
@@ -220,15 +234,14 @@
 }
 void mainloop()
 {
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 }
 int main (int argc, char **argv)
 {
 	int i;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;filebrowser&quot;))	
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;filebrowser&quot;)) {
 		i=0;
-		 /*  load the object files */
+		/*  load the object files */
 		folder=s3d_import_model_file(&quot;objs/folder.3ds&quot;);
 		geometry=s3d_import_model_file(&quot;objs/geometry.3ds&quot;);
 		mp3=s3d_import_model_file(&quot;objs/notes.3ds&quot;);

Modified: trunk/example/hudtest.c
===================================================================
--- trunk/example/hudtest.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/hudtest.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * hudtest.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -33,8 +33,7 @@
 int main(int argc, char **argv)
 {
 	int o,m;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;hud-test&quot;))
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;hud-test&quot;)) {
 		if (s3d_select_font(&quot;vera&quot;))
 			printf(&quot;font not found\n&quot;);
 		o=s3d_draw_string(&quot;hud-test&quot;,NULL);

Modified: trunk/example/katze.c
===================================================================
--- trunk/example/katze.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/katze.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * katze.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,7 +27,9 @@
 #include &lt;s3d.h&gt;
 #include &lt;math.h&gt;	/* sin() */
 #include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
 
 int a;
 int rot_point,body,legfr,legbr,legfl,legbl,tail;
@@ -44,13 +46,12 @@
 
 	s3d_rotate(tail,0,30,110+pos);
 	s3d_rotate(rot_point,0,-a,0);
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 }
 int main(int argc, char **argv)
 {
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;running cat&quot;))
-	{
-			
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;running cat&quot;)) {
+
 		rot_point=s3d_new_object();
 		body=s3d_import_model_file(&quot;objs/katze_body.3ds&quot;);
 		legfr=s3d_import_model_file(&quot;objs/katze_leg.3ds&quot;);
@@ -70,14 +71,14 @@
 		s3d_link(legbl,body);
 		s3d_link(tail,body);
 		s3d_link(body,rot_point);
-/*		s3d_link(oid_foot,oid_head);
- *		s3d_link(oid_middle,oid_head);
- *		s3d_translate(oid_head,0,4,0);
-		
- *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
- *		s3d_translate(oid_foot,0,-3.5,0); */
-		
+		/*		s3d_link(oid_foot,oid_head);
+		 *		s3d_link(oid_middle,oid_head);
+		 *		s3d_translate(oid_head,0,4,0);
 
+		 *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
+		 *		s3d_translate(oid_foot,0,-3.5,0); */
+
+
 		s3d_flags_on(body,S3D_OF_VISIBLE);
 		s3d_flags_on(legfr,S3D_OF_VISIBLE);
 		s3d_flags_on(legfl,S3D_OF_VISIBLE);

Modified: trunk/example/linetest.c
===================================================================
--- trunk/example/linetest.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/linetest.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * linetest.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -36,44 +36,40 @@
 void mainloop()
 {
 	i=(i+1)%2;
-	if (i)
-	{
+	if (i) {
 		s3d_pep_vertex(o,1,-2,0);
 		s3d_pep_line(o,0,2,3);
-	}
-	else
-	{
+	} else {
 		s3d_pep_vertex(o,1,-1,0);
 		s3d_pep_line(o,0,1,0);
 
 	}
-/* 	printf(&quot;now it's %s\n&quot;,time_str); */
+	/* 	printf(&quot;now it's %s\n&quot;,time_str); */
 	sleep(1);
 
 }
 int main (int argc, char **argv)
 {
 	i=0;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;linetest&quot;))	
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;linetest&quot;)) {
 		o=s3d_new_object();
-		
+
 		s3d_push_material(o,
-						1,0,0,
-						1,0,0,
-						1,0,0);
+		                  1,0,0,
+		                  1,0,0,
+		                  1,0,0);
 		s3d_push_material(o,
-						0,1,0,
-						0,1,0,
-						0,1,0);
+		                  0,1,0,
+		                  0,1,0,
+		                  0,1,0);
 		s3d_push_material(o,
-						0,1,0,
-						0,1,0,
-						0,1,0);
+		                  0,1,0,
+		                  0,1,0,
+		                  0,1,0);
 		s3d_push_material(o,
-						1,1,0,
-						1,1,0,
-						1,1,0);
+		                  1,1,0,
+		                  1,1,0,
+		                  1,1,0);
 		s3d_push_vertex(o,-1,-1,0);
 		s3d_push_vertex(o,-1,1,0);
 		s3d_push_vertex(o,1,1,0);
@@ -85,7 +81,7 @@
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
 		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
 		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/example/modelloader.c
===================================================================
--- trunk/example/modelloader.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/modelloader.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * modelloader.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,34 +27,33 @@
 #include &lt;s3d.h&gt;
 #include &lt;stdio.h&gt;  /* NULL */
 #include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+static struct timespec t= {
+	0,100*1000*1000
+}; /* 100 mili seconds */
 int i,oid;
 void mainloop()
 {
 	s3d_rotate(oid,0,i,0);
 	i=(i+1)%360;
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 }
 int object_click(struct s3d_evt *evt)
 {
 	s3d_quit();
 	return(0);
 }
-	
+
 int main (int argc, char **argv)
 {
-	if (argc&lt;2)
-	{
+	if (argc&lt;2) {
 		printf(&quot;usage: %s [somefile.3ds]\n&quot;,argv[0]);
 		return(-1);
 	}
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;modelloader&quot;))	
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;modelloader&quot;)) {
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
 		i=0;
-	    if (-1!=(oid=s3d_import_model_file(argv[1])))
-		{
-		    s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		if (-1!=(oid=s3d_import_model_file(argv[1]))) {
+			s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			s3d_mainloop(mainloop);
 		} else {
 			printf(&quot;file not found ... \n&quot;);

Modified: trunk/example/nichtsnutz.c
===================================================================
--- trunk/example/nichtsnutz.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/nichtsnutz.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * nichtsnutz.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -28,28 +28,30 @@
 #include &lt;s3d_keysym.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;math.h&gt;
-#include &lt;time.h&gt;	
+#include &lt;time.h&gt;
 
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
 
 int object,foll;
 float al, r, rc ,alpha=0.0, Asp, Bottom, Left, angle;
 float CamPosition[2][3],
-	  TmpMove[3],
-	  Tmp[3],
-	  TmpCam[2][3],
-	  RotCam[2][3],
-	  CatPos[3];
+TmpMove[3],
+Tmp[3],
+TmpCam[2][3],
+RotCam[2][3],
+CatPos[3];
 
 float length;
 
 void mainloop()
 {
-	
+
 	al=(alpha*M_PI/180);
-    r = 5.0;
+	r = 5.0;
 	rc = 12.0;
-	
+
 	CatPos[0] = sin(al)*r;
 	CatPos[1] = 0;
 	CatPos[2] = cos(al)*r;
@@ -62,18 +64,17 @@
 	s3d_rotate(object, 0, alpha, 0);
 	alpha = alpha+0.1;
 	if (alpha&gt;360.0) alpha=0.0;
-	
+
 	length = s3d_vector_length(CatPos);
 
 
 	RotCam[0][0] = ( CatPos[0] * 12.0 ) / length;
 	RotCam[0][1] = ( CatPos[1] * 12.0 ) / length;
 	RotCam[0][2] = ( CatPos[2] * 12.0 ) / length;
-	
-	
-	if( foll )
-	{
-		
+
+
+	if ( foll ) {
+
 		CamPosition[0][0] = ((CamPosition[0][0]*4 + RotCam[0][0])/5);
 		CamPosition[0][1] = ((CamPosition[0][1]*4 + RotCam[0][1])/5);
 		CamPosition[0][2] = ((CamPosition[0][2]*4 + RotCam[0][2])/5);
@@ -86,27 +87,26 @@
 		Tmp[0] = CamPosition[0][0] - CatPos[0];
 		Tmp[1] = 0.0;
 		Tmp[2] = CamPosition[0][2] - CatPos[2];
-		
+
 		angle = s3d_vector_angle(Tmp,TmpMove);
 		angle = (CatPos[0] &gt; 0)?(180-(180 / M_PI * angle)):(180+(180 / M_PI * angle));
 		printf(&quot;%f %f\n&quot;,angle,al);
-	
+
 		CamPosition[1][1] = (CamPosition[1][1]*4 + angle)/5;
 		s3d_rotate(0,CamPosition[1][0], CamPosition[1][1], CamPosition[1][2]);
 	}
-	
 
-	
-	nanosleep(&amp;t,NULL); 
+
+
+	nanosleep(&amp;t,NULL);
 }
 
 int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
-	
-	if (inf-&gt;object==0)
-	{
+
+	if (inf-&gt;object==0) {
 		CamPosition[0][0] = inf-&gt;trans_x;
 		CamPosition[0][1] = inf-&gt;trans_y;
 		CamPosition[0][2] = inf-&gt;trans_z;
@@ -115,8 +115,7 @@
 		CamPosition[1][2] = inf-&gt;rot_z;
 
 		Asp=inf-&gt;scale;
-		if (Asp&gt;1.0) /* wide screen */
-		{
+		if (Asp&gt;1.0) { /* wide screen */
 			Bottom=-1.0;
 			Left=-Asp;
 		} else {  /* high screen */
@@ -133,20 +132,18 @@
 {
 	int key;
 	key=*((unsigned short *)event-&gt;buf);
-	switch(key)
-	{
-		case 'f':
-				foll = foll ? 0 : 1;
-				if( foll )
-				{
-					TmpCam[0][0] = CamPosition[0][0];
-					TmpCam[0][1] = CamPosition[0][1];
-					TmpCam[0][2] = CamPosition[0][2];
-					TmpCam[1][0] = CamPosition[1][0];
-					TmpCam[1][1] = CamPosition[1][1];
-					TmpCam[1][2] = CamPosition[1][2];
-				}
-				break;
+	switch (key) {
+	case 'f':
+		foll = foll ? 0 : 1;
+		if ( foll ) {
+			TmpCam[0][0] = CamPosition[0][0];
+			TmpCam[0][1] = CamPosition[0][1];
+			TmpCam[0][2] = CamPosition[0][2];
+			TmpCam[1][0] = CamPosition[1][0];
+			TmpCam[1][1] = CamPosition[1][1];
+			TmpCam[1][2] = CamPosition[1][2];
+		}
+		break;
 	}
 	return(0);
 }
@@ -154,12 +151,11 @@
 
 int main(int argc, char **argv)
 {
-	
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;running cat&quot;))
-	{
+
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;running cat&quot;)) {
 		s3d_set_callback(S3D_EVENT_KEY,keypress);
 		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-		
+
 		object = s3d_import_model_file(&quot;objs/katze_body.3ds&quot;);
 		s3d_flags_on(object, S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);

Modified: trunk/example/ptrtest.c
===================================================================
--- trunk/example/ptrtest.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/ptrtest.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * ptrtest.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -33,7 +33,9 @@
 float asp=1.0;
 float len=1.0;
 int alpha=0;
-static struct timespec t={0,10*1000*1000}; /* 100 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 100 mili seconds */
 int stop(struct s3d_evt *evt)
 {
 	s3d_quit();
@@ -48,20 +50,17 @@
 	a=(((float)alpha)*M_PI/180);
 	s3d_translate(0,sin(a)*30,0,30+cos(a)*30);
 	s3d_rotate(0,sin(a)*30,alpha,0);
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 }
 int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
-	if (inf-&gt;object==0)
-	{
-		if (asp!=inf-&gt;scale)
-		{
+	if (inf-&gt;object==0) {
+		if (asp!=inf-&gt;scale) {
 			asp=inf-&gt;scale;
 			printf(&quot;screen aspect: %f\n&quot;,asp);
-			if (asp&gt;1.0) /* wide screen */
-			{
+			if (asp&gt;1.0) { /* wide screen */
 				bottom=-1.0;
 				left=-asp;
 			} else {  /* high screen */
@@ -70,8 +69,7 @@
 			}
 		}
 	}
-	if (inf-&gt;object==1)
-	{ /* of course, a link s3d_link(o,1 would be much easier ... */
+	if (inf-&gt;object==1) { /* of course, a link s3d_link(o,1 would be much easier ... */
 		s3d_translate(o,(inf-&gt;trans_x)*2.0,(inf-&gt;trans_y)*2.0,-2);
 	}
 	return(0);
@@ -88,15 +86,14 @@
 	s3d_translate(o,0,0,-2);
 	s3d_scale(o,0.2);
 	s3d_link(o,0);			/* link to cam */
-/*	s3d_link(o,1);*/
+	/*	s3d_link(o,1);*/
 	s3d_flags_on(o,S3D_OF_VISIBLE);
 	return(0);
 }
 int main (int argc, char **argv)
 {
 	i=0;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;ptr and cam test&quot;))	
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;ptr and cam test&quot;)) {
 		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
 		s3d_set_callback(S3D_EVENT_MBUTTON,mbutton_press);
 		s3d_set_callback(S3D_EVENT_QUIT,stop);
@@ -105,11 +102,11 @@
 		o=s3d_draw_string(&quot;hello&quot;,&amp;len);
 		s3d_translate(o,0,0,-2);
 		s3d_link(o,0);			/* link to cam */
-/*		s3d_link(o,1);*/
+		/*		s3d_link(o,1);*/
 		s3d_scale(o,0.2);
 		s3d_flags_on(o,S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/example/radius_test.c
===================================================================
--- trunk/example/radius_test.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/radius_test.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * radius_test.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -24,7 +24,9 @@
 #include &lt;s3d.h&gt;
 #include &lt;stdio.h&gt;  /*  NULL */
 #include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
 
 #include &lt;math.h&gt;	/* sin(), cos() */
 int item1, item2, item3;
@@ -35,40 +37,39 @@
 	f=sin((M_PI*(i%360))/180.0);
 	g=cos((M_PI*(i%360))/180.0);
 	h=sin((M_PI*((3*i)%360))/180.0);
-	
+
 	s3d_translate(item1,f*10,h*2, g*5);
 	s3d_rotate(item1,0,i%360,0);
-/*	s3d_scale(item1,h+3,h+3,h+3);*/
+	/*	s3d_scale(item1,h+3,h+3,h+3);*/
 
-/*	s3d_translate(item2,f*10,0, g*5);*/
+	/*	s3d_translate(item2,f*10,0, g*5);*/
 	s3d_translate(item2,0,0,10);
-/*	s3d_rotate(item2,i%360,0,-i%360);
-	s3d_scale(item2,2*f+5,2*f+5,2*f+5);*/
+	/*	s3d_rotate(item2,i%360,0,-i%360);
+		s3d_scale(item2,2*f+5,2*f+5,2*f+5);*/
 
 	s3d_translate(item3,0,0,10);
-/*	s3d_rotate(item3,((8*i)%360),0,-((8*i)%360));
-	s3d_scale(item3,2*f+5,2*f+5,2*f+5);*/
+	/*	s3d_rotate(item3,((8*i)%360),0,-((8*i)%360));
+		s3d_scale(item3,2*f+5,2*f+5,2*f+5);*/
 
-	
 
+
 	i++;
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 }
 int main (int argc, char **argv)
 {
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;radius test&quot;))	
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;radius test&quot;)) {
 		item1=s3d_import_model_file(&quot;objs/cubeyholes.3ds&quot;);
 		item2=s3d_import_model_file(&quot;objs/folder.3ds&quot;);
 		s3d_select_font(&quot;vera&quot;);
 		item3=s3d_draw_string(&quot;radius test&quot;,NULL);
 		s3d_link(item2,item1);
 		s3d_link(item3,item2);
-	    s3d_flags_on(item1,S3D_OF_VISIBLE);
-	    s3d_flags_on(item2,S3D_OF_VISIBLE);
-	    s3d_flags_on(item3,S3D_OF_VISIBLE);
+		s3d_flags_on(item1,S3D_OF_VISIBLE);
+		s3d_flags_on(item2,S3D_OF_VISIBLE);
+		s3d_flags_on(item3,S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
-			 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/example/s3dclock.c
===================================================================
--- trunk/example/s3dclock.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/s3dclock.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * s3dclock.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -26,7 +26,9 @@
 #include &lt;stdio.h&gt;  /*  NULL, sprintf() */
 #include &lt;time.h&gt;	 /*  nanosleep(), struct tm, time_t...  */
 #include &lt;string.h&gt;  /*  strlen() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+static struct timespec t= {
+	0,100*1000*1000
+}; /* 100 mili seconds */
 int big_p,lil_p,bg,sec_p;
 int str_oid=-1, o_str_oid;
 struct tm *mytime;
@@ -42,10 +44,9 @@
 {
 	onow=now;
 	now=time(NULL);
-	if (now!=onow)
-	{
+	if (now!=onow) {
 		o_str_oid=str_oid;
-		mytime=localtime(&amp;now);	
+		mytime=localtime(&amp;now);
 		s3d_rotate(lil_p,0,0,-((mytime-&gt;tm_hour%12)/12.0)*360.0);
 		s3d_rotate(big_p,0,0,-(mytime-&gt;tm_min/60.0)*360.0);
 		s3d_rotate(sec_p,0,0,-(mytime-&gt;tm_sec/60.0)*360.0);
@@ -57,14 +58,13 @@
 		if (str_oid!=-1)
 			s3d_del_object(o_str_oid);
 	}
-/* 	printf(&quot;now it's %s\n&quot;,time_str); */
-	nanosleep(&amp;t,NULL); 
+	/* 	printf(&quot;now it's %s\n&quot;,time_str); */
+	nanosleep(&amp;t,NULL);
 
 }
 int main (int argc, char **argv)
 {
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;clock&quot;))	
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;clock&quot;)) {
 		lil_p=s3d_import_model_file(&quot;objs/lil_p.3ds&quot;);
 		big_p=s3d_import_model_file(&quot;objs/big_p.3ds&quot;);
 		sec_p=s3d_import_model_file(&quot;objs/sec_p.3ds&quot;);
@@ -79,7 +79,7 @@
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
 		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
 		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/example/snowman.c
===================================================================
--- trunk/example/snowman.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/snowman.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * snowman.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -24,7 +24,9 @@
 #include &lt;s3d.h&gt;
 #include &lt;math.h&gt;	/* sin() */
 #include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
 
 int a;
 int oid_head;
@@ -43,24 +45,23 @@
 	s3d_translate(oid_head,		0,1.5 +2.00*pos,0);
 	s3d_translate(oid_middle,	0,0   +1.25*pos,0);
 	s3d_translate(oid_foot,		0,-2  +1.00*pos,0);
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 }
 int main(int argc, char **argv)
 {
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;snowman&quot;))
-	{
-			
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;snowman&quot;)) {
+
 		oid_head=s3d_import_model_file(&quot;objs/snow_head.3ds&quot;);
 		oid_middle=s3d_import_model_file(&quot;objs/snow_body.3ds&quot;);
 		oid_foot=s3d_import_model_file(&quot;objs/snow_foot.3ds&quot;);
 
-/*		s3d_link(oid_foot,oid_head);
- *		s3d_link(oid_middle,oid_head);
- *		s3d_translate(oid_head,0,4,0);
-		
- *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
- *		s3d_translate(oid_foot,0,-3.5,0); */
-		
+		/*		s3d_link(oid_foot,oid_head);
+		 *		s3d_link(oid_middle,oid_head);
+		 *		s3d_translate(oid_head,0,4,0);
+
+		 *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
+		 *		s3d_translate(oid_foot,0,-3.5,0); */
+
 		s3d_scale(oid_middle,1.25);
 		s3d_scale(oid_foot,1.5);
 

Modified: trunk/example/strtest.c
===================================================================
--- trunk/example/strtest.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/strtest.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * strtest.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -34,7 +34,7 @@
 
 void mainloop()
 {
-/* 	printf(&quot;now it's %s\n&quot;,time_str); */
+	/* 	printf(&quot;now it's %s\n&quot;,time_str); */
 	sleep(1);
 
 }
@@ -42,20 +42,19 @@
 {
 	char c[256];
 	int i;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;strtest&quot;))	
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;strtest&quot;)) {
 		s3d_select_font(&quot;vera&quot;);
-/*		o=s3d_draw_string(&quot;The lazy fox is bored enough to jump over everything it sees. weird, isn't it?!&quot;,NULL);  */
+		/*		o=s3d_draw_string(&quot;The lazy fox is bored enough to jump over everything it sees. weird, isn't it?!&quot;,NULL);  */
 		for (i=0;i&lt;256;i++)
 			c[255-i]=i;
 		o=s3d_draw_string(c,NULL);
-/*		o=s3d_draw_string(&quot;A&quot;,NULL);*/
+		/*		o=s3d_draw_string(&quot;A&quot;,NULL);*/
 		s3d_flags_on(o,S3D_OF_VISIBLE);
 
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
 		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
 		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/example/texturetest.c
===================================================================
--- trunk/example/texturetest.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/texturetest.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * texturetest.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -26,14 +26,16 @@
 #include &lt;stdio.h&gt;  /*  NULL */
 #include &lt;stdlib.h&gt;  /* malloc(),free() */
 #include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
 
 int i,oid;
 void mainloop()
 {
 	i=(i+1)%360;
 	s3d_rotate(oid,0,i,0);
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 }
 #define MAXX	300
 #define MAXY	300
@@ -41,9 +43,8 @@
 {
 	unsigned int x,y;
 	unsigned char *data;
-						
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;texturetest&quot;))	
-	{
+
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;texturetest&quot;)) {
 		data=malloc(MAXX*MAXY*4);
 		oid=s3d_new_object();
 		s3d_push_vertex(oid,-1,-1,0);
@@ -51,35 +52,34 @@
 		s3d_push_vertex(oid, 1, 1,0);
 		s3d_push_vertex(oid,-1, 1,0);
 		s3d_push_material_a(oid,
-						0.8,	0.0,	0.0	,1.0,
-						1.0,	1.0,	1.0	,1.0,
-						0.8,	0.0,	0.0	,1.0);
+		                    0.8,	0.0,	0.0	,1.0,
+		                    1.0,	1.0,	1.0	,1.0,
+		                    0.8,	0.0,	0.0	,1.0);
 		s3d_push_polygon(oid,0,1,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
-									   1.0,0.0,
-									   1.0,1.0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,0.0,
+		                          1.0,0.0,
+		                          1.0,1.0);
 		s3d_push_polygon(oid,0,2,3,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
-									   1.0,1.0,
-									   0.0,1.0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,0.0,
+		                          1.0,1.0,
+		                          0.0,1.0);
 		s3d_translate(oid,0,0,5);
 		for (y=0;y&lt;MAXY;y++)
-			for (x=0;x&lt;MAXX;x++)
-			{
+			for (x=0;x&lt;MAXX;x++) {
 				data[(y*MAXX+x)*4+0]=(char)((x*255)/MAXX);
 				data[(y*MAXX+x)*4+1]=((x*y)/(MAXX*MAXY));
 				data[(y*MAXX+x)*4+2]=((y*255)/MAXX);
 				data[(y*MAXX+x)*4+3]=255;
 			}
-		s3d_push_texture(oid,MAXX,MAXY);		
+		s3d_push_texture(oid,MAXX,MAXY);
 		s3d_load_texture(oid,0,0,0,MAXX,MAXY,data);
-					 /*  push data on texture 0 position (0,0) */
+		/*  push data on texture 0 position (0,0) */
 		free(data);
 		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
 		s3d_flags_on(oid,S3D_OF_VISIBLE);
 		i=0;
 		s3d_mainloop(mainloop);
-			 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/example/widgets.c
===================================================================
--- trunk/example/widgets.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/widgets.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * widgets.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -33,12 +33,14 @@
 
 s3dw_surface *surface;
 s3dw_input *input;
-static struct timespec t={0,33*1000*1000}; /* 33 mili seconds */
+static struct timespec t= {
+	0,33*1000*1000
+}; /* 33 mili seconds */
 void mainloop()
 {
 	/* keep this in your mainloop. this will do smooth animations for you ... */
 	s3dw_ani_mate();
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 }
 /* you should always put the s3dw-handler in your own event handler,
  * if you want s3dw to react on clicks or keys ... and i'm sure you
@@ -57,13 +59,12 @@
 	char string[8];
 	s3dw_surface *miniwin;
 	s3dw_button  *button;
-	
+
 	s3dw_handle_key(evt);
-	/* okay, that's a little bit insane ... ;) 
+	/* okay, that's a little bit insane ... ;)
 	 * we create some little windows with the actual key pressed. */
 
-	if (key-&gt;unicode!=0)
-	{
+	if (key-&gt;unicode!=0) {
 		miniwin=s3dw_surface_new(&quot;Key&quot;,6,6);
 		sprintf(string,&quot;%c&quot;,key-&gt;unicode);
 		s3dw_label_new(miniwin,string,1,2);
@@ -93,13 +94,13 @@
 
 	/* delete the old surface with it subwidgets */
 	s3dw_delete(S3DWIDGET(surface));
-	
+
 	/* and create a new one ... */
 	surface=s3dw_surface_new(&quot;Ah!&quot;,10,7);
-	
+
 	/* just cutting the string if it's too long */
 	if (strlen(age)&gt;8) age[8]=0;
-	
+
 	/* assemble the string ..*/
 	sprintf(string,&quot;I see, %s!!&quot;,age);
 
@@ -107,12 +108,12 @@
 	button=s3dw_button_new(surface,&quot;Great&quot;,4,4);
 	/* clicking on the button will exit ... */
 	button-&gt;onclick=done_button;
-	
+
 	/* of couse, show it */
 	s3dw_show(S3DWIDGET(surface));
 
 	/* we don't need it anymore. always free strings, don't leak around */
-	free(age); 
+	free(age);
 }
 void no_button(s3dw_widget *dummy)
 {
@@ -122,10 +123,10 @@
 	s3dw_label_new(surface,&quot;If you don't want to tell me ...&quot;,1,2);
 	button=s3dw_button_new(surface,&quot;Bye&quot;,4,4);
 	/* clicking on the button will exit ... */
-	
+
 	button-&gt;onclick=done_button;
 	/* of couse, show it */
-	
+
 	s3dw_show(S3DWIDGET(surface));
 }
 char *text=&quot;okay\nn2\n3\nfooobarfooobar ...\noh no\n its too loooong\n&quot;;
@@ -133,20 +134,19 @@
 {
 	s3dw_button *button;
 	s3dw_textbox *textbox;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;widgettest&quot;))
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;widgettest&quot;)) {
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,click);
 		s3d_set_callback(S3D_EVENT_KEY,key);
 		s3d_set_callback(S3D_EVENT_OBJ_INFO,s3dw_object_info);
 		/* this creates the &quot;window&quot; */
 		surface=s3dw_surface_new(&quot;Hello World&quot;,20,20);
-		
+
 		/* put a label (which is simply text) at position x=1, y=2 */
 		s3dw_label_new(surface,&quot;How old are you?&quot;,1,2);
 
 		/* put an input box right below. we grab the pointer because we want to focus it (need for reference) */
 		input=s3dw_input_new(surface,8,1,4);
-		
+
 		/* we want the input-field be focused on our widget */
 		s3dw_focus(S3DWIDGET(input));
 

Modified: trunk/example/wiresphere.c
===================================================================
--- trunk/example/wiresphere.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/wiresphere.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * wiresphere.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,7 +27,9 @@
 #include &lt;time.h&gt;	/* nanosleep()  */
 #include &lt;math.h&gt;	/* M_PI, cos(), sin() */
 #include &lt;stdlib.h&gt;	/* malloc(), free() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+static struct timespec t= {
+	0,100*1000*1000
+}; /* 100 mili seconds */
 int oid;
 int r;
 int wire_sphere(int slices, int stacks)
@@ -56,8 +58,7 @@
 	i=0;
 	for (x=0;x&lt;slices;x++) {
 		for (y=0;y&lt;stacks;y++) {
-			if ((y!=0) &amp;&amp; (y!=stacks)) /* no horizontal lines at the poles */
-			{
+			if ((y!=0) &amp;&amp; (y!=stacks)) { /* no horizontal lines at the poles */
 				l[i*3+0]=(x*(stacks+1))+y;
 				l[i*3+1]=(((x+1)%slices)*(stacks+1))+y;
 				l[i*3+2]=0;
@@ -86,9 +87,9 @@
 		}
 	}
 	o=s3d_new_object();
-	s3d_push_material(o,0,0,1, 
-						1,0,0, 
-						0,1,0);
+	s3d_push_material(o,0,0,1,
+	                  1,0,0,
+	                  0,1,0);
 	s3d_push_vertices(o,v,num_v);
 	s3d_push_lines(o,l,num_l);
 	s3d_load_line_normals(o,n,0,num_l);
@@ -106,20 +107,19 @@
 {
 	r=(r+1)%360;
 	s3d_rotate(oid,0,r,0);
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 
 }
 int main (int argc, char **argv)
 {
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;wiresphere&quot;))	
-	{
+	if (!s3d_init(&amp;argc,&amp;argv,&quot;wiresphere&quot;)) {
 		oid=wire_sphere(30,30);
 		s3d_scale(oid,10);
 		s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
 		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
 		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/libs3d/callback.c
===================================================================
--- trunk/libs3d/callback.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/callback.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -29,26 +29,26 @@
 /* i know it's ugly, but it's better to have ugly code somewhere than provoke
  * race conditions in the applications code */
 s3d_cb s3d_cb_list[MAX_CB]={
-			NULL,_s3d_ignore,_s3d_ignore,_s3d_ignore, _s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			_s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			_s3d_ignore,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,_s3d_ignore,_s3d_ignore,_s3d_ignore, _s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	_s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	_s3d_ignore,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
 
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
 
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
 
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL
-			};
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL
+};
 /* the ignore-handler ;) */
 static int _s3d_ignore(struct s3d_evt *S3DUNUSED(evt))
 {

Modified: trunk/libs3d/config.h
===================================================================
--- trunk/libs3d/config.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/config.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

Modified: trunk/libs3d/error.c
===================================================================
--- trunk/libs3d/error.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/error.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -29,41 +29,43 @@
 #include &lt;string.h&gt; 	 /*  sterror */
 /*  s3dprintf is only for internal use. */
 #ifdef DEBUG
-void s3dprintf(int relevance, const char *fmt, ...) {
+void s3dprintf(int relevance, const char *fmt, ...)
+{
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance &gt;= DEBUG )
-	{
+	if (relevance &gt;= DEBUG ) {
 		va_start(args,fmt);
 		vsnprintf((char *)&amp;dbm,DBM_MAX,fmt,args);
 		va_end(args);
-	
+
 		fprintf(stderr,&quot;s3dlib: %s\n&quot;,(char *)&amp;dbm);
 	}
 }
-void errdn(int relevance, char *func,int en) {
+void errdn(int relevance, char *func,int en)
+{
 	if (relevance &gt;= DEBUG )
-		 fprintf(stderr,&quot;s3dlib error: %s: (%d) %s\n&quot;,func,en, strerror(en));
+		fprintf(stderr,&quot;s3dlib error: %s: (%d) %s\n&quot;,func,en, strerror(en));
 }
 
 void errds(int relevance,char *func, const char *fmt, ...)
 {
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance &gt;= DEBUG )
-	{
+	if (relevance &gt;= DEBUG ) {
 		va_start(args,fmt);
 		vsnprintf((char *)&amp;dbm,DBM_MAX,fmt,args);
 		va_end(args);
-	
+
 		fprintf(stderr,&quot;s3dlib error: %s:%s\n&quot;,func,(char *)&amp;dbm);
 	}
 }
 #endif
-void errn(char *func,int en) {
+void errn(char *func,int en)
+{
 	fprintf(stderr,&quot;s3dlib error: %s: (%d) %s\n&quot;,func,en, strerror(en));
 }
-void errs(char *func, char *msg) {
+void errs(char *func, char *msg)
+{
 	fprintf(stderr,&quot;s3dlib error: %s: %s\n&quot;,func,msg);
 }
 

Modified: trunk/libs3d/event.c
===================================================================
--- trunk/libs3d/event.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/event.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,44 +35,37 @@
 	s3d_cb cb;
 
 	s3dprintf(VLOW,&quot;pushed event %d, cb_lock = %d&quot;,newevt-&gt;event, cb_lock);
-	 /*  this will always be called for S3D_EVENT_NEW_OBJECT!! */
-	if (newevt-&gt;event==S3D_EVENT_NEW_OBJECT)
-	{
-		_queue_new_object(*((unsigned int *)newevt-&gt;buf));	
+	/*  this will always be called for S3D_EVENT_NEW_OBJECT!! */
+	if (newevt-&gt;event==S3D_EVENT_NEW_OBJECT) {
+		_queue_new_object(*((unsigned int *)newevt-&gt;buf));
 	}
-	if (cb_lock==0)  /*  no recursive event-callbacks, please! */
-	{	
-		if (NULL!=(cb=s3d_get_callback(newevt-&gt;event)))
-		{
+	if (cb_lock==0) { /*  no recursive event-callbacks, please! */
+		if (NULL!=(cb=s3d_get_callback(newevt-&gt;event))) {
 			cb_lock++;		 /*  on our way! lock it.. */
 			cb(newevt);		 /*  .. and call it! */
 			cb_lock--;
-							 /* okay, no new callbacks, unlock now. */
+			/* okay, no new callbacks, unlock now. */
 			free(newevt);
 			return;
 		}
 	}
 	newevt-&gt;next=NULL;
-	if (s3d_stack!=NULL)
-	{
+	if (s3d_stack!=NULL) {
 		for (p=s3d_stack;p-&gt;next!=NULL;p=p-&gt;next);  /*  go to the end */
 		p-&gt;next=newevt;
 	} else
 		s3d_stack=newevt;
 }
-struct s3d_evt *s3d_pop_event()
-{
+struct s3d_evt *s3d_pop_event() {
 	struct s3d_evt *ret;
 	if ((ret=s3d_stack)!=NULL)
 		s3d_stack=s3d_stack-&gt;next;
 	return ret;
 }
-struct s3d_evt *s3d_find_event(uint8_t event)
-{
+struct s3d_evt *s3d_find_event(uint8_t event) {
 	struct s3d_evt *p;
 	p=s3d_stack;
-	while (p!=NULL)
-	{
+	while (p!=NULL) {
 		if (p-&gt;event==event)
 			return(p);
 		p=p-&gt;next;
@@ -83,20 +76,18 @@
 {
 	struct s3d_evt *previous=NULL;
 	struct s3d_evt *p=s3d_stack;
-	while (p!=NULL)
-	{
-		 /* if ((p-&gt;event==devt-&gt;event) &amp;&amp; (p-&gt;length==devt-&gt;length)) */
-		 /* 	if (0==memcmp(p-&gt;buf,devt-&gt;buf)) */
-		if (p==devt)
-			{
-				if (p-&gt;length&gt;0) 
-					free(p-&gt;buf);
-				if (previous==NULL) 
-					s3d_stack=p-&gt;next;  /*  the first element!! */
-				else
-					previous-&gt;next=p-&gt;next;  /*  unlink */
-				free(p);
-			}
+	while (p!=NULL) {
+		/* if ((p-&gt;event==devt-&gt;event) &amp;&amp; (p-&gt;length==devt-&gt;length)) */
+		/* 	if (0==memcmp(p-&gt;buf,devt-&gt;buf)) */
+		if (p==devt) {
+			if (p-&gt;length&gt;0)
+				free(p-&gt;buf);
+			if (previous==NULL)
+				s3d_stack=p-&gt;next;  /*  the first element!! */
+			else
+				previous-&gt;next=p-&gt;next;  /*  unlink */
+			free(p);
+		}
 		previous=p;
 		p=p-&gt;next;
 	}
@@ -107,9 +98,8 @@
 {
 	struct s3d_evt *p;
 	s3d_cb cb;
-	if (cb_lock&gt;0) /* can't do that now. */
-	{
-		
+	if (cb_lock&gt;0) { /* can't do that now. */
+
 		s3dprintf(VLOW,&quot;cb_lock = %d, processing later&quot;,cb_lock);
 		return;
 	}
@@ -121,11 +111,11 @@
 			cb_lock--;
 		} else {
 			/* kick out unprocessed event */
-			
+
 		}
-		 /*  free */
-		if (p-&gt;length&gt;0) 
+		/*  free */
+		if (p-&gt;length&gt;0)
 			free(p-&gt;buf);
-		free(p);	
+		free(p);
 	}
 }

Modified: trunk/libs3d/fontselect.c
===================================================================
--- trunk/libs3d/fontselect.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/fontselect.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -41,28 +41,29 @@
 #ifdef WITH_FONTCONFIG
 char *s3d_findfont(char *mask)
 {
-  FcPattern *pattern = 0, *match = 0;
-  FcChar8 *file = 0;
-  FcResult result;
+	FcPattern *pattern = 0, *match = 0;
+	FcChar8 *file = 0;
+	FcResult result;
 
-  pattern = FcNameParse((FcChar8 *)mask);
-  FcConfigSubstitute(0,pattern,FcMatchPattern);
-  FcDefaultSubstitute(pattern);
-  s3dprintf(LOW,&quot;Looking for font %s&quot;,mask);
+	pattern = FcNameParse((FcChar8 *)mask);
+	FcConfigSubstitute(0,pattern,FcMatchPattern);
+	FcDefaultSubstitute(pattern);
+	s3dprintf(LOW,&quot;Looking for font %s&quot;,mask);
 
-  if (!(match=FcFontMatch(0,pattern,&amp;result))) 
-	return NULL;
-  if (FcPatternGetString(match,FC_FILE,0,&amp;file)!=FcResultMatch)
-	return NULL;
-  return (char *)file;
+	if (!(match=FcFontMatch(0,pattern,&amp;result)))
+		return NULL;
+	if (FcPatternGetString(match,FC_FILE,0,&amp;file)!=FcResultMatch)
+		return NULL;
+	return (char *)file;
 }
-#else 
+#else
 /*  this uses the xserver to get a font-path and scan it for ttf-fonts. */
 /*  if it matches, give it out ... it's not nice, right, and might not */
 /*  work on your place. */
 char *s3d_findfont(char *mask)
 {
-    char **flist = NULL; int fnum = 0;
+	char **flist = NULL;
+	int fnum = 0;
 	char *disp=NULL;
 	int n;
 	char *fname;
@@ -71,44 +72,35 @@
 	Display *dpy;
 
 	dpy = XOpenDisplay(disp);  /*  Open display and check for success */
-	if (dpy == NULL) 
-	  errds(VHIGH, &quot;s3d_findfont()&quot;,&quot;unable to open display %s&quot;, XDisplayName (disp));
-	else 
-	{
-		if (!(flist = XGetFontPath (dpy, &amp;fnum)))
-		{
-		    errds(VHIGH, &quot;s3d_findfont():XGetFontPath()&quot;,&quot;unable to get font path.&quot;);
-		}
-		else 
-		while (fnum--)
-		{
-			 /*  now scan the directories	 */
-    		n =  scandir(flist[fnum], &amp;namelist, 0, alphasort);
-        	while(n--&gt;0) 
-			{
-				fname=namelist[n]-&gt;d_name;
-				if (strlen(fname)&gt;(strlen(mask)+3))  /*  there should be enough space for the .ttf ending */
-				{
-					 /*  check for the first n characters */
-					if (0==strncasecmp(fname,mask,strlen(mask)))
-					{
-						 /*  name matches! now check for the end... */
-						if (0==strncasecmp(fname+(strlen(fname)-3),&quot;ttf&quot;,3)) /*  check if it has a ttf-ending */
-						{
-							if (good==NULL)
-								good=malloc(256);
-							strncpy(good,flist[fnum],255);
-							good[256]=0; 									/* just in case */
-							strncat(good,fname,255-strlen(good));
-							if ((strlen(mask)+4)==strlen(fname))
-							{
-								return(good);
+	if (dpy == NULL)
+		errds(VHIGH, &quot;s3d_findfont()&quot;,&quot;unable to open display %s&quot;, XDisplayName (disp));
+	else {
+		if (!(flist = XGetFontPath (dpy, &amp;fnum))) {
+			errds(VHIGH, &quot;s3d_findfont():XGetFontPath()&quot;,&quot;unable to get font path.&quot;);
+		} else
+			while (fnum--) {
+				/*  now scan the directories	 */
+				n =  scandir(flist[fnum], &amp;namelist, 0, alphasort);
+				while (n--&gt;0) {
+					fname=namelist[n]-&gt;d_name;
+					if (strlen(fname)&gt;(strlen(mask)+3)) { /*  there should be enough space for the .ttf ending */
+						/*  check for the first n characters */
+						if (0==strncasecmp(fname,mask,strlen(mask))) {
+							/*  name matches! now check for the end... */
+							if (0==strncasecmp(fname+(strlen(fname)-3),&quot;ttf&quot;,3)) { /*  check if it has a ttf-ending */
+								if (good==NULL)
+									good=malloc(256);
+								strncpy(good,flist[fnum],255);
+								good[256]=0; 									/* just in case */
+								strncat(good,fname,255-strlen(good));
+								if ((strlen(mask)+4)==strlen(fname)) {
+									return(good);
+								}
 							}
 						}
 					}
 				}
 			}
-		}
 		XCloseDisplay (dpy);
 	}
 	return(good);

Modified: trunk/libs3d/freetype.c
===================================================================
--- trunk/libs3d/freetype.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/freetype.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -31,24 +31,23 @@
 #include &lt;string.h&gt;			/*  strncmp(), strncpy() */
 #include &quot;ft2build.h&quot;
 #include FT_FREETYPE_H
-#undef __FTERRORS_H__                
-#define FT_ERRORDEF( e, v, s )  { e, s },                    
-#define FT_ERROR_START_LIST     {                           
-#define FT_ERROR_END_LIST       { 0, 0 } };                
-                                                          
-const struct 
-{                                                       
-    int          err_code;                             
-    const char*  err_msg;
-} ft_errors[] = 
-                                                              
-#include FT_ERRORS_H                                         
+#undef __FTERRORS_H__
+#define FT_ERRORDEF( e, v, s )  { e, s },
+#define FT_ERROR_START_LIST     {
+#define FT_ERROR_END_LIST       { 0, 0 } };
 
-#ifndef CALLBACK 
+const struct {
+	int          err_code;
+	const char*  err_msg;
+} ft_errors[] =
+
+#include FT_ERRORS_H
+
+#ifndef CALLBACK
 #define CALLBACK
 #endif
-/*  bad global vars ... */
-static FT_Library 	library;
+        /*  bad global vars ... */
+        static FT_Library 	library;
 static FT_Face		face;
 static char *memory_font=NULL;		 /*  the font file in memory */
 static char oldfontpath[256];
@@ -70,9 +69,8 @@
 	oldfontpath[0]=0;
 	if (error)
 		return (-1);
-    ft_init=1;
-	for (i=0; i&lt;256;i++)
-	{
+	ft_init=1;
+	for (i=0; i&lt;256;i++) {
 		tess_buf[i].vbuf=NULL;
 		tess_buf[i].pbuf=NULL;
 	}
@@ -83,15 +81,13 @@
 int s3d_ft_load_font()
 {
 	FT_Error error;
-	if ((memory_font==NULL) || (memory_font_size==0))
-	{
+	if ((memory_font==NULL) || (memory_font_size==0)) {
 		errds(HIGH,&quot;s3d_ft_load_font()&quot;,&quot;there is no font in memory, breaking&quot;);
 		return(-1);
 	}
 	face_init=0;
 	error= FT_New_Memory_Face(library,(uint8_t *)memory_font,memory_font_size,0,&amp;face);
-	if (error)
-	{
+	if (error) {
 		errds(VHIGH,&quot;s3d_ft_load_font():FT_New_Memory_Face&quot;,&quot;can't load font : (%d) %s&quot;,ft_errors[error].err_code,ft_errors[error].err_msg);
 		return(-1);
 	}
@@ -104,13 +100,11 @@
 {
 	int i;
 
-	for (i=0; i&lt;256;i++)
-	{
+	for (i=0; i&lt;256;i++) {
 		if (tess_buf[i].vbuf!=NULL) free(tess_buf[i].vbuf);
 		if (tess_buf[i].pbuf!=NULL) free(tess_buf[i].pbuf);
 	}
-	for (i=0; i&lt;256;i++)
-	{
+	for (i=0; i&lt;256;i++) {
 		tess_buf[i].vbuf=NULL;
 		tess_buf[i].pbuf=NULL;
 	}
@@ -136,35 +130,31 @@
 	double vertices[SEI_SS+1][2];
 	double nvertices[SEI_SS+1][2];
 	FT_Error error;
-	
+
 	error= FT_Load_Char(face,a, FT_LOAD_NO_BITMAP|FT_LOAD_NO_SCALE);
-	if (error)
-	{
-		
+	if (error) {
+
 		errds(VHIGH,&quot;_s3d_add_tessbuf():FT_Load_Char()&quot;,&quot;can't load character %d : (%d) %s&quot;,a,ft_errors[error].err_code,ft_errors[error].err_msg);
 		return(-1);
-	} 
+	}
 	s3dprintf(VLOW,&quot;[T]riangulating character %c&quot;,a);
 	norm=1.0/face-&gt;glyph-&gt;metrics.vertAdvance;
 	ch=a;
 	v_off=0;
-	if ((face-&gt;glyph-&gt;outline.n_points&gt;0) &amp;&amp; (face-&gt;glyph-&gt;outline.n_points&lt;SEI_SS))
-	{
+	if ((face-&gt;glyph-&gt;outline.n_points&gt;0) &amp;&amp; (face-&gt;glyph-&gt;outline.n_points&lt;SEI_SS)) {
 		tess_buf[a].vn=face-&gt;glyph-&gt;outline.n_points;
 		tess_buf[a].vbuf=malloc(sizeof(float)*face-&gt;glyph-&gt;outline.n_points*3);
-		
+
 		j=0;
 		ncontours=face-&gt;glyph-&gt;outline.n_contours;
-		for (c=0;c&lt;ncontours;c++)
-		{
+		for (c=0;c&lt;ncontours;c++) {
 			start=j; 	/* first point */
 			i=0;
 			ncon=face-&gt;glyph-&gt;outline.contours[c]; /* position of the end of ths contour */
 			cntr[c]=ncon-j+1;					   /* how many points do we have here? */
 			csta[c]=j+1;
 			ar=0.0f;
-			while (j&lt;(ncon+1))
-			{
+			while (j&lt;(ncon+1)) {
 				/* vertices have reverse order in seidels algorithm, outer contours go anticlockwise, inner contours clockwise */
 				/* calculate the area */
 				k=((j+2-csta[c])%(cntr[c]))+csta[c]-1;
@@ -181,44 +171,38 @@
 			s3dprintf(VLOW,&quot;contour %d has area of %3.3f, cntr is %d, contour starts at %d, ncon %d&quot;,c,ar,cntr[c], csta[c], ncon);
 			area[c]=ar; /* save the area */
 		}
-		/* now as we have the areas and sizes of the contours, we need to order our contours so that 
+		/* now as we have the areas and sizes of the contours, we need to order our contours so that
 		 * the outlines and their holes are grouped together */
 		n=ncontours;
 		for (i=0;i&lt;n;i++)
 			perm[i]=i; /* initialise permutation */
-		while (n!=0)
-		{
+		while (n!=0) {
 			outl=-1;
 			/* find an outline */
 			for (i=0;i&lt;n;i++)
-				if (area[perm[i]]&gt;0)
-				{
+				if (area[perm[i]]&gt;0) {
 					outl=i; /* found. that was easy ;) */
 					break;
 				}
-			if (outl==-1)
-			{
+			if (outl==-1) {
 				s3dprintf(HIGH,&quot;hole without outline found, exiting ... %c&quot;,a);
 				return(-1);
 			}
-			for (i=0;i&lt;n;i++)
-			{
-				if (area[perm[i]]&lt;0)
-				{
+			for (i=0;i&lt;n;i++) {
+				if (area[perm[i]]&lt;0) {
 					/* test for a hole inside by taking one (the first) point of the hole and doing the test */
 					xa=vertices[csta[perm[i]]][0];
 					ya=vertices[csta[perm[i]]][1];
 					s=csta[perm[outl]];							/* start point of outline */
 					e=(csta[perm[outl]]+cntr[perm[outl]])-1;		/* end point */
 					ar=0;
-					for (j=s;j&lt;e;j++)
-					{ /* for all points of the outline, sum: */
+					for (j=s;j&lt;e;j++) { /* for all points of the outline, sum: */
 						ar+=atan2((vertices[j+1][1]-ya)*(vertices[j][0]-xa)-(vertices[j+1][0]-xa)*(vertices[j][1]-ya),
-								  (vertices[j+1][0]-xa)*(vertices[j][0]-xa)+(vertices[j+1][1]-ya)*(vertices[j][1]-ya));
+						          (vertices[j+1][0]-xa)*(vertices[j][0]-xa)+(vertices[j+1][1]-ya)*(vertices[j][1]-ya));
 					}
 					/* dont forget the start/end-point connection*/
 					ar+=atan2((vertices[s][1]-ya)*(vertices[e][0]-xa)-(vertices[s][0]-xa)*(vertices[e][1]-ya),
-							  (vertices[s][0]-xa)*(vertices[e][0]-xa)+(vertices[s][1]-ya)*(vertices[e][1]-ya));
+					          (vertices[s][0]-xa)*(vertices[e][0]-xa)+(vertices[s][1]-ya)*(vertices[e][1]-ya));
 					if (fabsf(ar)&gt;1)						/* if ar = 0.0, it's outside, elseway it's a multiple of pi. this check should be
 															 * very generous to roundoff errors */
 					{
@@ -242,11 +226,9 @@
 		}
 		/* finished the permutation, now apply the new order .... */
 		n=1;
-		for (c=0;c&lt;ncontours;c++)
-		{
+		for (c=0;c&lt;ncontours;c++) {
 			ncsta[c]=n-1;
-			for (j=csta[perm[c]];j&lt;(csta[perm[c]]+cntr[perm[c]]);j++)
-			{
+			for (j=csta[perm[c]];j&lt;(csta[perm[c]]+cntr[perm[c]]);j++) {
 				nvertices[n][0]=vertices[j][0];
 				nvertices[n][1]=vertices[j][1];
 				tess_buf[a].vbuf[(n-1)*3]	=nvertices[n][0];
@@ -257,17 +239,14 @@
 			ncntr[c]=cntr[perm[c]];
 		}
 		n=0;
-		tess_buf[a].pbuf=malloc(sizeof(uint32_t)*4*(face-&gt;glyph-&gt;outline.n_points+2*face-&gt;glyph-&gt;outline.n_contours)); 
+		tess_buf[a].pbuf=malloc(sizeof(uint32_t)*4*(face-&gt;glyph-&gt;outline.n_points+2*face-&gt;glyph-&gt;outline.n_contours));
 		k=0;
-		for (c=ncontours-1;c&gt;=0;c--)
-		{
+		for (c=ncontours-1;c&gt;=0;c--) {
 			n++;				 /* count out and inlines ... */
-			if (area[perm[c]]&gt;0) /* outline? start! */
-			{
+			if (area[perm[c]]&gt;0) { /* outline? start! */
 				s3dprintf(VLOW,&quot;[T]riangulation from outline %d (%d contours, area = %f)&quot;,perm[c],n,area[perm[c]]);
 				np=sei_triangulate_polygon(n, ncntr+c, nvertices+(ncsta[c]), triangles);
-				for (i=0;i&lt;np;i++)
-				{
+				for (i=0;i&lt;np;i++) {
 					tess_buf[a].pbuf[k*4]=  triangles[i][0]+ncsta[c]-1;
 					tess_buf[a].pbuf[k*4+1]=triangles[i][2]+ncsta[c]-1;
 					tess_buf[a].pbuf[k*4+2]=triangles[i][1]+ncsta[c]-1;
@@ -293,31 +272,29 @@
 		_s3d_add_tessbuf(a);
 	/* only draw if it has some information in it */
 	if ((tess_buf[a].pn != 0) &amp;&amp; (tess_buf[a].vn != 0)) {
-	
+
 		vbuf=malloc(sizeof(float)*3*tess_buf[a].vn);
 		pbuf=malloc(sizeof(uint32_t)*4*tess_buf[a].pn);
 		memcpy(vbuf,tess_buf[a].vbuf,sizeof(float)*3*tess_buf[a].vn);
 		memcpy(pbuf,tess_buf[a].pbuf,sizeof(uint32_t)*4*tess_buf[a].pn);
-		 /*  prepare the buffs ... */
-	/* 	s3dprintf(LOW,&quot;drawing [%c] (%d vertices, %d polys&quot;,a,tess_buf[a].vn,tess_buf[a].pn); */
-		for (i=0;i&lt;tess_buf[a].vn;i++)
-		{
+		/*  prepare the buffs ... */
+		/* 	s3dprintf(LOW,&quot;drawing [%c] (%d vertices, %d polys&quot;,a,tess_buf[a].vn,tess_buf[a].pn); */
+		for (i=0;i&lt;tess_buf[a].vn;i++) {
 			vbuf[i*3]+=*xoff;
-	/*		s3dprintf(LOW,&quot;vertex [%c:%d] %f %f %f&quot;,a,i,
-							vbuf[i*3],
-							vbuf[i*3+1],
-							vbuf[i*3+2]);*/
+			/*		s3dprintf(LOW,&quot;vertex [%c:%d] %f %f %f&quot;,a,i,
+									vbuf[i*3],
+									vbuf[i*3+1],
+									vbuf[i*3+2]);*/
 		}
-		for (i=0;i&lt;tess_buf[a].pn;i++)
-		{
+		for (i=0;i&lt;tess_buf[a].pn;i++) {
 			pbuf[i*4]+=*voff;
 			pbuf[i*4+1]+=*voff;
 			pbuf[i*4+2]+=*voff;
-	/*		s3dprintf(LOW,&quot;poly [%c:%d] %d %d %d | %d (voff %d)&quot;,a,i,
-							pbuf[i*4],
-							pbuf[i*4+1],
-							pbuf[i*4+2],
-							pbuf[i*4+3],*voff);*/
+			/*		s3dprintf(LOW,&quot;poly [%c:%d] %d %d %d | %d (voff %d)&quot;,a,i,
+									pbuf[i*4],
+									pbuf[i*4+1],
+									pbuf[i*4+2],
+									pbuf[i*4+3],*voff);*/
 		}
 		s3dprintf(VLOW,&quot;commiting %d vertices, %d polygons&quot;,tess_buf[a].vn,tess_buf[a].pn);
 		s3d_push_vertices(oid,vbuf,tess_buf[a].vn);
@@ -336,26 +313,21 @@
 	char *c;
 	char **p;
 	if (!ft_init)
-		if (s3d_ft_init())
-		{
+		if (s3d_ft_init()) {
 			errds(VHIGH,&quot;s3d_select_font()&quot;,&quot;error in initializtation (ft_init())&quot;);
 			return(-1);
 		}
-	if (strncmp(oldfontpath,path,256)==0)
-	{
+	if (strncmp(oldfontpath,path,256)==0) {
 		s3dprintf(VLOW,&quot;font already %s loaded.&quot;, path);
 		return(-1);
 	}
-	 /*  yse (system-specific?!) font grabber */
-	if (((c=s3d_findfont(path))!=NULL))
-	{
+	/*  yse (system-specific?!) font grabber */
+	if (((c=s3d_findfont(path))!=NULL)) {
 		s3dprintf(LOW,&quot;Loading Font %s ... &quot;,c);
 		_s3d_clear_tessbuf(); /* free and clear the tessbuf */
 		p=&amp;memory_font;
-		if ((memory_font_size=s3d_open_file(c,p))&gt;0)
-		{
-			if (!s3d_ft_load_font())
-			{	/* success */
+		if ((memory_font_size=s3d_open_file(c,p))&gt;0) {
+			if (!s3d_ft_load_font()) {	/* success */
 				if (oldfont!=NULL)				free(oldfont);
 				strncpy(oldfontpath,path,256);
 				return(0);
@@ -379,59 +351,55 @@
 	int len;
 	uint32_t f_oid;
 	if (!ft_init)
-		if (s3d_ft_init())
-		{
+		if (s3d_ft_init()) {
 			errds(VHIGH,&quot;s3d_draw_string()&quot;,&quot;error in initializtation (ft_init())&quot;);
 			return(-1);
 		}
-	if (!face_init)
-	{
+	if (!face_init) {
 		errds(VHIGH,&quot;s3d_draw_string()&quot;,&quot;no font to draw with&quot;);
 		return(-1);
 	}
-	f_oid=s3d_new_object(); 
-	 /*  standard material */
+	f_oid=s3d_new_object();
+	/*  standard material */
 	s3d_push_material(f_oid,1.0,1.0,1.0,		1.0,1.0,1.0,	1.0,1.0,1.0);
 	xoff=0;
-	voff=0; 
+	voff=0;
 	len=strlen(str);
 	for (i=0;i&lt;len; i++)
 		_s3d_draw_tessbuf(f_oid,(uint8_t )str[i],&amp;voff,&amp;xoff);
-	 /*  s3d_ft_quit(); */
+	/*  s3d_ft_quit(); */
 	if (xlen!=NULL) *xlen=xoff;
 	return(f_oid);
 }
 /* get the string length before actually drawing it. */
-float s3d_strlen( char *str) {
+float s3d_strlen( char *str)
+{
 	int i;
 	float xoff;
 	int voff;
 	int len;
 	uint16_t a;
 	if (!ft_init)
-		if (s3d_ft_init())
-		{
+		if (s3d_ft_init()) {
 			errds(VHIGH,&quot;s3d_draw_string()&quot;,&quot;error in initializtation (ft_init())&quot;);
 			return(0.0);
 		}
-	if (!face_init)
-	{
+	if (!face_init) {
 		errds(VHIGH,&quot;s3d_draw_string()&quot;,&quot;no font to draw with&quot;);
 		return(0.0);
 	}
-	 /*  standard material */
+	/*  standard material */
 	xoff=0;
-	voff=0; 
+	voff=0;
 	len=strlen(str);
-	for (i=0;i&lt;len; i++)
-	{
+	for (i=0;i&lt;len; i++) {
 		a=(uint8_t )str[i];
 		if (!(tess_buf[a].vbuf &amp;&amp; tess_buf[a].pbuf))
 			_s3d_add_tessbuf(a);
 		xoff+=tess_buf[a].xoff;  /*  xoffset */
 	}
 	return(xoff);
-	
+
 }
 int s3d_ft_quit()
 {

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/io.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -49,7 +49,7 @@
 #endif
 #include &lt;netinet/in.h&gt;  /*  htons(),htonl() */
 #ifndef WIN32
-	#include &lt;netdb.h&gt;		 /*  gethostbyname()  */
+#include &lt;netdb.h&gt;		 /*  gethostbyname()  */
 #endif
 
 static char				*url=NULL;
@@ -77,25 +77,18 @@
 {
 	char				 c;
 	int					 lopt_idx;
-	struct option long_options[] =
-	{
-		{&quot;s3d-url&quot;,1,0,0},
-		{&quot;help&quot;,0,0,'h'},
-		{&quot;s3d-help&quot;,0,0,'h'},
-		{0,0,0,0}
+	struct option long_options[] = {
+		{&quot;s3d-url&quot;,1,0,0
+		}, {&quot;help&quot;,0,0,'h'}, {&quot;s3d-help&quot;,0,0,'h'}, {0,0,0,0}
 	};
 	if ((argc==NULL) || (argv==NULL)) return(0); /* nothing to parse */
 	optind=0;
 	opterr=0;	/* we don't want to be bothered if there is some error */
-	while (-1!=(c=getopt_long(*argc,*argv,&quot;?h&quot;,long_options,&amp;lopt_idx)))
-	{
-		switch (c)
-		{
+	while (-1!=(c=getopt_long(*argc,*argv,&quot;?h&quot;,long_options,&amp;lopt_idx))) {
+		switch (c) {
 		case 0:
-			if (0==strcmp(long_options[lopt_idx].name,&quot;s3d-url&quot;))
-			{
-				if (optarg)
-				{
+			if (0==strcmp(long_options[lopt_idx].name,&quot;s3d-url&quot;)) {
+				if (optarg) {
 					url=optarg;
 					s3dprintf(HIGH,&quot;connecting to %s&quot;,url);
 				}
@@ -112,8 +105,7 @@
 		}
 	}
 	optind=0;
-	if (*argc&gt;0)
-	{
+	if (*argc&gt;0) {
 		*argc-=(optind-1); 				 /*  hide s3d-options */
 		(*argv)[optind-1]=(*argv)[0]; 	 /*  restore program path */
 		*argv+=(optind-1); 				 /*  set the string pointer at the right position */
@@ -127,21 +119,20 @@
 	char 				 urlc[256];		 /*  this should be enough for an url */
 	char 				 buf[258]; 		 /*  server buffer */
 	int					 i;
-	struct timespec		 t={0,10*1000*1000}; /* 10 mili second */
+	struct timespec		 t= {
+		0,10*1000*1000
+	}; /* 10 mili second */
 
 	cb_lock=1;	/* don't bother while initiating ... is set to 0 after INIT packet received. */
-	if (NULL!=(s=getenv(&quot;S3D&quot;)))
-	{
+	if (NULL!=(s=getenv(&quot;S3D&quot;))) {
 		s3dprintf(VLOW,&quot;at least we have the enviroment variable ... %s&quot;,s);
 		url=s;
 	}
 	parse_args(argc,argv);
-	if (url==NULL) /* no url specified or obtained through arguments */
-	{
+	if (url==NULL) { /* no url specified or obtained through arguments */
 		/* trying standard ways to connect */
 		strncpy(urlc,&quot;s3<A HREF="d:///tmp/.s3d:shm/">d:///tmp/.s3d:shm/</A>&quot;,256);
-		if (s3d_net_init(urlc)==CON_NULL)
-		{
+		if (s3d_net_init(urlc)==CON_NULL) {
 			strncpy(urlc,&quot;s3<A HREF="d://127.0.0.1:6066/">d://127.0.0.1:6066/</A>&quot;,256);
 			if (s3d_net_init(urlc)==CON_NULL)
 				return(-1);
@@ -149,12 +140,11 @@
 	} else {
 		strncpy(urlc,url,256);	 /*  this should keep buffer overflows away, maybe */
 		urlc[256]=0;			 /*  just to make sure */
-		if (!strncmp(urlc, &quot;s3<A HREF="d://">d://</A> &quot;,6))
-		{
+		if (!strncmp(urlc, &quot;s3<A HREF="d://">d://</A> &quot;,6)) {
 			if (s3d_net_init(urlc)==CON_NULL) return(-1);
 		} else {
 			errs(&quot;s3d_init()&quot;,&quot;invalid url&quot;);
-			  return(-1);
+			return(-1);
 		}
 	}
 	strncpy(buf,name,256);  /*  copy the name ... */
@@ -162,14 +152,14 @@
 
 	_queue_init();
 #ifdef SIGS
-    if (signal(SIGINT, (sig_t)sigint_handler) == SIG_ERR)
+	if (signal(SIGINT, (sig_t)sigint_handler) == SIG_ERR)
 		errdn(LOW,&quot;s3d_init():signal()&quot;,errno);
-    if (signal(SIGTERM, (sig_t)sigint_handler) == SIG_ERR)
+	if (signal(SIGTERM, (sig_t)sigint_handler) == SIG_ERR)
 		errdn(LOW,&quot;s3d_init():signal()&quot;,errno);
 #endif
 	for (i=0;i&lt;100;i++) {
 		s3d_net_check(); /* wait for init packet */
-		nanosleep(&amp;t,NULL); 
+		nanosleep(&amp;t,NULL);
 		if (_s3d_ready) {
 			cb_lock--;
 			return(0);
@@ -183,13 +173,16 @@
 	struct s3d_evt *ret;
 	if (con_type!=CON_NULL &amp;&amp; _s3d_ready) {
 		net_send(S3D_P_C_QUIT,NULL,0);
-		switch (con_type)
-		{
+		switch (con_type) {
 #ifdef TCP
-			case CON_TCP:_tcp_quit();break;
+		case CON_TCP:
+			_tcp_quit();
+			break;
 #endif
 #ifdef SHM
-			case CON_SHM:_shm_quit();break;
+		case CON_SHM:
+			_shm_quit();
+			break;
 #endif
 		}
 		con_type=CON_NULL;
@@ -207,13 +200,12 @@
 /*  apps should use that as main loop for their programs. */
 int s3d_mainloop(void (*f)())
 {
-	while (con_type!=CON_NULL)
-	{
+	while (con_type!=CON_NULL) {
 		cb_lock++;			/* no callbacks while we are in mainloop */
 		if (f!=NULL)	f();
 		cb_lock--;
 		s3d_process_stack();
-		s3d_net_check(); 	/* get any other packets we might have missed */	
+		s3d_net_check(); 	/* get any other packets we might have missed */
 	}
 	return(0);
 }
@@ -226,23 +218,26 @@
 	int filesize;
 	struct stat bf;
 	*pointer=NULL;
-/*	if ((fp = fopen(fname, &quot;rt&quot;)) == NULL)
-	{ errn(&quot;s3d_open_file():fopen()&quot;,errno); return(0);}
-	if (fseek(fp, 0, SEEK_END) != 0)
-	{ errn(&quot;s3d_open_file():fseek()&quot;,errno); return(0);}
-	if ((filesize = (int)ftell(fp)) == (long)-1)
-	{ errn(&quot;s3d_open_file():ftell()&quot;,errno); return(0);}
-	if (fseek(fp, 0, SEEK_SET) != 0)
-	{ errn(&quot;s3d_open_file():fseek()&quot;,errno); return(0);}*/
+	/*	if ((fp = fopen(fname, &quot;rt&quot;)) == NULL)
+		{ errn(&quot;s3d_open_file():fopen()&quot;,errno); return(0);}
+		if (fseek(fp, 0, SEEK_END) != 0)
+		{ errn(&quot;s3d_open_file():fseek()&quot;,errno); return(0);}
+		if ((filesize = (int)ftell(fp)) == (long)-1)
+		{ errn(&quot;s3d_open_file():ftell()&quot;,errno); return(0);}
+		if (fseek(fp, 0, SEEK_SET) != 0)
+		{ errn(&quot;s3d_open_file():fseek()&quot;,errno); return(0);}*/
 
-	if ((fp = fopen(fname, &quot;rt&quot;)) == NULL)
-	{ errdn(VLOW,&quot;s3d_open_file():fopen()&quot;,errno); return(-1);}
-	if (fstat(fileno(fp),&amp;bf))
-	{ errdn(VLOW,&quot;s3d_open_file():fstat()&quot;,errno); return(-1);}
+	if ((fp = fopen(fname, &quot;rt&quot;)) == NULL) {
+		errdn(VLOW,&quot;s3d_open_file():fopen()&quot;,errno);
+		return(-1);
+	}
+	if (fstat(fileno(fp),&amp;bf)) {
+		errdn(VLOW,&quot;s3d_open_file():fstat()&quot;,errno);
+		return(-1);
+	}
 	filesize=bf.st_size;
-/*	s3dprintf(LOW, &quot;opening %s, filesize is %d&quot;,fname, filesize);*/
-	if ((buf=malloc(filesize))==NULL)
-	{
+	/*	s3dprintf(LOW, &quot;opening %s, filesize is %d&quot;,fname, filesize);*/
+	if ((buf=malloc(filesize))==NULL) {
 		errn(&quot;s3d_open_3ds_file():malloc()&quot;,errno);
 		exit(-1);
 	}

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/modelread.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -57,21 +57,17 @@
 	strncpy(searchpath,OBJSDIR,1023);
 	searchpath[1023]=0;							/* just in case */
 	next=ptr=searchpath;
-	while (next!=NULL)
-	{
+	while (next!=NULL) {
 		next=NULL;
 
-		if (NULL!=(next=strchr(ptr,':')))
-		{
+		if (NULL!=(next=strchr(ptr,':'))) {
 			*next=0; 							/* clear the delimiter */
 			next+=1;							/* move to the beginner of the next dir */
 		}
-		if ((strlen(ptr)+strlen(fname))&lt;1024) 	/* only try if this fits */
-		{
+		if ((strlen(ptr)+strlen(fname))&lt;1024) {	/* only try if this fits */
 			strcpy(path,ptr); 					/* can use &quot;unsafe&quot; functions because size was verified above */
 			strcat(path,fname);
-			if (s3d_open_file(path,&amp;buf)!=-1)  /* found something */
-			{
+			if (s3d_open_file(path,&amp;buf)!=-1) { /* found something */
 				free(buf); /* TODO: badbadbad ... */
 				if (-1!=(oid=model_load(path))) return(oid);
 
@@ -84,7 +80,8 @@
 	return(-1); /* nothing in search path ... */
 }
 
-void *get_mat2tex( struct material2texture **mat2tex, void *mat_ptr ) {
+void *get_mat2tex( struct material2texture **mat2tex, void *mat_ptr )
+{
 
 	while ( (*mat2tex) != NULL ) {
 
@@ -175,8 +172,8 @@
 
 				if ( mat2tex-&gt;material_id == -1 ) { /* create a new texture if nothing found */
 					s3d_push_material_a( obj_id, 	face-&gt;material-&gt;r, face-&gt;material-&gt;g, face-&gt;material-&gt;b,face-&gt;material-&gt;a,
-													face-&gt;material-&gt;specular[0], face-&gt;material-&gt;specular[1], face-&gt;material-&gt;specular[2], face-&gt;material-&gt;specular[3],
-													face-&gt;material-&gt;r, face-&gt;material-&gt;g, face-&gt;material-&gt;b, face-&gt;material-&gt;a );
+					                     face-&gt;material-&gt;specular[0], face-&gt;material-&gt;specular[1], face-&gt;material-&gt;specular[2], face-&gt;material-&gt;specular[3],
+					                     face-&gt;material-&gt;r, face-&gt;material-&gt;g, face-&gt;material-&gt;b, face-&gt;material-&gt;a );
 
 					mat2tex-&gt;material_id = material_count;
 					material_count++;
@@ -211,8 +208,7 @@
 
 					}
 				}
-				if (face-&gt;flags != oldflags || npoly&gt;=PMAX)
-				{
+				if (face-&gt;flags != oldflags || npoly&gt;=PMAX) {
 					/* push things so far */
 					s3d_push_polygons(obj_id, polybuf, npoly);
 					if (oldflags &amp; G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
@@ -238,8 +234,7 @@
 					normalbuf[ npoly*9 + 7] = -face-&gt;normals[ 5 ];
 					normalbuf[ npoly*9 + 8] =  face-&gt;normals[ 4 ];
 				}
-				if ( face-&gt;flags &amp; G3D_FLAG_FAC_TEXMAP )
-				{
+				if ( face-&gt;flags &amp; G3D_FLAG_FAC_TEXMAP ) {
 					texcoordbuf[ npoly*6 + 0] = face-&gt;tex_vertex_data[ 0 ];
 					texcoordbuf[ npoly*6 + 1] = face-&gt;tex_vertex_data[ 1 ];
 					texcoordbuf[ npoly*6 + 2] = face-&gt;tex_vertex_data[ 4 ];
@@ -251,8 +246,7 @@
 				oface = oface-&gt;next;
 			}
 			/* push the last packets in buffer */
-			if (npoly &gt; 0)
-			{
+			if (npoly &gt; 0) {
 				s3d_push_polygons(obj_id, polybuf, npoly);
 				if (oldflags &amp; G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
 				if (oldflags &amp; G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);

Modified: trunk/libs3d/network.c
===================================================================
--- trunk/libs3d/network.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/network.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -40,20 +40,23 @@
 int net_send(u_int8_t opcode, char *buf, u_int16_t length)
 {
 	char *ptr;
-/* 	char *buff; */
+	/* 	char *buff; */
 	char buff[65539];  /*  u_int16_t really shouldn't be bigger ;) */
-	*(buff)=opcode; 
+	*(buff)=opcode;
 	ptr=buff+1;
 	*((u_int16_t *) ptr)=htons(length);
 	if (length!=0)
 		memcpy(buff+3,buf,length);
-	switch (con_type)
-	{
+	switch (con_type) {
 #ifdef SHM
-		case CON_SHM:shm_writen(buff,length+3);break;
+	case CON_SHM:
+		shm_writen(buff,length+3);
+		break;
 #endif
-#ifdef TCP		
-		case CON_TCP:tcp_writen(buff,length+3);break;
+#ifdef TCP
+	case CON_TCP:
+		tcp_writen(buff,length+3);
+		break;
 #endif
 	}
 	return(0);
@@ -68,25 +71,23 @@
 #endif
 int s3d_net_check()
 {
-	switch (con_type)
-	{
+	switch (con_type) {
 #ifdef TCP
-		case CON_TCP:
+	case CON_TCP:
 #ifdef SIGS
-		if (_s3d_sigio)
-		{
+		if (_s3d_sigio) {
 #endif
 			while (_s3d_net_receive());
 #ifdef SIGS
 			_s3d_sigio=0;
-		}	
+		}
 #endif
-			break;
+		break;
 #endif
 #ifdef SHM
-		case CON_SHM:
-			while(_shm_net_receive());
-			break;
+	case CON_SHM:
+		while (_shm_net_receive());
+		break;
 #endif
 	}
 	s3d_process_stack();
@@ -101,21 +102,18 @@
 #endif
 	int					 tcp,shm;
 	tcp=shm=1; /* everything is possible, yet */
-	
-	 /*  doing a very bad server/port extraction, but I think it'll work ... */
+
+	/*  doing a very bad server/port extraction, but I think it'll work ... */
 	s=sv=urlc+6;  /*  getting to the &quot;real&quot; thing */
-	 /* while (((*s!='/') &amp;&amp; (*s!=0)) &amp;&amp; (s&lt;(urlc-6))) */
-	while (*s!=0)
-	{
-		if (*s=='/')
-		{
+	/* while (((*s!='/') &amp;&amp; (*s!=0)) &amp;&amp; (s&lt;(urlc-6))) */
+	while (*s!=0) {
+		if (*s=='/') {
 			if (first_slash==NULL)
 				first_slash=s;
 			if (port!=NULL)
 				break;
 		}
-		if (*s==':')  /*  there is a port in here */
-		{
+		if (*s==':') { /*  there is a port in here */
 			port=s+1;
 			*s=0;	 /*  NULL the port  */
 		}
@@ -123,42 +121,36 @@
 	}
 
 	*s=0;
-	if (port==NULL)
-	{
+	if (port==NULL) {
 		shm=0;
 		if (first_slash!=NULL)
 			*first_slash=0;
 	} else {
 		if (first_slash&lt;port)
 			tcp=0;
-		else 
+		else
 			if (first_slash!=NULL)
 				*first_slash=0;
-		if (!strncmp(port, &quot;shm&quot;,3))
-		{
+		if (!strncmp(port, &quot;shm&quot;,3)) {
 			tcp=0; /* null the others */
 		} else {
 			shm=0;
 		}
 	}
 #ifdef SHM
-	if (shm)
-	{
+	if (shm) {
 		if (!strncmp(port, &quot;shm&quot;,3))
 			if (!_shm_init(sv)) return(con_type=CON_SHM);
 	}
 #endif
 #ifdef TCP
-	if (tcp)
-	{
+	if (tcp) {
 		pn=6066;
-		if (port!=NULL)
-		{
-			if (!(pn=atoi(port)))  /*  I hope atoi is safe enough. */
-			{
+		if (port!=NULL) {
+			if (!(pn=atoi(port))) { /*  I hope atoi is safe enough. */
 				errn(&quot;s3d_init():atoi()&quot;,errno);
 				pn=6066;
-			} 
+			}
 		}
 		if (!_tcp_init(sv,pn)) return(con_type=CON_TCP);
 	}

Modified: trunk/libs3d/object_queue.c
===================================================================
--- trunk/libs3d/object_queue.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/object_queue.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -24,7 +24,7 @@
 
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
-#include &quot;proto.h&quot;	 
+#include &quot;proto.h&quot;
 #include &lt;stdlib.h&gt;	 /*  malloc(),free(), realloc() */
 
 #ifndef _POSIX_C_SOURCE
@@ -44,8 +44,10 @@
 static unsigned int *queue;			 	/*  the object id's */
 static int queue_size=0;			 	/*  the size of the object queue */
 static int requested;				 	/*  counter of how many addtional */
-									 	/*  objects have been requested */
-static struct timespec t={0,10*1000};	/* 10 micro seconds */
+/*  objects have been requested */
+static struct timespec t= {
+	0,10*1000
+};	/* 10 micro seconds */
 /*  initializes the object queue */
 int _queue_init()
 {
@@ -53,8 +55,7 @@
 	queue_size=1;
 	requested=0;
 	queue=malloc(sizeof(unsigned int)*queue_size);
-	for (i=0;i&lt;queue_size;i++)
-	{
+	for (i=0;i&lt;queue_size;i++) {
 		queue[i]=Q_UNUSED;
 	}
 	_queue_fill();
@@ -73,18 +74,17 @@
 int _queue_new_object(unsigned int oid)
 {
 	int i;
-/* 	s3dprintf(LOW,&quot;having a new object (%d) in the queue!!&quot;,oid); */
+	/* 	s3dprintf(LOW,&quot;having a new object (%d) in the queue!!&quot;,oid); */
 	for (i=0;i&lt;queue_size;i++)
-		if (queue[i]==Q_UNUSED)
-		{
-/* 			s3dprintf(LOW,&quot;placing it at position %d&quot;,i); */
+		if (queue[i]==Q_UNUSED) {
+			/* 			s3dprintf(LOW,&quot;placing it at position %d&quot;,i); */
 			queue[i]=oid;
 			requested--;
 			return(0);
 		}
 	if (queue_size==0) return(-1);  /*  already quit. */
-	 /*  if we reach here, all slots all taken.  */
-/* 	s3dprintf(LOW,&quot;no place for object, resizing stack.&quot;,i); */
+	/*  if we reach here, all slots all taken.  */
+	/* 	s3dprintf(LOW,&quot;no place for object, resizing stack.&quot;,i); */
 	queue=realloc(queue,sizeof(unsigned int)*(queue_size+1));
 	queue_size+=1;
 	requested--;
@@ -99,34 +99,31 @@
 	j=0;
 	do {
 		for (i=0;i&lt;queue_size;i++)
-			if (queue[i]!=Q_UNUSED)
-			{
+			if (queue[i]!=Q_UNUSED) {
 				ret=queue[i];
 				queue[i]=Q_UNUSED;
 				net_send(S3D_P_C_NEW_OBJ,NULL,0);  /*  we already can request a new one. */
 				return(ret);
 			}
-		 /*  if we reach this point, our queue is empty. */
-		 /*  as other request should have sent S3D_P_C_NEW_OBJ-requests,  */
-		 /*  we request one more object than needed to satisfy more load in future. */
+		/*  if we reach this point, our queue is empty. */
+		/*  as other request should have sent S3D_P_C_NEW_OBJ-requests,  */
+		/*  we request one more object than needed to satisfy more load in future. */
 		if (queue_size==0) return(-1);  /*  already quit. */
-		if (requested&lt;MAX_REQ)
-		{
+		if (requested&lt;MAX_REQ) {
 			net_send(S3D_P_C_NEW_OBJ,NULL,0);
 			requested++;
 		}
 		s3d_net_check();
-		nanosleep(&amp;t,NULL); 
-	} while(j++&lt;TIMEOUT);
+		nanosleep(&amp;t,NULL);
+	} while (j++&lt;TIMEOUT);
 
-	errds(LOW,&quot;_queue_want_object()&quot;,&quot;timeout is reached. server is extremly slow/laggy or dead&quot;);	
+	errds(LOW,&quot;_queue_want_object()&quot;,&quot;timeout is reached. server is extremly slow/laggy or dead&quot;);
 	return(-1);
 }
 /*  cleans up */
 int _queue_quit()
 {
-	if (queue!=NULL)
-	{
+	if (queue!=NULL) {
 		free(queue);
 		queue=NULL;
 	}

Modified: trunk/libs3d/proto_in.c
===================================================================
--- trunk/libs3d/proto_in.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/proto_in.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,142 +35,127 @@
 	struct s3d_evt *s3devt=NULL;
 	struct mcp_object *mo;
 	struct s3d_obj_info *oi;
-	switch (opcode)
-	{
-		case S3D_P_S_INIT:
-			s3dprintf(MED,&quot;S3D_P_S_INIT: init!!&quot;);
-			_s3d_ready=1;
-			break;
-		case S3D_P_S_QUIT:
-			s3dprintf(MED,&quot;S3D_P_S_QUIT: server wants us to go. well ...&quot;);
-			s3d_quit();
-			break;	
-		case S3D_P_S_CLICK:
-			if (length==4) 
-			{
-				oid=ntohl(*((uint32_t *)buf));
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-					*((uint32_t *)buf)=oid;  /*  reuse buffer ... */
-					s3devt-&gt;event=S3D_EVENT_OBJ_CLICK;
-					s3devt-&gt;length=4;
-					s3devt-&gt;buf=buf;
-				}
-				s3dprintf(MED,&quot;S3D_P_S_CLICK: %d got clicked ....&quot;,oid);
+	switch (opcode) {
+	case S3D_P_S_INIT:
+		s3dprintf(MED,&quot;S3D_P_S_INIT: init!!&quot;);
+		_s3d_ready=1;
+		break;
+	case S3D_P_S_QUIT:
+		s3dprintf(MED,&quot;S3D_P_S_QUIT: server wants us to go. well ...&quot;);
+		s3d_quit();
+		break;
+	case S3D_P_S_CLICK:
+		if (length==4) {
+			oid=ntohl(*((uint32_t *)buf));
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+				*((uint32_t *)buf)=oid;  /*  reuse buffer ... */
+				s3devt-&gt;event=S3D_EVENT_OBJ_CLICK;
+				s3devt-&gt;length=4;
+				s3devt-&gt;buf=buf;
 			}
-			break;
-		case S3D_P_S_NEWOBJ:
-			if (length==4) 
+			s3dprintf(MED,&quot;S3D_P_S_CLICK: %d got clicked ....&quot;,oid);
+		}
+		break;
+	case S3D_P_S_NEWOBJ:
+		if (length==4) {
+			oid=ntohl(*((uint32_t *)buf));
+			_queue_new_object(oid);
+			/*
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
 			{
-				oid=ntohl(*((uint32_t *)buf));
-				_queue_new_object(oid);	
-				/*
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * /
-					s3devt-&gt;event=S3D_EVENT_NEW_OBJECT;
-					s3devt-&gt;length=4;
-					s3devt-&gt;buf=buf;
-					_queue_new_object(*((unsigned int *)newevt-&gt;buf));	
-				}*/
-				s3dprintf(VLOW,&quot;S3D_P_S_NEWOBJ: new object %d&quot;,oid);
+				*((uint32_t *)buf)=oid;  / *  reuse buffer ... * /
+				s3devt-&gt;event=S3D_EVENT_NEW_OBJECT;
+				s3devt-&gt;length=4;
+				s3devt-&gt;buf=buf;
+				_queue_new_object(*((unsigned int *)newevt-&gt;buf));
+			}*/
+			s3dprintf(VLOW,&quot;S3D_P_S_NEWOBJ: new object %d&quot;,oid);
+		}
+		break;
+	case S3D_P_S_KEY:
+		if (length==8) {
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+				struct s3d_key_event *keyevent;
+				s3devt-&gt;length=2;
+				keyevent=(struct s3d_key_event *)buf;
+				keyevent-&gt;keysym=ntohs(keyevent-&gt;keysym);
+				keyevent-&gt;unicode=ntohs(keyevent-&gt;unicode);
+				keyevent-&gt;modifier=ntohs(keyevent-&gt;modifier);
+				keyevent-&gt;state=ntohs(keyevent-&gt;state);
+				s3devt-&gt;buf=buf;
+				s3devt-&gt;event=(keyevent-&gt;state==0)?S3D_EVENT_KEYDOWN:S3D_EVENT_KEYUP;
 			}
-			break;
-		case S3D_P_S_KEY:
-			if (length==8)
-			{
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-					struct s3d_key_event *keyevent;
-					s3devt-&gt;length=2;
-					keyevent=(struct s3d_key_event *)buf;
-					keyevent-&gt;keysym=ntohs(keyevent-&gt;keysym);
-					keyevent-&gt;unicode=ntohs(keyevent-&gt;unicode);
-					keyevent-&gt;modifier=ntohs(keyevent-&gt;modifier);
-					keyevent-&gt;state=ntohs(keyevent-&gt;state);
-					s3devt-&gt;buf=buf;
-					s3devt-&gt;event=(keyevent-&gt;state==0)?S3D_EVENT_KEYDOWN:S3D_EVENT_KEYUP;
-				}
-				s3dprintf(VLOW,&quot;S3D_P_S_KEY: key %d hit!!&quot;,*((uint16_t *)s3devt-&gt;buf));
+			s3dprintf(VLOW,&quot;S3D_P_S_KEY: key %d hit!!&quot;,*((uint16_t *)s3devt-&gt;buf));
+		}
+		break;
+	case S3D_P_S_MBUTTON:
+		if (length==2) {
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+				s3devt-&gt;event=S3D_EVENT_MBUTTON;
+				s3devt-&gt;length=2;
+				s3devt-&gt;buf=buf;
 			}
-			break;
-		case S3D_P_S_MBUTTON:
-			if (length==2)
-			{
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-					s3devt-&gt;event=S3D_EVENT_MBUTTON;
-					s3devt-&gt;length=2;
-					s3devt-&gt;buf=buf;
-				}
-				s3dprintf(VLOW,&quot;S3D_P_S_MBUTTON: mbutton %d, state %d !!&quot;,*((uint8_t *)s3devt-&gt;buf), *(1+(uint8_t *)s3devt-&gt;buf));
-			}
-			break;
-		case S3D_P_MCP_OBJECT:
-			if (length==sizeof(struct mcp_object))
-			{
-/* 				oid=htonl(*((uint32_t *)buf)); */
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-/* 					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
-					s3devt-&gt;event=S3D_MCP_OBJECT;
-					s3devt-&gt;length=length;
-					mo=(struct mcp_object *)buf;
-					*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
+			s3dprintf(VLOW,&quot;S3D_P_S_MBUTTON: mbutton %d, state %d !!&quot;,*((uint8_t *)s3devt-&gt;buf), *(1+(uint8_t *)s3devt-&gt;buf));
+		}
+		break;
+	case S3D_P_MCP_OBJECT:
+		if (length==sizeof(struct mcp_object)) {
+			/* 				oid=htonl(*((uint32_t *)buf)); */
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+				/* 					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
+				s3devt-&gt;event=S3D_MCP_OBJECT;
+				s3devt-&gt;length=length;
+				mo=(struct mcp_object *)buf;
+				*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
 
-					buf[length-1]='\0';  /*  put a null byte at the end  */
-										 /*  for the not so careful users */
-					s3devt-&gt;buf=buf;
-					s3dprintf(VLOW,&quot;S3D_P_MCP_OBEJCT: something is happening to object %d, name %s&quot;, 	mo-&gt;object, mo-&gt;name);
+				buf[length-1]='\0';  /*  put a null byte at the end  */
+				/*  for the not so careful users */
+				s3devt-&gt;buf=buf;
+				s3dprintf(VLOW,&quot;S3D_P_MCP_OBEJCT: something is happening to object %d, name %s&quot;, 	mo-&gt;object, mo-&gt;name);
 
-				}
-			} else s3dprintf(MED,&quot;wrong length for S3D_P_MCP_OBJECT length %d != %d&quot;,length,sizeof(struct mcp_object));
-			break;
-		case S3D_P_S_OINFO:
-			if (length==sizeof(struct s3d_obj_info))
-			{
-/* 				oid=htonl(*((uint32_t *)buf)); */
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-/* 					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
-					s3devt-&gt;event=S3D_EVENT_OBJ_INFO;
-					s3devt-&gt;length=length;
-					oi=(struct s3d_obj_info *)buf;
-					oi-&gt;object	=ntohl(oi-&gt;object);
-					oi-&gt;flags	=ntohl(oi-&gt;flags);
+			}
+		} else s3dprintf(MED,&quot;wrong length for S3D_P_MCP_OBJECT length %d != %d&quot;,length,sizeof(struct mcp_object));
+		break;
+	case S3D_P_S_OINFO:
+		if (length==sizeof(struct s3d_obj_info)) {
+			/* 				oid=htonl(*((uint32_t *)buf)); */
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+				/* 					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
+				s3devt-&gt;event=S3D_EVENT_OBJ_INFO;
+				s3devt-&gt;length=length;
+				oi=(struct s3d_obj_info *)buf;
+				oi-&gt;object	=ntohl(oi-&gt;object);
+				oi-&gt;flags	=ntohl(oi-&gt;flags);
 
-					buf[length-1]='\0';  /*  put a null byte at the end  */
-										 /*  for the not so careful users */
-					s3devt-&gt;buf=buf;
-					s3dprintf(VLOW,&quot;S3D_P_S_OINFO: something is happening to object %d, name %s&quot;, 
-								oi-&gt;object,
-								oi-&gt;name
-								);
+				buf[length-1]='\0';  /*  put a null byte at the end  */
+				/*  for the not so careful users */
+				s3devt-&gt;buf=buf;
+				s3dprintf(VLOW,&quot;S3D_P_S_OINFO: something is happening to object %d, name %s&quot;,
+				          oi-&gt;object,
+				          oi-&gt;name
+				         );
 
-				}
-			} else s3dprintf(MED,&quot;wrong length for S3D_P_S_OINFO length %d != %d&quot;,length,sizeof(struct s3d_obj_info));
-			break;
+			}
+		} else s3dprintf(MED,&quot;wrong length for S3D_P_S_OINFO length %d != %d&quot;,length,sizeof(struct s3d_obj_info));
+		break;
 
-		case S3D_P_MCP_DEL_OBJECT:
-			if (length==4)
-			{
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-					s3devt-&gt;event=S3D_MCP_DEL_OBJECT;
-					s3devt-&gt;length=length;
-					*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
-					s3dprintf(MED,&quot;S3D_P_MCP_DEL_OBEJCT: deleting object %d&quot;,*((uint32_t *)buf));
-					s3devt-&gt;buf=buf;
-				}
+	case S3D_P_MCP_DEL_OBJECT:
+		if (length==4) {
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+				s3devt-&gt;event=S3D_MCP_DEL_OBJECT;
+				s3devt-&gt;length=length;
+				*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
+				s3dprintf(MED,&quot;S3D_P_MCP_DEL_OBEJCT: deleting object %d&quot;,*((uint32_t *)buf));
+				s3devt-&gt;buf=buf;
 			}
-			break;
-		default:
-			s3dprintf(MED,&quot;don't know command %d&quot;,opcode);
-			if (buf!=NULL) free(buf);
+		}
+		break;
+	default:
+		s3dprintf(MED,&quot;don't know command %d&quot;,opcode);
+		if (buf!=NULL) free(buf);
 	}
-	if (s3devt!=NULL)
-	{
-			
+	if (s3devt!=NULL) {
+
 		s3d_push_event(s3devt);
 	}
 	return(0);

Modified: trunk/libs3d/proto_out.c
===================================================================
--- trunk/libs3d/proto_out.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/proto_out.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -31,9 +31,9 @@
 #include &lt;unistd.h&gt;		 /*  select() */
 #include &lt;stdlib.h&gt;		 /*  getenv(),atoi(), malloc() */
 #ifdef WIN32
-	#define uint32_t uint32_t  /*  sohn */
+#define uint32_t uint32_t  /*  sohn */
 #else
-	#include &lt;netdb.h&gt;		 /*  gethostbyname()  */
+#include &lt;netdb.h&gt;		 /*  gethostbyname()  */
 #endif
 
 #define MF_LEN	65530	 /*  maximum fragmentation length */
@@ -41,7 +41,7 @@
 int s3d_new_object()
 {
 	int oid;
-	
+
 	cb_lock++; /* please, no callbacks now. */
 	oid=_queue_want_object();
 	cb_lock--; /* no new callbacks and nothing happened */
@@ -63,7 +63,7 @@
 	buf[0]=htonl(oid);
 	buf[1]=htonl(toid);
 	net_send(S3D_P_C_CLONE,(char *)&amp;buf,8);
-/* 	s3dprintf(MED,&quot;... changed clone-target of object %d to %d&quot;, oid, toid); */
+	/* 	s3dprintf(MED,&quot;... changed clone-target of object %d to %d&quot;, oid, toid); */
 	return oid;
 }
 /*  deletes an object */
@@ -100,10 +100,14 @@
 	int					len=4+3*4;
 
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=x;					ptr+=sizeof(float);
-	*((float *)ptr)=y;					ptr+=sizeof(float);
-	*((float *)ptr)=z;					ptr+=sizeof(float);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=x;
+	ptr+=sizeof(float);
+	*((float *)ptr)=y;
+	ptr+=sizeof(float);
+	*((float *)ptr)=z;
+	ptr+=sizeof(float);
 	net_send(S3D_P_C_PUSH_VERTEX, buf, len);
 	return(0);
 }
@@ -118,11 +122,11 @@
 		return(-1);
 	stepl=((int)((MF_LEN-4)/(4*3)))*(4*3);
 	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
-/* 	buf=malloc(f&gt;1?MF_LEN:len+4); */
-	for (i=0;i&lt;f;i++)
-	{
+	/* 	buf=malloc(f&gt;1?MF_LEN:len+4); */
+	for (i=0;i&lt;f;i++) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
 		if (len-i*stepl&gt;stepl)
 			flen=stepl;
 		else
@@ -130,65 +134,91 @@
 		memcpy(ptr,(char *)vbuf+i*stepl,flen);
 		net_send(S3D_P_C_PUSH_VERTEX,buf,flen+4);
 	}
-/* 	free(buf); */
+	/* 	free(buf); */
 	return(0);
 }
 
 /*  pushes a new material onto the stack */
 /*  a vectored version of this would be wise ... */
-int s3d_push_material( int object, 
-						float amb_r, float amb_g, float amb_b,
-						float spec_r, float spec_g, float spec_b,
-						float diff_r, float diff_g, float diff_b
-						)
+int s3d_push_material( int object,
+                       float amb_r, float amb_g, float amb_b,
+                       float spec_r, float spec_g, float spec_b,
+                       float diff_r, float diff_g, float diff_b
+                     )
 {
 	char				buf[4+4*12];
 	char				*ptr;
 	int					len=4+4*12;
-/* 	s3dprintf(LOW, &quot;adding a new material...&quot;); */
+	/* 	s3dprintf(LOW, &quot;adding a new material...&quot;); */
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;				ptr+=sizeof(float);
-	*((float *)ptr)=1.0;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;				ptr+=sizeof(float);
-	*((float *)ptr)=1.0;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;				ptr+=sizeof(float);
-	*((float *)ptr)=1.0;				ptr+=sizeof(float);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=amb_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=1.0;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=1.0;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=1.0;
+	ptr+=sizeof(float);
 
 	net_send(S3D_P_C_PUSH_MAT,buf,len);
 	return(0);  /*  nothing yet */
 }
 /*  same as s3d_push_material, but with values for alpha */
-int s3d_push_material_a( int object, 
-						float amb_r, float amb_g, float amb_b, float amb_a,
-						float spec_r, float spec_g, float spec_b, float spec_a,
-						float diff_r, float diff_g, float diff_b, float diff_a
-						)
+int s3d_push_material_a( int object,
+                         float amb_r, float amb_g, float amb_b, float amb_a,
+                         float spec_r, float spec_g, float spec_b, float spec_a,
+                         float diff_r, float diff_g, float diff_b, float diff_a
+                       )
 {
 	char				buf[4+4*12];
 	char				*ptr;
 	int					len=4+4*12;
-/* 	s3dprintf(LOW, &quot;adding a new material...&quot;); */
+	/* 	s3dprintf(LOW, &quot;adding a new material...&quot;); */
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_a;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_a;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_a;				ptr+=sizeof(float);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=amb_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_a;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_a;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_a;
+	ptr+=sizeof(float);
 
 	net_send(S3D_P_C_PUSH_MAT,buf,len);
 	return(0);  /*  nothing yet */
@@ -203,11 +233,11 @@
 		return(-1);
 	stepl=((int)((MF_LEN-4)/(4*12)))*(4*12);
 	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
-/* 	buf=malloc(f&gt;1?MF_LEN:len+4); */
-	for (i=0;i&lt;f;i++)
-	{
+	/* 	buf=malloc(f&gt;1?MF_LEN:len+4); */
+	for (i=0;i&lt;f;i++) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
 		if (len-i*stepl&gt;stepl)
 			flen=stepl;
 		else
@@ -215,7 +245,7 @@
 		memcpy(ptr,(char *)mbuf+i*stepl,flen);
 		net_send(S3D_P_C_PUSH_MAT,buf,flen+4);
 	}
-/* 	free(buf); */
+	/* 	free(buf); */
 	return(0);
 }
 int s3d_push_polygon(int object, uint32_t v1, uint32_t v2, uint32_t v3, uint32_t material)
@@ -223,11 +253,16 @@
 	char				buf[4+4*4],*ptr;
 	int					len=4+4*4;
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(v1);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v2);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v3);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(material);			ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint32_t *)ptr)=htonl(v1);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(v2);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(v3);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(material);
+	ptr+=sizeof(uint32_t);
 
 	net_send(S3D_P_C_PUSH_POLY,buf,len);
 	return(0);
@@ -237,10 +272,14 @@
 	char				buf[4+3*4],*ptr;
 	int					len=4+3*4;
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(v1);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v2);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(material);			ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint32_t *)ptr)=htonl(v1);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(v2);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(material);
+	ptr+=sizeof(uint32_t);
 
 	net_send(S3D_P_C_PUSH_LINE,buf,len);
 	return(0);
@@ -261,8 +300,7 @@
 
 	buf[0]=htonl(object);
 	d=buf+1;
-	for (i=0;i&lt;f;i++)
-	{
+	for (i=0;i&lt;f;i++) {
 		if (len-i*stepl&gt;stepl)			flen=stepl;
 		else							flen=(len-i*stepl);
 
@@ -287,8 +325,7 @@
 	buf[0]=htonl(object);
 	d=buf+1;
 
-	for (i=0;i&lt;f;i++)
-	{
+	for (i=0;i&lt;f;i++) {
 		if (len-i*stepl&gt;stepl)			flen=stepl;
 		else							flen=(len-i*stepl);
 
@@ -305,9 +342,11 @@
 	char				buf[4+2*2],*ptr;
 	int					len=4+2*2;
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint16_t *)ptr)=htons(w);				ptr+=sizeof(uint16_t);
-	*((uint16_t *)ptr)=htons(h);				
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint16_t *)ptr)=htons(w);
+	ptr+=sizeof(uint16_t);
+	*((uint16_t *)ptr)=htons(h);
 
 	net_send(S3D_P_C_PUSH_TEX,buf,len);
 	return(0);
@@ -327,8 +366,7 @@
 	*((uint32_t *)buf)=htonl(object);
 	d=(uint16_t *)(buf+1);
 
-	for (i=0;i&lt;f;i++)
-	{
+	for (i=0;i&lt;f;i++) {
 		if (len-i*stepl&gt;stepl)			flen=stepl;
 		else							flen=(len-i*stepl);
 
@@ -349,7 +387,7 @@
 	buf[1]=htonl(n);
 	net_send(S3D_P_C_DEL_VERTEX,(char *)buf,4*2);
 	return(0);
-	
+
 }
 /*  delete n materials */
 int s3d_pop_material(int object, uint32_t n)
@@ -359,7 +397,7 @@
 	buf[1]=htonl(n);
 	net_send(S3D_P_C_DEL_MAT,(char *)buf,4*2);
 	return(0);
-	
+
 }
 /*  delete n polygons */
 int s3d_pop_polygon(int object, uint32_t n)
@@ -369,7 +407,7 @@
 	buf[1]=htonl(n);
 	net_send(S3D_P_C_DEL_POLY,(char *)buf,4*2);
 	return(0);
-	
+
 }
 /*  delete n lines */
 int s3d_pop_line(int object, uint32_t n)
@@ -379,7 +417,7 @@
 	buf[1]=htonl(n);
 	net_send(S3D_P_C_DEL_LINE,(char *)buf,4*2);
 	return(0);
-	
+
 }
 /*  delete n polygons */
 int s3d_pop_texture(int object, uint32_t n)
@@ -389,64 +427,90 @@
 	buf[1]=htonl(n);
 	net_send(S3D_P_C_DEL_TEX,(char *)buf,4*2);
 	return(0);
-	
+
 }
 /*  pepping/loading functions */
 
 /*  overwrites the last material with this one */
-int s3d_pep_material( int object, 
-						float amb_r, float amb_g, float amb_b,
-						float spec_r, float spec_g, float spec_b,
-						float diff_r, float diff_g, float diff_b
-						)
+int s3d_pep_material( int object,
+                      float amb_r, float amb_g, float amb_b,
+                      float spec_r, float spec_g, float spec_b,
+                      float diff_r, float diff_g, float diff_b
+                    )
 {
 	char				buf[4+4*12];
 	char				*ptr;
 	int					len=4+4*12;
-/* 	s3dprintf(LOW, &quot;adding a new material...&quot;); */
+	/* 	s3dprintf(LOW, &quot;adding a new material...&quot;); */
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;				ptr+=sizeof(float);
-	*((float *)ptr)=1.0;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;				ptr+=sizeof(float);
-	*((float *)ptr)=1.0;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;				ptr+=sizeof(float);
-	*((float *)ptr)=1.0;				ptr+=sizeof(float);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=amb_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=1.0;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=1.0;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=1.0;
+	ptr+=sizeof(float);
 
 	net_send(S3D_P_C_PEP_MAT,buf,len);
 	return(0);  /*  nothing yet */
 }
 /*  same as above, with alpha */
-int s3d_pep_material_a( int object, 
-						float amb_r, float amb_g, float amb_b, float amb_a,
-						float spec_r, float spec_g, float spec_b, float spec_a,
-						float diff_r, float diff_g, float diff_b, float diff_a
-						)
+int s3d_pep_material_a( int object,
+                        float amb_r, float amb_g, float amb_b, float amb_a,
+                        float spec_r, float spec_g, float spec_b, float spec_a,
+                        float diff_r, float diff_g, float diff_b, float diff_a
+                      )
 {
 	char				buf[4+4*12];
 	char				*ptr;
 	int					len=4+4*12;
-/* 	s3dprintf(LOW, &quot;adding a new material...&quot;); */
+	/* 	s3dprintf(LOW, &quot;adding a new material...&quot;); */
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_a;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_a;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_a;				ptr+=sizeof(float);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=amb_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_a;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_a;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_a;
+	ptr+=sizeof(float);
 
 	net_send(S3D_P_C_PEP_MAT,buf,len);
 	return(0);  /*  nothing yet */
@@ -454,8 +518,7 @@
 int s3d_pep_materials_a(int object, float *mbuf, uint16_t n)
 {
 	char				buf[MF_LEN+4];
-	if ((n*12*sizeof(float)+4)&gt;MF_LEN)
-	{
+	if ((n*12*sizeof(float)+4)&gt;MF_LEN) {
 		errds(MED,&quot;s3d_pep_materials_a()&quot;,&quot;too much data&quot;);
 		return(-1);  /*  impossible */
 	}
@@ -469,8 +532,7 @@
 int s3d_pep_polygon_normals(int object, float *nbuf,uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
-	if ((n*9*sizeof(float)+4)&gt;MF_LEN) 
-	{
+	if ((n*9*sizeof(float)+4)&gt;MF_LEN) {
 		errds(MED,&quot;s3d_pep_polygon_normals()&quot;,&quot;too much data&quot;);
 		return(-1);  /*  impossible */
 	}
@@ -478,14 +540,13 @@
 	memcpy(buf+4,nbuf,9*n*sizeof(float));
 	net_send(S3D_P_C_PEP_POLY_NORMAL,(char *)buf,n*9*sizeof(float)+4);
 	return(0);
-	
+
 }
 /*  adds normal information to the last n line. */
 int s3d_pep_line_normals(int object, float *nbuf,uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
-	if ((n*9*sizeof(float)+4)&gt;MF_LEN) 
-	{
+	if ((n*9*sizeof(float)+4)&gt;MF_LEN) {
 		errds(MED,&quot;s3d_pep_line_normals()&quot;,&quot;too much data&quot;);
 		return(-1);  /*  impossible */
 	}
@@ -493,7 +554,7 @@
 	memcpy(buf+4,nbuf,6*n*sizeof(float));
 	net_send(S3D_P_C_PEP_LINE_NORMAL,(char *)buf,n*6*sizeof(float)+4);
 	return(0);
-	
+
 }
 /*  replaces the last vertex. */
 int s3d_pep_vertex(int object, float x, float y, float z)
@@ -502,10 +563,14 @@
 	int					len=4+3*4;
 
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=x;					ptr+=sizeof(float);
-	*((float *)ptr)=y;					ptr+=sizeof(float);
-	*((float *)ptr)=z;					ptr+=sizeof(float);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=x;
+	ptr+=sizeof(float);
+	*((float *)ptr)=y;
+	ptr+=sizeof(float);
+	*((float *)ptr)=z;
+	ptr+=sizeof(float);
 	net_send(S3D_P_C_PEP_VERTEX, buf, len);
 	return(0);
 }
@@ -515,10 +580,14 @@
 	char				buf[4+3*4],*ptr;
 	int					len=4+3*4;
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(v1);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v2);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(material);			ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint32_t *)ptr)=htonl(v1);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(v2);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(material);
+	ptr+=sizeof(uint32_t);
 
 	net_send(S3D_P_C_PEP_LINE,buf,len);
 	return(0);
@@ -530,8 +599,7 @@
 {
 	uint32_t 	buf[MF_LEN+4];
 	int				i;
-	if ((n*3*4+4)&gt;MF_LEN) 
-	{
+	if ((n*3*4+4)&gt;MF_LEN) {
 		errds(MED,&quot;s3d_pep_lines()&quot;,&quot;too much data&quot;);
 		return(-1);  /*  impossible */
 	}
@@ -540,14 +608,13 @@
 		buf[i+1]=htonl(lbuf[0]);
 	net_send(S3D_P_C_PEP_LINE, (char *)buf,n*3*4+4);
 	return(0);
-	
+
 }
 /*  replaces the last n vertices. */
 int s3d_pep_vertices(int object, float *vbuf,uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
-	if ((n*3*sizeof(float)+4)&gt;MF_LEN) 
-	{
+	if ((n*3*sizeof(float)+4)&gt;MF_LEN) {
 		errds(MED,&quot;s3d_pep_vertices()&quot;,&quot;too much data&quot;);
 		return(-1);  /*  impossible */
 	}
@@ -555,20 +622,27 @@
 	memcpy(buf+4,vbuf,3*n*sizeof(float));
 	net_send(S3D_P_C_PEP_VERTEX,(char *)buf,n*3*sizeof(float)+4);
 	return(0);
-	
+
 }
 /*  peps the last polygon with some texture coords */
 int s3d_pep_polygon_tex_coord(int object, float x1, float y1, float x2, float y2, float x3, float y3)
 {
 	char *ptr,buf[4*6+4];
 	ptr=buf;
-	*((uint32_t *)buf)=htonl(object);		ptr+=4;
-	*((float *)ptr)=x1;						ptr+=4;
-	*((float *)ptr)=y1;						ptr+=4;
-	*((float *)ptr)=x2;						ptr+=4;
-	*((float *)ptr)=y2;						ptr+=4;
-	*((float *)ptr)=x3;						ptr+=4;
-	*((float *)ptr)=y3;						ptr+=4;
+	*((uint32_t *)buf)=htonl(object);
+	ptr+=4;
+	*((float *)ptr)=x1;
+	ptr+=4;
+	*((float *)ptr)=y1;
+	ptr+=4;
+	*((float *)ptr)=x2;
+	ptr+=4;
+	*((float *)ptr)=y2;
+	ptr+=4;
+	*((float *)ptr)=x3;
+	ptr+=4;
+	*((float *)ptr)=y3;
+	ptr+=4;
 	net_send(S3D_P_C_PEP_POLY_TEXC,(char *)buf,6*4+4);
 	return(0);
 }
@@ -576,8 +650,7 @@
 int s3d_pep_polygon_tex_coords(int object, float *tbuf,uint16_t n)
 {
 	char buf[MF_LEN+4];
-	if ((n*6*sizeof(float))&gt;MF_LEN) 
-	{
+	if ((n*6*sizeof(float))&gt;MF_LEN) {
 		errds(MED,&quot;s3d_pep_polygon_tex_coords()&quot;,&quot;too much data&quot;);
 		return(-1);  /*  impossible */
 	}
@@ -598,11 +671,12 @@
 	mstart=start;
 	stepl=((int)((MF_LEN-8)/(9*4)))*(9*4);
 	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i&lt;f;i++)
-	{
+	for (i=0;i&lt;f;i++) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);			ptr+=sizeof(uint32_t);		  /*  start */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(mstart);
+		ptr+=sizeof(uint32_t);		  /*  start */
 		if (len-i*stepl&gt;stepl)
 			flen=stepl;
 		else
@@ -625,11 +699,12 @@
 	mstart=start;
 	stepl=((int)((MF_LEN-8)/(6*4)))*(6*4);
 	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i&lt;f;i++)
-	{
+	for (i=0;i&lt;f;i++) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);			ptr+=sizeof(uint32_t);		  /*  start */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(mstart);
+		ptr+=sizeof(uint32_t);		  /*  start */
 		if (len-i*stepl&gt;stepl)
 			flen=stepl;
 		else
@@ -652,11 +727,12 @@
 	mstart=start;
 	stepl=((int)((MF_LEN-8)/(6*4)))*(6*4);
 	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i&lt;f;i++)
-	{
+	for (i=0;i&lt;f;i++) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);			ptr+=sizeof(uint32_t);		  /*  start */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(mstart);
+		ptr+=sizeof(uint32_t);		  /*  start */
 		if (len-i*stepl&gt;stepl)
 			flen=stepl;
 		else
@@ -679,11 +755,12 @@
 	mstart=start;
 	stepl=((int)((MF_LEN-8)/(12*4)))*(12*4);
 	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i&lt;f;i++)
-	{
+	for (i=0;i&lt;f;i++) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);			ptr+=sizeof(uint32_t);		  /*  start */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(mstart);
+		ptr+=sizeof(uint32_t);		  /*  start */
 		if (len-i*stepl&gt;stepl)
 			flen=stepl;
 		else
@@ -698,8 +775,10 @@
 {
 	char				buf[4*2],*ptr;
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(tex);				ptr+=sizeof(uint32_t);		 	 /*  texture index numer */
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint32_t *)ptr)=htonl(tex);
+	ptr+=sizeof(uint32_t);		 	 /*  texture index numer */
 	net_send(S3D_P_C_PEP_MAT_TEX,buf,8);
 	return(0);
 }
@@ -711,17 +790,22 @@
 	linestep=(MF_LEN-16)/(w*4);
 	if (linestep==0)
 		return(-1);  /*  won't do that. .. yet */
-	for (i=0;i&lt;h;i+=linestep)
-	{
+	for (i=0;i&lt;h;i+=linestep) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(tex);				ptr+=sizeof(uint32_t);		  /*  texture number */
-		*((uint16_t *)ptr)=htons(xpos);				ptr+=sizeof(uint16_t);		  /*  xpos */
-		*((uint16_t *)ptr)=htons(ypos+i);			ptr+=sizeof(uint16_t);		  /*  ypos */
-		*((uint16_t *)ptr)=htons(w);				ptr+=sizeof(uint16_t);		  /*  width */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(tex);
+		ptr+=sizeof(uint32_t);		  /*  texture number */
+		*((uint16_t *)ptr)=htons(xpos);
+		ptr+=sizeof(uint16_t);		  /*  xpos */
+		*((uint16_t *)ptr)=htons(ypos+i);
+		ptr+=sizeof(uint16_t);		  /*  ypos */
+		*((uint16_t *)ptr)=htons(w);
+		ptr+=sizeof(uint16_t);		  /*  width */
 		if ((h-i)&gt;linestep)		lines=linestep;
 		else					lines=h-i;
-		*((uint16_t *)ptr)=htons(lines);			ptr+=sizeof(uint16_t);		  /*  height */
+		*((uint16_t *)ptr)=htons(lines);
+		ptr+=sizeof(uint16_t);		  /*  height */
 		memcpy(ptr,data+(i*w*4),lines*w*4);
 		net_send(S3D_P_C_LOAD_TEX,buf,16+lines*w*4);
 	}
@@ -732,10 +816,13 @@
 	char				buf[4+1+4],*ptr;
 	int					len=4+1+4;
 	ptr=buf;
-/* 	s3dprintf(VLOW, &quot;toggling flags on .. %010x&quot;, flags); */
-	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
-	*ptr=OF_TURN_ON;							ptr+=1;
-	*((uint32_t *)ptr)=htonl(flags);			ptr+=4;		
+	/* 	s3dprintf(VLOW, &quot;toggling flags on .. %010x&quot;, flags); */
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=4;
+	*ptr=OF_TURN_ON;
+	ptr+=1;
+	*((uint32_t *)ptr)=htonl(flags);
+	ptr+=4;
 	net_send(S3D_P_C_TOGGLE_FLAGS,buf,len);
 	return(0);
 }
@@ -744,10 +831,13 @@
 	char				buf[4+1+4],*ptr;
 	int					len=4+1+4;
 	ptr=buf;
-/* 	s3dprintf(VLOW, &quot;toggling flags off .. %010x&quot;, flags); */
-	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
-	*ptr=OF_TURN_OFF;							ptr+=1;
-	*((uint32_t *)ptr)=htonl(flags);			ptr+=4;		 
+	/* 	s3dprintf(VLOW, &quot;toggling flags off .. %010x&quot;, flags); */
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=4;
+	*ptr=OF_TURN_OFF;
+	ptr+=1;
+	*((uint32_t *)ptr)=htonl(flags);
+	ptr+=4;
 	net_send(S3D_P_C_TOGGLE_FLAGS,buf,len);
 	return(0);
 }
@@ -756,10 +846,13 @@
 	char				buf[4+4*3],*ptr;
 	int					len=4+4*3;
 	ptr=buf;
-/* 	s3dprintf(VLOW, &quot;translating object to  .. %f, %f, %f&quot;, x,y,z); */
-	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
-	*((float *)ptr)=x;							ptr+=4;
-	*((float *)ptr)=y;							ptr+=4;
+	/* 	s3dprintf(VLOW, &quot;translating object to  .. %f, %f, %f&quot;, x,y,z); */
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=4;
+	*((float *)ptr)=x;
+	ptr+=4;
+	*((float *)ptr)=y;
+	ptr+=4;
 	*((float *)ptr)=z;
 	net_send(S3D_P_C_TRANSLATE,buf,len);
 	return(0);
@@ -771,10 +864,13 @@
 	char				buf[4+4*3],*ptr;
 	int					len=4+4*3;
 	ptr=buf;
-/* 	s3dprintf(VLOW, &quot;rotating object to  .. %f, %f, %f&quot;, x,y,z); */
-	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
-	*((float *)ptr)=x;							ptr+=4;
-	*((float *)ptr)=y;							ptr+=4;
+	/* 	s3dprintf(VLOW, &quot;rotating object to  .. %f, %f, %f&quot;, x,y,z); */
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=4;
+	*((float *)ptr)=x;
+	ptr+=4;
+	*((float *)ptr)=y;
+	ptr+=4;
 	*((float *)ptr)=z;
 	net_send(S3D_P_C_ROTATE,buf,len);
 	return(0);
@@ -786,8 +882,9 @@
 	char				buf[4+4],*ptr;
 	int					len=4+4;
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
-	*((float *)ptr)=s;						
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=4;
+	*((float *)ptr)=s;
 	net_send(S3D_P_C_SCALE,buf,len);
 	return(0);
 }

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/s3d.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -53,16 +53,14 @@
 #define	S3D_OF_VISIBLE			0x00000001
 #define	S3D_OF_SELECTABLE		0x00000002
 #define S3D_OF_POINTABLE		0x00000004
-struct mcp_object
-{
+struct mcp_object {
 	uint32_t object;
 	float trans_x,trans_y,trans_z;
 	float r;
 #define MCP_NEW_OBJECT	1
 	char name[256];
 };
-struct s3d_obj_info
-{
+struct s3d_obj_info {
 	uint32_t object;
 	uint32_t flags;
 	float trans_x,trans_y,trans_z;
@@ -71,13 +69,11 @@
 	float r;
 	char name[256];
 };
-struct s3d_but_info
-{
+struct s3d_but_info {
 	uint8_t button; /* 0 = left, 1 = middle, 2 = right */
 	uint8_t state;  /* 0 = down, 1 = up, 2 = moving */
 };
-struct s3d_key_event
-{
+struct s3d_key_event {
 	uint16_t keysym;		/* the symbol, use this with s3d_keysym.h */
 	uint16_t unicode;		/* the unicode or &quot;actually typed&quot; character */
 	uint16_t modifier;	/* any modifiers involved */
@@ -97,22 +93,22 @@
 int s3d_push_vertex(int object, float x, float y, float z);
 int s3d_push_vertices(int object, float *vbuf, uint16_t n);
 int s3d_push_material( int object,
-						float amb_r, float amb_g, float amb_b,
-						float spec_r, float spec_g, float spec_b,
-						float diff_r, float diff_g, float diff_b);
+                       float amb_r, float amb_g, float amb_b,
+                       float spec_r, float spec_g, float spec_b,
+                       float diff_r, float diff_g, float diff_b);
 int s3d_pep_material( int object,
-						float amb_r, float amb_g, float amb_b,
-						float spec_r, float spec_g, float spec_b,
-						float diff_r, float diff_g, float diff_b);
+                      float amb_r, float amb_g, float amb_b,
+                      float spec_r, float spec_g, float spec_b,
+                      float diff_r, float diff_g, float diff_b);
 int s3d_push_material_a( int object,
-						float amb_r, float amb_g, float amb_b, float amb_a,
-						float spec_r, float spec_g, float spec_b, float spec_a,
-						float diff_r, float diff_g, float diff_b, float diff_a);
+                         float amb_r, float amb_g, float amb_b, float amb_a,
+                         float spec_r, float spec_g, float spec_b, float spec_a,
+                         float diff_r, float diff_g, float diff_b, float diff_a);
 int s3d_push_materials_a(int object, float *mbuf, uint16_t n);
 int s3d_pep_material_a( int object,
-						float amb_r, float amb_g, float amb_b, float amb_a,
-						float spec_r, float spec_g, float spec_b, float spec_a,
-						float diff_r, float diff_g, float diff_b, float diff_a);
+                        float amb_r, float amb_g, float amb_b, float amb_a,
+                        float spec_r, float spec_g, float spec_b, float spec_a,
+                        float diff_r, float diff_g, float diff_b, float diff_a);
 
 int s3d_pep_materials_a(int object, float *mbuf, uint16_t n);
 int s3d_load_materials_a(int object, float *mbuf, uint32_t start, uint16_t n);

Modified: trunk/libs3d/s3d_keysym.h
===================================================================
--- trunk/libs3d/s3d_keysym.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/s3d_keysym.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -6,17 +6,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -32,7 +32,7 @@
    as international virtual keycodes.  We'll follow in the footsteps of X11...
    The names of the keys
  */
- 
+
 typedef enum {
 	/* The keyboard syms have been cleverly chosen to map to ASCII */
 	S3DK_UNKNOWN		= 0,
@@ -75,7 +75,7 @@
 	S3DK_GREATER		= 62,
 	S3DK_QUESTION		= 63,
 	S3DK_AT			= 64,
-	/* 
+	/*
 	   Skip uppercase letters
 	 */
 	S3DK_LEFTBRACKET	= 91,

Modified: trunk/libs3d/s3dlib.h
===================================================================
--- trunk/libs3d/s3dlib.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/s3dlib.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -24,21 +24,21 @@
 
 #include &lt;stdint.h&gt;
 #include &quot;config.h&quot;
-#ifdef __APPLE__ 
+#ifdef __APPLE__
 #ifdef SHM
 #undef SHM
 #endif
-#endif 
+#endif
 
 #ifndef S3DUNUSED
-	#if defined(UNUSEDPARAM_ATTRIBUTE)
-		#define S3DUNUSED(x) (x)__attribute__((unused))
-	#elif defined(UNUSEDPARAM_OMIT)
-		#define S3DUNUSED(x) /* x */
-	#else
-		#define S3DUNUSED(x) x
-	#endif
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define S3DUNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define S3DUNUSED(x) /* x */
+#else
+#define S3DUNUSED(x) x
 #endif
+#endif
 
 #define VLOW	1
 #define	LOW		2
@@ -54,7 +54,7 @@
 #define TIMEOUT			100000
 #define MAX_CB			256		 /*  as much as there are callbacks */
 #ifndef NULL
-	#define NULL	0
+#define NULL	0
 #endif
 #define CON_NULL	0
 #define CON_SHM		1
@@ -76,13 +76,13 @@
 #pragma GCC visibility push(default) /* Only export following functions */
 #endif
 void s3dprintf(int relevance, const char *fmt, ...);
-void errdn(int relevance, char *func,int en); 
+void errdn(int relevance, char *func,int en);
 void errds(int relevance,char *func, const char *fmt, ...);
 #ifdef HAVE_GCCVISIBILITY
 #pragma GCC visibility pop
 #endif
 
-#else 
+#else
 static __inline__ void s3dprintf(int S3DUNUSED(relevance),
                                  const char *S3DUNUSED(fmt), ...) {}
 static __inline__ void errdn(int S3DUNUSED(relevance),
@@ -117,8 +117,7 @@
 #endif
 /* shm_ringbuf.c */
 #ifdef SHM
-struct buf_t
-{
+struct buf_t {
 	uint32_t start,end,bufsize;	/* start/end of the data */
 };
 int shm_write(struct buf_t *rb,char *buf, int n);
@@ -131,8 +130,7 @@
 int shm_readn(char *str,int s);
 #endif
 /* freetype.c */
-struct t_buf
-{
+struct t_buf {
 	float *vbuf;
 	uint32_t *pbuf;
 	int pn,vn;
@@ -140,8 +138,7 @@
 };
 
 /* tesselate.c */
-struct tessp_t
-{
+struct tessp_t {
 	int next,prev,done;
 };
 int _s3d_tesselate(struct tessp_t *t,struct t_buf *b);

Modified: trunk/libs3d/sei_construct.c
===================================================================
--- trunk/libs3d/sei_construct.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/sei_construct.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,9 +1,9 @@
 /*
  * sei_construct.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
- * for public domain: 
+ * for public domain:
  * &lt;snip&gt;
  *
  * This code is in the public domain. Specifically, we give to the public
@@ -20,17 +20,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -52,126 +52,118 @@
 /* Return a new node to be added into the query tree */
 static int newnode()
 {
-  if (q_idx &lt; QSIZE)
-    return q_idx++;
-  else
-    {
-      errs(&quot;sei:newnode()&quot;,&quot;Query-table overflow&quot;);
-      return -1;
-    }
+	if (q_idx &lt; QSIZE)
+		return q_idx++;
+	else {
+		errs(&quot;sei:newnode()&quot;,&quot;Query-table overflow&quot;);
+		return -1;
+	}
 }
 
 /* Return a free trapezoid */
 static int newtrap()
 {
-  if (tr_idx &lt; TRSIZE)
-    {
-      tr[tr_idx].lseg = -1;
-      tr[tr_idx].rseg = -1;
-      tr[tr_idx].state = ST_VALID;
-      return tr_idx++;
-    }
-  else
-    {
-      errs(&quot;sei:newtrap()&quot;,&quot;Trapezoid-table overflow&quot;);
-      return -1;
-    }
+	if (tr_idx &lt; TRSIZE) {
+		tr[tr_idx].lseg = -1;
+		tr[tr_idx].rseg = -1;
+		tr[tr_idx].state = ST_VALID;
+		return tr_idx++;
+	} else {
+		errs(&quot;sei:newtrap()&quot;,&quot;Trapezoid-table overflow&quot;);
+		return -1;
+	}
 }
 
 
 /* Return the maximum of the two points into the yval structure */
 static int _max(yval, v0, v1)
-     point_t *yval;
-     point_t *v0;
-     point_t *v1;
+point_t *yval;
+point_t *v0;
+point_t *v1;
 {
-  if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
-    *yval = *v0;
-  else if (FP_EQUAL(v0-&gt;y, v1-&gt;y))
-    {
-      if (v0-&gt;x &gt; v1-&gt;x + C_EPS)
-	*yval = *v0;
-      else
-	*yval = *v1;
-    }
-  else
-    *yval = *v1;
-  
-  return 0;
+	if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
+		*yval = *v0;
+	else if (FP_EQUAL(v0-&gt;y, v1-&gt;y)) {
+		if (v0-&gt;x &gt; v1-&gt;x + C_EPS)
+			*yval = *v0;
+		else
+			*yval = *v1;
+	} else
+		*yval = *v1;
+
+	return 0;
 }
 
 
 /* Return the minimum of the two points into the yval structure */
 static int _min(yval, v0, v1)
-     point_t *yval;
-     point_t *v0;
-     point_t *v1;
+point_t *yval;
+point_t *v0;
+point_t *v1;
 {
-  if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
-    *yval = *v0;
-  else if (FP_EQUAL(v0-&gt;y, v1-&gt;y))
-    {
-      if (v0-&gt;x &lt; v1-&gt;x)
-	*yval = *v0;
-      else
-	*yval = *v1;
-    }
-  else
-    *yval = *v1;
-  
-  return 0;
+	if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
+		*yval = *v0;
+	else if (FP_EQUAL(v0-&gt;y, v1-&gt;y)) {
+		if (v0-&gt;x &lt; v1-&gt;x)
+			*yval = *v0;
+		else
+			*yval = *v1;
+	} else
+		*yval = *v1;
+
+	return 0;
 }
 
 
 int _greater_than(v0, v1)
-     point_t *v0;
-     point_t *v1;
+point_t *v0;
+point_t *v1;
 {
-  if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
-    return TRUE;
-  else if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
-    return FALSE;
-  else
-    return (v0-&gt;x &gt; v1-&gt;x);
+	if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
+		return TRUE;
+	else if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
+		return FALSE;
+	else
+		return (v0-&gt;x &gt; v1-&gt;x);
 }
 
 
 int _equal_to(v0, v1)
-     point_t *v0;
-     point_t *v1;
+point_t *v0;
+point_t *v1;
 {
-  return (FP_EQUAL(v0-&gt;y, v1-&gt;y) &amp;&amp; FP_EQUAL(v0-&gt;x, v1-&gt;x));
+	return (FP_EQUAL(v0-&gt;y, v1-&gt;y) &amp;&amp; FP_EQUAL(v0-&gt;x, v1-&gt;x));
 }
 
 int _greater_than_equal_to(v0, v1)
-     point_t *v0;
-     point_t *v1;
+point_t *v0;
+point_t *v1;
 {
-  if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
-    return TRUE;
-  else if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
-    return FALSE;
-  else
-    return (v0-&gt;x &gt;= v1-&gt;x);
+	if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
+		return TRUE;
+	else if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
+		return FALSE;
+	else
+		return (v0-&gt;x &gt;= v1-&gt;x);
 }
 
 int _less_than(v0, v1)
-     point_t *v0;
-     point_t *v1;
+point_t *v0;
+point_t *v1;
 {
-  if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
-    return TRUE;
-  else if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
-    return FALSE;
-  else
-    return (v0-&gt;x &lt; v1-&gt;x);
+	if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
+		return TRUE;
+	else if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
+		return FALSE;
+	else
+		return (v0-&gt;x &lt; v1-&gt;x);
 }
 
 
-/* Initilialise the query structure (Q) and the trapezoid table (T) 
+/* Initilialise the query structure (Q) and the trapezoid table (T)
  * when the first segment is added to start the trapezoidation. The
  * query-tree starts out with 4 trapezoids, one S-node and 2 Y-nodes
- *    
+ *
  *                4
  *   -----------------------------------
  *  		  \
@@ -182,79 +174,79 @@
  */
 
 static int init_query_structure(segnum)
-     int segnum;
+int segnum;
 {
-  int i1, i2, i3, i4, i5, i6, i7, root;
-  int t1, t2, t3, t4;
-  segment_t *s = &amp;seg[segnum];
+	int i1, i2, i3, i4, i5, i6, i7, root;
+	int t1, t2, t3, t4;
+	segment_t *s = &amp;seg[segnum];
 
-  q_idx = tr_idx = 1;
-  memset((void *)tr, 0, sizeof(tr));
-  memset((void *)qs, 0, sizeof(qs));
+	q_idx = tr_idx = 1;
+	memset((void *)tr, 0, sizeof(tr));
+	memset((void *)qs, 0, sizeof(qs));
 
-  i1 = newnode();
-  qs[i1].nodetype = T_Y;
-  _max(&amp;qs[i1].yval, &amp;s-&gt;v0, &amp;s-&gt;v1); /* root */
-  root = i1;
+	i1 = newnode();
+	qs[i1].nodetype = T_Y;
+	_max(&amp;qs[i1].yval, &amp;s-&gt;v0, &amp;s-&gt;v1); /* root */
+	root = i1;
 
-  qs[i1].right = i2 = newnode();
-  qs[i2].nodetype = T_SINK;
-  qs[i2].parent = i1;
+	qs[i1].right = i2 = newnode();
+	qs[i2].nodetype = T_SINK;
+	qs[i2].parent = i1;
 
-  qs[i1].left = i3 = newnode();
-  qs[i3].nodetype = T_Y;
-  _min(&amp;qs[i3].yval, &amp;s-&gt;v0, &amp;s-&gt;v1); /* root */
-  qs[i3].parent = i1;
-  
-  qs[i3].left = i4 = newnode();
-  qs[i4].nodetype = T_SINK;
-  qs[i4].parent = i3;
-  
-  qs[i3].right = i5 = newnode();
-  qs[i5].nodetype = T_X;
-  qs[i5].segnum = segnum;
-  qs[i5].parent = i3;
-  
-  qs[i5].left = i6 = newnode();
-  qs[i6].nodetype = T_SINK;
-  qs[i6].parent = i5;
+	qs[i1].left = i3 = newnode();
+	qs[i3].nodetype = T_Y;
+	_min(&amp;qs[i3].yval, &amp;s-&gt;v0, &amp;s-&gt;v1); /* root */
+	qs[i3].parent = i1;
 
-  qs[i5].right = i7 = newnode();
-  qs[i7].nodetype = T_SINK;
-  qs[i7].parent = i5;
+	qs[i3].left = i4 = newnode();
+	qs[i4].nodetype = T_SINK;
+	qs[i4].parent = i3;
 
-  t1 = newtrap();		/* middle left */
-  t2 = newtrap();		/* middle right */
-  t3 = newtrap();		/* bottom-most */
-  t4 = newtrap();		/* topmost */
+	qs[i3].right = i5 = newnode();
+	qs[i5].nodetype = T_X;
+	qs[i5].segnum = segnum;
+	qs[i5].parent = i3;
 
-  tr[t1].hi = tr[t2].hi = tr[t4].lo = qs[i1].yval;
-  tr[t1].lo = tr[t2].lo = tr[t3].hi = qs[i3].yval;
-  tr[t4].hi.y = (double) (INFINITY);
-  tr[t4].hi.x = (double) (INFINITY);
-  tr[t3].lo.y = (double) -1* (INFINITY);
-  tr[t3].lo.x = (double) -1* (INFINITY);
-  tr[t1].rseg = tr[t2].lseg = segnum;
-  tr[t1].u0 = tr[t2].u0 = t4;
-  tr[t1].d0 = tr[t2].d0 = t3;
-  tr[t4].d0 = tr[t3].u0 = t1;
-  tr[t4].d1 = tr[t3].u1 = t2;
-  
-  tr[t1].sink = i6;
-  tr[t2].sink = i7;
-  tr[t3].sink = i4;
-  tr[t4].sink = i2;
+	qs[i5].left = i6 = newnode();
+	qs[i6].nodetype = T_SINK;
+	qs[i6].parent = i5;
 
-  tr[t1].state = tr[t2].state = ST_VALID;
-  tr[t3].state = tr[t4].state = ST_VALID;
+	qs[i5].right = i7 = newnode();
+	qs[i7].nodetype = T_SINK;
+	qs[i7].parent = i5;
 
-  qs[i2].trnum = t4;
-  qs[i4].trnum = t3;
-  qs[i6].trnum = t1;
-  qs[i7].trnum = t2;
+	t1 = newtrap();		/* middle left */
+	t2 = newtrap();		/* middle right */
+	t3 = newtrap();		/* bottom-most */
+	t4 = newtrap();		/* topmost */
 
-  s-&gt;is_inserted = TRUE;
-  return root;
+	tr[t1].hi = tr[t2].hi = tr[t4].lo = qs[i1].yval;
+	tr[t1].lo = tr[t2].lo = tr[t3].hi = qs[i3].yval;
+	tr[t4].hi.y = (double) (INFINITY);
+	tr[t4].hi.x = (double) (INFINITY);
+	tr[t3].lo.y = (double) -1* (INFINITY);
+	tr[t3].lo.x = (double) -1* (INFINITY);
+	tr[t1].rseg = tr[t2].lseg = segnum;
+	tr[t1].u0 = tr[t2].u0 = t4;
+	tr[t1].d0 = tr[t2].d0 = t3;
+	tr[t4].d0 = tr[t3].u0 = t1;
+	tr[t4].d1 = tr[t3].u1 = t2;
+
+	tr[t1].sink = i6;
+	tr[t2].sink = i7;
+	tr[t3].sink = i4;
+	tr[t4].sink = i2;
+
+	tr[t1].state = tr[t2].state = ST_VALID;
+	tr[t3].state = tr[t4].state = ST_VALID;
+
+	qs[i2].trnum = t4;
+	qs[i4].trnum = t3;
+	qs[i6].trnum = t1;
+	qs[i7].trnum = t2;
+
+	s-&gt;is_inserted = TRUE;
+	return root;
 }
 
 
@@ -264,55 +256,44 @@
  */
 
 static int is_left_of(segnum, v)
-     int segnum;
-     point_t *v;
+int segnum;
+point_t *v;
 {
-  segment_t *s = &amp;seg[segnum];
-  double area;
-  
-  if (_greater_than(&amp;s-&gt;v1, &amp;s-&gt;v0)) /* seg. going upwards */
-    {
-      if (FP_EQUAL(s-&gt;v1.y, v-&gt;y))
-	{
-	  if (v-&gt;x &lt; s-&gt;v1.x)
-	    area = 1.0;
-	  else
-	    area = -1.0;
+	segment_t *s = &amp;seg[segnum];
+	double area;
+
+	if (_greater_than(&amp;s-&gt;v1, &amp;s-&gt;v0)) { /* seg. going upwards */
+		if (FP_EQUAL(s-&gt;v1.y, v-&gt;y)) {
+			if (v-&gt;x &lt; s-&gt;v1.x)
+				area = 1.0;
+			else
+				area = -1.0;
+		} else if (FP_EQUAL(s-&gt;v0.y, v-&gt;y)) {
+			if (v-&gt;x &lt; s-&gt;v0.x)
+				area = 1.0;
+			else
+				area = -1.0;
+		} else
+			area = CROSS(s-&gt;v0, s-&gt;v1, (*v));
+	} else {			/* v0 &gt; v1 */
+		if (FP_EQUAL(s-&gt;v1.y, v-&gt;y)) {
+			if (v-&gt;x &lt; s-&gt;v1.x)
+				area = 1.0;
+			else
+				area = -1.0;
+		} else if (FP_EQUAL(s-&gt;v0.y, v-&gt;y)) {
+			if (v-&gt;x &lt; s-&gt;v0.x)
+				area = 1.0;
+			else
+				area = -1.0;
+		} else
+			area = CROSS(s-&gt;v1, s-&gt;v0, (*v));
 	}
-      else if (FP_EQUAL(s-&gt;v0.y, v-&gt;y))
-	{
-	  if (v-&gt;x &lt; s-&gt;v0.x)
-	    area = 1.0;
-	  else
-	    area = -1.0;
-	}
-      else
-	area = CROSS(s-&gt;v0, s-&gt;v1, (*v));
-    }
-  else				/* v0 &gt; v1 */
-    {
-      if (FP_EQUAL(s-&gt;v1.y, v-&gt;y))
-	{
-	  if (v-&gt;x &lt; s-&gt;v1.x)
-	    area = 1.0;
-	  else
-	    area = -1.0;
-	}
-      else if (FP_EQUAL(s-&gt;v0.y, v-&gt;y))
-	{
-	  if (v-&gt;x &lt; s-&gt;v0.x)
-	    area = 1.0;
-	  else
-	    area = -1.0;
-	}
-      else
-	area = CROSS(s-&gt;v1, s-&gt;v0, (*v));
-    }
-  
-  if (area &gt; 0.0)
-    return TRUE;
-  else 
-    return FALSE;
+
+	if (area &gt; 0.0)
+		return TRUE;
+	else
+		return FALSE;
 }
 
 
@@ -322,75 +303,70 @@
 /* whether the segment which shares this endpoint is already inserted */
 
 static int inserted(segnum, whichpt)
-     int segnum;
-     int whichpt;
+int segnum;
+int whichpt;
 {
-  if (whichpt == FIRSTPT)
-    return seg[seg[segnum].prev].is_inserted;
-  else
-    return seg[seg[segnum].next].is_inserted;
+	if (whichpt == FIRSTPT)
+		return seg[seg[segnum].prev].is_inserted;
+	else
+		return seg[seg[segnum].next].is_inserted;
 }
 
-/* This is query routine which determines which trapezoid does the 
- * point v lie in. The return value is the trapezoid number. 
+/* This is query routine which determines which trapezoid does the
+ * point v lie in. The return value is the trapezoid number.
  */
 
 int locate_endpoint(v, vo, r)
-     point_t *v;
-     point_t *vo;
-     int r;
+point_t *v;
+point_t *vo;
+int r;
 {
-  node_t *rptr = &amp;qs[r];
-  
-  switch (rptr-&gt;nodetype)
-    {
-    case T_SINK:
-      return rptr-&gt;trnum;
-      
-    case T_Y:
-      if (_greater_than(v, &amp;rptr-&gt;yval)) /* above */
-	return locate_endpoint(v, vo, rptr-&gt;right);
-      else if (_equal_to(v, &amp;rptr-&gt;yval)) /* the point is already */
-	{			          /* inserted. */
-	  if (_greater_than(vo, &amp;rptr-&gt;yval)) /* above */
-	    return locate_endpoint(v, vo, rptr-&gt;right);
-	  else 
-	    return locate_endpoint(v, vo, rptr-&gt;left); /* below */	    
-	}
-      else
-	return locate_endpoint(v, vo, rptr-&gt;left); /* below */
+	node_t *rptr = &amp;qs[r];
 
-    case T_X:
-      if (_equal_to(v, &amp;seg[rptr-&gt;segnum].v0) || 
-	       _equal_to(v, &amp;seg[rptr-&gt;segnum].v1))
-	{
-	  if (FP_EQUAL(v-&gt;y, vo-&gt;y)) /* horizontal segment */
-	    {
-	      if (vo-&gt;x &lt; v-&gt;x)
-		return locate_endpoint(v, vo, rptr-&gt;left); /* left */
-	      else
-		return locate_endpoint(v, vo, rptr-&gt;right); /* right */
-	    }
+	switch (rptr-&gt;nodetype) {
+	case T_SINK:
+		return rptr-&gt;trnum;
 
-	  else if (is_left_of(rptr-&gt;segnum, vo))
-	    return locate_endpoint(v, vo, rptr-&gt;left); /* left */
-	  else
-	    return locate_endpoint(v, vo, rptr-&gt;right); /* right */
-	}
-      else if (is_left_of(rptr-&gt;segnum, v))
-	return locate_endpoint(v, vo, rptr-&gt;left); /* left */
-      else
-	return locate_endpoint(v, vo, rptr-&gt;right); /* right */	
+	case T_Y:
+		if (_greater_than(v, &amp;rptr-&gt;yval)) /* above */
+			return locate_endpoint(v, vo, rptr-&gt;right);
+		else if (_equal_to(v, &amp;rptr-&gt;yval)) /* the point is already */
+		{			          /* inserted. */
+			if (_greater_than(vo, &amp;rptr-&gt;yval)) /* above */
+				return locate_endpoint(v, vo, rptr-&gt;right);
+			else
+				return locate_endpoint(v, vo, rptr-&gt;left); /* below */
+		} else
+			return locate_endpoint(v, vo, rptr-&gt;left); /* below */
 
-    default:
-      errs(&quot;sei:locate_endpoint()&quot;,&quot;Haggu!!!! (whatever)&quot;);
-      break;
-    }
-  return(-1);
+	case T_X:
+		if (_equal_to(v, &amp;seg[rptr-&gt;segnum].v0) ||
+		                _equal_to(v, &amp;seg[rptr-&gt;segnum].v1)) {
+			if (FP_EQUAL(v-&gt;y, vo-&gt;y)) { /* horizontal segment */
+				if (vo-&gt;x &lt; v-&gt;x)
+					return locate_endpoint(v, vo, rptr-&gt;left); /* left */
+				else
+					return locate_endpoint(v, vo, rptr-&gt;right); /* right */
+			}
+
+			else if (is_left_of(rptr-&gt;segnum, vo))
+				return locate_endpoint(v, vo, rptr-&gt;left); /* left */
+			else
+				return locate_endpoint(v, vo, rptr-&gt;right); /* right */
+		} else if (is_left_of(rptr-&gt;segnum, v))
+			return locate_endpoint(v, vo, rptr-&gt;left); /* left */
+		else
+			return locate_endpoint(v, vo, rptr-&gt;right); /* right */
+
+	default:
+		errs(&quot;sei:locate_endpoint()&quot;,&quot;Haggu!!!! (whatever)&quot;);
+		break;
+	}
+	return(-1);
 }
 
 
-/* Thread in the segment into the existing trapezoidation. The 
+/* Thread in the segment into the existing trapezoidation. The
  * limiting trapezoids are given by tfirst and tlast (which are the
  * trapezoids containing the two endpoints of the segment. Merges all
  * possible trapezoids which flank this segment and have been recently
@@ -398,71 +374,65 @@
  */
 
 static int merge_trapezoids(segnum, tfirst, tlast, side)
-     int segnum;
-     int tfirst;
-     int tlast;
-     int side;
+int segnum;
+int tfirst;
+int tlast;
+int side;
 {
-  int t, tnext, cond;
-  int ptnext;
+	int t, tnext, cond;
+	int ptnext;
 
-  /* First merge polys on the LHS */
-  t = tfirst;
-  while ((t &gt; 0) &amp;&amp; _greater_than_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo))
-    {
-      if (side == S_LEFT)
-	cond = ((((tnext = tr[t].d0) &gt; 0) &amp;&amp; (tr[tnext].rseg == segnum)) ||
-		(((tnext = tr[t].d1) &gt; 0) &amp;&amp; (tr[tnext].rseg == segnum)));
-      else
-	cond = ((((tnext = tr[t].d0) &gt; 0) &amp;&amp; (tr[tnext].lseg == segnum)) ||
-		(((tnext = tr[t].d1) &gt; 0) &amp;&amp; (tr[tnext].lseg == segnum)));
-      
-      if (cond)
-	{
-	  if ((tr[t].lseg == tr[tnext].lseg) &amp;&amp;
-	      (tr[t].rseg == tr[tnext].rseg)) /* good neighbours */
-	    {			              /* merge them */
-	      /* Use the upper node as the new node i.e. t */
-	      
-	      ptnext = qs[tr[tnext].sink].parent;
-	      
-	      if (qs[ptnext].left == tr[tnext].sink)
-		qs[ptnext].left = tr[t].sink;
-	      else
-		qs[ptnext].right = tr[t].sink;	/* redirect parent */
-	      
-	      
-	      /* Change the upper neighbours of the lower trapezoids */
-	      
-	      if ((tr[t].d0 = tr[tnext].d0) &gt; 0)
-		  {
-			if (tr[tr[t].d0].u0 == tnext)
-			  tr[tr[t].d0].u0 = t;
-			else if (tr[tr[t].d0].u1 == tnext)
-			  tr[tr[t].d0].u1 = t;
-		  }
-	      
-	      if ((tr[t].d1 = tr[tnext].d1) &gt; 0)
-		  {
-			if (tr[tr[t].d1].u0 == tnext)
-			  tr[tr[t].d1].u0 = t;
-			else if (tr[tr[t].d1].u1 == tnext)
-			  tr[tr[t].d1].u1 = t;
-		  }
-	      
-	      tr[t].lo = tr[tnext].lo;
-	      tr[tnext].state = ST_INVALID; /* invalidate the lower */
-				            /* trapezium */
-	    }
-	  else		    /* not good neighbours */
-	    t = tnext;
-	}
-      else		    /* do not satisfy the outer if */
-	t = tnext;
-      
-    } /* end-while */
-       
-  return 0;
+	/* First merge polys on the LHS */
+	t = tfirst;
+	while ((t &gt; 0) &amp;&amp; _greater_than_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo)) {
+		if (side == S_LEFT)
+			cond = ((((tnext = tr[t].d0) &gt; 0) &amp;&amp; (tr[tnext].rseg == segnum)) ||
+			        (((tnext = tr[t].d1) &gt; 0) &amp;&amp; (tr[tnext].rseg == segnum)));
+		else
+			cond = ((((tnext = tr[t].d0) &gt; 0) &amp;&amp; (tr[tnext].lseg == segnum)) ||
+			        (((tnext = tr[t].d1) &gt; 0) &amp;&amp; (tr[tnext].lseg == segnum)));
+
+		if (cond) {
+			if ((tr[t].lseg == tr[tnext].lseg) &amp;&amp;
+			                (tr[t].rseg == tr[tnext].rseg)) /* good neighbours */
+			{			              /* merge them */
+				/* Use the upper node as the new node i.e. t */
+
+				ptnext = qs[tr[tnext].sink].parent;
+
+				if (qs[ptnext].left == tr[tnext].sink)
+					qs[ptnext].left = tr[t].sink;
+				else
+					qs[ptnext].right = tr[t].sink;	/* redirect parent */
+
+
+				/* Change the upper neighbours of the lower trapezoids */
+
+				if ((tr[t].d0 = tr[tnext].d0) &gt; 0) {
+					if (tr[tr[t].d0].u0 == tnext)
+						tr[tr[t].d0].u0 = t;
+					else if (tr[tr[t].d0].u1 == tnext)
+						tr[tr[t].d0].u1 = t;
+				}
+
+				if ((tr[t].d1 = tr[tnext].d1) &gt; 0) {
+					if (tr[tr[t].d1].u0 == tnext)
+						tr[tr[t].d1].u0 = t;
+					else if (tr[tr[t].d1].u1 == tnext)
+						tr[tr[t].d1].u1 = t;
+				}
+
+				tr[t].lo = tr[tnext].lo;
+				tr[tnext].state = ST_INVALID; /* invalidate the lower */
+				/* trapezium */
+			} else		   /* not good neighbours */
+				t = tnext;
+		} else		   /* do not satisfy the outer if */
+			t = tnext;
+
+	} /* end-while */
+
+	return 0;
 }
 
 
@@ -473,574 +443,493 @@
  */
 
 static int add_segment(segnum)
-     int segnum;
+int segnum;
 {
-  segment_t s;
-  int tu, tl, sk, tfirst, tlast;
-  int tfirstr = 0, tlastr = 0, tfirstl, tlastl;
-  int i1, i2, t, tn;
-  point_t tpt;
-  int tritop = 0, tribot = 0, is_swapped = 0;
-  int tmptriseg;
-  int tmpseg = 1;
+	segment_t s;
+	int tu, tl, sk, tfirst, tlast;
+	int tfirstr = 0, tlastr = 0, tfirstl, tlastl;
+	int i1, i2, t, tn;
+	point_t tpt;
+	int tritop = 0, tribot = 0, is_swapped = 0;
+	int tmptriseg;
+	int tmpseg = 1;
 
-  s = seg[segnum];
-  if (_greater_than(&amp;s.v1, &amp;s.v0)) /* Get higher vertex in v0 */
-    {
-      int tmp;
-      tpt = s.v0;
-      s.v0 = s.v1;
-      s.v1 = tpt;
-      tmp = s.root0;
-      s.root0 = s.root1;
-      s.root1 = tmp;
-      is_swapped = TRUE;
-    }
+	s = seg[segnum];
+	if (_greater_than(&amp;s.v1, &amp;s.v0)) { /* Get higher vertex in v0 */
+		int tmp;
+		tpt = s.v0;
+		s.v0 = s.v1;
+		s.v1 = tpt;
+		tmp = s.root0;
+		s.root0 = s.root1;
+		s.root1 = tmp;
+		is_swapped = TRUE;
+	}
 
-  if ((is_swapped) ? !inserted(segnum, LASTPT) :
-       !inserted(segnum, FIRSTPT))     /* insert v0 in the tree */
-    {
-      int tmp_d;
+	if ((is_swapped) ? !inserted(segnum, LASTPT) :
+	                !inserted(segnum, FIRSTPT)) {   /* insert v0 in the tree */
+		int tmp_d;
 
-      tu = locate_endpoint(&amp;s.v0, &amp;s.v1, s.root0);
-      tl = newtrap();		/* tl is the new lower trapezoid */
-      tr[tl].state = ST_VALID;
-      tr[tl] = tr[tu];
-      tr[tu].lo.y = tr[tl].hi.y = s.v0.y;
-      tr[tu].lo.x = tr[tl].hi.x = s.v0.x;
-      tr[tu].d0 = tl;      
-      tr[tu].d1 = 0;
-      tr[tl].u0 = tu;
-      tr[tl].u1 = 0;
+		tu = locate_endpoint(&amp;s.v0, &amp;s.v1, s.root0);
+		tl = newtrap();		/* tl is the new lower trapezoid */
+		tr[tl].state = ST_VALID;
+		tr[tl] = tr[tu];
+		tr[tu].lo.y = tr[tl].hi.y = s.v0.y;
+		tr[tu].lo.x = tr[tl].hi.x = s.v0.x;
+		tr[tu].d0 = tl;
+		tr[tu].d1 = 0;
+		tr[tl].u0 = tu;
+		tr[tl].u1 = 0;
 
-      if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
-	tr[tmp_d].u0 = tl;
-      if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
-	tr[tmp_d].u1 = tl;
+		if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
+			tr[tmp_d].u0 = tl;
+		if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
+			tr[tmp_d].u1 = tl;
 
-      if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
-	tr[tmp_d].u0 = tl;
-      if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
-	tr[tmp_d].u1 = tl;
+		if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
+			tr[tmp_d].u0 = tl;
+		if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
+			tr[tmp_d].u1 = tl;
 
-      /* Now update the query structure and obtain the sinks for the */
-      /* two trapezoids */ 
-      
-      i1 = newnode();		/* Upper trapezoid sink */
-      i2 = newnode();		/* Lower trapezoid sink */
-      sk = tr[tu].sink;
-      
-      qs[sk].nodetype = T_Y;
-      qs[sk].yval = s.v0;
-      qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
-      qs[sk].left = i2;
-      qs[sk].right = i1;
+		/* Now update the query structure and obtain the sinks for the */
+		/* two trapezoids */
 
-      qs[i1].nodetype = T_SINK;
-      qs[i1].trnum = tu;
-      qs[i1].parent = sk;
+		i1 = newnode();		/* Upper trapezoid sink */
+		i2 = newnode();		/* Lower trapezoid sink */
+		sk = tr[tu].sink;
 
-      qs[i2].nodetype = T_SINK;
-      qs[i2].trnum = tl;
-      qs[i2].parent = sk;
+		qs[sk].nodetype = T_Y;
+		qs[sk].yval = s.v0;
+		qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
+		qs[sk].left = i2;
+		qs[sk].right = i1;
 
-      tr[tu].sink = i1;
-      tr[tl].sink = i2;
-      tfirst = tl;
-    }
-  else				/* v0 already present */
-    {       /* Get the topmost intersecting trapezoid */
-      tfirst = locate_endpoint(&amp;s.v0, &amp;s.v1, s.root0);
-      tritop = 1;
-    }
+		qs[i1].nodetype = T_SINK;
+		qs[i1].trnum = tu;
+		qs[i1].parent = sk;
 
+		qs[i2].nodetype = T_SINK;
+		qs[i2].trnum = tl;
+		qs[i2].parent = sk;
 
-  if ((is_swapped) ? !inserted(segnum, FIRSTPT) :
-       !inserted(segnum, LASTPT))     /* insert v1 in the tree */
-    {
-      int tmp_d;
+		tr[tu].sink = i1;
+		tr[tl].sink = i2;
+		tfirst = tl;
+	} else				/* v0 already present */
+	{       /* Get the topmost intersecting trapezoid */
+		tfirst = locate_endpoint(&amp;s.v0, &amp;s.v1, s.root0);
+		tritop = 1;
+	}
 
-      tu = locate_endpoint(&amp;s.v1, &amp;s.v0, s.root1);
 
-      tl = newtrap();		/* tl is the new lower trapezoid */
-      tr[tl].state = ST_VALID;
-      tr[tl] = tr[tu];
-      tr[tu].lo.y = tr[tl].hi.y = s.v1.y;
-      tr[tu].lo.x = tr[tl].hi.x = s.v1.x;
-      tr[tu].d0 = tl;      
-      tr[tu].d1 = 0;
-      tr[tl].u0 = tu;
-      tr[tl].u1 = 0;
+	if ((is_swapped) ? !inserted(segnum, FIRSTPT) :
+	                !inserted(segnum, LASTPT)) {   /* insert v1 in the tree */
+		int tmp_d;
 
-      if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
-	tr[tmp_d].u0 = tl;
-      if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
-	tr[tmp_d].u1 = tl;
+		tu = locate_endpoint(&amp;s.v1, &amp;s.v0, s.root1);
 
-      if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
-	tr[tmp_d].u0 = tl;
-      if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
-	tr[tmp_d].u1 = tl;
-      
-      /* Now update the query structure and obtain the sinks for the */
-      /* two trapezoids */ 
-      
-      i1 = newnode();		/* Upper trapezoid sink */
-      i2 = newnode();		/* Lower trapezoid sink */
-      sk = tr[tu].sink;
-      
-      qs[sk].nodetype = T_Y;
-      qs[sk].yval = s.v1;
-      qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
-      qs[sk].left = i2;
-      qs[sk].right = i1;
+		tl = newtrap();		/* tl is the new lower trapezoid */
+		tr[tl].state = ST_VALID;
+		tr[tl] = tr[tu];
+		tr[tu].lo.y = tr[tl].hi.y = s.v1.y;
+		tr[tu].lo.x = tr[tl].hi.x = s.v1.x;
+		tr[tu].d0 = tl;
+		tr[tu].d1 = 0;
+		tr[tl].u0 = tu;
+		tr[tl].u1 = 0;
 
-      qs[i1].nodetype = T_SINK;
-      qs[i1].trnum = tu;
-      qs[i1].parent = sk;
+		if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
+			tr[tmp_d].u0 = tl;
+		if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
+			tr[tmp_d].u1 = tl;
 
-      qs[i2].nodetype = T_SINK;
-      qs[i2].trnum = tl;
-      qs[i2].parent = sk;
+		if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
+			tr[tmp_d].u0 = tl;
+		if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
+			tr[tmp_d].u1 = tl;
 
-      tr[tu].sink = i1;
-      tr[tl].sink = i2;
-      tlast = tu;
-    }
-  else				/* v1 already present */
-    {       /* Get the lowermost intersecting trapezoid */
-      tlast = locate_endpoint(&amp;s.v1, &amp;s.v0, s.root1);
-      tribot = 1;
-    }
-  
-  /* Thread the segment into the query tree creating a new X-node */
-  /* First, split all the trapezoids which are intersected by s into */
-  /* two */
+		/* Now update the query structure and obtain the sinks for the */
+		/* two trapezoids */
 
-  t = tfirst;			/* topmost trapezoid */
-  
-  while ((t &gt; 0) &amp;&amp; 
-	 _greater_than_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo))
-				/* traverse from top to bot */
-    {
-      int t_sav, tn_sav;
-      sk = tr[t].sink;
-      i1 = newnode();		/* left trapezoid sink */
-      i2 = newnode();		/* right trapezoid sink */
-      
-      qs[sk].nodetype = T_X;
-      qs[sk].segnum = segnum;
-      qs[sk].left = i1;
-      qs[sk].right = i2;
+		i1 = newnode();		/* Upper trapezoid sink */
+		i2 = newnode();		/* Lower trapezoid sink */
+		sk = tr[tu].sink;
 
-      qs[i1].nodetype = T_SINK;	/* left trapezoid (use existing one) */
-      qs[i1].trnum = t;
-      qs[i1].parent = sk;
+		qs[sk].nodetype = T_Y;
+		qs[sk].yval = s.v1;
+		qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
+		qs[sk].left = i2;
+		qs[sk].right = i1;
 
-      qs[i2].nodetype = T_SINK;	/* right trapezoid (allocate new) */
-      qs[i2].trnum = tn = newtrap();
-      tr[tn].state = ST_VALID;
-      qs[i2].parent = sk;
+		qs[i1].nodetype = T_SINK;
+		qs[i1].trnum = tu;
+		qs[i1].parent = sk;
 
-      if (t == tfirst)
-	tfirstr = tn;
-      if (_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo))
-	tlastr = tn;
+		qs[i2].nodetype = T_SINK;
+		qs[i2].trnum = tl;
+		qs[i2].parent = sk;
 
-      tr[tn] = tr[t];
-      tr[t].sink = i1;
-      tr[tn].sink = i2;
-      t_sav = t;
-      tn_sav = tn;
+		tr[tu].sink = i1;
+		tr[tl].sink = i2;
+		tlast = tu;
+	} else				/* v1 already present */
+	{       /* Get the lowermost intersecting trapezoid */
+		tlast = locate_endpoint(&amp;s.v1, &amp;s.v0, s.root1);
+		tribot = 1;
+	}
 
-      /* error */
+	/* Thread the segment into the query tree creating a new X-node */
+	/* First, split all the trapezoids which are intersected by s into */
+	/* two */
 
-      if ((tr[t].d0 &lt;= 0) &amp;&amp; (tr[t].d1 &lt;= 0)) /* case cannot arise */
+	t = tfirst;			/* topmost trapezoid */
+
+	while ((t &gt; 0) &amp;&amp;
+	                _greater_than_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo))
+		/* traverse from top to bot */
 	{
-      errs(&quot;sei:add_segment()&quot;,&quot;error&quot;);
-	  break;
-	}
-      
-      /* only one trapezoid below. partition t into two and make the */
-      /* two resulting trapezoids t and tn as the upper neighbours of */
-      /* the sole lower trapezoid */
-      
-      else if ((tr[t].d0 &gt; 0) &amp;&amp; (tr[t].d1 &lt;= 0))
-	{			/* Only one trapezoid below */
-	  if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0))
-	    {			/* continuation of a chain from abv. */
-	      if (tr[t].usave &gt; 0) /* three upper neighbours */
-		{
-		  if (tr[t].uside == S_LEFT)
-		    {
-		      tr[tn].u0 = tr[t].u1;
-		      tr[t].u1 = -1;
-		      tr[tn].u1 = tr[t].usave;
-		      
-		      tr[tr[t].u0].d0 = t;
-		      tr[tr[tn].u0].d0 = tn;
-		      tr[tr[tn].u1].d0 = tn;
-		    }
-		  else		/* intersects in the right */
-		    {
-		      tr[tn].u1 = -1;
-		      tr[tn].u0 = tr[t].u1;
-		      tr[t].u1 = tr[t].u0;
-		      tr[t].u0 = tr[t].usave;
+		int t_sav, tn_sav;
+		sk = tr[t].sink;
+		i1 = newnode();		/* left trapezoid sink */
+		i2 = newnode();		/* right trapezoid sink */
 
-		      tr[tr[t].u0].d0 = t;
-		      tr[tr[t].u1].d0 = t;
-		      tr[tr[tn].u0].d0 = tn;		      
-		    }
-		  
-		  tr[t].usave = tr[tn].usave = 0;
-		}
-	      else		/* No usave.... simple case */
-		{
-		  tr[tn].u0 = tr[t].u1;
-		  tr[t].u1 = tr[tn].u1 = -1;
-		  tr[tr[tn].u0].d0 = tn;
-		}
-	    }
-	  else 
-	    {			/* fresh seg. or upward cusp */
-	      int tmp_u = tr[t].u0;
-	      int td0, td1;
-	      if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp; 
-		  ((td1 = tr[tmp_u].d1) &gt; 0))
-		{		/* upward cusp */
-		  if ((tr[td0].rseg &gt; 0) &amp;&amp;
-		      !is_left_of(tr[td0].rseg, &amp;s.v1))
-		    {
-		      tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
-		      tr[tr[tn].u0].d1 = tn;
-		    }
-		  else		/* cusp going leftwards */
-		    { 
-		      tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
-		      tr[tr[t].u0].d0 = t;
-		    }
-		}
-	      else		/* fresh segment */
-		{
-		  tr[tr[t].u0].d0 = t;
-		  tr[tr[t].u0].d1 = tn;
-		}	      
-	    }
-	  
-	  if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp; 
-	      FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot)
-	    {		/* bottom forms a triangle */
+		qs[sk].nodetype = T_X;
+		qs[sk].segnum = segnum;
+		qs[sk].left = i1;
+		qs[sk].right = i2;
 
-	      if (is_swapped)	
-		tmptriseg = seg[segnum].prev;
-	      else
-		tmptriseg = seg[segnum].next;
-	      
-	      if ((tmptriseg &gt; 0) &amp;&amp; is_left_of(tmptriseg, &amp;s.v0))
-		{
-				/* L-R downward cusp */
-		  tr[tr[t].d0].u0 = t;
-		  tr[tn].d0 = tr[tn].d1 = -1;
-		}
-	      else
-		{
-				/* R-L downward cusp */
-		  tr[tr[tn].d0].u1 = tn;
-		  tr[t].d0 = tr[t].d1 = -1;
-		}
-	    }
-	  else
-	    {
-	      if ((tr[tr[t].d0].u0 &gt; 0) &amp;&amp; (tr[tr[t].d0].u1 &gt; 0))
-		{
-		  if (tr[tr[t].d0].u0 == t) /* passes thru LHS */
-		    {
-		      tr[tr[t].d0].usave = tr[tr[t].d0].u1;
-		      tr[tr[t].d0].uside = S_LEFT;
-		    }
-		  else
-		    {
-		      tr[tr[t].d0].usave = tr[tr[t].d0].u0;
-		      tr[tr[t].d0].uside = S_RIGHT;
-		    }		    
-		}
-	      tr[tr[t].d0].u0 = t;
-	      tr[tr[t].d0].u1 = tn;
-	    }
-	  
-	  t = tr[t].d0;
-	}
+		qs[i1].nodetype = T_SINK;	/* left trapezoid (use existing one) */
+		qs[i1].trnum = t;
+		qs[i1].parent = sk;
 
+		qs[i2].nodetype = T_SINK;	/* right trapezoid (allocate new) */
+		qs[i2].trnum = tn = newtrap();
+		tr[tn].state = ST_VALID;
+		qs[i2].parent = sk;
 
-      else if ((tr[t].d0 &lt;= 0) &amp;&amp; (tr[t].d1 &gt; 0))
-	{			/* Only one trapezoid below */
-	  if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0))
-	    {			/* continuation of a chain from abv. */
-	      if (tr[t].usave &gt; 0) /* three upper neighbours */
-		{
-		  if (tr[t].uside == S_LEFT)
-		    {
-		      tr[tn].u0 = tr[t].u1;
-		      tr[t].u1 = -1;
-		      tr[tn].u1 = tr[t].usave;
-		      
-		      tr[tr[t].u0].d0 = t;
-		      tr[tr[tn].u0].d0 = tn;
-		      tr[tr[tn].u1].d0 = tn;
-		    }
-		  else		/* intersects in the right */
-		    {
-		      tr[tn].u1 = -1;
-		      tr[tn].u0 = tr[t].u1;
-		      tr[t].u1 = tr[t].u0;
-		      tr[t].u0 = tr[t].usave;
+		if (t == tfirst)
+			tfirstr = tn;
+		if (_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo))
+			tlastr = tn;
 
-		      tr[tr[t].u0].d0 = t;
-		      tr[tr[t].u1].d0 = t;
-		      tr[tr[tn].u0].d0 = tn;		      
-		    }
-		  
-		  tr[t].usave = tr[tn].usave = 0;
+		tr[tn] = tr[t];
+		tr[t].sink = i1;
+		tr[tn].sink = i2;
+		t_sav = t;
+		tn_sav = tn;
+
+		/* error */
+
+		if ((tr[t].d0 &lt;= 0) &amp;&amp; (tr[t].d1 &lt;= 0)) { /* case cannot arise */
+			errs(&quot;sei:add_segment()&quot;,&quot;error&quot;);
+			break;
 		}
-	      else		/* No usave.... simple case */
-		{
-		  tr[tn].u0 = tr[t].u1;
-		  tr[t].u1 = tr[tn].u1 = -1;
-		  tr[tr[tn].u0].d0 = tn;
-		}
-	    }
-	  else 
-	    {			/* fresh seg. or upward cusp */
-	      int tmp_u = tr[t].u0;
-	      int td0, td1;
-	      if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp; 
-		  ((td1 = tr[tmp_u].d1) &gt; 0))
-		{		/* upward cusp */
-		  if ((tr[td0].rseg &gt; 0) &amp;&amp;
-		      !is_left_of(tr[td0].rseg, &amp;s.v1))
-		    {
-		      tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
-		      tr[tr[tn].u0].d1 = tn;
-		    }
-		  else 
-		    {
-		      tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
-		      tr[tr[t].u0].d0 = t;
-		    }
-		}
-	      else		/* fresh segment */
-		{
-		  tr[tr[t].u0].d0 = t;
-		  tr[tr[t].u0].d1 = tn;
-		}
-	    }
-	  
-	  if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp; 
-	      FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot)
-	    {		/* bottom forms a triangle */
 
-	      if (is_swapped)	
-			tmptriseg = seg[segnum].prev;
-	      else
-			tmptriseg = seg[segnum].next;
+		/* only one trapezoid below. partition t into two and make the */
+		/* two resulting trapezoids t and tn as the upper neighbours of */
+		/* the sole lower trapezoid */
 
-	      if ((tmpseg &gt; 0) &amp;&amp; is_left_of(tmpseg, &amp;s.v0))
-		{
-		  /* L-R downward cusp */
-		  tr[tr[t].d1].u0 = t;
-		  tr[tn].d0 = tr[tn].d1 = -1;
+		else if ((tr[t].d0 &gt; 0) &amp;&amp; (tr[t].d1 &lt;= 0)) {			/* Only one trapezoid below */
+			if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0)) {			/* continuation of a chain from abv. */
+				if (tr[t].usave &gt; 0) { /* three upper neighbours */
+					if (tr[t].uside == S_LEFT) {
+						tr[tn].u0 = tr[t].u1;
+						tr[t].u1 = -1;
+						tr[tn].u1 = tr[t].usave;
+
+						tr[tr[t].u0].d0 = t;
+						tr[tr[tn].u0].d0 = tn;
+						tr[tr[tn].u1].d0 = tn;
+					} else {	/* intersects in the right */
+						tr[tn].u1 = -1;
+						tr[tn].u0 = tr[t].u1;
+						tr[t].u1 = tr[t].u0;
+						tr[t].u0 = tr[t].usave;
+
+						tr[tr[t].u0].d0 = t;
+						tr[tr[t].u1].d0 = t;
+						tr[tr[tn].u0].d0 = tn;
+					}
+
+					tr[t].usave = tr[tn].usave = 0;
+				} else {	/* No usave.... simple case */
+					tr[tn].u0 = tr[t].u1;
+					tr[t].u1 = tr[tn].u1 = -1;
+					tr[tr[tn].u0].d0 = tn;
+				}
+			} else {			/* fresh seg. or upward cusp */
+				int tmp_u = tr[t].u0;
+				int td0, td1;
+				if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp;
+				                ((td1 = tr[tmp_u].d1) &gt; 0)) {		/* upward cusp */
+					if ((tr[td0].rseg &gt; 0) &amp;&amp;
+					                !is_left_of(tr[td0].rseg, &amp;s.v1)) {
+						tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
+						tr[tr[tn].u0].d1 = tn;
+					} else {	/* cusp going leftwards */
+						tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
+						tr[tr[t].u0].d0 = t;
+					}
+				} else {	/* fresh segment */
+					tr[tr[t].u0].d0 = t;
+					tr[tr[t].u0].d1 = tn;
+				}
+			}
+
+			if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp;
+			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot) {		/* bottom forms a triangle */
+
+				if (is_swapped)
+					tmptriseg = seg[segnum].prev;
+				else
+					tmptriseg = seg[segnum].next;
+
+				if ((tmptriseg &gt; 0) &amp;&amp; is_left_of(tmptriseg, &amp;s.v0)) {
+					/* L-R downward cusp */
+					tr[tr[t].d0].u0 = t;
+					tr[tn].d0 = tr[tn].d1 = -1;
+				} else {
+					/* R-L downward cusp */
+					tr[tr[tn].d0].u1 = tn;
+					tr[t].d0 = tr[t].d1 = -1;
+				}
+			} else {
+				if ((tr[tr[t].d0].u0 &gt; 0) &amp;&amp; (tr[tr[t].d0].u1 &gt; 0)) {
+					if (tr[tr[t].d0].u0 == t) { /* passes thru LHS */
+						tr[tr[t].d0].usave = tr[tr[t].d0].u1;
+						tr[tr[t].d0].uside = S_LEFT;
+					} else {
+						tr[tr[t].d0].usave = tr[tr[t].d0].u0;
+						tr[tr[t].d0].uside = S_RIGHT;
+					}
+				}
+				tr[tr[t].d0].u0 = t;
+				tr[tr[t].d0].u1 = tn;
+			}
+
+			t = tr[t].d0;
 		}
-	      else
-		{
-		  /* R-L downward cusp */
-		  tr[tr[tn].d1].u1 = tn;
-		  tr[t].d0 = tr[t].d1 = -1;
-		}
-	    }		
-	  else
-	    {
-	      if ((tr[tr[t].d1].u0 &gt; 0) &amp;&amp; (tr[tr[t].d1].u1 &gt; 0))
-		{
-		  if (tr[tr[t].d1].u0 == t) /* passes thru LHS */
-		    {
-		      tr[tr[t].d1].usave = tr[tr[t].d1].u1;
-		      tr[tr[t].d1].uside = S_LEFT;
-		    }
-		  else
-		    {
-		      tr[tr[t].d1].usave = tr[tr[t].d1].u0;
-		      tr[tr[t].d1].uside = S_RIGHT;
-		    }		    
-		}
-	      tr[tr[t].d1].u0 = t;
-	      tr[tr[t].d1].u1 = tn;
-	    }
-	  
-	  t = tr[t].d1;
-	}
 
-      /* two trapezoids below. Find out which one is intersected by */
-      /* this segment and proceed down that one */
-      
-      else
-	{
-	  double y0, yt;
-	  point_t tmppt;
-	  int tnext, i_d0, i_d1;
-	  tmpseg = tr[tr[t].d0].rseg;
 
-	  i_d0 = i_d1 = FALSE;
-	  if (FP_EQUAL(tr[t].lo.y, s.v0.y))
-	    {
-	      if (tr[t].lo.x &gt; s.v0.x)
-		i_d0 = TRUE;
-	      else
-		i_d1 = TRUE;
-	    }
-	  else
-	    {
-	      tmppt.y = y0 = tr[t].lo.y;
-	      yt = (y0 - s.v0.y)/(s.v1.y - s.v0.y);
-	      tmppt.x = s.v0.x + yt * (s.v1.x - s.v0.x);
-	      
-	      if (_less_than(&amp;tmppt, &amp;tr[t].lo))
-		i_d0 = TRUE;
-	      else
-		i_d1 = TRUE;
-	    }
-	  
-	  /* check continuity from the top so that the lower-neighbour */
-	  /* values are properly filled for the upper trapezoid */
+		else if ((tr[t].d0 &lt;= 0) &amp;&amp; (tr[t].d1 &gt; 0)) {			/* Only one trapezoid below */
+			if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0)) {			/* continuation of a chain from abv. */
+				if (tr[t].usave &gt; 0) { /* three upper neighbours */
+					if (tr[t].uside == S_LEFT) {
+						tr[tn].u0 = tr[t].u1;
+						tr[t].u1 = -1;
+						tr[tn].u1 = tr[t].usave;
 
-	  if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0))
-	    {			/* continuation of a chain from abv. */
-	      if (tr[t].usave &gt; 0) /* three upper neighbours */
-		{
-		  if (tr[t].uside == S_LEFT)
-		    {
-		      tr[tn].u0 = tr[t].u1;
-		      tr[t].u1 = -1;
-		      tr[tn].u1 = tr[t].usave;
-		      
-		      tr[tr[t].u0].d0 = t;
-		      tr[tr[tn].u0].d0 = tn;
-		      tr[tr[tn].u1].d0 = tn;
-		    }
-		  else		/* intersects in the right */
-		    {
-		      tr[tn].u1 = -1;
-		      tr[tn].u0 = tr[t].u1;
-		      tr[t].u1 = tr[t].u0;
-		      tr[t].u0 = tr[t].usave;
+						tr[tr[t].u0].d0 = t;
+						tr[tr[tn].u0].d0 = tn;
+						tr[tr[tn].u1].d0 = tn;
+					} else {	/* intersects in the right */
+						tr[tn].u1 = -1;
+						tr[tn].u0 = tr[t].u1;
+						tr[t].u1 = tr[t].u0;
+						tr[t].u0 = tr[t].usave;
 
-		      tr[tr[t].u0].d0 = t;
-		      tr[tr[t].u1].d0 = t;
-		      tr[tr[tn].u0].d0 = tn;		      
-		    }
-		  
-		  tr[t].usave = tr[tn].usave = 0;
+						tr[tr[t].u0].d0 = t;
+						tr[tr[t].u1].d0 = t;
+						tr[tr[tn].u0].d0 = tn;
+					}
+
+					tr[t].usave = tr[tn].usave = 0;
+				} else {	/* No usave.... simple case */
+					tr[tn].u0 = tr[t].u1;
+					tr[t].u1 = tr[tn].u1 = -1;
+					tr[tr[tn].u0].d0 = tn;
+				}
+			} else {			/* fresh seg. or upward cusp */
+				int tmp_u = tr[t].u0;
+				int td0, td1;
+				if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp;
+				                ((td1 = tr[tmp_u].d1) &gt; 0)) {		/* upward cusp */
+					if ((tr[td0].rseg &gt; 0) &amp;&amp;
+					                !is_left_of(tr[td0].rseg, &amp;s.v1)) {
+						tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
+						tr[tr[tn].u0].d1 = tn;
+					} else {
+						tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
+						tr[tr[t].u0].d0 = t;
+					}
+				} else {	/* fresh segment */
+					tr[tr[t].u0].d0 = t;
+					tr[tr[t].u0].d1 = tn;
+				}
+			}
+
+			if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp;
+			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot) {		/* bottom forms a triangle */
+
+				if (is_swapped)
+					tmptriseg = seg[segnum].prev;
+				else
+					tmptriseg = seg[segnum].next;
+
+				if ((tmpseg &gt; 0) &amp;&amp; is_left_of(tmpseg, &amp;s.v0)) {
+					/* L-R downward cusp */
+					tr[tr[t].d1].u0 = t;
+					tr[tn].d0 = tr[tn].d1 = -1;
+				} else {
+					/* R-L downward cusp */
+					tr[tr[tn].d1].u1 = tn;
+					tr[t].d0 = tr[t].d1 = -1;
+				}
+			} else {
+				if ((tr[tr[t].d1].u0 &gt; 0) &amp;&amp; (tr[tr[t].d1].u1 &gt; 0)) {
+					if (tr[tr[t].d1].u0 == t) { /* passes thru LHS */
+						tr[tr[t].d1].usave = tr[tr[t].d1].u1;
+						tr[tr[t].d1].uside = S_LEFT;
+					} else {
+						tr[tr[t].d1].usave = tr[tr[t].d1].u0;
+						tr[tr[t].d1].uside = S_RIGHT;
+					}
+				}
+				tr[tr[t].d1].u0 = t;
+				tr[tr[t].d1].u1 = tn;
+			}
+
+			t = tr[t].d1;
 		}
-	      else		/* No usave.... simple case */
-		{
-		  tr[tn].u0 = tr[t].u1;
-		  tr[tn].u1 = -1;
-		  tr[t].u1 = -1;
-		  tr[tr[tn].u0].d0 = tn;
-		}
-	    }
-	  else 
-	    {			/* fresh seg. or upward cusp */
-	      int tmp_u = tr[t].u0;
-	      int td0, td1;
-	      if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp; 
-		  ((td1 = tr[tmp_u].d1) &gt; 0))
-		{		/* upward cusp */
-		  if ((tr[td0].rseg &gt; 0) &amp;&amp;
-		      !is_left_of(tr[td0].rseg, &amp;s.v1))
-		    {
-		      tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
-		      tr[tr[tn].u0].d1 = tn;
-		    }
-		  else 
-		    {
-		      tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
-		      tr[tr[t].u0].d0 = t;
-		    }
-		}
-	      else		/* fresh segment */
-		{
-		  tr[tr[t].u0].d0 = t;
-		  tr[tr[t].u0].d1 = tn;
-		}
-	    }
-	  
-	  if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp; 
-	      FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot)
-	    {
-	      /* this case arises only at the lowest trapezoid.. i.e.
-		 tlast, if the lower endpoint of the segment is
-		 already inserted in the structure */
-	      
-	      tr[tr[t].d0].u0 = t;
-	      tr[tr[t].d0].u1 = -1;
-	      tr[tr[t].d1].u0 = tn;
-	      tr[tr[t].d1].u1 = -1;
 
-	      tr[tn].d0 = tr[t].d1;
-	      tr[t].d1 = tr[tn].d1 = -1;
-	      
-	      tnext = tr[t].d1;	      
-	    }
-	  else if (i_d0)
+		/* two trapezoids below. Find out which one is intersected by */
+		/* this segment and proceed down that one */
+
+		else {
+			double y0, yt;
+			point_t tmppt;
+			int tnext, i_d0, i_d1;
+			tmpseg = tr[tr[t].d0].rseg;
+
+			i_d0 = i_d1 = FALSE;
+			if (FP_EQUAL(tr[t].lo.y, s.v0.y)) {
+				if (tr[t].lo.x &gt; s.v0.x)
+					i_d0 = TRUE;
+				else
+					i_d1 = TRUE;
+			} else {
+				tmppt.y = y0 = tr[t].lo.y;
+				yt = (y0 - s.v0.y)/(s.v1.y - s.v0.y);
+				tmppt.x = s.v0.x + yt * (s.v1.x - s.v0.x);
+
+				if (_less_than(&amp;tmppt, &amp;tr[t].lo))
+					i_d0 = TRUE;
+				else
+					i_d1 = TRUE;
+			}
+
+			/* check continuity from the top so that the lower-neighbour */
+			/* values are properly filled for the upper trapezoid */
+
+			if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0)) {			/* continuation of a chain from abv. */
+				if (tr[t].usave &gt; 0) { /* three upper neighbours */
+					if (tr[t].uside == S_LEFT) {
+						tr[tn].u0 = tr[t].u1;
+						tr[t].u1 = -1;
+						tr[tn].u1 = tr[t].usave;
+
+						tr[tr[t].u0].d0 = t;
+						tr[tr[tn].u0].d0 = tn;
+						tr[tr[tn].u1].d0 = tn;
+					} else {	/* intersects in the right */
+						tr[tn].u1 = -1;
+						tr[tn].u0 = tr[t].u1;
+						tr[t].u1 = tr[t].u0;
+						tr[t].u0 = tr[t].usave;
+
+						tr[tr[t].u0].d0 = t;
+						tr[tr[t].u1].d0 = t;
+						tr[tr[tn].u0].d0 = tn;
+					}
+
+					tr[t].usave = tr[tn].usave = 0;
+				} else {	/* No usave.... simple case */
+					tr[tn].u0 = tr[t].u1;
+					tr[tn].u1 = -1;
+					tr[t].u1 = -1;
+					tr[tr[tn].u0].d0 = tn;
+				}
+			} else {			/* fresh seg. or upward cusp */
+				int tmp_u = tr[t].u0;
+				int td0, td1;
+				if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp;
+				                ((td1 = tr[tmp_u].d1) &gt; 0)) {		/* upward cusp */
+					if ((tr[td0].rseg &gt; 0) &amp;&amp;
+					                !is_left_of(tr[td0].rseg, &amp;s.v1)) {
+						tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
+						tr[tr[tn].u0].d1 = tn;
+					} else {
+						tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
+						tr[tr[t].u0].d0 = t;
+					}
+				} else {	/* fresh segment */
+					tr[tr[t].u0].d0 = t;
+					tr[tr[t].u0].d1 = tn;
+				}
+			}
+
+			if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp;
+			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot) {
+				/* this case arises only at the lowest trapezoid.. i.e.
+				   tlast, if the lower endpoint of the segment is
+				   already inserted in the structure */
+
+				tr[tr[t].d0].u0 = t;
+				tr[tr[t].d0].u1 = -1;
+				tr[tr[t].d1].u0 = tn;
+				tr[tr[t].d1].u1 = -1;
+
+				tr[tn].d0 = tr[t].d1;
+				tr[t].d1 = tr[tn].d1 = -1;
+
+				tnext = tr[t].d1;
+			} else if (i_d0)
 				/* intersecting d0 */
-	    {
-	      tr[tr[t].d0].u0 = t;
-	      tr[tr[t].d0].u1 = tn;
-	      tr[tr[t].d1].u0 = tn;
-	      tr[tr[t].d1].u1 = -1;
-	      
-	      /* new code to determine the bottom neighbours of the */
-	      /* newly partitioned trapezoid */
-	      
-	      tr[t].d1 = -1;
+			{
+				tr[tr[t].d0].u0 = t;
+				tr[tr[t].d0].u1 = tn;
+				tr[tr[t].d1].u0 = tn;
+				tr[tr[t].d1].u1 = -1;
 
-	      tnext = tr[t].d0;
-	    }
-	  else			/* intersecting d1 */
-	    {
-	      tr[tr[t].d0].u0 = t;
-	      tr[tr[t].d0].u1 = -1;
-	      tr[tr[t].d1].u0 = t;
-	      tr[tr[t].d1].u1 = tn;
+				/* new code to determine the bottom neighbours of the */
+				/* newly partitioned trapezoid */
 
-	      /* new code to determine the bottom neighbours of the */
-	      /* newly partitioned trapezoid */
-	      
-	      tr[tn].d0 = tr[t].d1;
-	      tr[tn].d1 = -1;
-	      
-	      tnext = tr[t].d1;
-	    }	    
-	  
-	  t = tnext;
-	}
-      
-      tr[t_sav].rseg = tr[tn_sav].lseg  = segnum;
-    } /* end-while */
-  
-  /* Now combine those trapezoids which share common segments. We can */
-  /* use the pointers to the parent to connect these together. This */
-  /* works only because all these new trapezoids have been formed */
-  /* due to splitting by the segment, and hence have only one parent */
+				tr[t].d1 = -1;
 
-  tfirstl = tfirst; 
-  tlastl = tlast;
-  merge_trapezoids(segnum, tfirstl, tlastl, S_LEFT);
-  merge_trapezoids(segnum, tfirstr, tlastr, S_RIGHT);
+				tnext = tr[t].d0;
+			} else {		/* intersecting d1 */
+				tr[tr[t].d0].u0 = t;
+				tr[tr[t].d0].u1 = -1;
+				tr[tr[t].d1].u0 = t;
+				tr[tr[t].d1].u1 = tn;
 
-  seg[segnum].is_inserted = TRUE;
-  return 0;
+				/* new code to determine the bottom neighbours of the */
+				/* newly partitioned trapezoid */
+
+				tr[tn].d0 = tr[t].d1;
+				tr[tn].d1 = -1;
+
+				tnext = tr[t].d1;
+			}
+
+			t = tnext;
+		}
+
+		tr[t_sav].rseg = tr[tn_sav].lseg  = segnum;
+	} /* end-while */
+
+	/* Now combine those trapezoids which share common segments. We can */
+	/* use the pointers to the parent to connect these together. This */
+	/* works only because all these new trapezoids have been formed */
+	/* due to splitting by the segment, and hence have only one parent */
+
+	tfirstl = tfirst;
+	tlastl = tlast;
+	merge_trapezoids(segnum, tfirstl, tlastl, S_LEFT);
+	merge_trapezoids(segnum, tfirstr, tlastr, S_RIGHT);
+
+	seg[segnum].is_inserted = TRUE;
+	return 0;
 }
 
 
@@ -1049,51 +938,50 @@
  * the segment is inserted into the trapezoidation subsequently
  */
 static int find_new_roots(segnum)
-     int segnum;
+int segnum;
 {
-  segment_t *s = &amp;seg[segnum];
-  
-  if (s-&gt;is_inserted)
-    return 0;
+	segment_t *s = &amp;seg[segnum];
 
-  s-&gt;root0 = locate_endpoint(&amp;s-&gt;v0, &amp;s-&gt;v1, s-&gt;root0);
-  s-&gt;root0 = tr[s-&gt;root0].sink;
+	if (s-&gt;is_inserted)
+		return 0;
 
-  s-&gt;root1 = locate_endpoint(&amp;s-&gt;v1, &amp;s-&gt;v0, s-&gt;root1);
-  s-&gt;root1 = tr[s-&gt;root1].sink;  
-  return 0;
+	s-&gt;root0 = locate_endpoint(&amp;s-&gt;v0, &amp;s-&gt;v1, s-&gt;root0);
+	s-&gt;root0 = tr[s-&gt;root0].sink;
+
+	s-&gt;root1 = locate_endpoint(&amp;s-&gt;v1, &amp;s-&gt;v0, s-&gt;root1);
+	s-&gt;root1 = tr[s-&gt;root1].sink;
+	return 0;
 }
 
 
 /* Main routine to perform trapezoidation */
 int construct_trapezoids(nseg)
-     int nseg;
+int nseg;
 {
-  register int i;
-  int root, h;
-  
-  /* Add the first segment and get the query structure and trapezoid */
-  /* list initialised */
+	register int i;
+	int root, h;
 
-  root = init_query_structure(choose_segment());
+	/* Add the first segment and get the query structure and trapezoid */
+	/* list initialised */
 
-  for (i = 1; i &lt;= nseg; i++)
-    seg[i].root0 = seg[i].root1 = root;
-  
-  for (h = 1; h &lt;= math_logstar_n(nseg); h++)
-    {
-      for (i = math_N(nseg, h -1) + 1; i &lt;= math_N(nseg, h); i++)
-	add_segment(choose_segment());
-      
-      /* Find a new root for each of the segment endpoints */
-      for (i = 1; i &lt;= nseg; i++)
-	find_new_roots(i);
-    }
-  
-  for (i = math_N(nseg, math_logstar_n(nseg)) + 1; i &lt;= nseg; i++)
-    add_segment(choose_segment());
+	root = init_query_structure(choose_segment());
 
-  return 0;
+	for (i = 1; i &lt;= nseg; i++)
+		seg[i].root0 = seg[i].root1 = root;
+
+	for (h = 1; h &lt;= math_logstar_n(nseg); h++) {
+		for (i = math_N(nseg, h -1) + 1; i &lt;= math_N(nseg, h); i++)
+			add_segment(choose_segment());
+
+		/* Find a new root for each of the segment endpoints */
+		for (i = 1; i &lt;= nseg; i++)
+			find_new_roots(i);
+	}
+
+	for (i = math_N(nseg, math_logstar_n(nseg)) + 1; i &lt;= nseg; i++)
+		add_segment(choose_segment());
+
+	return 0;
 }
 
 

Modified: trunk/libs3d/sei_interface.h
===================================================================
--- trunk/libs3d/sei_interface.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/sei_interface.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,9 +1,9 @@
 /*
  * sei_interface.h
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
- * for public domain: 
+ * for public domain:
  * &lt;snip&gt;
  *
  * This code is in the public domain. Specifically, we give to the public
@@ -20,17 +20,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

Modified: trunk/libs3d/sei_misc.c
===================================================================
--- trunk/libs3d/sei_misc.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/sei_misc.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,9 +1,9 @@
 /*
  * sei_misc.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
- * for public domain: 
+ * for public domain:
  * &lt;snip&gt;
  *
  * This code is in the public domain. Specifically, we give to the public
@@ -20,17 +20,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -44,68 +44,68 @@
 
 static int choose_idx;
 static int permute[SEGSIZE];
-double mlog2(double x) {
-  return log(x)/log(2);
+double mlog2(double x)
+{
+	return log(x)/log(2);
 }
 
 /* Generate a random permutation of the segments 1..n */
 int generate_random_ordering(n)
-     int n;
+int n;
 {
-  struct timeval tval;
-  register int i;
-  int m, st[SEGSIZE], *p;
-  
-  choose_idx = 1;
-  gettimeofday(&amp;tval, NULL);
-  srand48(tval.tv_sec);
+	struct timeval tval;
+	register int i;
+	int m, st[SEGSIZE], *p;
 
-  for (i = 0; i &lt;= n; i++)
-    st[i] = i;
+	choose_idx = 1;
+	gettimeofday(&amp;tval, NULL);
+	srand48(tval.tv_sec);
 
-  p = st;
-  for (i = 1; i &lt;= n; i++, p++)
-    {
-      m = lrand48() % (n + 1 - i) + 1;
-      permute[i] = p[m];
-      if (m != 1)
-	p[m] = p[1];
-    }
-  return 0;
+	for (i = 0; i &lt;= n; i++)
+		st[i] = i;
+
+	p = st;
+	for (i = 1; i &lt;= n; i++, p++) {
+		m = lrand48() % (n + 1 - i) + 1;
+		permute[i] = p[m];
+		if (m != 1)
+			p[m] = p[1];
+	}
+	return 0;
 }
 
-  
+
 /* Return the next segment in the generated random ordering of all the */
 /* segments in S */
 int choose_segment()
 {
-  errds(VLOW,&quot;sei:choose_segment()&quot;,&quot;%d&quot;, permute[choose_idx]);
-  return permute[choose_idx++];
+	errds(VLOW,&quot;sei:choose_segment()&quot;,&quot;%d&quot;, permute[choose_idx]);
+	return permute[choose_idx++];
 }
 
 /* Get log*n for given n */
 int math_logstar_n(n)
-     int n;
+int n;
 {
-  register int i;
-  double v;
-  
-  for (i = 0, v = (double) n; v &gt;= 1; i++)
-    v = mlog2(v);
-  
-  return (i - 1);
+	register int i;
+	double v;
+
+	for (i = 0, v = (double) n; v &gt;= 1; i++)
+		v = mlog2(v);
+
+	return (i - 1);
 }
-  
 
+
 int math_N(n, h)
-     int n;
-     int h;
+int n;
+int h;
 {
-  register int i;
-  double v;
+	register int i;
+	double v;
 
-  for (i = 0, v = (int) n; i &lt; h; i++)
-    v = mlog2(v);
-  
-  return (int) ceil((double) 1.0*n/v);
+	for (i = 0, v = (int) n; i &lt; h; i++)
+		v = mlog2(v);
+
+	return (int) ceil((double) 1.0*n/v);
 }

Modified: trunk/libs3d/sei_monotone.c
===================================================================
--- trunk/libs3d/sei_monotone.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/sei_monotone.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,9 +1,9 @@
 /*
  * sei_monotone.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
- * for public domain: 
+ * for public domain:
  * &lt;snip&gt;
  *
  * This code is in the public domain. Specifically, we give to the public
@@ -20,17 +20,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -45,18 +45,18 @@
 #define LENGTH(v0) (sqrt((v0).x * (v0).x + (v0).y * (v0).y))
 
 static monchain_t mchain[TRSIZE]; /* Table to hold all the monotone */
-				  /* polygons . Each monotone polygon */
-				  /* is a circularly linked list */
+/* polygons . Each monotone polygon */
+/* is a circularly linked list */
 
 static vertexchain_t vert[SEGSIZE]; /* chain init. information. This */
-				    /* is used to decide which */
-				    /* monotone polygon to split if */
-				    /* there are several other */
-				    /* polygons touching at the same */
-				    /* vertex  */
+/* is used to decide which */
+/* monotone polygon to split if */
+/* there are several other */
+/* polygons touching at the same */
+/* vertex  */
 
 static int mon[SEGSIZE];	/* contains position of any vertex in */
-				/* the monotone chain for the polygon */
+/* the monotone chain for the polygon */
 static int visited[TRSIZE];
 static int chain_idx, op_idx, mon_idx;
 
@@ -66,534 +66,473 @@
 
 /* Function returns TRUE if the trapezoid lies inside the polygon */
 static int inside_polygon(t)
-     trap_t *t;
+trap_t *t;
 {
-  int rseg = t-&gt;rseg;
+	int rseg = t-&gt;rseg;
 
-  if (t-&gt;state == ST_INVALID)
-    return 0;
+	if (t-&gt;state == ST_INVALID)
+		return 0;
 
-  if ((t-&gt;lseg &lt;= 0) || (t-&gt;rseg &lt;= 0))
-    return 0;
-  
-  if (((t-&gt;u0 &lt;= 0) &amp;&amp; (t-&gt;u1 &lt;= 0)) || 
-      ((t-&gt;d0 &lt;= 0) &amp;&amp; (t-&gt;d1 &lt;= 0))) /* triangle */
-    return (_greater_than(&amp;seg[rseg].v1, &amp;seg[rseg].v0));
-  
-  return 0;
+	if ((t-&gt;lseg &lt;= 0) || (t-&gt;rseg &lt;= 0))
+		return 0;
+
+	if (((t-&gt;u0 &lt;= 0) &amp;&amp; (t-&gt;u1 &lt;= 0)) ||
+	                ((t-&gt;d0 &lt;= 0) &amp;&amp; (t-&gt;d1 &lt;= 0))) /* triangle */
+		return (_greater_than(&amp;seg[rseg].v1, &amp;seg[rseg].v0));
+
+	return 0;
 }
 
 
 /* return a new mon structure from the table */
 static int newmon()
 {
-  return ++mon_idx;
+	return ++mon_idx;
 }
 
 
 /* return a new chain element from the table */
 static int new_chain_element()
 {
-  return ++chain_idx;
+	return ++chain_idx;
 }
 
 
 static double get_angle(vp0, vpnext, vp1)
-     point_t *vp0;
-     point_t *vpnext;
-     point_t *vp1;
+point_t *vp0;
+point_t *vpnext;
+point_t *vp1;
 {
-  point_t v0, v1;
-  
-  v0.x = vpnext-&gt;x - vp0-&gt;x;
-  v0.y = vpnext-&gt;y - vp0-&gt;y;
+	point_t v0, v1;
 
-  v1.x = vp1-&gt;x - vp0-&gt;x;
-  v1.y = vp1-&gt;y - vp0-&gt;y;
+	v0.x = vpnext-&gt;x - vp0-&gt;x;
+	v0.y = vpnext-&gt;y - vp0-&gt;y;
 
-  if (CROSS_SINE(v0, v1) &gt;= 0)	/* sine is positive */
-    return DOT(v0, v1)/LENGTH(v0)/LENGTH(v1);
-  else
-    return (-1.0 * DOT(v0, v1)/LENGTH(v0)/LENGTH(v1) - 2);
+	v1.x = vp1-&gt;x - vp0-&gt;x;
+	v1.y = vp1-&gt;y - vp0-&gt;y;
+
+	if (CROSS_SINE(v0, v1) &gt;= 0)	/* sine is positive */
+		return DOT(v0, v1)/LENGTH(v0)/LENGTH(v1);
+	else
+		return (-1.0 * DOT(v0, v1)/LENGTH(v0)/LENGTH(v1) - 2);
 }
 
 
 /* (v0, v1) is the new diagonal to be added to the polygon. Find which */
-/* chain to use and return the positions of v0 and v1 in p and q */ 
+/* chain to use and return the positions of v0 and v1 in p and q */
 static int get_vertex_positions(v0, v1, ip, iq)
-     int v0;
-     int v1;
-     int *ip;
-     int *iq;
+int v0;
+int v1;
+int *ip;
+int *iq;
 {
-  vertexchain_t *vp0, *vp1;
-  register int i;
-  double angle, temp;
-  int tp, tq;
+	vertexchain_t *vp0, *vp1;
+	register int i;
+	double angle, temp;
+	int tp, tq;
 
-  tp = tq = 0;
-  
-  vp0 = &amp;vert[v0];
-  vp1 = &amp;vert[v1];
-  
-  /* p is identified as follows. Scan from (v0, v1) rightwards till */
-  /* you hit the first segment starting from v0. That chain is the */
-  /* chain of our interest */
-  
-  angle = -4.0;
-  for (i = 0; i &lt; 4; i++)
-    {
-      if (vp0-&gt;vnext[i] &lt;= 0)
-	continue;
-      if ((temp = get_angle(&amp;vp0-&gt;pt, &amp;(vert[vp0-&gt;vnext[i]].pt), 
-			    &amp;vp1-&gt;pt)) &gt; angle)
-	{
-	  angle = temp;
-	  tp = i;
+	tp = tq = 0;
+
+	vp0 = &amp;vert[v0];
+	vp1 = &amp;vert[v1];
+
+	/* p is identified as follows. Scan from (v0, v1) rightwards till */
+	/* you hit the first segment starting from v0. That chain is the */
+	/* chain of our interest */
+
+	angle = -4.0;
+	for (i = 0; i &lt; 4; i++) {
+		if (vp0-&gt;vnext[i] &lt;= 0)
+			continue;
+		if ((temp = get_angle(&amp;vp0-&gt;pt, &amp;(vert[vp0-&gt;vnext[i]].pt),
+		                      &amp;vp1-&gt;pt)) &gt; angle) {
+			angle = temp;
+			tp = i;
+		}
 	}
-    }
 
-  *ip = tp;
+	*ip = tp;
 
-  /* Do similar actions for q */
+	/* Do similar actions for q */
 
-  angle = -4.0;
-  for (i = 0; i &lt; 4; i++)
-    {
-      if (vp1-&gt;vnext[i] &lt;= 0)
-	continue;      
-      if ((temp = get_angle(&amp;vp1-&gt;pt, &amp;(vert[vp1-&gt;vnext[i]].pt), 
-			    &amp;vp0-&gt;pt)) &gt; angle)
-	{
-	  angle = temp;
-	  tq = i;
+	angle = -4.0;
+	for (i = 0; i &lt; 4; i++) {
+		if (vp1-&gt;vnext[i] &lt;= 0)
+			continue;
+		if ((temp = get_angle(&amp;vp1-&gt;pt, &amp;(vert[vp1-&gt;vnext[i]].pt),
+		                      &amp;vp0-&gt;pt)) &gt; angle) {
+			angle = temp;
+			tq = i;
+		}
 	}
-    }
 
-  *iq = tq;
+	*iq = tq;
 
-  return 0;
+	return 0;
 }
 
-  
-/* v0 and v1 are specified in anti-clockwise order with respect to 
- * the current monotone polygon mcur. Split the current polygon into 
- * two polygons using the diagonal (v0, v1) 
+
+/* v0 and v1 are specified in anti-clockwise order with respect to
+ * the current monotone polygon mcur. Split the current polygon into
+ * two polygons using the diagonal (v0, v1)
  */
 static int make_new_monotone_poly(mcur, v0, v1)
-     int mcur;
-     int v0;
-     int v1;
+int mcur;
+int v0;
+int v1;
 {
-  int p, q, ip, iq;
-  int mnew = newmon();
-  int i, j, nf0, nf1;
-  vertexchain_t *vp0, *vp1;
-  
-  vp0 = &amp;vert[v0];
-  vp1 = &amp;vert[v1];
+	int p, q, ip, iq;
+	int mnew = newmon();
+	int i, j, nf0, nf1;
+	vertexchain_t *vp0, *vp1;
 
-  get_vertex_positions(v0, v1, &amp;ip, &amp;iq);
+	vp0 = &amp;vert[v0];
+	vp1 = &amp;vert[v1];
 
-  p = vp0-&gt;vpos[ip];
-  q = vp1-&gt;vpos[iq];
+	get_vertex_positions(v0, v1, &amp;ip, &amp;iq);
 
-  /* At this stage, we have got the positions of v0 and v1 in the */
-  /* desired chain. Now modify the linked lists */
+	p = vp0-&gt;vpos[ip];
+	q = vp1-&gt;vpos[iq];
 
-  i = new_chain_element();	/* for the new list */
-  j = new_chain_element();
+	/* At this stage, we have got the positions of v0 and v1 in the */
+	/* desired chain. Now modify the linked lists */
 
-  mchain[i].vnum = v0;
-  mchain[j].vnum = v1;
+	i = new_chain_element();	/* for the new list */
+	j = new_chain_element();
 
-  mchain[i].next = mchain[p].next;
-  mchain[mchain[p].next].prev = i;
-  mchain[i].prev = j;
-  mchain[j].next = i;
-  mchain[j].prev = mchain[q].prev;
-  mchain[mchain[q].prev].next = j;
+	mchain[i].vnum = v0;
+	mchain[j].vnum = v1;
 
-  mchain[p].next = q;
-  mchain[q].prev = p;
+	mchain[i].next = mchain[p].next;
+	mchain[mchain[p].next].prev = i;
+	mchain[i].prev = j;
+	mchain[j].next = i;
+	mchain[j].prev = mchain[q].prev;
+	mchain[mchain[q].prev].next = j;
 
-  nf0 = vp0-&gt;nextfree;
-  nf1 = vp1-&gt;nextfree;
+	mchain[p].next = q;
+	mchain[q].prev = p;
 
-  vp0-&gt;vnext[ip] = v1;
+	nf0 = vp0-&gt;nextfree;
+	nf1 = vp1-&gt;nextfree;
 
-  vp0-&gt;vpos[nf0] = i;
-  vp0-&gt;vnext[nf0] = mchain[mchain[i].next].vnum;
-  vp1-&gt;vpos[nf1] = j;
-  vp1-&gt;vnext[nf1] = v0;
+	vp0-&gt;vnext[ip] = v1;
 
-  vp0-&gt;nextfree++;
-  vp1-&gt;nextfree++;
+	vp0-&gt;vpos[nf0] = i;
+	vp0-&gt;vnext[nf0] = mchain[mchain[i].next].vnum;
+	vp1-&gt;vpos[nf1] = j;
+	vp1-&gt;vnext[nf1] = v0;
 
-  errds(VLOW,&quot;sei:make_poly()&quot;,&quot;: mcur = %d, (v0, v1) = (%d, %d)&quot;, mcur, v0, v1);
-  errds(VLOW,&quot;sei:make_poly()&quot;,&quot;next posns = (p, q) = (%d, %d)&quot;, p, q);
+	vp0-&gt;nextfree++;
+	vp1-&gt;nextfree++;
 
-  mon[mcur] = p;
-  mon[mnew] = i;
-  return mnew;
+	errds(VLOW,&quot;sei:make_poly()&quot;,&quot;: mcur = %d, (v0, v1) = (%d, %d)&quot;, mcur, v0, v1);
+	errds(VLOW,&quot;sei:make_poly()&quot;,&quot;next posns = (p, q) = (%d, %d)&quot;, p, q);
+
+	mon[mcur] = p;
+	mon[mnew] = i;
+	return mnew;
 }
 
-/* Main routine to get monotone polygons from the trapezoidation of 
+/* Main routine to get monotone polygons from the trapezoidation of
  * the polygon.
  */
 
 int monotonate_trapezoids(n)
-     int n;
+int n;
 {
-  register int i;
-  int tr_start;
+	register int i;
+	int tr_start;
 
-  memset((void *)vert, 0, sizeof(vert));
-  memset((void *)visited, 0, sizeof(visited));
-  memset((void *)mchain, 0, sizeof(mchain));
-  memset((void *)mon, 0, sizeof(mon));
-  
-  /* First locate a trapezoid which lies inside the polygon */
-  /* and which is triangular */
-  for (i = 0; i &lt; TRSIZE; i++)
-    if (inside_polygon(&amp;tr[i]))
-      break;
-  tr_start = i;
-  
-  /* Initialise the mon data-structure and start spanning all the */
-  /* trapezoids within the polygon */
+	memset((void *)vert, 0, sizeof(vert));
+	memset((void *)visited, 0, sizeof(visited));
+	memset((void *)mchain, 0, sizeof(mchain));
+	memset((void *)mon, 0, sizeof(mon));
 
+	/* First locate a trapezoid which lies inside the polygon */
+	/* and which is triangular */
+	for (i = 0; i &lt; TRSIZE; i++)
+		if (inside_polygon(&amp;tr[i]))
+			break;
+	tr_start = i;
+
+	/* Initialise the mon data-structure and start spanning all the */
+	/* trapezoids within the polygon */
+
 #if 0
-  for (i = 1; i &lt;= n; i++)
-    {
-      mchain[i].prev = i - 1;
-      mchain[i].next = i + 1;
-      mchain[i].vnum = i;
-      vert[i].pt = seg[i].v0;
-      vert[i].vnext[0] = i + 1;	/* next vertex */
-      vert[i].vpos[0] = i;	/* locn. of next vertex */
-      vert[i].nextfree = 1;
-    }
-  mchain[1].prev = n;
-  mchain[n].next = 1;
-  vert[n].vnext[0] = 1;
-  vert[n].vpos[0] = n;
-  chain_idx = n;
-  mon_idx = 0;
-  mon[0] = 1;			/* position of any vertex in the first */
-				/* chain  */
+	for (i = 1; i &lt;= n; i++) {
+		mchain[i].prev = i - 1;
+		mchain[i].next = i + 1;
+		mchain[i].vnum = i;
+		vert[i].pt = seg[i].v0;
+		vert[i].vnext[0] = i + 1;	/* next vertex */
+		vert[i].vpos[0] = i;	/* locn. of next vertex */
+		vert[i].nextfree = 1;
+	}
+	mchain[1].prev = n;
+	mchain[n].next = 1;
+	vert[n].vnext[0] = 1;
+	vert[n].vpos[0] = n;
+	chain_idx = n;
+	mon_idx = 0;
+	mon[0] = 1;			/* position of any vertex in the first */
+	/* chain  */
 
 #else
 
-  for (i = 1; i &lt;= n; i++)
-    {
-      mchain[i].prev = seg[i].prev;
-      mchain[i].next = seg[i].next;
-      mchain[i].vnum = i;
-      vert[i].pt = seg[i].v0;
-      vert[i].vnext[0] = seg[i].next; /* next vertex */
-      vert[i].vpos[0] = i;	/* locn. of next vertex */
-      vert[i].nextfree = 1;
-    }
+	for (i = 1; i &lt;= n; i++) {
+		mchain[i].prev = seg[i].prev;
+		mchain[i].next = seg[i].next;
+		mchain[i].vnum = i;
+		vert[i].pt = seg[i].v0;
+		vert[i].vnext[0] = seg[i].next; /* next vertex */
+		vert[i].vpos[0] = i;	/* locn. of next vertex */
+		vert[i].nextfree = 1;
+	}
 
-  chain_idx = n;
-  mon_idx = 0;
-  mon[0] = 1;			/* position of any vertex in the first */
-				/* chain  */
+	chain_idx = n;
+	mon_idx = 0;
+	mon[0] = 1;			/* position of any vertex in the first */
+	/* chain  */
 
 #endif
-  
-  /* traverse the polygon */
-  if (tr[tr_start].u0 &gt; 0)
-    traverse_polygon(0, tr_start, tr[tr_start].u0, TR_FROM_UP);
-  else if (tr[tr_start].d0 &gt; 0)
-    traverse_polygon(0, tr_start, tr[tr_start].d0, TR_FROM_DN);
-  
-  /* return the number of polygons created */
-  return newmon();
+
+	/* traverse the polygon */
+	if (tr[tr_start].u0 &gt; 0)
+		traverse_polygon(0, tr_start, tr[tr_start].u0, TR_FROM_UP);
+	else if (tr[tr_start].d0 &gt; 0)
+		traverse_polygon(0, tr_start, tr[tr_start].d0, TR_FROM_DN);
+
+	/* return the number of polygons created */
+	return newmon();
 }
 
 
 /* recursively visit all the trapezoids */
 static int traverse_polygon(mcur, trnum, from, dir)
-     int mcur;
-     int trnum;
-     int from;
-     int dir;
+int mcur;
+int trnum;
+int from;
+int dir;
 {
-  trap_t *t = &amp;tr[trnum];
-  int mnew;
-  int v0, v1;
-  int retval = -1;
-  int do_switch = FALSE;
+	trap_t *t = &amp;tr[trnum];
+	int mnew;
+	int v0, v1;
+	int retval = -1;
+	int do_switch = FALSE;
 
-  if ((trnum &lt;= 0) || visited[trnum])
-    return 0;
+	if ((trnum &lt;= 0) || visited[trnum])
+		return 0;
 
-  visited[trnum] = TRUE;
-  
-  /* We have much more information available here. */
-  /* rseg: goes upwards   */
-  /* lseg: goes downwards */
+	visited[trnum] = TRUE;
 
-  /* Initially assume that dir = TR_FROM_DN (from the left) */
-  /* Switch v0 and v1 if necessary afterwards */
+	/* We have much more information available here. */
+	/* rseg: goes upwards   */
+	/* lseg: goes downwards */
 
+	/* Initially assume that dir = TR_FROM_DN (from the left) */
+	/* Switch v0 and v1 if necessary afterwards */
 
-  /* special cases for triangles with cusps at the opposite ends. */
-  /* take care of this first */
-  if ((t-&gt;u0 &lt;= 0) &amp;&amp; (t-&gt;u1 &lt;= 0))
-    {
-      if ((t-&gt;d0 &gt; 0) &amp;&amp; (t-&gt;d1 &gt; 0)) /* downward opening triangle */
-	{
-	  v0 = tr[t-&gt;d1].lseg;
-	  v1 = t-&gt;lseg;
-	  if (from == t-&gt;d1)
-	    {
-	      do_switch = TRUE;
-	      mnew = make_new_monotone_poly(mcur, v1, v0);
-	      traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
-	      traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);	    
-	    }
-	  else
-	    {
-	      mnew = make_new_monotone_poly(mcur, v0, v1);
-	      traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
-	      traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
-	    }
-	}
-      else
-	{
-	  retval = SP_NOSPLIT;	/* Just traverse all neighbours */
-	  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
-	  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
-	  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
-	  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
-	}
-    }
-  
-  else if ((t-&gt;d0 &lt;= 0) &amp;&amp; (t-&gt;d1 &lt;= 0))
-    {
-      if ((t-&gt;u0 &gt; 0) &amp;&amp; (t-&gt;u1 &gt; 0)) /* upward opening triangle */
-	{
-	  v0 = t-&gt;rseg;
-	  v1 = tr[t-&gt;u0].rseg;
-	  if (from == t-&gt;u1)
-	    {
-	      do_switch = TRUE;
-	      mnew = make_new_monotone_poly(mcur, v1, v0);
-	      traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
-	      traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);	    
-	    }
-	  else
-	    {
-	      mnew = make_new_monotone_poly(mcur, v0, v1);
-	      traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
-	      traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
-	    }
-	}
-      else
-	{
-	  retval = SP_NOSPLIT;	/* Just traverse all neighbours */
-	  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
-	  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
-	  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
-	  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
-	}
-    }
-  
-  else if ((t-&gt;u0 &gt; 0) &amp;&amp; (t-&gt;u1 &gt; 0)) 
-    {
-      if ((t-&gt;d0 &gt; 0) &amp;&amp; (t-&gt;d1 &gt; 0)) /* downward + upward cusps */
-	{
-	  v0 = tr[t-&gt;d1].lseg;
-	  v1 = tr[t-&gt;u0].rseg;
-	  retval = SP_2UP_2DN;
-	  if (((dir == TR_FROM_DN) &amp;&amp; (t-&gt;d1 == from)) ||
-	      ((dir == TR_FROM_UP) &amp;&amp; (t-&gt;u1 == from)))
-	    {
-	      do_switch = TRUE;
-	      mnew = make_new_monotone_poly(mcur, v1, v0);
-	      traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
-	      traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
-	      traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
-	      traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
-	    }
-	  else
-	    {
-	      mnew = make_new_monotone_poly(mcur, v0, v1);
-	      traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
-	      traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
-	      traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
-	      traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);	      
-	    }
-	}
-      else			/* only downward cusp */
-	{
-	  if (_equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;lseg].v1))
-	    {
-	      v0 = tr[t-&gt;u0].rseg;
-	      v1 = seg[t-&gt;lseg].next;
 
-	      retval = SP_2UP_LEFT;
-	      if ((dir == TR_FROM_UP) &amp;&amp; (t-&gt;u0 == from))
-		{
-		  do_switch = TRUE;
-		  mnew = make_new_monotone_poly(mcur, v1, v0);
-		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+	/* special cases for triangles with cusps at the opposite ends. */
+	/* take care of this first */
+	if ((t-&gt;u0 &lt;= 0) &amp;&amp; (t-&gt;u1 &lt;= 0)) {
+		if ((t-&gt;d0 &gt; 0) &amp;&amp; (t-&gt;d1 &gt; 0)) { /* downward opening triangle */
+			v0 = tr[t-&gt;d1].lseg;
+			v1 = t-&gt;lseg;
+			if (from == t-&gt;d1) {
+				do_switch = TRUE;
+				mnew = make_new_monotone_poly(mcur, v1, v0);
+				traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+				traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+			} else {
+				mnew = make_new_monotone_poly(mcur, v0, v1);
+				traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+				traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+			}
+		} else {
+			retval = SP_NOSPLIT;	/* Just traverse all neighbours */
+			traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+			traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+			traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+			traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
 		}
-	      else
-		{
-		  mnew = make_new_monotone_poly(mcur, v0, v1);
-		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
-		}
-	    }
-	  else
-	    {
-	      v0 = t-&gt;rseg;
-	      v1 = tr[t-&gt;u0].rseg;	
-	      retval = SP_2UP_RIGHT;
-	      if ((dir == TR_FROM_UP) &amp;&amp; (t-&gt;u1 == from))
-		{
-		  do_switch = TRUE;
-		  mnew = make_new_monotone_poly(mcur, v1, v0);
-		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
-		}
-	      else
-		{
-		  mnew = make_new_monotone_poly(mcur, v0, v1);
-		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
-		}
-	    }
 	}
-    }
-  else if ((t-&gt;u0 &gt; 0) || (t-&gt;u1 &gt; 0)) /* no downward cusp */
-    {
-      if ((t-&gt;d0 &gt; 0) &amp;&amp; (t-&gt;d1 &gt; 0)) /* only upward cusp */
-	{
-	  if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;lseg].v0))
-	    {
-	      v0 = tr[t-&gt;d1].lseg;
-	      v1 = t-&gt;lseg;
-	      retval = SP_2DN_LEFT;
-	      if (!((dir == TR_FROM_DN) &amp;&amp; (t-&gt;d0 == from)))
-		{
-		  do_switch = TRUE;
-		  mnew = make_new_monotone_poly(mcur, v1, v0);
-		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
-		}
-	      else
-		{
-		  mnew = make_new_monotone_poly(mcur, v0, v1);
-		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);	      
-		}
-	    }
-	  else
-	    {
-	      v0 = tr[t-&gt;d1].lseg;
-	      v1 = seg[t-&gt;rseg].next;
 
-	      retval = SP_2DN_RIGHT;	    
-	      if ((dir == TR_FROM_DN) &amp;&amp; (t-&gt;d1 == from))
-		{
-		  do_switch = TRUE;
-		  mnew = make_new_monotone_poly(mcur, v1, v0);
-		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+	else if ((t-&gt;d0 &lt;= 0) &amp;&amp; (t-&gt;d1 &lt;= 0)) {
+		if ((t-&gt;u0 &gt; 0) &amp;&amp; (t-&gt;u1 &gt; 0)) { /* upward opening triangle */
+			v0 = t-&gt;rseg;
+			v1 = tr[t-&gt;u0].rseg;
+			if (from == t-&gt;u1) {
+				do_switch = TRUE;
+				mnew = make_new_monotone_poly(mcur, v1, v0);
+				traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+				traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+			} else {
+				mnew = make_new_monotone_poly(mcur, v0, v1);
+				traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+				traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+			}
+		} else {
+			retval = SP_NOSPLIT;	/* Just traverse all neighbours */
+			traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+			traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+			traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+			traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
 		}
-	      else
-		{
-		  mnew = make_new_monotone_poly(mcur, v0, v1);
-		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
-		}
-	    }
 	}
-      else			/* no cusp */
-	{
-	  if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;lseg].v0) &amp;&amp;
-	      _equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;rseg].v0))
-	    {
-	      v0 = t-&gt;rseg;
-	      v1 = t-&gt;lseg;
-	      retval = SP_SIMPLE_LRDN;
-	      if (dir == TR_FROM_UP)
-		{
-		  do_switch = TRUE;
-		  mnew = make_new_monotone_poly(mcur, v1, v0);
-		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+
+	else if ((t-&gt;u0 &gt; 0) &amp;&amp; (t-&gt;u1 &gt; 0)) {
+		if ((t-&gt;d0 &gt; 0) &amp;&amp; (t-&gt;d1 &gt; 0)) { /* downward + upward cusps */
+			v0 = tr[t-&gt;d1].lseg;
+			v1 = tr[t-&gt;u0].rseg;
+			retval = SP_2UP_2DN;
+			if (((dir == TR_FROM_DN) &amp;&amp; (t-&gt;d1 == from)) ||
+			                ((dir == TR_FROM_UP) &amp;&amp; (t-&gt;u1 == from))) {
+				do_switch = TRUE;
+				mnew = make_new_monotone_poly(mcur, v1, v0);
+				traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+				traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+				traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+				traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+			} else {
+				mnew = make_new_monotone_poly(mcur, v0, v1);
+				traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+				traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+				traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+				traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+			}
+		} else {		/* only downward cusp */
+			if (_equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;lseg].v1)) {
+				v0 = tr[t-&gt;u0].rseg;
+				v1 = seg[t-&gt;lseg].next;
+
+				retval = SP_2UP_LEFT;
+				if ((dir == TR_FROM_UP) &amp;&amp; (t-&gt;u0 == from)) {
+					do_switch = TRUE;
+					mnew = make_new_monotone_poly(mcur, v1, v0);
+					traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+				} else {
+					mnew = make_new_monotone_poly(mcur, v0, v1);
+					traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+					traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+					traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+				}
+			} else {
+				v0 = t-&gt;rseg;
+				v1 = tr[t-&gt;u0].rseg;
+				retval = SP_2UP_RIGHT;
+				if ((dir == TR_FROM_UP) &amp;&amp; (t-&gt;u1 == from)) {
+					do_switch = TRUE;
+					mnew = make_new_monotone_poly(mcur, v1, v0);
+					traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+				} else {
+					mnew = make_new_monotone_poly(mcur, v0, v1);
+					traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+					traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+					traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+				}
+			}
 		}
-	      else
-		{
-		  mnew = make_new_monotone_poly(mcur, v0, v1);
-		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
-		}
-	    }
-	  else if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;rseg].v1) &amp;&amp;
-		   _equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;lseg].v1))
-	    {
-	      v0 = seg[t-&gt;rseg].next;
-	      v1 = seg[t-&gt;lseg].next;
+	} else if ((t-&gt;u0 &gt; 0) || (t-&gt;u1 &gt; 0)) { /* no downward cusp */
+		if ((t-&gt;d0 &gt; 0) &amp;&amp; (t-&gt;d1 &gt; 0)) { /* only upward cusp */
+			if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;lseg].v0)) {
+				v0 = tr[t-&gt;d1].lseg;
+				v1 = t-&gt;lseg;
+				retval = SP_2DN_LEFT;
+				if (!((dir == TR_FROM_DN) &amp;&amp; (t-&gt;d0 == from))) {
+					do_switch = TRUE;
+					mnew = make_new_monotone_poly(mcur, v1, v0);
+					traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+					traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+					traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+				} else {
+					mnew = make_new_monotone_poly(mcur, v0, v1);
+					traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+				}
+			} else {
+				v0 = tr[t-&gt;d1].lseg;
+				v1 = seg[t-&gt;rseg].next;
 
-	      retval = SP_SIMPLE_LRUP;
-	      if (dir == TR_FROM_UP)
-		{
-		  do_switch = TRUE;
-		  mnew = make_new_monotone_poly(mcur, v1, v0);
-		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+				retval = SP_2DN_RIGHT;
+				if ((dir == TR_FROM_DN) &amp;&amp; (t-&gt;d1 == from)) {
+					do_switch = TRUE;
+					mnew = make_new_monotone_poly(mcur, v1, v0);
+					traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+				} else {
+					mnew = make_new_monotone_poly(mcur, v0, v1);
+					traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+					traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+					traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+				}
+			}
+		} else {		/* no cusp */
+			if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;lseg].v0) &amp;&amp;
+			                _equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;rseg].v0)) {
+				v0 = t-&gt;rseg;
+				v1 = t-&gt;lseg;
+				retval = SP_SIMPLE_LRDN;
+				if (dir == TR_FROM_UP) {
+					do_switch = TRUE;
+					mnew = make_new_monotone_poly(mcur, v1, v0);
+					traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+					traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+				} else {
+					mnew = make_new_monotone_poly(mcur, v0, v1);
+					traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+					traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+				}
+			} else if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;rseg].v1) &amp;&amp;
+			                _equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;lseg].v1)) {
+				v0 = seg[t-&gt;rseg].next;
+				v1 = seg[t-&gt;lseg].next;
+
+				retval = SP_SIMPLE_LRUP;
+				if (dir == TR_FROM_UP) {
+					do_switch = TRUE;
+					mnew = make_new_monotone_poly(mcur, v1, v0);
+					traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+					traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+				} else {
+					mnew = make_new_monotone_poly(mcur, v0, v1);
+					traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+					traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+				}
+			} else {		/* no split possible */
+				retval = SP_NOSPLIT;
+				traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+				traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+				traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+				traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+			}
 		}
-	      else
-		{
-		  mnew = make_new_monotone_poly(mcur, v0, v1);
-		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
-		}
-	    }
-	  else			/* no split possible */
-	    {
-	      retval = SP_NOSPLIT;
-	      traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
-	      traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
-	      traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
-	      traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);	      	      
-	    }
 	}
-    }
 
-  return retval;
+	return retval;
 }
 
 
@@ -603,157 +542,138 @@
 /* Take care not to triangulate duplicate monotone polygons */
 
 int triangulate_monotone_polygons(nvert, nmonpoly, op)
-     int nvert;
-     int nmonpoly;
-     int op[][3];
+int nvert;
+int nmonpoly;
+int op[][3];
 {
-  register int i;
-  point_t ymax, ymin;
-  int p, vfirst, posmax, posmin, v;
-  int vcount, processed;
+	register int i;
+	point_t ymax, ymin;
+	int p, vfirst, posmax, posmin, v;
+	int vcount, processed;
 
 
-  op_idx = 0;
-  for (i = 0; i &lt; nmonpoly; i++)
-    {
-      vcount = 1;
-      processed = FALSE;
-      vfirst = mchain[mon[i]].vnum;
-      ymax = ymin = vert[vfirst].pt;
-      posmax = posmin = mon[i];
-      mchain[mon[i]].marked = TRUE;
-      p = mchain[mon[i]].next;
-      while ((v = mchain[p].vnum) != vfirst)
-	{
-	 if (mchain[p].marked)
-	   {
-	     processed = TRUE;
-	     break;		/* break from while */
-	   }
-	 else
-	   mchain[p].marked = TRUE;
+	op_idx = 0;
+	for (i = 0; i &lt; nmonpoly; i++) {
+		vcount = 1;
+		processed = FALSE;
+		vfirst = mchain[mon[i]].vnum;
+		ymax = ymin = vert[vfirst].pt;
+		posmax = posmin = mon[i];
+		mchain[mon[i]].marked = TRUE;
+		p = mchain[mon[i]].next;
+		while ((v = mchain[p].vnum) != vfirst) {
+			if (mchain[p].marked) {
+				processed = TRUE;
+				break;		/* break from while */
+			} else
+				mchain[p].marked = TRUE;
 
-	  if (_greater_than(&amp;vert[v].pt, &amp;ymax))
-	    {
-	      ymax = vert[v].pt;
-	      posmax = p;
-	    }
-	  if (_less_than(&amp;vert[v].pt, &amp;ymin))
-	    {
-	      ymin = vert[v].pt;
-	      posmin = p;
-	    }
-	  p = mchain[p].next;
-	  vcount++;
-       }
+			if (_greater_than(&amp;vert[v].pt, &amp;ymax)) {
+				ymax = vert[v].pt;
+				posmax = p;
+			}
+			if (_less_than(&amp;vert[v].pt, &amp;ymin)) {
+				ymin = vert[v].pt;
+				posmin = p;
+			}
+			p = mchain[p].next;
+			vcount++;
+		}
 
-      if (processed)		/* Go to next polygon */
-	continue;
-      
-      if (vcount == 3)		/* already a triangle */
-	{
-	  op[op_idx][0] = mchain[p].vnum;
-	  op[op_idx][1] = mchain[mchain[p].next].vnum;
-	  op[op_idx][2] = mchain[mchain[p].prev].vnum;
-	  op_idx++;
+		if (processed)		/* Go to next polygon */
+			continue;
+
+		if (vcount == 3) {	/* already a triangle */
+			op[op_idx][0] = mchain[p].vnum;
+			op[op_idx][1] = mchain[mchain[p].next].vnum;
+			op[op_idx][2] = mchain[mchain[p].prev].vnum;
+			op_idx++;
+		} else {		/* triangulate the polygon */
+			v = mchain[mchain[posmax].next].vnum;
+			if (_equal_to(&amp;vert[v].pt, &amp;ymin)) {			/* LHS is a single line */
+				triangulate_single_polygon(nvert, posmax, TRI_LHS, op);
+			} else
+				triangulate_single_polygon(nvert, posmax, TRI_RHS, op);
+		}
 	}
-      else			/* triangulate the polygon */
-	{
-	  v = mchain[mchain[posmax].next].vnum;
-	  if (_equal_to(&amp;vert[v].pt, &amp;ymin))
-	    {			/* LHS is a single line */
-	      triangulate_single_polygon(nvert, posmax, TRI_LHS, op);
-	    }
-	  else
-	    triangulate_single_polygon(nvert, posmax, TRI_RHS, op);
-	}
-    }
-  
-  for (i = 0; i &lt; op_idx; i++)
-    errds(VLOW,&quot;sei:triangulate_monotone_polygons()&quot;,&quot;tri #%d: (%d, %d, %d)\n&quot;, i, op[i][0], op[i][1],
-	   op[i][2]);
-  return op_idx;
+
+	for (i = 0; i &lt; op_idx; i++)
+		errds(VLOW,&quot;sei:triangulate_monotone_polygons()&quot;,&quot;tri #%d: (%d, %d, %d)\n&quot;, i, op[i][0], op[i][1],
+		      op[i][2]);
+	return op_idx;
 }
 
 
-/* A greedy corner-cutting algorithm to triangulate a y-monotone 
+/* A greedy corner-cutting algorithm to triangulate a y-monotone
  * polygon in O(n) time.
  * Joseph O-Rourke, Computational Geometry in C.
  */
 static int triangulate_single_polygon(nvert, posmax, side, op)
-     int nvert;
-     int posmax;
-     int side;
-     int op[][3];
+int nvert;
+int posmax;
+int side;
+int op[][3];
 {
-  register int v;
-  int rc[SEGSIZE], ri = 0;	/* reflex chain */
-  int endv, tmp, vpos;
-  
-  if (side == TRI_RHS)		/* RHS segment is a single segment */
-    {
-      rc[0] = mchain[posmax].vnum;
-      tmp = mchain[posmax].next;
-      rc[1] = mchain[tmp].vnum;
-      ri = 1;
-      
-      vpos = mchain[tmp].next;
-      v = mchain[vpos].vnum;
-      
-      if ((endv = mchain[mchain[posmax].prev].vnum) == 0)
-	endv = nvert;
-    }
-  else				/* LHS is a single segment */
-    {
-      tmp = mchain[posmax].next;
-      rc[0] = mchain[tmp].vnum;
-      tmp = mchain[tmp].next;
-      rc[1] = mchain[tmp].vnum;
-      ri = 1;
+	register int v;
+	int rc[SEGSIZE], ri = 0;	/* reflex chain */
+	int endv, tmp, vpos;
 
-      vpos = mchain[tmp].next;
-      v = mchain[vpos].vnum;
+	if (side == TRI_RHS) {	/* RHS segment is a single segment */
+		rc[0] = mchain[posmax].vnum;
+		tmp = mchain[posmax].next;
+		rc[1] = mchain[tmp].vnum;
+		ri = 1;
 
-      endv = mchain[posmax].vnum;
-    }
-  
-  while ((v != endv) || (ri &gt; 1))
-    {
-      if (ri &gt; 0)		/* reflex chain is non-empty */
-	{
-	  if (CROSS(vert[v].pt, vert[rc[ri - 1]].pt, 
-		    vert[rc[ri]].pt) &gt; 0)
-	    {			/* convex corner: cut if off */
-	      op[op_idx][0] = rc[ri - 1];
-	      op[op_idx][1] = rc[ri];
-	      op[op_idx][2] = v;
-	      op_idx++;	     
-	      ri--;
-	    }
-	  else		/* non-convex */
-	    {		/* add v to the chain */
-	      ri++;
-	      rc[ri] = v;
-	      vpos = mchain[vpos].next;
-	      v = mchain[vpos].vnum;
-	    }
+		vpos = mchain[tmp].next;
+		v = mchain[vpos].vnum;
+
+		if ((endv = mchain[mchain[posmax].prev].vnum) == 0)
+			endv = nvert;
+	} else {			/* LHS is a single segment */
+		tmp = mchain[posmax].next;
+		rc[0] = mchain[tmp].vnum;
+		tmp = mchain[tmp].next;
+		rc[1] = mchain[tmp].vnum;
+		ri = 1;
+
+		vpos = mchain[tmp].next;
+		v = mchain[vpos].vnum;
+
+		endv = mchain[posmax].vnum;
 	}
-      else			/* reflex-chain empty: add v to the */
-	{			/* reflex chain and advance it  */
-	  rc[++ri] = v;
-	  vpos = mchain[vpos].next;
-	  v = mchain[vpos].vnum;
-	}
-    } /* end-while */
-  
-  /* reached the bottom vertex. Add in the triangle formed */
-  op[op_idx][0] = rc[ri - 1];
-  op[op_idx][1] = rc[ri];
-  op[op_idx][2] = v;
-  op_idx++;	     
-  ri--;
-  
-  return 0;
+
+	while ((v != endv) || (ri &gt; 1)) {
+		if (ri &gt; 0) {	/* reflex chain is non-empty */
+			if (CROSS(vert[v].pt, vert[rc[ri - 1]].pt,
+			                vert[rc[ri]].pt) &gt; 0) {			/* convex corner: cut if off */
+				op[op_idx][0] = rc[ri - 1];
+				op[op_idx][1] = rc[ri];
+				op[op_idx][2] = v;
+				op_idx++;
+				ri--;
+			} else		/* non-convex */
+			{		/* add v to the chain */
+				ri++;
+				rc[ri] = v;
+				vpos = mchain[vpos].next;
+				v = mchain[vpos].vnum;
+			}
+		} else			/* reflex-chain empty: add v to the */
+		{			/* reflex chain and advance it  */
+			rc[++ri] = v;
+			vpos = mchain[vpos].next;
+			v = mchain[vpos].vnum;
+		}
+	} /* end-while */
+
+	/* reached the bottom vertex. Add in the triangle formed */
+	op[op_idx][0] = rc[ri - 1];
+	op[op_idx][1] = rc[ri];
+	op[op_idx][2] = v;
+	op_idx++;
+	ri--;
+
+	return 0;
 }
 
 

Modified: trunk/libs3d/sei_tri.c
===================================================================
--- trunk/libs3d/sei_tri.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/sei_tri.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2006 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
- * for public domain: 
+ * for public domain:
  * &lt;snip&gt;
  *
  * This code is in the public domain. Specifically, we give to the public
@@ -20,17 +20,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -43,26 +43,26 @@
 
 
 static int initialise(n)
-     int n;
+int n;
 {
-  register int i;
+	register int i;
 
-  for (i = 1; i &lt;= n; i++)
-    seg[i].is_inserted = FALSE;
+	for (i = 1; i &lt;= n; i++)
+		seg[i].is_inserted = FALSE;
 
-  generate_random_ordering(n);
-  
-  return 0;
+	generate_random_ordering(n);
+
+	return 0;
 }
 
 /* Input specified as contours.
  * Outer contour must be anti-clockwise.
  * All inner contours must be clockwise.
- *  
+ *
  * Every contour is specified by giving all its points in order. No
  * point shoud be repeated. i.e. if the outer contour is a square,
  * only the four distinct endpoints shopudl be specified in order.
- *  
+ *
  * ncontours: #contours
  * cntr: An array describing the number of points in each
  *	 contour. Thus, cntr[i] = #points in the i'th contour.
@@ -72,100 +72,93 @@
  *           vertices[1] instead. The output triangles are
  *	     specified  w.r.t. the indices of these vertices.
  * triangles: Output array to hold triangles.
- *  
+ *
  * Enough space must be allocated for all the arrays before calling
  * this routine
  */
 
 
 int sei_triangulate_polygon(ncontours, cntr, vertices, triangles)
-     int ncontours;
-     int cntr[];
-     double (*vertices)[2];
-     int (*triangles)[3];
+int ncontours;
+int cntr[];
+double (*vertices)[2];
+int (*triangles)[3];
 {
-  register int i;
-  int nmonpoly, ccount, npoints, genus;
-  int n;
+	register int i;
+	int nmonpoly, ccount, npoints, genus;
+	int n;
 
-  memset((void *)seg, 0, sizeof(seg));
-  ccount = 0;
-  i = 1;
-  
-  while (ccount &lt; ncontours)
-    {
-      int j;
-      int first, last;
+	memset((void *)seg, 0, sizeof(seg));
+	ccount = 0;
+	i = 1;
 
-      npoints = cntr[ccount];
-      first = i;
-      last = first + npoints - 1;
-      for (j = 0; j &lt; npoints; j++, i++)
-	{
-	  seg[i].v0.x = vertices[i][0];
-	  seg[i].v0.y = vertices[i][1];
+	while (ccount &lt; ncontours) {
+		int j;
+		int first, last;
 
-	  if (i == last)
-	    {
-	      seg[i].next = first;
-	      seg[i].prev = i-1;
-	      seg[i-1].v1 = seg[i].v0;
-	    }
-	  else if (i == first)
-	    {
-	      seg[i].next = i+1;
-	      seg[i].prev = last;
-	      seg[last].v1 = seg[i].v0;
-	    }
-	  else
-	    {
-	      seg[i].prev = i-1;
-	      seg[i].next = i+1;
-	      seg[i-1].v1 = seg[i].v0;
-	    }
-	  
-	  seg[i].is_inserted = FALSE;
+		npoints = cntr[ccount];
+		first = i;
+		last = first + npoints - 1;
+		for (j = 0; j &lt; npoints; j++, i++) {
+			seg[i].v0.x = vertices[i][0];
+			seg[i].v0.y = vertices[i][1];
+
+			if (i == last) {
+				seg[i].next = first;
+				seg[i].prev = i-1;
+				seg[i-1].v1 = seg[i].v0;
+			} else if (i == first) {
+				seg[i].next = i+1;
+				seg[i].prev = last;
+				seg[last].v1 = seg[i].v0;
+			} else {
+				seg[i].prev = i-1;
+				seg[i].next = i+1;
+				seg[i-1].v1 = seg[i].v0;
+			}
+
+			seg[i].is_inserted = FALSE;
+		}
+
+		ccount++;
 	}
-      
-      ccount++;
-    }
-  
-  genus = ncontours - 1;
-  n = i-1;
 
-  initialise(n);
-  construct_trapezoids(n);
-  nmonpoly = monotonate_trapezoids(n);
-  return(triangulate_monotone_polygons(n, nmonpoly, triangles));
+	genus = ncontours - 1;
+	n = i-1;
+
+	initialise(n);
+	construct_trapezoids(n);
+	nmonpoly = monotonate_trapezoids(n);
+	return(triangulate_monotone_polygons(n, nmonpoly, triangles));
 }
 
 
-/* This function returns TRUE or FALSE depending upon whether the 
+/* This function returns TRUE or FALSE depending upon whether the
  * vertex is inside the polygon or not. The polygon must already have
  * been triangulated before this routine is called.
- * This routine will always detect all the points belonging to the 
- * set (polygon-area - polygon-boundary). The return value for points 
+ * This routine will always detect all the points belonging to the
+ * set (polygon-area - polygon-boundary). The return value for points
  * on the boundary is not consistent!!!
  */
 
 int is_point_inside_polygon(vertex)
-     double vertex[2];
+double vertex[2];
 {
-  point_t v;
-  int trnum, rseg;
-  trap_t *t;
+	point_t v;
+	int trnum, rseg;
+	trap_t *t;
 
-  v.x = vertex[0];
-  v.y = vertex[1];
-  
-  trnum = locate_endpoint(&amp;v, &amp;v, 1);
-  t = &amp;tr[trnum];
-  
-  if (t-&gt;state == ST_INVALID)
-    return FALSE;
-  
-  if ((t-&gt;lseg &lt;= 0) || (t-&gt;rseg &lt;= 0))
-    return FALSE;
-  rseg = t-&gt;rseg;
-  return _greater_than_equal_to(&amp;seg[rseg].v1, &amp;seg[rseg].v0);
+	v.x = vertex[0];
+	v.y = vertex[1];
+
+	trnum = locate_endpoint(&amp;v, &amp;v, 1);
+	t = &amp;tr[trnum];
+
+	if (t-&gt;state == ST_INVALID)
+		return FALSE;
+
+	if ((t-&gt;lseg &lt;= 0) || (t-&gt;rseg &lt;= 0))
+		return FALSE;
+	rseg = t-&gt;rseg;
+	return _greater_than_equal_to(&amp;seg[rseg].v1, &amp;seg[rseg].v0);
 }

Modified: trunk/libs3d/sei_triangulate.h
===================================================================
--- trunk/libs3d/sei_triangulate.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/sei_triangulate.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,9 +1,9 @@
 /*
  * sei_triangulate.h
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
- * for public domain: 
+ * for public domain:
  * &lt;snip&gt;
  *
  * This code is in the public domain. Specifically, we give to the public
@@ -20,17 +20,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -47,59 +47,59 @@
 #include &quot;s3dlib.h&quot;
 
 typedef struct {
-  double x, y;
+	double x, y;
 } point_t, vector_t;
 
 
 /* Segment attributes */
 
-typedef struct {	
-  point_t v0, v1;		/* two endpoints */
-  int is_inserted;		/* inserted in trapezoidation yet ? */
-  int root0, root1;		/* root nodes in Q */
-  int next;			/* Next logical segment */
-  int prev;			/* Previous segment */
+typedef struct {
+	point_t v0, v1;		/* two endpoints */
+	int is_inserted;		/* inserted in trapezoidation yet ? */
+	int root0, root1;		/* root nodes in Q */
+	int next;			/* Next logical segment */
+	int prev;			/* Previous segment */
 } segment_t;
 
 
 /* Trapezoid attributes */
 
 typedef struct {
-  int lseg, rseg;		/* two adjoining segments */
-  point_t hi, lo;		/* max/min y-values */
-  int u0, u1;
-  int d0, d1;
-  int sink;			/* pointer to corresponding in Q */
-  int usave, uside;		/* I forgot what this means */
-  int state;
+	int lseg, rseg;		/* two adjoining segments */
+	point_t hi, lo;		/* max/min y-values */
+	int u0, u1;
+	int d0, d1;
+	int sink;			/* pointer to corresponding in Q */
+	int usave, uside;		/* I forgot what this means */
+	int state;
 } trap_t;
 
 
 /* Node attributes for every node in the query structure */
 
 typedef struct {
-  int nodetype;			/* Y-node or S-node */
-  int segnum;
-  point_t yval;
-  int trnum;
-  int parent;			/* doubly linked DAG */
-  int left, right;		/* children */
+	int nodetype;			/* Y-node or S-node */
+	int segnum;
+	point_t yval;
+	int trnum;
+	int parent;			/* doubly linked DAG */
+	int left, right;		/* children */
 } node_t;
 
 
 typedef struct {
-  int vnum;
-  int next;			/* Circularly linked list  */
-  int prev;			/* describing the monotone */
-  int marked;			/* polygon */
-} monchain_t;			
+	int vnum;
+	int next;			/* Circularly linked list  */
+	int prev;			/* describing the monotone */
+	int marked;			/* polygon */
+} monchain_t;
 
 
 typedef struct {
-  point_t pt;
-  int vnext[4];			/* next vertices for the 4 chains */
-  int vpos[4];			/* position of v in the 4 chains */
-  int nextfree;
+	point_t pt;
+	int vnext[4];			/* next vertices for the 4 chains */
+	int vpos[4];			/* position of v in the 4 chains */
+	int nextfree;
 } vertexchain_t;
 
 #ifdef DEBUG
@@ -113,10 +113,10 @@
 
 
 #define SEGSIZE SEI_SS	/* max# of segments. Determines how */
-						/* many points can be specified as */
-						/* input. If your datasets have large */
-						/* number of points, increase this */
-						/* value accordingly. */
+/* many points can be specified as */
+/* input. If your datasets have large */
+/* number of points, increase this */
+/* value accordingly. */
 
 #define QSIZE   8*SEGSIZE	/* maximum table sizes */
 #define TRSIZE  4*SEGSIZE	/* max# trapezoids */
@@ -126,16 +126,16 @@
 #define FALSE 0
 
 
-#define FIRSTPT 1		/* checking whether pt. is inserted */ 
+#define FIRSTPT 1		/* checking whether pt. is inserted */
 #define LASTPT  2
 
 
 #define INFINITY 1&lt;&lt;30
 #define C_EPS 1.0e-7		/* tolerance value: Used for making */
-							/* all decisions about collinearity or */
-							/* left/right of segment. Decrease */
-							/* this value if the input points are */
-							/* spaced very close together */
+/* all decisions about collinearity or */
+/* left/right of segment. Decrease */
+/* this value if the input points are */
+/* spaced very close together */
 
 
 #define S_LEFT 1		/* for merge-direction */
@@ -153,7 +153,7 @@
 #define SP_2UP_RIGHT   5
 #define SP_2DN_LEFT    6
 #define SP_2DN_RIGHT   7
-#define SP_NOSPLIT    -1	
+#define SP_NOSPLIT    -1
 
 #define TR_FROM_UP 1		/* for traverse-direction */
 #define TR_FROM_DN 2

Modified: trunk/libs3d/shm.c
===================================================================
--- trunk/libs3d/shm.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/shm.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -47,16 +47,18 @@
 static struct buf_t *data_in,*data_out;
 static int shmid_in, shmid_out;
 static int shm_idle=0;
-struct timespec t={0,10*1000*1000}; /* 10 mili second */
+struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili second */
 /* char ftoken[]=&quot;/tmp/.s3d_shm&quot;;*/
 
 int _shm_init(char *ftoken)
 {
 	int shmid;
 	uint32_t *next_key;
-/*	struct shmid_ds *buf; */
+	/*	struct shmid_ds *buf; */
 	key_t key,key_out,key_in;
-	
+
 	s3dprintf(MED,&quot;connecting to shm token %s&quot;,ftoken);
 	/* make the key: */
 	if ((key = ftok(ftoken, 'R')) == -1) {
@@ -64,7 +66,7 @@
 		return(1);
 	}
 	s3dprintf(MED,&quot;init key is 0x%08x&quot;,key);
-	
+
 	/* connect to the segment: */
 	if ((shmid = shmget(key, SHM_SIZE, 0644 )) == -1) {
 		errn(&quot;shm_init():shmget()&quot;,errno);
@@ -82,7 +84,7 @@
 	next_key[0]=next_key[1]=0;
 	s3dprintf(MED,&quot;right now, next_keys are: %08x, %08x&quot;,key_in,key_out);
 	/* as we have the new key, we  can detach here now. */
-	if (shmdt(next_key) == -1) { 
+	if (shmdt(next_key) == -1) {
 		errn(&quot;shm_init():shmdt()&quot;,errno);
 		return(1);
 	}
@@ -108,7 +110,7 @@
 		errn(&quot;shm_init():shmat()&quot;,errno);
 		return(1);
 	}
-	return(0);	
+	return(0);
 }
 int _shm_quit()
 {
@@ -128,20 +130,18 @@
 {
 	int no_left,no_written,wait=0;
 	no_left = s;
-	while (no_left &gt; 0) 
-    { 
+	while (no_left &gt; 0) {
 		no_written = shm_write(data_out,str,no_left);
- 		if (no_written &lt;0)  
+		if (no_written &lt;0)
 			return(no_written);
 		no_left -= no_written;
 		str += no_written;
-		if (wait++&gt;SHM_MAXLOOP) 
-		{
+		if (wait++&gt;SHM_MAXLOOP) {
 			s3dprintf(HIGH,&quot;shm_writen():waited too long ...&quot;);
 			return(-1);
 		}
-/*		if (wait&gt;10)
-			nanosleep(&amp;t,NULL); */
+		/*		if (wait&gt;10)
+					nanosleep(&amp;t,NULL); */
 	}
 	return(s - no_left);
 }
@@ -149,22 +149,20 @@
 {
 	int no_left,no_read,wait=0;
 	no_left = s;
-	while (no_left &gt; 0) 
-	{ 
+	while (no_left &gt; 0) {
 		no_read = shm_read(data_in,str,no_left);
-		if(no_read &lt;0)  
+		if (no_read &lt;0)
 			return(no_read);
-		if (no_read == 0) 
+		if (no_read == 0)
 			break;
 		no_left -= no_read;
 		str += no_read;
-		if (wait++&gt;SHM_MAXLOOP) 
-		{
+		if (wait++&gt;SHM_MAXLOOP) {
 			s3dprintf(HIGH,&quot;shm_readn():waited too long ...&quot;);
 			return(-1);
 		}
-/*		if (wait&gt;10)
-			nanosleep(&amp;t,NULL); */
+		/*		if (wait&gt;10)
+					nanosleep(&amp;t,NULL); */
 	}
 	return(s - no_left);
 }
@@ -174,13 +172,11 @@
 	char				 opcode,*buf;
 	u_int16_t		 length;
 	struct shmid_ds		 d;
-	
+
 	if (data_in==NULL)
 		return(found);
-	if (data_in-&gt;start!=data_in-&gt;end)
-	{
-		if (1==shm_readn(&amp;opcode,1))
-		{
+	if (data_in-&gt;start!=data_in-&gt;end) {
+		if (1==shm_readn(&amp;opcode,1)) {
 			shm_readn((char *)&amp;length,2);
 			length=ntohs(length);
 			buf=malloc(length);
@@ -192,14 +188,12 @@
 			s3d_quit();
 		}
 	} else {
-		if (shm_idle++&gt;SHM_MAX_IDLE)
-		{
+		if (shm_idle++&gt;SHM_MAX_IDLE) {
 			shmctl(shmid_in,IPC_STAT,&amp;d);
-			if (d.shm_nattch==1) /* we're all alone ... remove it!! */
-			{
+			if (d.shm_nattch==1) { /* we're all alone ... remove it!! */
 				s3dprintf(MED,&quot;server vanished ... &quot;);
 				s3d_quit();
-			} else 
+			} else
 				shm_idle=0;
 		}
 	}

Modified: trunk/libs3d/shm_ringbuf.c
===================================================================
--- trunk/libs3d/shm_ringbuf.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/shm_ringbuf.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -40,31 +40,28 @@
 	data=((char *)rb)+sizeof(struct buf_t);
 	if (e&lt;s) {
 		wrap=1;
-	} 
-	while ((((s+size*(1-wrap))-e)&lt;(n+1))) /* checking free space */
-	{
-		if /*((size*2)&gt;RB_MAX_SIZE)*/ (1)
-		{
-	/*		s3dprintf(MED,&quot;buffer reached maxsize, no resizing possible&quot;);*/
+	}
+	while ((((s+size*(1-wrap))-e)&lt;(n+1))) { /* checking free space */
+		if /*((size*2)&gt;RB_MAX_SIZE)*/ (1) {
+			/*		s3dprintf(MED,&quot;buffer reached maxsize, no resizing possible&quot;);*/
 			return(0);
 		}
-/*		printf(&quot;buffer full!! resizing ... (to size %d)&quot;,(int)size*2);
-		if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
-		{
-			printf(&quot;realloc failed - fatal!!&quot;);
-			return(-1);
-		}
-		if (wrap)
-		{
-			memcpy(data+size,data,e);
-			e+=size;
-			wrap=0;
-		}
-		size=rb-&gt;bufsize=size*2;
-		rb-&gt;end=e;*/
+		/*		printf(&quot;buffer full!! resizing ... (to size %d)&quot;,(int)size*2);
+				if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
+				{
+					printf(&quot;realloc failed - fatal!!&quot;);
+					return(-1);
+				}
+				if (wrap)
+				{
+					memcpy(data+size,data,e);
+					e+=size;
+					wrap=0;
+				}
+				size=rb-&gt;bufsize=size*2;
+				rb-&gt;end=e;*/
 	}
-	if ((e+n)&gt;size)
-	{
+	if ((e+n)&gt;size) {
 		rs=size-e;
 		memcpy(data+e,buf,rs);			/* copy the first part ... */
 		memcpy(data,buf+rs,n-rs); 		/* .. end the rest */
@@ -90,8 +87,7 @@
 	if (e&lt;s) wrap=1;
 	rs=(e+wrap*size-s);
 	mn=(n&gt;rs)?rs:n;
-	if ((wrap) &amp;&amp; (mn&gt;(size-s))) 
-	{
+	if ((wrap) &amp;&amp; (mn&gt;(size-s))) {
 		rs=size-s;	/* size of the first part */
 		memcpy(buf,data+s,rs);
 		memcpy(buf+rs,data,mn-rs);

Modified: trunk/libs3d/tcp.c
===================================================================
--- trunk/libs3d/tcp.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/tcp.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -31,8 +31,8 @@
 #include &lt;sys/socket.h&gt;
 #include &lt;netinet/in.h&gt;  /*  htons(),htonl() */
 #ifndef WIN32
-	#include &lt;sys/select.h&gt;
-	#include &lt;netdb.h&gt;		 /*  gethostbyname()  */
+#include &lt;sys/select.h&gt;
+#include &lt;netdb.h&gt;		 /*  gethostbyname()  */
 #endif
 #ifdef SIGS
 #define __USE_BSD	1		/* we want sig_t and F_SETOWN to be defined */
@@ -58,51 +58,49 @@
 {
 	int 	 			 sd;
 	int 				 res;
-/*	char			 	*port=NULL;*/
+	/*	char			 	*port=NULL;*/
 	struct sockaddr_in 	 sock;
 	struct hostent 		*server=0;
 #ifdef SIGS
 	_s3d_sigio=0;
 #endif
-#ifdef WIN32 
-   WSADATA datainfo;
-   if (WSAStartup(257, &amp;datainfo) != 0)
-   {
-     errn(&quot;s3d_init():startup()&quot;, errno);
-	 return(-1);
-   }
-#endif 
+#ifdef WIN32
+	WSADATA datainfo;
+	if (WSAStartup(257, &amp;datainfo) != 0) {
+		errn(&quot;s3d_init():startup()&quot;, errno);
+		return(-1);
+	}
+#endif
 	if ((sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) {
-	  errn(&quot;s3d_init():socket()&quot;,errno);
-	  return (-1);
+		errn(&quot;s3d_init():socket()&quot;,errno);
+		return (-1);
 	}
 	sock.sin_family = AF_INET;
 	if (*sv==0)  /*  no server argument */
 		sv=&quot;127.0.0.1&quot;;
 	if ((server = gethostbyname(sv)))
-      memcpy(&amp;sock.sin_addr.s_addr, server-&gt;h_addr_list[0], 4);
-	else 
-	{
+		memcpy(&amp;sock.sin_addr.s_addr, server-&gt;h_addr_list[0], 4);
+	else {
 		errn(&quot;s3d_init():gethostbyname()&quot;,errno);
 		return(-1);
 	}
-	sock.sin_port = htons(pn); 
+	sock.sin_port = htons(pn);
 
 	res = connect(sd, (struct sockaddr *) &amp;sock, sizeof(struct sockaddr_in));
 	if (res &lt; 0 ) {
-	  errn(&quot;s3d_init():connect()&quot;,errno);
-	  return(-1);
+		errn(&quot;s3d_init():connect()&quot;,errno);
+		return(-1);
 	}
-/*    if ( fcntl(sd, F_SETFL, O_ASYNC | O_NONBLOCK) &lt; 0 ) */
-/* 		errn(&quot;fcntl()&quot;,errno); */
-#ifdef SIGS 
-   if ( fcntl(sd, F_SETFL, O_ASYNC ) &lt; 0 )
+	/*    if ( fcntl(sd, F_SETFL, O_ASYNC | O_NONBLOCK) &lt; 0 ) */
+	/* 		errn(&quot;fcntl()&quot;,errno); */
+#ifdef SIGS
+	if ( fcntl(sd, F_SETFL, O_ASYNC ) &lt; 0 )
 		errn(&quot;fcntl()&quot;,errno);
-   if ( fcntl(sd, F_SETOWN, getpid()) &lt; 0 )
+	if ( fcntl(sd, F_SETOWN, getpid()) &lt; 0 )
 		errn(&quot;fcntl()&quot;,errno);
-    if (signal(SIGPIPE, (sig_t)sigpipe_handler) == SIG_ERR) 
+	if (signal(SIGPIPE, (sig_t)sigpipe_handler) == SIG_ERR)
 		errn(&quot;_tcp_init():signal()&quot;,errno);
-    if (signal(SIGIO, (sig_t)sigio_handler) == SIG_ERR) 
+	if (signal(SIGIO, (sig_t)sigio_handler) == SIG_ERR)
 		errn(&quot;_tcp_init():signal()&quot;,errno);
 #endif
 	s3d_socket=sd;
@@ -111,8 +109,7 @@
 }
 int _tcp_quit()
 {
-	if (s3d_socket)
-	{
+	if (s3d_socket) {
 		s3dprintf(MED,&quot;closing socket %d&quot;,s3d_socket);
 		close(s3d_socket);
 		s3d_socket=0;
@@ -120,27 +117,29 @@
 	return(0);
 }
 int tcp_readn(char *str,int s)
-{         int no_left,no_read;
-          no_left = s;
-          while (no_left &gt; 0) 
-                     { no_read = read(s3d_socket,str,no_left);
-                       if(no_read &lt;0)  return(no_read);
-                       if (no_read == 0) break;
-                       no_left -= no_read;
-                       str += no_read;
-                     }
-          return(s - no_left);
+{
+	int no_left,no_read;
+	no_left = s;
+	while (no_left &gt; 0) {
+		no_read = read(s3d_socket,str,no_left);
+		if (no_read &lt;0)  return(no_read);
+		if (no_read == 0) break;
+		no_left -= no_read;
+		str += no_read;
+	}
+	return(s - no_left);
 }
 int tcp_writen(char *str,int s)
-{         int no_left,no_written;
-          no_left = s;
-          while (no_left &gt; 0) 
-                     { no_written = write(s3d_socket,str,no_left);
-                       if(no_written &lt;=0)  return(no_written);
-                       no_left -= no_written;
-                       str += no_written;
-                     }
-          return(s - no_left);
+{
+	int no_left,no_written;
+	no_left = s;
+	while (no_left &gt; 0) {
+		no_written = write(s3d_socket,str,no_left);
+		if (no_written &lt;=0)  return(no_written);
+		no_left -= no_written;
+		str += no_written;
+	}
+	return(s - no_left);
 }
 int _s3d_tcp_net_receive()
 {
@@ -149,24 +148,20 @@
 	int 				 found=0;
 	char				 opcode,*buf;
 	u_int16_t		 length;
-	
-	
-	if (s3d_socket!=-1)
-	{
+
+
+	if (s3d_socket!=-1) {
 		FD_ZERO(&amp;fs_proc);
 		tv.tv_sec=tv.tv_usec=0;
 		FD_SET(s3d_socket,&amp;fs_proc);
-	
-		 /* s3dprintf(LOW,&quot;Added %d procceses into file descriptor ...&quot;, n); */
-		if (select(FD_SETSIZE, &amp;fs_proc, NULL,NULL,&amp;tv) ==-1) 
-		{
-			errn(&quot;select()&quot;,errno); 
+
+		/* s3dprintf(LOW,&quot;Added %d procceses into file descriptor ...&quot;, n); */
+		if (select(FD_SETSIZE, &amp;fs_proc, NULL,NULL,&amp;tv) ==-1) {
+			errn(&quot;select()&quot;,errno);
 		} else {
-			 /*  data is available */
-			if (FD_ISSET(s3d_socket,&amp;fs_proc))
-			{
-				if (1==tcp_readn(&amp;opcode,1))
-				{
+			/*  data is available */
+			if (FD_ISSET(s3d_socket,&amp;fs_proc)) {
+				if (1==tcp_readn(&amp;opcode,1)) {
 					tcp_readn((char *)&amp;length,2);
 					length=ntohs(length);
 					buf=malloc(length);

Modified: trunk/libs3d/vector.c
===================================================================
--- trunk/libs3d/vector.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/vector.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -36,7 +36,8 @@
  *
  ***/
 
-float s3d_vector_length( float vector[] ) {
+float s3d_vector_length( float vector[] )
+{
 
 	return ( sqrt( vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2] ) );
 
@@ -53,7 +54,8 @@
  *
  ***/
 
-void s3d_vector_subtract( float vector1[], float vector2[], float result_vector[] ) {
+void s3d_vector_subtract( float vector1[], float vector2[], float result_vector[] )
+{
 
 	result_vector[0] = vector2[0] - vector1[0];
 	result_vector[1] = vector2[1] - vector1[1];
@@ -72,7 +74,8 @@
  *
  ***/
 
-float s3d_vector_dot_product( float vector1[], float vector2[] ) {
+float s3d_vector_dot_product( float vector1[], float vector2[] )
+{
 	return ( vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2] );
 }
 
@@ -87,7 +90,8 @@
  *
  ***/
 
-void s3d_vector_cross_product( float vector1[], float vector2[], float result_vector[] ) {
+void s3d_vector_cross_product( float vector1[], float vector2[], float result_vector[] )
+{
 	result_vector[0]=vector1[1] * vector2[2] - vector1[2] * vector2[1];
 	result_vector[1]=vector1[2] * vector2[0] - vector1[0] * vector2[2];
 	result_vector[2]=vector1[0] * vector2[1] - vector1[1] * vector2[0];
@@ -105,7 +109,8 @@
  *
  ***/
 
-float s3d_vector_angle( float vector1[], float vector2[] ) {
+float s3d_vector_angle( float vector1[], float vector2[] )
+{
 
 	return ( acos( s3d_vector_dot_product( vector1, vector2 ) / ( s3d_vector_length( vector1 ) * s3d_vector_length( vector2 ) ) ) );
 
@@ -123,7 +128,8 @@
  *
  ***/
 
-float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad ) {
+float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad )
+{
 
 	float angle, tmp_mov_vec[3], desc_norm_vec[3] = { 0.0, 0.0, -1.0 };
 

Modified: trunk/libs3dw/animate.c
===================================================================
--- trunk/libs3dw/animate.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/animate.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -50,23 +50,20 @@
 		s3dprintf(HIGH,&quot;s3dw_ani_add() assert failed: weird, moving cam but its not a cam obeject?&quot;);
 		return;
 	}
-	if ((ani_n&lt;MAXANI) &amp;&amp; (animation_on))
-	{
+	if ((ani_n&lt;MAXANI) &amp;&amp; (animation_on)) {
 		if (s3dw_ani_onstack(f))
 			return;		/* already in list */
 		ani_s[ani_n]=f;
 		s3dw_ani_iterate(f);
 		ani_n++;
-	}
-	else /* no place, finish now */
+	} else /* no place, finish now */
 		s3dw_ani_finish(f,-1);
 }
 /* delete an item from the animation stack */
 void s3dw_ani_del(int i)
 {
-	if ((i&gt;=0) &amp;&amp; (i&lt;ani_n))
-	{
-/*		printf(&quot;[A]ni DEL %d\n&quot;,i);*/
+	if ((i&gt;=0) &amp;&amp; (i&lt;ani_n)) {
+		/*		printf(&quot;[A]ni DEL %d\n&quot;,i);*/
 		ani_n--;
 		ani_s[i]=ani_s[ani_n]; /* that should also work if i is the last one */
 	} else {
@@ -133,11 +130,10 @@
 void s3dw_ani_needarr()
 {
 	ani_need_arr=1;
-	if (!animation_on)	
-	{
+	if (!animation_on) {
 		while (ani_need_arr) s3dw_arrange();
 	}
-		
+
 }
 /* doing the whole animation thing */
 void s3dw_ani_mate()
@@ -146,12 +142,10 @@
 	s3dw_widget *f;
 	animation_on=1;			/* animation is activated */
 	if (ani_need_arr) s3dw_arrange();
-	for (i=0;i&lt;ani_n;i++)
-	{
+	for (i=0;i&lt;ani_n;i++) {
 		f=ani_s[i];
 		s3dw_ani_iterate(f);
-		if (s3dw_ani_check(f))
-		{
+		if (s3dw_ani_check(f)) {
 			s3dw_ani_finish(f,i);
 			i--; /* a new widget is here now, take care in the next iteration */
 		} else {

Modified: trunk/libs3dw/arrange.c
===================================================================
--- trunk/libs3dw/arrange.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/arrange.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -41,12 +41,12 @@
 	xt= cos(widget-&gt;ry/R2D)*x + sin(widget-&gt;ry/R2D) *z;
 	yt=y;
 	zt=-sin(widget-&gt;ry/R2D)*x + cos(widget-&gt;ry/R2D) *z;
-	
+
 	/* around the x axis (vertical direction) */
 	x=xt;
 	y= cos(widget-&gt;rx/R2D)*yt + sin(widget-&gt;rx/R2D) *zt;
 	z=-sin(widget-&gt;rx/R2D)*yt + cos(widget-&gt;rx/R2D) *zt;
-	
+
 	center[0]=x;
 	center[1]=y;
 	center[2]=z;
@@ -54,8 +54,7 @@
 void s3dw_arr_normdir(float *dir)
 {
 	float dirlen=s3d_vector_length(dir);
-	while ((dirlen=s3d_vector_length(dir))==0)
-	{
+	while ((dirlen=s3d_vector_length(dir))==0) {
 		/* make up some random direction if they're exactly the same position */
 		dir[0]=((float)rand() - RAND_MAX/2.0)/RAND_MAX;
 		dir[1]=((float)rand() - RAND_MAX/2.0)/RAND_MAX;
@@ -74,11 +73,9 @@
 	a[0]=0;
 	a[1]=0;
 	a[2]=1;
-	for (i=0;i&lt;root-&gt;nobj;i++)
-	{
+	for (i=0;i&lt;root-&gt;nobj;i++) {
 		w=root-&gt;pobj[i];
-		if ((w-&gt;oid!=0) &amp;&amp; (w-&gt;flags&amp;S3DW_TURN_CAM))
-		{
+		if ((w-&gt;oid!=0) &amp;&amp; (w-&gt;flags&amp;S3DW_TURN_CAM)) {
 			s3dw_arr_widgetcenter(w,op);
 			/* horizontal movement */
 			b[0]=w-&gt;x + op[0]  - _s3dw_cam-&gt;x;
@@ -125,19 +122,17 @@
 	float b[3];
 	float op[3];
 	float lsqr,l;
-	for (i=0;i&lt;root-&gt;nobj;i++)
-	{
+	for (i=0;i&lt;root-&gt;nobj;i++) {
 		w=root-&gt;pobj[i];
 		if ((w-&gt;oid!=0) &amp;&amp; (w-&gt;flags&amp;S3DW_FOLLOW_CAM))
-				
+
 		{
 			s3dw_arr_widgetcenter(w,op);
 			/* horizontal movement */
 			b[0]=_s3dw_cam-&gt;x - (w-&gt;x + op[0]);
 			b[1]=_s3dw_cam-&gt;y - (w-&gt;y + op[1]);
 			b[2]=_s3dw_cam-&gt;z - (w-&gt;z + op[2]);
-			if ((lsqr=(b[0]*b[0] + b[1]*b[1] + b[2]*b[2])) &gt; (DIST * DIST))
-			{
+			if ((lsqr=(b[0]*b[0] + b[1]*b[1] + b[2]*b[2])) &gt; (DIST * DIST)) {
 				/* need to adjust ... */
 				l=sqrt(lsqr);
 				w-&gt;x+= b[0]-b[0]*DIST/l;
@@ -146,7 +141,7 @@
 				w-&gt;flags&amp;=~S3DW_ARRANGED;
 				ani_need_arr=1;
 				s3dw_ani_add(w);
-				
+
 			}
 		}
 	}
@@ -164,23 +159,20 @@
 	for (i=0;i&lt;root-&gt;nobj;i++)
 		if (!(root-&gt;pobj[i]-&gt;flags&amp;S3DW_ARRANGED)) arranged=0;
 	if (arranged &amp;&amp; !ani_need_arr) return; /* no arrangement necceasary .... */
-		
+
 	ani_need_arr=0;
-	if (root-&gt;nobj==1)
-	{
+	if (root-&gt;nobj==1) {
 		w1=root-&gt;pobj[0];
 		w1-&gt;flags|=S3DW_ARRANGED; /* done */
 		return;
 	}
 	allarr=1;
-	for (i=0;i&lt;root-&gt;nobj;i++)
-	{
+	for (i=0;i&lt;root-&gt;nobj;i++) {
 		w1=root-&gt;pobj[i];
 		arranged=1;
 		for (j=0;j&lt;root-&gt;nobj;j++) {
 			w2=root-&gt;pobj[j];
-			if ((i!=j) &amp;&amp; ((w1-&gt;oid!=0) &amp;&amp; (w2-&gt;oid!=0)))
-			{
+			if ((i!=j) &amp;&amp; ((w1-&gt;oid!=0) &amp;&amp; (w2-&gt;oid!=0))) {
 				s3dw_arr_widgetcenter(w1,f1);
 				s3dw_arr_widgetcenter(w2,f2);
 				len1=s3d_vector_length(f1);
@@ -189,8 +181,7 @@
 				dir[1]=(w1-&gt;y+f1[1]) - (w2-&gt;y+f2[1]);
 				dir[2]=(w1-&gt;z+f1[2]) - (w2-&gt;z+f2[2]);
 				dirlen=s3d_vector_length(dir);
-				if (dirlen&lt;(len1+len2))
-				{
+				if (dirlen&lt;(len1+len2)) {
 					allarr=0;
 					arranged=0;
 					w1-&gt;flags&amp;=~S3DW_ARRANGED;
@@ -200,8 +191,7 @@
 					tomove=((len1+len2+1)-dirlen);
 					move1=len1/(len1+len2);
 					move2=len2/(len1+len2);
-					if (w1-&gt;oid!=0)
-					{
+					if (w1-&gt;oid!=0) {
 						w1-&gt;x += tomove * move1 *  dir[0];
 						w1-&gt;y += tomove * move1 *  dir[1];
 						w1-&gt;z += tomove * move1 *  dir[2];
@@ -212,8 +202,7 @@
 						w2-&gt;z += tomove * move2 * -dir[2];
 
 					}
-					if (w2-&gt;oid!=0)
-					{
+					if (w2-&gt;oid!=0) {
 						w2-&gt;x += tomove * move2 * -dir[0];
 						w2-&gt;y += tomove * move2 * -dir[1];
 						w2-&gt;z += tomove * move2 * -dir[2];

Modified: trunk/libs3dw/button.c
===================================================================
--- trunk/libs3dw/button.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/button.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -34,30 +34,46 @@
 	float length;
 	float vertices[8*3];
 	u_int32_t polygons[10*4]={
-			0,4,5,0,
-			0,5,1,0,
-			1,5,6,0,
-			1,6,2,0,
-			2,6,7,0,
-			2,7,3,0,
-			3,7,4,0,
-			3,4,0,0,
-			4,7,6,0,
-			4,6,5,0
+		0,4,5,0,
+		0,5,1,0,
+		1,5,6,0,
+		1,6,2,0,
+		2,6,7,0,
+		2,7,3,0,
+		3,7,4,0,
+		3,4,0,0,
+		4,7,6,0,
+		4,6,5,0
 	};
 
 	button-&gt;oid_text=s3d_draw_string(button-&gt;text,&amp;length);
 	s3d_pep_materials_a(button-&gt;oid_text,widget-&gt;style-&gt;text_mat,1);
 
 	/* width of the button depends on the length of the text */
-	vertices[0*3+0]=0.0;			vertices[0*3+1]=0.0;		vertices[0*3+2]=0.0;	
-	vertices[1*3+0]=0.0;			vertices[1*3+1]=-2.0;		vertices[1*3+2]=0.0;	
-	vertices[2*3+0]=length+1;		vertices[2*3+1]=-2.0;		vertices[2*3+2]=0.0;	
-	vertices[3*3+0]=length+1;		vertices[3*3+1]=0.0;		vertices[3*3+2]=0.0;	
-	vertices[4*3+0]=0.25;			vertices[4*3+1]=-0.25;		vertices[4*3+2]=0.25;	
-	vertices[5*3+0]=0.25;			vertices[5*3+1]=-1.75;		vertices[5*3+2]=0.25;	
-	vertices[6*3+0]=length+0.75;	vertices[6*3+1]=-1.75;		vertices[6*3+2]=0.25;	
-	vertices[7*3+0]=length+0.75;	vertices[7*3+1]=-0.25;		vertices[7*3+2]=0.25;	
+	vertices[0*3+0]=0.0;
+	vertices[0*3+1]=0.0;
+	vertices[0*3+2]=0.0;
+	vertices[1*3+0]=0.0;
+	vertices[1*3+1]=-2.0;
+	vertices[1*3+2]=0.0;
+	vertices[2*3+0]=length+1;
+	vertices[2*3+1]=-2.0;
+	vertices[2*3+2]=0.0;
+	vertices[3*3+0]=length+1;
+	vertices[3*3+1]=0.0;
+	vertices[3*3+2]=0.0;
+	vertices[4*3+0]=0.25;
+	vertices[4*3+1]=-0.25;
+	vertices[4*3+2]=0.25;
+	vertices[5*3+0]=0.25;
+	vertices[5*3+1]=-1.75;
+	vertices[5*3+2]=0.25;
+	vertices[6*3+0]=length+0.75;
+	vertices[6*3+1]=-1.75;
+	vertices[6*3+2]=0.25;
+	vertices[7*3+0]=length+0.75;
+	vertices[7*3+1]=-0.25;
+	vertices[7*3+2]=0.25;
 	widget-&gt;oid=s3d_new_object();
 	s3d_push_materials_a(widget-&gt;oid,widget-&gt;style-&gt;input_mat,1);
 	s3d_push_vertices   (widget-&gt;oid,vertices,8);
@@ -92,15 +108,15 @@
 void s3dw_button_show(s3dw_widget *widget)
 {
 	s3dw_button *button=(s3dw_button *)widget;
-    s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(button-&gt;oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(button-&gt;oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* hide */
 void s3dw_button_hide(s3dw_widget *widget)
 {
 	s3dw_button *button=(s3dw_button *)widget;
-    s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(button-&gt;oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(button-&gt;oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* destroy s3d structures of the button */
 void s3dw_button_erase(s3dw_widget *widget)
@@ -128,8 +144,7 @@
 int s3dw_button_event_click(s3dw_widget *widget, u_int32_t oid)
 {
 	s3dw_button *button=(s3dw_button *)widget;
-	if ((button-&gt;oid_text==oid) || (widget-&gt;oid==oid))
-	{
+	if ((button-&gt;oid_text==oid) || (widget-&gt;oid==oid)) {
 		button-&gt;onclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/event.c
===================================================================
--- trunk/libs3dw/event.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/event.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -39,8 +39,7 @@
 int s3dw_object_info(struct s3d_evt *evt)
 {
 	struct s3d_obj_info *info=(struct s3d_obj_info *)evt-&gt;buf;
-	if (info-&gt;object==0) /* the _s3dw_cam */
-	{
+	if (info-&gt;object==0) { /* the _s3dw_cam */
 		if (_s3dw_cam==NULL)	s3dw_getroot(); /* init, get _s3dw_cam */
 		_s3dw_cam-&gt;ax=_s3dw_cam-&gt;x=info-&gt;trans_x;
 		_s3dw_cam-&gt;ay=_s3dw_cam-&gt;y=info-&gt;trans_y;

Modified: trunk/libs3dw/input.c
===================================================================
--- trunk/libs3dw/input.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/input.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -51,44 +51,68 @@
 	float length;
 	float vertices[12*3];
 	uint32_t polygons[18*4]={
-			0,4,5,1,
-			0,5,1,1,
-			1,5,6,1,
-			1,6,2,1,
-			2,6,7,1,
-			2,7,3,1,
-			3,7,4,1,
-			3,4,0,1,
+		0,4,5,1,
+		0,5,1,1,
+		1,5,6,1,
+		1,6,2,1,
+		2,6,7,1,
+		2,7,3,1,
+		3,7,4,1,
+		3,4,0,1,
 
-			4,8, 9, 1,
-			4,9, 5, 1,
-			5,9, 10,1,
-			5,10,6, 1,
-			6,10,11,1,
-			6,11,7, 1,
-			7,11,8, 1,
-			7,8, 4, 1,
+		4,8, 9, 1,
+		4,9, 5, 1,
+		5,9, 10,1,
+		5,10,6, 1,
+		6,10,11,1,
+		6,11,7, 1,
+		7,11,8, 1,
+		7,8, 4, 1,
 
 
-			8,11,10,0,
-			8,10,9, 0
+		8,11,10,0,
+		8,10,9, 0
 	};
 	length=widget-&gt;width-1;
 	if (widget-&gt;width&lt;1) return;
 	widget-&gt;height=2;
 	/* width of the input depends on the length of the text */
-	vertices[0*3+0]=0.0;			vertices[0*3+1]=0.0;		vertices[0*3+2]=0.0;	
-	vertices[1*3+0]=0.0;			vertices[1*3+1]=-2.0;		vertices[1*3+2]=0.0;	
-	vertices[2*3+0]=length+1;		vertices[2*3+1]=-2.0;		vertices[2*3+2]=0.0;	
-	vertices[3*3+0]=length+1;		vertices[3*3+1]=0.0;		vertices[3*3+2]=0.0;	
-	vertices[4*3+0]=0.125;			vertices[4*3+1]=-0.125;		vertices[4*3+2]=0.25;	
-	vertices[5*3+0]=0.125;			vertices[5*3+1]=-1.875;		vertices[5*3+2]=0.25;	
-	vertices[6*3+0]=length+0.875;	vertices[6*3+1]=-1.875;		vertices[6*3+2]=0.25;	
-	vertices[7*3+0]=length+0.875;	vertices[7*3+1]=-0.125;		vertices[7*3+2]=0.25;	
-	vertices[8*3+0]=0.25;			vertices[8*3+1]=-0.25;		vertices[8*3+2]=0.125;	
-	vertices[9*3+0]=0.25;			vertices[9*3+1]=-1.75;		vertices[9*3+2]=0.125;	
-	vertices[10*3+0]=length+0.75;	vertices[10*3+1]=-1.75;		vertices[10*3+2]=0.125;	
-	vertices[11*3+0]=length+0.75;	vertices[11*3+1]=-0.25;		vertices[11*3+2]=0.125;	
+	vertices[0*3+0]=0.0;
+	vertices[0*3+1]=0.0;
+	vertices[0*3+2]=0.0;
+	vertices[1*3+0]=0.0;
+	vertices[1*3+1]=-2.0;
+	vertices[1*3+2]=0.0;
+	vertices[2*3+0]=length+1;
+	vertices[2*3+1]=-2.0;
+	vertices[2*3+2]=0.0;
+	vertices[3*3+0]=length+1;
+	vertices[3*3+1]=0.0;
+	vertices[3*3+2]=0.0;
+	vertices[4*3+0]=0.125;
+	vertices[4*3+1]=-0.125;
+	vertices[4*3+2]=0.25;
+	vertices[5*3+0]=0.125;
+	vertices[5*3+1]=-1.875;
+	vertices[5*3+2]=0.25;
+	vertices[6*3+0]=length+0.875;
+	vertices[6*3+1]=-1.875;
+	vertices[6*3+2]=0.25;
+	vertices[7*3+0]=length+0.875;
+	vertices[7*3+1]=-0.125;
+	vertices[7*3+2]=0.25;
+	vertices[8*3+0]=0.25;
+	vertices[8*3+1]=-0.25;
+	vertices[8*3+2]=0.125;
+	vertices[9*3+0]=0.25;
+	vertices[9*3+1]=-1.75;
+	vertices[9*3+2]=0.125;
+	vertices[10*3+0]=length+0.75;
+	vertices[10*3+1]=-1.75;
+	vertices[10*3+2]=0.125;
+	vertices[11*3+0]=length+0.75;
+	vertices[11*3+1]=-0.25;
+	vertices[11*3+2]=0.125;
 	widget-&gt;oid=s3d_new_object();
 	s3d_push_materials_a(widget-&gt;oid,widget-&gt;style-&gt;inputback_mat,1);
 	s3d_push_materials_a(widget-&gt;oid,widget-&gt;style-&gt;input_mat,1);
@@ -103,15 +127,15 @@
 void s3dw_input_show(s3dw_widget *widget)
 {
 	s3dw_input *input=(s3dw_input *)widget;
-    s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(input-&gt;oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(input-&gt;oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* hides the input */
 void s3dw_input_hide(s3dw_widget *widget)
 {
 	s3dw_input *input=(s3dw_input *)widget;
-    s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(input-&gt;oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(input-&gt;oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* create a new input in the surface */
 s3dw_input *s3dw_input_new(s3dw_surface *surface, float width, float posx, float posy)
@@ -144,7 +168,7 @@
 void s3dw_input_destroy(s3dw_widget *widget)
 {
 	s3dw_input *input=(s3dw_input *)widget;
-    s3dw_input_erase(widget);
+	s3dw_input_erase(widget);
 	free(input-&gt;text);
 	free(input);
 }
@@ -170,34 +194,31 @@
 	char key=keys-&gt;unicode; /* unicode support so far ... :/ */
 	int len;
 	s3dprintf(MED,&quot;edit field got key %d!!&quot;,key);
-	switch (keys-&gt;keysym)
-	{
-		case S3DK_BACKSPACE:
+	switch (keys-&gt;keysym) {
+	case S3DK_BACKSPACE:
+		len=strlen(input-&gt;text);
+		if ((len=strlen(input-&gt;text))&gt;0) {
+			newtext=malloc(len + 0); /* +1 for the terminating byte, -1 for the deleted character */
+			strncpy(newtext,input-&gt;text,len);
+			newtext[len-1]=0;
+			s3dw_input_change_text(input,newtext);
+			free(newtext);
+			return(1);
+		}
+		break;
+	default:
+		if (isprint(key)) {
 			len=strlen(input-&gt;text);
-			if ((len=strlen(input-&gt;text))&gt;0)
-			{
-				newtext=malloc(len + 0); /* +1 for the terminating byte, -1 for the deleted character */
-				strncpy(newtext,input-&gt;text,len);
-				newtext[len-1]=0;
-				s3dw_input_change_text(input,newtext);
-				free(newtext);
-				return(1);
-			}
-			break;
-		default:
-			if (isprint(key))
-			{
-				len=strlen(input-&gt;text);
-				newtext=malloc(len + 2); /* +1 for the terminating byte, +1 for the new character */
-				strcpy(newtext,input-&gt;text);
-				newtext[len]=key;
-				newtext[len+1]=0;
-				s3dw_input_change_text(input,newtext);
-				free(newtext);
-				return(1);
-			} 
+			newtext=malloc(len + 2); /* +1 for the terminating byte, +1 for the new character */
+			strcpy(newtext,input-&gt;text);
+			newtext[len]=key;
+			newtext[len+1]=0;
+			s3dw_input_change_text(input,newtext);
+			free(newtext);
+			return(1);
+		}
 	}
-	
+
 	return(0);
 }
 
@@ -205,8 +226,7 @@
 int s3dw_input_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	s3dw_input *input=(s3dw_input *)widget;
-	if ((input-&gt;oid_text==oid) || (widget-&gt;oid==oid))
-	{
+	if ((input-&gt;oid_text==oid) || (widget-&gt;oid==oid)) {
 		s3dw_focus(widget);
 		input-&gt;onclick(widget);
 		return(1);

Modified: trunk/libs3dw/label.c
===================================================================
--- trunk/libs3dw/label.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/label.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -42,12 +42,12 @@
 /* show the label */
 void s3dw_label_show(s3dw_widget *widget)
 {
-    s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* hides the label */
 void s3dw_label_hide(s3dw_widget *widget)
 {
-    s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* change label text */
 void s3dw_label_change_text(s3dw_label *label, char *text)
@@ -102,8 +102,7 @@
 int s3dw_label_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	s3dw_label *label=(s3dw_label *)widget;
-	if (widget-&gt;oid==oid)
-	{
+	if (widget-&gt;oid==oid) {
 		label-&gt;onclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/root.c
===================================================================
--- trunk/libs3dw/root.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/root.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -57,8 +57,7 @@
 /* get the root .... if it's NULL, the lib is not initialized, so do this too ... */
 s3dw_widget *s3dw_getroot()
 {
-	if (root==NULL)
-	{
+	if (root==NULL) {
 		root=(s3dw_widget *)malloc(sizeof(s3dw_widget));
 		root=s3dw_widget_new(root);
 		root-&gt;type=S3DW_TROOT;
@@ -93,7 +92,7 @@
 		s3dwcb_hide[S3DW_TINPUT]=		s3dw_input_hide;
 		s3dwcb_hide[S3DW_TTEXTBOX]=		s3dw_textbox_hide;
 		s3dwcb_hide[S3DW_TSCROLLBAR]=	s3dw_scrollbar_hide;
-		
+
 		s3dwcb_destroy[S3DW_TROOT]=		s3dw_root_destroy;
 		s3dwcb_destroy[S3DW_TCAM]=		s3dw_root_destroy;
 		s3dwcb_destroy[S3DW_TSURFACE]=	s3dw_surface_destroy;
@@ -121,7 +120,7 @@
 		s3dwcb_key[S3DW_TTEXTBOX]=		s3dw_key_nothing;
 		s3dwcb_key[S3DW_TSCROLLBAR]=	s3dw_key_nothing;
 
-	} 
+	}
 	return root;
 }
 

Modified: trunk/libs3dw/s3dw.h
===================================================================
--- trunk/libs3dw/s3dw.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/s3dw.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -28,8 +28,8 @@
 #endif
 #include &lt;stdint.h&gt;  /* [u]intXX_t type definitions*/
 
-/* we want this widget visible, as long as the widgets below are also visible. 
- * on for all widgets, except surfaces which have to be switched visible 
+/* we want this widget visible, as long as the widgets below are also visible.
+ * on for all widgets, except surfaces which have to be switched visible
  * with s3dw_show() */
 #define		S3DW_VISIBLE	1
 /* widget should accept input. that's on by default. */
@@ -70,7 +70,7 @@
 struct _s3dw_widget {
 	/* private .. */
 	int   		 type;
-	s3dw_widget *parent; 
+	s3dw_widget *parent;
 	s3dw_style  *style;
 	int 				  nobj; /* number of children objects */
 	s3dw_widget		 	**pobj; /* pointer to list of children objects */
@@ -103,7 +103,7 @@
 	char 			*text;
 	/* public */
 	s3dw_callback 	 onclick;
-	
+
 };
 struct _s3dw_scrollbar {
 	/* private */
@@ -114,20 +114,20 @@
 	/* public */
 	s3dw_callback 	 lonclick;
 	s3dw_callback 	 ronclick;
-	
+
 };
 
 struct _s3dw_textbox {
 	/* private */
 	s3dw_widget 	 widget;
 	s3dw_scrollbar	*scroll_vertical,
-					*scroll_horizontal;
+	*scroll_horizontal;
 	char 			*text;
 	int				n_lineoids,*p_lineoids;
 	int				window_x,window_y;
 	/* public */
 	s3dw_callback 	 onclick;
-	
+
 };
 
 struct _s3dw_input {

Modified: trunk/libs3dw/s3dw_int.h
===================================================================
--- trunk/libs3dw/s3dw_int.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/s3dw_int.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

Modified: trunk/libs3dw/scrollbar.c
===================================================================
--- trunk/libs3dw/scrollbar.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/scrollbar.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -34,135 +34,222 @@
 	float back_vertices[3*32];
 	int i,j;
 	unsigned int back_polygons[44*4]={
-							/* box outside */
-							0,4,5,0,							0,5,1,0,
-							1,5,6,0,							1,6,2,0,
-							3,2,7,0,							7,2,6,0,
-							3,7,4,0,							3,4,0,0,
-							
-							/* sides of big box */
-							12,13,9,0,							12,9,8,0,
-							14,15,11,0,							14,11,10,0,
+		/* box outside */
+		0,4,5,0,							0,5,1,0,
+		1,5,6,0,							1,6,2,0,
+		3,2,7,0,							7,2,6,0,
+		3,7,4,0,							3,4,0,0,
 
-							/* inlay box */
-							9,16,17,0,							9,17,10,0,
-							17,18,14,0,							17,14,10,0,
-							13,14,18,0,							13,18,19,0,
-							13,19,16,0,							13,16,9,0,
+		/* sides of big box */
+		12,13,9,0,							12,9,8,0,
+		14,15,11,0,							14,11,10,0,
 
-							/* inlay box back */
-							19,18,17,0,							19,17,16,0,
+		/* inlay box */
+		9,16,17,0,							9,17,10,0,
+		17,18,14,0,							17,14,10,0,
+		13,14,18,0,							13,18,19,0,
+		13,19,16,0,							13,16,9,0,
 
-							/* up arrow background surface */
-							7,6,15,0,
-							7,15,14,0,
-							7,14,13,0,
-							7,13,12,0,
-							
-							/* up arrow face */
-							20,23,24,0,							20,24,21,0,
-							21,24,25,0,							21,25,22,0,
-							20,22,25,0,							20,25,23,0,
-							23,25,24,0,
+		/* inlay box back */
+		19,18,17,0,							19,17,16,0,
 
-							/* down arrow background surface */
-							4,8,9,0,
-							4,9,10,0,
-							4,10,11,0,
-							4,11,5,0,
-							
-							/* down arrow face */
-							26,27,31,0,							26,31,30,0,
-							31,27,28,0,							31,28,29,0,
-							26,30,29,0,							26,29,28,0,
-							30,31,29,0
+		/* up arrow background surface */
+		7,6,15,0,
+		7,15,14,0,
+		7,14,13,0,
+		7,13,12,0,
 
-					};
+		/* up arrow face */
+		20,23,24,0,							20,24,21,0,
+		21,24,25,0,							21,25,22,0,
+		20,22,25,0,							20,25,23,0,
+		23,25,24,0,
+
+		/* down arrow background surface */
+		4,8,9,0,
+		4,9,10,0,
+		4,10,11,0,
+		4,11,5,0,
+
+		/* down arrow face */
+		26,27,31,0,							26,31,30,0,
+		31,27,28,0,							31,28,29,0,
+		26,30,29,0,							26,29,28,0,
+		30,31,29,0
+
+	};
 	unsigned int bar_polygons[14*4]={
-							/* front */
-							0,4,5,0,							0,5,1,0,
-							1,5,6,0,							1,6,2,0,
-							3,2,6,0,							3,6,7,0,
-							3,7,4,0,							3,4,0,0,
+		/* front */
+		0,4,5,0,							0,5,1,0,
+		1,5,6,0,							1,6,2,0,
+		3,2,6,0,							3,6,7,0,
+		3,7,4,0,							3,4,0,0,
 
-							7,6,4,0,							4,6,5,0,
+		7,6,4,0,							4,6,5,0,
 
-							/* back, only visible sides */
-							2,3,11,0,							2,11,10,0,
-							1,9,8,0,							1,8,0,0
-			};
+		/* back, only visible sides */
+		2,3,11,0,							2,11,10,0,
+		1,9,8,0,							1,8,0,0
+	};
 	float bar_vertices[12*3];
 	float w,h;
 	float temp;
 
-	
+
 	w=(scrollbar-&gt;type==S3DW_SBAR_VERT)? widget-&gt;width : widget-&gt;height;
 	h=(scrollbar-&gt;type==S3DW_SBAR_VERT)? widget-&gt;height : widget-&gt;width;
 	/* outside/big  box */
-	back_vertices[0*3+0]=w*0.0;			back_vertices[0*3+1]=0.0-h;			back_vertices[0*3+2]=0.0;
-	back_vertices[1*3+0]=w*1.0;			back_vertices[1*3+1]=0.0-h;			back_vertices[1*3+2]=0.0;
-	back_vertices[2*3+0]=w*1.0;			back_vertices[2*3+1]=0.0;			back_vertices[2*3+2]=0.0;
-	back_vertices[3*3+0]=w*0.0;			back_vertices[3*3+1]=0.0;			back_vertices[3*3+2]=0.0;
-	back_vertices[4*3+0]=w*0.125;		back_vertices[4*3+1]=w*0.125-h;		back_vertices[4*3+2]=0.25;
-	back_vertices[5*3+0]=w*0.875;		back_vertices[5*3+1]=w*0.125-h;		back_vertices[5*3+2]=0.25;
-	back_vertices[6*3+0]=w*0.875;		back_vertices[6*3+1]=w*-0.125;		back_vertices[6*3+2]=0.25;
-	back_vertices[7*3+0]=w*0.125;		back_vertices[7*3+1]=w*-0.125;		back_vertices[7*3+2]=0.25;
+	back_vertices[0*3+0]=w*0.0;
+	back_vertices[0*3+1]=0.0-h;
+	back_vertices[0*3+2]=0.0;
+	back_vertices[1*3+0]=w*1.0;
+	back_vertices[1*3+1]=0.0-h;
+	back_vertices[1*3+2]=0.0;
+	back_vertices[2*3+0]=w*1.0;
+	back_vertices[2*3+1]=0.0;
+	back_vertices[2*3+2]=0.0;
+	back_vertices[3*3+0]=w*0.0;
+	back_vertices[3*3+1]=0.0;
+	back_vertices[3*3+2]=0.0;
+	back_vertices[4*3+0]=w*0.125;
+	back_vertices[4*3+1]=w*0.125-h;
+	back_vertices[4*3+2]=0.25;
+	back_vertices[5*3+0]=w*0.875;
+	back_vertices[5*3+1]=w*0.125-h;
+	back_vertices[5*3+2]=0.25;
+	back_vertices[6*3+0]=w*0.875;
+	back_vertices[6*3+1]=w*-0.125;
+	back_vertices[6*3+2]=0.25;
+	back_vertices[7*3+0]=w*0.125;
+	back_vertices[7*3+1]=w*-0.125;
+	back_vertices[7*3+2]=0.25;
 
 	/* downside inlay */
-	back_vertices[8*3+0]=w* 0.125;		back_vertices[8*3+1]=w-h;			back_vertices[8*3+2]=0.25;
-	back_vertices[9*3+0]=w* 0.25;		back_vertices[9*3+1]=w-h;			back_vertices[9*3+2]=0.25;
-	back_vertices[10*3+0]=w*0.75;		back_vertices[10*3+1]=w-h;			back_vertices[10*3+2]=0.25;
-	back_vertices[11*3+0]=w*0.875;		back_vertices[11*3+1]=w-h;			back_vertices[11*3+2]=0.25;
+	back_vertices[8*3+0]=w* 0.125;
+	back_vertices[8*3+1]=w-h;
+	back_vertices[8*3+2]=0.25;
+	back_vertices[9*3+0]=w* 0.25;
+	back_vertices[9*3+1]=w-h;
+	back_vertices[9*3+2]=0.25;
+	back_vertices[10*3+0]=w*0.75;
+	back_vertices[10*3+1]=w-h;
+	back_vertices[10*3+2]=0.25;
+	back_vertices[11*3+0]=w*0.875;
+	back_vertices[11*3+1]=w-h;
+	back_vertices[11*3+2]=0.25;
 
 	/* upside inlay */
-	back_vertices[12*3+0]=w*0.125;		back_vertices[12*3+1]=-w;			back_vertices[12*3+2]=0.25;
-	back_vertices[13*3+0]=w*0.25;		back_vertices[13*3+1]=-w;			back_vertices[13*3+2]=0.25;
-	back_vertices[14*3+0]=w*0.75;		back_vertices[14*3+1]=-w;			back_vertices[14*3+2]=0.25;
-	back_vertices[15*3+0]=w*0.875;		back_vertices[15*3+1]=-w;			back_vertices[15*3+2]=0.25;
+	back_vertices[12*3+0]=w*0.125;
+	back_vertices[12*3+1]=-w;
+	back_vertices[12*3+2]=0.25;
+	back_vertices[13*3+0]=w*0.25;
+	back_vertices[13*3+1]=-w;
+	back_vertices[13*3+2]=0.25;
+	back_vertices[14*3+0]=w*0.75;
+	back_vertices[14*3+1]=-w;
+	back_vertices[14*3+2]=0.25;
+	back_vertices[15*3+0]=w*0.875;
+	back_vertices[15*3+1]=-w;
+	back_vertices[15*3+2]=0.25;
 
 	/* inlay box */
-	back_vertices[16*3+0]=w*0.25;		back_vertices[16*3+1]=w*0.125-h+w;	back_vertices[16*3+2]=0.125;
-	back_vertices[17*3+0]=w*0.75;		back_vertices[17*3+1]=w*0.125-h+w;	back_vertices[17*3+2]=0.125;
-	back_vertices[18*3+0]=w*0.75;		back_vertices[18*3+1]=w*-0.125-w;	back_vertices[18*3+2]=0.125;
-	back_vertices[19*3+0]=w*0.25;		back_vertices[19*3+1]=w*-0.125-w;	back_vertices[19*3+2]=0.125;
+	back_vertices[16*3+0]=w*0.25;
+	back_vertices[16*3+1]=w*0.125-h+w;
+	back_vertices[16*3+2]=0.125;
+	back_vertices[17*3+0]=w*0.75;
+	back_vertices[17*3+1]=w*0.125-h+w;
+	back_vertices[17*3+2]=0.125;
+	back_vertices[18*3+0]=w*0.75;
+	back_vertices[18*3+1]=w*-0.125-w;
+	back_vertices[18*3+2]=0.125;
+	back_vertices[19*3+0]=w*0.25;
+	back_vertices[19*3+1]=w*-0.125-w;
+	back_vertices[19*3+2]=0.125;
 
 	/* arrow up */
-	back_vertices[20*3+0]=w*0.25;		back_vertices[20*3+1]=w*-0.875;		back_vertices[20*3+2]=0.25;
-	back_vertices[21*3+0]=w*0.75;		back_vertices[21*3+1]=w*-0.875;		back_vertices[21*3+2]=0.25;
-	back_vertices[22*3+0]=w*0.5;		back_vertices[22*3+1]=w*-0.25;		back_vertices[22*3+2]=0.25;
-	back_vertices[23*3+0]=w*0.375;		back_vertices[23*3+1]=w*-0.75;		back_vertices[23*3+2]=0.375;
-	back_vertices[24*3+0]=w*0.625;		back_vertices[24*3+1]=w*-0.75;		back_vertices[24*3+2]=0.375;
-	back_vertices[25*3+0]=w*0.5;		back_vertices[25*3+1]=w*-0.375;		back_vertices[25*3+2]=0.375;
+	back_vertices[20*3+0]=w*0.25;
+	back_vertices[20*3+1]=w*-0.875;
+	back_vertices[20*3+2]=0.25;
+	back_vertices[21*3+0]=w*0.75;
+	back_vertices[21*3+1]=w*-0.875;
+	back_vertices[21*3+2]=0.25;
+	back_vertices[22*3+0]=w*0.5;
+	back_vertices[22*3+1]=w*-0.25;
+	back_vertices[22*3+2]=0.25;
+	back_vertices[23*3+0]=w*0.375;
+	back_vertices[23*3+1]=w*-0.75;
+	back_vertices[23*3+2]=0.375;
+	back_vertices[24*3+0]=w*0.625;
+	back_vertices[24*3+1]=w*-0.75;
+	back_vertices[24*3+2]=0.375;
+	back_vertices[25*3+0]=w*0.5;
+	back_vertices[25*3+1]=w*-0.375;
+	back_vertices[25*3+2]=0.375;
 
 	/* arrow down */
-	back_vertices[26*3+0]=w*0.25;		back_vertices[26*3+1]=-h+w*0.875;	back_vertices[26*3+2]=0.25;
-	back_vertices[27*3+0]=w*0.75;		back_vertices[27*3+1]=-h+w*0.875;	back_vertices[27*3+2]=0.25;
-	back_vertices[28*3+0]=w*0.5;		back_vertices[28*3+1]=-h+w*0.25;	back_vertices[28*3+2]=0.25;
-	back_vertices[29*3+0]=w*0.375;		back_vertices[29*3+1]=-h+w*0.75;	back_vertices[29*3+2]=0.375;
-	back_vertices[30*3+0]=w*0.625;		back_vertices[30*3+1]=-h+w*0.75;	back_vertices[30*3+2]=0.375;
-	back_vertices[31*3+0]=w*0.5;		back_vertices[31*3+1]=-h+w*0.375;	back_vertices[31*3+2]=0.375;
+	back_vertices[26*3+0]=w*0.25;
+	back_vertices[26*3+1]=-h+w*0.875;
+	back_vertices[26*3+2]=0.25;
+	back_vertices[27*3+0]=w*0.75;
+	back_vertices[27*3+1]=-h+w*0.875;
+	back_vertices[27*3+2]=0.25;
+	back_vertices[28*3+0]=w*0.5;
+	back_vertices[28*3+1]=-h+w*0.25;
+	back_vertices[28*3+2]=0.25;
+	back_vertices[29*3+0]=w*0.375;
+	back_vertices[29*3+1]=-h+w*0.75;
+	back_vertices[29*3+2]=0.375;
+	back_vertices[30*3+0]=w*0.625;
+	back_vertices[30*3+1]=-h+w*0.75;
+	back_vertices[30*3+2]=0.375;
+	back_vertices[31*3+0]=w*0.5;
+	back_vertices[31*3+1]=-h+w*0.375;
+	back_vertices[31*3+2]=0.375;
 
 	/* scrollbar bar poinst */
-	bar_vertices[0*3+0]=w*0.25;			bar_vertices[0*3+1]=-(h-3)+w*0.125;	bar_vertices[0*3+2]=0.25;
-	bar_vertices[1*3+0]=w*0.75;			bar_vertices[1*3+1]=-(h-3)+w*0.125;	bar_vertices[1*3+2]=0.25;
-	bar_vertices[2*3+0]=w*0.75;			bar_vertices[2*3+1]=-w*0.125;		bar_vertices[2*3+2]=0.25;
-	bar_vertices[3*3+0]=w*0.25;			bar_vertices[3*3+1]=-w*0.125;		bar_vertices[3*3+2]=0.25;
+	bar_vertices[0*3+0]=w*0.25;
+	bar_vertices[0*3+1]=-(h-3)+w*0.125;
+	bar_vertices[0*3+2]=0.25;
+	bar_vertices[1*3+0]=w*0.75;
+	bar_vertices[1*3+1]=-(h-3)+w*0.125;
+	bar_vertices[1*3+2]=0.25;
+	bar_vertices[2*3+0]=w*0.75;
+	bar_vertices[2*3+1]=-w*0.125;
+	bar_vertices[2*3+2]=0.25;
+	bar_vertices[3*3+0]=w*0.25;
+	bar_vertices[3*3+1]=-w*0.125;
+	bar_vertices[3*3+2]=0.25;
 
-	bar_vertices[4*3+0]=w*0.125;		bar_vertices[4*3+1]=-(h-3)+w*0.25;	bar_vertices[4*3+2]=0.375;
-	bar_vertices[5*3+0]=w*0.875;		bar_vertices[5*3+1]=-(h-3)+w*0.25;	bar_vertices[5*3+2]=0.375;
-	bar_vertices[6*3+0]=w*0.875;		bar_vertices[6*3+1]=-w*0.25;		bar_vertices[6*3+2]=0.375;
-	bar_vertices[7*3+0]=w*0.125;		bar_vertices[7*3+1]=-w*0.25;		bar_vertices[7*3+2]=0.375;
-	
-	bar_vertices[8*3+0]=w*0.125;		bar_vertices[8*3+1]=-(h-3)+w*0.25;	bar_vertices[8*3+2]=0.175;
-	bar_vertices[9*3+0]=w*0.875;		bar_vertices[9*3+1]=-(h-3)+w*0.25;	bar_vertices[9*3+2]=0.175;
-	bar_vertices[10*3+0]=w*0.875;		bar_vertices[10*3+1]=-w*0.25;		bar_vertices[10*3+2]=0.175;
-	bar_vertices[11*3+0]=w*0.125;		bar_vertices[11*3+1]=-w*0.25;		bar_vertices[11*3+2]=0.175;
+	bar_vertices[4*3+0]=w*0.125;
+	bar_vertices[4*3+1]=-(h-3)+w*0.25;
+	bar_vertices[4*3+2]=0.375;
+	bar_vertices[5*3+0]=w*0.875;
+	bar_vertices[5*3+1]=-(h-3)+w*0.25;
+	bar_vertices[5*3+2]=0.375;
+	bar_vertices[6*3+0]=w*0.875;
+	bar_vertices[6*3+1]=-w*0.25;
+	bar_vertices[6*3+2]=0.375;
+	bar_vertices[7*3+0]=w*0.125;
+	bar_vertices[7*3+1]=-w*0.25;
+	bar_vertices[7*3+2]=0.375;
 
+	bar_vertices[8*3+0]=w*0.125;
+	bar_vertices[8*3+1]=-(h-3)+w*0.25;
+	bar_vertices[8*3+2]=0.175;
+	bar_vertices[9*3+0]=w*0.875;
+	bar_vertices[9*3+1]=-(h-3)+w*0.25;
+	bar_vertices[9*3+2]=0.175;
+	bar_vertices[10*3+0]=w*0.875;
+	bar_vertices[10*3+1]=-w*0.25;
+	bar_vertices[10*3+2]=0.175;
+	bar_vertices[11*3+0]=w*0.125;
+	bar_vertices[11*3+1]=-w*0.25;
+	bar_vertices[11*3+2]=0.175;
 
 
-	
-	if (scrollbar-&gt;type==S3DW_SBAR_HORI) /* rotate x and y for horizontal scrollbar */
-	{
+
+
+	if (scrollbar-&gt;type==S3DW_SBAR_HORI) { /* rotate x and y for horizontal scrollbar */
 		for (i=0;i&lt;32;i++)	{
 			temp=back_vertices[i*3];
 			back_vertices[i*3]=-back_vertices[i*3+1];
@@ -207,7 +294,7 @@
 	s3d_link(		   scrollbar-&gt;roid,widget-&gt;oid);
 	s3d_link(		   scrollbar-&gt;baroid,widget-&gt;oid);
 	s3d_translate(widget-&gt;oid,widget-&gt;x,-widget-&gt;y,0);
-	if (scrollbar-&gt;type==S3DW_SBAR_VERT) 
+	if (scrollbar-&gt;type==S3DW_SBAR_VERT)
 		s3d_translate(scrollbar-&gt;baroid,0,-1.5,0);
 	else
 		s3d_translate(scrollbar-&gt;baroid,1.5,0,0);
@@ -217,20 +304,20 @@
 void s3dw_scrollbar_show(s3dw_widget *widget)
 {
 	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
-    s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(scrollbar-&gt;loid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(scrollbar-&gt;roid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(scrollbar-&gt;baroid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(scrollbar-&gt;loid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(scrollbar-&gt;roid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(scrollbar-&gt;baroid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 
 }
 /* hides the scrollbar */
 void s3dw_scrollbar_hide(s3dw_widget *widget)
 {
 	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
-    s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(scrollbar-&gt;loid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(scrollbar-&gt;roid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(scrollbar-&gt;baroid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(scrollbar-&gt;loid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(scrollbar-&gt;roid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(scrollbar-&gt;baroid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 
 /* create a new scrollbar in the surface */
@@ -241,8 +328,7 @@
 	scrollbar=(s3dw_scrollbar *)malloc(sizeof(s3dw_scrollbar));
 	widget=s3dw_widget_new((s3dw_widget *)scrollbar);
 	widget-&gt;type=S3DW_TSCROLLBAR;
-	if ((scrollbar-&gt;type=type)==S3DW_SBAR_HORI)
-	{
+	if ((scrollbar-&gt;type=type)==S3DW_SBAR_HORI) {
 		widget-&gt;height=1;
 		widget-&gt;width=length;
 	} else {
@@ -286,13 +372,11 @@
 int s3dw_scrollbar_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
-	if (scrollbar-&gt;loid==oid)
-	{
+	if (scrollbar-&gt;loid==oid) {
 		scrollbar-&gt;lonclick(widget);
 		return(1);
 	}
-	if (scrollbar-&gt;roid==oid)
-	{
+	if (scrollbar-&gt;roid==oid) {
 		scrollbar-&gt;ronclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/style.c
===================================================================
--- trunk/libs3dw/style.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/style.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -29,43 +29,43 @@
 
 /* default style */
 s3dw_style def_style={
-/* name */
-&quot;default&quot;,
-/* font face */
-&quot;vera&quot;,
-/* surface_mat */
-{0.7,0.7,0.7,1.0, 
- 0.7,0.7,0.7,1.0, 
- 0.7,0.7,0.7,1.0
-},
-/* input_mat */
-{0.7,0.7,0.7,1.0,
- 0.7,0.7,0.7,1.0,
- 0.7,0.7,0.7,1.0
-},
-/* inputback_mat */
-{0.9,0.9,0.9,1.0,
- 0.9,0.9,0.9,1.0,
- 0.9,0.9,0.9,1.0
-},
+	/* name */
+	&quot;default&quot;,
+	/* font face */
+	&quot;vera&quot;,
+	/* surface_mat */
+	{0.7,0.7,0.7,1.0,
+		0.7,0.7,0.7,1.0,
+		0.7,0.7,0.7,1.0
+	},
+	/* input_mat */
+	{0.7,0.7,0.7,1.0,
+	 0.7,0.7,0.7,1.0,
+	 0.7,0.7,0.7,1.0
+	},
+	/* inputback_mat */
+	{0.9,0.9,0.9,1.0,
+	 0.9,0.9,0.9,1.0,
+	 0.9,0.9,0.9,1.0
+	},
 
-/* text_mat */
-{
- 0.0,0.0,0.0,1.0,
- 1.0,1.0,1.0,1.0,
- 0.0,0.0,0.0,1.0
-},
-/* title_mat */
-{
- 0.0,0.4,0.8,1.0,
- 1.0,1.0,1.0,1.0,
- 0.0,0.4,0.8,1.0
-},
-/* title_text_mat */
-{
- 0.0,0.0,0.0,1.0,
- 0.0,0.0,0.0,1.0,
- 0.0,0.0,0.0,1.0
-}
+	/* text_mat */
+	{
+		0.0,0.0,0.0,1.0,
+		1.0,1.0,1.0,1.0,
+		0.0,0.0,0.0,1.0
+	},
+	/* title_mat */
+	{
+		0.0,0.4,0.8,1.0,
+		1.0,1.0,1.0,1.0,
+		0.0,0.4,0.8,1.0
+	},
+	/* title_text_mat */
+	{
+		0.0,0.0,0.0,1.0,
+		0.0,0.0,0.0,1.0,
+		0.0,0.0,0.0,1.0
+	}
 };
 

Modified: trunk/libs3dw/surface.c
===================================================================
--- trunk/libs3dw/surface.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/surface.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -65,14 +65,12 @@
 	surface-&gt;oid_tbar=s3d_new_object();
 	s3d_select_font(&quot;vera&quot;);
 	surface-&gt;oid_title=s3d_draw_string(surface-&gt;title,&amp;length);
-	while (length &gt; (widget-&gt;width+1))
-	{
+	while (length &gt; (widget-&gt;width+1)) {
 		s3dprintf(HIGH,&quot;%f &gt; %f&quot;,length,widget-&gt;width+1);
 		textlen=strlen(surface-&gt;title);
 		if (length&gt;((widget-&gt;width+1)*1.3))
 			textlen=textlen*((widget-&gt;width+1)*1.1/length);
-		if (textlen&gt;4)
-		{
+		if (textlen&gt;4) {
 			surface-&gt;title[textlen-2]=0;
 			surface-&gt;title[textlen-3]='.';
 			surface-&gt;title[textlen-4]='.';
@@ -82,9 +80,8 @@
 			break;
 		}
 	}
- 	/* prepare vertices */
-	for (i=0;i&lt;8;i++)
-	{
+	/* prepare vertices */
+	for (i=0;i&lt;8;i++) {
 		sver[i*3 + 0]=vertices[i*3+0] * widget-&gt;width;
 		sver[i*3 + 1]=vertices[i*3+1] * -widget-&gt;height;
 		sver[i*3 + 2]=vertices[i*3+2] * -1;
@@ -93,12 +90,11 @@
 		tver[i*3 + 2]=vertices[i*3+2] * -1;
 	}
 	/* swap */
-	for (i=0;i&lt;10;i++)
-	{
-	   tpol[i*4 + 0]=polygon[i*4 + 1];
-	   tpol[i*4 + 1]=polygon[i*4 + 0];
-	   tpol[i*4 + 2]=polygon[i*4 + 2];
-	   tpol[i*4 + 3]=polygon[i*4 + 3];
+	for (i=0;i&lt;10;i++) {
+		tpol[i*4 + 0]=polygon[i*4 + 1];
+		tpol[i*4 + 1]=polygon[i*4 + 0];
+		tpol[i*4 + 2]=polygon[i*4 + 2];
+		tpol[i*4 + 3]=polygon[i*4 + 3];
 	}
 	s3d_push_vertices(widget-&gt;oid,sver,8);
 	s3d_push_vertices(surface-&gt;oid_tbar,tver,8);
@@ -118,17 +114,17 @@
 void s3dw_surface_show(s3dw_widget *widget)
 {
 	s3dw_surface *surface=(s3dw_surface *)widget;
-    s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(surface-&gt;oid_title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(surface-&gt;oid_tbar,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(surface-&gt;oid_title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(surface-&gt;oid_tbar,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* hides the surface */
 void s3dw_surface_hide(s3dw_widget *widget)
 {
 	s3dw_surface *surface=(s3dw_surface *)widget;
-    s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(surface-&gt;oid_title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(surface-&gt;oid_tbar,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(surface-&gt;oid_title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(surface-&gt;oid_tbar,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* create a new surface */
 s3dw_surface *s3dw_surface_new(char *title, float width, float height)
@@ -136,7 +132,7 @@
 	s3dw_surface *surface;
 	s3dw_widget  *widget;
 	float f1[3];
-			
+
 	surface=(s3dw_surface *)malloc(sizeof(s3dw_surface));
 	surface-&gt;title=strdup(title);
 	widget=s3dw_widget_new((s3dw_widget *)surface);
@@ -183,14 +179,12 @@
 int s3dw_surface_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	s3dw_surface *surface=(s3dw_surface *)widget;
-	if (widget-&gt;oid==oid)
-	{
+	if (widget-&gt;oid==oid) {
 		s3dw_focus(widget);
 		s3dprintf(MED,&quot;body %s clicked&quot;,surface-&gt;title);
 		return(1);
 	}
-	if ((surface-&gt;oid_tbar==oid) || (surface-&gt;oid_title==oid))
-	{
+	if ((surface-&gt;oid_tbar==oid) || (surface-&gt;oid_title==oid)) {
 		s3dw_focus(widget);
 		s3dprintf(MED,&quot;title %s clicked&quot;,surface-&gt;title);
 		return(1);

Modified: trunk/libs3dw/textbox.c
===================================================================
--- trunk/libs3dw/textbox.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/textbox.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -33,44 +33,68 @@
 	float h,w;
 	float vertices[12*3];
 	uint32_t polygons[18*4]={
-			0,4,5,1,
-			0,5,1,1,
-			1,5,6,1,
-			1,6,2,1,
-			2,6,7,1,
-			2,7,3,1,
-			3,7,4,1,
-			3,4,0,1,
+		0,4,5,1,
+		0,5,1,1,
+		1,5,6,1,
+		1,6,2,1,
+		2,6,7,1,
+		2,7,3,1,
+		3,7,4,1,
+		3,4,0,1,
 
-			4,8, 9, 1,
-			4,9, 5, 1,
-			5,9, 10,1,
-			5,10,6, 1,
-			6,10,11,1,
-			6,11,7, 1,
-			7,11,8, 1,
-			7,8, 4, 1,
+		4,8, 9, 1,
+		4,9, 5, 1,
+		5,9, 10,1,
+		5,10,6, 1,
+		6,10,11,1,
+		6,11,7, 1,
+		7,11,8, 1,
+		7,8, 4, 1,
 
 
-			8,11,10,0,
-			8,10,9, 0
+		8,11,10,0,
+		8,10,9, 0
 	};
 	w=widget-&gt;width-2;
 	h=widget-&gt;height-3;
 	if (widget-&gt;width&lt;1) return;
 	/* width of the input depends on the length of the text */
-	vertices[0*3+0]=0.0;			vertices[0*3+1]=0.0;		vertices[0*3+2]=0.0;	
-	vertices[1*3+0]=0.0;			vertices[1*3+1]=-h-2.0;		vertices[1*3+2]=0.0;	
-	vertices[2*3+0]=w+1;			vertices[2*3+1]=-h-2.0;		vertices[2*3+2]=0.0;	
-	vertices[3*3+0]=w+1;			vertices[3*3+1]=0.0;		vertices[3*3+2]=0.0;	
-	vertices[4*3+0]=0.125;			vertices[4*3+1]=-0.125;		vertices[4*3+2]=0.25;	
-	vertices[5*3+0]=0.125;			vertices[5*3+1]=-h-1.875;	vertices[5*3+2]=0.25;	
-	vertices[6*3+0]=w+0.875;		vertices[6*3+1]=-h-1.875;	vertices[6*3+2]=0.25;	
-	vertices[7*3+0]=w+0.875;		vertices[7*3+1]=-0.125;		vertices[7*3+2]=0.25;	
-	vertices[8*3+0]=0.25;			vertices[8*3+1]=-0.25;		vertices[8*3+2]=0.125;	
-	vertices[9*3+0]=0.25;			vertices[9*3+1]=-h-1.75;	vertices[9*3+2]=0.125;	
-	vertices[10*3+0]=w+0.75;		vertices[10*3+1]=-h-1.75;	vertices[10*3+2]=0.125;	
-	vertices[11*3+0]=w+0.75;		vertices[11*3+1]=-0.25;		vertices[11*3+2]=0.125;	
+	vertices[0*3+0]=0.0;
+	vertices[0*3+1]=0.0;
+	vertices[0*3+2]=0.0;
+	vertices[1*3+0]=0.0;
+	vertices[1*3+1]=-h-2.0;
+	vertices[1*3+2]=0.0;
+	vertices[2*3+0]=w+1;
+	vertices[2*3+1]=-h-2.0;
+	vertices[2*3+2]=0.0;
+	vertices[3*3+0]=w+1;
+	vertices[3*3+1]=0.0;
+	vertices[3*3+2]=0.0;
+	vertices[4*3+0]=0.125;
+	vertices[4*3+1]=-0.125;
+	vertices[4*3+2]=0.25;
+	vertices[5*3+0]=0.125;
+	vertices[5*3+1]=-h-1.875;
+	vertices[5*3+2]=0.25;
+	vertices[6*3+0]=w+0.875;
+	vertices[6*3+1]=-h-1.875;
+	vertices[6*3+2]=0.25;
+	vertices[7*3+0]=w+0.875;
+	vertices[7*3+1]=-0.125;
+	vertices[7*3+2]=0.25;
+	vertices[8*3+0]=0.25;
+	vertices[8*3+1]=-0.25;
+	vertices[8*3+2]=0.125;
+	vertices[9*3+0]=0.25;
+	vertices[9*3+1]=-h-1.75;
+	vertices[9*3+2]=0.125;
+	vertices[10*3+0]=w+0.75;
+	vertices[10*3+1]=-h-1.75;
+	vertices[10*3+2]=0.125;
+	vertices[11*3+0]=w+0.75;
+	vertices[11*3+1]=-0.25;
+	vertices[11*3+2]=0.125;
 	widget-&gt;oid=s3d_new_object();
 	s3d_push_materials_a(widget-&gt;oid,widget-&gt;style-&gt;inputback_mat,1);
 	s3d_push_materials_a(widget-&gt;oid,widget-&gt;style-&gt;input_mat,1);
@@ -98,28 +122,25 @@
 	for (i=0;i&lt;textbox-&gt;n_lineoids;i++)
 		textbox-&gt;p_lineoids[i]=-1;
 	rest=text=strdup(textbox-&gt;text);
-	while (NULL!=(linefeedpos=strchr(rest,'\n'))) /* process every line */
-	{
+	while (NULL!=(linefeedpos=strchr(rest,'\n'))) { /* process every line */
 		linefeedpos[0]=0;
-		if ((x&lt;strlen(rest)) &amp;&amp; ((y&gt;=0) &amp;&amp; y&lt;textbox-&gt;n_lineoids)) /* don't bother, if it's not visible anyway */
-		{
+		if ((x&lt;strlen(rest)) &amp;&amp; ((y&gt;=0) &amp;&amp; y&lt;textbox-&gt;n_lineoids)) { /* don't bother, if it's not visible anyway */
 			rest+=x;	/* ignore the first x chars because we've scrolled a bit right */
 			while ((strlen(rest)&gt;0) &amp;&amp; (s3d_strlen(rest)&gt;width))
 				rest[strlen(rest)-1]=0; /* remove last character and try again until it fits */
-			if (strlen(rest)&gt;0)
-			{
-				 textbox-&gt;p_lineoids[y]=s3d_draw_string(rest,NULL);
-				 s3d_pep_materials_a(textbox-&gt;p_lineoids[y],widget-&gt;style-&gt;text_mat,1);
-				 s3d_translate( textbox-&gt;p_lineoids[y],0.5,-y-1,0.30);
-				 s3d_link(	   textbox-&gt;p_lineoids[y],widget-&gt;oid);
+			if (strlen(rest)&gt;0) {
+				textbox-&gt;p_lineoids[y]=s3d_draw_string(rest,NULL);
+				s3d_pep_materials_a(textbox-&gt;p_lineoids[y],widget-&gt;style-&gt;text_mat,1);
+				s3d_translate( textbox-&gt;p_lineoids[y],0.5,-y-1,0.30);
+				s3d_link(	   textbox-&gt;p_lineoids[y],widget-&gt;oid);
 
 			}
-		} 
+		}
 		rest=linefeedpos+1;
 		y+=1;
 	}
 	if (y&lt;0) textbox-&gt;window_y-=y;
-	
+
 	free(text);
 }
 void s3dw_textbox_erasetext(s3dw_widget *widget)
@@ -128,8 +149,7 @@
 	int i;
 
 
-	if (textbox-&gt;p_lineoids!=NULL)
-	{
+	if (textbox-&gt;p_lineoids!=NULL) {
 		for (i=0;i&lt;textbox-&gt;n_lineoids;i++)
 			if (textbox-&gt;p_lineoids[i]!=-1)
 				s3d_del_object(textbox-&gt;p_lineoids[i]);
@@ -144,28 +164,36 @@
 {
 	s3dw_textbox *textbox=(s3dw_textbox *)widget;
 	int i;
-    s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	for (i=0;i&lt;textbox-&gt;n_lineoids;i++)
-    	s3d_flags_on(textbox-&gt;p_lineoids[i],S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_on(textbox-&gt;p_lineoids[i],S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* hides the textbox */
 void s3dw_textbox_hide(s3dw_widget *widget)
 {
 	s3dw_textbox *textbox=(s3dw_textbox *)widget;
 	int i;
-    s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	for (i=0;i&lt;textbox-&gt;n_lineoids;i++)
-    	s3d_flags_on(textbox-&gt;p_lineoids[i],S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_on(textbox-&gt;p_lineoids[i],S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 
 }
 static void _s3dw_textbox_scrollbar_up(s3dw_widget *widget)
-{	s3dw_textbox_scrollup((s3dw_textbox *)widget-&gt;parent);}
+{
+	s3dw_textbox_scrollup((s3dw_textbox *)widget-&gt;parent);
+}
 static void _s3dw_textbox_scrollbar_down(s3dw_widget *widget)
-{	s3dw_textbox_scrolldown((s3dw_textbox *)widget-&gt;parent);}
+{
+	s3dw_textbox_scrolldown((s3dw_textbox *)widget-&gt;parent);
+}
 static void _s3dw_textbox_scrollbar_left(s3dw_widget *widget)
-{	s3dw_textbox_scrollleft((s3dw_textbox *)widget-&gt;parent);}
+{
+	s3dw_textbox_scrollleft((s3dw_textbox *)widget-&gt;parent);
+}
 static void _s3dw_textbox_scrollbar_right(s3dw_widget *widget)
-{	s3dw_textbox_scrollright((s3dw_textbox *)widget-&gt;parent);}
+{
+	s3dw_textbox_scrollright((s3dw_textbox *)widget-&gt;parent);
+}
 
 /* create a new textbox in the surface */
 s3dw_textbox *s3dw_textbox_new(s3dw_surface *surface, char *text, float posx, float posy, float width, float height)
@@ -187,7 +215,7 @@
 	textbox-&gt;onclick=s3dw_nothing;
 	s3dw_widget_append((s3dw_widget *)surface, widget);		/* append first so the scrollbars inherit the style */
 	s3dw_textbox_draw(widget);
-	textbox-&gt;scroll_horizontal=s3dw_scrollbar_new(widget,S3DW_SBAR_HORI,  0,widget-&gt;height-1, widget-&gt;width-1); 
+	textbox-&gt;scroll_horizontal=s3dw_scrollbar_new(widget,S3DW_SBAR_HORI,  0,widget-&gt;height-1, widget-&gt;width-1);
 	textbox-&gt;scroll_vertical=s3dw_scrollbar_new(widget,S3DW_SBAR_VERT,  widget-&gt;width-1,0, widget-&gt;height-1);
 	textbox-&gt;scroll_horizontal-&gt;lonclick=_s3dw_textbox_scrollbar_left;
 	textbox-&gt;scroll_horizontal-&gt;ronclick=_s3dw_textbox_scrollbar_right;
@@ -203,7 +231,7 @@
 	if (widget-&gt;flags&amp;S3DW_ONSCREEN)
 		s3dw_textbox_show(widget);
 }
-		
+
 void s3dw_textbox_scrollup(s3dw_textbox *textbox)
 {
 	if (textbox-&gt;window_y&gt;0)
@@ -268,8 +296,7 @@
 int s3dw_textbox_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	s3dw_textbox *textbox=(s3dw_textbox *)widget;
-	if (widget-&gt;oid==oid)
-	{
+	if (widget-&gt;oid==oid) {
 		textbox-&gt;onclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/widget.c
===================================================================
--- trunk/libs3dw/widget.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/widget.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -86,8 +86,7 @@
 	if (parent==NULL) return;
 
 	for (i=0;i&lt;parent-&gt;nobj;i++) /* search ... */
-		if (parent-&gt;pobj[i]==widget) /* ... and destroy */
-		{
+		if (parent-&gt;pobj[i]==widget) { /* ... and destroy */
 			if (parent-&gt;focus==i)					parent-&gt;focus=-1;
 			if (parent-&gt;focus==(parent-&gt;nobj-1))	parent-&gt;focus=i;
 			parent-&gt;pobj[i]=parent-&gt;pobj[parent-&gt;nobj-1]; /* swap last element to the to be deleted one */
@@ -114,8 +113,7 @@
 {
 	int i;
 	for (i=0;i&lt;focus-&gt;parent-&gt;nobj;i++)
-		if (focus-&gt;parent-&gt;pobj[i]==focus)
-		{
+		if (focus-&gt;parent-&gt;pobj[i]==focus) {
 			focus-&gt;parent-&gt;focus=i;
 			return;
 		}
@@ -126,8 +124,7 @@
 {
 	int i;
 	s3dw_widget *kid;
-	for (i=0;i&lt;widget-&gt;nobj;i++)
-	{
+	for (i=0;i&lt;widget-&gt;nobj;i++) {
 		kid=widget-&gt;pobj[i];
 		if (widget-&gt;flags&amp;S3DW_VISIBLE)
 			s3dw_widget_visible(kid);

Modified: trunk/server/allocate.c
===================================================================
--- trunk/server/allocate.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/allocate.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -10,17 +10,17 @@
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -44,16 +44,14 @@
 
 struct chunkHeader *chunkList = NULL;
 
-struct chunkHeader
-{
+struct chunkHeader {
 	struct chunkHeader *next;
 	unsigned int length;
 	int tag;
 	unsigned int magicNumber;
 };
 
-struct chunkTrailer
-{
+struct chunkTrailer {
 	unsigned int magicNumber;
 };
 
@@ -63,10 +61,8 @@
 	struct chunkTrailer *chunkTrailer;
 	unsigned char *memory;
 
-	for (walker = chunkList; walker != NULL; walker = walker-&gt;next)
-	{
-		if (walker-&gt;magicNumber != MAGIC_NUMBER)
-		{
+	for (walker = chunkList; walker != NULL; walker = walker-&gt;next) {
+		if (walker-&gt;magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, &quot;Invalid magic number in header: %08x, tag = %d\n&quot;, walker-&gt;magicNumber, walker-&gt;tag);
 			exit(1);
 		}
@@ -75,8 +71,7 @@
 
 		chunkTrailer = (struct chunkTrailer *)(memory + sizeof(struct chunkHeader) + walker-&gt;length);
 
-		if (chunkTrailer-&gt;magicNumber != MAGIC_NUMBER)
-		{
+		if (chunkTrailer-&gt;magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, &quot;Invalid magic number in header: %08x, tag = %d\n&quot;, chunkTrailer-&gt;magicNumber, walker-&gt;tag);
 			exit(1);
 		}
@@ -98,12 +93,11 @@
 	struct chunkTrailer *chunkTrailer;
 	unsigned char *chunk;
 
-/* 	printf(&quot;sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\n&quot;, sizeof (struct chunkHeader), sizeof (struct chunkTrailer)); */
+	/* 	printf(&quot;sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\n&quot;, sizeof (struct chunkHeader), sizeof (struct chunkTrailer)); */
 
 	memory = malloc(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer));
 
-	if (memory == NULL)
-	{
+	if (memory == NULL) {
 		fprintf(stderr, &quot;Cannot allocate %u bytes, tag = %d\n&quot;, (unsigned int)(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer)), tag);
 		exit(1);
 	}
@@ -135,30 +129,28 @@
 	if (memoryParameter) { /* if memoryParameter==NULL, realloc() should work like malloc() !! */
 		memory = memoryParameter;
 		chunkHeader = (struct chunkHeader *)(memory - sizeof(struct chunkHeader));
-	
-		if (chunkHeader-&gt;magicNumber != MAGIC_NUMBER)
-		{
+
+		if (chunkHeader-&gt;magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, &quot;Invalid magic number in header: %08x, tag = %d\n&quot;, chunkHeader-&gt;magicNumber, chunkHeader-&gt;tag);
 			exit(1);
 		}
-	
+
 		chunkTrailer = (struct chunkTrailer *)(memory + chunkHeader-&gt;length);
-	
-		if (chunkTrailer-&gt;magicNumber != MAGIC_NUMBER)
-		{
+
+		if (chunkTrailer-&gt;magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, &quot;Invalid magic number in header: %08x, tag = %d\n&quot;, chunkTrailer-&gt;magicNumber, chunkHeader-&gt;tag);
 			exit(1);
 		}
 	}
-	
 
+
 	result = debugMalloc(length, tag);
 	if (memoryParameter) {
 		copyLength = length;
 
 		if (copyLength &gt; chunkHeader-&gt;length)
 			copyLength = chunkHeader-&gt;length;
-	
+
 		memcpy(result, memoryParameter, copyLength);
 		debugFree(memoryParameter);
 	}
@@ -178,24 +170,21 @@
 	memory = memoryParameter;
 	chunkHeader = (struct chunkHeader *)(memory - sizeof(struct chunkHeader));
 
-	if (chunkHeader-&gt;magicNumber != MAGIC_NUMBER)
-	{
+	if (chunkHeader-&gt;magicNumber != MAGIC_NUMBER) {
 		fprintf(stderr, &quot;Invalid magic number in header: %08x, tag = %d\n&quot;, chunkHeader-&gt;magicNumber, chunkHeader-&gt;tag);
 		exit(1);
 	}
 
 	previous = NULL;
 
-	for (walker = chunkList; walker != NULL; walker = walker-&gt;next)
-	{
+	for (walker = chunkList; walker != NULL; walker = walker-&gt;next) {
 		if (walker == chunkHeader)
 			break;
 
 		previous = walker;
 	}
 
-	if (walker == NULL)
-	{
+	if (walker == NULL) {
 		fprintf(stderr, &quot;Double free detected, tag = %d\n&quot;, chunkHeader-&gt;tag);
 		exit(1);
 	}
@@ -208,8 +197,7 @@
 
 	chunkTrailer = (struct chunkTrailer *)(memory + chunkHeader-&gt;length);
 
-	if (chunkTrailer-&gt;magicNumber != MAGIC_NUMBER)
-	{
+	if (chunkTrailer-&gt;magicNumber != MAGIC_NUMBER) {
 		fprintf(stderr, &quot;Invalid magic number in header: %08x, tag = %d\n&quot;, chunkTrailer-&gt;magicNumber, chunkHeader-&gt;tag);
 		exit(1);
 	}
@@ -233,8 +221,7 @@
 
 	result = malloc(length);
 
-	if (result == NULL)
-	{
+	if (result == NULL) {
 		fprintf(stderr, &quot;Cannot allocate %u bytes, tag = %d\n&quot;, length, tag);
 		exit(1);
 	}
@@ -248,8 +235,7 @@
 
 	result = realloc(memory, length);
 
-	if (result == NULL)
-	{
+	if (result == NULL) {
 		fprintf(stderr, &quot;Cannot re-allocate %u bytes, tag = %d\n&quot;, length, tag);
 		exit(1);
 	}

Modified: trunk/server/allocate.h
===================================================================
--- trunk/server/allocate.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/allocate.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -10,17 +10,17 @@
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

Modified: trunk/server/config.h
===================================================================
--- trunk/server/config.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/config.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,24 +5,24 @@
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 /* use the global config.h */
-#include &lt;config-s3d.h&gt; 
+#include &lt;config-s3d.h&gt;
 
 /*  to be filled with configure options ...  */
 /*   */

Modified: trunk/server/cull.c
===================================================================
--- trunk/server/cull.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/cull.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,23 +1,23 @@
 /*
  * cull.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- * code originated from  <A HREF="http://www.racer.nl/reference/vfc.htm">http://www.racer.nl/reference/vfc.htm</A> 
+ * code originated from  <A HREF="http://www.racer.nl/reference/vfc.htm">http://www.racer.nl/reference/vfc.htm</A>
  * which is (C) Ruud van Gaal
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -44,8 +44,8 @@
 	struct t_plane *p;
 	int i;
 	float d;
-	
 
+
 	/* get matrices from opengl */
 	glGetFloatv(GL_MODELVIEW_MATRIX,mmodel);
 	glGetFloatv(GL_PROJECTION_MATRIX,mproj);
@@ -91,12 +91,10 @@
 	p-&gt;d=m[15]+m[14];
 
 	/* Normalize all plane normals */
-	for(i=0;i&lt;6;i++)
-	{
+	for (i=0;i&lt;6;i++) {
 		p=&amp;frustumPlane[i];
 		d=sqrt(p-&gt;n.x*p-&gt;n.x + p-&gt;n.y*p-&gt;n.y + p-&gt;n.z*p-&gt;n.z);
-		if (d!=0.0)
-		{
+		if (d!=0.0) {
 			p-&gt;n.x/=d;
 			p-&gt;n.y/=d;
 			p-&gt;n.z/=d;
@@ -109,13 +107,11 @@
 {
 	int i;
 	struct t_plane *p;
-	for(i=0;i&lt;6;i++)
-	{
+	for (i=0;i&lt;6;i++) {
 		p=&amp;frustumPlane[i];
-		if (p-&gt;n.x*center-&gt;x+p-&gt;n.y*center-&gt;y+p-&gt;n.z*center-&gt;z+p-&gt;d &lt;= -radius)
-		{
-/*			s3dprintf(MED,&quot;out of %d plane (n %f %f %f |d %f)&quot;,i,p-&gt;n.x,p-&gt;n.y,p-&gt;n.z,p-&gt;d);*/
-			 return 0; /* sorry, no ... */
+		if (p-&gt;n.x*center-&gt;x+p-&gt;n.y*center-&gt;y+p-&gt;n.z*center-&gt;z+p-&gt;d &lt;= -radius) {
+			/*			s3dprintf(MED,&quot;out of %d plane (n %f %f %f |d %f)&quot;,i,p-&gt;n.x,p-&gt;n.y,p-&gt;n.z,p-&gt;d);*/
+			return 0; /* sorry, no ... */
 		}
 	}
 	return 1; /* it's inside */

Modified: trunk/server/error.c
===================================================================
--- trunk/server/error.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/error.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,28 +1,28 @@
 /*
  * error.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 
-#include &quot;global.h&quot;	 
+#include &quot;global.h&quot;
 #include &lt;stdio.h&gt;	 /*  for printf() */
 #include &lt;stdarg.h&gt;	 /*  va_start, va_end */
 #include &lt;string.h&gt;  /*  for strerror() */
@@ -32,21 +32,25 @@
 /*  basicly, this is for upcoming logfiles, or maybe draw error-messages into */
 /*  the 3d-space */
 /*  this is the generic failure routine ... */
-void errn(char *func,int en) {
+void errn(char *func,int en)
+{
 	fprintf(stderr,&quot;error: %s: (%d) %s\n&quot;,func,en, strerror(en));
 }
 /*  ... and it's fatal pendant */
-void errnf(char *func,int en) {
+void errnf(char *func,int en)
+{
 	fprintf(stderr,&quot;FATAL: %s: (%d) %s\n&quot;,func,en, strerror(en));
 	exit(-1);
 }
 
 /*  prints an error with the function and it's error-message */
-void errs(char *func, char *msg) {
+void errs(char *func, char *msg)
+{
 	fprintf(stderr,&quot;error: %s: %s\n&quot;,func,msg);
 }
 
-void errsf(char *func, char *msg) {
+void errsf(char *func, char *msg)
+{
 	fprintf(stderr,&quot;FATAL: %s: %s\n&quot;,func,msg);
 	exit(-1);
 }
@@ -56,27 +60,26 @@
 {
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance &gt;= DEBUG )
-	{
+	if (relevance &gt;= DEBUG ) {
 		va_start(args,fmt);
 		vsnprintf((char *)&amp;dbm,DBM_MAX,fmt,args);
 		va_end(args);
-	
+
 		fprintf(stderr,&quot;error: %s:%s\n&quot;,func,(char *)&amp;dbm);
 	}
 }
 /*  printing debug message */
 
-void s3dprintf(int relevance, const char *fmt, ...) {
+void s3dprintf(int relevance, const char *fmt, ...)
+{
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance &gt;= DEBUG )
-	{
+	if (relevance &gt;= DEBUG ) {
 		va_start(args,fmt);
 		vsnprintf((char *)&amp;dbm,DBM_MAX,fmt,args);
 		va_end(args);
-	
-/*		fprintf(stderr,&quot;debug: %s\n&quot;,(char *)&amp;dbm);*/
+
+		/*		fprintf(stderr,&quot;debug: %s\n&quot;,(char *)&amp;dbm);*/
 		fprintf(stdout,&quot;debug: %s\n&quot;,(char *)&amp;dbm);
 	}
 }

Modified: trunk/server/event.c
===================================================================
--- trunk/server/event.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/event.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * event.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -25,11 +25,11 @@
 #include &quot;global.h&quot;
 #include &quot;proto.h&quot;
 #include &lt;stdio.h&gt;		/* sprintf() */
-#ifdef WIN32 
+#ifdef WIN32
 #include &lt;winsock2.h&gt;
 #else
 #include &lt;netinet/in.h&gt;  /*  htonl(),htons() */
-#endif 
+#endif
 #include &lt;string.h&gt;  /*  strlen(),strcpy() */
 extern int focus_oid;
 extern int winw,winh; /* to give aspect ratio to the program */
@@ -84,7 +84,7 @@
 int event_quit(struct t_process *p)
 {
 	prot_com_out(p, S3D_P_S_QUIT, NULL,0);
-	s3dprintf(HIGH,&quot;sending pid %d QUIT signal&quot;,p-&gt;id); 
+	s3dprintf(HIGH,&quot;sending pid %d QUIT signal&quot;,p-&gt;id);
 	process_del(p-&gt;id);
 	return(0);
 }
@@ -106,8 +106,7 @@
 	struct t_obj	 *o;
 	p=get_proc_by_pid(MCP);
 	event_obj_info(p,get_pointer(p));
-	if (OBJ_VALID(p,focus_oid,o))
-	{
+	if (OBJ_VALID(p,focus_oid,o)) {
 		p=get_proc_by_pid(o-&gt;n_mat); /* focused program pointer*/
 		event_obj_info(p,get_pointer(p));
 	}
@@ -120,35 +119,33 @@
 	struct t_obj_info mo;
 	struct t_process *ap;
 	struct t_obj *o;
-	if (OBJ_VALID(p,oid,o))
-	{
+	if (OBJ_VALID(p,oid,o)) {
 		mo.object=htonl(oid);
 		mo.trans_x=p-&gt;object[oid]-&gt;translate.x;
 		mo.trans_y=p-&gt;object[oid]-&gt;translate.y;
 		mo.trans_z=p-&gt;object[oid]-&gt;translate.z;
-	
+
 		mo.rot_x=p-&gt;object[oid]-&gt;rotate.x;
 		mo.rot_y=p-&gt;object[oid]-&gt;rotate.y;
 		mo.rot_z=p-&gt;object[oid]-&gt;rotate.z;
-	
+
 		mo.scale=p-&gt;object[oid]-&gt;scale;
-	
+
 		mo.r=p-&gt;object[oid]-&gt;r;
 
 		memset(mo.name,0,NAME_MAX);
-		switch (o-&gt;oflags&amp;OF_TYPE)
-		{
-			case OF_VIRTUAL:
-				ap=get_proc_by_pid(o-&gt;n_mat);
-				strncpy(mo.name,ap-&gt;name,NAME_MAX);
-				break;
-			case OF_CAM:
-				mo.scale=(float)((float)winw)/winh; /* give aspect ratio to program */
-				strncpy(mo.name,&quot;sys_camera0&quot;,NAME_MAX);
-				break;
-			case OF_POINTER:
-				strncpy(mo.name,&quot;sys_pointer0&quot;,NAME_MAX);
-				break;
+		switch (o-&gt;oflags&amp;OF_TYPE) {
+		case OF_VIRTUAL:
+			ap=get_proc_by_pid(o-&gt;n_mat);
+			strncpy(mo.name,ap-&gt;name,NAME_MAX);
+			break;
+		case OF_CAM:
+			mo.scale=(float)((float)winw)/winh; /* give aspect ratio to program */
+			strncpy(mo.name,&quot;sys_camera0&quot;,NAME_MAX);
+			break;
+		case OF_POINTER:
+			strncpy(mo.name,&quot;sys_pointer0&quot;,NAME_MAX);
+			break;
 
 		}
 		prot_com_out(p,S3D_P_S_OINFO,(uint8_t *)&amp;mo,sizeof(struct t_obj_info));

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/global.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -23,28 +23,28 @@
 
 
 #include &quot;config.h&quot;
-#ifdef __APPLE__ 
+#ifdef __APPLE__
 #ifdef SHM
 #undef SHM
 #endif
-#endif 
+#endif
 #include &lt;stdint.h&gt;		 /*  integer types */
 #ifdef SHM
-	#include &lt;sys/shm.h&gt; /* key_t */
+#include &lt;sys/shm.h&gt; /* key_t */
 #endif
 /*  variables and defines */
 extern int frame_mode; 	 /*  GLUT, SDL, ... ? */
 extern int running;		 /*  server running flag */
 /*  relevance macros */
 #ifndef S3DUNUSED
-	#if defined(UNUSEDPARAM_ATTRIBUTE)
-		#define S3DUNUSED(x) (x)__attribute__((unused))
-	#elif defined(UNUSEDPARAM_OMIT)
-		#define S3DUNUSED(x) /* x */
-	#else
-		#define S3DUNUSED(x) x
-	#endif
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define S3DUNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define S3DUNUSED(x) /* x */
+#else
+#define S3DUNUSED(x) x
 #endif
+#endif
 #define NAME_MAX	256		 /*  limit for names [e.g. process names] */
 #define MCP			0		 /*  the mcp's pid	 */
 #define TEXTURE_MAX_W	2048
@@ -66,60 +66,52 @@
 #define OBJ_VALID(p,oid,o)	(oid &gt;= 0) &amp;&amp; ((oid &lt; p-&gt;n_obj) &amp;&amp; ((o=p-&gt;object[oid])!=NULL))
 typedef float t_mtrx[16];
 
-struct buf_t
-{
+struct buf_t {
 	uint32_t start,end,bufsize;	/* start/end of the data */
 };
 
 /*  some graphic simple prototypes, they might get into some headerfile later ... */
 /*  our lovely vertex list ... */
-struct t_vertex 
-{
+struct t_vertex {
 	float x,y,z;
 };
-struct t_texc
-{
+struct t_texc {
 	float x,y;
 };
 /*  polygon definition; */
 /*  it's all handled via list types as usually we have only one surface for many polygons, */
 /*  and many vertexes have 2 or more polygons connected. OpenGL will optimize the lists for us */
 /*  anyways, so we shouldn't care ... */
-struct t_poly
-{
+struct t_poly {
 	uint32_t v[3]; 				 /*  we define a poly as set of 3 vertexes, as its usual */
 	struct t_vertex n[3]; 		 /*  normal vectors */
 	uint32_t mat;  				 /*  material index */
 	struct t_texc tc[3];		 /*  texture coords */
 };
-struct t_line
-{
+struct t_line {
 	uint32_t v[2];
 	struct t_vertex n[2];		 /* normal vectors */
 	uint32_t mat;
 };
 /*  material of surfaces, as it's usual in the OpenGL standard */
-struct t_mat
-{
+struct t_mat {
 	float amb_r,amb_g,amb_b,amb_a, 			 /*  ambience */
-		  spec_r,spec_g,spec_b,spec_a,	 	 /*  specualar */
-		  diff_r,diff_g,diff_b,diff_a;		 /*  diffusion */
+	spec_r,spec_g,spec_b,spec_a,	 	 /*  specualar */
+	diff_r,diff_g,diff_b,diff_a;		 /*  diffusion */
 	int32_t tex;							 /*  texture index, -1 if there is no */
 };
 /*  this defines a texture */
-struct t_tex
-{
+struct t_tex {
 	uint16_t w,h;		 /*  width and height */
 	uint16_t tw,th;		 /*  texture width */
 	uint8_t *buf;		 /*  the data */
 	float xs,ys;		 /*  scale data for gl-implementations which require 2^x */
-						 /*  texture sizes. */
+	/*  texture sizes. */
 	int32_t gl_texnum;	 /*  the gl texture number. */
 };
 /*  the object type */
-struct t_obj
-{
-		uint32_t oflags;			 /*  flags, like this object beeing input etc. */
+struct t_obj {
+	uint32_t oflags;			 /*  flags, like this object beeing input etc. */
 #define OF_TURN_ON 		1
 #define OF_TURN_OFF 	2
 #define OF_TURN_SWAP 	3
@@ -138,31 +130,31 @@
 
 #define OF_CLONE		0x10000000
 #define OF_VIRTUAL		0x20000000
-		
+
 #define OF_SYSTEM		0x80000000
 #define OF_CAM			0x90000000
 #define OF_POINTER		0xA0000000
 #define OF_3DPOINTER	0xB0000000
 
 #define OF_MASK			0x00FFFFFF
-		int32_t n_vertex, n_mat, n_poly, n_tex, n_line;
-					 /*  if OF_VIRTUAL is set, n_mat contains the pid */
-					 /*  if OF_CLONE is set, n_vertex contains the original oid */
-					 /*  I know this is dirty, but it would a waste of data if I don't do so ... */
-		int32_t dplist;		 /*  opengl display list number */
-		int32_t linkid;		 /*  linking target, -1 if there is none */
-		int32_t lsub,lnext,lprev;
-		 /*  pointer to our objects; */
-		struct t_vertex *p_vertex;
-		struct t_mat	*p_mat;
-		struct t_poly	*p_poly;
-		struct t_line   *p_line;
-		struct t_tex	*p_tex;
-		struct t_vertex translate,rotate;
-		float 			scale;
-		t_mtrx			m;
-		int				m_uptodate;	 
-		float r,or;					 /*  radius, object radius */
+	int32_t n_vertex, n_mat, n_poly, n_tex, n_line;
+	/*  if OF_VIRTUAL is set, n_mat contains the pid */
+	/*  if OF_CLONE is set, n_vertex contains the original oid */
+	/*  I know this is dirty, but it would a waste of data if I don't do so ... */
+	int32_t dplist;		 /*  opengl display list number */
+	int32_t linkid;		 /*  linking target, -1 if there is none */
+	int32_t lsub,lnext,lprev;
+	/*  pointer to our objects; */
+	struct t_vertex *p_vertex;
+	struct t_mat	*p_mat;
+	struct t_poly	*p_poly;
+	struct t_line   *p_line;
+	struct t_tex	*p_tex;
+	struct t_vertex translate,rotate;
+	float 			scale;
+	t_mtrx			m;
+	int				m_uptodate;
+	float r,or;					 /*  radius, object radius */
 };
 #ifdef SHM
 struct t_shmcb {
@@ -175,8 +167,7 @@
 #endif
 
 /*  l_* is a list-type, t_* is the type itself */
-struct t_process
-{
+struct t_process {
 	char 				  name[NAME_MAX];		 /*  process name */
 	struct t_obj		**object;				 /*  initial pointer to object list */
 	int32_t				  n_obj;				 /*  number of objects */
@@ -195,15 +186,14 @@
 #endif
 };
 
-struct t_obj_info 
-{
+struct t_obj_info {
 	int32_t object;
 	uint32_t flags;
 	float trans_x,trans_y,trans_z;
 	float rot_x,rot_y,rot_z;
 	float scale;
 	float r;
-	char name[NAME_MAX]; 
+	char name[NAME_MAX];
 };
 enum {
 	zero,

Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/graphics.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * graphics.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -50,38 +50,42 @@
 int graphics_init ()
 {
 	GLfloat shin[]={16.0};
-	switch (frame_mode)
-	{
+	switch (frame_mode) {
 #ifdef G_SDL
-		case FRAME_SDL:graphics_init_sdl();break;
+	case FRAME_SDL:
+		graphics_init_sdl();
+		break;
 #endif
 #ifdef G_GLUT
-		case FRAME_GLUT:graphics_init_glut();break;
+	case FRAME_GLUT:
+		graphics_init_glut();
+		break;
 #endif
-		default: return(-1);
+	default:
+		return(-1);
 	}
 	/* light */
 	glEnable(GL_LIGHTING);
 	glEnable(GL_LIGHT0);
-	
+
 	/* depth test */
 	glEnable(GL_DEPTH_TEST);
-/*     glDepthFunc( GL_LEQUAL ); */
-	
+	/*     glDepthFunc( GL_LEQUAL ); */
+
 	/* textures */
-    glEnable(GL_TEXTURE_2D);
-    glShadeModel (GL_SMOOTH);
+	glEnable(GL_TEXTURE_2D);
+	glShadeModel (GL_SMOOTH);
 	glDisable(GL_DITHER);
 
 	/* lines */
-    glHint(GL_LINE_SMOOTH_HINT, GL_FASTEST); 
-    glLineWidth(1.0);
-    glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
-	
+	glHint(GL_LINE_SMOOTH_HINT, GL_FASTEST);
+	glLineWidth(1.0);
+	glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
+
 	/* polygon smoothing */
 	glDisable(GL_POLYGON_SMOOTH);
-/*    glEnable(GL_POLYGON_SMOOTH); 
-    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST); */
+	/*    glEnable(GL_POLYGON_SMOOTH);
+	    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST); */
 
 	/* normalizing */
 	glDisable(GL_AUTO_NORMAL);
@@ -89,12 +93,12 @@
 	glEnable(GL_RESCALE_NORMAL);
 
 	/* blending */
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-/*    glBlendFunc(GL_SRC_ALPHA_SATURATE, GL_ONE);*/
+	glEnable(GL_BLEND);
+	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	/*    glBlendFunc(GL_SRC_ALPHA_SATURATE, GL_ONE);*/
 
 	/* set shininess */
-/* 	glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS,shin); */
+	/* 	glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS,shin); */
 	glMaterialfv(GL_FRONT,GL_SHININESS,shin);
 	graphics_reshape(X_RES,Y_RES);
 
@@ -117,7 +121,7 @@
 		glFrustum(-1.0,1.0,-(1.0*h)/w,(1.0*h)/w,1.0,5000);
 	glMatrixMode(GL_MODELVIEW);
 	if (procs_p!=NULL)
-	event_cam_changed();
+		event_cam_changed();
 }
 void render_virtual_object(struct t_obj *o)
 {
@@ -130,30 +134,26 @@
 	glMultMatrixf(o-&gt;m);
 	glGetFloatv(GL_MODELVIEW_MATRIX,m);
 	cull_get_planes();
-	if (NULL==(ap=get_proc_by_pid(o-&gt;n_mat)))  /*  the clean way */
-	{
+	if (NULL==(ap=get_proc_by_pid(o-&gt;n_mat))) { /*  the clean way */
 		errds(HIGH,&quot;render_by_mcp()&quot;,&quot;not existing pid (%d) referenced by mcp-object!!&quot;, o);
 	} else {
-	 /*  now go throu the objects of our app  */
-		for (j=0;j&lt;ap-&gt;n_obj;j++)
-		{
-			if (ap-&gt;object[j]!=NULL)
-			{
-				if (((select_mode==0) &amp;&amp; ap-&gt;object[j]-&gt;oflags&amp;OF_VISIBLE) || ((select_mode ==1 ) &amp;&amp; (ap-&gt;object[j]-&gt;oflags&amp;OF_SELECTABLE))) /* either select mode is off or it's selectable */
-				{
+		/*  now go throu the objects of our app  */
+		for (j=0;j&lt;ap-&gt;n_obj;j++) {
+			if (ap-&gt;object[j]!=NULL) {
+				if (((select_mode==0) &amp;&amp; ap-&gt;object[j]-&gt;oflags&amp;OF_VISIBLE) || ((select_mode ==1 ) &amp;&amp; (ap-&gt;object[j]-&gt;oflags&amp;OF_SELECTABLE))) { /* either select mode is off or it's selectable */
 					x.x=x.y=x.z=0.0f;
 					mySetMatrix(ap-&gt;object[j]-&gt;m); /* get into position ... */
 					myTransformV(&amp;x);
-					y.x=1.0;y.y=y.z=0.0f;
+					y.x=1.0;
+					y.y=y.z=0.0f;
 					myTransformV(&amp;y);
 					y.x-=x.x;
 					y.y-=x.y;
 					y.z-=x.z;
 
 					k=cull_sphere_in_frustum(&amp;x,ap-&gt;object[j]-&gt;r * sqrt(y.x*y.x + y.y*y.y + y.z*y.z));
-					if (k)
-					{
-/*						s3dprintf(HIGH,&quot;object %d is in %s frustum&quot;,j,k?&quot;&quot;:&quot;not&quot;);*/
+					if (k) {
+						/*						s3dprintf(HIGH,&quot;object %d is in %s frustum&quot;,j,k?&quot;&quot;:&quot;not&quot;);*/
 						if (select_mode==1)
 							glPushName(j);
 						obj_render(ap,j);
@@ -175,22 +175,18 @@
 	struct t_obj *o;
 	struct t_vertex x,y;
 	int k;
-	for (i=0 ; i &lt; p-&gt;n_obj ; i++)
-	{   /* check all mcp objects ... */
+	for (i=0 ; i &lt; p-&gt;n_obj ; i++) {  /* check all mcp objects ... */
 		o=p-&gt;object[i];
-		if (o!=NULL)
-		{
-			if ((select_mode==0 &amp;&amp; o-&gt;oflags&amp;OF_VISIBLE) || (select_mode==1 &amp;&amp; o-&gt;oflags&amp;OF_SELECTABLE))  /*  it's even visible ;) */
-			{
-				if (o-&gt;oflags&amp;OF_VIRTUAL)  /*  we have an app here. */
-				{
-					if (o-&gt;r!=0.0)
-					{
-						cull_get_planes(); 
+		if (o!=NULL) {
+			if ((select_mode==0 &amp;&amp; o-&gt;oflags&amp;OF_VISIBLE) || (select_mode==1 &amp;&amp; o-&gt;oflags&amp;OF_SELECTABLE)) { /*  it's even visible ;) */
+				if (o-&gt;oflags&amp;OF_VIRTUAL) { /*  we have an app here. */
+					if (o-&gt;r!=0.0) {
+						cull_get_planes();
 						mySetMatrix(o-&gt;m);
 						x.x=x.y=x.z=0.0f;
 						myTransformV(&amp;x);
-						y.x=1.0;y.y=y.z=0.0f;
+						y.x=1.0;
+						y.y=y.z=0.0f;
 						myTransformV(&amp;y);
 						y.x-=x.x;
 						y.y-=x.y;
@@ -198,32 +194,27 @@
 
 						k=cull_sphere_in_frustum(&amp;x,o-&gt;r * sqrt(y.x*y.x + y.y*y.y + y.z*y.z));
 						s3dprintf(VLOW,&quot;mcp-object %d is in %s frustum&quot;,i,k?&quot;&quot;:&quot;not&quot;);
-						if (k)
-							{
-							if (select_mode==1)
-							{
+						if (k) {
+							if (select_mode==1) {
 								s3dprintf(VLOW,&quot;object %d in culling frustrum!&quot;,i);
 								glLoadName(i);
 							}
 							render_virtual_object(o);
 						} else {
-							if (select_mode==1)
-							{
+							if (select_mode==1) {
 								s3dprintf(VLOW,&quot;object %d not in culling frustrum!&quot;,i);
 							}
 						}
 					}
-				} else if ((o-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[o-&gt;n_vertex]-&gt;oflags&amp;OF_VIRTUAL))  /* it's a clone of an app */
-				{
+				} else if ((o-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[o-&gt;n_vertex]-&gt;oflags&amp;OF_VIRTUAL)) { /* it's a clone of an app */
 					if (select_mode==1)
 						glLoadName(o-&gt;n_vertex);/*TODO: what to do if a clone is selected?! */
 					glPushMatrix();
 					render_virtual_object(o);
-					render_virtual_object(p-&gt;object[o-&gt;n_vertex]); 
+					render_virtual_object(p-&gt;object[o-&gt;n_vertex]);
 					glPopMatrix();
 				} else { /* it's a &quot;regular&quot; mcp object */
-					if (select_mode==1)
-					{
+					if (select_mode==1) {
 						s3dprintf(VLOW,&quot;mcp object no. %d&quot;,i);
 						glLoadName(-1);
 						glPushName(i);
@@ -237,9 +228,9 @@
 	}
 	return(0);
 }
- /* this picks objects from their screen-positions and sends
-  * OBK_CLICK-events for the selected object(s).
-  * TODO: how big should the select buffer be? */
+/* this picks objects from their screen-positions and sends
+ * OBK_CLICK-events for the selected object(s).
+ * TODO: how big should the select buffer be? */
 #define SBSIZE	65536
 int graphics_pick_obj(int x, int y)
 {
@@ -257,12 +248,11 @@
 	glSelectBuffer(SBSIZE,select_buf);
 	glRenderMode(GL_SELECT);
 	glMatrixMode(GL_PROJECTION);
-	 /*  count the objects .... */
+	/*  count the objects .... */
 	glPushMatrix();
 	glLoadIdentity();
 	glGetIntegerv(GL_VIEWPORT, viewport);
-	if (winw&gt;winh)
-	{
+	if (winw&gt;winh) {
 		xpos=((x-winw/2.0)/(winw/2.0))*(((double)winw/winh));
 		ypos=(((winh-y)-winh/2.0)/(winh/2.0));
 	} else {
@@ -277,62 +267,61 @@
 	myInvert();
 	myGetMatrix(m);
 	glMultMatrixf(m);
-/*
-	glRotatef(-cam.rotate.x, 1.0,0.0,0.0);
-	glRotatef(-cam.rotate.y, 0.0,1.0,0.0);
-	glTranslatef(-cam.translate.x,-cam.translate.y,-cam.translate.z);*/
+	/*
+		glRotatef(-cam.rotate.x, 1.0,0.0,0.0);
+		glRotatef(-cam.rotate.y, 0.0,1.0,0.0);
+		glTranslatef(-cam.translate.x,-cam.translate.y,-cam.translate.z);*/
 
 	glInitNames();
 	glPushName(0);
 	render_by_mcp();
 	glFlush();
 	hits=glRenderMode(GL_RENDER);
-	if ( hits &gt; 0 )
-	{
+	if ( hits &gt; 0 ) {
 		big=INFINITY;
 		s3dprintf(LOW,&quot;had %d hits&quot;,hits);
 		ptr=select_buf;
 		mcp_o= o= names= -1;
 		/* check all the hits, only select the nearest ... */
-		for (i=0 ; i &lt; hits ; i++)
-		{
-			names=*ptr;						ptr++;
-			z1=(float)*ptr/0x7fffffff;		ptr++;
-			z2=(float)*ptr/0x7fffffff;		ptr++;
-			if (z1&lt;big)
-			{
+		for (i=0 ; i &lt; hits ; i++) {
+			names=*ptr;
+			ptr++;
+			z1=(float)*ptr/0x7fffffff;
+			ptr++;
+			z2=(float)*ptr/0x7fffffff;
+			ptr++;
+			if (z1&lt;big) {
 				mcp_o=o=-1;
-				for (j=0;j&lt;names;j++)
-				{
-					switch (j)
-					{
-						case 0:mcp_o=	*ptr;break;
-						case 1:o=		*ptr;break;
+				for (j=0;j&lt;names;j++) {
+					switch (j) {
+					case 0:
+						mcp_o=	*ptr;
+						break;
+					case 1:
+						o=		*ptr;
+						break;
 					}
 					ptr++;
 				}
 				big=z1;
-			} else 
+			} else
 				for (j=0;j&lt;names;j++)
 					ptr++;
-		    s3dprintf(VLOW,&quot;[HIT %d] names %d [z1:%f|z2:%f] mcp_o=%d, o=%d &quot;,i,names, z1, z2, mcp_o, o);
+			s3dprintf(VLOW,&quot;[HIT %d] names %d [z1:%f|z2:%f] mcp_o=%d, o=%d &quot;,i,names, z1, z2, mcp_o, o);
 		}
 		s3dprintf(VLOW,&quot;mcp_o= %d, o= %d&quot;,mcp_o,o);
 		ptr=select_buf;
-		if (mcp_o==-1) /* it's an mcp object */
-		{
+		if (mcp_o==-1) { /* it's an mcp object */
 			s3dprintf(LOW,&quot;clicked on mcp-object no. %d&quot;,o);
 			event_obj_click(p,o);
-		} else 
-		if ((names&gt;1) &amp;&amp; ((mcp_o&gt;=0)&amp;&amp;(mcp_o&lt;p-&gt;n_obj)))
-		{ /* it's an usual object */
-			s3dprintf(LOW,&quot;clicked on mcp-object %d, object %d&quot;,mcp_o,o);
-			if (p-&gt;object[mcp_o]!=NULL)  /*  that shouldn't happen anyways ... */
-			{
-				obj_debug(get_proc_by_pid(p-&gt;object[mcp_o]-&gt;n_mat),o); 
-				event_obj_click(get_proc_by_pid(p-&gt;object[mcp_o]-&gt;n_mat),o);
+		} else
+			if ((names&gt;1) &amp;&amp; ((mcp_o&gt;=0)&amp;&amp;(mcp_o&lt;p-&gt;n_obj))) { /* it's an usual object */
+				s3dprintf(LOW,&quot;clicked on mcp-object %d, object %d&quot;,mcp_o,o);
+				if (p-&gt;object[mcp_o]!=NULL) { /*  that shouldn't happen anyways ... */
+					obj_debug(get_proc_by_pid(p-&gt;object[mcp_o]-&gt;n_mat),o);
+					event_obj_click(get_proc_by_pid(p-&gt;object[mcp_o]-&gt;n_mat),o);
+				}
 			}
- 	}
 	}
 	glMatrixMode(GL_PROJECTION);
 	glPopMatrix();
@@ -351,52 +340,52 @@
 	GLfloat light0_shininess[] ={1.0};
 	GLfloat light0_diff[]={0.5,0.5,0.5,1.0};
 	GLfloat light0_amb[]={1.0,1.0,1.0,1.0};
-	
+
 	select_mode=0;
 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  /*  clear screen */
-	 /*  set up the cam ... */
+	/*  set up the cam ... */
 	glMatrixMode(GL_MODELVIEW);
 
 	glLightfv(GL_LIGHT0,GL_AMBIENT,light0_amb);
 	glLightfv(GL_LIGHT0,GL_DIFFUSE,light0_diff);
 	glLightfv(GL_LIGHT0,GL_SPECULAR,light0_spec);
 	glLightfv(GL_LIGHT0,GL_SHININESS,light0_shininess);
-	
+
 	glLoadIdentity();
-	
+
 	mySetMatrix(p-&gt;object[0]-&gt;m);
 	myInvert();
 	myGetMatrix(m);
 	glMultMatrixf(m);
 	glLightfv(GL_LIGHT0,GL_POSITION,pos);
-	
+
 	/*glRotatef(-cam.rotate.z, 0.0,0.0,1.0);
 	glRotatef(-cam.rotate.x, 1.0,0.0,0.0);
 	glRotatef(-cam.rotate.y, 0.0,1.0,0.0);
 	glTranslatef(-cam.translate.x,-cam.translate.y,-cam.translate.z);*/
 
- 	glPushMatrix();  /*  save the cam */ 
-		render_by_mcp();
- 	glPopMatrix();  /*  restore the cam */ 
+	glPushMatrix();  /*  save the cam */
+	render_by_mcp();
+	glPopMatrix();  /*  restore the cam */
 	glLoadIdentity();
 	glMultMatrixf(m);
 
-	switch (frame_mode)
-	{
+	switch (frame_mode) {
 #ifdef G_GLUT
-		case FRAME_GLUT:
-				glFlush();
-				glutSwapBuffers();
-				break;
+	case FRAME_GLUT:
+		glFlush();
+		glutSwapBuffers();
+		break;
 #endif
 #ifdef G_SDL
-    	case FRAME_SDL:
-				/* SDL will glFlush itself */
-				SDL_GL_SwapBuffers(); 
-				break;
+	case FRAME_SDL:
+		/* SDL will glFlush itself */
+		SDL_GL_SwapBuffers();
+		break;
 #endif
 #ifdef G_GLX
-		case FRAME_GLX:...
+	case FRAME_GLX:
+		...
 #endif
 	}
 }

Modified: trunk/server/graphics_glut.c
===================================================================
--- trunk/server/graphics_glut.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/graphics_glut.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * graphics_glut.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -37,11 +37,11 @@
 	int argc=1;
 	char *argv[]={&quot;s3d&quot;, NULL};
 	s3dprintf(MED,&quot;Using GLUT for GL/windowing ...&quot;);
- 	glutInit(&amp;argc, argv); 
+	glutInit(&amp;argc, argv);
 	glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH | GLUT_RGBA);
 	glutInitWindowSize (X_RES, Y_RES);
 	glutCreateWindow(&quot;grmbl&quot;);
-    glutIdleFunc(one_time);
+	glutIdleFunc(one_time);
 	if (0!=(atexit(quit)))
 		s3dprintf(MED,&quot;Error in setting Exit function ...&quot;);
 	glutDisplayFunc(graphics_main);
@@ -51,5 +51,5 @@
 /*  nothing to be done ... */
 int graphics_quit_glut()
 {
-	return(0);	
+	return(0);
 }

Modified: trunk/server/graphics_sdl.c
===================================================================
--- trunk/server/graphics_sdl.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/graphics_sdl.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * graphics_sdl.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -30,40 +30,37 @@
 int SDLFlags = 0;					 /*  some flags for SDL */
 int graphics_init_sdl()
 {
-    SDL_Surface *GLwin = NULL;
-    SDL_VideoInfo *VideoInfo;
-    int rgb_size[3]; 				 /*  for SDL_GL attributes */
-    int buffers, samples;
+	SDL_Surface *GLwin = NULL;
+	SDL_VideoInfo *VideoInfo;
+	int rgb_size[3]; 				 /*  for SDL_GL attributes */
+	int buffers, samples;
 	s3dprintf(MED,&quot;Using SDL driver ...&quot;);
-	
-    SDLFlags = SDL_OPENGL | SDL_GL_DOUBLEBUFFER | SDL_HWPALETTE | SDL_RESIZABLE;
-    if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) &lt; 0)  		
-			errsf(&quot;SDL_Init()&quot;,SDL_GetError());
-    if ((VideoInfo = (SDL_VideoInfo *)SDL_GetVideoInfo())==NULL)
-			errs(&quot;SDL_GetVIdeoInfo()&quot;,SDL_GetError());
-    if(VideoInfo -&gt; hw_available) 
-	{
+
+	SDLFlags = SDL_OPENGL | SDL_GL_DOUBLEBUFFER | SDL_HWPALETTE | SDL_RESIZABLE;
+	if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) &lt; 0)
+		errsf(&quot;SDL_Init()&quot;,SDL_GetError());
+	if ((VideoInfo = (SDL_VideoInfo *)SDL_GetVideoInfo())==NULL)
+		errs(&quot;SDL_GetVIdeoInfo()&quot;,SDL_GetError());
+	if (VideoInfo -&gt; hw_available) {
 		s3dprintf(LOW,&quot;detected HW_SURFACE&quot;);
 		SDLFlags |= SDL_HWSURFACE;
-	}
-	else
-	{
+	} else {
 		s3dprintf(LOW,&quot;detected SW_SURFACE&quot;);
 		SDLFlags |= SDL_SWSURFACE;
 	}
-    if(VideoInfo -&gt; blit_hw)  	
+	if (VideoInfo -&gt; blit_hw)
 		SDLFlags |= SDL_HWACCEL;
-/*     if(SDL_WM_ToggleFullScreen(GLwin) == 0)        	SDLerror(&quot;SDL_WM_ToggleFullScreen&quot;); */
+	/*     if(SDL_WM_ToggleFullScreen(GLwin) == 0)        	SDLerror(&quot;SDL_WM_ToggleFullScreen&quot;); */
 
 
-	 /*  set some opengl-attributes */
-/*	SDL_GL_SetAttribute( SDL_GL_RED_SIZE, rgb_size[0] );
-	SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, rgb_size[1] );
-	SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, rgb_size[2] );*/
-/* 	SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5); */
-/* 	SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 5); */
-/* 	SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5); */
-/* 	SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 ); */
+	/*  set some opengl-attributes */
+	/*	SDL_GL_SetAttribute( SDL_GL_RED_SIZE, rgb_size[0] );
+		SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, rgb_size[1] );
+		SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, rgb_size[2] );*/
+	/* 	SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5); */
+	/* 	SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 5); */
+	/* 	SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5); */
+	/* 	SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 ); */
 	SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
 	do {
 		if (aa_level&gt;0) {
@@ -71,9 +68,8 @@
 			if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, aa_level ))	s3dprintf(VHIGH,&quot;no multisampling available&quot;);
 		}
 
-		 /*  more opengl-init-stuff */
-		if ((GLwin = SDL_SetVideoMode(X_RES,Y_RES,16,SDLFlags))==NULL) 
-		{
+		/*  more opengl-init-stuff */
+		if ((GLwin = SDL_SetVideoMode(X_RES,Y_RES,16,SDLFlags))==NULL) {
 			if (aa_level&gt;0) {
 				s3dprintf(MED,&quot;retry without multisampling&quot;);
 				aa_level=0;
@@ -84,27 +80,36 @@
 		}
 	} while (GLwin==0);
 	switch (SDL_GetVideoInfo()-&gt;vfmt-&gt;BitsPerPixel) {
-	    case 8:
-				rgb_size[0] = 3;	rgb_size[1] = 3;	rgb_size[2] = 2;	break;
-	    case 15:
-	    case 16:
-				rgb_size[0] = 5;	rgb_size[1] = 5;	rgb_size[2] = 5;	break;
-            default:
-				rgb_size[0] = 8;	rgb_size[1] = 8;	rgb_size[2] = 8;	break;
+	case 8:
+		rgb_size[0] = 3;
+		rgb_size[1] = 3;
+		rgb_size[2] = 2;
+		break;
+	case 15:
+	case 16:
+		rgb_size[0] = 5;
+		rgb_size[1] = 5;
+		rgb_size[2] = 5;
+		break;
+	default:
+		rgb_size[0] = 8;
+		rgb_size[1] = 8;
+		rgb_size[2] = 8;
+		break;
 	}
 	if (aa_level &gt;0) {
-	    SDL_GL_GetAttribute( SDL_GL_MULTISAMPLEBUFFERS, &amp;buffers );
-	    SDL_GL_GetAttribute( SDL_GL_MULTISAMPLESAMPLES, &amp;samples );
-	    s3dprintf(LOW,&quot;Buffers: %d Samples: %d&quot;, buffers, samples);
+		SDL_GL_GetAttribute( SDL_GL_MULTISAMPLEBUFFERS, &amp;buffers );
+		SDL_GL_GetAttribute( SDL_GL_MULTISAMPLESAMPLES, &amp;samples );
+		s3dprintf(LOW,&quot;Buffers: %d Samples: %d&quot;, buffers, samples);
 	}
 
-	 /*  print some information */
+	/*  print some information */
 	s3dprintf(VLOW,&quot;Screen BPP: %d&quot;, SDL_GetVideoSurface()-&gt;format-&gt;BitsPerPixel);
 	s3dprintf(VLOW,&quot;Vendor     : %s&quot;, glGetString( GL_VENDOR ) );
 	s3dprintf(VLOW,&quot;Renderer   : %s&quot;, glGetString( GL_RENDERER ) );
 	s3dprintf(VLOW,&quot;Version    : %s&quot;, glGetString( GL_VERSION ) );
 	s3dprintf(VLOW,&quot;Extensions : %s&quot;, glGetString( GL_EXTENSIONS ) );
-	
+
 	graphics_reshape(X_RES,Y_RES);
 	return(0);
 }

Modified: trunk/server/main.c
===================================================================
--- trunk/server/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * main.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -58,10 +58,9 @@
 }
 void sigchld_handler(int S3DUNUSED(sig))
 {
-	if (kidpid!=0)
-	{
+	if (kidpid!=0) {
 		kidpid=0;
-	    s3dprintf(HIGH,&quot;how cruel, my kid died!!&quot;);
+		s3dprintf(HIGH,&quot;how cruel, my kid died!!&quot;);
 		quit();
 	}
 }
@@ -76,39 +75,35 @@
 {
 #ifdef SIGS
 	int ret,i;
-	struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+	struct timespec t= {
+		0,10*1000*1000
+	}; /* 10 mili seconds */
 	kidpid=fork();
-	if (kidpid==-1)
-	{
+	if (kidpid==-1) {
 		errsf(&quot;rc_init()&quot;,&quot;*sobsob*, can't fork&quot;);
 		exit(1);
 	}
-	if (kidpid==0)
-	{
-	    if (signal(SIGUSR1, sigusr_handler) == SIG_ERR) 
-		        errn(&quot;init():signal()&quot;,errno);
+	if (kidpid==0) {
+		if (signal(SIGUSR1, sigusr_handler) == SIG_ERR)
+			errn(&quot;init():signal()&quot;,errno);
 
 		/* giving the father lots of time to set his signal handler
 		 * and all his sockets up */
-		while (!running)  
-			nanosleep(&amp;t,NULL); 	
-		for (i=0 ; i &lt; ((int)(sizeof(s3drc)/sizeof(char **))) ; i++)
-		{
-			if ((*s3drc[i])!=NULL)
-			{
+		while (!running)
+			nanosleep(&amp;t,NULL);
+		for (i=0 ; i &lt; ((int)(sizeof(s3drc)/sizeof(char **))) ; i++) {
+			if ((*s3drc[i])!=NULL) {
 				s3dprintf(LOW,&quot;[RC] launching %s&quot;,*s3drc[i]);
 				ret=system(*s3drc[i]);
 				s3dprintf(VLOW,&quot;[RC] system() said %d&quot;,ret);
-				if (ret&lt;128) 
-				{
+				if (ret&lt;128) {
 					s3dprintf(LOW,&quot;V[RC] system() did well, I guess. let's die clean now.&quot;);
 					exit(0);
 				}
-			} 
+			}
 		}
 		errs(&quot;rc_init()&quot;, &quot;no usuable rc script found.&quot;);
-		if (rc==NULL)
-		{
+		if (rc==NULL) {
 			errs(&quot;rc_init()&quot;,&quot;You don't have an rc-script? Think about creating one (~/.s3drc), its handy :)&quot;);
 			errs(&quot;rc_init()&quot;,&quot;Starting anyway ...&quot;);
 			while (1) sleep(1);
@@ -121,15 +116,14 @@
 		if (signal(SIGCHLD, sigchld_handler) == SIG_ERR) {
 		}
 		/* father just returns */
-	}	
+	}
 #endif
 	return(0);
 }
 /*  the mainloop, should be handling all signals */
-static void mainloop(void) 
+static void mainloop(void)
 {
-	while (running)
-	{
+	while (running) {
 		one_time();
 	}
 }
@@ -137,16 +131,18 @@
 /*  things which should be done each time in main loop go here! this is */
 /*  just for the case we use a function for the mainloop like we do for glut... */
 
-struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-void one_time() 
+struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
+void one_time()
 {
-	nanosleep(&amp;t,NULL); 
+	nanosleep(&amp;t,NULL);
 	user_main();
-	network_main(); 
+	network_main();
 	graphics_main();
 }
 /*  this initalizes all components.  */
-int init() 
+int init()
 {
 #ifdef	__APPLE__
 	NSApplicationLoad();
@@ -157,8 +153,7 @@
 #else
 	s3dprintf(VHIGH,&quot;rc-files won't work without signals :(&quot;);
 #endif
-	if (!frame_mode)  /*  turn default frame_mode on */
-	{
+	if (!frame_mode) { /*  turn default frame_mode on */
 #ifdef G_SDL
 		frame_mode=FRAME_SDL;
 #else
@@ -167,8 +162,7 @@
 #endif
 #endif
 	}
-	if (!frame_mode)
-	{
+	if (!frame_mode) {
 		errsf(&quot;init()&quot;,&quot;no framework mode available&quot;);
 		return(-1);
 	}
@@ -178,10 +172,10 @@
 	process_init();
 	running=1;
 #ifdef SIGS
-    if (signal(SIGINT, sigint_handler) == SIG_ERR) 
-	        errn(&quot;init():signal()&quot;,errno);
-    if (signal(SIGTERM, sigint_handler) == SIG_ERR) 
-	        errn(&quot;init():signal()&quot;,errno);
+	if (signal(SIGINT, sigint_handler) == SIG_ERR)
+		errn(&quot;init():signal()&quot;,errno);
+	if (signal(SIGTERM, sigint_handler) == SIG_ERR)
+		errn(&quot;init():signal()&quot;,errno);
 	if (kidpid!=0)
 		kill(kidpid, SIGUSR1);
 #endif
@@ -191,14 +185,12 @@
 /*  things to be cleaned up  */
 void quit()
 {
-	if (running!=0)
-	{
+	if (running!=0) {
 		user_quit();
 		network_quit();
 		graphics_quit();
 		process_quit();
-		if (kidpid!=0)
-		{ /* our kid is most probably still alive. kill it!! */
+		if (kidpid!=0) { /* our kid is most probably still alive. kill it!! */
 			s3dprintf(HIGH,&quot;kill all the kids!!&quot;);
 			kill(kidpid,SIGTERM);
 			kidpid=0;
@@ -213,82 +205,77 @@
 {
 	int					 lopt_idx;
 	char				 c;
-	struct option long_options[] = 
-	{
-		{&quot;multisample&quot;,		1,0,'m'},
-		{&quot;rc&quot;,				1,0,'r'},
-		{&quot;help&quot;,			0,0,'h'},
-		{&quot;use-glut&quot;,		0,0,'g'},
-		{&quot;use-sdl&quot;,			0,0,'s'},
-		{&quot;no-rc&quot;,			0,0,'n'},
-		{0,0,0,0}
+	struct option long_options[] = {
+		{&quot;multisample&quot;,		1,0,'m'
+		}, {&quot;rc&quot;,				1,0,'r'}, {&quot;help&quot;,			0,0,'h'}, {&quot;use-glut&quot;,		0,0,'g'}, {&quot;use-sdl&quot;,			0,0,'s'}, {&quot;no-rc&quot;,			0,0,'n'}, {0,0,0,0}
 	};
-	while (-1!=(c=getopt_long(argc,argv,&quot;?hgsnr:m:&quot;,long_options,&amp;lopt_idx)))
-	{
-		switch (c)
-		{
-				case 0:break;
-				case 'g':
+	while (-1!=(c=getopt_long(argc,argv,&quot;?hgsnr:m:&quot;,long_options,&amp;lopt_idx))) {
+		switch (c) {
+		case 0:
+			break;
+		case 'g':
 #ifdef G_GLUT
-					frame_mode=FRAME_GLUT;
+			frame_mode=FRAME_GLUT;
 #else
-					errsf(&quot;process_args()&quot;,&quot;sorry, GLUT is not available&quot;);
+			errsf(&quot;process_args()&quot;,&quot;sorry, GLUT is not available&quot;);
 #endif
-					break;
-				case 's':
+			break;
+		case 's':
 #ifdef G_SDL
-					frame_mode=FRAME_SDL;
+			frame_mode=FRAME_SDL;
 #else
-					errsf(&quot;process_args()&quot;,&quot;sorry, SDL is not available&quot;);
-#endif					
-					break;
-				case 'r':
-					s3dprintf(VHIGH,&quot;using rc file: %s&quot;,optarg);
-					rc=optarg;
-					break;
-				case 'm':
-					aa_level=atoi(optarg);
-					if (aa_level&gt;=0 || aa_level&lt;=16)
-						s3dprintf(VHIGH,&quot;aa_level: %d&quot;,aa_level);
-					else
-						errsf(&quot;process_args()&quot;,&quot;bad multisampling level&quot;);
-					break;
-				case 'n':
-					s3dprintf(VHIGH,&quot;Using no rc file!&quot;);
-					norc=1;
-					break;
+			errsf(&quot;process_args()&quot;,&quot;sorry, SDL is not available&quot;);
+#endif
+			break;
+		case 'r':
+			s3dprintf(VHIGH,&quot;using rc file: %s&quot;,optarg);
+			rc=optarg;
+			break;
+		case 'm':
+			aa_level=atoi(optarg);
+			if (aa_level&gt;=0 || aa_level&lt;=16)
+				s3dprintf(VHIGH,&quot;aa_level: %d&quot;,aa_level);
+			else
+				errsf(&quot;process_args()&quot;,&quot;bad multisampling level&quot;);
+			break;
+		case 'n':
+			s3dprintf(VHIGH,&quot;Using no rc file!&quot;);
+			norc=1;
+			break;
 
-				case '?':
-				case 'h':
-					s3dprintf(VHIGH,&quot;usage: %s [options]&quot;,argv[0]);
-					s3dprintf(VHIGH,&quot;s3d, the 3d server:&quot;);
-					s3dprintf(VHIGH,&quot; --multisample, -m:\tSpecify Multisampling level (antialiasing) if available.\n\t\t(value 1-16, default 4, 0 = off),&quot;);
-					s3dprintf(VHIGH,&quot; --rc, -r:\tspecify a rc (startup script)&quot;);
-					s3dprintf(VHIGH,&quot; --no-rc, -n:\tdon't use a rc file (useful for debugging mcp's)&quot;);
+		case '?':
+		case 'h':
+			s3dprintf(VHIGH,&quot;usage: %s [options]&quot;,argv[0]);
+			s3dprintf(VHIGH,&quot;s3d, the 3d server:&quot;);
+			s3dprintf(VHIGH,&quot; --multisample, -m:\tSpecify Multisampling level (antialiasing) if available.\n\t\t(value 1-16, default 4, 0 = off),&quot;);
+			s3dprintf(VHIGH,&quot; --rc, -r:\tspecify a rc (startup script)&quot;);
+			s3dprintf(VHIGH,&quot; --no-rc, -n:\tdon't use a rc file (useful for debugging mcp's)&quot;);
 #ifdef G_GLUT
-					s3dprintf(VHIGH,&quot; --use-glut, -g:\tuse GLUT as framework-system&quot;);
+			s3dprintf(VHIGH,&quot; --use-glut, -g:\tuse GLUT as framework-system&quot;);
 #endif
 #ifdef G_SDL
-					s3dprintf(VHIGH,&quot; --use-sdl, -s:\tuse SDL as framework-system&quot;);
+			s3dprintf(VHIGH,&quot; --use-sdl, -s:\tuse SDL as framework-system&quot;);
 #endif
-					s3dprintf(VHIGH,&quot; --help, -?, -h: this helpful text&quot;);
-					errsf(&quot;process_args()&quot;,&quot;exiting for users sake&quot;);
-					return(-1);
+			s3dprintf(VHIGH,&quot; --help, -?, -h: this helpful text&quot;);
+			errsf(&quot;process_args()&quot;,&quot;exiting for users sake&quot;);
+			return(-1);
 		}
 	}
 	return(0);
 }
 /*  things to be done when program is started */
-int main(int argc, char **argv) {
+int main(int argc, char **argv)
+{
 	process_args(argc,argv);
 	init();
-	switch (frame_mode)
-	{
+	switch (frame_mode) {
 #ifdef G_GLUT
-		case FRAME_GLUT:glutMainLoop();
-				break;
+	case FRAME_GLUT:
+		glutMainLoop();
+		break;
 #endif
-		default:mainloop();
+	default:
+		mainloop();
 	}
 	quit();
 	return(0);

Modified: trunk/server/matrix.c
===================================================================
--- trunk/server/matrix.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/matrix.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
- * matrix.c 
- * 
+ * matrix.c
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -29,10 +29,10 @@
 #define DEG2RAD (M_PI/180.0)
 static t_mtrx MAT;
 t_mtrx Identity = {
-   1.0, 0.0, 0.0, 0.0,
-   0.0, 1.0, 0.0, 0.0,
-   0.0, 0.0, 1.0, 0.0,
-   0.0, 0.0, 0.0, 1.0
+	1.0, 0.0, 0.0, 0.0,
+	0.0, 1.0, 0.0, 0.0,
+	0.0, 0.0, 1.0, 0.0,
+	0.0, 0.0, 0.0, 1.0
 };
 void myLoadIdentity()
 {
@@ -52,8 +52,7 @@
 	int i,j,k;
 	t_mtrx mat_d;  /*  destination matrix */
 	for (i=0;i&lt;4;i++)
-		for (j=0;j&lt;4;j++)
-		{
+		for (j=0;j&lt;4;j++) {
 			mat_d[I(i,j)]=0.0F;
 			for (k=0;k&lt;4;k++)
 				mat_d[I(i,j)]+=M(k,j)*mat2[I(i,k)];
@@ -107,18 +106,17 @@
 	memcpy(Mm,MAT,sizeof(t_mtrx));			/* backup matrix */
 	memcpy(Pm,Identity,sizeof(t_mtrx));		/* target */
 
-/*	s3dprintf(MED,&quot;start:&quot;);
-	mat_debug(MAT);*/
+	/*	s3dprintf(MED,&quot;start:&quot;);
+		mat_debug(MAT);*/
 
-/*	s3dprintf(LOW,&quot;inverting matrix, we shall begin now ...&quot;);*/
+	/*	s3dprintf(LOW,&quot;inverting matrix, we shall begin now ...&quot;);*/
 
 	/* step 1 */
-	for (l=0;l&lt;4;l++)
-	{
-check:	if (M(l,l)*M(l,l)&gt;0.00000001F) /* it won't work with real zero */
-		{
-			
-/*			s3dprintf(MED,&quot;normalizing line %d&quot;,l);*/
+	for (l=0;l&lt;4;l++) {
+check:
+		if (M(l,l)*M(l,l)&gt;0.00000001F) { /* it won't work with real zero */
+
+			/*			s3dprintf(MED,&quot;normalizing line %d&quot;,l);*/
 			/* normalize */
 			f=1/M(l,l);
 			M(l,l)=1.0;
@@ -126,15 +124,13 @@
 				M(i,l)*=f; /* the left side ... */
 			for (i=0;i&lt;4;i++)
 				P(i,l)*=f; /* ... and the right */
-/*			mat_debug(Mm);
-			s3dprintf(MED,&quot;-&quot;);
-			mat_debug(Pm);*/
+			/*			mat_debug(Mm);
+						s3dprintf(MED,&quot;-&quot;);
+						mat_debug(Pm);*/
 			/* mult/fac */
-			for (lh=l+1;lh&lt;4;lh++)
-			{
-			/*	s3dprintf(MED,&quot;adding line %d for %d&quot;,lh,l);*/
-				if (M(l,lh)!=0) /* &quot;first&quot; element of the line */
-				{
+			for (lh=l+1;lh&lt;4;lh++) {
+				/*	s3dprintf(MED,&quot;adding line %d for %d&quot;,lh,l);*/
+				if (M(l,lh)!=0) { /* &quot;first&quot; element of the line */
 					f=-M(l,lh);
 					M(l,lh)=0.0; /* yes, this WILL be zero! ... */
 					for (i=l+1;i&lt;4;i++) /* left side */
@@ -145,13 +141,11 @@
 			}
 		} else {
 			M(l,l)=0.0F;
-/*			s3dprintf(MED,&quot;already zero now check and try to swap lines ...&quot;);*/
+			/*			s3dprintf(MED,&quot;already zero now check and try to swap lines ...&quot;);*/
 			for (lh=l+1;lh&lt;4;lh++)
-				if (M(l,lh)!=0.0)
-				{
-/*					s3dprintf(MED,&quot;swapping lines %d and %d&quot;,l,lh);*/
-					for (i=0;i&lt;4;i++)
-					{
+				if (M(l,lh)!=0.0) {
+					/*					s3dprintf(MED,&quot;swapping lines %d and %d&quot;,l,lh);*/
+					for (i=0;i&lt;4;i++) {
 						f=M(i,l);
 						M(i,l)=M(i,lh);
 						M(i,lh)=f;
@@ -172,35 +166,31 @@
 	 * (01??|????)
 	 * (001?|????)
 	 * (0001|????)
-	 * 
+	 *
 	 *  (M = left side, P = right side)
 	 * */
 
 	/* step 2 */
-/*	s3dprintf(MED,&quot;S.T.E.P. 2!!&quot;);*/
-	for (l=3;l&gt;0;l--)
-	{
+	/*	s3dprintf(MED,&quot;S.T.E.P. 2!!&quot;);*/
+	for (l=3;l&gt;0;l--) {
 		/* mult/fac */
-		for (lh=l-1;lh&gt;=0;lh--)
-		{
-/*			s3dprintf(MED,&quot;adding line %d for %d&quot;,lh,l);*/
-			if (M(l,lh)!=0) /* &quot;first&quot; element of the line */
-			{
+		for (lh=l-1;lh&gt;=0;lh--) {
+			/*			s3dprintf(MED,&quot;adding line %d for %d&quot;,lh,l);*/
+			if (M(l,lh)!=0) { /* &quot;first&quot; element of the line */
 				f=-M(l,lh);
-				M(l,lh)=0; 
-				for (i=0;i&lt;4;i++)	/* ... and the right one! */
-				{
+				M(l,lh)=0;
+				for (i=0;i&lt;4;i++) {	/* ... and the right one! */
 					P(i,lh)+=f*P(i,l);
 				}
 
 			}
-/*			mat_debug(Mm);
-			mat_debug(Pm);*/
+			/*			mat_debug(Mm);
+						mat_debug(Pm);*/
 		}
 	}
 	/* now, Mm,is Identity and Pm is result!*/
-/*	s3dprintf(MED,&quot;result:&quot;);
-	mat_debug(Pm);*/
+	/*	s3dprintf(MED,&quot;result:&quot;);
+		mat_debug(Pm);*/
 	memcpy(MAT,Pm,sizeof(t_mtrx)); /* copy result */
 	return(0);
 }

Modified: trunk/server/mcp.c
===================================================================
--- trunk/server/mcp.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/mcp.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * mcp.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -25,9 +25,9 @@
 #include &quot;global.h&quot;
 #include &quot;proto.h&quot; 			 /*  for S3D_P_OBJECT, to be integrated in proto.c */
 #ifdef WIN32
-	#include &lt;winsock2.h&gt;
+#include &lt;winsock2.h&gt;
 #else
-	#include &lt;netinet/in.h&gt; 	 /*  htonl() */
+#include &lt;netinet/in.h&gt; 	 /*  htonl() */
 #endif
 #include &lt;string.h&gt;			 /*  strncpy() */
 
@@ -35,13 +35,12 @@
 extern int 		   focus_oid;		 /*  the focused program */
 
 /*  this interacts with the actual mcp client */
-struct mcp_object 
-{
+struct mcp_object {
 	uint32_t object;
 	float trans_x,trans_y,trans_z;
 	float r;
-/* 	char event; */
-	char name[NAME_MAX]; 
+	/* 	char event; */
+	char name[NAME_MAX];
 };
 #define MCP_NEW_OBJECT	1
 /*  call when a new mcp connects */
@@ -51,18 +50,16 @@
 	uint32_t i;
 	p=get_proc_by_pid(MCP);
 	i=p-&gt;n_obj;
-	while (i--)
-	{
+	while (i--) {
 		if (p-&gt;object[i]!=NULL)
-		switch (p-&gt;object[i]-&gt;oflags&amp;OF_TYPE)
-		{
+			switch (p-&gt;object[i]-&gt;oflags&amp;OF_TYPE) {
 			case OF_VIRTUAL:
-					mcp_rep_object(i);
-					break;
+				mcp_rep_object(i);
+				break;
 			case OF_CAM:
-					event_obj_info(p,i);
-					break;
-		}
+				event_obj_info(p,i);
+				break;
+			}
 	}
 	mcp_focus(-1);
 	return(0);
@@ -78,7 +75,7 @@
 	mo.trans_y=p-&gt;object[mcp_oid]-&gt;translate.y;
 	mo.trans_z=p-&gt;object[mcp_oid]-&gt;translate.z;
 	mo.r=p-&gt;object[mcp_oid]-&gt;r;
-/* 	mo.event=MCP_NEW_OBJECT; */
+	/* 	mo.event=MCP_NEW_OBJECT; */
 	ap=get_proc_by_pid(p-&gt;object[mcp_oid]-&gt;n_mat);
 	strncpy(mo.name,ap-&gt;name,NAME_MAX);
 	prot_com_out(p,S3D_P_MCP_OBJECT,(uint8_t *)&amp;mo,sizeof(struct mcp_object));
@@ -88,8 +85,7 @@
 int mcp_del_object(int32_t mcp_oid)
 {
 	int32_t oid=htonl(mcp_oid);
-	if (mcp_oid==focus_oid)
-	{
+	if (mcp_oid==focus_oid) {
 		s3dprintf(MED,&quot;lost the focus of mcp-oid %d&quot;,mcp_oid);
 		mcp_focus(-1);
 	}
@@ -105,8 +101,7 @@
 	p=get_proc_by_pid(MCP);
 	s3dprintf(MED,&quot;request to focus %d&quot;,oid);
 	if (OBJ_VALID(p,oid,o))
-		if (o-&gt;oflags&amp;OF_VIRTUAL)
-		{
+		if (o-&gt;oflags&amp;OF_VIRTUAL) {
 			focus_oid=oid;
 			obj_pos_update(p,0,0);
 		}

Modified: trunk/server/navigation.c
===================================================================
--- trunk/server/navigation.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/navigation.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * navigation.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -43,7 +43,7 @@
 {
 	navi_pos(0,-1);
 }
-/* simple movements, not needed currently 
+/* simple movements, not needed currently
 void navi_rot_right()
 {
 	cam.rotate.y=cam.rotate.y+2;
@@ -99,8 +99,7 @@
 	float tv[3],rv[3],xf,yf;
 	struct t_process *p;
 	int ptr;
-	if (winw&gt;winh)
-	{
+	if (winw&gt;winh) {
 		xf=winw/(float)winh;
 		yf=1;
 	} else {
@@ -114,9 +113,8 @@
 	rv[1]=1.5*180/M_PI*-atan(tv[0]/2);
 	rv[2]=0;
 	p=get_proc_by_pid(MCP);
-	if (-1!=(ptr=get_pointer(p)))
-	{
-		obj_translate(p,ptr,tv);	
-		obj_rotate(p,ptr,rv);	
+	if (-1!=(ptr=get_pointer(p))) {
+		obj_translate(p,ptr,tv);
+		obj_rotate(p,ptr,rv);
 	}
 }

Modified: trunk/server/network.c
===================================================================
--- trunk/server/network.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/network.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * network.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -32,7 +32,7 @@
 #include &lt;SDL.h&gt;	/* SDL_SetTimer() */
 #endif
 #ifdef SIGS
-  #include &lt;signal.h&gt;	 /*  sighandler_t SIG_PIPE */
+#include &lt;signal.h&gt;	 /*  sighandler_t SIG_PIPE */
 #endif
 /*  here go all the network functions */
 /*  */
@@ -45,10 +45,10 @@
 uint8_t obuf[MAXPLEN]; /* output buffer */
 #ifdef SIGS
 int sigio=0;
-#endif 
+#endif
 
 #ifdef SIGS
-void sigpipe_handler(int S3DUNUSED(unused))  
+void sigpipe_handler(int S3DUNUSED(unused))
 {
 	errs(&quot;sigpip_handler()&quot;,&quot;there is a broken pipe somewhere&quot;);
 }
@@ -62,24 +62,24 @@
 int network_init()
 {
 #ifdef SIGS
-/*	struct sigaction act;*/
+	/*	struct sigaction act;*/
 #endif
 #ifdef TCP
-   tcp_init();
-#endif 
+	tcp_init();
+#endif
 #ifdef SHM
-   shm_init();
+	shm_init();
 #endif
-#ifdef SIGS			
-    if (signal(SIGPIPE, sigpipe_handler) == SIG_ERR) 
+#ifdef SIGS
+	if (signal(SIGPIPE, sigpipe_handler) == SIG_ERR)
 		errn(&quot;network_init():signal()&quot;,errno);
-/*	act.sa_handler = (sig_t)sigio_handler;
-	if ( sigaction(SIGIO, &amp;act, 0) &lt; 0 )
-		errn(&quot;network_init():sigaction()&quot;,errno);*/
-     if (signal(SIGIO, sigio_handler) == SIG_ERR)  
- 		errn(&quot;s3d_init():signal()&quot;,errno); 
+	/*	act.sa_handler = (sig_t)sigio_handler;
+		if ( sigaction(SIGIO, &amp;act, 0) &lt; 0 )
+			errn(&quot;network_init():sigaction()&quot;,errno);*/
+	if (signal(SIGIO, sigio_handler) == SIG_ERR)
+		errn(&quot;s3d_init():signal()&quot;,errno);
 #endif
-   return(0);
+	return(0);
 }
 int					 turn;
 int	net_turn_off(int S3DUNUSED(interval))
@@ -94,8 +94,7 @@
 {
 #ifdef TCP
 #ifdef SIGS
-	if (sigio==1)  /*  as long as there is no locking/threadsafety, do like this ... */
-	{
+	if (sigio==1) { /*  as long as there is no locking/threadsafety, do like this ... */
 #endif
 		tcp_pollport();	/*  this polls for new processes */
 #ifdef G_SDL
@@ -118,13 +117,16 @@
 }
 int n_remove(struct t_process *p)
 {
-	switch (p-&gt;con_type)
-	{
+	switch (p-&gt;con_type) {
 #ifdef SHM
-		case CON_SHM:		shm_remove(p); break;
+	case CON_SHM:
+		shm_remove(p);
+		break;
 #endif
 #ifdef TCP
-		case CON_TCP:		tcp_remove(p-&gt;sockid); break;
+	case CON_TCP:
+		tcp_remove(p-&gt;sockid);
+		break;
 #endif
 	}
 	p-&gt;con_type=CON_NULL;
@@ -133,26 +135,28 @@
 
 int n_readn(struct t_process *p, uint8_t *str, int s)
 {
-	switch (p-&gt;con_type)
-	{
+	switch (p-&gt;con_type) {
 #ifdef TCP
-		case CON_TCP:return(tcp_readn(p-&gt;sockid,str,s));
+	case CON_TCP:
+		return(tcp_readn(p-&gt;sockid,str,s));
 #endif
 #ifdef SHM
-		case CON_SHM:return(shm_readn((struct buf_t *)p-&gt;shmsock.data_ctos,str,s));
+	case CON_SHM:
+		return(shm_readn((struct buf_t *)p-&gt;shmsock.data_ctos,str,s));
 #endif
 	}
 	return(-1);
 }
 int n_writen(struct t_process *p, uint8_t *str, int s)
 {
-	switch (p-&gt;con_type)
-	{
+	switch (p-&gt;con_type) {
 #ifdef TCP
-		case CON_TCP:return(tcp_writen(p-&gt;sockid,str,s));
+	case CON_TCP:
+		return(tcp_writen(p-&gt;sockid,str,s));
 #endif
 #ifdef SHM
-		case CON_SHM:return(shm_writen((struct buf_t *)p-&gt;shmsock.data_stoc,str,s));
+	case CON_SHM:
+		return(shm_writen((struct buf_t *)p-&gt;shmsock.data_stoc,str,s));
 #endif
 	}
 	return(-1);
@@ -166,6 +170,6 @@
 #ifdef SHM
 	shm_quit();
 #endif
-	return(0);	
+	return(0);
 }
 

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/object.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * object.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -32,7 +32,7 @@
 #include &lt;math.h&gt;		 /*  sin(),cos() */
 
 #define MAXLOOP	10
-		 /*  if oid is always unsigned, we don't have to check oid&gt;=0 */
+/*  if oid is always unsigned, we don't have to check oid&gt;=0 */
 
 extern t_mtrx Identity;
 extern int focus_oid;
@@ -46,19 +46,15 @@
 {
 	struct t_obj *o;
 	s3dprintf(HIGH,&quot;about pid %d/obj %d:&quot;,p-&gt;id,oid);
-	if (OBJ_VALID(p,oid,o))
-	{
+	if (OBJ_VALID(p,oid,o)) {
 		s3dprintf(HIGH,&quot;vertices: %d, polygons: %d, materials: %d, textures: %d, flags: %010x&quot;,o-&gt;n_vertex,o-&gt;n_poly, o-&gt;n_mat, o-&gt;n_tex,o-&gt;oflags);
 		s3dprintf(HIGH,&quot;linkid %d, displaylist %d&quot;,o-&gt;linkid,o-&gt;dplist);
 		s3dprintf(HIGH,&quot;translation: %f %f %f&quot;,o-&gt;translate.x,o-&gt;translate.y,o-&gt;translate.z);
 		s3dprintf(HIGH,&quot;rotation: %f %f %f&quot;,o-&gt;rotate.x,o-&gt;rotate.y,o-&gt;rotate.z);
 		s3dprintf(HIGH,&quot;scale: %f&quot;,o-&gt;scale);
-		if (o-&gt;oflags&amp;OF_SYSTEM)
-		{
+		if (o-&gt;oflags&amp;OF_SYSTEM) {
 			s3dprintf(HIGH,&quot;it's a system object!!&quot;);
-		}
-		else if (o-&gt;oflags&amp;OF_CLONE)
-		{
+		} else if (o-&gt;oflags&amp;OF_CLONE) {
 			s3dprintf(HIGH,&quot;it's a clone linking to %d&quot;,o-&gt;n_vertex);
 			obj_debug(p,o-&gt;n_vertex);
 		}
@@ -77,58 +73,48 @@
 	float *px;
 	float r;
 	int is_clnsrc;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_push_vertex()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
 		m=obj-&gt;n_vertex;	 /*  saving the first number of vertices */
 		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_vertex=realloc(obj-&gt;p_vertex,sizeof(struct t_vertex) * ( n + (obj-&gt;n_vertex)))))
-		{
-			if (obj-&gt;dplist)
-			{
+		if (NULL!=(p_vertex=realloc(obj-&gt;p_vertex,sizeof(struct t_vertex) * ( n + (obj-&gt;n_vertex))))) {
+			if (obj-&gt;dplist) {
 				s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 				glDeleteLists(obj-&gt;dplist,1);
 				obj-&gt;dplist=0;
 			}
 			obj-&gt;p_vertex=p_vertex;
-			for (i=0;i&lt;n;i++)
-			{
+			for (i=0;i&lt;n;i++) {
 				obj-&gt;p_vertex[m+i].x=*(px++);
 				obj-&gt;p_vertex[m+i].y=*(px++);
 				obj-&gt;p_vertex[m+i].z=*(px++);
 
 				a=&amp;obj-&gt;p_vertex[m+i];
-				r=obj-&gt;scale * sqrt(	
-						(a-&gt;x * a-&gt;x ) + 
-						(a-&gt;y * a-&gt;y ) +
-						(a-&gt;z * a-&gt;z ));
+				r=obj-&gt;scale * sqrt(
+				          (a-&gt;x * a-&gt;x ) +
+				          (a-&gt;y * a-&gt;y ) +
+				          (a-&gt;z * a-&gt;z ));
 				if (r&gt; obj-&gt;r) obj-&gt;r=r;
-/*				s3dprintf(VLOW,&quot;added following vertex[%d]: %f, %f, %f&quot;,i,
-								obj-&gt;p_vertex[m+i].x,
-								obj-&gt;p_vertex[m+i].y,
-								obj-&gt;p_vertex[m+i].z);*/
+				/*				s3dprintf(VLOW,&quot;added following vertex[%d]: %f, %f, %f&quot;,i,
+												obj-&gt;p_vertex[m+i].x,
+												obj-&gt;p_vertex[m+i].y,
+												obj-&gt;p_vertex[m+i].z);*/
 
 			}
-			if (p-&gt;id!=MCP)
-			{
-			/* this is doing live update which is quite okay, but we need
-			 * to check for biggest update and clonesources ... */
+			if (p-&gt;id!=MCP) {
+				/* this is doing live update which is quite okay, but we need
+				 * to check for biggest update and clonesources ... */
 				obj_check_biggest_object(p,oid);
 			}
-			if (p-&gt;object[oid]-&gt;oflags&amp;OF_CLONE_SRC)
-			{
+			if (p-&gt;object[oid]-&gt;oflags&amp;OF_CLONE_SRC) {
 				is_clnsrc=0;
-				for (i=0;i&lt;p-&gt;n_obj;i++)
-				{
-					if (p-&gt;object[i]!=NULL)
-					{
-						if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex==oid))
-						{ /* if it's pointing to our object ... */
+				for (i=0;i&lt;p-&gt;n_obj;i++) {
+					if (p-&gt;object[i]!=NULL) {
+						if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex==oid)) { /* if it's pointing to our object ... */
 							is_clnsrc=1;
 							p-&gt;object[i]-&gt;r=obj-&gt;r*(p-&gt;object[i]-&gt;r/obj-&gt;scale); /* give it the new radius too! */
 							obj_check_biggest_object(p,i);
@@ -141,8 +127,7 @@
 
 			obj-&gt;n_vertex+=n;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -155,26 +140,21 @@
 	struct t_mat *p_mat;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_push_mat()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 		m=obj-&gt;n_mat;	 /*  saving the first number of materials */
 		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_mat=realloc(obj-&gt;p_mat,sizeof(struct t_mat) * ( n + (obj-&gt;n_mat)))))
-		{
-			if (obj-&gt;dplist)
-			{
+		if (NULL!=(p_mat=realloc(obj-&gt;p_mat,sizeof(struct t_mat) * ( n + (obj-&gt;n_mat))))) {
+			if (obj-&gt;dplist) {
 				s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 				glDeleteLists(obj-&gt;dplist,1);
 				obj-&gt;dplist=0;
 			}
 			obj-&gt;p_mat=p_mat;
-			for (i=0;i&lt;n;i++)
-			{
+			for (i=0;i&lt;n;i++) {
 				obj-&gt;p_mat[m+i].amb_r=*(px++);
 				obj-&gt;p_mat[m+i].amb_g=*(px++);
 				obj-&gt;p_mat[m+i].amb_b=*(px++);
@@ -191,8 +171,7 @@
 			}
 			obj-&gt;n_mat+=n;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -205,27 +184,22 @@
 	struct t_poly *p_poly;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_push_poly()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
 		m=obj-&gt;n_poly;	 /*  saving the first number of polys */
 		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_poly=realloc(obj-&gt;p_poly,sizeof(struct t_poly) * ( n + (obj-&gt;n_poly)))))
-		{
-			if (obj-&gt;dplist)
-			{
+		if (NULL!=(p_poly=realloc(obj-&gt;p_poly,sizeof(struct t_poly) * ( n + (obj-&gt;n_poly))))) {
+			if (obj-&gt;dplist) {
 				s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 				glDeleteLists(obj-&gt;dplist,1);
 				obj-&gt;dplist=0;
 			}
 			obj-&gt;p_poly=p_poly;
-			for (i=0;i&lt;n;i++)
-			{
+			for (i=0;i&lt;n;i++) {
 				obj-&gt;p_poly[m+i].v[0]=*(px++);
 				obj-&gt;p_poly[m+i].v[1]=*(px++);
 				obj-&gt;p_poly[m+i].v[2]=*(px++);
@@ -239,8 +213,7 @@
 			}
 			obj-&gt;n_poly+=n;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -252,27 +225,22 @@
 	struct t_line *p_line;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_push_line()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
 		m=obj-&gt;n_line;	 /*  saving the first number of lines */
 		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_line=realloc(obj-&gt;p_line,sizeof(struct t_line) * ( n + (obj-&gt;n_line)))))
-		{
-			if (obj-&gt;dplist)
-			{
+		if (NULL!=(p_line=realloc(obj-&gt;p_line,sizeof(struct t_line) * ( n + (obj-&gt;n_line))))) {
+			if (obj-&gt;dplist) {
 				s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 				glDeleteLists(obj-&gt;dplist,1);
 				obj-&gt;dplist=0;
 			}
 			obj-&gt;p_line=p_line;
-			for (i=0;i&lt;n;i++)
-			{
+			for (i=0;i&lt;n;i++) {
 				obj-&gt;p_line[m+i].v[0]=*(px++);
 				obj-&gt;p_line[m+i].v[1]=*(px++);
 				obj-&gt;p_line[m+i].mat=*(px++);
@@ -281,8 +249,7 @@
 			}
 			obj-&gt;n_line+=n;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -296,31 +263,26 @@
 	struct t_tex *p_tex;
 	struct t_obj *obj;
 	uint16_t *px,hm;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_push_tex()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 		m=obj-&gt;n_tex;	     /*  saving the first number of textures */
 		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_tex=realloc(obj-&gt;p_tex,sizeof(struct t_tex) * ( n + (obj-&gt;n_tex)))))
-		{
-/*			if (obj-&gt;dplist)
-			{
-				s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-				glDeleteLists(obj-&gt;dplist,1);
-				obj-&gt;dplist=0;
-			}*/
+		if (NULL!=(p_tex=realloc(obj-&gt;p_tex,sizeof(struct t_tex) * ( n + (obj-&gt;n_tex))))) {
+			/*			if (obj-&gt;dplist)
+						{
+							s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
+							glDeleteLists(obj-&gt;dplist,1);
+							obj-&gt;dplist=0;
+						}*/
 			obj-&gt;p_tex=p_tex;
-			for (i=0;i&lt;n;i++)
-			{
+			for (i=0;i&lt;n;i++) {
 				obj-&gt;p_tex[m+i].gl_texnum=-1;
 				obj-&gt;p_tex[m+i].tw=*(px++);
 				obj-&gt;p_tex[m+i].th=*(px++);
-				if ((obj-&gt;p_tex[m+i].tw&lt;=TEXTURE_MAX_W) &amp;&amp; (obj-&gt;p_tex[m+i].th&lt;=TEXTURE_MAX_H))
-				{
+				if ((obj-&gt;p_tex[m+i].tw&lt;=TEXTURE_MAX_W) &amp;&amp; (obj-&gt;p_tex[m+i].th&lt;=TEXTURE_MAX_H)) {
 					d=log((double)obj-&gt;p_tex[m+i].tw)/log(2.0);
 					hm=pow(2,floor(d));
 					s3dprintf(MED,&quot;hm %d, tw %d&quot;,hm,obj-&gt;p_tex[m+i].tw);
@@ -334,7 +296,7 @@
 					d=log((double)obj-&gt;p_tex[m+i].th)/log(2.0);
 					hm=pow(2,floor(d));
 					s3dprintf(MED,&quot;hm %d, th %d&quot;,hm,obj-&gt;p_tex[m+i].th);
-					
+
 					if (hm!=obj-&gt;p_tex[m+i].th) 	{
 						obj-&gt;p_tex[m+i].h=hm*2;
 						obj-&gt;p_tex[m+i].ys=(float)((double)obj-&gt;p_tex[m+i].th)/((double)obj-&gt;p_tex[m+i].h);
@@ -345,21 +307,20 @@
 					obj-&gt;p_tex[m+i].buf=malloc(obj-&gt;p_tex[m+i].h*obj-&gt;p_tex[m+i].w*4);
 					memset(obj-&gt;p_tex[m+i].buf,0,obj-&gt;p_tex[m+i].h*obj-&gt;p_tex[m+i].w*4);
 					errds(LOW,&quot;obj_push_tex()&quot;,&quot;setting up %d %d (in mem: %d %d) texture&quot;,
-									obj-&gt;p_tex[m+i].tw,
-									obj-&gt;p_tex[m+i].th,
-									obj-&gt;p_tex[m+i].w,
-									obj-&gt;p_tex[m+i].h);
-									
+					      obj-&gt;p_tex[m+i].tw,
+					      obj-&gt;p_tex[m+i].th,
+					      obj-&gt;p_tex[m+i].w,
+					      obj-&gt;p_tex[m+i].h);
+
 				} else	{
 					errds(MED,&quot;obj_push_tex()&quot;,&quot;bad size for texture %d (requested size: %dx%d, max %dx%d)&quot;,m+i,
-									obj-&gt;p_tex[m+i].tw,obj-&gt;p_tex[m+i].th,TEXTURE_MAX_W,TEXTURE_MAX_H);
+					      obj-&gt;p_tex[m+i].tw,obj-&gt;p_tex[m+i].th,TEXTURE_MAX_W,TEXTURE_MAX_H);
 					obj-&gt;p_tex[m+i].buf=NULL;
 				}
 			}
 			obj-&gt;n_tex+=n;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -370,31 +331,26 @@
 	int32_t i,j,m;
 	struct t_obj *obj;
 	float *px;
- 	float len; 
-	if (OBJ_VALID(p,oid,obj))
-	{
+	float len;
+	if (OBJ_VALID(p,oid,obj)) {
 		m=obj-&gt;n_poly;
 		if (m&lt;n)	 /*  saving the first number of polys */
 			n=m;  /*  when more polygons than available should be pepped,  */
-				 /*  just pep the first m polygons */
+		/*  just pep the first m polygons */
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_pep_poly_normal()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
-		if (obj-&gt;dplist)
-		{
+		if (obj-&gt;dplist) {
 			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 			glDeleteLists(obj-&gt;dplist,1);
 			obj-&gt;dplist=0;
 		}
 		s3dprintf(VLOW,&quot;pepping poly's %d to %d&quot;,(m-n),m);
-		for (i=(m-n);i&lt;m;i++)
-		{
-			for (j=0;j&lt;3;j++)
-			{
+		for (i=(m-n);i&lt;m;i++) {
+			for (j=0;j&lt;3;j++) {
 				obj-&gt;p_poly[i].n[j].x=*(px++);
 				obj-&gt;p_poly[i].n[j].y=*(px++);
 				obj-&gt;p_poly[i].n[j].z=*(px++);
@@ -408,8 +364,7 @@
 				}
 			}
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -421,30 +376,25 @@
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		m=obj-&gt;n_line;
 		if (m&lt;n)	 /*  saving the first number of lines */
 			n=m;  /*  when more lines than available should be pepped,  */
-				 /*  just pep the first m liness */
+		/*  just pep the first m liness */
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_pep_line_normal()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
-		if (obj-&gt;dplist)
-		{
+		if (obj-&gt;dplist) {
 			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 			glDeleteLists(obj-&gt;dplist,1);
 			obj-&gt;dplist=0;
 		}
 		s3dprintf(VLOW,&quot;pepping line's %d to %d&quot;,(m-n),m);
-		for (i=(m-n);i&lt;m;i++)
-		{
-			for (j=0;j&lt;2;j++)
-			{
+		for (i=(m-n);i&lt;m;i++) {
+			for (j=0;j&lt;2;j++) {
 				obj-&gt;p_line[i].n[j].x=*(px++);
 				obj-&gt;p_line[i].n[j].y=*(px++);
 				obj-&gt;p_line[i].n[j].z=*(px++);
@@ -459,8 +409,7 @@
 
 			}
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -472,10 +421,8 @@
 	int32_t i,j,m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_pep_poly_texc()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
@@ -483,26 +430,22 @@
 		m=obj-&gt;n_poly;
 		if (m&lt;n)	 /*  saving the first number of polys */
 			n=m;  /*  when more polygons than available should be pepped,  */
-				 /*  just pep the first m polygons */
+		/*  just pep the first m polygons */
 		px=x; 				 /*  movable pointer for x, later */
 
-		if (obj-&gt;dplist)
-		{
+		if (obj-&gt;dplist) {
 			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 			glDeleteLists(obj-&gt;dplist,1);
 			obj-&gt;dplist=0;
 		}
 		s3dprintf(VLOW,&quot;pepping poly's %d to %d&quot;,(m-n),m);
-		for (i=(m-n);i&lt;m;i++)
-		{
-			for (j=0;j&lt;3;j++)
-			{
+		for (i=(m-n);i&lt;m;i++) {
+			for (j=0;j&lt;3;j++) {
 				obj-&gt;p_poly[i].tc[j].x=*(px++);
 				obj-&gt;p_poly[i].tc[j].y=*(px++);
 			}
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -513,27 +456,23 @@
 	int32_t i,m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		m=obj-&gt;n_mat;	 /*  saving the first number of materials */
-		if (m&lt;n)	
+		if (m&lt;n)
 			n=m;  /*  when more mats than available should be pepped,  */
-				 /*  just pep the first m mats */
+		/*  just pep the first m mats */
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_pep_mat()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
-		if (obj-&gt;dplist)
-		{
+		if (obj-&gt;dplist) {
 			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 			glDeleteLists(obj-&gt;dplist,1);
 			obj-&gt;dplist=0;
 		}
 		s3dprintf(VLOW,&quot;pepping mats %d to %d&quot;,(m-n),m);
-		for (i=(m-n);i&lt;m;i++)
-		{
+		for (i=(m-n);i&lt;m;i++) {
 			obj-&gt;p_mat[i].amb_r=*(px++);
 			obj-&gt;p_mat[i].amb_g=*(px++);
 			obj-&gt;p_mat[i].amb_b=*(px++);
@@ -547,8 +486,7 @@
 			obj-&gt;p_mat[i].diff_b=*(px++);
 			obj-&gt;p_mat[i].diff_a=*(px++);
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -559,35 +497,30 @@
 	int32_t i,m;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		m=obj-&gt;n_line;	 /*  saving the first number of lines */
-		if (m&lt;n)	
+		if (m&lt;n)
 			n=m;  /*  when more lines than available should be pepped,  */
-				 /*  just pep the first m lines */
+		/*  just pep the first m lines */
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_pep_line()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
-		if (obj-&gt;dplist)
-		{
+		if (obj-&gt;dplist) {
 			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 			glDeleteLists(obj-&gt;dplist,1);
 			obj-&gt;dplist=0;
 		}
 		s3dprintf(VLOW,&quot;pepping lines %d to %d&quot;,(m-n),m);
-		for (i=(m-n);i&lt;m;i++)
-		{
+		for (i=(m-n);i&lt;m;i++) {
 			obj-&gt;p_line[i].v[0]=*(px++);
 			obj-&gt;p_line[i].v[1]=*(px++);
 			obj-&gt;p_line[i].mat=*(px++);
 			obj-&gt;p_line[i].n[0].x=obj-&gt;p_line[i].n[0].y=obj-&gt;p_line[i].n[0].z=0;
 			obj-&gt;p_line[i].n[1].x=obj-&gt;p_line[i].n[1].y=obj-&gt;p_line[i].n[1].z=0;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -603,52 +536,43 @@
 	struct t_obj *obj;
 	float *px;
 	int is_clnsrc;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		m=obj-&gt;n_vertex;	 /*  saving the first number of vertices */
-		if (m&lt;n)	 
+		if (m&lt;n)
 			n=m;  /*  when more mats than available should be pepped,  */
-				 /*  just pep the first m mats */
+		/*  just pep the first m mats */
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_pep_vertices()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
-		if (obj-&gt;dplist)
-		{
+		if (obj-&gt;dplist) {
 			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 			glDeleteLists(obj-&gt;dplist,1);
 			obj-&gt;dplist=0;
 		}
 		s3dprintf(VLOW,&quot;pepping vertices %d to %d&quot;,(m-n),m-1);
-		for (i=(m-n);i&lt;m;i++)
-		{
+		for (i=(m-n);i&lt;m;i++) {
 			obj-&gt;p_vertex[i].x=*(px++);
 			obj-&gt;p_vertex[i].y=*(px++);
 			obj-&gt;p_vertex[i].z=*(px++);
 			a=&amp;obj-&gt;p_vertex[i];
-			r=obj-&gt;scale * sqrt(	
-					(a-&gt;x * a-&gt;x ) + 
-					(a-&gt;y * a-&gt;y ) +
-					(a-&gt;z * a-&gt;z ));
+			r=obj-&gt;scale * sqrt(
+			          (a-&gt;x * a-&gt;x ) +
+			          (a-&gt;y * a-&gt;y ) +
+			          (a-&gt;z * a-&gt;z ));
 			if (r&gt; obj-&gt;r) obj-&gt;r=r;
 		}
-		if (p-&gt;id!=MCP)
-		{
-		/* this is doing live update which is quite okay, but we need
-		 * to check for biggest update and clonesources ... */
+		if (p-&gt;id!=MCP) {
+			/* this is doing live update which is quite okay, but we need
+			 * to check for biggest update and clonesources ... */
 			obj_check_biggest_object(p,oid);
 		}
-		if (p-&gt;object[oid]-&gt;oflags&amp;OF_CLONE_SRC)
-		{
+		if (p-&gt;object[oid]-&gt;oflags&amp;OF_CLONE_SRC) {
 			is_clnsrc=0;
-			for (i=0;i&lt;p-&gt;n_obj;i++)
-			{
-				if (p-&gt;object[i]!=NULL)
-				{
-					if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex==oid))
-					{ /* if it's pointing to our object ... */
+			for (i=0;i&lt;p-&gt;n_obj;i++) {
+				if (p-&gt;object[i]!=NULL) {
+					if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex==oid)) { /* if it's pointing to our object ... */
 						is_clnsrc=1;
 						p-&gt;object[i]-&gt;r=obj-&gt;r*(p-&gt;object[i]-&gt;r/obj-&gt;scale); /* give it the new radius too! */
 						obj_check_biggest_object(p,i);
@@ -658,8 +582,7 @@
 			if (!is_clnsrc)
 				p-&gt;object[oid]-&gt;oflags&amp;=~OF_CLONE_SRC;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -670,20 +593,17 @@
 	int32_t i,m;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		m=obj-&gt;n_mat;	 /*  saving the first number of vertices */
 		if (m&lt;n)	 /*  saving the first number of polys */
 			n=m;  /*  when more mats than available should be pepped,  */
-				 /*  just pep the first m mats */
+		/*  just pep the first m mats */
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_pep_mat_tex()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
-		if (obj-&gt;dplist)
-		{
+		if (obj-&gt;dplist) {
 			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 			glDeleteLists(obj-&gt;dplist,1);
 			obj-&gt;dplist=0;
@@ -691,8 +611,7 @@
 		s3dprintf(MED,&quot;pepping mats %d to %d&quot;,(m-n),m);
 		for (i=(m-n);i&lt;m;i++)
 			obj-&gt;p_mat[i].tex=*(px++);
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -704,29 +623,24 @@
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if (start &lt; 0) return(-1);
 		m=obj-&gt;n_poly;
-		if (m&lt;(start+n))	
-			n=m-start; 
+		if (m&lt;(start+n))
+			n=m-start;
 		px=x;
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_load_poly_normal()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
-		if (obj-&gt;dplist)
-		{
+		if (obj-&gt;dplist) {
 			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 			glDeleteLists(obj-&gt;dplist,1);
 			obj-&gt;dplist=0;
 		}
-		for (i=start;i&lt;(start+n);i++)
-		{
-			for (j=0;j&lt;3;j++)
-			{
+		for (i=start;i&lt;(start+n);i++) {
+			for (j=0;j&lt;3;j++) {
 				obj-&gt;p_poly[i].n[j].x=*(px++);
 				obj-&gt;p_poly[i].n[j].y=*(px++);
 				obj-&gt;p_poly[i].n[j].z=*(px++);
@@ -741,7 +655,7 @@
 
 			}
 		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -752,29 +666,24 @@
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if (start &lt; 0) return(-1);
 		m=obj-&gt;n_line;
-		if (m&lt;(start+n))	
-			n=m-start; 
+		if (m&lt;(start+n))
+			n=m-start;
 		px=x;
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_load_line_normal()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
-		if (obj-&gt;dplist)
-		{
+		if (obj-&gt;dplist) {
 			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 			glDeleteLists(obj-&gt;dplist,1);
 			obj-&gt;dplist=0;
 		}
-		for (i=start;i&lt;(start+n);i++)
-		{
-			for (j=0;j&lt;2;j++)
-			{
+		for (i=start;i&lt;(start+n);i++) {
+			for (j=0;j&lt;2;j++) {
 				obj-&gt;p_line[i].n[j].x=*(px++);
 				obj-&gt;p_line[i].n[j].y=*(px++);
 				obj-&gt;p_line[i].n[j].z=*(px++);
@@ -789,7 +698,7 @@
 
 			}
 		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -799,34 +708,29 @@
 	int32_t i,j,m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if (start &lt; 0) return(-1);
 		m=obj-&gt;n_poly;
-		if (m&lt;(start+n))	
-			n=m-start; 
+		if (m&lt;(start+n))
+			n=m-start;
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_load_poly_texc()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
-		if (obj-&gt;dplist)
-		{
+		if (obj-&gt;dplist) {
 			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 			glDeleteLists(obj-&gt;dplist,1);
 			obj-&gt;dplist=0;
 		}
-		for (i=start;i&lt;(start+n);i++)
-		{
-			for (j=0;j&lt;3;j++)
-			{
+		for (i=start;i&lt;(start+n);i++) {
+			for (j=0;j&lt;3;j++) {
 				obj-&gt;p_poly[i].tc[j].x=*(px++);
 				obj-&gt;p_poly[i].tc[j].y=*(px++);
 			}
 		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -838,27 +742,23 @@
 	int32_t i,m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if (start &lt; 0) return(-1);
-		m=obj-&gt;n_mat;	
-		if (m&lt;(start+n))	
-			n=m-start; 
+		m=obj-&gt;n_mat;
+		if (m&lt;(start+n))
+			n=m-start;
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_pep_mat()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
-		if (obj-&gt;dplist)
-		{
+		if (obj-&gt;dplist) {
 			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 			glDeleteLists(obj-&gt;dplist,1);
 			obj-&gt;dplist=0;
 		}
 		s3dprintf(MED,&quot;pepping %d mats, starting at %d&quot;,n,start);
-		for (i=start;i&lt;(start+n);i++)
-		{
+		for (i=start;i&lt;(start+n);i++) {
 			obj-&gt;p_mat[i].amb_r=*(px++);
 			obj-&gt;p_mat[i].amb_g=*(px++);
 			obj-&gt;p_mat[i].amb_b=*(px++);
@@ -872,7 +772,7 @@
 			obj-&gt;p_mat[i].diff_b=*(px++);
 			obj-&gt;p_mat[i].diff_a=*(px++);
 		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -880,11 +780,10 @@
 static void obj_update_tex(struct t_tex *tex,u_int16_t S3DUNUSED(x),u_int16_t S3DUNUSED(y),u_int16_t S3DUNUSED(w),u_int16_t S3DUNUSED(h),u_int8_t *S3DUNUSED(pixbuf))
 {
 	GLuint t;
-	if ((tex-&gt;gl_texnum)!=-1)
-	{
+	if ((tex-&gt;gl_texnum)!=-1) {
 		t= tex-&gt;gl_texnum;
-/* s3dprintf(MED,&quot;updating texture %d at [%d %d] with a [%d %d] pixbuf&quot;,t,x,y,w,h); */
-/* 		glTexSubImage2D(t,0,x,y,w,h,GL_RGBA,GL_UNSIGNED_BYTE,pixbuf); */
+		/* s3dprintf(MED,&quot;updating texture %d at [%d %d] with a [%d %d] pixbuf&quot;,t,x,y,w,h); */
+		/* 		glTexSubImage2D(t,0,x,y,w,h,GL_RGBA,GL_UNSIGNED_BYTE,pixbuf); */
 
 		glDeleteTextures(1,&amp;t);
 		tex-&gt;gl_texnum=-1;
@@ -897,21 +796,16 @@
 	struct t_tex *t;
 	int32_t i,p1,p2,m;
 	int16_t mw;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_load_tex()&quot;,&quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 		if ( tex &lt; 0 ) return(-1);
-		if ( tex &lt; obj-&gt;n_tex)
-		{
+		if ( tex &lt; obj-&gt;n_tex) {
 			t=&amp;obj-&gt;p_tex[tex];
-			if (t-&gt;buf!=NULL)
-			{
-				if (obj-&gt;dplist)
-				{
+			if (t-&gt;buf!=NULL) {
+				if (obj-&gt;dplist) {
 					s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 					glDeleteLists(obj-&gt;dplist,1);
 					obj-&gt;dplist=0;
@@ -919,11 +813,10 @@
 
 				m=(t-&gt;w-1)*t-&gt;th+t-&gt;tw; 			 /*  maximum: position of the last pixel in the buffer */
 				if ((x+w)&gt;t-&gt;tw) mw=(t-&gt;tw-x);
-					else mw=w;
+				else mw=w;
 				if (mw&lt;=0)	 /*  nothing to do */
 					return(-1);
-				for (i=0;i&lt;h;i++)
-				{
+				for (i=0;i&lt;h;i++) {
 					p1=(y+i)*t-&gt;w+x;  /*  scanline start position */
 					p2=mw;			 /*  and length */
 					if (p1&gt;m)
@@ -931,8 +824,8 @@
 					if ((p1+w)&gt;m)
 						p2=m-p1;	 /*  only draw a part of the scanline */
 					memcpy(	t-&gt;buf+	4*p1,			 /*  draw at p1 position ... */
-							pixbuf+	4*i*w,			 /*  scanline number i ... */
-									4*p2);
+					        pixbuf+	4*i*w,			 /*  scanline number i ... */
+					        4*p2);
 				}
 				obj_update_tex(t,x,y,w,h,pixbuf);
 				return(0);
@@ -940,7 +833,7 @@
 				errds(HIGH,&quot;obj_load_tex()&quot;,&quot;no buffer to draw to in oid %d, texture %d&quot;,oid,tex);
 			}
 		}
-	} 
+	}
 	return(-1);
 }
 int obj_toggle_flags(struct t_process *p, int32_t oid, uint8_t type, uint32_t flags)
@@ -949,17 +842,22 @@
 	uint32_t f;
 
 	f=flags&amp;OF_MASK;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		switch (type)
-		{
-			case OF_TURN_ON:	obj-&gt;oflags|=f;		break;
-			case OF_TURN_OFF:	obj-&gt;oflags&amp;=~f;	break;
-			case OF_TURN_SWAP:	obj-&gt;oflags^=f;		break;
-			default:return(-1);
+	if (OBJ_VALID(p,oid,obj)) {
+		switch (type) {
+		case OF_TURN_ON:
+			obj-&gt;oflags|=f;
+			break;
+		case OF_TURN_OFF:
+			obj-&gt;oflags&amp;=~f;
+			break;
+		case OF_TURN_SWAP:
+			obj-&gt;oflags^=f;
+			break;
+		default:
+			return(-1);
 		}
-/* 		s3dprintf(VLOW,&quot;toggled %d-&gt;oflags=%010x with %010x [%d]&quot;,oid,obj-&gt;oflags,flags,type); */
-	} 
+		/* 		s3dprintf(VLOW,&quot;toggled %d-&gt;oflags=%010x with %010x [%d]&quot;,oid,obj-&gt;oflags,flags,type); */
+	}
 	return(0);
 }
 /*  deletes the last n vertices of the stack. if n&gt;=n_vertex, delete all vertices */
@@ -968,29 +866,22 @@
 	int32_t m;
 	struct t_vertex *p_vertex;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_del_vertex()&quot;,&quot;error: can't delete vertices in this object!&quot;);
 			return(-1);
 		}
 
 		s3dprintf(VLOW,&quot;deleting %d vertices of pid %d/ oid %d&quot;,n,p-&gt;id,oid);
 		m=obj-&gt;n_vertex;	 /*  saving the first number of vertices */
-		if (n&gt;=m) 
-		{
+		if (n&gt;=m) {
 			if (m&gt;0)
 				free(obj-&gt;p_vertex);
 			obj-&gt;n_vertex=0;
 			obj-&gt;p_vertex=NULL;
-		}
-		else if (n&gt;0)
-		{
-			if (NULL!=(p_vertex=realloc(obj-&gt;p_vertex,sizeof(struct t_vertex) * ( m - n))))
-			{
-				if (obj-&gt;dplist)
-				{
+		} else if (n&gt;0) {
+			if (NULL!=(p_vertex=realloc(obj-&gt;p_vertex,sizeof(struct t_vertex) * ( m - n)))) {
+				if (obj-&gt;dplist) {
 					s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
 					glDeleteLists(obj-&gt;dplist,1);
 					obj-&gt;dplist=0;
@@ -1000,8 +891,7 @@
 			}
 		}
 		obj_size_update(p,oid);
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -1012,36 +902,30 @@
 	int32_t m;
 	struct t_mat *p_mat;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_del_mat()&quot;,&quot;error: can't delete materials in this object!&quot;);
 			return(-1);
 		}
 
 		s3dprintf(VLOW,&quot;deleting %d materials of pid %d/ oid %d&quot;,n,p-&gt;id,oid);
 		m=obj-&gt;n_mat;	 /*  saving the first number of materials */
-		if (n&gt;=m) 
-		{
+		if (n&gt;=m) {
 			if (m&gt;0)
 				free(obj-&gt;p_mat);
 			obj-&gt;n_mat=0;
 			obj-&gt;p_mat=NULL;
-		}
-		else if (n&gt;0)
-		if (NULL!=(p_mat=realloc(obj-&gt;p_mat,sizeof(struct t_mat) * ( m - n))))
-		{
-			if (obj-&gt;dplist)
-			{
-				s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-				glDeleteLists(obj-&gt;dplist,1);
-				obj-&gt;dplist=0;
+		} else if (n&gt;0)
+			if (NULL!=(p_mat=realloc(obj-&gt;p_mat,sizeof(struct t_mat) * ( m - n)))) {
+				if (obj-&gt;dplist) {
+					s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
+					glDeleteLists(obj-&gt;dplist,1);
+					obj-&gt;dplist=0;
+				}
+				obj-&gt;p_mat=p_mat;
+				obj-&gt;n_mat-=n;
 			}
-			obj-&gt;p_mat=p_mat;
-			obj-&gt;n_mat-=n;
-		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -1051,36 +935,30 @@
 	int32_t m;
 	struct t_poly *p_poly;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_del_poly()&quot;,&quot;error: can't delete poly in this object!&quot;);
 			return(-1);
 		}
 
 		s3dprintf(VLOW,&quot;deleting %d polys of pid %d/ oid %d&quot;,n,p-&gt;id,oid);
 		m=obj-&gt;n_poly;	 /*  saving the first number of poly  */
-		if (n&gt;=m) 
-		{
+		if (n&gt;=m) {
 			if (m&gt;0)
 				free(obj-&gt;p_poly);
 			obj-&gt;n_poly=0;
 			obj-&gt;p_poly=NULL;
-		}
-		else if (n&gt;0)
-		if (NULL!=(p_poly=realloc(obj-&gt;p_poly,sizeof(struct t_poly) * ( m - n))))
-		{
-			if (obj-&gt;dplist)
-			{
-				s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-				glDeleteLists(obj-&gt;dplist,1);
-				obj-&gt;dplist=0;
+		} else if (n&gt;0)
+			if (NULL!=(p_poly=realloc(obj-&gt;p_poly,sizeof(struct t_poly) * ( m - n)))) {
+				if (obj-&gt;dplist) {
+					s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
+					glDeleteLists(obj-&gt;dplist,1);
+					obj-&gt;dplist=0;
+				}
+				obj-&gt;p_poly=p_poly;
+				obj-&gt;n_poly-=n;
 			}
-			obj-&gt;p_poly=p_poly;
-			obj-&gt;n_poly-=n;
-		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -1090,36 +968,30 @@
 	int32_t m;
 	struct t_line *p_line;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_del_line()&quot;,&quot;error: can't delete line in this object!&quot;);
 			return(-1);
 		}
 
 		s3dprintf(VLOW,&quot;deleting %d lines of pid %d/ oid %d&quot;,n,p-&gt;id,oid);
 		m=obj-&gt;n_line;	 /*  saving the first number of line  */
-		if (n&gt;=m) 
-		{
+		if (n&gt;=m) {
 			if (m&gt;0)
 				free(obj-&gt;p_line);
 			obj-&gt;n_line=0;
 			obj-&gt;p_line=NULL;
-		}
-		else if (n&gt;0)
-		if (NULL!=(p_line=realloc(obj-&gt;p_line,sizeof(struct t_line) * ( m - n))))
-		{
-			if (obj-&gt;dplist)
-			{
-				s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-				glDeleteLists(obj-&gt;dplist,1);
-				obj-&gt;dplist=0;
+		} else if (n&gt;0)
+			if (NULL!=(p_line=realloc(obj-&gt;p_line,sizeof(struct t_line) * ( m - n)))) {
+				if (obj-&gt;dplist) {
+					s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
+					glDeleteLists(obj-&gt;dplist,1);
+					obj-&gt;dplist=0;
+				}
+				obj-&gt;p_line=p_line;
+				obj-&gt;n_line-=n;
 			}
-			obj-&gt;p_line=p_line;
-			obj-&gt;n_line-=n;
-		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -1131,24 +1003,19 @@
 	struct t_tex *p_tex;
 	struct t_obj *obj;
 	GLuint t;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj-&gt;oflags&amp;OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj-&gt;oflags&amp;OF_NODATA) {
 			errds(MED,&quot;obj_del_tex()&quot;,&quot;error: can't delete textures in this object!&quot;);
 			return(-1);
 		}
 
 		s3dprintf(VLOW,&quot;deleting %d textures of pid %d/ oid %d&quot;,n,p-&gt;id,oid);
 		m=obj-&gt;n_tex;	 /*  saving the first number of textures  */
-		if (n&gt;=m) 
-		{
-			for (i=0;i&lt;m;i++)
-			{
+		if (n&gt;=m) {
+			for (i=0;i&lt;m;i++) {
 				if ((obj-&gt;p_tex[i].buf)!=NULL)
 					free(obj-&gt;p_tex[i].buf);
-				if (obj-&gt;p_tex[i].gl_texnum)
-				{
+				if (obj-&gt;p_tex[i].gl_texnum) {
 					t=obj-&gt;p_tex[i].gl_texnum;
 					glDeleteTextures(1,&amp;t);
 				}
@@ -1157,32 +1024,27 @@
 				free(obj-&gt;p_tex);
 			obj-&gt;n_tex=0;
 			obj-&gt;p_tex=NULL;
-		} else if (n&gt;0)
-		{
-			for (i=(m-n);i&lt;m;i++)
-			{
+		} else if (n&gt;0) {
+			for (i=(m-n);i&lt;m;i++) {
 				if (obj-&gt;p_tex[i].buf!=NULL)
 					free(obj-&gt;p_tex[i].buf);
-				if (obj-&gt;p_tex[i].gl_texnum)
-				{
+				if (obj-&gt;p_tex[i].gl_texnum) {
 					t=obj-&gt;p_tex[i].gl_texnum;
 					glDeleteTextures(1,&amp;t);
 				}
 
 			}
-			if (NULL!=(p_tex=realloc(obj-&gt;p_tex,sizeof(struct t_tex) * ( m - n))))
-			{
-				if (obj-&gt;dplist)
-				{
+			if (NULL!=(p_tex=realloc(obj-&gt;p_tex,sizeof(struct t_tex) * ( m - n)))) {
+				if (obj-&gt;dplist) {
 					s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-						glDeleteLists(obj-&gt;dplist,1);
+					glDeleteLists(obj-&gt;dplist,1);
 					obj-&gt;dplist=0;
 				}
 				obj-&gt;p_tex=p_tex;
 				obj-&gt;n_tex=n;
 			}
 		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -1193,26 +1055,23 @@
 	struct t_obj *obj;
 	struct t_process *mcp_p=get_proc_by_pid(MCP);
 	float v[3];
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if (isnan(transv[0])||isinf(transv[0])) return(-1);
 		if (isnan(transv[1])||isinf(transv[1])) return(-1);
 		if (isnan(transv[2])||isinf(transv[2])) return(-1);
-		if ((p-&gt;id!=MCP) &amp;&amp; (obj-&gt;oflags&amp;OF_SYSTEM))
-		{
-			if (focus_oid==p-&gt;mcp_oid)
-			{
+		if ((p-&gt;id!=MCP) &amp;&amp; (obj-&gt;oflags&amp;OF_SYSTEM)) {
+			if (focus_oid==p-&gt;mcp_oid) {
 				v[0]=transv[0];
 				v[1]=transv[1];
 				v[2]=transv[2];
 				mySetMatrix(mcp_p-&gt;object[p-&gt;mcp_oid]-&gt;m);
 				myTransform3f(v);
-/*				mySetMatrix(mcp_p-&gt;object[oid]-&gt;m);
-				myInvert();
-				myTransform3f(v);
-				s3dprintf(LOW,&quot;%3.3f %3.3f %3.3f&quot;,v[0],v[1],v[2]);*/
+				/*				mySetMatrix(mcp_p-&gt;object[oid]-&gt;m);
+								myInvert();
+								myTransform3f(v);
+								s3dprintf(LOW,&quot;%3.3f %3.3f %3.3f&quot;,v[0],v[1],v[2]);*/
 				obj_translate(mcp_p,oid,v);
-			} 
+			}
 		} else {
 			obj-&gt;translate.x=*transv;
 			obj-&gt;translate.y=*(transv+1);
@@ -1230,15 +1089,12 @@
 	struct t_process *mcp_p=get_proc_by_pid(MCP);
 	float v[3];
 	float f;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if (isnan(rotv[0])||isinf(rotv[0])) return(-1);
 		if (isnan(rotv[1])||isinf(rotv[1])) return(-1);
 		if (isnan(rotv[2])||isinf(rotv[2])) return(-1);
-		if ((p-&gt;id!=MCP) &amp;&amp; (obj-&gt;oflags&amp;OF_SYSTEM))
-		{
-			if (focus_oid==p-&gt;mcp_oid)
-			{
+		if ((p-&gt;id!=MCP) &amp;&amp; (obj-&gt;oflags&amp;OF_SYSTEM)) {
+			if (focus_oid==p-&gt;mcp_oid) {
 				v[0]=obj-&gt;rotate.x + (rotv[0] - obj-&gt;rotate.x);
 				v[1]=obj-&gt;rotate.y + (rotv[1] - obj-&gt;rotate.y);
 				v[2]=obj-&gt;rotate.z + (rotv[2] - obj-&gt;rotate.z);
@@ -1267,19 +1123,17 @@
 int obj_scale(struct t_process *p, int32_t oid, float scav)
 {
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if ((p-&gt;id==MCP) || (!(obj-&gt;oflags&amp;OF_SYSTEM)))
-		if (!isinf(scav) &amp;&amp; !isnan(scav) &amp;&amp; !((scav&lt;1.0e-10) &amp;&amp; (scav&gt;-1.0e-10))) /* ignore very low values */
-		{
-			s3dprintf(VLOW,&quot;[scale|pid %d] obj %d to %f&quot;,p-&gt;id,oid,scav);
-			obj-&gt;scale=scav;
-	/*		obj-&gt;scale.x=*scav;
-			obj-&gt;scale.y=*(scav+1);
-			obj-&gt;scale.z=*(scav+2);*/
-			obj_size_update(p,oid);
-			obj_pos_update(p,oid,oid);
-		}
+			if (!isinf(scav) &amp;&amp; !isnan(scav) &amp;&amp; !((scav&lt;1.0e-10) &amp;&amp; (scav&gt;-1.0e-10))) { /* ignore very low values */
+				s3dprintf(VLOW,&quot;[scale|pid %d] obj %d to %f&quot;,p-&gt;id,oid,scav);
+				obj-&gt;scale=scav;
+				/*		obj-&gt;scale.x=*scav;
+						obj-&gt;scale.y=*(scav+1);
+						obj-&gt;scale.z=*(scav+2);*/
+				obj_size_update(p,oid);
+				obj_pos_update(p,oid,oid);
+			}
 	}
 	return(0);
 }
@@ -1287,25 +1141,23 @@
 void into_position(struct t_process *p, struct t_obj *obj, int depth)
 {
 	struct t_obj *on;
-	if ((obj-&gt;oflags&amp;OF_LINK) &amp;&amp; (depth&lt;p-&gt;n_obj))
-	{
+	if ((obj-&gt;oflags&amp;OF_LINK) &amp;&amp; (depth&lt;p-&gt;n_obj)) {
 		/* TODO: only MultMatrix if m_uptodate ?! */
-		if (OBJ_VALID(p,obj-&gt;linkid,on))
-		{
+		if (OBJ_VALID(p,obj-&gt;linkid,on)) {
 			into_position(p,on,depth+1);
 		} else {
 			obj-&gt;oflags&amp;=~OF_LINK;
 			s3dprintf(LOW,&quot;link object is broken, removing link&quot;);
 		}
 	}
-	 /* if (depth&gt;=MAXLOOP) */
+	/* if (depth&gt;=MAXLOOP) */
 	if (depth&gt;=p-&gt;n_obj)
 		s3dprintf(MED,&quot;too much looping ...&quot;);
 	glTranslatef(obj-&gt;translate.x,obj-&gt;translate.y,obj-&gt;translate.z);
 	glRotatef(obj-&gt;rotate.y,0.0,1.0,0.0);
 	glRotatef(obj-&gt;rotate.x,1.0,0.0,0.0);
 	glRotatef(obj-&gt;rotate.z,0.0,0.0,1.0);
-/*	glScalef(obj-&gt;scale.x,obj-&gt;scale.y,obj-&gt;scale.z);*/
+	/*	glScalef(obj-&gt;scale.x,obj-&gt;scale.y,obj-&gt;scale.z);*/
 	glScalef(obj-&gt;scale,obj-&gt;scale,obj-&gt;scale);
 }
 
@@ -1317,42 +1169,34 @@
 	int vn,is_clnsrc;
 	int32_t i;
 	if (p-&gt;id==MCP) return; /*  mcp does not need that. */
-	if (OBJ_VALID(p,oid,o))
-	{
-		if (o-&gt;oflags&amp;OF_SYSTEM)
-		{
+	if (OBJ_VALID(p,oid,o)) {
+		if (o-&gt;oflags&amp;OF_SYSTEM) {
 			o-&gt;r=o-&gt;or=0; /* we don't care about system objects */
-			return; 
+			return;
 		}
 		vp=o-&gt;p_vertex;
 		vn=o-&gt;n_vertex;
-		if (o-&gt;oflags&amp;OF_CLONE)
-		{  
+		if (o-&gt;oflags&amp;OF_CLONE) {
 			o2=p-&gt;object[o-&gt;n_vertex];	 /*  get the target into o2*/
 			o-&gt;r= o2-&gt;r * (o-&gt;scale/o2-&gt;scale);
 			obj_check_biggest_object(p,oid);
 			return;
 		} else {
-/* 			printf(MED,&quot;looking through vertices...&quot;); */
-			for (i=0;i&lt;vn;i++)
-			{
+			/* 			printf(MED,&quot;looking through vertices...&quot;); */
+			for (i=0;i&lt;vn;i++) {
 				a=&amp;(vp[i]);
 				r=o-&gt;scale * sqrt(
-						(a-&gt;x  * a-&gt;x ) + 
-						(a-&gt;y  * a-&gt;y ) +
-						(a-&gt;z  * a-&gt;z ));
+				          (a-&gt;x  * a-&gt;x ) +
+				          (a-&gt;y  * a-&gt;y ) +
+				          (a-&gt;z  * a-&gt;z ));
 				if (r &gt; o-&gt;r) o-&gt;r=r;
 			}
 			obj_check_biggest_object(p,oid);
-			if (p-&gt;object[oid]-&gt;oflags&amp;OF_CLONE_SRC)
-			{
+			if (p-&gt;object[oid]-&gt;oflags&amp;OF_CLONE_SRC) {
 				is_clnsrc=0;
-				for (i=0;i&lt;p-&gt;n_obj;i++)
-				{
-					if (p-&gt;object[i]!=NULL)
-					{
-						if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex== oid))
-						{ /* if it's pointing to our object ... */
+				for (i=0;i&lt;p-&gt;n_obj;i++) {
+					if (p-&gt;object[i]!=NULL) {
+						if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex== oid)) { /* if it's pointing to our object ... */
 							is_clnsrc=1;
 							p-&gt;object[i]-&gt;r=o-&gt;r*(p-&gt;object[i]-&gt;r/o-&gt;scale); /* give it the new radius too! */
 							obj_check_biggest_object(p,i);
@@ -1380,53 +1224,46 @@
 	if (o-&gt;oflags&amp;OF_SYSTEM)
 		return; /* we don't care, system objects don't count. */
 	r=o-&gt;r+o-&gt;or;
-	if (r&gt;mcp_o-&gt;r)
-	{	 /*  this is now the biggest object. */
+	if (r&gt;mcp_o-&gt;r) {	 /*  this is now the biggest object. */
 		mcp_o-&gt;r=r;
 		p-&gt;biggest_obj=oid;
-/*		s3dprintf(MED,&quot;there is a new biggest object in [%d:\&quot;\&quot;]&quot;,p-&gt;id,p-&gt;name);*/
+		/*		s3dprintf(MED,&quot;there is a new biggest object in [%d:\&quot;\&quot;]&quot;,p-&gt;id,p-&gt;name);*/
 		mcp_rep_object(p-&gt;mcp_oid);	  /*  and tell the mcp */
 	} else {
-		if (p-&gt;biggest_obj==oid)
-		{  /*  oid might now lose the status of the &quot;biggest object&quot;. let's check: */
+		if (p-&gt;biggest_obj==oid) { /*  oid might now lose the status of the &quot;biggest object&quot;. let's check: */
 			found=0;
 			for (i=0;i&lt;p-&gt;n_obj;i++)
-				if (p-&gt;object[i]!=NULL)
-				{
-					if ((r2=p-&gt;object[i]-&gt;r+p-&gt;object[i]-&gt;or)&gt;r)
-					{  /*  this object is bigger than the old biggest one. */
-						if (!(p-&gt;object[i]-&gt;oflags&amp;OF_SYSTEM))
-						{
+				if (p-&gt;object[i]!=NULL) {
+					if ((r2=p-&gt;object[i]-&gt;r+p-&gt;object[i]-&gt;or)&gt;r) { /*  this object is bigger than the old biggest one. */
+						if (!(p-&gt;object[i]-&gt;oflags&amp;OF_SYSTEM)) {
 							p-&gt;biggest_obj=oid;
 							r=r2;
 							found=1;
 						}
 					}
 				}
-			if (found)
-			{
+			if (found) {
 				s3dprintf(VLOW,&quot;there is a new biggest object in [%d:\&quot;\&quot;]&quot;,p-&gt;id,p-&gt;name);
 				mcp_o-&gt;r=r;  /*  save the new size */
 				mcp_rep_object(p-&gt;mcp_oid);	  /*  and tell the mcp */
 			}
 		}   /*  if it wasn't the biggest object, no one cares if it's smaller than process */
-			 /*  radius */
+		/*  radius */
 	}
 }
 /* calculates and saves the transformation matrix, if needed */
 void obj_recalc_tmat(struct t_process *p, int32_t oid)
 {
 	GLint matrixmode;
-	if (!p-&gt;object[oid]-&gt;m_uptodate)
-	{
+	if (!p-&gt;object[oid]-&gt;m_uptodate) {
 		glGetIntegerv(GL_MATRIX_MODE,&amp;matrixmode); 		 /*  save matrixmode */
 		glMatrixMode(GL_MODELVIEW); 					 /*  go into modelview */
 		glPushMatrix();
 		glLoadIdentity();
-		into_position(p,p-&gt;object[oid],0);	
+		into_position(p,p-&gt;object[oid],0);
 		glGetFloatv( GL_MODELVIEW_MATRIX, p-&gt;object[oid]-&gt;m );
 		glPopMatrix();
-		glMatrixMode(matrixmode);	
+		glMatrixMode(matrixmode);
 		p-&gt;object[oid]-&gt;m_uptodate=1;
 	}
 }
@@ -1441,8 +1278,7 @@
 	sa=ss=1.0F;
 	/* find the angel of the sys object */
 	o=mcp_p-&gt;object[oid];
-	while (o!=NULL)
-	{
+	while (o!=NULL) {
 		fs.x+=o-&gt;rotate.x;
 		fs.y+=o-&gt;rotate.y;
 		fs.z+=o-&gt;rotate.z;
@@ -1457,8 +1293,7 @@
 	myTransform3f(v);
 
 	o=mcp_p-&gt;object[p-&gt;mcp_oid];
-	while (o!=NULL)
-	{
+	while (o!=NULL) {
 		fa.x+=o-&gt;rotate.x;
 		fa.y+=o-&gt;rotate.y;
 		fa.z+=o-&gt;rotate.z;
@@ -1482,7 +1317,7 @@
 
 	p-&gt;object[oid]-&gt;scale=ss/sa;
 
-/*	obj_debug(p,oid);*/
+	/*	obj_debug(p,oid);*/
 	obj_pos_update(p,oid,oid); /* now also update the matrix and the objects linking to our sys-object ... */
 }
 /*  recalculate the position of an object. this assumes that oid is valid. */
@@ -1495,24 +1330,20 @@
 	s3dprintf(VLOW,&quot;[obj_pos_upd|pid %d] %d&quot;,p-&gt;id, oid,first_oid);
 	o-&gt;m_uptodate=0;
 	obj_recalc_tmat(p,oid);
-	if (p-&gt;id!=MCP) 
-	{/*  mcp does not need that. */
-		 /*  save the matrixmode to reset it later on */
+	if (p-&gt;id!=MCP) {/*  mcp does not need that. */
+		/*  save the matrixmode to reset it later on */
 		v[0]=v[1]=v[2]=0.0F;
 		mySetMatrix(o-&gt;m);
 		myTransform3f(v);
-			 /*  and get it's destination point. phew */
+		/*  and get it's destination point. phew */
 		o-&gt;or=sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
-	} else 
+	} else
 		if (o-&gt;oflags&amp;OF_SYSTEM) /* TODO: what will we do if $sys_object is linked to another? */
 		{ /* a system object changed position? let's update the focus'ed sys-objects */
 			if (OBJ_VALID(p,focus_oid,ao))
-				if (NULL!=(ap=get_proc_by_pid(ao-&gt;n_mat)))
-				{
-					if (OF_POINTER==(o-&gt;oflags&amp;0xF0000000))
-					{ /* we dont have to do that much in this case ... */
-						if (OBJ_VALID(ap,get_pointer(ap),ao)) /* we can redefine ao here -&gt; ao = focused app's pointer*/
-						{
+				if (NULL!=(ap=get_proc_by_pid(ao-&gt;n_mat))) {
+					if (OF_POINTER==(o-&gt;oflags&amp;0xF0000000)) { /* we dont have to do that much in this case ... */
+						if (OBJ_VALID(ap,get_pointer(ap),ao)) { /* we can redefine ao here -&gt; ao = focused app's pointer*/
 							ao-&gt;rotate.x=o-&gt;rotate.x;
 							ao-&gt;rotate.y=o-&gt;rotate.y;
 							ao-&gt;rotate.z=o-&gt;rotate.z;
@@ -1522,27 +1353,26 @@
 							obj_pos_update(ap,get_pointer(ap),get_pointer(ap));
 						}
 					} else {
-						obj_sys_update(ap,oid);	
+						obj_sys_update(ap,oid);
 					}
 				}
-			switch (o-&gt;oflags&amp;0xF0000000)
-			{
-				case OF_CAM:
-					event_cam_changed();
-					break;
-				case OF_POINTER:
-					event_ptr_changed();
-					break;
-				default:
-					s3dprintf(LOW,&quot;[obj_pos_upd|pid %d] %d unknown system event&quot;,p-&gt;id,oid);
-					
+			switch (o-&gt;oflags&amp;0xF0000000) {
+			case OF_CAM:
+				event_cam_changed();
+				break;
+			case OF_POINTER:
+				event_ptr_changed();
+				break;
+			default:
+				s3dprintf(LOW,&quot;[obj_pos_upd|pid %d] %d unknown system event&quot;,p-&gt;id,oid);
+
 			}
 
 		}
 	/* if it's the root (oid==first_oid), only go down */
-	
+
 	if (o-&gt;lsub!=-1)						obj_pos_update(p,o-&gt;lsub,first_oid);
-	if ((o-&gt;lnext!=-1) &amp;&amp; (oid!=first_oid))	obj_pos_update(p,o-&gt;lnext,first_oid); 
+	if ((o-&gt;lnext!=-1) &amp;&amp; (oid!=first_oid))	obj_pos_update(p,o-&gt;lnext,first_oid);
 	if (p-&gt;id!=MCP)
 		obj_check_biggest_object(p,oid);
 }
@@ -1552,20 +1382,18 @@
 	struct t_vertex a,b,n;
 	struct t_vertex *v[3];
 	int32_t vp,i;
-	
+
 	float len;
-	for (i=0;i&lt;3;i++)  /*  set and check */
-	{
+	for (i=0;i&lt;3;i++) { /*  set and check */
 		vp= obj-&gt;p_poly[pn].v[i];  /*  ... get the vertices ... */
 		if ( vp &lt; obj-&gt;n_vertex)
 			v[i]=&amp;(obj-&gt;p_vertex[vp]);
 		else return(-1);
 	}
-	 /*  check for already set normal */
+	/*  check for already set normal */
 	if ((obj-&gt;p_poly[pn].n[0].x*obj-&gt;p_poly[pn].n[0].x+
-		 obj-&gt;p_poly[pn].n[0].y*obj-&gt;p_poly[pn].n[0].y+
-		 obj-&gt;p_poly[pn].n[0].z*obj-&gt;p_poly[pn].n[0].z)==0)  
-	{/*  normal already defined? */
+	                obj-&gt;p_poly[pn].n[0].y*obj-&gt;p_poly[pn].n[0].y+
+	                obj-&gt;p_poly[pn].n[0].z*obj-&gt;p_poly[pn].n[0].z)==0) {/*  normal already defined? */
 		a.x=v[1]-&gt;x-v[0]-&gt;x;
 		a.y=v[1]-&gt;y-v[0]-&gt;y;
 		a.z=v[1]-&gt;z-v[0]-&gt;z;
@@ -1577,15 +1405,13 @@
 		n.z=a.x*b.y - a.y*b.x;
 
 		len=sqrt(n.x*n.x+n.y*n.y+n.z*n.z);
-		if (len==0.0F)
-		{
-		 /* 		errds(VLOW,&quot;bad polygon (can't normalize ...)&quot;); */
+		if (len==0.0F) {
+			/* 		errds(VLOW,&quot;bad polygon (can't normalize ...)&quot;); */
 		} else {
 			n.x=n.x/len;
 			n.y=n.y/len;
 			n.z=n.z/len;
-			for (i=0;i&lt;3;i++) 
-			{
+			for (i=0;i&lt;3;i++) {
 				obj-&gt;p_poly[pn].n[i].x=n.x;
 				obj-&gt;p_poly[pn].n[i].y=n.y;
 				obj-&gt;p_poly[pn].n[i].z=n.z;
@@ -1600,19 +1426,16 @@
 {
 	struct t_vertex *v[2];
 	int i,vp;
-	for (i=0;i&lt;2;i++)  /*  set and check */
-	{
+	for (i=0;i&lt;2;i++) { /*  set and check */
 		vp= obj-&gt;p_line[pn].v[i];  /*  ... get the vertices ... */
 		if (vp &lt; (int)obj-&gt;n_vertex)
 			v[i]=&amp;(obj-&gt;p_vertex[vp]);
 		else return(-1);
 	}
 	if ((obj-&gt;p_line[pn].n[0].x*obj-&gt;p_line[pn].n[0].x+
-		 obj-&gt;p_line[pn].n[0].y*obj-&gt;p_line[pn].n[0].y+
-		 obj-&gt;p_line[pn].n[0].z*obj-&gt;p_line[pn].n[0].z)==0)  
-	{ /* guess we have nothing set yet, so set something */
-		for (i=0;i&lt;2;i++)
-		{
+	                obj-&gt;p_line[pn].n[0].y*obj-&gt;p_line[pn].n[0].y+
+	                obj-&gt;p_line[pn].n[0].z*obj-&gt;p_line[pn].n[0].z)==0) { /* guess we have nothing set yet, so set something */
+		for (i=0;i&lt;2;i++) {
 			obj-&gt;p_line[pn].n[0].x=0;
 			obj-&gt;p_line[pn].n[0].y=0;
 			obj-&gt;p_line[pn].n[0].z=1;
@@ -1623,17 +1446,14 @@
 }
 
 /* activate/bind texture for object */
-static struct t_tex *get_texture(struct t_obj *obj,struct t_mat *m)
-{
+static struct t_tex *get_texture(struct t_obj *obj,struct t_mat *m) {
 	GLuint t;
 	struct t_tex *tex=NULL;
 	GLfloat matgl[4];
-/* 	int i,j; */
-	if (m-&gt;tex &lt; obj-&gt;n_tex)
-	{
+	/* 	int i,j; */
+	if (m-&gt;tex &lt; obj-&gt;n_tex) {
 		tex=&amp;obj-&gt;p_tex[m-&gt;tex];
-		if (tex-&gt;buf!=NULL)
-		{  /*  texture seems to be okay, select it. */
+		if (tex-&gt;buf!=NULL) { /*  texture seems to be okay, select it. */
 			matgl[0]=0.5f;
 			matgl[1]=0.5f;
 			matgl[2]=0.5f;
@@ -1641,37 +1461,35 @@
 			glMaterialfv(GL_FRONT,GL_AMBIENT,matgl);
 			glMaterialfv(GL_FRONT,GL_DIFFUSE,matgl);
 			glMaterialfv(GL_FRONT,GL_SPECULAR,matgl);
-			if (tex-&gt;gl_texnum!=-1)
-			{
+			if (tex-&gt;gl_texnum!=-1) {
 				glBindTexture( GL_TEXTURE_2D,tex-&gt;gl_texnum);
 			} else {
 				glGenTextures(1,&amp;t);
 				glBindTexture( GL_TEXTURE_2D, t);
 				tex-&gt;gl_texnum=t;
 				s3dprintf(HIGH,&quot;generated texture %d [%dx%d, in memory %dx%d]&quot;,t,tex-&gt;tw,tex-&gt;th,tex-&gt;w,tex-&gt;h);
-/*				for (j=0;j&lt;tex-&gt;th;j++)
-				for (i=0;i&lt;tex-&gt;tw;i++)
-				{
-					s3dprintf(MED,&quot;pixel[%d,%d], %d %d %d %d&quot;,i,j,
-									tex-&gt;buf[(j*tex-&gt;w+i)*4+0],
-									tex-&gt;buf[(j*tex-&gt;w+i)*4+1],
-									tex-&gt;buf[(j*tex-&gt;w+i)*4+2],
-									tex-&gt;buf[(j*tex-&gt;w+i)*4+3]);
-				}*/
-				glTexImage2D(	GL_TEXTURE_2D,0, GL_RGBA,	
-								tex-&gt;w,tex-&gt;h,0,  /*  no border. */
-								GL_RGBA,GL_UNSIGNED_BYTE,tex-&gt;buf);
-								 /*  texture has to be generated yet ... */
-			   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-			   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-			   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, 
-			                   GL_NEAREST);
-			   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, 
-			                   GL_NEAREST);
-			   
-				}
-		}
-		else {  /* . can't use a texture  */
+				/*				for (j=0;j&lt;tex-&gt;th;j++)
+								for (i=0;i&lt;tex-&gt;tw;i++)
+								{
+									s3dprintf(MED,&quot;pixel[%d,%d], %d %d %d %d&quot;,i,j,
+													tex-&gt;buf[(j*tex-&gt;w+i)*4+0],
+													tex-&gt;buf[(j*tex-&gt;w+i)*4+1],
+													tex-&gt;buf[(j*tex-&gt;w+i)*4+2],
+													tex-&gt;buf[(j*tex-&gt;w+i)*4+3]);
+								}*/
+				glTexImage2D(	GL_TEXTURE_2D,0, GL_RGBA,
+				              tex-&gt;w,tex-&gt;h,0,  /*  no border. */
+				              GL_RGBA,GL_UNSIGNED_BYTE,tex-&gt;buf);
+				/*  texture has to be generated yet ... */
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
+				                GL_NEAREST);
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
+				                GL_NEAREST);
+
+			}
+		} else { /* . can't use a texture  */
 			tex=NULL;
 		}
 	}
@@ -1683,7 +1501,7 @@
 	int32_t pn;
 	int32_t mat,omat=-1;
 	int32_t v;
-/* 	int link_obj; */
+	/* 	int link_obj; */
 	struct t_vertex *on;
 	struct t_obj *obj;
 	struct t_mat *m;
@@ -1694,86 +1512,83 @@
 	obj=p-&gt;object[oid];
 	glPushMatrix();
 	glMultMatrixf(obj-&gt;m);
-/*	into_position(p,obj,0);*/
+	/*	into_position(p,obj,0);*/
 	if (obj-&gt;oflags&amp;OF_SYSTEM)		return(-1); 					/* can't render system objects */
 	if (obj-&gt;oflags&amp;OF_CLONE)		obj=p-&gt;object[obj-&gt;n_vertex]; 	/* it's a clone - draw the clone! */
 	if (!obj-&gt;dplist) {
 		obj-&gt;dplist=glGenLists(1);
 		if (obj-&gt;dplist)	glNewList(obj-&gt;dplist,GL_COMPILE); /* only compile and calling later should save time. maybe. */
-		 else 				s3dprintf(LOW,&quot;couldn't get a new list :/&quot;);
+		else 				s3dprintf(LOW,&quot;couldn't get a new list :/&quot;);
 		omat=-1;
-		for (pn=0; pn&lt;obj-&gt;n_poly; pn++)  /*  cycle throu our polygons ... */
-		{
-			if (calc_normal(obj,pn))
-			{
+		for (pn=0; pn&lt;obj-&gt;n_poly; pn++) { /*  cycle throu our polygons ... */
+			if (calc_normal(obj,pn)) {
 				s3dprintf(HIGH,&quot;something is wrong with polygon %d!&quot;,pn);
-				if (obj-&gt;dplist) glEndList();	glPopMatrix(); /* clean up GL-stuff */
+				if (obj-&gt;dplist) glEndList();
+				glPopMatrix(); /* clean up GL-stuff */
 				return(-1);
 			}
-	 /* 		glNormal3f(-n.x,-n.y,-n.z); */
+			/* 		glNormal3f(-n.x,-n.y,-n.z); */
 			mat= obj-&gt;p_poly[pn].mat;
 			if (mat!=omat) {
 				tex=NULL;
 				if (mat&lt; obj-&gt;n_mat) {
 					m=&amp;obj-&gt;p_mat[mat];
 					if (m-&gt;tex!=-1)		tex=get_texture(obj,m);
-					if (tex==NULL)		/* still NULL? then it couldn't get the texture. */
-					{
-/*						s3dprintf(VLOW,&quot;no texture, using standard material...&quot;);*/
+					if (tex==NULL) {	/* still NULL? then it couldn't get the texture. */
+						/*						s3dprintf(VLOW,&quot;no texture, using standard material...&quot;);*/
 						glBindTexture( GL_TEXTURE_2D,0);
-						matgl[0]=m-&gt;amb_r/2;		
-						matgl[1]=m-&gt;amb_g/2;		
+						matgl[0]=m-&gt;amb_r/2;
+						matgl[1]=m-&gt;amb_g/2;
 						matgl[2]=m-&gt;amb_b/2;
 						matgl[3]=m-&gt;amb_a;
-		 /* 				glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
+						/* 				glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
 						glMaterialfv(GL_FRONT,GL_AMBIENT,matgl);
 						matgl[0]=m-&gt;diff_r/2;
 						matgl[1]=m-&gt;diff_g/2;
 						matgl[2]=m-&gt;diff_b/2;
 						matgl[3]=m-&gt;diff_a;
-		 /* 				glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
+						/* 				glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
 						glMaterialfv(GL_FRONT,GL_DIFFUSE,matgl);
 						matgl[0]=m-&gt;spec_r/2;
 						matgl[1]=m-&gt;spec_g/2;
 						matgl[2]=m-&gt;spec_b/2;
 						matgl[3]=m-&gt;spec_a;
-		 /* 				glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
+						/* 				glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
 						glMaterialfv(GL_FRONT,GL_SPECULAR,matgl);
 					}
 				} else {
 					s3dprintf(MED,&quot;something is wrong with polygon %d! material: [%d,%d]&quot;,pn, mat,obj-&gt;n_mat);
-					if (obj-&gt;dplist) glEndList();	glEnd();	glPopMatrix();
+					if (obj-&gt;dplist) glEndList();
+					glEnd();
+					glPopMatrix();
 					return(-1);
 				}
 			}
 			omat=mat;		 /*  saving old material */
 			glBegin(GL_TRIANGLES);
-			for (i=0; i&lt;3; i++)
-				{
-					on=&amp;(obj-&gt;p_poly[pn].n[i]);
-					glNormal3f(-on-&gt;x,-on-&gt;y,-on-&gt;z);
-					if (tex!=NULL)
-					{
-/*						s3dprintf(MED,&quot;using texture coordinate (%f,%f) for polygon %d point %d&quot;,
-										obj-&gt;p_poly[pn].tc[i].x *tex-&gt;xs,
-										obj-&gt;p_poly[pn].tc[i].y *tex-&gt;ys,
-										pn,i);*/
+			for (i=0; i&lt;3; i++) {
+				on=&amp;(obj-&gt;p_poly[pn].n[i]);
+				glNormal3f(-on-&gt;x,-on-&gt;y,-on-&gt;z);
+				if (tex!=NULL) {
+					/*						s3dprintf(MED,&quot;using texture coordinate (%f,%f) for polygon %d point %d&quot;,
+															obj-&gt;p_poly[pn].tc[i].x *tex-&gt;xs,
+															obj-&gt;p_poly[pn].tc[i].y *tex-&gt;ys,
+															pn,i);*/
 
-						glTexCoord2f(	obj-&gt;p_poly[pn].tc[i].x *tex-&gt;xs,
-										(obj-&gt;p_poly[pn].tc[i].y *tex-&gt;ys));
-					}
-					v= obj-&gt;p_poly[pn].v[i];  /*  ... get the vertices ... */
-					glVertex3f(obj-&gt;p_vertex[v].x, obj-&gt;p_vertex[v].y, obj-&gt;p_vertex[v].z);  /*  ...and draw them */
+					glTexCoord2f(	obj-&gt;p_poly[pn].tc[i].x *tex-&gt;xs,
+					              (obj-&gt;p_poly[pn].tc[i].y *tex-&gt;ys));
 				}
+				v= obj-&gt;p_poly[pn].v[i];  /*  ... get the vertices ... */
+				glVertex3f(obj-&gt;p_vertex[v].x, obj-&gt;p_vertex[v].y, obj-&gt;p_vertex[v].z);  /*  ...and draw them */
+			}
 			glEnd();
 		}
 		if (tex!=NULL)			glBindTexture( GL_TEXTURE_2D, 0);  /*  switch back to standard texture */
-		for (pn=0;pn&lt;obj-&gt;n_line; pn++)
-		{
-			if (check_line_normal(obj,pn))
-			{
+		for (pn=0;pn&lt;obj-&gt;n_line; pn++) {
+			if (check_line_normal(obj,pn)) {
 				s3dprintf(HIGH,&quot;something is wrong with line %d!&quot;,pn);
-				if (obj-&gt;dplist) glEndList();	glPopMatrix(); /* clean up GL-stuff */
+				if (obj-&gt;dplist) glEndList();
+				glPopMatrix(); /* clean up GL-stuff */
 				return(-1);
 			}
 
@@ -1784,23 +1599,23 @@
 					m=&amp;obj-&gt;p_mat[mat];
 					/* dont need to care about textures ...  it's rather impossible
 					 * to get some textures on a line. at least it would look ugly ;)*/
-					matgl[0]=m-&gt;amb_r/2;		
-					matgl[1]=m-&gt;amb_g/2;		
+					matgl[0]=m-&gt;amb_r/2;
+					matgl[1]=m-&gt;amb_g/2;
 					matgl[2]=m-&gt;amb_b/2;
 					matgl[3]=m-&gt;amb_a;
-		 /* 			glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
+					/* 			glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
 					glMaterialfv(GL_FRONT,GL_AMBIENT,matgl);
 					matgl[0]=m-&gt;diff_r/2;
 					matgl[1]=m-&gt;diff_g/2;
 					matgl[2]=m-&gt;diff_b/2;
 					matgl[3]=m-&gt;diff_a;
-		 /* 			glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
+					/* 			glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
 					glMaterialfv(GL_FRONT,GL_DIFFUSE,matgl);
 					matgl[0]=m-&gt;spec_r/2;
 					matgl[1]=m-&gt;spec_g/2;
 					matgl[2]=m-&gt;spec_b/2;
 					matgl[3]=m-&gt;spec_a;
-		 /* 			glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
+					/* 			glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
 					glMaterialfv(GL_FRONT,GL_SPECULAR,matgl);
 				} else {
 					s3dprintf(MED,&quot;something is wrong with line %d! material: [%d,%d]&quot;,pn, mat,obj-&gt;n_mat);
@@ -1812,14 +1627,13 @@
 			}
 			omat=mat;		 /*  saving old material */
 			glBegin(GL_LINES);
-			for (i=0; i&lt;2; i++)
-				{
-					on=&amp;(obj-&gt;p_line[pn].n[i]);
-					glNormal3f(-on-&gt;x,-on-&gt;y,-on-&gt;z);
+			for (i=0; i&lt;2; i++) {
+				on=&amp;(obj-&gt;p_line[pn].n[i]);
+				glNormal3f(-on-&gt;x,-on-&gt;y,-on-&gt;z);
 
-					v= obj-&gt;p_line[pn].v[i];  /*  ... get the vertices ... */
-					glVertex3f(obj-&gt;p_vertex[v].x, obj-&gt;p_vertex[v].y, obj-&gt;p_vertex[v].z);  /*  ...and draw them */
-				}
+				v= obj-&gt;p_line[pn].v[i];  /*  ... get the vertices ... */
+				glVertex3f(obj-&gt;p_vertex[v].x, obj-&gt;p_vertex[v].y, obj-&gt;p_vertex[v].z);  /*  ...and draw them */
+			}
 			glEnd();
 		}
 		if (obj-&gt;dplist) glEndList();
@@ -1834,26 +1648,20 @@
 void link_delete(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o,*o2;
-	if (OBJ_VALID(p,oid,o))
-	{
+	if (OBJ_VALID(p,oid,o)) {
 		s3dprintf(VLOW,&quot;link_delete(): [%d] unlinking %d from %d&quot;,p-&gt;id, oid, o-&gt;linkid);
-		if (o-&gt;linkid!=-1) 
-		{
+		if (o-&gt;linkid!=-1) {
 			if (o-&gt;lprev!=-1)
-				if (OBJ_VALID(p,o-&gt;lprev,o2))
-				{ /* we have a previous pointer linking to us */
+				if (OBJ_VALID(p,o-&gt;lprev,o2)) { /* we have a previous pointer linking to us */
 					o2-&gt;lnext=o-&gt;lnext; /* might also be -1 */
 				}
-			if (OBJ_VALID(p,o-&gt;linkid,o2))
-			{
-				if (o2-&gt;lsub==oid)
-				{/* parent is having oid as it's first link in chain */
-					o2-&gt;lsub=o-&gt;lnext; 
+			if (OBJ_VALID(p,o-&gt;linkid,o2)) {
+				if (o2-&gt;lsub==oid) {/* parent is having oid as it's first link in chain */
+					o2-&gt;lsub=o-&gt;lnext;
 				}
 			}
 			if (o-&gt;lnext!=-1)
-				if (OBJ_VALID(p,o-&gt;lnext,o2))
-				{ /* fixing next's previous pointer */
+				if (OBJ_VALID(p,o-&gt;lnext,o2)) { /* fixing next's previous pointer */
 					o2-&gt;lprev=o-&gt;lprev;
 				}
 		}
@@ -1867,17 +1675,16 @@
 void link_insert(struct t_process *p, int32_t oid, int32_t target)
 {
 	struct t_obj *o,*ot,*o2;
-	if (OBJ_VALID(p,oid,o) &amp;&amp; OBJ_VALID(p,target,ot))
-	{
+	if (OBJ_VALID(p,oid,o) &amp;&amp; OBJ_VALID(p,target,ot)) {
 		s3dprintf(VLOW,&quot;link_insert(): [%d] linking %d to %d&quot;,p-&gt;id, oid, target);
 		o-&gt;oflags|=OF_LINK;
 		o-&gt;linkid=target;
 		o-&gt;lnext=ot-&gt;lsub; /* we have a new &quot;first&quot; element */
 		if (o-&gt;lnext!=-1) if (OBJ_VALID(p,o-&gt;lnext,o2))  /* if we already had an element
 														  in the chain, create the backlink */
-		{
-			o2-&gt;lprev=oid;
-		}
+			{
+				o2-&gt;lprev=oid;
+			}
 		ot-&gt;lsub=oid;
 	}
 }
@@ -1886,36 +1693,29 @@
 int obj_link(struct t_process *p, int32_t oid_from, int32_t oid_to)
 {
 	struct t_obj *o,*o2;
-	if (OBJ_VALID(p,oid_from,o) &amp;&amp; OBJ_VALID(p,oid_to,o2))
-	{
-		if (oid_to==oid_from)
-		{
+	if (OBJ_VALID(p,oid_from,o) &amp;&amp; OBJ_VALID(p,oid_to,o2)) {
+		if (oid_to==oid_from) {
 			errds(VHIGH,&quot;obj_link()&quot;,&quot;can't link to itself!!&quot;);
 			return(-1);
 		}
-		if (OF_POINTER==(o-&gt;oflags&amp;0xF0000000))
-		{
+		if (OF_POINTER==(o-&gt;oflags&amp;0xF0000000)) {
 			errds(VHIGH,&quot;obj_link()&quot;,&quot;may not change the link of a pointer&quot;);
 			return(-1);
 		}
 
-		while (o2-&gt;oflags&amp;OF_LINK)
-		{
-			if (o2-&gt;linkid==oid_from)  /*  circular link!! we can't do that */
-			{
+		while (o2-&gt;oflags&amp;OF_LINK) {
+			if (o2-&gt;linkid==oid_from) { /*  circular link!! we can't do that */
 				errds(VHIGH,&quot;obj_link()&quot;,&quot;link from %d to %d would produce a circular link!&quot;,oid_from,oid_to);
 				return(-1);
 			}
 			o2=p-&gt;object[o2-&gt;linkid];  /*   move to the next object in the linkchain */
 		}
-		if ((o-&gt;oflags&amp;OF_SYSTEM) &amp;&amp; (p-&gt;id==MCP))
-		{
+		if ((o-&gt;oflags&amp;OF_SYSTEM) &amp;&amp; (p-&gt;id==MCP)) {
 			errds(VHIGH,&quot;obj_link()&quot;,&quot;can't link system-objects in non-mcp-apps!&quot;);
 			return(-1);
 		}
- 		s3dprintf(VLOW,&quot;[link|pid %d] %d -&gt; %d&quot;,p-&gt;id, oid_from,oid_to); 
-		if (oid_to!=o-&gt;linkid) /* only if something changed ... */
-		{
+		s3dprintf(VLOW,&quot;[link|pid %d] %d -&gt; %d&quot;,p-&gt;id, oid_from,oid_to);
+		if (oid_to!=o-&gt;linkid) { /* only if something changed ... */
 			if (o-&gt;linkid!=-1)
 				link_delete(p,oid_from);
 			link_insert(p,oid_from,oid_to);
@@ -1930,10 +1730,8 @@
 int obj_unlink(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o;
-	if (OBJ_VALID(p,oid,o))
-	{
-		if (OF_POINTER==(o-&gt;oflags&amp;0xF0000000))
-		{
+	if (OBJ_VALID(p,oid,o)) {
+		if (OF_POINTER==(o-&gt;oflags&amp;0xF0000000)) {
 			errds(VHIGH,&quot;obj_link()&quot;,&quot;may not change the link of a pointer&quot;);
 			return(-1);
 		}
@@ -1963,32 +1761,28 @@
 	obj-&gt;r=obj-&gt;or=0.0F;
 	obj-&gt;m_uptodate=0;
 	memcpy(obj-&gt;m,Identity,sizeof(t_mtrx));
-	 /*  fresh and clean ... */
-	if (p!=NULL)
-	{
-		 /*  look for an old object for reuse ... */
-		for (pos=0; pos &lt; p-&gt;n_obj ; pos++)
-		{
-			if (p-&gt;object[pos]==NULL)
-			{
+	/*  fresh and clean ... */
+	if (p!=NULL) {
+		/*  look for an old object for reuse ... */
+		for (pos=0; pos &lt; p-&gt;n_obj ; pos++) {
+			if (p-&gt;object[pos]==NULL) {
 				reuse=1;
 				break;
-/* 				s3dprintf(HIGH,&quot;reusing position %d&quot;,pos); */
+				/* 				s3dprintf(HIGH,&quot;reusing position %d&quot;,pos); */
 			}
 		}
-		if (!reuse)
-		{
+		if (!reuse) {
 			if (p-&gt;n_obj&gt;0)
 				p-&gt;object=realloc(p-&gt;object,sizeof(struct t_obj *)*(p-&gt;n_obj+1));
 			else p-&gt;object=malloc(sizeof(struct t_obj *)*(p-&gt;n_obj+1));
 			pos=p-&gt;n_obj; 				 /*  add object at the end */
 			p-&gt;n_obj++;					 /*  increment counter */
 		}
-		p-&gt;object[pos]=obj;						
+		p-&gt;object[pos]=obj;
 		s3dprintf(VLOW,&quot;pid %d added new object %d at %010p [pos %d]&quot;,p-&gt;id,pos,obj,pos);
 		return (pos);
 	} else {
-		s3dprintf(HIGH,&quot;obj_new(): no such process %d&quot;,p-&gt;id);	
+		s3dprintf(HIGH,&quot;obj_new(): no such process %d&quot;,p-&gt;id);
 		return(-1);
 	}
 }
@@ -2000,42 +1794,33 @@
 	struct t_obj *o,*no;
 	int already_clone,is_clnsrc;
 	int32_t i;
-	if (OBJ_VALID(p,oid,o) &amp;&amp; OBJ_VALID(p,toid,no))
-	{
-		if ((o-&gt;oflags&amp;OF_SYSTEM) || (no-&gt;oflags&amp;OF_SYSTEM))
-		{
+	if (OBJ_VALID(p,oid,o) &amp;&amp; OBJ_VALID(p,toid,no)) {
+		if ((o-&gt;oflags&amp;OF_SYSTEM) || (no-&gt;oflags&amp;OF_SYSTEM)) {
 			s3dprintf(MED,&quot;can't clone from or to system objects&quot;);
 		}
-		 /*  get obj pointer and check for availability of the other object. */
-		if (((already_clone=(o-&gt;oflags&amp;OF_CLONE)) || (!(o-&gt;n_vertex|o-&gt;n_mat|o-&gt;n_poly|o-&gt;n_tex))) &amp;&amp; (!(o-&gt;oflags&amp;OF_VIRTUAL)))
-		{
-			if (no-&gt;oflags&amp;OF_CLONE)
-			{	 /*  target is clone */
+		/*  get obj pointer and check for availability of the other object. */
+		if (((already_clone=(o-&gt;oflags&amp;OF_CLONE)) || (!(o-&gt;n_vertex|o-&gt;n_mat|o-&gt;n_poly|o-&gt;n_tex))) &amp;&amp; (!(o-&gt;oflags&amp;OF_VIRTUAL))) {
+			if (no-&gt;oflags&amp;OF_CLONE) {	 /*  target is clone */
 				errds(VHIGH,&quot;obj_clone_change()&quot;,&quot;couldn't clone %d from %d (on pid %d): clone target is already clone.&quot;,oid,toid,p-&gt;id,oid);
 				return(-1);
 			}
-			if (!already_clone)  /*  some other object could link to us, so we check the other objects and forward them just in case. */
-			{
-				if (p-&gt;object[oid]-&gt;oflags&amp;OF_CLONE_SRC)
-				{
+			if (!already_clone) { /*  some other object could link to us, so we check the other objects and forward them just in case. */
+				if (p-&gt;object[oid]-&gt;oflags&amp;OF_CLONE_SRC) {
 					is_clnsrc=0;
 					for (i=0;i&lt;p-&gt;n_obj;i++)
 						if (p-&gt;object[i]!=NULL)
-							if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex==oid))  /*  it's linking to our object! */
-							{
+							if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex==oid)) { /*  it's linking to our object! */
 								errds(VHIGH,&quot;obj_clone_change()&quot;,&quot;couldn't clone %d from %d (on pid %d): object %d is already cloning from object %d.&quot;,
-												oid,toid,p-&gt;id,oid,i,oid);
+								      oid,toid,p-&gt;id,oid,i,oid);
 								return(-1);
 							}
-					if (!is_clnsrc)
-					{
+					if (!is_clnsrc) {
 						s3dprintf(MED,&quot;obj_clone_change(): %d in process %d is no longer a clone-source&quot;,oid,p-&gt;id);
 						p-&gt;object[oid]-&gt;oflags&amp;=~OF_CLONE_SRC;
 					}
 				}
 			}
-			if (oid!=toid)
-			{  /*  don't looplink */
+			if (oid!=toid) { /*  don't looplink */
 				o-&gt;oflags|=OF_CLONE;
 				no-&gt;oflags|=OF_CLONE_SRC;
 				o-&gt;n_vertex=toid;  /*  n_vertex is not used for this as it's just cloned, so we can use it ... */
@@ -2066,41 +1851,32 @@
 	int32_t i;
 	int32_t mcp_oid=-1;
 	mcp_p=get_proc_by_pid(MCP);
-	if (OBJ_VALID(p,oid,o))
-	{
-		if (o-&gt;oflags&amp;OF_SYSTEM)
-		{
+	if (OBJ_VALID(p,oid,o)) {
+		if (o-&gt;oflags&amp;OF_SYSTEM) {
 			s3dprintf(HIGH,&quot;can't delete system object!&quot;);
 			return(0);
 		}
 
 
-		if (p-&gt;id==MCP) 
-		{
-			if (o-&gt;oflags&amp;OF_VIRTUAL)  /*  only delete if virtual */
-			{
+		if (p-&gt;id==MCP) {
+			if (o-&gt;oflags&amp;OF_VIRTUAL) { /*  only delete if virtual */
 				s3dprintf(HIGH,&quot;the mcp wants %d to be closed&quot;,o-&gt;n_mat);
 				event_quit(get_proc_by_pid(o-&gt;n_mat));
 				return(0);
 			}
-		} else 
+		} else
 			mcp_oid=p-&gt;mcp_oid;
 
-		if (OBJ_VALID(p,oid,o))
-		{
+		if (OBJ_VALID(p,oid,o)) {
 			obj_free(p,oid);
-			if ((p-&gt;id!=MCP) &amp;&amp; (p-&gt;biggest_obj==oid))
-			{  /*  if object was the biggest object, find a new one. */
+			if ((p-&gt;id!=MCP) &amp;&amp; (p-&gt;biggest_obj==oid)) { /*  if object was the biggest object, find a new one. */
 				mr=-1;
 				p-&gt;biggest_obj=-1;
 				for (i=0;i&lt;p-&gt;n_obj;i++)
-					if (p-&gt;object[i]!=NULL)
-					{
+					if (p-&gt;object[i]!=NULL) {
 						r=p-&gt;object[i]-&gt;r+p-&gt;object[i]-&gt;or;
-						if (r&gt;mr)
-						{
-							if (!(p-&gt;object[i]-&gt;oflags&amp;OF_SYSTEM)) 
-							{
+						if (r&gt;mr) {
+							if (!(p-&gt;object[i]-&gt;oflags&amp;OF_SYSTEM)) {
 								p-&gt;biggest_obj=i;
 								mr=r;
 							}
@@ -2113,8 +1889,7 @@
 			if (o-&gt;oflags&amp;OF_CLONE_SRC)
 				for (i=0;i&lt;p-&gt;n_obj;i++)
 					if (p-&gt;object[i]!=NULL)
-						if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex==oid))  /*  it's linking to our object! */
-						{
+						if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex==oid)) { /*  it's linking to our object! */
 							p-&gt;object[i]-&gt;oflags&amp;=~OF_CLONE;  	 /*  disable clone flag */
 							p-&gt;object[i]-&gt;n_vertex=0; 			 /*  and &quot;clone reference&quot; to 0 */
 							p-&gt;object[i]-&gt;r=0.0F;				 /*  empty object, so radius is zero! */
@@ -2136,29 +1911,24 @@
 
 	/* clearing links */
 	if (o-&gt;linkid!=-1)		link_delete(p,oid);
-	while (o-&gt;lsub!=-1)		
-	{
+	while (o-&gt;lsub!=-1) {
 		i=o-&gt;lsub;
 		link_delete(p,o-&gt;lsub);
-		if (i==o-&gt;lsub) 
-		{
+		if (i==o-&gt;lsub) {
 			s3dprintf(HIGH,&quot;something is wrong!!&quot;);
 			o=NULL; /* segfault */
 			o-&gt;lsub=-1;
 		}
 	}
 
-	if (!(o-&gt;oflags&amp;OF_NODATA))
-	{
+	if (!(o-&gt;oflags&amp;OF_NODATA)) {
 		if (o-&gt;n_vertex&gt;0) free(o-&gt;p_vertex);
 		if (o-&gt;n_poly&gt;0) free(o-&gt;p_poly);
 		if (o-&gt;n_mat&gt;0) free(o-&gt;p_mat);
-		for (i=0;i&lt;o-&gt;n_tex;i++)
-		{
+		for (i=0;i&lt;o-&gt;n_tex;i++) {
 			if (o-&gt;p_tex[i].buf!=NULL)
 				free(o-&gt;p_tex[i].buf);
-			if (o-&gt;p_tex[i].gl_texnum)
-			{
+			if (o-&gt;p_tex[i].gl_texnum) {
 				t=o-&gt;p_tex[i].gl_texnum;
 				glDeleteTextures(1,&amp;t);
 			}
@@ -2166,18 +1936,15 @@
 		if (o-&gt;n_tex&gt;0) free(o-&gt;p_tex);
 
 	}
-	if (o-&gt;dplist)
-	{
-		if (!(o-&gt;oflags&amp;(OF_CLONE|OF_SYSTEM))) 
-		{
+	if (o-&gt;dplist) {
+		if (!(o-&gt;oflags&amp;(OF_CLONE|OF_SYSTEM))) {
 			s3dprintf(VLOW,&quot;freeing display list %d&quot;,o-&gt;dplist);
 			glDeleteLists(o-&gt;dplist,1);
 		}
 	}
 	free(o);
 	p-&gt;object[oid]=NULL;
-	if (oid==(p-&gt;n_obj-1))
-	{
+	if (oid==(p-&gt;n_obj-1)) {
 		i=oid;
 		while ((i!=-1) &amp;&amp; (p-&gt;object[i]==NULL)) i--;
 		p-&gt;n_obj=i+1;
@@ -2189,11 +1956,9 @@
 int32_t get_pointer(struct t_process *p)
 {
 	int32_t i;
-	for (i=0;i&lt;p-&gt;n_obj;i++)
-	{
+	for (i=0;i&lt;p-&gt;n_obj;i++) {
 
-		if (OF_POINTER==(p-&gt;object[i]-&gt;oflags&amp;0xF0000000))
-		{
+		if (OF_POINTER==(p-&gt;object[i]-&gt;oflags&amp;0xF0000000)) {
 			return(i);
 		}
 	}

Modified: trunk/server/process.c
===================================================================
--- trunk/server/process.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/process.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * process.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,29 +35,25 @@
 int process_sys_init(struct t_process *p);
 
 /* protocol request for process initialization */
-struct t_process *process_protinit(struct t_process *p, char *name)
-{
+struct t_process *process_protinit(struct t_process *p, char *name) {
 	int con_type;
 	int32_t mcp_oid;
-	if ((strncmp(name,&quot;sys_&quot;,4)==0))
-	{ /* we don't like &quot;sys_&quot;-apps, kicking this */
+	if ((strncmp(name,&quot;sys_&quot;,4)==0)) { /* we don't like &quot;sys_&quot;-apps, kicking this */
 		errds(VHIGH,&quot;process_protinit()&quot;,&quot;appnames starting with 'sys_' not allowed.&quot;);
 		return(NULL);
 	}
-	if ((p-&gt;id!=MCP) &amp;&amp; (strncmp(name,&quot;mcp&quot;,3)==0))
-	{
-		if (procs_p[MCP].con_type==CON_NULL)
-		{
+	if ((p-&gt;id!=MCP) &amp;&amp; (strncmp(name,&quot;mcp&quot;,3)==0)) {
+		if (procs_p[MCP].con_type==CON_NULL) {
 			s3dprintf(MED,&quot;free mcp place, pid %d becoming mcp!&quot;,p-&gt;id);
 			con_type=p-&gt;con_type; /* move connection data */
-#ifdef TCP			
+#ifdef TCP
 			procs_p[MCP].sockid=p-&gt;sockid; /* don't save contype yet,
 									or p_del will notify mcp about a deleted
 									mcp-object (which is itselfs, actually) */
 #endif
 #ifdef SHM
 			memcpy(&amp;procs_p[MCP].shmsock,&amp;p-&gt;shmsock,sizeof(struct t_shmcb));
-#endif 
+#endif
 			p_del(p); /* deleting data/mcp object */
 			procs_p[MCP].con_type=con_type;
 			mcp_init();
@@ -71,19 +67,17 @@
 		strncpy(p-&gt;name, name, NAME_MAX);
 		process_sys_init(p);
 
-	/* register the new process in the mcp */
-		if (-1!=(mcp_oid= obj_new(&amp;procs_p[MCP])))
-		{
+		/* register the new process in the mcp */
+		if (-1!=(mcp_oid= obj_new(&amp;procs_p[MCP]))) {
 			mcp_p-&gt;object[mcp_oid]-&gt;oflags|=OF_VIRTUAL|OF_VISIBLE|OF_SELECTABLE;
 			mcp_p-&gt;object[mcp_oid]-&gt;n_mat=p-&gt;id;
-			
-	/* 		mcp_p-&gt;object[mcp_oid]-&gt;p_mat=(struct t_material *)new_p; */
-						/*  dirty, but it's just a pointer after all ... */
+
+			/* 		mcp_p-&gt;object[mcp_oid]-&gt;p_mat=(struct t_material *)new_p; */
+			/*  dirty, but it's just a pointer after all ... */
 			p-&gt;mcp_oid=mcp_oid;
 			s3dprintf(LOW,&quot;process %d now has mcp_oid %d&quot;,p-&gt;id,mcp_oid);
 			mcp_rep_object(mcp_oid);
-			if (mcp_p-&gt;con_type==CON_NULL)
-			{  /*  there is no mcp connected! setting focus to the new program: */
+			if (mcp_p-&gt;con_type==CON_NULL) { /*  there is no mcp connected! setting focus to the new program: */
 				mcp_focus(mcp_oid);
 			}
 		} else {
@@ -99,8 +93,7 @@
 	struct t_obj *o;
 	cam=obj_new(p);
 	ptr=obj_new(p);
-	if (p-&gt;id==MCP)
-	{   /* this is only called once within process_init, later mcp's are
+	if (p-&gt;id==MCP) {   /* this is only called once within process_init, later mcp's are
 		   will be registered as &quot;real&quot; apps first */
 		p-&gt;object[cam]-&gt;translate.z=5;
 		p-&gt;object[cam]-&gt;oflags=OF_CAM;
@@ -110,9 +103,8 @@
 	} else {
 		/* TODO: ... get the cam and ptr position of the mcp, somehow */
 		p-&gt;object[cam]-&gt;oflags=OF_CAM;
-		
-		if (OBJ_VALID(mcp_p,get_pointer(mcp_p),o)) /* get parent pointer, copy parent */
-		{
+
+		if (OBJ_VALID(mcp_p,get_pointer(mcp_p),o)) { /* get parent pointer, copy parent */
 			p-&gt;object[ptr]-&gt;rotate.x=o-&gt;rotate.x;
 			p-&gt;object[ptr]-&gt;rotate.y=o-&gt;rotate.y;
 			p-&gt;object[ptr]-&gt;rotate.z=o-&gt;rotate.z;
@@ -127,26 +119,25 @@
 	s3dprintf(MED,&quot;process_sys_init(): added object ptr0 %d&quot;,ptr);
 	obj_pos_update(get_proc_by_pid(MCP),cam,cam);
 	obj_pos_update(get_proc_by_pid(MCP),ptr,ptr);
-/*	obj_recalc_tmat(p,0);*/
+	/*	obj_recalc_tmat(p,0);*/
 	event_obj_info(p,0); /* tell the new program about the thing */
 
 	return(0);
 }
 
 /* this is to be called when a new connection appears. a pointer to the added process will be returned */
-struct t_process *process_add()
-{
+struct t_process *process_add() {
 	struct t_process *new_p;
 	procs_n++;
 	procs_p=realloc(procs_p,sizeof(struct t_process)*procs_n); /* increase the block */
 	new_p=&amp;procs_p[procs_n-1];
 
 	new_p-&gt;id	  = procs_n-1;
-/*	if (new_p-&gt;id==0)
-		mcp_p=&amp;procs_p[0];*/
+	/*	if (new_p-&gt;id==0)
+			mcp_p=&amp;procs_p[0];*/
 	new_p-&gt;object = NULL;
 	new_p-&gt;n_obj  = 0;
-/*	new_p-&gt;netin  = 0;*/
+	/*	new_p-&gt;netin  = 0;*/
 	new_p-&gt;mcp_oid = -1;
 	new_p-&gt;biggest_obj=-1;
 	new_p-&gt;con_type=CON_NULL;	/* this is to be changed by the caller */
@@ -156,14 +147,12 @@
 /* deletes the process with pid */
 int process_del(int pid)
 {
-	if (pid==MCP)
-	{
+	if (pid==MCP) {
 		n_remove(&amp;procs_p[pid]);
 		p_del(&amp;procs_p[pid]);
 		return(0);
 	}
-	if ((pid&gt;0) &amp;&amp; (pid&lt;procs_n))
-	{
+	if ((pid&gt;0) &amp;&amp; (pid&lt;procs_n)) {
 		n_remove(&amp;procs_p[pid]);
 		p_del(&amp;procs_p[pid]);
 		process_list_rm(pid);
@@ -174,22 +163,20 @@
 /* just kick process out of the process list, no network/mcp-oid cleanup */
 int process_list_rm(int pid)
 {
-	if (pid!=(procs_n-1)) 
-	{ /* copy last block, swap pid */
+	if (pid!=(procs_n-1)) { /* copy last block, swap pid */
 		memcpy(&amp;procs_p[pid],&amp;procs_p[procs_n-1],sizeof(struct t_process));
 		procs_p[pid].id=pid; /* change the pid of the new procs_p */
 		if (procs_p[pid].mcp_oid!=-1) /* the last process could just appear without initializing yet ... */
-			procs_p[0].object[procs_p[pid].mcp_oid]-&gt;n_mat=pid; 
-			/* change the mcp-objects pid-pointer to the right position! */
-			/* this is kind of pointer madness */
+			procs_p[0].object[procs_p[pid].mcp_oid]-&gt;n_mat=pid;
+		/* change the mcp-objects pid-pointer to the right position! */
+		/* this is kind of pointer madness */
 	}
 	procs_n--;
 	procs_p=realloc(procs_p,sizeof(struct t_process)*procs_n); /* decrease the block,
 		wipe the last one */
 	return(0);
 }
-struct t_process *get_proc_by_pid(int pid)
-{
+struct t_process *get_proc_by_pid(int pid) {
 	if ((pid&gt;=0) &amp;&amp; (pid&lt;procs_n))
 		return(&amp;procs_p[pid]);
 	return(NULL);
@@ -199,15 +186,11 @@
 static int p_del(struct t_process *p)
 {
 	int j,i=p-&gt;n_obj;
-	if (p-&gt;id!=MCP)
-	{
-		if (p-&gt;mcp_oid!=-1)
-		{
+	if (p-&gt;id!=MCP) {
+		if (p-&gt;mcp_oid!=-1) {
 			for (j=0;j&lt;mcp_p-&gt;n_obj;j++)	 /*  remove clones and links pointing on this app-object ... */
-				if (mcp_p-&gt;object[j]!=NULL)
-				{
-					if ((mcp_p-&gt;object[j]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (mcp_p-&gt;object[j]-&gt;n_vertex == p-&gt;mcp_oid))  /*  it's linking to our object! */
-					{
+				if (mcp_p-&gt;object[j]!=NULL) {
+					if ((mcp_p-&gt;object[j]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (mcp_p-&gt;object[j]-&gt;n_vertex == p-&gt;mcp_oid)) { /*  it's linking to our object! */
 						mcp_p-&gt;object[j]-&gt;oflags&amp;=~OF_CLONE;  	 /*  disable clone flag */
 						mcp_p-&gt;object[j]-&gt;n_vertex=0; 			 /*  and &quot;clone reference&quot; to 0 */
 						mcp_p-&gt;object[j]-&gt;r=0.0F;				 /*  empty object, so radius is zero! */
@@ -217,20 +200,17 @@
 			mcp_del_object(p-&gt;mcp_oid); 	 /*  tell MCP that it's object is beeing deleted. */
 		} else /*
 			errs(&quot;p_del()&quot;,&quot;bad mcp_oid, unable to free mcp object&quot;);*/
-		if (i&gt;0)
-		{
-			for (i=0;i&lt;p-&gt;n_obj;i++)
-				if (p-&gt;object[i]) obj_free(p,i);
-			free(p-&gt;object);
-		}
-	}
-	else {
-		 /*  the mcp keeps in our memory ... */
-		 /*  so we just delete the objects added */
-		 /*  by the last mcp */
+			if (i&gt;0) {
+				for (i=0;i&lt;p-&gt;n_obj;i++)
+					if (p-&gt;object[i]) obj_free(p,i);
+				free(p-&gt;object);
+			}
+	} else {
+		/*  the mcp keeps in our memory ... */
+		/*  so we just delete the objects added */
+		/*  by the last mcp */
 		s3dprintf(MED,&quot;clean up mcp's junk ...&quot;);
-		for (i=0;i&lt;p-&gt;n_obj;i++)
-		{
+		for (i=0;i&lt;p-&gt;n_obj;i++) {
 			if (p-&gt;object[i]!=NULL)
 				if (!(p-&gt;object[i]-&gt;oflags&amp;(OF_SYSTEM|OF_VIRTUAL)))
 					obj_free(p,i);
@@ -242,7 +222,7 @@
 {
 	procs_n=0;
 	procs_p=NULL;
-	process_add(); 
+	process_add();
 	/* set up mcp */
 	strncpy(mcp_p-&gt;name,&quot;mcp&quot;,NAME_MAX);
 	mcp_p-&gt;con_type=CON_NULL;
@@ -253,11 +233,10 @@
 {
 	int i;
 	s3dprintf(HIGH,&quot;telling %d processes to go away&quot;,procs_n);
-	for (i=(procs_n-1);i&gt;=0;i--)
-	{ 
+	for (i=(procs_n-1);i&gt;=0;i--) {
 		s3dprintf(HIGH,&quot;[QUIT] for %d&quot;,i);
 		event_quit(&amp;procs_p[i]);
-/*		process_del(procs_p[i].id);*/
+		/*		process_del(procs_p[i].id);*/
 	}
 	free(procs_p);
 	return(0);

Modified: trunk/server/proto.c
===================================================================
--- trunk/server/proto.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/proto.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * proto.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,11 +27,11 @@
 /* #include &lt;string.h&gt;  / *  memcpy() * / */
 #include &lt;stdlib.h&gt;  /*  malloc() */
 #include &lt;string.h&gt;  /*  strncpy(),memset() */
-#ifdef WIN32 
+#ifdef WIN32
 #include &lt;winsock2.h&gt;
 #else
 #include &lt;netinet/in.h&gt;  /*  htonl(),htons() */
-#endif 
+#endif
 /*  this code should do the protocol work .... */
 /*  */
 extern uint8_t obuf[MAXPLEN];
@@ -53,347 +53,357 @@
 	uint8_t	type;
 	int32_t flags,mcp_oid=-1;
 	command=pbuf[0];
-	if (p-&gt;id!=0)
-	{
+	if (p-&gt;id!=0) {
 		mcp_oid=p-&gt;mcp_oid;		 /*  get mcp-oid if we need to report something to */
-								 /*  the mcp */
-		if ((mcp_oid==-1) &amp;&amp; (command!=S3D_P_C_INIT))
-		{
+		/*  the mcp */
+		if ((mcp_oid==-1) &amp;&amp; (command!=S3D_P_C_INIT)) {
 			s3dprintf(MED,&quot;prot_com_in(): commands without beeing initialized ?! no way, kicking ...&quot;);
 			event_quit(p);
 		}
-	} 
+	}
 	length=ntohs(*((uint16_t *)((uint8_t *)pbuf+1)));
 	cptr=buf=pbuf+3;
-/* 	if (mcp_oid==-1) s3dprintf(HIGH,&quot;couldn't find mcp-oid for pid %d!&quot;,p-&gt;id); */
-		switch (command) {
-			case S3D_P_C_INIT:
-				memset(name,0,NAME_MAX);
-				if (length&gt;NAME_MAX) i=NAME_MAX; else i=length;
-				strncpy(name,(char *)buf,i);
-				s3dprintf(LOW,&quot;[%d]\&quot;%s\&quot; logged in&quot;, p-&gt;id,name);
-				if (NULL==(np=process_protinit(p,name)))
-					event_quit(p);  /*  couldn't get process */
-				else
-					event_init(np);
-				break;
-			case S3D_P_C_NEW_OBJ:
-				oid=htonl(obj_new(p));
-/* 				s3dprintf(LOW,&quot;pid %d registering new object %d&quot;,p-&gt;id,ntohl(oid)); */
-				prot_com_out(p,S3D_P_S_NEWOBJ,(uint8_t *)&amp;oid, 4);
-				break;
-			case S3D_P_C_DEL_OBJ:
-				if (length==4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		
-					obj_del(p,oid);
-				}
-				break;
-			case S3D_P_C_CLONE:
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));
-					obj_clone_change(p,oid,toid);
-				}
-				break;
-			case S3D_P_C_LINK:
-				if (length==4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));
-					obj_unlink(p,oid);
-				}
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));
-					obj_link(p,oid,toid);
-				}
-				break;
-			case S3D_P_C_QUIT:
-				s3dprintf(LOW,&quot;QUIT issued&quot;);
-				event_quit(p);
-				break;
-			case S3D_P_C_PUSH_VERTEX:
-				if (length&gt;4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*3);
-/* 					s3dprintf(LOW,&quot;received %d new vertices for object oid...%d&quot;, num, oid); */
-					obj_push_vertex(p,oid, (float  *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PUSH_MAT:
-				if (length&gt;4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*12);
-/* 					s3dprintf(LOW,&quot;received %d new materials for object oid...%d&quot;, num, oid); */
-					obj_push_mat(p,oid, (float *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PUSH_POLY:
-				if (length&gt;4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*4);
-/* 					s3dprintf(LOW,&quot;received %d new polygons for object oid...%d&quot;, num, oid); */
-					for (i=0;i&lt;(num*4);i++)
-						*((uint32_t *)cptr+i)=
-								ntohl(*((uint32_t *)cptr+i));
-					 /*  convert index names */
-					obj_push_poly(p,oid, (uint32_t *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PUSH_LINE:
-				if (length&gt;4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*3);
- 					s3dprintf(VLOW,&quot;received %d new lines for object oid...%d&quot;, num, oid); 
-					for (i=0;i&lt;(num*3);i++)
-						*((uint32_t *)cptr+i)=
-								ntohl(*((uint32_t *)cptr+i));
-					 /*  convert index names */
-					obj_push_line(p,oid, (uint32_t *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PUSH_TEX:
-				if (length&gt;4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(2*2);
-					s3dprintf(LOW,&quot;received %d new textures for object oid...%d&quot;, num, oid);
-					for (i=0;i&lt;(num*2);i++)
-						*((uint16_t *)cptr+i)=
-								ntohs(*((uint16_t *)cptr+i));
-					 /*  convert index names */
-					obj_push_tex(p,oid, (uint16_t *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PEP_POLY_NORMAL:
-				if (length&gt;4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(9*4);
-					s3dprintf(VLOW,&quot;PEP_POLY_NORMAL[%d]: oid %d, %f polys&quot;,length,oid, (length-4)/(9.0*4.0));
-					obj_pep_poly_normal(p,oid, (float *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PEP_LINE_NORMAL:
-				if (length&gt;4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(6*4);
-					s3dprintf(VLOW,&quot;PEP_LINE_NORMAL[%d]: oid %d, %.1f lines&quot;,length,oid, (length-4)/(6.0*4.0));
-					obj_pep_line_normal(p,oid, (float *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PEP_POLY_TEXC:
-				if (length&gt;4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(6*4);
-					s3dprintf(VLOW,&quot;PEP_POLY_TEXC[%d]: oid %d, %f polys&quot;,length,oid, (length-4)/(6.0*4.0));
-					obj_pep_poly_texc(p,oid, (float *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PEP_MAT:
-				if (length&gt;4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*12);
-					s3dprintf(VLOW,&quot;PEP_MAT[%d]: %d materials for object oid...%d&quot;, length, num, oid);
-					obj_pep_mat(p,oid, (float *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PEP_VERTEX:
-				if (length&gt;4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*3);
- 					s3dprintf(VLOW,&quot;pepping %d new vertices for object oid...%d&quot;, num, oid); 
-					obj_pep_vertex(p,oid, (float  *)cptr, num);
-				}
-				break;
+	/* 	if (mcp_oid==-1) s3dprintf(HIGH,&quot;couldn't find mcp-oid for pid %d!&quot;,p-&gt;id); */
+	switch (command) {
+	case S3D_P_C_INIT:
+		memset(name,0,NAME_MAX);
+		if (length&gt;NAME_MAX) i=NAME_MAX;
+		else i=length;
+		strncpy(name,(char *)buf,i);
+		s3dprintf(LOW,&quot;[%d]\&quot;%s\&quot; logged in&quot;, p-&gt;id,name);
+		if (NULL==(np=process_protinit(p,name)))
+			event_quit(p);  /*  couldn't get process */
+		else
+			event_init(np);
+		break;
+	case S3D_P_C_NEW_OBJ:
+		oid=htonl(obj_new(p));
+		/* 				s3dprintf(LOW,&quot;pid %d registering new object %d&quot;,p-&gt;id,ntohl(oid)); */
+		prot_com_out(p,S3D_P_S_NEWOBJ,(uint8_t *)&amp;oid, 4);
+		break;
+	case S3D_P_C_DEL_OBJ:
+		if (length==4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			obj_del(p,oid);
+		}
+		break;
+	case S3D_P_C_CLONE:
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			obj_clone_change(p,oid,toid);
+		}
+		break;
+	case S3D_P_C_LINK:
+		if (length==4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			obj_unlink(p,oid);
+		}
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			obj_link(p,oid,toid);
+		}
+		break;
+	case S3D_P_C_QUIT:
+		s3dprintf(LOW,&quot;QUIT issued&quot;);
+		event_quit(p);
+		break;
+	case S3D_P_C_PUSH_VERTEX:
+		if (length&gt;4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*3);
+			/* 					s3dprintf(LOW,&quot;received %d new vertices for object oid...%d&quot;, num, oid); */
+			obj_push_vertex(p,oid, (float  *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PUSH_MAT:
+		if (length&gt;4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*12);
+			/* 					s3dprintf(LOW,&quot;received %d new materials for object oid...%d&quot;, num, oid); */
+			obj_push_mat(p,oid, (float *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PUSH_POLY:
+		if (length&gt;4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*4);
+			/* 					s3dprintf(LOW,&quot;received %d new polygons for object oid...%d&quot;, num, oid); */
+			for (i=0;i&lt;(num*4);i++)
+				*((uint32_t *)cptr+i)=
+				        ntohl(*((uint32_t *)cptr+i));
+			/*  convert index names */
+			obj_push_poly(p,oid, (uint32_t *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PUSH_LINE:
+		if (length&gt;4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*3);
+			s3dprintf(VLOW,&quot;received %d new lines for object oid...%d&quot;, num, oid);
+			for (i=0;i&lt;(num*3);i++)
+				*((uint32_t *)cptr+i)=
+				        ntohl(*((uint32_t *)cptr+i));
+			/*  convert index names */
+			obj_push_line(p,oid, (uint32_t *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PUSH_TEX:
+		if (length&gt;4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(2*2);
+			s3dprintf(LOW,&quot;received %d new textures for object oid...%d&quot;, num, oid);
+			for (i=0;i&lt;(num*2);i++)
+				*((uint16_t *)cptr+i)=
+				        ntohs(*((uint16_t *)cptr+i));
+			/*  convert index names */
+			obj_push_tex(p,oid, (uint16_t *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PEP_POLY_NORMAL:
+		if (length&gt;4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(9*4);
+			s3dprintf(VLOW,&quot;PEP_POLY_NORMAL[%d]: oid %d, %f polys&quot;,length,oid, (length-4)/(9.0*4.0));
+			obj_pep_poly_normal(p,oid, (float *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PEP_LINE_NORMAL:
+		if (length&gt;4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(6*4);
+			s3dprintf(VLOW,&quot;PEP_LINE_NORMAL[%d]: oid %d, %.1f lines&quot;,length,oid, (length-4)/(6.0*4.0));
+			obj_pep_line_normal(p,oid, (float *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PEP_POLY_TEXC:
+		if (length&gt;4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(6*4);
+			s3dprintf(VLOW,&quot;PEP_POLY_TEXC[%d]: oid %d, %f polys&quot;,length,oid, (length-4)/(6.0*4.0));
+			obj_pep_poly_texc(p,oid, (float *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PEP_MAT:
+		if (length&gt;4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*12);
+			s3dprintf(VLOW,&quot;PEP_MAT[%d]: %d materials for object oid...%d&quot;, length, num, oid);
+			obj_pep_mat(p,oid, (float *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PEP_VERTEX:
+		if (length&gt;4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*3);
+			s3dprintf(VLOW,&quot;pepping %d new vertices for object oid...%d&quot;, num, oid);
+			obj_pep_vertex(p,oid, (float  *)cptr, num);
+		}
+		break;
 
-			case S3D_P_C_PEP_MAT_TEX:
-				if (length&gt;4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4);
-					s3dprintf(VLOW,&quot;PEP_MAT_TEX[%d]: %d materials for object oid...%d&quot;, length, num, oid);
-					obj_pep_mat_tex(p,oid, (uint32_t *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PEP_LINE:
-				if (length&gt;4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*3);
- 					s3dprintf(VLOW,&quot;pepping %d new lines for object oid...%d&quot;, num, oid); 
-					for (i=0;i&lt;(num*3);i++)
-						*((uint32_t *)cptr+i)=
-								ntohl(*((uint32_t *)cptr+i));
-					obj_pep_line(p,oid, (uint32_t *)cptr, num);
-				}
-				break;
-			case S3D_P_C_LOAD_LINE_NORMAL:
-				if (length&gt;8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-8)/(6*4);
-					s3dprintf(VLOW,&quot;LOAD_POLY_NORMAL[%d]: oid %d, %.2f lines&quot;,length,oid, (length-8)/(6.0*4.0));
-					obj_load_line_normal(p,oid, (float *)cptr, toid, num);
-				}
-				break;
-			case S3D_P_C_LOAD_POLY_NORMAL:
-				if (length&gt;8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-8)/(9*4);
-					s3dprintf(MED,&quot;LOAD_POLY_NORMAL[%d]: oid %d, %f polys&quot;,length,oid, (length-8)/(9.0*4.0));
-					obj_load_poly_normal(p,oid, (float *)cptr, toid, num);
-				}
-				break;
-			case S3D_P_C_LOAD_POLY_TEXC:
-				if (length&gt;8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-8)/(6*4);
-					s3dprintf(MED,&quot;LOAD_POLY_TEXC[%d]: oid %d, %f polys&quot;,length,oid, (length-8)/(6.0*4.0));
-					obj_load_poly_texc(p,oid, (float *)cptr, toid, num);
-				}
-				break;
-			case S3D_P_C_LOAD_MAT:
-				if (length&gt;8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-8)/(4*12);
-					s3dprintf(LOW,&quot;LOAD_MAT[%d]: %d materials for object oid...%d&quot;, length, num, oid);
-					obj_load_mat(p,oid, (float *)cptr, toid, num);
-				}
-				break;
-			case S3D_P_C_LOAD_TEX:
-				if (length&gt;8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					x=ntohs(*((uint16_t *)cptr));			cptr+=2;
-					y=ntohs(*((uint16_t *)cptr));			cptr+=2;
-					w=ntohs(*((uint16_t *)cptr));			cptr+=2;
-					h=ntohs(*((uint16_t *)cptr));			cptr+=2;
-					num=length-16;
-	 /* 				s3dprintf(MED,&quot;LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)&quot;,length, oid,toid,w,h,x,y,num,w*h*4,num); */
-					if ((w*h*4)==num)  /*  check correct size */
-						obj_load_tex(p,oid, toid, x, y, w, h, cptr);
-				}
-				break;
-			case S3D_P_C_DEL_VERTEX:
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=ntohl(*((uint32_t *)cptr));		cptr+=4;
-/* 					s3dprintf(LOW,&quot;deleting %d vertices for object oid...%d&quot;, num, oid); */
-					obj_del_vertex(p,oid,num);
-				}
-				break;
-			case S3D_P_C_DEL_POLY:
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=ntohl(*((uint32_t *)cptr));		cptr+=4;
-/* 					s3dprintf(LOW,&quot;deleting %d vertices for object oid...%d&quot;, num, oid); */
-					obj_del_poly(p,oid,num);
-				}	
-				break;
-			case S3D_P_C_DEL_LINE:
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=ntohl(*((uint32_t *)cptr));		cptr+=4;
- 					s3dprintf(VLOW,&quot;deleting %d lines for object oid...%d&quot;, num, oid); 
-					obj_del_line(p,oid,num);
-				}	
-				break;
+	case S3D_P_C_PEP_MAT_TEX:
+		if (length&gt;4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4);
+			s3dprintf(VLOW,&quot;PEP_MAT_TEX[%d]: %d materials for object oid...%d&quot;, length, num, oid);
+			obj_pep_mat_tex(p,oid, (uint32_t *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PEP_LINE:
+		if (length&gt;4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*3);
+			s3dprintf(VLOW,&quot;pepping %d new lines for object oid...%d&quot;, num, oid);
+			for (i=0;i&lt;(num*3);i++)
+				*((uint32_t *)cptr+i)=
+				        ntohl(*((uint32_t *)cptr+i));
+			obj_pep_line(p,oid, (uint32_t *)cptr, num);
+		}
+		break;
+	case S3D_P_C_LOAD_LINE_NORMAL:
+		if (length&gt;8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-8)/(6*4);
+			s3dprintf(VLOW,&quot;LOAD_POLY_NORMAL[%d]: oid %d, %.2f lines&quot;,length,oid, (length-8)/(6.0*4.0));
+			obj_load_line_normal(p,oid, (float *)cptr, toid, num);
+		}
+		break;
+	case S3D_P_C_LOAD_POLY_NORMAL:
+		if (length&gt;8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-8)/(9*4);
+			s3dprintf(MED,&quot;LOAD_POLY_NORMAL[%d]: oid %d, %f polys&quot;,length,oid, (length-8)/(9.0*4.0));
+			obj_load_poly_normal(p,oid, (float *)cptr, toid, num);
+		}
+		break;
+	case S3D_P_C_LOAD_POLY_TEXC:
+		if (length&gt;8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-8)/(6*4);
+			s3dprintf(MED,&quot;LOAD_POLY_TEXC[%d]: oid %d, %f polys&quot;,length,oid, (length-8)/(6.0*4.0));
+			obj_load_poly_texc(p,oid, (float *)cptr, toid, num);
+		}
+		break;
+	case S3D_P_C_LOAD_MAT:
+		if (length&gt;8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-8)/(4*12);
+			s3dprintf(LOW,&quot;LOAD_MAT[%d]: %d materials for object oid...%d&quot;, length, num, oid);
+			obj_load_mat(p,oid, (float *)cptr, toid, num);
+		}
+		break;
+	case S3D_P_C_LOAD_TEX:
+		if (length&gt;8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			x=ntohs(*((uint16_t *)cptr));
+			cptr+=2;
+			y=ntohs(*((uint16_t *)cptr));
+			cptr+=2;
+			w=ntohs(*((uint16_t *)cptr));
+			cptr+=2;
+			h=ntohs(*((uint16_t *)cptr));
+			cptr+=2;
+			num=length-16;
+			/* 				s3dprintf(MED,&quot;LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)&quot;,length, oid,toid,w,h,x,y,num,w*h*4,num); */
+			if ((w*h*4)==num)  /*  check correct size */
+				obj_load_tex(p,oid, toid, x, y, w, h, cptr);
+		}
+		break;
+	case S3D_P_C_DEL_VERTEX:
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			/* 					s3dprintf(LOW,&quot;deleting %d vertices for object oid...%d&quot;, num, oid); */
+			obj_del_vertex(p,oid,num);
+		}
+		break;
+	case S3D_P_C_DEL_POLY:
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			/* 					s3dprintf(LOW,&quot;deleting %d vertices for object oid...%d&quot;, num, oid); */
+			obj_del_poly(p,oid,num);
+		}
+		break;
+	case S3D_P_C_DEL_LINE:
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			s3dprintf(VLOW,&quot;deleting %d lines for object oid...%d&quot;, num, oid);
+			obj_del_line(p,oid,num);
+		}
+		break;
 
-			case S3D_P_C_DEL_MAT:
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=ntohl(*((uint32_t *)cptr));		cptr+=4;
-/* 					s3dprintf(LOW,&quot;deleting %d materials for object oid...%d&quot;, num, oid); */
-					obj_del_mat(p,oid,num);
-				}
-				break;
-			case S3D_P_C_DEL_TEX:
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=ntohl(*((uint32_t *)cptr));		cptr+=4;
-/* 					s3dprintf(LOW,&quot;deleting %d textures for object oid...%d&quot;, num, oid); */
-					obj_del_tex(p,oid,num);
-				}
-				break;
-			case S3D_P_C_TOGGLE_FLAGS:
-				if (length==9)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					type=*cptr;								cptr+=1;
-					flags=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					obj_toggle_flags(p,oid, type, flags);
-				}
-				break;
-			case S3D_P_C_TRANSLATE:
-				if (length&gt;=16)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					obj_translate(p,oid,(float *)cptr);
-				}
-				break;
-			case S3D_P_C_ROTATE:
-				if (length&gt;=16)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					obj_rotate(p,oid,(float *)cptr);
-				}
-				break;
-			case S3D_P_C_SCALE:
-				if (length&gt;=8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					obj_scale(p,oid,*((float *)cptr));
-				}
-				break;
-			case S3D_P_MCP_FOCUS:
-				if ((p-&gt;id==MCP) &amp;&amp; (length==4))
-				{
-					oid=ntohl(*((uint32_t *)cptr));
-					mcp_focus(oid);	
-				}
-				break;
-			default:
-				s3dprintf(LOW,&quot;don't know this command (%d)&quot;,command);
+	case S3D_P_C_DEL_MAT:
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			/* 					s3dprintf(LOW,&quot;deleting %d materials for object oid...%d&quot;, num, oid); */
+			obj_del_mat(p,oid,num);
 		}
+		break;
+	case S3D_P_C_DEL_TEX:
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			/* 					s3dprintf(LOW,&quot;deleting %d textures for object oid...%d&quot;, num, oid); */
+			obj_del_tex(p,oid,num);
+		}
+		break;
+	case S3D_P_C_TOGGLE_FLAGS:
+		if (length==9) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			type=*cptr;
+			cptr+=1;
+			flags=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			obj_toggle_flags(p,oid, type, flags);
+		}
+		break;
+	case S3D_P_C_TRANSLATE:
+		if (length&gt;=16) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			obj_translate(p,oid,(float *)cptr);
+		}
+		break;
+	case S3D_P_C_ROTATE:
+		if (length&gt;=16) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			obj_rotate(p,oid,(float *)cptr);
+		}
+		break;
+	case S3D_P_C_SCALE:
+		if (length&gt;=8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			obj_scale(p,oid,*((float *)cptr));
+		}
+		break;
+	case S3D_P_MCP_FOCUS:
+		if ((p-&gt;id==MCP) &amp;&amp; (length==4)) {
+			oid=ntohl(*((uint32_t *)cptr));
+			mcp_focus(oid);
+		}
+		break;
+	default:
+		s3dprintf(LOW,&quot;don't know this command (%d)&quot;,command);
+	}
 	return(0);
 }
 /*  this pushes some buffer out on the wire... */
 int prot_com_out(struct t_process *p, uint8_t opcode, uint8_t *buf, uint16_t length)
 {
 	uint8_t *ptr;
-	if (p-&gt;con_type!=CON_NULL)
-	{
-		*(obuf)=opcode; 
+	if (p-&gt;con_type!=CON_NULL) {
+		*(obuf)=opcode;
 		ptr=obuf+1;
 		*((uint16_t *) ptr)=htons(length);
 		if (length)
 			memcpy(obuf+3,buf,length);
-		if (n_writen(p,obuf,length+3)&lt;0)
-		{
+		if (n_writen(p,obuf,length+3)&lt;0) {
 			s3dprintf(LOW,&quot;prot_com_out():n_writen(): connection seems to be dead (pid %d)&quot;, p-&gt;id);
 			process_del(p-&gt;id);
 		}

Modified: trunk/server/proto.h
===================================================================
--- trunk/server/proto.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/proto.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * proto.h
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,150 +35,150 @@
 /*  */
 /*  every command is 1 byte long, arguments differ. */
 #define S3D_P_C_INIT			1
-			/*  max 256b: 	name */
+/*  max 256b: 	name */
 #define S3D_P_C_QUIT			2  /*  no argument */
 
 #define S3D_P_C_NEW_OBJ			3  /*  add a new object */
-			 /*  return: 4b:	object id  */
+/*  return: 4b:	object id  */
 #define S3D_P_C_DEL_OBJ			4
-			 /*  4b:			object id */
+/*  4b:			object id */
 #define S3D_P_C_CLONE			5
-			 /*  4b:			object id */
-			 /*  return: 4b: object id */
-			 /*  if 8b: 		 */
-			 /*  4b:			object id */
-			 /*  4b:			target oid */
+/*  4b:			object id */
+/*  return: 4b: object id */
+/*  if 8b: 		 */
+/*  4b:			object id */
+/*  4b:			target oid */
 #define S3D_P_C_LINK			6
-			 /*  if 4b: */
-			 /*  4b:		oid (for unlink) */
-			 /*  if 8b: */
-			 /*  4b:		oid from */
-			 /*  4b:		oid to */
+/*  if 4b: */
+/*  4b:		oid (for unlink) */
+/*  if 8b: */
+/*  4b:		oid from */
+/*  4b:		oid to */
 #define S3D_P_C_PUSH_LINE		7
-			 /*  4b: 		object id */
-			 /*  n*3d		from vertex, to vertex, color */
+/*  4b: 		object id */
+/*  n*3d		from vertex, to vertex, color */
 #define S3D_P_C_PUSH_VERTEX		8
-			 /*  4b:		object id */
-			 /*  n*3f:	vertexes, each with x,y,z in float */
+/*  4b:		object id */
+/*  n*3f:	vertexes, each with x,y,z in float */
 #define S3D_P_C_PUSH_MAT		9
-			 /*  4b:		object id */
-			 /*  3*4f:	material elements [amb,spec,diff with r,g,b,a] */
+/*  4b:		object id */
+/*  3*4f:	material elements [amb,spec,diff with r,g,b,a] */
 #define S3D_P_C_PUSH_POLY		10
-			 /*  4b:		object id */
+/*  4b:		object id */
 #define S3D_P_C_PUSH_TEX		11
-			 /*  4b: 			object id */
-			 /*  nx(2x2b):	width,height */
+/*  4b: 			object id */
+/*  nx(2x2b):	width,height */
 #define S3D_P_C_DEL_VERTEX		12
-			 /*  4b:		object id */
-			 /*  4b:		number */
+/*  4b:		object id */
+/*  4b:		number */
 #define S3D_P_C_DEL_POLY		13
-			 /*  4b:		object id */
-			 /*  4b:		number */
+/*  4b:		object id */
+/*  4b:		number */
 #define S3D_P_C_DEL_MAT			14
-			 /*  4b:		object id */
-			 /*  4b:		number */
+/*  4b:		object id */
+/*  4b:		number */
 #define S3D_P_C_DEL_TEX			15
-			 /*  4b:		object id */
-			 /*  4b:		number */
+/*  4b:		object id */
+/*  4b:		number */
 #define S3D_P_C_PEP_POLY_NORMAL	16
-			 /*  4b:		object id */
-			 /*  n*9f:		normals (3* x/y/z for each vertex of the poly) */
+/*  4b:		object id */
+/*  n*9f:		normals (3* x/y/z for each vertex of the poly) */
 #define S3D_P_C_PEP_POLY_TEXC	17
-			 /*  4b:		object id */
-			 /*  n*6f		poly texture coordinates (3* u/v for each vertex of the poly) */
+/*  4b:		object id */
+/*  n*6f		poly texture coordinates (3* u/v for each vertex of the poly) */
 #define S3D_P_C_PEP_MAT			18
-			 /*  4b:		object id */
-			 /*  3*4f:		material elements [amb,spec,diff with r,g,b,a] */
+/*  4b:		object id */
+/*  3*4f:		material elements [amb,spec,diff with r,g,b,a] */
 #define S3D_P_C_PEP_MAT_TEX		19
-			 /*  4b:		object id */
-			 /*  4b:		texture index references */
+/*  4b:		object id */
+/*  4b:		texture index references */
 #define S3D_P_C_PEP_VERTEX		20
-			 /*  4b:		object id */
-			 /*  n*3f:	vertexes, each with x,y,z in float */
+/*  4b:		object id */
+/*  n*3f:	vertexes, each with x,y,z in float */
 #define S3D_P_C_PEP_LINE		21
-			 /* 4b:			object id */
-			 /* n*3u:		line information (from,to,color)*/
+/* 4b:			object id */
+/* n*3u:		line information (from,to,color)*/
 #define S3D_P_C_DEL_LINE		22
-			 /*  4b:		object id */
-			 /*  4b:		number */
+/*  4b:		object id */
+/*  4b:		number */
 #define S3D_P_C_PEP_LINE_NORMAL	23
-			 /*  4b:		object id */
-			 /*  n*6f:		normals (2* x/y/z for each vertex of the line) */
+/*  4b:		object id */
+/*  n*6f:		normals (2* x/y/z for each vertex of the line) */
 #define S3D_P_C_LOAD_POLY_NORMAL	24
-			 /*  4b:		object id */
-			 /*  4b:		position */
-			 /*  n*9f:	normals (3* x/y/z for each vertex of the poly) */
+/*  4b:		object id */
+/*  4b:		position */
+/*  n*9f:	normals (3* x/y/z for each vertex of the poly) */
 #define S3D_P_C_LOAD_POLY_TEXC	25
-			 /*  4b:		object id */
-			 /*  4b:		position */
-			 /*  n*6f		poly texture coordinates (3* u/v for each vertex of the poly) */
+/*  4b:		object id */
+/*  4b:		position */
+/*  n*6f		poly texture coordinates (3* u/v for each vertex of the poly) */
 #define S3D_P_C_LOAD_MAT		26
-			 /*  4b:		object id */
-			 /*  4b:		position */
-			 /*  3*4f:	material elements [amb,spec,diff with r,g,b,a] */
+/*  4b:		object id */
+/*  4b:		position */
+/*  3*4f:	material elements [amb,spec,diff with r,g,b,a] */
 #define S3D_P_C_LOAD_TEX		28
-			 /*  4b:		object id */
-			 /*  4b:		texture number */
-			 /*  4*2b:	xpos,ypos,width,height */
-			 /*  n*2b:	pixbuf (16bit) */
+/*  4b:		object id */
+/*  4b:		texture number */
+/*  4*2b:	xpos,ypos,width,height */
+/*  n*2b:	pixbuf (16bit) */
 #define S3D_P_C_LOAD_MAT_TEX	29
-			 /*  4b:		object id */
-			 /*  4b:		texture index references */
+/*  4b:		object id */
+/*  4b:		texture index references */
 #define S3D_P_C_LOAD_LINE_NORMAL 30
-			 /*  4b:		object id */
-			 /*  4b:		position */
-			 /*  n*6f:		normals (2* x/y/z for each vertex of the line) */
+/*  4b:		object id */
+/*  4b:		position */
+/*  n*6f:		normals (2* x/y/z for each vertex of the line) */
 
 
 #define S3D_P_C_TOGGLE_FLAGS 	32
-			 /*  4b:		object id */
-			 /*  1b:		type  */
-			 /*  4b:		flags */
+/*  4b:		object id */
+/*  1b:		type  */
+/*  4b:		flags */
 #define S3D_P_C_TRANSLATE 		33
-			 /*  4b:		object id */
-			 /*  3f:		position */
+/*  4b:		object id */
+/*  3f:		position */
 #define S3D_P_C_ROTATE			34
-			 /*  4b:		object id */
-			 /*  3f:		rotation angle over x,y,z axis */
+/*  4b:		object id */
+/*  3f:		rotation angle over x,y,z axis */
 #define S3D_P_C_SCALE			35
-			 /*  4b: 		object id */
-			 /*  1f:		scale */
+/*  4b: 		object id */
+/*  1f:		scale */
 #define S3D_P_C_GET_SIZE		36
-			   /*  4b: object id */
+/*  4b: object id */
 #define S3D_P_MCP_FOCUS			66		 /*  set the app which should get the keystrokes etc */
-			 /*  4b:		object id/pid */
-			 /*  */
-			 /*  */
-			 /*   */
+/*  4b:		object id/pid */
+/*  */
+/*  */
+/*   */
 #define S3D_P_MCP_OBJECT	67
-			 /*  4b: 		oid */
-			 /*  3*f:		translate */
-			 /*  ... ? */
-			 /*  max 256b:name */
+/*  4b: 		oid */
+/*  3*f:		translate */
+/*  ... ? */
+/*  max 256b:name */
 #define S3D_P_MCP_DEL_OBJECT 68
 
 #define S3D_P_S_INIT	1
-			 /*  1b: acknowledged */
-			 /*  3b: version,major,minor */
-			 /*  description string */
+/*  1b: acknowledged */
+/*  3b: version,major,minor */
+/*  description string */
 #define S3D_P_S_QUIT	2
 #define S3D_P_S_CLICK	3
-			 /*  4b: oid */
+/*  4b: oid */
 #define	S3D_P_S_KEY		4
-			 /*  2b: button */
-			 /*  2b: unicode translation */
-			 /*  2b: modifier information */
-			 /*  2b: state */
+/*  2b: button */
+/*  2b: unicode translation */
+/*  2b: modifier information */
+/*  2b: state */
 #define S3D_P_S_MBUTTON	5
-             /*  1b: button number */
-             /*  2b: butotn state */
+/*  1b: button number */
+/*  2b: butotn state */
 #define S3D_P_S_NEWOBJ	16
-			 /*  4b: oid */
+/*  4b: oid */
 
 #define S3D_P_S_OINFO	32
-			 /*  4b: 		oid */
-			 /*  3*f:		translate */
-			 /*  3*f:		rotate */
-			 /*  1*f:		scale */
-			 /*  1*f:		radius */
-			 /*  max 256b:name */
+/*  4b: 		oid */
+/*  3*f:		translate */
+/*  3*f:		rotate */
+/*  1*f:		scale */
+/*  1*f:		radius */
+/*  max 256b:name */

Modified: trunk/server/shm.c
===================================================================
--- trunk/server/shm.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/shm.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * shm.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -34,9 +34,9 @@
 #include &lt;signal.h&gt;	/* signal() */
 #include &lt;errno.h&gt;	/* errno */
 #ifdef WIN32  /*  sohn wars */
-	#include &lt;winsock2.h&gt;
+#include &lt;winsock2.h&gt;
 #else  /* sohn wars */
-	#include &lt;netinet/in.h&gt;  /* ntohs(),htons(),htonl(),ntohl() */
+#include &lt;netinet/in.h&gt;  /* ntohs(),htons(),htonl(),ntohl() */
 #endif   /*  sohn wars */
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
@@ -63,7 +63,7 @@
 {
 	FILE *fp;
 	key_t key;
-	
+
 	/* create an empty token file */
 	fp=fopen(ftoken,&quot;w&quot;);
 	fclose(fp);
@@ -87,7 +87,7 @@
 		return(1);
 	}
 	shm_new_comblock(data);
-	return(0);	
+	return(0);
 }
 void comblock_init(struct t_shmcb *p_cb)
 {
@@ -137,7 +137,7 @@
 	data[1]=mycb-&gt;key_stoc;
 	mycb-&gt;idle=0;
 	s3dprintf(LOW,&quot;shm_open_comblock():data: %08x, %08x&quot;,data[0],data[1]);
-	return(0);	
+	return(0);
 }
 
 int shm_quit()
@@ -145,14 +145,13 @@
 	/* detach from the segment: */
 	s3dprintf(LOW,&quot;shm_quit()...&quot;);
 	unlink(ftoken);
-	if (data!=NULL)
-	{
+	if (data!=NULL) {
 		data[0]=data[1]=0;
 		data=0;
 		s3dprintf(MED,&quot;shm_quit():removing init block&quot;);
-		if (shmdt(data) == -1) 
+		if (shmdt(data) == -1)
 			errn(&quot;shm_quit():shmdt()&quot;,errno);
-		if (shmctl(shmid, IPC_RMID, NULL) == -1) 
+		if (shmctl(shmid, IPC_RMID, NULL) == -1)
 			errn(&quot;shm_quit():shmctl()&quot;,errno);
 	}
 	return(0);
@@ -161,13 +160,13 @@
 {
 	s3dprintf(MED,&quot;shm_remove(): removing pid %d&quot;,p-&gt;id);
 	s3dprintf(MED,&quot;shm_remove():freeing keys: %08x, %08x&quot;,p-&gt;shmsock.key_ctos,p-&gt;shmsock.key_stoc);
-	if (shmdt(p-&gt;shmsock.data_ctos) == -1) 
+	if (shmdt(p-&gt;shmsock.data_ctos) == -1)
 		errn(&quot;shm_rmove():shmdt()&quot;,errno);
-	if (shmctl(p-&gt;shmsock.shmid_ctos, IPC_RMID, NULL) == -1) 
+	if (shmctl(p-&gt;shmsock.shmid_ctos, IPC_RMID, NULL) == -1)
 		errn(&quot;shm_quit():shmctl()&quot;,errno);
-	if (shmdt(p-&gt;shmsock.data_stoc) == -1) 
+	if (shmdt(p-&gt;shmsock.data_stoc) == -1)
 		errn(&quot;shm_quit():shmdt()&quot;,errno);
-	if (shmctl(p-&gt;shmsock.shmid_stoc, IPC_RMID, NULL) == -1) 
+	if (shmctl(p-&gt;shmsock.shmid_stoc, IPC_RMID, NULL) == -1)
 		errn(&quot;shm_quit():shmctl()&quot;,errno);
 	return(0);
 }
@@ -179,20 +178,18 @@
 	struct buf_t 		*dai; /* data in, data out */
 	struct t_process	*new_p;
 	struct shmid_ds		 d;
-/*	do*/ {
-/*		found=0;*/
+	/*	do*/
+	{
+		/*		found=0;*/
 		turn=1;
-		for (i=0;i&lt;procs_n;i++)
-		{
+		for (i=0;i&lt;procs_n;i++) {
 #ifdef G_SDL
 			SDL_SetTimer(100,(SDL_TimerCallback) net_turn_off);
 #endif
-			if (procs_p[i].con_type==CON_SHM)
-			{
+			if (procs_p[i].con_type==CON_SHM) {
 				dai=(struct buf_t *) procs_p[i].shmsock.data_ctos;
-				if (dai-&gt;start!=dai-&gt;end)
-				{
-/*					found=1;*/
+				if (dai-&gt;start!=dai-&gt;end) {
+					/*					found=1;*/
 					procs_p[i].shmsock.idle=0;
 					shm_prot_com_in(&amp;procs_p[i]);
 					if (turn)
@@ -202,11 +199,9 @@
 						turn=1; /* don't decrease, it's next connections turn */
 					}
 				} else {
-					if (procs_p[i].shmsock.idle++&gt;MAX_IDLE)
-					{ /* maybe the function timed out somehow ...? let's check ...*/
+					if (procs_p[i].shmsock.idle++&gt;MAX_IDLE) { /* maybe the function timed out somehow ...? let's check ...*/
 						shmctl(procs_p[i].shmsock.shmid_ctos,IPC_STAT,&amp;d);
-						if (d.shm_nattch==1) /* we're all alone ... remove it!! */
-						{
+						if (d.shm_nattch==1) { /* we're all alone ... remove it!! */
 							s3dprintf(MED,&quot;client [%s] detached, removing ... &quot;,procs_p[i].name);
 							process_del(procs_p[i].id);
 						} else {
@@ -220,8 +215,7 @@
 		SDL_SetTimer(0,NULL);
 #endif
 	} /*while (found);*/
-	if ((data[0]==0) &amp;&amp; (data[1]==0))
-	{
+	if ((data[0]==0) &amp;&amp; (data[1]==0)) {
 		new_p=process_add();
 		new_p-&gt;con_type=CON_SHM;
 		memcpy(&amp;new_p-&gt;shmsock,&amp;waiting_comblock,sizeof(struct t_shmcb));
@@ -238,38 +232,36 @@
 	struct buf_t *dai;
 	dai=(struct buf_t *)p-&gt;shmsock.data_ctos;
 	if (dai!=NULL)
-/*	if ((pid=get_proc_by_dai( */
-	if (3==shm_readn(dai,ibuf,3))
-	{
-		length=ntohs(*((uint16_t *)((uint8_t *)ibuf+1)));
-		s3dprintf(VLOW,&quot;command %d, length %d&quot;,ibuf[0], length);
-		if (length&gt;0)
-		{
-			shm_readn(dai,ibuf+3,length);	  
+		/*	if ((pid=get_proc_by_dai( */
+		if (3==shm_readn(dai,ibuf,3)) {
+			length=ntohs(*((uint16_t *)((uint8_t *)ibuf+1)));
+			s3dprintf(VLOW,&quot;command %d, length %d&quot;,ibuf[0], length);
+			if (length&gt;0) {
+				shm_readn(dai,ibuf+3,length);
+			}
+			prot_com_in(p,ibuf);
 		}
-		prot_com_in(p,ibuf);
-	}
 	return(0);
 }
 #define SHM_MAXLOOP		20
-static	struct timespec t={0,1000*1000}; /* 1 mili seconds */
+static	struct timespec t= {
+	0,1000*1000
+}; /* 1 mili seconds */
 int shm_writen(struct buf_t *rb,uint8_t *buf, int n)
 {
 	int no_left,no_written,wait=0;
 	no_left = n;
-	while (no_left &gt; 0) 
-    { 
+	while (no_left &gt; 0) {
 		no_written = shm_write(rb,(char *)buf,no_left);
- 		if(no_written &lt;=0)  
+		if (no_written &lt;=0)
 			return(no_written);
 		no_left -= no_written;
 		buf += no_written;
-		if (wait++&gt;SHM_MAXLOOP) 
-		{
+		if (wait++&gt;SHM_MAXLOOP) {
 			s3dprintf(HIGH,&quot;shm_writen():waited too long ...&quot;);
 			return(-1);
-		} 
-		if (wait&gt;10)		nanosleep(&amp;t,NULL); 	
+		}
+		if (wait&gt;10)		nanosleep(&amp;t,NULL);
 	}
 	return(n - no_left);
 }
@@ -277,21 +269,19 @@
 {
 	int no_left,no_read,wait=0;
 	no_left = n;
-	while (no_left &gt; 0) 
-	{ 
+	while (no_left &gt; 0) {
 		no_read = shm_read(rb,(char *)buf,no_left);
-		if(no_read &lt;0)  
+		if (no_read &lt;0)
 			return(no_read);
-		if (no_read == 0) 
+		if (no_read == 0)
 			break;
 		no_left -= no_read;
 		buf += no_read;
-		if (wait++&gt;SHM_MAXLOOP) 
-		{
+		if (wait++&gt;SHM_MAXLOOP) {
 			s3dprintf(HIGH,&quot;shm_readn():waited too long ...&quot;);
 			return(-1);
 		}
-		if (wait&gt;10)		nanosleep(&amp;t,NULL); 	
+		if (wait&gt;10)		nanosleep(&amp;t,NULL);
 	}
 	return(n - no_left);
 }

Modified: trunk/server/shm_ringbuf.c
===================================================================
--- trunk/server/shm_ringbuf.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/shm_ringbuf.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * shm_ringbuf.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -39,31 +39,28 @@
 	data=((char *)rb)+sizeof(struct buf_t);
 	if (e&lt;s) {
 		wrap=1;
-	} 
-	while ((((s+size*(1-wrap))-e) &lt; (n+1))) /* checking free space */
-	{
-		if /*((size*2)&gt;RB_MAX_SIZE)*/ (1)
-		{
+	}
+	while ((((s+size*(1-wrap))-e) &lt; (n+1))) { /* checking free space */
+		if /*((size*2)&gt;RB_MAX_SIZE)*/ (1) {
 			printf(&quot;buffer reached maxsize, no resizing possible&quot;);
 			return(-1);
 		}
-/*		printf(&quot;buffer full!! resizing ... (to size %d)&quot;,(int)size*2);
-		if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
-		{
-			printf(&quot;realloc failed - fatal!!&quot;);
-			return(-1);
-		}
-		if (wrap)
-		{
-			memcpy(data+size,data,e);
-			e+=size;
-			wrap=0;
-		}
-		size=rb-&gt;bufsize=size*2;
-		rb-&gt;end=e;*/
+		/*		printf(&quot;buffer full!! resizing ... (to size %d)&quot;,(int)size*2);
+				if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
+				{
+					printf(&quot;realloc failed - fatal!!&quot;);
+					return(-1);
+				}
+				if (wrap)
+				{
+					memcpy(data+size,data,e);
+					e+=size;
+					wrap=0;
+				}
+				size=rb-&gt;bufsize=size*2;
+				rb-&gt;end=e;*/
 	}
-	if ((e+n)&gt;size)
-	{
+	if ((e+n)&gt;size) {
 		rs=size-e;
 		memcpy(data+e,buf,rs);			/* copy the first part ... */
 		memcpy(data,buf+rs,n-rs); 		/* .. end the rest */
@@ -89,8 +86,7 @@
 	if (e&lt;s) wrap=1;
 	rs=(e+wrap*size-s);
 	mn=(n&gt;rs)?rs:n;
-	if ((wrap) &amp;&amp; (mn&gt;(size-s))) 
-	{
+	if ((wrap) &amp;&amp; (mn&gt;(size-s))) {
 		rs=size-s;	/* size of the first part */
 		memcpy(buf,data+s,rs);
 		memcpy(buf+rs,data,mn-rs);
@@ -104,11 +100,11 @@
 void ringbuf_init(char *data,uint32_t init_size)
 {
 	struct buf_t *ringbuf=(struct buf_t *)data;
-/*	ringbuf=malloc(init_size); */
+	/*	ringbuf=malloc(init_size); */
 	ringbuf-&gt;start=0;
 	ringbuf-&gt;end=0;
 	ringbuf-&gt;bufsize=init_size-RB_OVERHEAD;
-/*	return (ringbuf); */
+	/*	return (ringbuf); */
 }
 
 

Modified: trunk/server/tcp.c
===================================================================
--- trunk/server/tcp.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/tcp.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * tcp.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,19 +27,19 @@
 #include &lt;errno.h&gt;		 /*  errno */
 #include &lt;string.h&gt;		 /*  memset() */
 #ifdef WIN32  /*  sohn wars */
-	#include &lt;winsock2.h&gt;
+#include &lt;winsock2.h&gt;
 #else  /* sohn wars */
-	#include &lt;sys/types.h&gt;   /* fd_set, FD*, socket, accept ... */
-	#include &lt;sys/socket.h&gt;  /* socket, accept ... */
-	#include &lt;sys/select.h&gt;  /* fd_set,FD* */
-	#include &lt;sys/time.h&gt;	 /* fd_set,FD* */
-	#include &lt;netinet/in.h&gt;  /* ntohs(),htons(),htonl(),ntohl() */
-	#include &lt;arpa/inet.h&gt;   /* network */
+#include &lt;sys/types.h&gt;   /* fd_set, FD*, socket, accept ... */
+#include &lt;sys/socket.h&gt;  /* socket, accept ... */
+#include &lt;sys/select.h&gt;  /* fd_set,FD* */
+#include &lt;sys/time.h&gt;	 /* fd_set,FD* */
+#include &lt;netinet/in.h&gt;  /* ntohs(),htons(),htonl(),ntohl() */
+#include &lt;arpa/inet.h&gt;   /* network */
 #endif   /*  sohn wars */
 #include &lt;time.h&gt;		 /*  select() timeval things */
 #include &lt;fcntl.h&gt;		 /*  fcntl(),F_SETOWN */
 #ifndef F_SETOWN /* somehow it is not set with -ansi */
-	#define F_SETOWN	8
+#define F_SETOWN	8
 #endif
 #include &lt;unistd.h&gt;		 /*  read(),write(),getpid(),close() */
 #include &lt;stdlib.h&gt;		 /*  malloc(),free() */
@@ -52,36 +52,36 @@
 int tcp_init()
 {
 	int yes=1;
-	struct sockaddr_in my_addr;   
+	struct sockaddr_in my_addr;
 	s3dprintf(LOW,&quot;server: creating socket&quot;);
 #ifdef WIN32  /*  sohn wars */
 	WSADATA datainfo;
 	if (WSAStartup(257, &amp;datainfo) != 0)
 		errnf(&quot;startup()&quot;, 0);
 #endif  /*  auch sohn */
-   if ((tcp_sockid = socket(AF_INET,SOCK_STREAM,0)) &lt; 0)
-     errnf(&quot;socket()&quot;, errno);
+	if ((tcp_sockid = socket(AF_INET,SOCK_STREAM,0)) &lt; 0)
+		errnf(&quot;socket()&quot;, errno);
 
-   s3dprintf(LOW,&quot;server: binding my local socket&quot;);
-   /*  allow addresses to be reused */
-   /*  this seems to have something to do with servers using one port */
-   if ( setsockopt(tcp_sockid, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int)) == -1 )
-        errn(&quot;setsockopt(...,SO_REUSEADDR...)&quot;,errno );
-   memset((char *) &amp;my_addr,0,sizeof(my_addr));
-   my_addr.sin_family = AF_INET;
-   my_addr.sin_port = htons(S3D_PORT);
-   my_addr.sin_addr.s_addr = htons(INADDR_ANY);
-   if (bind(tcp_sockid ,(struct sockaddr *) &amp;my_addr,sizeof(my_addr)) &lt; 0)
+	s3dprintf(LOW,&quot;server: binding my local socket&quot;);
+	/*  allow addresses to be reused */
+	/*  this seems to have something to do with servers using one port */
+	if ( setsockopt(tcp_sockid, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int)) == -1 )
+		errn(&quot;setsockopt(...,SO_REUSEADDR...)&quot;,errno );
+	memset((char *) &amp;my_addr,0,sizeof(my_addr));
+	my_addr.sin_family = AF_INET;
+	my_addr.sin_port = htons(S3D_PORT);
+	my_addr.sin_addr.s_addr = htons(INADDR_ANY);
+	if (bind(tcp_sockid ,(struct sockaddr *) &amp;my_addr,sizeof(my_addr)) &lt; 0)
 		errnf(&quot;bind()&quot;,errno);
-   if (listen(tcp_sockid,5) &lt; 0)	
+	if (listen(tcp_sockid,5) &lt; 0)
 		errnf(&quot;listen()&quot;,errno);
 #ifdef SIGS
-   if ( fcntl(tcp_sockid, F_SETFL, O_ASYNC | O_NONBLOCK) &lt; 0 )
+	if ( fcntl(tcp_sockid, F_SETFL, O_ASYNC | O_NONBLOCK) &lt; 0 )
 		errnf(&quot;fcntl()&quot;,errno);
-   if ( fcntl(tcp_sockid, F_SETOWN, getpid()) &lt; 0 )
+	if ( fcntl(tcp_sockid, F_SETOWN, getpid()) &lt; 0 )
 		errnf(&quot;fcntl()&quot;,errno);
 #endif
-   return(0);
+	return(0);
 
 }
 int tcp_quit()
@@ -98,43 +98,39 @@
 	fd_set				 fs_port; 	 /*  filedescriptor set for listening port(s) */
 	int 				 newsd; 	 /*  new socket descriptor */
 	struct timeval		 tv;		 /*  time structure */
-/*	struct t_con 		*new_con;	*/ /*  pointer to new connection */
+	/*	struct t_con 		*new_con;	*/ /*  pointer to new connection */
 	struct t_process	*new_p;		 /*  pointer to new process */
 	struct sockaddr		 client_addr;  /*  new client's address */
 	socklen_t			 clilen=sizeof(client_addr);		 /*  length of client's address */
-	 /* int i; */
-    FD_ZERO(&amp;fs_port);
-  	FD_SET(tcp_sockid,&amp;fs_port);
+	/* int i; */
+	FD_ZERO(&amp;fs_port);
+	FD_SET(tcp_sockid,&amp;fs_port);
 select_again:
 	tv.tv_sec=tv.tv_usec=0;
-	if (select(FD_SETSIZE, &amp;fs_port, NULL,NULL,&amp;tv)&lt;0)
-	{
-		if (errno==EINTR)  /*  interruption by some evil signal, just do again :) */
-		{
+	if (select(FD_SETSIZE, &amp;fs_port, NULL,NULL,&amp;tv)&lt;0) {
+		if (errno==EINTR) { /*  interruption by some evil signal, just do again :) */
 			errn(&quot;tcp_pollport():select()&quot;,errno);
 			goto select_again;  /*  oh no, a goto!! that's evil */
 		} else
 			errn(&quot;tcp_pollport():select()&quot;,errno);
-	}
-	else 
-	if (FD_ISSET(tcp_sockid,&amp;fs_port)) {  /* redundant, I guess */
-		s3dprintf(HIGH,&quot;select(): new connection!!&quot;);
-        if ((newsd = accept(tcp_sockid ,(struct sockaddr *) &amp;client_addr,&amp;clilen)) &lt; 0)
-			 errn(&quot;accept()&quot;,errno);
-		else 
-		{
+	} else
+		if (FD_ISSET(tcp_sockid,&amp;fs_port)) {  /* redundant, I guess */
+			s3dprintf(HIGH,&quot;select(): new connection!!&quot;);
+			if ((newsd = accept(tcp_sockid ,(struct sockaddr *) &amp;client_addr,&amp;clilen)) &lt; 0)
+				errn(&quot;accept()&quot;,errno);
+			else {
 #ifdef SIGS
-		   if ( fcntl(newsd, F_SETFL, O_ASYNC ) &lt; 0 )
-				errnf(&quot;fcntl()&quot;,errno);
-		   if ( fcntl(newsd, F_SETOWN, getpid()) &lt; 0 )
-				errnf(&quot;fcntl()&quot;,errno);
+				if ( fcntl(newsd, F_SETFL, O_ASYNC ) &lt; 0 )
+					errnf(&quot;fcntl()&quot;,errno);
+				if ( fcntl(newsd, F_SETOWN, getpid()) &lt; 0 )
+					errnf(&quot;fcntl()&quot;,errno);
 #endif
-			new_p=process_add();
-			new_p-&gt;con_type=CON_TCP;
-			new_p-&gt;sockid=newsd;
-			s3dprintf(HIGH,&quot;registered new connection %d as pid %d&quot;,new_p-&gt;sockid, new_p-&gt;id);
+				new_p=process_add();
+				new_p-&gt;con_type=CON_TCP;
+				new_p-&gt;sockid=newsd;
+				s3dprintf(HIGH,&quot;registered new connection %d as pid %d&quot;,new_p-&gt;sockid, new_p-&gt;id);
+			}
 		}
-	}
 	return(0);
 }
 extern struct t_process *procs_p;
@@ -153,43 +149,35 @@
 		FD_ZERO(&amp;fs_proc);
 		unfinished=0;
 		n=0;
-		for (i=off;i&lt;procs_n;i++)
-		{
+		for (i=off;i&lt;procs_n;i++) {
 			p=&amp;procs_p[i];
-			if (p-&gt;con_type==CON_TCP)
-			{
+			if (p-&gt;con_type==CON_TCP) {
 				FD_SET(p-&gt;sockid,&amp;fs_proc);
 				n++;
-				if (n&gt;=FD_SETSIZE)	/* don't overflow the setsize! */
-				{
+				if (n&gt;=FD_SETSIZE) {	/* don't overflow the setsize! */
 					off=i;
 					unfinished=1;
 					break;
 				}
 			}
 		}
-		 /*  maybe having a global fd_set for all the processes would have been better */
-		 /*  than generating them new in every poll. to be optimized... */
-select_again_poll:	
+		/*  maybe having a global fd_set for all the processes would have been better */
+		/*  than generating them new in every poll. to be optimized... */
+select_again_poll:
 		tv.tv_sec=tv.tv_usec=0;
-		if (select(FD_SETSIZE, &amp;fs_proc, NULL,NULL,&amp;tv) ==-1) 
-		{
-			if (errno==EINTR)
-			{
-				errn(&quot;tcp_pollproc():select()&quot;,errno); 
+		if (select(FD_SETSIZE, &amp;fs_proc, NULL,NULL,&amp;tv) ==-1) {
+			if (errno==EINTR) {
+				errn(&quot;tcp_pollproc():select()&quot;,errno);
 				goto select_again_poll;
 			} else {
-				errn(&quot;tcp_pollproc():select()&quot;,errno); 
+				errn(&quot;tcp_pollproc():select()&quot;,errno);
 			}
 		} else {
-			 /*  data is available */
-			for (i=0;i&lt;procs_n;i++)
-			{
+			/*  data is available */
+			for (i=0;i&lt;procs_n;i++) {
 				p=&amp;procs_p[i];
-				if (p-&gt;con_type==CON_TCP)
-				{
-					if (FD_ISSET(p-&gt;sockid,&amp;fs_proc))
-					{
+				if (p-&gt;con_type==CON_TCP) {
+					if (FD_ISSET(p-&gt;sockid,&amp;fs_proc)) {
 						FD_CLR(p-&gt;sockid,&amp;fs_proc);  /*  clear it from the fd */
 						tcp_prot_com_in(p);
 						found=1;
@@ -204,14 +192,12 @@
 int tcp_prot_com_in(struct t_process *p)
 {
 	uint16_t	length;
-	if (3==tcp_readn(p-&gt;sockid, ibuf,3))
-	{
+	if (3==tcp_readn(p-&gt;sockid, ibuf,3)) {
 		length=ntohs(*((uint16_t *)((uint8_t *)ibuf+1)));
 		s3dprintf(VLOW,&quot;command %d, length %d&quot;,ibuf[0], length);
-		if (length&gt;0)
-		{
+		if (length&gt;0) {
 			tcp_readn(p-&gt;sockid,ibuf+3,length);	  /*  uint16_t is limited to 65536, so  */
-										 /*  length can't be bigger than that ... lucky */
+			/*  length can't be bigger than that ... lucky */
 		}
 		prot_com_in(p,ibuf);
 	} else {
@@ -222,33 +208,35 @@
 }
 /*  shamelessly ripped from simple ftp server */
 int tcp_readn(int sock, uint8_t *str,int s)
-{         int no_left,no_read;
-          no_left = s;
-          while (no_left &gt; 0) 
-                     { no_read = read(sock,str,no_left);
-                       if(no_read &lt;0) {
-     						errn(&quot;read()&quot;, errno); 
-							return(no_read);
-					   }
-                       if (no_read == 0) break;
-                       no_left -= no_read;
-                       str += no_read;
-                     }
-          return(s - no_left);
+{
+	int no_left,no_read;
+	no_left = s;
+	while (no_left &gt; 0) {
+		no_read = read(sock,str,no_left);
+		if (no_read &lt;0) {
+			errn(&quot;read()&quot;, errno);
+			return(no_read);
+		}
+		if (no_read == 0) break;
+		no_left -= no_read;
+		str += no_read;
+	}
+	return(s - no_left);
 }
 int tcp_writen(int sock, uint8_t *str,int s)
-{         int no_left,no_written;
-          no_left = s;
-          while (no_left &gt; 0) 
-                     { no_written = write(sock,str,no_left);
-                       if(no_written &lt;=0) {
-							errn(&quot;write()&quot;,errno);
-							return(no_written);
-					   }
-                       no_left -= no_written;
-                       str += no_written;
-                     }
-          return(s - no_left);
+{
+	int no_left,no_written;
+	no_left = s;
+	while (no_left &gt; 0) {
+		no_written = write(sock,str,no_left);
+		if (no_written &lt;=0) {
+			errn(&quot;write()&quot;,errno);
+			return(no_written);
+		}
+		no_left -= no_written;
+		str += no_written;
+	}
+	return(s - no_left);
 }
 int tcp_remove(int sock)
 {

Modified: trunk/server/user.c
===================================================================
--- trunk/server/user.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/user.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * user.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,31 +27,39 @@
 static int ox,oy;
 static int pressed;
 int but=-1;
-int user_init() {
-	switch (frame_mode)
-	{
+int user_init()
+{
+	switch (frame_mode) {
 #ifdef G_GLUT
-		case FRAME_GLUT:user_init_glut();break;
+	case FRAME_GLUT:
+		user_init_glut();
+		break;
 #endif
 #ifdef G_SDL
-    	case FRAME_SDL:user_init_sdl();break;
+	case FRAME_SDL:
+		user_init_sdl();
+		break;
 #endif
-		default:return(-1);
+	default:
+		return(-1);
 	}
 	pressed=0;
 	ox=oy=0xFFFFFF;
 	return(0);
 }
-int user_main() {
-	switch (frame_mode)
-	{
+int user_main()
+{
+	switch (frame_mode) {
 #ifdef G_GLUT
-		case FRAME_GLUT:return(0);  /*  glut uses callback functions */
+	case FRAME_GLUT:
+		return(0);  /*  glut uses callback functions */
 #endif
 #ifdef G_SDL
-    	case FRAME_SDL:user_main_sdl();
+	case FRAME_SDL:
+		user_main_sdl();
 #endif
-		default:return(0);
+	default:
+		return(0);
 	}
 	return(0);
 }
@@ -59,71 +67,69 @@
 {
 	event_key_pressed(key,unicode,mod,state);
 }
-void user_mouse(int button, int state, int x, int y) 
+void user_mouse(int button, int state, int x, int y)
 {
-	switch (state)
-	{
-		case 0: /*  mouse_down ... */
-			switch (button)
-			{
-				case 0:
-					graphics_pick_obj(x,y);	
-					break;
-				case 1:
-					if ((ox!=0xFFFFFF) &amp;&amp; (oy!=0xFFFFFF))
-						navi_pos(ox-x,oy-y);
-					break;
-				case 2:
-					if ((ox!=0xFFFFFF) &amp;&amp; (oy!=0xFFFFFF))
-						navi_rot(ox-x,oy-y);
-					break;
-				case 3:
-					navi_fwd();
-					break;
-				case 4:
-					navi_back();
-					break;
-				default:
-					s3dprintf(VLOW,&quot;button is ... %d&quot;, button);
-			}
-			ox=x;
-			oy=y;
-			event_mbutton_clicked(button,state);
+	switch (state) {
+	case 0: /*  mouse_down ... */
+		switch (button) {
+		case 0:
+			graphics_pick_obj(x,y);
 			break;
-		case 1:  /*  mouse up */
-			ox=oy=0xFFFFFF;
-			event_mbutton_clicked(button,state);
-	/*		s3dprintf(LOW,&quot;state is: %d,button is %d&quot;,state,button);*/
+		case 1:
+			if ((ox!=0xFFFFFF) &amp;&amp; (oy!=0xFFFFFF))
+				navi_pos(ox-x,oy-y);
 			break;
-		case 2:	 /*  mouse still down */
-			switch (button)
-			{
-				case 1:
-					if ((ox!=0xFFFFFF) &amp;&amp; (oy!=0xFFFFFF))
-						navi_pos(ox-x,oy-y);
-					break;
-				case 2:
-					if ((ox!=0xFFFFFF) &amp;&amp; (oy!=0xFFFFFF))
-						navi_rot(ox-x,oy-y);
-					break;
-				case 3:
-					navi_fwd();
-					break;
-				case 4:
-					navi_back();
-					break;
-				default:
-					s3dprintf(VLOW,&quot;button is ... %d&quot;, button);
-			}
-			ox=x;
-			oy=y;
+		case 2:
+			if ((ox!=0xFFFFFF) &amp;&amp; (oy!=0xFFFFFF))
+				navi_rot(ox-x,oy-y);
 			break;
+		case 3:
+			navi_fwd();
+			break;
+		case 4:
+			navi_back();
+			break;
+		default:
+			s3dprintf(VLOW,&quot;button is ... %d&quot;, button);
+		}
+		ox=x;
+		oy=y;
+		event_mbutton_clicked(button,state);
+		break;
+	case 1:  /*  mouse up */
+		ox=oy=0xFFFFFF;
+		event_mbutton_clicked(button,state);
+		/*		s3dprintf(LOW,&quot;state is: %d,button is %d&quot;,state,button);*/
+		break;
+	case 2:	 /*  mouse still down */
+		switch (button) {
+		case 1:
+			if ((ox!=0xFFFFFF) &amp;&amp; (oy!=0xFFFFFF))
+				navi_pos(ox-x,oy-y);
+			break;
+		case 2:
+			if ((ox!=0xFFFFFF) &amp;&amp; (oy!=0xFFFFFF))
+				navi_rot(ox-x,oy-y);
+			break;
+		case 3:
+			navi_fwd();
+			break;
+		case 4:
+			navi_back();
+			break;
+		default:
+			s3dprintf(VLOW,&quot;button is ... %d&quot;, button);
+		}
+		ox=x;
+		oy=y;
+		break;
 	}
 	but=button;
 	/* mouse changed? */
 	ptr_move(x,y);
 }
-int user_quit() {
+int user_quit()
+{
 	return(0);
 }
 

Modified: trunk/server/user_glut.c
===================================================================
--- trunk/server/user_glut.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/user_glut.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * user_glut.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -38,7 +38,7 @@
 	glutKeyboardFunc (keyboard);
 	glutSpecialFunc (special);
 	glutMouseFunc (user_mouse);
-    glutMotionFunc(mouse_motion);
+	glutMotionFunc(mouse_motion);
 	glutPassiveMotionFunc(passive_mouse_motion);
 	return(0);
 }
@@ -51,30 +51,73 @@
 void special(int skey, int x, int y)
 {
 	uint16_t mkey;
-	switch (skey) /* handle special keys */
-	{
-		case GLUT_KEY_F1:		mkey=S3DK_F1;	break;
-		case GLUT_KEY_F2:		mkey=S3DK_F2;	break;
-		case GLUT_KEY_F3:		mkey=S3DK_F3;	break;
-		case GLUT_KEY_F4:		mkey=S3DK_F4;	break;
-		case GLUT_KEY_F5:		mkey=S3DK_F5;	break;
-		case GLUT_KEY_F6: 		mkey=S3DK_F6;	break;
-		case GLUT_KEY_F7:		mkey=S3DK_F7;	break;
-		case GLUT_KEY_F8:		mkey=S3DK_F8;	break;
-		case GLUT_KEY_F9: 		mkey=S3DK_F9;	break;
-		case GLUT_KEY_F10:		mkey=S3DK_F10;	break;
-		case GLUT_KEY_F11: 		mkey=S3DK_F11;	break;
-		case GLUT_KEY_F12: 		mkey=S3DK_F12;	break;
-		case GLUT_KEY_LEFT: 	mkey=S3DK_LEFT;	break;
-		case GLUT_KEY_RIGHT: 	mkey=S3DK_RIGHT;break;
-		case GLUT_KEY_UP: 		mkey=S3DK_UP;	break;
-		case GLUT_KEY_DOWN: 	mkey=S3DK_DOWN;	break;
-		case GLUT_KEY_PAGE_UP:	mkey=S3DK_PAGEUP;break;
-		case GLUT_KEY_PAGE_DOWN:mkey=S3DK_PAGEDOWN;break;
-		case GLUT_KEY_HOME:		mkey=S3DK_HOME;break;
-		case GLUT_KEY_END: 		mkey=S3DK_END;break;
-		case GLUT_KEY_INSERT: 	mkey=S3DK_INSERT;break;
-		default: 				mkey=skey; break;
+	switch (skey) { /* handle special keys */
+	case GLUT_KEY_F1:
+		mkey=S3DK_F1;
+		break;
+	case GLUT_KEY_F2:
+		mkey=S3DK_F2;
+		break;
+	case GLUT_KEY_F3:
+		mkey=S3DK_F3;
+		break;
+	case GLUT_KEY_F4:
+		mkey=S3DK_F4;
+		break;
+	case GLUT_KEY_F5:
+		mkey=S3DK_F5;
+		break;
+	case GLUT_KEY_F6:
+		mkey=S3DK_F6;
+		break;
+	case GLUT_KEY_F7:
+		mkey=S3DK_F7;
+		break;
+	case GLUT_KEY_F8:
+		mkey=S3DK_F8;
+		break;
+	case GLUT_KEY_F9:
+		mkey=S3DK_F9;
+		break;
+	case GLUT_KEY_F10:
+		mkey=S3DK_F10;
+		break;
+	case GLUT_KEY_F11:
+		mkey=S3DK_F11;
+		break;
+	case GLUT_KEY_F12:
+		mkey=S3DK_F12;
+		break;
+	case GLUT_KEY_LEFT:
+		mkey=S3DK_LEFT;
+		break;
+	case GLUT_KEY_RIGHT:
+		mkey=S3DK_RIGHT;
+		break;
+	case GLUT_KEY_UP:
+		mkey=S3DK_UP;
+		break;
+	case GLUT_KEY_DOWN:
+		mkey=S3DK_DOWN;
+		break;
+	case GLUT_KEY_PAGE_UP:
+		mkey=S3DK_PAGEUP;
+		break;
+	case GLUT_KEY_PAGE_DOWN:
+		mkey=S3DK_PAGEDOWN;
+		break;
+	case GLUT_KEY_HOME:
+		mkey=S3DK_HOME;
+		break;
+	case GLUT_KEY_END:
+		mkey=S3DK_END;
+		break;
+	case GLUT_KEY_INSERT:
+		mkey=S3DK_INSERT;
+		break;
+	default:
+		mkey=skey;
+		break;
 	}
 	s3dprintf(MED,&quot;special(): %d -&gt; %d&quot;,skey,mkey);
 	user_key(mkey,0,0,0);

Modified: trunk/server/user_sdl.c
===================================================================
--- trunk/server/user_sdl.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/user_sdl.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * user_sdl.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -28,75 +28,85 @@
 /*  this is done right now by SDL-polling */
 
 extern int SDLFlags;
-int user_init_sdl() {
+int user_init_sdl()
+{
 	SDL_EnableUNICODE(1);
 	return(0);
 }
-int user_main_sdl() {
-  SDL_Event 	event;
-  SDL_Surface *GLwin = NULL;
-  while (SDL_PollEvent(&amp;event)) 
-  {
-	switch (event.type)
-	{
-		case SDL_MOUSEMOTION: 
-/* 			s3dprintf(VLOW,&quot;Current mouse position is: (%d, %d),button %d&quot;, event.motion.x, event.motion.y,event.button.button); */
-			 switch (event.button.button)
-			 {
-			 	case SDL_BUTTON_LEFT:
-			 		user_mouse(0,2,event.motion.x,event.motion.y);break;
-			 	case SDL_BUTTON_MIDDLE:
-			 		user_mouse(1,2,event.motion.x,event.motion.y);break;
-			 	case SDL_BUTTON_RIGHT:
-				case SDL_BUTTON_RMASK:
-			 		user_mouse(2,2,event.motion.x,event.motion.y);break;
-/*				case SDL_BUTTON_WHEELUP:
-			 		user_mouse(3,2,event.motion.x,event.motion.y);break;
-				case SDL_BUTTON_WHEELDOWN:
-			 		user_mouse(4,2,event.motion.x,event.motion.y);break;*/
-				case 0:
-					user_mouse(-1,-1,event.motion.x,event.motion.y);
-					break;
-					 /*  no button ... */
-				default:
-					s3dprintf(LOW,&quot;don't know button %d&quot;, event.button.button);
+int user_main_sdl()
+{
+	SDL_Event 	event;
+	SDL_Surface *GLwin = NULL;
+	while (SDL_PollEvent(&amp;event)) {
+		switch (event.type) {
+		case SDL_MOUSEMOTION:
+			/* 			s3dprintf(VLOW,&quot;Current mouse position is: (%d, %d),button %d&quot;, event.motion.x, event.motion.y,event.button.button); */
+			switch (event.button.button) {
+			case SDL_BUTTON_LEFT:
+				user_mouse(0,2,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_MIDDLE:
+				user_mouse(1,2,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_RIGHT:
+			case SDL_BUTTON_RMASK:
+				user_mouse(2,2,event.motion.x,event.motion.y);
+				break;
+				/*				case SDL_BUTTON_WHEELUP:
+							 		user_mouse(3,2,event.motion.x,event.motion.y);break;
+								case SDL_BUTTON_WHEELDOWN:
+							 		user_mouse(4,2,event.motion.x,event.motion.y);break;*/
+			case 0:
+				user_mouse(-1,-1,event.motion.x,event.motion.y);
+				break;
+				/*  no button ... */
+			default:
+				s3dprintf(LOW,&quot;don't know button %d&quot;, event.button.button);
 
-			 }
+			}
 			break;
 		case SDL_MOUSEBUTTONDOWN:
-			 switch (event.button.button)
-			 {
-			 	case SDL_BUTTON_LEFT:
-			 		user_mouse(0,0,event.motion.x,event.motion.y);break;
-			 	case SDL_BUTTON_MIDDLE:
-			 		user_mouse(1,0,event.motion.x,event.motion.y);break;
-			 	case SDL_BUTTON_RIGHT:
-			 		user_mouse(2,0,event.motion.x,event.motion.y);break;
-				case SDL_BUTTON_WHEELUP:
-			 		user_mouse(3,0,event.motion.x,event.motion.y);break;
-				case SDL_BUTTON_WHEELDOWN:
-			 		user_mouse(4,0,event.motion.x,event.motion.y);break;
-				default:
-					s3dprintf(LOW,&quot;don't know button %d&quot;, event.button.button);
-			 }
-			 break;
+			switch (event.button.button) {
+			case SDL_BUTTON_LEFT:
+				user_mouse(0,0,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_MIDDLE:
+				user_mouse(1,0,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_RIGHT:
+				user_mouse(2,0,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_WHEELUP:
+				user_mouse(3,0,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_WHEELDOWN:
+				user_mouse(4,0,event.motion.x,event.motion.y);
+				break;
+			default:
+				s3dprintf(LOW,&quot;don't know button %d&quot;, event.button.button);
+			}
+			break;
 		case SDL_MOUSEBUTTONUP:
-			 switch (event.button.button)
-			 {
-			 	case SDL_BUTTON_LEFT:
-			 		user_mouse(0,1,event.motion.x,event.motion.y);break;
-			 	case SDL_BUTTON_MIDDLE:
-			 		user_mouse(1,1,event.motion.x,event.motion.y);break;
-			 	case SDL_BUTTON_RIGHT:
-			 		user_mouse(2,1,event.motion.x,event.motion.y);break;
-				case SDL_BUTTON_WHEELUP:
-			 		user_mouse(3,1,event.motion.x,event.motion.y);break;
-				case SDL_BUTTON_WHEELDOWN:
-			 		user_mouse(4,1,event.motion.x,event.motion.y);break;
-				default:
-					s3dprintf(LOW,&quot;don't know button %d&quot;, event.button.button);
-			 }
-			 break;
+			switch (event.button.button) {
+			case SDL_BUTTON_LEFT:
+				user_mouse(0,1,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_MIDDLE:
+				user_mouse(1,1,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_RIGHT:
+				user_mouse(2,1,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_WHEELUP:
+				user_mouse(3,1,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_WHEELDOWN:
+				user_mouse(4,1,event.motion.x,event.motion.y);
+				break;
+			default:
+				s3dprintf(LOW,&quot;don't know button %d&quot;, event.button.button);
+			}
+			break;
 
 		case SDL_KEYDOWN:
 			user_key(event.key.keysym.sym,event.key.keysym.unicode,event.key.keysym.mod,0);
@@ -108,29 +118,49 @@
 			s3dprintf(HIGH,&quot;SDL_QUIT&quot;);
 			quit();
 			break;
-		 /*  these events are not processed right now ... */
-		case SDL_ACTIVEEVENT:		s3dprintf(VLOW,&quot;SDL_ACTIVEEVENT&quot;);break;
-		case SDL_SYSWMEVENT:		s3dprintf(VLOW,&quot;SDL_SYSWMEVENT&quot;);break;
-		case SDL_VIDEORESIZE:		if ((GLwin = SDL_SetVideoMode(event.resize.w,event.resize.h,16,SDLFlags))==NULL) 
-										errsf(&quot;SDL_SetVideoMode()&quot;,SDL_GetError());
-									graphics_reshape(event.resize.w,event.resize.h);
-									break;
-		case SDL_VIDEOEXPOSE:		s3dprintf(VLOW,&quot;SDL_VIDEOEXPOSE&quot;);break;
-		case SDL_USEREVENT:			s3dprintf(VLOW,&quot;SDL_USEREVENT&quot;);break;
-		case SDL_JOYAXISMOTION:		s3dprintf(VLOW,&quot;SDL_JOYAXISMOTION&quot;);break;
-		case SDL_JOYBALLMOTION:		s3dprintf(VLOW,&quot;SDL_JOYBALLMOTION&quot;);break;
-		case SDL_JOYHATMOTION:		s3dprintf(VLOW,&quot;SDL_JOYHATMOTION&quot;);break;
-		case SDL_JOYBUTTONDOWN:		s3dprintf(VLOW,&quot;SDL_JOYBUTTONDOWN&quot;);break;
-		case SDL_JOYBUTTONUP:		s3dprintf(VLOW,&quot;SDL_JOYBUTTONUP&quot;);break;
+			/*  these events are not processed right now ... */
+		case SDL_ACTIVEEVENT:
+			s3dprintf(VLOW,&quot;SDL_ACTIVEEVENT&quot;);
+			break;
+		case SDL_SYSWMEVENT:
+			s3dprintf(VLOW,&quot;SDL_SYSWMEVENT&quot;);
+			break;
+		case SDL_VIDEORESIZE:
+			if ((GLwin = SDL_SetVideoMode(event.resize.w,event.resize.h,16,SDLFlags))==NULL)
+				errsf(&quot;SDL_SetVideoMode()&quot;,SDL_GetError());
+			graphics_reshape(event.resize.w,event.resize.h);
+			break;
+		case SDL_VIDEOEXPOSE:
+			s3dprintf(VLOW,&quot;SDL_VIDEOEXPOSE&quot;);
+			break;
+		case SDL_USEREVENT:
+			s3dprintf(VLOW,&quot;SDL_USEREVENT&quot;);
+			break;
+		case SDL_JOYAXISMOTION:
+			s3dprintf(VLOW,&quot;SDL_JOYAXISMOTION&quot;);
+			break;
+		case SDL_JOYBALLMOTION:
+			s3dprintf(VLOW,&quot;SDL_JOYBALLMOTION&quot;);
+			break;
+		case SDL_JOYHATMOTION:
+			s3dprintf(VLOW,&quot;SDL_JOYHATMOTION&quot;);
+			break;
+		case SDL_JOYBUTTONDOWN:
+			s3dprintf(VLOW,&quot;SDL_JOYBUTTONDOWN&quot;);
+			break;
+		case SDL_JOYBUTTONUP:
+			s3dprintf(VLOW,&quot;SDL_JOYBUTTONUP&quot;);
+			break;
 		default:
 			s3dprintf(MED,&quot;SDL_PollEvent(): unhandled event&quot;);
-		 	break;
-	  }
-  }
-  return(0);
+			break;
+		}
+	}
+	return(0);
 
 }
-int user_quit_sdl() {
+int user_quit_sdl()
+{
 	return(0);
 }
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000656.html">[S3d-svn] r664 - trunk
</A></li>
	<LI>Next message: <A HREF="000658.html">[S3d-svn] r666 - trunk/apps/s3dosm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#657">[ date ]</a>
              <a href="thread.html#657">[ thread ]</a>
              <a href="subject.html#657">[ subject ]</a>
              <a href="author.html#657">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/s3d-svn">More information about the S3d-svn
mailing list</a><br>
</body></html>
