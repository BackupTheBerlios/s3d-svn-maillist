<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [S3d-svn] r667 - in trunk: apps/dot_mcp apps/kism3d apps/meshs3d	apps/olsrs3d apps/s3d_x11gate apps/s3dfm apps/s3dosm	apps/s3dvt example libs3d libs3dw server
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/s3d-svn/2007-September/index.html" >
   <LINK REL="made" HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r667%20-%20in%20trunk%3A%20apps/dot_mcp%20apps/kism3d%20apps/meshs3d%0A%09apps/olsrs3d%20apps/s3d_x11gate%20apps/s3dfm%20apps/s3dosm%0A%09apps/s3dvt%20example%20libs3d%20libs3dw%20server&In-Reply-To=%3C200709171351.l8HDpX5G026916%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000658.html">
   <LINK REL="Next"  HREF="000660.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[S3d-svn] r667 - in trunk: apps/dot_mcp apps/kism3d apps/meshs3d	apps/olsrs3d apps/s3d_x11gate apps/s3dfm apps/s3dosm	apps/s3dvt example libs3d libs3dw server</H1>
    <B>lazhur at BerliOS</B> 
    <A HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r667%20-%20in%20trunk%3A%20apps/dot_mcp%20apps/kism3d%20apps/meshs3d%0A%09apps/olsrs3d%20apps/s3d_x11gate%20apps/s3dfm%20apps/s3dosm%0A%09apps/s3dvt%20example%20libs3d%20libs3dw%20server&In-Reply-To=%3C200709171351.l8HDpX5G026916%40sheep.berlios.de%3E"
       TITLE="[S3d-svn] r667 - in trunk: apps/dot_mcp apps/kism3d apps/meshs3d	apps/olsrs3d apps/s3d_x11gate apps/s3dfm apps/s3dosm	apps/s3dvt example libs3d libs3dw server">lazhur at mail.berlios.de
       </A><BR>
    <I>Mon Sep 17 15:51:33 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000658.html">[S3d-svn] r666 - trunk/apps/s3dosm
</A></li>
        <LI>Next message: <A HREF="000660.html">[S3d-svn] r668 - in trunk: . libs3dw
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#659">[ date ]</a>
              <a href="thread.html#659">[ thread ]</a>
              <a href="subject.html#659">[ subject ]</a>
              <a href="author.html#659">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lazhur
Date: 2007-09-17 15:51:17 +0200 (Mon, 17 Sep 2007)
New Revision: 667

Modified:
   trunk/apps/dot_mcp/main.c
   trunk/apps/dot_mcp/menu.c
   trunk/apps/kism3d/client.c
   trunk/apps/kism3d/gui.c
   trunk/apps/kism3d/kism3d.c
   trunk/apps/kism3d/kism3d.h
   trunk/apps/kism3d/list.h
   trunk/apps/kism3d/network.c
   trunk/apps/meshs3d/allocate.c
   trunk/apps/meshs3d/hash.c
   trunk/apps/meshs3d/hash.h
   trunk/apps/meshs3d/main.c
   trunk/apps/meshs3d/meshs3d.h
   trunk/apps/meshs3d/net.c
   trunk/apps/meshs3d/process.c
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/net.c
   trunk/apps/olsrs3d/olsrs3d.h
   trunk/apps/olsrs3d/process.c
   trunk/apps/olsrs3d/search.c
   trunk/apps/olsrs3d/search.h
   trunk/apps/olsrs3d/structs.h
   trunk/apps/s3d_x11gate/s3d_x11gate.c
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/event.c
   trunk/apps/s3dfm/fly.c
   trunk/apps/s3dfm/focus.c
   trunk/apps/s3dfm/fs.c
   trunk/apps/s3dfm/icon.c
   trunk/apps/s3dfm/main.c
   trunk/apps/s3dfm/node.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dfm/s3dfm.h
   trunk/apps/s3dfm/string.c
   trunk/apps/s3dosm/db.c
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/gps.c
   trunk/apps/s3dosm/http_error_codes.c
   trunk/apps/s3dosm/http_error_codes.h
   trunk/apps/s3dosm/http_fetcher.c
   trunk/apps/s3dosm/http_fetcher.h
   trunk/apps/s3dosm/io.c
   trunk/apps/s3dosm/kismet.c
   trunk/apps/s3dosm/main.c
   trunk/apps/s3dosm/nav.c
   trunk/apps/s3dosm/object.c
   trunk/apps/s3dosm/olsrs3d.h
   trunk/apps/s3dosm/osm.c
   trunk/apps/s3dosm/s3dosm.h
   trunk/apps/s3dosm/search.h
   trunk/apps/s3dosm/structs.h
   trunk/apps/s3dosm/tag.c
   trunk/apps/s3dosm/ui.c
   trunk/apps/s3dvt/main.c
   trunk/apps/s3dvt/s3dvt.h
   trunk/apps/s3dvt/terminal.c
   trunk/example/filebrowser.c
   trunk/example/hudtest.c
   trunk/example/katze.c
   trunk/example/linetest.c
   trunk/example/modelloader.c
   trunk/example/nichtsnutz.c
   trunk/example/ptrtest.c
   trunk/example/radius_test.c
   trunk/example/s3dclock.c
   trunk/example/snowman.c
   trunk/example/strtest.c
   trunk/example/texturetest.c
   trunk/example/widgets.c
   trunk/example/wiresphere.c
   trunk/libs3d/callback.c
   trunk/libs3d/config.h
   trunk/libs3d/error.c
   trunk/libs3d/event.c
   trunk/libs3d/fontselect.c
   trunk/libs3d/freetype.c
   trunk/libs3d/io.c
   trunk/libs3d/modelread.c
   trunk/libs3d/network.c
   trunk/libs3d/object_queue.c
   trunk/libs3d/proto_in.c
   trunk/libs3d/proto_out.c
   trunk/libs3d/s3d.h
   trunk/libs3d/s3d_keysym.h
   trunk/libs3d/s3dlib.h
   trunk/libs3d/sei_construct.c
   trunk/libs3d/sei_interface.h
   trunk/libs3d/sei_misc.c
   trunk/libs3d/sei_monotone.c
   trunk/libs3d/sei_tri.c
   trunk/libs3d/sei_triangulate.h
   trunk/libs3d/shm.c
   trunk/libs3d/shm_ringbuf.c
   trunk/libs3d/tcp.c
   trunk/libs3d/vector.c
   trunk/libs3dw/animate.c
   trunk/libs3dw/arrange.c
   trunk/libs3dw/button.c
   trunk/libs3dw/event.c
   trunk/libs3dw/input.c
   trunk/libs3dw/label.c
   trunk/libs3dw/root.c
   trunk/libs3dw/s3dw.h
   trunk/libs3dw/s3dw_int.h
   trunk/libs3dw/scrollbar.c
   trunk/libs3dw/style.c
   trunk/libs3dw/surface.c
   trunk/libs3dw/textbox.c
   trunk/libs3dw/widget.c
   trunk/server/allocate.c
   trunk/server/allocate.h
   trunk/server/config.h
   trunk/server/cull.c
   trunk/server/error.c
   trunk/server/event.c
   trunk/server/global.h
   trunk/server/graphics.c
   trunk/server/graphics_glut.c
   trunk/server/graphics_sdl.c
   trunk/server/main.c
   trunk/server/matrix.c
   trunk/server/mcp.c
   trunk/server/navigation.c
   trunk/server/network.c
   trunk/server/object.c
   trunk/server/process.c
   trunk/server/proto.c
   trunk/server/proto.h
   trunk/server/shm.c
   trunk/server/shm_ringbuf.c
   trunk/server/tcp.c
   trunk/server/user.c
   trunk/server/user_glut.c
   trunk/server/user_sdl.c
Log:
Reformatted space paddings


Modified: trunk/apps/dot_mcp/main.c
===================================================================
--- trunk/apps/dot_mcp/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/dot_mcp/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,192 +25,192 @@
 #include &lt;s3d.h&gt;
 #include &lt;s3d_keysym.h&gt;
 #include &quot;dot_mcp.h&quot;
-#include &lt;stdint.h&gt;	 /*  uint32_t */
+#include &lt;stdint.h&gt;  /*  uint32_t */
 #include &lt;unistd.h&gt;  /*  sleep() */
 #include &lt;stdlib.h&gt;  /*  free(), malloc() */
 #include &lt;string.h&gt;  /*  strncpy() */
 #include &lt;stdio.h&gt;  /*  printf() */
-#include &lt;math.h&gt;	/* sin(), cos() */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t= {
-	0,33*1000*1000
+#include &lt;math.h&gt; /* sin(), cos() */
+#include &lt;time.h&gt; /* nanosleep() */
+static struct timespec t = {
+	0, 33*1000*1000
 };
 
-#define bsize 	0.2
+#define bsize  0.2
 struct tver {
-	float x,y,z;
+	float x, y, z;
 };
 struct tver campos, camrot;
-float xdif=0,ydif=0;
+float xdif = 0, ydif = 0;
 
 struct app {
-	unsigned int oid,oid_c;
+	unsigned int oid, oid_c;
 	float r;
 	int init;
-	float trans_x,trans_y,trans_z;
+	float trans_x, trans_y, trans_z;
 	float textw;
 	char name[256];
-	int min_but,close_but,title;
+	int min_but, close_but, title;
 	int sphere;
 	struct app *next;
 };
-int ego_mode=0;
-float asp=1.0;
-struct app *apps=NULL;
-float bottom=-1.0;
-float left=-1.0;
-float zoom=5.0;
-int n_app=0;
-int rot_flag=0;
-struct app *focus=NULL;
-float focus_r=0;
-float alpha=0;
-unsigned int min_but,rotate,close_but,sphere,reset,menu=-1;
+int ego_mode = 0;
+float asp = 1.0;
+struct app *apps = NULL;
+float bottom = -1.0;
+float left = -1.0;
+float zoom = 5.0;
+int n_app = 0;
+int rot_flag = 0;
+struct app *focus = NULL;
+float focus_r = 0;
+float alpha = 0;
+unsigned int min_but, rotate, close_but, sphere, reset, menu = -1;
 
 void place_apps();
 
-#define SIDES	60
-#define RINGS	60
+#define SIDES 60
+#define RINGS 60
 int greentorus()
 {
-	int o,i,j;
-	float R,r,a;
-	float ia,ja,iap,jap;
+	int o, i, j;
+	float R, r, a;
+	float ia, ja, iap, jap;
 	float v[SIDES*RINGS*3];
 	float n[SIDES*12]; /* normals */
 	uint32_t l[SIDES*RINGS*6];
-	o=s3d_new_object();
-	R=100; /* outer radius */
-	r=100; /* inner radius */
-	a=M_PI/180;
-	s3d_push_material_a(o, 0.2,0.6,0.2,0.5,
-	                    1  ,1  ,1  ,0.5,
-	                    0.2,0.6,0.2,0.5);
-	for (i=0;i&lt;RINGS;i++) {
-		for (j=0;j&lt;SIDES;j++) {
-			ia=a*((float)i*360.0/RINGS);
-			ja=a*((float)j*360.0/SIDES);
-			iap=a*((float)(i+1)*360.0/RINGS);
-			jap=a*((float)(j+1)*360.0/SIDES);
+	o = s3d_new_object();
+	R = 100; /* outer radius */
+	r = 100; /* inner radius */
+	a = M_PI / 180;
+	s3d_push_material_a(o, 0.2, 0.6, 0.2, 0.5,
+	                    1  , 1  , 1  , 0.5,
+	                    0.2, 0.6, 0.2, 0.5);
+	for (i = 0;i &lt; RINGS;i++) {
+		for (j = 0;j &lt; SIDES;j++) {
+			ia = a * ((float)i * 360.0 / RINGS);
+			ja = a * ((float)j * 360.0 / SIDES);
+			iap = a * ((float)(i + 1) * 360.0 / RINGS);
+			jap = a * ((float)(j + 1) * 360.0 / SIDES);
 
-			v[i*SIDES*3+ j*3 +0]=(R+r*cos(ja))* cos(ia);
-			v[i*SIDES*3+ j*3 +1]=r*sin(ja);
-			v[i*SIDES*3+ j*3 +2]=(R+r*cos(ja))* sin(ia);
+			v[i*SIDES*3+ j*3 +0] = (R + r * cos(ja)) * cos(ia);
+			v[i*SIDES*3+ j*3 +1] = r * sin(ja);
+			v[i*SIDES*3+ j*3 +2] = (R + r * cos(ja)) * sin(ia);
 
-			l[i*SIDES*6+ j*6 +0]=i*SIDES+ j;
-			l[i*SIDES*6+ j*6 +1]=i*SIDES+ (j+1)%SIDES;
-			l[i*SIDES*6+ j*6 +2]=0;
-			l[i*SIDES*6+ j*6 +3]=i*SIDES+ j;
-			l[i*SIDES*6+ j*6 +4]=((i+1)%RINGS)*SIDES+ j;
-			l[i*SIDES*6+ j*6 +5]=0;
+			l[i*SIDES*6+ j*6 +0] = i * SIDES + j;
+			l[i*SIDES*6+ j*6 +1] = i * SIDES + (j + 1) % SIDES;
+			l[i*SIDES*6+ j*6 +2] = 0;
+			l[i*SIDES*6+ j*6 +3] = i * SIDES + j;
+			l[i*SIDES*6+ j*6 +4] = ((i + 1) % RINGS) * SIDES + j;
+			l[i*SIDES*6+ j*6 +5] = 0;
 
-			n[j*12 +0] =R*r*cos(ja)*    cos(ia) + r*r*cos(ja)* cos(ia)*cos(ia);
-			n[j*12 +1] =R*r*sin(ja)*    cos(ia) + r*r*sin(ja)* cos(ia)*cos(ia);
-			n[j*12 +2] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
-			n[j*12 +3] =R*r*cos(jap)*    cos(ia)+ r*r*cos(jap)*cos(ia)*cos(ia);
-			n[j*12 +4] =R*r*sin(jap)*    cos(ia)+ r*r*sin(jap)*cos(ia)*cos(ia);
-			n[j*12 +5] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
+			n[j*12 +0] = R * r * cos(ja) *    cos(ia) + r * r * cos(ja) * cos(ia) * cos(ia);
+			n[j*12 +1] = R * r * sin(ja) *    cos(ia) + r * r * sin(ja) * cos(ia) * cos(ia);
+			n[j*12 +2] = R * r * sin(ia)    + r * r * sin(ia) * cos(ia);
+			n[j*12 +3] = R * r * cos(jap) *    cos(ia) + r * r * cos(jap) * cos(ia) * cos(ia);
+			n[j*12 +4] = R * r * sin(jap) *    cos(ia) + r * r * sin(jap) * cos(ia) * cos(ia);
+			n[j*12 +5] = R * r * sin(ia)    + r * r * sin(ia) * cos(ia);
 
-			n[j*12 +6] =R*r*cos(ja)*    cos(ia) + r*r*cos(ja)* cos(ia)*cos(ia);
-			n[j*12 +7] =R*r*sin(ja)*    cos(ia) + r*r*sin(ja)* cos(ia)*cos(ia);
-			n[j*12 +8] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
-			n[j*12 +9] =R*r*cos(ja)*    cos(iap)+ r*r*cos(ja)* cos(iap)*cos(iap);
-			n[j*12 +10]=R*r*sin(ja)*    cos(iap)+ r*r*sin(ja)* cos(iap)*cos(iap);
-			n[j*12 +11]=R*r*sin(iap) 			+ r*r*sin(iap)*cos(iap);
+			n[j*12 +6] = R * r * cos(ja) *    cos(ia) + r * r * cos(ja) * cos(ia) * cos(ia);
+			n[j*12 +7] = R * r * sin(ja) *    cos(ia) + r * r * sin(ja) * cos(ia) * cos(ia);
+			n[j*12 +8] = R * r * sin(ia)    + r * r * sin(ia) * cos(ia);
+			n[j*12 +9] = R * r * cos(ja) *    cos(iap) + r * r * cos(ja) * cos(iap) * cos(iap);
+			n[j*12 +10] = R * r * sin(ja) *    cos(iap) + r * r * sin(ja) * cos(iap) * cos(iap);
+			n[j*12 +11] = R * r * sin(iap)    + r * r * sin(iap) * cos(iap);
 		}
-		s3d_push_vertices(o,&amp;v[i*SIDES*3],SIDES);
-		s3d_push_lines(o,   &amp;l[i*SIDES*6],SIDES*2);
-		s3d_pep_line_normals(o,n,SIDES*2);
+		s3d_push_vertices(o, &amp;v[i*SIDES*3], SIDES);
+		s3d_push_lines(o,   &amp;l[i*SIDES*6], SIDES*2);
+		s3d_pep_line_normals(o, n, SIDES*2);
 	}
-	/*	s3d_push_vertices(o,v,SIDES*RINGS);
-		s3d_push_lines(o,   l,SIDES*RINGS*2);*/
+	/* s3d_push_vertices(o,v,SIDES*RINGS);
+	 s3d_push_lines(o,   l,SIDES*RINGS*2);*/
 
-	s3d_flags_on(o,S3D_OF_VISIBLE);
+	s3d_flags_on(o, S3D_OF_VISIBLE);
 	return(o);
 }
 void set_focus(struct app *a)
 {
-	if (focus!=a)
+	if (focus != a)
 		/* resetting old focus */
-		if (focus!=NULL) {
-			printf(&quot;unfocusing app name %s\n&quot;,focus-&gt;name);
-			s3d_scale(focus-&gt;oid,1/focus-&gt;r);
-			s3d_scale(focus-&gt;sphere,focus-&gt;r);
+		if (focus != NULL) {
+			printf(&quot;unfocusing app name %s\n&quot;, focus-&gt;name);
+			s3d_scale(focus-&gt;oid, 1 / focus-&gt;r);
+			s3d_scale(focus-&gt;sphere, focus-&gt;r);
 
-			s3d_flags_on(focus-&gt;sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_off(focus-&gt;min_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_translate(	focus-&gt;title,-focus-&gt;textw-1.2,0.0,0);
-			s3d_translate(	focus-&gt;close_but,bsize*focus-&gt;textw/2,1.2,0);
-			s3d_link(		focus-&gt;close_but,focus-&gt;sphere);
-			s3d_link(		focus-&gt;oid,0);
+			s3d_flags_on(focus-&gt;sphere, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			s3d_flags_off(focus-&gt;min_but, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			s3d_translate(focus-&gt;title, -focus-&gt;textw - 1.2, 0.0, 0);
+			s3d_translate(focus-&gt;close_but, bsize*focus-&gt;textw / 2, 1.2, 0);
+			s3d_link(focus-&gt;close_but, focus-&gt;sphere);
+			s3d_link(focus-&gt;oid, 0);
 		}
-	focus=a;
-	if (a==NULL) {
-		focus_r=n_app;
+	focus = a;
+	if (a == NULL) {
+		focus_r = n_app;
 		s3d_mcp_focus(-1);
-		s3d_flags_off(rotate,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_off(reset,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		rot_flag=0;
+		s3d_flags_off(rotate, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		s3d_flags_off(reset, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		rot_flag = 0;
 	} else {
 		/* set the new focus app up */
-		s3d_translate(	a-&gt;title,-a-&gt;textw-9.6,0.0,0);
-		s3d_translate(	reset,-7.2,0.0,0);
-		s3d_translate(	rotate,-4.8,0.0,0);
-		s3d_translate(	a-&gt;min_but,-2.4,0.0,0);
-		s3d_link(		a-&gt;close_but,0);
-		s3d_link(		rotate,a-&gt;close_but);
-		s3d_link(		reset,a-&gt;close_but);
-		s3d_flags_on(	a-&gt;min_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(	rotate,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(	reset,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_off(	a-&gt;sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_translate(a-&gt;title, -a-&gt;textw - 9.6, 0.0, 0);
+		s3d_translate(reset, -7.2, 0.0, 0);
+		s3d_translate(rotate, -4.8, 0.0, 0);
+		s3d_translate(a-&gt;min_but, -2.4, 0.0, 0);
+		s3d_link(a-&gt;close_but, 0);
+		s3d_link(rotate, a-&gt;close_but);
+		s3d_link(reset, a-&gt;close_but);
+		s3d_flags_on(a-&gt;min_but, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		s3d_flags_on(rotate, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		s3d_flags_on(reset, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		s3d_flags_off(a-&gt;sphere, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 		s3d_unlink(a-&gt;oid);
-		s3d_rotate(a-&gt;oid,		0,0,0);
-		s3d_translate(a-&gt;oid,	0,0,0);
-		focus_r=a-&gt;r;
-		s3d_scale(a-&gt;oid,1);
-		s3d_mcp_focus(	a-&gt;oid);
+		s3d_rotate(a-&gt;oid,  0, 0, 0);
+		s3d_translate(a-&gt;oid, 0, 0, 0);
+		focus_r = a-&gt;r;
+		s3d_scale(a-&gt;oid, 1);
+		s3d_mcp_focus(a-&gt;oid);
 	}
 	place_apps();
 }
 
 int add_app(struct app *a)
 {
-	struct app *prev=NULL,*a2=apps;
-	while ((a2)!=NULL) {
-		prev=a2;
-		if (a2-&gt;oid==a-&gt;oid) { /*  already added, so free() and return */
+	struct app *prev = NULL, *a2 = apps;
+	while ((a2) != NULL) {
+		prev = a2;
+		if (a2-&gt;oid == a-&gt;oid) { /*  already added, so free() and return */
 			free(a);
 			return(1);
 		}
-		a2=a2-&gt;next;  /*  go to the end */
+		a2 = a2-&gt;next;  /*  go to the end */
 	}
-	a-&gt;next=NULL;
-	if (prev==NULL)
-		apps=a;
+	a-&gt;next = NULL;
+	if (prev == NULL)
+		apps = a;
 	else
-		prev-&gt;next=a;
-	n_app+=1;
+		prev-&gt;next = a;
+	n_app += 1;
 	return(0);
 }
 void *find_app(int oid)
 {
-	struct app *a=apps;
-	while (a!=NULL) {
-		if (oid==a-&gt;oid)
+	struct app *a = apps;
+	while (a != NULL) {
+		if (oid == a-&gt;oid)
 			break;
-		a=a-&gt;next;
+		a = a-&gt;next;
 	}
 	return(a);
 }
 void *del_app(int oid)
 {
-	struct app *prev=NULL,*a=apps;
-	while ((a!=NULL)  &amp;&amp; (a-&gt;oid!=oid)) {
-		prev=a;
-		a=a-&gt;next;
+	struct app *prev = NULL, *a = apps;
+	while ((a != NULL)  &amp;&amp; (a-&gt;oid != oid)) {
+		prev = a;
+		a = a-&gt;next;
 	}
-	if (a!=NULL) { /*  found ... */
+	if (a != NULL) { /*  found ... */
 		if (a-&gt;init) {
 			s3d_del_object(a-&gt;close_but);
 			s3d_del_object(a-&gt;min_but);
@@ -218,14 +218,14 @@
 			s3d_del_object(a-&gt;sphere);
 			s3d_del_object(a-&gt;oid);
 		}
-		if (prev==NULL)
-			apps=a-&gt;next;  /*  new head */
+		if (prev == NULL)
+			apps = a-&gt;next;  /*  new head */
 		else
-			prev-&gt;next=a-&gt;next;
+			prev-&gt;next = a-&gt;next;
 		n_app--;
-		if (focus==a) {
+		if (focus == a) {
 			set_focus(NULL);
-			focus=NULL;
+			focus = NULL;
 		}
 		free(a);
 		place_apps();
@@ -239,64 +239,64 @@
 }
 void place_apps()
 {
-	struct app *a=apps;
-	int j=0;
-	float u[3],v[3],ya,xa;
-	while (a!=NULL) {
+	struct app *a = apps;
+	int j = 0;
+	float u[3], v[3], ya, xa;
+	while (a != NULL) {
 		if (a-&gt;init) {
-			/*			printf(&quot;placing app [%d,'%s'], oid %d, r=%f\n&quot;,j,a-&gt;name,a-&gt;oid,a-&gt;r); */
-			if (focus==a) {
-				s3d_translate(a-&gt;close_but,(-left)*zoom-0.4,(-bottom)*zoom-0.4,-zoom);
+			/*   printf(&quot;placing app [%d,'%s'], oid %d, r=%f\n&quot;,j,a-&gt;name,a-&gt;oid,a-&gt;r); */
+			if (focus == a) {
+				s3d_translate(a-&gt;close_but, (-left)*zoom - 0.4, (-bottom)*zoom - 0.4, -zoom);
 			} else {
-				s3d_translate(	a-&gt;oid,	zoom*(left)+j*2+1.0,zoom*bottom+1.0,-zoom);
-				s3d_rotate(		a-&gt;oid,	0,10,0);
+				s3d_translate(a-&gt;oid, zoom*(left) + j*2 + 1.0, zoom*bottom + 1.0, -zoom);
+				s3d_rotate(a-&gt;oid, 0, 10, 0);
 				j++;
 			}
 		}
-		a=a-&gt;next;
+		a = a-&gt;next;
 	}
-	s3d_translate(menu,	left*zoom+0.4,(-bottom)*zoom-0.4,-zoom);
+	s3d_translate(menu, left*zoom + 0.4, (-bottom)*zoom - 0.4, -zoom);
 
-	v[0]=0;
-	v[1]=0;
-	v[2]=1;
-	u[0]=left*zoom+0.4;
-	u[1]=0;
-	u[2]=-zoom;
-	ya=s3d_vector_angle(v,u);
-	u[0]=0;
-	u[1]=(-bottom)*zoom;
-	u[2]=-zoom;
-	xa=s3d_vector_angle(v,u);
-	s3d_rotate(menu, 0 ,30,0);
+	v[0] = 0;
+	v[1] = 0;
+	v[2] = 1;
+	u[0] = left * zoom + 0.4;
+	u[1] = 0;
+	u[2] = -zoom;
+	ya = s3d_vector_angle(v, u);
+	u[0] = 0;
+	u[1] = (-bottom) * zoom;
+	u[2] = -zoom;
+	xa = s3d_vector_angle(v, u);
+	s3d_rotate(menu, 0 , 30, 0);
 }
 int mcp_object(struct s3d_evt *hrmz)
 {
 	struct mcp_object *mo;
 	struct app *a;
-	mo=(struct mcp_object *)hrmz-&gt;buf;
-	if (NULL==(a=find_app(mo-&gt;object))) {
+	mo = (struct mcp_object *)hrmz-&gt;buf;
+	if (NULL == (a = find_app(mo-&gt;object))) {
 		printf(&quot;adding new object ......&quot;);
-		a=malloc(sizeof(struct app));
-		a-&gt;oid=mo-&gt;object;
-		a-&gt;r=mo-&gt;r;
-		strncpy(a-&gt;name,mo-&gt;name,256);
-		a-&gt;init=0;
+		a = malloc(sizeof(struct app));
+		a-&gt;oid = mo-&gt;object;
+		a-&gt;r = mo-&gt;r;
+		strncpy(a-&gt;name, mo-&gt;name, 256);
+		a-&gt;init = 0;
 		add_app(a);
 		place_apps();
-		printf(&quot;..%s\n&quot;,a-&gt;name);
+		printf(&quot;..%s\n&quot;, a-&gt;name);
 	} else {
-		/*		printf(&quot;updating app %d\n&quot;,a-&gt;oid);*/
-		a-&gt;trans_x=mo-&gt;trans_x;
-		a-&gt;trans_y=mo-&gt;trans_y;
-		a-&gt;trans_z=mo-&gt;trans_z;
-		a-&gt;r=mo-&gt;r;
+		/*  printf(&quot;updating app %d\n&quot;,a-&gt;oid);*/
+		a-&gt;trans_x = mo-&gt;trans_x;
+		a-&gt;trans_y = mo-&gt;trans_y;
+		a-&gt;trans_z = mo-&gt;trans_z;
+		a-&gt;r = mo-&gt;r;
 		if (a-&gt;init) {
-			if (a==focus) {
-				focus_r=a-&gt;r;
+			if (a == focus) {
+				focus_r = a-&gt;r;
 			} else {
-				s3d_scale(a-&gt;sphere,a-&gt;r);
-				s3d_scale(a-&gt;oid,1/a-&gt;r);
+				s3d_scale(a-&gt;sphere, a-&gt;r);
+				s3d_scale(a-&gt;oid, 1 / a-&gt;r);
 			}
 		}
 		place_apps();
@@ -305,44 +305,44 @@
 }
 void app_init(struct app *a)
 {
-	printf(&quot;building some window decorations on %d ['%s']\n&quot;,a-&gt;oid,a-&gt;name);
-	printf(&quot;radius of object %d is %f\n&quot;,a-&gt;oid,a-&gt;r);
-	s3d_scale(a-&gt;oid,		1/a-&gt;r);
+	printf(&quot;building some window decorations on %d ['%s']\n&quot;, a-&gt;oid, a-&gt;name);
+	printf(&quot;radius of object %d is %f\n&quot;, a-&gt;oid, a-&gt;r);
+	s3d_scale(a-&gt;oid,  1 / a-&gt;r);
 
-	a-&gt;sphere=s3d_clone(sphere);
-	s3d_scale(		a-&gt;sphere,a-&gt;r);
-	s3d_link(		a-&gt;sphere,a-&gt;oid);
-	s3d_flags_on(	a-&gt;sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	a-&gt;sphere = s3d_clone(sphere);
+	s3d_scale(a-&gt;sphere, a-&gt;r);
+	s3d_link(a-&gt;sphere, a-&gt;oid);
+	s3d_flags_on(a-&gt;sphere, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
-	a-&gt;title=s3d_draw_string(a-&gt;name,&amp;a-&gt;textw);
+	a-&gt;title = s3d_draw_string(a-&gt;name, &amp;a-&gt;textw);
 
-	a-&gt;close_but=s3d_clone(close_but);
-	s3d_translate(	a-&gt;close_but,bsize*a-&gt;textw/2.0,1.2f,0.0f);
-	s3d_link(		a-&gt;close_but,a-&gt;sphere);
-	s3d_flags_on(	a-&gt;close_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	a-&gt;close_but = s3d_clone(close_but);
+	s3d_translate(a-&gt;close_but, bsize*a-&gt;textw / 2.0, 1.2f, 0.0f);
+	s3d_link(a-&gt;close_but, a-&gt;sphere);
+	s3d_flags_on(a-&gt;close_but, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
 
-	s3d_translate(	a-&gt;title,-a-&gt;textw-1.2f,0.0f,0.0f);
-	s3d_link(		a-&gt;title,a-&gt;close_but);
-	s3d_flags_on(	a-&gt;title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_translate(a-&gt;title, -a-&gt;textw - 1.2f, 0.0f, 0.0f);
+	s3d_link(a-&gt;title, a-&gt;close_but);
+	s3d_flags_on(a-&gt;title, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
-	a-&gt;min_but=s3d_clone(min_but);
-	s3d_link(		a-&gt;min_but,a-&gt;close_but);
+	a-&gt;min_but = s3d_clone(min_but);
+	s3d_link(a-&gt;min_but, a-&gt;close_but);
 
 
-	s3d_scale(		a-&gt;close_but,bsize);
+	s3d_scale(a-&gt;close_but, bsize);
 
-	s3d_link(		a-&gt;oid,0);
-	a-&gt;init=1;
-	/*	if (focus==NULL)
-			set_focus(a);
-		else*/
+	s3d_link(a-&gt;oid, 0);
+	a-&gt;init = 1;
+	/* if (focus==NULL)
+	  set_focus(a);
+	 else*/
 	place_apps();
 }
 int mcp_del_object(struct s3d_evt *hrmz)
 {
 	struct mcp_object *mo;
-	mo=(struct mcp_object *)hrmz-&gt;buf;
+	mo = (struct mcp_object *)hrmz-&gt;buf;
 	del_app(mo-&gt;object);
 	return(0);
 }
@@ -350,33 +350,33 @@
 {
 	struct app *a;
 	unsigned int i, oid;
-	oid=*((unsigned int *)hrmz-&gt;buf);
-	a=apps;
-	i=0;
-	if (oid==rotate) {
-		rot_flag=!rot_flag;
+	oid = *((unsigned int *)hrmz-&gt;buf);
+	a = apps;
+	i = 0;
+	if (oid == rotate) {
+		rot_flag = !rot_flag;
 		return(0);
 	}
-	if (oid==reset) {
-		s3d_translate(0,0.0,0.0,5.0);
-		s3d_rotate(0,0,0,0);
+	if (oid == reset) {
+		s3d_translate(0, 0.0, 0.0, 5.0);
+		s3d_rotate(0, 0, 0, 0);
 	}
-	while (a!=NULL) {
-		if (oid==a-&gt;close_but) {
+	while (a != NULL) {
+		if (oid == a-&gt;close_but) {
 			del_app(a-&gt;oid);
 			return(0);
-		} else 	if (oid==a-&gt;min_but) {
-			if (a==focus) {
+		} else  if (oid == a-&gt;min_but) {
+			if (a == focus) {
 				set_focus(NULL); /* nothing is focused now */
 			}
 			return(0);
-		} else 	if (((oid==a-&gt;title) || (oid==a-&gt;sphere)) || (oid==a-&gt;oid)) {
-			printf(&quot;giving focus to [%s], %d\n&quot;,a-&gt;name,oid);
+		} else  if (((oid == a-&gt;title) || (oid == a-&gt;sphere)) || (oid == a-&gt;oid)) {
+			printf(&quot;giving focus to [%s], %d\n&quot;, a-&gt;name, oid);
 			set_focus(a);
 			return(0);
 		}
 		i++;
-		a=a-&gt;next;
+		a = a-&gt;next;
 	}
 	menu_click(oid);
 	return(0);
@@ -384,24 +384,24 @@
 int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
-	if (inf-&gt;object==0) {
-		campos.x=inf-&gt;trans_x;
-		campos.y=inf-&gt;trans_y;
-		campos.z=inf-&gt;trans_z;
-		camrot.x=inf-&gt;rot_x;
-		camrot.y=inf-&gt;rot_y;
-		camrot.z=inf-&gt;rot_z;
+	inf = (struct s3d_obj_info *)hrmz-&gt;buf;
+	if (inf-&gt;object == 0) {
+		campos.x = inf-&gt;trans_x;
+		campos.y = inf-&gt;trans_y;
+		campos.z = inf-&gt;trans_z;
+		camrot.x = inf-&gt;rot_x;
+		camrot.y = inf-&gt;rot_y;
+		camrot.z = inf-&gt;rot_z;
 
-		if (asp!=inf-&gt;scale) {
-			asp=inf-&gt;scale;
-			printf(&quot;screen aspect: %f\n&quot;,asp);
-			if (asp&gt;1.0) { /* wide screen */
-				bottom=-1.0;
-				left=-asp;
+		if (asp != inf-&gt;scale) {
+			asp = inf-&gt;scale;
+			printf(&quot;screen aspect: %f\n&quot;, asp);
+			if (asp &gt; 1.0) { /* wide screen */
+				bottom = -1.0;
+				left = -asp;
 			} else {  /* high screen */
-				bottom=(-1.0/asp);
-				left=-1.0;
+				bottom = (-1.0 / asp);
+				left = -1.0;
 			}
 			place_apps(); /* replace apps */
 		}
@@ -411,108 +411,108 @@
 void mainloop()
 {
 	struct app *a;
-	float al,r;
+	float al, r;
 	int i;
-	a=apps;
-	i=0;
-	while (a!=NULL) {
+	a = apps;
+	i = 0;
+	while (a != NULL) {
 		if (!a-&gt;init)
 			app_init(a);
 		i++;
-		a=a-&gt;next;
+		a = a-&gt;next;
 	}
 	if (rot_flag) {
-		al=(alpha*M_PI/180);
-		r=(focus_r&gt;20.0)?20.0:focus_r;
-		s3d_translate(0,sin(al)*(r+5),0,cos(al)*(r+5));
-		s3d_rotate(0,0,alpha,0);
-		alpha=alpha+0.1;
-		if (alpha&gt;360.0) alpha=0.0;
+		al = (alpha * M_PI / 180);
+		r = (focus_r &gt; 20.0) ? 20.0 : focus_r;
+		s3d_translate(0, sin(al)*(r + 5), 0, cos(al)*(r + 5));
+		s3d_rotate(0, 0, alpha, 0);
+		alpha = alpha + 0.1;
+		if (alpha &gt; 360.0) alpha = 0.0;
 	}
 	if (ego_mode) {
-		if ((ydif!=0) || (xdif!=0)) {
-			campos.x+=ydif*sin((camrot.y*M_PI)/180);
-			campos.z+=ydif*cos((camrot.y*M_PI)/180);
-			campos.x+=xdif*cos((-camrot.y*M_PI)/180);
-			campos.z+=xdif*sin((-camrot.y*M_PI)/180);
-			campos.y+=ydif*sin((-camrot.x*M_PI)/180);
-			s3d_translate(	0,campos.x,campos.y,campos.z);
+		if ((ydif != 0) || (xdif != 0)) {
+			campos.x += ydif * sin((camrot.y * M_PI) / 180);
+			campos.z += ydif * cos((camrot.y * M_PI) / 180);
+			campos.x += xdif * cos((-camrot.y * M_PI) / 180);
+			campos.z += xdif * sin((-camrot.y * M_PI) / 180);
+			campos.y += ydif * sin((-camrot.x * M_PI) / 180);
+			s3d_translate(0, campos.x, campos.y, campos.z);
 		}
 	}
-	nanosleep(&amp;t,NULL);
+	nanosleep(&amp;t, NULL);
 }
 
 int keydown(struct s3d_evt *event)
 {
-	struct s3d_key_event *keys=(struct s3d_key_event *)event-&gt;buf;
+	struct s3d_key_event *keys = (struct s3d_key_event *)event-&gt;buf;
 	switch (keys-&gt;keysym) {
 	case S3DK_F2:
-		ego_mode=(ego_mode+1)%2;
-		xdif=0;
-		ydif=0;
-		printf(&quot;ego mode %d\n&quot;,ego_mode);
+		ego_mode = (ego_mode + 1) % 2;
+		xdif = 0;
+		ydif = 0;
+		printf(&quot;ego mode %d\n&quot;, ego_mode);
 		break;
 	case 'w':
-		ydif+=-1.0;
+		ydif += -1.0;
 		break;
 	case 'a':
-		xdif+=-1.0;
+		xdif += -1.0;
 		break;
 	case 's':
-		ydif+= 1.0;
+		ydif += 1.0;
 		break;
 	case 'd':
-		xdif+= 1.0;
+		xdif += 1.0;
 		break;
 	}
 	return(0);
 }
 int keyup(struct s3d_evt *event)
 {
-	struct s3d_key_event *keys=(struct s3d_key_event *)event-&gt;buf;
+	struct s3d_key_event *keys = (struct s3d_key_event *)event-&gt;buf;
 	switch (keys-&gt;keysym) {
 	case 'w':
-		ydif-=-1.0;
+		ydif -= -1.0;
 		break;
 	case 'a':
-		xdif-=-1.0;
+		xdif -= -1.0;
 		break;
 	case 's':
-		ydif-= 1.0;
+		ydif -= 1.0;
 		break;
 	case 'd':
-		xdif-= 1.0;
+		xdif -= 1.0;
 		break;
 	}
 	return(0);
 
 }
 
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-	s3d_set_callback(S3D_MCP_OBJECT,mcp_object);
-	s3d_set_callback(S3D_EVENT_QUIT,stop);
-	s3d_set_callback(S3D_MCP_DEL_OBJECT,mcp_del_object);
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-	s3d_set_callback(S3D_EVENT_KEYDOWN,keydown);
-	s3d_set_callback(S3D_EVENT_KEYUP,keyup);
+	s3d_set_callback(S3D_EVENT_OBJ_INFO, object_info);
+	s3d_set_callback(S3D_MCP_OBJECT, mcp_object);
+	s3d_set_callback(S3D_EVENT_QUIT, stop);
+	s3d_set_callback(S3D_MCP_DEL_OBJECT, mcp_del_object);
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK, object_click);
+	s3d_set_callback(S3D_EVENT_KEYDOWN, keydown);
+	s3d_set_callback(S3D_EVENT_KEYUP, keyup);
 
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;mcp&quot;)) {
-		if (!((argc&gt;1) &amp;&amp; (0==strcmp(argv[1],&quot;--notorus&quot;))))
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;mcp&quot;)) {
+		if (!((argc &gt; 1) &amp;&amp; (0 == strcmp(argv[1], &quot;--notorus&quot;))))
 			greentorus(); /* just call ... */
 
 		if (s3d_select_font(&quot;vera&quot;)) {
 			printf(&quot;font not found\n&quot;);
 		}
-		min_but=s3d_import_model_file(&quot;objs/btn_minimize.3ds&quot;);
-		rotate=s3d_import_model_file(&quot;objs/btn_rotate.3ds&quot;);
-		reset=s3d_import_model_file(&quot;objs/reset.3ds&quot;);
-		close_but=s3d_import_model_file(&quot;objs/btn_close.3ds&quot;);
-		sphere=s3d_import_model_file(&quot;objs/ringsystem.3ds&quot;);
-		menu=menu_init();
-		s3d_link(menu,0);
-		s3d_scale(menu,bsize);
+		min_but = s3d_import_model_file(&quot;objs/btn_minimize.3ds&quot;);
+		rotate = s3d_import_model_file(&quot;objs/btn_rotate.3ds&quot;);
+		reset = s3d_import_model_file(&quot;objs/reset.3ds&quot;);
+		close_but = s3d_import_model_file(&quot;objs/btn_close.3ds&quot;);
+		sphere = s3d_import_model_file(&quot;objs/ringsystem.3ds&quot;);
+		menu = menu_init();
+		s3d_link(menu, 0);
+		s3d_scale(menu, bsize);
 		place_apps();
 		s3d_mainloop(mainloop);
 		s3d_quit();

Modified: trunk/apps/dot_mcp/menu.c
===================================================================
--- trunk/apps/dot_mcp/menu.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/dot_mcp/menu.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -33,66 +33,66 @@
 	char *icon, *name, *path;
 	int icon_oid, str_oid;
 };
-static int go=-1;
+static int go = -1;
 static int act;
-static struct menu_entry menu[]= {
-	{&quot;objs/comp.3ds&quot;,&quot;terminal&quot;,&quot;s3dvt&quot;,				0,0
-	}, {&quot;objs/comp.3ds&quot;,&quot;olsrs3d&quot;,&quot;olsrs3d&quot;,				0,0}, {&quot;objs/comp.3ds&quot;,&quot;s3d_x11gate&quot;,&quot;s3d_x11gate&quot;,		0,0}, {&quot;objs/comp.3ds&quot;,&quot;filebrowser&quot;,&quot;filebrowser&quot;,		0,0}, {&quot;objs/comp.3ds&quot;,&quot;logout&quot;,&quot;LOGOUT&quot;,					0,0},
+static struct menu_entry menu[] = {
+	{&quot;objs/comp.3ds&quot;, &quot;terminal&quot;, &quot;s3dvt&quot;,    0, 0
+	}, {&quot;objs/comp.3ds&quot;, &quot;olsrs3d&quot;, &quot;olsrs3d&quot;,    0, 0}, {&quot;objs/comp.3ds&quot;, &quot;s3d_x11gate&quot;, &quot;s3d_x11gate&quot;,  0, 0}, {&quot;objs/comp.3ds&quot;, &quot;filebrowser&quot;, &quot;filebrowser&quot;,  0, 0}, {&quot;objs/comp.3ds&quot;, &quot;logout&quot;, &quot;LOGOUT&quot;,     0, 0},
 };
 void menu_click(int oid)
 {
 	unsigned int i;
 	char exec[256];
-	printf(&quot;%d got clicked\n&quot;,oid);
-	if (oid==go) {
-		act=!act;
-		for (i=0;i&lt;(sizeof(menu)/sizeof(struct menu_entry));i++) {
+	printf(&quot;%d got clicked\n&quot;, oid);
+	if (oid == go) {
+		act = !act;
+		for (i = 0;i &lt; (sizeof(menu) / sizeof(struct menu_entry));i++) {
 			if (act) {
-				s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-				s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+				s3d_flags_on(menu[i].icon_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+				s3d_flags_on(menu[i].str_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 			} else {
-				s3d_flags_off(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-				s3d_flags_off(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+				s3d_flags_off(menu[i].icon_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+				s3d_flags_off(menu[i].str_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 			}
 
 		}
 		return;
 	}
 	if (act) {
-		for (i=0;i&lt;(sizeof(menu)/sizeof(struct menu_entry));i++) {
-			if ((oid==menu[i].icon_oid) || (oid==menu[i].str_oid)) {
-				if (0==strncmp(menu[i].path,&quot;LOGOUT&quot;,6)) {
+		for (i = 0;i &lt; (sizeof(menu) / sizeof(struct menu_entry));i++) {
+			if ((oid == menu[i].icon_oid) || (oid == menu[i].str_oid)) {
+				if (0 == strncmp(menu[i].path, &quot;LOGOUT&quot;, 6)) {
 					s3d_quit();
 					return;
 				}
-				strncpy(exec,menu[i].path,256);
-				strncat(exec,&quot;&gt; /dev/null 2&gt;&amp;1 &amp;&quot;,256); /* ignoring output, starting in background */
-				printf(&quot;executing [%s]\n&quot;,exec);
+				strncpy(exec, menu[i].path, 256);
+				strncat(exec, &quot;&gt; /dev/null 2&gt;&amp;1 &amp;&quot;, 256); /* ignoring output, starting in background */
+				printf(&quot;executing [%s]\n&quot;, exec);
 				system(exec);
 				return;
 			}
 		}
 	}
 }
-int menu_init ()
+int menu_init()
 {
-	int i,menu_o;
-	menu_o=s3d_new_object();
-	act=0; /* menu deactived */
-	go=s3d_import_model_file(&quot;objs/s3dstart.3ds&quot;);
-	s3d_flags_on(go,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_link(go,menu_o);
-	for (i=0;i&lt;(sizeof(menu)/sizeof(struct menu_entry));i++) {
-		if (-1==(menu[i].icon_oid=s3d_import_model_file(menu[i].icon)))
-			menu[i].icon_oid=s3d_new_object();
-		menu[i].str_oid=s3d_draw_string(menu[i].name,NULL);
-		s3d_link(menu[i].str_oid,menu[i].icon_oid);
-		s3d_link(menu[i].icon_oid,menu_o);
-		s3d_translate(menu[i].icon_oid,0,-3+(-3*i),0);
-		s3d_translate(menu[i].str_oid,2,0,0);
-		/*		s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-				s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);*/
-		printf(&quot;menu item menu[%d], icon_oid=%d, icon_str=%d\n&quot;,i,menu[i].icon_oid,menu[i].str_oid);
+	int i, menu_o;
+	menu_o = s3d_new_object();
+	act = 0; /* menu deactived */
+	go = s3d_import_model_file(&quot;objs/s3dstart.3ds&quot;);
+	s3d_flags_on(go, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_link(go, menu_o);
+	for (i = 0;i &lt; (sizeof(menu) / sizeof(struct menu_entry));i++) {
+		if (-1 == (menu[i].icon_oid = s3d_import_model_file(menu[i].icon)))
+			menu[i].icon_oid = s3d_new_object();
+		menu[i].str_oid = s3d_draw_string(menu[i].name, NULL);
+		s3d_link(menu[i].str_oid, menu[i].icon_oid);
+		s3d_link(menu[i].icon_oid, menu_o);
+		s3d_translate(menu[i].icon_oid, 0, -3 + (-3*i), 0);
+		s3d_translate(menu[i].str_oid, 2, 0, 0);
+		/*  s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		  s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);*/
+		printf(&quot;menu item menu[%d], icon_oid=%d, icon_str=%d\n&quot;, i, menu[i].icon_oid, menu[i].str_oid);
 	}
 	return(menu_o);
 }

Modified: trunk/apps/kism3d/client.c
===================================================================
--- trunk/apps/kism3d/client.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/kism3d/client.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -29,7 +29,7 @@
 
 
 
-struct wlan_client *get_wlan_client( char *mac ) {
+struct wlan_client *get_wlan_client(char *mac) {
 
 	struct list_head *client_pos;
 	struct wlan_client *wlan_client;
@@ -39,27 +39,27 @@
 
 		wlan_client = list_entry(client_pos, struct wlan_client, list);
 
-		if ( strncmp( wlan_client-&gt;mac, mac, 18 ) == 0 )
+		if (strncmp(wlan_client-&gt;mac, mac, 18) == 0)
 			return wlan_client;
 
 	}
 
 
 	/* we reached the end of the list and must create a new wlan_network */
-	wlan_client = alloc_memory( sizeof( struct wlan_client ) );
+	wlan_client = alloc_memory(sizeof(struct wlan_client));
 
 	INIT_LIST_HEAD(&amp;wlan_client-&gt;list);
 
-	strncpy( wlan_client-&gt;mac, mac, 18 );
+	strncpy(wlan_client-&gt;mac, mac, 18);
 	wlan_client-&gt;wlan_network = NULL;
 
 	wlan_client-&gt;props_changed = 1;
 
 	wlan_client-&gt;visible = 1;
 
-	wlan_client-&gt;pos_vec[0] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-	wlan_client-&gt;pos_vec[1] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-	wlan_client-&gt;pos_vec[2] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+	wlan_client-&gt;pos_vec[0] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
+	wlan_client-&gt;pos_vec[1] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
+	wlan_client-&gt;pos_vec[2] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
 	wlan_client-&gt;mov_vec[0] = wlan_client-&gt;mov_vec[1] = wlan_client-&gt;mov_vec[2] = 0.0;
 
 	wlan_client-&gt;obj_id = -1;

Modified: trunk/apps/kism3d/gui.c
===================================================================
--- trunk/apps/kism3d/gui.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/kism3d/gui.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,10 +26,10 @@
 #include &quot;kism3d.h&quot;
 #include &lt;s3d.h&gt;
 #include &lt;s3dw.h&gt;
-#include &lt;math.h&gt;	/* M_PI, cos(), sin() */
-#include &lt;stdlib.h&gt;	/* malloc(), free() */
+#include &lt;math.h&gt; /* M_PI, cos(), sin() */
+#include &lt;stdlib.h&gt; /* malloc(), free() */
 #include &lt;stdio.h&gt;      /* printf() */
-#include &lt;time.h&gt;	/* nanosleep()  */
+#include &lt;time.h&gt; /* nanosleep()  */
 #include &lt;pthread.h&gt;
 
 
@@ -51,65 +51,65 @@
 
 int wire_sphere(int slices, int stacks)
 {
-	int x,y,i,o;
-	int num_v,num_l;
-	float *v,*n;			/* vertices, normals */
+	int x, y, i, o;
+	int num_v, num_l;
+	float *v, *n;  /* vertices, normals */
 	float alpha, beta;
-	unsigned int *l;	/* lines */
-	num_v=(stacks+1) * slices;
-	num_l=stacks * slices+ (stacks-1) * slices; /* vertical + horizontal */
-	v=malloc(sizeof(float) * 3 * num_v);
-	n=malloc(sizeof(float) * 6 * num_l);
-	l=malloc(sizeof(unsigned int) * 3 * num_l);
-	i=0;
-	for (x=0;x&lt;slices;x++) {
-		alpha=(x*360.0/slices)*M_PI/180.0;
-		for (y=0;y&lt;(stacks+1);y++) {
-			beta=((y*180/slices)-90.0)*M_PI/180.0;
-			v[i*3+0]=cos(alpha) * cos(beta);
-			v[i*3+1]=sin(beta);
-			v[i*3+2]=sin(alpha) * cos(beta);
+	unsigned int *l; /* lines */
+	num_v = (stacks + 1) * slices;
+	num_l = stacks * slices + (stacks - 1) * slices; /* vertical + horizontal */
+	v = malloc(sizeof(float) * 3 * num_v);
+	n = malloc(sizeof(float) * 6 * num_l);
+	l = malloc(sizeof(unsigned int) * 3 * num_l);
+	i = 0;
+	for (x = 0;x &lt; slices;x++) {
+		alpha = (x * 360.0 / slices) * M_PI / 180.0;
+		for (y = 0;y &lt; (stacks + 1);y++) {
+			beta = ((y * 180 / slices) - 90.0) * M_PI / 180.0;
+			v[i*3+0] = cos(alpha) * cos(beta);
+			v[i*3+1] = sin(beta);
+			v[i*3+2] = sin(alpha) * cos(beta);
 			i++;
 		}
 	}
-	i=0;
-	for (x=0;x&lt;slices;x++) {
-		for (y=0;y&lt;stacks;y++) {
-			if ((y!=0) &amp;&amp; (y!=stacks)) { /* no horizontal lines at the poles */
-				l[i*3+0]=(x*(stacks+1))+y;
-				l[i*3+1]=(((x+1)%slices)*(stacks+1))+y;
-				l[i*3+2]=0;
-				n[i*6+0]=v[ l[i*3+0]*3 + 0];
-				n[i*6+1]=v[ l[i*3+0]*3 + 1];
-				n[i*6+2]=v[ l[i*3+0]*3 + 2];
-				n[i*6+3]=v[ l[i*3+1]*3 + 0];
-				n[i*6+4]=v[ l[i*3+1]*3 + 1];
-				n[i*6+5]=v[ l[i*3+1]*3 + 2];
+	i = 0;
+	for (x = 0;x &lt; slices;x++) {
+		for (y = 0;y &lt; stacks;y++) {
+			if ((y != 0) &amp;&amp; (y != stacks)) { /* no horizontal lines at the poles */
+				l[i*3+0] = (x * (stacks + 1)) + y;
+				l[i*3+1] = (((x + 1) % slices) * (stacks + 1)) + y;
+				l[i*3+2] = 0;
+				n[i*6+0] = v[ l[i*3+0] * 3 + 0];
+				n[i*6+1] = v[ l[i*3+0] * 3 + 1];
+				n[i*6+2] = v[ l[i*3+0] * 3 + 2];
+				n[i*6+3] = v[ l[i*3+1] * 3 + 0];
+				n[i*6+4] = v[ l[i*3+1] * 3 + 1];
+				n[i*6+5] = v[ l[i*3+1] * 3 + 2];
 
 				i++;
 
 			}
 			/* vertical lines */
-			l[i*3+0]=(x*(stacks+1))+y;
-			l[i*3+1]=(x*(stacks+1))+y+1;
-			l[i*3+2]=0;
-			n[i*6+0]=v[ l[i*3+0]*3 + 0];
-			n[i*6+1]=v[ l[i*3+0]*3 + 1];
-			n[i*6+2]=v[ l[i*3+0]*3 + 2];
-			n[i*6+3]=v[ l[i*3+1]*3 + 0];
-			n[i*6+4]=v[ l[i*3+1]*3 + 1];
-			n[i*6+5]=v[ l[i*3+1]*3 + 2];
+			l[i*3+0] = (x * (stacks + 1)) + y;
+			l[i*3+1] = (x * (stacks + 1)) + y + 1;
+			l[i*3+2] = 0;
+			n[i*6+0] = v[ l[i*3+0] * 3 + 0];
+			n[i*6+1] = v[ l[i*3+0] * 3 + 1];
+			n[i*6+2] = v[ l[i*3+0] * 3 + 2];
+			n[i*6+3] = v[ l[i*3+1] * 3 + 0];
+			n[i*6+4] = v[ l[i*3+1] * 3 + 1];
+			n[i*6+5] = v[ l[i*3+1] * 3 + 2];
 			i++;
 
 		}
 	}
-	o=s3d_new_object();
-	s3d_push_material(o,0,0,1,
-	                  1,0,0,
-	                  0,1,0);
-	s3d_push_vertices(o,v,num_v);
-	s3d_push_lines(o,l,num_l);
-	s3d_load_line_normals(o,n,0,num_l);
+	o = s3d_new_object();
+	s3d_push_material(o, 0, 0, 1,
+	                  1, 0, 0,
+	                  0, 1, 0);
+	s3d_push_vertices(o, v, num_v);
+	s3d_push_lines(o, l, num_l);
+	s3d_load_line_normals(o, n, 0, num_l);
 	free(v);
 	free(n);
 	free(l);
@@ -125,120 +125,120 @@
 	struct wlan_network *wlan_network;
 	float real_node_pos_x, real_node_pos_z, angle, angle_rad;
 	int network_index = 0;
-	char label_str[101];	/* safe to do as long as we use strn* functions */
-	float maxlen,templen;
+	char label_str[101]; /* safe to do as long as we use strn* functions */
+	float maxlen, templen;
 
 
-	pthread_mutex_lock( &amp;Network_list_mutex );
+	pthread_mutex_lock(&amp;Network_list_mutex);
 
 	list_for_each(network_pos, &amp;Network_list) {
 
 		wlan_network = list_entry(network_pos, struct wlan_network, list);
 
-		if ( wlan_network-&gt;visible ) {
+		if (wlan_network-&gt;visible) {
 
 			network_index++;
 
-			if ( wlan_network-&gt;obj_id == -1 ) {
+			if (wlan_network-&gt;obj_id == -1) {
 
 				wlan_network-&gt;obj_id = s3d_new_object();
-				wlan_network-&gt;wrsphr_id = wire_sphere( 30, 30 );
-				s3d_link( wlan_network-&gt;wrsphr_id, wlan_network-&gt;obj_id );
-				s3d_flags_on( wlan_network-&gt;wrsphr_id, S3D_OF_VISIBLE );
+				wlan_network-&gt;wrsphr_id = wire_sphere(30, 30);
+				s3d_link(wlan_network-&gt;wrsphr_id, wlan_network-&gt;obj_id);
+				s3d_flags_on(wlan_network-&gt;wrsphr_id, S3D_OF_VISIBLE);
 
 			}
 
 
 			wlan_network-&gt;scale_fac = wlan_network-&gt;num_wlan_clients + 2;
-			s3d_translate( wlan_network-&gt;wrsphr_id, 0, /*-6 + wlan_network-&gt;scale_fac*/ 0, 0);
-			s3d_scale( wlan_network-&gt;obj_id, wlan_network-&gt;scale_fac );
+			s3d_translate(wlan_network-&gt;wrsphr_id, 0, /*-6 + wlan_network-&gt;scale_fac*/ 0, 0);
+			s3d_scale(wlan_network-&gt;obj_id, wlan_network-&gt;scale_fac);
 
-			real_node_pos_x = sin( 2.0 * M_PI * network_index / ((float) Num_networks ) ) * ( ( ( 1 * Num_networks ) / 2 * M_PI ) );
-			real_node_pos_z = cos( 2.0 * M_PI * network_index / ((float) Num_networks ) ) * ( ( ( 1 * Num_networks ) / 2 * M_PI ) );
+			real_node_pos_x = sin(2.0 * M_PI * network_index / ((float) Num_networks)) * (((1 * Num_networks) / 2 * M_PI));
+			real_node_pos_z = cos(2.0 * M_PI * network_index / ((float) Num_networks)) * (((1 * Num_networks) / 2 * M_PI));
 
-			if ( ( fabs( wlan_network-&gt;pos_vec[0] - real_node_pos_x ) &gt; 0.5 ) || ( fabs( wlan_network-&gt;pos_vec[2] - real_node_pos_z ) &gt; 0.5 ) ) {
+			if ((fabs(wlan_network-&gt;pos_vec[0] - real_node_pos_x) &gt; 0.5) || (fabs(wlan_network-&gt;pos_vec[2] - real_node_pos_z) &gt; 0.5)) {
 
-				if ( fabs( wlan_network-&gt;pos_vec[0] - real_node_pos_x ) &gt; 0.5 )
-					wlan_network-&gt;pos_vec[0] = ( ( wlan_network-&gt;pos_vec[0] * 9 + real_node_pos_x ) / 10 );
+				if (fabs(wlan_network-&gt;pos_vec[0] - real_node_pos_x) &gt; 0.5)
+					wlan_network-&gt;pos_vec[0] = ((wlan_network-&gt;pos_vec[0] * 9 + real_node_pos_x) / 10);
 
-				if ( fabs( wlan_network-&gt;pos_vec[2] - real_node_pos_z ) &gt; 0.5 )
-					wlan_network-&gt;pos_vec[2] = ( ( wlan_network-&gt;pos_vec[2] * 9 + real_node_pos_z ) / 10 );
+				if (fabs(wlan_network-&gt;pos_vec[2] - real_node_pos_z) &gt; 0.5)
+					wlan_network-&gt;pos_vec[2] = ((wlan_network-&gt;pos_vec[2] * 9 + real_node_pos_z) / 10);
 
-				s3d_translate( wlan_network-&gt;obj_id, wlan_network-&gt;pos_vec[0], wlan_network-&gt;pos_vec[1], wlan_network-&gt;pos_vec[2] );
+				s3d_translate(wlan_network-&gt;obj_id, wlan_network-&gt;pos_vec[0], wlan_network-&gt;pos_vec[1], wlan_network-&gt;pos_vec[2]);
 
 			}
 
-			if ( wlan_network-&gt;props_changed ) {
-				snprintf( label_str, 100, &quot;Type: %s, CH: %i, Clients: %i&quot;, ( wlan_network-&gt;type == 0 ? &quot;Managed&quot; : ( wlan_network-&gt;type == 1 ? &quot;Ad-Hoc&quot; : ( wlan_network-&gt;type == 2 ? &quot;Prober&quot; : &quot;unknown&quot; ) ) ), wlan_network-&gt;chan, wlan_network-&gt;num_wlan_clients );
+			if (wlan_network-&gt;props_changed) {
+				snprintf(label_str, 100, &quot;Type: %s, CH: %i, Clients: %i&quot;, (wlan_network-&gt;type == 0 ? &quot;Managed&quot; : (wlan_network-&gt;type == 1 ? &quot;Ad-Hoc&quot; : (wlan_network-&gt;type == 2 ? &quot;Prober&quot; : &quot;unknown&quot;))), wlan_network-&gt;chan, wlan_network-&gt;num_wlan_clients);
 
 				/* determine our longest string which we draw */
-				maxlen = s3d_strlen( label_str );
+				maxlen = s3d_strlen(label_str);
 
-				if ( ( templen = s3d_strlen( wlan_network-&gt;ssid ) ) &gt; maxlen )
+				if ((templen = s3d_strlen(wlan_network-&gt;ssid)) &gt; maxlen)
 					maxlen = templen;
 
-				if ( ( templen = s3d_strlen( wlan_network-&gt;bssid ) ) &gt; maxlen )
+				if ((templen = s3d_strlen(wlan_network-&gt;bssid)) &gt; maxlen)
 					maxlen = templen;
 
 				wlan_network-&gt;props_changed = 0;
 
-				if ( wlan_network-&gt;ssid_id != -1 )
-					s3d_del_object( wlan_network-&gt;ssid_id );
+				if (wlan_network-&gt;ssid_id != -1)
+					s3d_del_object(wlan_network-&gt;ssid_id);
 
-				if ( wlan_network-&gt;misc_id != -1 )
-					s3d_del_object( wlan_network-&gt;misc_id );
+				if (wlan_network-&gt;misc_id != -1)
+					s3d_del_object(wlan_network-&gt;misc_id);
 
 
-				if ( wlan_network-&gt;bssid_id == -1 ) {
+				if (wlan_network-&gt;bssid_id == -1) {
 
-					wlan_network-&gt;bssid_id = s3d_draw_string( wlan_network-&gt;bssid, NULL );
+					wlan_network-&gt;bssid_id = s3d_draw_string(wlan_network-&gt;bssid, NULL);
 					wlan_network-&gt;text_width = maxlen; /* the other strings might be longer, so we use the longest string for calculating our rotation. */
-					s3d_link( wlan_network-&gt;bssid_id, wlan_network-&gt;obj_id );
-					s3d_translate( wlan_network-&gt;bssid_id, - maxlen / 2, 2 + wlan_network-&gt;scale_fac, 0 );
-					s3d_scale( wlan_network-&gt;bssid_id, NETWORK_TEXT_SCALE );
-					s3d_flags_on( wlan_network-&gt;bssid_id, S3D_OF_VISIBLE );
+					s3d_link(wlan_network-&gt;bssid_id, wlan_network-&gt;obj_id);
+					s3d_translate(wlan_network-&gt;bssid_id, - maxlen / 2, 2 + wlan_network-&gt;scale_fac, 0);
+					s3d_scale(wlan_network-&gt;bssid_id, NETWORK_TEXT_SCALE);
+					s3d_flags_on(wlan_network-&gt;bssid_id, S3D_OF_VISIBLE);
 
 					wlan_network-&gt;click_id = s3d_new_object();
-					s3d_link( wlan_network-&gt;click_id, wlan_network-&gt;bssid_id );
-					s3d_push_material( wlan_network-&gt;click_id, 0,0,0,  0,0,0,  0,0,0);
-					s3d_push_vertex( wlan_network-&gt;click_id, 0, 1, 0.1 );
-					s3d_push_vertex( wlan_network-&gt;click_id, maxlen, 1, 0.1 );
-					s3d_push_vertex( wlan_network-&gt;click_id, maxlen, -2.5, 0.1 ); /* 3 lines of text + some mor space for low characters, like g,q,p ... */
-					s3d_push_vertex( wlan_network-&gt;click_id, 0, -2.5, 0.1 );
-					s3d_push_polygon( wlan_network-&gt;click_id, 0, 1, 2, 0 );
-					s3d_push_polygon( wlan_network-&gt;click_id, 0, 2, 3, 0 );
+					s3d_link(wlan_network-&gt;click_id, wlan_network-&gt;bssid_id);
+					s3d_push_material(wlan_network-&gt;click_id, 0, 0, 0,  0, 0, 0,  0, 0, 0);
+					s3d_push_vertex(wlan_network-&gt;click_id, 0, 1, 0.1);
+					s3d_push_vertex(wlan_network-&gt;click_id, maxlen, 1, 0.1);
+					s3d_push_vertex(wlan_network-&gt;click_id, maxlen, -2.5, 0.1);   /* 3 lines of text + some mor space for low characters, like g,q,p ... */
+					s3d_push_vertex(wlan_network-&gt;click_id, 0, -2.5, 0.1);
+					s3d_push_polygon(wlan_network-&gt;click_id, 0, 1, 2, 0);
+					s3d_push_polygon(wlan_network-&gt;click_id, 0, 2, 3, 0);
 
-					s3d_flags_on( wlan_network-&gt;click_id, S3D_OF_SELECTABLE );
+					s3d_flags_on(wlan_network-&gt;click_id, S3D_OF_SELECTABLE);
 
 				}
 
-				wlan_network-&gt;ssid_id = s3d_draw_string( wlan_network-&gt;ssid, NULL );
-				s3d_link( wlan_network-&gt;ssid_id, wlan_network-&gt;bssid_id );
-				s3d_translate( wlan_network-&gt;ssid_id, 0, -1, 0 );
-				s3d_flags_on( wlan_network-&gt;ssid_id, S3D_OF_VISIBLE );
+				wlan_network-&gt;ssid_id = s3d_draw_string(wlan_network-&gt;ssid, NULL);
+				s3d_link(wlan_network-&gt;ssid_id, wlan_network-&gt;bssid_id);
+				s3d_translate(wlan_network-&gt;ssid_id, 0, -1, 0);
+				s3d_flags_on(wlan_network-&gt;ssid_id, S3D_OF_VISIBLE);
 
 
-				wlan_network-&gt;misc_id = s3d_draw_string( label_str, NULL );
-				s3d_link( wlan_network-&gt;misc_id, wlan_network-&gt;ssid_id );
-				s3d_translate( wlan_network-&gt;misc_id, 0, -1, 0 );
-				s3d_flags_on( wlan_network-&gt;misc_id, S3D_OF_VISIBLE );
+				wlan_network-&gt;misc_id = s3d_draw_string(label_str, NULL);
+				s3d_link(wlan_network-&gt;misc_id, wlan_network-&gt;ssid_id);
+				s3d_translate(wlan_network-&gt;misc_id, 0, -1, 0);
+				s3d_flags_on(wlan_network-&gt;misc_id, S3D_OF_VISIBLE);
 
 			}
 
-			angle = s3d_angle_to_cam( wlan_network-&gt;pos_vec, CamPosition[0], &amp;angle_rad );
-			s3d_rotate( wlan_network-&gt;bssid_id, 0, angle , 0 );
+			angle = s3d_angle_to_cam(wlan_network-&gt;pos_vec, CamPosition[0], &amp;angle_rad);
+			s3d_rotate(wlan_network-&gt;bssid_id, 0, angle , 0);
 
-			s3d_translate( wlan_network-&gt;bssid_id, -cos(angle_rad) * NETWORK_TEXT_SCALE * wlan_network-&gt;text_width / 2 ,2 , sin(angle_rad) * NETWORK_TEXT_SCALE * wlan_network-&gt;text_width / 2 );
+			s3d_translate(wlan_network-&gt;bssid_id, -cos(angle_rad) * NETWORK_TEXT_SCALE * wlan_network-&gt;text_width / 2 , 2 , sin(angle_rad) * NETWORK_TEXT_SCALE * wlan_network-&gt;text_width / 2);
 
-			wlan_network-&gt;rotation = ( wlan_network-&gt;rotation + 1 ) % 360;
-			s3d_rotate( wlan_network-&gt;wrsphr_id, 0, wlan_network-&gt;rotation, 0 );
+			wlan_network-&gt;rotation = (wlan_network-&gt;rotation + 1) % 360;
+			s3d_rotate(wlan_network-&gt;wrsphr_id, 0, wlan_network-&gt;rotation, 0);
 
 		}
 
 	}
 
 
-	pthread_mutex_unlock( &amp;Network_list_mutex );
+	pthread_mutex_unlock(&amp;Network_list_mutex);
 
 	return(0);
 
@@ -254,49 +254,49 @@
 	float angle, angle_rad;
 
 
-	pthread_mutex_lock( &amp;Client_list_mutex );
+	pthread_mutex_lock(&amp;Client_list_mutex);
 
 	list_for_each(client_pos, &amp;Client_list) {
 
 		wlan_client = list_entry(client_pos, struct wlan_client, list);
 
-		if ( wlan_client-&gt;visible ) {
+		if (wlan_client-&gt;visible) {
 
-			if ( wlan_client-&gt;obj_id == -1 ) {
+			if (wlan_client-&gt;obj_id == -1) {
 
 				wlan_client-&gt;obj_id = s3d_new_object();
-				wlan_client-&gt;symbol_id = s3d_clone( Client_obj );
-				s3d_link( wlan_client-&gt;symbol_id, wlan_client-&gt;obj_id );
-				s3d_flags_on( wlan_client-&gt;symbol_id, S3D_OF_VISIBLE );
+				wlan_client-&gt;symbol_id = s3d_clone(Client_obj);
+				s3d_link(wlan_client-&gt;symbol_id, wlan_client-&gt;obj_id);
+				s3d_flags_on(wlan_client-&gt;symbol_id, S3D_OF_VISIBLE);
 
 			}
 
-			if ( wlan_client-&gt;props_changed ) {
+			if (wlan_client-&gt;props_changed) {
 
 				wlan_client-&gt;props_changed = 0;
 
-				if ( wlan_client-&gt;ip_id != -1 )
-					s3d_del_object( wlan_client-&gt;ip_id );
+				if (wlan_client-&gt;ip_id != -1)
+					s3d_del_object(wlan_client-&gt;ip_id);
 
-				wlan_client-&gt;ip_id = s3d_draw_string( wlan_client-&gt;ip, &amp;wlan_client-&gt;ip_len );
-				s3d_link( wlan_client-&gt;ip_id, wlan_client-&gt;obj_id );
-				s3d_translate( wlan_client-&gt;ip_id, - wlan_client-&gt;ip_len / 2, 2, 0 );
-				s3d_scale( wlan_client-&gt;ip_id, CLIENT_TEXT_SCALE );
-				s3d_flags_on( wlan_client-&gt;ip_id, S3D_OF_VISIBLE );
+				wlan_client-&gt;ip_id = s3d_draw_string(wlan_client-&gt;ip, &amp;wlan_client-&gt;ip_len);
+				s3d_link(wlan_client-&gt;ip_id, wlan_client-&gt;obj_id);
+				s3d_translate(wlan_client-&gt;ip_id, - wlan_client-&gt;ip_len / 2, 2, 0);
+				s3d_scale(wlan_client-&gt;ip_id, CLIENT_TEXT_SCALE);
+				s3d_flags_on(wlan_client-&gt;ip_id, S3D_OF_VISIBLE);
 
 			}
 
-			angle = s3d_angle_to_cam( wlan_client-&gt;pos_vec, CamPosition[0], &amp;angle_rad );
-			s3d_rotate( wlan_client-&gt;ip_id, 0, angle , 0 );
+			angle = s3d_angle_to_cam(wlan_client-&gt;pos_vec, CamPosition[0], &amp;angle_rad);
+			s3d_rotate(wlan_client-&gt;ip_id, 0, angle , 0);
 
-			s3d_translate( wlan_client-&gt;ip_id, -cos(angle_rad) * CLIENT_TEXT_SCALE * wlan_client-&gt;ip_len / 2 ,2 , sin(angle_rad) * CLIENT_TEXT_SCALE * wlan_client-&gt;ip_len / 2 );
+			s3d_translate(wlan_client-&gt;ip_id, -cos(angle_rad) * CLIENT_TEXT_SCALE * wlan_client-&gt;ip_len / 2 , 2 , sin(angle_rad) * CLIENT_TEXT_SCALE * wlan_client-&gt;ip_len / 2);
 
 		}
 
 	}
 
 
-	pthread_mutex_unlock( &amp;Client_list_mutex );
+	pthread_mutex_unlock(&amp;Client_list_mutex);
 
 	return(0);
 
@@ -315,19 +315,19 @@
 
 	struct list_head *network_pos;
 	struct wlan_network *wlan_network;
-	int clicked_id = (int)*((uint32_t *)evt-&gt;buf);
+	int clicked_id = (int) * ((uint32_t *)evt-&gt;buf);
 
 
-	s3dw_handle_click( evt );
+	s3dw_handle_click(evt);
 
 	/* emulate double click */
-	if ( ( Last_Click_Oid == clicked_id ) &amp;&amp; ( Last_Click_Time + 250 &gt; get_time() ) ) {
+	if ((Last_Click_Oid == clicked_id) &amp;&amp; (Last_Click_Time + 250 &gt; get_time())) {
 
-		list_for_each( network_pos, &amp;Network_list ) {
+		list_for_each(network_pos, &amp;Network_list) {
 
 			wlan_network = list_entry(network_pos, struct wlan_network, list);
 
-			if ( wlan_network-&gt;click_id == clicked_id ) {
+			if (wlan_network-&gt;click_id == clicked_id) {
 
 				Cam_target = wlan_network;
 				break;
@@ -363,7 +363,7 @@
 	inf = (struct s3d_obj_info *)hrmz-&gt;buf;
 	s3dw_object_info(hrmz);
 
-	if ( inf-&gt;object == 0 ) {
+	if (inf-&gt;object == 0) {
 
 		CamPosition[0][0] = inf-&gt;trans_x;
 		CamPosition[0][1] = inf-&gt;trans_y;
@@ -389,57 +389,57 @@
 	handle_networks();
 	handle_clients();
 
-	if ( Cam_target != NULL ) {
+	if (Cam_target != NULL) {
 
 		/* move to target */
 		/* printf( &quot;Moving to Network: %s, %s\n&quot;, ((struct wlan_network *)Cam_target)-&gt;bssid, ((struct wlan_network *)Cam_target)-&gt;ssid ); */
 
-		CamPosition[0][0] = ( CamPosition[0][0] * 4 + ((struct wlan_network *)Cam_target)-&gt;pos_vec[0] + 10 ) / 5;
-		CamPosition[0][1] = ( CamPosition[0][1] * 4 + ((struct wlan_network *)Cam_target)-&gt;pos_vec[1] ) / 5;
-		CamPosition[0][2] = ( CamPosition[0][2] * 4 + ((struct wlan_network *)Cam_target)-&gt;pos_vec[2] ) / 5;
+		CamPosition[0][0] = (CamPosition[0][0] * 4 + ((struct wlan_network *)Cam_target)-&gt;pos_vec[0] + 10) / 5;
+		CamPosition[0][1] = (CamPosition[0][1] * 4 + ((struct wlan_network *)Cam_target)-&gt;pos_vec[1]) / 5;
+		CamPosition[0][2] = (CamPosition[0][2] * 4 + ((struct wlan_network *)Cam_target)-&gt;pos_vec[2]) / 5;
 
 		diff_vec[0] = CamPosition[0][0] - ((struct wlan_network *)Cam_target)-&gt;pos_vec[0];
 		diff_vec[1] = 0.0;
 		diff_vec[2] = CamPosition[0][2] - ((struct wlan_network *)Cam_target)-&gt;pos_vec[2];
 
-		angle = s3d_vector_angle( diff_vec, tmp_vec );
-		angle = 180 - ( 180 / M_PI * angle );
-		CamPosition[1][1] = ( CamPosition[1][1] * 4 + angle ) / 5;
+		angle = s3d_vector_angle(diff_vec, tmp_vec);
+		angle = 180 - (180 / M_PI * angle);
+		CamPosition[1][1] = (CamPosition[1][1] * 4 + angle) / 5;
 
-		s3d_translate( 0, CamPosition[0][0], CamPosition[0][1], CamPosition[0][2] );
-		s3d_rotate( 0, CamPosition[1][0], CamPosition[1][1], CamPosition[1][2] );
+		s3d_translate(0, CamPosition[0][0], CamPosition[0][1], CamPosition[0][2]);
+		s3d_rotate(0, CamPosition[1][0], CamPosition[1][1], CamPosition[1][2]);
 
-		if ( ( fabs( diff_vec[0] ) &lt; 11.0 ) &amp;&amp; ( fabs( CamPosition[0][1] - ((struct wlan_network *)Cam_target)-&gt;pos_vec[1] ) &lt; 1.0 ) &amp;&amp; ( fabs( diff_vec[2] ) &lt; 1.0 ) )
+		if ((fabs(diff_vec[0]) &lt; 11.0) &amp;&amp; (fabs(CamPosition[0][1] - ((struct wlan_network *)Cam_target)-&gt;pos_vec[1]) &lt; 1.0) &amp;&amp; (fabs(diff_vec[2]) &lt; 1.0))
 			Cam_target = NULL;
 
 	}
 
-	if ( Kism3d_aborted )
+	if (Kism3d_aborted)
 		s3d_quit();
 
-	nanosleep( &amp;sleeptime, NULL );
+	nanosleep(&amp;sleeptime, NULL);
 
 }
 
 
 
-void* gui_main( void *unused )
+void* gui_main(void *unused)
 {
 
-	if ( !s3d_init( NULL, NULL, &quot;kism3d&quot; ) ) {
+	if (!s3d_init(NULL, NULL, &quot;kism3d&quot;)) {
 
-		if ( s3d_select_font( &quot;vera&quot; ) ) {
+		if (s3d_select_font(&quot;vera&quot;)) {
 
-			printf( &quot;font 'vera' not found\n&quot; );
+			printf(&quot;font 'vera' not found\n&quot;);
 
 		} else {
 
-			s3d_set_callback( S3D_EVENT_OBJ_INFO, object_info );
-			s3d_set_callback( S3D_EVENT_OBJ_CLICK, object_click );
+			s3d_set_callback(S3D_EVENT_OBJ_INFO, object_info);
+			s3d_set_callback(S3D_EVENT_OBJ_CLICK, object_click);
 
-			Client_obj = s3d_import_model_file( &quot;objs/accesspoint.3ds&quot; );
+			Client_obj = s3d_import_model_file(&quot;objs/accesspoint.3ds&quot;);
 
-			s3d_mainloop( mainloop );
+			s3d_mainloop(mainloop);
 
 		}
 

Modified: trunk/apps/kism3d/kism3d.c
===================================================================
--- trunk/apps/kism3d/kism3d.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/kism3d/kism3d.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -52,17 +52,17 @@
 
 
 
-void *alloc_memory( int len )
+void *alloc_memory(int len)
 {
 
-	void *res = malloc( len );
+	void *res = malloc(len);
 
-	if ( res == NULL ) {
-		printf( &quot;Error - can't allocate memory: %s\n&quot;, strerror(errno) );
+	if (res == NULL) {
+		printf(&quot;Error - can't allocate memory: %s\n&quot;, strerror(errno));
 		exit(1);
 	}
 
-	memset( res, 0, len );
+	memset(res, 0, len);
 
 	return res;
 
@@ -70,17 +70,17 @@
 
 
 
-void *realloc_memory( void *ptr, int len )
+void *realloc_memory(void *ptr, int len)
 {
 
-	void *res = realloc( ptr, len );
+	void *res = realloc(ptr, len);
 
 	if (res == NULL) {
-		printf( &quot;Error - can't trallocate memory: %s\n&quot;, strerror(errno) );
+		printf(&quot;Error - can't trallocate memory: %s\n&quot;, strerror(errno));
 		exit(1);
 	}
 
-	memset( res, 0, len );
+	memset(res, 0, len);
 
 	return res;
 
@@ -88,7 +88,7 @@
 
 
 
-unsigned int get_time( void )
+unsigned int get_time(void)
 {
 
 	struct timeval tv;
@@ -101,7 +101,7 @@
 
 
 
-void parse_buffer( struct kismet_src *kismet_src )
+void parse_buffer(struct kismet_src *kismet_src)
 {
 
 	struct wlan_network *wlan_network;
@@ -116,9 +116,9 @@
 	line_ptr = kismet_src-&gt;recv_buff;
 
 
-	while ( (*read_ptr) != '\0' ) {
+	while ((*read_ptr) != '\0') {
 
-		if ( (*read_ptr) == '\n' ) {
+		if ((*read_ptr) == '\n') {
 
 			last_cr_ptr = read_ptr;
 			*last_cr_ptr = '\0';
@@ -127,25 +127,25 @@
 
 			/* printf( &quot;line: %s\n&quot;, line_ptr ); */
 
-			if ( strncmp( line_ptr, &quot;*TIME: &quot;, strlen( &quot;*TIME: &quot; ) ) == 0 ) {
+			if (strncmp(line_ptr, &quot;*TIME: &quot;, strlen(&quot;*TIME: &quot;)) == 0) {
 
-				if ( kismet_src-&gt;enable_level &lt; 4 ) {
+				if (kismet_src-&gt;enable_level &lt; 4) {
 
-					switch ( kismet_src-&gt;enable_level ) {
+					switch (kismet_src-&gt;enable_level) {
 
 					case 0:
-						if ( write( kismet_src-&gt;sock, enable_alert, sizeof( enable_alert ) ) &lt; 0 ) {
+						if (write(kismet_src-&gt;sock, enable_alert, sizeof(enable_alert)) &lt; 0) {
 
-							printf( &quot;Warning - can't send ENABLE ALERT message to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno) );
+							printf(&quot;Warning - can't send ENABLE ALERT message to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno));
 
 						}
 
 						break;
 
 					case 1:
-						if ( write( kismet_src-&gt;sock, enable_client, sizeof( enable_client ) ) &lt; 0 ) {
+						if (write(kismet_src-&gt;sock, enable_client, sizeof(enable_client)) &lt; 0) {
 
-							printf( &quot;Warning - can't send ENABLE CLIENT message to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno) );
+							printf(&quot;Warning - can't send ENABLE CLIENT message to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno));
 
 						}
 
@@ -153,9 +153,9 @@
 
 					case 2:
 
-						if ( write( kismet_src-&gt;sock, enable_network, sizeof( enable_network ) ) &lt; 0 ) {
+						if (write(kismet_src-&gt;sock, enable_network, sizeof(enable_network)) &lt; 0) {
 
-							printf( &quot;Warning - can't send ENABLE NETWORK message to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno) );
+							printf(&quot;Warning - can't send ENABLE NETWORK message to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno));
 
 						}
 
@@ -163,10 +163,10 @@
 
 					case 3:
 
-						if ( !thread_running ) {
+						if (!thread_running) {
 
 							thread_running++;
-							pthread_create( &amp;s3d_thread_id, NULL, &amp;gui_main, NULL );
+							pthread_create(&amp;s3d_thread_id, NULL, &amp;gui_main, NULL);
 
 						}
 
@@ -178,19 +178,19 @@
 
 				}
 
-			} else if ( strncmp( line_ptr, &quot;*NETWORK: &quot;, strlen( &quot;*NETWORK: &quot; ) ) == 0 ) {
+			} else if (strncmp(line_ptr, &quot;*NETWORK: &quot;, strlen(&quot;*NETWORK: &quot;)) == 0) {
 
 				/* printf( &quot;line: %s\n&quot;, line_ptr ); */
 
-				parse_begin_ptr = parse_end_ptr = line_ptr + strlen( &quot;*NETWORK: &quot; );
+				parse_begin_ptr = parse_end_ptr = line_ptr + strlen(&quot;*NETWORK: &quot;);
 				end_char = ' ';
 				count = 0;
 
-				while ( (*parse_end_ptr) != '\0' ) {
+				while ((*parse_end_ptr) != '\0') {
 
-					if ( (*parse_end_ptr) == ' ' ) {
+					if ((*parse_end_ptr) == ' ') {
 
-						switch ( count ) {
+						switch (count) {
 
 						case 0:
 							bssid = parse_begin_ptr;
@@ -206,11 +206,11 @@
 
 						case 3:
 							/* ssids with spaces are quoted by kismet */
-							if ( parse_begin_ptr[0] == '\001' ) {
+							if (parse_begin_ptr[0] == '\001') {
 
 								parse_begin_ptr++;
 
-								parse_end_ptr = strchr( parse_begin_ptr, '\001' );
+								parse_end_ptr = strchr(parse_begin_ptr, '\001');
 								*parse_end_ptr = '\0';
 
 								count++;
@@ -222,7 +222,7 @@
 
 						}
 
-						if ( count == 4 )
+						if (count == 4)
 							break;
 
 						*parse_end_ptr = '\0';
@@ -237,39 +237,39 @@
 				}
 
 
-				pthread_mutex_lock( &amp;Network_list_mutex );
+				pthread_mutex_lock(&amp;Network_list_mutex);
 
-				wlan_network = get_wlan_network( bssid );
+				wlan_network = get_wlan_network(bssid);
 
-				if ( ( wlan_network-&gt;type != -1 ) &amp;&amp; ( wlan_network-&gt;chan != -1 ) &amp;&amp; ( wlan_network-&gt;ssid != NULL ) ) {
+				if ((wlan_network-&gt;type != -1) &amp;&amp; (wlan_network-&gt;chan != -1) &amp;&amp; (wlan_network-&gt;ssid != NULL)) {
 
 					/* network properties have changed - alert user */
 
 				}
 
-				wlan_network-&gt;type = atoi( type );
-				wlan_network-&gt;chan = atoi( channel );
+				wlan_network-&gt;type = atoi(type);
+				wlan_network-&gt;chan = atoi(channel);
 
-				if ( wlan_network-&gt;ssid != NULL )
-					free( wlan_network-&gt;ssid );
+				if (wlan_network-&gt;ssid != NULL)
+					free(wlan_network-&gt;ssid);
 
-				wlan_network-&gt;ssid = alloc_memory( strlen( ssid ) );
-				strcpy( wlan_network-&gt;ssid, ssid );
+				wlan_network-&gt;ssid = alloc_memory(strlen(ssid));
+				strcpy(wlan_network-&gt;ssid, ssid);
 
-				pthread_mutex_unlock( &amp;Network_list_mutex );
+				pthread_mutex_unlock(&amp;Network_list_mutex);
 
 				/* printf( &quot;network found - bssid %s, type %s, channel %s, ssid '%s' &lt;&gt; '%s'\n&quot;, bssid, type, channel, ssid, wlan_network-&gt;ssid ); */
 
-			} else if ( strncmp( line_ptr, &quot;*CLIENT: &quot;, strlen( &quot;*CLIENT: &quot; ) ) == 0 ) {
+			} else if (strncmp(line_ptr, &quot;*CLIENT: &quot;, strlen(&quot;*CLIENT: &quot;)) == 0) {
 
-				parse_begin_ptr = parse_end_ptr = line_ptr + strlen( &quot;*CLIENT: &quot; );
+				parse_begin_ptr = parse_end_ptr = line_ptr + strlen(&quot;*CLIENT: &quot;);
 				count = 0;
 
-				while ( (*parse_end_ptr) != '\0' ) {
+				while ((*parse_end_ptr) != '\0') {
 
-					if ( (*parse_end_ptr) == ' ' ) {
+					if ((*parse_end_ptr) == ' ') {
 
-						switch ( count ) {
+						switch (count) {
 
 						case 0:
 							bssid = parse_begin_ptr;
@@ -285,7 +285,7 @@
 
 						}
 
-						if ( count == 2 )
+						if (count == 2)
 							break;
 
 						*parse_end_ptr = '\0';
@@ -299,29 +299,29 @@
 
 				}
 
-				wlan_client = get_wlan_client( mac );
+				wlan_client = get_wlan_client(mac);
 
 				/*if ( ( wlan_client-&gt;type != -1 ) &amp;&amp; ( wlan_client-&gt;channel != -1 ) &amp;&amp; ( wlan_client-&gt;ssid != NULL ) ) {
 
-					 client properties have changed - alert user
+				  client properties have changed - alert user
 
 				}*/
 
-				strncpy( wlan_client-&gt;bssid, bssid, 18 );
-				strncpy( wlan_client-&gt;ip, ip, 16 );
+				strncpy(wlan_client-&gt;bssid, bssid, 18);
+				strncpy(wlan_client-&gt;ip, ip, 16);
 
-				wlan_network = find_wlan_network( wlan_client-&gt;bssid );
+				wlan_network = find_wlan_network(wlan_client-&gt;bssid);
 
-				if ( wlan_client-&gt;wlan_network != wlan_network ) {
+				if (wlan_client-&gt;wlan_network != wlan_network) {
 
-					if ( wlan_client-&gt;wlan_network != NULL ) {
+					if (wlan_client-&gt;wlan_network != NULL) {
 
 						wlan_client-&gt;wlan_network-&gt;num_wlan_clients--;
 						wlan_client-&gt;wlan_network-&gt;props_changed = 1;
 
 					}
 
-					if ( wlan_network != NULL ) {
+					if (wlan_network != NULL) {
 
 						wlan_network-&gt;num_wlan_clients++;
 						wlan_network-&gt;props_changed = 1;
@@ -335,7 +335,7 @@
 
 				/* printf( &quot;client found - bssid %s, mac %s, ip %s\n&quot;, bssid, mac, ip ); */
 
-			} else if ( strncmp( line_ptr, &quot;*ALERT: &quot;, strlen( &quot;*ALERT: &quot; ) ) == 0 ) {
+			} else if (strncmp(line_ptr, &quot;*ALERT: &quot;, strlen(&quot;*ALERT: &quot;)) == 0) {
 
 				/* printf( &quot;alert: %s\n&quot;, line_ptr + strlen( &quot;*ALERT: &quot; ) ); */
 
@@ -350,14 +350,14 @@
 
 	}
 
-	if ( last_cr_ptr != NULL )
-		memmove( kismet_src-&gt;recv_buff, last_cr_ptr + 1, strlen( last_cr_ptr ) );
+	if (last_cr_ptr != NULL)
+		memmove(kismet_src-&gt;recv_buff, last_cr_ptr + 1, strlen(last_cr_ptr));
 
 }
 
 
 
-int main( int argc, char *argv[] )
+int main(int argc, char *argv[])
 {
 
 	struct in_addr tmp_ip_holder;
@@ -374,25 +374,25 @@
 	FD_ZERO(&amp;wait_sockets);
 
 
-	while ( argc &gt; found_args ) {
+	while (argc &gt; found_args) {
 
-		kismet_src = alloc_memory( sizeof(struct kismet_src) );
+		kismet_src = alloc_memory(sizeof(struct kismet_src));
 
 		INIT_LIST_HEAD(&amp;kismet_src-&gt;list);
 		kismet_src-&gt;enable_level = 0;
 
 		/* get ip and port from argument */
-		if ( ( colon_ptr = strchr( argv[found_args], ':' ) ) != NULL ) {
+		if ((colon_ptr = strchr(argv[found_args], ':')) != NULL) {
 
 			*colon_ptr = '\0';
 			colon_ptr++;
 
 		}
 
-		if ( inet_pton(AF_INET, argv[found_args], &amp;tmp_ip_holder) &lt; 1 ) {
+		if (inet_pton(AF_INET, argv[found_args], &amp;tmp_ip_holder) &lt; 1) {
 
-			printf( &quot;Invalid kismet IP specified: %s\n&quot;, argv[found_args] );
-			free( kismet_src );
+			printf(&quot;Invalid kismet IP specified: %s\n&quot;, argv[found_args]);
+			free(kismet_src);
 			found_args++;
 			continue;
 
@@ -402,13 +402,13 @@
 
 		}
 
-		if ( colon_ptr != NULL ) {
+		if (colon_ptr != NULL) {
 
 			kismet_src-&gt;port = strtol(colon_ptr, NULL , 10);
 
-			if ( kismet_src-&gt;port &lt; 1 || kismet_src-&gt;port &gt; 65535 ) {
-				printf( &quot;Invalid kismet PORT specified: %s\n&quot;, colon_ptr );
-				free( kismet_src );
+			if (kismet_src-&gt;port &lt; 1 || kismet_src-&gt;port &gt; 65535) {
+				printf(&quot;Invalid kismet PORT specified: %s\n&quot;, colon_ptr);
+				free(kismet_src);
 				found_args++;
 				continue;
 			}
@@ -421,40 +421,40 @@
 
 
 		kismet_src-&gt;kismet_addr.sin_family = AF_INET;
-		kismet_src-&gt;kismet_addr.sin_port = htons( kismet_src-&gt;port );
+		kismet_src-&gt;kismet_addr.sin_port = htons(kismet_src-&gt;port);
 		kismet_src-&gt;kismet_addr.sin_addr.s_addr = kismet_src-&gt;ip;
 
-		kismet_src-&gt;kismet_ip = alloc_memory( 16 );
-		inet_ntop( AF_INET, &amp;kismet_src-&gt;ip, kismet_src-&gt;kismet_ip, 16 );
+		kismet_src-&gt;kismet_ip = alloc_memory(16);
+		inet_ntop(AF_INET, &amp;kismet_src-&gt;ip, kismet_src-&gt;kismet_ip, 16);
 
 
 		/* connect to kismet server */
-		if ( ( kismet_src-&gt;sock = socket( PF_INET, SOCK_STREAM, 0 ) ) &lt; 0 ) {
+		if ((kismet_src-&gt;sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
 
-			printf( &quot;Error - can't create tcp socket (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno) );
-			free( kismet_src-&gt;kismet_ip );
-			free( kismet_src );
+			printf(&quot;Error - can't create tcp socket (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno));
+			free(kismet_src-&gt;kismet_ip);
+			free(kismet_src);
 			found_args++;
 			continue;
 
 		}
 
-		if ( connect ( kismet_src-&gt;sock, (struct sockaddr *)&amp;kismet_src-&gt;kismet_addr, sizeof(struct sockaddr) ) &lt; 0 ) {
+		if (connect(kismet_src-&gt;sock, (struct sockaddr *)&amp;kismet_src-&gt;kismet_addr, sizeof(struct sockaddr)) &lt; 0) {
 
-			printf( &quot;Error - can't connect to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno) );
-			close( kismet_src-&gt;sock );
-			free( kismet_src-&gt;kismet_ip );
-			free( kismet_src );
+			printf(&quot;Error - can't connect to kismet server (%s:%i): %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno));
+			close(kismet_src-&gt;sock);
+			free(kismet_src-&gt;kismet_ip);
+			free(kismet_src);
 			found_args++;
 			continue;
 
 		}
 
 
-		kismet_src-&gt;recv_buff = alloc_memory( 1500 );
+		kismet_src-&gt;recv_buff = alloc_memory(1500);
 
-		FD_SET( kismet_src-&gt;sock, &amp;wait_sockets );
-		if ( kismet_src-&gt;sock &gt; max_sock )
+		FD_SET(kismet_src-&gt;sock, &amp;wait_sockets);
+		if (kismet_src-&gt;sock &gt; max_sock)
 			max_sock = kismet_src-&gt;sock;
 
 		list_add_tail(&amp;kismet_src-&gt;list, &amp;kismet_src_list);
@@ -466,86 +466,86 @@
 	}
 
 
-	if ( num_kismet_sources == 0 ) {
+	if (num_kismet_sources == 0) {
 
-		printf( &quot;Exiting - can't find any valid kismet server\n&quot; );
+		printf(&quot;Exiting - can't find any valid kismet server\n&quot;);
 		exit(EXIT_FAILURE);
 
 	}
 
 
-	while ( ( num_kismet_sources &gt; 0 ) &amp;&amp; !( Kism3d_aborted ) ) {
+	while ((num_kismet_sources &gt; 0) &amp;&amp; !(Kism3d_aborted)) {
 
 		tv.tv_sec = 0;
 		tv.tv_usec = 250;
 
 		tmp_wait_sockets = wait_sockets;
 
-		res = select( max_sock + 1, &amp;tmp_wait_sockets, NULL, NULL, &amp;tv );
+		res = select(max_sock + 1, &amp;tmp_wait_sockets, NULL, NULL, &amp;tv);
 
-		if ( res &gt; 0 ) {
+		if (res &gt; 0) {
 
 			max_sock = -1;
 
-			list_for_each_safe( kismet_pos, kismet_pos_tmp, &amp;kismet_src_list ) {
+			list_for_each_safe(kismet_pos, kismet_pos_tmp, &amp;kismet_src_list) {
 
-				kismet_src = list_entry( kismet_pos, struct kismet_src, list );
+				kismet_src = list_entry(kismet_pos, struct kismet_src, list);
 
-				if ( FD_ISSET( kismet_src-&gt;sock, &amp;tmp_wait_sockets ) ) {
+				if (FD_ISSET(kismet_src-&gt;sock, &amp;tmp_wait_sockets)) {
 
-					status = read( kismet_src-&gt;sock, buff, sizeof( buff ) );
+					status = read(kismet_src-&gt;sock, buff, sizeof(buff));
 
-					if ( status &gt; 0 ) {
+					if (status &gt; 0) {
 
-						if ( kismet_src-&gt;sock &gt; max_sock )
+						if (kismet_src-&gt;sock &gt; max_sock)
 							max_sock = kismet_src-&gt;sock;
 
 						buff[status] = '\0';
 
 						/* check for potential buffer overflow */
-						if ( ( strlen( kismet_src-&gt;recv_buff ) + strlen( buff ) ) &lt; 1500 ) {
+						if ((strlen(kismet_src-&gt;recv_buff) + strlen(buff)) &lt; 1500) {
 
-							strncat( kismet_src-&gt;recv_buff, buff, 1000 );
+							strncat(kismet_src-&gt;recv_buff, buff, 1000);
 
 						} else {
 
 							/* hope that carriage return is now in buffer */
-							if ( strlen( kismet_src-&gt;recv_buff ) &lt; 1500 ) {
+							if (strlen(kismet_src-&gt;recv_buff) &lt; 1500) {
 
-								printf( &quot;WARNING: receive buffer almost filled without *any* carriage return within that data !\nAppending truncated buffer to receive buffer to prevent buffer overflow.\n&quot; );
-								strncat( kismet_src-&gt;recv_buff, buff, 1500 - strlen( kismet_src-&gt;recv_buff ) );
+								printf(&quot;WARNING: receive buffer almost filled without *any* carriage return within that data !\nAppending truncated buffer to receive buffer to prevent buffer overflow.\n&quot;);
+								strncat(kismet_src-&gt;recv_buff, buff, 1500 - strlen(kismet_src-&gt;recv_buff));
 
 							} else {
 
-								printf( &quot;ERROR: receive buffer filled without *any* carriage return within that data !\nClearing receive buffer to prevent buffer overflow.\n&quot; );
-								strncpy( kismet_src-&gt;recv_buff, buff, 1000 );
+								printf(&quot;ERROR: receive buffer filled without *any* carriage return within that data !\nClearing receive buffer to prevent buffer overflow.\n&quot;);
+								strncpy(kismet_src-&gt;recv_buff, buff, 1000);
 
 							}
 
 						}
 
-						parse_buffer( kismet_src );
+						parse_buffer(kismet_src);
 
 						/* printf( &quot;buffer length: %i\n&quot;, strlen( kismet_src-&gt;recv_buff ) ); */
 
 					} else {
 
-						if ( status &lt; 0 ) {
+						if (status &lt; 0) {
 
-							printf( &quot;Error - can't read message from %s:%i: %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno) );
+							printf(&quot;Error - can't read message from %s:%i: %s\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port, strerror(errno));
 
 						} else {
 
-							printf( &quot;Kismet server %s:%i closed connection ...\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port );
+							printf(&quot;Kismet server %s:%i closed connection ...\n&quot;, kismet_src-&gt;kismet_ip, kismet_src-&gt;port);
 
 						}
 
 						FD_CLR(kismet_src-&gt;sock, &amp;wait_sockets);
-						close( kismet_src-&gt;sock );
+						close(kismet_src-&gt;sock);
 
-						list_del( kismet_pos );
-						free( kismet_src-&gt;kismet_ip );
-						free( kismet_pos );
+						list_del(kismet_pos);
+						free(kismet_src-&gt;kismet_ip);
+						free(kismet_pos);
 
 						num_kismet_sources--;
 
@@ -553,16 +553,16 @@
 
 				} else {
 
-					if ( kismet_src-&gt;sock &gt; max_sock )
+					if (kismet_src-&gt;sock &gt; max_sock)
 						max_sock = kismet_src-&gt;sock;
 
 				}
 
 			}
 
-		} else if ( ( res &lt; 0 ) &amp;&amp; (errno != EINTR) ) {
+		} else if ((res &lt; 0) &amp;&amp; (errno != EINTR)) {
 
-			printf( &quot;Error - can't select: %s\n&quot;, strerror(errno) );
+			printf(&quot;Error - can't select: %s\n&quot;, strerror(errno));
 			break;
 
 		}
@@ -571,9 +571,9 @@
 
 		list_for_each_safe(kismet_pos, kismet_pos_tmp, &amp;Network_list) {
 
-			wlan_network = list_entry(kismet_pos, struct wlan_network, list);
+		 wlan_network = list_entry(kismet_pos, struct wlan_network, list);
 
-			printf( &quot;   =&gt; %s\n&quot;, wlan_network-&gt;bssid );
+		 printf( &quot;   =&gt; %s\n&quot;, wlan_network-&gt;bssid );
 
 		}
 
@@ -581,30 +581,30 @@
 
 		list_for_each_safe(kismet_pos, kismet_pos_tmp, &amp;Client_list) {
 
-			wlan_client = list_entry(kismet_pos, struct wlan_client, list);
+		 wlan_client = list_entry(kismet_pos, struct wlan_client, list);
 
-			printf( &quot;   =&gt; %s belonging to %s\n&quot;, wlan_client-&gt;mac, ( wlan_client-&gt;wlan_network == NULL ? &quot;unknown&quot; : wlan_client-&gt;wlan_network-&gt;bssid ) );
+		 printf( &quot;   =&gt; %s belonging to %s\n&quot;, wlan_client-&gt;mac, ( wlan_client-&gt;wlan_network == NULL ? &quot;unknown&quot; : wlan_client-&gt;wlan_network-&gt;bssid ) );
 
 		} */
 
 	}
 
 
-	if ( Kism3d_aborted ) {
+	if (Kism3d_aborted) {
 
-		printf( &quot;Closing all sockets ... \n&quot; );
+		printf(&quot;Closing all sockets ... \n&quot;);
 		list_for_each(kismet_pos, &amp;kismet_src_list) {
 
-			kismet_src = list_entry( kismet_pos, struct kismet_src, list );
+			kismet_src = list_entry(kismet_pos, struct kismet_src, list);
 
-			close( kismet_src-&gt;sock );
+			close(kismet_src-&gt;sock);
 
 		}
 
 	} else {
 
 		Kism3d_aborted = 1;
-		pthread_join( s3d_thread_id, NULL );
+		pthread_join(s3d_thread_id, NULL);
 
 	}
 

Modified: trunk/apps/kism3d/kism3d.h
===================================================================
--- trunk/apps/kism3d/kism3d.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/kism3d/kism3d.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -92,12 +92,12 @@
 
 
 
-void *alloc_memory( int len );
-unsigned int get_time( void );
-struct wlan_network *get_wlan_network( char *bssid );
-struct wlan_network *find_wlan_network( char *bssid );
-struct wlan_client *get_wlan_client( char *mac );
-void* gui_main( void *unused );
+void *alloc_memory(int len);
+unsigned int get_time(void);
+struct wlan_network *get_wlan_network(char *bssid);
+struct wlan_network *find_wlan_network(char *bssid);
+struct wlan_client *get_wlan_client(char *mac);
+void* gui_main(void *unused);
 
 
 

Modified: trunk/apps/kism3d/list.h
===================================================================
--- trunk/apps/kism3d/list.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/kism3d/list.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -30,42 +30,42 @@
 
 
 #define DEFINE_LIST_HEAD(name) \
-	struct list_head name = { &amp;(name), &amp;(name) }
+ struct list_head name = { &amp;(name), &amp;(name) }
 
 #define INIT_LIST_HEAD(ptr) do { \
-	(ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); \
+ (ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); \
 } while (0)
 
 
 /**
- * list_for_each	-	iterate over a list
- * @pos:	the &amp;struct list_head to use as a loop counter.
- * @head:	the head for your list.
+ * list_for_each - iterate over a list
+ * @pos: the &amp;struct list_head to use as a loop counter.
+ * @head: the head for your list.
  */
 #define list_for_each(pos, head) \
-	for (pos = (head)-&gt;next; pos != (head); \
-        	pos = pos-&gt;next)
+ for (pos = (head)-&gt;next; pos != (head); \
+         pos = pos-&gt;next)
 
 
 /**
  * list_for_each_safe - iterate over a list safe against removal of list entry
- * @pos:	the &amp;struct list_head to use as a loop counter.
- * @n:		another &amp;struct list_head to use as temporary storage
- * @head:	the head for your list.
+ * @pos: the &amp;struct list_head to use as a loop counter.
+ * @n:  another &amp;struct list_head to use as temporary storage
+ * @head: the head for your list.
  */
 #define list_for_each_safe(pos, n, head) \
-	for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \
-		pos = n, n = pos-&gt;next)
+ for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \
+  pos = n, n = pos-&gt;next)
 
 
 /**
  * list_entry - get the struct for this entry
- * @ptr:	the &amp;struct list_head pointer.
- * @type:	the type of the struct this is embedded in.
- * @member:	the name of the list_struct within the struct.
+ * @ptr: the &amp;struct list_head pointer.
+ * @type: the type of the struct this is embedded in.
+ * @member: the name of the list_struct within the struct.
  */
 #define list_entry(ptr, type, member) \
-	((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))
+ ((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))
 
 
 

Modified: trunk/apps/kism3d/network.c
===================================================================
--- trunk/apps/kism3d/network.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/kism3d/network.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -29,23 +29,23 @@
 
 
 
-struct wlan_network *get_wlan_network( char *bssid ) {
+struct wlan_network *get_wlan_network(char *bssid) {
 
 	struct wlan_network *wlan_network;
 
 
-	wlan_network = find_wlan_network( bssid );
+	wlan_network = find_wlan_network(bssid);
 
-	if ( wlan_network != NULL )
+	if (wlan_network != NULL)
 		return wlan_network;
 
 
 	/* we reached the end of the list and must create a new wlan_network */
-	wlan_network = alloc_memory( sizeof( struct wlan_network ) );
+	wlan_network = alloc_memory(sizeof(struct wlan_network));
 
 	INIT_LIST_HEAD(&amp;wlan_network-&gt;list);
 
-	strncpy( wlan_network-&gt;bssid, bssid, 18 );
+	strncpy(wlan_network-&gt;bssid, bssid, 18);
 
 	wlan_network-&gt;type = -1;
 	wlan_network-&gt;chan = -1;
@@ -78,7 +78,7 @@
 
 
 
-struct wlan_network *find_wlan_network( char *bssid ) {
+struct wlan_network *find_wlan_network(char *bssid) {
 
 	struct list_head *network_pos;
 	struct wlan_network *wlan_network;
@@ -88,7 +88,7 @@
 
 		wlan_network = list_entry(network_pos, struct wlan_network, list);
 
-		if ( strncmp( wlan_network-&gt;bssid, bssid, 18 ) == 0 )
+		if (strncmp(wlan_network-&gt;bssid, bssid, 18) == 0)
 			return wlan_network;
 
 	}

Modified: trunk/apps/meshs3d/allocate.c
===================================================================
--- trunk/apps/meshs3d/allocate.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/allocate.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -60,15 +60,15 @@
 };
 
 
-void addMemory( uint32_t length, int32_t tag )
+void addMemory(uint32_t length, int32_t tag)
 {
 
 	struct memoryUsage *walker;
 
 
-	for ( walker = memoryList; walker != NULL; walker = walker-&gt;next ) {
+	for (walker = memoryList; walker != NULL; walker = walker-&gt;next) {
 
-		if ( walker-&gt;tag == tag ) {
+		if (walker-&gt;tag == tag) {
 
 			walker-&gt;counter++;
 			break;
@@ -77,9 +77,9 @@
 
 	}
 
-	if ( walker == NULL ) {
+	if (walker == NULL) {
 
-		walker = malloc( sizeof(struct memoryUsage) );
+		walker = malloc(sizeof(struct memoryUsage));
 
 		walker-&gt;length = length;
 		walker-&gt;tag = tag;
@@ -93,19 +93,19 @@
 }
 
 
-void removeMemory( int32_t tag, int32_t freetag )
+void removeMemory(int32_t tag, int32_t freetag)
 {
 
 	struct memoryUsage *walker;
 
 
-	for ( walker = memoryList; walker != NULL; walker = walker-&gt;next ) {
+	for (walker = memoryList; walker != NULL; walker = walker-&gt;next) {
 
-		if ( walker-&gt;tag == tag ) {
+		if (walker-&gt;tag == tag) {
 
-			if ( walker-&gt;counter == 0 ) {
+			if (walker-&gt;counter == 0) {
 
-				fprintf( stderr, &quot;Freeing more memory than was allocated: malloc tag = %d, free tag = %d\n&quot;, tag, freetag );
+				fprintf(stderr, &quot;Freeing more memory than was allocated: malloc tag = %d, free tag = %d\n&quot;, tag, freetag);
 				exit(1);
 
 			}
@@ -117,9 +117,9 @@
 
 	}
 
-	if ( walker == NULL ) {
+	if (walker == NULL) {
 
-		fprintf( stderr, &quot;Freeing memory that was never allocated: malloc tag = %d, free tag = %d\n&quot;, tag, freetag );
+		fprintf(stderr, &quot;Freeing memory that was never allocated: malloc tag = %d, free tag = %d\n&quot;, tag, freetag);
 		exit(1);
 
 	}
@@ -141,12 +141,12 @@
 
 	struct memoryUsage *memoryWalker;
 
-	fprintf( stderr, &quot; \nMemory usage information:\n&quot; );
+	fprintf(stderr, &quot; \nMemory usage information:\n&quot;);
 
-	for ( memoryWalker = memoryList; memoryWalker != NULL; memoryWalker = memoryWalker-&gt;next ) {
+	for (memoryWalker = memoryList; memoryWalker != NULL; memoryWalker = memoryWalker-&gt;next) {
 
-		if ( memoryWalker-&gt;counter != 0 )
-			fprintf( stderr, &quot;   tag: %d, num malloc: %4i, bytes per malloc: %u, total: %6i\n&quot;, memoryWalker-&gt;tag, memoryWalker-&gt;counter, memoryWalker-&gt;length, memoryWalker-&gt;counter * memoryWalker-&gt;length );
+		if (memoryWalker-&gt;counter != 0)
+			fprintf(stderr, &quot;   tag: %d, num malloc: %4i, bytes per malloc: %u, total: %6i\n&quot;, memoryWalker-&gt;tag, memoryWalker-&gt;counter, memoryWalker-&gt;length, memoryWalker-&gt;counter * memoryWalker-&gt;length);
 
 	}
 
@@ -209,7 +209,7 @@
 
 #if defined MEMORY_USAGE
 
-	addMemory( length, tag );
+	addMemory(length, tag);
 
 #endif
 
@@ -302,7 +302,7 @@
 
 #if defined MEMORY_USAGE
 
-	removeMemory( chunkHeader-&gt;tag, tag );
+	removeMemory(chunkHeader-&gt;tag, tag);
 
 #endif
 

Modified: trunk/apps/meshs3d/hash.c
===================================================================
--- trunk/apps/meshs3d/hash.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/hash.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -18,7 +18,7 @@
  */
 
 
-#include &lt;stdio.h&gt;		/* NULL */
+#include &lt;stdio.h&gt;  /* NULL */
 #include &quot;hash.h&quot;
 #include &quot;allocate.h&quot;
 
@@ -27,8 +27,8 @@
 void hash_init(struct hashtable_t *hash)
 {
 	int i;
-	hash-&gt;elements=0;
-	for (i=0 ; i&lt;hash-&gt;size ; i++) {
+	hash-&gt;elements = 0;
+	for (i = 0 ; i &lt; hash-&gt;size ; i++) {
 		hash-&gt;table[i] = NULL;
 	}
 }
@@ -42,16 +42,16 @@
 	struct element_t *bucket, *last_bucket;
 	int i;
 
-	for (i=0; i&lt;hash-&gt;size; i++) {
+	for (i = 0; i &lt; hash-&gt;size; i++) {
 
-		bucket= hash-&gt;table[i];
+		bucket = hash-&gt;table[i];
 		while (bucket != NULL) {
 
-			if (free_cb!=NULL)
-				free_cb( bucket-&gt;data );
+			if (free_cb != NULL)
+				free_cb(bucket-&gt;data);
 
-			last_bucket= bucket;
-			bucket= bucket-&gt;next;
+			last_bucket = bucket;
+			bucket = bucket-&gt;next;
 			debugFree(last_bucket, 1301);
 
 		}
@@ -66,8 +66,8 @@
 void hash_destroy(struct hashtable_t *hash)
 {
 
-	debugFree( hash-&gt;table, 1302 );
-	debugFree( hash, 1303 );
+	debugFree(hash-&gt;table, 1302);
+	debugFree(hash, 1303);
 
 }
 
@@ -80,24 +80,24 @@
 	struct hash_it_t *iter;
 
 	if (iter_in == NULL) {
-		iter= debugMalloc(sizeof(struct hash_it_t), 301);
+		iter = debugMalloc(sizeof(struct hash_it_t), 301);
 		iter-&gt;index =  -1;
 		iter-&gt;bucket = NULL;
 		iter-&gt;prev_bucket = NULL;
 	} else
-		iter= iter_in;
+		iter = iter_in;
 
 	/* sanity checks first (if our bucket got deleted in the last iteration): */
-	if (iter-&gt;bucket!=NULL) {
+	if (iter-&gt;bucket != NULL) {
 		if (iter-&gt;first_bucket != NULL) {
 
 			/* we're on the first element and it got removed after the last iteration. */
 			if ((*iter-&gt;first_bucket) != iter-&gt;bucket) {
 
 				/* there are still other elements in the list */
-				if ( (*iter-&gt;first_bucket) != NULL ) {
+				if ((*iter-&gt;first_bucket) != NULL) {
 					iter-&gt;prev_bucket = NULL;
-					iter-&gt;bucket= (*iter-&gt;first_bucket);
+					iter-&gt;bucket = (*iter-&gt;first_bucket);
 					iter-&gt;first_bucket = &amp;hash-&gt;table[ iter-&gt;index ];
 					return(iter);
 				} else {
@@ -106,23 +106,23 @@
 
 			}
 
-		} else if ( iter-&gt;prev_bucket != NULL ) {
+		} else if (iter-&gt;prev_bucket != NULL) {
 
 			/* we're not on the first element, and the bucket got removed after the last iteration.
 			* the last bucket's next pointer is not pointing to our actual bucket anymore.
 			* select the next. */
-			if ( iter-&gt;prev_bucket-&gt;next != iter-&gt;bucket )
-				iter-&gt;bucket= iter-&gt;prev_bucket;
+			if (iter-&gt;prev_bucket-&gt;next != iter-&gt;bucket)
+				iter-&gt;bucket = iter-&gt;prev_bucket;
 
 		}
 
 	}
 
 	/* now as we are sane, select the next one if there is some */
-	if (iter-&gt;bucket!=NULL) {
-		if (iter-&gt;bucket-&gt;next!=NULL) {
-			iter-&gt;prev_bucket= iter-&gt;bucket;
-			iter-&gt;bucket= iter-&gt;bucket-&gt;next;
+	if (iter-&gt;bucket != NULL) {
+		if (iter-&gt;bucket-&gt;next != NULL) {
+			iter-&gt;prev_bucket = iter-&gt;bucket;
+			iter-&gt;bucket = iter-&gt;bucket-&gt;next;
 			iter-&gt;first_bucket = NULL;
 			return(iter);
 		}
@@ -130,14 +130,14 @@
 	/* if not returned yet, we've reached the last one on the index and have to search forward */
 
 	iter-&gt;index++;
-	while ( iter-&gt;index &lt; hash-&gt;size ) {		/* go through the entries of the hash table */
+	while (iter-&gt;index &lt; hash-&gt;size) {    /* go through the entries of the hash table */
 		if ((hash-&gt;table[ iter-&gt;index ]) != NULL) {
 			iter-&gt;prev_bucket = NULL;
 			iter-&gt;bucket = hash-&gt;table[ iter-&gt;index ];
 			iter-&gt;first_bucket = &amp;hash-&gt;table[ iter-&gt;index ];
-			return(iter);						/* if this table entry is not null, return it */
+			return(iter);      /* if this table entry is not null, return it */
 		} else
-			iter-&gt;index++;						/* else, go to the next */
+			iter-&gt;index++;      /* else, go to the next */
 	}
 	/* nothing to iterate over anymore */
 	debugFree(iter, 1304);
@@ -149,19 +149,19 @@
 struct hashtable_t *hash_new(int size, hashdata_compare_cb compare, hashdata_choose_cb choose) {
 	struct hashtable_t *hash;
 
-	hash= debugMalloc( sizeof(struct hashtable_t) , 302);
-	if ( hash == NULL ) 			/* could not allocate the hash control structure */
+	hash = debugMalloc(sizeof(struct hashtable_t) , 302);
+	if (hash == NULL)      /* could not allocate the hash control structure */
 		return (NULL);
 
-	hash-&gt;size= size;
-	hash-&gt;table= debugMalloc( sizeof(struct element_t *) * size, 303);
-	if ( hash-&gt;table == NULL ) {	/* could not allocate the table */
+	hash-&gt;size = size;
+	hash-&gt;table = debugMalloc(sizeof(struct element_t *) * size, 303);
+	if (hash-&gt;table == NULL) {   /* could not allocate the table */
 		debugFree(hash, 1305);
 		return(NULL);
 	}
 	hash_init(hash);
-	hash-&gt;compare= compare;
-	hash-&gt;choose= choose;
+	hash-&gt;compare = compare;
+	hash-&gt;choose = choose;
 	return(hash);
 }
 
@@ -172,26 +172,26 @@
 	int index;
 	struct element_t *bucket, *prev_bucket = NULL;
 
-	index = hash-&gt;choose( data, hash-&gt;size );
+	index = hash-&gt;choose(data, hash-&gt;size);
 	bucket = hash-&gt;table[index];
 
-	while ( bucket!=NULL ) {
-		if (0 == hash-&gt;compare( bucket-&gt;data, data ))
+	while (bucket != NULL) {
+		if (0 == hash-&gt;compare(bucket-&gt;data, data))
 			return(-1);
 
 		prev_bucket = bucket;
-		bucket= bucket-&gt;next;
+		bucket = bucket-&gt;next;
 	}
 
 	/* found the tail of the list, add new element */
-	if (NULL == (bucket= debugMalloc(sizeof(struct element_t),304)))
+	if (NULL == (bucket = debugMalloc(sizeof(struct element_t), 304)))
 		return(-1); /* debugMalloc failed */
 
-	bucket-&gt;data= data;				/* init the new bucket */
-	bucket-&gt;next= NULL;
+	bucket-&gt;data = data;   /* init the new bucket */
+	bucket-&gt;next = NULL;
 
 	/* and link it */
-	if ( prev_bucket == NULL ) {
+	if (prev_bucket == NULL) {
 		hash-&gt;table[index] = bucket;
 	} else {
 		prev_bucket-&gt;next = bucket;
@@ -207,14 +207,14 @@
 	int index;
 	struct element_t *bucket;
 
-	index = hash-&gt;choose( keydata , hash-&gt;size );
+	index = hash-&gt;choose(keydata , hash-&gt;size);
 	bucket = hash-&gt;table[index];
 
-	while ( bucket!=NULL ) {
-		if (0 == hash-&gt;compare( bucket-&gt;data, keydata ))
-			return( bucket-&gt;data );
+	while (bucket != NULL) {
+		if (0 == hash-&gt;compare(bucket-&gt;data, keydata))
+			return(bucket-&gt;data);
 
-		bucket= bucket-&gt;next;
+		bucket = bucket-&gt;next;
 	}
 
 	return(NULL);
@@ -228,18 +228,18 @@
 {
 	void *data_save;
 
-	data_save = hash_it_t-&gt;bucket-&gt;data;	/* save the pointer to the data */
+	data_save = hash_it_t-&gt;bucket-&gt;data; /* save the pointer to the data */
 
-	if ( hash_it_t-&gt;prev_bucket != NULL ) {
+	if (hash_it_t-&gt;prev_bucket != NULL) {
 		hash_it_t-&gt;prev_bucket-&gt;next = hash_it_t-&gt;bucket-&gt;next;
-	} else if ( hash_it_t-&gt;first_bucket != NULL ) {
+	} else if (hash_it_t-&gt;first_bucket != NULL) {
 		(*hash_it_t-&gt;first_bucket) = hash_it_t-&gt;bucket-&gt;next;
 	}
 
 	debugFree(hash_it_t-&gt;bucket, 1306);
 
 	hash-&gt;elements--;
-	return( data_save );
+	return(data_save);
 
 }
 
@@ -252,18 +252,18 @@
 {
 	struct hash_it_t hash_it_t;
 
-	hash_it_t.index = hash-&gt;choose( data, hash-&gt;size );
+	hash_it_t.index = hash-&gt;choose(data, hash-&gt;size);
 	hash_it_t.bucket = hash-&gt;table[hash_it_t.index];
 	hash_it_t.prev_bucket = NULL;
 
-	while ( hash_it_t.bucket!=NULL ) {
-		if (0 == hash-&gt;compare( hash_it_t.bucket-&gt;data, data )) {
+	while (hash_it_t.bucket != NULL) {
+		if (0 == hash-&gt;compare(hash_it_t.bucket-&gt;data, data)) {
 			hash_it_t.first_bucket = (hash_it_t.bucket == hash-&gt;table[hash_it_t.index] ? &amp;hash-&gt;table[ hash_it_t.index ] : NULL);
-			return( hash_remove_bucket(hash, &amp;hash_it_t) );
+			return(hash_remove_bucket(hash, &amp;hash_it_t));
 		}
 
 		hash_it_t.prev_bucket = hash_it_t.bucket;
-		hash_it_t.bucket= hash_it_t.bucket-&gt;next;
+		hash_it_t.bucket = hash_it_t.bucket-&gt;next;
 	}
 
 	return(NULL);
@@ -278,20 +278,20 @@
 	int i;
 
 	/* initialize a new hash with the new size */
-	if (NULL == (new_hash= hash_new(size, hash-&gt;compare, hash-&gt;choose)))
+	if (NULL == (new_hash = hash_new(size, hash-&gt;compare, hash-&gt;choose)))
 		return(NULL);
 
 	/* copy the elements */
-	for (i=0; i&lt;hash-&gt;size; i++) {
-		bucket= hash-&gt;table[i];
+	for (i = 0; i &lt; hash-&gt;size; i++) {
+		bucket = hash-&gt;table[i];
 		while (bucket != NULL) {
-			hash_add( new_hash, bucket-&gt;data );
-			bucket= bucket-&gt;next;
+			hash_add(new_hash, bucket-&gt;data);
+			bucket = bucket-&gt;next;
 		}
 	}
-	hash_delete(hash, NULL);	/* remove hash and eventual overflow buckets but not the content itself. */
+	hash_delete(hash, NULL); /* remove hash and eventual overflow buckets but not the content itself. */
 
-	return( new_hash);
+	return(new_hash);
 
 }
 
@@ -302,13 +302,13 @@
 	int i;
 	struct element_t *bucket;
 
-	for (i=0; i&lt;hash-&gt;size;i++) {
-		printf(&quot;[%d] &quot;,i);
-		bucket= hash-&gt;table[i];
+	for (i = 0; i &lt; hash-&gt;size;i++) {
+		printf(&quot;[%d] &quot;, i);
+		bucket = hash-&gt;table[i];
 
 		while (bucket != NULL) {
 			printf(&quot;-&gt; [%10p] &quot;, (void *)bucket);
-			bucket= bucket-&gt;next;
+			bucket = bucket-&gt;next;
 		}
 
 		printf(&quot;\n&quot;);

Modified: trunk/apps/meshs3d/hash.h
===================================================================
--- trunk/apps/meshs3d/hash.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/hash.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,8 +23,8 @@
 typedef void (*hashdata_free_cb)(void *);
 
 struct element_t {
-	void *data;						/* pointer to the data */
-	struct element_t *next;			/* overflow bucket pointer */
+	void *data;      /* pointer to the data */
+	struct element_t *next;   /* overflow bucket pointer */
 };
 
 struct hash_it_t {
@@ -35,53 +35,53 @@
 };
 
 struct hashtable_t {
-	struct element_t **table;					/* the hashtable itself, with the buckets */
-	int elements;								/* number of elements registered */
-	int size;									/* size of hashtable */
-	hashdata_compare_cb compare;			    /* callback to a compare function.
-												 * should compare 2 element datas for their keys,
-												 * return 0 if same and not 0 if not same */
-	hashdata_choose_cb choose;					/* the hashfunction, should return an index based
-												 * on the key in the data of the first argument
-												 * and the size the second */
+	struct element_t **table;     /* the hashtable itself, with the buckets */
+	int elements;        /* number of elements registered */
+	int size;         /* size of hashtable */
+	hashdata_compare_cb compare;       /* callback to a compare function.
+             * should compare 2 element datas for their keys,
+             * return 0 if same and not 0 if not same */
+	hashdata_choose_cb choose;     /* the hashfunction, should return an index based
+             * on the key in the data of the first argument
+             * and the size the second */
 };
 
 /* clears the hash */
-void 				 hash_init(struct hashtable_t *hash);
+void      hash_init(struct hashtable_t *hash);
 
 /* allocates and clears the hash */
-struct hashtable_t	*hash_new(int size, hashdata_compare_cb compare, hashdata_choose_cb choose);
+struct hashtable_t *hash_new(int size, hashdata_compare_cb compare, hashdata_choose_cb choose);
 
 /* remove bucket (this might be used in hash_iterate() if you already found the bucket
  * you want to delete and don't need the overhead to find it again with hash_remove().
  * But usually, you don't want to use this function, as it fiddles with hash-internals. */
-void 				*hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t);
+void     *hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t);
 
 /* remove the hash structure. if hashdata_free_cb != NULL,
  * this function will be called to remove the elements inside of the hash.
  * if you don't remove the elements, memory might be leaked. */
-void 				 hash_delete(struct hashtable_t *hash, hashdata_free_cb free_cb);
+void      hash_delete(struct hashtable_t *hash, hashdata_free_cb free_cb);
 
 /* free only the hashtable and the hash itself. */
-void 				 hash_destroy(struct hashtable_t *hash);
+void      hash_destroy(struct hashtable_t *hash);
 
 /* adds data to the hashtable. returns 0 on success, -1 on error */
-int 				 hash_add(struct hashtable_t *hash, void *data);
+int      hash_add(struct hashtable_t *hash, void *data);
 
 /* removes data from hash, if found. returns pointer do data on success,
  * so you can remove the used structure yourself, or NULL on error .
  * data could be the structure you use with just the key filled,
  * we just need the key for comparing. */
-void 				*hash_remove(struct hashtable_t *hash, void *data);
+void     *hash_remove(struct hashtable_t *hash, void *data);
 
 /* adds data to the hashtable. returns 0 on success, -1 on error */
-void 				*hash_find(struct hashtable_t *hash, void *keydata);
+void     *hash_find(struct hashtable_t *hash, void *keydata);
 
 /* resize the hash, returns the pointer to the new hash or NULL on error. removes the old hash on success */
-struct hashtable_t	*hash_resize(struct hashtable_t *hash, int size);
+struct hashtable_t *hash_resize(struct hashtable_t *hash, int size);
 
 /* print the hash table for debugging */
-void 				 hash_debug( struct hashtable_t *hash);
+void      hash_debug(struct hashtable_t *hash);
 
 /* iterate though the hash. first element is selected with iter_in NULL.
  * use the returned iterator to access the elements until hash_it_t returns NULL. */

Modified: trunk/apps/meshs3d/main.c
===================================================================
--- trunk/apps/meshs3d/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -45,7 +45,7 @@
 };   /* 100 mili seconds */
 
 
-void init_globals( void )
+void init_globals(void)
 {
 	Global.debug = 1;
 	Global.obj_node_hna = 0;
@@ -58,39 +58,39 @@
 }
 
 
-void print_usage( void )
+void print_usage(void)
 {
 
-	printf( &quot;Usage is olsrs3d [options] [-- [s3d options]]\n&quot; );
-	printf( &quot;olsrs3d options:\n&quot; );
-	printf( &quot;   -h\tprint this short help\n&quot; );
-	printf( &quot;   -d\tenable debug mode\n&quot; );
-	printf( &quot;   -H\tconnect to olsr node [default: localhost]\n&quot; );
+	printf(&quot;Usage is olsrs3d [options] [-- [s3d options]]\n&quot;);
+	printf(&quot;olsrs3d options:\n&quot;);
+	printf(&quot;   -h\tprint this short help\n&quot;);
+	printf(&quot;   -d\tenable debug mode\n&quot;);
+	printf(&quot;   -H\tconnect to olsr node [default: localhost]\n&quot;);
 	s3d_usage();
 }
 
 float dist(float p1[], float p2[])
 {
 	float p[3];
-	p[0]=p1[0]-p2[0];
-	p[1]=p1[1]-p2[1];
-	p[2]=p1[2]-p2[2];
+	p[0] = p1[0] - p2[0];
+	p[1] = p1[1] - p2[1];
+	p[2] = p1[2] - p2[2];
 	return (sqrt(p[0]*p[0]   +  p[1]*p[1]  +  p[2]*p[2]));
 }
 
 float dirt(float p1[], float p2[], float p3[])
 {
 	float d;
-	d=dist(p1,p2);
-	if (d==0) {
-		p3[0]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		p3[1]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		p3[2]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		d=s3d_vector_length(p3);
+	d = dist(p1, p2);
+	if (d == 0) {
+		p3[0] = ((float) 0.2 * rand()) / RAND_MAX - 0.1;
+		p3[1] = ((float) 0.2 * rand()) / RAND_MAX - 0.1;
+		p3[2] = ((float) 0.2 * rand()) / RAND_MAX - 0.1;
+		d = s3d_vector_length(p3);
 	} else {
-		p3[0]=p2[0]-p1[0];
-		p3[1]=p2[1]-p1[1];
-		p3[2]=p2[2]-p1[2];
+		p3[0] = p2[0] - p1[0];
+		p3[1] = p2[1] - p1[1];
+		p3[2] = p2[2] - p1[2];
 	}
 	return(d);
 }
@@ -100,29 +100,29 @@
 	struct node *node;
 	struct hash_it_t *hashit;
 
-	if ( node_hash-&gt;elements == 0 )
+	if (node_hash-&gt;elements == 0)
 		return;
 	hashit = NULL;
-	while ( NULL != ( hashit = hash_iterate( node_hash, hashit ) ) ) {
+	while (NULL != (hashit = hash_iterate(node_hash, hashit))) {
 		node = (struct node *) hashit-&gt;bucket-&gt;data;
-		if ( node-&gt;node_type_modified ) {
+		if (node-&gt;node_type_modified) {
 
 			node-&gt;node_type_modified = 0;
-			if ( node-&gt;obj_id != -1 ) {
-				s3d_del_object( node-&gt;obj_id );
+			if (node-&gt;obj_id != -1) {
+				s3d_del_object(node-&gt;obj_id);
 			}
 
-			if ( node-&gt;desc_id != -1 ) s3d_del_object( node-&gt;desc_id );
+			if (node-&gt;desc_id != -1) s3d_del_object(node-&gt;desc_id);
 
-			if ( node-&gt;node_type == 1 ) {
-				node-&gt;obj_id = s3d_clone( Global.obj_node_inet );
-			} else if ( node-&gt;node_type == 2 ) {
-				node-&gt;obj_id = s3d_clone( Global.obj_node_hna );
+			if (node-&gt;node_type == 1) {
+				node-&gt;obj_id = s3d_clone(Global.obj_node_inet);
+			} else if (node-&gt;node_type == 2) {
+				node-&gt;obj_id = s3d_clone(Global.obj_node_hna);
 			} else {
-				node-&gt;obj_id = s3d_clone( Global.obj_node_normal );
+				node-&gt;obj_id = s3d_clone(Global.obj_node_normal);
 			}
 
-			s3d_flags_on( node-&gt;obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(node-&gt;obj_id, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
 		}
 	}
@@ -131,65 +131,65 @@
 
 void mov_add(float mov[], float p[], float fac)
 {
-	/*	if (fac&gt;1000)
-			return;
-		fac=1000; */
-	mov[0]+=fac*p[0];
-	mov[1]+=fac*p[1];
-	mov[2]+=fac*p[2];
+	/* if (fac&gt;1000)
+	  return;
+	 fac=1000; */
+	mov[0] += fac * p[0];
+	mov[1] += fac * p[1];
+	mov[2] += fac * p[2];
 }
 
-void move_meshnode( struct node *node )
+void move_meshnode(struct node *node)
 {
-	float null_vec[3] = {0,0,0};
+	float null_vec[3] = {0, 0, 0};
 	float tmp_mov_vec[3];
 	float distance;
 
-	if ( !( ( node-&gt;mov_vec[0] == 0 ) &amp;&amp; ( node-&gt;mov_vec[1] == 0 ) &amp;&amp; ( node-&gt;mov_vec[2] == 0 ) ) &amp;&amp; node-&gt;visible ) {
-		distance = dirt( node-&gt;pos_vec, null_vec, tmp_mov_vec );
-		mov_add( node-&gt;mov_vec, tmp_mov_vec, distance / 100 ); /* move a little bit to point zero */
-		mov_add( node-&gt;mov_vec, tmp_mov_vec, 1 ); /* move a little bit to point zero */
+	if (!((node-&gt;mov_vec[0] == 0) &amp;&amp; (node-&gt;mov_vec[1] == 0) &amp;&amp; (node-&gt;mov_vec[2] == 0)) &amp;&amp; node-&gt;visible) {
+		distance = dirt(node-&gt;pos_vec, null_vec, tmp_mov_vec);
+		mov_add(node-&gt;mov_vec, tmp_mov_vec, distance / 100);   /* move a little bit to point zero */
+		mov_add(node-&gt;mov_vec, tmp_mov_vec, 1);   /* move a little bit to point zero */
 
-		if ( ( distance = dist( node-&gt;mov_vec, null_vec ) ) &gt; 10.0 )
-			mov_add( node-&gt;pos_vec, node-&gt;mov_vec, 1.0 / ( ( float ) distance ) );
+		if ((distance = dist(node-&gt;mov_vec, null_vec)) &gt; 10.0)
+			mov_add(node-&gt;pos_vec, node-&gt;mov_vec, 1.0 / ((float) distance));
 		else
-			mov_add( node-&gt;pos_vec, node-&gt;mov_vec, 0.1 );
+			mov_add(node-&gt;pos_vec, node-&gt;mov_vec, 0.1);
 
-		s3d_translate( node-&gt;obj_id, node-&gt;pos_vec[0], node-&gt;pos_vec[1], node-&gt;pos_vec[2] );
+		s3d_translate(node-&gt;obj_id, node-&gt;pos_vec[0], node-&gt;pos_vec[1], node-&gt;pos_vec[2]);
 		/* reset movement vector */
 		node-&gt;mov_vec[0] = node-&gt;mov_vec[1] = node-&gt;mov_vec[2] = 0.0;
 	}
 }
 
-void calc_node_mov( void )
+void calc_node_mov(void)
 {
 
 	float distance;
-	float tmp_mov_vec[3],vertex_buf[6];
+	float tmp_mov_vec[3], vertex_buf[6];
 	float f;
 	int ip[2];
 	struct node_con *con;
 	struct node *first_node, *sec_node;
 	struct hash_it_t *hashit1, *hashit2;
 
-	if ( con_hash-&gt;elements == 0 )
+	if (con_hash-&gt;elements == 0)
 		return;
 	hashit1 = hashit2 = NULL;
-	while ( NULL != ( hashit1 = hash_iterate( node_hash, hashit1 ) ) ) {
+	while (NULL != (hashit1 = hash_iterate(node_hash, hashit1))) {
 		first_node = (struct node *) hashit1-&gt;bucket-&gt;data;
-		while ( NULL != ( hashit2 = hash_iterate( node_hash, hashit2 ) ) ) {
+		while (NULL != (hashit2 = hash_iterate(node_hash, hashit2))) {
 			sec_node = (struct node *) hashit2-&gt;bucket-&gt;data;
-			if ( first_node != sec_node ) {
+			if (first_node != sec_node) {
 				ip[0] = max(first_node-&gt;ip, sec_node-&gt;ip);
 				ip[1] = min(first_node-&gt;ip, sec_node-&gt;ip);
-				distance = dirt( first_node-&gt;pos_vec, sec_node-&gt;pos_vec, tmp_mov_vec );
-				if ( NULL != ( con = hash_find(con_hash, ip ) ) ) {
+				distance = dirt(first_node-&gt;pos_vec, sec_node-&gt;pos_vec, tmp_mov_vec);
+				if (NULL != (con = hash_find(con_hash, ip))) {
 					/* we have a connection */
-					f = ( ( con-&gt;etx1_sqrt + con-&gt;etx2_sqrt ) / 4.0 ) / distance;
-					mov_add( first_node-&gt;mov_vec, tmp_mov_vec,  1 / f - 1 );
-					mov_add( sec_node-&gt;mov_vec, tmp_mov_vec, -( 1 / f - 1 ) );
-					printf(&quot;------co---------\n%s %.2f %.2f %.2f\n%s %.2f %.2f %.2f\n&quot;, first_node-&gt;ip_string,first_node-&gt;mov_vec[0],first_node-&gt;mov_vec[1],first_node-&gt;mov_vec[2],
-					       sec_node-&gt;ip_string,sec_node-&gt;mov_vec[0],sec_node-&gt;mov_vec[1],sec_node-&gt;mov_vec[2]  );
+					f = ((con-&gt;etx1_sqrt + con-&gt;etx2_sqrt) / 4.0) / distance;
+					mov_add(first_node-&gt;mov_vec, tmp_mov_vec,  1 / f - 1);
+					mov_add(sec_node-&gt;mov_vec, tmp_mov_vec, -(1 / f - 1));
+					printf(&quot;------co---------\n%s %.2f %.2f %.2f\n%s %.2f %.2f %.2f\n&quot;, first_node-&gt;ip_string, first_node-&gt;mov_vec[0], first_node-&gt;mov_vec[1], first_node-&gt;mov_vec[2],
+					       sec_node-&gt;ip_string, sec_node-&gt;mov_vec[0], sec_node-&gt;mov_vec[1], sec_node-&gt;mov_vec[2]);
 
 					vertex_buf[0] = first_node-&gt;pos_vec[0];
 					vertex_buf[1] = first_node-&gt;pos_vec[1];
@@ -197,24 +197,24 @@
 					vertex_buf[3] = sec_node-&gt;pos_vec[0];
 					vertex_buf[4] = sec_node-&gt;pos_vec[1];
 					vertex_buf[5] = sec_node-&gt;pos_vec[2];
-					s3d_pep_vertices( con-&gt;obj_id, vertex_buf, 2 );
+					s3d_pep_vertices(con-&gt;obj_id, vertex_buf, 2);
 
-					s3d_pep_material( con-&gt;obj_id,
-					                  1.0,1.0,1.0,
-					                  1.0,1.0,1.0,
-					                  1.0,1.0,1.0
+					s3d_pep_material(con-&gt;obj_id,
+					                 1.0, 1.0, 1.0,
+					                 1.0, 1.0, 1.0,
+					                 1.0, 1.0, 1.0
 					                );
 
 				} else {
 					/* we have no connection */
 					if (distance &lt; 0.1) distance = 0.1;
-					mov_add( first_node-&gt;mov_vec, tmp_mov_vec, 100 / ( distance * distance ) );
-					mov_add( sec_node-&gt;mov_vec, tmp_mov_vec, -100 / ( distance * distance ) );
-					printf(&quot;------nco---------\n%s %.2f %.2f %.2f\n%s %.2f %.2f %.2f\n&quot;, first_node-&gt;ip_string,first_node-&gt;mov_vec[0],first_node-&gt;mov_vec[1],first_node-&gt;mov_vec[2],
-					       sec_node-&gt;ip_string,sec_node-&gt;mov_vec[0],sec_node-&gt;mov_vec[1],sec_node-&gt;mov_vec[2]  );
+					mov_add(first_node-&gt;mov_vec, tmp_mov_vec, 100 / (distance * distance));
+					mov_add(sec_node-&gt;mov_vec, tmp_mov_vec, -100 / (distance * distance));
+					printf(&quot;------nco---------\n%s %.2f %.2f %.2f\n%s %.2f %.2f %.2f\n&quot;, first_node-&gt;ip_string, first_node-&gt;mov_vec[0], first_node-&gt;mov_vec[1], first_node-&gt;mov_vec[2],
+					       sec_node-&gt;ip_string, sec_node-&gt;mov_vec[0], sec_node-&gt;mov_vec[1], sec_node-&gt;mov_vec[2]);
 				}
-				move_meshnode( first_node );
-				move_meshnode( sec_node );
+				move_meshnode(first_node);
+				move_meshnode(sec_node);
 			}
 		}
 		/* first_node = hash_find( node_hash, &amp;con-&gt;ip[0] );
@@ -241,36 +241,36 @@
 	handle_node();
 	/* move_nodes(); */
 
-	while ( ( net_result = net_main() ) != 0 ) {
-		if ( net_result == -1 ) {
+	while ((net_result = net_main()) != 0) {
+		if (net_result == -1) {
 			s3d_quit();
 			break;
 		}
 	}
-	nanosleep( &amp;sleep_time, NULL );
+	nanosleep(&amp;sleep_time, NULL);
 	return;
 }
 
 
-int main( int argc, char *argv[] )
+int main(int argc, char *argv[])
 {
 	int optchar;
 	char olsr_host[256];
 
 	init_globals();
-	strncpy( olsr_host, &quot;127.0.0.1&quot;, 256 );
+	strncpy(olsr_host, &quot;127.0.0.1&quot;, 256);
 	lbuf[0] = '\0';
 
-	while ( ( optchar = getopt ( argc, argv, &quot;dhH:&quot; ) ) != -1 ) {
+	while ((optchar = getopt(argc, argv, &quot;dhH:&quot;)) != -1) {
 
-		switch ( optchar ) {
+		switch (optchar) {
 
 		case 'd':
 			Global.debug = 1;
 			break;
 
 		case 'H':
-			strncpy( olsr_host, optarg, 256 );
+			strncpy(olsr_host, optarg, 256);
 			break;
 
 		case 'h':
@@ -282,17 +282,17 @@
 
 	}
 
-	if ( Global.debug )
-		printf( &quot;debug mode enabled ...\n&quot; );
+	if (Global.debug)
+		printf(&quot;debug mode enabled ...\n&quot;);
 
 	/* initialize obj2ip linked list */
 	/* lst_initialize(); */
 
 	/* delete olsrs3d options */
-	while ( ( optind &lt; argc ) &amp;&amp; ( argv[optind][0] != '-' ) ) optind++;		/* optind may point to ip addr of '-H' */
+	while ((optind &lt; argc) &amp;&amp; (argv[optind][0] != '-')) optind++;        /* optind may point to ip addr of '-H' */
 	optind--;
-	argv[optind] = argv[0];		/* save program path */
-	argc -= optind;				/* jump over olsrs3d options */
+	argv[optind] = argv[0];  /* save program path */
+	argc -= optind;    /* jump over olsrs3d options */
 	argv += optind;
 
 	/* set extern int optind = 0 for parse_args in io.c */
@@ -306,22 +306,22 @@
 		s3d_set_callback(S3D_EVENT_KEY,keypress);
 		s3d_set_callback(S3D_EVENT_QUIT,stop); */
 
-		if (!s3d_init(&amp;argc,&amp;argv,&quot;meshs3d&quot;)) {
+		if (!s3d_init(&amp;argc, &amp;argv, &quot;meshs3d&quot;)) {
 
 			if (s3d_select_font(&quot;vera&quot;))
 				printf(&quot;font not found\n&quot;);
 
-			Global.obj_node_normal = s3d_import_model_file( &quot;objs/accesspoint.3ds&quot; );
-			Global.obj_node_inet = s3d_import_model_file( &quot;objs/accesspoint_inet.3ds&quot; );
-			Global.obj_node_hna = s3d_import_model_file( &quot;objs/internet.3ds&quot; );
-			Global.obj_btn_close = s3d_import_model_file( &quot;objs/btn_close.3ds&quot; );
+			Global.obj_node_normal = s3d_import_model_file(&quot;objs/accesspoint.3ds&quot;);
+			Global.obj_node_inet = s3d_import_model_file(&quot;objs/accesspoint_inet.3ds&quot;);
+			Global.obj_node_hna = s3d_import_model_file(&quot;objs/internet.3ds&quot;);
+			Global.obj_btn_close = s3d_import_model_file(&quot;objs/btn_close.3ds&quot;);
 
-			Global.obj_s3d_url = s3d_import_model_file( &quot;objs/s3d_berlios_de.3ds&quot; );
+			Global.obj_s3d_url = s3d_import_model_file(&quot;objs/s3d_berlios_de.3ds&quot;);
 
-			s3d_translate( Global.obj_s3d_url, 0.75, -0.75, -1 );
-			s3d_scale( Global.obj_s3d_url, 0.07 );
-			s3d_link( Global.obj_s3d_url, 0 );
-			s3d_flags_on( Global.obj_s3d_url, S3D_OF_VISIBLE );
+			s3d_translate(Global.obj_s3d_url, 0.75, -0.75, -1);
+			s3d_scale(Global.obj_s3d_url, 0.07);
+			s3d_link(Global.obj_s3d_url, 0);
+			s3d_flags_on(Global.obj_s3d_url, S3D_OF_VISIBLE);
 
 			/* create_search_widget( 0, 0, 300 ); */
 

Modified: trunk/apps/meshs3d/meshs3d.h
===================================================================
--- trunk/apps/meshs3d/meshs3d.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/meshs3d.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,42 +25,42 @@
 
 #define max(x,y) ((x)&gt;(y)?(x):(y))
 #define min(x,y) ((x)&lt;(y)?(x):(y))
-#define NAMEMAX		128
-#define MAXLINESIZE 1000		/* lines in a digraph just shouldn't get that longer ... */
-#define MAXDATASIZE 100			/* max number of bytes we can get at once  */
+#define NAMEMAX  128
+#define MAXLINESIZE 1000  /* lines in a digraph just shouldn't get that longer ... */
+#define MAXDATASIZE 100   /* max number of bytes we can get at once  */
 
 /* linked list for the all connections */
 struct node_con {
 	unsigned int ip[2];
-	float etx1;							/* etx of left olsr node */
-	float etx2;						/* etx of right olsr node */
-	float etx1_sqrt;					/* sqrt of etx of left olsr node */
-	float etx2_sqrt;					/* sqrt etx of right olsr node */
-	int obj_id;								/* id of connection object in s3d */
+	float etx1;       /* etx of left olsr node */
+	float etx2;      /* etx of right olsr node */
+	float etx1_sqrt;     /* sqrt of etx of left olsr node */
+	float etx2_sqrt;     /* sqrt etx of right olsr node */
+	int obj_id;        /* id of connection object in s3d */
 	int color;
 	float rgb;
 };
 
 /* linked list for the neighbours of each olsr node */
 struct olsr_neigh_list {
-	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
-	struct olsr_con *olsr_con;							/* pointer to the connection */
+	struct olsr_neigh_list *next_olsr_neigh_list;  /* pointer to next neighbour */
+	struct olsr_con *olsr_con;       /* pointer to the connection */
 };
 
 
 /* we contruct a binary tree to handle the nodes */
 struct node {
 	unsigned int ip;
-	char ip_string[NAMEMAX];		/* host ip */
-	int node_type;					/* normal = 0, internet gateway = 1, via hna announced network = 2 */
-	int node_type_modified;			/* node_type modified flag */
-	int last_seen;					/* last seen counter */
-	int visible;					/* is this node visible or vanished */
-	float pos_vec[3];				/* position vector in 3d &quot;space&quot; */
-	float mov_vec[3];				/* move vector */
-	int obj_id;						/* id of node object in s3d */
-	int desc_id;					/* id of node description object in s3d */
-	float desc_length;				/* length of node description object in s3d */
+	char ip_string[NAMEMAX];  /* host ip */
+	int node_type;     /* normal = 0, internet gateway = 1, via hna announced network = 2 */
+	int node_type_modified;   /* node_type modified flag */
+	int last_seen;     /* last seen counter */
+	int visible;     /* is this node visible or vanished */
+	float pos_vec[3];    /* position vector in 3d &quot;space&quot; */
+	float mov_vec[3];    /* move vector */
+	int obj_id;      /* id of node object in s3d */
+	int desc_id;     /* id of node description object in s3d */
+	float desc_length;    /* length of node description object in s3d */
 };
 
 
@@ -73,11 +73,11 @@
 
 struct glob {
 	int debug;
-	int	obj_node_normal;
-	int	obj_node_inet;
-	int	obj_node_hna;
-	int	obj_btn_close;
-	int	obj_s3d_url;
+	int obj_node_normal;
+	int obj_node_inet;
+	int obj_node_hna;
+	int obj_btn_close;
+	int obj_s3d_url;
 	int obj_zero_point;
 };
 

Modified: trunk/apps/meshs3d/net.c
===================================================================
--- trunk/apps/meshs3d/net.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/net.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -46,7 +46,7 @@
 	struct hostent *he;
 	struct sockaddr_in their_addr; /* connector's address information  */
 
-	if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
+	if ((he = gethostbyname(host)) == NULL) {  /* get the host info  */
 		herror(&quot;gethostbyname&quot;);
 		return(1);
 	}
@@ -66,7 +66,7 @@
 		perror(&quot;connect&quot;);
 		return(1);
 	}
-	fcntl(sockfd,F_SETFL, O_NONBLOCK);
+	fcntl(sockfd, F_SETFL, O_NONBLOCK);
 	return(0);
 }
 
@@ -74,14 +74,14 @@
 {
 	static int net_read_count = 0;
 
-	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
-		if (errno==EAGAIN)
+	if ((numbytes = recv(sockfd, buf, MAXDATASIZE - 1, 0)) == -1) {
+		if (errno == EAGAIN)
 			return(0); /* well, that's okay ... */
 		perror(&quot;recv&quot;);
 		return(-1);
 	}
 
-	if (numbytes==0) {
+	if (numbytes == 0) {
 		printf(&quot;connection reset\n&quot;);
 		return(-1);
 	}
@@ -89,22 +89,22 @@
 	buf[numbytes] = '\0';
 
 	/* check for potential buffer overflow */
-	if ( ( strlen( lbuf ) + strlen( buf ) ) &lt; MAXLINESIZE ) {
+	if ((strlen(lbuf) + strlen(buf)) &lt; MAXLINESIZE) {
 
-		strncat( lbuf, buf, MAXLINESIZE );
+		strncat(lbuf, buf, MAXLINESIZE);
 
 	} else {
 
 		/* hope that carriage return is now in buf */
-		if ( strlen( lbuf ) &lt; MAXLINESIZE ) {
+		if (strlen(lbuf) &lt; MAXLINESIZE) {
 
-			if ( Global.debug ) printf( &quot;WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n&quot; );
-			strncat( lbuf, buf, MAXLINESIZE - strlen( lbuf ) );
+			if (Global.debug) printf(&quot;WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n&quot;);
+			strncat(lbuf, buf, MAXLINESIZE - strlen(lbuf));
 
 		} else {
 
-			if ( Global.debug ) printf( &quot;ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n&quot; );
-			strncpy( lbuf, buf, MAXLINESIZE );
+			if (Global.debug) printf(&quot;ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n&quot;);
+			strncpy(lbuf, buf, MAXLINESIZE);
 
 		}
 
@@ -112,7 +112,7 @@
 
 	process_main();
 
-	if ( ++net_read_count &gt; 5 ) {
+	if (++net_read_count &gt; 5) {
 		net_read_count = 0;
 		return(0);   /* continue mainloop */
 	} else {

Modified: trunk/apps/meshs3d/process.c
===================================================================
--- trunk/apps/meshs3d/process.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/process.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,9 +25,9 @@
 
 
 
-#include &lt;stdio.h&gt; 	/* NULL */
-#include &lt;string.h&gt; 	/* strlen(), memmove() */
-#include &lt;stdlib.h&gt; 	/* rand(), malloc(), realloc(), free() */
+#include &lt;stdio.h&gt;  /* NULL */
+#include &lt;string.h&gt;  /* strlen(), memmove() */
+#include &lt;stdlib.h&gt;  /* rand(), malloc(), realloc(), free() */
 #include &lt;s3d.h&gt;
 #include &lt;math.h&gt;       /* sqrt() */
 #include &lt;sys/socket.h&gt;
@@ -53,7 +53,7 @@
 
 int long_choose(void *data, int32_t size)
 {
-	unsigned char *key= data;
+	unsigned char *key = data;
 	uint32_t hash = 0;
 	size_t i;
 
@@ -65,7 +65,7 @@
 	hash += (hash &lt;&lt; 3);
 	hash ^= (hash &gt;&gt; 11);
 	hash += (hash &lt;&lt; 15);
-	return (hash%size);
+	return (hash % size);
 }
 
 int orig_comp(void *data1, void *data2)
@@ -77,7 +77,7 @@
 /* hash algorithm from <A HREF="http://en.wikipedia.org/wiki/Hash_table">http://en.wikipedia.org/wiki/Hash_table</A> */
 int orig_choose(void *data, int32_t size)
 {
-	unsigned char *key= data;
+	unsigned char *key = data;
 	uint32_t hash = 0;
 	size_t i;
 
@@ -89,7 +89,7 @@
 	hash += (hash &lt;&lt; 3);
 	hash ^= (hash &gt;&gt; 11);
 	hash += (hash &lt;&lt; 15);
-	return (hash%size);
+	return (hash % size);
 }
 
 void exit_error(char *format, ...)
@@ -99,32 +99,32 @@
 	va_start(args, format);
 	vprintf(format, args);
 	va_end(args);
-	exit( EXIT_FAILURE );
+	exit(EXIT_FAILURE);
 }
 
 void process_init()
 {
 	/* initialize hashtable */
-	if ( NULL == ( node_hash = hash_new( 1600, orig_comp, orig_choose ) ) )
-		exit_error( &quot;Can't create hashtable node_hash\n&quot;);
-	if ( NULL == ( con_hash = hash_new( 1600, long_comp, long_choose ) ) )
-		exit_error( &quot;Can't create hashtable con_hash\n&quot;);
+	if (NULL == (node_hash = hash_new(1600, orig_comp, orig_choose)))
+		exit_error(&quot;Can't create hashtable node_hash\n&quot;);
+	if (NULL == (con_hash = hash_new(1600, long_comp, long_choose)))
+		exit_error(&quot;Can't create hashtable con_hash\n&quot;);
 	return;
 }
 
-void handle_con( unsigned int ip1, unsigned int ip2, float etx )
+void handle_con(unsigned int ip1, unsigned int ip2, float etx)
 {
 
 	unsigned int ip[2];
 	struct node_con *con;
 	struct hashtable_t *swaphash;
 
-	ip[0] = max(ip1,ip2);
-	ip[1] = min(ip1,ip2);
+	ip[0] = max(ip1, ip2);
+	ip[1] = min(ip1, ip2);
 
-	con = ( struct node_con* ) hash_find( con_hash, ip);
-	if ( con == NULL ) {
-		con = ( struct node_con * ) debugMalloc( sizeof( struct node_con ), 102 );
+	con = (struct node_con*) hash_find(con_hash, ip);
+	if (con == NULL) {
+		con = (struct node_con *) debugMalloc(sizeof(struct node_con), 102);
 		con-&gt;ip[0] = ip[0];
 		con-&gt;ip[1] = ip[1];
 		con-&gt;color = 0;
@@ -134,58 +134,58 @@
 		con-&gt;etx2 = 0.00;
 		con-&gt;etx1_sqrt = 0.00;
 		con-&gt;etx2_sqrt = 0.00;
-		hash_add( con_hash, con );
+		hash_add(con_hash, con);
 	}
 
-	if ( con-&gt;ip[0] == ip1 ) {
+	if (con-&gt;ip[0] == ip1) {
 		con-&gt;etx1 = etx;
-		con-&gt;etx1_sqrt = sqrt( etx );
+		con-&gt;etx1_sqrt = sqrt(etx);
 	} else {
 		con-&gt;etx2 = etx;
-		con-&gt;etx2_sqrt = sqrt( etx );
+		con-&gt;etx2_sqrt = sqrt(etx);
 	}
 
 
-	if ( con_hash-&gt;elements * 4 &gt; con_hash-&gt;size ) {
-		swaphash = hash_resize( con_hash, con_hash-&gt;size * 2 );
-		if ( swaphash == NULL )
+	if (con_hash-&gt;elements * 4 &gt; con_hash-&gt;size) {
+		swaphash = hash_resize(con_hash, con_hash-&gt;size * 2);
+		if (swaphash == NULL)
 			exit_error(&quot;Couldn't resize hash table \n&quot;);
 		con_hash = swaphash;
 	}
 
 }
 
-void handle_mesh_node( unsigned int *ip, char *ip_string )
+void handle_mesh_node(unsigned int *ip, char *ip_string)
 {
 	struct node *orig_node;
 	struct hashtable_t *swaphash;
 
-	if ( node_hash-&gt;elements * 4 &gt; node_hash-&gt;size ) {
-		swaphash = hash_resize( node_hash, node_hash-&gt;size * 2 );
-		if ( swaphash == NULL )
-			exit_error(&quot;Couldn't resize hash table \n&quot; );
+	if (node_hash-&gt;elements * 4 &gt; node_hash-&gt;size) {
+		swaphash = hash_resize(node_hash, node_hash-&gt;size * 2);
+		if (swaphash == NULL)
+			exit_error(&quot;Couldn't resize hash table \n&quot;);
 		node_hash = swaphash;
 	}
-	orig_node = (struct node *) hash_find( node_hash, ip );
+	orig_node = (struct node *) hash_find(node_hash, ip);
 
-	if ( NULL == orig_node ) {
-		orig_node = (struct node *)debugMalloc( sizeof(struct node), 101 );
+	if (NULL == orig_node) {
+		orig_node = (struct node *)debugMalloc(sizeof(struct node), 101);
 		orig_node-&gt;ip = *ip;
-		strncpy( orig_node-&gt;ip_string, ip_string, NAMEMAX );
+		strncpy(orig_node-&gt;ip_string, ip_string, NAMEMAX);
 
 		orig_node-&gt;node_type = 0;
 		orig_node-&gt;node_type_modified = 1;
 
 		orig_node-&gt;visible = 1;
 
-		orig_node-&gt;pos_vec[0] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		orig_node-&gt;pos_vec[1] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		orig_node-&gt;pos_vec[2] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+		orig_node-&gt;pos_vec[0] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
+		orig_node-&gt;pos_vec[1] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
+		orig_node-&gt;pos_vec[2] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
 		orig_node-&gt;mov_vec[0] = orig_node-&gt;mov_vec[1] = orig_node-&gt;mov_vec[2] = 0.0;
 
 		orig_node-&gt;obj_id = -1;
 		orig_node-&gt;desc_id = -1;
-		hash_add( node_hash, orig_node );
+		hash_add(node_hash, orig_node);
 	}
 	return;
 }
@@ -198,7 +198,7 @@
 	char *lbuf_ptr, *last_cr_ptr, *con_from, *con_from_end, *con_to, *con_to_end, *etx, *etx_end;
 	/* struct node *node_from, *node_to; */
 
-	unsigned int int_con_from=0, int_con_to=0;
+	unsigned int int_con_from = 0, int_con_to = 0;
 
 	lbuf_ptr = lbuf;
 	last_cr_ptr = NULL;
@@ -207,15 +207,15 @@
 	dn = 0;
 
 
-	while ( (*lbuf_ptr) != '\0' ) {
-		if ( (*lbuf_ptr) == '\n' ) {
+	while ((*lbuf_ptr) != '\0') {
+		if ((*lbuf_ptr) == '\n') {
 			last_cr_ptr = lbuf_ptr;
 			con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
 			dn = 0;
 		}
 
-		if ( (*lbuf_ptr) == '&quot;' ) {
-			switch ( dn ) {
+		if ((*lbuf_ptr) == '&quot;') {
+			switch (dn) {
 			case 0:
 				con_from = lbuf_ptr + 1;
 				break;
@@ -236,32 +236,32 @@
 				break;
 			}
 
-			if ( ++dn == 6 ) {
+			if (++dn == 6) {
 
 				(*con_from_end) = (*con_to_end) = (*etx_end) = '\0';
 
 				/* if( Global.debug ) printf( &quot;con_from: %s, con_to: %s, etx: %s\n&quot;, con_from, con_to, etx ); */
 
 				/* announced network via HNA */
-				if ( strncmp( etx, &quot;HNA&quot;, NAMEMAX ) == 0 ) {
+				if (strncmp(etx, &quot;HNA&quot;, NAMEMAX) == 0) {
 
 				} else {
 
-					f = strtod(etx,NULL);
-					if ( f &lt; 1.0 )
+					f = strtod(etx, NULL);
+					if (f &lt; 1.0)
 						f = 999.0;
 
-					if ( inet_pton(AF_INET, con_from, &amp;int_con_from ) &lt; 1 ) {
-						printf(&quot;%s is not a valid ip address\n&quot;, con_from );
+					if (inet_pton(AF_INET, con_from, &amp;int_con_from) &lt; 1) {
+						printf(&quot;%s is not a valid ip address\n&quot;, con_from);
 						continue;
 					}
-					if ( inet_pton(AF_INET, con_to, &amp;int_con_to ) &lt; 1 ) {
-						printf(&quot;%s is not a valid ip address\n&quot;, con_to );
+					if (inet_pton(AF_INET, con_to, &amp;int_con_to) &lt; 1) {
+						printf(&quot;%s is not a valid ip address\n&quot;, con_to);
 						continue;
 					}
-					handle_mesh_node( &amp;int_con_from, con_from );
-					handle_mesh_node( &amp;int_con_to, con_to );
-					handle_con( int_con_from, int_con_to, f);
+					handle_mesh_node(&amp;int_con_from, con_from);
+					handle_mesh_node(&amp;int_con_to, con_to);
+					handle_con(int_con_from, int_con_to, f);
 					/* node_from = (struct node *) hash_find( node_hash, &amp;int_con_from );
 					node_to = (struct node *) hash_find( node_hash, &amp;int_con_to ); */
 				}
@@ -274,7 +274,7 @@
 				last_cr_ptr = lbuf_ptr;
 			}
 
-		} else if ( ( (*lbuf_ptr) == '}' ) &amp;&amp; ( (*(lbuf_ptr + 1)) == '\n' ) ) {
+		} else if (((*lbuf_ptr) == '}') &amp;&amp; ((*(lbuf_ptr + 1)) == '\n')) {
 
 		}
 
@@ -282,7 +282,7 @@
 
 	}
 
-	if ( last_cr_ptr != NULL ) memmove( lbuf, last_cr_ptr + 1, strlen( last_cr_ptr ) );
+	if (last_cr_ptr != NULL) memmove(lbuf, last_cr_ptr + 1, strlen(last_cr_ptr));
 	return(0);
 
 }

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -29,17 +29,17 @@
 #include &lt;s3d.h&gt;
 #include &lt;s3d_keysym.h&gt;
 #include &lt;s3dw.h&gt;
-#include &lt;sys/time.h&gt;	 /* gettimeofday() */
-#include &lt;time.h&gt;	     /* nanosleep() */
-#include &lt;string.h&gt;		 /* strncpy() */
-#include &lt;math.h&gt;		 /* sqrt() */
-#include &lt;getopt.h&gt;		 /* getopt() */
-#include &lt;stdlib.h&gt;		 /* exit() */
-#include &lt;stdint.h&gt;		 /* uintXX_t */
+#include &lt;sys/time.h&gt;  /* gettimeofday() */
+#include &lt;time.h&gt;      /* nanosleep() */
+#include &lt;string.h&gt;   /* strncpy() */
+#include &lt;math.h&gt;   /* sqrt() */
+#include &lt;getopt.h&gt;   /* getopt() */
+#include &lt;stdlib.h&gt;   /* exit() */
+#include &lt;stdint.h&gt;   /* uintXX_t */
 #include &quot;olsrs3d.h&quot;
 #include &quot;search.h&quot;
 
-#define SPEED		10.0
+#define SPEED  10.0
 
 static struct timespec sleep_time = {
 	0, 100 * 1000 * 1000
@@ -71,18 +71,18 @@
 float Bottom = -1.0;
 float Left = -1.0;
 
-float CamPosition[2][3];	/* CamPosition[trans|rot][x-z] */
-float CamPosition2[2][3];	/* CamPosition[trans|rot][x-z] */
+float CamPosition[2][3]; /* CamPosition[trans|rot][x-z] */
+float CamPosition2[2][3]; /* CamPosition[trans|rot][x-z] */
 
 /* needed ? */
-/* float ZeroPosition[3] = {0,0,0};	 current position zero position */
+/* float ZeroPosition[3] = {0,0,0};  current position zero position */
 
 int ZeroPoint;   /* object zeropoint */
 float Zp_rotate = 0.0;
 int ColorSwitch = 0;   /* enable/disable colored olsr connections */
 int RotateSwitch = 0;
 float RotateSpeed = 0.5;
-float Factor = 0.6;	/* Factor in calc_olsr_node_mov */
+float Factor = 0.6; /* Factor in calc_olsr_node_mov */
 struct olsr_node *Olsr_node_pEtx;
 
 int Btn_close_id = -1;
@@ -98,14 +98,14 @@
  *
  ***/
 
-void print_usage( void )
+void print_usage(void)
 {
 
-	printf( &quot;Usage is olsrs3d [options] [-- [s3d options]]\n&quot; );
-	printf( &quot;olsrs3d options:\n&quot; );
-	printf( &quot;   -h\tprint this short help\n&quot; );
-	printf( &quot;   -d\tenable debug mode\n&quot; );
-	printf( &quot;   -H\tconnect to olsr node [default: localhost]\n&quot; );
+	printf(&quot;Usage is olsrs3d [options] [-- [s3d options]]\n&quot;);
+	printf(&quot;olsrs3d options:\n&quot;);
+	printf(&quot;   -h\tprint this short help\n&quot;);
+	printf(&quot;   -d\tenable debug mode\n&quot;);
+	printf(&quot;   -H\tconnect to olsr node [default: localhost]\n&quot;);
 	s3d_usage();
 
 }
@@ -124,30 +124,30 @@
 	s3dw_surface *infwin;
 	s3dw_button  *button;
 
-	infwin = s3dw_surface_new( &quot;Help Window&quot;, 20, 19 );
+	infwin = s3dw_surface_new(&quot;Help Window&quot;, 20, 19);
 
 	/*s3dw_label_new(infwin,&quot;C        - Colour On/Off&quot;,1,2);*/
-	s3dw_label_new(infwin,&quot;c&quot;,1,2);
-	s3dw_label_new(infwin,&quot;- Colour On/Off&quot;,6,2);
+	s3dw_label_new(infwin, &quot;c&quot;, 1, 2);
+	s3dw_label_new(infwin, &quot;- Colour On/Off&quot;, 6, 2);
 	/*s3dw_label_new(infwin,&quot;r        - Rotation On/Off&quot;,1,4);*/
-	s3dw_label_new(infwin,&quot;r&quot;,1,4);
-	s3dw_label_new(infwin,&quot;- Rotation On/Off&quot;,6,4);
-	s3dw_label_new(infwin,&quot;+&quot;,1,5);
-	s3dw_label_new(infwin,&quot;- Increase Rotation Speed&quot;,6,5);
-	s3dw_label_new(infwin,&quot;-&quot;,1,6);
-	s3dw_label_new(infwin,&quot;- Decrease Rotation Speed&quot;,6,6);
-	s3dw_label_new(infwin,&quot;s&quot;,1,8);
-	s3dw_label_new(infwin,&quot;- Search IP&quot;,6,8);
-	s3dw_label_new(infwin,&quot;ESC&quot;,1,9);
-	s3dw_label_new(infwin,&quot;- Disable FollowMode&quot;,6,9);
-	s3dw_label_new(infwin,&quot;PGUP&quot;,1,11);
-	s3dw_label_new(infwin,&quot;- Increase Drift Factor&quot;,6,11);
-	s3dw_label_new(infwin,&quot;PGDOWN&quot;,1,12);
-	s3dw_label_new(infwin,&quot;- Decrease Drift Factor&quot;,6,12);
-	s3dw_label_new(infwin,&quot;STRG + p&quot;,1,14);
-	s3dw_label_new(infwin,&quot;- Reset Nodes&quot;,6,14);
+	s3dw_label_new(infwin, &quot;r&quot;, 1, 4);
+	s3dw_label_new(infwin, &quot;- Rotation On/Off&quot;, 6, 4);
+	s3dw_label_new(infwin, &quot;+&quot;, 1, 5);
+	s3dw_label_new(infwin, &quot;- Increase Rotation Speed&quot;, 6, 5);
+	s3dw_label_new(infwin, &quot;-&quot;, 1, 6);
+	s3dw_label_new(infwin, &quot;- Decrease Rotation Speed&quot;, 6, 6);
+	s3dw_label_new(infwin, &quot;s&quot;, 1, 8);
+	s3dw_label_new(infwin, &quot;- Search IP&quot;, 6, 8);
+	s3dw_label_new(infwin, &quot;ESC&quot;, 1, 9);
+	s3dw_label_new(infwin, &quot;- Disable FollowMode&quot;, 6, 9);
+	s3dw_label_new(infwin, &quot;PGUP&quot;, 1, 11);
+	s3dw_label_new(infwin, &quot;- Increase Drift Factor&quot;, 6, 11);
+	s3dw_label_new(infwin, &quot;PGDOWN&quot;, 1, 12);
+	s3dw_label_new(infwin, &quot;- Decrease Drift Factor&quot;, 6, 12);
+	s3dw_label_new(infwin, &quot;STRG + p&quot;, 1, 14);
+	s3dw_label_new(infwin, &quot;- Reset Nodes&quot;, 6, 14);
 
-	button=s3dw_button_new(infwin,&quot;OK&quot;,9,16);
+	button = s3dw_button_new(infwin, &quot;OK&quot;, 9, 16);
 	button-&gt;onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 
@@ -160,10 +160,10 @@
 	s3dw_surface *infwin;
 	s3dw_button  *button;
 
-	infwin = s3dw_surface_new( &quot;Error&quot;, 12, 6 );
-	s3dw_label_new(infwin,msg,1,2);
+	infwin = s3dw_surface_new(&quot;Error&quot;, 12, 6);
+	s3dw_label_new(infwin, msg, 1, 2);
 
-	button=s3dw_button_new(infwin,&quot;OK&quot;,4,4);
+	button = s3dw_button_new(infwin, &quot;OK&quot;, 4, 4);
 	button-&gt;onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 
@@ -176,10 +176,10 @@
  *
  ***/
 
-void out_of_mem( void )
+void out_of_mem(void)
 {
 
-	printf( &quot;Sorry - you ran out of memory !\n&quot; );
+	printf(&quot;Sorry - you ran out of memory !\n&quot;);
 	exit(8);
 
 }
@@ -213,9 +213,9 @@
 float dist(float p1[], float p2[])
 {
 	float p[3];
-	p[0]=p1[0]-p2[0];
-	p[1]=p1[1]-p2[1];
-	p[2]=p1[2]-p2[2];
+	p[0] = p1[0] - p2[0];
+	p[1] = p1[1] - p2[1];
+	p[2] = p1[2] - p2[2];
 	return (sqrt(p[0]*p[0]   +  p[1]*p[1]  +  p[2]*p[2]));
 
 }
@@ -237,16 +237,16 @@
 float dirt(float p1[], float p2[], float p3[])
 {
 	float d;
-	d=dist(p1,p2);
-	if (d==0) {
-		p3[0]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		p3[1]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		p3[2]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		d=s3d_vector_length(p3);
+	d = dist(p1, p2);
+	if (d == 0) {
+		p3[0] = ((float) 0.2 * rand()) / RAND_MAX - 0.1;
+		p3[1] = ((float) 0.2 * rand()) / RAND_MAX - 0.1;
+		p3[2] = ((float) 0.2 * rand()) / RAND_MAX - 0.1;
+		d = s3d_vector_length(p3);
 	} else {
-		p3[0]=p2[0]-p1[0];
-		p3[1]=p2[1]-p1[1];
-		p3[2]=p2[2]-p1[2];
+		p3[0] = p2[0] - p1[0];
+		p3[1] = p2[1] - p1[1];
+		p3[2] = p2[2] - p1[2];
 	}
 	return(d);
 }
@@ -266,12 +266,12 @@
 
 void mov_add(float mov[], float p[], float fac)
 {
-	/*	if (fac&gt;1000)
-			return;
-		fac=1000; */
-	mov[0]+=fac*p[0];
-	mov[1]+=fac*p[1];
-	mov[2]+=fac*p[2];
+	/* if (fac&gt;1000)
+	  return;
+	 fac=1000; */
+	mov[0] += fac * p[0];
+	mov[1] += fac * p[1];
+	mov[2] += fac * p[2];
 }
 
 
@@ -284,43 +284,43 @@
  *
  ***/
 
-void handle_olsr_node( struct olsr_node *olsr_node )
+void handle_olsr_node(struct olsr_node *olsr_node)
 {
 
 	float distance, angle, angle_rad;
-	float tmp_mov_vec[3], desc_norm_vec[3] = {0,0,-1};
+	float tmp_mov_vec[3], desc_norm_vec[3] = {0, 0, -1};
 	struct olsr_node *other_node;
 	struct Obj_to_ip *Obj_to_ip_curr;
 	struct olsr_neigh_list *olsr_neigh_list, *prev_olsr_neigh_list, *other_node_neigh_list, *tmp_olsr_neigh_list;
 
 	/* no more nodes left */
-	if ( olsr_node == NULL ) return;
+	if (olsr_node == NULL) return;
 
 	/* olsr node vanished */
-	if ( ( olsr_node-&gt;last_seen &lt; Output_block_counter - 1 ) &amp;&amp; ( olsr_node-&gt;visible ) ) {
+	if ((olsr_node-&gt;last_seen &lt; Output_block_counter - 1) &amp;&amp; (olsr_node-&gt;visible)) {
 
-		if ( Debug )
-			printf( &quot;olsr node vanished: %s\n&quot;, olsr_node-&gt;ip );
+		if (Debug)
+			printf(&quot;olsr node vanished: %s\n&quot;, olsr_node-&gt;ip);
 
 		Olsr_node_count--;
 
 		olsr_node-&gt;visible = 0;
 
 		/* delete shape */
-		if ( olsr_node-&gt;obj_id != -1 ) {
+		if (olsr_node-&gt;obj_id != -1) {
 
 			/* remove element from ob2ip list */
-			lst_del( olsr_node-&gt;obj_id );
+			lst_del(olsr_node-&gt;obj_id);
 			/* remove object from s3d server */
-			s3d_del_object( olsr_node-&gt;obj_id );
+			s3d_del_object(olsr_node-&gt;obj_id);
 
 			olsr_node-&gt;obj_id = -1;
 
 		}
 
-		if ( olsr_node-&gt;desc_id != -1 ) {
+		if (olsr_node-&gt;desc_id != -1) {
 
-			s3d_del_object( olsr_node-&gt;desc_id );
+			s3d_del_object(olsr_node-&gt;desc_id);
 			olsr_node-&gt;desc_id = -1;
 
 		}
@@ -328,10 +328,10 @@
 		/* delete olsr connections of this node */
 		olsr_neigh_list = olsr_node-&gt;olsr_neigh_list;
 
-		while ( olsr_neigh_list != NULL ) {
+		while (olsr_neigh_list != NULL) {
 
 			/* get connection list of 'other' node */
-			if ( olsr_neigh_list-&gt;olsr_con-&gt;left_olsr_node == olsr_node ) {
+			if (olsr_neigh_list-&gt;olsr_con-&gt;left_olsr_node == olsr_node) {
 				other_node = olsr_neigh_list-&gt;olsr_con-&gt;right_olsr_node;
 			} else {
 				other_node = olsr_neigh_list-&gt;olsr_con-&gt;left_olsr_node;
@@ -341,12 +341,12 @@
 			prev_olsr_neigh_list = NULL;
 			other_node_neigh_list = other_node-&gt;olsr_neigh_list;
 
-			while ( other_node_neigh_list != NULL ) {
+			while (other_node_neigh_list != NULL) {
 
-				if ( other_node_neigh_list-&gt;olsr_con == olsr_neigh_list-&gt;olsr_con ) {
+				if (other_node_neigh_list-&gt;olsr_con == olsr_neigh_list-&gt;olsr_con) {
 
 					/* and delete it ! */
-					if ( prev_olsr_neigh_list != NULL ) {
+					if (prev_olsr_neigh_list != NULL) {
 						/* is first, any or last element in the list */
 						prev_olsr_neigh_list-&gt;next_olsr_neigh_list = other_node_neigh_list-&gt;next_olsr_neigh_list;
 					} else {
@@ -354,7 +354,7 @@
 						other_node-&gt;olsr_neigh_list = NULL;
 					}
 
-					free( other_node_neigh_list );
+					free(other_node_neigh_list);
 
 					break;
 
@@ -365,61 +365,61 @@
 
 			}
 
-			s3d_del_object( olsr_neigh_list-&gt;olsr_con-&gt;obj_id );
+			s3d_del_object(olsr_neigh_list-&gt;olsr_con-&gt;obj_id);
 
 			/* delete connection */
-			if ( olsr_neigh_list-&gt;olsr_con-&gt;prev_olsr_con != NULL ) olsr_neigh_list-&gt;olsr_con-&gt;prev_olsr_con-&gt;next_olsr_con = olsr_neigh_list-&gt;olsr_con-&gt;next_olsr_con;
-			if ( olsr_neigh_list-&gt;olsr_con-&gt;next_olsr_con != NULL ) olsr_neigh_list-&gt;olsr_con-&gt;next_olsr_con-&gt;prev_olsr_con = olsr_neigh_list-&gt;olsr_con-&gt;prev_olsr_con;
+			if (olsr_neigh_list-&gt;olsr_con-&gt;prev_olsr_con != NULL) olsr_neigh_list-&gt;olsr_con-&gt;prev_olsr_con-&gt;next_olsr_con = olsr_neigh_list-&gt;olsr_con-&gt;next_olsr_con;
+			if (olsr_neigh_list-&gt;olsr_con-&gt;next_olsr_con != NULL) olsr_neigh_list-&gt;olsr_con-&gt;next_olsr_con-&gt;prev_olsr_con = olsr_neigh_list-&gt;olsr_con-&gt;prev_olsr_con;
 
 			tmp_olsr_neigh_list = olsr_neigh_list;
 
 			olsr_neigh_list = olsr_neigh_list-&gt;next_olsr_neigh_list;
 
-			free( tmp_olsr_neigh_list-&gt;olsr_con );
-			free( tmp_olsr_neigh_list );
+			free(tmp_olsr_neigh_list-&gt;olsr_con);
+			free(tmp_olsr_neigh_list);
 
 		}
 
 		olsr_node-&gt;olsr_neigh_list = NULL;
 
-	} else if ( olsr_node-&gt;visible ) {
+	} else if (olsr_node-&gt;visible) {
 
 		/* olsr node shape has been modified */
-		if ( olsr_node-&gt;node_type_modified ) {
+		if (olsr_node-&gt;node_type_modified) {
 
 			/* delete old shape */
-			if ( olsr_node-&gt;obj_id != -1 ) {
+			if (olsr_node-&gt;obj_id != -1) {
 				/* remove element from ob2ip list */
-				lst_del( olsr_node-&gt;obj_id );
-				s3d_del_object( olsr_node-&gt;obj_id );
+				lst_del(olsr_node-&gt;obj_id);
+				s3d_del_object(olsr_node-&gt;obj_id);
 			}
 
-			if ( olsr_node-&gt;desc_id != -1 ) s3d_del_object( olsr_node-&gt;desc_id );
+			if (olsr_node-&gt;desc_id != -1) s3d_del_object(olsr_node-&gt;desc_id);
 
 			/* create new shape */
-			if ( olsr_node-&gt;node_type == 1 ) {
+			if (olsr_node-&gt;node_type == 1) {
 				/* olsr node offers internet access */
-				olsr_node-&gt;obj_id = s3d_clone( Olsr_node_inet_obj );
-			} else if ( olsr_node-&gt;node_type == 2 ) {
+				olsr_node-&gt;obj_id = s3d_clone(Olsr_node_inet_obj);
+			} else if (olsr_node-&gt;node_type == 2) {
 				/* via hna announced network */
-				olsr_node-&gt;obj_id = s3d_clone( Olsr_node_hna_net );
+				olsr_node-&gt;obj_id = s3d_clone(Olsr_node_hna_net);
 			} else {
 				/* normal olsr node */
-				olsr_node-&gt;obj_id = s3d_clone( Olsr_node_obj );
+				olsr_node-&gt;obj_id = s3d_clone(Olsr_node_obj);
 			}
 
-			s3d_flags_on( olsr_node-&gt;obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(olsr_node-&gt;obj_id, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
 			/* link newly created object to ZeroPoint */
-			s3d_link( olsr_node-&gt;obj_id, ZeroPoint );
+			s3d_link(olsr_node-&gt;obj_id, ZeroPoint);
 			/* add object_id and olsr_node to linked list */
-			lst_add(olsr_node-&gt;obj_id,&amp;olsr_node);
+			lst_add(olsr_node-&gt;obj_id, &amp;olsr_node);
 
 			/* create olsr node text and attach (link) it to the node */
-			olsr_node-&gt;desc_id = s3d_draw_string( olsr_node-&gt;ip, &amp;olsr_node-&gt;desc_length );
-			s3d_link( olsr_node-&gt;desc_id, olsr_node-&gt;obj_id );
-			s3d_translate( olsr_node-&gt;desc_id, - olsr_node-&gt;desc_length / 2, -2, 0 );
-			s3d_flags_on( olsr_node-&gt;desc_id, S3D_OF_VISIBLE );
+			olsr_node-&gt;desc_id = s3d_draw_string(olsr_node-&gt;ip, &amp;olsr_node-&gt;desc_length);
+			s3d_link(olsr_node-&gt;desc_id, olsr_node-&gt;obj_id);
+			s3d_translate(olsr_node-&gt;desc_id, - olsr_node-&gt;desc_length / 2, -2, 0);
+			s3d_flags_on(olsr_node-&gt;desc_id, S3D_OF_VISIBLE);
 
 			olsr_node-&gt;node_type_modified = 0;
 
@@ -431,35 +431,35 @@
 		tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
 		tmp_mov_vec[2] = CamPosition2[0][2] - olsr_node-&gt;pos_vec[2];
 
-		angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
+		angle = s3d_vector_angle(desc_norm_vec, tmp_mov_vec);
 
 		/* take care of inverse cosinus */
-		if ( tmp_mov_vec[0] &gt; 0 ) {
-			angle_rad = 90.0/M_PI - angle;
-			angle = 180 - ( 180.0/M_PI * angle );
+		if (tmp_mov_vec[0] &gt; 0) {
+			angle_rad = 90.0 / M_PI - angle;
+			angle = 180 - (180.0 / M_PI * angle);
 		} else {
-			angle_rad = 90.0/M_PI + angle;
-			angle = 180 + ( 180.0/M_PI * angle );
+			angle_rad = 90.0 / M_PI + angle;
+			angle = 180 + (180.0 / M_PI * angle);
 		}
 
-		s3d_rotate( olsr_node-&gt;desc_id, 0, angle , 0 );
-		s3d_translate( olsr_node-&gt;desc_id, -cos(angle_rad)*olsr_node-&gt;desc_length/2 ,-1.5, sin(angle_rad)*olsr_node-&gt;desc_length/2 );
+		s3d_rotate(olsr_node-&gt;desc_id, 0, angle , 0);
+		s3d_translate(olsr_node-&gt;desc_id, -cos(angle_rad)*olsr_node-&gt;desc_length / 2 , -1.5, sin(angle_rad)*olsr_node-&gt;desc_length / 2);
 
 
 		/* drift away from unrelated nodes */
 		Obj_to_ip_curr = Obj_to_ip_head-&gt;next;
-		while ( Obj_to_ip_curr != Obj_to_ip_end ) {
+		while (Obj_to_ip_curr != Obj_to_ip_end) {
 
 			/* myself ... */
-			if ( olsr_node != Obj_to_ip_curr-&gt;olsr_node ) {
+			if (olsr_node != Obj_to_ip_curr-&gt;olsr_node) {
 
 				olsr_neigh_list = olsr_node-&gt;olsr_neigh_list;
-				while ( olsr_neigh_list != NULL ) {
+				while (olsr_neigh_list != NULL) {
 
 					/* nodes are related */
-					if ( ( olsr_neigh_list-&gt;olsr_con-&gt;left_olsr_node-&gt;visible == 1 ) &amp;&amp; ( olsr_neigh_list-&gt;olsr_con-&gt;right_olsr_node-&gt;visible == 1 ) ) {
+					if ((olsr_neigh_list-&gt;olsr_con-&gt;left_olsr_node-&gt;visible == 1) &amp;&amp; (olsr_neigh_list-&gt;olsr_con-&gt;right_olsr_node-&gt;visible == 1)) {
 
-						if ( ( olsr_neigh_list-&gt;olsr_con-&gt;left_olsr_node == Obj_to_ip_curr-&gt;olsr_node ) || (  olsr_neigh_list-&gt;olsr_con-&gt;right_olsr_node == Obj_to_ip_curr-&gt;olsr_node ) ) break;
+						if ((olsr_neigh_list-&gt;olsr_con-&gt;left_olsr_node == Obj_to_ip_curr-&gt;olsr_node) || (olsr_neigh_list-&gt;olsr_con-&gt;right_olsr_node == Obj_to_ip_curr-&gt;olsr_node)) break;
 
 					}
 
@@ -468,12 +468,12 @@
 				}
 
 				/* nodes are not related - so drift */
-				if ( olsr_neigh_list == NULL ) {
+				if (olsr_neigh_list == NULL) {
 
-					distance = dirt( olsr_node-&gt;pos_vec, Obj_to_ip_curr-&gt;olsr_node-&gt;pos_vec, tmp_mov_vec );
-					if ( distance &lt; 0.1 ) distance = 0.1;
-					mov_add( olsr_node-&gt;mov_vec, tmp_mov_vec,-100 / ( distance * distance ) );
-					mov_add( Obj_to_ip_curr-&gt;olsr_node-&gt;mov_vec, tmp_mov_vec, 100 / ( distance * distance ) );
+					distance = dirt(olsr_node-&gt;pos_vec, Obj_to_ip_curr-&gt;olsr_node-&gt;pos_vec, tmp_mov_vec);
+					if (distance &lt; 0.1) distance = 0.1;
+					mov_add(olsr_node-&gt;mov_vec, tmp_mov_vec, -100 / (distance * distance));
+					mov_add(Obj_to_ip_curr-&gt;olsr_node-&gt;mov_vec, tmp_mov_vec, 100 / (distance * distance));
 
 				}
 
@@ -485,8 +485,8 @@
 
 	}
 
-	handle_olsr_node( olsr_node-&gt;left );
-	handle_olsr_node( olsr_node-&gt;right );
+	handle_olsr_node(olsr_node-&gt;left);
+	handle_olsr_node(olsr_node-&gt;right);
 
 }
 
@@ -498,7 +498,7 @@
  *
  ***/
 
-void calc_olsr_node_mov( void )
+void calc_olsr_node_mov(void)
 {
 
 	float distance;
@@ -506,19 +506,19 @@
 	float f;
 	struct olsr_con *olsr_con = Con_begin;
 
-	while ( olsr_con != NULL ) {
+	while (olsr_con != NULL) {
 
-		distance = dirt( olsr_con-&gt;left_olsr_node-&gt;pos_vec, olsr_con-&gt;right_olsr_node-&gt;pos_vec, tmp_mov_vec );
-		f = ( ( olsr_con-&gt;left_etx_sqrt + olsr_con-&gt;left_etx_sqrt ) / 4.0 ) / distance;
+		distance = dirt(olsr_con-&gt;left_olsr_node-&gt;pos_vec, olsr_con-&gt;right_olsr_node-&gt;pos_vec, tmp_mov_vec);
+		f = ((olsr_con-&gt;left_etx_sqrt + olsr_con-&gt;left_etx_sqrt) / 4.0) / distance;
 
 		/***
 		 * drift factor - 0.0 &lt; factor &lt; 1.0 ( best results: 0.3 &lt; factor &lt; 0.9
 		 * small factor: fast and strong drift to neighbours
 		 ***/
-		if ( f &lt; Factor ) f = Factor;
+		if (f &lt; Factor) f = Factor;
 
-		mov_add( olsr_con-&gt;left_olsr_node-&gt;mov_vec, tmp_mov_vec, 1 / f - 1 );
-		mov_add( olsr_con-&gt;right_olsr_node-&gt;mov_vec, tmp_mov_vec, - ( 1 / f - 1 ) );
+		mov_add(olsr_con-&gt;left_olsr_node-&gt;mov_vec, tmp_mov_vec, 1 / f - 1);
+		mov_add(olsr_con-&gt;right_olsr_node-&gt;mov_vec, tmp_mov_vec, - (1 / f - 1));
 
 		olsr_con = olsr_con-&gt;next_olsr_con;
 
@@ -534,30 +534,30 @@
  *
  ***/
 
-void move_olsr_nodes( void )
+void move_olsr_nodes(void)
 {
 
-	float null_vec[3] = {0,0,0}, vertex_buf[6];
+	float null_vec[3] = {0, 0, 0}, vertex_buf[6];
 	float tmp_mov_vec[3];
 	float distance, etx, rgb;
 	struct olsr_con *olsr_con = Con_begin;
 
-	while ( olsr_con != NULL ) {
+	while (olsr_con != NULL) {
 
 		/* move left olsr node if it has not been moved yet */
-		if ( !( ( olsr_con-&gt;left_olsr_node-&gt;mov_vec[0] == 0 ) &amp;&amp; ( olsr_con-&gt;left_olsr_node-&gt;mov_vec[1] == 0 ) &amp;&amp; ( olsr_con-&gt;left_olsr_node-&gt;mov_vec[2] == 0 ) ) &amp;&amp; olsr_con-&gt;left_olsr_node-&gt;visible ) {
+		if (!((olsr_con-&gt;left_olsr_node-&gt;mov_vec[0] == 0) &amp;&amp; (olsr_con-&gt;left_olsr_node-&gt;mov_vec[1] == 0) &amp;&amp; (olsr_con-&gt;left_olsr_node-&gt;mov_vec[2] == 0)) &amp;&amp; olsr_con-&gt;left_olsr_node-&gt;visible) {
 
-			distance = dirt( olsr_con-&gt;left_olsr_node-&gt;pos_vec, null_vec, tmp_mov_vec );
-			mov_add( olsr_con-&gt;left_olsr_node-&gt;mov_vec, tmp_mov_vec, distance / 100 ); /* move a little bit to point zero */
-			mov_add( olsr_con-&gt;left_olsr_node-&gt;mov_vec, tmp_mov_vec, 1 ); /* move a little bit to point zero */
+			distance = dirt(olsr_con-&gt;left_olsr_node-&gt;pos_vec, null_vec, tmp_mov_vec);
+			mov_add(olsr_con-&gt;left_olsr_node-&gt;mov_vec, tmp_mov_vec, distance / 100);   /* move a little bit to point zero */
+			mov_add(olsr_con-&gt;left_olsr_node-&gt;mov_vec, tmp_mov_vec, 1);   /* move a little bit to point zero */
 
-			if ( ( distance = dist( olsr_con-&gt;left_olsr_node-&gt;mov_vec, null_vec ) ) &gt; 10.0 ) {
-				mov_add( olsr_con-&gt;left_olsr_node-&gt;pos_vec, olsr_con-&gt;left_olsr_node-&gt;mov_vec, 1.0 / ( ( float ) distance ) );
+			if ((distance = dist(olsr_con-&gt;left_olsr_node-&gt;mov_vec, null_vec)) &gt; 10.0) {
+				mov_add(olsr_con-&gt;left_olsr_node-&gt;pos_vec, olsr_con-&gt;left_olsr_node-&gt;mov_vec, 1.0 / ((float) distance));
 			} else {
-				mov_add( olsr_con-&gt;left_olsr_node-&gt;pos_vec, olsr_con-&gt;left_olsr_node-&gt;mov_vec, 0.1 );
+				mov_add(olsr_con-&gt;left_olsr_node-&gt;pos_vec, olsr_con-&gt;left_olsr_node-&gt;mov_vec, 0.1);
 			}
 
-			s3d_translate( olsr_con-&gt;left_olsr_node-&gt;obj_id, olsr_con-&gt;left_olsr_node-&gt;pos_vec[0], olsr_con-&gt;left_olsr_node-&gt;pos_vec[1], olsr_con-&gt;left_olsr_node-&gt;pos_vec[2] );
+			s3d_translate(olsr_con-&gt;left_olsr_node-&gt;obj_id, olsr_con-&gt;left_olsr_node-&gt;pos_vec[0], olsr_con-&gt;left_olsr_node-&gt;pos_vec[1], olsr_con-&gt;left_olsr_node-&gt;pos_vec[2]);
 
 			/* reset movement vector */
 			olsr_con-&gt;left_olsr_node-&gt;mov_vec[0] = olsr_con-&gt;left_olsr_node-&gt;mov_vec[1] = olsr_con-&gt;left_olsr_node-&gt;mov_vec[2] = 0.0;
@@ -565,19 +565,19 @@
 		}
 
 		/* move right olsr node if it has not been moved yet */
-		if ( !( ( olsr_con-&gt;right_olsr_node-&gt;mov_vec[0] == 0 ) &amp;&amp; ( olsr_con-&gt;right_olsr_node-&gt;mov_vec[1] == 0 ) &amp;&amp; ( olsr_con-&gt;right_olsr_node-&gt;mov_vec[2] == 0 ) ) &amp;&amp; olsr_con-&gt;right_olsr_node-&gt;visible ) {
+		if (!((olsr_con-&gt;right_olsr_node-&gt;mov_vec[0] == 0) &amp;&amp; (olsr_con-&gt;right_olsr_node-&gt;mov_vec[1] == 0) &amp;&amp; (olsr_con-&gt;right_olsr_node-&gt;mov_vec[2] == 0)) &amp;&amp; olsr_con-&gt;right_olsr_node-&gt;visible) {
 
-			distance = dirt( olsr_con-&gt;right_olsr_node-&gt;pos_vec, null_vec, tmp_mov_vec );
-			mov_add( olsr_con-&gt;right_olsr_node-&gt;mov_vec, tmp_mov_vec, distance / 100 ); /* move a little bit to point zero */
-			mov_add( olsr_con-&gt;right_olsr_node-&gt;mov_vec, tmp_mov_vec, 1 ); /* move a little bit to point zero */
+			distance = dirt(olsr_con-&gt;right_olsr_node-&gt;pos_vec, null_vec, tmp_mov_vec);
+			mov_add(olsr_con-&gt;right_olsr_node-&gt;mov_vec, tmp_mov_vec, distance / 100);   /* move a little bit to point zero */
+			mov_add(olsr_con-&gt;right_olsr_node-&gt;mov_vec, tmp_mov_vec, 1);   /* move a little bit to point zero */
 
-			if ( ( distance = dist( olsr_con-&gt;right_olsr_node-&gt;mov_vec, null_vec ) ) &gt; 10.0 ) {
-				mov_add( olsr_con-&gt;right_olsr_node-&gt;pos_vec, olsr_con-&gt;right_olsr_node-&gt;mov_vec, 1.0 / ( ( float ) distance ) );
+			if ((distance = dist(olsr_con-&gt;right_olsr_node-&gt;mov_vec, null_vec)) &gt; 10.0) {
+				mov_add(olsr_con-&gt;right_olsr_node-&gt;pos_vec, olsr_con-&gt;right_olsr_node-&gt;mov_vec, 1.0 / ((float) distance));
 			} else {
-				mov_add( olsr_con-&gt;right_olsr_node-&gt;pos_vec, olsr_con-&gt;right_olsr_node-&gt;mov_vec, 0.1 );
+				mov_add(olsr_con-&gt;right_olsr_node-&gt;pos_vec, olsr_con-&gt;right_olsr_node-&gt;mov_vec, 0.1);
 			}
 
-			s3d_translate( olsr_con-&gt;right_olsr_node-&gt;obj_id, olsr_con-&gt;right_olsr_node-&gt;pos_vec[0], olsr_con-&gt;right_olsr_node-&gt;pos_vec[1], olsr_con-&gt;right_olsr_node-&gt;pos_vec[2] );
+			s3d_translate(olsr_con-&gt;right_olsr_node-&gt;obj_id, olsr_con-&gt;right_olsr_node-&gt;pos_vec[0], olsr_con-&gt;right_olsr_node-&gt;pos_vec[1], olsr_con-&gt;right_olsr_node-&gt;pos_vec[2]);
 
 			/* reset movement vector */
 			olsr_con-&gt;right_olsr_node-&gt;mov_vec[0] = olsr_con-&gt;right_olsr_node-&gt;mov_vec[1] = olsr_con-&gt;right_olsr_node-&gt;mov_vec[2] = 0.0;
@@ -593,92 +593,92 @@
 		vertex_buf[4] = olsr_con-&gt;right_olsr_node-&gt;pos_vec[1];
 		vertex_buf[5] = olsr_con-&gt;right_olsr_node-&gt;pos_vec[2];
 
-		s3d_pep_vertices( olsr_con-&gt;obj_id, vertex_buf, 2 );
+		s3d_pep_vertices(olsr_con-&gt;obj_id, vertex_buf, 2);
 
 
-		if ( ColorSwitch ) {
+		if (ColorSwitch) {
 
 			/* HNA */
-			if ( olsr_con-&gt;left_etx == -1000.00 ) {
+			if (olsr_con-&gt;left_etx == -1000.00) {
 
 				if (olsr_con-&gt;color != 1) {
-					s3d_pep_material( olsr_con-&gt;obj_id,
-					                  0.0,0.0,1.0,
-					                  0.0,0.0,1.0,
-					                  0.0,0.0,1.0);
+					s3d_pep_material(olsr_con-&gt;obj_id,
+					                 0.0, 0.0, 1.0,
+					                 0.0, 0.0, 1.0,
+					                 0.0, 0.0, 1.0);
 					olsr_con-&gt;color = 1;
 				}
 
 			} else {
 
-				etx = ( olsr_con-&gt;left_etx + olsr_con-&gt;right_etx ) / 2.0;
+				etx = (olsr_con-&gt;left_etx + olsr_con-&gt;right_etx) / 2.0;
 
 				/* very good link - bright blue */
-				if ( ( etx &gt;= 1.0 ) &amp;&amp; ( etx &lt; 1.5 ) ) {
+				if ((etx &gt;= 1.0) &amp;&amp; (etx &lt; 1.5)) {
 
 					if (olsr_con-&gt;color != 2) {
-						s3d_pep_material( olsr_con-&gt;obj_id,
-						                  0.5,1.0,1.0,
-						                  0.5,1.0,1.0,
-						                  0.5,1.0,1.0);
+						s3d_pep_material(olsr_con-&gt;obj_id,
+						                 0.5, 1.0, 1.0,
+						                 0.5, 1.0, 1.0,
+						                 0.5, 1.0, 1.0);
 						olsr_con-&gt;color = 2;
 					}
 
 					/* good link - bright yellow */
-				} else if ( ( etx &gt;= 1.5 ) &amp;&amp; ( etx &lt; 2.0 ) ) {
+				} else if ((etx &gt;= 1.5) &amp;&amp; (etx &lt; 2.0)) {
 
 					rgb = 2.0 - etx;
-					if ( olsr_con-&gt;color != 3 || (olsr_con-&gt;color == 3 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10))) {
-						s3d_pep_material( olsr_con-&gt;obj_id,
-						                  1.0,1.0,rgb,
-						                  1.0,1.0,rgb,
-						                  1.0,1.0,rgb);
+					if (olsr_con-&gt;color != 3 || (olsr_con-&gt;color == 3 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) != (int) rintf(rgb * 10))) {
+						s3d_pep_material(olsr_con-&gt;obj_id,
+						                 1.0, 1.0, rgb,
+						                 1.0, 1.0, rgb,
+						                 1.0, 1.0, rgb);
 						olsr_con-&gt;color = 3;
 
 						olsr_con-&gt;rgb =  rgb;
 					}
 
 					/* not so good link - orange */
-				} else if ( ( etx &gt;= 2.0 ) &amp;&amp; ( etx &lt; 3.0 ) ) {
+				} else if ((etx &gt;= 2.0) &amp;&amp; (etx &lt; 3.0)) {
 
-					rgb = 1.5 - ( etx / 2.0 );
-					if ( olsr_con-&gt;color != 4 || (olsr_con-&gt;color == 4 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10))) {
-						s3d_pep_material( olsr_con-&gt;obj_id,
-						                  1.0,rgb,0.0,
-						                  1.0,rgb,0.0,
-						                  1.0,rgb,0.0);
+					rgb = 1.5 - (etx / 2.0);
+					if (olsr_con-&gt;color != 4 || (olsr_con-&gt;color == 4 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) != (int) rintf(rgb * 10))) {
+						s3d_pep_material(olsr_con-&gt;obj_id,
+						                 1.0, rgb, 0.0,
+						                 1.0, rgb, 0.0,
+						                 1.0, rgb, 0.0);
 						olsr_con-&gt;color = 4;
 
 						olsr_con-&gt;rgb = rgb;
 					}
 
 					/* bad link (almost dead) - brown */
-				} else if ( ( etx &gt;= 3.0 ) &amp;&amp; ( etx &lt; 5.0 ) ) {
+				} else if ((etx &gt;= 3.0) &amp;&amp; (etx &lt; 5.0)) {
 
-					rgb = 1.75 - ( etx / 4.0 );
+					rgb = 1.75 - (etx / 4.0);
 
-					if ( olsr_con-&gt;color != 5 || (olsr_con-&gt;color == 5 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10)) ) {
+					if (olsr_con-&gt;color != 5 || (olsr_con-&gt;color == 5 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) != (int) rintf(rgb * 10))) {
 
-						s3d_pep_material( olsr_con-&gt;obj_id,
-						                  rgb,rgb - 0.5,0.0,
-						                  rgb,rgb - 0.5,0.0,
-						                  rgb,rgb - 0.5,0.0);
+						s3d_pep_material(olsr_con-&gt;obj_id,
+						                 rgb, rgb - 0.5, 0.0,
+						                 rgb, rgb - 0.5, 0.0,
+						                 rgb, rgb - 0.5, 0.0);
 						olsr_con-&gt;color = 5;
 
 						olsr_con-&gt;rgb = rgb;
 					}
 
 					/* zombie link - grey */
-				} else if ( ( etx &gt;= 5.0 ) &amp;&amp; ( etx &lt; 1000.0 ) ) {
+				} else if ((etx &gt;= 5.0) &amp;&amp; (etx &lt; 1000.0)) {
 
-					rgb = 1000.0 / ( 1500.0 + etx );
+					rgb = 1000.0 / (1500.0 + etx);
 
-					if ( olsr_con-&gt;color != 6 || (olsr_con-&gt;color == 6 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10)) ) {
+					if (olsr_con-&gt;color != 6 || (olsr_con-&gt;color == 6 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) != (int) rintf(rgb * 10))) {
 
-						s3d_pep_material( olsr_con-&gt;obj_id,
-						                  rgb,rgb,rgb,
-						                  rgb,rgb,rgb,
-						                  rgb,rgb,rgb);
+						s3d_pep_material(olsr_con-&gt;obj_id,
+						                 rgb, rgb, rgb,
+						                 rgb, rgb, rgb,
+						                 rgb, rgb, rgb);
 						olsr_con-&gt;color = 6;
 
 						olsr_con-&gt;rgb = rgb;
@@ -688,10 +688,10 @@
 				} else {
 
 					if (olsr_con-&gt;color != 7) {
-						s3d_pep_material( olsr_con-&gt;obj_id,
-						                  0.3,0.3,0.3,
-						                  0.3,0.3,0.3,
-						                  0.3,0.3,0.3);
+						s3d_pep_material(olsr_con-&gt;obj_id,
+						                 0.3, 0.3, 0.3,
+						                 0.3, 0.3, 0.3,
+						                 0.3, 0.3, 0.3);
 						olsr_con-&gt;color = 7;
 					}
 
@@ -702,10 +702,10 @@
 		} else {
 
 			if (olsr_con-&gt;color != 0) {
-				s3d_pep_material( olsr_con-&gt;obj_id,
-				                  1.0,1.0,1.0,
-				                  1.0,1.0,1.0,
-				                  1.0,1.0,1.0);
+				s3d_pep_material(olsr_con-&gt;obj_id,
+				                 1.0, 1.0, 1.0,
+				                 1.0, 1.0, 1.0,
+				                 1.0, 1.0, 1.0);
 				olsr_con-&gt;color = 0;
 			}
 
@@ -731,26 +731,26 @@
 	calc_olsr_node_mov();
 
 	/* prepare nodes */
-	handle_olsr_node( Olsr_root );
+	handle_olsr_node(Olsr_root);
 
 	/* move it */
 	move_olsr_nodes();
 
 	/* if we have more or less nodes now - redraw node count */
-	if ( Olsr_node_count != Last_olsr_node_count ) {
+	if (Olsr_node_count != Last_olsr_node_count) {
 
-		if ( Olsr_node_count_obj != -1 ) s3d_del_object( Olsr_node_count_obj );
-		snprintf( nc_str, 20, &quot;node count: %d&quot;, Olsr_node_count );
-		Olsr_node_count_obj = s3d_draw_string( nc_str, &amp;strLen );
-		s3d_link( Olsr_node_count_obj, 0 );
-		s3d_flags_on( Olsr_node_count_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_node_count_obj, 0.2 );
-		s3d_translate( Olsr_node_count_obj, -Left*3.0-(strLen * 0.2), -Bottom*3.0-0.5, -3.0 );
+		if (Olsr_node_count_obj != -1) s3d_del_object(Olsr_node_count_obj);
+		snprintf(nc_str, 20, &quot;node count: %d&quot;, Olsr_node_count);
+		Olsr_node_count_obj = s3d_draw_string(nc_str, &amp;strLen);
+		s3d_link(Olsr_node_count_obj, 0);
+		s3d_flags_on(Olsr_node_count_obj, S3D_OF_VISIBLE);
+		s3d_scale(Olsr_node_count_obj, 0.2);
+		s3d_translate(Olsr_node_count_obj, -Left*3.0 - (strLen * 0.2), -Bottom*3.0 - 0.5, -3.0);
 		Last_olsr_node_count = Olsr_node_count;
 
 	}
 
-	if ( Output_block_completed ) {
+	if (Output_block_completed) {
 
 		Output_block_counter++;
 		Output_block_completed = 0;
@@ -759,8 +759,8 @@
 
 	/* read data from socket */
 	Net_read_count = 0;
-	while ( ( net_result = net_main() ) != 0 ) {
-		if ( net_result == -1 ) {
+	while ((net_result = net_main()) != 0) {
+		if (net_result == -1) {
 			s3d_quit();
 			break;
 		}
@@ -768,30 +768,30 @@
 
 	/* rotate modus */
 	if (RotateSwitch) {
-		Zp_rotate = ( Zp_rotate + RotateSpeed ) &gt; 360 ? 0.0 : ( Zp_rotate + RotateSpeed );
-		s3d_rotate(ZeroPoint,0,Zp_rotate,0);
+		Zp_rotate = (Zp_rotate + RotateSpeed) &gt; 360 ? 0.0 : (Zp_rotate + RotateSpeed);
+		s3d_rotate(ZeroPoint, 0, Zp_rotate, 0);
 	}
 
 	/* calc for node description */
-	CamPosition2[0][0]=  CamPosition[0][0]*cos(Zp_rotate*M_PI/180.0) - CamPosition[0][2] * sin (Zp_rotate*M_PI/180.0);
-	CamPosition2[0][1]=  CamPosition[0][1];
-	CamPosition2[0][2]=  CamPosition[0][0]*sin(Zp_rotate*M_PI/180.0) + CamPosition[0][2] * cos (Zp_rotate*M_PI/180.0);
+	CamPosition2[0][0] =  CamPosition[0][0] * cos(Zp_rotate * M_PI / 180.0) - CamPosition[0][2] * sin(Zp_rotate * M_PI / 180.0);
+	CamPosition2[0][1] =  CamPosition[0][1];
+	CamPosition2[0][2] =  CamPosition[0][0] * sin(Zp_rotate * M_PI / 180.0) + CamPosition[0][2] * cos(Zp_rotate * M_PI / 180.0);
 
 	/* check search status */
-	/*	if( get_search_status() == WIDGET )
-			move_to_search_widget( CamPosition[0], CamPosition[1] );*/
-	if ( get_search_status() == FOLLOW )
-		follow_node( CamPosition[0], CamPosition[1], Zp_rotate );
-	/*	if( get_search_status() == ABORT )
-			move_to_return_point( CamPosition[0], CamPosition[1] );*/
+	/* if( get_search_status() == WIDGET )
+	  move_to_search_widget( CamPosition[0], CamPosition[1] );*/
+	if (get_search_status() == FOLLOW)
+		follow_node(CamPosition[0], CamPosition[1], Zp_rotate);
+	/* if( get_search_status() == ABORT )
+	  move_to_return_point( CamPosition[0], CamPosition[1] );*/
 
 
-	if ( Olsr_ip_label_obj != -1 ) {
+	if (Olsr_ip_label_obj != -1) {
 		print_etx();
 	}
 	s3dw_ani_mate();
 
-	nanosleep( &amp;sleep_time, NULL );
+	nanosleep(&amp;sleep_time, NULL);
 
 	return;
 
@@ -813,8 +813,8 @@
 int keypress(struct s3d_evt *event)
 {
 
-	struct s3d_key_event *key=(struct s3d_key_event *)event-&gt;buf;
-	if ( get_search_status() != WIDGET ) {
+	struct s3d_key_event *key = (struct s3d_key_event *)event-&gt;buf;
+	if (get_search_status() != WIDGET) {
 		switch (key-&gt;keysym) {
 		case S3DK_F1: /* help */
 
@@ -823,16 +823,16 @@
 
 		case S3DK_ESCAPE: /* abort action */
 
-			set_search_status( get_search_status() == WIDGET ? ABORT : NOTHING );
+			set_search_status(get_search_status() == WIDGET ? ABORT : NOTHING);
 			break;
 
 		case S3DK_s: /* move to search widget, give widget focus */
 
-			set_search_status(WIDGET);							/* set status for mainloop */
-			set_node_root( Olsr_root );
+			set_search_status(WIDGET);       /* set status for mainloop */
+			set_node_root(Olsr_root);
 			show_search_window();
-			/*				set_return_point(CamPosition[0],CamPosition[1]);	/ * save the return position * /
-							set_node_root( Olsr_root );*/
+			/*    set_return_point(CamPosition[0],CamPosition[1]); / * save the return position * /
+			    set_node_root( Olsr_root );*/
 
 			break;
 
@@ -859,7 +859,7 @@
 		case S3DK_MINUS: /* - -&gt; rotate speed decrease */
 
 			if (RotateSwitch) {
-				if ( RotateSpeed &gt;= 2.0 )
+				if (RotateSpeed &gt;= 2.0)
 					RotateSpeed -= 1.0;
 				else {
 					if (RotateSpeed &gt; 0.2)
@@ -869,7 +869,7 @@
 			break;
 
 		case S3DK_p: /* strg + p -&gt; reset nodes ( zeroPoint to 0,0,0 ) */
-			if (key-&gt;modifier&amp;(S3D_KMOD_LCTRL|S3D_KMOD_RCTRL)) {
+			if (key-&gt;modifier&amp;(S3D_KMOD_LCTRL | S3D_KMOD_RCTRL)) {
 				s3d_rotate(ZeroPoint, 0, 0, 0);
 				Zp_rotate = 0.0;
 			}
@@ -889,8 +889,8 @@
 
 		}
 	} else {
-		if ( (key-&gt;keysym &gt;= S3DK_PERIOD &amp;&amp; key-&gt;keysym &lt;= S3DK_9) || key-&gt;keysym == S3DK_COMMA || key-&gt;keysym == S3DK_RETURN || key-&gt;keysym == S3DK_BACKSPACE )
-			search_widget_write( key-&gt;keysym );
+		if ((key-&gt;keysym &gt;= S3DK_PERIOD &amp;&amp; key-&gt;keysym &lt;= S3DK_9) || key-&gt;keysym == S3DK_COMMA || key-&gt;keysym == S3DK_RETURN || key-&gt;keysym == S3DK_BACKSPACE)
+			search_widget_write(key-&gt;keysym);
 	}
 	return(0);
 }
@@ -903,28 +903,28 @@
 
 int object_click(struct s3d_evt *evt)
 {
-	/*	int i
-		char ip_str[50];
-		struct timeval tv;*/
+	/* int i
+	 char ip_str[50];
+	 struct timeval tv;*/
 	struct olsr_node *olsr_node;
 	int oid;
 
 	s3dw_handle_click(evt);
-	/*	if( get_search_status() == WIDGET )
-		{
-			s3dw_handle_click(evt);
-			return;
-		}*/
+	/* if( get_search_status() == WIDGET )
+	 {
+	  s3dw_handle_click(evt);
+	  return;
+	 }*/
 
-	oid=(int)*((uint32_t *)evt-&gt;buf);
+	oid = (int) * ((uint32_t *)evt-&gt;buf);
 
 
-	if ( ( get_search_status() != FOLLOW ) &amp;&amp; ( Last_Click_Oid == oid ) &amp;&amp; ( Last_Click_Time + 250 &gt; get_time() ) ) {
+	if ((get_search_status() != FOLLOW) &amp;&amp; (Last_Click_Oid == oid) &amp;&amp; (Last_Click_Time + 250 &gt; get_time())) {
 
 		olsr_node = lst_search(oid);
 
-		if ( olsr_node != NULL )
-			follow_node_by_click( olsr_node );
+		if (olsr_node != NULL)
+			follow_node_by_click(olsr_node);
 
 	}
 
@@ -932,55 +932,55 @@
 	Last_Click_Time = get_time();
 
 
-	/*	if( oid == Btn_close_id )
-		{
-			s3d_del_object(Btn_close_id);
-			s3d_del_object(Olsr_ip_label_obj);
-			Btn_close_id = Olsr_ip_label_obj = -1;
-			for(i=0; i &lt; Size; i++)
-				s3d_del_object( Olsr_neighbour_label_obj[i] );
-			free(Olsr_neighbour_label_obj);
-			Olsr_neighbour_label_obj = NULL;
-			for(i = 0; i &lt; 4; i++)
-			{
-				if(Output_border[i] != -1)
-					s3d_del_object(Output_border[i]);
-				Output_border[i] = -1;
-			}
-			return;
-		}
+	/* if( oid == Btn_close_id )
+	 {
+	  s3d_del_object(Btn_close_id);
+	  s3d_del_object(Olsr_ip_label_obj);
+	  Btn_close_id = Olsr_ip_label_obj = -1;
+	  for(i=0; i &lt; Size; i++)
+	   s3d_del_object( Olsr_neighbour_label_obj[i] );
+	  free(Olsr_neighbour_label_obj);
+	  Olsr_neighbour_label_obj = NULL;
+	  for(i = 0; i &lt; 4; i++)
+	  {
+	   if(Output_border[i] != -1)
+	    s3d_del_object(Output_border[i]);
+	   Output_border[i] = -1;
+	  }
+	  return;
+	 }
 
-		Olsr_node_pEtx = *lst_search(oid);
+	 Olsr_node_pEtx = *lst_search(oid);
 
-		if( Olsr_node_pEtx != NULL )
-		{
-			if( Btn_close_id == -1 )
-			{
-				Btn_close_id = s3d_clone( Btn_close_obj );
-				s3d_link(Btn_close_id,0);
-				s3d_flags_on(Btn_close_id,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-				s3d_scale( Btn_close_id, 0.10 );
-				s3d_translate( Btn_close_id,-Left*3.0-0.150, -Bottom*3.0-0.9, -3.0 );
-			}
+	 if( Olsr_node_pEtx != NULL )
+	 {
+	  if( Btn_close_id == -1 )
+	  {
+	   Btn_close_id = s3d_clone( Btn_close_obj );
+	   s3d_link(Btn_close_id,0);
+	   s3d_flags_on(Btn_close_id,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	   s3d_scale( Btn_close_id, 0.10 );
+	   s3d_translate( Btn_close_id,-Left*3.0-0.150, -Bottom*3.0-0.9, -3.0 );
+	  }
 
-			if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
-			snprintf( ip_str, 35, &quot;ip: %s&quot;, Olsr_node_pEtx-&gt;ip );
-			Olsr_ip_label_obj = s3d_draw_string( ip_str, &amp;Title_len );
-			s3d_link( Olsr_ip_label_obj, 0 );
-			s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
-			s3d_scale( Olsr_ip_label_obj, 0.2 );
-			s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.2, -3.0 );
+	  if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
+	  snprintf( ip_str, 35, &quot;ip: %s&quot;, Olsr_node_pEtx-&gt;ip );
+	  Olsr_ip_label_obj = s3d_draw_string( ip_str, &amp;Title_len );
+	  s3d_link( Olsr_ip_label_obj, 0 );
+	  s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
+	  s3d_scale( Olsr_ip_label_obj, 0.2 );
+	  s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.2, -3.0 );
 
-			cam_go=1;
-			if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
-			snprintf( ip_str, 35, &quot;ip: %s&quot;, Olsr_node_pEtx-&gt;ip );
-			Olsr_ip_label_obj = s3d_draw_string( ip_str, &amp;Title_len );
-			s3d_link( Olsr_ip_label_obj, 0 );
-			s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
-			s3d_scale( Olsr_ip_label_obj, 0.2 );
-			s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
+	  cam_go=1;
+	  if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
+	  snprintf( ip_str, 35, &quot;ip: %s&quot;, Olsr_node_pEtx-&gt;ip );
+	  Olsr_ip_label_obj = s3d_draw_string( ip_str, &amp;Title_len );
+	  s3d_link( Olsr_ip_label_obj, 0 );
+	  s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
+	  s3d_scale( Olsr_ip_label_obj, 0.2 );
+	  s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
 
-		}*/
+	 }*/
 	return(0);
 }
 
@@ -989,12 +989,12 @@
 	struct olsr_neigh_list *tmpNeighbour;
 	float p = 1.4;
 	int i;
-	float len = 0.0, max_len=0.0;
+	float len = 0.0, max_len = 0.0;
 
-	if ( Olsr_neighbour_label_obj != NULL ) {
+	if (Olsr_neighbour_label_obj != NULL) {
 		/* int n = sizeof(Olsr_neighbour_label_obj) / sizeof(int);*/
-		for (i=0; i &lt; Size; i++)
-			s3d_del_object( Olsr_neighbour_label_obj[i] );
+		for (i = 0; i &lt; Size; i++)
+			s3d_del_object(Olsr_neighbour_label_obj[i]);
 		free(Olsr_neighbour_label_obj);
 		Olsr_neighbour_label_obj = NULL;
 	}
@@ -1007,81 +1007,81 @@
 		tmpNeighbour = tmpNeighbour-&gt;next_olsr_neigh_list;
 	}
 
-	Olsr_neighbour_label_obj = malloc(Size*sizeof(int));
+	Olsr_neighbour_label_obj = malloc(Size * sizeof(int));
 	tmpNeighbour = Olsr_node_pEtx-&gt;olsr_neigh_list;
 
 	for (i = 0; i &lt; Size ;i++) {
 		char nIpStr[60];
-		float mEtx = ( tmpNeighbour-&gt;olsr_con-&gt;left_etx + tmpNeighbour-&gt;olsr_con-&gt;right_etx ) / 2;
+		float mEtx = (tmpNeighbour-&gt;olsr_con-&gt;left_etx + tmpNeighbour-&gt;olsr_con-&gt;right_etx) / 2;
 
-		if ( mEtx != -1000 )
-			snprintf(nIpStr, 60, &quot;%15s --&gt; %.2f&quot;,(strcmp(Olsr_node_pEtx-&gt;ip,tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip)?tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip:tmpNeighbour-&gt;olsr_con-&gt;left_olsr_node-&gt;ip),mEtx);
+		if (mEtx != -1000)
+			snprintf(nIpStr, 60, &quot;%15s --&gt; %.2f&quot;, (strcmp(Olsr_node_pEtx-&gt;ip, tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip) ? tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip : tmpNeighbour-&gt;olsr_con-&gt;left_olsr_node-&gt;ip), mEtx);
 		else
-			snprintf(nIpStr, 60, &quot;%15s --&gt; HNA&quot;,(strcmp(Olsr_node_pEtx-&gt;ip,tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip)?tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip:tmpNeighbour-&gt;olsr_con-&gt;left_olsr_node-&gt;ip));
+			snprintf(nIpStr, 60, &quot;%15s --&gt; HNA&quot;, (strcmp(Olsr_node_pEtx-&gt;ip, tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip) ? tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip : tmpNeighbour-&gt;olsr_con-&gt;left_olsr_node-&gt;ip));
 
-		Olsr_neighbour_label_obj[i] = s3d_draw_string( nIpStr, &amp;len );
+		Olsr_neighbour_label_obj[i] = s3d_draw_string(nIpStr, &amp;len);
 		s3d_link(Olsr_neighbour_label_obj[i], 0);
-		s3d_flags_on(Olsr_neighbour_label_obj[i], S3D_OF_VISIBLE );
-		s3d_scale(Olsr_neighbour_label_obj[i], 0.2 );
-		s3d_translate(Olsr_neighbour_label_obj[i], -Left*3.0-(len * 0.2)-0.15, -Bottom*3.0-p, -3.0 );
+		s3d_flags_on(Olsr_neighbour_label_obj[i], S3D_OF_VISIBLE);
+		s3d_scale(Olsr_neighbour_label_obj[i], 0.2);
+		s3d_translate(Olsr_neighbour_label_obj[i], -Left*3.0 - (len * 0.2) - 0.15, -Bottom*3.0 - p, -3.0);
 		tmpNeighbour = tmpNeighbour-&gt;next_olsr_neigh_list;
 		p += 0.2;
-		max_len = (len &gt; max_len - 0.2)?len+0.2:max_len;
-		max_len = (Title_len &gt; max_len - 0.2)?len+0.2:max_len;
+		max_len = (len &gt; max_len - 0.2) ? len + 0.2 : max_len;
+		max_len = (Title_len &gt; max_len - 0.2) ? len + 0.2 : max_len;
 		/* printf(&quot;title: %f len: %f maxlen: %f %s\n&quot;,Title_len,len,max_len-0.2,nIpStr);*/
 	}
 
-	if ( Btn_close_id != -1) {
-		if ( Output_border[0] == -1 ) {
+	if (Btn_close_id != -1) {
+		if (Output_border[0] == -1) {
 			for (i = 0; i &lt; 4; i++) {
 				Output_border[i] = s3d_new_object();
-				s3d_push_material( Output_border[i],
-				                   1.0,1.0,1.0,
-				                   1.0,1.0,1.0,
-				                   1.0,1.0,1.0);
+				s3d_push_material(Output_border[i],
+				                  1.0, 1.0, 1.0,
+				                  1.0, 1.0, 1.0,
+				                  1.0, 1.0, 1.0);
 			}
-			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,			-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
+			s3d_push_vertex(Output_border[0], -Left*3.0 - 0.2,   -Bottom*3.0 - 0.9, -3.0);
+			s3d_push_vertex(Output_border[0], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - 0.9, -3.0);
 
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-1.0, -3.0);
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
+			s3d_push_vertex(Output_border[1], -Left*3.0 - 0.1,   -Bottom*3.0 - 1.0, -3.0);
+			s3d_push_vertex(Output_border[1], -Left*3.0 - 0.1,   -Bottom*3.0 - p,  -3.0);
 
-			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
-			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
+			s3d_push_vertex(Output_border[2], -Left*3.0 - 0.1,   -Bottom*3.0 - p,  -3.0);
+			s3d_push_vertex(Output_border[2], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - p,  -3.0);
 
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
+			s3d_push_vertex(Output_border[3], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - 0.9, -3.0);
+			s3d_push_vertex(Output_border[3], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - p,  -3.0);
 
-			s3d_push_line( Output_border[0], 0,1,0);
-			s3d_push_line( Output_border[1], 0,1,0);
-			s3d_push_line( Output_border[2], 0,1,0);
-			s3d_push_line( Output_border[3], 0,1,0);
+			s3d_push_line(Output_border[0], 0, 1, 0);
+			s3d_push_line(Output_border[1], 0, 1, 0);
+			s3d_push_line(Output_border[2], 0, 1, 0);
+			s3d_push_line(Output_border[3], 0, 1, 0);
 
-			s3d_flags_on( Output_border[0], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[1], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[2], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[3], S3D_OF_VISIBLE);
+			s3d_flags_on(Output_border[0], S3D_OF_VISIBLE);
+			s3d_flags_on(Output_border[1], S3D_OF_VISIBLE);
+			s3d_flags_on(Output_border[2], S3D_OF_VISIBLE);
+			s3d_flags_on(Output_border[3], S3D_OF_VISIBLE);
 
-			s3d_link( Output_border[0], 0);
-			s3d_link( Output_border[1], 0);
-			s3d_link( Output_border[2], 0);
-			s3d_link( Output_border[3], 0);
+			s3d_link(Output_border[0], 0);
+			s3d_link(Output_border[1], 0);
+			s3d_link(Output_border[2], 0);
+			s3d_link(Output_border[3], 0);
 		} else {
 			s3d_pop_vertex(Output_border[0], 2);
 			s3d_pop_vertex(Output_border[1], 2);
 			s3d_pop_vertex(Output_border[2], 2);
 			s3d_pop_vertex(Output_border[3], 2);
-			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,				-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
+			s3d_push_vertex(Output_border[0], -Left*3.0 - 0.2,    -Bottom*3.0 - 0.9, -3.0);
+			s3d_push_vertex(Output_border[0], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - 0.9, -3.0);
 
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-1.0, -3.0);
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
+			s3d_push_vertex(Output_border[1], -Left*3.0 - 0.1,    -Bottom*3.0 - 1.0, -3.0);
+			s3d_push_vertex(Output_border[1], -Left*3.0 - 0.1,    -Bottom*3.0 - p,  -3.0);
 
-			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
-			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p,	 -3.0);
+			s3d_push_vertex(Output_border[2], -Left*3.0 - 0.1,    -Bottom*3.0 - p,  -3.0);
+			s3d_push_vertex(Output_border[2], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - p,  -3.0);
 
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	 -3.0);
+			s3d_push_vertex(Output_border[3], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - 0.9, -3.0);
+			s3d_push_vertex(Output_border[3], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - p,   -3.0);
 		}
 	}
 }
@@ -1098,22 +1098,22 @@
 int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
+	inf = (struct s3d_obj_info *)hrmz-&gt;buf;
 	s3dw_object_info(hrmz);
-	if (inf-&gt;object==0) {
+	if (inf-&gt;object == 0) {
 		CamPosition[0][0] = inf-&gt;trans_x;
 		CamPosition[0][1] = inf-&gt;trans_y;
 		CamPosition[0][2] = inf-&gt;trans_z;
 		CamPosition[1][0] = inf-&gt;rot_x;
 		CamPosition[1][1] = inf-&gt;rot_y;
 		CamPosition[1][2] = inf-&gt;rot_z;
-		Asp=inf-&gt;scale;
-		if (Asp&gt;1.0) { /* wide screen */
-			Bottom=-1.0;
-			Left=-Asp;
+		Asp = inf-&gt;scale;
+		if (Asp &gt; 1.0) { /* wide screen */
+			Bottom = -1.0;
+			Left = -Asp;
 		} else {  /* high screen */
-			Bottom=(-1.0/Asp);
-			Left=-1.0;
+			Bottom = (-1.0 / Asp);
+			Left = -1.0;
 
 		}
 
@@ -1125,28 +1125,28 @@
 int mbutton_press(struct s3d_evt *hrmz)
 {
 	struct s3d_but_info *inf;
-	inf=(struct s3d_but_info *)hrmz-&gt;buf;
-	printf(&quot;button %d, state %d\n&quot;, inf-&gt;button,inf-&gt;state);
+	inf = (struct s3d_but_info *)hrmz-&gt;buf;
+	printf(&quot;button %d, state %d\n&quot;, inf-&gt;button, inf-&gt;state);
 	return(0);
 }
 
-int main( int argc, char *argv[] )
+int main(int argc, char *argv[])
 {
 
 	int optchar;
-	strncpy( Olsr_host, &quot;127.0.0.1&quot;, 256 );
+	strncpy(Olsr_host, &quot;127.0.0.1&quot;, 256);
 	lbuf[0] = '\0';   /* init lbuf */
 
-	while ( ( optchar = getopt ( argc, argv, &quot;dhH:&quot; ) ) != -1 ) {
+	while ((optchar = getopt(argc, argv, &quot;dhH:&quot;)) != -1) {
 
-		switch ( optchar ) {
+		switch (optchar) {
 
 		case 'd':
 			Debug = 1;
 			break;
 
 		case 'H':
-			strncpy( Olsr_host, optarg, 256 );
+			strncpy(Olsr_host, optarg, 256);
 			break;
 
 		case 'h':
@@ -1158,14 +1158,14 @@
 
 	}
 
-	if ( Debug )
-		printf( &quot;debug mode enabled ...\n&quot; );
+	if (Debug)
+		printf(&quot;debug mode enabled ...\n&quot;);
 
 	/* initialize obj2ip linked list */
 	lst_initialize();
 
 	/* delete olsrs3d options */
-	while ( ( optind &lt; argc ) &amp;&amp; ( argv[optind][0] != '-' ) ) optind++;   /* optind may point to ip addr of '-H' */
+	while ((optind &lt; argc) &amp;&amp; (argv[optind][0] != '-')) optind++;         /* optind may point to ip addr of '-H' */
 	optind--;
 	argv[optind] = argv[0];   /* save program path */
 	argc -= optind;   /* jump over olsrs3d options */
@@ -1176,27 +1176,27 @@
 
 
 	if (!net_init(Olsr_host)) {
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-		s3d_set_callback(S3D_EVENT_KEY,keypress);
-		s3d_set_callback(S3D_EVENT_QUIT,stop);
+		s3d_set_callback(S3D_EVENT_OBJ_INFO, object_info);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, object_click);
+		s3d_set_callback(S3D_EVENT_KEY, keypress);
+		s3d_set_callback(S3D_EVENT_QUIT, stop);
 
-		if (!s3d_init(&amp;argc,&amp;argv,&quot;olsrs3d&quot;)) {
+		if (!s3d_init(&amp;argc, &amp;argv, &quot;olsrs3d&quot;)) {
 
 			if (s3d_select_font(&quot;vera&quot;))
 				printf(&quot;font not found\n&quot;);
 
-			Olsr_node_obj = s3d_import_model_file( &quot;objs/accesspoint.3ds&quot; );
-			Olsr_node_inet_obj = s3d_import_model_file( &quot;objs/accesspoint_inet.3ds&quot; );
-			Olsr_node_hna_net = s3d_import_model_file( &quot;objs/internet.3ds&quot; );
-			Btn_close_obj = s3d_import_model_file( &quot;objs/btn_close.3ds&quot; );
+			Olsr_node_obj = s3d_import_model_file(&quot;objs/accesspoint.3ds&quot;);
+			Olsr_node_inet_obj = s3d_import_model_file(&quot;objs/accesspoint_inet.3ds&quot;);
+			Olsr_node_hna_net = s3d_import_model_file(&quot;objs/internet.3ds&quot;);
+			Btn_close_obj = s3d_import_model_file(&quot;objs/btn_close.3ds&quot;);
 
-			S3d_obj = s3d_import_model_file( &quot;objs/s3d_berlios_de.3ds&quot; );
+			S3d_obj = s3d_import_model_file(&quot;objs/s3d_berlios_de.3ds&quot;);
 
-			s3d_translate( S3d_obj, 0.75, -0.75, -1 );
-			s3d_scale( S3d_obj, 0.07 );
-			s3d_link( S3d_obj, 0 );
-			s3d_flags_on( S3d_obj, S3D_OF_VISIBLE );
+			s3d_translate(S3d_obj, 0.75, -0.75, -1);
+			s3d_scale(S3d_obj, 0.07);
+			s3d_link(S3d_obj, 0);
+			s3d_flags_on(S3d_obj, S3D_OF_VISIBLE);
 
 			/* create_search_widget( 0, 0, 300 ); */
 

Modified: trunk/apps/olsrs3d/net.c
===================================================================
--- trunk/apps/olsrs3d/net.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/net.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -27,17 +27,17 @@
 
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
-#include &lt;unistd.h&gt;	/* close() */
+#include &lt;unistd.h&gt; /* close() */
 #include &lt;errno.h&gt;
-#include &lt;string.h&gt; 	/* strlen(), memmove(), strncpy(), strncat() */
+#include &lt;string.h&gt;  /* strlen(), memmove(), strncpy(), strncat() */
 #include &lt;netdb.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;netinet/in.h&gt;
 #include &lt;sys/socket.h&gt;
-#include &lt;fcntl.h&gt;		/* fnctl() */
+#include &lt;fcntl.h&gt;  /* fnctl() */
 #include &quot;olsrs3d.h&quot;
 
-#define PORT 2004 		/* the port client will be connecting to  */
+#define PORT 2004   /* the port client will be connecting to  */
 char buf[MAXDATASIZE];
 
 
@@ -47,7 +47,7 @@
 	struct hostent *he;
 	struct sockaddr_in their_addr; /* connector's address information  */
 
-	if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
+	if ((he = gethostbyname(host)) == NULL) {  /* get the host info  */
 		herror(&quot;gethostbyname&quot;);
 		return(1);
 	}
@@ -67,21 +67,21 @@
 		perror(&quot;connect&quot;);
 		return(1);
 	}
-	fcntl(sockfd,F_SETFL, O_NONBLOCK);
+	fcntl(sockfd, F_SETFL, O_NONBLOCK);
 	return(0);
 }
 
 int net_main()
 {
 
-	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
-		if (errno==EAGAIN)
+	if ((numbytes = recv(sockfd, buf, MAXDATASIZE - 1, 0)) == -1) {
+		if (errno == EAGAIN)
 			return(0); /* well, that's okay ... */
 		perror(&quot;recv&quot;);
 		return(-1);
 	}
 
-	if (numbytes==0) {
+	if (numbytes == 0) {
 		printf(&quot;connection reset\n&quot;);
 		return(-1);
 	}
@@ -89,22 +89,22 @@
 	buf[numbytes] = '\0';
 
 	/* check for potential buffer overflow */
-	if ( ( strlen( lbuf ) + strlen( buf ) ) &lt; MAXLINESIZE ) {
+	if ((strlen(lbuf) + strlen(buf)) &lt; MAXLINESIZE) {
 
-		strncat( lbuf, buf, MAXLINESIZE );
+		strncat(lbuf, buf, MAXLINESIZE);
 
 	} else {
 
 		/* hope that carriage return is now in buf */
-		if ( strlen( lbuf ) &lt; MAXLINESIZE ) {
+		if (strlen(lbuf) &lt; MAXLINESIZE) {
 
-			if ( Debug ) printf( &quot;WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n&quot; );
-			strncat( lbuf, buf, MAXLINESIZE - strlen( lbuf ) );
+			if (Debug) printf(&quot;WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n&quot;);
+			strncat(lbuf, buf, MAXLINESIZE - strlen(lbuf));
 
 		} else {
 
-			if ( Debug ) printf( &quot;ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n&quot; );
-			strncpy( lbuf, buf, MAXLINESIZE );
+			if (Debug) printf(&quot;ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n&quot;);
+			strncpy(lbuf, buf, MAXLINESIZE);
 
 		}
 
@@ -112,7 +112,7 @@
 
 	process_main();
 
-	if ( ++Net_read_count &gt; 5 ) {
+	if (++Net_read_count &gt; 5) {
 		return(0);   /* continue mainloop */
 	} else {
 		return(1);   /* continue reading data from socket */

Modified: trunk/apps/olsrs3d/olsrs3d.h
===================================================================
--- trunk/apps/olsrs3d/olsrs3d.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/olsrs3d.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -37,12 +37,12 @@
 extern struct olsr_node *Olsr_root;   /* top of olsr node tree */
 extern struct Obj_to_ip *Obj_to_ip_head, *Obj_to_ip_end, *List_ptr;   /* struct list */
 
-extern int	Olsr_node_obj;
-extern int	Olsr_node_inet_obj;
-extern int	Olsr_node_hna_net;
-extern int	Btn_close_obj;
-extern int	S3d_obj;
-extern int	Btn_close_id;
+extern int Olsr_node_obj;
+extern int Olsr_node_inet_obj;
+extern int Olsr_node_hna_net;
+extern int Btn_close_obj;
+extern int S3d_obj;
+extern int Btn_close_id;
 extern int Olsr_node_count_obj;
 extern int Olsr_node_count;
 extern int Last_olsr_node_count;
@@ -58,7 +58,7 @@
 
 /* process */
 void lst_initialize();
-void lst_add(int id,struct olsr_node **olsr_node);
+void lst_add(int id, struct olsr_node **olsr_node);
 void lst_del(int id);
 struct olsr_node *lst_search(int id);
 void lst_out();
@@ -69,7 +69,7 @@
 int net_main();
 int net_quit();
 /* main */
-void out_of_mem( void );
-void print_etx( void );
+void out_of_mem(void);
+void print_etx(void);
 float dist(float p1[], float p2[]);
 void window_error(char *msg);

Modified: trunk/apps/olsrs3d/process.c
===================================================================
--- trunk/apps/olsrs3d/process.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/process.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,9 +25,9 @@
 
 
 
-#include &lt;stdio.h&gt; 	/* NULL */
-#include &lt;string.h&gt; 	/* strlen(), memmove() */
-#include &lt;stdlib.h&gt; 	/* rand(), malloc(), realloc(), free() */
+#include &lt;stdio.h&gt;  /* NULL */
+#include &lt;string.h&gt;  /* strlen(), memmove() */
+#include &lt;stdlib.h&gt;  /* rand(), malloc(), realloc(), free() */
 #include &lt;s3d.h&gt;
 #include &lt;math.h&gt;       /* sqrt() */
 #include &quot;olsrs3d.h&quot;
@@ -50,25 +50,25 @@
  *
  ***/
 
-int add_olsr_con( struct olsr_node *con_from, struct olsr_node *con_to, float etx )
+int add_olsr_con(struct olsr_node *con_from, struct olsr_node *con_to, float etx)
 {
 
 	struct olsr_con **olsr_con = &amp;Con_begin;
 	struct olsr_con *prev_olsr_con = NULL;   /* previous olsr connection */
 	struct olsr_neigh_list **olsr_neigh_list;
 
-	while ( (*olsr_con) != NULL ) {
+	while ((*olsr_con) != NULL) {
 
 		/* connection already exists */
-		if ( ( strncmp( (*olsr_con)-&gt;left_olsr_node-&gt;ip, con_from-&gt;ip, NAMEMAX ) == 0 ) &amp;&amp; ( strncmp( (*olsr_con)-&gt;right_olsr_node-&gt;ip, con_to-&gt;ip, NAMEMAX ) == 0 ) ) {
+		if ((strncmp((*olsr_con)-&gt;left_olsr_node-&gt;ip, con_from-&gt;ip, NAMEMAX) == 0) &amp;&amp; (strncmp((*olsr_con)-&gt;right_olsr_node-&gt;ip, con_to-&gt;ip, NAMEMAX) == 0)) {
 			(*olsr_con)-&gt;left_etx = etx;
-			(*olsr_con)-&gt;left_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
+			(*olsr_con)-&gt;left_etx_sqrt = (etx == -1000.00) ? 10.0 : sqrt(etx) ;
 			break;
 
-		} else if ( ( strncmp( (*olsr_con)-&gt;right_olsr_node-&gt;ip, con_from-&gt;ip, NAMEMAX ) == 0 ) &amp;&amp; ( strncmp( (*olsr_con)-&gt;left_olsr_node-&gt;ip, con_to-&gt;ip, NAMEMAX ) == 0 ) ) {
+		} else if ((strncmp((*olsr_con)-&gt;right_olsr_node-&gt;ip, con_from-&gt;ip, NAMEMAX) == 0) &amp;&amp; (strncmp((*olsr_con)-&gt;left_olsr_node-&gt;ip, con_to-&gt;ip, NAMEMAX) == 0)) {
 
 			(*olsr_con)-&gt;right_etx = etx;
-			(*olsr_con)-&gt;right_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
+			(*olsr_con)-&gt;right_etx_sqrt = (etx == -1000.00) ? 10.0 : sqrt(etx) ;
 			break;
 
 		}
@@ -81,10 +81,10 @@
 	}
 
 	/* new connection */
-	if ( (*olsr_con) == NULL ) {
+	if ((*olsr_con) == NULL) {
 
-		(*olsr_con) = malloc( sizeof( struct olsr_con ) );
-		if ( (*olsr_con) == NULL ) out_of_mem();
+		(*olsr_con) = malloc(sizeof(struct olsr_con));
+		if ((*olsr_con) == NULL) out_of_mem();
 
 		/* create connection object */
 		(*olsr_con)-&gt;obj_id = s3d_new_object();
@@ -95,23 +95,23 @@
 
 		/* add connection color */
 		(*olsr_con)-&gt;color = 0;
-		s3d_push_material( (*olsr_con)-&gt;obj_id,
-		                   1.0,1.0,1.0,
-		                   1.0,1.0,1.0,
-		                   1.0,1.0,1.0);
+		s3d_push_material((*olsr_con)-&gt;obj_id,
+		                  1.0, 1.0, 1.0,
+		                  1.0, 1.0, 1.0,
+		                  1.0, 1.0, 1.0);
 
 		/* add connection endpoints */
-		s3d_push_vertex( (*olsr_con)-&gt;obj_id, (*olsr_con)-&gt;left_olsr_node-&gt;pos_vec[0], (*olsr_con)-&gt;left_olsr_node-&gt;pos_vec[1], (*olsr_con)-&gt;left_olsr_node-&gt;pos_vec[2] );
-		s3d_push_vertex( (*olsr_con)-&gt;obj_id, (*olsr_con)-&gt;right_olsr_node-&gt;pos_vec[0], (*olsr_con)-&gt;right_olsr_node-&gt;pos_vec[1], (*olsr_con)-&gt;right_olsr_node-&gt;pos_vec[2] );
+		s3d_push_vertex((*olsr_con)-&gt;obj_id, (*olsr_con)-&gt;left_olsr_node-&gt;pos_vec[0], (*olsr_con)-&gt;left_olsr_node-&gt;pos_vec[1], (*olsr_con)-&gt;left_olsr_node-&gt;pos_vec[2]);
+		s3d_push_vertex((*olsr_con)-&gt;obj_id, (*olsr_con)-&gt;right_olsr_node-&gt;pos_vec[0], (*olsr_con)-&gt;right_olsr_node-&gt;pos_vec[1], (*olsr_con)-&gt;right_olsr_node-&gt;pos_vec[2]);
 
-		s3d_push_line( (*olsr_con)-&gt;obj_id, 0,1,0 );
+		s3d_push_line((*olsr_con)-&gt;obj_id, 0, 1, 0);
 
-		s3d_flags_on( (*olsr_con)-&gt;obj_id, S3D_OF_VISIBLE );
+		s3d_flags_on((*olsr_con)-&gt;obj_id, S3D_OF_VISIBLE);
 
-		s3d_link( (*olsr_con)-&gt;obj_id,  ZeroPoint );
+		s3d_link((*olsr_con)-&gt;obj_id,  ZeroPoint);
 
 		/* HNA */
-		if ( etx == -1000.00 ) {
+		if (etx == -1000.00) {
 
 			(*olsr_con)-&gt;left_etx = etx;
 			(*olsr_con)-&gt;left_etx_sqrt = 10.0;
@@ -121,9 +121,9 @@
 		} else {
 
 			(*olsr_con)-&gt;left_etx = etx;
-			(*olsr_con)-&gt;left_etx_sqrt = sqrt( etx );
+			(*olsr_con)-&gt;left_etx_sqrt = sqrt(etx);
 			(*olsr_con)-&gt;right_etx = 999.0;
-			(*olsr_con)-&gt;right_etx_sqrt = sqrt( 999.0 );
+			(*olsr_con)-&gt;right_etx_sqrt = sqrt(999.0);
 
 		}
 
@@ -132,16 +132,16 @@
 
 		/* add new olsr connection to olsr nodes in order to access the connection from the olsr node */
 		olsr_neigh_list = &amp;(*olsr_con)-&gt;left_olsr_node-&gt;olsr_neigh_list;
-		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &amp;(*olsr_neigh_list)-&gt;next_olsr_neigh_list;
-		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
-		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
+		while ((*olsr_neigh_list) != NULL) olsr_neigh_list = &amp;(*olsr_neigh_list)-&gt;next_olsr_neigh_list;
+		(*olsr_neigh_list) = malloc(sizeof(struct olsr_neigh_list));
+		if ((*olsr_neigh_list) == NULL) out_of_mem();
 		(*olsr_neigh_list)-&gt;olsr_con = (*olsr_con);
 		(*olsr_neigh_list)-&gt;next_olsr_neigh_list = NULL;
 
 		olsr_neigh_list = &amp;(*olsr_con)-&gt;right_olsr_node-&gt;olsr_neigh_list;
-		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &amp;(*olsr_neigh_list)-&gt;next_olsr_neigh_list;
-		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
-		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
+		while ((*olsr_neigh_list) != NULL) olsr_neigh_list = &amp;(*olsr_neigh_list)-&gt;next_olsr_neigh_list;
+		(*olsr_neigh_list) = malloc(sizeof(struct olsr_neigh_list));
+		if ((*olsr_neigh_list) == NULL) out_of_mem();
 		(*olsr_neigh_list)-&gt;olsr_con = (*olsr_con);
 		(*olsr_neigh_list)-&gt;next_olsr_neigh_list = NULL;
 
@@ -164,22 +164,22 @@
  *
  ***/
 
-void *get_olsr_node( struct olsr_node **olsr_node, char *ip )
+void *get_olsr_node(struct olsr_node **olsr_node, char *ip)
 {
 
 	int result;   /* result of strcmp */
 
-	while ( (*olsr_node) != NULL ) {
+	while ((*olsr_node) != NULL) {
 
-		result = strncmp( (*olsr_node)-&gt;ip, ip, NAMEMAX );
+		result = strncmp((*olsr_node)-&gt;ip, ip, NAMEMAX);
 
 		/* we found the node */
-		if ( result == 0 ) {
+		if (result == 0) {
 
 			(*olsr_node)-&gt;last_seen = Output_block_counter;
 
 			/* former invisble (deleted) node */
-			if ( (*olsr_node)-&gt;visible == 0 ) {
+			if ((*olsr_node)-&gt;visible == 0) {
 
 				(*olsr_node)-&gt;node_type = 0;
 				(*olsr_node)-&gt;node_type_modified = 1;
@@ -188,7 +188,7 @@
 
 				(*olsr_node)-&gt;mov_vec[0] = (*olsr_node)-&gt;mov_vec[1] = (*olsr_node)-&gt;mov_vec[2] = 0.0;
 
-				if ( Debug ) printf( &quot;new olsr node: %s\n&quot;, (*olsr_node)-&gt;ip );
+				if (Debug) printf(&quot;new olsr node: %s\n&quot;, (*olsr_node)-&gt;ip);
 
 				Olsr_node_count++;
 
@@ -199,7 +199,7 @@
 		}
 
 		/* the searched node must be in the subtree */
-		if ( result &lt; 0 ) {
+		if (result &lt; 0) {
 			olsr_node = &amp;(*olsr_node)-&gt;right;
 		} else {
 			olsr_node = &amp;(*olsr_node)-&gt;left;
@@ -208,15 +208,15 @@
 	}
 
 	/* if node is NULL we reached the end of the tree and must create a new olsr_node */
-	if ( (*olsr_node) == NULL ) {
+	if ((*olsr_node) == NULL) {
 
-		(*olsr_node) = malloc( sizeof( struct olsr_node ) );
-		if ( (*olsr_node) == NULL ) out_of_mem();
+		(*olsr_node) = malloc(sizeof(struct olsr_node));
+		if ((*olsr_node) == NULL) out_of_mem();
 
 		(*olsr_node)-&gt;left = NULL;
 		(*olsr_node)-&gt;right = NULL;
 
-		strncpy( (*olsr_node)-&gt;ip, ip, NAMEMAX );
+		strncpy((*olsr_node)-&gt;ip, ip, NAMEMAX);
 
 		(*olsr_node)-&gt;node_type = 0;
 		(*olsr_node)-&gt;node_type_modified = 1;
@@ -224,13 +224,13 @@
 		(*olsr_node)-&gt;last_seen = Output_block_counter;
 		(*olsr_node)-&gt;visible = 1;
 
-		if ( Debug ) printf( &quot;new olsr node: %s\n&quot;, (*olsr_node)-&gt;ip );
+		if (Debug) printf(&quot;new olsr node: %s\n&quot;, (*olsr_node)-&gt;ip);
 
 		Olsr_node_count++;
 
-		(*olsr_node)-&gt;pos_vec[0] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)-&gt;pos_vec[1] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)-&gt;pos_vec[2] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+		(*olsr_node)-&gt;pos_vec[0] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
+		(*olsr_node)-&gt;pos_vec[1] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
+		(*olsr_node)-&gt;pos_vec[2] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
 		(*olsr_node)-&gt;mov_vec[0] = (*olsr_node)-&gt;mov_vec[1] = (*olsr_node)-&gt;mov_vec[2] = 0.0;
 
 		(*olsr_node)-&gt;obj_id = -1;
@@ -270,7 +270,7 @@
  *
  */
 
-void lst_add(int id,struct olsr_node **olsr_node)
+void lst_add(int id, struct olsr_node **olsr_node)
 {
 	struct Obj_to_ip *new;
 	new = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
@@ -298,7 +298,7 @@
 	struct Obj_to_ip *del;
 	move_lst_ptr(&amp;id);
 	if (id != List_ptr-&gt;id) {
-		printf(&quot;obj2ip: remove id %d failed move_lst_ptr return id %d\n&quot;,id,List_ptr-&gt;next-&gt;id);
+		printf(&quot;obj2ip: remove id %d failed move_lst_ptr return id %d\n&quot;, id, List_ptr-&gt;next-&gt;id);
 	} else {
 		del = List_ptr;
 		List_ptr-&gt;next-&gt;prev = List_ptr-&gt;prev;
@@ -311,7 +311,7 @@
 /*
  *
  * move the List_ptr one positon ahead the searched element
- *	*id =&gt; pointer of object_id , returned from s3d_clone or s3d_new_object
+ * *id =&gt; pointer of object_id , returned from s3d_clone or s3d_new_object
  *
  */
 
@@ -327,7 +327,7 @@
 		return NULL;
 	} else {
 		/* printf(&quot;obj2ip: ok i search deeper ;-) for id=%d\n&quot;,*id); */
-		if ((*id - (int) Obj_to_ip_head-&gt;next-&gt;id) &lt;= ((int)(Obj_to_ip_end-&gt;prev-&gt;id)-*id)) {
+		if ((*id - (int) Obj_to_ip_head-&gt;next-&gt;id) &lt;= ((int)(Obj_to_ip_end-&gt;prev-&gt;id) - *id)) {
 			List_ptr = Obj_to_ip_head;
 			/* printf(&quot;obj2ip: start at head id %d - %d &lt;= %d - %d \n&quot;,*id,Obj_to_ip_head-&gt;next-&gt;id,Obj_to_ip_end-&gt;prev-&gt;id,*id); */
 			while (*id &gt;= List_ptr-&gt;next-&gt;id) {
@@ -347,7 +347,7 @@
 			List_ptr = List_ptr-&gt;prev;
 		}
 
-		if ( List_ptr-&gt;id == *id )
+		if (List_ptr-&gt;id == *id)
 			return List_ptr-&gt;olsr_node;
 		else
 			return NULL;
@@ -359,7 +359,7 @@
 /*
  *
  * search a object_id in linked list and return pointer on struct olsr_node
- *	id =&gt; object_id , returned from s3d_clone or s3d_new_object
+ * id =&gt; object_id , returned from s3d_clone or s3d_new_object
  *
  * &lt;example&gt;
  *     struct olsr_node *olsr_node;
@@ -371,7 +371,7 @@
 
 struct olsr_node *lst_search(int id) {
 
-	return( move_lst_ptr(&amp;id) );
+	return(move_lst_ptr(&amp;id));
 
 }
 
@@ -380,7 +380,7 @@
 	struct Obj_to_ip *ptr;
 	ptr = Obj_to_ip_head;
 	while (ptr != ptr-&gt;next) {
-		printf(&quot;id-&gt; %d\n&quot;,ptr-&gt;id);
+		printf(&quot;id-&gt; %d\n&quot;, ptr-&gt;id);
 		ptr = ptr-&gt;next;
 	}
 }
@@ -405,11 +405,11 @@
 
 	/*printf(&quot;---lbuf-start---\n%s\n---lbuf-end---\n&quot;,lbuf);*/
 
-	while ( (*lbuf_ptr) != '\0' ) {
+	while ((*lbuf_ptr) != '\0') {
 
 		/* printf( &quot;%c&quot;,(*lbuf_ptr) ); */
 
-		if ( (*lbuf_ptr) == '\n' ) {
+		if ((*lbuf_ptr) == '\n') {
 
 			last_cr_ptr = lbuf_ptr;
 			con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
@@ -417,9 +417,9 @@
 
 		}
 
-		if ( (*lbuf_ptr) == '&quot;' ) {
+		if ((*lbuf_ptr) == '&quot;') {
 
-			switch ( dn ) {
+			switch (dn) {
 
 			case 0:
 				con_from = lbuf_ptr + 1;
@@ -442,7 +442,7 @@
 
 			}
 
-			if ( ++dn == 6 ) {
+			if (++dn == 6) {
 
 				/* terminate strings - but not before 6 times '&quot;' */
 				(*con_from_end) = (*con_to_end) = (*etx_end) = '\0';
@@ -450,55 +450,55 @@
 				/* printf( &quot;con_from: %s, con_to: %s, etx: %s\n&quot;, con_from, con_to, etx ); */
 
 				/* announced network via HNA */
-				if ( strncmp( etx, &quot;HNA&quot;, NAMEMAX ) == 0 ) {
+				if (strncmp(etx, &quot;HNA&quot;, NAMEMAX) == 0) {
 
 					/* connection to internet */
-					if ( strncmp( con_to, &quot;0.0.0.0/0.0.0.0&quot;, NAMEMAX ) == 0 ) {
+					if (strncmp(con_to, &quot;0.0.0.0/0.0.0.0&quot;, NAMEMAX) == 0) {
 
-						olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );
+						olsr_node1 = get_olsr_node(&amp;Olsr_root, con_from);
 
-						if ( olsr_node1-&gt;node_type != 1 ) {
+						if (olsr_node1-&gt;node_type != 1) {
 
 							olsr_node1-&gt;node_type = 1;
 							olsr_node1-&gt;node_type_modified = 1;
-							if ( Debug ) printf( &quot;new internet: %s\n&quot;, olsr_node1-&gt;ip );
+							if (Debug) printf(&quot;new internet: %s\n&quot;, olsr_node1-&gt;ip);
 
 						}
 
 						/* normal HNA */
 					} else {
-						memmove(hna_node,con_to,NAMEMAX);
-						if ( (tmpChar = strchr(hna_node, (int)'/'))) {
+						memmove(hna_node, con_to, NAMEMAX);
+						if ((tmpChar = strchr(hna_node, (int)'/'))) {
 							tmpChar++;
-							address = (int)-inet_network(tmpChar);
-							sprintf(hna_name,&quot;%d&quot;,(int)(32 - ceil(log(address)/log(2))));
-							strcpy(tmpChar,hna_name);
+							address = (int) - inet_network(tmpChar);
+							sprintf(hna_name, &quot;%d&quot;, (int)(32 - ceil(log(address) / log(2))));
+							strcpy(tmpChar, hna_name);
 						}
 
-						olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );
-						olsr_node2 = get_olsr_node( &amp;Olsr_root, hna_node );
+						olsr_node1 = get_olsr_node(&amp;Olsr_root, con_from);
+						olsr_node2 = get_olsr_node(&amp;Olsr_root, hna_node);
 
-						if ( olsr_node2-&gt;node_type != 2 ) {
+						if (olsr_node2-&gt;node_type != 2) {
 
 							olsr_node2-&gt;node_type = 2;
 							olsr_node2-&gt;node_type_modified = 1;
-							if ( Debug ) printf( &quot;new hna network: %s\n&quot;, olsr_node2-&gt;ip );
+							if (Debug) printf(&quot;new hna network: %s\n&quot;, olsr_node2-&gt;ip);
 
 						}
-						if ( olsr_node1-&gt;visible &amp;&amp; olsr_node2-&gt;visible )
-							add_olsr_con( olsr_node1, olsr_node2, -1000.00 );
+						if (olsr_node1-&gt;visible &amp;&amp; olsr_node2-&gt;visible)
+							add_olsr_con(olsr_node1, olsr_node2, -1000.00);
 
 					}
 
 					/* normal node */
 				} else {
 
-					olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );
-					olsr_node2 = get_olsr_node( &amp;Olsr_root, con_to );
-					f = strtod(etx,NULL);
-					if ( f &lt; 1.0 )
+					olsr_node1 = get_olsr_node(&amp;Olsr_root, con_from);
+					olsr_node2 = get_olsr_node(&amp;Olsr_root, con_to);
+					f = strtod(etx, NULL);
+					if (f &lt; 1.0)
 						f = 999.0;
-					add_olsr_con( olsr_node1, olsr_node2, f );
+					add_olsr_con(olsr_node1, olsr_node2, f);
 				}
 				/* remove zerobyte */
 				(*con_from_end) = (*con_to_end) = (*etx_end) = '&quot;';
@@ -509,7 +509,7 @@
 
 			}
 
-		} else if ( ( (*lbuf_ptr) == '}' ) &amp;&amp; ( (*(lbuf_ptr + 1)) == '\n' ) ) {
+		} else if (((*lbuf_ptr) == '}') &amp;&amp; ((*(lbuf_ptr + 1)) == '\n')) {
 
 			Output_block_completed = 1;
 
@@ -519,7 +519,7 @@
 
 	}
 
-	if ( last_cr_ptr != NULL ) memmove( lbuf, last_cr_ptr + 1, strlen( last_cr_ptr ) );
+	if (last_cr_ptr != NULL) memmove(lbuf, last_cr_ptr + 1, strlen(last_cr_ptr));
 	/*printf(&quot;---memmove-lbuf-start---\n%s\n---memmove-lbuf-end---\n&quot;,lbuf);*/
 	return(0);
 

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/search.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,21 +25,21 @@
 #include &lt;s3dw.h&gt;
 #include &lt;s3d_keysym.h&gt;
 #include &lt;math.h&gt;
-#include &lt;stdio.h&gt;	/* TODO can remove then no more printf needed */
+#include &lt;stdio.h&gt; /* TODO can remove then no more printf needed */
 #include &lt;string.h&gt;
-#include &quot;olsrs3d.h&quot;	/* for window_error(), structs */
+#include &quot;olsrs3d.h&quot; /* for window_error(), structs */
 /* #include &quot;structs.h&quot;  already included by olsrs3d.h */
 #include &quot;search.h&quot;
 
-s3dw_surface	*_search_surface;
-s3dw_input		*_search_input;
-s3dw_widget		*_search_widget;
+s3dw_surface *_search_surface;
+s3dw_input  *_search_input;
+s3dw_widget  *_search_widget;
 
 struct olsr_node *_node_root = NULL;
 struct olsr_node **search_node = NULL;
 
-float	_return_point[2][3];				/* cam position before move to the widget */
-int		_search_status = NOTHING;			/* status of search */
+float _return_point[2][3];    /* cam position before move to the widget */
+int  _search_status = NOTHING;   /* status of search */
 
 void _search_node(s3dw_widget *dummy);
 void _new_search_node(s3dw_widget *dummy);
@@ -47,7 +47,7 @@
 
 
 /* public */
-void follow_node(float cam_position_t[], float cam_position_r[],float rotate)
+void follow_node(float cam_position_t[], float cam_position_r[], float rotate)
 {
 	float real_node_pos[3],
 	cam_target[3],
@@ -55,17 +55,17 @@
 	diff_vec[3],
 	angle;
 
-	real_node_pos[0] =  (*search_node)-&gt;pos_vec[0] * cos( rotate * M_PI / 180.0 ) - (*search_node)-&gt;pos_vec[2] * -sin ( rotate * M_PI / 180.0 );
-	real_node_pos[1] =  (*search_node)-&gt;pos_vec[1];
-	real_node_pos[2] =  (*search_node)-&gt;pos_vec[0] * -sin( rotate * M_PI / 180.0) + (*search_node)-&gt;pos_vec[2] * cos ( rotate * M_PI / 180.0 );
+	real_node_pos[0] = (*search_node)-&gt;pos_vec[0] * cos(rotate * M_PI / 180.0) - (*search_node)-&gt;pos_vec[2] * -sin(rotate * M_PI / 180.0);
+	real_node_pos[1] = (*search_node)-&gt;pos_vec[1];
+	real_node_pos[2] = (*search_node)-&gt;pos_vec[0] * -sin(rotate * M_PI / 180.0) + (*search_node)-&gt;pos_vec[2] * cos(rotate * M_PI / 180.0);
 
-	cam_target[0] = ( real_node_pos[0] + 7);
+	cam_target[0] = (real_node_pos[0] + 7);
 	cam_target[1] =   real_node_pos[1];
-	cam_target[2] = ( real_node_pos[2] + 7);
+	cam_target[2] = (real_node_pos[2] + 7);
 
-	cam_position_t[0]=( cam_position_t[0] * 4 + cam_target[0] ) / 5;
-	cam_position_t[1]=( cam_position_t[1] * 4 + cam_target[1] ) / 5;
-	cam_position_t[2]=( cam_position_t[2] * 4 + cam_target[2] ) / 5;
+	cam_position_t[0] = (cam_position_t[0] * 4 + cam_target[0]) / 5;
+	cam_position_t[1] = (cam_position_t[1] * 4 + cam_target[1]) / 5;
+	cam_position_t[2] = (cam_position_t[2] * 4 + cam_target[2]) / 5;
 
 	tmp_vec[0] =  0.0;
 	tmp_vec[1] =  0.0;
@@ -74,44 +74,44 @@
 	diff_vec[0] = cam_position_t[0] - real_node_pos[0];
 	diff_vec[1] = 0.0;
 	diff_vec[2] = cam_position_t[2] - real_node_pos[2];
-	angle = s3d_vector_angle( diff_vec, tmp_vec );
+	angle = s3d_vector_angle(diff_vec, tmp_vec);
 	/* angle = ( real_node_pos[0] &gt; 0) ? ( 180 - ( 180 / M_PI * angle ) ) : ( 180 + ( 180 / M_PI * angle ) ); */
-	angle = 180 - ( 180 / M_PI * angle );
-	cam_position_r[1] = ( cam_position_r[1] * 4 + angle ) / 5;
+	angle = 180 - (180 / M_PI * angle);
+	cam_position_r[1] = (cam_position_r[1] * 4 + angle) / 5;
 
-	s3d_translate( 0, cam_position_t[0], cam_position_t[1], cam_position_t[2] );
-	s3d_rotate( 0, cam_position_r[0], cam_position_r[1], cam_position_r[2] );
+	s3d_translate(0, cam_position_t[0], cam_position_t[1], cam_position_t[2]);
+	s3d_rotate(0, cam_position_r[0], cam_position_r[1], cam_position_r[2]);
 }
 void _abort_search_window(s3dw_widget *bwidget)
 {
 	s3dw_delete(bwidget-&gt;parent); /* remove the window cointaining the button */
-	_search_surface=NULL;
-	_search_input=NULL;
-	_search_widget=NULL;
+	_search_surface = NULL;
+	_search_input = NULL;
+	_search_widget = NULL;
 	set_search_status(NOTHING);
 }
 void show_search_window()
 {
 	s3dw_button *search_button, *abort_button;
 
-	_search_surface	= s3dw_surface_new( &quot;Node Search&quot;, 17, 10 );
-	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
+	_search_surface = s3dw_surface_new(&quot;Node Search&quot;, 17, 10);
+	_search_input = s3dw_input_new(_search_surface, 15, 1, 4);
 
-	s3dw_label_new( _search_surface, &quot;Enter the IP of the node.&quot;, 1, 2);
-	s3dw_focus( S3DWIDGET( _search_input ) );
+	s3dw_label_new(_search_surface, &quot;Enter the IP of the node.&quot;, 1, 2);
+	s3dw_focus(S3DWIDGET(_search_input));
 
-	search_button = s3dw_button_new( _search_surface, &quot;Search&quot;, 11.5, 7 );
-	abort_button  = s3dw_button_new( _search_surface, &quot;Abort&quot;, 1, 7 );
+	search_button = s3dw_button_new(_search_surface, &quot;Search&quot;, 11.5, 7);
+	abort_button  = s3dw_button_new(_search_surface, &quot;Abort&quot;, 1, 7);
 	search_button-&gt;onclick = _new_search_node;
 	abort_button-&gt;onclick = _abort_search_window;
 
 	/* TODO calc position for ok button */
 
-	s3dw_focus	( S3DWIDGET( _search_input ) );
-	s3dw_focus	( S3DWIDGET( _search_surface ) );
-	s3dw_show	( S3DWIDGET( _search_surface ) );
+	s3dw_focus(S3DWIDGET(_search_input));
+	s3dw_focus(S3DWIDGET(_search_surface));
+	s3dw_show(S3DWIDGET(_search_surface));
 
-	_search_widget	= S3DWIDGET(search_button);
+	_search_widget = S3DWIDGET(search_button);
 }
 
 /* public */
@@ -119,25 +119,25 @@
 {
 	s3dw_button *search_button, *abort_button;
 
-	_search_surface	= s3dw_surface_new( &quot;Node Search&quot;, 17, 10 );
-	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
+	_search_surface = s3dw_surface_new(&quot;Node Search&quot;, 17, 10);
+	_search_input = s3dw_input_new(_search_surface, 15, 1, 4);
 
-	s3dw_label_new( _search_surface, &quot;Enter the IP of the node.&quot;, 1, 2);
-	s3dw_focus( S3DWIDGET( _search_input ) );
+	s3dw_label_new(_search_surface, &quot;Enter the IP of the node.&quot;, 1, 2);
+	s3dw_focus(S3DWIDGET(_search_input));
 
-	search_button = s3dw_button_new( _search_surface, &quot;Search&quot;, 11.5, 7 );
-	abort_button  = s3dw_button_new( _search_surface, &quot;Abort&quot;, 1, 7 );
+	search_button = s3dw_button_new(_search_surface, &quot;Search&quot;, 11.5, 7);
+	abort_button  = s3dw_button_new(_search_surface, &quot;Abort&quot;, 1, 7);
 	search_button-&gt;onclick = _search_node;
 	abort_button-&gt;onclick = _abort_search;
 
 	/* TODO calc position for ok button */
 
-	s3dw_focus	( S3DWIDGET( _search_input ) );
-	s3dw_focus	( S3DWIDGET( _search_surface ) );
-	s3dw_show	( S3DWIDGET( _search_surface ) );
+	s3dw_focus(S3DWIDGET(_search_input));
+	s3dw_focus(S3DWIDGET(_search_surface));
+	s3dw_show(S3DWIDGET(_search_surface));
 
 	/* disabled for autofollowing mode */
-	/*_search_widget	= s3dw_getroot();
+	/*_search_widget = s3dw_getroot();
 	move_search_widget( x, y, z );
 
 	_search_widget-&gt;ary = 180;
@@ -150,7 +150,7 @@
 	_search_widget-&gt;x = x;
 	_search_widget-&gt;y = y;
 	_search_widget-&gt;z = z;
-	s3dw_moveit( _search_widget );
+	s3dw_moveit(_search_widget);
 }
 
 /* public */
@@ -159,45 +159,45 @@
 	float target, current;
 
 	set_search_status(WIDGET);
-	cam_position_t[0] = ( cam_position_t[0] * 4 + _search_widget-&gt;x ) / 5;
-	cam_position_t[1] = ( cam_position_t[1] * 4 + _search_widget-&gt;y ) / 5;
-	cam_position_t[2] = ( cam_position_t[2] * 4 + ( _search_widget-&gt;z - 10 ) ) / 5;
+	cam_position_t[0] = (cam_position_t[0] * 4 + _search_widget-&gt;x) / 5;
+	cam_position_t[1] = (cam_position_t[1] * 4 + _search_widget-&gt;y) / 5;
+	cam_position_t[2] = (cam_position_t[2] * 4 + (_search_widget-&gt;z - 10)) / 5;
 
 	target = _search_widget-&gt;arx;
 	current = cam_position_r[0];
 
-	if ( _search_widget-&gt;arx - cam_position_r[0] &gt; 180 )
+	if (_search_widget-&gt;arx - cam_position_r[0] &gt; 180)
 		target -= 360;
-	if ( _search_widget-&gt;arx - cam_position_r[0] &lt; -180 )
+	if (_search_widget-&gt;arx - cam_position_r[0] &lt; -180)
 		current -= 360;
-	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
+	cam_position_r[0] = (cam_position_r[0] * 4 + target) / 5;
 
 	target = _search_widget-&gt;ary;
 	current = cam_position_r[1];
 
-	if ( _search_widget-&gt;ary - cam_position_r[1] &gt; 180 )
+	if (_search_widget-&gt;ary - cam_position_r[1] &gt; 180)
 		target -= 360;
-	if ( _search_widget-&gt;ary - cam_position_r[1] &lt; -180 )
+	if (_search_widget-&gt;ary - cam_position_r[1] &lt; -180)
 		current -= 360;
-	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
+	cam_position_r[1] = (cam_position_r[1] * 4 + target) / 5;
 
 	target = _search_widget-&gt;arz;
 	current = cam_position_r[2];
 
-	if ( _search_widget-&gt;arz - cam_position_r[2] &gt; 180 )
+	if (_search_widget-&gt;arz - cam_position_r[2] &gt; 180)
 		target -= 360;
-	if ( _search_widget-&gt;arz - cam_position_r[2] &lt; -180 )
+	if (_search_widget-&gt;arz - cam_position_r[2] &lt; -180)
 		current -= 360;
-	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
+	cam_position_r[2] = (cam_position_r[2] * 4 + target) / 5;
 
-	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
-	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
+	s3d_translate(0, cam_position_t[0], cam_position_t[1], cam_position_t[2]);
+	s3d_rotate(0, cam_position_r[0], cam_position_r[1], cam_position_r[2]);
 
-	if ( sqrt(  (( cam_position_t[0] - _search_widget-&gt;x)*( cam_position_t[0] - _search_widget-&gt;x)) +
-	                (( cam_position_t[1] - _search_widget-&gt;y)*( cam_position_t[1] - _search_widget-&gt;y)) +
-	                (( cam_position_t[2] - _search_widget-&gt;z)*( cam_position_t[2] - _search_widget-&gt;z)) ) &lt; 0.2 ) {
-		s3d_translate( 0, _search_widget-&gt;x, _search_widget-&gt;y, ( _search_widget-&gt;z - 10 ) );
-		s3d_rotate( 0, _search_widget-&gt;arx, _search_widget-&gt;ary, _search_widget-&gt;arz );
+	if (sqrt(((cam_position_t[0] - _search_widget-&gt;x)*(cam_position_t[0] - _search_widget-&gt;x)) +
+	                ((cam_position_t[1] - _search_widget-&gt;y)*(cam_position_t[1] - _search_widget-&gt;y)) +
+	                ((cam_position_t[2] - _search_widget-&gt;z)*(cam_position_t[2] - _search_widget-&gt;z))) &lt; 0.2) {
+		s3d_translate(0, _search_widget-&gt;x, _search_widget-&gt;y, (_search_widget-&gt;z - 10));
+		s3d_rotate(0, _search_widget-&gt;arx, _search_widget-&gt;ary, _search_widget-&gt;arz);
 	}
 }
 
@@ -206,45 +206,45 @@
 {
 	float target, current;
 
-	cam_position_t[0] = ( cam_position_t[0] * 4 + _return_point[0][0] ) / 5;
-	cam_position_t[1] = ( cam_position_t[1] * 4 + _return_point[0][1] ) / 5;
-	cam_position_t[2] = ( cam_position_t[2] * 4 + _return_point[0][2] ) / 5;
+	cam_position_t[0] = (cam_position_t[0] * 4 + _return_point[0][0]) / 5;
+	cam_position_t[1] = (cam_position_t[1] * 4 + _return_point[0][1]) / 5;
+	cam_position_t[2] = (cam_position_t[2] * 4 + _return_point[0][2]) / 5;
 
 	target = _return_point[1][0];
 	current = cam_position_r[0];
 
-	if ( _return_point[1][0] - cam_position_r[0] &gt; 180 )
+	if (_return_point[1][0] - cam_position_r[0] &gt; 180)
 		target -= 360;
-	if ( _return_point[1][0] - cam_position_r[0] &lt; -180 )
+	if (_return_point[1][0] - cam_position_r[0] &lt; -180)
 		current -= 360;
-	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
+	cam_position_r[0] = (cam_position_r[0] * 4 + target) / 5;
 
 	target = _return_point[1][1];
 	current = cam_position_r[1];
 
-	if ( _return_point[1][1] - cam_position_r[1] &gt; 180 )
+	if (_return_point[1][1] - cam_position_r[1] &gt; 180)
 		target -= 360;
-	if ( _return_point[1][1] - cam_position_r[1] &lt; -180 )
+	if (_return_point[1][1] - cam_position_r[1] &lt; -180)
 		current -= 360;
-	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
+	cam_position_r[1] = (cam_position_r[1] * 4 + target) / 5;
 
 	target = _return_point[1][2];
 	current = cam_position_r[2];
 
-	if ( _return_point[1][2] - cam_position_r[2] &gt; 180 )
+	if (_return_point[1][2] - cam_position_r[2] &gt; 180)
 		target -= 360;
-	if ( _return_point[1][2] - cam_position_r[2] &lt; -180 )
+	if (_return_point[1][2] - cam_position_r[2] &lt; -180)
 		current -= 360;
-	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
+	cam_position_r[2] = (cam_position_r[2] * 4 + target) / 5;
 
-	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
-	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
+	s3d_translate(0, cam_position_t[0], cam_position_t[1], cam_position_t[2]);
+	s3d_rotate(0, cam_position_r[0], cam_position_r[1], cam_position_r[2]);
 
-	if ( sqrt(  (( cam_position_t[0] - _return_point[0][0])*( cam_position_t[0] - _return_point[0][0])) +
-	                (( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) +
-	                (( cam_position_t[2] - _return_point[0][2])*( cam_position_t[2] - _return_point[0][2])) ) &lt; 0.2 ) {
-		s3d_translate( 0, _return_point[0][0], _return_point[0][1], _return_point[0][2] );
-		s3d_rotate( 0, _return_point[1][0], _return_point[1][1], _return_point[1][2] );
+	if (sqrt(((cam_position_t[0] - _return_point[0][0])*(cam_position_t[0] - _return_point[0][0])) +
+	                ((cam_position_t[1] - _return_point[0][1])*(cam_position_t[1] - _return_point[0][1])) +
+	                ((cam_position_t[2] - _return_point[0][2])*(cam_position_t[2] - _return_point[0][2]))) &lt; 0.2) {
+		s3d_translate(0, _return_point[0][0], _return_point[0][1], _return_point[0][2]);
+		s3d_rotate(0, _return_point[1][0], _return_point[1][1], _return_point[1][2]);
 		set_search_status(NOTHING);
 	}
 }
@@ -260,19 +260,19 @@
 	static char s[20];
 	int ln = strlen(s);
 
-	if ( key == S3DK_COMMA ) key = S3DK_PERIOD;
+	if (key == S3DK_COMMA) key = S3DK_PERIOD;
 
-	if ( key != S3DK_RETURN ) {
-		if ( key == S3DK_BACKSPACE ) {
-			if ( ln &gt; 0 )
+	if (key != S3DK_RETURN) {
+		if (key == S3DK_BACKSPACE) {
+			if (ln &gt; 0)
 				s[ln-1] = '\0';
 		} else {
-			if ( ln &lt; 20 )
+			if (ln &lt; 20)
 				s[ln] = key;
 		}
-		s3dw_input_change_text( _search_input, s );
+		s3dw_input_change_text(_search_input, s);
 	} else {
-		_new_search_node( _search_widget );
+		_new_search_node(_search_widget);
 	}
 }
 
@@ -280,9 +280,9 @@
 void set_return_point(float cam_position_t[], float cam_position_r[])
 {
 	int i;
-	for ( i = 0; i &lt; 3; i++ )
+	for (i = 0; i &lt; 3; i++)
 		_return_point[0][i] = cam_position_t[i];
-	for ( i = 0; i &lt; 3; i++ )
+	for (i = 0; i &lt; 3; i++)
 		_return_point[1][i] = cam_position_r[i];
 }
 
@@ -312,31 +312,31 @@
 
 	search_node = &amp;_node_root;
 
-	ip = s3dw_input_gettext( _search_input );
+	ip = s3dw_input_gettext(_search_input);
 
-	while ( (*search_node) != NULL ) {
+	while ((*search_node) != NULL) {
 
-		result = strncmp( (*search_node)-&gt;ip, ip, NAMEMAX );
+		result = strncmp((*search_node)-&gt;ip, ip, NAMEMAX);
 
-		if ( result == 0 )
+		if (result == 0)
 			break;
 
-		if ( result &lt; 0 )
+		if (result &lt; 0)
 			(*search_node) = (*search_node)-&gt;right;
 		else
 			(*search_node) = (*search_node)-&gt;left;
 	}
 	s3dw_delete(dummy-&gt;parent); /* remove the window cointaining the button */
-	_search_surface=NULL;
-	_search_input=NULL;
-	_search_widget=NULL;
+	_search_surface = NULL;
+	_search_input = NULL;
+	_search_widget = NULL;
 
 
-	if ( (*search_node) != NULL ) {
-		set_search_status( FOLLOW );
+	if ((*search_node) != NULL) {
+		set_search_status(FOLLOW);
 	} else {
 		window_error(&quot;Sorry, could not find...&quot;);
-		set_search_status( NOTHING );
+		set_search_status(NOTHING);
 	}
 }
 /* public */
@@ -344,7 +344,7 @@
 {
 	search_node = &amp;_node_root;
 	(*search_node) = olsr_node;
-	set_search_status( FOLLOW );
+	set_search_status(FOLLOW);
 }
 
 /* private */
@@ -355,23 +355,23 @@
 
 	search_node = &amp;_node_root;
 
-	ip = s3dw_input_gettext( _search_input );
+	ip = s3dw_input_gettext(_search_input);
 
-	while ( (*search_node) != NULL ) {
+	while ((*search_node) != NULL) {
 
-		result = strncmp( (*search_node)-&gt;ip, ip, NAMEMAX );
+		result = strncmp((*search_node)-&gt;ip, ip, NAMEMAX);
 
-		if ( result == 0 )
+		if (result == 0)
 			break;
 
-		if ( result &lt; 0 )
+		if (result &lt; 0)
 			(*search_node) = (*search_node)-&gt;right;
 		else
 			(*search_node) = (*search_node)-&gt;left;
 	}
 
-	if ( (*search_node) != NULL )
-		set_search_status( FOLLOW );
+	if ((*search_node) != NULL)
+		set_search_status(FOLLOW);
 }
 
 /* private */

Modified: trunk/apps/olsrs3d/search.h
===================================================================
--- trunk/apps/olsrs3d/search.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/search.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -21,10 +21,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#define NOTHING 0		/* nothing ;) */
-#define ABORT 1			/* widget has no focus */
-#define WIDGET 2		/* focus on widget */
-#define FOLLOW 3		/* follow search result */
+#define NOTHING 0  /* nothing ;) */
+#define ABORT 1   /* widget has no focus */
+#define WIDGET 2  /* focus on widget */
+#define FOLLOW 3  /* follow search result */
 
 void create_search_widget(float x, float y, float z);
 void move_search_widget(float x, float y, float z);
@@ -35,7 +35,7 @@
 void set_search_status(int stat);
 void search_widget_write(int key);
 void set_node_root(struct olsr_node *root);
-void follow_node(float cam_position_t[], float cam_position_r[],float rotate);
+void follow_node(float cam_position_t[], float cam_position_r[], float rotate);
 void follow_node_by_click(struct olsr_node *olsr_node);
 
 void show_search_window();

Modified: trunk/apps/olsrs3d/structs.h
===================================================================
--- trunk/apps/olsrs3d/structs.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/structs.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,21 +23,21 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#define NAMEMAX		128
-#define MAXLINESIZE 1000		/* lines in a digraph just shouldn't get that longer ... */
-#define MAXDATASIZE 100			/* max number of bytes we can get at once  */
+#define NAMEMAX  128
+#define MAXLINESIZE 1000  /* lines in a digraph just shouldn't get that longer ... */
+#define MAXDATASIZE 100   /* max number of bytes we can get at once  */
 
 /* linked list for the all connections */
 struct olsr_con {
-	struct olsr_con *next_olsr_con;			/* pointer to next connection */
-	struct olsr_con *prev_olsr_con;			/* pointer to previous connection */
-	struct olsr_node *left_olsr_node;		/* pointer to left end point of the connection */
-	struct olsr_node *right_olsr_node;		/* pointer to right end point of the connection */
-	float left_etx;							/* etx of left olsr node */
-	float right_etx;						/* etx of right olsr node */
-	float left_etx_sqrt;					/* sqrt of etx of left olsr node */
-	float right_etx_sqrt;					/* sqrt etx of right olsr node */
-	int obj_id;								/* id of connection object in s3d */
+	struct olsr_con *next_olsr_con;   /* pointer to next connection */
+	struct olsr_con *prev_olsr_con;   /* pointer to previous connection */
+	struct olsr_node *left_olsr_node;  /* pointer to left end point of the connection */
+	struct olsr_node *right_olsr_node;  /* pointer to right end point of the connection */
+	float left_etx;       /* etx of left olsr node */
+	float right_etx;      /* etx of right olsr node */
+	float left_etx_sqrt;     /* sqrt of etx of left olsr node */
+	float right_etx_sqrt;     /* sqrt etx of right olsr node */
+	int obj_id;        /* id of connection object in s3d */
 	int color;
 	float rgb;
 };
@@ -45,8 +45,8 @@
 
 /* linked list for the neighbours of each olsr node */
 struct olsr_neigh_list {
-	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
-	struct olsr_con *olsr_con;							/* pointer to the connection */
+	struct olsr_neigh_list *next_olsr_neigh_list;  /* pointer to next neighbour */
+	struct olsr_con *olsr_con;       /* pointer to the connection */
 };
 
 
@@ -54,17 +54,17 @@
 struct olsr_node {
 	struct olsr_node *left;
 	struct olsr_node *right;
-	char ip[NAMEMAX];				/* host ip */
-	int node_type;					/* normal = 0, internet gateway = 1, via hna announced network = 2 */
-	int node_type_modified;			/* node_type modified flag */
-	int last_seen;					/* last seen counter */
-	int visible;					/* is this node visible or vanished */
-	float pos_vec[3];				/* position vector in 3d &quot;space&quot; */
-	float mov_vec[3];				/* move vector */
-	int obj_id;						/* id of node object in s3d */
-	int desc_id;					/* id of node description object in s3d */
-	float desc_length;				/* length of node description object in s3d */
-	struct olsr_neigh_list *olsr_neigh_list;	/* pointer to first neighbour */
+	char ip[NAMEMAX];    /* host ip */
+	int node_type;     /* normal = 0, internet gateway = 1, via hna announced network = 2 */
+	int node_type_modified;   /* node_type modified flag */
+	int last_seen;     /* last seen counter */
+	int visible;     /* is this node visible or vanished */
+	float pos_vec[3];    /* position vector in 3d &quot;space&quot; */
+	float mov_vec[3];    /* move vector */
+	int obj_id;      /* id of node object in s3d */
+	int desc_id;     /* id of node description object in s3d */
+	float desc_length;    /* length of node description object in s3d */
+	struct olsr_neigh_list *olsr_neigh_list; /* pointer to first neighbour */
 };
 
 

Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,33 +22,33 @@
  */
 
 
-#include &lt;s3d.h&gt;		 /*  s3d_*() */
-#include &lt;stdlib.h&gt; 	 /*  getenv() */
-#include &lt;stdio.h&gt;		 /*  printf() */
-#include &lt;X11/Xlib.h&gt;	 /*  Ximage, Display, X*() */
-#include &lt;X11/Xutil.h&gt;	 /*  XDestroyImage() */
+#include &lt;s3d.h&gt;   /*  s3d_*() */
+#include &lt;stdlib.h&gt;   /*  getenv() */
+#include &lt;stdio.h&gt;   /*  printf() */
+#include &lt;X11/Xlib.h&gt;  /*  Ximage, Display, X*() */
+#include &lt;X11/Xutil.h&gt;  /*  XDestroyImage() */
 #define XK_MISCELLANY
-#include &lt;X11/keysymdef.h&gt;	 /* keysyms */
-#include &lt;X11/extensions/XTest.h&gt;	/* keyboard/mouse input via s3d */
+#include &lt;X11/keysymdef.h&gt;  /* keysyms */
+#include &lt;X11/extensions/XTest.h&gt; /* keyboard/mouse input via s3d */
 #include &lt;X11/extensions/XShm.h&gt; /* */
-#include &lt;time.h&gt;		/* nanosleep() */
-#include &lt;sys/time.h&gt; 	/* gettimeofday */
+#include &lt;time.h&gt;  /* nanosleep() */
+#include &lt;sys/time.h&gt;  /* gettimeofday */
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/shm.h&gt;
-static struct timespec t= {
-	0,100*1000*1000
+static struct timespec t = {
+	0, 100*1000*1000
 }; /* 100 mili seconds */
 
 int oid;
 XImage *image;
-Display *dpy=0;
-int window,scr;
-unsigned int width,height, height, depth;
+Display *dpy = 0;
+int window, scr;
+unsigned int width, height, height, depth;
 int format;
 char *data;
 Visual *visual;
 XShmSegmentInfo shminfo;
-char *tex_image=NULL,*otex_image=NULL,*img1,*img2;
+char *tex_image = NULL, *otex_image = NULL, *img1, *img2;
 
 
 
@@ -58,116 +58,116 @@
 
 int get_shift(unsigned long t)
 {
-	int i=0;
+	int i = 0;
 	while (t) {
-		t&gt;&gt;=1;
+		t &gt;&gt;= 1;
 		i++;
 	}
 	return(i);
 }
 void mainloop()
 {
-	int x,y;
-	int rs,gs,bs;
+	int x, y;
+	int rs, gs, bs;
 	unsigned long d;
 	int bpp;
 	char *swap_timg;
-	int last_change,start_change;
-	gettimeofday(&amp;end,NULL);
-	count[0]+=(end.tv_sec-start.tv_sec)*10000000 + end.tv_usec-start.tv_usec;
-	start.tv_sec	=end.tv_sec;
-	start.tv_usec 	=end.tv_usec;
+	int last_change, start_change;
+	gettimeofday(&amp;end, NULL);
+	count[0] += (end.tv_sec - start.tv_sec) * 10000000 + end.tv_usec - start.tv_usec;
+	start.tv_sec = end.tv_sec;
+	start.tv_usec  = end.tv_usec;
 
-	/*	image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);*/
-	XShmGetImage(dpy, window, image, 0,0,0xffffffff);
-	gettimeofday(&amp;end,NULL);
-	count[1]+=(end.tv_sec-start.tv_sec)*10000000 + end.tv_usec-start.tv_usec;
-	start.tv_sec	=end.tv_sec;
-	start.tv_usec 	=end.tv_usec;
-	if (image-&gt;format==ZPixmap) {
-		printf(&quot;Ximage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n&quot;,image-&gt;width,image-&gt;height,image-&gt;format,ZPixmap,
-		       image-&gt;bits_per_pixel,image-&gt;depth,image-&gt;bitmap_pad);
-		rs=get_shift(image-&gt;red_mask)-8;
-		gs=get_shift(image-&gt;green_mask)-8;
-		bs=get_shift(image-&gt;blue_mask)-8;
+	/* image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);*/
+	XShmGetImage(dpy, window, image, 0, 0, 0xffffffff);
+	gettimeofday(&amp;end, NULL);
+	count[1] += (end.tv_sec - start.tv_sec) * 10000000 + end.tv_usec - start.tv_usec;
+	start.tv_sec = end.tv_sec;
+	start.tv_usec  = end.tv_usec;
+	if (image-&gt;format == ZPixmap) {
+		printf(&quot;Ximage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n&quot;, image-&gt;width, image-&gt;height, image-&gt;format, ZPixmap,
+		       image-&gt;bits_per_pixel, image-&gt;depth, image-&gt;bitmap_pad);
+		rs = get_shift(image-&gt;red_mask) - 8;
+		gs = get_shift(image-&gt;green_mask) - 8;
+		bs = get_shift(image-&gt;blue_mask) - 8;
 
-		bpp=(image-&gt;bits_per_pixel/8);
+		bpp = (image-&gt;bits_per_pixel / 8);
 		/* rgb is not bgr */
-		rs=rs;
-		gs=gs-8;
-		bs=bs-16;
-		printf(&quot;Ximage: rgb: %d|%d|%d\n&quot;,	rs,gs,bs);;
-		/*		printf(&quot;red: size %d, offset %d\n&quot;,rs,roff);
-				printf(&quot;green: size %d, offset %d\n&quot;,gs,goff);
-				printf(&quot;blue: size %d, offset %d\n&quot;,bs,boff);
-				printf(&quot;bits per pixel:%d\n&quot;,bpp);*/
-		last_change=-1;
-		start_change=-1;
-		for (y=0;y&lt;height;y++) {
+		rs = rs;
+		gs = gs - 8;
+		bs = bs - 16;
+		printf(&quot;Ximage: rgb: %d|%d|%d\n&quot;, rs, gs, bs);;
+		/*  printf(&quot;red: size %d, offset %d\n&quot;,rs,roff);
+		  printf(&quot;green: size %d, offset %d\n&quot;,gs,goff);
+		  printf(&quot;blue: size %d, offset %d\n&quot;,bs,boff);
+		  printf(&quot;bits per pixel:%d\n&quot;,bpp);*/
+		last_change = -1;
+		start_change = -1;
+		for (y = 0;y &lt; height;y++) {
 
-			for (x=0;x&lt;width;x++) {
-				d=*((unsigned long *)(image-&gt;data+(y*width+x)*bpp));
-				((unsigned long *)tex_image)[(y*width+x)]=
-				        (rs&gt;0?((d&amp;image-&gt;red_mask)&gt;&gt;rs):	((d&amp;image-&gt;red_mask)&lt;&lt;-rs))|
-				        (gs&gt;0?((d&amp;image-&gt;green_mask)&gt;&gt;gs):	((d&amp;image-&gt;green_mask)&lt;&lt;-gs))|
-				        (bs&gt;0?((d&amp;image-&gt;blue_mask)&gt;&gt;bs):	((d&amp;image-&gt;blue_mask)&lt;&lt;-bs))|
-				        255&lt;&lt;24;
-				if (((unsigned long *)tex_image)[(y*width+x)]!=
+			for (x = 0;x &lt; width;x++) {
+				d = *((unsigned long *)(image-&gt;data + (y * width + x) * bpp));
+				((unsigned long *)tex_image)[(y*width+x)] =
+				        (rs &gt; 0 ? ((d &amp; image-&gt;red_mask) &gt;&gt; rs) : ((d &amp; image-&gt;red_mask) &lt;&lt; -rs)) |
+				        (gs &gt; 0 ? ((d &amp; image-&gt;green_mask) &gt;&gt; gs) : ((d &amp; image-&gt;green_mask) &lt;&lt; -gs)) |
+				        (bs &gt; 0 ? ((d &amp; image-&gt;blue_mask) &gt;&gt; bs) : ((d &amp; image-&gt;blue_mask) &lt;&lt; -bs)) |
+				        255 &lt;&lt; 24;
+				if (((unsigned long *)tex_image)[(y*width+x)] !=
 				                ((unsigned long *)otex_image)[(y*width+x)])
-					last_change=y;
+					last_change = y;
 			}
-			if (last_change!=-1) {
-				if (start_change==-1) {
-					start_change=y;
-					/* 					printf(&quot;setting start_change to %d\n&quot;,start_change); */
+			if (last_change != -1) {
+				if (start_change == -1) {
+					start_change = y;
+					/*      printf(&quot;setting start_change to %d\n&quot;,start_change); */
 				}
-				if (last_change!=y) {	 /*  last change is already over, post it! */
-					s3d_load_texture(oid,0,0,start_change,width,last_change-start_change+1,(unsigned char *)tex_image+start_change*width*4);
-					start_change=-1;
-					last_change=-1;
+				if (last_change != y) {  /*  last change is already over, post it! */
+					s3d_load_texture(oid, 0, 0, start_change, width, last_change - start_change + 1, (unsigned char *)tex_image + start_change*width*4);
+					start_change = -1;
+					last_change = -1;
 				}
 			}
 		}
 		/*  posting the last bit, maybe */
-		if (last_change!=-1) {
-			/*			printf(&quot;last one: [%d-%d]&quot;,start_change,last_change);*/
-			s3d_load_texture(oid,0,0,start_change,width,last_change-start_change,(unsigned char *)tex_image+start_change*width*4);
+		if (last_change != -1) {
+			/*   printf(&quot;last one: [%d-%d]&quot;,start_change,last_change);*/
+			s3d_load_texture(oid, 0, 0, start_change, width, last_change - start_change, (unsigned char *)tex_image + start_change*width*4);
 		}
-		/* 		s3d_load_texture(oid,0,0,0,width,height,tex_image); */
+		/*   s3d_load_texture(oid,0,0,0,width,height,tex_image); */
 		/*  swap images */
-		swap_timg=tex_image;
-		tex_image=otex_image;
-		otex_image=swap_timg;
+		swap_timg = tex_image;
+		tex_image = otex_image;
+		otex_image = swap_timg;
 	}
-	gettimeofday(&amp;end,NULL);
-	count[2]+=(end.tv_sec-start.tv_sec)*10000000 + end.tv_usec-start.tv_usec;
-	start.tv_sec	=end.tv_sec;
-	start.tv_usec 	=end.tv_usec;
+	gettimeofday(&amp;end, NULL);
+	count[2] += (end.tv_sec - start.tv_sec) * 10000000 + end.tv_usec - start.tv_usec;
+	start.tv_sec = end.tv_sec;
+	start.tv_usec  = end.tv_usec;
 	iterations++;
-	/*	XDestroyImage(image);*/
-	/*	nanosleep(&amp;t,NULL); */
+	/* XDestroyImage(image);*/
+	/* nanosleep(&amp;t,NULL); */
 }
 int keypress(struct s3d_evt *event)
 {
 	int key;
 	int kc;
-	key=*((unsigned short *)event-&gt;buf);
-	printf(&quot;received key %d &quot;,key);
+	key = *((unsigned short *)event-&gt;buf);
+	printf(&quot;received key %d &quot;, key);
 	kc = XKeysymToKeycode(dpy, key);
-	if (kc==0) {
-		kc = XKeysymToKeycode(dpy, 0xFF00+ key);
-		printf(&quot; (%04x) &quot;,0xFF00+key);
+	if (kc == 0) {
+		kc = XKeysymToKeycode(dpy, 0xFF00 + key);
+		printf(&quot; (%04x) &quot;, 0xFF00 + key);
 	}
-	if (kc==0) {
-		if (key==8) {
-			kc=22;
+	if (kc == 0) {
+		if (key == 8) {
+			kc = 22;
 			printf(&quot;!backspace!&quot;);
 		}
 	}
-	printf(&quot;using key: %d, keycode %d (%04x)\n&quot;,key,kc,kc);
-	if (kc!=0)
+	printf(&quot;using key: %d, keycode %d (%04x)\n&quot;, key, kc, kc);
+	if (kc != 0)
 		XTestFakeKeyEvent(dpy, kc, 1, 1);
-	/*	    XTestFakeKeyEvent(dpy, kc, 0, 1);*/
+	/*     XTestFakeKeyEvent(dpy, kc, 0, 1);*/
 	return(0);
 
 }
@@ -175,80 +175,80 @@
 {
 	int i;
 	printf(&quot;thats it, collecting:\n&quot;);
-	for (i=0;i&lt;3;i++)
-		printf(&quot;[%d] %f\n&quot;,i,count[i]/iterations);
+	for (i = 0;i &lt; 3;i++)
+		printf(&quot;[%d] %f\n&quot;, i, count[i] / iterations);
 	exit(0);
 	return(0);
 }
 int main(int argc, char **argv)
 {
-	char *disp=NULL;
-	int a,b,c,d;
+	char *disp = NULL;
+	int a, b, c, d;
 	int xt;
-	if (disp==NULL) disp=getenv(&quot;DISPLAY&quot;);
-	if (disp==NULL) disp=&quot;&quot;;  /*  fallback */
+	if (disp == NULL) disp = getenv(&quot;DISPLAY&quot;);
+	if (disp == NULL) disp = &quot;&quot;;  /*  fallback */
 	dpy = XOpenDisplay(disp);
 	if (!dpy) {
 		printf(&quot;couldn't open display\n&quot;);
 		return(-1);
 	}
-	count[0]=count[1]=count[2]=0;
-	iterations=0;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;X11-gate&quot;)) {
+	count[0] = count[1] = count[2] = 0;
+	iterations = 0;
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;X11-gate&quot;)) {
 		scr = DefaultScreen(dpy);
 		window = RootWindow(dpy, scr);
 		width = DisplayWidth(dpy, scr);
 		height = DisplayHeight(dpy, scr);
-		visual= DefaultVisual(dpy, scr);
+		visual = DefaultVisual(dpy, scr);
 		depth = DefaultDepth(dpy, scr);
 		XLockDisplay(dpy);
-		xt=XTestQueryExtension(dpy,&amp;a,&amp;b,&amp;c,&amp;d);
+		xt = XTestQueryExtension(dpy, &amp;a, &amp;b, &amp;c, &amp;d);
 		XUnlockDisplay(dpy);
 		if (xt) {
 			printf(&quot;having xtest extension ...\n&quot;);
 		}
 		/* X11 shm - <A HREF="http://www.xfree86.org/current/mit-shm.html">http://www.xfree86.org/current/mit-shm.html</A> */
 
-		image= XShmCreateImage(dpy, visual, depth, ZPixmap, NULL, &amp;shminfo, width, height);
-		shminfo.shmid = shmget(IPC_PRIVATE, image-&gt;bytes_per_line * image-&gt;height, IPC_CREAT|0777);
-		shminfo.shmaddr = image-&gt;data = shmat (shminfo.shmid, 0, 0);
+		image = XShmCreateImage(dpy, visual, depth, ZPixmap, NULL, &amp;shminfo, width, height);
+		shminfo.shmid = shmget(IPC_PRIVATE, image-&gt;bytes_per_line * image-&gt;height, IPC_CREAT | 0777);
+		shminfo.shmaddr = image-&gt;data = shmat(shminfo.shmid, 0, 0);
 		shmctl(shminfo.shmid, IPC_RMID, 0);
-		shminfo.readOnly= False;
+		shminfo.readOnly = False;
 		if (!XShmAttach(dpy, &amp;shminfo))
 			printf(&quot;cannot use the shared memory segment .. :( \n&quot;);
 		else
 			printf(&quot;can use share segment :D\n&quot;);
 		XSync(dpy, False);
 
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,mouseclick);
-		s3d_set_callback(S3D_EVENT_KEY,keypress);
-		printf(&quot;screen: %dx%d\n&quot;,width,height);
-		img1=malloc(width*height*4);
-		img2=malloc(width*height*4);
-		tex_image=img1;
-		otex_image=img2;
-		oid=s3d_new_object();
-		s3d_push_vertex(oid,-5,-5,0);
-		s3d_push_vertex(oid, 5,-5,0);
-		s3d_push_vertex(oid, 5, 5,0);
-		s3d_push_vertex(oid,-5, 5,0);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, mouseclick);
+		s3d_set_callback(S3D_EVENT_KEY, keypress);
+		printf(&quot;screen: %dx%d\n&quot;, width, height);
+		img1 = malloc(width * height * 4);
+		img2 = malloc(width * height * 4);
+		tex_image = img1;
+		otex_image = img2;
+		oid = s3d_new_object();
+		s3d_push_vertex(oid, -5, -5, 0);
+		s3d_push_vertex(oid, 5, -5, 0);
+		s3d_push_vertex(oid, 5, 5, 0);
+		s3d_push_vertex(oid, -5, 5, 0);
 		s3d_push_material_a(oid,
-		                    0.8,	0.0,	0.0	,1.0,
-		                    1.0,	1.0,	1.0	,1.0,
-		                    0.8,	0.0,	0.0	,1.0);
-		s3d_push_polygon(oid,0,2,1,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,1.0,
-		                          1.0,0.0,
-		                          1.0,1.0);
-		s3d_push_polygon(oid,0,3,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,1.0,
-		                          0.0,0.0,
-		                          1.0,0.0);
-		s3d_push_texture(oid,width,height);
+		                    0.8, 0.0, 0.0 , 1.0,
+		                    1.0, 1.0, 1.0 , 1.0,
+		                    0.8, 0.0, 0.0 , 1.0);
+		s3d_push_polygon(oid, 0, 2, 1, 0);
+		s3d_pep_polygon_tex_coord(oid, 0.0, 1.0,
+		                          1.0, 0.0,
+		                          1.0, 1.0);
+		s3d_push_polygon(oid, 0, 3, 2, 0);
+		s3d_pep_polygon_tex_coord(oid, 0.0, 1.0,
+		                          0.0, 0.0,
+		                          1.0, 0.0);
+		s3d_push_texture(oid, width, height);
 		/*  push data on texture 0 position (0,0) */
-		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
-		s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		gettimeofday(&amp;start,NULL);
+		s3d_pep_material_texture(oid, 0); /*  assign texture 0 to material 0 */
+		s3d_flags_on(oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		gettimeofday(&amp;start, NULL);
 		s3d_mainloop(mainloop);
 		free(img1);
 		free(img2);

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/animation.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,44 +22,44 @@
  */
 
 #include &quot;s3dfm.h&quot;
-#include &lt;stdio.h&gt; 	 /*  printf(),NULL */
-#include &lt;math.h&gt;	 /*  fabs() */
-#define SCALE 	1
+#include &lt;stdio.h&gt;   /*  printf(),NULL */
+#include &lt;math.h&gt;  /*  fabs() */
+#define SCALE  1
 
 /* the animation stack */
 static t_node *ani_s[MAXANI];
-static int ani_n=0;
+static int ani_n = 0;
 
 /* is node f already on stack? */
 int ani_onstack(t_node *f)
 {
 	int i;
-	for (i=0;i&lt;ani_n;i++)
-		if (ani_s[i]==f)
-			return(i);		/* already in list */
+	for (i = 0;i &lt; ani_n;i++)
+		if (ani_s[i] == f)
+			return(i);  /* already in list */
 	return(-1);
 
 }
 /* add an node on the animation stack */
 void ani_add(t_node *f)
 {
-	if (ani_n&lt;MAXANI) {
-		if (-1!=ani_onstack(f))
-			return;		/* already in list */
-		ani_s[ani_n]=f;
+	if (ani_n &lt; MAXANI) {
+		if (-1 != ani_onstack(f))
+			return;  /* already in list */
+		ani_s[ani_n] = f;
 		ani_iterate(f);
-		/*	printf(&quot;[A]ni ADD %d\n&quot;,ani_n); */
+		/* printf(&quot;[A]ni ADD %d\n&quot;,ani_n); */
 		ani_n++;
 	} else /* no place, finish now */
-		ani_finish(f,-1);
+		ani_finish(f, -1);
 }
 /* delete an node from the animation stack */
 void ani_del(int i)
 {
-	if ((i&gt;=0) &amp;&amp; (i&lt;ani_n)) {
-		/*		printf(&quot;[A]ni DEL %d\n&quot;,i);*/
+	if ((i &gt;= 0) &amp;&amp; (i &lt; ani_n)) {
+		/*  printf(&quot;[A]ni DEL %d\n&quot;,i);*/
 		ani_n--;
-		ani_s[i]=ani_s[ani_n]; /* that should also work if i is the last one */
+		ani_s[i] = ani_s[ani_n]; /* that should also work if i is the last one */
 	} else {
 		printf(&quot;[F]ATAL: can't delete animation!\n&quot;);
 	}
@@ -67,38 +67,38 @@
 /* well ... */
 void ani_doit(t_node *f)
 {
-	s3d_translate(	f-&gt;oid, f-&gt;dpx,f-&gt;dpy,f-&gt;dpz);
-	s3d_scale(		f-&gt;oid, f-&gt;dscale);
+	s3d_translate(f-&gt;oid, f-&gt;dpx, f-&gt;dpy, f-&gt;dpz);
+	s3d_scale(f-&gt;oid, f-&gt;dscale);
 }
 
 /* finish an animation on the stack, stack index i */
 void ani_finish(t_node *f, int i)
 {
-	f-&gt;dpx= f-&gt;px;
-	f-&gt;dpy= f-&gt;py;
-	f-&gt;dpz= f-&gt;pz;
-	f-&gt;dscale= f-&gt;scale;
+	f-&gt;dpx = f-&gt;px;
+	f-&gt;dpy = f-&gt;py;
+	f-&gt;dpz = f-&gt;pz;
+	f-&gt;dscale = f-&gt;scale;
 	ani_doit(f);
-	if (i!=-1)
+	if (i != -1)
 		ani_del(i);
 }
 void ani_iterate(t_node *f)
 {
-	f-&gt;dpx=(f-&gt;px + f-&gt;dpx*ZOOMS)/(ZOOMS+1);
-	f-&gt;dpy=(f-&gt;py + f-&gt;dpy*ZOOMS)/(ZOOMS+1);
-	f-&gt;dpz=(f-&gt;pz + f-&gt;dpz*ZOOMS)/(ZOOMS+1);
-	f-&gt;dscale=(f-&gt;scale + f-&gt;dscale*ZOOMS)/(ZOOMS+1);
+	f-&gt;dpx = (f-&gt;px + f-&gt;dpx * ZOOMS) / (ZOOMS + 1);
+	f-&gt;dpy = (f-&gt;py + f-&gt;dpy * ZOOMS) / (ZOOMS + 1);
+	f-&gt;dpz = (f-&gt;pz + f-&gt;dpz * ZOOMS) / (ZOOMS + 1);
+	f-&gt;dscale = (f-&gt;scale + f-&gt;dscale * ZOOMS) / (ZOOMS + 1);
 
 }
 
 /* checks if f is good enough */
 int ani_check(t_node *f)
 {
-	float x,y,z;
-	x=f-&gt;dpx - f-&gt;px;
-	y=f-&gt;dpy - f-&gt;py;
-	z=f-&gt;dpz - f-&gt;pz;
-	if (((fabs(f-&gt;dscale - f-&gt;scale)/f-&gt;scale)&gt;0.01) || (sqrt(x*x+y*y+z*z) &gt; 0.01))
+	float x, y, z;
+	x = f-&gt;dpx - f-&gt;px;
+	y = f-&gt;dpy - f-&gt;py;
+	z = f-&gt;dpz - f-&gt;pz;
+	if (((fabs(f-&gt;dscale - f-&gt;scale) / f-&gt;scale) &gt; 0.01) || (sqrt(x*x + y*y + z*z) &gt; 0.01))
 		return(0);
 	return(1);
 }
@@ -108,15 +108,15 @@
 	int i;
 	t_node *f;
 	s3dw_ani_mate();
-	for (i=0;i&lt;ani_n;i++) {
-		f=ani_s[i];
-		if (f-&gt;oid==-1) { /* kick out bad animations */
+	for (i = 0;i &lt; ani_n;i++) {
+		f = ani_s[i];
+		if (f-&gt;oid == -1) { /* kick out bad animations */
 			ani_del(i);
 			i--;
 		} else {
 			ani_iterate(f);
 			if (ani_check(f)) {
-				ani_finish(f,i);
+				ani_finish(f, i);
 				i--; /* a new object is here now, take care in the next iteration */
 			} else {
 				ani_doit(f);

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/box.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,8 +22,8 @@
  */
 
 #include &quot;s3dfm.h&quot;
-#include &lt;stdio.h&gt; 	 /*  printf() */
-#include &lt;math.h&gt;	 /*  sin(),cos() */
+#include &lt;stdio.h&gt;   /*  printf() */
+#include &lt;math.h&gt;  /*  sin(),cos() */
 #include &lt;string.h&gt;  /*  strlen() */
 
 void box_draw(t_node *dir)
@@ -31,12 +31,12 @@
 	box_buildblock(dir);
 	box_sidelabel(dir);
 	ani_doit(dir);
-	s3d_flags_on(dir-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(dir-&gt;objs.close,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(dir-&gt;objs.title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(dir-&gt;objs.select,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(dir-&gt;objs.titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	dir-&gt;disp=D_DIR;
+	s3d_flags_on(dir-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(dir-&gt;objs.close, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(dir-&gt;objs.title, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(dir-&gt;objs.select, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(dir-&gt;objs.titlestr, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	dir-&gt;disp = D_DIR;
 	box_draw_icons(dir);
 }
 
@@ -44,9 +44,9 @@
 void box_draw_icons(t_node *dir)
 {
 	int i;
-	printf(&quot;box_draw_icons(%s, %d subs)\n&quot;,dir-&gt;name, dir-&gt;n_sub);
-	for (i=0;i&lt;dir-&gt;n_sub;i++) {
-		if (dir-&gt;sub[i]-&gt;disp==D_NONE)	icon_draw(dir-&gt;sub[i]);
+	printf(&quot;box_draw_icons(%s, %d subs)\n&quot;, dir-&gt;name, dir-&gt;n_sub);
+	for (i = 0;i &lt; dir-&gt;n_sub;i++) {
+		if (dir-&gt;sub[i]-&gt;disp == D_NONE) icon_draw(dir-&gt;sub[i]);
 	}
 	box_order_icons(dir);
 }
@@ -56,178 +56,178 @@
 void box_sidelabel(t_node *dir)
 {
 	float len;
-	if (dir-&gt;objs.str==-1) {
-		dir-&gt;objs.str=s3d_draw_string(dir-&gt;name,&amp;len);
-		if (len&lt;2) len=2;
-		dir-&gt;objs.strlen=len;
+	if (dir-&gt;objs.str == -1) {
+		dir-&gt;objs.str = s3d_draw_string(dir-&gt;name, &amp;len);
+		if (len &lt; 2) len = 2;
+		dir-&gt;objs.strlen = len;
 	}
-	s3d_rotate(dir-&gt;objs.str,0,90,0);
-	s3d_translate(dir-&gt;objs.str,1.1,0.3,1);
-	s3d_scale(dir-&gt;objs.str,(float)1.8/(dir-&gt;objs.strlen));
-	s3d_scale(dir-&gt;objs.str,(float)1.8/(dir-&gt;objs.strlen));
-	s3d_link(dir-&gt;objs.str,dir-&gt;oid);
-	s3d_flags_on(dir-&gt;objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_rotate(dir-&gt;objs.str, 0, 90, 0);
+	s3d_translate(dir-&gt;objs.str, 1.1, 0.3, 1);
+	s3d_scale(dir-&gt;objs.str, (float)1.8 / (dir-&gt;objs.strlen));
+	s3d_scale(dir-&gt;objs.str, (float)1.8 / (dir-&gt;objs.strlen));
+	s3d_link(dir-&gt;objs.str, dir-&gt;oid);
+	s3d_flags_on(dir-&gt;objs.str, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* gives another color for the focused box */
 void box_focus_color(t_node *dir, int on)
 {
 
 	s3d_pep_material(dir-&gt;oid,
-	                 0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
-	                 0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
-	                 0.5+on*0.3,0.5+on*0.3,0.5+on*0.3);
+	                 0.5 + on*0.3, 0.5 + on*0.3, 0.5 + on*0.3,
+	                 0.5 + on*0.3, 0.5 + on*0.3, 0.5 + on*0.3,
+	                 0.5 + on*0.3, 0.5 + on*0.3, 0.5 + on*0.3);
 
 }
 /* creates a big block which will hold files and subdirs on top */
 int box_buildblock(t_node *dir)
 {
 	char fname[30];
-	char *fullname=fname;
+	char *fullname = fname;
 	float len;
-	float vertices[]= {-BHP,0,-BHP,
-	                   -BHP,0, BHP,
-	                   BHP,0, BHP,
-	                   BHP,0,-BHP,
-	                   -BHP,BHH,-BHP,
-	                   -BHP,BHH, BHP,
-	                   BHP,BHH, BHP,
-	                   BHP,BHH,-BHP,
-	                   -1,0, 0.8,
-	                   -1,BOXHEIGHT, 0.8,
-	                   1,BOXHEIGHT, 0.8,
-	                   1,0, 0.8
-	                  };
-	float xvertices[]= {
-		0.8,BHH-0.2, 0.8,
-		0.8,BHH    , 0.8,
-		BHP,BHH    , 0.8,
-		BHP,BHH-0.2, 0.8,
-		0.8,BHH-0.2, 1.0,
-		0.8,BHH    , 1.0,
-		BHP,BHH    , 1.0,
-		BHP,BHH-0.2, 1.0
+	float vertices[] = { -BHP, 0, -BHP,
+	                     -BHP, 0, BHP,
+	                     BHP, 0, BHP,
+	                     BHP, 0, -BHP,
+	                     -BHP, BHH, -BHP,
+	                     -BHP, BHH, BHP,
+	                     BHP, BHH, BHP,
+	                     BHP, BHH, -BHP,
+	                     -1, 0, 0.8,
+	                     -1, BOXHEIGHT, 0.8,
+	                     1, BOXHEIGHT, 0.8,
+	                     1, 0, 0.8
+	                   };
+	float xvertices[] = {
+		0.8, BHH - 0.2, 0.8,
+		0.8, BHH    , 0.8,
+		BHP, BHH    , 0.8,
+		BHP, BHH - 0.2, 0.8,
+		0.8, BHH - 0.2, 1.0,
+		0.8, BHH    , 1.0,
+		BHP, BHH    , 1.0,
+		BHP, BHH - 0.2, 1.0
 	};
-	float svertices[]= {
-		0.6,BHH-0.2, 0.8,
-		0.6,BHH    , 0.8,
-		0.8,BHH    , 0.8,
-		0.8,BHH-0.2, 0.8,
-		0.6,BHH-0.2, 1.0,
-		0.6,BHH    , 1.0,
-		0.8,BHH    , 1.0,
-		0.8,BHH-0.2, 1.0
+	float svertices[] = {
+		0.6, BHH - 0.2, 0.8,
+		0.6, BHH    , 0.8,
+		0.8, BHH    , 0.8,
+		0.8, BHH - 0.2, 0.8,
+		0.6, BHH - 0.2, 1.0,
+		0.6, BHH    , 1.0,
+		0.8, BHH    , 1.0,
+		0.8, BHH - 0.2, 1.0
 	};
-	float tvertices[]= {
-		-BHP,BHH-0.2, 0.8,
-		-BHP,BHH    , 0.8,
+	float tvertices[] = {
+		-BHP, BHH - 0.2, 0.8,
+		-BHP, BHH    , 0.8,
 		0.6, BHH    , 0.8,
-		0.6, BHH-0.2, 0.8,
-		-BHP,BHH-0.2, 1.0,
-		-BHP,BHH    , 1.0,
+		0.6, BHH - 0.2, 0.8,
+		-BHP, BHH - 0.2, 1.0,
+		-BHP, BHH    , 1.0,
 		0.6, BHH    , 1.0,
-		0.6, BHH-0.2, 1.0
+		0.6, BHH - 0.2, 1.0
 	};
-	uint32_t bar_poly[]={
-		4,5,6,0,
-		4,6,7,0,
-		3,7,4,0,
-		3,4,0,0
+	uint32_t bar_poly[] = {
+		4, 5, 6, 0,
+		4, 6, 7, 0,
+		3, 7, 4, 0,
+		3, 4, 0, 0
 	};
-	/*	printf(&quot;new block for %s\n&quot;,dir-&gt;name);*/
+	/* printf(&quot;new block for %s\n&quot;,dir-&gt;name);*/
 
-	dir-&gt;oid=s3d_new_object();
+	dir-&gt;oid = s3d_new_object();
 
 	/* draw block outside */
-	s3d_push_vertices(dir-&gt;oid,vertices,sizeof(vertices)/(3*sizeof(float)));
+	s3d_push_vertices(dir-&gt;oid, vertices, sizeof(vertices) / (3*sizeof(float)));
 	s3d_push_material(dir-&gt;oid,
-	                  0.5,0.5,0.5,
-	                  0.5,0.5,0.5,
-	                  0.5,0.5,0.5
+	                  0.5, 0.5, 0.5,
+	                  0.5, 0.5, 0.5,
+	                  0.5, 0.5, 0.5
 	                 );
 
 	/* top */
-	s3d_push_polygon(dir-&gt;oid,4,6,5,0);
-	s3d_push_polygon(dir-&gt;oid,4,7,6,0);
+	s3d_push_polygon(dir-&gt;oid, 4, 6, 5, 0);
+	s3d_push_polygon(dir-&gt;oid, 4, 7, 6, 0);
 	/* bottom */
-	s3d_push_polygon(dir-&gt;oid,8,11,3,0);
-	s3d_push_polygon(dir-&gt;oid,8,3,0,0);
+	s3d_push_polygon(dir-&gt;oid, 8, 11, 3, 0);
+	s3d_push_polygon(dir-&gt;oid, 8, 3, 0, 0);
 
 
 	/* left */
-	s3d_push_polygon(dir-&gt;oid,0,4,5,0);
-	s3d_push_polygon(dir-&gt;oid,0,5,1,0);
+	s3d_push_polygon(dir-&gt;oid, 0, 4, 5, 0);
+	s3d_push_polygon(dir-&gt;oid, 0, 5, 1, 0);
 
 	/* back */
-	s3d_push_polygon(dir-&gt;oid,3,7,4,0);
-	s3d_push_polygon(dir-&gt;oid,3,4,0,0);
+	s3d_push_polygon(dir-&gt;oid, 3, 7, 4, 0);
+	s3d_push_polygon(dir-&gt;oid, 3, 4, 0, 0);
 
 	/* right */
-	s3d_push_polygon(dir-&gt;oid,2,6,7,0);
-	s3d_push_polygon(dir-&gt;oid,2,7,3,0);
+	s3d_push_polygon(dir-&gt;oid, 2, 6, 7, 0);
+	s3d_push_polygon(dir-&gt;oid, 2, 7, 3, 0);
 
 	/* front */
-	s3d_push_polygon(dir-&gt;oid,8,9,10,0);
-	s3d_push_polygon(dir-&gt;oid,8,10,11,0);
+	s3d_push_polygon(dir-&gt;oid, 8, 9, 10, 0);
+	s3d_push_polygon(dir-&gt;oid, 8, 10, 11, 0);
 	/* left inner side */
-	s3d_push_polygon(dir-&gt;oid,1,5,9,0);
-	s3d_push_polygon(dir-&gt;oid,1,9,8,0);
+	s3d_push_polygon(dir-&gt;oid, 1, 5, 9, 0);
+	s3d_push_polygon(dir-&gt;oid, 1, 9, 8, 0);
 
 	/* right inner side */
-	s3d_push_polygon(dir-&gt;oid,2,11,10,0);
-	s3d_push_polygon(dir-&gt;oid,2,10,6,0);
+	s3d_push_polygon(dir-&gt;oid, 2, 11, 10, 0);
+	s3d_push_polygon(dir-&gt;oid, 2, 10, 6, 0);
 
 	/* top inner side */
-	s3d_push_polygon(dir-&gt;oid,9,5,6,0);
-	s3d_push_polygon(dir-&gt;oid,9,6,10,0);
+	s3d_push_polygon(dir-&gt;oid, 9, 5, 6, 0);
+	s3d_push_polygon(dir-&gt;oid, 9, 6, 10, 0);
 
 
 
 
 	/* draw the select, close buttons ... */
-	dir-&gt;objs.close=s3d_new_object();
+	dir-&gt;objs.close = s3d_new_object();
 	s3d_push_material(dir-&gt;objs.close,
-	                  0.5,0.3,0.3,
-	                  0.5,0.3,0.3,
-	                  0.5,0.3,0.3
+	                  0.5, 0.3, 0.3,
+	                  0.5, 0.3, 0.3,
+	                  0.5, 0.3, 0.3
 	                 );
-	s3d_push_vertices(dir-&gt;objs.close,xvertices,sizeof(xvertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir-&gt;objs.close,bar_poly,sizeof(bar_poly)/(sizeof(uint32_t)*4));
-	s3d_link(dir-&gt;objs.close,dir-&gt;oid);
+	s3d_push_vertices(dir-&gt;objs.close, xvertices, sizeof(xvertices) / (3*sizeof(float)));
+	s3d_push_polygons(dir-&gt;objs.close, bar_poly, sizeof(bar_poly) / (sizeof(uint32_t)*4));
+	s3d_link(dir-&gt;objs.close, dir-&gt;oid);
 
-	dir-&gt;objs.select=s3d_new_object();
+	dir-&gt;objs.select = s3d_new_object();
 	s3d_push_material(dir-&gt;objs.select,
-	                  0.1,0.1,0.3,
-	                  0.1,0.1,0.3,
-	                  0.1,0.1,0.3
+	                  0.1, 0.1, 0.3,
+	                  0.1, 0.1, 0.3,
+	                  0.1, 0.1, 0.3
 	                 );
-	s3d_push_vertices(dir-&gt;objs.select,svertices,sizeof(svertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir-&gt;objs.select,bar_poly,sizeof(bar_poly)/(sizeof(uint32_t)*4));
-	s3d_link(dir-&gt;objs.select,dir-&gt;oid);
+	s3d_push_vertices(dir-&gt;objs.select, svertices, sizeof(svertices) / (3*sizeof(float)));
+	s3d_push_polygons(dir-&gt;objs.select, bar_poly, sizeof(bar_poly) / (sizeof(uint32_t)*4));
+	s3d_link(dir-&gt;objs.select, dir-&gt;oid);
 
 	/* draw the title string */
 
-	dir-&gt;objs.title=s3d_new_object();
+	dir-&gt;objs.title = s3d_new_object();
 	s3d_push_material(dir-&gt;objs.title,
-	                  0.3,0.3,0.3,
-	                  0.3,0.3,0.3,
-	                  0.3,0.3,0.3
+	                  0.3, 0.3, 0.3,
+	                  0.3, 0.3, 0.3,
+	                  0.3, 0.3, 0.3
 	                 );
-	s3d_push_vertices(dir-&gt;objs.title,tvertices,sizeof(tvertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir-&gt;objs.title,bar_poly,sizeof(bar_poly)/(sizeof(uint32_t)*4));
-	s3d_link(dir-&gt;objs.title,dir-&gt;oid);
-	dir-&gt;objs.titlestr=s3d_draw_string(dots_at_start(fullname,30,dir),&amp;len);
-	if (len&gt;(1.6*5.0))		s3d_scale(dir-&gt;objs.titlestr,1.6/len);
-	else					s3d_scale(dir-&gt;objs.titlestr,0.2);
-	s3d_translate(dir-&gt;objs.titlestr,-1.0,1.05,1.01);
-	s3d_link(dir-&gt;objs.titlestr,dir-&gt;oid);
-	dir-&gt;disp=D_DIR;
-	/*	printf(&quot;FULLNAME is [%s]\n&quot;,fullname);*/
+	s3d_push_vertices(dir-&gt;objs.title, tvertices, sizeof(tvertices) / (3*sizeof(float)));
+	s3d_push_polygons(dir-&gt;objs.title, bar_poly, sizeof(bar_poly) / (sizeof(uint32_t)*4));
+	s3d_link(dir-&gt;objs.title, dir-&gt;oid);
+	dir-&gt;objs.titlestr = s3d_draw_string(dots_at_start(fullname, 30, dir), &amp;len);
+	if (len &gt; (1.6*5.0))  s3d_scale(dir-&gt;objs.titlestr, 1.6 / len);
+	else     s3d_scale(dir-&gt;objs.titlestr, 0.2);
+	s3d_translate(dir-&gt;objs.titlestr, -1.0, 1.05, 1.01);
+	s3d_link(dir-&gt;objs.titlestr, dir-&gt;oid);
+	dir-&gt;disp = D_DIR;
+	/* printf(&quot;FULLNAME is [%s]\n&quot;,fullname);*/
 	return(0);
 }
 /* display a directoy on the top of another */
 int box_expand(t_node *dir)
 {
-	printf(&quot;box_expand( %s )\n&quot;,dir-&gt;name);
+	printf(&quot;box_expand( %s )\n&quot;, dir-&gt;name);
 	switch (dir-&gt;disp) {
 	case D_DIR:
 		return(0); /* already done */
@@ -239,16 +239,16 @@
 	default:
 		return(-1); /* panic */
 	}
-	dir-&gt;dpx=0.0;
-	dir-&gt;dpy=BOXHEIGHT;
-	dir-&gt;dpz=0.0;
-	dir-&gt;dscale=0.01;
+	dir-&gt;dpx = 0.0;
+	dir-&gt;dpy = BOXHEIGHT;
+	dir-&gt;dpz = 0.0;
+	dir-&gt;dscale = 0.01;
 	box_draw(dir);
 
 	/* initialize position on the parent */
-	if (dir-&gt;parent!=NULL) {
+	if (dir-&gt;parent != NULL) {
 		dir-&gt;parent-&gt;dirs_opened++;
-		s3d_link(dir-&gt;oid,dir-&gt;parent-&gt;oid);
+		s3d_link(dir-&gt;oid, dir-&gt;parent-&gt;oid);
 		box_order_subdirs(dir-&gt;parent);
 	}
 	return(0);
@@ -256,38 +256,38 @@
 /* remove s3d-objects of a directory node */
 int box_undisplay(t_node *dir)
 {
-	printf(&quot;box_undisplay( %s )\n&quot;,dir-&gt;name);
-	if (dir-&gt;objs.close!=-1)		{
+	printf(&quot;box_undisplay( %s )\n&quot;, dir-&gt;name);
+	if (dir-&gt;objs.close != -1)  {
 		s3d_del_object(dir-&gt;objs.close);
-		dir-&gt;objs.close=-1;
+		dir-&gt;objs.close = -1;
 	}
-	if (dir-&gt;objs.select!=-1)		{
+	if (dir-&gt;objs.select != -1)  {
 		s3d_del_object(dir-&gt;objs.select);
-		dir-&gt;objs.select=-1;
+		dir-&gt;objs.select = -1;
 	}
-	if (dir-&gt;objs.title!=-1)		{
+	if (dir-&gt;objs.title != -1)  {
 		s3d_del_object(dir-&gt;objs.title);
-		dir-&gt;objs.title=-1;
+		dir-&gt;objs.title = -1;
 	}
-	if (dir-&gt;objs.titlestr!=-1)		{
+	if (dir-&gt;objs.titlestr != -1)  {
 		s3d_del_object(dir-&gt;objs.titlestr);
-		dir-&gt;objs.titlestr=-1;
+		dir-&gt;objs.titlestr = -1;
 	}
-	if (dir-&gt;oid!=-1)				{
+	if (dir-&gt;oid != -1)    {
 		s3d_del_object(dir-&gt;oid);
 	}
 	/* keep this. icons also needs the *same* string */
-	/*	if (dir-&gt;objs.str!=-1)			{ 	s3d_del_object(dir-&gt;objs.str); dir-&gt;objs.str=-1;	}*/
-	dir-&gt;disp=D_NONE;
+	/* if (dir-&gt;objs.str!=-1)   {  s3d_del_object(dir-&gt;objs.str); dir-&gt;objs.str=-1; }*/
+	dir-&gt;disp = D_NONE;
 	return(0);
 }
 /* the opposite effect of box_expand, e.g. transforming the box back to an icon */
 int box_unexpand(t_node *dir)
 {
-	printf(&quot;box_unexpand( %s )\n&quot;,dir-&gt;name);
-	if (dir-&gt;parent==NULL) /* we can't do this on root.... */
+	printf(&quot;box_unexpand( %s )\n&quot;, dir-&gt;name);
+	if (dir-&gt;parent == NULL) /* we can't do this on root.... */
 		return(-1);
-	dir-&gt;detached=0;
+	dir-&gt;detached = 0;
 	box_undisplay(dir);
 	icon_draw(dir);
 	dir-&gt;parent-&gt;dirs_opened--;
@@ -298,36 +298,36 @@
 
 /* undisplay a directory, thus recursively removing the kids.*/
 /* if force is 1, even the directory is removed even if it still have selected kids */
-int box_close(t_node *dir,int force)
+int box_close(t_node *dir, int force)
 {
 	int i;
 	int ret;
-	printf(&quot;box_close( %s )\n&quot;,dir-&gt;name);
-	if (&amp;root==dir) {
+	printf(&quot;box_close( %s )\n&quot;, dir-&gt;name);
+	if (&amp;root == dir) {
 		printf(&quot;won't close down root box ... \n&quot;);
 		return(-1);
 	}
-	if (dir-&gt;detached &amp;&amp; !force)	return(1);
-	if (dir-&gt;disp!=D_DIR) { /* that should not be happening ... */
-		printf(&quot;[A]lready undisplayed %s, nothing to do ...\n&quot;,dir-&gt;name);
+	if (dir-&gt;detached &amp;&amp; !force) return(1);
+	if (dir-&gt;disp != D_DIR) { /* that should not be happening ... */
+		printf(&quot;[A]lready undisplayed %s, nothing to do ...\n&quot;, dir-&gt;name);
 		return(-1);
 	}
 	/* closing kids. ret will be != 0 if any of the kids did not close correctly */
-	ret=0;
-	for (i=0;i&lt;dir-&gt;n_sub;i++)
-		if (dir-&gt;sub[i]-&gt;disp==D_DIR)
-			ret|=box_close(dir-&gt;sub[i],force);
-	if (ret &amp;&amp; !force) {	/* if anything got wrong, return here ... */
+	ret = 0;
+	for (i = 0;i &lt; dir-&gt;n_sub;i++)
+		if (dir-&gt;sub[i]-&gt;disp == D_DIR)
+			ret |= box_close(dir-&gt;sub[i], force);
+	if (ret &amp;&amp; !force) { /* if anything got wrong, return here ... */
 		box_order_subdirs(dir);
 		return(ret);
 	} else {
 		/* also remove the icons */
-		if (focus==dir)			focus_set(dir-&gt;parent);
-		for (i=0;i&lt;dir-&gt;n_sub;i++)
-			if (dir-&gt;sub[i]-&gt;disp==D_ICON) {
+		if (focus == dir)   focus_set(dir-&gt;parent);
+		for (i = 0;i &lt; dir-&gt;n_sub;i++)
+			if (dir-&gt;sub[i]-&gt;disp == D_ICON) {
 				icon_undisplay(dir-&gt;sub[i]);
-				dir-&gt;detached=0;
-				if (focus==dir-&gt;sub[i])
+				dir-&gt;detached = 0;
+				if (focus == dir-&gt;sub[i])
 					focus_set(dir-&gt;parent);
 			}
 		box_unexpand(dir);
@@ -338,46 +338,46 @@
 / * only display dir and its kids, but nothing below. * /
 int box_collapse_grandkids(t_node *dir)
 {
-	int i,j;
-	t_node *kid;
-	for (i=0;i&lt;dir-&gt;n_sub;i++)
-		if (dir-&gt;sub[i].disp==D_DIR)
-		{
-			kid=&amp;dir-&gt;sub[i];
-			for (j=0;j&lt;kid-&gt;n_item;j++)
-			if (kid-&gt;list[j].disp==D_DIR)
-				box_collapse(&amp;kid-&gt;list[j],0);
-		}
-	return(0);
+ int i,j;
+ t_node *kid;
+ for (i=0;i&lt;dir-&gt;n_sub;i++)
+  if (dir-&gt;sub[i].disp==D_DIR)
+  {
+   kid=&amp;dir-&gt;sub[i];
+   for (j=0;j&lt;kid-&gt;n_item;j++)
+   if (kid-&gt;list[j].disp==D_DIR)
+    box_collapse(&amp;kid-&gt;list[j],0);
+  }
+ return(0);
 }*/
 /* orders the directory objects on top of its parent objects
  * to be called after adding or removing things ...*/
 void box_order_subdirs(t_node *dir)
 {
-	int i,j;
-	printf(&quot;box_order_subdirs( %s ): %d dirs opened\n&quot;,dir-&gt;name,dir-&gt;dirs_opened);
+	int i, j;
+	printf(&quot;box_order_subdirs( %s ): %d dirs opened\n&quot;, dir-&gt;name, dir-&gt;dirs_opened);
 	switch (dir-&gt;dirs_opened) {
 	case 0:
 		return;
 	case 1:
-		for (i=0;i&lt;dir-&gt;n_sub;i++) {
-			if (dir-&gt;sub[i]-&gt;disp==D_DIR) {
-				dir-&gt;sub[i]-&gt;px=0.0;
-				dir-&gt;sub[i]-&gt;py=BOXHEIGHT+dir-&gt;sub[i]-&gt;detached*DETHEIGHT;
-				dir-&gt;sub[i]-&gt;pz=0.0;
-				dir-&gt;sub[i]-&gt;scale=0.2;
+		for (i = 0;i &lt; dir-&gt;n_sub;i++) {
+			if (dir-&gt;sub[i]-&gt;disp == D_DIR) {
+				dir-&gt;sub[i]-&gt;px = 0.0;
+				dir-&gt;sub[i]-&gt;py = BOXHEIGHT + dir-&gt;sub[i]-&gt;detached * DETHEIGHT;
+				dir-&gt;sub[i]-&gt;pz = 0.0;
+				dir-&gt;sub[i]-&gt;scale = 0.2;
 				ani_add(dir-&gt;sub[i]);
 			}
 		}
 		break;
 	default:
-		j=0;
-		for (i=0;i&lt;dir-&gt;n_sub;i++) {
-			if (dir-&gt;sub[i]-&gt;disp==D_DIR) {
-				dir-&gt;sub[i]-&gt;px=0.8 * sin(((float)j*2*M_PI)/((float)dir-&gt;dirs_opened));
-				dir-&gt;sub[i]-&gt;py=BOXHEIGHT+dir-&gt;sub[i]-&gt;detached*DETHEIGHT;
-				dir-&gt;sub[i]-&gt;pz=0.8 * cos(((float)j*2*M_PI)/((float)dir-&gt;dirs_opened));
-				dir-&gt;sub[i]-&gt;scale=0.2;
+		j = 0;
+		for (i = 0;i &lt; dir-&gt;n_sub;i++) {
+			if (dir-&gt;sub[i]-&gt;disp == D_DIR) {
+				dir-&gt;sub[i]-&gt;px = 0.8 * sin(((float)j * 2 * M_PI) / ((float)dir-&gt;dirs_opened));
+				dir-&gt;sub[i]-&gt;py = BOXHEIGHT + dir-&gt;sub[i]-&gt;detached * DETHEIGHT;
+				dir-&gt;sub[i]-&gt;pz = 0.8 * cos(((float)j * 2 * M_PI) / ((float)dir-&gt;dirs_opened));
+				dir-&gt;sub[i]-&gt;scale = 0.2;
 				ani_add(dir-&gt;sub[i]);
 				j++;
 			}
@@ -387,18 +387,18 @@
 /* order the icons properly */
 void box_order_icons(t_node *dir)
 {
-	int dps,i;
-	dps=ceil(sqrt(dir-&gt;n_sub)); /* directories per line */
-	for (i=0;i&lt;dir-&gt;n_sub;i++) {
+	int dps, i;
+	dps = ceil(sqrt(dir-&gt;n_sub)); /* directories per line */
+	for (i = 0;i &lt; dir-&gt;n_sub;i++) {
 		if (dir-&gt;sub[i]-&gt;disp == D_ICON) {
-			dir-&gt;sub[i]-&gt;px = -1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
-			dir-&gt;sub[i]-&gt;py = 0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
-			dir-&gt;sub[i]-&gt;pz=dir-&gt;sub[i]-&gt;detached*0.2+1.0;
-			dir-&gt;sub[i]-&gt;scale = (float)1.0/((float)dps);
-			s3d_link(dir-&gt;sub[i]-&gt;oid,dir-&gt;oid);	 /* if it's already displayed, make sure it linked properly ... */
-			ani_finish(dir-&gt;sub[i], -1);			 /* copy to the current animation state */
-			s3d_flags_on(dir-&gt;sub[i]-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_on(dir-&gt;sub[i]-&gt;objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			dir-&gt;sub[i]-&gt;px = -1 + 2 * ((float)((int)i % dps) + 0.5) / ((float)dps);
+			dir-&gt;sub[i]-&gt;py = 0.5 + ((float)((int)i / dps) + 0.5) / ((float)dps) - 0.5;
+			dir-&gt;sub[i]-&gt;pz = dir-&gt;sub[i]-&gt;detached * 0.2 + 1.0;
+			dir-&gt;sub[i]-&gt;scale = (float)1.0 / ((float)dps);
+			s3d_link(dir-&gt;sub[i]-&gt;oid, dir-&gt;oid); /* if it's already displayed, make sure it linked properly ... */
+			ani_finish(dir-&gt;sub[i], -1);    /* copy to the current animation state */
+			s3d_flags_on(dir-&gt;sub[i]-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			s3d_flags_on(dir-&gt;sub[i]-&gt;objs.str, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 		}
 	}
 }

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/dialog.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,7 +24,7 @@
 
 #include &quot;s3dfm.h&quot;
 #include &lt;s3d_keysym.h&gt;
-#include &lt;stdio.h&gt; 	/* NULL, printf() */
+#include &lt;stdio.h&gt;  /* NULL, printf() */
 #include &lt;string.h&gt; /* strlen() */
 #include &lt;stdlib.h&gt; /* realloc(),malloc() */
 #include &lt;errno.h&gt;  /* errno */
@@ -32,13 +32,13 @@
 #include &lt;sys/stat.h&gt; /* mkdir() */
 #include &lt;sys/types.h&gt; /* mkdir() */
 
-static s3dw_input	 *input;
+static s3dw_input  *input;
 static filelist *fp;
 static char destdir[M_DIR];
-static t_node *destnode=NULL;
+static t_node *destnode = NULL;
 
 extern int typeinput;
-int fs_lock=0;
+int fs_lock = 0;
 pthread_t filethread;
 
 
@@ -51,20 +51,20 @@
 {
 	int i;
 	char *s;
-	for (i=0;i&lt;dir-&gt;n_sub;i++) {
-		if (dir-&gt;sub[i]-&gt;sub!=NULL)	get_selected(fp,dir-&gt;sub[i]); /* scan subdir */
+	for (i = 0;i &lt; dir-&gt;n_sub;i++) {
+		if (dir-&gt;sub[i]-&gt;sub != NULL) get_selected(fp, dir-&gt;sub[i]); /* scan subdir */
 		if (dir-&gt;sub[i]-&gt;detached) {
 			fp-&gt;n++;
-			fp-&gt;p=realloc(fp-&gt;p,sizeof(t_file) * fp-&gt;n);
-			s=malloc(M_DIR);
-			node_path(dir-&gt;sub[i],s);
-			fp-&gt;p[fp-&gt;n - 1].name=s;
-			if ((fs_lock==TYPE_COPY)||(fs_lock==TYPE_MOVE))
-				fp-&gt;p[fp-&gt;n - 1].anode=fly_create_anode(dir-&gt;sub[i]);
+			fp-&gt;p = realloc(fp-&gt;p, sizeof(t_file) * fp-&gt;n);
+			s = malloc(M_DIR);
+			node_path(dir-&gt;sub[i], s);
+			fp-&gt;p[fp-&gt;n - 1].name = s;
+			if ((fs_lock == TYPE_COPY) || (fs_lock == TYPE_MOVE))
+				fp-&gt;p[fp-&gt;n - 1].anode = fly_create_anode(dir-&gt;sub[i]);
 			else
-				fp-&gt;p[fp-&gt;n - 1].anode=NULL;
-			fp-&gt;p[fp-&gt;n - 1].size=0; /*TODO: later */
-			fp-&gt;p[fp-&gt;n - 1].state=STATE_NONE;
+				fp-&gt;p[fp-&gt;n - 1].anode = NULL;
+			fp-&gt;p[fp-&gt;n - 1].size = 0; /*TODO: later */
+			fp-&gt;p[fp-&gt;n - 1].state = STATE_NONE;
 
 		}
 	}
@@ -74,17 +74,17 @@
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;
-	infwin=s3dw_surface_new(&quot;Help Window&quot;,12,12);
-	s3dw_label_new(infwin,&quot;F1 - This Help Window&quot;,1,2);
-	s3dw_label_new(infwin,&quot;F5 - Copy&quot;,1,3);
-	s3dw_label_new(infwin,&quot;F6 - Move&quot;,1,4);
-	s3dw_label_new(infwin,&quot;F7 - Create Directory&quot;,1,5);
-	s3dw_label_new(infwin,&quot;F8 - Unlink&quot;,1,5);
-	s3dw_label_new(infwin,&quot;R - Refresh&quot;,1,6);
-	s3dw_label_new(infwin,&quot;I - Info&quot;,1,7);
+	infwin = s3dw_surface_new(&quot;Help Window&quot;, 12, 12);
+	s3dw_label_new(infwin, &quot;F1 - This Help Window&quot;, 1, 2);
+	s3dw_label_new(infwin, &quot;F5 - Copy&quot;, 1, 3);
+	s3dw_label_new(infwin, &quot;F6 - Move&quot;, 1, 4);
+	s3dw_label_new(infwin, &quot;F7 - Create Directory&quot;, 1, 5);
+	s3dw_label_new(infwin, &quot;F8 - Unlink&quot;, 1, 5);
+	s3dw_label_new(infwin, &quot;R - Refresh&quot;, 1, 6);
+	s3dw_label_new(infwin, &quot;I - Info&quot;, 1, 7);
 
-	button=s3dw_button_new(infwin,&quot;OK&quot;,4,10);
-	button-&gt;onclick=close_win;
+	button = s3dw_button_new(infwin, &quot;OK&quot;, 4, 10);
+	button-&gt;onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 
 }
@@ -92,25 +92,25 @@
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;
-	infwin=s3dw_surface_new(&quot;Error&quot;,20,8);
-	s3dw_label_new(infwin,&quot;Sorry, another FS Action is in Progress&quot;,1,2);
-	button=s3dw_button_new(infwin,&quot;OK&quot;,5,5);
-	button-&gt;onclick=close_win;
+	infwin = s3dw_surface_new(&quot;Error&quot;, 20, 8);
+	s3dw_label_new(infwin, &quot;Sorry, another FS Action is in Progress&quot;, 1, 2);
+	button = s3dw_button_new(infwin, &quot;OK&quot;, 5, 5);
+	button-&gt;onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 }
 void window_fs_nothing()
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;
-	infwin=s3dw_surface_new(&quot;Error&quot;,12,8);
-	s3dw_label_new(infwin,&quot;Nothing selected :(&quot;,1,2);
-	button=s3dw_button_new(infwin,&quot;OK&quot;,5,5);
-	button-&gt;onclick=close_win;
+	infwin = s3dw_surface_new(&quot;Error&quot;, 12, 8);
+	s3dw_label_new(infwin, &quot;Nothing selected :(&quot;, 1, 2);
+	button = s3dw_button_new(infwin, &quot;OK&quot;, 5, 5);
+	button-&gt;onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 }
 void window_fs_confirm_error(s3dw_widget *button)
 {
-	fs_err.state=ESTATE_NONE;
+	fs_err.state = ESTATE_NONE;
 	s3dw_delete(button-&gt;parent); /* parent =surface. this means close containing window */
 
 }
@@ -120,24 +120,24 @@
 	s3dw_button  *button;
 	char string[M_DIR];
 	float l;
-	snprintf(string,M_DIR,&quot;%s: %s&quot;,errmsg,strerror(errno));
-	l=strlen(string)*0.7;
-	infwin=s3dw_surface_new(&quot;Error&quot;,l,8);
-	s3dw_label_new(infwin,string,1,2);
-	button=s3dw_button_new(infwin,&quot;OK&quot;,l/2-1,5);
-	button-&gt;onclick=close_win;
+	snprintf(string, M_DIR, &quot;%s: %s&quot;, errmsg, strerror(errno));
+	l = strlen(string) * 0.7;
+	infwin = s3dw_surface_new(&quot;Error&quot;, l, 8);
+	s3dw_label_new(infwin, string, 1, 2);
+	button = s3dw_button_new(infwin, &quot;OK&quot;, l / 2 - 1, 5);
+	button-&gt;onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 }
 
 void window_fs_abort(s3dw_widget *button)
 {
 	/* delete a filelist, if there was any */
-	if (fp!=NULL) {
+	if (fp != NULL) {
 		fl_del(fp);
-		fp=NULL;
+		fp = NULL;
 	}
-	typeinput=0;
-	fs_lock=TYPE_NONE;
+	typeinput = 0;
+	fs_lock = TYPE_NONE;
 	s3dw_delete(button-&gt;parent); /* parent =surface. this means close containing window */
 }
 void *thread_start(void *ptr)
@@ -145,8 +145,8 @@
 	switch (fs_lock) {
 	case TYPE_COPY:
 		printf(&quot;starting a copy process in the thread ... \n&quot;);
-		destnode=node_getbypath(destdir);
-		fs_fl_copy(fp,destdir);
+		destnode = node_getbypath(destdir);
+		fs_fl_copy(fp, destdir);
 		printf(&quot;done\n&quot;);
 		break;
 	case TYPE_UNLINK:
@@ -155,60 +155,60 @@
 		printf(&quot;done\n&quot;);
 		break;
 	}
-	fs_lock=TYPE_FINISHED;
+	fs_lock = TYPE_FINISHED;
 	return(NULL);
 
 }
 /* start the thread, as filesystem stuff is locked ... */
 void window_fs(s3dw_widget *button)
 {
-	pthread_create( &amp;filethread, NULL, thread_start, NULL);
+	pthread_create(&amp;filethread, NULL, thread_start, NULL);
 	s3dw_delete(button-&gt;parent); /* parent =surface. this means close containing window */
 }
 void window_copy(char *path)
 {
 	s3dw_surface *infwin;
-	s3dw_button  *okbutton,*abortbutton;
+	s3dw_button  *okbutton, *abortbutton;
 	float l;
 
-	int i,m;
+	int i, m;
 
-	if (fs_lock) 	{
+	if (fs_lock)  {
 		window_fs_another();
 		return;
 	}
-	fs_lock=TYPE_COPY;
-	fp=malloc(sizeof(filelist));
-	fp-&gt;n=0;
-	fp-&gt;p=NULL;
-	get_selected(fp,&amp;root);
-	printf(&quot;selected %d nodes\n&quot;,fp-&gt;n);
-	if (fp-&gt;n == 0)	{
+	fs_lock = TYPE_COPY;
+	fp = malloc(sizeof(filelist));
+	fp-&gt;n = 0;
+	fp-&gt;p = NULL;
+	get_selected(fp, &amp;root);
+	printf(&quot;selected %d nodes\n&quot;, fp-&gt;n);
+	if (fp-&gt;n == 0) {
 		window_fs_nothing();
 		free(fp);
-		fp=NULL;
+		fp = NULL;
 		return;
 	}
 	/* get the longest item on the list */
-	m=10;
-	for (i=0;i&lt;fp-&gt;n;i++) {
-		if (strlen(fp-&gt;p[i].name)&gt;m) m=strlen(fp-&gt;p[i].name);
-		printf(&quot;%d: %s\n&quot;,i,fp-&gt;p[i].name);
+	m = 10;
+	for (i = 0;i &lt; fp-&gt;n;i++) {
+		if (strlen(fp-&gt;p[i].name) &gt; m) m = strlen(fp-&gt;p[i].name);
+		printf(&quot;%d: %s\n&quot;, i, fp-&gt;p[i].name);
 	}
 
-	l=(m+3)*0.7;
-	infwin=s3dw_surface_new(&quot;Copy Window&quot;,l,fp-&gt;n+8);
-	s3dw_label_new(infwin,&quot;Copy: &quot;,1,1);
-	for (i=0;i&lt;fp-&gt;n;i++)
-		s3dw_label_new(infwin,fp-&gt;p[i].name,3,2+i);
-	s3dw_label_new(infwin,&quot;to:&quot;,1,fp-&gt;n+3);
-	node_path(node_getdir(focus),destdir);
-	s3dw_label_new(infwin,destdir,3,fp-&gt;n+4);
+	l = (m + 3) * 0.7;
+	infwin = s3dw_surface_new(&quot;Copy Window&quot;, l, fp-&gt;n + 8);
+	s3dw_label_new(infwin, &quot;Copy: &quot;, 1, 1);
+	for (i = 0;i &lt; fp-&gt;n;i++)
+		s3dw_label_new(infwin, fp-&gt;p[i].name, 3, 2 + i);
+	s3dw_label_new(infwin, &quot;to:&quot;, 1, fp-&gt;n + 3);
+	node_path(node_getdir(focus), destdir);
+	s3dw_label_new(infwin, destdir, 3, fp-&gt;n + 4);
 
-	okbutton=s3dw_button_new(infwin,&quot;OK&quot;,l/2-3,fp-&gt;n+5);
-	okbutton-&gt;onclick=window_fs;
-	abortbutton=s3dw_button_new(infwin,&quot;abort&quot;,l/2,fp-&gt;n+5);
-	abortbutton-&gt;onclick=window_fs_abort;
+	okbutton = s3dw_button_new(infwin, &quot;OK&quot;, l / 2 - 3, fp-&gt;n + 5);
+	okbutton-&gt;onclick = window_fs;
+	abortbutton = s3dw_button_new(infwin, &quot;abort&quot;, l / 2, fp-&gt;n + 5);
+	abortbutton-&gt;onclick = window_fs_abort;
 
 	s3dw_show(S3DWIDGET(infwin));
 
@@ -218,42 +218,42 @@
 void window_unlink()
 {
 	s3dw_surface *infwin;
-	s3dw_button  *okbutton,*abortbutton;
+	s3dw_button  *okbutton, *abortbutton;
 	float l;
 
-	int i,m;
+	int i, m;
 
-	if (fs_lock) 	{
+	if (fs_lock)  {
 		window_fs_another();
 		return;
 	}
-	fs_lock=TYPE_UNLINK;
-	fp=malloc(sizeof(filelist));
-	fp-&gt;n=0;
-	fp-&gt;p=NULL;
-	get_selected(fp,&amp;root);
-	printf(&quot;selected %d nodes\n&quot;,fp-&gt;n);
-	if (fp-&gt;n == 0)	{
+	fs_lock = TYPE_UNLINK;
+	fp = malloc(sizeof(filelist));
+	fp-&gt;n = 0;
+	fp-&gt;p = NULL;
+	get_selected(fp, &amp;root);
+	printf(&quot;selected %d nodes\n&quot;, fp-&gt;n);
+	if (fp-&gt;n == 0) {
 		window_fs_nothing();
 		free(fp);
-		fp=NULL;
+		fp = NULL;
 		return;
 	}
 	/* get the longest item on the list */
-	m=10;
-	for (i=0;i&lt;fp-&gt;n;i++)
-		if (strlen(fp-&gt;p[i].name)&gt;m) m=strlen(fp-&gt;p[i].name);
+	m = 10;
+	for (i = 0;i &lt; fp-&gt;n;i++)
+		if (strlen(fp-&gt;p[i].name) &gt; m) m = strlen(fp-&gt;p[i].name);
 
-	l=(m+3)*0.7;
-	infwin=s3dw_surface_new(&quot;Unlink Window&quot;,l,fp-&gt;n+8);
-	s3dw_label_new(infwin,&quot;Unlink: &quot;,1,1);
-	for (i=0;i&lt;fp-&gt;n;i++)
-		s3dw_label_new(infwin,fp-&gt;p[i].name,3,2+i);
+	l = (m + 3) * 0.7;
+	infwin = s3dw_surface_new(&quot;Unlink Window&quot;, l, fp-&gt;n + 8);
+	s3dw_label_new(infwin, &quot;Unlink: &quot;, 1, 1);
+	for (i = 0;i &lt; fp-&gt;n;i++)
+		s3dw_label_new(infwin, fp-&gt;p[i].name, 3, 2 + i);
 
-	okbutton=s3dw_button_new(infwin,&quot;OK&quot;,l/2-3,fp-&gt;n+3);
-	okbutton-&gt;onclick=window_fs;
-	abortbutton=s3dw_button_new(infwin,&quot;Abort&quot;,l/2,fp-&gt;n+3);
-	abortbutton-&gt;onclick=window_fs_abort;
+	okbutton = s3dw_button_new(infwin, &quot;OK&quot;, l / 2 - 3, fp-&gt;n + 3);
+	okbutton-&gt;onclick = window_fs;
+	abortbutton = s3dw_button_new(infwin, &quot;Abort&quot;, l / 2, fp-&gt;n + 3);
+	abortbutton-&gt;onclick = window_fs_abort;
 
 	s3dw_show(S3DWIDGET(infwin));
 
@@ -262,48 +262,48 @@
 {
 	char *dir;
 	t_node *item;
-	dir=s3dw_input_gettext(input);
-	printf(&quot;creating Directory ...%s\n&quot;,dir);
-	if (-1==mkdir(dir,0777)) /* umask ?! */
+	dir = s3dw_input_gettext(input);
+	printf(&quot;creating Directory ...%s\n&quot;, dir);
+	if (-1 == mkdir(dir, 0777)) /* umask ?! */
 		window_fs_errno(&quot;could not create directory&quot;);
 	else {
 		/* success, now refresh it */
-		item=node_getbypath(dir);
-		if (item==NULL) {
+		item = node_getbypath(dir);
+		if (item == NULL) {
 			printf(&quot;cannot refresh\n&quot;);
 		} else {
-			printf(&quot;refreshing %s\n&quot;,item-&gt;name);
-			/*			parse_again(item);*/
+			printf(&quot;refreshing %s\n&quot;, item-&gt;name);
+			/*   parse_again(item);*/
 		}
 	}
-	fs_lock=0;
+	fs_lock = 0;
 	window_fs_abort(button); /* finish */
 
 }
 void window_mkdir(char *path)
 {
 	s3dw_surface *infwin;
-	s3dw_button  *okbutton,*abortbutton;
+	s3dw_button  *okbutton, *abortbutton;
 	char string1[M_DIR];
 	float l;
 	if (fs_lock) {
 		window_fs_another();
 		return;
 	}
-	snprintf(string1,M_DIR,&quot;Create Directory in %s&quot;,path);
-	l=strlen(string1)*0.7;
-	infwin=s3dw_surface_new(&quot;Create Directory&quot;,l,8);
-	s3dw_label_new(infwin,string1,1,2);
-	input=s3dw_input_new(infwin,10,1,3);
+	snprintf(string1, M_DIR, &quot;Create Directory in %s&quot;, path);
+	l = strlen(string1) * 0.7;
+	infwin = s3dw_surface_new(&quot;Create Directory&quot;, l, 8);
+	s3dw_label_new(infwin, string1, 1, 2);
+	input = s3dw_input_new(infwin, 10, 1, 3);
 	s3dw_input_change_text(input, path);
 	s3dw_focus(S3DWIDGET(input));
 	s3dw_focus(S3DWIDGET(infwin));
-	typeinput=1;
-	fs_lock=1;
-	okbutton=s3dw_button_new(infwin,&quot;OK&quot;,l/2-3,5);
-	okbutton-&gt;onclick=window_fs_mkdir;
-	abortbutton=s3dw_button_new(infwin,&quot;abort&quot;,l/2,5);
-	abortbutton-&gt;onclick=window_fs_abort;
+	typeinput = 1;
+	fs_lock = 1;
+	okbutton = s3dw_button_new(infwin, &quot;OK&quot;, l / 2 - 3, 5);
+	okbutton-&gt;onclick = window_fs_mkdir;
+	abortbutton = s3dw_button_new(infwin, &quot;abort&quot;, l / 2, 5);
+	abortbutton-&gt;onclick = window_fs_abort;
 	s3dw_show(S3DWIDGET(infwin));
 }
 
@@ -315,10 +315,10 @@
 		window_fs_another();
 		return;
 	}
-	infwin=s3dw_surface_new(&quot;Info Window&quot;,20,8);
-	s3dw_label_new(infwin,&quot;Sorry, moving is not implemented yet.. :(&quot;,1,2);
-	button=s3dw_button_new(infwin,&quot;Too bad&quot;,7,5);
-	button-&gt;onclick=close_win;
+	infwin = s3dw_surface_new(&quot;Info Window&quot;, 20, 8);
+	s3dw_label_new(infwin, &quot;Sorry, moving is not implemented yet.. :(&quot;, 1, 2);
+	button = s3dw_button_new(infwin, &quot;Too bad&quot;, 7, 5);
+	button-&gt;onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 
 }
@@ -329,24 +329,24 @@
 	s3dw_button  *button;
 	char string1[M_DIR];
 	char string2[M_DIR];
-	int b,d,f;
+	int b, d, f;
 	char bd[M_DIR];
 	float l;
-	snprintf(string1,M_DIR,&quot;Info for %s&quot;,path);
+	snprintf(string1, M_DIR, &quot;Info for %s&quot;, path);
 	fs_approx(path, &amp;f, &amp;d, &amp;b);
-	dotted_int(bd,b);
-	snprintf(string2 ,M_DIR,&quot;%s bytes in %d files and %d Directories&quot;,bd,f,d);
+	dotted_int(bd, b);
+	snprintf(string2 , M_DIR, &quot;%s bytes in %d files and %d Directories&quot;, bd, f, d);
 
-	l=((strlen(string1)&gt;strlen(string2)) ? strlen(string1) :strlen(string2))*0.7;
+	l = ((strlen(string1) &gt; strlen(string2)) ? strlen(string1) : strlen(string2)) * 0.7;
 
-	infwin=s3dw_surface_new(&quot;Info Window&quot;,l,12);
+	infwin = s3dw_surface_new(&quot;Info Window&quot;, l, 12);
 
-	s3dw_label_new(infwin,string1,1,2);
-	s3dw_label_new(infwin,string2,1,4);
+	s3dw_label_new(infwin, string1, 1, 2);
+	s3dw_label_new(infwin, string2, 1, 4);
 
-	button=s3dw_button_new(infwin,&quot;OK&quot;,l/2-1,6);
+	button = s3dw_button_new(infwin, &quot;OK&quot;, l / 2 - 1, 6);
 	/* clicking on the button will exit ... */
-	button-&gt;onclick=close_win;
+	button-&gt;onclick = close_win;
 	/* of couse, show it */
 	s3dw_show(S3DWIDGET(infwin));
 }
@@ -355,10 +355,10 @@
 {
 	int i;
 	t_node *node, dummy;
-	if (fs_lock!=TYPE_NONE)	{
+	if (fs_lock != TYPE_NONE) {
 		/* get current position of our destination node */
-		if (destnode!=NULL) {
-			node=destnode;
+		if (destnode != NULL) {
+			node = destnode;
 			node_init(&amp;dummy);
 			dummy.parent = node-&gt;parent;
 			dummy.scale = node-&gt;scale;
@@ -368,18 +368,18 @@
 			dummy.type = node-&gt;type;
 			fly_set_absolute_position(&amp;dummy);
 		} else {
-			dummy.px=0;
-			dummy.py=0;
-			dummy.pz=0;
-			dummy.scale=0.01;
+			dummy.px = 0;
+			dummy.py = 0;
+			dummy.pz = 0;
+			dummy.scale = 0.01;
 		}
-		if (fp!=NULL) {
-			for (i=0;i&lt;fp-&gt;n;i++) {
-				if (fp-&gt;p[i].state==STATE_FINISHED) { /* we can go and clean up now. */
-					if (NULL!=(node=node_getbypath(fp-&gt;p[i].name))) {
-						printf(&quot;[CLEANUP] for node %s (%s)\n&quot;,node-&gt;name,fp-&gt;p[i].name);
-						node-&gt;detached=0;
-						if (node-&gt;parent!=NULL) {
+		if (fp != NULL) {
+			for (i = 0;i &lt; fp-&gt;n;i++) {
+				if (fp-&gt;p[i].state == STATE_FINISHED) { /* we can go and clean up now. */
+					if (NULL != (node = node_getbypath(fp-&gt;p[i].name))) {
+						printf(&quot;[CLEANUP] for node %s (%s)\n&quot;, node-&gt;name, fp-&gt;p[i].name);
+						node-&gt;detached = 0;
+						if (node-&gt;parent != NULL) {
 							parse_dir(node-&gt;parent);
 							switch (node-&gt;disp) {
 							case D_ICON:
@@ -391,50 +391,50 @@
 							}
 						}
 					} else
-						printf(&quot;node %s already vanished ...\n&quot;,fp-&gt;p[i].name);
+						printf(&quot;node %s already vanished ...\n&quot;, fp-&gt;p[i].name);
 
-					fp-&gt;p[i].state=STATE_CLEANED;
+					fp-&gt;p[i].state = STATE_CLEANED;
 				}
-				if (fp-&gt;p[i].state&gt;STATE_NONE) {
-					if (destnode!=NULL) {
-						fp-&gt;p[i].anode-&gt;px=dummy.px;
-						fp-&gt;p[i].anode-&gt;py=dummy.py;
-						fp-&gt;p[i].anode-&gt;pz=dummy.pz;
+				if (fp-&gt;p[i].state &gt; STATE_NONE) {
+					if (destnode != NULL) {
+						fp-&gt;p[i].anode-&gt;px = dummy.px;
+						fp-&gt;p[i].anode-&gt;py = dummy.py;
+						fp-&gt;p[i].anode-&gt;pz = dummy.pz;
 						ani_add(fp-&gt;p[i].anode);
 					}
 
 				}
 			}
 		}
-		if (fs_lock==TYPE_FINISHED)	{
+		if (fs_lock == TYPE_FINISHED) {
 			printf(&quot;filesystem stuff is finisheed, cleaning up&quot;);
-			if (fp!=NULL) {
+			if (fp != NULL) {
 				fl_del(fp);
-				fp=NULL;
+				fp = NULL;
 			}
-			typeinput=0;
-			fs_lock=TYPE_NONE;
-			if (destnode!=NULL)
-				if (destnode-&gt;disp==D_DIR) { /* it usually is opened */
+			typeinput = 0;
+			fs_lock = TYPE_NONE;
+			if (destnode != NULL)
+				if (destnode-&gt;disp == D_DIR) { /* it usually is opened */
 					printf(&quot;reordering icons on destnode ...\n&quot;);
 					box_order_icons(destnode);
 				}
-			destnode=NULL;
+			destnode = NULL;
 		}
-		if (fs_err.state==ESTATE_RISE) {
+		if (fs_err.state == ESTATE_RISE) {
 			s3dw_surface *infwin;
 			s3dw_button  *button;
 			char errmsg[M_DIR];
 			float l;
-			fs_err.state=ESTATE_WAIT_FOR_CONFIRM;
-			snprintf(errmsg,M_DIR,&quot;Error \&quot;%s\&quot; on %s&quot;,fs_err.message,fs_err.file);
-			l=s3d_strlen(errmsg)+2;
-			infwin=s3dw_surface_new(&quot;Error&quot;,l,8);
-			s3dw_label_new(infwin,errmsg,1,2);
-			button=s3dw_button_new(infwin,&quot;OK&quot;,l/2-1,5);
-			button-&gt;onclick=window_fs_confirm_error;
+			fs_err.state = ESTATE_WAIT_FOR_CONFIRM;
+			snprintf(errmsg, M_DIR, &quot;Error \&quot;%s\&quot; on %s&quot;, fs_err.message, fs_err.file);
+			l = s3d_strlen(errmsg) + 2;
+			infwin = s3dw_surface_new(&quot;Error&quot;, l, 8);
+			s3dw_label_new(infwin, errmsg, 1, 2);
+			button = s3dw_button_new(infwin, &quot;OK&quot;, l / 2 - 1, 5);
+			button-&gt;onclick = window_fs_confirm_error;
 			s3dw_show(S3DWIDGET(infwin));
-			printf(&quot;fs_err is active ... message: %s\n&quot;,errmsg);
+			printf(&quot;fs_err is active ... message: %s\n&quot;, errmsg);
 		}
 	}
 }

Modified: trunk/apps/s3dfm/event.c
===================================================================
--- trunk/apps/s3dfm/event.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/event.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -27,17 +27,17 @@
 
 
 
-int typeinput=0;
+int typeinput = 0;
 
 /* info packets handler, we're just interested in the cam */
 int event_oinfo(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
-	if ((inf-&gt;object==0) &amp;&amp; (!ani_onstack(&amp;cam))) {
-		cam.dpx=inf-&gt;trans_x;
-		cam.dpy=inf-&gt;trans_y;
-		cam.dpz=inf-&gt;trans_z;
+	inf = (struct s3d_obj_info *)hrmz-&gt;buf;
+	if ((inf-&gt;object == 0) &amp;&amp; (!ani_onstack(&amp;cam))) {
+		cam.dpx = inf-&gt;trans_x;
+		cam.dpy = inf-&gt;trans_y;
+		cam.dpz = inf-&gt;trans_z;
 	}
 	s3dw_object_info(hrmz);
 	return(0);
@@ -46,14 +46,14 @@
 /* keyevent handler */
 int event_key(struct s3d_evt *evt)
 {
-	struct s3d_key_event *keys=(struct s3d_key_event *)evt-&gt;buf;
+	struct s3d_key_event *keys = (struct s3d_key_event *)evt-&gt;buf;
 	char path[M_DIR];
-	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */
+	if (typeinput) { /* we have some inputfield now and want the s3dw to handle our input */
 		printf(&quot;inputting text ...\n&quot;);
 		s3dw_handle_key(evt);
 		return(0);
 	}
-	node_path(node_getdir(focus),path);
+	node_path(node_getdir(focus), path);
 	switch (keys-&gt;keysym) {
 	case 'i':
 	case 'I': {
@@ -63,8 +63,8 @@
 	case 'r':
 	case 'R': {/* refresh this window ... */
 		t_node *node;
-		node=node_getdir(focus);
-		printf(&quot;[R]efreshing %s\n&quot;,node-&gt;name);
+		node = node_getdir(focus);
+		printf(&quot;[R]efreshing %s\n&quot;, node-&gt;name);
 		parse_dir(node);
 		box_draw_icons(node);
 		box_order_icons(node);
@@ -103,10 +103,10 @@
 		node_select(focus);
 		break;
 	case S3DK_BACKSPACE:
-		if (focus-&gt;disp==D_DIR)
-			box_close(focus,1);
-		else if (focus-&gt;parent!=NULL)
-			box_close(focus-&gt;parent,1);
+		if (focus-&gt;disp == D_DIR)
+			box_close(focus, 1);
+		else if (focus-&gt;parent != NULL)
+			box_close(focus-&gt;parent, 1);
 		break;
 
 	}
@@ -120,20 +120,20 @@
 	int oid;
 	t_node *f;
 	s3dw_handle_click(evt);
-	oid=(int)*((u_int32_t *)evt-&gt;buf);
-	if (NULL!=(f=node_getbyoid(&amp;root,oid))) {
-		if (f-&gt;objs.close==oid) {
-			box_close(f,1);
+	oid = (int) * ((u_int32_t *)evt-&gt;buf);
+	if (NULL != (f = node_getbyoid(&amp;root, oid))) {
+		if (f-&gt;objs.close == oid) {
+			box_close(f, 1);
 			return(0);
 		}
-		if (f-&gt;objs.select==oid) {
-			printf(&quot;[S]electing %s\n&quot;,f-&gt;name);
+		if (f-&gt;objs.select == oid) {
+			printf(&quot;[S]electing %s\n&quot;, f-&gt;name);
 			node_select(f);
 			return(0);
 		}
 		node_select(f);
 	} else {
-		/*		printf(&quot;[C]ould not find :/\n&quot;);*/
+		/*  printf(&quot;[C]ould not find :/\n&quot;);*/
 	}
 	return(0);
 }

Modified: trunk/apps/s3dfm/fly.c
===================================================================
--- trunk/apps/s3dfm/fly.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/fly.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,43 +22,43 @@
  */
 
 #include &quot;s3dfm.h&quot;
-#include &lt;stdio.h&gt;	/* NULL */
+#include &lt;stdio.h&gt; /* NULL */
 #include &lt;string.h&gt; /* strncpy() */
 static void _get_pos(t_node *work, t_node *f)
 {
-	if (f-&gt;parent!=NULL) _get_pos(work,f-&gt;parent);
-	work-&gt;px+=f-&gt;px										* work-&gt;scale;
-	work-&gt;pz+=f-&gt;pz										* work-&gt;scale;
-	work-&gt;py+=f-&gt;py										* work-&gt;scale;
+	if (f-&gt;parent != NULL) _get_pos(work, f-&gt;parent);
+	work-&gt;px += f-&gt;px          * work-&gt;scale;
+	work-&gt;pz += f-&gt;pz          * work-&gt;scale;
+	work-&gt;py += f-&gt;py          * work-&gt;scale;
 	/*
 	printf(&quot;%s: %3.3f %3.3f %3.3f - %3.3f\n&quot;,f-&gt;name, f-&gt;px, f-&gt;py, f-&gt;pz, f-&gt;scale );
 	printf(&quot;### %3.3f %3.3f %3.3f - %3.3f)\n&quot;, work-&gt;px, work-&gt;py, work-&gt;pz, work-&gt;scale);
 	*/
-	if (f-&gt;parent==NULL)	work-&gt;scale = f-&gt;scale;
-	else					work-&gt;scale = work-&gt;scale * f-&gt;scale;
+	if (f-&gt;parent == NULL) work-&gt;scale = f-&gt;scale;
+	else     work-&gt;scale = work-&gt;scale * f-&gt;scale;
 
 }
 
 int fly_set_absolute_position(t_node *node)
 {
 	t_node work;
-	work.px=0;
-	work.py=0;
-	work.pz=0;
-	work.scale=1.0;
+	work.px = 0;
+	work.py = 0;
+	work.pz = 0;
+	work.scale = 1.0;
 	_get_pos(&amp;work, node);
-	node-&gt;px=work.px;
-	node-&gt;py=work.py;
-	node-&gt;pz=work.pz;
-	node-&gt;scale=work.scale;
-	/*	printf(&quot;node coordinates: %3.3f %3.3f %3.3f %3.3f\n&quot;,node-&gt;px,node-&gt;py,node-&gt;pz,node-&gt;scale);*/
+	node-&gt;px = work.px;
+	node-&gt;py = work.py;
+	node-&gt;pz = work.pz;
+	node-&gt;scale = work.scale;
+	/* printf(&quot;node coordinates: %3.3f %3.3f %3.3f %3.3f\n&quot;,node-&gt;px,node-&gt;py,node-&gt;pz,node-&gt;scale);*/
 	return(0);
 }
 /* create a copy of *node as an icon (block) which can be moved for animation ... */
 t_node *fly_create_anode(t_node *node)
 {
 	t_node *work;
-	work=malloc(sizeof(t_node));
+	work = malloc(sizeof(t_node));
 	node_init(work);
 	work-&gt;parent = node-&gt;parent;
 	work-&gt;scale = node-&gt;scale;
@@ -66,17 +66,17 @@
 	work-&gt;py = node-&gt;py;
 	work-&gt;pz = node-&gt;pz;
 	work-&gt;type = node-&gt;type;
-	strncpy(work-&gt;name,node-&gt;name,M_NAME);
+	strncpy(work-&gt;name, node-&gt;name, M_NAME);
 	fly_set_absolute_position(work);
 	icon_draw(work);
 
-	work-&gt;dpx=work-&gt;px;
-	work-&gt;dpy=work-&gt;py;
-	work-&gt;dpz=work-&gt;pz;
-	work-&gt;dscale=work-&gt;scale;
-	work-&gt;py=2*work-&gt;scale - work-&gt;py; /* invert */
-	s3d_flags_on(work-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(work-&gt;objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	work-&gt;dpx = work-&gt;px;
+	work-&gt;dpy = work-&gt;py;
+	work-&gt;dpz = work-&gt;pz;
+	work-&gt;dscale = work-&gt;scale;
+	work-&gt;py = 2 * work-&gt;scale - work-&gt;py; /* invert */
+	s3d_flags_on(work-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(work-&gt;objs.str, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 	ani_add(work);
 	return(work);
 }

Modified: trunk/apps/s3dfm/focus.c
===================================================================
--- trunk/apps/s3dfm/focus.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/focus.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,55 +25,55 @@
 #include &lt;s3d_keysym.h&gt;
 #include &lt;stdio.h&gt; /* printf() */
 #include &lt;math.h&gt;  /* ceil(), sqrt() */
-int moveon=1;
+int moveon = 1;
 
 /* get the scale for the rootbox zoom */
 float focus_get_scale(t_node *f)
 {
-	float scale,s;
-	if (f-&gt;disp==D_DIR) {
-		s=0.2;
-		scale=1/s;
-		if (f-&gt;parent!=NULL)
-			scale=1/s*focus_get_scale(f-&gt;parent);
+	float scale, s;
+	if (f-&gt;disp == D_DIR) {
+		s = 0.2;
+		scale = 1 / s;
+		if (f-&gt;parent != NULL)
+			scale = 1 / s * focus_get_scale(f-&gt;parent);
 		else
 			return(1.0);
-		root.px-=f-&gt;px;
-		root.pz-=f-&gt;pz;
-		root.py-=BOXHEIGHT+f-&gt;detached*DETHEIGHT;
-		root.px*=1/s;
-		root.py*=1/s;
-		root.pz*=1/s;
+		root.px -= f-&gt;px;
+		root.pz -= f-&gt;pz;
+		root.py -= BOXHEIGHT + f-&gt;detached * DETHEIGHT;
+		root.px *= 1 / s;
+		root.py *= 1 / s;
+		root.pz *= 1 / s;
 		return(scale);
 	} else {
-		if (f-&gt;parent!=NULL)		return(focus_get_scale(f-&gt;parent));	/* icons etc */
-		else  						return(1.0);						/* that should never happen */
+		if (f-&gt;parent != NULL)  return(focus_get_scale(f-&gt;parent)); /* icons etc */
+		else        return(1.0);      /* that should never happen */
 	}
 
 }
 /* center f for the viewer, therefore moving the root box ... */
 void focus_set(t_node *f)
 {
-	root.px=0.0;
-	root.py=0.0;
-	root.pz=0.0;
-	moveon=1;
-	/*	printf(&quot;[Z]ooming to %s\n&quot;,f-&gt;name);*/
-	/*	box_collapse_grandkids(f);*/
-	root.scale=focus_get_scale(f);
-	root.py-=1.5;
-	/*	printf(&quot;[R]escaling to %f\n&quot;,root.scale);
-		printf(&quot;px: %f py:%f pz: %f\n&quot;,root.px,root.py,root.pz);*/
+	root.px = 0.0;
+	root.py = 0.0;
+	root.pz = 0.0;
+	moveon = 1;
+	/* printf(&quot;[Z]ooming to %s\n&quot;,f-&gt;name);*/
+	/* box_collapse_grandkids(f);*/
+	root.scale = focus_get_scale(f);
+	root.py -= 1.5;
+	/* printf(&quot;[R]escaling to %f\n&quot;,root.scale);
+	 printf(&quot;px: %f py:%f pz: %f\n&quot;,root.px,root.py,root.pz);*/
 
 	ani_add(&amp;root);
-	node_focus_color(focus,0);
-	node_focus_color(f,1);
-	focus=f;
-	if (((cam.dpx-cam.px)* (cam.dpx-cam.px) + (cam.dpy-cam.py)* (cam.dpy-cam.py)
-	                + (cam.dpz-cam.pz)* (cam.dpz-cam.pz))	&gt; ( 10 * 10)) {
-		cam.px=0;
-		cam.py=0;
-		cam.pz=5;
+	node_focus_color(focus, 0);
+	node_focus_color(f, 1);
+	focus = f;
+	if (((cam.dpx - cam.px)* (cam.dpx - cam.px) + (cam.dpy - cam.py)* (cam.dpy - cam.py)
+	                + (cam.dpz - cam.pz)* (cam.dpz - cam.pz)) &gt; (10 * 10)) {
+		cam.px = 0;
+		cam.py = 0;
+		cam.pz = 5;
 		ani_add(&amp;cam);
 	}
 }
@@ -81,52 +81,52 @@
 /* uses a keysym to set the focus new */
 void focus_by_key(int keysym)
 {
-	int i,rowsize;
-	if (focus-&gt;pindex!=-1) {
+	int i, rowsize;
+	if (focus-&gt;pindex != -1) {
 		switch (focus-&gt;disp) {
 		case D_DIR:
 			switch (keysym) {
 			case S3DK_RIGHT:
 				/* cycle to the next directory on the ring */
-				for (i=focus-&gt;pindex-1;i&gt;=0;i--)
-					if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR) { /* found a directory before, cycle */
+				for (i = focus-&gt;pindex - 1;i &gt;= 0;i--)
+					if (focus-&gt;parent-&gt;sub[i]-&gt;disp == D_DIR) { /* found a directory before, cycle */
 						focus_set(focus-&gt;parent-&gt;sub[i]);
 						break;
 					}
-				if (i==-1) /* nothing found, wrap to the other side */
-					for (i=focus-&gt;parent-&gt;n_sub-1;i&gt;=focus-&gt;pindex+1;i--)
-						if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR) { /* found a directory before, cycle */
+				if (i == -1) /* nothing found, wrap to the other side */
+					for (i = focus-&gt;parent-&gt;n_sub - 1;i &gt;= focus-&gt;pindex + 1;i--)
+						if (focus-&gt;parent-&gt;sub[i]-&gt;disp == D_DIR) { /* found a directory before, cycle */
 							focus_set(focus-&gt;parent-&gt;sub[i]);
 							break;
 						}
 				break;
 			case S3DK_LEFT:
 				/* cycle to the next directory on the ring */
-				for (i=focus-&gt;pindex+1;i&lt;focus-&gt;parent-&gt;n_sub;i++)
-					if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR) { /* found a directory before, cycle */
+				for (i = focus-&gt;pindex + 1;i &lt; focus-&gt;parent-&gt;n_sub;i++)
+					if (focus-&gt;parent-&gt;sub[i]-&gt;disp == D_DIR) { /* found a directory before, cycle */
 						focus_set(focus-&gt;parent-&gt;sub[i]);
 						break;
 					}
-				if (i==focus-&gt;parent-&gt;n_sub) /* nothing found, wrap to the other side */
-					for (i=0;i&lt;focus-&gt;pindex;i++)
-						if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR) { /* found a directory before, cycle */
+				if (i == focus-&gt;parent-&gt;n_sub) /* nothing found, wrap to the other side */
+					for (i = 0;i &lt; focus-&gt;pindex;i++)
+						if (focus-&gt;parent-&gt;sub[i]-&gt;disp == D_DIR) { /* found a directory before, cycle */
 							focus_set(focus-&gt;parent-&gt;sub[i]);
 							break;
 						}
 				break;
 			case S3DK_UP:
 				/* go in the first entry of this directory, if possible */
-				if (focus-&gt;n_sub&gt;0)
+				if (focus-&gt;n_sub &gt; 0)
 					focus_set(focus-&gt;sub[0]);
 				break;
 			case S3DK_DOWN:
 				/* go to first icon entry of parent,  or parent itself */
-				for (i=focus-&gt;parent-&gt;n_sub-1;i&gt;=0;i--)
-					if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_ICON) { /* found a directory before, cycle */
+				for (i = focus-&gt;parent-&gt;n_sub - 1;i &gt;= 0;i--)
+					if (focus-&gt;parent-&gt;sub[i]-&gt;disp == D_ICON) { /* found a directory before, cycle */
 						focus_set(focus-&gt;parent-&gt;sub[i]);
 						break;
 					}
-				if (i==0) /* no icons? go to parent. */
+				if (i == 0) /* no icons? go to parent. */
 					focus_set(focus-&gt;parent);
 				break;
 
@@ -138,48 +138,48 @@
 			switch (keysym) {
 			case S3DK_LEFT:
 				/* search for the next icon on the left side */
-				i=focus-&gt;pindex;
+				i = focus-&gt;pindex;
 				do {
 					i--;
-					if (i&lt;0) i=focus-&gt;parent-&gt;n_sub-1;
-				} while (focus-&gt;parent-&gt;sub[i]-&gt;disp!=D_ICON);
+					if (i &lt; 0) i = focus-&gt;parent-&gt;n_sub - 1;
+				} while (focus-&gt;parent-&gt;sub[i]-&gt;disp != D_ICON);
 				focus_set(focus-&gt;parent-&gt;sub[i]);
 				break;
 			case S3DK_RIGHT:
 				/* search for the next icon on the right side */
-				i=focus-&gt;pindex;
+				i = focus-&gt;pindex;
 				do {
 					i++;
-					if (i&gt;=focus-&gt;parent-&gt;n_sub) i=0;
-				} while (focus-&gt;parent-&gt;sub[i]-&gt;disp!=D_ICON);
+					if (i &gt;= focus-&gt;parent-&gt;n_sub) i = 0;
+				} while (focus-&gt;parent-&gt;sub[i]-&gt;disp != D_ICON);
 				focus_set(focus-&gt;parent-&gt;sub[i]);
 				break;
 			case S3DK_UP:
 				/* search for the next icon on the left side */
-				i=focus-&gt;pindex;
-				rowsize=ceil(sqrt(focus-&gt;parent-&gt;n_sub)); /* items per line */
+				i = focus-&gt;pindex;
+				rowsize = ceil(sqrt(focus-&gt;parent-&gt;n_sub)); /* items per line */
 				do {
-					i+=rowsize;
-					if (i&gt;=focus-&gt;parent-&gt;n_sub) break;
-				} while (focus-&gt;parent-&gt;sub[i]-&gt;disp!=D_ICON);
-				if (i&gt;=focus-&gt;parent-&gt;n_sub) {
+					i += rowsize;
+					if (i &gt;= focus-&gt;parent-&gt;n_sub) break;
+				} while (focus-&gt;parent-&gt;sub[i]-&gt;disp != D_ICON);
+				if (i &gt;= focus-&gt;parent-&gt;n_sub) {
 					/* go to the first activated dir above ... */
-					for (i=0;i&lt;focus-&gt;parent-&gt;n_sub;i++)
-						if (focus-&gt;parent-&gt;sub[i]-&gt;disp==D_DIR) { /* found a directory before, cycle */
+					for (i = 0;i &lt; focus-&gt;parent-&gt;n_sub;i++)
+						if (focus-&gt;parent-&gt;sub[i]-&gt;disp == D_DIR) { /* found a directory before, cycle */
 							focus_set(focus-&gt;parent-&gt;sub[i]);
 							break;
 						}
-				} else		focus_set(focus-&gt;parent-&gt;sub[i]);
+				} else  focus_set(focus-&gt;parent-&gt;sub[i]);
 				break;
 			case S3DK_DOWN:
 				/* search for the next icon on the left side */
-				i=focus-&gt;pindex;
-				rowsize=ceil(sqrt(focus-&gt;parent-&gt;n_sub)); /* items per line */
+				i = focus-&gt;pindex;
+				rowsize = ceil(sqrt(focus-&gt;parent-&gt;n_sub)); /* items per line */
 				do {
-					i-=rowsize;
-					if (i&lt;0) break;
-				} while (focus-&gt;parent-&gt;sub[i]-&gt;disp!=D_ICON);
-				if (i&lt;0)
+					i -= rowsize;
+					if (i &lt; 0) break;
+				} while (focus-&gt;parent-&gt;sub[i]-&gt;disp != D_ICON);
+				if (i &lt; 0)
 					focus_set(focus-&gt;parent);
 				else
 					focus_set(focus-&gt;parent-&gt;sub[i]);
@@ -193,7 +193,7 @@
 		switch (keysym) {
 		case S3DK_UP:
 			/* go in the first entry of this directory, if possible */
-			if (focus-&gt;n_sub&gt;0)
+			if (focus-&gt;n_sub &gt; 0)
 				focus_set(focus-&gt;sub[0]);
 			break;
 		}

Modified: trunk/apps/s3dfm/fs.c
===================================================================
--- trunk/apps/s3dfm/fs.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/fs.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -21,13 +21,13 @@
  */
 
 #include &quot;s3dfm.h&quot;
-#include &lt;stdio.h&gt;	/*  printf() */
-#include &lt;dirent.h&gt;	/* scandir() */
-#include &lt;stdlib.h&gt;	/*  malloc() */
+#include &lt;stdio.h&gt; /*  printf() */
+#include &lt;dirent.h&gt; /* scandir() */
+#include &lt;stdlib.h&gt; /*  malloc() */
 
 /* we want GNU version of basename */
 #define _GNU_SOURCE
-#include &lt;string.h&gt;	/*  strlen(), strncmp(), strrchr() */
+#include &lt;string.h&gt; /*  strlen(), strncmp(), strrchr() */
 #include &lt;libgen.h&gt; /* basename() */
 
 #include &lt;sys/types.h&gt;
@@ -35,10 +35,10 @@
 #include &lt;unistd.h&gt;
 
 #include &lt;errno.h&gt; /* errno */
-#include &lt;time.h&gt;	/* nanosleep() */
+#include &lt;time.h&gt; /* nanosleep() */
 
-struct fs_error fs_err= {
-	0,0,NULL,NULL
+struct fs_error fs_err = {
+	0, 0, NULL, NULL
 };
 
 
@@ -47,40 +47,40 @@
 {
 	struct dirent **namelist;
 	filelist *fl;
-	int n,i,j;
+	int n, i, j;
 	char *name;
 
-	fl=malloc(sizeof(filelist));
-	fl-&gt;p=NULL;
-	fl-&gt;n=0;
+	fl = malloc(sizeof(filelist));
+	fl-&gt;p = NULL;
+	fl-&gt;n = 0;
 	n = scandir(path, &amp;namelist, 0, alphasort);
 	if (n &lt;= 2) { /* . and .. is always included. */
-		if (n&lt;0)
-			fs_error(&quot;fl_new():scandir()&quot;,path);
+		if (n &lt; 0)
+			fs_error(&quot;fl_new():scandir()&quot;, path);
 	} else {
-		j=0;
-		fl-&gt;n=n-2 ; /* ignore . and .. */
-		fl-&gt;p=malloc(sizeof(t_file)*fl-&gt;n);
-		for (i=0;i&lt;n;i++) {
-			name=namelist[i]-&gt;d_name;
-			if (!((strcmp(name,&quot;.&quot;)==0) || (strcmp(name,&quot;..&quot;)==0))) { /* ignore */
-				fl-&gt;p[j].name=malloc(strlen(name)+strlen(path)+2);
-				strcpy(fl-&gt;p[j].name,path);
-				strcat(fl-&gt;p[j].name,&quot;/&quot;);
-				strcat(fl-&gt;p[j].name,name);
-				fl-&gt;p[j].anode=NULL;
-				fl-&gt;p[j].size=0; /*TODO: later */
-				fl-&gt;p[j].state=STATE_NONE;
+		j = 0;
+		fl-&gt;n = n - 2 ; /* ignore . and .. */
+		fl-&gt;p = malloc(sizeof(t_file) * fl-&gt;n);
+		for (i = 0;i &lt; n;i++) {
+			name = namelist[i]-&gt;d_name;
+			if (!((strcmp(name, &quot;.&quot;) == 0) || (strcmp(name, &quot;..&quot;) == 0))) { /* ignore */
+				fl-&gt;p[j].name = malloc(strlen(name) + strlen(path) + 2);
+				strcpy(fl-&gt;p[j].name, path);
+				strcat(fl-&gt;p[j].name, &quot;/&quot;);
+				strcat(fl-&gt;p[j].name, name);
+				fl-&gt;p[j].anode = NULL;
+				fl-&gt;p[j].size = 0; /*TODO: later */
+				fl-&gt;p[j].state = STATE_NONE;
 
 				j++;
 			}
 			free(namelist[i]);
 		}
-		if (j!=fl-&gt;n) { /* TODO: GUH! don't exit(-1) */
+		if (j != fl-&gt;n) { /* TODO: GUH! don't exit(-1) */
 			printf(&quot;assertion failed\n&quot;);
 			exit(-1);
 		}
-		free (namelist);
+		free(namelist);
 	}
 	return(fl);
 }
@@ -88,9 +88,9 @@
 void fl_del(filelist *fl)
 {
 	int i;
-	for (i=0;i&lt;fl-&gt;n;i++) {
+	for (i = 0;i &lt; fl-&gt;n;i++) {
 		free(fl-&gt;p[i].name);
-		if (fl-&gt;p[i].anode!=NULL) {
+		if (fl-&gt;p[i].anode != NULL) {
 			/* maybe let node_delete do that? */
 			/*node_delete(fl-&gt;p[i].anode);*/
 			icon_undisplay(fl-&gt;p[i].anode);
@@ -102,50 +102,50 @@
 /* approximate the heaviness of a single */
 void fs_approx(char *source, int *files, int *dirs, int *bytes)
 {
-	int sfiles,sdirs,sbytes; 	/* for subdirs */
+	int sfiles, sdirs, sbytes;  /* for subdirs */
 	filelist *fl;
 	struct stat s;
 
-	*files=	sfiles=	0;
-	*dirs=	sdirs=	0;
-	*bytes=	sbytes=	0;
+	*files = sfiles = 0;
+	*dirs = sdirs = 0;
+	*bytes = sbytes = 0;
 
-	/*	printf(&quot;start: %d files, %d dirs, %d bytes in %s\n&quot;,*files,*dirs,*bytes,source);*/
-	if (-1==stat(source,&amp;s))
+	/* printf(&quot;start: %d files, %d dirs, %d bytes in %s\n&quot;,*files,*dirs,*bytes,source);*/
+	if (-1 == stat(source, &amp;s))
 		return;
-	/*	printf(&quot;%s: %08x (%db)\n&quot;,source,s.st_mode,(int)s.st_size);*/
+	/* printf(&quot;%s: %08x (%db)\n&quot;,source,s.st_mode,(int)s.st_size);*/
 	if ((s.st_mode&amp;S_IFMT) == S_IFDIR) {
 
-		fl=fl_new(source);
-		if (fl-&gt;n&gt;0)
-			fs_fl_approx(fl,&amp;sfiles,&amp;sdirs,&amp;sbytes);
+		fl = fl_new(source);
+		if (fl-&gt;n &gt; 0)
+			fs_fl_approx(fl, &amp;sfiles, &amp;sdirs, &amp;sbytes);
 		fl_del(fl);
-		/*		printf(&quot;%d files, %d dirs, %d bytes in %s\n&quot;,sfiles,sdirs,sbytes,source);*/
+		/*  printf(&quot;%d files, %d dirs, %d bytes in %s\n&quot;,sfiles,sdirs,sbytes,source);*/
 
-		*files=		sfiles;
-		*bytes+=	sbytes;
-		*dirs=		sdirs;
-		*dirs+=		1;
+		*files =  sfiles;
+		*bytes += sbytes;
+		*dirs =  sdirs;
+		*dirs +=  1;
 	} else
-		*files=		1;
-	*bytes+=s.st_size;
-	/*	printf(&quot;end: %d files, %d dirs, %d bytes in %s\n&quot;,*files,*dirs,*bytes,source);*/
+		*files =  1;
+	*bytes += s.st_size;
+	/* printf(&quot;end: %d files, %d dirs, %d bytes in %s\n&quot;,*files,*dirs,*bytes,source);*/
 }
 /* approximate the heaviness of our source ...*/
 void fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes)
 {
 	int i;
-	int sfiles,sdirs,sbytes; 	/* for subdirs */
+	int sfiles, sdirs, sbytes;  /* for subdirs */
 
-	*files=0;
-	*dirs=0;
-	*bytes=0;
+	*files = 0;
+	*dirs = 0;
+	*bytes = 0;
 
-	for (i=0;i&lt;fl-&gt;n;i++) {
-		fs_approx(fl-&gt;p[i].name,&amp;sfiles,&amp;sdirs,&amp;sbytes);
-		*files+=		sfiles;
-		*dirs+=			sdirs;
-		*bytes+=		sbytes;
+	for (i = 0;i &lt; fl-&gt;n;i++) {
+		fs_approx(fl-&gt;p[i].name, &amp;sfiles, &amp;sdirs, &amp;sbytes);
+		*files +=  sfiles;
+		*dirs +=   sdirs;
+		*bytes +=  sbytes;
 	}
 }
 /* copy a certain file */
@@ -156,14 +156,14 @@
 	struct stat s;
 	char buf[1024];
 	int n;
-	if (-1==stat(source,&amp;s))
+	if (-1 == stat(source, &amp;s))
 		return(0);
 	switch (s.st_mode&amp;S_IFMT) {
 	case S_IFDIR:
-		fl=fl_new(source);
+		fl = fl_new(source);
 
-		printf(&quot;mkdir %s\n&quot;,dest);
-		mkdir(dest,0777);
+		printf(&quot;mkdir %s\n&quot;, dest);
+		mkdir(dest, 0777);
 
 		fs_fl_copy(fl, dest);
 
@@ -172,19 +172,19 @@
 	case S_IFIFO:
 		printf(&quot;link the fifo\n&quot;);
 
-		link(source,dest);
+		link(source, dest);
 		break;
 	default:
 		printf(&quot;fs_copy -&gt; atomic copy\n&quot;);
 		printf(&quot;open source...&quot;);
-		if (NULL==(fps=fopen(source,&quot;r&quot;))) {
-			fs_error(&quot;fs_copy():fopen(source)&quot;,source);
+		if (NULL == (fps = fopen(source, &quot;r&quot;))) {
+			fs_error(&quot;fs_copy():fopen(source)&quot;, source);
 			return(-1);
 		}
 		printf(&quot;ok\n&quot;);
 		printf(&quot;open dest...&quot;);
-		if (NULL==(fpd=fopen(dest,&quot;w&quot;))) {
-			fs_error(&quot;fs_copy():fopen(source)&quot;,source);
+		if (NULL == (fpd = fopen(dest, &quot;w&quot;))) {
+			fs_error(&quot;fs_copy():fopen(source)&quot;, source);
 			return(-1);
 		}
 		printf(&quot;ok\n&quot;);
@@ -193,11 +193,11 @@
 
 		while (!feof(fps)) {
 			printf(&quot;.&quot;);
-			errno=0;
-			n=fread(buf,1,1024,fps);
-			if (errno)	fs_error(&quot;fs_copy():fread(source)&quot;,source);
-			fwrite(buf,1,n,fpd);
-			if (errno)	fs_error(&quot;fs_copy():fwrite(source)&quot;,source);
+			errno = 0;
+			n = fread(buf, 1, 1024, fps);
+			if (errno) fs_error(&quot;fs_copy():fread(source)&quot;, source);
+			fwrite(buf, 1, n, fpd);
+			if (errno) fs_error(&quot;fs_copy():fwrite(source)&quot;, source);
 		}
 		printf(&quot;ok\n&quot;);
 		fclose(fps);
@@ -213,19 +213,19 @@
 	int r;
 	char *sdest;
 	char *bname;
-	r=0;
-	for (i=0;i&lt;fl-&gt;n;i++) {
-		fl-&gt;p[i].state=STATE_INUSE;
-		bname=basename(fl-&gt;p[i].name);
-		sdest=malloc(strlen(dest)+strlen(bname)+2);
+	r = 0;
+	for (i = 0;i &lt; fl-&gt;n;i++) {
+		fl-&gt;p[i].state = STATE_INUSE;
+		bname = basename(fl-&gt;p[i].name);
+		sdest = malloc(strlen(dest) + strlen(bname) + 2);
 
-		strcpy(sdest,dest);
-		strcat(sdest,&quot;/&quot;);
-		strcat(sdest,bname);
-		r|=fs_copy(fl-&gt;p[i].name,sdest);
+		strcpy(sdest, dest);
+		strcat(sdest, &quot;/&quot;);
+		strcat(sdest, bname);
+		r |= fs_copy(fl-&gt;p[i].name, sdest);
 
 		free(sdest);
-		fl-&gt;p[i].state=STATE_FINISHED;
+		fl-&gt;p[i].state = STATE_FINISHED;
 	}
 
 	return(r);
@@ -236,24 +236,24 @@
 	filelist *fl;
 	struct stat s;
 
-	if (-1==stat(dest,&amp;s))		return(-1);
+	if (-1 == stat(dest, &amp;s))  return(-1);
 	if ((s.st_mode&amp;S_IFMT) == S_IFDIR) {
-		printf(&quot;%s is a dir, removing below ...\n&quot;,dest);
-		fl=fl_new(dest);
+		printf(&quot;%s is a dir, removing below ...\n&quot;, dest);
+		fl = fl_new(dest);
 		if (fs_fl_unlink(fl)) {
 			fl_del(fl);
 			return(-1);
 		} else {
 			fl_del(fl);
-			printf(&quot;removing %s\n&quot;,dest);
-			if (rmdir(dest)==-1) {
-				fs_error(&quot;fs_fl_unlink(): rmdir()&quot;,dest);
+			printf(&quot;removing %s\n&quot;, dest);
+			if (rmdir(dest) == -1) {
+				fs_error(&quot;fs_fl_unlink(): rmdir()&quot;, dest);
 				return(-1);
 			}
 		}
 	} else {
-		if (unlink(dest)==-1) {
-			fs_error(&quot;fs_fl_unlink(): unlink()&quot;,dest);
+		if (unlink(dest) == -1) {
+			fs_error(&quot;fs_fl_unlink(): unlink()&quot;, dest);
 			return(-1);
 		}
 	}
@@ -262,27 +262,27 @@
 /* remove a lot of files */
 int fs_fl_unlink(filelist *fl)
 {
-	int i,r;
-	r=0;
-	for (i=0;i&lt;fl-&gt;n;i++) {
-		fl-&gt;p[i].state=STATE_INUSE;
-		printf(&quot;-&gt; atomic unlink %s\n&quot;,fl-&gt;p[i].name);
-		r|=fs_unlink(fl-&gt;p[i].name);
-		fl-&gt;p[i].state=STATE_FINISHED;
+	int i, r;
+	r = 0;
+	for (i = 0;i &lt; fl-&gt;n;i++) {
+		fl-&gt;p[i].state = STATE_INUSE;
+		printf(&quot;-&gt; atomic unlink %s\n&quot;, fl-&gt;p[i].name);
+		r |= fs_unlink(fl-&gt;p[i].name);
+		fl-&gt;p[i].state = STATE_FINISHED;
 	}
 	return(r);
 
 }
 int fs_move(char *source, char *dest)
 {
-	if (!rename(source,dest)) {
+	if (!rename(source, dest)) {
 		switch (errno) {
 		case EXDEV:
-			fs_copy(source,dest);
+			fs_copy(source, dest);
 			fs_unlink(source);
 			break;
 		default:
-			fs_error(&quot;fs_move()&quot;,dest);
+			fs_error(&quot;fs_move()&quot;, dest);
 			return(-1); /* can't help it */
 
 		}
@@ -297,19 +297,19 @@
 	int r;
 	char *sdest;
 	char *bname;
-	r=0;
-	for (i=0;i&lt;fl-&gt;n;i++) {
-		fl-&gt;p[i].state=STATE_INUSE;
-		bname=basename(fl-&gt;p[i].name);
-		sdest=malloc(strlen(dest)+strlen(bname)+2);
+	r = 0;
+	for (i = 0;i &lt; fl-&gt;n;i++) {
+		fl-&gt;p[i].state = STATE_INUSE;
+		bname = basename(fl-&gt;p[i].name);
+		sdest = malloc(strlen(dest) + strlen(bname) + 2);
 
-		strcpy(sdest,dest);
-		strcat(sdest,&quot;/&quot;);
-		strcat(sdest,bname);
-		r|=fs_move(fl-&gt;p[i].name,sdest);
+		strcpy(sdest, dest);
+		strcat(sdest, &quot;/&quot;);
+		strcat(sdest, bname);
+		r |= fs_move(fl-&gt;p[i].name, sdest);
 
 		free(sdest);
-		fl-&gt;p[i].state=STATE_FINISHED;
+		fl-&gt;p[i].state = STATE_FINISHED;
 	}
 
 	return(r);
@@ -320,15 +320,15 @@
 /* write an error and wait for a reaction */
 int fs_error(char *message, char *file)
 {
-	static struct timespec t= {
-		0,100*1000*1000
+	static struct timespec t = {
+		0, 100*1000*1000
 	};
-	fs_err.err=errno;
-	fs_err.message=message;
-	fs_err.file=file;
-	fs_err.state=ESTATE_RISE;
-	printf(&quot;[FS ERROR]: %s %s %s&quot;,message,file,strerror(errno));
-	while (fs_err.state!=ESTATE_NONE)
-		nanosleep(&amp;t,NULL);  /* until situation clear, wait (and don't waste cpu-time) */
+	fs_err.err = errno;
+	fs_err.message = message;
+	fs_err.file = file;
+	fs_err.state = ESTATE_RISE;
+	printf(&quot;[FS ERROR]: %s %s %s&quot;, message, file, strerror(errno));
+	while (fs_err.state != ESTATE_NONE)
+		nanosleep(&amp;t, NULL); /* until situation clear, wait (and don't waste cpu-time) */
 	return(0);
 }

Modified: trunk/apps/s3dfm/icon.c
===================================================================
--- trunk/apps/s3dfm/icon.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/icon.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,19 +22,19 @@
  */
 
 #include &quot;s3dfm.h&quot;
-#include &lt;stdio.h&gt; 	 /* printf() */
-#include &lt;math.h&gt;	 /* sin(),cos() */
+#include &lt;stdio.h&gt;   /* printf() */
+#include &lt;math.h&gt;  /* sin(),cos() */
 #include &lt;string.h&gt;  /* strlen() */
 #include &lt;stdlib.h&gt;  /* memcpy() */
-float icon_colors[T_TYPENUM][12]={
+float icon_colors[T_TYPENUM][12] = {
 	/* T_DUNO */
-	{	0,0,0.5,1.0,
-		0,0,0.5,1.0,
-		0,0,0.5,1.0 },
+	{ 0, 0, 0.5, 1.0,
+		0, 0, 0.5, 1.0,
+		0, 0, 0.5, 1.0 },
 	/* T_FOLDER */
-	{	0.4,0.4,0,1.0,
-	  0.4,0.4,0,1.0,
-	  0.4,0.4,0,1.0}
+	{ 0.4, 0.4, 0, 1.0,
+	  0.4, 0.4, 0, 1.0,
+	  0.4, 0.4, 0, 1.0}
 };
 
 /* gives another color for the focused item */
@@ -42,64 +42,64 @@
 {
 	float color[12];
 	int i;
-	memcpy(color,icon_colors[dir-&gt;type],sizeof(color));
-	if (on) for (i=0;i&lt;3;i++) {
-			color[i*4 + 0]+=0.3;
-			color[i*4 + 1]+=0.3;
-			color[i*4 + 2]+=0.3;
+	memcpy(color, icon_colors[dir-&gt;type], sizeof(color));
+	if (on) for (i = 0;i &lt; 3;i++) {
+			color[i*4 + 0] += 0.3;
+			color[i*4 + 1] += 0.3;
+			color[i*4 + 2] += 0.3;
 		}
-	s3d_pep_materials_a(dir-&gt;oid,color,1);
+	s3d_pep_materials_a(dir-&gt;oid, color, 1);
 }
 /* draws icon dir */
 int icon_draw(t_node *dir)
 {
-	float vertices[]={	-1,-0.5,0,
-	                   -1, 0.5,0,
-	                   1, 0.5,0,
-	                   1,-0.5,0,
-	                   -1,-0.5,-1,
-	                   -1, 0.5,-1,
-	                   1, 0.5,-1,
-	                   1,-0.5,-1
-	                 };
-	uint32_t polys[]={
-		1,3,0,0,				2,3,1,0,
-		5,6,2,0,				1,5,2,0,
-		2,6,7,0,				2,7,3,0,
-		0,3,7,0,				0,7,4,0,
-		5,1,0,0,				5,0,4,0
+	float vertices[] = { -1, -0.5, 0,
+	                     -1, 0.5, 0,
+	                     1, 0.5, 0,
+	                     1, -0.5, 0,
+	                     -1, -0.5, -1,
+	                     -1, 0.5, -1,
+	                     1, 0.5, -1,
+	                     1, -0.5, -1
+	                   };
+	uint32_t polys[] = {
+		1, 3, 0, 0,    2, 3, 1, 0,
+		5, 6, 2, 0,    1, 5, 2, 0,
+		2, 6, 7, 0,    2, 7, 3, 0,
+		0, 3, 7, 0,    0, 7, 4, 0,
+		5, 1, 0, 0,    5, 0, 4, 0
 	};
 	float len;
 	/* find position for the new block in our directory box */
 	/* create the block */
-	dir-&gt;oid=s3d_new_object();
-	s3d_push_vertices(dir-&gt;oid,vertices,8);
-	s3d_push_materials_a(dir-&gt;oid,icon_colors[dir-&gt;type],1);
-	s3d_push_polygons(dir-&gt;oid,polys,10);
+	dir-&gt;oid = s3d_new_object();
+	s3d_push_vertices(dir-&gt;oid, vertices, 8);
+	s3d_push_materials_a(dir-&gt;oid, icon_colors[dir-&gt;type], 1);
+	s3d_push_polygons(dir-&gt;oid, polys, 10);
 
 	/* draw and position the string */
-	if (dir-&gt;objs.str==-1) {
-		dir-&gt;objs.str=s3d_draw_string(dir-&gt;name,&amp;len);
-		if (len&lt;2) len=2;
-		dir-&gt;objs.strlen=len;
-	} else len=dir-&gt;objs.strlen;
-	s3d_scale(dir-&gt;objs.str,(float)1.8/len);
-	s3d_translate(dir-&gt;objs.str,-0.9,-0.3,0.1);
-	s3d_rotate(dir-&gt;objs.str,0,0,0);
-	s3d_link(dir-&gt;objs.str,dir-&gt;oid);
-	dir-&gt;disp=D_ICON;
+	if (dir-&gt;objs.str == -1) {
+		dir-&gt;objs.str = s3d_draw_string(dir-&gt;name, &amp;len);
+		if (len &lt; 2) len = 2;
+		dir-&gt;objs.strlen = len;
+	} else len = dir-&gt;objs.strlen;
+	s3d_scale(dir-&gt;objs.str, (float)1.8 / len);
+	s3d_translate(dir-&gt;objs.str, -0.9, -0.3, 0.1);
+	s3d_rotate(dir-&gt;objs.str, 0, 0, 0);
+	s3d_link(dir-&gt;objs.str, dir-&gt;oid);
+	dir-&gt;disp = D_ICON;
 	return(0);
 }
 int icon_undisplay(t_node *dir)
 {
-	if (dir-&gt;oid!=-1) {
+	if (dir-&gt;oid != -1) {
 		s3d_del_object(dir-&gt;oid);
-		dir-&gt;oid=-1;
+		dir-&gt;oid = -1;
 	}
-	if (dir-&gt;objs.str!=-1) {
+	if (dir-&gt;objs.str != -1) {
 		s3d_del_object(dir-&gt;objs.str);
-		dir-&gt;objs.str=-1;
+		dir-&gt;objs.str = -1;
 	}
-	dir-&gt;disp=0;
+	dir-&gt;disp = 0;
 	return(0);
 }

Modified: trunk/apps/s3dfm/main.c
===================================================================
--- trunk/apps/s3dfm/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,36 +24,36 @@
 
 #include &quot;s3dfm.h&quot;
 #include &lt;string.h&gt;  /*  strlen(), strncmp(), strrchr() */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t= {
-	0,33*1000*1000
+#include &lt;time.h&gt; /* nanosleep() */
+static struct timespec t = {
+	0, 33*1000*1000
 };
-t_node root,cam,*focus;
+t_node root, cam, *focus;
 
 void mainloop()
 {
 	ani_mate();
 	s3dw_ani_mate();
 	window_fsani();
-	nanosleep(&amp;t,NULL);
+	nanosleep(&amp;t, NULL);
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
 
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,event_click);
-	s3d_set_callback(S3D_EVENT_OBJ_INFO,event_oinfo);
-	s3d_set_callback(S3D_EVENT_KEY,event_key);
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;s3dfm&quot;)) {
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK, event_click);
+	s3d_set_callback(S3D_EVENT_OBJ_INFO, event_oinfo);
+	s3d_set_callback(S3D_EVENT_KEY, event_key);
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;s3dfm&quot;)) {
 		s3d_select_font(&quot;vera&quot;);
 
 		node_init(&amp;cam); /* a virtual object, just to push the cam throu our animation stack */
-		cam.oid=0;
+		cam.oid = 0;
 		/* set up file system representation */
 		node_init(&amp;root);
-		strncpy(root.name,&quot;/&quot;,M_NAME);
-		focus=&root;
-		root.dscale=0.1;
-		root.type=T_FOLDER;
+		strncpy(root.name, &quot;/&quot;, M_NAME);
+		focus = &root;
+		root.dscale = 0.1;
+		root.type = T_FOLDER;
 		parse_dir(&amp;root);
 		box_draw(&amp;root);
 		ani_doit(&amp;root);

Modified: trunk/apps/s3dfm/node.c
===================================================================
--- trunk/apps/s3dfm/node.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/node.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,43 +22,43 @@
  */
 
 #include &quot;s3dfm.h&quot;
-#include &lt;string.h&gt;	/* strncpy(), index() */
-#include &lt;stdio.h&gt;	/* printf() */
+#include &lt;string.h&gt; /* strncpy(), index() */
+#include &lt;stdio.h&gt; /* printf() */
 #include &lt;stdlib.h&gt; /* free() */
 /* find the node to a path, return NULL if not parsed yet */
 t_node *node_getbypath(char *path)
 {
 	char p[M_DIR];
-	char *s,*match;
+	char *s, *match;
 	t_node *cur;
 	int i;
 
-	if (path==NULL) return NULL;
-	if (path[0]=='/') {
-		strncpy(p,path,M_DIR-1);
-		s=p+1;
-		cur=&root;
+	if (path == NULL) return NULL;
+	if (path[0] == '/') {
+		strncpy(p, path, M_DIR - 1);
+		s = p + 1;
+		cur = &root;
 	} else return NULL; /* TODO: also process local paths. right now, we are to lazy */
-	p[strlen(p)+1]=0; /* extra terminating 0, to be sure */
-	printf(&quot;processing rest of string %s\n&quot;,s);
-	match=s;
-	while (*s!=0) { /* while search string is not empty */
-		if ((s=index(s,'/'))!=NULL) {
-			s[0]=0; /* mark the slash with space */
-			s++;	/* move to the next */
+	p[strlen(p)+1] = 0; /* extra terminating 0, to be sure */
+	printf(&quot;processing rest of string %s\n&quot;, s);
+	match = s;
+	while (*s != 0) { /* while search string is not empty */
+		if ((s = index(s, '/')) != NULL) {
+			s[0] = 0; /* mark the slash with space */
+			s++; /* move to the next */
 		} else {
-			s=match+strlen(match); /* select terminating 0 */
+			s = match + strlen(match); /* select terminating 0 */
 		}
 		/* parse ... */
-		printf(&quot;looking for a match for %s, rest is %s\n&quot;,match,s);
-		for (i=0;i&lt;cur-&gt;n_sub;i++)
-			if (0==strcmp(cur-&gt;sub[i]-&gt;name,match)) { /* found !! */
-				cur=cur-&gt;sub[i]; /* forward */
-				match=s; /* select next */
+		printf(&quot;looking for a match for %s, rest is %s\n&quot;, match, s);
+		for (i = 0;i &lt; cur-&gt;n_sub;i++)
+			if (0 == strcmp(cur-&gt;sub[i]-&gt;name, match)) { /* found !! */
+				cur = cur-&gt;sub[i]; /* forward */
+				match = s; /* select next */
 				break;
 			}
-		if (i==cur-&gt;n_sub) {
-			printf(&quot;found no match for %s :(\n&quot;,match);
+		if (i == cur-&gt;n_sub) {
+			printf(&quot;found no match for %s :(\n&quot;, match);
 			return NULL; /* not found */
 		}
 	}
@@ -69,55 +69,55 @@
 {
 	int i;
 	t_node *f;
-	if (t-&gt;oid==oid)			return(t);
-	if (t-&gt;objs.str==oid)		return(t);
-	if (t-&gt;objs.close==oid)		return(t);
-	if (t-&gt;objs.select==oid)	return(t);
-	if (t-&gt;objs.title==oid)		return(t);
-	if (t-&gt;objs.titlestr==oid)	return(t);
-	if (t-&gt;type==T_FOLDER)
-		for (i=0;i&lt;t-&gt;n_sub;i++)
-			if ((f=node_getbyoid(t-&gt;sub[i],oid))!=NULL)
+	if (t-&gt;oid == oid)   return(t);
+	if (t-&gt;objs.str == oid)  return(t);
+	if (t-&gt;objs.close == oid)  return(t);
+	if (t-&gt;objs.select == oid) return(t);
+	if (t-&gt;objs.title == oid)  return(t);
+	if (t-&gt;objs.titlestr == oid) return(t);
+	if (t-&gt;type == T_FOLDER)
+		for (i = 0;i &lt; t-&gt;n_sub;i++)
+			if ((f = node_getbyoid(t-&gt;sub[i], oid)) != NULL)
 				return(f);
 	return(NULL);
 }
 /* writes the path of dir into *path. path should be of type path[M_DIR] */
 void node_path(t_node *dir, char *path)
 {
-	if (dir-&gt;parent!=NULL) {
-		node_path(dir-&gt;parent,path);
-		if (dir-&gt;parent-&gt;parent!=NULL)
-			mstrncat(path,&quot;/&quot;,M_DIR);
-		mstrncat(path,dir-&gt;name,M_DIR);
+	if (dir-&gt;parent != NULL) {
+		node_path(dir-&gt;parent, path);
+		if (dir-&gt;parent-&gt;parent != NULL)
+			mstrncat(path, &quot;/&quot;, M_DIR);
+		mstrncat(path, dir-&gt;name, M_DIR);
 	} else
-		mstrncpy(path,dir-&gt;name,M_DIR);
+		mstrncpy(path, dir-&gt;name, M_DIR);
 }
 /* clear the node */
 int node_init(t_node *dir)
 {
-	dir-&gt;parent=NULL;
-	dir-&gt;sub=NULL;
-	dir-&gt;n_sub=0;
+	dir-&gt;parent = NULL;
+	dir-&gt;sub = NULL;
+	dir-&gt;n_sub = 0;
 
-	dir-&gt;oid=-1;
-	dir-&gt;objs.str=-1;
-	dir-&gt;objs.close=-1;
-	dir-&gt;objs.select=-1;
-	dir-&gt;objs.title=-1;
-	dir-&gt;objs.titlestr=-1;
-	dir-&gt;objs.strlen=0;
+	dir-&gt;oid = -1;
+	dir-&gt;objs.str = -1;
+	dir-&gt;objs.close = -1;
+	dir-&gt;objs.select = -1;
+	dir-&gt;objs.title = -1;
+	dir-&gt;objs.titlestr = -1;
+	dir-&gt;objs.strlen = 0;
 
-	dir-&gt;disp=D_NONE;
-	dir-&gt;parsed=0;
+	dir-&gt;disp = D_NONE;
+	dir-&gt;parsed = 0;
 
-	dir-&gt;pindex=-1;
-	dir-&gt;check=0;
-	dir-&gt;dirs_opened=0;
-	dir-&gt;type=T_DUNO;
-	dir-&gt;px=dir-&gt;py=dir-&gt;pz=0.0;
-	dir-&gt;dpx=dir-&gt;dpy=dir-&gt;dpz=0.0;
-	dir-&gt;scale=dir-&gt;dscale=1.0;
-	dir-&gt;detached=0;
+	dir-&gt;pindex = -1;
+	dir-&gt;check = 0;
+	dir-&gt;dirs_opened = 0;
+	dir-&gt;type = T_DUNO;
+	dir-&gt;px = dir-&gt;py = dir-&gt;pz = 0.0;
+	dir-&gt;dpx = dir-&gt;dpy = dir-&gt;dpz = 0.0;
+	dir-&gt;scale = dir-&gt;dscale = 1.0;
+	dir-&gt;detached = 0;
 
 	return(0);
 }
@@ -134,25 +134,25 @@
 	default:
 		return(-1);
 	}
-	dir-&gt;disp=0;
+	dir-&gt;disp = 0;
 }
 
 /* delete a node and all its kids internally, remove the graphics, reorder the parents etc ... */
 int node_delete(t_node *dir)
 {
 	int i;
-	if (dir-&gt;parent==NULL) {
+	if (dir-&gt;parent == NULL) {
 		printf(&quot;won't delete root window!\n&quot;);
 		return(-1);
 	}
 	/* delete all the kids */
-	if (dir-&gt;n_sub&gt;0) {
-		for (i=0;i&lt;dir-&gt;n_sub;i++)
+	if (dir-&gt;n_sub &gt; 0) {
+		for (i = 0;i &lt; dir-&gt;n_sub;i++)
 			node_delete(dir-&gt;sub[i]);
 		free(dir-&gt;sub);
 	}
 	/* move focus upward, this should go up with the recursion */
-	if (focus==dir)	focus_set(dir-&gt;parent); /* do this before deleting the contents, its better ... */
+	if (focus == dir) focus_set(dir-&gt;parent); /* do this before deleting the contents, its better ... */
 	switch (dir-&gt;disp) {
 	case D_DIR:
 		box_undisplay(dir);
@@ -160,7 +160,7 @@
 		icon_undisplay(dir);
 	}
 
-	if (-1!=(i=ani_onstack(dir))) ani_del(i); /* tell animation stack too */
+	if (-1 != (i = ani_onstack(dir))) ani_del(i); /* tell animation stack too */
 	free(dir);
 	return(0);
 }
@@ -168,23 +168,23 @@
 void node_select(t_node *dir)
 {
 
-	dir-&gt;detached=dir-&gt;detached?0:1; /* swapping, not sure if !dir-&gt;detached would do the same .. */
+	dir-&gt;detached = dir-&gt;detached ? 0 : 1; /* swapping, not sure if !dir-&gt;detached would do the same .. */
 	switch (dir-&gt;disp) {
 	case D_DIR:
-		if (focus!=dir) {
-			dir-&gt;detached=dir-&gt;detached?0:1; /* swap again, we actually don't want to have it detachedf now. */
+		if (focus != dir) {
+			dir-&gt;detached = dir-&gt;detached ? 0 : 1; /* swap again, we actually don't want to have it detachedf now. */
 			focus_set(dir);
 		}
-		if (dir-&gt;parent!=NULL)
+		if (dir-&gt;parent != NULL)
 			box_order_subdirs(dir-&gt;parent);
 		break;
 	case D_ICON:
-		if (dir-&gt;type==T_FOLDER) {
-			dir-&gt;detached=0;
+		if (dir-&gt;type == T_FOLDER) {
+			dir-&gt;detached = 0;
 			if (!parse_dir(dir))
 				box_expand(dir);
 		} else {
-			dir-&gt;pz=dir-&gt;detached*0.2+1.0;
+			dir-&gt;pz = dir-&gt;detached * 0.2 + 1.0;
 			ani_add(dir);
 		}
 		focus_set(dir);
@@ -196,16 +196,16 @@
 {
 	switch (node-&gt;disp) {
 	case D_DIR:
-		box_focus_color(node,on);
+		box_focus_color(node, on);
 		break;
 	case D_ICON:
-		icon_focus_color(node,on);
+		icon_focus_color(node, on);
 		break;
 	}
 }
 /* get the directory of a node */
 t_node *node_getdir(t_node *node)
 {
-	if (node-&gt;type==T_FOLDER) return(node);
+	if (node-&gt;type == T_FOLDER) return(node);
 	else return(node-&gt;parent);
 }

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/parse.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,83 +26,83 @@
 #include &lt;stdio.h&gt;   /*  printf() */
 #include &lt;dirent.h&gt;  /*  dirent */
 #include &lt;string.h&gt;  /*  strlen(), strncmp(), strrchr() */
-#include &lt;stdlib.h&gt;	 /*  realloc () */
+#include &lt;stdlib.h&gt;  /*  realloc () */
 
 
 int parse_dir(t_node *dir)
 {
 	struct dirent **namelist;
-	int n,i;
+	int n, i;
 	int oldn;
-	DIR	 *dirhd=NULL;
-	char *ext,*nstr=NULL;
+	DIR  *dirhd = NULL;
+	char *ext, *nstr = NULL;
 	char path[M_DIR];
 	char ndir[M_DIR];
 
-	printf(&quot;parse_dir( %s )\n&quot;,dir-&gt;name);
-	node_path(dir,path);
-	for (i=0;i&lt;dir-&gt;n_sub;i++) {
-		dir-&gt;sub[i]-&gt;check=1;
+	printf(&quot;parse_dir( %s )\n&quot;, dir-&gt;name);
+	node_path(dir, path);
+	for (i = 0;i &lt; dir-&gt;n_sub;i++) {
+		dir-&gt;sub[i]-&gt;check = 1;
 	}
 	n = i = scandir(path, &amp;namelist, 0, alphasort);
 	if (n &lt; 0) {
 		window_fs_errno(path);
 		return(-1);
 	} else {
-		oldn=dir-&gt;n_sub;
+		oldn = dir-&gt;n_sub;
 		while (n--) {
 			nstr = namelist[n]-&gt;d_name;
 			/* setup kids in the sub */
-			for (i=0;i&lt;oldn;i++) /* see if it's already there */
+			for (i = 0;i &lt; oldn;i++) /* see if it's already there */
 				if (dir-&gt;sub[i])
-					if (0==strcmp(namelist[n]-&gt;d_name,dir-&gt;sub[i]-&gt;name))
+					if (0 == strcmp(namelist[n]-&gt;d_name, dir-&gt;sub[i]-&gt;name))
 						break;
-			if ((0!=strcmp(nstr,&quot;.&quot;)) &amp;&amp; (0!=strcmp(nstr,&quot;..&quot;))) { /* we don't care about those */
-				if (i==oldn) {	/* it's new, add it, initialize it ... */
-					i=dir-&gt;n_sub;
+			if ((0 != strcmp(nstr, &quot;.&quot;)) &amp;&amp; (0 != strcmp(nstr, &quot;..&quot;))) { /* we don't care about those */
+				if (i == oldn) { /* it's new, add it, initialize it ... */
+					i = dir-&gt;n_sub;
 					/* i now holds the right index in sub, so we use dir-&gt;sub[i]
 					 * to reference the new item now... */
 					dir-&gt;n_sub++;
-					dir-&gt;sub = realloc( dir-&gt;sub , dir-&gt;n_sub * sizeof(t_node *) );
+					dir-&gt;sub = realloc(dir-&gt;sub , dir-&gt;n_sub * sizeof(t_node *));
 					dir-&gt;sub[i] = malloc(sizeof(t_node));
 					node_init(dir-&gt;sub[i]);
-					strncpy(dir-&gt;sub[i]-&gt;name,nstr,M_NAME);
+					strncpy(dir-&gt;sub[i]-&gt;name, nstr, M_NAME);
 					dir-&gt;sub[i]-&gt;parent = dir;
 				}
 				/* find out the filetype ... very simple */
-				dir-&gt;sub[i]-&gt;type=T_DUNO;
-				dir-&gt;sub[i]-&gt;pindex=i;
-				ext=strrchr(nstr,'.');
-				strncpy(ndir,path,M_DIR);
-				strncat(ndir,namelist[n]-&gt;d_name,M_DIR);
-				if ((namelist[n]-&gt;d_type==DT_DIR) || ((namelist[n]-&gt;d_type==DT_UNKNOWN)))
-					if ((dirhd=opendir(ndir))!=NULL) {
-						dir-&gt;sub[i]-&gt;type=T_FOLDER;
+				dir-&gt;sub[i]-&gt;type = T_DUNO;
+				dir-&gt;sub[i]-&gt;pindex = i;
+				ext = strrchr(nstr, '.');
+				strncpy(ndir, path, M_DIR);
+				strncat(ndir, namelist[n]-&gt;d_name, M_DIR);
+				if ((namelist[n]-&gt;d_type == DT_DIR) || ((namelist[n]-&gt;d_type == DT_UNKNOWN)))
+					if ((dirhd = opendir(ndir)) != NULL) {
+						dir-&gt;sub[i]-&gt;type = T_FOLDER;
 						closedir(dirhd);
 					} /*else if (ext!=NULL)
-					   {
-						   if (0==strncmp(ext,&quot;.3ds&quot;,strlen(ext)&lt;4?strlen(ext):4))		   dir-&gt;sub[i]-&gt;type=T_GEOMETRY;
-						   else if (0==strncmp(ext,&quot;.mp3&quot;,strlen(ext)&lt;4?strlen(ext):4))	   dir-&gt;sub[i]-&gt;type=T_MUSIC;
-						   }	*/
-				dir-&gt;sub[i]-&gt;check=0; /* check=0 means we've already processed this item */
+        {
+         if (0==strncmp(ext,&quot;.3ds&quot;,strlen(ext)&lt;4?strlen(ext):4))     dir-&gt;sub[i]-&gt;type=T_GEOMETRY;
+         else if (0==strncmp(ext,&quot;.mp3&quot;,strlen(ext)&lt;4?strlen(ext):4))    dir-&gt;sub[i]-&gt;type=T_MUSIC;
+         } */
+				dir-&gt;sub[i]-&gt;check = 0; /* check=0 means we've already processed this item */
 			}
 			free(namelist[n]);
 		}
 		free(namelist);
-		dir-&gt;check=0;
-		for (i=0;i&lt;dir-&gt;n_sub;i++)
+		dir-&gt;check = 0;
+		for (i = 0;i &lt; dir-&gt;n_sub;i++)
 			if (dir-&gt;sub[i]-&gt;check) {
 				/* not checked yet... that means the item is not in the reparsed directory, ie vanished.
 				 * so we're removing it from our queue */
 				node_delete(dir-&gt;sub[i]);
 				dir-&gt;n_sub--;
-				dir-&gt;sub[i]=dir-&gt;sub[dir-&gt;n_sub]; /* exchange with the last one */
-				dir-&gt;sub[i]-&gt;pindex=i;
-				dir-&gt;check=1;
+				dir-&gt;sub[i] = dir-&gt;sub[dir-&gt;n_sub]; /* exchange with the last one */
+				dir-&gt;sub[i]-&gt;pindex = i;
+				dir-&gt;check = 1;
 			}
 		/* if we removed something, then shrink the buffer accordingly .. */
-		if (dir-&gt;check)		dir-&gt;sub = realloc( dir-&gt;sub , dir-&gt;n_sub * sizeof(t_node *) );
-		dir-&gt;parsed=1;
+		if (dir-&gt;check)  dir-&gt;sub = realloc(dir-&gt;sub , dir-&gt;n_sub * sizeof(t_node *));
+		dir-&gt;parsed = 1;
 	}
 	return(0);
 }

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/s3dfm.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,69 +24,69 @@
 
 #include &lt;s3d.h&gt;
 #include &lt;s3dw.h&gt;
-#include &lt;stdlib.h&gt;		/* uintXX_t */
-#define T_DUNO		0
-#define T_FOLDER	1
-#define T_TYPENUM	2
+#include &lt;stdlib.h&gt;  /* uintXX_t */
+#define T_DUNO  0
+#define T_FOLDER 1
+#define T_TYPENUM 2
 
-#define M_DIR		512
-#define M_NAME		256
+#define M_DIR  512
+#define M_NAME  256
 
 /* total height of the block */
-#define BOXHEIGHT	1.2
-#define BHP			1.001
-#define BHH			BOXHEIGHT+0.001
+#define BOXHEIGHT 1.2
+#define BHP   1.001
+#define BHH   BOXHEIGHT+0.001
 /* how much should detached dirs move away from parent block */
-#define DETHEIGHT	0.3
+#define DETHEIGHT 0.3
 
 /* maximum size of the animation stack */
-#define MAXANI		1024
-#define ZOOMS 		10
+#define MAXANI  1024
+#define ZOOMS   10
 /* zoomspeed */
 
 struct _t_node {
-	char 			 name[M_NAME];						/* name (e.g. file name) */
-	struct _t_node 	*parent;							/* parent node */
-	struct _t_node 	**sub;								/* list of nodes  (if it's a subdir)*/
-	int 			 n_sub;								/* number of nodes in list ( = -1 for normal or not-expanded files) */
-	int 			 dirs_opened;						/* how many dirs are opened/displayed */
-	float 			 px ,py ,pz ,scale;					/* state after animation */
-	float 			 dpx,dpy,dpz,dscale;				/* current state in animation */
-	int 			 type;								/* type, determined by extension or file type like dir, pipe, link etc */
-	int 			 disp;								/* the type of how the node is displayed currently */
-#define D_NONE		0
-#define D_ICON		1
-#define D_DIR		2
-	int				 parsed,detached;					/* Flags for parsed/detached (selected) nodes ... */
-	int 			 oid;								/* main oid, e.g the block or icons oid */
-	int 			 pindex;							/* the index in parents structure */
-	struct 			 {
+	char     name[M_NAME];      /* name (e.g. file name) */
+	struct _t_node  *parent;       /* parent node */
+	struct _t_node  **sub;        /* list of nodes  (if it's a subdir)*/
+	int     n_sub;        /* number of nodes in list ( = -1 for normal or not-expanded files) */
+	int     dirs_opened;      /* how many dirs are opened/displayed */
+	float     px , py , pz , scale;  /* state after animation */
+	float     dpx, dpy, dpz, dscale; /* current state in animation */
+	int     type;        /* type, determined by extension or file type like dir, pipe, link etc */
+	int     disp;        /* the type of how the node is displayed currently */
+#define D_NONE  0
+#define D_ICON  1
+#define D_DIR  2
+	int     parsed, detached;    /* Flags for parsed/detached (selected) nodes ... */
+	int     oid;        /* main oid, e.g the block or icons oid */
+	int     pindex;       /* the index in parents structure */
+	struct     {
 		/* some objects which might be used ... if not, should be -1 */
-		int 		 close,select,title,titlestr; /* box decorations. */
-		int 		 str;						  /* the name of the nodeas s3d object */
-		float		 strlen;					  /* the length of this string */
+		int    close, select, title, titlestr; /* box decorations. */
+		int    str;        /* the name of the nodeas s3d object */
+		float   strlen;       /* the length of this string */
 
 
-	} 				 objs;
-	int 			 check;							    /* check marker, for internal things */
+	}      objs;
+	int     check;           /* check marker, for internal things */
 };
 struct _t_file {
 	char *name;
-	int size,state;
+	int size, state;
 	struct _t_node *anode;
 };
 enum {
-	STATE_NONE, 		/* nothing happned */
-	STATE_INUSE, 		/* currently processing */
-	STATE_FINISHED, 	/* file operation finished */
-	STATE_CLEANED		/* cleaned (e.g. reordered the item */
+	STATE_NONE,   /* nothing happned */
+	STATE_INUSE,   /* currently processing */
+	STATE_FINISHED,  /* file operation finished */
+	STATE_CLEANED  /* cleaned (e.g. reordered the item */
 };
 struct _filelist {
 	struct _t_file *p;
 	int n;
 };
 struct fs_error {
-	int err,state;
+	int err, state;
 	char *message, *file;
 };
 enum {
@@ -98,11 +98,11 @@
 };
 typedef struct _filelist filelist;
 typedef struct _t_node   t_node;
-typedef struct _t_file	 t_file;
+typedef struct _t_file  t_file;
 
 
-extern t_node root,cam; /* some global objects */
-extern t_node *focus;	/* the focused object */
+extern t_node root, cam; /* some global objects */
+extern t_node *focus; /* the focused object */
 extern struct fs_error fs_err;
 
 enum {
@@ -116,82 +116,82 @@
 extern int fs_lock;
 
 /* animation.c */
-int 		 ani_onstack(t_node *f);
-void 		 ani_add(t_node *f);
-void 		 ani_del(int i);
-void 		 ani_doit(t_node *f);
-void 		 ani_finish(t_node *f, int i);
-void 		 ani_iterate(t_node *f);
-int 		 ani_check(t_node *f);
-void 		 ani_mate();
+int    ani_onstack(t_node *f);
+void    ani_add(t_node *f);
+void    ani_del(int i);
+void    ani_doit(t_node *f);
+void    ani_finish(t_node *f, int i);
+void    ani_iterate(t_node *f);
+int    ani_check(t_node *f);
+void    ani_mate();
 /* box.c */
-void	 	 box_draw(t_node *dir);
-void 	 	 box_draw_icons(t_node *dir);
-int 		 box_undisplay(t_node *dir);
-void  		 box_order_icons(t_node *dir);
-void	 	 box_sidelabel(t_node *dir);
-int 		 box_buildblock(t_node *dir);
-void 		 box_order_subdirs(t_node *dir);
-int 		 box_expand(t_node *dir);
-int 		 box_unexpand(t_node *dir);
-int 		 box_close(t_node *dir,int force);
-void 		 box_focus_color(t_node *dir, int on);
+void    box_draw(t_node *dir);
+void     box_draw_icons(t_node *dir);
+int    box_undisplay(t_node *dir);
+void     box_order_icons(t_node *dir);
+void    box_sidelabel(t_node *dir);
+int    box_buildblock(t_node *dir);
+void    box_order_subdirs(t_node *dir);
+int    box_expand(t_node *dir);
+int    box_unexpand(t_node *dir);
+int    box_close(t_node *dir, int force);
+void    box_focus_color(t_node *dir, int on);
 /* dialog.c */
-void		 close_win(s3dw_widget *button);
-void		 window_help();
-void 		 window_fs(s3dw_widget *button);
-void		 window_fs_another();
-void		 window_fs_nothing();
-void		 window_fs_errno(char *errmsg);
-void		 window_fs_abort(s3dw_widget *button);
-void		 window_copy(char *path);
-void		 window_fs_mkdir(s3dw_widget *button);
-void		 window_mkdir(char *path);
-void		 window_move(char *path);
-void		 window_info(char *path);
-void		 window_fsani();
-void 		 window_unlink();
+void   close_win(s3dw_widget *button);
+void   window_help();
+void    window_fs(s3dw_widget *button);
+void   window_fs_another();
+void   window_fs_nothing();
+void   window_fs_errno(char *errmsg);
+void   window_fs_abort(s3dw_widget *button);
+void   window_copy(char *path);
+void   window_fs_mkdir(s3dw_widget *button);
+void   window_mkdir(char *path);
+void   window_move(char *path);
+void   window_info(char *path);
+void   window_fsani();
+void    window_unlink();
 /* event.c */
-int 		 event_click(struct s3d_evt *evt);
-int			 event_key(struct s3d_evt *evt);
-int			 event_oinfo(struct s3d_evt *hrmz);
+int    event_click(struct s3d_evt *evt);
+int    event_key(struct s3d_evt *evt);
+int    event_oinfo(struct s3d_evt *hrmz);
 /* focus.c */
-void 		 focus_by_key(int keysym);
-float		 focus_get_scale(t_node *f);
-void 		 focus_set(t_node *f);
+void    focus_by_key(int keysym);
+float   focus_get_scale(t_node *f);
+void    focus_set(t_node *f);
 /* fs.c */
-filelist	 *fl_new(char *path);
-void		 fl_del(filelist *fl);
-void	 	 fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes);
-int			 fs_fl_copy(filelist *fl, char *dest);
-int			 fs_fl_move(filelist *fl, char *dest);
-int			 fs_fl_unlink(filelist *fl);
-void	 	 fs_approx(char *source, int *files, int *dirs, int *bytes);
-int			 fs_copy(char *source, char *dest);
-int			 fs_move(char *source, char *dest);
-int			 fs_unlink(char *dest);
-int 		 fs_error(char *message, char *file);
+filelist  *fl_new(char *path);
+void   fl_del(filelist *fl);
+void    fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes);
+int    fs_fl_copy(filelist *fl, char *dest);
+int    fs_fl_move(filelist *fl, char *dest);
+int    fs_fl_unlink(filelist *fl);
+void    fs_approx(char *source, int *files, int *dirs, int *bytes);
+int    fs_copy(char *source, char *dest);
+int    fs_move(char *source, char *dest);
+int    fs_unlink(char *dest);
+int    fs_error(char *message, char *file);
 /* icon.c */
-int 		 icon_draw(t_node *dir);
-int 		 icon_undisplay(t_node *dir);
-void 		 icon_focus_color(t_node *dir, int on);
+int    icon_draw(t_node *dir);
+int    icon_undisplay(t_node *dir);
+void    icon_focus_color(t_node *dir, int on);
 /* node.c */
-t_node 		*node_getbypath(char *path);
-void 		 node_path(t_node *dir, char *path);
-t_node 		*node_getbyoid(t_node *t, int oid);
-int 		 node_init(t_node *dir);
-int 		 node_delete(t_node *dir);
-int 		 node_undisplay(t_node *dir);
-void		 node_select(t_node *dir);
-void 		 node_focus_color(t_node *node, int on);
-t_node		*node_getdir(t_node *node);
+t_node   *node_getbypath(char *path);
+void    node_path(t_node *dir, char *path);
+t_node   *node_getbyoid(t_node *t, int oid);
+int    node_init(t_node *dir);
+int    node_delete(t_node *dir);
+int    node_undisplay(t_node *dir);
+void   node_select(t_node *dir);
+void    node_focus_color(t_node *node, int on);
+t_node  *node_getdir(t_node *node);
 /* parse.c */
-int 		 parse_dir(t_node *dir);
+int    parse_dir(t_node *dir);
 /* string.c */
-void		 dotted_int(char *s,unsigned int i);
-char 		*dots_at_start(char *str, unsigned int n, t_node *d);
-char		*mstrncat(char *dest, const char *src, int n);
-char		*mstrncpy(char *dest, const char *src, int n);
+void   dotted_int(char *s, unsigned int i);
+char   *dots_at_start(char *str, unsigned int n, t_node *d);
+char  *mstrncat(char *dest, const char *src, int n);
+char  *mstrncpy(char *dest, const char *src, int n);
 /* fly.c */
-int 		 fly_set_absolute_position(t_node *node);
-t_node 		*fly_create_anode(t_node *node);
+int    fly_set_absolute_position(t_node *node);
+t_node   *fly_create_anode(t_node *node);

Modified: trunk/apps/s3dfm/string.c
===================================================================
--- trunk/apps/s3dfm/string.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/string.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -31,73 +31,73 @@
  * adds some dots to the beginning if its too long */
 char *dots_at_start(char *str, unsigned int n, t_node *d)
 {
-	char *s=str;
-	int i,j;
-	i=n-2;
-	s[n-1]=0;
+	char *s = str;
+	int i, j;
+	i = n - 2;
+	s[n-1] = 0;
 	do {
-		j=strlen(d-&gt;name)-1;
-		if (NULL!=(d-&gt;parent)) {
-			s[i]='/';
+		j = strlen(d-&gt;name) - 1;
+		if (NULL != (d-&gt;parent)) {
+			s[i] = '/';
 			i--;
 		}
 		while ((i &gt;= 0) &amp;&amp; (j &gt;= 0)) {
-			s[i]=d-&gt;name[j];
+			s[i] = d-&gt;name[j];
 			j--;
 			i--;
 		}
-		if (i&lt;0)
+		if (i &lt; 0)
 			break;
-	} while ((d=d-&gt;parent)!=NULL);
-	if (i&lt;0)			s[0]=s[1]='.';
-	else 				s=(char *)s+i+1; /* jump to start of the string */
+	} while ((d = d-&gt;parent) != NULL);
+	if (i &lt; 0)   s[0] = s[1] = '.';
+	else     s = (char *)s + i + 1; /* jump to start of the string */
 	return(s);
 
 }
 /* add some dots to an integer value for better readability */
-void dotted_int(char *s,unsigned int i)
+void dotted_int(char *s, unsigned int i)
 {
 	char st[M_DIR];
 	int p;
-	p=0;
-	st[0]=0;
-	while (i&gt;0) {
-		if ((p+1)%4==0) {
-			st[p]='.';
+	p = 0;
+	st[0] = 0;
+	while (i &gt; 0) {
+		if ((p + 1) % 4 == 0) {
+			st[p] = '.';
 			p++;
 		}
-		st[p]=(i%10)+'0';
-		i=i/10;
+		st[p] = (i % 10) + '0';
+		i = i / 10;
 		p++;
 	}
-	if (p&gt;0) p--;
-	st[p+1]=0;
-	for (i=0;i&lt;p+1;i++)
-		s[i]=st[p-i];
-	s[p+1]=0;
+	if (p &gt; 0) p--;
+	st[p+1] = 0;
+	for (i = 0;i &lt; p + 1;i++)
+		s[i] = st[p-i];
+	s[p+1] = 0;
 }
 /* save concatting 2 strings, this version takes argument n
  * as the size of the buffer of dest. */
 char *mstrncat(char *dest, const char *src, int n)
 {
-	int i,j;
-	dest[n-1]=0;						/* for malformed destinations */
-	j=0;
-	for (i=strlen(dest);i&lt;(n-1);i++) {
-		dest[i]=src[j];
-		if (dest[i]==0) break;
+	int i, j;
+	dest[n-1] = 0;    /* for malformed destinations */
+	j = 0;
+	for (i = strlen(dest);i &lt; (n - 1);i++) {
+		dest[i] = src[j];
+		if (dest[i] == 0) break;
 		j++;
 	}
-	for (;i&lt;n;i++)
-		dest[i]=0; /* pad the rest with zero */
+	for (;i &lt; n;i++)
+		dest[i] = 0; /* pad the rest with zero */
 	return(dest);
 }
 /* same as strncpy, but have a terminating zero even if
  * source is too big */
 char *mstrncpy(char *dest, const char *src, int n)
 {
-	strncpy(dest,src,n);
-	dest[n-1]=0;
+	strncpy(dest, src, n);
+	dest[n-1] = 0;
 	return(dest);
 }
 

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/db.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,30 +25,30 @@
 #include &quot;s3dosm.h&quot;
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt; /* stdup() */
-#include &lt;unistd.h&gt;	/* unlink() */
-#include &lt;stdlib.h&gt;	/* atoi() */
+#include &lt;unistd.h&gt; /* unlink() */
+#include &lt;stdlib.h&gt; /* atoi() */
 static char qbuf[QBUF];
-static int qlen=0;
-static int tagid=1;		/* tagid, incremented with each new object */
+static int qlen = 0;
+static int tagid = 1;  /* tagid, incremented with each new object */
 
 static sqlite3 *db;
-static char *dbFile=NULL;
+static char *dbFile = NULL;
 int db_exec(const char *query, sqlite3_callback callback, void *arg);
 
 /* TODO: remove '' for security reasons */
 void clean_string(char *clean, char *dirty, int n)
 {
 	strncpy(clean, dirty, n);
-	clean[n-1]=0;
+	clean[n-1] = 0;
 }
 
 int db_add_tag(object_t *obj, char *key, char *val)
 {
 	char tagquery[MAXQ];
 	char mkey[MAXQ], mval[MAXQ];
-	clean_string(mkey,key,MAXQ);
-	clean_string(mval,val,MAXQ);
-	snprintf(tagquery,MAXQ,&quot;INSERT INTO tag VALUES (%d, '%s','%s' );&quot;,(int)obj-&gt;tagid, mkey, mval);
+	clean_string(mkey, key, MAXQ);
+	clean_string(mval, val, MAXQ);
+	snprintf(tagquery, MAXQ, &quot;INSERT INTO tag VALUES (%d, '%s','%s' );&quot;, (int)obj-&gt;tagid, mkey, mval);
 	db_exec(tagquery, NULL, 0);
 	return(0);
 }
@@ -56,14 +56,14 @@
 int db_insert_node(node_t *node)
 {
 	char addquery[MAXQ];
-	node-&gt;base.tagid= tagid++;
+	node-&gt;base.tagid = tagid++;
 
-	if (node-&gt;base.id==0) /* give own id */
-		snprintf(addquery,MAXQ,&quot;INSERT INTO node (layer_id, latitude, longitude, altitude, visible, tag_id) VALUES (%d, %f, %f, %f, %d, %d);&quot;,
-		         (int)node-&gt;base.layerid,				node-&gt;lat,		node-&gt;lon,		node-&gt;alt,		node-&gt;visible, 		(int)node-&gt;base.tagid);
+	if (node-&gt;base.id == 0) /* give own id */
+		snprintf(addquery, MAXQ, &quot;INSERT INTO node (layer_id, latitude, longitude, altitude, visible, tag_id) VALUES (%d, %f, %f, %f, %d, %d);&quot;,
+		         (int)node-&gt;base.layerid,    node-&gt;lat,  node-&gt;lon,  node-&gt;alt,  node-&gt;visible, (int)node-&gt;base.tagid);
 	else
-		snprintf(addquery,MAXQ,&quot;INSERT INTO node (layer_id, node_id,latitude, longitude, altitude, visible, tag_id) VALUES (%d, %d, %f, %f, %f, %d, %d);&quot;,
-		         (int)node-&gt;base.layerid,(int)node-&gt;base.id,	node-&gt;lat,		node-&gt;lon,		node-&gt;alt,		node-&gt;visible, 		(int)node-&gt;base.tagid);
+		snprintf(addquery, MAXQ, &quot;INSERT INTO node (layer_id, node_id,latitude, longitude, altitude, visible, tag_id) VALUES (%d, %d, %f, %f, %f, %d, %d);&quot;,
+		         (int)node-&gt;base.layerid, (int)node-&gt;base.id, node-&gt;lat,  node-&gt;lon,  node-&gt;alt,  node-&gt;visible, (int)node-&gt;base.tagid);
 
 	db_exec(addquery, NULL, 0);
 	return(0);
@@ -72,19 +72,19 @@
 int db_insert_segment(segment_t *seg)
 {
 	char addquery[MAXQ];
-	seg-&gt;base.tagid=tagid++;
+	seg-&gt;base.tagid = tagid++;
 
 
-	if (seg-&gt;base.id==0) { /* give own id */
+	if (seg-&gt;base.id == 0) { /* give own id */
 		printf(&quot;ugh, segment id is 0!\n&quot;);
 		exit(0);
 	}
-	/*	if (seg-&gt;base.id==0) / * give own id * /
-			snprintf(addquery,MAXQ,&quot;INSERT INTO segment (layer_id, node_from, node_to, tag_id) VALUES (%d, %d, %d), %d;&quot;,
-							(int)seg-&gt;base.layerid,				(int)seg-&gt;from, (int)seg-&gt;to,	tagid );
-		else*/
-	snprintf(addquery,MAXQ,&quot;INSERT INTO segment (layer_id, seg_id, node_from, node_to, tag_id) VALUES (%d, %d, %d, %d, %d);&quot;,
-	         (int)seg-&gt;base.layerid,(int)seg-&gt;base.id,(int)seg-&gt;from, (int)seg-&gt;to,	(int)seg-&gt;base.tagid );
+	/* if (seg-&gt;base.id==0) / * give own id * /
+	  snprintf(addquery,MAXQ,&quot;INSERT INTO segment (layer_id, node_from, node_to, tag_id) VALUES (%d, %d, %d), %d;&quot;,
+	      (int)seg-&gt;base.layerid,    (int)seg-&gt;from, (int)seg-&gt;to, tagid );
+	 else*/
+	snprintf(addquery, MAXQ, &quot;INSERT INTO segment (layer_id, seg_id, node_from, node_to, tag_id) VALUES (%d, %d, %d, %d, %d);&quot;,
+	         (int)seg-&gt;base.layerid, (int)seg-&gt;base.id, (int)seg-&gt;from, (int)seg-&gt;to, (int)seg-&gt;base.tagid);
 	db_exec(addquery, NULL, 0);
 
 	return(0);
@@ -93,8 +93,8 @@
 int db_insert_way_only(way_t *way)
 {
 	char addquery[MAXQ];
-	way-&gt;base.tagid= tagid++;
-	snprintf(addquery,MAXQ,&quot;INSERT INTO way (layer_id, way_id, tag_id) VALUES (%d, %d, %d);&quot;,(int)way-&gt;base.layerid, (int)way-&gt;base.id, (int)way-&gt;base.tagid );
+	way-&gt;base.tagid = tagid++;
+	snprintf(addquery, MAXQ, &quot;INSERT INTO way (layer_id, way_id, tag_id) VALUES (%d, %d, %d);&quot;, (int)way-&gt;base.layerid, (int)way-&gt;base.id, (int)way-&gt;base.tagid);
 	db_exec(addquery, NULL, 0);
 	return(0);
 }
@@ -102,7 +102,7 @@
 int db_insert_way_seg(way_t *way, int seg_n)
 {
 	char addquery[MAXQ];
-	snprintf(addquery,MAXQ,&quot;UPDATE segment SET way_id=%d WHERE seg_id=%d AND layer_id=%d;&quot;,(int)way-&gt;base.id,seg_n,(int)way-&gt;base.layerid );
+	snprintf(addquery, MAXQ, &quot;UPDATE segment SET way_id=%d WHERE seg_id=%d AND layer_id=%d;&quot;, (int)way-&gt;base.id, seg_n, (int)way-&gt;base.layerid);
 	db_exec(addquery, NULL, 0);
 	return(0);
 }
@@ -112,12 +112,12 @@
 	char findquery[MAXQ];
 	char addquery[MAXQ];
 	char clayer[MAXQ];
-	int layerid=-1;
-	clean_string(clayer,layer_name,MAXQ);
+	int layerid = -1;
+	clean_string(clayer, layer_name, MAXQ);
 
 	snprintf(findquery, MAXQ, &quot;SELECT layer_id FROM layer WHERE name='%s';&quot;, clayer);
 	db_exec(findquery, db_getint, &amp;layerid);
-	if (layerid==-1) { /* need to add */
+	if (layerid == -1) { /* need to add */
 		snprintf(addquery, MAXQ, &quot;INSERT INTO layer(name) VALUES ('%s');&quot;, clayer);
 		db_exec(addquery, NULL, 0);
 		db_flush();
@@ -126,78 +126,78 @@
 	return(layerid);
 }
 
-#define MAGIC	1337 /* just to elevate the nodes a little bit */
-static int found=0;
+#define MAGIC 1337 /* just to elevate the nodes a little bit */
+static int found = 0;
 /* tries to find node coordinates of ip, returns 1 if has found something */
 int db_olsr_check(char *ip, float *pos)
 {
 	char findquery[MAXQ];
 	char clean_ip[16];
 	float p[6];
-	char *s=NULL;
-	clean_string(clean_ip,ip,16);
-	if (NULL!=(s=strchr(clean_ip,'/')))  /* don't process ip's with subnet information */
-		*s=0; /* TERMINATING ZERO!! */
+	char *s = NULL;
+	clean_string(clean_ip, ip, 16);
+	if (NULL != (s = strchr(clean_ip, '/')))  /* don't process ip's with subnet information */
+		*s = 0; /* TERMINATING ZERO!! */
 
 	snprintf(findquery, MAXQ, &quot;SELECT latitude, longitude, altitude FROM node WHERE tag_id=(SELECT tag_id FROM tag WHERE tagkey='ip' AND tagvalue='%s');&quot;, clean_ip);
-	found=MAGIC;
+	found = MAGIC;
 	db_exec(findquery, db_getpoint, p);
-	if (found==1) {
-		pos[0]=p[0];
-		pos[1]=p[1];
-		pos[2]=p[2];
-		found=0;
+	if (found == 1) {
+		pos[0] = p[0];
+		pos[1] = p[1];
+		pos[2] = p[2];
+		found = 0;
 		return(1);
 	}
-	found=0;
+	found = 0;
 	return(0);
 }
 
 /* initializes the starting point of nodes  by averaging its lon/lat */
 int db_olsr_node_init(float *pos)
 {
-	found=0;
+	found = 0;
 	db_exec(&quot;SELECT AVG(latitude) as latitude, AVG(longitude) as longitude, AVG(altitude) as altitude FROM node WHERE tag_id IN (SELECT tag_id FROM tag WHERE tagkey='ip');&quot;, db_getpoint, pos);
-	printf(&quot;pos = %3.3f %3.3f %3.3f\n&quot;,pos[0],pos[1],pos[2]);
-	return(0);	/* return 1 if something is found, 0 if pos[0] its still 0 */
+	printf(&quot;pos = %3.3f %3.3f %3.3f\n&quot;, pos[0], pos[1], pos[2]);
+	return(0); /* return 1 if something is found, 0 if pos[0] its still 0 */
 }
 
 
 /* expecting a 3x float vector, returns the points coordinates */
 int db_getpoint(void *data, int argc, char **argv, char **azColName)
 {
-	float lo=0.0,la=0.0,alt=0.0;
-	float *p=data;
+	float lo = 0.0, la = 0.0, alt = 0.0;
+	float *p = data;
 	int i;
-	for (i=0; i&lt;argc; i++) {
+	for (i = 0; i &lt; argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],&quot;longitude&quot;))			lo=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],&quot;latitude&quot;))		la=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],&quot;altitude&quot;))		alt=strtod(argv[i],NULL);
+			if (0 == strcmp(azColName[i], &quot;longitude&quot;))   lo = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], &quot;latitude&quot;))  la = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], &quot;altitude&quot;))  alt = strtod(argv[i], NULL);
 		}
 	}
-	if (lo==0.0)	{
+	if (lo == 0.0) {
 		printf(&quot;missing lo\n&quot;);
 		exit(0);
 	}
-	if (la==0.0)	{
+	if (la == 0.0) {
 		printf(&quot;missing la\n&quot;);
 		exit(0);
 	}
-	if (found==MAGIC) alt=2;
-	calc_earth_to_eukl(la,lo,alt,p);
-	p[3]=la;
-	p[4]=lo;
-	p[5]=alt;
-	found=1;
+	if (found == MAGIC) alt = 2;
+	calc_earth_to_eukl(la, lo, alt, p);
+	p[3] = la;
+	p[4] = lo;
+	p[5] = alt;
+	found = 1;
 	return(0);
 }
 
 /* sqlite3-callback to get an integer of the database */
 int db_getint(void *tagid, int argc, char **argv, char **azColName)
 {
-	if (argv[0]!=NULL)
-		*((int *)tagid)=atoi(argv[0]);
+	if (argv[0] != NULL)
+		*((int *)tagid) = atoi(argv[0]);
 	return 0;
 }
 
@@ -205,7 +205,7 @@
 static int db_getstr(void *string, int argc, char **argv, char **azColName)
 {
 	if (argv[0])
-		strncpy((char *)string,argv[0],MAXQ);
+		strncpy((char *)string, argv[0], MAXQ);
 	return(0);
 }
 
@@ -214,16 +214,16 @@
 int db_gettag(int tagid, char *field, char *target)
 {
 	char query[MAXQ];
-	target[0]=0;
-	snprintf(query,MAXQ,&quot;SELECT tagvalue FROM tag WHERE tagkey='%s' AND tag_id=%d;&quot;,field,tagid);
-	db_exec(query, db_getstr,target);
-	return(target[0]==0);
+	target[0] = 0;
+	snprintf(query, MAXQ, &quot;SELECT tagvalue FROM tag WHERE tagkey='%s' AND tag_id=%d;&quot;, field, tagid);
+	db_exec(query, db_getstr, target);
+	return(target[0] == 0);
 }
 
 int callback(void *NotUsed, int argc, char **argv, char **azColName)
 {
 	int i;
-	for (i=0; i&lt;argc; i++) {
+	for (i = 0; i &lt; argc; i++) {
 		printf(&quot;%s = %s\n&quot;, azColName[i], argv[i] ? argv[i] : &quot;NULL&quot;);
 	}
 	printf(&quot;\n&quot;);
@@ -234,21 +234,21 @@
 {
 	char *zErrMsg = 0;
 	int rc;
-	if (SQLITE_OK !=(  rc = sqlite3_exec(db, query, callback, arg, &amp;zErrMsg))) {
-		fprintf(stderr,&quot;query: %s\n&quot;,query);
+	if (SQLITE_OK != (rc = sqlite3_exec(db, query, callback, arg, &amp;zErrMsg))) {
+		fprintf(stderr, &quot;query: %s\n&quot;, query);
 		fprintf(stderr, &quot;SQL error: %s\n&quot;, zErrMsg);
 		exit(-1);
 	}
-	return(SQLITE_OK!=rc); /* 0 = okay */
+	return(SQLITE_OK != rc); /* 0 = okay */
 }
 
 /* call this if you're finished with a few stackable operations */
 void db_flush()
 {
-	if (qlen&gt;0)
-		db_really_exec(qbuf,NULL,0);
-	qbuf[0]=0;
-	qlen=0;
+	if (qlen &gt; 0)
+		db_really_exec(qbuf, NULL, 0);
+	qbuf[0] = 0;
+	qlen = 0;
 }
 
 int db_exec(const char *query, sqlite3_callback callback, void *arg)
@@ -257,17 +257,17 @@
 #ifdef DB_STACK
 	if (callback == NULL) { /* we can stack it */
 		int len;
-		len=strlen(query);
-		if (len+qlen&gt;=QBUF)
+		len = strlen(query);
+		if (len + qlen &gt;= QBUF)
 			db_flush();
-		strncat(qbuf,query,QBUF);
-		qlen+=strlen(query);
-		ret=0;
+		strncat(qbuf, query, QBUF);
+		qlen += strlen(query);
+		ret = 0;
 	} else
 #endif
 
 	{
-		ret=db_really_exec(query,callback,arg);		/* pass it to the real function */
+		ret = db_really_exec(query, callback, arg);  /* pass it to the real function */
 	}
 	return(ret);
 }
@@ -275,13 +275,13 @@
 int db_init(char *dbFile)
 {
 	int rc;
-	tagid=1;
-	qbuf[0]=0;		/* clear querybuffer */
-	qlen=0;
+	tagid = 1;
+	qbuf[0] = 0;  /* clear querybuffer */
+	qlen = 0;
 
-	unlink(dbFile);	/* remove if already there */
+	unlink(dbFile); /* remove if already there */
 	rc = sqlite3_open(dbFile, &amp;db);
-	if ( rc ) {
+	if (rc) {
 		fprintf(stderr, &quot;Can't open database: %s\n&quot;, sqlite3_errmsg(db));
 		sqlite3_close(db);
 		return(-1);
@@ -292,7 +292,7 @@
 int db_quit()
 {
 	sqlite3_close(db);
-	if (dbFile!=NULL)
+	if (dbFile != NULL)
 		if (unlink(dbFile))
 			perror(&quot;db_quit()&quot;);
 	return(0);
@@ -300,7 +300,7 @@
 
 int db_create()
 {
-	db_exec(&quot;CREATE TABLE node (layer_id INT, node_id INTEGER , latitude DOUBLE PRECISION, longitude DOUBLE PRECISION, altitude DOUBLE PRECISION, visible BOOLEAN, tag_id INT, s3doid INT, PRIMARY KEY(layer_id,node_id));&quot;,NULL,0);
+	db_exec(&quot;CREATE TABLE node (layer_id INT, node_id INTEGER , latitude DOUBLE PRECISION, longitude DOUBLE PRECISION, altitude DOUBLE PRECISION, visible BOOLEAN, tag_id INT, s3doid INT, PRIMARY KEY(layer_id,node_id));&quot;, NULL, 0);
 	db_exec(&quot;CREATE TABLE segment (layer_id INT, seg_id INTEGER, node_from INT, node_to INT, tag_id INT, way_id INT,PRIMARY KEY(layer_id,seg_id));&quot;, NULL, 0);
 	db_exec(&quot;CREATE TABLE way (layer_id INTEGER, way_id INTEGER, tag_id INT, s3doid INT, PRIMARY KEY(layer_id,way_id));&quot;, NULL, 0);
 	db_exec(&quot;CREATE TABLE layer (layer_id INTEGER, name TEXT, PRIMARY KEY(layer_id));&quot;, NULL, 0);

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/draw.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,107 +22,107 @@
  */
 #include &quot;s3dosm.h&quot;
 #include &lt;s3d.h&gt;
-#include &lt;math.h&gt;	/* sin(), cos() */
-#include &lt;stdio.h&gt;	/* printf() */
-#include &lt;string.h&gt;	/* strcmp() */
+#include &lt;math.h&gt; /* sin(), cos() */
+#include &lt;stdio.h&gt; /* printf() */
+#include &lt;string.h&gt; /* strcmp() */
 #include &lt;stdlib.h&gt; /* atoi(),malloc(), calloc(), free() */
 
 static float temp;
-#define		V_COPY(a,b)		a[0]=b[0];	a[1]=b[1];	a[2]=b[2];
-#define 	V_ADD(a,b,c)	c[0]=a[0]+b[0];	c[1]=a[1]+b[1];	c[2]=a[2]+b[2];
-#define 	V_SUB(a,b,c)	c[0]=a[0]-b[0];	c[1]=a[1]-b[1];	c[2]=a[2]-b[2];
-#define		V_DOT(a,b)		a[0]*b[0] + a[1]*b[1] + a[2] * b[2]
-#define		V_CROSS(a,b,c)	c[0]=a[1]*b[2] - a[2]*b[1];		c[1]=a[2]*b[0] - a[0]*b[2]; 	c[2]=a[0]*b[1] - a[1]*b[0];
-#define		V_LEN(a)		sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2])
-#define		V_SCAL(a,s)		a[0]=s*a[0];	a[1]=s*a[1];	a[2]=s*a[2];
-#define		V_NORM(a)		temp=V_LEN(a); V_SCAL(a,1/temp);
+#define  V_COPY(a,b)  a[0]=b[0]; a[1]=b[1]; a[2]=b[2];
+#define  V_ADD(a,b,c) c[0]=a[0]+b[0]; c[1]=a[1]+b[1]; c[2]=a[2]+b[2];
+#define  V_SUB(a,b,c) c[0]=a[0]-b[0]; c[1]=a[1]-b[1]; c[2]=a[2]-b[2];
+#define  V_DOT(a,b)  a[0]*b[0] + a[1]*b[1] + a[2] * b[2]
+#define  V_CROSS(a,b,c) c[0]=a[1]*b[2] - a[2]*b[1];  c[1]=a[2]*b[0] - a[0]*b[2];  c[2]=a[0]*b[1] - a[1]*b[0];
+#define  V_LEN(a)  sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2])
+#define  V_SCAL(a,s)  a[0]=s*a[0]; a[1]=s*a[1]; a[2]=s*a[2];
+#define  V_NORM(a)  temp=V_LEN(a); V_SCAL(a,1/temp);
 
 
-static int num_max;		/* how many results in our query? to calculate pecent done ... */
-static int num_done;	/* how many already done */
+static int num_max;  /* how many results in our query? to calculate pecent done ... */
+static int num_done; /* how many already done */
 
-static int lastid=-1;
+static int lastid = -1;
 /* list element of a segment which is on our way */
 struct waylist {
-	int node_from,node_to;
-	int node_from_int,node_to_int;
+	int node_from, node_to;
+	int node_from_int, node_to_int;
 	int seg_id;
-	int node_from_l,node_from_r;	/* vertex id's for corners */
-	int node_to_l,node_to_r;
+	int node_from_l, node_from_r; /* vertex id's for corners */
+	int node_to_l, node_to_r;
 };
 /* list element of a node which is to be drawn */
 struct nodelist {
-	int node_id;			/* (external counting) */
-	float la,lo,alt;		/* earth coords */
-	float x[3];				/* euclid coords */
+	int node_id;   /* (external counting) */
+	float la, lo, alt;  /* earth coords */
+	float x[3];    /* euclid coords */
 	float normal[3];
 	float len;
 };
 /* list element for adjacent nodes */
 struct adjlist {
-	int node_id;			/* node to which the segment leads to */
-	int seg_id;				/* segment which is involved to the node (both internal counting) */
+	int node_id;   /* node to which the segment leads to */
+	int seg_id;    /* segment which is involved to the node (both internal counting) */
 };
 
-struct waylist 	*waylist_p=NULL;
-struct nodelist	*nodelist_p=NULL;
-struct adjlist	*adjlist_p=NULL;
-int				nodelist_n=0;
-int				adjlist_n=0;
-int 			waylist_n=0;
-int 			waylist_bufn=0;
+struct waylist  *waylist_p = NULL;
+struct nodelist *nodelist_p = NULL;
+struct adjlist *adjlist_p = NULL;
+int    nodelist_n = 0;
+int    adjlist_n = 0;
+int    waylist_n = 0;
+int    waylist_bufn = 0;
 
 
 void calc_earth_to_eukl(float lat, float lon, float alt, float *x)
 {
-	float la,lo;
-	la=lat*M_PI/180.0;
-	lo=lon*M_PI/180.0;
-	x[0]=(ESIZE+alt)*sin(lo) *cos(la);
-	x[1]=(ESIZE+alt)*			sin(la);
-	x[2]=(ESIZE+alt)*cos(lo) *cos(la);
+	float la, lo;
+	la = lat * M_PI / 180.0;
+	lo = lon * M_PI / 180.0;
+	x[0] = (ESIZE + alt) * sin(lo) * cos(la);
+	x[1] = (ESIZE + alt) *   sin(la);
+	x[2] = (ESIZE + alt) * cos(lo) * cos(la);
 }
 int draw_icon(void *data, int argc, char **argv, char **azColName)
 {
-	int i,tagid=-1,oid;
-	int nodeid=-1, layerid=-1;
-	/*	char query[MAXQ];*/
+	int i, tagid = -1, oid;
+	int nodeid = -1, layerid = -1;
+	/* char query[MAXQ];*/
 	char s[MAXQ];
 	float la, lo, alt;
 	float x[3];
-	la=lo=alt=0.0;
+	la = lo = alt = 0.0;
 	num_done++;
-	for (i=0; i&lt;argc; i++) {
+	for (i = 0; i &lt; argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],&quot;longitude&quot;))			lo=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],&quot;latitude&quot;))		la=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],&quot;altitude&quot;))		alt=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],&quot;tag_id&quot;)) 			tagid=atoi(argv[i]);
-			else if (0==strcmp(azColName[i],&quot;node_id&quot;)) 		nodeid=atoi(argv[i]);
-			else if (0==strcmp(azColName[i],&quot;layer_id&quot;)) 		layerid=atoi(argv[i]);
+			if (0 == strcmp(azColName[i], &quot;longitude&quot;))   lo = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], &quot;latitude&quot;))  la = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], &quot;altitude&quot;))  alt = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], &quot;tag_id&quot;))    tagid = atoi(argv[i]);
+			else if (0 == strcmp(azColName[i], &quot;node_id&quot;))   nodeid = atoi(argv[i]);
+			else if (0 == strcmp(azColName[i], &quot;layer_id&quot;))   layerid = atoi(argv[i]);
 		}
 	}
-	if (0==db_gettag(tagid, &quot;amenity&quot;,s)) {
-		oid=-1;
-		if (0==strcmp(s,&quot;wifi&quot;)) {					/* some wifi icon */
-			if (0==db_gettag(tagid, &quot;wifi_type&quot;,s)) {
-				if (0==strcmp(s,&quot;infrastructure&quot;)) {	/* access point */
-					if (0==db_gettag(tagid, &quot;wifi_wep&quot;,s)) {
-						if (0==strcmp(s,&quot;true&quot;))	oid=s3d_clone(icons[ICON_AP_WPA].oid);
-						else						oid=s3d_clone(icons[ICON_AP_OPEN].oid);
-					} else oid=s3d_clone(icons[ICON_AP_OPEN].oid);	/* assuming open ap */
+	if (0 == db_gettag(tagid, &quot;amenity&quot;, s)) {
+		oid = -1;
+		if (0 == strcmp(s, &quot;wifi&quot;)) {  /* some wifi icon */
+			if (0 == db_gettag(tagid, &quot;wifi_type&quot;, s)) {
+				if (0 == strcmp(s, &quot;infrastructure&quot;)) { /* access point */
+					if (0 == db_gettag(tagid, &quot;wifi_wep&quot;, s)) {
+						if (0 == strcmp(s, &quot;true&quot;)) oid = s3d_clone(icons[ICON_AP_WPA].oid);
+						else      oid = s3d_clone(icons[ICON_AP_OPEN].oid);
+					} else oid = s3d_clone(icons[ICON_AP_OPEN].oid); /* assuming open ap */
 				}
 			}
 		}
-		if (oid!=-1) {
-			calc_earth_to_eukl(la,lo,0,x);
-			s3d_translate(oid,x[0],x[1],x[2]);
-			s3d_rotate(oid,(90-la),lo,0);
-			s3d_link(oid,oidy);
-			s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			load_update_status((100.0*num_done)/(float)num_max);
-			/*			snprintf(query,MAXQ,&quot;UPDATE node SET s3doid=%d WHERE node_id=%d AND layer_id=%d;&quot;,oid,nodeid,layerid);
-						db_exec(query, NULL, 0);*/
+		if (oid != -1) {
+			calc_earth_to_eukl(la, lo, 0, x);
+			s3d_translate(oid, x[0], x[1], x[2]);
+			s3d_rotate(oid, (90 - la), lo, 0);
+			s3d_link(oid, oidy);
+			s3d_flags_on(oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			load_update_status((100.0*num_done) / (float)num_max);
+			/*   snprintf(query,MAXQ,&quot;UPDATE node SET s3doid=%d WHERE node_id=%d AND layer_id=%d;&quot;,oid,nodeid,layerid);
+			   db_exec(query, NULL, 0);*/
 		}
 
 	}
@@ -131,13 +131,13 @@
 /* just fetches node information and puts in the nodelist */
 int insert_node(void *data, int argc, char **argv, char **azColName)
 {
-	struct nodelist *np=data;	/* get the nodepointer */
+	struct nodelist *np = data; /* get the nodepointer */
 	int i;
-	for (i=0; i&lt;argc; i++) {
+	for (i = 0; i &lt; argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],&quot;longitude&quot;))			np[nodelist_n].lo=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],&quot;latitude&quot;))		np[nodelist_n].la=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],&quot;altitude&quot;))		np[nodelist_n].alt=strtod(argv[i],NULL);
+			if (0 == strcmp(azColName[i], &quot;longitude&quot;))   np[nodelist_n].lo = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], &quot;latitude&quot;))  np[nodelist_n].la = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], &quot;altitude&quot;))  np[nodelist_n].alt = strtod(argv[i], NULL);
 		}
 	}
 	return(0);
@@ -145,13 +145,13 @@
 int select_waytype(void *data, int argc, char **argv, char **azColName)
 {
 	int i;
-	for (i=0; i&lt;argc; i++) {
+	for (i = 0; i &lt; argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(argv[i],&quot;motorway&quot;))				*((int *) data)=5;
-			else if (0==strcmp(argv[i],&quot;motorway_link&quot;))	*((int *) data)=4;
-			else if (0==strcmp(argv[i],&quot;primary&quot;))			*((int *) data)=3;
-			else if (0==strcmp(argv[i],&quot;secondary&quot;))		*((int *) data)=2;
-			else if (0==strcmp(argv[i],&quot;residential&quot;))		*((int *) data)=1;
+			if (0 == strcmp(argv[i], &quot;motorway&quot;))    *((int *) data) = 5;
+			else if (0 == strcmp(argv[i], &quot;motorway_link&quot;)) *((int *) data) = 4;
+			else if (0 == strcmp(argv[i], &quot;primary&quot;))   *((int *) data) = 3;
+			else if (0 == strcmp(argv[i], &quot;secondary&quot;))  *((int *) data) = 2;
+			else if (0 == strcmp(argv[i], &quot;residential&quot;))  *((int *) data) = 1;
 		}
 	}
 	return(0);
@@ -161,245 +161,245 @@
 {
 	float len;
 	char query[MAXQ];
-	int i,j,k,vert=0;
+	int i, j, k, vert = 0;
 	int node_id;
 	int way_obj;
-	int waytype=0;
+	int waytype = 0;
 	int adj_seg;
-	float a[3],b[3],*left,*right,*swap;
+	float a[3], b[3], *left, *right, *swap;
 	float street_width; /* dynamically adjust? */
-	float an[3];		/* normal on the plane, orthogonal on the right side of the left segment */
-	float n[3];			/* the direction vector in which the intersecion should be placed */
-	float s[3];			/* intersection point */
+	float an[3];  /* normal on the plane, orthogonal on the right side of the left segment */
+	float n[3];   /* the direction vector in which the intersecion should be placed */
+	float s[3];   /* intersection point */
 	float point_zero[3]; /* we use point_zero so we don't have very big bounding spheres in s3d and speed up picking */
-	float n_len,scale;
+	float n_len, scale;
 
-	if (waylist_n==0)	/* no nodes, no fun */
+	if (waylist_n == 0) /* no nodes, no fun */
 		return;
-	/*	printf(&quot;way: %d - %d segments\n&quot;,lastid,waylist_n);*/
-	way_obj=s3d_new_object();
-	if (lastid!=-1) {
-		snprintf(query,MAXQ,&quot;SELECT tagvalue FROM tag WHERE tag_id=(SELECT tag_id FROM way WHERE way_id=%d AND %s) AND tagkey='highway';&quot;,lastid,filter);
+	/* printf(&quot;way: %d - %d segments\n&quot;,lastid,waylist_n);*/
+	way_obj = s3d_new_object();
+	if (lastid != -1) {
+		snprintf(query, MAXQ, &quot;SELECT tagvalue FROM tag WHERE tag_id=(SELECT tag_id FROM way WHERE way_id=%d AND %s) AND tagkey='highway';&quot;, lastid, filter);
 		db_exec(query, select_waytype, &amp;waytype);
 	}
 	switch (waytype) {
 	case 5:
-		s3d_push_material(way_obj,0.2,0.2,0.6,		1.0,1.0,1.0,	0.3,0.3,1.0);	/* motorway */
+		s3d_push_material(way_obj, 0.2, 0.2, 0.6,  1.0, 1.0, 1.0, 0.3, 0.3, 1.0); /* motorway */
 	case 4:
-		s3d_push_material(way_obj,0.3,0.3,0.4,		1.0,1.0,1.0,	0.5,0.5,0.8);	/* motorway_link*/
+		s3d_push_material(way_obj, 0.3, 0.3, 0.4,  1.0, 1.0, 1.0, 0.5, 0.5, 0.8); /* motorway_link*/
 	case 3:
-		s3d_push_material(way_obj,0.6,0.3,0.1,		1.0,1.0,1.0, 	1.0,0.6,0.2);	/* primary */
+		s3d_push_material(way_obj, 0.6, 0.3, 0.1,  1.0, 1.0, 1.0,  1.0, 0.6, 0.2); /* primary */
 	case 2:
-		s3d_push_material(way_obj,0.6,0.6,0.0,		1.0,1.0,1.0, 	1.0,1.0,0.0);	/* secondary */
+		s3d_push_material(way_obj, 0.6, 0.6, 0.0,  1.0, 1.0, 1.0,  1.0, 1.0, 0.0); /* secondary */
 	case 1:
-		s3d_push_material(way_obj,0.6,0.6,0.6,		1.0,1.0,1.0, 	1.0,1.0,1.0);	/* residential */
+		s3d_push_material(way_obj, 0.6, 0.6, 0.6,  1.0, 1.0, 1.0,  1.0, 1.0, 1.0); /* residential */
 	default:
-		s3d_push_material(way_obj,0.6,0.2,0.6,		1.0,1.0,1.0,	1.0,0.5,1.0); /* default */
+		s3d_push_material(way_obj, 0.6, 0.2, 0.6,  1.0, 1.0, 1.0, 1.0, 0.5, 1.0); /* default */
 	}
-	street_width=(0.5+waytype/10)/RESCALE;
+	street_width = (0.5 + waytype / 10) / RESCALE;
 	/* put nodes of the graph into a list */
-	nodelist_n=0;
-	for (i=0;i&lt;waylist_n*2;i++) {
-		if (i%2)				node_id=waylist_p[i/2].node_from;
-		else					node_id=waylist_p[i/2].node_to;
-		for (j=0;j&lt;nodelist_n;j++)
-			if (nodelist_p[j].node_id==node_id) break;
-		if (j==nodelist_n) { /* we still need to add this node */
-			/*			printf(&quot;[way %d] add node %d to nodelist as %d\n&quot;,lastid, node_id, nodelist_n);*/
-			nodelist_p[j].node_id=node_id;
-			snprintf(query,MAXQ,&quot;SELECT longitude, latitude, altitude FROM node WHERE %s AND node_id=%d;&quot;,filter, node_id);
-			db_exec(query, insert_node,(void *)(nodelist_p));
-			calc_earth_to_eukl(nodelist_p[j].la,nodelist_p[j].lo,0,nodelist_p[j].x); /* elevate higher priority streets a little bit ... */
-			len=sqrt(nodelist_p[j].x[0]*nodelist_p[j].x[0] + nodelist_p[j].x[1]*nodelist_p[j].x[1] + nodelist_p[j].x[2]*nodelist_p[j].x[2]);
-			nodelist_p[j].normal[0]=nodelist_p[j].x[0]/len;
-			nodelist_p[j].normal[1]=nodelist_p[j].x[1]/len;
-			nodelist_p[j].normal[2]=nodelist_p[j].x[2]/len;
+	nodelist_n = 0;
+	for (i = 0;i &lt; waylist_n*2;i++) {
+		if (i % 2)    node_id = waylist_p[i/2].node_from;
+		else     node_id = waylist_p[i/2].node_to;
+		for (j = 0;j &lt; nodelist_n;j++)
+			if (nodelist_p[j].node_id == node_id) break;
+		if (j == nodelist_n) { /* we still need to add this node */
+			/*   printf(&quot;[way %d] add node %d to nodelist as %d\n&quot;,lastid, node_id, nodelist_n);*/
+			nodelist_p[j].node_id = node_id;
+			snprintf(query, MAXQ, &quot;SELECT longitude, latitude, altitude FROM node WHERE %s AND node_id=%d;&quot;, filter, node_id);
+			db_exec(query, insert_node, (void *)(nodelist_p));
+			calc_earth_to_eukl(nodelist_p[j].la, nodelist_p[j].lo, 0, nodelist_p[j].x); /* elevate higher priority streets a little bit ... */
+			len = sqrt(nodelist_p[j].x[0] * nodelist_p[j].x[0] + nodelist_p[j].x[1] * nodelist_p[j].x[1] + nodelist_p[j].x[2] * nodelist_p[j].x[2]);
+			nodelist_p[j].normal[0] = nodelist_p[j].x[0] / len;
+			nodelist_p[j].normal[1] = nodelist_p[j].x[1] / len;
+			nodelist_p[j].normal[2] = nodelist_p[j].x[2] / len;
 			nodelist_n++;
 		}
-		if (i%2)				waylist_p[i/2].node_from_int=j;
-		else					waylist_p[i/2].node_to_int=j;
+		if (i % 2)    waylist_p[i/2].node_from_int = j;
+		else     waylist_p[i/2].node_to_int = j;
 	}
 	V_COPY(point_zero, nodelist_p[0].x);
 	/* iterate for all nodes */
-	for (i=0;i&lt;nodelist_n;i++) {
+	for (i = 0;i &lt; nodelist_n;i++) {
 		/* find adjacent segments */
-		adjlist_n=0;
-		node_id=nodelist_p[i].node_id;
-		for (j=0;j&lt;=waylist_n;j++)	{
-			if (waylist_p[j].node_from==node_id) {
-				adjlist_p[adjlist_n].node_id=waylist_p[j].node_to_int;
-				adjlist_p[adjlist_n].seg_id=j;
+		adjlist_n = 0;
+		node_id = nodelist_p[i].node_id;
+		for (j = 0;j &lt;= waylist_n;j++) {
+			if (waylist_p[j].node_from == node_id) {
+				adjlist_p[adjlist_n].node_id = waylist_p[j].node_to_int;
+				adjlist_p[adjlist_n].seg_id = j;
 				adjlist_n++;
-			} else  if (waylist_p[j].node_to==node_id) {
-				adjlist_p[adjlist_n].node_id=waylist_p[j].node_from_int;
-				adjlist_p[adjlist_n].seg_id=j;
+			} else  if (waylist_p[j].node_to == node_id) {
+				adjlist_p[adjlist_n].node_id = waylist_p[j].node_from_int;
+				adjlist_p[adjlist_n].seg_id = j;
 				adjlist_n++;
 			}
 		}
 
-		if (adjlist_n&gt;1) {	/* more than one adjacent, need to order and calculate intersections */
-			if (adjlist_n&gt;2) { /* no ordering needed for 2 incoming segments */
-				for (j=0;j&lt;adjlist_n-2;j++)
-					for (k=j+2;k&lt;adjlist_n;k++) {
-						float test[3],normal[3],linevector[3];
+		if (adjlist_n &gt; 1) { /* more than one adjacent, need to order and calculate intersections */
+			if (adjlist_n &gt; 2) { /* no ordering needed for 2 incoming segments */
+				for (j = 0;j &lt; adjlist_n - 2;j++)
+					for (k = j + 2;k &lt; adjlist_n;k++) {
+						float test[3], normal[3], linevector[3];
 						/* (re)calc test direction */
-						V_SUB(nodelist_p[adjlist_p[j].node_id].x,	nodelist_p[adjlist_p[j+1].node_id].x,	linevector);
-						V_CROSS(nodelist_p[adjlist_p[j].node_id].normal,	linevector,		normal); /* normal should look outside of our circle now. */
-						while (k&lt;adjlist_n) {
+						V_SUB(nodelist_p[adjlist_p[j].node_id].x, nodelist_p[adjlist_p[j+1].node_id].x, linevector);
+						V_CROSS(nodelist_p[adjlist_p[j].node_id].normal, linevector,  normal); /* normal should look outside of our circle now. */
+						while (k &lt; adjlist_n) {
 							/* determine on which side the point is. if its between our testvector, we'll need to swap. */
-							V_SUB(nodelist_p[adjlist_p[j].node_id].x,nodelist_p[adjlist_p[k].node_id].x,test);
-							if (s3d_vector_dot_product(normal,test)&gt;0) { /* same side, means adjacent line k is nearer to our point j
-																			than our point j+1 which is supposed to be the nearest point,
-																			so we swap them and call a break to get the new test-normal */
+							V_SUB(nodelist_p[adjlist_p[j].node_id].x, nodelist_p[adjlist_p[k].node_id].x, test);
+							if (s3d_vector_dot_product(normal, test) &gt; 0) { /* same side, means adjacent line k is nearer to our point j
+                   than our point j+1 which is supposed to be the nearest point,
+                   so we swap them and call a break to get the new test-normal */
 								struct adjlist swap;
-								memcpy(&amp;swap,&amp;(adjlist_p[j+1]),sizeof(struct adjlist));
-								memcpy(&amp;(adjlist_p[j+1]),&amp;(adjlist_p[k]),sizeof(struct adjlist));
-								memcpy(&amp;(adjlist_p[k]),&amp;swap,sizeof(struct adjlist));
+								memcpy(&amp;swap, &amp;(adjlist_p[j+1]), sizeof(struct adjlist));
+								memcpy(&amp;(adjlist_p[j+1]), &amp;(adjlist_p[k]), sizeof(struct adjlist));
+								memcpy(&amp;(adjlist_p[k]), &amp;swap, sizeof(struct adjlist));
 								break;
 							}
 							k++;
 						}
 					}
 			}
-			left=a;
-			right=b;
+			left = a;
+			right = b;
 			V_SUB(nodelist_p[adjlist_p[0].node_id].x, nodelist_p[i].x, right);
 			V_NORM(right);
 
 
-			for (j=0;j&lt;adjlist_n;j++) {
-				swap=left;
-				left=right;			/* use last right segment as new left segment */
-				right=swap;			/* get space for the next right segment */
+			for (j = 0;j &lt; adjlist_n;j++) {
+				swap = left;
+				left = right; /* use last right segment as new left segment */
+				right = swap; /* get space for the next right segment */
 				V_SUB(nodelist_p[adjlist_p[(j+1)%adjlist_n].node_id].x, nodelist_p[i].x, right);
 				V_NORM(right);
-				V_CROSS(nodelist_p[i].normal, left ,an);	/* an is also normalized, as first and second argument are already length 1 */
-				V_ADD(left, right, n);						/* direction which our intersection is */
+				V_CROSS(nodelist_p[i].normal, left , an); /* an is also normalized, as first and second argument are already length 1 */
+				V_ADD(left, right, n);      /* direction which our intersection is */
 
 				V_CROSS(nodelist_p[i].normal, n, s);
 				V_CROSS(s, nodelist_p[i].normal, n); /* get n on the plane which is spanned by the points normal */
 
-				n_len=V_LEN(n);
+				n_len = V_LEN(n);
 
-				V_COPY(s, nodelist_p[i].x);	/* s = P + (street_width/ ( n * an)) * n */
-				V_SCAL(n,1/n_len);	/* normalize n first! */
-				scale=V_DOT(n,an);	/* get cos (alpha/2), alpha is opposite angel of left and right segment */
+				V_COPY(s, nodelist_p[i].x); /* s = P + (street_width/ ( n * an)) * n */
+				V_SCAL(n, 1 / n_len); /* normalize n first! */
+				scale = V_DOT(n, an); /* get cos (alpha/2), alpha is opposite angel of left and right segment */
 
-				if ((n_len&lt;0.1) || (fabs(scale)&lt;0.1)) {	/* too low, don't use, just have intersection 90 degree of it. */
-					V_SCAL(an, -street_width);		/* S = P + street_width * an */
+				if ((n_len &lt; 0.1) || (fabs(scale) &lt; 0.1)) { /* too low, don't use, just have intersection 90 degree of it. */
+					V_SCAL(an, -street_width);  /* S = P + street_width * an */
 					V_ADD(nodelist_p[i].x, an, s);
 
 				} else {
-					V_SCAL(n,-street_width/scale);
+					V_SCAL(n, -street_width / scale);
 					V_ADD(s, n, s);
 				}
 
 
-				/*				printf(&quot;calc intersection: %3.3f %3.3f %3.3f\n&quot;,s[0],s[1],s[2]);*/
-				V_SUB(s,point_zero,s);
-				s3d_push_vertices(way_obj,s,1);
-				adj_seg=adjlist_p[j].seg_id;				/* left segment */
-				if (i==waylist_p[adj_seg].node_from_int)	waylist_p[adj_seg].node_from_r=vert;
-				else									waylist_p[adj_seg].node_to_l=vert;
-				adj_seg=adjlist_p[(j+1)%adjlist_n].seg_id;	/* right segment */
-				if (i==waylist_p[adj_seg].node_from_int)	waylist_p[adj_seg].node_from_l=vert;
-				else									waylist_p[adj_seg].node_to_r=vert;
+				/*    printf(&quot;calc intersection: %3.3f %3.3f %3.3f\n&quot;,s[0],s[1],s[2]);*/
+				V_SUB(s, point_zero, s);
+				s3d_push_vertices(way_obj, s, 1);
+				adj_seg = adjlist_p[j].seg_id;  /* left segment */
+				if (i == waylist_p[adj_seg].node_from_int) waylist_p[adj_seg].node_from_r = vert;
+				else         waylist_p[adj_seg].node_to_l = vert;
+				adj_seg = adjlist_p[(j+1)%adjlist_n].seg_id; /* right segment */
+				if (i == waylist_p[adj_seg].node_from_int) waylist_p[adj_seg].node_from_l = vert;
+				else         waylist_p[adj_seg].node_to_r = vert;
 				vert++;
 			}
-			if (adjlist_n&gt;=3) {
+			if (adjlist_n &gt;= 3) {
 				/* we know that the last adjlist_n vertices set belong to our intersection here .. */
-				for (j=vert-adjlist_n+1;j&lt;(vert-1);j++)
-					s3d_push_polygon(way_obj, vert-adjlist_n, j, j+1,0 );
+				for (j = vert - adjlist_n + 1;j &lt; (vert - 1);j++)
+					s3d_push_polygon(way_obj, vert - adjlist_n, j, j + 1, 0);
 			}
 		} else {
 			/* endpoint */
 			V_SUB(nodelist_p[adjlist_p[0].node_id].x, nodelist_p[i].x, a);
 			V_NORM(a);
-			V_CROSS(nodelist_p[i].normal, a ,an);	/* an is also normalized, as first and second argument are already length 1 */
+			V_CROSS(nodelist_p[i].normal, a , an); /* an is also normalized, as first and second argument are already length 1 */
 			V_SCAL(an, street_width);
 
-			V_COPY(s,nodelist_p[i].x);
-			V_ADD(s,an,s);
-			V_SUB(s,point_zero,s);
-			s3d_push_vertices(way_obj,s,1);
-			j=vert;
+			V_COPY(s, nodelist_p[i].x);
+			V_ADD(s, an, s);
+			V_SUB(s, point_zero, s);
+			s3d_push_vertices(way_obj, s, 1);
+			j = vert;
 			vert++;
-			V_SCAL(an,-1);
-			V_COPY(s,nodelist_p[i].x);
-			V_ADD(s,an,s);
-			V_SUB(s,point_zero,s);
-			s3d_push_vertices(way_obj,s,1);
-			k=vert;
+			V_SCAL(an, -1);
+			V_COPY(s, nodelist_p[i].x);
+			V_ADD(s, an, s);
+			V_SUB(s, point_zero, s);
+			s3d_push_vertices(way_obj, s, 1);
+			k = vert;
 			vert++;
 
-			adj_seg=adjlist_p[0].seg_id;
-			if (i==waylist_p[adj_seg].node_from_int)	{
-				waylist_p[adj_seg].node_from_l=j;
-				waylist_p[adj_seg].node_from_r=k;
+			adj_seg = adjlist_p[0].seg_id;
+			if (i == waylist_p[adj_seg].node_from_int) {
+				waylist_p[adj_seg].node_from_l = j;
+				waylist_p[adj_seg].node_from_r = k;
 			} else {
-				waylist_p[adj_seg].node_to_l=k;
-				waylist_p[adj_seg].node_to_r=j;
+				waylist_p[adj_seg].node_to_l = k;
+				waylist_p[adj_seg].node_to_r = j;
 			}
 		}
 	}
-	for (i=0;i&lt;waylist_n;i++) {
-		uint32_t	polys[8];
+	for (i = 0;i &lt; waylist_n;i++) {
+		uint32_t polys[8];
 		/* printf(&quot;drawing way from points %d %d %d %d\n&quot;,waylist_p[i].node_from_l, waylist_p[i].node_to_l, waylist_p[i].node_to_r,waylist_p[i].node_from_r);*/
-		polys[0]=waylist_p[i].node_from_l;
-		polys[1]=waylist_p[i].node_to_l;
-		polys[2]=waylist_p[i].node_to_r;
-		polys[3]=0;
-		polys[4]=waylist_p[i].node_from_l;
-		polys[5]=waylist_p[i].node_to_r;
-		polys[6]=waylist_p[i].node_from_r;
-		polys[7]=0;
+		polys[0] = waylist_p[i].node_from_l;
+		polys[1] = waylist_p[i].node_to_l;
+		polys[2] = waylist_p[i].node_to_r;
+		polys[3] = 0;
+		polys[4] = waylist_p[i].node_from_l;
+		polys[5] = waylist_p[i].node_to_r;
+		polys[6] = waylist_p[i].node_from_r;
+		polys[7] = 0;
 
 		s3d_push_polygons(way_obj, polys, 2);
 	}
-	s3d_translate(way_obj,point_zero[0], point_zero[1], point_zero[2]);
-	s3d_link(way_obj,oidy);
-	s3d_flags_on(way_obj,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	snprintf(query,MAXQ,&quot;UPDATE way SET s3doid=%d WHERE way_id=%d AND %s;&quot;,way_obj,lastid,filter);
+	s3d_translate(way_obj, point_zero[0], point_zero[1], point_zero[2]);
+	s3d_link(way_obj, oidy);
+	s3d_flags_on(way_obj, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	snprintf(query, MAXQ, &quot;UPDATE way SET s3doid=%d WHERE way_id=%d AND %s;&quot;, way_obj, lastid, filter);
 	db_exec(query, NULL, 0);
 
-	waylist_n=0;
+	waylist_n = 0;
 
-	load_update_status((100.0*num_done)/(float)num_max);
+	load_update_status((100.0*num_done) / (float)num_max);
 }
 void waylist_add(struct waylist *p)
 {
-	if (waylist_n&gt;=waylist_bufn) {
-		waylist_bufn+=64;
-		waylist_p=realloc(waylist_p,sizeof(struct waylist)*waylist_bufn);
-		nodelist_p=realloc(nodelist_p,sizeof(struct nodelist)*waylist_bufn*2); /* we can have twice as many nodes as there are segments in a graph. */
-		adjlist_p=realloc(adjlist_p,sizeof(struct nodelist)*waylist_bufn*2);
+	if (waylist_n &gt;= waylist_bufn) {
+		waylist_bufn += 64;
+		waylist_p = realloc(waylist_p, sizeof(struct waylist) * waylist_bufn);
+		nodelist_p = realloc(nodelist_p, sizeof(struct nodelist) * waylist_bufn * 2); /* we can have twice as many nodes as there are segments in a graph. */
+		adjlist_p = realloc(adjlist_p, sizeof(struct nodelist) * waylist_bufn * 2);
 	}
-	waylist_p[waylist_n].node_to= p-&gt;node_to;
-	waylist_p[waylist_n].node_from= p-&gt;node_from;
+	waylist_p[waylist_n].node_to = p-&gt;node_to;
+	waylist_p[waylist_n].node_from = p-&gt;node_from;
 	waylist_n++;
 }
 
 int way_group(void *data, int argc, char **argv, char **azColName)
 {
 	int i;
-	int id=-1;
+	int id = -1;
 	struct waylist p;
-	char *filter=(char *)data;
+	char *filter = (char *)data;
 	num_done++;
-	p.node_from=p.node_to=0;
-	p.node_to=-1;
-	p.seg_id=-1;
-	for (i=0; i&lt;argc; i++) {
+	p.node_from = p.node_to = 0;
+	p.node_to = -1;
+	p.seg_id = -1;
+	for (i = 0; i &lt; argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],&quot;way_id&quot;))				id=atoi(argv[i]);
-			else if (0==strcmp(azColName[i],&quot;node_from&quot;))		p.node_from=atoi(argv[i]);
-			else if (0==strcmp(azColName[i],&quot;node_to&quot;))			p.node_to=atoi(argv[i]);
-			else if (0==strcmp(azColName[i],&quot;seg_id&quot;))			p.seg_id=atoi(argv[i]);
+			if (0 == strcmp(azColName[i], &quot;way_id&quot;))    id = atoi(argv[i]);
+			else if (0 == strcmp(azColName[i], &quot;node_from&quot;))  p.node_from = atoi(argv[i]);
+			else if (0 == strcmp(azColName[i], &quot;node_to&quot;))   p.node_to = atoi(argv[i]);
+			else if (0 == strcmp(azColName[i], &quot;seg_id&quot;))   p.seg_id = atoi(argv[i]);
 		}
 	}
-	if (p.node_from==p.node_to)	/* skip */
+	if (p.node_from == p.node_to) /* skip */
 		return(0);
-	if ((lastid!=id) &amp;&amp; (id!=0)) {
+	if ((lastid != id) &amp;&amp; (id != 0)) {
 		waylist_draw(filter);
 		/* flush/draw the list, add new  */
 		waylist_add(&amp;p);
@@ -407,25 +407,25 @@
 		/* add id to the list */
 		waylist_add(&amp;p);
 	}
-	lastid=id;
+	lastid = id;
 	return 0;
 }
 void draw_translate_icon(int user_icon, float la, float lo)
 {
 	float x[3];
-	calc_earth_to_eukl(la,lo,1/RESCALE,x);
-	s3d_translate(user_icon,x[0],x[1],x[2]);
-	s3d_rotate(user_icon,(90-la),lo,0);
+	calc_earth_to_eukl(la, lo, 1 / RESCALE, x);
+	s3d_translate(user_icon, x[0], x[1], x[2]);
+	s3d_rotate(user_icon, (90 - la), lo, 0);
 }
 
 void draw_ways(char *filter)
 {
 	char query[MAXQ];
-	num_done=0;
-	snprintf(query,MAXQ,&quot;SELECT count(seg_id) FROM segment WHERE %s;&quot;,filter);
-	db_exec(query, db_getint,&amp;num_max);
-	snprintf(query,MAXQ,&quot;SELECT * FROM segment WHERE %s ORDER BY way_id;&quot;,filter);
-	db_exec(query, way_group,filter);
+	num_done = 0;
+	snprintf(query, MAXQ, &quot;SELECT count(seg_id) FROM segment WHERE %s;&quot;, filter);
+	db_exec(query, db_getint, &amp;num_max);
+	snprintf(query, MAXQ, &quot;SELECT * FROM segment WHERE %s ORDER BY way_id;&quot;, filter);
+	db_exec(query, way_group, filter);
 	waylist_draw(filter); /* last way */
 }
 void draw_osm()
@@ -436,13 +436,13 @@
 void draw_kismet()
 {
 	char query[MAXQ];
-	char filter[]=&quot;layer_id=(SELECT layer_id FROM layer WHERE name='kismet')&quot;;
+	char filter[] = &quot;layer_id=(SELECT layer_id FROM layer WHERE name='kismet')&quot;;
 	load_window(&quot;Drawing Access Points ...&quot;);
-	num_done=0;
-	snprintf(query,MAXQ,&quot;SELECT count(node_id) FROM node WHERE %s;&quot;,filter);
-	db_exec(query, db_getint,&amp;num_max);
-	snprintf(query,MAXQ,&quot;SELECT * FROM node WHERE %s;&quot;,filter);
-	db_exec(query, draw_icon,filter);
+	num_done = 0;
+	snprintf(query, MAXQ, &quot;SELECT count(node_id) FROM node WHERE %s;&quot;, filter);
+	db_exec(query, db_getint, &amp;num_max);
+	snprintf(query, MAXQ, &quot;SELECT * FROM node WHERE %s;&quot;, filter);
+	db_exec(query, draw_icon, filter);
 }
 void draw_all_layers()
 {

Modified: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/gps.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,10 +24,10 @@
 
 #include &lt;s3d.h&gt;
 #include &quot;s3dosm.h&quot;
-#include &lt;stdio.h&gt; 	/* printf() */
-int user_icon=-1,user_icon_rotator=-1;
+#include &lt;stdio.h&gt;  /* printf() */
+int user_icon = -1, user_icon_rotator = -1;
 #ifdef HAVE_GPS
-#include &lt;gps.h&gt; 	/* gps_*() */
+#include &lt;gps.h&gt;  /* gps_*() */
 #ifdef NMEA_CHANNELS
 #define GPS_NEW
 #endif
@@ -36,35 +36,35 @@
 #endif
 
 #include &lt;errno.h&gt;  /* errno */
-#include &lt;stdlib.h&gt;	/* malloc(), free() */
+#include &lt;stdlib.h&gt; /* malloc(), free() */
 #include &lt;string.h&gt; /* strlen() */
-#include &lt;stdio.h&gt;		 /*  snprintf(), printf(), NULL */
-#include &lt;time.h&gt;	 /*  nanosleep(), struct tm, time_t...  */
-#include &lt;math.h&gt;	/* fabs(), finite () */
-static struct gps_data_t 	*dgps;
-static int 					 frame=0;
-static int 					 lastfix=0;
-static int 					 gps_active=0;
-static int					 gps_info=-1;
-static float 				 lat,lon,tlat,tlon;	/* we have the same in nav.c, this one is for the user icon ... */
-static float				 lat_old,lon_old;
-static float				 speed_old=0.0;
-void 				 show_gpsdata(struct gps_data_t *dgps);
-void				 show_position(struct gps_data_t *dgps);
+#include &lt;stdio.h&gt;   /*  snprintf(), printf(), NULL */
+#include &lt;time.h&gt;  /*  nanosleep(), struct tm, time_t...  */
+#include &lt;math.h&gt; /* fabs(), finite () */
+static struct gps_data_t  *dgps;
+static int       frame = 0;
+static int       lastfix = 0;
+static int       gps_active = 0;
+static int      gps_info = -1;
+static float      lat, lon, tlat, tlon; /* we have the same in nav.c, this one is for the user icon ... */
+static float     lat_old, lon_old;
+static float     speed_old = 0.0;
+void      show_gpsdata(struct gps_data_t *dgps);
+void     show_position(struct gps_data_t *dgps);
 
 void show_gpsdata(struct gps_data_t *dgps)
 {
 	if (!dgps-&gt;online)
 		printf(&quot;WARNING: no connection to gps device\n&quot;);
 #ifdef GPS_NEW
-	printf(&quot;[%d] lat/long: [%f|%f], altitude %f\n&quot;,frame,dgps-&gt;fix.latitude,dgps-&gt;fix.longitude,dgps-&gt;fix.altitude);
-	printf(&quot;speed [kph]: %f\n&quot;,dgps-&gt;fix.speed/KNOTS_TO_KPH);
-	printf(&quot;used %d/%d satellits\n&quot;,dgps-&gt;satellites_used,dgps-&gt;satellites);
-	printf(&quot;################## = %f %f %f\n&quot;,dgps-&gt;fix.pitch, dgps-&gt;fix.roll, dgps-&gt;fix.dip);
+	printf(&quot;[%d] lat/long: [%f|%f], altitude %f\n&quot;, frame, dgps-&gt;fix.latitude, dgps-&gt;fix.longitude, dgps-&gt;fix.altitude);
+	printf(&quot;speed [kph]: %f\n&quot;, dgps-&gt;fix.speed / KNOTS_TO_KPH);
+	printf(&quot;used %d/%d satellits\n&quot;, dgps-&gt;satellites_used, dgps-&gt;satellites);
+	printf(&quot;################## = %f %f %f\n&quot;, dgps-&gt;fix.pitch, dgps-&gt;fix.roll, dgps-&gt;fix.dip);
 #else
-	printf(&quot;[%d] lat/long: [%f|%f], altitude %f\n&quot;,frame,dgps-&gt;latitude,dgps-&gt;longitude,dgps-&gt;altitude);
-	printf(&quot;speed [kph]: %f\n&quot;,dgps-&gt;speed/KNOTS_TO_KPH);
-	printf(&quot;used %d/%d satellits\n&quot;,dgps-&gt;satellites_used,dgps-&gt;satellites);
+	printf(&quot;[%d] lat/long: [%f|%f], altitude %f\n&quot;, frame, dgps-&gt;latitude, dgps-&gt;longitude, dgps-&gt;altitude);
+	printf(&quot;speed [kph]: %f\n&quot;, dgps-&gt;speed / KNOTS_TO_KPH);
+	printf(&quot;used %d/%d satellits\n&quot;, dgps-&gt;satellites_used, dgps-&gt;satellites);
 
 #endif
 	switch (dgps-&gt;status) {
@@ -98,87 +98,87 @@
 		break;
 	}
 }
-#define BUFSIZE		1024
+#define BUFSIZE  1024
 void show_position(struct gps_data_t *dgps)
 {
-	int fix=1;
-	float la,lo,heading,speed,slen;
+	int fix = 1;
+	float la, lo, heading, speed, slen;
 	char buf[BUFSIZE+1];
 #ifdef GPS_NEW
 	if (!dgps-&gt;online)
-		fix=0;
+		fix = 0;
 	switch (dgps-&gt;fix.mode) {
 	case MODE_NOT_SEEN:
-		fix=0;
+		fix = 0;
 		break;
 	case MODE_NO_FIX:
-		fix=0;
+		fix = 0;
 		break;
 	}
 
-	la=dgps-&gt;fix.latitude;
-	lo=dgps-&gt;fix.longitude;
-	heading=-dgps-&gt;fix.track;
-	speed=dgps-&gt;fix.speed;
+	la = dgps-&gt;fix.latitude;
+	lo = dgps-&gt;fix.longitude;
+	heading = -dgps-&gt;fix.track;
+	speed = dgps-&gt;fix.speed;
 
 #else
 	if (!dgps-&gt;online)
-		fix=0;
+		fix = 0;
 	switch (dgps-&gt;mode) {
 	case MODE_NOT_SEEN:
-		fix=0;
+		fix = 0;
 		break;
 	case MODE_NO_FIX:
-		fix=0;
+		fix = 0;
 		break;
 	}
-	la=dgps-&gt;latitude;
-	lo=dgps-&gt;longitude;
-	heading=-dgps-&gt;track;
-	speed=dgps-&gt;speed*KNOTS_TO_MPH/METERS_TO_MILES/3600; /* speed in knots -&gt; miles per hour -&gt; meter per hour -&gt; meter per secon */
+	la = dgps-&gt;latitude;
+	lo = dgps-&gt;longitude;
+	heading = -dgps-&gt;track;
+	speed = dgps-&gt;speed * KNOTS_TO_MPH / METERS_TO_MILES / 3600; /* speed in knots -&gt; miles per hour -&gt; meter per hour -&gt; meter per secon */
 #endif
-	tlat=la;
-	tlon=lo;
+	tlat = la;
+	tlon = lo;
 	if (fix) {
 		printf(&quot;have a fix\n&quot;);
-		nav_center(la,lo);
+		nav_center(la, lo);
 		if (!finitef(heading)) {
-			heading=get_heading(lat_old,lon_old,la,lo);
-			if (!lastfix &amp;&amp; fix) 		{
-				s3d_scale(user_icon,1.0/RESCALE);
+			heading = get_heading(lat_old, lon_old, la, lo);
+			if (!lastfix &amp;&amp; fix)   {
+				s3d_scale(user_icon, 1.0 / RESCALE);
 			}
-			if (lastfix &amp;&amp; !fix)		{
-				s3d_scale(user_icon,0.3/RESCALE);
-				lat=tlat;
-				lon=tlon;
+			if (lastfix &amp;&amp; !fix)  {
+				s3d_scale(user_icon, 0.3 / RESCALE);
+				lat = tlat;
+				lon = tlon;
 			}
 		}
-		if (finitef(heading))		s3d_rotate(user_icon,0,heading,0); /* wrong rotation? */
+		if (finitef(heading))  s3d_rotate(user_icon, 0, heading, 0); /* wrong rotation? */
 		if (finitef(speed)) {
 			/* print some information */
-			snprintf(buf,BUFSIZE,&quot;speed: %3.2f km/h&quot;,speed*3.6);
-			speed_old=speed;
+			snprintf(buf, BUFSIZE, &quot;speed: %3.2f km/h&quot;, speed*3.6);
+			speed_old = speed;
 		} else
-			snprintf(buf,BUFSIZE,&quot;speed: NA (old: %3.2f km/h)&quot;,speed_old*3.6);
+			snprintf(buf, BUFSIZE, &quot;speed: NA (old: %3.2f km/h)&quot;, speed_old*3.6);
 
-		if (gps_info!=-1)	s3d_del_object(gps_info);
-		gps_info=s3d_draw_string(buf,&amp;slen);
-		s3d_translate(gps_info,-slen/2,1,0);
+		if (gps_info != -1) s3d_del_object(gps_info);
+		gps_info = s3d_draw_string(buf, &amp;slen);
+		s3d_translate(gps_info, -slen / 2, 1, 0);
 		s3d_link(gps_info, user_icon);
-		s3d_flags_on(gps_info,S3D_OF_VISIBLE);
+		s3d_flags_on(gps_info, S3D_OF_VISIBLE);
 	}
 
 
-	lat_old=la;
-	lon_old=lo;
-	lastfix=fix;
+	lat_old = la;
+	lon_old = lo;
+	lastfix = fix;
 }
 int gps_init(char *gpshost)
 {
 	char *err_str;
-	dgps=gps_open(gpshost,&quot;2947&quot;);
-	if (dgps==NULL) {
-		switch ( errno ) {
+	dgps = gps_open(gpshost, &quot;2947&quot;);
+	if (dgps == NULL) {
+		switch (errno) {
 		case NL_NOSERVICE:
 			err_str = &quot;can't get service entry&quot;;
 			break;
@@ -201,25 +201,25 @@
 			err_str = &quot;Unknown&quot;;
 			break;
 		}
-		/*		printf(&quot;no connection to gpsd\n&quot;);*/
-		fprintf(stderr, &quot;s3dosm: no gpsd running or network error: %d, %s\n&quot;	,  errno, err_str);
+		/*  printf(&quot;no connection to gpsd\n&quot;);*/
+		fprintf(stderr, &quot;s3dosm: no gpsd running or network error: %d, %s\n&quot; ,  errno, err_str);
 		return(-1);
 	}
-	user_icon=s3d_clone(icons[ICON_ARROW].oid);
-	user_icon_rotator=s3d_new_object();
-	s3d_link(user_icon,user_icon_rotator);
-	s3d_link(user_icon_rotator,oidy);
-	s3d_flags_on(user_icon,S3D_OF_VISIBLE);
-	s3d_scale(user_icon,1.0/RESCALE);
-	tlat=lat=lat_old=0.0;
-	tlon=lon=lon_old=0.0;
-	gps_active=1;
+	user_icon = s3d_clone(icons[ICON_ARROW].oid);
+	user_icon_rotator = s3d_new_object();
+	s3d_link(user_icon, user_icon_rotator);
+	s3d_link(user_icon_rotator, oidy);
+	s3d_flags_on(user_icon, S3D_OF_VISIBLE);
+	s3d_scale(user_icon, 1.0 / RESCALE);
+	tlat = lat = lat_old = 0.0;
+	tlon = lon = lon_old = 0.0;
+	gps_active = 1;
 	gps_query(dgps, &quot;w+x\n&quot;);
 	return(0);
 }
 int gps_main()
 {
-	if (gps_active &amp;&amp; ((frame%6)==0)) {
+	if (gps_active &amp;&amp; ((frame % 6) == 0)) {
 		if (gps_poll(dgps) &lt; 0) {
 			printf(&quot;read error on server socket\n&quot;);
 			gps_quit();
@@ -228,19 +228,19 @@
 		/*show_gpsdata(dgps);*/
 		show_position(dgps);
 	}
-	if ((fabs(tlat-lat)&gt;0.00001) &amp;&amp; (fabs(tlon-lon)&gt;0.00001)) {
-		if (lat==0.0 &amp;&amp; lon==0.0) {
-			lat=tlat;
-			lon=tlon;
+	if ((fabs(tlat - lat) &gt; 0.00001) &amp;&amp; (fabs(tlon - lon) &gt; 0.00001)) {
+		if (lat == 0.0 &amp;&amp; lon == 0.0) {
+			lat = tlat;
+			lon = tlon;
 		} else {
-			lat=(tlat+lat*7)/8;
-			lon=(tlon+lon*7)/8;
+			lat = (tlat + lat * 7) / 8;
+			lon = (tlon + lon * 7) / 8;
 		}
 	} else {
-		tlat=lat;
-		tlon=lon;
+		tlat = lat;
+		tlon = lon;
 	}
-	draw_translate_icon(user_icon_rotator,lat,lon);
+	draw_translate_icon(user_icon_rotator, lat, lon);
 	frame++;
 	return(0);
 }
@@ -248,7 +248,7 @@
 {
 	if (gps_active) {
 		printf(&quot;deactivating gps-connection ...\n&quot;);
-		gps_active=0;
+		gps_active = 0;
 		gps_close(dgps);
 	}
 	return(0);

Modified: trunk/apps/s3dosm/http_error_codes.c
===================================================================
--- trunk/apps/s3dosm/http_error_codes.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/http_error_codes.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,35 +1,35 @@
 /* http_error_codes.c - Error code declarations
 
-	HTTP Fetcher
- 	Copyright (C) 2001 Lyle Hanson (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lhanson at cs.nmu.edu</A>)
+ HTTP Fetcher
+  Copyright (C) 2001 Lyle Hanson (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lhanson at cs.nmu.edu</A>)
 
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Library General Public
-	License as published by the Free Software Foundation; either
-	version 2 of the License, or (at your option) any later version.
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Library General Public
+ License as published by the Free Software Foundation; either
+ version 2 of the License, or (at your option) any later version.
 
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Library General Public License for more details.
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Library General Public License for more details.
 
-	See LICENSE file for details
+ See LICENSE file for details
  */
 
 
 /* Note that '%d' cannot be escaped at this time */
 const char *http_errlist[] = {
-	&quot;Success&quot;,										/* HF_SUCCESS		*/
-	&quot;Internal Error. What the hell?!&quot;,				/* HF_METAERROR		*/
-	&quot;Got NULL url&quot;,									/* HF_NULLURL		*/
-	&quot;Timed out, no metadata for %d seconds&quot;,		/* HF_HEADTIMEOUT 	*/
-	&quot;Timed out, no data for %d seconds&quot;,			/* HF_DATATIMEOUT	*/
-	&quot;Couldn't find return code in HTTP response&quot;,	/* HF_FRETURNCODE	*/
-	&quot;Couldn't convert return code in HTTP response&quot;,/* HF_CRETURNCODE	*/
-	&quot;Request returned a status code of %d&quot;,			/* HF_STATUSCODE	*/
-	&quot;Couldn't convert Content-Length to integer&quot;	/* HF_CONTENTLEN	*/
+	&quot;Success&quot;,          /* HF_SUCCESS  */
+	&quot;Internal Error. What the hell?!&quot;,    /* HF_METAERROR  */
+	&quot;Got NULL url&quot;,         /* HF_NULLURL  */
+	&quot;Timed out, no metadata for %d seconds&quot;,  /* HF_HEADTIMEOUT  */
+	&quot;Timed out, no data for %d seconds&quot;,   /* HF_DATATIMEOUT */
+	&quot;Couldn't find return code in HTTP response&quot;, /* HF_FRETURNCODE */
+	&quot;Couldn't convert return code in HTTP response&quot;,/* HF_CRETURNCODE */
+	&quot;Request returned a status code of %d&quot;,   /* HF_STATUSCODE */
+	&quot;Couldn't convert Content-Length to integer&quot; /* HF_CONTENTLEN */
 };
 
 /* Used to copy in messages from http_errlist[] and replace %d's with
- *	the value of errorInt.  Then we can pass the pointer to THIS */
+ * the value of errorInt.  Then we can pass the pointer to THIS */
 char convertedError[128];

Modified: trunk/apps/s3dosm/http_error_codes.h
===================================================================
--- trunk/apps/s3dosm/http_error_codes.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/http_error_codes.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,18 +1,18 @@
 /* http_error_codes.h - Error code definitions
 
-	Copyright (C) 2001 Lyle Hanson (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lhanson at cs.nmu.edu</A>)
+ Copyright (C) 2001 Lyle Hanson (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lhanson at cs.nmu.edu</A>)
 
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Library General Public
-	License as published by the Free Software Foundation; either
-	version 2 of the License, or (at your option) any later version.
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Library General Public
+ License as published by the Free Software Foundation; either
+ version 2 of the License, or (at your option) any later version.
 
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Library General Public License for more details.
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Library General Public License for more details.
 
-	See LICENSE file for details
+ See LICENSE file for details
 
  */
 
@@ -20,19 +20,19 @@
 #define HTTP_ERROR_CODES_H
 
 /* Error sources */
-#define FETCHER_ERROR	0
-#define ERRNO			1
-#define H_ERRNO			2
+#define FETCHER_ERROR 0
+#define ERRNO   1
+#define H_ERRNO   2
 
 /* HTTP Fetcher error codes */
-#define HF_SUCCESS		0
-#define HF_METAERROR	1
-#define HF_NULLURL		2
-#define HF_HEADTIMEOUT	3
-#define HF_DATATIMEOUT	4
-#define HF_FRETURNCODE	5
-#define HF_CRETURNCODE	6
-#define HF_STATUSCODE	7
-#define HF_CONTENTLEN	8
+#define HF_SUCCESS  0
+#define HF_METAERROR 1
+#define HF_NULLURL  2
+#define HF_HEADTIMEOUT 3
+#define HF_DATATIMEOUT 4
+#define HF_FRETURNCODE 5
+#define HF_CRETURNCODE 6
+#define HF_STATUSCODE 7
+#define HF_CONTENTLEN 8
 
 #endif

Modified: trunk/apps/s3dosm/http_fetcher.c
===================================================================
--- trunk/apps/s3dosm/http_fetcher.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/http_fetcher.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,22 +1,22 @@
 /* http_fetcher.c - HTTP handling functions
 
-	Copyright (C) 2001 Lyle Hanson (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lhanson at cs.nmu.edu</A>)
+ Copyright (C) 2001 Lyle Hanson (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lhanson at cs.nmu.edu</A>)
 
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Library General Public
-	License as published by the Free Software Foundation; either
-	version 2 of the License, or (at your option) any later version.
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Library General Public
+ License as published by the Free Software Foundation; either
+ version 2 of the License, or (at your option) any later version.
 
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Library General Public License for more details.
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Library General Public License for more details.
 
-	See included LICENSE file for details
+ See included LICENSE file for details
 
-	Changes:
-		Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
-		+ added http_setAuth() to support basic http-authentication and some minor fixes
+ Changes:
+  Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+  + added http_setAuth() to support basic http-authentication and some minor fixes
 
  */
 
@@ -38,21 +38,21 @@
 char *auth = NULL;
 int hideUserAgent = 0;
 int hideReferer = 1;
-extern const char *http_errlist[];	/* Array of HTTP Fetcher error messages */
-extern char convertedError[128];	/* Buffer to used when errors contain %d */
+extern const char *http_errlist[]; /* Array of HTTP Fetcher error messages */
+extern char convertedError[128]; /* Buffer to used when errors contain %d */
 static int errorSource = 0;
 static int http_errno = 0;
-static int errorInt = 0;			/* When the error message has a %d in it,
-									 *	this variable is inserted */
+static int errorInt = 0;   /* When the error message has a %d in it,
+          * this variable is inserted */
 static int freeOldAgent = 0; /* Indicates previous malloc's */
 static int freeOldReferer = 0; /* Indicated previous malloc's */
 
 
 /*
  * Actually downloads the page, registering a hit (donation)
- *	If the fileBuf passed in is NULL, the url is downloaded and then
- *	freed; otherwise the necessary space is allocated for fileBuf.
- *	Returns size of download on success, -1 on error is set,
+ * If the fileBuf passed in is NULL, the url is downloaded and then
+ * freed; otherwise the necessary space is allocated for fileBuf.
+ * Returns size of download on success, -1 on error is set,
  */
 int http_fetch(const char *url_tmp, char **fileBuf)
 {
@@ -72,7 +72,7 @@
 	}
 
 	/* Copy the url passed in into a buffer we can work with, change, etc. */
-	url = malloc(strlen(url_tmp)+1);
+	url = malloc(strlen(url_tmp) + 1);
 	if (url == NULL) {
 		errorSource = ERRNO;
 		return -1;
@@ -94,7 +94,7 @@
 	/* Compose a request string */
 	if (charIndex == NULL)
 		/* The url has no '/' in it, assume the user is making a root-level
-		 *	request */
+		 * request */
 		sprintf(requestBuf, &quot;GET / %s\r\n&quot;, HTTP_VERSION);
 	else
 		sprintf(requestBuf, &quot;GET %s %s\r\n&quot;, charIndex, HTTP_VERSION);
@@ -107,7 +107,7 @@
 	strcat(requestBuf, &quot;\r\n&quot;);
 
 
-	if (!hideReferer &amp;&amp; referer != NULL) {	/* NO default referer */
+	if (!hideReferer &amp;&amp; referer != NULL) { /* NO default referer */
 		strcat(requestBuf, &quot;Referer: &quot;);
 		strcat(requestBuf, referer);
 		strcat(requestBuf, &quot;\r\n&quot;);
@@ -124,7 +124,7 @@
 		strcat(requestBuf, userAgent);
 		strcat(requestBuf, &quot;\r\n&quot;);
 	}
-	if (auth!=NULL) {
+	if (auth != NULL) {
 		strcat(requestBuf, &quot;Authorization: Basic &quot;);
 		strcat(requestBuf, auth);
 		strcat(requestBuf, &quot;\r\n&quot;);
@@ -132,7 +132,7 @@
 	strcat(requestBuf, &quot;\r\n&quot;);
 
 	printf(&quot;[HTTP] creating connection ...\n&quot;);
-	sock = makeSocket(host);			/* errorSource set within makeSocket */
+	sock = makeSocket(host);   /* errorSource set within makeSocket */
 	if (sock == -1) {
 		free(url);
 		return -1;
@@ -147,7 +147,7 @@
 
 	printf(&quot;[HTTP] receiving header\n&quot;);
 	/* Grab enough of the response to get the metadata */
-	ret = _http_read_header(sock, headerBuf);	/* errorSource set within */
+	ret = _http_read_header(sock, headerBuf); /* errorSource set within */
 	if (ret &lt; 0) {
 		close(sock);
 		free(url);
@@ -176,10 +176,10 @@
 		http_errno = HF_CRETURNCODE;
 		return -1;
 	}
-	if (i&lt;200 || i&gt;299) {
+	if (i &lt; 200 || i &gt; 299) {
 		close(sock);
 		free(url);
-		errorInt = i;	/* Status code, to be inserted in error string */
+		errorInt = i; /* Status code, to be inserted in error string */
 		errorSource = FETCHER_ERROR;
 		http_errno = HF_STATUSCODE;
 		return -1;
@@ -187,9 +187,9 @@
 
 	/*
 	 * Parse out about how big the data segment is.
-	 *	Note that under current HTTP standards (1.1 and prior), the
-	 *	Content-Length field is not guaranteed to be accurate or even present.
-	 *	I just use it here so I can allocate a ballpark amount of memory.
+	 * Note that under current HTTP standards (1.1 and prior), the
+	 * Content-Length field is not guaranteed to be accurate or even present.
+	 * I just use it here so I can allocate a ballpark amount of memory.
 	 *
 	 * Note that some servers use different capitalization
 	 */
@@ -213,7 +213,7 @@
 	if (contentLength == -1)
 		contentLength = DEFAULT_PAGE_BUF_SIZE;
 
-	pageBuf = (char *)malloc(contentLength+1);
+	pageBuf = (char *)malloc(contentLength + 1);
 	if (pageBuf == NULL) {
 		close(sock);
 		free(url);
@@ -229,9 +229,9 @@
 		tv.tv_usec = 0;
 
 		if (timeout &gt;= 0)
-			selectRet = select(sock+1, &amp;rfds, NULL, NULL, &amp;tv);
-		else		/* No timeout, can block indefinately */
-			selectRet = select(sock+1, &amp;rfds, NULL, NULL, NULL);
+			selectRet = select(sock + 1, &amp;rfds, NULL, NULL, &amp;tv);
+		else  /* No timeout, can block indefinately */
+			selectRet = select(sock + 1, &amp;rfds, NULL, NULL, NULL);
 
 		if (selectRet == 0 &amp;&amp; timeout &lt; 0) {
 			errorSource = FETCHER_ERROR;
@@ -262,8 +262,8 @@
 
 		if (ret &gt; 0) {
 			/* To be tolerant of inaccurate Content-Length fields, we'll
-			 *	allocate another read-sized chunk to make sure we have
-			 *	enough room.
+			 * allocate another read-sized chunk to make sure we have
+			 * enough room.
 			 */
 			pageBuf = (char *)realloc(pageBuf, bytesRead + contentLength);
 			if (pageBuf == NULL) {
@@ -274,7 +274,7 @@
 				return -1;
 			}
 		}
-		printf(&quot;[HTTP] read %d bytes\n&quot;,ret);
+		printf(&quot;[HTTP] read %d bytes\n&quot;, ret);
 	}
 
 	/*
@@ -282,9 +282,9 @@
 	 */
 	pageBuf = (char *)realloc(pageBuf, bytesRead);
 	/* pageBuf shouldn't be null, since we're _shrinking_ the buffer,
-	 *	and if it DID fail, we could go on with the too-large buffer,
-	 *	but something would DEFINATELY be wrong, so we'll just give
-	 *	an error message */
+	 * and if it DID fail, we could go on with the too-large buffer,
+	 * but something would DEFINATELY be wrong, so we'll just give
+	 * an error message */
 	if (pageBuf == NULL) {
 		close(sock);
 		free(url);
@@ -293,7 +293,7 @@
 		return -1;
 	}
 
-	if (fileBuf == NULL)	/* They just wanted us to &quot;hit&quot; the url */
+	if (fileBuf == NULL) /* They just wanted us to &quot;hit&quot; the url */
 		free(pageBuf);
 	else
 		*fileBuf = pageBuf;
@@ -363,46 +363,46 @@
 int http_setAuth(const char *user, const char *pass)
 {
 	unsigned char plain[1024];
-	char ec64[]=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
+	char ec64[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
 	char *b64;
-	int i,j,c,len,n;
-	char o=0;
+	int i, j, c, len, n;
+	char o = 0;
 	/* base64 encode user and pass */
-	if ((user==NULL) || (pass==NULL)) { /* bad input or request to clean up */
-		if (auth!=NULL)	free(auth); /* free old auth */
-		auth=NULL;
+	if ((user == NULL) || (pass == NULL)) { /* bad input or request to clean up */
+		if (auth != NULL) free(auth); /* free old auth */
+		auth = NULL;
 		return(-1);
 	}
 
-	snprintf((char *)plain,1024,&quot;%s:%s&quot;,user,pass);
-	len=strlen((char *)plain);
-	b64=malloc(len*4+1);
-	i=j=c=0;
-	while (i&lt;len || c!=0) {
+	snprintf((char *)plain, 1024, &quot;%s:%s&quot;, user, pass);
+	len = strlen((char *)plain);
+	b64 = malloc(len * 4 + 1);
+	i = j = c = 0;
+	while (i &lt; len || c != 0) {
 		switch (c) {
 		case 0:
-			o=ec64[ n=plain[i] &gt;&gt; 2 ];
+			o = ec64[ n=plain[i] &gt;&gt; 2 ];
 			i++;
 			break;
 		case 1:
-			o=ec64[ n=((plain[i-1]&amp;0x3)&lt;&lt;4) | (plain[i]&gt;&gt;4) ];
+			o = ec64[ n=((plain[i-1] &amp; 0x3) &lt;&lt; 4) | (plain[i] &gt;&gt; 4)];
 			i++;
 			break;
 		case 2:
-			o=(i&gt;=len)?'=':ec64[ n=((plain[i-1]&amp;0xf)&lt;&lt;2) | (plain[i]&gt;&gt;6) ];
+			o = (i &gt;= len) ? '=' : ec64[ n=((plain[i-1] &amp; 0xf) &lt;&lt; 2) | (plain[i] &gt;&gt; 6)];
 			break;
 		case 3:
-			o=(i&gt;=len)?'=':ec64[ n=(plain[i]&amp;0x3f) ];
+			o = (i &gt;= len) ? '=' : ec64[ n=(plain[i] &amp; 0x3f)];
 			i++;
 			break;
 		}
-		b64[j]=o;
-		c=(c+1)%4;
+		b64[j] = o;
+		c = (c + 1) % 4;
 		j++;
 	}
-	b64[j]=0;
-	if (auth!=NULL)	free(auth); /* free old auth */
-	auth=b64;
+	b64[j] = 0;
+	if (auth != NULL) free(auth); /* free old auth */
+	auth = b64;
 	return(0);
 
 
@@ -413,7 +413,7 @@
 
 /*
  * Changes the amount of time that HTTP Fetcher will wait for data
- *	before timing out on reads
+ * before timing out on reads
  */
 void http_setTimeout(int seconds)
 {
@@ -425,10 +425,10 @@
 /*
  * Puts the filename portion of the url into 'filename'.
  * Returns:
- *	0 on success
- *	1 when url contains no end filename (i.e., 'www.foo.com/'),
- *		and **filename should not be assumed to be valid
- *	-1 on error
+ * 0 on success
+ * 1 when url contains no end filename (i.e., 'www.foo.com/'),
+ *  and **filename should not be assumed to be valid
+ * -1 on error
  */
 int http_parseFilename(const char *url, char **filename)
 {
@@ -461,7 +461,7 @@
 
 
 /* Depending on the source of error, calls either perror() or prints
- *	an HTTP Fetcher error message to stdout */
+ * an HTTP Fetcher error message to stdout */
 void http_perror(const char *string)
 {
 	if (errorSource == ERRNO)
@@ -479,13 +479,13 @@
 		} else {
 			/* The error string has a %d in it, we need to insert errorInt */
 			stringIndex = (char *)http_errlist[http_errno];
-			while (*stringIndex != '%') {		/* Print up to the %d */
+			while (*stringIndex != '%') {  /* Print up to the %d */
 				fputc(*stringIndex, stderr);
 				stringIndex++;
 			}
-			fprintf(stderr, &quot;%d&quot;, errorInt);	/* Print the number */
-			stringIndex += 2;					/* Skip past the %d */
-			while (*stringIndex != 0) {		/* Print up to the end NULL */
+			fprintf(stderr, &quot;%d&quot;, errorInt); /* Print the number */
+			stringIndex += 2;     /* Skip past the %d */
+			while (*stringIndex != 0) {  /* Print up to the end NULL */
 				fputc(*stringIndex, stderr);
 				stringIndex++;
 			}
@@ -498,9 +498,9 @@
 
 /*
  * Returns a pointer to the current error description message. The
- *	message pointed to is only good until the next call to http_strerror(),
- *	so if you need to hold on to the message for a while you should make
- *	a copy of it
+ * message pointed to is only good until the next call to http_strerror(),
+ * so if you need to hold on to the message for a while you should make
+ * a copy of it
  */
 const char *http_strerror()
 {
@@ -513,33 +513,33 @@
 			return http_errlist[http_errno];
 		else {
 			/* The error string has a %d in it, we need to insert errorInt.
-			 *	convertedError[128] has been declared for that purpose */
+			 * convertedError[128] has been declared for that purpose */
 			char *stringIndex, *originalError;
 
 			originalError = (char *)http_errlist[http_errno];
-			convertedError[0] = 0;		/* Start off with NULL */
+			convertedError[0] = 0;  /* Start off with NULL */
 			stringIndex = strstr(originalError, &quot;%d&quot;);
-			strncat(convertedError, originalError,		/* Copy up to %d */
+			strncat(convertedError, originalError,  /* Copy up to %d */
 			        abs(stringIndex - originalError));
-			sprintf(&amp;convertedError[strlen(convertedError)],&quot;%d&quot;,errorInt);
-			stringIndex += 2;		/* Skip past the %d */
+			sprintf(&amp;convertedError[strlen(convertedError)], &quot;%d&quot;, errorInt);
+			stringIndex += 2;  /* Skip past the %d */
 			strcat(convertedError, stringIndex);
 
 			return convertedError;
 		}
 	}
 
-	return http_errlist[HF_METAERROR];	/* Should NEVER happen */
+	return http_errlist[HF_METAERROR]; /* Should NEVER happen */
 }
 
 
 /*
  * Reads the metadata of an HTTP response.
  * Perhaps a little inefficient, as it reads 1 byte at a time, but
- *	I don't think it's that much of a loss (most headers aren't HUGE).
+ * I don't think it's that much of a loss (most headers aren't HUGE).
  * Returns:
- *	# of bytes read on success, or
- *	-1 on error
+ * # of bytes read on success, or
+ * -1 on error
  */
 int _http_read_header(int sock, char *headerPtr)
 {
@@ -554,9 +554,9 @@
 		tv.tv_usec = 0;
 
 		if (timeout &gt;= 0)
-			selectRet = select(sock+1, &amp;rfds, NULL, NULL, &amp;tv);
-		else		/* No timeout, can block indefinately */
-			selectRet = select(sock+1, &amp;rfds, NULL, NULL, NULL);
+			selectRet = select(sock + 1, &amp;rfds, NULL, NULL, &amp;tv);
+		else  /* No timeout, can block indefinately */
+			selectRet = select(sock + 1, &amp;rfds, NULL, NULL, NULL);
 
 		if (selectRet == 0 &amp;&amp; timeout &lt; 0) {
 			errorSource = FETCHER_ERROR;
@@ -575,12 +575,12 @@
 		}
 		bytesRead++;
 
-		if (*headerPtr == '\r') {		/* Ignore CR */
+		if (*headerPtr == '\r') {  /* Ignore CR */
 			/* Basically do nothing special, just don't set newlines
-			 *	to 0 */
+			 * to 0 */
 			headerPtr++;
 			continue;
-		} else if (*headerPtr == '\n')		/* LF is the separator */
+		} else if (*headerPtr == '\n')  /* LF is the separator */
 			newlines++;
 		else
 			newlines = 0;
@@ -588,7 +588,7 @@
 		headerPtr++;
 	}
 
-	headerPtr -= 3;		/* Snip the trailing LF's */
+	headerPtr -= 3;  /* Snip the trailing LF's */
 	*headerPtr = '\0';
 	return bytesRead;
 }
@@ -598,14 +598,14 @@
 /*
  * Opens a TCP socket and returns the descriptor
  * Returns:
- *	socket descriptor, or
- *	-1 on error
+ * socket descriptor, or
+ * -1 on error
  */
 int makeSocket(const char *host)
 {
-	int sock;										/* Socket descriptor */
-	struct sockaddr_in sa;							/* Socket address */
-	struct hostent *hp;								/* Host entity */
+	int sock;          /* Socket descriptor */
+	struct sockaddr_in sa;       /* Socket address */
+	struct hostent *hp;        /* Host entity */
 	int ret;
 
 	hp = gethostbyname(host);
@@ -616,8 +616,8 @@
 
 	/* Copy host address from hostent to (server) socket address */
 	memcpy((char *)&amp;sa.sin_addr, (char *)hp-&gt;h_addr, hp-&gt;h_length);
-	sa.sin_family = hp-&gt;h_addrtype;		/* Set service sin_family to PF_INET */
-	sa.sin_port = htons(PORT_NUMBER);	/* Put portnum into sockaddr */
+	sa.sin_family = hp-&gt;h_addrtype;  /* Set service sin_family to PF_INET */
+	sa.sin_port = htons(PORT_NUMBER); /* Put portnum into sockaddr */
 
 	sock = socket(hp-&gt;h_addrtype, SOCK_STREAM, 0);
 	if (sock == -1) {
@@ -625,7 +625,7 @@
 		return -1;
 	}
 
-	ret = connect(sock, (struct sockaddr *)&amp;sa, sizeof(sa));
+	ret = connect(sock, (struct sockaddr *) &amp; sa, sizeof(sa));
 	if (ret == -1) {
 		errorSource = ERRNO;
 		return -1;

Modified: trunk/apps/s3dosm/http_fetcher.h
===================================================================
--- trunk/apps/s3dosm/http_fetcher.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/http_fetcher.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,23 +1,23 @@
 /* http_fetcher.h - HTTP handling functions
 
-	HTTP Fetcher
-	Copyright (C) 2001 Lyle Hanson (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lhanson at cs.nmu.edu</A>)
+ HTTP Fetcher
+ Copyright (C) 2001 Lyle Hanson (<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lhanson at cs.nmu.edu</A>)
 
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Library General Public
-	License as published by the Free Software Foundation; either
-	version 2 of the License, or (at your option) any later version.
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Library General Public
+ License as published by the Free Software Foundation; either
+ version 2 of the License, or (at your option) any later version.
 
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Library General Public License for more details.
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Library General Public License for more details.
 
-	See LICENSE file for details
+ See LICENSE file for details
 
-	Changes:
-		Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
-		+ added http_setAuth() to support basic http-authentication and some minor fixes
+ Changes:
+  Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+  + added http_setAuth() to support basic http-authentication and some minor fixes
 
  */
 
@@ -26,16 +26,15 @@
 
 #include &quot;http_error_codes.h&quot;
 
-#define PORT_NUMBER 			80
-#define HTTP_VERSION 			&quot;HTTP/1.1&quot;
-#define DEFAULT_USER_AGENT		&quot;HTTP Fetcher&quot;
-#define	HTTP_FETCHER_VERSION	&quot;1.0&quot;
-#define DEFAULT_READ_TIMEOUT	30		/* Seconds to wait before giving up
-*	when no data is arriving */
+#define PORT_NUMBER    80
+#define HTTP_VERSION    &quot;HTTP/1.1&quot;
+#define DEFAULT_USER_AGENT  &quot;HTTP Fetcher&quot;
+#define HTTP_FETCHER_VERSION &quot;1.0&quot;
+#define DEFAULT_READ_TIMEOUT 30  /* Seconds to wait before giving up when no data is arriving */
 
-#define REQUEST_BUF_SIZE 		1024
-#define HEADER_BUF_SIZE 		1024
-#define DEFAULT_PAGE_BUF_SIZE 	1024 * 200	/* 200K should hold most things */
+#define REQUEST_BUF_SIZE   1024
+#define HEADER_BUF_SIZE   1024
+#define DEFAULT_PAGE_BUF_SIZE  1024 * 200 /* 200K should hold most things */
 
 
 
@@ -45,48 +44,48 @@
 
 /*
  * [!!! NOTE !!!]  All HTTP Fetcher functions return -1 on error.  You can
- *	then either call http_perror to print the error message or call
- *	http_strerror to get a pointer to it
+ * then either call http_perror to print the error message or call
+ * http_strerror to get a pointer to it
  */
 
 
 /*
  * Download the page, registering a hit. If you pass it a NULL for fileBuf,
- *	'url' will be requested but will not remain in memory (useful for
- *	simply registering a hit).  Otherwise necessary space will be allocated
- *	and will be pointed to by fileBuf.
+ * 'url' will be requested but will not remain in memory (useful for
+ * simply registering a hit).  Otherwise necessary space will be allocated
+ * and will be pointed to by fileBuf.
  * Returns:
- *	# of bytes downloaded, or
- *	-1 on error
+ * # of bytes downloaded, or
+ * -1 on error
  */
 int http_fetch(const char *url, char **fileBuf);
 
 /*
  * Changes the User Agent (shown to the web server with each request)
- *	Send it NULL to avoid telling the server a User Agent
- *	By default, the User Agent is sent (The default one unless changed)
+ * Send it NULL to avoid telling the server a User Agent
+ * By default, the User Agent is sent (The default one unless changed)
  * Returns:
- *	0 on success, or
- *	-1 on error (previous value for agent remains unchanged)
+ * 0 on success, or
+ * -1 on error (previous value for agent remains unchanged)
  */
 int http_setUserAgent(const char *newAgent);
 
 /*
  * Changes the Referer (shown to the web server with each request)
- *	Send it NULL to avoid thelling the server a Referer
- *	By default, no Referer is sent
+ * Send it NULL to avoid thelling the server a Referer
+ * By default, no Referer is sent
  * Returns:
- *	0 on success, or
- *	-1 on error
+ * 0 on success, or
+ * -1 on error
  */
 int http_setReferer(const char *newReferer);
 
 /*
  * Changes the maximum amount of time that HTTP Fetcher will wait on
- *	data.  If this many seconds elapses without more data from the
- *	server, http_fetch will return with an error.
+ * data.  If this many seconds elapses without more data from the
+ * server, http_fetch will return with an error.
  * If you pass a value less than 0, reads will not time out, potentially
- *	waiting forever (or until data shows up, whichever comes first)
+ * waiting forever (or until data shows up, whichever comes first)
  */
 void http_setTimeout(int seconds);
 
@@ -101,24 +100,24 @@
 /*
  * Takes a url and puts the filename portion of it into 'filename'.
  * Returns:
- *	0 on success, or
- *	1 when url contains no end filename (i.e., &quot;www.foo.com/&quot;)
- *		and **filename should not be assumed to point to anything), or
- *	-1 on error
+ * 0 on success, or
+ * 1 when url contains no end filename (i.e., &quot;www.foo.com/&quot;)
+ *  and **filename should not be assumed to point to anything), or
+ * -1 on error
  */
 int http_parseFilename(const char *url, char **filename);
 
 /*
  * Works like perror.  If an HTTP Fetcher function ever returns an
- *	error (-1), this will print a descriptive message to standard output
+ * error (-1), this will print a descriptive message to standard output
  */
 void http_perror(const char *string);
 
 /*
  * Returns a pointer to the current error description message.  The
- *	message pointed to is only good until the next call to http_strerror(),
- *	so if you need to hold on to the message for a while you should make
- *	a copy of it.
+ * message pointed to is only good until the next call to http_strerror(),
+ * so if you need to hold on to the message for a while you should make
+ * a copy of it.
  */
 const char *http_strerror();
 
@@ -131,16 +130,16 @@
 /*
  * Reads the metadata of an HTTP response.  On success returns the number
  * Returns:
- *	# of bytes read on success, or
- *	-1 on error
+ * # of bytes read on success, or
+ * -1 on error
  */
 int _http_read_header(int sock, char *headerPtr);
 
 /*
  * Opens a TCP socket and returns the descriptor
  * Returns:
- *	socket descriptor, or
- *	-1 on error
+ * socket descriptor, or
+ * -1 on error
  */
 int makeSocket(const char *host);
 

Modified: trunk/apps/s3dosm/io.c
===================================================================
--- trunk/apps/s3dosm/io.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/io.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,67 +23,67 @@
 
 
 #include &quot;s3dosm.h&quot;
-#include &lt;stdio.h&gt;		 /* fopen(), fread(), fclose() */
-#include &lt;stdlib.h&gt;		 /* malloc(), free() */
-#include &lt;string.h&gt;		 /* strstr() */
-#include &lt;sys/stat.h&gt;	 /* fstat() */
-#include &lt;getopt.h&gt;		 /* getopt() */
-#include &lt;errno.h&gt;		 /* errno */
-#include &lt;s3d.h&gt;		 /* s3d_usage() */
+#include &lt;stdio.h&gt;   /* fopen(), fread(), fclose() */
+#include &lt;stdlib.h&gt;   /* malloc(), free() */
+#include &lt;string.h&gt;   /* strstr() */
+#include &lt;sys/stat.h&gt;  /* fstat() */
+#include &lt;getopt.h&gt;   /* getopt() */
+#include &lt;errno.h&gt;   /* errno */
+#include &lt;s3d.h&gt;   /* s3d_usage() */
 
 char *read_file(char *fname, int *fsize)
 {
 	FILE *fp;
-	char *buf=NULL;
+	char *buf = NULL;
 	int filesize;
 	struct stat bf;
 
-	if ((fp = fopen(fname, &quot;rt&quot;)) == NULL)	{
-		fprintf(stderr,&quot;read_file( %s ):fopen(): %s&quot;,fname,strerror(errno));
+	if ((fp = fopen(fname, &quot;rt&quot;)) == NULL) {
+		fprintf(stderr, &quot;read_file( %s ):fopen(): %s&quot;, fname, strerror(errno));
 		return(NULL);
 	}
-	if (fstat(fileno(fp),&amp;bf))				{
-		fprintf(stderr,&quot;read_file( %s ):fopen(): %s&quot;,fname,strerror(errno));
+	if (fstat(fileno(fp), &amp;bf))    {
+		fprintf(stderr, &quot;read_file( %s ):fopen(): %s&quot;, fname, strerror(errno));
 		return(NULL);
 	}
-	filesize=bf.st_size;
-	if ((buf=malloc(filesize))==NULL)		{
-		fprintf(stderr,&quot;read_file( %s ):malloc(): %s&quot;,fname,strerror(errno));
+	filesize = bf.st_size;
+	if ((buf = malloc(filesize)) == NULL)  {
+		fprintf(stderr, &quot;read_file( %s ):malloc(): %s&quot;, fname, strerror(errno));
 		return(NULL);
 	}
 	fread(buf, filesize, 1, fp);
 	fclose(fp);
-	if (fsize!=NULL) *fsize=filesize;
+	if (fsize != NULL) *fsize = filesize;
 	return(buf);
 }
 
 int process_args(int argc, char **argv)
 {
-	int					 lopt_idx=0,i;
-	char				 c;
-	float				 minlat, minlon, maxlat, maxlon;
-	char 				 info[1024];
+	int      lopt_idx = 0, i;
+	char     c;
+	float     minlat, minlon, maxlat, maxlon;
+	char      info[1024];
 	struct option long_options[] = {
-		{&quot;help&quot;,0,0,'h'
-		}, {&quot;osm&quot;,1,0,'o'}, {0,0,0,0}
+		{&quot;help&quot;, 0, 0, 'h'
+		}, {&quot;osm&quot;, 1, 0, 'o'}, {0, 0, 0, 0}
 	};
-	optind=0;
-	opterr=0;
-	while (-1!=(c=getopt_long(argc,argv,&quot;dH:?ho&quot;,long_options,&amp;lopt_idx))) {
+	optind = 0;
+	opterr = 0;
+	while (-1 != (c = getopt_long(argc, argv, &quot;dH:?ho&quot;, long_options, &amp;lopt_idx))) {
 		switch (c) {
 		case 0:
 			break;
 		case 'o':
-			if (4==sscanf(optarg,&quot;%f,%f,%f,%f&quot;,&amp;minlat,&amp;minlon,&amp;maxlat,&amp;maxlon))
-				layerset_add(load_osm_web(minlat,minlon,maxlat,maxlon));
+			if (4 == sscanf(optarg, &quot;%f,%f,%f,%f&quot;, &amp;minlat, &amp;minlon, &amp;maxlat, &amp;maxlon))
+				layerset_add(load_osm_web(minlat, minlon, maxlat, maxlon));
 			else {
-				printf(&quot;%s: bad map bounding box&quot;,optarg);
+				printf(&quot;%s: bad map bounding box&quot;, optarg);
 				return(-1);
 			}
 			break;
 		case 'h':
 		case '?':
-			printf(&quot;\nUSAGE: %s [options] [files]\n\n&quot;,argv[0]);
+			printf(&quot;\nUSAGE: %s [options] [files]\n\n&quot;, argv[0]);
 			printf(&quot;options:\n&quot;);
 			printf(&quot;\t--osm, -o MINLAT,MINLON,MAXLAT,MAXLON:\n&quot;);
 			printf(&quot;\t\tload a map with the given bounding box\n\t\tfrom the openstreetmap server\n&quot;);
@@ -91,30 +91,30 @@
 			printf(&quot;supported file types:\n&quot;);
 			printf(&quot;\t+ Kismet .xml Logs\n&quot;);
 			printf(&quot;\t+ Opemstreetmap .osm files\n\n&quot;);
-			s3d_usage();	/* add s3d usage */
+			s3d_usage(); /* add s3d usage */
 			return(-1);
 		default:
 			break;
 		}
 	}
-	for (i=1;i&lt;argc;i++) {
-		if (strstr(argv[i],&quot;.osm&quot;)-argv[i]==strlen(argv[i])-4) {
-			snprintf(info,1024,&quot;loading OSM-File: %s&quot;,argv[i]);
+	for (i = 1;i &lt; argc;i++) {
+		if (strstr(argv[i], &quot;.osm&quot;) - argv[i] == strlen(argv[i]) - 4) {
+			snprintf(info, 1024, &quot;loading OSM-File: %s&quot;, argv[i]);
 			load_window(info);
 			layerset_add(load_osm_file(argv[i]));
-		} else if (strstr(argv[i],&quot;.xml&quot;)-argv[i]==strlen(argv[i])-4) { /* might be osm or kismet xml */
+		} else if (strstr(argv[i], &quot;.xml&quot;) - argv[i] == strlen(argv[i]) - 4) { /* might be osm or kismet xml */
 			char *file;
 			int fsize;
-			if (NULL==(file=read_file(argv[i],&amp;fsize)))
+			if (NULL == (file = read_file(argv[i], &amp;fsize)))
 				break;
-			if (NULL!=strstr(file,&quot;&lt;!DOCTYPE detection-run SYSTEM \&quot;<A HREF="http://kismetwireless.net">http://kismetwireless.net</A>&quot;)) {
-				snprintf(info,1024,&quot;loading Kismet-File: %s&quot;,argv[i]);
+			if (NULL != strstr(file, &quot;&lt;!DOCTYPE detection-run SYSTEM \&quot;<A HREF="http://kismetwireless.net">http://kismetwireless.net</A>&quot;)) {
+				snprintf(info, 1024, &quot;loading Kismet-File: %s&quot;, argv[i]);
 				load_window(info);
-				layerset_add(parse_kismet(file,fsize));
-			} else if (NULL!=strstr(file,&quot;&lt;osm &quot;)) {
-				snprintf(info,1024,&quot;loading OSM-File: %s&quot;,argv[i]);
+				layerset_add(parse_kismet(file, fsize));
+			} else if (NULL != strstr(file, &quot;&lt;osm &quot;)) {
+				snprintf(info, 1024, &quot;loading OSM-File: %s&quot;, argv[i]);
 				load_window(info);
-				layerset_add(parse_osm(file,fsize));
+				layerset_add(parse_osm(file, fsize));
 			}
 			free(file);
 		}

Modified: trunk/apps/s3dosm/kismet.c
===================================================================
--- trunk/apps/s3dosm/kismet.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/kismet.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,9 +22,9 @@
  */
 
 #include &quot;s3dosm.h&quot;
-#include &lt;math.h&gt;			/* fabs() */
-#include &lt;string.h&gt;			/* strcmp() */
-#include &lt;stdlib.h&gt;			/* strtof(),strtod(),strtol() */
+#include &lt;math.h&gt;   /* fabs() */
+#include &lt;string.h&gt;   /* strcmp() */
+#include &lt;stdlib.h&gt;   /* strtof(),strtod(),strtol() */
 #include &lt;libxml/parser.h&gt;
 #include &lt;libxml/tree.h&gt;
 static int layerid;
@@ -32,41 +32,41 @@
 {
 	node_t node;
 	xmlAttrPtr attr;
-	xmlNodePtr kids,gpskids;
+	xmlNodePtr kids, gpskids;
 
 	node_init(&amp;node);
-	attr=cur-&gt;properties;
+	attr = cur-&gt;properties;
 
-	node.base.layerid=layerid;
-	node.base.id=0;				/* let database decide */
-	node.visible=2;	/* something special */
-	for (kids=cur-&gt;children;kids;kids=kids-&gt;next) {
-		if (0==strcmp((char *)kids-&gt;name,&quot;gps-info&quot;)) {
-			for (gpskids=kids-&gt;children;gpskids;gpskids=gpskids-&gt;next) {
+	node.base.layerid = layerid;
+	node.base.id = 0;  /* let database decide */
+	node.visible = 2; /* something special */
+	for (kids = cur-&gt;children;kids;kids = kids-&gt;next) {
+		if (0 == strcmp((char *)kids-&gt;name, &quot;gps-info&quot;)) {
+			for (gpskids = kids-&gt;children;gpskids;gpskids = gpskids-&gt;next) {
 				/* get median value */
-				if (0==strcmp((char *)gpskids-&gt;name,&quot;min-lat&quot;)) 		node.lat=node.lat + strtod((char *)xmlNodeGetContent(gpskids-&gt;children),NULL)/2;
-				if (0==strcmp((char *)gpskids-&gt;name,&quot;max-lat&quot;)) 		node.lat=node.lat + strtod((char *)xmlNodeGetContent(gpskids-&gt;children),NULL)/2;
-				if (0==strcmp((char *)gpskids-&gt;name,&quot;min-lon&quot;)) 		node.lon=node.lon + strtod((char *)xmlNodeGetContent(gpskids-&gt;children),NULL)/2;
-				if (0==strcmp((char *)gpskids-&gt;name,&quot;max-lon&quot;)) 		node.lon=node.lon + strtod((char *)xmlNodeGetContent(gpskids-&gt;children),NULL)/2;
-				if (0==strcmp((char *)gpskids-&gt;name,&quot;min-alt&quot;)) 		node.alt=node.alt + strtod((char *)xmlNodeGetContent(gpskids-&gt;children),NULL)/2;
-				if (0==strcmp((char *)gpskids-&gt;name,&quot;max-alt&quot;)) 		node.alt=node.alt + strtod((char *)xmlNodeGetContent(gpskids-&gt;children),NULL)/2;
+				if (0 == strcmp((char *)gpskids-&gt;name, &quot;min-lat&quot;))   node.lat = node.lat + strtod((char *)xmlNodeGetContent(gpskids-&gt;children), NULL) / 2;
+				if (0 == strcmp((char *)gpskids-&gt;name, &quot;max-lat&quot;))   node.lat = node.lat + strtod((char *)xmlNodeGetContent(gpskids-&gt;children), NULL) / 2;
+				if (0 == strcmp((char *)gpskids-&gt;name, &quot;min-lon&quot;))   node.lon = node.lon + strtod((char *)xmlNodeGetContent(gpskids-&gt;children), NULL) / 2;
+				if (0 == strcmp((char *)gpskids-&gt;name, &quot;max-lon&quot;))   node.lon = node.lon + strtod((char *)xmlNodeGetContent(gpskids-&gt;children), NULL) / 2;
+				if (0 == strcmp((char *)gpskids-&gt;name, &quot;min-alt&quot;))   node.alt = node.alt + strtod((char *)xmlNodeGetContent(gpskids-&gt;children), NULL) / 2;
+				if (0 == strcmp((char *)gpskids-&gt;name, &quot;max-alt&quot;))   node.alt = node.alt + strtod((char *)xmlNodeGetContent(gpskids-&gt;children), NULL) / 2;
 			}
 		}
 	}
-	if ((fabs(node.lon)&gt;0.01) || (fabs(node.lat)&gt;0.01)) /* really, i don't want to discriminate anyone at 0 lat 0 lon running a wifi hotspot, even
-																	if it's in the middle of the ocean. i'm very sorry. */
+	if ((fabs(node.lon) &gt; 0.01) || (fabs(node.lat) &gt; 0.01)) /* really, i don't want to discriminate anyone at 0 lat 0 lon running a wifi hotspot, even
+                 if it's in the middle of the ocean. i'm very sorry. */
 	{
 
 		db_insert_node(&amp;node);
-		for (kids=cur-&gt;children;kids;kids=kids-&gt;next) {
-			if (0==strcmp((char *)kids-&gt;name,&quot;SSID&quot;)) 			db_add_tag(OBJECT_T(&amp;node),&quot;wifi_SSID&quot;,(char *)xmlNodeGetContent(kids-&gt;children));
-			if (0==strcmp((char *)kids-&gt;name,&quot;BSSID&quot;)) 			db_add_tag(OBJECT_T(&amp;node),&quot;wifi_BSSID&quot;,(char *)xmlNodeGetContent(kids-&gt;children));
+		for (kids = cur-&gt;children;kids;kids = kids-&gt;next) {
+			if (0 == strcmp((char *)kids-&gt;name, &quot;SSID&quot;))    db_add_tag(OBJECT_T(&amp;node), &quot;wifi_SSID&quot;, (char *)xmlNodeGetContent(kids-&gt;children));
+			if (0 == strcmp((char *)kids-&gt;name, &quot;BSSID&quot;))    db_add_tag(OBJECT_T(&amp;node), &quot;wifi_BSSID&quot;, (char *)xmlNodeGetContent(kids-&gt;children));
 		}
-		for (attr=cur-&gt;properties;attr;attr=attr-&gt;next) {
-			/*		if (0==strcmp((char *)attr-&gt;name,&quot;number&quot;)) 		node-&gt;base.id=		strtol((char *)attr-&gt;children-&gt;content,NULL,10);
-					else */
-			if (0==strcmp((char *)attr-&gt;name,&quot;wep&quot;)) 	db_add_tag(OBJECT_T(&amp;node),&quot;wifi_wep&quot;,(char *)attr-&gt;children-&gt;content);
-			else if (0==strcmp((char *)attr-&gt;name,&quot;type&quot;)) 		db_add_tag(OBJECT_T(&amp;node),&quot;wifi_type&quot;,(char *)attr-&gt;children-&gt;content);
+		for (attr = cur-&gt;properties;attr;attr = attr-&gt;next) {
+			/*  if (0==strcmp((char *)attr-&gt;name,&quot;number&quot;))   node-&gt;base.id=  strtol((char *)attr-&gt;children-&gt;content,NULL,10);
+			  else */
+			if (0 == strcmp((char *)attr-&gt;name, &quot;wep&quot;))  db_add_tag(OBJECT_T(&amp;node), &quot;wifi_wep&quot;, (char *)attr-&gt;children-&gt;content);
+			else if (0 == strcmp((char *)attr-&gt;name, &quot;type&quot;))   db_add_tag(OBJECT_T(&amp;node), &quot;wifi_type&quot;, (char *)attr-&gt;children-&gt;content);
 		}
 
 		db_add_tag(OBJECT_T(&amp;node), &quot;amenity&quot;, &quot;wifi&quot;);
@@ -77,32 +77,32 @@
 layer_t *parse_kismet(char *buf, int length)
 {
 	xmlDocPtr doc;
-	xmlNodePtr cur,c;
-	layer_t *layer=layer_new();
-	int i=0;
-	float n=0;
+	xmlNodePtr cur, c;
+	layer_t *layer = layer_new();
+	int i = 0;
+	float n = 0;
 
 
 	doc = xmlReadMemory(buf, length, &quot;noname.xml&quot;, NULL, 0);
 	if (doc == NULL) {
-		fprintf(stderr,&quot;Document not parsed successfully.\n&quot;);
+		fprintf(stderr, &quot;Document not parsed successfully.\n&quot;);
 		return(NULL);
 	}
 	cur = xmlDocGetRootElement(doc);
 	if (cur == NULL) {
-		fprintf(stderr,&quot;empty document\n&quot;);
+		fprintf(stderr, &quot;empty document\n&quot;);
 		xmlFreeDoc(doc);
 		return(NULL);
 	}
-	layerid=db_insert_layer(&quot;kismet&quot;);
-	for (c=cur-&gt;children;  c!=NULL;   c=c-&gt;next) 		n++; /* count */
-	for (cur=cur-&gt;children;cur!=NULL; cur=cur-&gt;next) {
-		if (cur-&gt;type==XML_ELEMENT_NODE) {
-			if (0==strcmp((char *)cur-&gt;name,&quot;wireless-network&quot;)) {
+	layerid = db_insert_layer(&quot;kismet&quot;);
+	for (c = cur-&gt;children;  c != NULL;   c = c-&gt;next)   n++; /* count */
+	for (cur = cur-&gt;children;cur != NULL; cur = cur-&gt;next) {
+		if (cur-&gt;type == XML_ELEMENT_NODE) {
+			if (0 == strcmp((char *)cur-&gt;name, &quot;wireless-network&quot;)) {
 				parse_kismet_node(cur);
 			}
 		}
-		if ((i++)%10==0) load_update_status(100*((float)i)/n);
+		if ((i++) % 10 == 0) load_update_status(100*((float)i) / n);
 
 	}
 	db_flush();
@@ -114,8 +114,8 @@
 	int length;
 	char *file;
 	layer_t *ret;
-	if (NULL==(file=read_file(filename,&amp;length))) return(NULL);
-	ret=parse_kismet(file,length);
+	if (NULL == (file = read_file(filename, &amp;length))) return(NULL);
+	ret = parse_kismet(file, length);
 	free(file);
 	return ret;
 }

Modified: trunk/apps/s3dosm/main.c
===================================================================
--- trunk/apps/s3dosm/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,34 +22,34 @@
  */
 
 
-#include &lt;stdio.h&gt;		 /*  snprintf(), printf(), NULL */
+#include &lt;stdio.h&gt;   /*  snprintf(), printf(), NULL */
 #include &lt;s3d.h&gt;
 #include &lt;s3dw.h&gt;
 #include &quot;s3dosm.h&quot;
-#include &lt;time.h&gt;	 /*  nanosleep(), struct tm, time_t...  */
-static int ready=0;
+#include &lt;time.h&gt;  /*  nanosleep(), struct tm, time_t...  */
+static int ready = 0;
 
 void mainloop()
 {
-	struct timespec t= {
-		0,100*1000*1000
+	struct timespec t = {
+		0, 100*1000*1000
 	}; /* 100 mili seconds */
 	if (ready) {
-		nanosleep(&amp;t,NULL);
+		nanosleep(&amp;t, NULL);
 		gps_main();
 		nav_main();
 		s3dw_ani_mate();
 	} /* else {
-		s3d_net_check(); / * we are not yet in the mainloop of
-							s3d_mainloop(), because ready==0,
-							so we check protocol things ourselves.
-							This just prevents timing out from the server
-							because map loading takes so long, you shouldn't take
-							this as good example and write proper threaded or
-							timesliced loaders :) * /
-		s3d_process_stack();
-	}
-	s3dw_ani_mate();*/
+  s3d_net_check(); / * we are not yet in the mainloop of
+       s3d_mainloop(), because ready==0,
+       so we check protocol things ourselves.
+       This just prevents timing out from the server
+       because map loading takes so long, you shouldn't take
+       this as good example and write proper threaded or
+       timesliced loaders :) * /
+  s3d_process_stack();
+ }
+ s3dw_ani_mate();*/
 }
 int init(int argc, char **argv)
 {
@@ -57,17 +57,17 @@
 	ui_init();
 	if (db_init(&quot;:memory:&quot;)) return(-1);
 	if (db_create()) return(-1);
-	if (process_args(argc,argv)) return(-1);
+	if (process_args(argc, argv)) return(-1);
 	nav_init();
 	nav_autocenter();
 	draw_all_layers();
 	gps_init(&quot;localhost&quot;);
-	ready=1;
+	ready = 1;
 	return(0);
 }
 int quit()
 {
-	ready=0;
+	ready = 0;
 	gps_quit();
 	s3d_quit();
 	db_quit();
@@ -75,7 +75,7 @@
 }
 int main(int argc, char **argv)
 {
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;s3dosm&quot;)) {
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;s3dosm&quot;)) {
 		if (!init(argc, argv)) s3d_mainloop(mainloop);
 		quit();
 	} else return(-1);

Modified: trunk/apps/s3dosm/nav.c
===================================================================
--- trunk/apps/s3dosm/nav.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/nav.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,85 +1,85 @@
 #include &quot;s3dosm.h&quot;
 #include &lt;s3d.h&gt;
-#include &lt;string.h&gt;	/* strcmp() */
-#include &lt;stdlib.h&gt;	/* strtod() */
-#include &lt;stdio.h&gt;	/* printf() */
-#include &lt;math.h&gt;	/* fabs() */
+#include &lt;string.h&gt; /* strcmp() */
+#include &lt;stdlib.h&gt; /* strtod() */
+#include &lt;stdio.h&gt; /* printf() */
+#include &lt;math.h&gt; /* fabs() */
 
 int oidx, oidy;
-static float lat,lon,tlat,tlon;
+static float lat, lon, tlat, tlon;
 /* load rotation centers */
 void nav_init()
 {
-	lat=lon=tlat=tlon=0.0;
-	oidx=s3d_new_object();
-	oidy=s3d_new_object();
-	s3d_link(oidy,oidx);
-	s3d_translate(oidx,0,-ESIZE*RESCALE- VIEWHEIGHT,0);
-	s3d_scale(oidx,RESCALE);
+	lat = lon = tlat = tlon = 0.0;
+	oidx = s3d_new_object();
+	oidy = s3d_new_object();
+	s3d_link(oidy, oidx);
+	s3d_translate(oidx, 0, -ESIZE*RESCALE - VIEWHEIGHT, 0);
+	s3d_scale(oidx, RESCALE);
 }
 /* center to given latitude longitude */
 void nav_center(float la, float lo)
 {
-	tlat=la;
-	tlon=lo;
+	tlat = la;
+	tlon = lo;
 }
 void nav_campos(float campos[3], float earthpos[3])
 {
 
-	float tmp1[3],tmp2[3];
+	float tmp1[3], tmp2[3];
 	float alpha;
 
-	tmp1[0]=campos[0];
-	tmp1[1]=campos[1] + ESIZE*RESCALE +VIEWHEIGHT;
-	tmp1[2]=campos[2];
+	tmp1[0] = campos[0];
+	tmp1[1] = campos[1] + ESIZE * RESCALE + VIEWHEIGHT;
+	tmp1[2] = campos[2];
 
-	alpha= (90-lat) *M_PI/180.0;
-	tmp2[0]=  tmp1[0];
-	tmp2[1]=  tmp1[1]*cos(alpha) - tmp1[2] * sin (alpha);
-	tmp2[2]=  tmp1[1]*sin(alpha) + tmp1[2] * cos (alpha);
+	alpha = (90 - lat) * M_PI / 180.0;
+	tmp2[0] =  tmp1[0];
+	tmp2[1] =  tmp1[1] * cos(alpha) - tmp1[2] * sin(alpha);
+	tmp2[2] =  tmp1[1] * sin(alpha) + tmp1[2] * cos(alpha);
 
-	alpha= lon *M_PI/180.0;
-	tmp1[0]=  tmp2[0]*cos(alpha) + tmp2[2] * sin (alpha);
-	tmp1[1]=  tmp2[1];
-	tmp1[2]=  - tmp2[0]*sin(alpha) + tmp2[2] * cos (alpha);
+	alpha = lon * M_PI / 180.0;
+	tmp1[0] =  tmp2[0] * cos(alpha) + tmp2[2] * sin(alpha);
+	tmp1[1] =  tmp2[1];
+	tmp1[2] =  - tmp2[0] * sin(alpha) + tmp2[2] * cos(alpha);
 
 
 
-	earthpos[0]=tmp1[0];
-	earthpos[1]=tmp1[1];
-	earthpos[2]=tmp1[2];
+	earthpos[0] = tmp1[0];
+	earthpos[1] = tmp1[1];
+	earthpos[2] = tmp1[2];
 
 }
 void nav_main()
 {
 	float x[3];
-	if ((fabs(tlat-lat)&gt;0.00001) &amp;&amp; (fabs(tlon-lon)&gt;0.00001)) {
-		if (lat==0.0 &amp;&amp; lon==0.0) {
-			lat=tlat;
-			lon=tlon;
+	if ((fabs(tlat - lat) &gt; 0.00001) &amp;&amp; (fabs(tlon - lon) &gt; 0.00001)) {
+		if (lat == 0.0 &amp;&amp; lon == 0.0) {
+			lat = tlat;
+			lon = tlon;
 		} else {
-			lat=(tlat+lat*15)/16;
-			lon=(tlon+lon*15)/16;
+			lat = (tlat + lat * 15) / 16;
+			lon = (tlon + lon * 15) / 16;
 		}
 	} else {
-		lat=tlat;
-		lon=tlon;
+		lat = tlat;
+		lon = tlon;
 	}
-	s3d_rotate(oidy,0,-lon,0);
-	s3d_rotate(oidx,-(90-lat),0,0);
-	calc_earth_to_eukl(lon,lat,0,x);
+	s3d_rotate(oidy, 0, -lon, 0);
+	s3d_rotate(oidx, -(90 - lat), 0, 0);
+	calc_earth_to_eukl(lon, lat, 0, x);
 }
 
 int get_center(void *data, int argc, char **argv, char **azColName)
 {
-	float *med=(float *)data;
+	float *med = (float *)data;
 	int i;
-	med[0]=0;
-	med[1]=0;
-	for (i=0; i&lt;argc; i++) {
+	med[0] = 0;
+	med[1] = 0;
+	for (i = 0; i &lt; argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],&quot;la&quot;))			med[0]=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],&quot;lo&quot;))		med[1]=strtod(argv[i],NULL);
+			if (0 == strcmp(azColName[i], &quot;la&quot;))   med[0] = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], &quot;lo&quot;))  med[1] = strtod(argv[i], NULL);
 		}
 	}
 	return(0);
@@ -88,25 +88,25 @@
 float get_heading(float la1, float lo1, float la2, float lo2)
 {
 	float p1_north[3], p1[3], p2[3];
-	float dir[3],north[3];
+	float dir[3], north[3];
 	float angle;
 	int i;
-	calc_earth_to_eukl(la1,lo1,0,p1);
-	calc_earth_to_eukl(la2,lo2,0,p2);
-	calc_earth_to_eukl(la1+1,lo1,0,p1_north);
-	for (i=0;i&lt;3;i++)		north[i]=p1_north[i]-p1[i];
-	for (i=0;i&lt;3;i++)		dir[i]=p2[i]-p1[i];
-	angle=s3d_vector_angle(dir,north);
-	angle=angle*180.0/M_PI;
-	if ((lo2&gt;lo1) || (lo1-lo2&gt;180.0))		angle=360-angle;
+	calc_earth_to_eukl(la1, lo1, 0, p1);
+	calc_earth_to_eukl(la2, lo2, 0, p2);
+	calc_earth_to_eukl(la1 + 1, lo1, 0, p1_north);
+	for (i = 0;i &lt; 3;i++)  north[i] = p1_north[i] - p1[i];
+	for (i = 0;i &lt; 3;i++)  dir[i] = p2[i] - p1[i];
+	angle = s3d_vector_angle(dir, north);
+	angle = angle * 180.0 / M_PI;
+	if ((lo2 &gt; lo1) || (lo1 - lo2 &gt; 180.0))  angle = 360 - angle;
 	return(angle);
 }
 /* find some good center on our own */
 void nav_autocenter()
 {
 	float med[2];
-	char query[]=&quot;SELECT avg(longitude) as lo, avg(latitude) as la FROM node; &quot;;
-	db_exec(query,get_center,med);
-	nav_center(med[0],med[1]);
-	printf(&quot;center to %f,%f\n&quot;,med[0],med[1]);
+	char query[] = &quot;SELECT avg(longitude) as lo, avg(latitude) as la FROM node; &quot;;
+	db_exec(query, get_center, med);
+	nav_center(med[0], med[1]);
+	printf(&quot;center to %f,%f\n&quot;, med[0], med[1]);
 }

Modified: trunk/apps/s3dosm/object.c
===================================================================
--- trunk/apps/s3dosm/object.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/object.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -29,46 +29,46 @@
 void object_free(object_t *obj)
 {
 	int i;
-	for (i=0;i&lt;obj-&gt;tag_n;i++)
+	for (i = 0;i &lt; obj-&gt;tag_n;i++)
 		tag_free(&amp;(obj-&gt;tag_p[i]));
 }
 void object_init(object_t *nobj)
 {
-	nobj-&gt;bal=0;
-	nobj-&gt;left=NULL;
-	nobj-&gt;right=NULL;
-	nobj-&gt;id=0;
-	nobj-&gt;oid=-1;
-	nobj-&gt;layerid=-1;
-	nobj-&gt;tagid=-1;
-	nobj-&gt;tag_n=0;
-	nobj-&gt;tag_p=NULL;
-	nobj-&gt;type=T_OBJECT;
+	nobj-&gt;bal = 0;
+	nobj-&gt;left = NULL;
+	nobj-&gt;right = NULL;
+	nobj-&gt;id = 0;
+	nobj-&gt;oid = -1;
+	nobj-&gt;layerid = -1;
+	nobj-&gt;tagid = -1;
+	nobj-&gt;tag_n = 0;
+	nobj-&gt;tag_p = NULL;
+	nobj-&gt;type = T_OBJECT;
 }
 
 object_t *object_new(int key)
 {
-	object_t *nobj=malloc(sizeof(object_t));
+	object_t *nobj = malloc(sizeof(object_t));
 	object_init(nobj);
-	nobj-&gt;id=key;
+	nobj-&gt;id = key;
 	return (nobj);
 }
 /* ########### node ############### */
 void node_init(node_t *nnode)
 {
 	object_init((object_t *)nnode);
-	OBJECT_T(nnode)-&gt;type=T_NODE;
-	nnode-&gt;lat=0;
-	nnode-&gt;lon=0;
-	nnode-&gt;alt=0;
-	nnode-&gt;visible=1;
-	nnode-&gt;vid=-1;
-	nnode-&gt;adj_n=0;
-	nnode-&gt;adj_p=NULL;
+	OBJECT_T(nnode)-&gt;type = T_NODE;
+	nnode-&gt;lat = 0;
+	nnode-&gt;lon = 0;
+	nnode-&gt;alt = 0;
+	nnode-&gt;visible = 1;
+	nnode-&gt;vid = -1;
+	nnode-&gt;adj_n = 0;
+	nnode-&gt;adj_p = NULL;
 }
 node_t *node_new()
 {
-	node_t *nnode=malloc(sizeof(node_t));
+	node_t *nnode = malloc(sizeof(node_t));
 	node_init(nnode);
 	return(nnode);
 }
@@ -81,13 +81,13 @@
 void segment_init(segment_t *nsegment)
 {
 	object_init((object_t *)nsegment);
-	OBJECT_T(nsegment)-&gt;type=T_SEGMENT;
-	nsegment-&gt;from=0;
-	nsegment-&gt;to=0;
+	OBJECT_T(nsegment)-&gt;type = T_SEGMENT;
+	nsegment-&gt;from = 0;
+	nsegment-&gt;to = 0;
 }
 segment_t *segment_new()
 {
-	segment_t *nsegment=malloc(sizeof(segment_t));
+	segment_t *nsegment = malloc(sizeof(segment_t));
 	segment_init(nsegment);
 	return(nsegment);
 }
@@ -100,37 +100,37 @@
 void way_init(way_t *nway)
 {
 	object_init((object_t *)nway);
-	OBJECT_T(nway)-&gt;type=T_WAY;
-	nway-&gt;seg_n=0;
-	nway-&gt;seg_p=NULL;
+	OBJECT_T(nway)-&gt;type = T_WAY;
+	nway-&gt;seg_n = 0;
+	nway-&gt;seg_p = NULL;
 }
 way_t *way_new()
 {
-	way_t *nway=malloc(sizeof(way_t));
+	way_t *nway = malloc(sizeof(way_t));
 	way_init(nway);
 	return(nway);
 }
 void way_free(way_t *way)
 {
-	if (way-&gt;seg_n&gt;0)
+	if (way-&gt;seg_n &gt; 0)
 		free(way-&gt;seg_p);
 	free(way);
 }
 /* ########### layer  ############### */
 layer_t *layer_new()
 {
-	layer_t *nlayer=malloc(sizeof(layer_t));
-	nlayer-&gt;tree=NULL;
-	nlayer-&gt;visible=0;
+	layer_t *nlayer = malloc(sizeof(layer_t));
+	nlayer-&gt;tree = NULL;
+	nlayer-&gt;visible = 0;
 	return(nlayer);
 }
 /* ########### layerset ############### */
-layerset_t layerset={0,NULL};
+layerset_t layerset = {0, NULL};
 
 void layerset_add(layer_t *layer)
 {
-	if (layer==NULL) return;
+	if (layer == NULL) return;
 	layerset.n++;
-	layerset.p=realloc(layerset.p, sizeof(layer_t *)*layerset.n);
-	layerset.p[layerset.n-1]=layer;
+	layerset.p = realloc(layerset.p, sizeof(layer_t *) * layerset.n);
+	layerset.p[layerset.n-1] = layer;
 }

Modified: trunk/apps/s3dosm/olsrs3d.h
===================================================================
--- trunk/apps/s3dosm/olsrs3d.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/olsrs3d.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -37,12 +37,12 @@
 extern struct olsr_node *Olsr_root;   /* top of olsr node tree */
 extern struct Obj_to_ip *Obj_to_ip_head, *Obj_to_ip_end, *List_ptr;   /* struct list */
 
-extern int	Olsr_node_obj;
-extern int	Olsr_node_inet_obj;
-extern int	Olsr_node_hna_net;
-extern int	Btn_close_obj;
-extern int	S3d_obj;
-extern int	Btn_close_id;
+extern int Olsr_node_obj;
+extern int Olsr_node_inet_obj;
+extern int Olsr_node_hna_net;
+extern int Btn_close_obj;
+extern int S3d_obj;
+extern int Btn_close_id;
 extern int Olsr_node_count_obj;
 extern int Olsr_node_count;
 extern int Last_olsr_node_count;
@@ -58,7 +58,7 @@
 
 /* process */
 void lst_initialize();
-void lst_add(int id,struct olsr_node **olsr_node);
+void lst_add(int id, struct olsr_node **olsr_node);
 void lst_del(int id);
 struct olsr_node *lst_search(int id);
 void lst_out();
@@ -69,7 +69,7 @@
 int net_main();
 int net_quit();
 /* main */
-void out_of_mem( void );
-void print_etx( void );
+void out_of_mem(void);
+void print_etx(void);
 float dist(float p1[], float p2[]);
 void window_error(char *msg);

Modified: trunk/apps/s3dosm/osm.c
===================================================================
--- trunk/apps/s3dosm/osm.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/osm.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,8 +22,8 @@
  */
 
 #include &quot;s3dosm.h&quot;
-#include &lt;string.h&gt;			/* strcmp() */
-#include &lt;stdlib.h&gt;			/* strtof(),strtod(),strtol() */
+#include &lt;string.h&gt;   /* strcmp() */
+#include &lt;stdlib.h&gt;   /* strtof(),strtod(),strtol() */
 #include &lt;libxml/parser.h&gt;
 #include &lt;libxml/tree.h&gt;
 #include &quot;http_fetcher.h&quot;
@@ -32,15 +32,15 @@
 {
 	xmlNodePtr c;
 	xmlAttrPtr attr;
-	char *v,*k;
-	v=k=NULL;
-	for (c=cur-&gt;children;c!=NULL; c=c-&gt;next) {
-		if (0==strcmp((char *)c-&gt;name,&quot;tag&quot;))	{
-			for (attr=c-&gt;properties;attr;attr=attr-&gt;next) {
-				if (0==strcmp((char *)attr-&gt;name,&quot;k&quot;)) 				k=(char *)attr-&gt;children-&gt;content;
-				else if (0==strcmp((char *)attr-&gt;name,&quot;v&quot;)) 		v=(char *)attr-&gt;children-&gt;content;
+	char *v, *k;
+	v = k = NULL;
+	for (c = cur-&gt;children;c != NULL; c = c-&gt;next) {
+		if (0 == strcmp((char *)c-&gt;name, &quot;tag&quot;)) {
+			for (attr = c-&gt;properties;attr;attr = attr-&gt;next) {
+				if (0 == strcmp((char *)attr-&gt;name, &quot;k&quot;))     k = (char *)attr-&gt;children-&gt;content;
+				else if (0 == strcmp((char *)attr-&gt;name, &quot;v&quot;))   v = (char *)attr-&gt;children-&gt;content;
 			}
-			if (k!=NULL &amp;&amp; v!=NULL)
+			if (k != NULL &amp;&amp; v != NULL)
 				db_add_tag(obj, k, v);
 		}
 	}
@@ -51,22 +51,22 @@
 {
 	way_t way;
 	xmlNodePtr kids;
-	xmlAttrPtr attr,kattr;
+	xmlAttrPtr attr, kattr;
 	int seg;
 
 	way_init(&amp;way);
 
-	way.base.layerid=layerid;
-	for (attr=cur-&gt;properties;attr;attr=attr-&gt;next)
-		if (0==strcmp((char *)attr-&gt;name,&quot;id&quot;)) 			way.base.id=	strtol((char *)attr-&gt;children-&gt;content,NULL,10);
+	way.base.layerid = layerid;
+	for (attr = cur-&gt;properties;attr;attr = attr-&gt;next)
+		if (0 == strcmp((char *)attr-&gt;name, &quot;id&quot;))    way.base.id = strtol((char *)attr-&gt;children-&gt;content, NULL, 10);
 	db_insert_way_only(&amp;way);
-	parse_osm_tags(OBJECT_T(&amp;way),cur);
-	for (kids=cur-&gt;children;kids!=NULL;kids=kids-&gt;next) {
-		if (0==strcmp((char *)kids-&gt;name,&quot;seg&quot;))	{
-			seg=-1;
-			for (kattr=kids-&gt;properties;kattr;kattr=kattr-&gt;next)
-				if (0==strcmp((char *)kattr-&gt;name,&quot;id&quot;)) 			seg=	strtol((char *)kattr-&gt;children-&gt;content,NULL,10);
-			db_insert_way_seg(&amp;way,seg);
+	parse_osm_tags(OBJECT_T(&amp;way), cur);
+	for (kids = cur-&gt;children;kids != NULL;kids = kids-&gt;next) {
+		if (0 == strcmp((char *)kids-&gt;name, &quot;seg&quot;)) {
+			seg = -1;
+			for (kattr = kids-&gt;properties;kattr;kattr = kattr-&gt;next)
+				if (0 == strcmp((char *)kattr-&gt;name, &quot;id&quot;))    seg = strtol((char *)kattr-&gt;children-&gt;content, NULL, 10);
+			db_insert_way_seg(&amp;way, seg);
 		}
 	}
 }
@@ -77,16 +77,16 @@
 
 	segment_init(&amp;segment);
 
-	segment.base.layerid=layerid;
-	for (attr=cur-&gt;properties;attr;attr=attr-&gt;next) {
+	segment.base.layerid = layerid;
+	for (attr = cur-&gt;properties;attr;attr = attr-&gt;next) {
 
-		if (0==strcmp((char *)attr-&gt;name,&quot;id&quot;)) 			segment.base.id=	strtol((char *)attr-&gt;children-&gt;content,NULL,10);
-		else if (0==strcmp((char *)attr-&gt;name,&quot;from&quot;)) 		segment.from=		strtod((char *)attr-&gt;children-&gt;content,NULL);
-		else if (0==strcmp((char *)attr-&gt;name,&quot;to&quot;)) 		segment.to=			strtod((char *)attr-&gt;children-&gt;content,NULL);
+		if (0 == strcmp((char *)attr-&gt;name, &quot;id&quot;))    segment.base.id = strtol((char *)attr-&gt;children-&gt;content, NULL, 10);
+		else if (0 == strcmp((char *)attr-&gt;name, &quot;from&quot;))   segment.from =  strtod((char *)attr-&gt;children-&gt;content, NULL);
+		else if (0 == strcmp((char *)attr-&gt;name, &quot;to&quot;))   segment.to =   strtod((char *)attr-&gt;children-&gt;content, NULL);
 	}
-	if ((segment.base.id&gt;0) &amp;&amp; (segment.from&gt;0) &amp;&amp; (segment.to&gt;0)) {
+	if ((segment.base.id &gt; 0) &amp;&amp; (segment.from &gt; 0) &amp;&amp; (segment.to &gt; 0)) {
 		db_insert_segment(&amp;segment);
-		parse_osm_tags(OBJECT_T(&amp;segment),cur);
+		parse_osm_tags(OBJECT_T(&amp;segment), cur);
 	}
 }
 void parse_osm_node(xmlNodePtr cur)
@@ -95,53 +95,53 @@
 	xmlAttrPtr attr;
 
 	node_init(&amp;node);
-	attr=cur-&gt;properties;
+	attr = cur-&gt;properties;
 
-	node.base.layerid=layerid;
-	for (attr=cur-&gt;properties;attr;attr=attr-&gt;next) {
-		if (0==strcmp((char *)attr-&gt;name,&quot;id&quot;)) 			node.base.id=		strtol((char *)attr-&gt;children-&gt;content,NULL,10);
-		else if (0==strcmp((char *)attr-&gt;name,&quot;lat&quot;)) 		node.lat=			strtod((char *)attr-&gt;children-&gt;content,NULL);
-		else if (0==strcmp((char *)attr-&gt;name,&quot;lon&quot;)) 		node.lon=			strtod((char *)attr-&gt;children-&gt;content,NULL);
-		else if (0==strcmp((char *)attr-&gt;name,&quot;visible&quot;)) 	node.visible=		(0==strcmp((char *)attr-&gt;children-&gt;content,&quot;true&quot;))?1:0;
-		else if (0==strcmp((char *)attr-&gt;name,&quot;time&quot;)) {}	/* TODO */
+	node.base.layerid = layerid;
+	for (attr = cur-&gt;properties;attr;attr = attr-&gt;next) {
+		if (0 == strcmp((char *)attr-&gt;name, &quot;id&quot;))    node.base.id =  strtol((char *)attr-&gt;children-&gt;content, NULL, 10);
+		else if (0 == strcmp((char *)attr-&gt;name, &quot;lat&quot;))   node.lat =   strtod((char *)attr-&gt;children-&gt;content, NULL);
+		else if (0 == strcmp((char *)attr-&gt;name, &quot;lon&quot;))   node.lon =   strtod((char *)attr-&gt;children-&gt;content, NULL);
+		else if (0 == strcmp((char *)attr-&gt;name, &quot;visible&quot;))  node.visible = (0 == strcmp((char *)attr-&gt;children-&gt;content, &quot;true&quot;)) ? 1 : 0;
+		else if (0 == strcmp((char *)attr-&gt;name, &quot;time&quot;)) {} /* TODO */
 	}
-	if (node.base.id&gt;0) {
+	if (node.base.id &gt; 0) {
 		db_insert_node(&amp;node);
-		parse_osm_tags(OBJECT_T(&amp;node),cur);
+		parse_osm_tags(OBJECT_T(&amp;node), cur);
 	}
 }
 /* parse the osm input file */
 layer_t *parse_osm(char *buf, int length)
 {
 	xmlDocPtr doc;
-	xmlNodePtr cur,c;
-	layer_t *layer=layer_new();
+	xmlNodePtr cur, c;
+	layer_t *layer = layer_new();
 	object_t *obj;
-	float n=0;
-	int i=0;
+	float n = 0;
+	int i = 0;
 
 
 	doc = xmlReadMemory(buf, length, &quot;noname.xml&quot;, NULL, 0);
 	if (doc == NULL) {
-		fprintf(stderr,&quot;Document not parsed successfully.\n&quot;);
+		fprintf(stderr, &quot;Document not parsed successfully.\n&quot;);
 		return(NULL);
 	}
 	cur = xmlDocGetRootElement(doc);
 	if (cur == NULL) {
-		fprintf(stderr,&quot;empty document\n&quot;);
+		fprintf(stderr, &quot;empty document\n&quot;);
 		xmlFreeDoc(doc);
 		return(NULL);
 	}
-	layerid=db_insert_layer(&quot;osm&quot;);
-	for (c=cur-&gt;children;  c!=NULL;   c=c-&gt;next) 		n++; /* count */
-	for (cur=cur-&gt;children;cur!=NULL; cur=cur-&gt;next) {
-		if (cur-&gt;type==XML_ELEMENT_NODE) {
-			obj=NULL;
-			if (0==strcmp((char *)cur-&gt;name,&quot;node&quot;))				parse_osm_node(cur);
-			else if (0==strcmp((char *)cur-&gt;name,&quot;segment&quot;))		parse_osm_segment(cur);
-			else if (0==strcmp((char *)cur-&gt;name,&quot;way&quot;))			parse_osm_way(cur);
+	layerid = db_insert_layer(&quot;osm&quot;);
+	for (c = cur-&gt;children;  c != NULL;   c = c-&gt;next)   n++; /* count */
+	for (cur = cur-&gt;children;cur != NULL; cur = cur-&gt;next) {
+		if (cur-&gt;type == XML_ELEMENT_NODE) {
+			obj = NULL;
+			if (0 == strcmp((char *)cur-&gt;name, &quot;node&quot;))    parse_osm_node(cur);
+			else if (0 == strcmp((char *)cur-&gt;name, &quot;segment&quot;))  parse_osm_segment(cur);
+			else if (0 == strcmp((char *)cur-&gt;name, &quot;way&quot;))   parse_osm_way(cur);
 		}
-		if ((i++)%200==0) 	load_update_status(100*((float)i)/n); /* report status */
+		if ((i++) % 200 == 0)  load_update_status(100*((float)i) / n); /* report status */
 	}
 	xmlFreeDoc(doc);
 	db_flush();
@@ -154,18 +154,18 @@
 	char *user = &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">foo at packetmixer.de</A>&quot;;
 	char *pass = &quot;foobar&quot;;
 	char url[1024];
-	char *fileBuf;						/* Pointer to downloaded data */
+	char *fileBuf;      /* Pointer to downloaded data */
 	layer_t *layer;
-	snprintf(url,1024,&quot;www.openstreetmap.org/api/0.3/map?bbox=%f,%f,%f,%f&quot;,minlon,minlat,maxlon,maxlat);
-	printf(&quot;downloading url [ %s ]\n&quot;,url);
+	snprintf(url, 1024, &quot;www.openstreetmap.org/api/0.3/map?bbox=%f,%f,%f,%f&quot;, minlon, minlat, maxlon, maxlat);
+	printf(&quot;downloading url [ %s ]\n&quot;, url);
 
-	http_setAuth(user,pass);
-	ret = http_fetch(url, &amp;fileBuf);	/* Downloads page */
+	http_setAuth(user, pass);
+	ret = http_fetch(url, &amp;fileBuf); /* Downloads page */
 	if (ret == -1) {
 		http_perror(&quot;http_fetch&quot;);
 		return(NULL);
 	}
-	layer=parse_osm(fileBuf, ret);
+	layer = parse_osm(fileBuf, ret);
 	/* TODO: cleanup http-lib */
 	free(fileBuf);
 	return layer;
@@ -175,8 +175,8 @@
 	int length;
 	char *file;
 	layer_t *ret;
-	if (NULL==(file=read_file(filename,&amp;length))) return(NULL);
-	ret=parse_osm(file,length);
+	if (NULL == (file = read_file(filename, &amp;length))) return(NULL);
+	ret = parse_osm(file, length);
 	free(file);
 	return ret;
 }

Modified: trunk/apps/s3dosm/s3dosm.h
===================================================================
--- trunk/apps/s3dosm/s3dosm.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/s3dosm.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,14 +1,14 @@
 #include &lt;sqlite3.h&gt;
-#include &lt;s3d.h&gt;	/* s3devt structure */
+#include &lt;s3d.h&gt; /* s3devt structure */
 #include &lt;config-s3d.h&gt;
-#define	ESIZE	637800		/* earth size */
-#define	RESCALE	1
+#define ESIZE 637800  /* earth size */
+#define RESCALE 1
 #define VIEWHEIGHT 3
-#define MAXQ	4096
-#define QBUF	1024*128
+#define MAXQ 4096
+#define QBUF 1024*128
 
 /* stack it */
-/* #define DB_STACK	1*/
+/* #define DB_STACK 1*/
 
 typedef struct _layer_t layer_t;
 typedef struct _adj_t adj_t;
@@ -20,10 +20,10 @@
 typedef struct _tag_t tag_t;
 typedef struct _icon_t icon_t;
 typedef unsigned long ID_T;
-#define OBJECT_T(x)		((object_t *)x)
-#define NODE_T(x)		((node_t *)x)
-#define SEGMENT_T(x)	((segment_t *)x)
-#define WAY_T(x)		((way_t *)x)
+#define OBJECT_T(x)  ((object_t *)x)
+#define NODE_T(x)  ((node_t *)x)
+#define SEGMENT_T(x) ((segment_t *)x)
+#define WAY_T(x)  ((way_t *)x)
 struct _layerset_t {
 	int n;
 	layer_t **p;
@@ -72,60 +72,60 @@
 };
 
 struct _object_t {
-	ID_T 		 id;		/* id of this object */
-	ID_T		 layerid;
-	ID_T		 tagid;
-	int 		 oid;		/* s3d oid */
-	int 		 type;		/* type of this object */
+	ID_T    id;  /* id of this object */
+	ID_T   layerid;
+	ID_T   tagid;
+	int    oid;  /* s3d oid */
+	int    type;  /* type of this object */
 	/* avl stuff */
-	char 		 bal;
-	int			 tag_n;
-	tag_t		*tag_p;
-	object_t 	*left,*right;
+	char    bal;
+	int    tag_n;
+	tag_t  *tag_p;
+	object_t  *left, *right;
 };
 
 struct _adj_t {
-	ID_T 		 to,seg;	/* destination and segment to use */
+	ID_T    to, seg; /* destination and segment to use */
 };
 
 struct _node_t {
-	object_t	 base;
-	float 		 lon;		/* longitude */
-	float 		 lat;		/* latitude */
-	float 		 alt;		/* altitude */
-	char 		 visible;	/* node visible? 0 = no, 1 = yes, 2 = some sepcial object */
-	int 		 vid;		/* vertex id */
-	/*	time_t time;*/
-	int 		 adj_n;		/* adjacence list */
-	adj_t 		*adj_p;
+	object_t  base;
+	float    lon;  /* longitude */
+	float    lat;  /* latitude */
+	float    alt;  /* altitude */
+	char    visible; /* node visible? 0 = no, 1 = yes, 2 = some sepcial object */
+	int    vid;  /* vertex id */
+	/* time_t time;*/
+	int    adj_n;  /* adjacence list */
+	adj_t   *adj_p;
 };
 struct _segment_t {
-	object_t	 base;
-	ID_T		 from;
-	ID_T		 to;
+	object_t  base;
+	ID_T   from;
+	ID_T   to;
 };
 struct _way_t {
-	object_t	 base;
-	int 		 seg_n;
-	ID_T		*seg_p;
+	object_t  base;
+	int    seg_n;
+	ID_T  *seg_p;
 };
 
 /* public functions */
 
 /* object.c */
-void 		 object_init(object_t *nobj);
-void 		 node_init(node_t *nnode);
-void 		 segment_init(segment_t *nsegment);
-void 		 way_init(way_t *nway);
-object_t 	*object_new(int key);
-node_t 		*node_new();
-segment_t 	*segment_new();
-layer_t 	*layer_new();
-way_t 		*way_new();
-void 		 node_free(node_t *node);
-void 		 segment_free(segment_t *segment);
-void 		 way_free(way_t *way);
-void 		 layerset_add(layer_t *layer);
+void    object_init(object_t *nobj);
+void    node_init(node_t *nnode);
+void    segment_init(segment_t *nsegment);
+void    way_init(way_t *nway);
+object_t  *object_new(int key);
+node_t   *node_new();
+segment_t  *segment_new();
+layer_t  *layer_new();
+way_t   *way_new();
+void    node_free(node_t *node);
+void    segment_free(segment_t *segment);
+void    way_free(way_t *way);
+void    layerset_add(layer_t *layer);
 /* main.c */
 void mainloop();
 /* osm.c */
@@ -150,7 +150,7 @@
 float get_heading(float la1, float lo1, float la2, float lo2);
 extern int oidy;
 /* tag.c */
-void tag_add(object_t *obj,char *k, char *v);
+void tag_add(object_t *obj, char *k, char *v);
 tag_t *tag_get(object_t *obj, char *k);
 void tag_free(tag_t *tag);
 /* io.c */
@@ -185,7 +185,7 @@
 int load_window_remove();
 int load_update_status(float percent);
 /* olsrs3d.c */
-#define NODEHEIGHT	10
+#define NODEHEIGHT 10
 int olsr_object_click(struct s3d_evt *evt);
 int olsr_object_info(struct s3d_evt *hrmz);
 int olsr_parse_args(int argc, char **argv);

Modified: trunk/apps/s3dosm/search.h
===================================================================
--- trunk/apps/s3dosm/search.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/search.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -21,10 +21,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#define NOTHING 0		/* nothing ;) */
-#define ABORT 1			/* widget has no focus */
-#define WIDGET 2		/* focus on widget */
-#define FOLLOW 3		/* follow search result */
+#define NOTHING 0  /* nothing ;) */
+#define ABORT 1   /* widget has no focus */
+#define WIDGET 2  /* focus on widget */
+#define FOLLOW 3  /* follow search result */
 
 void create_search_widget(float x, float y, float z);
 void move_search_widget(float x, float y, float z);
@@ -35,7 +35,7 @@
 void set_search_status(int stat);
 void search_widget_write(int key);
 void set_node_root(struct olsr_node *root);
-void follow_node(float cam_position_t[], float cam_position_r[],float rotate);
+void follow_node(float cam_position_t[], float cam_position_r[], float rotate);
 void follow_node_by_click(struct olsr_node *olsr_node);
 
 void show_search_window();

Modified: trunk/apps/s3dosm/structs.h
===================================================================
--- trunk/apps/s3dosm/structs.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/structs.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,21 +23,21 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#define NAMEMAX		128
-#define MAXLINESIZE 1000		/* lines in a digraph just shouldn't get that longer ... */
-#define MAXDATASIZE 100			/* max number of bytes we can get at once  */
+#define NAMEMAX  128
+#define MAXLINESIZE 1000  /* lines in a digraph just shouldn't get that longer ... */
+#define MAXDATASIZE 100   /* max number of bytes we can get at once  */
 
 /* linked list for the all connections */
 struct olsr_con {
-	struct olsr_con *next_olsr_con;			/* pointer to next connection */
-	struct olsr_con *prev_olsr_con;			/* pointer to previous connection */
-	struct olsr_node *left_olsr_node;		/* pointer to left end point of the connection */
-	struct olsr_node *right_olsr_node;		/* pointer to right end point of the connection */
-	float left_etx;							/* etx of left olsr node */
-	float right_etx;						/* etx of right olsr node */
-	float left_etx_sqrt;					/* sqrt of etx of left olsr node */
-	float right_etx_sqrt;					/* sqrt etx of right olsr node */
-	int obj_id;								/* id of connection object in s3d */
+	struct olsr_con *next_olsr_con;   /* pointer to next connection */
+	struct olsr_con *prev_olsr_con;   /* pointer to previous connection */
+	struct olsr_node *left_olsr_node;  /* pointer to left end point of the connection */
+	struct olsr_node *right_olsr_node;  /* pointer to right end point of the connection */
+	float left_etx;       /* etx of left olsr node */
+	float right_etx;      /* etx of right olsr node */
+	float left_etx_sqrt;     /* sqrt of etx of left olsr node */
+	float right_etx_sqrt;     /* sqrt etx of right olsr node */
+	int obj_id;        /* id of connection object in s3d */
 	int color;
 	float rgb;
 };
@@ -45,8 +45,8 @@
 
 /* linked list for the neighbours of each olsr node */
 struct olsr_neigh_list {
-	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
-	struct olsr_con *olsr_con;							/* pointer to the connection */
+	struct olsr_neigh_list *next_olsr_neigh_list;  /* pointer to next neighbour */
+	struct olsr_con *olsr_con;       /* pointer to the connection */
 };
 
 
@@ -54,18 +54,18 @@
 struct olsr_node {
 	struct olsr_node *left;
 	struct olsr_node *right;
-	char ip[NAMEMAX];				/* host ip */
-	int static_node;				/* static nodes have some known geolocation and won't move */
-	int node_type;					/* normal = 0, internet gateway = 1, via hna announced network = 2 */
-	int node_type_modified;			/* node_type modified flag */
-	int last_seen;					/* last seen counter */
-	int visible;					/* is this node visible or vanished */
-	float pos_vec[3];				/* position vector in 3d &quot;space&quot; */
-	float mov_vec[3];				/* move vector */
-	int obj_id;						/* id of node object in s3d */
-	int desc_id;					/* id of node description object in s3d */
-	float desc_length;				/* length of node description object in s3d */
-	struct olsr_neigh_list *olsr_neigh_list;	/* pointer to first neighbour */
+	char ip[NAMEMAX];    /* host ip */
+	int static_node;    /* static nodes have some known geolocation and won't move */
+	int node_type;     /* normal = 0, internet gateway = 1, via hna announced network = 2 */
+	int node_type_modified;   /* node_type modified flag */
+	int last_seen;     /* last seen counter */
+	int visible;     /* is this node visible or vanished */
+	float pos_vec[3];    /* position vector in 3d &quot;space&quot; */
+	float mov_vec[3];    /* move vector */
+	int obj_id;      /* id of node object in s3d */
+	int desc_id;     /* id of node description object in s3d */
+	float desc_length;    /* length of node description object in s3d */
+	struct olsr_neigh_list *olsr_neigh_list; /* pointer to first neighbour */
 };
 
 

Modified: trunk/apps/s3dosm/tag.c
===================================================================
--- trunk/apps/s3dosm/tag.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/tag.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -21,38 +21,38 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 #include &quot;s3dosm.h&quot;
-#include &lt;stdio.h&gt;	/* printf() */
-#include &lt;string.h&gt;	/* strcmp() */
-#include &lt;stdlib.h&gt;	/* realloc() */
-void tag_add(object_t *obj,char *k, char *v)
+#include &lt;stdio.h&gt; /* printf() */
+#include &lt;string.h&gt; /* strcmp() */
+#include &lt;stdlib.h&gt; /* realloc() */
+void tag_add(object_t *obj, char *k, char *v)
 {
 	tag_t *t;
 	obj-&gt;tag_n++;
-	obj-&gt;tag_p=realloc(obj-&gt;tag_p,obj-&gt;tag_n*sizeof(tag_t));
-	if (k!=NULL &amp;&amp; v!=NULL) {
-		t=&amp;(obj-&gt;tag_p[obj-&gt;tag_n-1]);
-		t-&gt;ttype=TAG_UNKNOWN;
-		t-&gt;k=strdup(k);
-		t-&gt;v=strdup(v);
-		t-&gt;d.s=v;
-		if (0==strcmp(k,&quot;name&quot;))	t-&gt;ttype=TAG_NAME;
+	obj-&gt;tag_p = realloc(obj-&gt;tag_p, obj-&gt;tag_n * sizeof(tag_t));
+	if (k != NULL &amp;&amp; v != NULL) {
+		t = &amp;(obj-&gt;tag_p[obj-&gt;tag_n-1]);
+		t-&gt;ttype = TAG_UNKNOWN;
+		t-&gt;k = strdup(k);
+		t-&gt;v = strdup(v);
+		t-&gt;d.s = v;
+		if (0 == strcmp(k, &quot;name&quot;)) t-&gt;ttype = TAG_NAME;
 	}
 }
 tag_t *tag_get(object_t *obj, char *k)
 {
 	int i;
-	for (i=0;i&lt;obj-&gt;tag_n;i++) {
-		if (0==strcmp(obj-&gt;tag_p[i].k,k)) return(&amp;(obj-&gt;tag_p[i]));
+	for (i = 0;i &lt; obj-&gt;tag_n;i++) {
+		if (0 == strcmp(obj-&gt;tag_p[i].k, k)) return(&amp;(obj-&gt;tag_p[i]));
 	}
 	return(NULL);
 }
 void tag_free(tag_t *tag)
 {
-	if (tag-&gt;d.s!=tag-&gt;v)
+	if (tag-&gt;d.s != tag-&gt;v)
 		free(tag-&gt;d.s);
 	free(tag-&gt;v);
 	free(tag-&gt;k);
-	tag-&gt;k=NULL;
-	tag-&gt;d.s=NULL;
-	tag-&gt;v=NULL;
+	tag-&gt;k = NULL;
+	tag-&gt;d.s = NULL;
+	tag-&gt;v = NULL;
 }

Modified: trunk/apps/s3dosm/ui.c
===================================================================
--- trunk/apps/s3dosm/ui.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/ui.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,27 +24,27 @@
 #include &lt;s3d.h&gt;
 #include &lt;s3dw.h&gt;
 #include &quot;s3dosm.h&quot;
-#include &lt;stdio.h&gt;	/* NULL */
+#include &lt;stdio.h&gt; /* NULL */
 #include &lt;string.h&gt; /* strcmp */
 #include &lt;stdlib.h&gt; /* atoi() */
-icon_t icons[ICON_NUM]={
-	{&quot;objs/accesspoint.3ds&quot;,0},
-	{&quot;objs/noinetwep.3ds&quot;,0},
-	{&quot;objs/noinetwpa.3ds&quot;,0},
-	{&quot;objs/arrow2.3ds&quot;,0}
+icon_t icons[ICON_NUM] = {
+	{&quot;objs/accesspoint.3ds&quot;, 0},
+	{&quot;objs/noinetwep.3ds&quot;, 0},
+	{&quot;objs/noinetwpa.3ds&quot;, 0},
+	{&quot;objs/arrow2.3ds&quot;, 0}
 };
 
 /* load icons, we want to clone each of them later */
 void ui_loadicons()
 {
 	int i;
-	for (i=0;i&lt;ICON_NUM;i++)
-		icons[i].oid=s3d_import_model_file(icons[i].path);
+	for (i = 0;i &lt; ICON_NUM;i++)
+		icons[i].oid = s3d_import_model_file(icons[i].path);
 }
 
-static s3dw_surface *loadwindow=NULL;
-static s3dw_label   *loadlabel=NULL;
-static s3dw_label   *loadstatus=NULL;
+static s3dw_surface *loadwindow = NULL;
+static s3dw_label   *loadlabel = NULL;
+static s3dw_label   *loadstatus = NULL;
 
 void key_button(s3dw_widget *button)
 {
@@ -53,53 +53,53 @@
 
 int ui_getinfo_node(void *data, int argc, char **argv, char **azColName)
 {
-	int i,tagid=-1;
+	int i, tagid = -1;
 	char type[MAXQ];
 	char name[MAXQ];
 	char string[128];
 	s3dw_surface *miniwin;
 	s3dw_button  *button;
 
-	for (i=0; i&lt;argc; i++) {
+	for (i = 0; i &lt; argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],&quot;tag_id&quot;)) 			tagid=atoi(argv[i]);
+			if (0 == strcmp(azColName[i], &quot;tag_id&quot;))    tagid = atoi(argv[i]);
 		}
 	}
-	if (db_gettag(tagid, &quot;amenity&quot;,type)) type[0]=0;
-	if (db_gettag(tagid, &quot;name&quot;,name)) name[0]=0;
+	if (db_gettag(tagid, &quot;amenity&quot;, type)) type[0] = 0;
+	if (db_gettag(tagid, &quot;name&quot;, name)) name[0] = 0;
 
-	miniwin=s3dw_surface_new(&quot;About node&quot;,30,6);
-	snprintf(string,128,&quot;name: %s&quot;,name);
-	s3dw_label_new(miniwin,string,1,2);
-	snprintf(string,128,&quot;type: %s&quot;,type);
-	s3dw_label_new(miniwin,string,1,4);
-	button=s3dw_button_new(miniwin,&quot;OK&quot;,2,6);
-	button-&gt;onclick=key_button;
+	miniwin = s3dw_surface_new(&quot;About node&quot;, 30, 6);
+	snprintf(string, 128, &quot;name: %s&quot;, name);
+	s3dw_label_new(miniwin, string, 1, 2);
+	snprintf(string, 128, &quot;type: %s&quot;, type);
+	s3dw_label_new(miniwin, string, 1, 4);
+	button = s3dw_button_new(miniwin, &quot;OK&quot;, 2, 6);
+	button-&gt;onclick = key_button;
 	s3dw_show(S3DWIDGET(miniwin));
 
 	return(0);
 }
 int ui_getinfo_way(void *data, int argc, char **argv, char **azColName)
 {
-	int i,tagid=-1;
+	int i, tagid = -1;
 	char name[MAXQ];
 	char string[128];
 	s3dw_surface *miniwin;
 	s3dw_button  *button;
 
-	for (i=0; i&lt;argc; i++) {
+	for (i = 0; i &lt; argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],&quot;tag_id&quot;)) 			tagid=atoi(argv[i]);
+			if (0 == strcmp(azColName[i], &quot;tag_id&quot;))    tagid = atoi(argv[i]);
 		}
 	}
-	if (db_gettag(tagid, &quot;name&quot;,name)) name[0]=0;
-	printf(&quot;reporting street %s\n&quot;,name);
+	if (db_gettag(tagid, &quot;name&quot;, name)) name[0] = 0;
+	printf(&quot;reporting street %s\n&quot;, name);
 
-	miniwin=s3dw_surface_new(&quot;About street&quot;,30,6);
-	snprintf(string,128,&quot;name: %s&quot;,name);
-	s3dw_label_new(miniwin,string,1,2);
-	button=s3dw_button_new(miniwin,&quot;OK&quot;,2,4);
-	button-&gt;onclick=key_button;
+	miniwin = s3dw_surface_new(&quot;About street&quot;, 30, 6);
+	snprintf(string, 128, &quot;name: %s&quot;, name);
+	s3dw_label_new(miniwin, string, 1, 2);
+	button = s3dw_button_new(miniwin, &quot;OK&quot;, 2, 4);
+	button-&gt;onclick = key_button;
 	s3dw_show(S3DWIDGET(miniwin));
 
 	return(0);
@@ -107,19 +107,19 @@
 
 int ui_click(struct s3d_evt *evt)
 {
-	int oid=(int)*((uint32_t *)evt-&gt;buf);
+	int oid = (int) * ((uint32_t *)evt-&gt;buf);
 	char query[MAXQ];
 	if (s3dw_handle_click(evt)) return(0);
-	snprintf(query,MAXQ,&quot;SELECT * FROM node WHERE s3doid=%d;&quot;,oid);
+	snprintf(query, MAXQ, &quot;SELECT * FROM node WHERE s3doid=%d;&quot;, oid);
 	db_exec(query, ui_getinfo_node, 0);
-	snprintf(query,MAXQ,&quot;SELECT * FROM way WHERE s3doid=%d;&quot;,oid);
+	snprintf(query, MAXQ, &quot;SELECT * FROM way WHERE s3doid=%d;&quot;, oid);
 	db_exec(query, ui_getinfo_way, 0);
 
 	return(0);
 }
 int ui_key(struct s3d_evt *evt)
 {
-	/*	struct s3d_key_event *key=(struct s3d_key_event *)evt-&gt;buf;*/
+	/* struct s3d_key_event *key=(struct s3d_key_event *)evt-&gt;buf;*/
 	if (s3dw_handle_key(evt)) return(0);
 	return(0);
 }
@@ -131,33 +131,33 @@
 int ui_init()
 {
 	ui_loadicons();
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,ui_click);
-	s3d_set_callback(S3D_EVENT_KEY,ui_key);
-	s3d_set_callback(S3D_EVENT_OBJ_INFO,ui_oinfo);
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK, ui_click);
+	s3d_set_callback(S3D_EVENT_KEY, ui_key);
+	s3d_set_callback(S3D_EVENT_OBJ_INFO, ui_oinfo);
 	return(0);
 }
 
 /* initialize the loadwindow or change its caption text */
 int load_window(char *text)
 {
-	if (loadwindow==NULL) { /* create it */
-		loadwindow=s3dw_surface_new(&quot;Now loading ...&quot;,20,5);
-		loadlabel=s3dw_label_new(loadwindow,text,1,2);
-		loadstatus=s3dw_label_new(loadwindow,&quot;&quot;,1,3);
+	if (loadwindow == NULL) { /* create it */
+		loadwindow = s3dw_surface_new(&quot;Now loading ...&quot;, 20, 5);
+		loadlabel = s3dw_label_new(loadwindow, text, 1, 2);
+		loadstatus = s3dw_label_new(loadwindow, &quot;&quot;, 1, 3);
 		s3dw_show(S3DWIDGET(loadwindow));
 	} else {
-		s3dw_label_change_text(loadlabel,text);
-		s3dw_label_change_text(loadstatus,&quot;&quot;);
+		s3dw_label_change_text(loadlabel, text);
+		s3dw_label_change_text(loadstatus, &quot;&quot;);
 	}
 	return(0);
 }
 /* remove it if still here */
 int load_window_remove()
 {
-	if (loadwindow!=NULL) {
+	if (loadwindow != NULL) {
 		s3dw_delete(S3DWIDGET(loadwindow));
-		loadwindow=NULL;
-		loadlabel=NULL;
+		loadwindow = NULL;
+		loadlabel = NULL;
 	}
 	return(0);
 }
@@ -165,9 +165,9 @@
 int load_update_status(float percent)
 {
 	char text[128];
-	if (loadwindow!=NULL) {
-		snprintf(text,128,&quot;%3.1f&quot;,percent);
-		s3dw_label_change_text(loadstatus,text);
+	if (loadwindow != NULL) {
+		snprintf(text, 128, &quot;%3.1f&quot;, percent);
+		s3dw_label_change_text(loadstatus, text);
 	}
 	mainloop();
 	return(0);

Modified: trunk/apps/s3dvt/main.c
===================================================================
--- trunk/apps/s3dvt/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dvt/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,26 +24,26 @@
 
 
 #include &quot;s3dvt.h&quot;
-#include &lt;stdio.h&gt; 		 /*  FILE,NULL */
-#include &lt;unistd.h&gt; 	 /*  read(),write(), sleep(),close() ... */
-#include &lt;errno.h&gt;		 /*  errno() */
-#include &lt;fcntl.h&gt; 		 /*  open() */
-#include &lt;signal.h&gt;		 /*  signal() */
-#include &lt;stdlib.h&gt;		 /*  exit(),getenv(),setenv() */
-#include &lt;sys/ioctl.h&gt; 	 /*  ioctl() */
-#include &lt;pthread.h&gt;	 /*  pthread_create() */
-#include &lt;s3d.h&gt;		 /*  s3d_* */
-#include &lt;s3d_keysym.h&gt;	 /*  key symbols */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t= {
-	0,10*1000*1000
+#include &lt;stdio.h&gt;    /*  FILE,NULL */
+#include &lt;unistd.h&gt;   /*  read(),write(), sleep(),close() ... */
+#include &lt;errno.h&gt;   /*  errno() */
+#include &lt;fcntl.h&gt;    /*  open() */
+#include &lt;signal.h&gt;   /*  signal() */
+#include &lt;stdlib.h&gt;   /*  exit(),getenv(),setenv() */
+#include &lt;sys/ioctl.h&gt;   /*  ioctl() */
+#include &lt;pthread.h&gt;  /*  pthread_create() */
+#include &lt;s3d.h&gt;   /*  s3d_* */
+#include &lt;s3d_keysym.h&gt;  /*  key symbols */
+#include &lt;time.h&gt; /* nanosleep() */
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 
 
 static int pid;
-static int term_mode=0;
+static int term_mode = 0;
 
-static int cursor;		/* the object id of the cursor */
+static int cursor;  /* the object id of the cursor */
 
 static pthread_t term_thread;
 
@@ -52,46 +52,46 @@
 static int mpipe_out[2];
 #endif
 #ifdef M_PTY
-static int curtty,curpty;
+static int curtty, curpty;
 #endif
 
 #ifdef M_CHAR
 static unsigned int charbuf[256];
 static unsigned int screenbuf[MAX_LINES*MAX_CHARS];
-static char 		last_c[MAX_LINES*MAX_CHARS];
+static char   last_c[MAX_LINES*MAX_CHARS];
 #endif
 
 #ifdef M_LINE
-static int 			lines[MAX_LINES];
+static int    lines[MAX_LINES];
 #endif
 
 void *thread_terminal(void *a)
 {
-	int iscon=1,ret;
+	int iscon = 1, ret;
 	char buffer[1024];
 	while (iscon) {
 		switch (term_mode) {
 		case M_PIPE:
-			ret=read(mpipe_out[0], &amp;buffer, 1000);
+			ret = read(mpipe_out[0], &amp;buffer, 1000);
 			break;
 		case M_PTY:
-			ret=read(curpty, &amp;buffer, 1000);
+			ret = read(curpty, &amp;buffer, 1000);
 			break;
 		default:
-			ret=-1;
+			ret = -1;
 		}
-		if (ret&gt;0) {
-			buffer[ret]='\0';
+		if (ret &gt; 0) {
+			buffer[ret] = '\0';
 			printf(&quot;&lt;&lt;&lt;new data(%d bytes)\n&quot;, ret);
 			AddChar(buffer);
 		} else {
-			if (ret==-1) {
+			if (ret == -1) {
 				perror(&quot;read()&quot;);
-				printf(&quot;Connection to pty lost (ret=%d)\n&quot;,ret);
+				printf(&quot;Connection to pty lost (ret=%d)\n&quot;, ret);
 				close(mpipe_in[0]);
 				close(mpipe_out[1]);
-				/* 		close(curpty);  */
-				/* 		close(curtty);  */
+				/*   close(curpty);  */
+				/*   close(curtty);  */
 				printf(&quot;********CONNECTION TO PTY LOST!*******\n&quot;);
 				sleep(1);
 				s3d_quit();
@@ -107,19 +107,19 @@
 	char buf[256];
 	char tmpstr[1024];
 	int curtty;
-	int uid=0,gid=0;
-	char exe[]=&quot;/bin/bash&quot;;
+	int uid = 0, gid = 0;
+	char exe[] = &quot;/bin/bash&quot;;
 	char curchar;
 	char *disp;
 
-	disp=getenv(&quot;DISPLAY&quot;);
-	uid=getuid();
-	gid=getgid();
-	term_mode=M_PTY;
-	for (curchar='p'; curchar&lt;'z';curchar++) {
-		for (i=0;i &lt; 16;i++) {
+	disp = getenv(&quot;DISPLAY&quot;);
+	uid = getuid();
+	gid = getgid();
+	term_mode = M_PTY;
+	for (curchar = 'p'; curchar &lt; 'z';curchar++) {
+		for (i = 0;i &lt; 16;i++) {
 			sprintf(buf, &quot;/dev/pty%c%x&quot;, curchar, i);
-			curpty=open(buf, O_RDWR);
+			curpty = open(buf, O_RDWR);
 			if (curpty &gt;= 0)
 				goto endloop;
 		}
@@ -129,19 +129,19 @@
 		printf(&quot;Error opening pty\n&quot;);
 		return 0;
 	}
-	/* 	fnctl(F_SETFL,O_NONBLOCK); */
+	/*  fnctl(F_SETFL,O_NONBLOCK); */
 	signal(SIGCHLD, SIG_IGN);
 	pid = fork();
 	if (!pid) {
-		buf[5]='t';
-		curtty=open(buf, O_RDWR);
+		buf[5] = 't';
+		curtty = open(buf, O_RDWR);
 		if (curtty &lt; 0) {
 			printf(&quot;Error opening tty\n&quot;);
 			return 0;
 		}
 		setuid(uid);
 		setgid(gid);
-		if (setsid()&lt;0)
+		if (setsid() &lt; 0)
 			printf(&quot;ERROR (setsid)\n&quot;);
 		/*     tcflush(curpty, TCIOFLUSH); */
 		if (ioctl(curtty, TIOCSCTTY, NULL))
@@ -149,9 +149,9 @@
 		dup2(curtty, 0);
 		dup2(curtty, 1);
 		dup2(curtty, 2);
-		sprintf(tmpstr, &quot;%d&quot;, MAX_LINES-1);
+		sprintf(tmpstr, &quot;%d&quot;, MAX_LINES - 1);
 		setenv(&quot;LINES&quot;, tmpstr, 1);
-		sprintf(tmpstr, &quot;%d&quot;, MAX_CHARS-1);
+		sprintf(tmpstr, &quot;%d&quot;, MAX_CHARS - 1);
 		setenv(&quot;COLUMNS&quot;, tmpstr, 1);
 		setenv(&quot;TERM&quot;, &quot;rxvt&quot;, 1);
 		execl(exe, exe, NULL);
@@ -159,7 +159,7 @@
 		printf(&quot;that's it, exiting&quot;);
 		close(curtty);
 		exit(0);
-	} else if (pid&lt;0) {
+	} else if (pid &lt; 0) {
 		printf(&quot;Cant fork()\n&quot;);
 		exit(0);
 	} else {
@@ -173,8 +173,8 @@
 	/*    printf(&quot;sending: %.3d\n&quot;, toprint);*/
 	switch (term_mode) {
 	case M_PIPE:
-		write(mpipe_in[1],&amp;toprint,1);
-		write(mpipe_out[1],&amp;toprint,1);
+		write(mpipe_in[1], &amp;toprint, 1);
+		write(mpipe_out[1], &amp;toprint, 1);
 		break;
 	case M_PTY:
 		write(curpty, &amp;toprint, 1);
@@ -186,46 +186,46 @@
 int pipe_init_terminal()
 {
 	char buf[256];
-	int uid=0,gid=0;
-	char *exe=&quot;/bin/bash&quot;;
-	char *args=&quot;-i&quot;;
+	int uid = 0, gid = 0;
+	char *exe = &quot;/bin/bash&quot;;
+	char *args = &quot;-i&quot;;
 	char *disp;
 
-	term_mode=M_PIPE;
-	if ((pipe(mpipe_in)==-1) || (pipe(mpipe_out)==-1)) {
+	term_mode = M_PIPE;
+	if ((pipe(mpipe_in) == -1) || (pipe(mpipe_out) == -1)) {
 		printf(&quot;pipe failed\n&quot;);
 		return(-1);
 	}
-	disp=getenv(&quot;DISPLAY&quot;);
-	uid=getuid();
-	gid=getgid();
+	disp = getenv(&quot;DISPLAY&quot;);
+	uid = getuid();
+	gid = getgid();
 	pid = fork();
-	if (pid==0) { /*  the child */
+	if (pid == 0) { /*  the child */
 		char tmpstr[1024];
-		buf[5]='t';
+		buf[5] = 't';
 		setuid(uid);
 		setgid(gid);
-		if (setsid()&lt;0)
+		if (setsid() &lt; 0)
 			printf(&quot;ERROR (setsid)\n&quot;);
 		/*     tcflush(curpty, TCIOFLUSH); */
 		/*     if(ioctl(curtty, TIOCSCTTY, NULL)) printf(&quot;ERROR! (ttyflush)\n&quot;);; */
-		setvbuf(stdout,(char*)NULL,_IONBF,0);
+		setvbuf(stdout, (char*)NULL, _IONBF, 0);
 		dup2(mpipe_in[0], fileno(stdin));
 		dup2(mpipe_out[1], fileno(stdout));
 		dup2(mpipe_out[1], fileno(stderr));
 		/*  close unneded things: */
 		close(mpipe_out[0]);
 		close(mpipe_in[1]);
-		sprintf(tmpstr, &quot;%d&quot;, MAX_LINES-1);
+		sprintf(tmpstr, &quot;%d&quot;, MAX_LINES - 1);
 		setenv(&quot;LINES&quot;, tmpstr, 1);
-		sprintf(tmpstr, &quot;%d&quot;, MAX_CHARS-1);
+		sprintf(tmpstr, &quot;%d&quot;, MAX_CHARS - 1);
 		setenv(&quot;COLUMNS&quot;, tmpstr, 1);
 		setenv(&quot;TERM&quot;, &quot;rxvt&quot;, 1);
-		execl(exe, exe, args,NULL);
+		execl(exe, exe, args, NULL);
 		printf(&quot;that's it, exiting&quot;);
 		close(curtty);
 		exit(0);
-	} else if (pid&lt;0) {
+	} else if (pid &lt; 0) {
 		printf(&quot;Cant fork()\n&quot;);
 		exit(0);
 	} else {
@@ -238,7 +238,7 @@
 int init_terminal()
 {
 	int i;
-	for (i=0;i&lt;5;i++)
+	for (i = 0;i &lt; 5;i++)
 		if (pty_init_terminal())  /*  find an open pty. */
 			return(0);
 	return(pipe_init_terminal());  /*  if not, fallback to pipe mode */
@@ -265,121 +265,121 @@
 {
 	int cline;
 	int c;
-	unsigned char ch,och;
+	unsigned char ch, och;
 	unsigned int ci;
-	int i,line_end;
+	int i, line_end;
 
-	s3d_translate(	cursor,cx*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cy*CS + CS*MAX_LINES/2,0);
-	s3d_scale(		cursor,CS);
-	for (cline=0;cline&lt;MAX_LINES;cline++) {
-		line_end=0;
-		for (c=0;c&lt;MAX_CHARS;c++) {
-			i=cline*MAX_CHARS+c;			 /*  calculate position */
-			if (((ch=line[cline].chars[c].character)!=(och=last_c[i]))) {
-				if (screenbuf[i]==-1) {
-					screenbuf[i]=s3d_new_object();
-					s3d_translate(screenbuf[i],c*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cline*CS + CS*MAX_LINES/2,0);
-					s3d_scale(screenbuf[i],CS);
-					s3d_flags_on(screenbuf[i],S3D_OF_VISIBLE);
+	s3d_translate(cursor, cx*X_RATIO*CS - CS*X_RATIO*MAX_CHARS / 2, -cy*CS + CS*MAX_LINES / 2, 0);
+	s3d_scale(cursor, CS);
+	for (cline = 0;cline &lt; MAX_LINES;cline++) {
+		line_end = 0;
+		for (c = 0;c &lt; MAX_CHARS;c++) {
+			i = cline * MAX_CHARS + c;    /*  calculate position */
+			if (((ch = line[cline].chars[c].character) != (och = last_c[i]))) {
+				if (screenbuf[i] == -1) {
+					screenbuf[i] = s3d_new_object();
+					s3d_translate(screenbuf[i], c*X_RATIO*CS - CS*X_RATIO*MAX_CHARS / 2, -cline*CS + CS*MAX_LINES / 2, 0);
+					s3d_scale(screenbuf[i], CS);
+					s3d_flags_on(screenbuf[i], S3D_OF_VISIBLE);
 				}
-				if ((ch==0) || (line_end)) {	/*  the new character is zero! delete! */
-					line[cline].chars[c].character=0;
-					ci=charbuf[' '];
-					s3d_clone_target(screenbuf[i],ci);
-					line_end=1;
-					/* 					printf(&quot;-%03d&quot;,ch); */
+				if ((ch == 0) || (line_end)) { /*  the new character is zero! delete! */
+					line[cline].chars[c].character = 0;
+					ci = charbuf[' '];
+					s3d_clone_target(screenbuf[i], ci);
+					line_end = 1;
+					/*      printf(&quot;-%03d&quot;,ch); */
 				} else {
-					ci=charbuf[ch];
-					/* 					printf(&quot;!%03d&quot;,ch); */
-					s3d_clone_target(screenbuf[i],ci);
+					ci = charbuf[ch];
+					/*      printf(&quot;!%03d&quot;,ch); */
+					s3d_clone_target(screenbuf[i], ci);
 				}
 			} else {
-				/* 				printf(&quot;=%03d&quot;,ch); */
+				/*     printf(&quot;=%03d&quot;,ch); */
 			}
-			last_c[i]=ch;
+			last_c[i] = ch;
 		}
-		/* 		printf(&quot;\n&quot;); */
+		/*   printf(&quot;\n&quot;); */
 	}
-	gotnewdata=0;
+	gotnewdata = 0;
 }
 #endif
 #ifdef M_LINE
 void paintit()
 {
 	int cline;
-	int oid,c;
+	int oid, c;
 	int len;
 	int changed;
 	char cl[MAX_CHARS];
-	for (cline=0;cline&lt;MAX_LINES;cline++) {
-		len=MAX_CHARS;
-		changed=0;
-		for (c=MAX_CHARS;c&gt;=0;c--) {
-			cl[c]=line[cline].chars[c].character;
-			if (line[cline].chars[c].character!=line[cline].chars[c].last_c) {
-				changed=c+1;
-				/*				printf(&quot;changed [%d/%d] from %d to %d\n&quot;,cline,c,
-												line[cline].chars[c].last_c,
-												line[cline].chars[c].character
-												);*/
-				line[cline].chars[c].last_c=line[cline].chars[c].character;
+	for (cline = 0;cline &lt; MAX_LINES;cline++) {
+		len = MAX_CHARS;
+		changed = 0;
+		for (c = MAX_CHARS;c &gt;= 0;c--) {
+			cl[c] = line[cline].chars[c].character;
+			if (line[cline].chars[c].character != line[cline].chars[c].last_c) {
+				changed = c + 1;
+				/*    printf(&quot;changed [%d/%d] from %d to %d\n&quot;,cline,c,
+				        line[cline].chars[c].last_c,
+				        line[cline].chars[c].character
+				        );*/
+				line[cline].chars[c].last_c = line[cline].chars[c].character;
 			}
-			if (cl[c]==0) len=c;
+			if (cl[c] == 0) len = c;
 		}
 		if (changed) {
-			if (len&gt;0) {
-				printf(&quot;[p: line %d [len: %d/changed: %d]\n&quot;,cline,len,changed);
-				oid=s3d_draw_string(cl,NULL);
-				s3d_translate(oid,0,-cline,0);
-				if (lines[cline]!=-1) {
+			if (len &gt; 0) {
+				printf(&quot;[p: line %d [len: %d/changed: %d]\n&quot;, cline, len, changed);
+				oid = s3d_draw_string(cl, NULL);
+				s3d_translate(oid, 0, -cline, 0);
+				if (lines[cline] != -1) {
 					s3d_del_object(lines[cline]);
-					lines[cline]=-1;
+					lines[cline] = -1;
 				}
-				s3d_flags_on(oid,S3D_OF_VISIBLE);
-				lines[cline]=oid;
+				s3d_flags_on(oid, S3D_OF_VISIBLE);
+				lines[cline] = oid;
 			} else {
-				if (lines[cline]!=-1) {
+				if (lines[cline] != -1) {
 					s3d_del_object(lines[cline]);
-					lines[cline]=-1;
+					lines[cline] = -1;
 				}
 			}
 		}
 
 	}
-	gotnewdata=0;
+	gotnewdata = 0;
 }
 #endif
 /*
 void paint_chars()
 {
-	char c;
-	int oid;
-	int cline,cchar;
-	for(cline=0;cline&lt;MAX_LINES;cline++)
-	{
-	    for(cchar=0;cchar&lt;MAX_CHARS;cchar++)
-		{
-			c=line[cline].chars[cchar].character;
-/ * 			printf(&quot;%02x|&quot;,c); * /
-	        if(!islastchar(cline,cchar))
-	         if(line[cline].chars[cchar].character &amp;&amp; line[cline].chars[cchar].character != ' ')
-			 {
-/ * 				if (screenbuf[MAX_LINES*MAX_CHARS]!=-1) s3d_del_object(screenbuf[MAX_LINES*MAX_CHARS]); * /
-				oid=s3d_clone(cobjs[c]);
-				s3d_translate(oid,10*cchar,10*cline,0);
-				s3d_flags_on(oid,S3D_OF_VISIBLE);
-				screenbuf[MAX_LINES*MAX_CHARS]=oid;
-			 }
-	    }
-/ * 		printf(&quot;\n&quot;); * /
-	}
+ char c;
+ int oid;
+ int cline,cchar;
+ for(cline=0;cline&lt;MAX_LINES;cline++)
+ {
+     for(cchar=0;cchar&lt;MAX_CHARS;cchar++)
+  {
+   c=line[cline].chars[cchar].character;
+/ *    printf(&quot;%02x|&quot;,c); * /
+         if(!islastchar(cline,cchar))
+          if(line[cline].chars[cchar].character &amp;&amp; line[cline].chars[cchar].character != ' ')
+    {
+/ *     if (screenbuf[MAX_LINES*MAX_CHARS]!=-1) s3d_del_object(screenbuf[MAX_LINES*MAX_CHARS]); * /
+    oid=s3d_clone(cobjs[c]);
+    s3d_translate(oid,10*cchar,10*cline,0);
+    s3d_flags_on(oid,S3D_OF_VISIBLE);
+    screenbuf[MAX_LINES*MAX_CHARS]=oid;
+    }
+     }
+/ *   printf(&quot;\n&quot;); * /
+ }
 }*/
 int keypress(struct s3d_evt *event)
 {
-	struct s3d_key_event *keys=(struct s3d_key_event *)event-&gt;buf;
+	struct s3d_key_event *keys = (struct s3d_key_event *)event-&gt;buf;
 	int key;
-	/*	printf(&quot;received key: %d\n&quot;,key);*/
-	switch (key=keys-&gt;keysym) {
+	/* printf(&quot;received key: %d\n&quot;,key);*/
+	switch (key = keys-&gt;keysym) {
 	case S3DK_F1:
 	case S3DK_F2:
 	case S3DK_F3:
@@ -388,7 +388,7 @@
 		term_addchar(0x1b);
 		term_addchar('[');
 		term_addchar('1');
-		term_addchar(key-S3DK_F1+'1');
+		term_addchar(key - S3DK_F1 + '1');
 		break;
 	case S3DK_F6:
 	case S3DK_F7:
@@ -396,21 +396,21 @@
 		term_addchar(0x1b);
 		term_addchar('[');
 		term_addchar('1');
-		term_addchar((key-S3DK_F6)+'7');
+		term_addchar((key - S3DK_F6) + '7');
 		break;
 	case S3DK_F9:
 	case S3DK_F10:
 		term_addchar(0x1b);
 		term_addchar('[');
 		term_addchar('2');
-		term_addchar((key-S3DK_F9)+'0');
+		term_addchar((key - S3DK_F9) + '0');
 		break;
 	case S3DK_F11:
 	case S3DK_F12:
 		term_addchar(0x1b);
 		term_addchar('[');
 		term_addchar('2');
-		term_addchar((key-S3DK_F11)+'3');
+		term_addchar((key - S3DK_F11) + '3');
 		break;
 	case S3DK_UP:
 		term_addchar(0x1b);
@@ -466,23 +466,23 @@
 	return(0);
 
 }
-int i=0;
+int i = 0;
 void mainloop()
 {
 	usleep(10000);
-	nanosleep(&amp;t,NULL);
+	nanosleep(&amp;t, NULL);
 
-	if ((i+=2)&gt;100) {
-		if (i%2) {
-			s3d_flags_on(cursor,S3D_OF_VISIBLE);
-			i=0;
+	if ((i += 2) &gt; 100) {
+		if (i % 2) {
+			s3d_flags_on(cursor, S3D_OF_VISIBLE);
+			i = 0;
 		} else {
-			s3d_flags_off(cursor,S3D_OF_VISIBLE);
-			i=1;
+			s3d_flags_off(cursor, S3D_OF_VISIBLE);
+			i = 1;
 		}
 	}
 	if (gotnewdata) {
-		/* 		printf(&quot;got new data,displaying\n&quot;); */
+		/*   printf(&quot;got new data,displaying\n&quot;); */
 		paintit();
 	}
 }
@@ -494,68 +494,68 @@
 unsigned int draw_background()
 {
 	unsigned int b;
-	b=s3d_new_object();
-	s3d_push_vertex(b,-MAX_CHARS/2*X_RATIO*CS	,CS	+CS*MAX_LINES/2		,-0.01);
-	s3d_push_vertex(b, MAX_CHARS/2*X_RATIO*CS	,CS	+CS*MAX_LINES/2		,-0.01);
-	s3d_push_vertex(b, MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
-	s3d_push_vertex(b,-MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
-	s3d_push_material_a(b,0.5,0.5,0.5,0.7,
-	                    1,1,1,0.7,
-	                    0,0,0,0.7);
-	s3d_push_polygon(b,1,2,0,0);
-	s3d_push_polygon(b,2,3,0,0);
-	s3d_flags_on(b,S3D_OF_VISIBLE);
+	b = s3d_new_object();
+	s3d_push_vertex(b, -MAX_CHARS / 2*X_RATIO*CS , CS + CS*MAX_LINES / 2  , -0.01);
+	s3d_push_vertex(b, MAX_CHARS / 2*X_RATIO*CS , CS + CS*MAX_LINES / 2  , -0.01);
+	s3d_push_vertex(b, MAX_CHARS / 2*X_RATIO*CS , -CS*MAX_LINES / 2  , -0.01);
+	s3d_push_vertex(b, -MAX_CHARS / 2*X_RATIO*CS , -CS*MAX_LINES / 2  , -0.01);
+	s3d_push_material_a(b, 0.5, 0.5, 0.5, 0.7,
+	                    1, 1, 1, 0.7,
+	                    0, 0, 0, 0.7);
+	s3d_push_polygon(b, 1, 2, 0, 0);
+	s3d_push_polygon(b, 2, 3, 0, 0);
+	s3d_flags_on(b, S3D_OF_VISIBLE);
 	return(b);
 }
 void chars_s3d_init()
 {
 #ifdef M_CHAR
 	char c[2];
-	c[1]='\0';
-	for (i=0;i&lt;128;i++) {
-		c[0]=i;
-		charbuf[i]=s3d_draw_string(c,NULL);
+	c[1] = '\0';
+	for (i = 0;i &lt; 128;i++) {
+		c[0] = i;
+		charbuf[i] = s3d_draw_string(c, NULL);
 	}
-	for (i=128;i&lt;256;i++) {
-		charbuf[i]=s3d_new_object();
+	for (i = 128;i &lt; 256;i++) {
+		charbuf[i] = s3d_new_object();
 	}
-	cursor=s3d_new_object();
-	s3d_clone_target(cursor,charbuf['_']);
+	cursor = s3d_new_object();
+	s3d_clone_target(cursor, charbuf['_']);
 #endif
 }
 void chars_init()
 {
 #ifdef M_CHAR
-	int x,y;
-	for (y=0;y&lt;(MAX_LINES);y++)
-		for (x=0;x&lt;(MAX_CHARS);x++) {
-			line[y].chars[x].character=line[y].chars[x].character=0;
-			i=y*MAX_CHARS+x;
-			screenbuf[i]=-1;
-			last_c[i]=0;
+	int x, y;
+	for (y = 0;y &lt; (MAX_LINES);y++)
+		for (x = 0;x &lt; (MAX_CHARS);x++) {
+			line[y].chars[x].character = line[y].chars[x].character = 0;
+			i = y * MAX_CHARS + x;
+			screenbuf[i] = -1;
+			last_c[i] = 0;
 		}
 #endif
 #ifdef M_LINE
 	int i;
-	for (i=0;i&lt;MAX_LINES;i++)
-		lines[i]=-1;
+	for (i = 0;i &lt; MAX_LINES;i++)
+		lines[i] = -1;
 #endif
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
 	unsigned int b;
 	chars_init();
 	init_terminal();
-	s3d_set_callback(S3D_EVENT_QUIT,stop);
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,stop);
-	s3d_set_callback(S3D_EVENT_KEY,keypress);
+	s3d_set_callback(S3D_EVENT_QUIT, stop);
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK, stop);
+	s3d_set_callback(S3D_EVENT_KEY, keypress);
 
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;s3dvt&quot;)) {
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;s3dvt&quot;)) {
 		if (s3d_select_font(&quot;vera&quot;)) {
 			printf(&quot;font not found\n&quot;);
 			exit(-1);
 		}
-		b=draw_background();
+		b = draw_background();
 		chars_s3d_init();
 		s3d_mainloop(mainloop);
 		s3d_quit();

Modified: trunk/apps/s3dvt/s3dvt.h
===================================================================
--- trunk/apps/s3dvt/s3dvt.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dvt/s3dvt.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,18 +22,18 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#define MAX_LINES	50
-#define MAX_CHARS	80
+#define MAX_LINES 50
+#define MAX_CHARS 80
 #define DEFAULT_FGCOLOR 2
 #define DEFAULT_BGCOLOR 0
-#define X_RATIO		0.75
-#define CS			0.1
+#define X_RATIO  0.75
+#define CS   0.1
 
-#define M_PIPE		1
-#define M_PTY		2
+#define M_PIPE  1
+#define M_PTY  2
 
-/* #define M_LINE		1 */
-#define M_CHAR		1
+/* #define M_LINE  1 */
+#define M_CHAR  1
 
 typedef struct char_struct {
 	char character;
@@ -53,4 +53,4 @@
 void AddChar(char *_toadd);
 
 extern int gotnewdata;
-extern int cx,cy;
+extern int cx, cy;

Modified: trunk/apps/s3dvt/terminal.c
===================================================================
--- trunk/apps/s3dvt/terminal.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dvt/terminal.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,113 +24,113 @@
 
 
 #include &quot;s3dvt.h&quot;
-#include &lt;stdio.h&gt; 		 /*  NULL,perror() */
-#include &lt;string.h&gt;		 /*  memcpy() */
-#include &lt;stdlib.h&gt;		 /*  atoi() */
-#define MOVE_RIGHT 	1
-#define MOVE_LEFT 	2
-#define MOVE_UP	 	3
-#define MOVE_DOWN 	4
+#include &lt;stdio.h&gt;    /*  NULL,perror() */
+#include &lt;string.h&gt;   /*  memcpy() */
+#include &lt;stdlib.h&gt;   /*  atoi() */
+#define MOVE_RIGHT  1
+#define MOVE_LEFT  2
+#define MOVE_UP   3
+#define MOVE_DOWN  4
 
 
-int cx=0,cy=0;
+int cx = 0, cy = 0;
 
-int gotnewdata=1;
+int gotnewdata = 1;
 t_line line[MAX_LINES+1];
-static int isansi=0;
-static int isansi2=0;
+static int isansi = 0;
+static int isansi2 = 0;
 
-static int bottom=MAX_LINES-1;
-static int top=0;
+static int bottom = MAX_LINES - 1;
+static int top = 0;
 
-static int curfgcolor=DEFAULT_FGCOLOR;
-static int curbgcolor=DEFAULT_BGCOLOR;
+static int curfgcolor = DEFAULT_FGCOLOR;
+static int curbgcolor = DEFAULT_BGCOLOR;
 
 void move_all_lines_up()
 {
-	t_line *pfirstline=(t_line*)&line;
-	t_line *psecondline=(t_line*)&amp;line+1;
+	t_line *pfirstline = (t_line*) &amp; line;
+	t_line *psecondline = (t_line*) &amp; line + 1;
 	t_line tmpline[MAX_LINES];
-	memcpy(&amp;tmpline, psecondline, (MAX_LINES-1)*sizeof(struct line_struct));
-	memcpy(pfirstline, &amp;tmpline, (MAX_LINES-1)*sizeof(struct line_struct));
+	memcpy(&amp;tmpline, psecondline, (MAX_LINES - 1)*sizeof(struct line_struct));
+	memcpy(pfirstline, &amp;tmpline, (MAX_LINES - 1)*sizeof(struct line_struct));
 }
 
 void clear_char(int lineid, int charid)
 {
-	line[lineid].chars[charid].character=0;
-	line[lineid].chars[charid].fgcolor=DEFAULT_FGCOLOR;
-	line[lineid].chars[charid].bgcolor=DEFAULT_BGCOLOR;
+	line[lineid].chars[charid].character = 0;
+	line[lineid].chars[charid].fgcolor = DEFAULT_FGCOLOR;
+	line[lineid].chars[charid].bgcolor = DEFAULT_BGCOLOR;
 }
 
 void clear_line(int lineid)
 {
 	int i;
-	for (i=0;i&lt;MAX_CHARS;i++)
+	for (i = 0;i &lt; MAX_CHARS;i++)
 		clear_char(lineid, i);
 }
 
 void clear_line_after_lastchar()
 {
 	int i;
-	for (i=cx;i&lt;MAX_CHARS;i++)
+	for (i = cx;i &lt; MAX_CHARS;i++)
 		clear_char(cy, i);
 }
 
 t_line *line_is_full()
 {
-	t_line *pcurline=(t_line*)&amp;line+cy;
+	t_line *pcurline = (t_line*) &amp; line + cy;
 	cy++;
-	if (cy&gt;=MAX_LINES) {       /*  damn it ... our display is filled ... let's move everything upwards */
-		cy=MAX_LINES-1;
-		pcurline=(t_line*)&amp;line+cy;
+	if (cy &gt;= MAX_LINES) {     /*  damn it ... our display is filled ... let's move everything upwards */
+		cy = MAX_LINES - 1;
+		pcurline = (t_line*) &amp; line + cy;
 		move_all_lines_up();
 		clear_line(cy);
-		gotnewdata=1;
+		gotnewdata = 1;
 	} else {
-		pcurline=(t_line*)&amp;line+cy;
+		pcurline = (t_line*) &amp; line + cy;
 	}
-	cx=0;
+	cx = 0;
 	return pcurline;
 }
 
 void add_char_append(char toappend)
 {
-	int shouldinc=1;
-	t_line *pcurline=(t_line*)&amp;line+cy;
-	if (cx==MAX_CHARS-1) {
-		pcurline=line_is_full();
-		shouldinc=0;
+	int shouldinc = 1;
+	t_line *pcurline = (t_line*) &amp; line + cy;
+	if (cx == MAX_CHARS - 1) {
+		pcurline = line_is_full();
+		shouldinc = 0;
 	}  /*  our line is full */
-	pcurline-&gt;chars[cx].character=toappend;
-	pcurline-&gt;chars[cx].fgcolor=curfgcolor;
-	pcurline-&gt;chars[cx].bgcolor=curbgcolor;
+	pcurline-&gt;chars[cx].character = toappend;
+	pcurline-&gt;chars[cx].fgcolor = curfgcolor;
+	pcurline-&gt;chars[cx].bgcolor = curbgcolor;
 	if (shouldinc)
 		cx++;
 }
 
 void backspace()
 {
-	if (cx&gt;0)
+	if (cx &gt; 0)
 		cx--;
 	else
-		cx=0;
+		cx = 0;
 }
 
 void endansi()
 {
 	printf(&quot; [/ANSI(%d)]\n&quot;, isansi2);
-	isansi=0;
-	isansi2=0;
+	isansi = 0;
+	isansi2 = 0;
 }
 
 /*
               Parameter                              Parameter Meaning
 
-	      0                                      Attributes off
-	      1                                      Bold or increased intensity
-	      4                                      Underscore
-	      5                                      Blink
-	      7                                      Negative (reverse) image
+       0                                      Attributes off
+       1                                      Bold or increased intensity
+       4                                      Underscore
+       5                                      Blink
+       7                                      Negative (reverse) image
 */
 
 void ansi_change_graphic(char **args)
@@ -138,26 +138,26 @@
 	int curcol;
 	int i;
 
-	if (args[0][0]=='\0') {
-		args[0][0]='0';
-		args[0][1]='\0';
+	if (args[0][0] == '\0') {
+		args[0][0] = '0';
+		args[0][1] = '\0';
 	}
 
-	for (i=0;i&lt;5;i++) {
+	for (i = 0;i &lt; 5;i++) {
 		if (args[i][0]) {
-			curcol=atoi(args[i]);
+			curcol = atoi(args[i]);
 
 			switch (curcol) {
 			case 0:
-				curbgcolor=DEFAULT_BGCOLOR;
-				curfgcolor=DEFAULT_FGCOLOR;
+				curbgcolor = DEFAULT_BGCOLOR;
+				curfgcolor = DEFAULT_FGCOLOR;
 				break;
-			case 1:	 /*  Bold or increased intensity */
-			case 4:	 /*  Underscore */
-			case 5:	 /*  Blink */
-			case 7:	 /*  Negative (reverse) image */
-			case 10:	 /*  primary font */
-			case 11:	 /*  alternate font */
+			case 1:  /*  Bold or increased intensity */
+			case 4:  /*  Underscore */
+			case 5:  /*  Blink */
+			case 7:  /*  Negative (reverse) image */
+			case 10:  /*  primary font */
+			case 11:  /*  alternate font */
 				break;
 			case 30:
 			case 31:
@@ -167,10 +167,10 @@
 			case 35:
 			case 36:
 			case 37:
-				curfgcolor=curcol-30;
+				curfgcolor = curcol - 30;
 				break;
 			case 39:
-				curbgcolor=DEFAULT_FGCOLOR;
+				curbgcolor = DEFAULT_FGCOLOR;
 				break;
 			case 40:
 			case 41:
@@ -180,11 +180,11 @@
 			case 45:
 			case 46:
 			case 47:
-				curbgcolor=curcol-40;
+				curbgcolor = curcol - 40;
 				break;
 
 			case 49:
-				curbgcolor=DEFAULT_BGCOLOR;
+				curbgcolor = DEFAULT_BGCOLOR;
 				break;
 
 			default:
@@ -202,18 +202,18 @@
 	int amount;
 	int i;
 
-	if (arg[0]) amount=atoi(arg);
-	else amount=0;
+	if (arg[0]) amount = atoi(arg);
+	else amount = 0;
 
 	printf(&quot;moving up %d lines&quot;, amount);
 
-	for (i=0;i&lt;amount;i++) {
+	for (i = 0;i &lt; amount;i++) {
 
-		pfirstline=(t_line*)&amp;line+cy;
-		psecondline=pfirstline+1;
+		pfirstline = (t_line*) &amp; line + cy;
+		psecondline = pfirstline + 1;
 
-		memcpy(&amp;tmpline, psecondline, (bottom-top)*sizeof(struct line_struct));
-		memcpy(pfirstline, &amp;tmpline,  (bottom-top)*sizeof(struct line_struct));
+		memcpy(&amp;tmpline, psecondline, (bottom - top)*sizeof(struct line_struct));
+		memcpy(pfirstline, &amp;tmpline, (bottom - top)*sizeof(struct line_struct));
 
 	}
 }
@@ -226,17 +226,17 @@
 	int amount;
 	int i;
 
-	if (arg[0]) amount=atoi(arg);
-	else amount=0;
+	if (arg[0]) amount = atoi(arg);
+	else amount = 0;
 
 	printf(&quot;moving down %d lines&quot;, amount);
 
-	for (i=0;i&lt;amount;i++) {
-		pfirstline=(t_line*)&amp;line+cy;
-		psecondline=pfirstline+1;
+	for (i = 0;i &lt; amount;i++) {
+		pfirstline = (t_line*) &amp; line + cy;
+		psecondline = pfirstline + 1;
 
-		memcpy(&amp;tmpline, pfirstline, (bottom-top)*sizeof(struct line_struct));
-		memcpy(psecondline, &amp;tmpline,  (bottom-top)*sizeof(struct line_struct));
+		memcpy(&amp;tmpline, pfirstline, (bottom - top)*sizeof(struct line_struct));
+		memcpy(psecondline, &amp;tmpline, (bottom - top)*sizeof(struct line_struct));
 	}
 }
 void delete_x_letters(char *arg1)
@@ -244,13 +244,13 @@
 	int tmpint;
 	t_line *pcurline;
 	int i;
-	if (arg1[0]) tmpint=atoi(arg1);
-	else	    tmpint=1;
-	pcurline=(t_line*)&amp;line+cy;
-	if (tmpint+cx&gt;MAX_CHARS)
-		tmpint=MAX_CHARS-cx;
-	for (i=cx;i&lt;cx+tmpint;i++)
-		clear_char(cy,i);
+	if (arg1[0]) tmpint = atoi(arg1);
+	else     tmpint = 1;
+	pcurline = (t_line*) &amp; line + cy;
+	if (tmpint + cx &gt; MAX_CHARS)
+		tmpint = MAX_CHARS - cx;
+	for (i = cx;i &lt; cx + tmpint;i++)
+		clear_char(cy, i);
 }
 void move_x_letters(int mode, char *arg1)
 {
@@ -258,27 +258,27 @@
 	t_line *pcurline;
 	int i;
 	if (arg1[0])
-		tmpint=atoi(arg1);
+		tmpint = atoi(arg1);
 	else
-		tmpint=1;
-	pcurline=(t_line*)&amp;line+cy;
+		tmpint = 1;
+	pcurline = (t_line*) &amp; line + cy;
 	switch (mode) {
 	case MOVE_RIGHT:
-		for (i=0;i&lt;tmpint;i++) {
-			/*	    	    pcurline-&gt;nextchar++;
-							lastchar++;*/
+		for (i = 0;i &lt; tmpint;i++) {
+			/*          pcurline-&gt;nextchar++;
+			    lastchar++;*/
 			cx++;
-			if (cx==MAX_CHARS)
-				pcurline=line_is_full();  /*  our line is full */
+			if (cx == MAX_CHARS)
+				pcurline = line_is_full();  /*  our line is full */
 		}
 		break;
 	case MOVE_LEFT:
-		for (i=0;i&lt;tmpint;i++) {
+		for (i = 0;i &lt; tmpint;i++) {
 			cx--;
-			if (cx==-1) {
+			if (cx == -1) {
 				cy--;
-				pcurline=(t_line*)&amp;line+cy;
-				cx=MAX_CHARS-1;
+				pcurline = (t_line*) &amp; line + cy;
+				cx = MAX_CHARS - 1;
 			}  /*  need to go up one line */
 		}
 		break;
@@ -294,26 +294,26 @@
 }
 void remove_beginning_from_curpos()
 {
-	int i,j=cx;
-	for (i=cy;i&lt;MAX_LINES;i++) {
-		for (;j&lt;MAX_CHARS;j++) {
-			clear_char(i,j);
+	int i, j = cx;
+	for (i = cy;i &lt; MAX_LINES;i++) {
+		for (;j &lt; MAX_CHARS;j++) {
+			clear_char(i, j);
 		}
-		j=0;
+		j = 0;
 	}
 }
 
 int parseansi(char curchar)
 {
-	static char arg1[16]=&quot;&quot;;
-	static char arg2[16]=&quot;&quot;;
-	static char arg3[16]=&quot;&quot;;
-	static char arg4[16]=&quot;&quot;;
-	static char arg5[16]=&quot;&quot;;
-	static char curindex=0;
-	static char curarg=0;
-	static char *args[]={arg1,arg2,arg3,arg4,arg5};
-	/* 	static char *args[]={&amp;arg1,&amp;arg2,&amp;arg3,&amp;arg4,&amp;arg5}; */
+	static char arg1[16] = &quot;&quot;;
+	static char arg2[16] = &quot;&quot;;
+	static char arg3[16] = &quot;&quot;;
+	static char arg4[16] = &quot;&quot;;
+	static char arg5[16] = &quot;&quot;;
+	static char curindex = 0;
+	static char curarg = 0;
+	static char *args[] = {arg1, arg2, arg3, arg4, arg5};
+	/*  static char *args[]={&amp;arg1,&amp;arg2,&amp;arg3,&amp;arg4,&amp;arg5}; */
 	printf(&quot;%c&quot;, curchar);
 	switch (isansi2) {
 	case 1:
@@ -328,38 +328,38 @@
 		case '7':
 		case '8':
 		case '9':  /*  we got an argument */
-			args[(int)curarg][(int)curindex]=curchar;
+			args[(int)curarg][(int)curindex] = curchar;
 			curindex++;
-			args[(int)curarg][(int)curindex]='\0';
+			args[(int)curarg][(int)curindex] = '\0';
 			break;
 		case ';':  /*  some arg is finished */
 			curarg++;
-			curindex=0;
-			args[(int)curarg][0]='\0';
+			curindex = 0;
+			args[(int)curarg][0] = '\0';
 			break;
 		case 'J':  /*  remove beginning from current cursor to end of screen */
 			remove_beginning_from_curpos();
-			gotnewdata=1;
+			gotnewdata = 1;
 			break;
 		case 'K':  /*  remove everything in line beginning from lastchar */
 			clear_line_after_lastchar();
 			break;
 		case 'H':  /*  move to position x=arg1 y=arg2 */
-			if (arg1[0]) cy=atoi(arg1)-1;
-			else 	cy=0;
-			if (arg2[0]) cx=atoi(arg2)-1;
-			else 	cx=0;
+			if (arg1[0]) cy = atoi(arg1) - 1;
+			else  cy = 0;
+			if (arg2[0]) cx = atoi(arg2) - 1;
+			else  cx = 0;
 			break;
 		case 'G':  /*  move to position x=arg1 y=MAX */
-			if (arg1[0]) cx=atoi(arg1)-1;
-			else cx=-1;
-			cy=bottom-1;
+			if (arg1[0]) cx = atoi(arg1) - 1;
+			else cx = -1;
+			cy = bottom - 1;
 			break;
 		case 'd':  /*  move to position x=MAX y=arg1 */
-			if (arg1[0]) cy=atoi(arg1)-1;
-			else cy=0;
-			cy=top+cy;
-			cx=MAX_CHARS-1;
+			if (arg1[0]) cy = atoi(arg1) - 1;
+			else cy = 0;
+			cy = top + cy;
+			cx = MAX_CHARS - 1;
 			break;
 		case 'm':  /*  change graphic */
 			ansi_change_graphic(args);
@@ -371,23 +371,23 @@
 			move_down_x_lines(arg1);
 			break;
 		case 'l':
-			/*		RM -- Reset Mode
-					
-					ESC [ Ps ; Ps ; . . . ; Ps l                                                                                                          default value: none
-					
-					Resets one or more VT100 modes as specified by each selective parameter in the parameter string. Each mode to be reset is specified by a separate
-					parameter. [See Set Mode (SM) control sequence]. (See Modes following this section).*/
+			/*  RM -- Reset Mode
+			  
+			  ESC [ Ps ; Ps ; . . . ; Ps l                                                                                                          default value: none
+			  
+			  Resets one or more VT100 modes as specified by each selective parameter in the parameter string. Each mode to be reset is specified by a separate
+			  parameter. [See Set Mode (SM) control sequence]. (See Modes following this section).*/
 
 			/*  mc only resets the '4' !?! =&gt; IRM (Insert/Replacement-Mode) */
 			/*  perhaps Set Cursor to Block mode ? */
 			break;
 		case 'r':  /*  define scroll-range  */
-			if (arg1[0]) top=atoi(arg1);
-			else top=0;
-			if (arg2[0]) bottom=atoi(arg2);
-			else bottom=0;
-			cy=0;
-			cx=0;
+			if (arg1[0]) top = atoi(arg1);
+			else top = 0;
+			if (arg2[0]) bottom = atoi(arg2);
+			else bottom = 0;
+			cy = 0;
+			cx = 0;
 			break;
 		case 'a':
 		case 'A':  /*  move x letters up */
@@ -406,35 +406,35 @@
 			delete_x_letters(arg1);
 			break;
 		case '?':
-			isansi2=4;
+			isansi2 = 4;
 			return 0;
 		default:
 			printf(&quot;***unknown***&quot;);
 		}
-		if (!((curchar&gt;='0' &amp;&amp; curchar&lt;='9') || curchar==';')) { /*  clean our args */
-			args[0][0]='\0';
-			args[1][0]='\0';
-			args[2][0]='\0';
-			args[3][0]='\0';
-			args[4][0]='\0';
-			curindex=0;
-			curarg=0;
+		if (!((curchar &gt;= '0' &amp;&amp; curchar &lt;= '9') || curchar == ';')) { /*  clean our args */
+			args[0][0] = '\0';
+			args[1][0] = '\0';
+			args[2][0] = '\0';
+			args[3][0] = '\0';
+			args[4][0] = '\0';
+			curindex = 0;
+			curarg = 0;
 			endansi();
 		}
 		break;
 	case 0:
 		switch (curchar) {
 		case '[':
-			isansi2=1;
+			isansi2 = 1;
 			break;
 		case '(':
-			isansi2=2;
+			isansi2 = 2;
 			break;
 		case ')':
-			isansi2=3;
+			isansi2 = 3;
 			break;
 		case ']':
-			isansi2=5;
+			isansi2 = 5;
 			break;
 		default:
 			endansi();
@@ -442,11 +442,11 @@
 		}
 		break;
 	case 4:
-		if (curchar&gt;'9' || curchar&lt;'0')
+		if (curchar &gt; '9' || curchar &lt; '0')
 			endansi();
 		break;
 	case 5:
-		if (curchar==7) endansi(); /* FIXME: Window Title*/
+		if (curchar == 7) endansi(); /* FIXME: Window Title*/
 		break;
 	default:
 		endansi();
@@ -460,9 +460,9 @@
 	char *toadd;
 	char curchar;
 
-	for (toadd=_toadd;toadd[0];toadd++) {
-		curchar=toadd[0];
-		/*	printf(&quot;%.3d (&quot;, curchar);*/
+	for (toadd = _toadd;toadd[0];toadd++) {
+		curchar = toadd[0];
+		/* printf(&quot;%.3d (&quot;, curchar);*/
 		if (isansi)
 			parseansi(curchar);
 		else {
@@ -477,7 +477,7 @@
 			case 27:
 				/*  ANSI */
 				printf(&quot;&lt;ESC&gt;[ANSI] &quot;);
-				isansi=1;
+				isansi = 1;
 				break;
 			case 10:
 				printf(&quot;&lt;LF&gt;\n&quot;);/* get onto the next line */
@@ -485,33 +485,33 @@
 				break;
 			case 13:
 				printf(&quot;&lt;CR&gt;\n&quot;);/* carriage return, get back */
-				if (cx==MAX_CHARS-1)
+				if (cx == MAX_CHARS - 1)
 					line_is_full();
-				cx=0;
+				cx = 0;
 				break;
 			default:
-				if ((curchar&gt;=32) &amp;&amp; (curchar&lt;127)) {
-					/*	    printf(&quot;%c&quot;, curchar);*/
+				if ((curchar &gt;= 32) &amp;&amp; (curchar &lt; 127)) {
+					/*     printf(&quot;%c&quot;, curchar);*/
 					add_char_append(curchar);
 				}
 				break;
 			}
-			/*	printf(&quot;)\n&quot;);*/
+			/* printf(&quot;)\n&quot;);*/
 		}
 	}
-	gotnewdata=1;
+	gotnewdata = 1;
 }
 void init_line()
 {
 	int i;
-	for (i=0;i&lt;MAX_LINES;i++) {
+	for (i = 0;i &lt; MAX_LINES;i++) {
 		clear_line(i);
 	}
 }
 void term_addstring(char *toprint)
 {
 	char *ns;
-	for (ns=toprint;ns[0];ns++) {
+	for (ns = toprint;ns[0];ns++) {
 		term_addchar(ns[0]);
 	}  /*  better method */
 }

Modified: trunk/example/filebrowser.c
===================================================================
--- trunk/example/filebrowser.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/filebrowser.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,48 +25,48 @@
 
 
 #include &lt;s3d.h&gt;
-#include &lt;stdio.h&gt; 	 /*  printf() */
+#include &lt;stdio.h&gt;   /*  printf() */
 #include &lt;dirent.h&gt;  /*  dirent */
-#include &lt;stdlib.h&gt;	 /*  malloc() */
+#include &lt;stdlib.h&gt;  /*  malloc() */
 #include &lt;string.h&gt;  /*  strlen(), strncmp(), strrchr() */
-#include &lt;unistd.h&gt;	 /*  chdir() */
-#include &lt;math.h&gt;	 /*  sin(),cos() */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t= {
-	0,100*1000*1000
+#include &lt;unistd.h&gt;  /*  chdir() */
+#include &lt;math.h&gt;  /*  sin(),cos() */
+#include &lt;time.h&gt; /* nanosleep() */
+static struct timespec t = {
+	0, 100*1000*1000
 }; /* 100 mili seconds */
 
-#define T_DUNO		0
-#define T_LOCALDIR	1
-#define T_BACKDIR	2
-#define T_FOLDER	3
-#define T_GEOMETRY	4
-#define T_MUSIC		5
-#define	T_MOVIE		6
+#define T_DUNO  0
+#define T_LOCALDIR 1
+#define T_BACKDIR 2
+#define T_FOLDER 3
+#define T_GEOMETRY 4
+#define T_MUSIC  5
+#define T_MOVIE  6
 
-#define M_DIR		512
-#define M_NAME		256
-int folder,geometry,mp3,movie,duno,dot,dotdot;
+#define M_DIR  512
+#define M_NAME  256
+int folder, geometry, mp3, movie, duno, dot, dotdot;
 struct t_item {
 	int icon_oid, descr_oid, pie_oid;
 	char name[M_NAME];
 	int type;
 };
 struct t_item *item;
-int n_item=0;
+int n_item = 0;
 int display_dir(char *dir, int depth, int  posx, int posy, int posz)
 {
 	struct dirent **namelist;
-	int n,i;
-	int  px,py,pz;
+	int n, i;
+	int  px, py, pz;
 	char *ext;
 	char *nstr;
-	float alpha,al,radius,f;
+	float alpha, al, radius, f;
 	char ndir[M_DIR+1];
 	if (n_item) {
-		printf(&quot;freeing %d old items\n&quot;,n_item);
-		for (i=0;i&lt;n_item;i++) {
-			printf(&quot;deleting %d and %d\n&quot;,item[i].icon_oid,	item[i].descr_oid);
+		printf(&quot;freeing %d old items\n&quot;, n_item);
+		for (i = 0;i &lt; n_item;i++) {
+			printf(&quot;deleting %d and %d\n&quot;, item[i].icon_oid, item[i].descr_oid);
 			s3d_del_object(item[i].descr_oid);
 			s3d_del_object(item[i].icon_oid);
 			s3d_del_object(item[i].pie_oid);
@@ -79,115 +79,115 @@
 		perror(&quot;scandir&quot;);
 		return(-1);
 	} else {
-		item=malloc(sizeof(struct t_item)*i);
-		n_item=i;
+		item = malloc(sizeof(struct t_item) * i);
+		n_item = i;
 		while (n--) {
-			item[n].type=T_DUNO;
-			nstr=namelist[n]-&gt;d_name;
-			strncpy(item[n].name,nstr,M_NAME);
-			if ((0==strncmp(nstr,&quot;.&quot;,1)) &amp;&amp; (strlen(nstr)==1))
-				item[n].type=T_LOCALDIR;
-			else if (0==strncmp(nstr,&quot;..&quot;,strlen(nstr)&lt;2?strlen(nstr):2))
-				item[n].type=T_BACKDIR;
+			item[n].type = T_DUNO;
+			nstr = namelist[n]-&gt;d_name;
+			strncpy(item[n].name, nstr, M_NAME);
+			if ((0 == strncmp(nstr, &quot;.&quot;, 1)) &amp;&amp; (strlen(nstr) == 1))
+				item[n].type = T_LOCALDIR;
+			else if (0 == strncmp(nstr, &quot;..&quot;, strlen(nstr) &lt; 2 ? strlen(nstr) : 2))
+				item[n].type = T_BACKDIR;
 			else {
-				ext=strrchr(nstr,'.');
-				strncpy(ndir,dir,M_DIR);
-				ndir[M_DIR]=0;		/* just in case */
-				strncat(ndir,&quot;/&quot;,M_DIR-strlen(ndir));
-				strncat(ndir,namelist[n]-&gt;d_name,M_DIR-strlen(ndir));
-				/* 				printf(&quot;displaying %s\n&quot;,ndir); */
-				if ((namelist[n]-&gt;d_type==DT_DIR) ||
-				                ((namelist[n]-&gt;d_type==DT_UNKNOWN) &amp;&amp; (opendir(ndir)!=NULL)))
-					item[n].type=T_FOLDER;
+				ext = strrchr(nstr, '.');
+				strncpy(ndir, dir, M_DIR);
+				ndir[M_DIR] = 0;  /* just in case */
+				strncat(ndir, &quot;/&quot;, M_DIR - strlen(ndir));
+				strncat(ndir, namelist[n]-&gt;d_name, M_DIR - strlen(ndir));
+				/*     printf(&quot;displaying %s\n&quot;,ndir); */
+				if ((namelist[n]-&gt;d_type == DT_DIR) ||
+				                ((namelist[n]-&gt;d_type == DT_UNKNOWN) &amp;&amp; (opendir(ndir) != NULL)))
+					item[n].type = T_FOLDER;
 				else {
-					if (ext!=NULL) {
-						if (0==strncmp(ext,&quot;.3ds&quot;,strlen(ext)&lt;4?strlen(ext):4))
-							item[n].type=T_GEOMETRY;
-						else if (0==strncmp(ext,&quot;.mp3&quot;,strlen(ext)&lt;4?strlen(ext):4))
-							item[n].type=T_MUSIC;
-						else if (0==strncmp(ext,&quot;.mpg&quot;,strlen(ext)&lt;4?strlen(ext):4))
-							item[n].type=T_MOVIE;
+					if (ext != NULL) {
+						if (0 == strncmp(ext, &quot;.3ds&quot;, strlen(ext) &lt; 4 ? strlen(ext) : 4))
+							item[n].type = T_GEOMETRY;
+						else if (0 == strncmp(ext, &quot;.mp3&quot;, strlen(ext) &lt; 4 ? strlen(ext) : 4))
+							item[n].type = T_MUSIC;
+						else if (0 == strncmp(ext, &quot;.mpg&quot;, strlen(ext) &lt; 4 ? strlen(ext) : 4))
+							item[n].type = T_MOVIE;
 
 					}
 				}
 			}
 			switch (item[n].type) {
 			case T_LOCALDIR:
-				item[n].icon_oid=s3d_clone(dot);
+				item[n].icon_oid = s3d_clone(dot);
 				break;
 			case T_BACKDIR:
-				item[n].icon_oid=s3d_clone(dotdot);
+				item[n].icon_oid = s3d_clone(dotdot);
 				break;
 			case T_FOLDER:
-				item[n].icon_oid=s3d_clone(folder);
+				item[n].icon_oid = s3d_clone(folder);
 				break;
 			case T_GEOMETRY:
-				item[n].icon_oid=s3d_clone(geometry);
+				item[n].icon_oid = s3d_clone(geometry);
 				break;
 			case T_MUSIC:
-				item[n].icon_oid=s3d_clone(mp3);
+				item[n].icon_oid = s3d_clone(mp3);
 				break;
 			case T_MOVIE:
-				item[n].icon_oid=s3d_clone(movie);
+				item[n].icon_oid = s3d_clone(movie);
 				break;
 			default:
-				printf(&quot;don't know type, defaulting to duno %d...\n&quot;,duno);
-				item[n].icon_oid=s3d_clone(duno);
+				printf(&quot;don't know type, defaulting to duno %d...\n&quot;, duno);
+				item[n].icon_oid = s3d_clone(duno);
 				break;
 			}
 
-			px=posx;
-			py=posy;
-			pz=posz;
-			alpha=((360.0*n)/((float)i));
-			radius=((n_item*10)/(M_PI*4));
-			if (n_item&lt;5)
-				radius=((50)/(M_PI*4));
+			px = posx;
+			py = posy;
+			pz = posz;
+			alpha = ((360.0 * n) / ((float)i));
+			radius = ((n_item * 10) / (M_PI * 4));
+			if (n_item &lt; 5)
+				radius = ((50) / (M_PI * 4));
 			else
-				radius=((n_item*10)/(M_PI*4));
-			px=posx-sin(alpha*M_PI/180.0)*radius;
-			pz=posy;
-			pz=posz-cos(alpha*M_PI/180.0)*radius;
+				radius = ((n_item * 10) / (M_PI * 4));
+			px = posx - sin(alpha * M_PI / 180.0) * radius;
+			pz = posy;
+			pz = posz - cos(alpha * M_PI / 180.0) * radius;
 
-			item[n].pie_oid=s3d_new_object();
-			s3d_push_vertex(item[n].pie_oid,0,-2,0);
-			al=((360.0*(n-0.5))/((float)i));
+			item[n].pie_oid = s3d_new_object();
+			s3d_push_vertex(item[n].pie_oid, 0, -2, 0);
+			al = ((360.0 * (n - 0.5)) / ((float)i));
 			s3d_push_vertex(item[n].pie_oid,
-			                posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
-			al=((360.0*(n+0.5))/((float)i));
+			                posx - sin(al*M_PI / 180.0)*radius, -2, posz - cos(al*M_PI / 180.0)*radius);
+			al = ((360.0 * (n + 0.5)) / ((float)i));
 			s3d_push_vertex(item[n].pie_oid,
-			                posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
+			                posx - sin(al*M_PI / 180.0)*radius, -2, posz - cos(al*M_PI / 180.0)*radius);
 
-			f=1.0-0.05*(n%2);
+			f = 1.0 - 0.05 * (n % 2);
 			switch (item[n].type) {
 			case T_LOCALDIR:
-				s3d_push_material(item[n].pie_oid,		0,f,0,			0.5,0.5,0.5,		f,f,f);
+				s3d_push_material(item[n].pie_oid,  0, f, 0,   0.5, 0.5, 0.5,  f, f, f);
 				break;
 			case T_BACKDIR:
-				s3d_push_material(item[n].pie_oid,		0,f/2,0,		0.5,0.5,0.5,		f,f,f);
+				s3d_push_material(item[n].pie_oid,  0, f / 2, 0,  0.5, 0.5, 0.5,  f, f, f);
 				break;
 			case T_FOLDER:
-				s3d_push_material(item[n].pie_oid,		f,f,0,			0.5,0.5,0.0,		f,f,1);
+				s3d_push_material(item[n].pie_oid,  f, f, 0,   0.5, 0.5, 0.0,  f, f, 1);
 				break;
 			default:
-				s3d_push_material(item[n].pie_oid,		f,f,f,			0.5,0.5,0.5,		f,f,f);
+				s3d_push_material(item[n].pie_oid,  f, f, f,   0.5, 0.5, 0.5,  f, f, f);
 				break;
 			}
-			s3d_push_polygon(item[n].pie_oid,	0,2,1,	0);
+			s3d_push_polygon(item[n].pie_oid, 0, 2, 1, 0);
 
-			s3d_push_vertex(item[n].pie_oid,pz,-2,0);
-			s3d_translate(item[n].icon_oid,px,py,pz);
-			s3d_rotate(item[n].icon_oid,0,alpha,0);
-			s3d_flags_on(item[n].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_on(item[n].pie_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			item[n].descr_oid=s3d_draw_string(nstr,NULL);
-			s3d_link(item[n].descr_oid,item[n].icon_oid);
-			s3d_translate(item[n].descr_oid,-1,-2,0);
-			/* 			r=s3d_get_radius(p); */
-			/* 			s3d_scale(p,1.0/r,1.0/r,1.0/r); */
-			s3d_flags_on(item[n].descr_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			printf(&quot;%s [%d]\n&quot;, nstr,namelist[n]-&gt;d_type);
-			printf(&quot;string %d linked to %d\n&quot;,item[n].descr_oid,item[n].icon_oid);
+			s3d_push_vertex(item[n].pie_oid, pz, -2, 0);
+			s3d_translate(item[n].icon_oid, px, py, pz);
+			s3d_rotate(item[n].icon_oid, 0, alpha, 0);
+			s3d_flags_on(item[n].icon_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			s3d_flags_on(item[n].pie_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			item[n].descr_oid = s3d_draw_string(nstr, NULL);
+			s3d_link(item[n].descr_oid, item[n].icon_oid);
+			s3d_translate(item[n].descr_oid, -1, -2, 0);
+			/*    r=s3d_get_radius(p); */
+			/*    s3d_scale(p,1.0/r,1.0/r,1.0/r); */
+			s3d_flags_on(item[n].descr_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			printf(&quot;%s [%d]\n&quot;, nstr, namelist[n]-&gt;d_type);
+			printf(&quot;string %d linked to %d\n&quot;, item[n].descr_oid, item[n].icon_oid);
 			free(namelist[n]);
 		}
 		free(namelist);
@@ -197,31 +197,31 @@
 
 int object_click(struct s3d_evt *evt)
 {
-	int i,oid;
+	int i, oid;
 	char execstr[256];
-	oid=(int)*((unsigned long *)evt-&gt;buf);
-	printf(&quot;!!!!!!!!! clicked object %d\n&quot;,oid);
-	for (i=0;i&lt;n_item;i++) {
-		if (((oid==item[i].icon_oid) || (oid==item[i].descr_oid)) ||
-		                (oid==item[i].pie_oid) ) {
+	oid = (int) * ((unsigned long *)evt-&gt;buf);
+	printf(&quot;!!!!!!!!! clicked object %d\n&quot;, oid);
+	for (i = 0;i &lt; n_item;i++) {
+		if (((oid == item[i].icon_oid) || (oid == item[i].descr_oid)) ||
+		                (oid == item[i].pie_oid)) {
 			switch (item[i].type) {
 			case T_BACKDIR:
 			case T_FOLDER:
 			case T_LOCALDIR:
-				printf(&quot;going into %s\n&quot;,item[i].name);
+				printf(&quot;going into %s\n&quot;, item[i].name);
 				chdir(item[i].name);
-				display_dir(&quot;.&quot;,0,0,0,0);
+				display_dir(&quot;.&quot;, 0, 0, 0, 0);
 				return(0);
 				break;
 			case T_GEOMETRY:
-				printf(&quot;loading geometry %s\n&quot;,item[i].name);
-				snprintf(execstr,256,&quot;modelloader \&quot;%s\&quot;&amp;\n&quot;,item[i].name);
+				printf(&quot;loading geometry %s\n&quot;, item[i].name);
+				snprintf(execstr, 256, &quot;modelloader \&quot;%s\&quot;&amp;\n&quot;, item[i].name);
 				system(execstr);
 				return(0);
 				break;
 			case T_MOVIE:
-				printf(&quot;playing %s\n&quot;,item[i].name);
-				snprintf(execstr,256,&quot;mplayer -vo s3d \&quot;%s\&quot;&amp;\n&quot;,item[i].name);
+				printf(&quot;playing %s\n&quot;, item[i].name);
+				snprintf(execstr, 256, &quot;mplayer -vo s3d \&quot;%s\&quot;&amp;\n&quot;, item[i].name);
 				system(execstr);
 				return(0);
 				break;
@@ -234,24 +234,24 @@
 }
 void mainloop()
 {
-	nanosleep(&amp;t,NULL);
+	nanosleep(&amp;t, NULL);
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
 	int i;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;filebrowser&quot;)) {
-		i=0;
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;filebrowser&quot;)) {
+		i = 0;
 		/*  load the object files */
-		folder=s3d_import_model_file(&quot;objs/folder.3ds&quot;);
-		geometry=s3d_import_model_file(&quot;objs/geometry.3ds&quot;);
-		mp3=s3d_import_model_file(&quot;objs/notes.3ds&quot;);
-		movie=s3d_import_model_file(&quot;objs/film.3ds&quot;);
-		duno=s3d_import_model_file(&quot;objs/duno.3ds&quot;);
-		dot=s3d_import_model_file(&quot;objs/dot.3ds&quot;);
-		dotdot=s3d_import_model_file(&quot;objs/dotdot.3ds&quot;);
+		folder = s3d_import_model_file(&quot;objs/folder.3ds&quot;);
+		geometry = s3d_import_model_file(&quot;objs/geometry.3ds&quot;);
+		mp3 = s3d_import_model_file(&quot;objs/notes.3ds&quot;);
+		movie = s3d_import_model_file(&quot;objs/film.3ds&quot;);
+		duno = s3d_import_model_file(&quot;objs/duno.3ds&quot;);
+		dot = s3d_import_model_file(&quot;objs/dot.3ds&quot;);
+		dotdot = s3d_import_model_file(&quot;objs/dotdot.3ds&quot;);
 		s3d_select_font(&quot;vera&quot;);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-		display_dir(&quot;.&quot;,0,0,0,0);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, object_click);
+		display_dir(&quot;.&quot;, 0, 0, 0, 0);
 		s3d_mainloop(mainloop);
 		s3d_quit();
 	}

Modified: trunk/example/hudtest.c
===================================================================
--- trunk/example/hudtest.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/hudtest.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -32,16 +32,16 @@
 }
 int main(int argc, char **argv)
 {
-	int o,m;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;hud-test&quot;)) {
+	int o, m;
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;hud-test&quot;)) {
 		if (s3d_select_font(&quot;vera&quot;))
 			printf(&quot;font not found\n&quot;);
-		o=s3d_draw_string(&quot;hud-test&quot;,NULL);
-		m=s3d_import_model_file(&quot;objs/star.3ds&quot;);
-		s3d_translate(o,0,0,-5);
-		s3d_link(o,0);
-		s3d_flags_on(o,S3D_OF_VISIBLE);
-		s3d_flags_on(m,S3D_OF_VISIBLE);
+		o = s3d_draw_string(&quot;hud-test&quot;, NULL);
+		m = s3d_import_model_file(&quot;objs/star.3ds&quot;);
+		s3d_translate(o, 0, 0, -5);
+		s3d_link(o, 0);
+		s3d_flags_on(o, S3D_OF_VISIBLE);
+		s3d_flags_on(m, S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
 		s3d_quit();
 	}

Modified: trunk/example/katze.c
===================================================================
--- trunk/example/katze.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/katze.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,66 +25,66 @@
 
 
 #include &lt;s3d.h&gt;
-#include &lt;math.h&gt;	/* sin() */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t= {
-	0,10*1000*1000
+#include &lt;math.h&gt; /* sin() */
+#include &lt;time.h&gt; /* nanosleep() */
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 
 int a;
-int rot_point,body,legfr,legbr,legfl,legbl,tail;
+int rot_point, body, legfr, legbr, legfl, legbl, tail;
 
 void mainloop()
 {
 	float pos;
-	a=(a+2)%360;
-	pos=sin((5*a*M_PI)/180)*20;
-	s3d_rotate(legfr,0,90,180+pos);
-	s3d_rotate(legfl,0,90,180-pos);
-	s3d_rotate(legbr,0,0,180+pos);
-	s3d_rotate(legbl,0,0,180-pos);
+	a = (a + 2) % 360;
+	pos = sin((5 * a * M_PI) / 180) * 20;
+	s3d_rotate(legfr, 0, 90, 180 + pos);
+	s3d_rotate(legfl, 0, 90, 180 - pos);
+	s3d_rotate(legbr, 0, 0, 180 + pos);
+	s3d_rotate(legbl, 0, 0, 180 - pos);
 
-	s3d_rotate(tail,0,30,110+pos);
-	s3d_rotate(rot_point,0,-a,0);
-	nanosleep(&amp;t,NULL);
+	s3d_rotate(tail, 0, 30, 110 + pos);
+	s3d_rotate(rot_point, 0, -a, 0);
+	nanosleep(&amp;t, NULL);
 }
 int main(int argc, char **argv)
 {
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;running cat&quot;)) {
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;running cat&quot;)) {
 
-		rot_point=s3d_new_object();
-		body=s3d_import_model_file(&quot;objs/katze_body.3ds&quot;);
-		legfr=s3d_import_model_file(&quot;objs/katze_leg.3ds&quot;);
-		tail=s3d_import_model_file(&quot;objs/katze_tail.3ds&quot;);
-		legfl=s3d_clone(legfr);
-		legbl=s3d_clone(legfr);
-		legbr=s3d_clone(legfr);
-		s3d_translate(legfl,2.3,1.0,0.5);
-		s3d_translate(legfr,0,1.0,0.2);
-		s3d_translate(legbl,-1.2,1.0,-1.8);
-		s3d_translate(legbr,-1.2,1.0,0.0);
-		s3d_translate(tail,-1.6,1.6,-0.8);
-		s3d_translate(body,1.3,0.0,-1.3);
-		s3d_link(legfr,body);
-		s3d_link(legfl,body);
-		s3d_link(legbr,body);
-		s3d_link(legbl,body);
-		s3d_link(tail,body);
-		s3d_link(body,rot_point);
-		/*		s3d_link(oid_foot,oid_head);
-		 *		s3d_link(oid_middle,oid_head);
-		 *		s3d_translate(oid_head,0,4,0);
+		rot_point = s3d_new_object();
+		body = s3d_import_model_file(&quot;objs/katze_body.3ds&quot;);
+		legfr = s3d_import_model_file(&quot;objs/katze_leg.3ds&quot;);
+		tail = s3d_import_model_file(&quot;objs/katze_tail.3ds&quot;);
+		legfl = s3d_clone(legfr);
+		legbl = s3d_clone(legfr);
+		legbr = s3d_clone(legfr);
+		s3d_translate(legfl, 2.3, 1.0, 0.5);
+		s3d_translate(legfr, 0, 1.0, 0.2);
+		s3d_translate(legbl, -1.2, 1.0, -1.8);
+		s3d_translate(legbr, -1.2, 1.0, 0.0);
+		s3d_translate(tail, -1.6, 1.6, -0.8);
+		s3d_translate(body, 1.3, 0.0, -1.3);
+		s3d_link(legfr, body);
+		s3d_link(legfl, body);
+		s3d_link(legbr, body);
+		s3d_link(legbl, body);
+		s3d_link(tail, body);
+		s3d_link(body, rot_point);
+		/*  s3d_link(oid_foot,oid_head);
+		 *  s3d_link(oid_middle,oid_head);
+		 *  s3d_translate(oid_head,0,4,0);
 
-		 *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
-		 *		s3d_translate(oid_foot,0,-3.5,0); */
+		 *  s3d_translate(oid_middle,0,-1.5,0);  * relative to head: *
+		 *  s3d_translate(oid_foot,0,-3.5,0); */
 
 
-		s3d_flags_on(body,S3D_OF_VISIBLE);
-		s3d_flags_on(legfr,S3D_OF_VISIBLE);
-		s3d_flags_on(legfl,S3D_OF_VISIBLE);
-		s3d_flags_on(legbr,S3D_OF_VISIBLE);
-		s3d_flags_on(legbl,S3D_OF_VISIBLE);
-		s3d_flags_on(tail,S3D_OF_VISIBLE);
+		s3d_flags_on(body, S3D_OF_VISIBLE);
+		s3d_flags_on(legfr, S3D_OF_VISIBLE);
+		s3d_flags_on(legfl, S3D_OF_VISIBLE);
+		s3d_flags_on(legbr, S3D_OF_VISIBLE);
+		s3d_flags_on(legbl, S3D_OF_VISIBLE);
+		s3d_flags_on(tail, S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
 		s3d_quit();
 	}

Modified: trunk/example/linetest.c
===================================================================
--- trunk/example/linetest.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/linetest.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -35,51 +35,51 @@
 
 void mainloop()
 {
-	i=(i+1)%2;
+	i = (i + 1) % 2;
 	if (i) {
-		s3d_pep_vertex(o,1,-2,0);
-		s3d_pep_line(o,0,2,3);
+		s3d_pep_vertex(o, 1, -2, 0);
+		s3d_pep_line(o, 0, 2, 3);
 	} else {
-		s3d_pep_vertex(o,1,-1,0);
-		s3d_pep_line(o,0,1,0);
+		s3d_pep_vertex(o, 1, -1, 0);
+		s3d_pep_line(o, 0, 1, 0);
 
 	}
-	/* 	printf(&quot;now it's %s\n&quot;,time_str); */
+	/*  printf(&quot;now it's %s\n&quot;,time_str); */
 	sleep(1);
 
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	i=0;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;linetest&quot;)) {
-		o=s3d_new_object();
+	i = 0;
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;linetest&quot;)) {
+		o = s3d_new_object();
 
 		s3d_push_material(o,
-		                  1,0,0,
-		                  1,0,0,
-		                  1,0,0);
+		                  1, 0, 0,
+		                  1, 0, 0,
+		                  1, 0, 0);
 		s3d_push_material(o,
-		                  0,1,0,
-		                  0,1,0,
-		                  0,1,0);
+		                  0, 1, 0,
+		                  0, 1, 0,
+		                  0, 1, 0);
 		s3d_push_material(o,
-		                  0,1,0,
-		                  0,1,0,
-		                  0,1,0);
+		                  0, 1, 0,
+		                  0, 1, 0,
+		                  0, 1, 0);
 		s3d_push_material(o,
-		                  1,1,0,
-		                  1,1,0,
-		                  1,1,0);
-		s3d_push_vertex(o,-1,-1,0);
-		s3d_push_vertex(o,-1,1,0);
-		s3d_push_vertex(o,1,1,0);
-		s3d_push_vertex(o,1,-1,0);
-		s3d_push_line(o,2,3,1);
-		s3d_push_line(o,0,1,0);
+		                  1, 1, 0,
+		                  1, 1, 0,
+		                  1, 1, 0);
+		s3d_push_vertex(o, -1, -1, 0);
+		s3d_push_vertex(o, -1, 1, 0);
+		s3d_push_vertex(o, 1, 1, 0);
+		s3d_push_vertex(o, 1, -1, 0);
+		s3d_push_line(o, 2, 3, 1);
+		s3d_push_line(o, 0, 1, 0);
 
-		s3d_flags_on(o,S3D_OF_VISIBLE);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
+		s3d_flags_on(o, S3D_OF_VISIBLE);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, (s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_QUIT, (s3d_cb)stop);
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/example/modelloader.c
===================================================================
--- trunk/example/modelloader.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/modelloader.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,16 +26,16 @@
 
 #include &lt;s3d.h&gt;
 #include &lt;stdio.h&gt;  /* NULL */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t= {
-	0,100*1000*1000
+#include &lt;time.h&gt; /* nanosleep() */
+static struct timespec t = {
+	0, 100*1000*1000
 }; /* 100 mili seconds */
-int i,oid;
+int i, oid;
 void mainloop()
 {
-	s3d_rotate(oid,0,i,0);
-	i=(i+1)%360;
-	nanosleep(&amp;t,NULL);
+	s3d_rotate(oid, 0, i, 0);
+	i = (i + 1) % 360;
+	nanosleep(&amp;t, NULL);
 }
 int object_click(struct s3d_evt *evt)
 {
@@ -43,17 +43,17 @@
 	return(0);
 }
 
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	if (argc&lt;2) {
-		printf(&quot;usage: %s [somefile.3ds]\n&quot;,argv[0]);
+	if (argc &lt; 2) {
+		printf(&quot;usage: %s [somefile.3ds]\n&quot;, argv[0]);
 		return(-1);
 	}
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;modelloader&quot;)) {
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-		i=0;
-		if (-1!=(oid=s3d_import_model_file(argv[1]))) {
-			s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;modelloader&quot;)) {
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, object_click);
+		i = 0;
+		if (-1 != (oid = s3d_import_model_file(argv[1]))) {
+			s3d_flags_on(oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 			s3d_mainloop(mainloop);
 		} else {
 			printf(&quot;file not found ... \n&quot;);

Modified: trunk/example/nichtsnutz.c
===================================================================
--- trunk/example/nichtsnutz.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/nichtsnutz.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -30,12 +30,12 @@
 #include &lt;math.h&gt;
 #include &lt;time.h&gt;
 
-static struct timespec t= {
-	0,10*1000*1000
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 
-int object,foll;
-float al, r, rc ,alpha=0.0, Asp, Bottom, Left, angle;
+int object, foll;
+float al, r, rc , alpha = 0.0, Asp, Bottom, Left, angle;
 float CamPosition[2][3],
 TmpMove[3],
 Tmp[3],
@@ -48,37 +48,37 @@
 void mainloop()
 {
 
-	al=(alpha*M_PI/180);
+	al = (alpha * M_PI / 180);
 	r = 5.0;
 	rc = 12.0;
 
-	CatPos[0] = sin(al)*r;
+	CatPos[0] = sin(al) * r;
 	CatPos[1] = 0;
-	CatPos[2] = cos(al)*r;
+	CatPos[2] = cos(al) * r;
 	/*
 	RotCam[0][0] = sin(al) * rc;
 	RotCam[0][1] = 0.0;
 	RotCam[0][2] = cos(al) * rc;
 	*/
-	s3d_translate(object,CatPos[0] ,CatPos[1], CatPos[2]);
+	s3d_translate(object, CatPos[0] , CatPos[1], CatPos[2]);
 	s3d_rotate(object, 0, alpha, 0);
-	alpha = alpha+0.1;
-	if (alpha&gt;360.0) alpha=0.0;
+	alpha = alpha + 0.1;
+	if (alpha &gt; 360.0) alpha = 0.0;
 
 	length = s3d_vector_length(CatPos);
 
 
-	RotCam[0][0] = ( CatPos[0] * 12.0 ) / length;
-	RotCam[0][1] = ( CatPos[1] * 12.0 ) / length;
-	RotCam[0][2] = ( CatPos[2] * 12.0 ) / length;
+	RotCam[0][0] = (CatPos[0] * 12.0) / length;
+	RotCam[0][1] = (CatPos[1] * 12.0) / length;
+	RotCam[0][2] = (CatPos[2] * 12.0) / length;
 
 
-	if ( foll ) {
+	if (foll) {
 
-		CamPosition[0][0] = ((CamPosition[0][0]*4 + RotCam[0][0])/5);
-		CamPosition[0][1] = ((CamPosition[0][1]*4 + RotCam[0][1])/5);
-		CamPosition[0][2] = ((CamPosition[0][2]*4 + RotCam[0][2])/5);
-		s3d_translate(0,CamPosition[0][0],CamPosition[0][1],CamPosition[0][2]);
+		CamPosition[0][0] = ((CamPosition[0][0] * 4 + RotCam[0][0]) / 5);
+		CamPosition[0][1] = ((CamPosition[0][1] * 4 + RotCam[0][1]) / 5);
+		CamPosition[0][2] = ((CamPosition[0][2] * 4 + RotCam[0][2]) / 5);
+		s3d_translate(0, CamPosition[0][0], CamPosition[0][1], CamPosition[0][2]);
 
 		TmpMove[0] = 0.0;
 		TmpMove[1] = 0.0;
@@ -88,25 +88,25 @@
 		Tmp[1] = 0.0;
 		Tmp[2] = CamPosition[0][2] - CatPos[2];
 
-		angle = s3d_vector_angle(Tmp,TmpMove);
-		angle = (CatPos[0] &gt; 0)?(180-(180 / M_PI * angle)):(180+(180 / M_PI * angle));
-		printf(&quot;%f %f\n&quot;,angle,al);
+		angle = s3d_vector_angle(Tmp, TmpMove);
+		angle = (CatPos[0] &gt; 0) ? (180 - (180 / M_PI * angle)) : (180 + (180 / M_PI * angle));
+		printf(&quot;%f %f\n&quot;, angle, al);
 
-		CamPosition[1][1] = (CamPosition[1][1]*4 + angle)/5;
-		s3d_rotate(0,CamPosition[1][0], CamPosition[1][1], CamPosition[1][2]);
+		CamPosition[1][1] = (CamPosition[1][1] * 4 + angle) / 5;
+		s3d_rotate(0, CamPosition[1][0], CamPosition[1][1], CamPosition[1][2]);
 	}
 
 
 
-	nanosleep(&amp;t,NULL);
+	nanosleep(&amp;t, NULL);
 }
 
 int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
+	inf = (struct s3d_obj_info *)hrmz-&gt;buf;
 
-	if (inf-&gt;object==0) {
+	if (inf-&gt;object == 0) {
 		CamPosition[0][0] = inf-&gt;trans_x;
 		CamPosition[0][1] = inf-&gt;trans_y;
 		CamPosition[0][2] = inf-&gt;trans_z;
@@ -114,13 +114,13 @@
 		CamPosition[1][1] = inf-&gt;rot_y;
 		CamPosition[1][2] = inf-&gt;rot_z;
 
-		Asp=inf-&gt;scale;
-		if (Asp&gt;1.0) { /* wide screen */
-			Bottom=-1.0;
-			Left=-Asp;
+		Asp = inf-&gt;scale;
+		if (Asp &gt; 1.0) { /* wide screen */
+			Bottom = -1.0;
+			Left = -Asp;
 		} else {  /* high screen */
-			Bottom=(-1.0/Asp);
-			Left=-1.0;
+			Bottom = (-1.0 / Asp);
+			Left = -1.0;
 		}
 	}
 	return(0);
@@ -131,11 +131,11 @@
 int keypress(struct s3d_evt *event)
 {
 	int key;
-	key=*((unsigned short *)event-&gt;buf);
+	key = *((unsigned short *)event-&gt;buf);
 	switch (key) {
 	case 'f':
 		foll = foll ? 0 : 1;
-		if ( foll ) {
+		if (foll) {
 			TmpCam[0][0] = CamPosition[0][0];
 			TmpCam[0][1] = CamPosition[0][1];
 			TmpCam[0][2] = CamPosition[0][2];
@@ -152,9 +152,9 @@
 int main(int argc, char **argv)
 {
 
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;running cat&quot;)) {
-		s3d_set_callback(S3D_EVENT_KEY,keypress);
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;running cat&quot;)) {
+		s3d_set_callback(S3D_EVENT_KEY, keypress);
+		s3d_set_callback(S3D_EVENT_OBJ_INFO, object_info);
 
 		object = s3d_import_model_file(&quot;objs/katze_body.3ds&quot;);
 		s3d_flags_on(object, S3D_OF_VISIBLE);

Modified: trunk/example/ptrtest.c
===================================================================
--- trunk/example/ptrtest.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/ptrtest.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,17 +24,17 @@
 
 #include &lt;s3d.h&gt;
 #include &lt;stdio.h&gt;  /*  NULL*/
-#include &lt;time.h&gt;	/* nanosleep() */
-#include &lt;math.h&gt;	/* sin(), cos() */
+#include &lt;time.h&gt; /* nanosleep() */
+#include &lt;math.h&gt; /* sin(), cos() */
 int i;
 int o;
-float bottom=-1.0;
-float left=-1.0;
-float asp=1.0;
-float len=1.0;
-int alpha=0;
-static struct timespec t= {
-	0,10*1000*1000
+float bottom = -1.0;
+float left = -1.0;
+float asp = 1.0;
+float len = 1.0;
+int alpha = 0;
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 100 mili seconds */
 int stop(struct s3d_evt *evt)
 {
@@ -45,32 +45,32 @@
 void mainloop()
 {
 	float a;
-	alpha=(alpha+1)%360;
-	s3d_rotate(o,alpha,0,0);
-	a=(((float)alpha)*M_PI/180);
-	s3d_translate(0,sin(a)*30,0,30+cos(a)*30);
-	s3d_rotate(0,sin(a)*30,alpha,0);
-	nanosleep(&amp;t,NULL);
+	alpha = (alpha + 1) % 360;
+	s3d_rotate(o, alpha, 0, 0);
+	a = (((float)alpha) * M_PI / 180);
+	s3d_translate(0, sin(a)*30, 0, 30 + cos(a)*30);
+	s3d_rotate(0, sin(a)*30, alpha, 0);
+	nanosleep(&amp;t, NULL);
 }
 int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
-	if (inf-&gt;object==0) {
-		if (asp!=inf-&gt;scale) {
-			asp=inf-&gt;scale;
-			printf(&quot;screen aspect: %f\n&quot;,asp);
-			if (asp&gt;1.0) { /* wide screen */
-				bottom=-1.0;
-				left=-asp;
+	inf = (struct s3d_obj_info *)hrmz-&gt;buf;
+	if (inf-&gt;object == 0) {
+		if (asp != inf-&gt;scale) {
+			asp = inf-&gt;scale;
+			printf(&quot;screen aspect: %f\n&quot;, asp);
+			if (asp &gt; 1.0) { /* wide screen */
+				bottom = -1.0;
+				left = -asp;
 			} else {  /* high screen */
-				bottom=(-1.0/asp);
-				left=-1.0;
+				bottom = (-1.0 / asp);
+				left = -1.0;
 			}
 		}
 	}
-	if (inf-&gt;object==1) { /* of course, a link s3d_link(o,1 would be much easier ... */
-		s3d_translate(o,(inf-&gt;trans_x)*2.0,(inf-&gt;trans_y)*2.0,-2);
+	if (inf-&gt;object == 1) { /* of course, a link s3d_link(o,1 would be much easier ... */
+		s3d_translate(o, (inf-&gt;trans_x)*2.0, (inf-&gt;trans_y)*2.0, -2);
 	}
 	return(0);
 }
@@ -78,33 +78,33 @@
 {
 	struct s3d_but_info *inf;
 	char s[256];
-	inf=(struct s3d_but_info *)hrmz-&gt;buf;
-	snprintf(s,256,&quot;please, watch your stomach! button %d, state %d&quot;, inf-&gt;button,inf-&gt;state);
-	printf(&quot;button %d, state %d\n&quot;, inf-&gt;button,inf-&gt;state);
+	inf = (struct s3d_but_info *)hrmz-&gt;buf;
+	snprintf(s, 256, &quot;please, watch your stomach! button %d, state %d&quot;, inf-&gt;button, inf-&gt;state);
+	printf(&quot;button %d, state %d\n&quot;, inf-&gt;button, inf-&gt;state);
 	s3d_del_object(o);
-	o=s3d_draw_string(s,&amp;len);
-	s3d_translate(o,0,0,-2);
-	s3d_scale(o,0.2);
-	s3d_link(o,0);			/* link to cam */
-	/*	s3d_link(o,1);*/
-	s3d_flags_on(o,S3D_OF_VISIBLE);
+	o = s3d_draw_string(s, &amp;len);
+	s3d_translate(o, 0, 0, -2);
+	s3d_scale(o, 0.2);
+	s3d_link(o, 0);  /* link to cam */
+	/* s3d_link(o,1);*/
+	s3d_flags_on(o, S3D_OF_VISIBLE);
 	return(0);
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	i=0;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;ptr and cam test&quot;)) {
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-		s3d_set_callback(S3D_EVENT_MBUTTON,mbutton_press);
-		s3d_set_callback(S3D_EVENT_QUIT,stop);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,stop);
+	i = 0;
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;ptr and cam test&quot;)) {
+		s3d_set_callback(S3D_EVENT_OBJ_INFO, object_info);
+		s3d_set_callback(S3D_EVENT_MBUTTON, mbutton_press);
+		s3d_set_callback(S3D_EVENT_QUIT, stop);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, stop);
 		s3d_select_font(&quot;vera&quot;);
-		o=s3d_draw_string(&quot;hello&quot;,&amp;len);
-		s3d_translate(o,0,0,-2);
-		s3d_link(o,0);			/* link to cam */
-		/*		s3d_link(o,1);*/
-		s3d_scale(o,0.2);
-		s3d_flags_on(o,S3D_OF_VISIBLE);
+		o = s3d_draw_string(&quot;hello&quot;, &amp;len);
+		s3d_translate(o, 0, 0, -2);
+		s3d_link(o, 0);  /* link to cam */
+		/*  s3d_link(o,1);*/
+		s3d_scale(o, 0.2);
+		s3d_flags_on(o, S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/example/radius_test.c
===================================================================
--- trunk/example/radius_test.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/radius_test.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,51 +23,51 @@
 
 #include &lt;s3d.h&gt;
 #include &lt;stdio.h&gt;  /*  NULL */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t= {
-	0,10*1000*1000
+#include &lt;time.h&gt; /* nanosleep() */
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 
-#include &lt;math.h&gt;	/* sin(), cos() */
+#include &lt;math.h&gt; /* sin(), cos() */
 int item1, item2, item3;
-int i=0;
+int i = 0;
 void mainloop()
 {
-	float f,g,h;
-	f=sin((M_PI*(i%360))/180.0);
-	g=cos((M_PI*(i%360))/180.0);
-	h=sin((M_PI*((3*i)%360))/180.0);
+	float f, g, h;
+	f = sin((M_PI * (i % 360)) / 180.0);
+	g = cos((M_PI * (i % 360)) / 180.0);
+	h = sin((M_PI * ((3 * i) % 360)) / 180.0);
 
-	s3d_translate(item1,f*10,h*2, g*5);
-	s3d_rotate(item1,0,i%360,0);
-	/*	s3d_scale(item1,h+3,h+3,h+3);*/
+	s3d_translate(item1, f*10, h*2, g*5);
+	s3d_rotate(item1, 0, i % 360, 0);
+	/* s3d_scale(item1,h+3,h+3,h+3);*/
 
-	/*	s3d_translate(item2,f*10,0, g*5);*/
-	s3d_translate(item2,0,0,10);
-	/*	s3d_rotate(item2,i%360,0,-i%360);
-		s3d_scale(item2,2*f+5,2*f+5,2*f+5);*/
+	/* s3d_translate(item2,f*10,0, g*5);*/
+	s3d_translate(item2, 0, 0, 10);
+	/* s3d_rotate(item2,i%360,0,-i%360);
+	 s3d_scale(item2,2*f+5,2*f+5,2*f+5);*/
 
-	s3d_translate(item3,0,0,10);
-	/*	s3d_rotate(item3,((8*i)%360),0,-((8*i)%360));
-		s3d_scale(item3,2*f+5,2*f+5,2*f+5);*/
+	s3d_translate(item3, 0, 0, 10);
+	/* s3d_rotate(item3,((8*i)%360),0,-((8*i)%360));
+	 s3d_scale(item3,2*f+5,2*f+5,2*f+5);*/
 
 
 
 	i++;
-	nanosleep(&amp;t,NULL);
+	nanosleep(&amp;t, NULL);
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;radius test&quot;)) {
-		item1=s3d_import_model_file(&quot;objs/cubeyholes.3ds&quot;);
-		item2=s3d_import_model_file(&quot;objs/folder.3ds&quot;);
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;radius test&quot;)) {
+		item1 = s3d_import_model_file(&quot;objs/cubeyholes.3ds&quot;);
+		item2 = s3d_import_model_file(&quot;objs/folder.3ds&quot;);
 		s3d_select_font(&quot;vera&quot;);
-		item3=s3d_draw_string(&quot;radius test&quot;,NULL);
-		s3d_link(item2,item1);
-		s3d_link(item3,item2);
-		s3d_flags_on(item1,S3D_OF_VISIBLE);
-		s3d_flags_on(item2,S3D_OF_VISIBLE);
-		s3d_flags_on(item3,S3D_OF_VISIBLE);
+		item3 = s3d_draw_string(&quot;radius test&quot;, NULL);
+		s3d_link(item2, item1);
+		s3d_link(item3, item2);
+		s3d_flags_on(item1, S3D_OF_VISIBLE);
+		s3d_flags_on(item2, S3D_OF_VISIBLE);
+		s3d_flags_on(item3, S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/example/s3dclock.c
===================================================================
--- trunk/example/s3dclock.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/s3dclock.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,15 +24,15 @@
 
 #include &lt;s3d.h&gt;
 #include &lt;stdio.h&gt;  /*  NULL, sprintf() */
-#include &lt;time.h&gt;	 /*  nanosleep(), struct tm, time_t...  */
+#include &lt;time.h&gt;  /*  nanosleep(), struct tm, time_t...  */
 #include &lt;string.h&gt;  /*  strlen() */
-static struct timespec t= {
-	0,100*1000*1000
+static struct timespec t = {
+	0, 100*1000*1000
 }; /* 100 mili seconds */
-int big_p,lil_p,bg,sec_p;
-int str_oid=-1, o_str_oid;
+int big_p, lil_p, bg, sec_p;
+int str_oid = -1, o_str_oid;
 struct tm *mytime;
-time_t now,onow;
+time_t now, onow;
 char time_str[256];
 
 void stop(struct s3d_evt *evt)
@@ -42,42 +42,42 @@
 
 void mainloop()
 {
-	onow=now;
-	now=time(NULL);
-	if (now!=onow) {
-		o_str_oid=str_oid;
-		mytime=localtime(&amp;now);
-		s3d_rotate(lil_p,0,0,-((mytime-&gt;tm_hour%12)/12.0)*360.0);
-		s3d_rotate(big_p,0,0,-(mytime-&gt;tm_min/60.0)*360.0);
-		s3d_rotate(sec_p,0,0,-(mytime-&gt;tm_sec/60.0)*360.0);
-		sprintf(time_str,&quot;%02d:%02d:%02d&quot;,mytime-&gt;tm_hour,mytime-&gt;tm_min,mytime-&gt;tm_sec);
-		str_oid=s3d_draw_string(time_str,NULL);
-		s3d_translate(str_oid,-1,-1.3,0);
-		s3d_scale(str_oid,0.5);
-		s3d_flags_on(str_oid,S3D_OF_VISIBLE);
-		if (str_oid!=-1)
+	onow = now;
+	now = time(NULL);
+	if (now != onow) {
+		o_str_oid = str_oid;
+		mytime = localtime(&amp;now);
+		s3d_rotate(lil_p, 0, 0, -((mytime-&gt;tm_hour % 12) / 12.0)*360.0);
+		s3d_rotate(big_p, 0, 0, -(mytime-&gt;tm_min / 60.0)*360.0);
+		s3d_rotate(sec_p, 0, 0, -(mytime-&gt;tm_sec / 60.0)*360.0);
+		sprintf(time_str, &quot;%02d:%02d:%02d&quot;, mytime-&gt;tm_hour, mytime-&gt;tm_min, mytime-&gt;tm_sec);
+		str_oid = s3d_draw_string(time_str, NULL);
+		s3d_translate(str_oid, -1, -1.3, 0);
+		s3d_scale(str_oid, 0.5);
+		s3d_flags_on(str_oid, S3D_OF_VISIBLE);
+		if (str_oid != -1)
 			s3d_del_object(o_str_oid);
 	}
-	/* 	printf(&quot;now it's %s\n&quot;,time_str); */
-	nanosleep(&amp;t,NULL);
+	/*  printf(&quot;now it's %s\n&quot;,time_str); */
+	nanosleep(&amp;t, NULL);
 
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;clock&quot;)) {
-		lil_p=s3d_import_model_file(&quot;objs/lil_p.3ds&quot;);
-		big_p=s3d_import_model_file(&quot;objs/big_p.3ds&quot;);
-		sec_p=s3d_import_model_file(&quot;objs/sec_p.3ds&quot;);
-		bg=s3d_import_model_file(&quot;objs/clock_bg.3ds&quot;);
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;clock&quot;)) {
+		lil_p = s3d_import_model_file(&quot;objs/lil_p.3ds&quot;);
+		big_p = s3d_import_model_file(&quot;objs/big_p.3ds&quot;);
+		sec_p = s3d_import_model_file(&quot;objs/sec_p.3ds&quot;);
+		bg = s3d_import_model_file(&quot;objs/clock_bg.3ds&quot;);
 
-		s3d_flags_on(big_p,S3D_OF_VISIBLE);
-		s3d_flags_on(lil_p,S3D_OF_VISIBLE);
-		s3d_flags_on(sec_p,S3D_OF_VISIBLE);
-		s3d_flags_on(bg,S3D_OF_VISIBLE);
+		s3d_flags_on(big_p, S3D_OF_VISIBLE);
+		s3d_flags_on(lil_p, S3D_OF_VISIBLE);
+		s3d_flags_on(sec_p, S3D_OF_VISIBLE);
+		s3d_flags_on(bg, S3D_OF_VISIBLE);
 		s3d_select_font(&quot;vera&quot;);
 
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, (s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_QUIT, (s3d_cb)stop);
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/example/snowman.c
===================================================================
--- trunk/example/snowman.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/snowman.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,10 +22,10 @@
  */
 
 #include &lt;s3d.h&gt;
-#include &lt;math.h&gt;	/* sin() */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t= {
-	0,10*1000*1000
+#include &lt;math.h&gt; /* sin() */
+#include &lt;time.h&gt; /* nanosleep() */
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 
 int a;
@@ -36,38 +36,38 @@
 void mainloop()
 {
 	float pos;
-	a=(a+3)%360;
-	pos=sin((a*M_PI)/180)*5;
-	if (pos&lt;0) pos*=-1;
-	s3d_rotate(oid_head,0,a,0);
-	s3d_rotate(oid_middle,0,a,0);
-	s3d_rotate(oid_foot,0,a,0);
-	s3d_translate(oid_head,		0,1.5 +2.00*pos,0);
-	s3d_translate(oid_middle,	0,0   +1.25*pos,0);
-	s3d_translate(oid_foot,		0,-2  +1.00*pos,0);
-	nanosleep(&amp;t,NULL);
+	a = (a + 3) % 360;
+	pos = sin((a * M_PI) / 180) * 5;
+	if (pos &lt; 0) pos *= -1;
+	s3d_rotate(oid_head, 0, a, 0);
+	s3d_rotate(oid_middle, 0, a, 0);
+	s3d_rotate(oid_foot, 0, a, 0);
+	s3d_translate(oid_head,  0, 1.5 + 2.00*pos, 0);
+	s3d_translate(oid_middle, 0, 0   + 1.25*pos, 0);
+	s3d_translate(oid_foot,  0, -2  + 1.00*pos, 0);
+	nanosleep(&amp;t, NULL);
 }
 int main(int argc, char **argv)
 {
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;snowman&quot;)) {
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;snowman&quot;)) {
 
-		oid_head=s3d_import_model_file(&quot;objs/snow_head.3ds&quot;);
-		oid_middle=s3d_import_model_file(&quot;objs/snow_body.3ds&quot;);
-		oid_foot=s3d_import_model_file(&quot;objs/snow_foot.3ds&quot;);
+		oid_head = s3d_import_model_file(&quot;objs/snow_head.3ds&quot;);
+		oid_middle = s3d_import_model_file(&quot;objs/snow_body.3ds&quot;);
+		oid_foot = s3d_import_model_file(&quot;objs/snow_foot.3ds&quot;);
 
-		/*		s3d_link(oid_foot,oid_head);
-		 *		s3d_link(oid_middle,oid_head);
-		 *		s3d_translate(oid_head,0,4,0);
+		/*  s3d_link(oid_foot,oid_head);
+		 *  s3d_link(oid_middle,oid_head);
+		 *  s3d_translate(oid_head,0,4,0);
 
-		 *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
-		 *		s3d_translate(oid_foot,0,-3.5,0); */
+		 *  s3d_translate(oid_middle,0,-1.5,0);  * relative to head: *
+		 *  s3d_translate(oid_foot,0,-3.5,0); */
 
-		s3d_scale(oid_middle,1.25);
-		s3d_scale(oid_foot,1.5);
+		s3d_scale(oid_middle, 1.25);
+		s3d_scale(oid_foot, 1.5);
 
-		s3d_flags_on(oid_head,S3D_OF_VISIBLE);
-		s3d_flags_on(oid_middle,S3D_OF_VISIBLE);
-		s3d_flags_on(oid_foot,S3D_OF_VISIBLE);
+		s3d_flags_on(oid_head, S3D_OF_VISIBLE);
+		s3d_flags_on(oid_middle, S3D_OF_VISIBLE);
+		s3d_flags_on(oid_foot, S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
 		s3d_quit();
 	}

Modified: trunk/example/strtest.c
===================================================================
--- trunk/example/strtest.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/strtest.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -34,25 +34,25 @@
 
 void mainloop()
 {
-	/* 	printf(&quot;now it's %s\n&quot;,time_str); */
+	/*  printf(&quot;now it's %s\n&quot;,time_str); */
 	sleep(1);
 
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
 	char c[256];
 	int i;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;strtest&quot;)) {
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;strtest&quot;)) {
 		s3d_select_font(&quot;vera&quot;);
-		/*		o=s3d_draw_string(&quot;The lazy fox is bored enough to jump over everything it sees. weird, isn't it?!&quot;,NULL);  */
-		for (i=0;i&lt;256;i++)
-			c[255-i]=i;
-		o=s3d_draw_string(c,NULL);
-		/*		o=s3d_draw_string(&quot;A&quot;,NULL);*/
-		s3d_flags_on(o,S3D_OF_VISIBLE);
+		/*  o=s3d_draw_string(&quot;The lazy fox is bored enough to jump over everything it sees. weird, isn't it?!&quot;,NULL);  */
+		for (i = 0;i &lt; 256;i++)
+			c[255-i] = i;
+		o = s3d_draw_string(c, NULL);
+		/*  o=s3d_draw_string(&quot;A&quot;,NULL);*/
+		s3d_flags_on(o, S3D_OF_VISIBLE);
 
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, (s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_QUIT, (s3d_cb)stop);
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/example/texturetest.c
===================================================================
--- trunk/example/texturetest.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/texturetest.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,59 +25,59 @@
 #include &lt;s3d.h&gt;
 #include &lt;stdio.h&gt;  /*  NULL */
 #include &lt;stdlib.h&gt;  /* malloc(),free() */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t= {
-	0,10*1000*1000
+#include &lt;time.h&gt; /* nanosleep() */
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 
-int i,oid;
+int i, oid;
 void mainloop()
 {
-	i=(i+1)%360;
-	s3d_rotate(oid,0,i,0);
-	nanosleep(&amp;t,NULL);
+	i = (i + 1) % 360;
+	s3d_rotate(oid, 0, i, 0);
+	nanosleep(&amp;t, NULL);
 }
-#define MAXX	300
-#define MAXY	300
-int main (int argc, char **argv)
+#define MAXX 300
+#define MAXY 300
+int main(int argc, char **argv)
 {
-	unsigned int x,y;
+	unsigned int x, y;
 	unsigned char *data;
 
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;texturetest&quot;)) {
-		data=malloc(MAXX*MAXY*4);
-		oid=s3d_new_object();
-		s3d_push_vertex(oid,-1,-1,0);
-		s3d_push_vertex(oid, 1,-1,0);
-		s3d_push_vertex(oid, 1, 1,0);
-		s3d_push_vertex(oid,-1, 1,0);
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;texturetest&quot;)) {
+		data = malloc(MAXX * MAXY * 4);
+		oid = s3d_new_object();
+		s3d_push_vertex(oid, -1, -1, 0);
+		s3d_push_vertex(oid, 1, -1, 0);
+		s3d_push_vertex(oid, 1, 1, 0);
+		s3d_push_vertex(oid, -1, 1, 0);
 		s3d_push_material_a(oid,
-		                    0.8,	0.0,	0.0	,1.0,
-		                    1.0,	1.0,	1.0	,1.0,
-		                    0.8,	0.0,	0.0	,1.0);
-		s3d_push_polygon(oid,0,1,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0,
-		                          1.0,0.0,
-		                          1.0,1.0);
-		s3d_push_polygon(oid,0,2,3,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0,
-		                          1.0,1.0,
-		                          0.0,1.0);
-		s3d_translate(oid,0,0,5);
-		for (y=0;y&lt;MAXY;y++)
-			for (x=0;x&lt;MAXX;x++) {
-				data[(y*MAXX+x)*4+0]=(char)((x*255)/MAXX);
-				data[(y*MAXX+x)*4+1]=((x*y)/(MAXX*MAXY));
-				data[(y*MAXX+x)*4+2]=((y*255)/MAXX);
-				data[(y*MAXX+x)*4+3]=255;
+		                    0.8, 0.0, 0.0 , 1.0,
+		                    1.0, 1.0, 1.0 , 1.0,
+		                    0.8, 0.0, 0.0 , 1.0);
+		s3d_push_polygon(oid, 0, 1, 2, 0);
+		s3d_pep_polygon_tex_coord(oid, 0.0, 0.0,
+		                          1.0, 0.0,
+		                          1.0, 1.0);
+		s3d_push_polygon(oid, 0, 2, 3, 0);
+		s3d_pep_polygon_tex_coord(oid, 0.0, 0.0,
+		                          1.0, 1.0,
+		                          0.0, 1.0);
+		s3d_translate(oid, 0, 0, 5);
+		for (y = 0;y &lt; MAXY;y++)
+			for (x = 0;x &lt; MAXX;x++) {
+				data[(y*MAXX+x)*4+0] = (char)((x * 255) / MAXX);
+				data[(y*MAXX+x)*4+1] = ((x * y) / (MAXX * MAXY));
+				data[(y*MAXX+x)*4+2] = ((y * 255) / MAXX);
+				data[(y*MAXX+x)*4+3] = 255;
 			}
-		s3d_push_texture(oid,MAXX,MAXY);
-		s3d_load_texture(oid,0,0,0,MAXX,MAXY,data);
+		s3d_push_texture(oid, MAXX, MAXY);
+		s3d_load_texture(oid, 0, 0, 0, MAXX, MAXY, data);
 		/*  push data on texture 0 position (0,0) */
 		free(data);
-		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
-		s3d_flags_on(oid,S3D_OF_VISIBLE);
-		i=0;
+		s3d_pep_material_texture(oid, 0); /*  assign texture 0 to material 0 */
+		s3d_flags_on(oid, S3D_OF_VISIBLE);
+		i = 0;
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/example/widgets.c
===================================================================
--- trunk/example/widgets.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/widgets.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -27,20 +27,20 @@
 #include &lt;s3d.h&gt;
 #include &lt;s3dw.h&gt;
 #include &lt;stdio.h&gt;  /* NULL */
-#include &lt;time.h&gt;	/* nanosleep() */
-#include &lt;stdlib.h&gt;	/* free() */
+#include &lt;time.h&gt; /* nanosleep() */
+#include &lt;stdlib.h&gt; /* free() */
 #include &lt;string.h&gt; /* strlen() */
 
 s3dw_surface *surface;
 s3dw_input *input;
-static struct timespec t= {
-	0,33*1000*1000
+static struct timespec t = {
+	0, 33*1000*1000
 }; /* 33 mili seconds */
 void mainloop()
 {
 	/* keep this in your mainloop. this will do smooth animations for you ... */
 	s3dw_ani_mate();
-	nanosleep(&amp;t,NULL);
+	nanosleep(&amp;t, NULL);
 }
 /* you should always put the s3dw-handler in your own event handler,
  * if you want s3dw to react on clicks or keys ... and i'm sure you
@@ -55,7 +55,7 @@
 }
 int key(struct s3d_evt *evt)
 {
-	struct s3d_key_event *key=(struct s3d_key_event *)evt-&gt;buf;
+	struct s3d_key_event *key = (struct s3d_key_event *)evt-&gt;buf;
 	char string[8];
 	s3dw_surface *miniwin;
 	s3dw_button  *button;
@@ -64,13 +64,13 @@
 	/* okay, that's a little bit insane ... ;)
 	 * we create some little windows with the actual key pressed. */
 
-	if (key-&gt;unicode!=0) {
-		miniwin=s3dw_surface_new(&quot;Key&quot;,6,6);
-		sprintf(string,&quot;%c&quot;,key-&gt;unicode);
-		s3dw_label_new(miniwin,string,1,2);
-		button=s3dw_button_new(miniwin,&quot;OK&quot;,2,4);
+	if (key-&gt;unicode != 0) {
+		miniwin = s3dw_surface_new(&quot;Key&quot;, 6, 6);
+		sprintf(string, &quot;%c&quot;, key-&gt;unicode);
+		s3dw_label_new(miniwin, string, 1, 2);
+		button = s3dw_button_new(miniwin, &quot;OK&quot;, 2, 4);
 		/* clicking on the button will exit ... */
-		button-&gt;onclick=key_button;
+		button-&gt;onclick = key_button;
 		/* of couse, show it */
 		s3dw_show(S3DWIDGET(miniwin));
 	}
@@ -90,24 +90,24 @@
 	char *age;
 
 	/* get the input of the text ... before its destroyed, of course*/
-	age=s3dw_input_gettext(input);
+	age = s3dw_input_gettext(input);
 
 	/* delete the old surface with it subwidgets */
 	s3dw_delete(S3DWIDGET(surface));
 
 	/* and create a new one ... */
-	surface=s3dw_surface_new(&quot;Ah!&quot;,10,7);
+	surface = s3dw_surface_new(&quot;Ah!&quot;, 10, 7);
 
 	/* just cutting the string if it's too long */
-	if (strlen(age)&gt;8) age[8]=0;
+	if (strlen(age) &gt; 8) age[8] = 0;
 
 	/* assemble the string ..*/
-	sprintf(string,&quot;I see, %s!!&quot;,age);
+	sprintf(string, &quot;I see, %s!!&quot;, age);
 
-	s3dw_label_new(surface,string,1,2);
-	button=s3dw_button_new(surface,&quot;Great&quot;,4,4);
+	s3dw_label_new(surface, string, 1, 2);
+	button = s3dw_button_new(surface, &quot;Great&quot;, 4, 4);
 	/* clicking on the button will exit ... */
-	button-&gt;onclick=done_button;
+	button-&gt;onclick = done_button;
 
 	/* of couse, show it */
 	s3dw_show(S3DWIDGET(surface));
@@ -119,50 +119,50 @@
 {
 	s3dw_button *button;
 	s3dw_delete(S3DWIDGET(surface));
-	surface=s3dw_surface_new(&quot;Well ...&quot;,10,7);
-	s3dw_label_new(surface,&quot;If you don't want to tell me ...&quot;,1,2);
-	button=s3dw_button_new(surface,&quot;Bye&quot;,4,4);
+	surface = s3dw_surface_new(&quot;Well ...&quot;, 10, 7);
+	s3dw_label_new(surface, &quot;If you don't want to tell me ...&quot;, 1, 2);
+	button = s3dw_button_new(surface, &quot;Bye&quot;, 4, 4);
 	/* clicking on the button will exit ... */
 
-	button-&gt;onclick=done_button;
+	button-&gt;onclick = done_button;
 	/* of couse, show it */
 
 	s3dw_show(S3DWIDGET(surface));
 }
-char *text=&quot;okay\nn2\n3\nfooobarfooobar ...\noh no\n its too loooong\n&quot;;
-int main (int argc, char **argv)
+char *text = &quot;okay\nn2\n3\nfooobarfooobar ...\noh no\n its too loooong\n&quot;;
+int main(int argc, char **argv)
 {
 	s3dw_button *button;
 	s3dw_textbox *textbox;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;widgettest&quot;)) {
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,click);
-		s3d_set_callback(S3D_EVENT_KEY,key);
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,s3dw_object_info);
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;widgettest&quot;)) {
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, click);
+		s3d_set_callback(S3D_EVENT_KEY, key);
+		s3d_set_callback(S3D_EVENT_OBJ_INFO, s3dw_object_info);
 		/* this creates the &quot;window&quot; */
-		surface=s3dw_surface_new(&quot;Hello World&quot;,20,20);
+		surface = s3dw_surface_new(&quot;Hello World&quot;, 20, 20);
 
 		/* put a label (which is simply text) at position x=1, y=2 */
-		s3dw_label_new(surface,&quot;How old are you?&quot;,1,2);
+		s3dw_label_new(surface, &quot;How old are you?&quot;, 1, 2);
 
 		/* put an input box right below. we grab the pointer because we want to focus it (need for reference) */
-		input=s3dw_input_new(surface,8,1,4);
+		input = s3dw_input_new(surface, 8, 1, 4);
 
 		/* we want the input-field be focused on our widget */
 		s3dw_focus(S3DWIDGET(input));
 
 		/* create the okay button */
-		button=s3dw_button_new(surface,&quot;OK&quot;,1,7);
+		button = s3dw_button_new(surface, &quot;OK&quot;, 1, 7);
 
 		/* define the callback when the button is clicked. in our case, okay_button() will handle the event */
-		button-&gt;onclick=okay_button;
+		button-&gt;onclick = okay_button;
 
 		/* another button  */
-		button=s3dw_button_new(surface,&quot;Won't tell you&quot;,10,7);
+		button = s3dw_button_new(surface, &quot;Won't tell you&quot;, 10, 7);
 
 		/* we will tell him how sad we are ... */
-		button-&gt;onclick=no_button;
+		button-&gt;onclick = no_button;
 		/* create some textbox at (1,10) widh width 18 and height 8 */
-		textbox=s3dw_textbox_new(surface,text,1,10,18,8);
+		textbox = s3dw_textbox_new(surface, text, 1, 10, 18, 8);
 
 		/* this widget is focused (of course, it's our only one ... */
 		s3dw_focus(S3DWIDGET(surface));

Modified: trunk/example/wiresphere.c
===================================================================
--- trunk/example/wiresphere.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/wiresphere.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,75 +24,75 @@
 
 #include &lt;s3d.h&gt;
 #include &lt;stdio.h&gt;  /* NULL, sprintf() */
-#include &lt;time.h&gt;	/* nanosleep()  */
-#include &lt;math.h&gt;	/* M_PI, cos(), sin() */
-#include &lt;stdlib.h&gt;	/* malloc(), free() */
-static struct timespec t= {
-	0,100*1000*1000
+#include &lt;time.h&gt; /* nanosleep()  */
+#include &lt;math.h&gt; /* M_PI, cos(), sin() */
+#include &lt;stdlib.h&gt; /* malloc(), free() */
+static struct timespec t = {
+	0, 100*1000*1000
 }; /* 100 mili seconds */
 int oid;
 int r;
 int wire_sphere(int slices, int stacks)
 {
-	int x,y,i,o;
-	int num_v,num_l;
-	float *v,*n;			/* vertices, normals */
+	int x, y, i, o;
+	int num_v, num_l;
+	float *v, *n;  /* vertices, normals */
 	float alpha, beta;
-	unsigned int *l;	/* lines */
-	num_v=(stacks+1) * slices;
-	num_l=stacks * slices+ (stacks-1) * slices; /* vertical + horizontal */
-	v=malloc(sizeof(float) * 3 * num_v);
-	n=malloc(sizeof(float) * 6 * num_l);
-	l=malloc(sizeof(unsigned int) * 3 * num_l);
-	i=0;
-	for (x=0;x&lt;slices;x++) {
-		alpha=(x*360.0/slices)*M_PI/180.0;
-		for (y=0;y&lt;(stacks+1);y++) {
-			beta=((y*180/slices)-90.0)*M_PI/180.0;
-			v[i*3+0]=cos(alpha) * cos(beta);
-			v[i*3+1]=sin(beta);
-			v[i*3+2]=sin(alpha) * cos(beta);
+	unsigned int *l; /* lines */
+	num_v = (stacks + 1) * slices;
+	num_l = stacks * slices + (stacks - 1) * slices; /* vertical + horizontal */
+	v = malloc(sizeof(float) * 3 * num_v);
+	n = malloc(sizeof(float) * 6 * num_l);
+	l = malloc(sizeof(unsigned int) * 3 * num_l);
+	i = 0;
+	for (x = 0;x &lt; slices;x++) {
+		alpha = (x * 360.0 / slices) * M_PI / 180.0;
+		for (y = 0;y &lt; (stacks + 1);y++) {
+			beta = ((y * 180 / slices) - 90.0) * M_PI / 180.0;
+			v[i*3+0] = cos(alpha) * cos(beta);
+			v[i*3+1] = sin(beta);
+			v[i*3+2] = sin(alpha) * cos(beta);
 			i++;
 		}
 	}
-	i=0;
-	for (x=0;x&lt;slices;x++) {
-		for (y=0;y&lt;stacks;y++) {
-			if ((y!=0) &amp;&amp; (y!=stacks)) { /* no horizontal lines at the poles */
-				l[i*3+0]=(x*(stacks+1))+y;
-				l[i*3+1]=(((x+1)%slices)*(stacks+1))+y;
-				l[i*3+2]=0;
-				n[i*6+0]=v[ l[i*3+0]*3 + 0];
-				n[i*6+1]=v[ l[i*3+0]*3 + 1];
-				n[i*6+2]=v[ l[i*3+0]*3 + 2];
-				n[i*6+3]=v[ l[i*3+1]*3 + 0];
-				n[i*6+4]=v[ l[i*3+1]*3 + 1];
-				n[i*6+5]=v[ l[i*3+1]*3 + 2];
+	i = 0;
+	for (x = 0;x &lt; slices;x++) {
+		for (y = 0;y &lt; stacks;y++) {
+			if ((y != 0) &amp;&amp; (y != stacks)) { /* no horizontal lines at the poles */
+				l[i*3+0] = (x * (stacks + 1)) + y;
+				l[i*3+1] = (((x + 1) % slices) * (stacks + 1)) + y;
+				l[i*3+2] = 0;
+				n[i*6+0] = v[ l[i*3+0] * 3 + 0];
+				n[i*6+1] = v[ l[i*3+0] * 3 + 1];
+				n[i*6+2] = v[ l[i*3+0] * 3 + 2];
+				n[i*6+3] = v[ l[i*3+1] * 3 + 0];
+				n[i*6+4] = v[ l[i*3+1] * 3 + 1];
+				n[i*6+5] = v[ l[i*3+1] * 3 + 2];
 
 				i++;
 
 			}
 			/* vertical lines */
-			l[i*3+0]=(x*(stacks+1))+y;
-			l[i*3+1]=(x*(stacks+1))+y+1;
-			l[i*3+2]=0;
-			n[i*6+0]=v[ l[i*3+0]*3 + 0];
-			n[i*6+1]=v[ l[i*3+0]*3 + 1];
-			n[i*6+2]=v[ l[i*3+0]*3 + 2];
-			n[i*6+3]=v[ l[i*3+1]*3 + 0];
-			n[i*6+4]=v[ l[i*3+1]*3 + 1];
-			n[i*6+5]=v[ l[i*3+1]*3 + 2];
+			l[i*3+0] = (x * (stacks + 1)) + y;
+			l[i*3+1] = (x * (stacks + 1)) + y + 1;
+			l[i*3+2] = 0;
+			n[i*6+0] = v[ l[i*3+0] * 3 + 0];
+			n[i*6+1] = v[ l[i*3+0] * 3 + 1];
+			n[i*6+2] = v[ l[i*3+0] * 3 + 2];
+			n[i*6+3] = v[ l[i*3+1] * 3 + 0];
+			n[i*6+4] = v[ l[i*3+1] * 3 + 1];
+			n[i*6+5] = v[ l[i*3+1] * 3 + 2];
 			i++;
 
 		}
 	}
-	o=s3d_new_object();
-	s3d_push_material(o,0,0,1,
-	                  1,0,0,
-	                  0,1,0);
-	s3d_push_vertices(o,v,num_v);
-	s3d_push_lines(o,l,num_l);
-	s3d_load_line_normals(o,n,0,num_l);
+	o = s3d_new_object();
+	s3d_push_material(o, 0, 0, 1,
+	                  1, 0, 0,
+	                  0, 1, 0);
+	s3d_push_vertices(o, v, num_v);
+	s3d_push_lines(o, l, num_l);
+	s3d_load_line_normals(o, n, 0, num_l);
 	free(v);
 	free(n);
 	free(l);
@@ -105,19 +105,19 @@
 
 void mainloop()
 {
-	r=(r+1)%360;
-	s3d_rotate(oid,0,r,0);
-	nanosleep(&amp;t,NULL);
+	r = (r + 1) % 360;
+	s3d_rotate(oid, 0, r, 0);
+	nanosleep(&amp;t, NULL);
 
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;wiresphere&quot;)) {
-		oid=wire_sphere(30,30);
-		s3d_scale(oid,10);
-		s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
+	if (!s3d_init(&amp;argc, &amp;argv, &quot;wiresphere&quot;)) {
+		oid = wire_sphere(30, 30);
+		s3d_scale(oid, 10);
+		s3d_flags_on(oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, (s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_QUIT, (s3d_cb)stop);
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/libs3d/callback.c
===================================================================
--- trunk/libs3d/callback.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/callback.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -28,26 +28,26 @@
 /*  the s3d callback list */
 /* i know it's ugly, but it's better to have ugly code somewhere than provoke
  * race conditions in the applications code */
-s3d_cb s3d_cb_list[MAX_CB]={
-	NULL,_s3d_ignore,_s3d_ignore,_s3d_ignore, _s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	_s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	_s3d_ignore,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+s3d_cb s3d_cb_list[MAX_CB] = {
+	NULL, _s3d_ignore, _s3d_ignore, _s3d_ignore, _s3d_ignore, _s3d_ignore, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	_s3d_ignore, _s3d_ignore, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	_s3d_ignore, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
 };
 /* the ignore-handler ;) */
 static int _s3d_ignore(struct s3d_evt *S3DUNUSED(evt))
@@ -58,18 +58,18 @@
 /*  sets a callback */
 void s3d_set_callback(uint8_t event, s3d_cb func)
 {
-	s3d_cb_list[(int)event]=func;
+	s3d_cb_list[(int)event] = func;
 	s3d_process_stack();
 }
 /*  clears a callback, same as s3d_set_callback(event, (s3d_cb) NULL); */
 void s3d_clear_callback(uint8_t event)
 {
-	s3d_cb_list[(int)event]=NULL;
+	s3d_cb_list[(int)event] = NULL;
 }
 /* ignores an event ... */
 void s3d_ignore_callback(uint8_t event)
 {
-	s3d_set_callback(event,_s3d_ignore);
+	s3d_set_callback(event, _s3d_ignore);
 }
 s3d_cb s3d_get_callback(uint8_t event)
 {

Modified: trunk/libs3d/config.h
===================================================================
--- trunk/libs3d/config.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/config.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -29,6 +29,6 @@
 
 #define WITH_FONTCONFIG
 /*  our level of debug messages */
-/* #define DEBUG			LOW */ 	/*  standard debug level, should be set with compiler, e.g. -DDEBUG=LOW */
-#define SHM_MAX_IDLE	200	/* maximum wait for server timeout */
-#define	SEI_SS			200	/* seidel algorithm maximum point number */
+/* #define DEBUG   LOW */  /*  standard debug level, should be set with compiler, e.g. -DDEBUG=LOW */
+#define SHM_MAX_IDLE 200 /* maximum wait for server timeout */
+#define SEI_SS   200 /* seidel algorithm maximum point number */

Modified: trunk/libs3d/error.c
===================================================================
--- trunk/libs3d/error.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/error.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,49 +24,49 @@
 
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
-#include &lt;stdarg.h&gt;		 /*  va_list */
-#include &lt;stdio.h&gt; 		 /*  perror(),fprintf() */
-#include &lt;string.h&gt; 	 /*  sterror */
+#include &lt;stdarg.h&gt;   /*  va_list */
+#include &lt;stdio.h&gt;    /*  perror(),fprintf() */
+#include &lt;string.h&gt;   /*  sterror */
 /*  s3dprintf is only for internal use. */
 #ifdef DEBUG
 void s3dprintf(int relevance, const char *fmt, ...)
 {
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance &gt;= DEBUG ) {
-		va_start(args,fmt);
-		vsnprintf((char *)&amp;dbm,DBM_MAX,fmt,args);
+	if (relevance &gt;= DEBUG) {
+		va_start(args, fmt);
+		vsnprintf((char *)&amp;dbm, DBM_MAX, fmt, args);
 		va_end(args);
 
-		fprintf(stderr,&quot;s3dlib: %s\n&quot;,(char *)&amp;dbm);
+		fprintf(stderr, &quot;s3dlib: %s\n&quot;, (char *)&amp;dbm);
 	}
 }
-void errdn(int relevance, char *func,int en)
+void errdn(int relevance, char *func, int en)
 {
-	if (relevance &gt;= DEBUG )
-		fprintf(stderr,&quot;s3dlib error: %s: (%d) %s\n&quot;,func,en, strerror(en));
+	if (relevance &gt;= DEBUG)
+		fprintf(stderr, &quot;s3dlib error: %s: (%d) %s\n&quot;, func, en, strerror(en));
 }
 
-void errds(int relevance,char *func, const char *fmt, ...)
+void errds(int relevance, char *func, const char *fmt, ...)
 {
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance &gt;= DEBUG ) {
-		va_start(args,fmt);
-		vsnprintf((char *)&amp;dbm,DBM_MAX,fmt,args);
+	if (relevance &gt;= DEBUG) {
+		va_start(args, fmt);
+		vsnprintf((char *)&amp;dbm, DBM_MAX, fmt, args);
 		va_end(args);
 
-		fprintf(stderr,&quot;s3dlib error: %s:%s\n&quot;,func,(char *)&amp;dbm);
+		fprintf(stderr, &quot;s3dlib error: %s:%s\n&quot;, func, (char *)&amp;dbm);
 	}
 }
 #endif
-void errn(char *func,int en)
+void errn(char *func, int en)
 {
-	fprintf(stderr,&quot;s3dlib error: %s: (%d) %s\n&quot;,func,en, strerror(en));
+	fprintf(stderr, &quot;s3dlib error: %s: (%d) %s\n&quot;, func, en, strerror(en));
 }
 void errs(char *func, char *msg)
 {
-	fprintf(stderr,&quot;s3dlib error: %s: %s\n&quot;,func,msg);
+	fprintf(stderr, &quot;s3dlib error: %s: %s\n&quot;, func, msg);
 }
 
 

Modified: trunk/libs3d/event.c
===================================================================
--- trunk/libs3d/event.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/event.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,71 +25,71 @@
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
 #include &quot;proto.h&quot;
-#include &lt;stdlib.h&gt;		 /*  malloc(), free() */
+#include &lt;stdlib.h&gt;   /*  malloc(), free() */
 
 struct s3d_evt *s3d_stack;
-int cb_lock=2;	 /*  callback lock */
+int cb_lock = 2;  /*  callback lock */
 void s3d_push_event(struct s3d_evt *newevt)
 {
 	struct s3d_evt *p;
 	s3d_cb cb;
 
-	s3dprintf(VLOW,&quot;pushed event %d, cb_lock = %d&quot;,newevt-&gt;event, cb_lock);
+	s3dprintf(VLOW, &quot;pushed event %d, cb_lock = %d&quot;, newevt-&gt;event, cb_lock);
 	/*  this will always be called for S3D_EVENT_NEW_OBJECT!! */
-	if (newevt-&gt;event==S3D_EVENT_NEW_OBJECT) {
+	if (newevt-&gt;event == S3D_EVENT_NEW_OBJECT) {
 		_queue_new_object(*((unsigned int *)newevt-&gt;buf));
 	}
-	if (cb_lock==0) { /*  no recursive event-callbacks, please! */
-		if (NULL!=(cb=s3d_get_callback(newevt-&gt;event))) {
-			cb_lock++;		 /*  on our way! lock it.. */
-			cb(newevt);		 /*  .. and call it! */
+	if (cb_lock == 0) { /*  no recursive event-callbacks, please! */
+		if (NULL != (cb = s3d_get_callback(newevt-&gt;event))) {
+			cb_lock++;   /*  on our way! lock it.. */
+			cb(newevt);   /*  .. and call it! */
 			cb_lock--;
 			/* okay, no new callbacks, unlock now. */
 			free(newevt);
 			return;
 		}
 	}
-	newevt-&gt;next=NULL;
-	if (s3d_stack!=NULL) {
-		for (p=s3d_stack;p-&gt;next!=NULL;p=p-&gt;next);  /*  go to the end */
-		p-&gt;next=newevt;
+	newevt-&gt;next = NULL;
+	if (s3d_stack != NULL) {
+		for (p = s3d_stack;p-&gt;next != NULL;p = p-&gt;next);  /*  go to the end */
+		p-&gt;next = newevt;
 	} else
-		s3d_stack=newevt;
+		s3d_stack = newevt;
 }
 struct s3d_evt *s3d_pop_event() {
 	struct s3d_evt *ret;
-	if ((ret=s3d_stack)!=NULL)
-		s3d_stack=s3d_stack-&gt;next;
+	if ((ret = s3d_stack) != NULL)
+		s3d_stack = s3d_stack-&gt;next;
 	return ret;
 }
 struct s3d_evt *s3d_find_event(uint8_t event) {
 	struct s3d_evt *p;
-	p=s3d_stack;
-	while (p!=NULL) {
-		if (p-&gt;event==event)
+	p = s3d_stack;
+	while (p != NULL) {
+		if (p-&gt;event == event)
 			return(p);
-		p=p-&gt;next;
+		p = p-&gt;next;
 	}
 	return(NULL);
 }
 int s3d_delete_event(struct s3d_evt *devt)
 {
-	struct s3d_evt *previous=NULL;
-	struct s3d_evt *p=s3d_stack;
-	while (p!=NULL) {
+	struct s3d_evt *previous = NULL;
+	struct s3d_evt *p = s3d_stack;
+	while (p != NULL) {
 		/* if ((p-&gt;event==devt-&gt;event) &amp;&amp; (p-&gt;length==devt-&gt;length)) */
-		/* 	if (0==memcmp(p-&gt;buf,devt-&gt;buf)) */
-		if (p==devt) {
-			if (p-&gt;length&gt;0)
+		/*  if (0==memcmp(p-&gt;buf,devt-&gt;buf)) */
+		if (p == devt) {
+			if (p-&gt;length &gt; 0)
 				free(p-&gt;buf);
-			if (previous==NULL)
-				s3d_stack=p-&gt;next;  /*  the first element!! */
+			if (previous == NULL)
+				s3d_stack = p-&gt;next;  /*  the first element!! */
 			else
-				previous-&gt;next=p-&gt;next;  /*  unlink */
+				previous-&gt;next = p-&gt;next;  /*  unlink */
 			free(p);
 		}
-		previous=p;
-		p=p-&gt;next;
+		previous = p;
+		p = p-&gt;next;
 	}
 	return(-1);
 }
@@ -98,14 +98,14 @@
 {
 	struct s3d_evt *p;
 	s3d_cb cb;
-	if (cb_lock&gt;0) { /* can't do that now. */
+	if (cb_lock &gt; 0) { /* can't do that now. */
 
-		s3dprintf(VLOW,&quot;cb_lock = %d, processing later&quot;,cb_lock);
+		s3dprintf(VLOW, &quot;cb_lock = %d, processing later&quot;, cb_lock);
 		return;
 	}
-	s3dprintf(VLOW,&quot;processing stack ...&quot;);
-	while (NULL!=(p=s3d_pop_event())) {
-		if ((cb=s3d_get_callback(p-&gt;event))!=NULL) {
+	s3dprintf(VLOW, &quot;processing stack ...&quot;);
+	while (NULL != (p = s3d_pop_event())) {
+		if ((cb = s3d_get_callback(p-&gt;event)) != NULL) {
 			cb_lock++;
 			cb(p);
 			cb_lock--;
@@ -114,7 +114,7 @@
 
 		}
 		/*  free */
-		if (p-&gt;length&gt;0)
+		if (p-&gt;length &gt; 0)
 			free(p-&gt;buf);
 		free(p);
 	}

Modified: trunk/libs3d/fontselect.c
===================================================================
--- trunk/libs3d/fontselect.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/fontselect.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -27,7 +27,7 @@
 /*  version would be nice too, to be implemented :) */
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
-#include &lt;dirent.h&gt; 	 /*  dirent */
+#include &lt;dirent.h&gt;   /*  dirent */
 #include &lt;X11/Xlib.h&gt;  /*  Display type, XOpenDisplay(), XCloseDIsplay etc. */
 #ifdef WITH_FONTCONFIG
 #include &quot;ft2build.h&quot;
@@ -46,13 +46,13 @@
 	FcResult result;
 
 	pattern = FcNameParse((FcChar8 *)mask);
-	FcConfigSubstitute(0,pattern,FcMatchPattern);
+	FcConfigSubstitute(0, pattern, FcMatchPattern);
 	FcDefaultSubstitute(pattern);
-	s3dprintf(LOW,&quot;Looking for font %s&quot;,mask);
+	s3dprintf(LOW, &quot;Looking for font %s&quot;, mask);
 
-	if (!(match=FcFontMatch(0,pattern,&amp;result)))
+	if (!(match = FcFontMatch(0, pattern, &amp;result)))
 		return NULL;
-	if (FcPatternGetString(match,FC_FILE,0,&amp;file)!=FcResultMatch)
+	if (FcPatternGetString(match, FC_FILE, 0, &amp;file) != FcResultMatch)
 		return NULL;
 	return (char *)file;
 }
@@ -64,36 +64,36 @@
 {
 	char **flist = NULL;
 	int fnum = 0;
-	char *disp=NULL;
+	char *disp = NULL;
 	int n;
 	char *fname;
-	char *good=NULL;
+	char *good = NULL;
 	struct dirent **namelist;
 	Display *dpy;
 
 	dpy = XOpenDisplay(disp);  /*  Open display and check for success */
 	if (dpy == NULL)
-		errds(VHIGH, &quot;s3d_findfont()&quot;,&quot;unable to open display %s&quot;, XDisplayName (disp));
+		errds(VHIGH, &quot;s3d_findfont()&quot;, &quot;unable to open display %s&quot;, XDisplayName(disp));
 	else {
-		if (!(flist = XGetFontPath (dpy, &amp;fnum))) {
-			errds(VHIGH, &quot;s3d_findfont():XGetFontPath()&quot;,&quot;unable to get font path.&quot;);
+		if (!(flist = XGetFontPath(dpy, &amp;fnum))) {
+			errds(VHIGH, &quot;s3d_findfont():XGetFontPath()&quot;, &quot;unable to get font path.&quot;);
 		} else
 			while (fnum--) {
-				/*  now scan the directories	 */
+				/*  now scan the directories  */
 				n =  scandir(flist[fnum], &amp;namelist, 0, alphasort);
-				while (n--&gt;0) {
-					fname=namelist[n]-&gt;d_name;
-					if (strlen(fname)&gt;(strlen(mask)+3)) { /*  there should be enough space for the .ttf ending */
+				while (n-- &gt; 0) {
+					fname = namelist[n]-&gt;d_name;
+					if (strlen(fname) &gt; (strlen(mask) + 3)) { /*  there should be enough space for the .ttf ending */
 						/*  check for the first n characters */
-						if (0==strncasecmp(fname,mask,strlen(mask))) {
+						if (0 == strncasecmp(fname, mask, strlen(mask))) {
 							/*  name matches! now check for the end... */
-							if (0==strncasecmp(fname+(strlen(fname)-3),&quot;ttf&quot;,3)) { /*  check if it has a ttf-ending */
-								if (good==NULL)
-									good=malloc(256);
-								strncpy(good,flist[fnum],255);
-								good[256]=0; 									/* just in case */
-								strncat(good,fname,255-strlen(good));
-								if ((strlen(mask)+4)==strlen(fname)) {
+							if (0 == strncasecmp(fname + (strlen(fname) - 3), &quot;ttf&quot;, 3)) { /*  check if it has a ttf-ending */
+								if (good == NULL)
+									good = malloc(256);
+								strncpy(good, flist[fnum], 255);
+								good[256] = 0;        /* just in case */
+								strncat(good, fname, 255 - strlen(good));
+								if ((strlen(mask) + 4) == strlen(fname)) {
 									return(good);
 								}
 							}
@@ -101,7 +101,7 @@
 					}
 				}
 			}
-		XCloseDisplay (dpy);
+		XCloseDisplay(dpy);
 	}
 	return(good);
 }

Modified: trunk/libs3d/freetype.c
===================================================================
--- trunk/libs3d/freetype.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/freetype.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,10 +25,10 @@
 /*  this file should render truetype fonts as objects */
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
-#include &quot;sei_interface.h&quot;	/* sei_triangulate_polygon() */
-#include &lt;stdlib.h&gt;    		/*  malloc(), free() */
-#include &lt;math.h&gt;			/*  atan2() */
-#include &lt;string.h&gt;			/*  strncmp(), strncpy() */
+#include &quot;sei_interface.h&quot; /* sei_triangulate_polygon() */
+#include &lt;stdlib.h&gt;      /*  malloc(), free() */
+#include &lt;math.h&gt;   /*  atan2() */
+#include &lt;string.h&gt;   /*  strncmp(), strncpy() */
 #include &quot;ft2build.h&quot;
 #include FT_FREETYPE_H
 #undef __FTERRORS_H__
@@ -47,15 +47,15 @@
 #define CALLBACK
 #endif
         /*  bad global vars ... */
-        static FT_Library 	library;
-static FT_Face		face;
-static char *memory_font=NULL;		 /*  the font file in memory */
+        static FT_Library  library;
+static FT_Face  face;
+static char *memory_font = NULL; /*  the font file in memory */
 static char oldfontpath[256];
-static int memory_font_size=0;	 /*  and it's size, to reduce load times. */
-static int ft_init=0;
-static int face_init=0;
+static int memory_font_size = 0;  /*  and it's size, to reduce load times. */
+static int ft_init = 0;
+static int face_init = 0;
 
-static int v_off; 	 /*  the vertex number offset, to have the right vertex numbers for each character */
+static int v_off;   /*  the vertex number offset, to have the right vertex numbers for each character */
 static int ch;
 struct t_buf tess_buf[256];
 
@@ -64,15 +64,15 @@
 /*  initialize truetype and tess_buf ... */
 int s3d_ft_init()
 {
-	int error= FT_Init_FreeType( &amp;library);
+	int error = FT_Init_FreeType(&amp;library);
 	int i;
-	oldfontpath[0]=0;
+	oldfontpath[0] = 0;
 	if (error)
 		return (-1);
-	ft_init=1;
-	for (i=0; i&lt;256;i++) {
-		tess_buf[i].vbuf=NULL;
-		tess_buf[i].pbuf=NULL;
+	ft_init = 1;
+	for (i = 0; i &lt; 256;i++) {
+		tess_buf[i].vbuf = NULL;
+		tess_buf[i].pbuf = NULL;
 	}
 
 	return(0);
@@ -81,18 +81,18 @@
 int s3d_ft_load_font()
 {
 	FT_Error error;
-	if ((memory_font==NULL) || (memory_font_size==0)) {
-		errds(HIGH,&quot;s3d_ft_load_font()&quot;,&quot;there is no font in memory, breaking&quot;);
+	if ((memory_font == NULL) || (memory_font_size == 0)) {
+		errds(HIGH, &quot;s3d_ft_load_font()&quot;, &quot;there is no font in memory, breaking&quot;);
 		return(-1);
 	}
-	face_init=0;
-	error= FT_New_Memory_Face(library,(uint8_t *)memory_font,memory_font_size,0,&amp;face);
+	face_init = 0;
+	error = FT_New_Memory_Face(library, (uint8_t *)memory_font, memory_font_size, 0, &amp;face);
 	if (error) {
-		errds(VHIGH,&quot;s3d_ft_load_font():FT_New_Memory_Face&quot;,&quot;can't load font : (%d) %s&quot;,ft_errors[error].err_code,ft_errors[error].err_msg);
+		errds(VHIGH, &quot;s3d_ft_load_font():FT_New_Memory_Face&quot;, &quot;can't load font : (%d) %s&quot;, ft_errors[error].err_code, ft_errors[error].err_msg);
 		return(-1);
 	}
-	s3dprintf(LOW,&quot;Load Font successful ...&quot;);
-	face_init=1;
+	s3dprintf(LOW, &quot;Load Font successful ...&quot;);
+	face_init = 1;
 	return(0);
 }
 
@@ -100,13 +100,13 @@
 {
 	int i;
 
-	for (i=0; i&lt;256;i++) {
-		if (tess_buf[i].vbuf!=NULL) free(tess_buf[i].vbuf);
-		if (tess_buf[i].pbuf!=NULL) free(tess_buf[i].pbuf);
+	for (i = 0; i &lt; 256;i++) {
+		if (tess_buf[i].vbuf != NULL) free(tess_buf[i].vbuf);
+		if (tess_buf[i].pbuf != NULL) free(tess_buf[i].pbuf);
 	}
-	for (i=0; i&lt;256;i++) {
-		tess_buf[i].vbuf=NULL;
-		tess_buf[i].pbuf=NULL;
+	for (i = 0; i &lt; 256;i++) {
+		tess_buf[i].vbuf = NULL;
+		tess_buf[i].pbuf = NULL;
 	}
 	return(0);
 }
@@ -117,153 +117,153 @@
  * usage */
 int _s3d_add_tessbuf(uint16_t a)
 {
-	float norm,ar,xa,ya;
-	int i,j,k,c,n,start,outl,s,e;
-	int np,pos;
+	float norm, ar, xa, ya;
+	int i, j, k, c, n, start, outl, s, e;
+	int np, pos;
 	int triangles[SEI_SS*2][3]; /* more than enough ... */
-	int ncontours,ncon;
+	int ncontours, ncon;
 	int cntr[SEI_SS];
 	int ncntr[SEI_SS];
-	int csta[SEI_SS],ncsta[SEI_SS];
+	int csta[SEI_SS], ncsta[SEI_SS];
 	int perm[SEI_SS];
 	float area[SEI_SS];
 	double vertices[SEI_SS+1][2];
 	double nvertices[SEI_SS+1][2];
 	FT_Error error;
 
-	error= FT_Load_Char(face,a, FT_LOAD_NO_BITMAP|FT_LOAD_NO_SCALE);
+	error = FT_Load_Char(face, a, FT_LOAD_NO_BITMAP | FT_LOAD_NO_SCALE);
 	if (error) {
 
-		errds(VHIGH,&quot;_s3d_add_tessbuf():FT_Load_Char()&quot;,&quot;can't load character %d : (%d) %s&quot;,a,ft_errors[error].err_code,ft_errors[error].err_msg);
+		errds(VHIGH, &quot;_s3d_add_tessbuf():FT_Load_Char()&quot;, &quot;can't load character %d : (%d) %s&quot;, a, ft_errors[error].err_code, ft_errors[error].err_msg);
 		return(-1);
 	}
-	s3dprintf(VLOW,&quot;[T]riangulating character %c&quot;,a);
-	norm=1.0/face-&gt;glyph-&gt;metrics.vertAdvance;
-	ch=a;
-	v_off=0;
-	if ((face-&gt;glyph-&gt;outline.n_points&gt;0) &amp;&amp; (face-&gt;glyph-&gt;outline.n_points&lt;SEI_SS)) {
-		tess_buf[a].vn=face-&gt;glyph-&gt;outline.n_points;
-		tess_buf[a].vbuf=malloc(sizeof(float)*face-&gt;glyph-&gt;outline.n_points*3);
+	s3dprintf(VLOW, &quot;[T]riangulating character %c&quot;, a);
+	norm = 1.0 / face-&gt;glyph-&gt;metrics.vertAdvance;
+	ch = a;
+	v_off = 0;
+	if ((face-&gt;glyph-&gt;outline.n_points &gt; 0) &amp;&amp; (face-&gt;glyph-&gt;outline.n_points &lt; SEI_SS)) {
+		tess_buf[a].vn = face-&gt;glyph-&gt;outline.n_points;
+		tess_buf[a].vbuf = malloc(sizeof(float) * face-&gt;glyph-&gt;outline.n_points * 3);
 
-		j=0;
-		ncontours=face-&gt;glyph-&gt;outline.n_contours;
-		for (c=0;c&lt;ncontours;c++) {
-			start=j; 	/* first point */
-			i=0;
-			ncon=face-&gt;glyph-&gt;outline.contours[c]; /* position of the end of ths contour */
-			cntr[c]=ncon-j+1;					   /* how many points do we have here? */
-			csta[c]=j+1;
-			ar=0.0f;
-			while (j&lt;(ncon+1)) {
+		j = 0;
+		ncontours = face-&gt;glyph-&gt;outline.n_contours;
+		for (c = 0;c &lt; ncontours;c++) {
+			start = j;  /* first point */
+			i = 0;
+			ncon = face-&gt;glyph-&gt;outline.contours[c]; /* position of the end of ths contour */
+			cntr[c] = ncon - j + 1;  /* how many points do we have here? */
+			csta[c] = j + 1;
+			ar = 0.0f;
+			while (j &lt; (ncon + 1)) {
 				/* vertices have reverse order in seidels algorithm, outer contours go anticlockwise, inner contours clockwise */
 				/* calculate the area */
-				k=((j+2-csta[c])%(cntr[c]))+csta[c]-1;
-				ar-=face-&gt;glyph-&gt;outline.points[j].x * face-&gt;glyph-&gt;outline.points[k].y;
-				ar+=face-&gt;glyph-&gt;outline.points[k].x * face-&gt;glyph-&gt;outline.points[j].y;
+				k = ((j + 2 - csta[c]) % (cntr[c])) + csta[c] - 1;
+				ar -= face-&gt;glyph-&gt;outline.points[j].x * face-&gt;glyph-&gt;outline.points[k].y;
+				ar += face-&gt;glyph-&gt;outline.points[k].x * face-&gt;glyph-&gt;outline.points[j].y;
 
-				pos=ncon-i;
-				vertices[pos+1][0]=face-&gt;glyph-&gt;outline.points[j].x*norm;
-				vertices[pos+1][1]=face-&gt;glyph-&gt;outline.points[j].y*norm;
+				pos = ncon - i;
+				vertices[pos+1][0] = face-&gt;glyph-&gt;outline.points[j].x * norm;
+				vertices[pos+1][1] = face-&gt;glyph-&gt;outline.points[j].y * norm;
 				j++;
 				i++;
 			}
-			ar=0.5f*norm*norm*ar;
-			s3dprintf(VLOW,&quot;contour %d has area of %3.3f, cntr is %d, contour starts at %d, ncon %d&quot;,c,ar,cntr[c], csta[c], ncon);
-			area[c]=ar; /* save the area */
+			ar = 0.5f * norm * norm * ar;
+			s3dprintf(VLOW, &quot;contour %d has area of %3.3f, cntr is %d, contour starts at %d, ncon %d&quot;, c, ar, cntr[c], csta[c], ncon);
+			area[c] = ar; /* save the area */
 		}
 		/* now as we have the areas and sizes of the contours, we need to order our contours so that
 		 * the outlines and their holes are grouped together */
-		n=ncontours;
-		for (i=0;i&lt;n;i++)
-			perm[i]=i; /* initialise permutation */
-		while (n!=0) {
-			outl=-1;
+		n = ncontours;
+		for (i = 0;i &lt; n;i++)
+			perm[i] = i; /* initialise permutation */
+		while (n != 0) {
+			outl = -1;
 			/* find an outline */
-			for (i=0;i&lt;n;i++)
-				if (area[perm[i]]&gt;0) {
-					outl=i; /* found. that was easy ;) */
+			for (i = 0;i &lt; n;i++)
+				if (area[perm[i]] &gt; 0) {
+					outl = i; /* found. that was easy ;) */
 					break;
 				}
-			if (outl==-1) {
-				s3dprintf(HIGH,&quot;hole without outline found, exiting ... %c&quot;,a);
+			if (outl == -1) {
+				s3dprintf(HIGH, &quot;hole without outline found, exiting ... %c&quot;, a);
 				return(-1);
 			}
-			for (i=0;i&lt;n;i++) {
-				if (area[perm[i]]&lt;0) {
+			for (i = 0;i &lt; n;i++) {
+				if (area[perm[i]] &lt; 0) {
 					/* test for a hole inside by taking one (the first) point of the hole and doing the test */
-					xa=vertices[csta[perm[i]]][0];
-					ya=vertices[csta[perm[i]]][1];
-					s=csta[perm[outl]];							/* start point of outline */
-					e=(csta[perm[outl]]+cntr[perm[outl]])-1;		/* end point */
-					ar=0;
-					for (j=s;j&lt;e;j++) { /* for all points of the outline, sum: */
-						ar+=atan2((vertices[j+1][1]-ya)*(vertices[j][0]-xa)-(vertices[j+1][0]-xa)*(vertices[j][1]-ya),
-						          (vertices[j+1][0]-xa)*(vertices[j][0]-xa)+(vertices[j+1][1]-ya)*(vertices[j][1]-ya));
+					xa = vertices[csta[perm[i]]][0];
+					ya = vertices[csta[perm[i]]][1];
+					s = csta[perm[outl]];     /* start point of outline */
+					e = (csta[perm[outl]] + cntr[perm[outl]]) - 1;  /* end point */
+					ar = 0;
+					for (j = s;j &lt; e;j++) { /* for all points of the outline, sum: */
+						ar += atan2((vertices[j+1][1] - ya) * (vertices[j][0] - xa) - (vertices[j+1][0] - xa) * (vertices[j][1] - ya),
+						            (vertices[j+1][0] - xa) * (vertices[j][0] - xa) + (vertices[j+1][1] - ya) * (vertices[j][1] - ya));
 					}
 					/* dont forget the start/end-point connection*/
-					ar+=atan2((vertices[s][1]-ya)*(vertices[e][0]-xa)-(vertices[s][0]-xa)*(vertices[e][1]-ya),
-					          (vertices[s][0]-xa)*(vertices[e][0]-xa)+(vertices[s][1]-ya)*(vertices[e][1]-ya));
-					if (fabsf(ar)&gt;1)						/* if ar = 0.0, it's outside, elseway it's a multiple of pi. this check should be
-															 * very generous to roundoff errors */
+					ar += atan2((vertices[s][1] - ya) * (vertices[e][0] - xa) - (vertices[s][0] - xa) * (vertices[e][1] - ya),
+					            (vertices[s][0] - xa) * (vertices[e][0] - xa) + (vertices[s][1] - ya) * (vertices[e][1] - ya));
+					if (fabsf(ar) &gt; 1)      /* if ar = 0.0, it's outside, elseway it's a multiple of pi. this check should be
+                * very generous to roundoff errors */
 					{
-						s3dprintf(VLOW,&quot;hole %d (%d) in %d (%d): interior angle sum %f (n=%d)&quot;,i,perm[i],outl, perm[outl],ar,n);
-						j=perm[n-1];	/* swap our hole to the end */
-						perm[n-1]=perm[i];
-						perm[i]=j;
-						if (outl==n-1)
-							outl=i;		/* outline got swapped */
-						n--;			/* we don't care for the hole at the end anymore as it's found */
-						i--;			/* check again for the just-swapped value in the next
-										 * loop iteration */
+						s3dprintf(VLOW, &quot;hole %d (%d) in %d (%d): interior angle sum %f (n=%d)&quot;, i, perm[i], outl, perm[outl], ar, n);
+						j = perm[n-1]; /* swap our hole to the end */
+						perm[n-1] = perm[i];
+						perm[i] = j;
+						if (outl == n - 1)
+							outl = i;  /* outline got swapped */
+						n--;   /* we don't care for the hole at the end anymore as it's found */
+						i--;   /* check again for the just-swapped value in the next
+           * loop iteration */
 					}
 				}
 			}
 			/* all the holes should be behind n-i, if so, so we swap our outline to the end now */
-			j=perm[n-1];	/* swap our hole to the end */
-			perm[n-1]=perm[outl];
-			perm[outl]=j;
-			n--;			/* we don't care for the hole at the end anymore as it's found */
+			j = perm[n-1]; /* swap our hole to the end */
+			perm[n-1] = perm[outl];
+			perm[outl] = j;
+			n--;   /* we don't care for the hole at the end anymore as it's found */
 		}
 		/* finished the permutation, now apply the new order .... */
-		n=1;
-		for (c=0;c&lt;ncontours;c++) {
-			ncsta[c]=n-1;
-			for (j=csta[perm[c]];j&lt;(csta[perm[c]]+cntr[perm[c]]);j++) {
-				nvertices[n][0]=vertices[j][0];
-				nvertices[n][1]=vertices[j][1];
-				tess_buf[a].vbuf[(n-1)*3]	=nvertices[n][0];
-				tess_buf[a].vbuf[(n-1)*3+1]	=nvertices[n][1];
-				tess_buf[a].vbuf[(n-1)*3+2]	=0;
+		n = 1;
+		for (c = 0;c &lt; ncontours;c++) {
+			ncsta[c] = n - 1;
+			for (j = csta[perm[c]];j &lt; (csta[perm[c]] + cntr[perm[c]]);j++) {
+				nvertices[n][0] = vertices[j][0];
+				nvertices[n][1] = vertices[j][1];
+				tess_buf[a].vbuf[(n-1)*3] = nvertices[n][0];
+				tess_buf[a].vbuf[(n-1)*3+1] = nvertices[n][1];
+				tess_buf[a].vbuf[(n-1)*3+2] = 0;
 				n++;
 			}
-			ncntr[c]=cntr[perm[c]];
+			ncntr[c] = cntr[perm[c]];
 		}
-		n=0;
-		tess_buf[a].pbuf=malloc(sizeof(uint32_t)*4*(face-&gt;glyph-&gt;outline.n_points+2*face-&gt;glyph-&gt;outline.n_contours));
-		k=0;
-		for (c=ncontours-1;c&gt;=0;c--) {
-			n++;				 /* count out and inlines ... */
-			if (area[perm[c]]&gt;0) { /* outline? start! */
-				s3dprintf(VLOW,&quot;[T]riangulation from outline %d (%d contours, area = %f)&quot;,perm[c],n,area[perm[c]]);
-				np=sei_triangulate_polygon(n, ncntr+c, nvertices+(ncsta[c]), triangles);
-				for (i=0;i&lt;np;i++) {
-					tess_buf[a].pbuf[k*4]=  triangles[i][0]+ncsta[c]-1;
-					tess_buf[a].pbuf[k*4+1]=triangles[i][2]+ncsta[c]-1;
-					tess_buf[a].pbuf[k*4+2]=triangles[i][1]+ncsta[c]-1;
-					tess_buf[a].pbuf[k*4+3]=0;
+		n = 0;
+		tess_buf[a].pbuf = malloc(sizeof(uint32_t) * 4 * (face-&gt;glyph-&gt;outline.n_points + 2 * face-&gt;glyph-&gt;outline.n_contours));
+		k = 0;
+		for (c = ncontours - 1;c &gt;= 0;c--) {
+			n++;     /* count out and inlines ... */
+			if (area[perm[c]] &gt; 0) { /* outline? start! */
+				s3dprintf(VLOW, &quot;[T]riangulation from outline %d (%d contours, area = %f)&quot;, perm[c], n, area[perm[c]]);
+				np = sei_triangulate_polygon(n, ncntr + c, nvertices + (ncsta[c]), triangles);
+				for (i = 0;i &lt; np;i++) {
+					tess_buf[a].pbuf[k*4] =  triangles[i][0] + ncsta[c] - 1;
+					tess_buf[a].pbuf[k*4+1] = triangles[i][2] + ncsta[c] - 1;
+					tess_buf[a].pbuf[k*4+2] = triangles[i][1] + ncsta[c] - 1;
+					tess_buf[a].pbuf[k*4+3] = 0;
 					k++;
 				}
-				n=0;
+				n = 0;
 			}
 		}
-		tess_buf[a].pn=k;
+		tess_buf[a].pn = k;
 	}
-	tess_buf[a].xoff=1.0*face-&gt;glyph-&gt;metrics.horiAdvance*norm;
+	tess_buf[a].xoff = 1.0 * face-&gt;glyph-&gt;metrics.horiAdvance * norm;
 	return(0);
 }
 
 /* draws one charachter a */
-int _s3d_draw_tessbuf(int oid,uint16_t a,int *voff, float *xoff)
+int _s3d_draw_tessbuf(int oid, uint16_t a, int *voff, float *xoff)
 {
 	float *vbuf;
 	uint32_t *pbuf;
@@ -273,77 +273,77 @@
 	/* only draw if it has some information in it */
 	if ((tess_buf[a].pn != 0) &amp;&amp; (tess_buf[a].vn != 0)) {
 
-		vbuf=malloc(sizeof(float)*3*tess_buf[a].vn);
-		pbuf=malloc(sizeof(uint32_t)*4*tess_buf[a].pn);
-		memcpy(vbuf,tess_buf[a].vbuf,sizeof(float)*3*tess_buf[a].vn);
-		memcpy(pbuf,tess_buf[a].pbuf,sizeof(uint32_t)*4*tess_buf[a].pn);
+		vbuf = malloc(sizeof(float) * 3 * tess_buf[a].vn);
+		pbuf = malloc(sizeof(uint32_t) * 4 * tess_buf[a].pn);
+		memcpy(vbuf, tess_buf[a].vbuf, sizeof(float)*3*tess_buf[a].vn);
+		memcpy(pbuf, tess_buf[a].pbuf, sizeof(uint32_t)*4*tess_buf[a].pn);
 		/*  prepare the buffs ... */
-		/* 	s3dprintf(LOW,&quot;drawing [%c] (%d vertices, %d polys&quot;,a,tess_buf[a].vn,tess_buf[a].pn); */
-		for (i=0;i&lt;tess_buf[a].vn;i++) {
-			vbuf[i*3]+=*xoff;
-			/*		s3dprintf(LOW,&quot;vertex [%c:%d] %f %f %f&quot;,a,i,
-									vbuf[i*3],
-									vbuf[i*3+1],
-									vbuf[i*3+2]);*/
+		/*  s3dprintf(LOW,&quot;drawing [%c] (%d vertices, %d polys&quot;,a,tess_buf[a].vn,tess_buf[a].pn); */
+		for (i = 0;i &lt; tess_buf[a].vn;i++) {
+			vbuf[i*3] += *xoff;
+			/*  s3dprintf(LOW,&quot;vertex [%c:%d] %f %f %f&quot;,a,i,
+			      vbuf[i*3],
+			      vbuf[i*3+1],
+			      vbuf[i*3+2]);*/
 		}
-		for (i=0;i&lt;tess_buf[a].pn;i++) {
-			pbuf[i*4]+=*voff;
-			pbuf[i*4+1]+=*voff;
-			pbuf[i*4+2]+=*voff;
-			/*		s3dprintf(LOW,&quot;poly [%c:%d] %d %d %d | %d (voff %d)&quot;,a,i,
-									pbuf[i*4],
-									pbuf[i*4+1],
-									pbuf[i*4+2],
-									pbuf[i*4+3],*voff);*/
+		for (i = 0;i &lt; tess_buf[a].pn;i++) {
+			pbuf[i*4] += *voff;
+			pbuf[i*4+1] += *voff;
+			pbuf[i*4+2] += *voff;
+			/*  s3dprintf(LOW,&quot;poly [%c:%d] %d %d %d | %d (voff %d)&quot;,a,i,
+			      pbuf[i*4],
+			      pbuf[i*4+1],
+			      pbuf[i*4+2],
+			      pbuf[i*4+3],*voff);*/
 		}
-		s3dprintf(VLOW,&quot;commiting %d vertices, %d polygons&quot;,tess_buf[a].vn,tess_buf[a].pn);
-		s3d_push_vertices(oid,vbuf,tess_buf[a].vn);
-		s3d_push_polygons(oid,pbuf,tess_buf[a].pn);
-		*voff+=tess_buf[a].vn;
+		s3dprintf(VLOW, &quot;commiting %d vertices, %d polygons&quot;, tess_buf[a].vn, tess_buf[a].pn);
+		s3d_push_vertices(oid, vbuf, tess_buf[a].vn);
+		s3d_push_polygons(oid, pbuf, tess_buf[a].pn);
+		*voff += tess_buf[a].vn;
 		free(vbuf);
 		free(pbuf);
 	}
-	*xoff+=tess_buf[a].xoff;  /*  xoffset */
+	*xoff += tess_buf[a].xoff;  /*  xoffset */
 	return(0);
 }
 int s3d_select_font(char *path)
 {
-	char		 	*oldfont=memory_font;
-	int 			 oldsize=memory_font_size;
+	char    *oldfont = memory_font;
+	int     oldsize = memory_font_size;
 	char *c;
 	char **p;
 	if (!ft_init)
 		if (s3d_ft_init()) {
-			errds(VHIGH,&quot;s3d_select_font()&quot;,&quot;error in initializtation (ft_init())&quot;);
+			errds(VHIGH, &quot;s3d_select_font()&quot;, &quot;error in initializtation (ft_init())&quot;);
 			return(-1);
 		}
-	if (strncmp(oldfontpath,path,256)==0) {
-		s3dprintf(VLOW,&quot;font already %s loaded.&quot;, path);
+	if (strncmp(oldfontpath, path, 256) == 0) {
+		s3dprintf(VLOW, &quot;font already %s loaded.&quot;, path);
 		return(-1);
 	}
 	/*  yse (system-specific?!) font grabber */
-	if (((c=s3d_findfont(path))!=NULL)) {
-		s3dprintf(LOW,&quot;Loading Font %s ... &quot;,c);
+	if (((c = s3d_findfont(path)) != NULL)) {
+		s3dprintf(LOW, &quot;Loading Font %s ... &quot;, c);
 		_s3d_clear_tessbuf(); /* free and clear the tessbuf */
-		p=&amp;memory_font;
-		if ((memory_font_size=s3d_open_file(c,p))&gt;0) {
-			if (!s3d_ft_load_font()) {	/* success */
-				if (oldfont!=NULL)				free(oldfont);
-				strncpy(oldfontpath,path,256);
+		p = &amp;memory_font;
+		if ((memory_font_size = s3d_open_file(c, p)) &gt; 0) {
+			if (!s3d_ft_load_font()) { /* success */
+				if (oldfont != NULL)    free(oldfont);
+				strncpy(oldfontpath, path, 256);
 				return(0);
 			} else {
-				memory_font=oldfont;
-				memory_font_size=oldsize;
+				memory_font = oldfont;
+				memory_font_size = oldsize;
 			}
 		} else {
-			errds(VHIGH,&quot;s3d_select_font()&quot;,&quot;Could not open fontfile %s&quot;,c);
+			errds(VHIGH, &quot;s3d_select_font()&quot;, &quot;Could not open fontfile %s&quot;, c);
 		}
 	}
 	return(-1);
 }
 
 /*  draws a simple string. */
-int s3d_draw_string( char *str,float *xlen)
+int s3d_draw_string(char *str, float *xlen)
 {
 	int i;
 	float xoff;
@@ -352,27 +352,27 @@
 	uint32_t f_oid;
 	if (!ft_init)
 		if (s3d_ft_init()) {
-			errds(VHIGH,&quot;s3d_draw_string()&quot;,&quot;error in initializtation (ft_init())&quot;);
+			errds(VHIGH, &quot;s3d_draw_string()&quot;, &quot;error in initializtation (ft_init())&quot;);
 			return(-1);
 		}
 	if (!face_init) {
-		errds(VHIGH,&quot;s3d_draw_string()&quot;,&quot;no font to draw with&quot;);
+		errds(VHIGH, &quot;s3d_draw_string()&quot;, &quot;no font to draw with&quot;);
 		return(-1);
 	}
-	f_oid=s3d_new_object();
+	f_oid = s3d_new_object();
 	/*  standard material */
-	s3d_push_material(f_oid,1.0,1.0,1.0,		1.0,1.0,1.0,	1.0,1.0,1.0);
-	xoff=0;
-	voff=0;
-	len=strlen(str);
-	for (i=0;i&lt;len; i++)
-		_s3d_draw_tessbuf(f_oid,(uint8_t )str[i],&amp;voff,&amp;xoff);
+	s3d_push_material(f_oid, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0, 1.0, 1.0);
+	xoff = 0;
+	voff = 0;
+	len = strlen(str);
+	for (i = 0;i &lt; len; i++)
+		_s3d_draw_tessbuf(f_oid, (uint8_t)str[i], &amp;voff, &amp;xoff);
 	/*  s3d_ft_quit(); */
-	if (xlen!=NULL) *xlen=xoff;
+	if (xlen != NULL) *xlen = xoff;
 	return(f_oid);
 }
 /* get the string length before actually drawing it. */
-float s3d_strlen( char *str)
+float s3d_strlen(char *str)
 {
 	int i;
 	float xoff;
@@ -381,22 +381,22 @@
 	uint16_t a;
 	if (!ft_init)
 		if (s3d_ft_init()) {
-			errds(VHIGH,&quot;s3d_draw_string()&quot;,&quot;error in initializtation (ft_init())&quot;);
+			errds(VHIGH, &quot;s3d_draw_string()&quot;, &quot;error in initializtation (ft_init())&quot;);
 			return(0.0);
 		}
 	if (!face_init) {
-		errds(VHIGH,&quot;s3d_draw_string()&quot;,&quot;no font to draw with&quot;);
+		errds(VHIGH, &quot;s3d_draw_string()&quot;, &quot;no font to draw with&quot;);
 		return(0.0);
 	}
 	/*  standard material */
-	xoff=0;
-	voff=0;
-	len=strlen(str);
-	for (i=0;i&lt;len; i++) {
-		a=(uint8_t )str[i];
+	xoff = 0;
+	voff = 0;
+	len = strlen(str);
+	for (i = 0;i &lt; len; i++) {
+		a = (uint8_t)str[i];
 		if (!(tess_buf[a].vbuf &amp;&amp; tess_buf[a].pbuf))
 			_s3d_add_tessbuf(a);
-		xoff+=tess_buf[a].xoff;  /*  xoffset */
+		xoff += tess_buf[a].xoff;  /*  xoffset */
 	}
 	return(xoff);
 
@@ -405,7 +405,7 @@
 {
 	_s3d_clear_tessbuf();
 	FT_Done_FreeType(library);
-	ft_init=0;
+	ft_init = 0;
 	return(0);
 }
 

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/io.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,40 +25,40 @@
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
 #include &quot;proto.h&quot;
-#include &lt;stdio.h&gt;  	 /*  fopen(),fclose(),fileno() */
-#include &lt;string.h&gt; 	 /*  strncpy(),strncmp(),memcpy() */
-#include &lt;stdlib.h&gt;		 /*  atoi(),malloc(),free() */
-#include &lt;sys/stat.h&gt;	 /*  fstat() */
-#include &lt;unistd.h&gt;		 /*  getpid(), fstat() */
-#include &lt;errno.h&gt;		 /*  errno */
+#include &lt;stdio.h&gt;    /*  fopen(),fclose(),fileno() */
+#include &lt;string.h&gt;   /*  strncpy(),strncmp(),memcpy() */
+#include &lt;stdlib.h&gt;   /*  atoi(),malloc(),free() */
+#include &lt;sys/stat.h&gt;  /*  fstat() */
+#include &lt;unistd.h&gt;   /*  getpid(), fstat() */
+#include &lt;errno.h&gt;   /*  errno */
 #include &lt;sys/socket.h&gt;  /*  socket() */
-#include &lt;getopt.h&gt;		 /*  getopt() */
+#include &lt;getopt.h&gt;   /*  getopt() */
 
 #ifndef _POSIX_C_SOURCE
-#define _POSIX_C_SOURCE 199309		/* we want struct timespec to be defined */
+#define _POSIX_C_SOURCE 199309  /* we want struct timespec to be defined */
 #endif
 #ifndef __USE_POSIX199309
 #define __USE_POSIX199309 1
 #endif
-#include &lt;time.h&gt;		 /*  nanosleep() */
+#include &lt;time.h&gt;   /*  nanosleep() */
 
 #ifdef SIGS
-#include &lt;fcntl.h&gt;		 /*  fcntl() */
-#define __USE_BSD	1		/* we want sig_t to be defined */
-#include &lt;signal.h&gt;		 /*  signal.h, SIG_PIPE */
+#include &lt;fcntl.h&gt;   /*  fcntl() */
+#define __USE_BSD 1  /* we want sig_t to be defined */
+#include &lt;signal.h&gt;   /*  signal.h, SIG_PIPE */
 #endif
 #include &lt;netinet/in.h&gt;  /*  htons(),htonl() */
 #ifndef WIN32
-#include &lt;netdb.h&gt;		 /*  gethostbyname()  */
+#include &lt;netdb.h&gt;   /*  gethostbyname()  */
 #endif
 
-static char				*url=NULL;
-extern int 				con_type;
-extern int 				cb_lock;
+static char    *url = NULL;
+extern int     con_type;
+extern int     cb_lock;
 /*  this file is the client-lib-implementation which holds the function to connect and control the server. */
 #ifdef SIGS
-int _s3d_sigio=0;
-int _s3d_ready=0;
+int _s3d_sigio = 0;
+int _s3d_ready = 0;
 void sigint_handler(int S3DUNUSED(sig), int S3DUNUSED(code))  /*  ... ? */
 {
 	/*s3d_quit();*/ /* TODO: sometimes no clean quit ?!*/
@@ -75,27 +75,27 @@
 
 static int parse_args(int *argc, char ***argv)
 {
-	char				 c;
-	int					 lopt_idx;
+	char     c;
+	int      lopt_idx;
 	struct option long_options[] = {
-		{&quot;s3d-url&quot;,1,0,0
-		}, {&quot;help&quot;,0,0,'h'}, {&quot;s3d-help&quot;,0,0,'h'}, {0,0,0,0}
+		{&quot;s3d-url&quot;, 1, 0, 0
+		}, {&quot;help&quot;, 0, 0, 'h'}, {&quot;s3d-help&quot;, 0, 0, 'h'}, {0, 0, 0, 0}
 	};
-	if ((argc==NULL) || (argv==NULL)) return(0); /* nothing to parse */
-	optind=0;
-	opterr=0;	/* we don't want to be bothered if there is some error */
-	while (-1!=(c=getopt_long(*argc,*argv,&quot;?h&quot;,long_options,&amp;lopt_idx))) {
+	if ((argc == NULL) || (argv == NULL)) return(0); /* nothing to parse */
+	optind = 0;
+	opterr = 0; /* we don't want to be bothered if there is some error */
+	while (-1 != (c = getopt_long(*argc, *argv, &quot;?h&quot;, long_options, &amp;lopt_idx))) {
 		switch (c) {
 		case 0:
-			if (0==strcmp(long_options[lopt_idx].name,&quot;s3d-url&quot;)) {
+			if (0 == strcmp(long_options[lopt_idx].name, &quot;s3d-url&quot;)) {
 				if (optarg) {
-					url=optarg;
-					s3dprintf(HIGH,&quot;connecting to %s&quot;,url);
+					url = optarg;
+					s3dprintf(HIGH, &quot;connecting to %s&quot;, url);
 				}
 			}
 			break;
 		case 'h':
-			printf(&quot;usage: %s [options]&quot;,(*argv)[0]);
+			printf(&quot;usage: %s [options]&quot;, (*argv)[0]);
 			s3d_usage();
 			return(-1);
 		case '?':
@@ -104,62 +104,62 @@
 			break;
 		}
 	}
-	optind=0;
-	if (*argc&gt;0) {
-		*argc-=(optind-1); 				 /*  hide s3d-options */
-		(*argv)[optind-1]=(*argv)[0]; 	 /*  restore program path */
-		*argv+=(optind-1); 				 /*  set the string pointer at the right position */
+	optind = 0;
+	if (*argc &gt; 0) {
+		*argc -= (optind - 1);  /*  hide s3d-options */
+		(*argv)[optind-1] = (*argv)[0]; /*  restore program path */
+		*argv += (optind - 1);  /*  set the string pointer at the right position */
 	}
 	return(0);
 }
 /*  external functions go here ... */
 int s3d_init(int *argc, char ***argv, char *name)
 {
-	char 				*s;
-	char 				 urlc[256];		 /*  this should be enough for an url */
-	char 				 buf[258]; 		 /*  server buffer */
-	int					 i;
-	struct timespec		 t= {
-		0,10*1000*1000
+	char     *s;
+	char      urlc[256];   /*  this should be enough for an url */
+	char      buf[258];    /*  server buffer */
+	int      i;
+	struct timespec   t = {
+		0, 10*1000*1000
 	}; /* 10 mili second */
 
-	cb_lock=1;	/* don't bother while initiating ... is set to 0 after INIT packet received. */
-	if (NULL!=(s=getenv(&quot;S3D&quot;))) {
-		s3dprintf(VLOW,&quot;at least we have the enviroment variable ... %s&quot;,s);
-		url=s;
+	cb_lock = 1; /* don't bother while initiating ... is set to 0 after INIT packet received. */
+	if (NULL != (s = getenv(&quot;S3D&quot;))) {
+		s3dprintf(VLOW, &quot;at least we have the enviroment variable ... %s&quot;, s);
+		url = s;
 	}
-	parse_args(argc,argv);
-	if (url==NULL) { /* no url specified or obtained through arguments */
+	parse_args(argc, argv);
+	if (url == NULL) { /* no url specified or obtained through arguments */
 		/* trying standard ways to connect */
-		strncpy(urlc,&quot;s3<A HREF="d:///tmp/.s3d:shm/">d:///tmp/.s3d:shm/</A>&quot;,256);
-		if (s3d_net_init(urlc)==CON_NULL) {
-			strncpy(urlc,&quot;s3<A HREF="d://127.0.0.1:6066/">d://127.0.0.1:6066/</A>&quot;,256);
-			if (s3d_net_init(urlc)==CON_NULL)
+		strncpy(urlc, &quot;s3<A HREF="d:///tmp/.s3d:shm/">d:///tmp/.s3d:shm/</A>&quot;, 256);
+		if (s3d_net_init(urlc) == CON_NULL) {
+			strncpy(urlc, &quot;s3<A HREF="d://127.0.0.1:6066/">d://127.0.0.1:6066/</A>&quot;, 256);
+			if (s3d_net_init(urlc) == CON_NULL)
 				return(-1);
 		}
 	} else {
-		strncpy(urlc,url,256);	 /*  this should keep buffer overflows away, maybe */
-		urlc[256]=0;			 /*  just to make sure */
-		if (!strncmp(urlc, &quot;s3<A HREF="d://">d://</A> &quot;,6)) {
-			if (s3d_net_init(urlc)==CON_NULL) return(-1);
+		strncpy(urlc, url, 256);  /*  this should keep buffer overflows away, maybe */
+		urlc[256] = 0;  /*  just to make sure */
+		if (!strncmp(urlc, &quot;s3<A HREF="d://">d://</A> &quot;, 6)) {
+			if (s3d_net_init(urlc) == CON_NULL) return(-1);
 		} else {
-			errs(&quot;s3d_init()&quot;,&quot;invalid url&quot;);
+			errs(&quot;s3d_init()&quot;, &quot;invalid url&quot;);
 			return(-1);
 		}
 	}
-	strncpy(buf,name,256);  /*  copy the name ... */
-	net_send(S3D_P_C_INIT,buf,strlen(buf));
+	strncpy(buf, name, 256);  /*  copy the name ... */
+	net_send(S3D_P_C_INIT, buf, strlen(buf));
 
 	_queue_init();
 #ifdef SIGS
 	if (signal(SIGINT, (sig_t)sigint_handler) == SIG_ERR)
-		errdn(LOW,&quot;s3d_init():signal()&quot;,errno);
+		errdn(LOW, &quot;s3d_init():signal()&quot;, errno);
 	if (signal(SIGTERM, (sig_t)sigint_handler) == SIG_ERR)
-		errdn(LOW,&quot;s3d_init():signal()&quot;,errno);
+		errdn(LOW, &quot;s3d_init():signal()&quot;, errno);
 #endif
-	for (i=0;i&lt;100;i++) {
+	for (i = 0;i &lt; 100;i++) {
 		s3d_net_check(); /* wait for init packet */
-		nanosleep(&amp;t,NULL);
+		nanosleep(&amp;t, NULL);
 		if (_s3d_ready) {
 			cb_lock--;
 			return(0);
@@ -171,8 +171,8 @@
 int s3d_quit()
 {
 	struct s3d_evt *ret;
-	if (con_type!=CON_NULL &amp;&amp; _s3d_ready) {
-		net_send(S3D_P_C_QUIT,NULL,0);
+	if (con_type != CON_NULL &amp;&amp; _s3d_ready) {
+		net_send(S3D_P_C_QUIT, NULL, 0);
 		switch (con_type) {
 #ifdef TCP
 		case CON_TCP:
@@ -185,14 +185,14 @@
 			break;
 #endif
 		}
-		con_type=CON_NULL;
-		_s3d_ready=0;
+		con_type = CON_NULL;
+		_s3d_ready = 0;
 		_queue_quit();
-		while (NULL!=(ret=s3d_pop_event())) s3d_delete_event(ret);  /*  clear the stack ... */
-		cb_lock=0; /* we don't care about old callbacks, now we just quit! */
-		ret=malloc(sizeof(struct s3d_evt));
-		ret-&gt;event=S3D_EVENT_QUIT;
-		ret-&gt;length=0;
+		while (NULL != (ret = s3d_pop_event())) s3d_delete_event(ret);  /*  clear the stack ... */
+		cb_lock = 0; /* we don't care about old callbacks, now we just quit! */
+		ret = malloc(sizeof(struct s3d_evt));
+		ret-&gt;event = S3D_EVENT_QUIT;
+		ret-&gt;length = 0;
 		s3d_push_event(ret);
 	}
 	return(0);
@@ -200,12 +200,12 @@
 /*  apps should use that as main loop for their programs. */
 int s3d_mainloop(void (*f)())
 {
-	while (con_type!=CON_NULL) {
-		cb_lock++;			/* no callbacks while we are in mainloop */
-		if (f!=NULL)	f();
+	while (con_type != CON_NULL) {
+		cb_lock++;   /* no callbacks while we are in mainloop */
+		if (f != NULL) f();
 		cb_lock--;
 		s3d_process_stack();
-		s3d_net_check(); 	/* get any other packets we might have missed */
+		s3d_net_check();  /* get any other packets we might have missed */
 	}
 	return(0);
 }
@@ -214,35 +214,35 @@
 int s3d_open_file(char *fname, char **pointer)
 {
 	FILE *fp;
-	char *buf=NULL;
+	char *buf = NULL;
 	int filesize;
 	struct stat bf;
-	*pointer=NULL;
-	/*	if ((fp = fopen(fname, &quot;rt&quot;)) == NULL)
-		{ errn(&quot;s3d_open_file():fopen()&quot;,errno); return(0);}
-		if (fseek(fp, 0, SEEK_END) != 0)
-		{ errn(&quot;s3d_open_file():fseek()&quot;,errno); return(0);}
-		if ((filesize = (int)ftell(fp)) == (long)-1)
-		{ errn(&quot;s3d_open_file():ftell()&quot;,errno); return(0);}
-		if (fseek(fp, 0, SEEK_SET) != 0)
-		{ errn(&quot;s3d_open_file():fseek()&quot;,errno); return(0);}*/
+	*pointer = NULL;
+	/* if ((fp = fopen(fname, &quot;rt&quot;)) == NULL)
+	 { errn(&quot;s3d_open_file():fopen()&quot;,errno); return(0);}
+	 if (fseek(fp, 0, SEEK_END) != 0)
+	 { errn(&quot;s3d_open_file():fseek()&quot;,errno); return(0);}
+	 if ((filesize = (int)ftell(fp)) == (long)-1)
+	 { errn(&quot;s3d_open_file():ftell()&quot;,errno); return(0);}
+	 if (fseek(fp, 0, SEEK_SET) != 0)
+	 { errn(&quot;s3d_open_file():fseek()&quot;,errno); return(0);}*/
 
 	if ((fp = fopen(fname, &quot;rt&quot;)) == NULL) {
-		errdn(VLOW,&quot;s3d_open_file():fopen()&quot;,errno);
+		errdn(VLOW, &quot;s3d_open_file():fopen()&quot;, errno);
 		return(-1);
 	}
-	if (fstat(fileno(fp),&amp;bf)) {
-		errdn(VLOW,&quot;s3d_open_file():fstat()&quot;,errno);
+	if (fstat(fileno(fp), &amp;bf)) {
+		errdn(VLOW, &quot;s3d_open_file():fstat()&quot;, errno);
 		return(-1);
 	}
-	filesize=bf.st_size;
-	/*	s3dprintf(LOW, &quot;opening %s, filesize is %d&quot;,fname, filesize);*/
-	if ((buf=malloc(filesize))==NULL) {
-		errn(&quot;s3d_open_3ds_file():malloc()&quot;,errno);
+	filesize = bf.st_size;
+	/* s3dprintf(LOW, &quot;opening %s, filesize is %d&quot;,fname, filesize);*/
+	if ((buf = malloc(filesize)) == NULL) {
+		errn(&quot;s3d_open_3ds_file():malloc()&quot;, errno);
 		exit(-1);
 	}
 	fread(buf, 1, filesize, fp);
 	fclose(fp);
-	*pointer=buf;
+	*pointer = buf;
 	return(filesize);
 }

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/modelread.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,10 +25,10 @@
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
 #include &lt;g3d/g3d.h&gt;
-#include &lt;stdlib.h&gt; 	 /*  exit(), malloc() */
-#include &lt;math.h&gt;		 /*  sqrt() */
-#include &lt;string.h&gt; 	 /*  strncpy() */
-#include &lt;errno.h&gt; 		 /*  errno */
+#include &lt;stdlib.h&gt;   /*  exit(), malloc() */
+#include &lt;math.h&gt;   /*  sqrt() */
+#include &lt;string.h&gt;   /*  strncpy() */
+#include &lt;errno.h&gt;    /*  errno */
 
 
 struct material2texture {
@@ -40,63 +40,63 @@
 };
 struct material2texture *mat2tex_root = NULL;
 
-#define MAXSTRN		20
+#define MAXSTRN  20
 static int model_load(char *file);
 /*  just a helper function for reading from file instead of memory. */
 int s3d_import_model_file(char *fname)
 {
-	char *buf,*ptr,*next;
+	char *buf, *ptr, *next;
 	char searchpath[1024];
 	char path[1024];
 	int oid;
-	if (fname==NULL) return(-1);
+	if (fname == NULL) return(-1);
 #ifndef OBJSDIR
-#define OBJSDIR 	&quot;:./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/&quot;
+#define OBJSDIR  &quot;:./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/&quot;
 #endif
 
-	strncpy(searchpath,OBJSDIR,1023);
-	searchpath[1023]=0;							/* just in case */
-	next=ptr=searchpath;
-	while (next!=NULL) {
-		next=NULL;
+	strncpy(searchpath, OBJSDIR, 1023);
+	searchpath[1023] = 0;     /* just in case */
+	next = ptr = searchpath;
+	while (next != NULL) {
+		next = NULL;
 
-		if (NULL!=(next=strchr(ptr,':'))) {
-			*next=0; 							/* clear the delimiter */
-			next+=1;							/* move to the beginner of the next dir */
+		if (NULL != (next = strchr(ptr, ':'))) {
+			*next = 0;      /* clear the delimiter */
+			next += 1;     /* move to the beginner of the next dir */
 		}
-		if ((strlen(ptr)+strlen(fname))&lt;1024) {	/* only try if this fits */
-			strcpy(path,ptr); 					/* can use &quot;unsafe&quot; functions because size was verified above */
-			strcat(path,fname);
-			if (s3d_open_file(path,&amp;buf)!=-1) { /* found something */
+		if ((strlen(ptr) + strlen(fname)) &lt; 1024) { /* only try if this fits */
+			strcpy(path, ptr);     /* can use &quot;unsafe&quot; functions because size was verified above */
+			strcat(path, fname);
+			if (s3d_open_file(path, &amp;buf) != -1) { /* found something */
 				free(buf); /* TODO: badbadbad ... */
-				if (-1!=(oid=model_load(path))) return(oid);
+				if (-1 != (oid = model_load(path))) return(oid);
 
 			}
 		}
-		if (next!=NULL)
-			ptr=next;							/* move pointer to the next position */
+		if (next != NULL)
+			ptr = next;     /* move pointer to the next position */
 	}
-	errds(LOW,&quot;s3d_import_model_file()&quot;,&quot;Could not open %s&quot;, fname);
+	errds(LOW, &quot;s3d_import_model_file()&quot;, &quot;Could not open %s&quot;, fname);
 	return(-1); /* nothing in search path ... */
 }
 
-void *get_mat2tex( struct material2texture **mat2tex, void *mat_ptr )
+void *get_mat2tex(struct material2texture **mat2tex, void *mat_ptr)
 {
 
-	while ( (*mat2tex) != NULL ) {
+	while ((*mat2tex) != NULL) {
 
-		if ( (*mat2tex)-&gt;material_ptr == mat_ptr ) return (*mat2tex);
+		if ((*mat2tex)-&gt;material_ptr == mat_ptr) return (*mat2tex);
 
 		mat2tex = &amp;(*mat2tex)-&gt;next_ptr;
 
 	}
 
-	if ( (*mat2tex) == NULL ) {
+	if ((*mat2tex) == NULL) {
 
-		(*mat2tex) = malloc( sizeof( struct material2texture ) );
+		(*mat2tex) = malloc(sizeof(struct material2texture));
 
-		if ( (*mat2tex) == NULL ) {
-			errs( &quot;model_import()&quot;, &quot;Sorry - you ran out of memory !\n&quot; );
+		if ((*mat2tex) == NULL) {
+			errs(&quot;model_import()&quot;, &quot;Sorry - you ran out of memory !\n&quot;);
 			exit(8);
 		}
 
@@ -118,112 +118,112 @@
 
 int model_load(char *file)
 {
-	G3DContext			 	*context;
-	G3DModel				*model;
-	G3DObject 				*object;
-	G3DFace 				*face;
-	GSList 					*oitem, *oface;
+	G3DContext     *context;
+	G3DModel    *model;
+	G3DObject     *object;
+	G3DFace     *face;
+	GSList      *oitem, *oface;
 	struct material2texture *mat2tex;
-	int						 j, k, material_count, texture_count, voff,obj_id;
-#define 					PMAX	100
-	uint32_t 			 polybuf[PMAX * 4],npoly,oldflags;
-	float					 normalbuf[PMAX * 9],texcoordbuf[PMAX * 6];
-	float 					 swaph;				/* swap helper */
-	uint8_t 			*s3d_pixeldata = NULL;
+	int       j, k, material_count, texture_count, voff, obj_id;
+#define      PMAX 100
+	uint32_t     polybuf[PMAX * 4], npoly, oldflags;
+	float      normalbuf[PMAX * 9], texcoordbuf[PMAX * 6];
+	float       swaph;    /* swap helper */
+	uint8_t    *s3d_pixeldata = NULL;
 
 	context = g3d_context_new();
-	obj_id=-1;
+	obj_id = -1;
 	model = g3d_model_load_full(context, file, 0);
 
-	if ( model ) {
+	if (model) {
 
 		oitem = model-&gt;objects;
 		obj_id = s3d_new_object();
 		material_count = texture_count = voff = 0;
 
-		while ( oitem ) {
+		while (oitem) {
 
 			object = (G3DObject *)oitem-&gt;data;
 
 			/* push vertices */
-			for ( j = 0; j &lt; object-&gt;vertex_count; j++ ) {
+			for (j = 0; j &lt; object-&gt;vertex_count; j++) {
 				/* 2. and 3. coord have to change places otherwise the object will be turned */
 				object-&gt;vertex_data[j * 3 + 0] =  object-&gt;vertex_data[j * 3 + 0];
-				swaph=							  object-&gt;vertex_data[j * 3 + 2];
+				swaph =         object-&gt;vertex_data[j * 3 + 2];
 				object-&gt;vertex_data[j * 3 + 2] = -object-&gt;vertex_data[j * 3 + 1];
 				object-&gt;vertex_data[j * 3 + 1] = swaph;
 			}
-			s3d_push_vertices( obj_id, object-&gt;vertex_data, object-&gt;vertex_count);
+			s3d_push_vertices(obj_id, object-&gt;vertex_data, object-&gt;vertex_count);
 
 
 
-			if (NULL==(oface = object-&gt;faces)) {
+			if (NULL == (oface = object-&gt;faces)) {
 				voff += object-&gt;vertex_count; /* increase vertex offset */
 				oitem = oitem-&gt;next;
 				continue;
 			}
-			npoly=0;
-			oldflags = ((G3DFace *) (oface-&gt;data))-&gt;flags;
+			npoly = 0;
+			oldflags = ((G3DFace *)(oface-&gt;data))-&gt;flags;
 
-			while ( oface ) {
+			while (oface) {
 
 				face = (G3DFace *)oface-&gt;data;
-				mat2tex = get_mat2tex( &amp;mat2tex_root, face-&gt;material );
+				mat2tex = get_mat2tex(&amp;mat2tex_root, face-&gt;material);
 
-				if ( mat2tex-&gt;material_id == -1 ) { /* create a new texture if nothing found */
-					s3d_push_material_a( obj_id, 	face-&gt;material-&gt;r, face-&gt;material-&gt;g, face-&gt;material-&gt;b,face-&gt;material-&gt;a,
-					                     face-&gt;material-&gt;specular[0], face-&gt;material-&gt;specular[1], face-&gt;material-&gt;specular[2], face-&gt;material-&gt;specular[3],
-					                     face-&gt;material-&gt;r, face-&gt;material-&gt;g, face-&gt;material-&gt;b, face-&gt;material-&gt;a );
+				if (mat2tex-&gt;material_id == -1) {   /* create a new texture if nothing found */
+					s3d_push_material_a(obj_id,  face-&gt;material-&gt;r, face-&gt;material-&gt;g, face-&gt;material-&gt;b, face-&gt;material-&gt;a,
+					                    face-&gt;material-&gt;specular[0], face-&gt;material-&gt;specular[1], face-&gt;material-&gt;specular[2], face-&gt;material-&gt;specular[3],
+					                    face-&gt;material-&gt;r, face-&gt;material-&gt;g, face-&gt;material-&gt;b, face-&gt;material-&gt;a);
 
 					mat2tex-&gt;material_id = material_count;
 					material_count++;
 
-					if ( face-&gt;tex_image != NULL ) {
+					if (face-&gt;tex_image != NULL) {
 
 						/* reorder pixeldata - s3d wants rgba */
-						if ( s3d_pixeldata != NULL ) free( s3d_pixeldata );
+						if (s3d_pixeldata != NULL) free(s3d_pixeldata);
 
-						s3d_pixeldata = malloc( sizeof( uint8_t ) * face-&gt;tex_image-&gt;width * face-&gt;tex_image-&gt;height * 32 );
+						s3d_pixeldata = malloc(sizeof(uint8_t) * face-&gt;tex_image-&gt;width * face-&gt;tex_image-&gt;height * 32);
 
-						if ( s3d_pixeldata == NULL ) {
-							errs(&quot;model_load()&quot;, &quot;Sorry - you ran out of memory !\n&quot; );
+						if (s3d_pixeldata == NULL) {
+							errs(&quot;model_load()&quot;, &quot;Sorry - you ran out of memory !\n&quot;);
 							exit(8);
 						}
 
-						for ( j = ( face-&gt;tex_image-&gt;height - 1 ); j &gt;= 0; j-- ) {
-							for ( k = 0; k &lt; face-&gt;tex_image-&gt;width; k++ ) {
-								s3d_pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 0 ] = face-&gt;tex_image-&gt;pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 2 ];
-								s3d_pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 1 ] = face-&gt;tex_image-&gt;pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 1 ];
-								s3d_pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 2 ] = face-&gt;tex_image-&gt;pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 0 ];
-								s3d_pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 3 ] = face-&gt;tex_image-&gt;pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 3 ];
+						for (j = (face-&gt;tex_image-&gt;height - 1); j &gt;= 0; j--) {
+							for (k = 0; k &lt; face-&gt;tex_image-&gt;width; k++) {
+								s3d_pixeldata[(j * face-&gt;tex_image-&gt;width + k) * 4 + 0 ] = face-&gt;tex_image-&gt;pixeldata[(j * face-&gt;tex_image-&gt;width + k) * 4 + 2 ];
+								s3d_pixeldata[(j * face-&gt;tex_image-&gt;width + k) * 4 + 1 ] = face-&gt;tex_image-&gt;pixeldata[(j * face-&gt;tex_image-&gt;width + k) * 4 + 1 ];
+								s3d_pixeldata[(j * face-&gt;tex_image-&gt;width + k) * 4 + 2 ] = face-&gt;tex_image-&gt;pixeldata[(j * face-&gt;tex_image-&gt;width + k) * 4 + 0 ];
+								s3d_pixeldata[(j * face-&gt;tex_image-&gt;width + k) * 4 + 3 ] = face-&gt;tex_image-&gt;pixeldata[(j * face-&gt;tex_image-&gt;width + k) * 4 + 3 ];
 							}
 						}
 
-						s3d_push_texture( obj_id, face-&gt;tex_image-&gt;width, face-&gt;tex_image-&gt;height );
-						s3d_pep_material_texture( obj_id, texture_count );
-						s3d_load_texture( obj_id, texture_count, 0, 0, face-&gt;tex_image-&gt;width, face-&gt;tex_image-&gt;height, s3d_pixeldata );
+						s3d_push_texture(obj_id, face-&gt;tex_image-&gt;width, face-&gt;tex_image-&gt;height);
+						s3d_pep_material_texture(obj_id, texture_count);
+						s3d_load_texture(obj_id, texture_count, 0, 0, face-&gt;tex_image-&gt;width, face-&gt;tex_image-&gt;height, s3d_pixeldata);
 
 						mat2tex-&gt;texture_id = texture_count;
 						texture_count++;
 
 					}
 				}
-				if (face-&gt;flags != oldflags || npoly&gt;=PMAX) {
+				if (face-&gt;flags != oldflags || npoly &gt;= PMAX) {
 					/* push things so far */
 					s3d_push_polygons(obj_id, polybuf, npoly);
-					if (oldflags &amp; G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
-					if (oldflags &amp; G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);
-					npoly=0;
+					if (oldflags &amp; G3D_FLAG_FAC_NORMALS)  s3d_pep_polygon_normals(obj_id, normalbuf,   npoly);
+					if (oldflags &amp; G3D_FLAG_FAC_TEXMAP)   s3d_pep_polygon_tex_coords(obj_id, texcoordbuf, npoly);
+					npoly = 0;
 				}
-				oldflags=face-&gt;flags;
+				oldflags = face-&gt;flags;
 
 				/* add polygon to the polygon buffer */
-				polybuf[npoly*4+0]=face-&gt;vertex_indices[0] + voff;
-				polybuf[npoly*4+1]=face-&gt;vertex_indices[2] + voff;
-				polybuf[npoly*4+2]=face-&gt;vertex_indices[1] + voff;
-				polybuf[npoly*4+3]=mat2tex-&gt;material_id;
+				polybuf[npoly*4+0] = face-&gt;vertex_indices[0] + voff;
+				polybuf[npoly*4+1] = face-&gt;vertex_indices[2] + voff;
+				polybuf[npoly*4+2] = face-&gt;vertex_indices[1] + voff;
+				polybuf[npoly*4+3] = mat2tex-&gt;material_id;
 
-				if ( face-&gt;flags &amp; G3D_FLAG_FAC_NORMALS ) {
+				if (face-&gt;flags &amp; G3D_FLAG_FAC_NORMALS) {
 					normalbuf[ npoly*9 + 0] = -face-&gt;normals[ 0 ];
 					normalbuf[ npoly*9 + 1] = -face-&gt;normals[ 2 ];
 					normalbuf[ npoly*9 + 2] =  face-&gt;normals[ 1 ];
@@ -234,7 +234,7 @@
 					normalbuf[ npoly*9 + 7] = -face-&gt;normals[ 5 ];
 					normalbuf[ npoly*9 + 8] =  face-&gt;normals[ 4 ];
 				}
-				if ( face-&gt;flags &amp; G3D_FLAG_FAC_TEXMAP ) {
+				if (face-&gt;flags &amp; G3D_FLAG_FAC_TEXMAP) {
 					texcoordbuf[ npoly*6 + 0] = face-&gt;tex_vertex_data[ 0 ];
 					texcoordbuf[ npoly*6 + 1] = face-&gt;tex_vertex_data[ 1 ];
 					texcoordbuf[ npoly*6 + 2] = face-&gt;tex_vertex_data[ 4 ];
@@ -248,9 +248,9 @@
 			/* push the last packets in buffer */
 			if (npoly &gt; 0) {
 				s3d_push_polygons(obj_id, polybuf, npoly);
-				if (oldflags &amp; G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
-				if (oldflags &amp; G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);
-				npoly=0;
+				if (oldflags &amp; G3D_FLAG_FAC_NORMALS)  s3d_pep_polygon_normals(obj_id, normalbuf,   npoly);
+				if (oldflags &amp; G3D_FLAG_FAC_TEXMAP)   s3d_pep_polygon_tex_coords(obj_id, texcoordbuf, npoly);
+				npoly = 0;
 			}
 
 			voff += object-&gt;vertex_count; /* increase vertex offset */

Modified: trunk/libs3d/network.c
===================================================================
--- trunk/libs3d/network.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/network.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,15 +24,15 @@
 
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
-#include &lt;string.h&gt; 	 /*  memcpy() */
-#include &lt;stdlib.h&gt;		 /*  malloc(), free() */
-#include &lt;unistd.h&gt;		 /*  read(), write() */
-#include &lt;errno.h&gt;		 /*  errno */
+#include &lt;string.h&gt;   /*  memcpy() */
+#include &lt;stdlib.h&gt;   /*  malloc(), free() */
+#include &lt;unistd.h&gt;   /*  read(), write() */
+#include &lt;errno.h&gt;   /*  errno */
 #include &lt;netinet/in.h&gt;  /*  htons(),htonl() */
 #ifdef SIGS
 extern int _s3d_sigio;
 #endif
-int con_type=CON_NULL;
+int con_type = CON_NULL;
 #ifdef TCP
 static int _s3d_net_receive();
 #endif
@@ -40,22 +40,22 @@
 int net_send(u_int8_t opcode, char *buf, u_int16_t length)
 {
 	char *ptr;
-	/* 	char *buff; */
+	/*  char *buff; */
 	char buff[65539];  /*  u_int16_t really shouldn't be bigger ;) */
-	*(buff)=opcode;
-	ptr=buff+1;
-	*((u_int16_t *) ptr)=htons(length);
-	if (length!=0)
-		memcpy(buff+3,buf,length);
+	*(buff) = opcode;
+	ptr = buff + 1;
+	*((u_int16_t *) ptr) = htons(length);
+	if (length != 0)
+		memcpy(buff + 3, buf, length);
 	switch (con_type) {
 #ifdef SHM
 	case CON_SHM:
-		shm_writen(buff,length+3);
+		shm_writen(buff, length + 3);
 		break;
 #endif
 #ifdef TCP
 	case CON_TCP:
-		tcp_writen(buff,length+3);
+		tcp_writen(buff, length + 3);
 		break;
 #endif
 	}
@@ -79,7 +79,7 @@
 #endif
 			while (_s3d_net_receive());
 #ifdef SIGS
-			_s3d_sigio=0;
+			_s3d_sigio = 0;
 		}
 #endif
 		break;
@@ -95,64 +95,64 @@
 }
 int s3d_net_init(char *urlc)
 {
-	char				*s,*sv,*port=NULL;
-	char				*first_slash=NULL;
+	char    *s, *sv, *port = NULL;
+	char    *first_slash = NULL;
 #ifdef TCP
-	int					 pn=0;
+	int      pn = 0;
 #endif
-	int					 tcp,shm;
-	tcp=shm=1; /* everything is possible, yet */
+	int      tcp, shm;
+	tcp = shm = 1; /* everything is possible, yet */
 
 	/*  doing a very bad server/port extraction, but I think it'll work ... */
-	s=sv=urlc+6;  /*  getting to the &quot;real&quot; thing */
+	s = sv = urlc + 6;  /*  getting to the &quot;real&quot; thing */
 	/* while (((*s!='/') &amp;&amp; (*s!=0)) &amp;&amp; (s&lt;(urlc-6))) */
-	while (*s!=0) {
-		if (*s=='/') {
-			if (first_slash==NULL)
-				first_slash=s;
-			if (port!=NULL)
+	while (*s != 0) {
+		if (*s == '/') {
+			if (first_slash == NULL)
+				first_slash = s;
+			if (port != NULL)
 				break;
 		}
-		if (*s==':') { /*  there is a port in here */
-			port=s+1;
-			*s=0;	 /*  NULL the port  */
+		if (*s == ':') { /*  there is a port in here */
+			port = s + 1;
+			*s = 0;  /*  NULL the port  */
 		}
 		s++;
 	}
 
-	*s=0;
-	if (port==NULL) {
-		shm=0;
-		if (first_slash!=NULL)
-			*first_slash=0;
+	*s = 0;
+	if (port == NULL) {
+		shm = 0;
+		if (first_slash != NULL)
+			*first_slash = 0;
 	} else {
-		if (first_slash&lt;port)
-			tcp=0;
+		if (first_slash &lt; port)
+			tcp = 0;
 		else
-			if (first_slash!=NULL)
-				*first_slash=0;
-		if (!strncmp(port, &quot;shm&quot;,3)) {
-			tcp=0; /* null the others */
+			if (first_slash != NULL)
+				*first_slash = 0;
+		if (!strncmp(port, &quot;shm&quot;, 3)) {
+			tcp = 0; /* null the others */
 		} else {
-			shm=0;
+			shm = 0;
 		}
 	}
 #ifdef SHM
 	if (shm) {
-		if (!strncmp(port, &quot;shm&quot;,3))
-			if (!_shm_init(sv)) return(con_type=CON_SHM);
+		if (!strncmp(port, &quot;shm&quot;, 3))
+			if (!_shm_init(sv)) return(con_type = CON_SHM);
 	}
 #endif
 #ifdef TCP
 	if (tcp) {
-		pn=6066;
-		if (port!=NULL) {
-			if (!(pn=atoi(port))) { /*  I hope atoi is safe enough. */
-				errn(&quot;s3d_init():atoi()&quot;,errno);
-				pn=6066;
+		pn = 6066;
+		if (port != NULL) {
+			if (!(pn = atoi(port))) { /*  I hope atoi is safe enough. */
+				errn(&quot;s3d_init():atoi()&quot;, errno);
+				pn = 6066;
 			}
 		}
-		if (!_tcp_init(sv,pn)) return(con_type=CON_TCP);
+		if (!_tcp_init(sv, pn)) return(con_type = CON_TCP);
 	}
 #endif
 	return(CON_NULL);

Modified: trunk/libs3d/object_queue.c
===================================================================
--- trunk/libs3d/object_queue.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/object_queue.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,38 +25,38 @@
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
 #include &quot;proto.h&quot;
-#include &lt;stdlib.h&gt;	 /*  malloc(),free(), realloc() */
+#include &lt;stdlib.h&gt;  /*  malloc(),free(), realloc() */
 
 #ifndef _POSIX_C_SOURCE
-#define _POSIX_C_SOURCE 199309		/* we want struct timespec to be defined */
+#define _POSIX_C_SOURCE 199309  /* we want struct timespec to be defined */
 #endif
 #ifndef __USE_POSIX199309
 #define __USE_POSIX199309 1
 #endif
-#include &lt;time.h&gt;		 /*  nanosleep() */
+#include &lt;time.h&gt;   /*  nanosleep() */
 
 /*  objects are requested before beeing used for having fast  */
 /*  access when needed. this also makes things more asynchronous, */
 /*  therefore faster (I hope). */
 
-#define Q_UNUSED	-1				 	/*  unused slot magic number */
-#define MAX_REQ		100				 	/*  don't request more than that. */
-static unsigned int *queue;			 	/*  the object id's */
-static int queue_size=0;			 	/*  the size of the object queue */
-static int requested;				 	/*  counter of how many addtional */
+#define Q_UNUSED -1      /*  unused slot magic number */
+#define MAX_REQ  100      /*  don't request more than that. */
+static unsigned int *queue;     /*  the object id's */
+static int queue_size = 0;   /*  the size of the object queue */
+static int requested;      /*  counter of how many addtional */
 /*  objects have been requested */
-static struct timespec t= {
-	0,10*1000
-};	/* 10 micro seconds */
+static struct timespec t = {
+	0, 10*1000
+}; /* 10 micro seconds */
 /*  initializes the object queue */
 int _queue_init()
 {
 	int i;
-	queue_size=1;
-	requested=0;
-	queue=malloc(sizeof(unsigned int)*queue_size);
-	for (i=0;i&lt;queue_size;i++) {
-		queue[i]=Q_UNUSED;
+	queue_size = 1;
+	requested = 0;
+	queue = malloc(sizeof(unsigned int) * queue_size);
+	for (i = 0;i &lt; queue_size;i++) {
+		queue[i] = Q_UNUSED;
 	}
 	_queue_fill();
 	return(0);
@@ -65,68 +65,68 @@
 int _queue_fill()
 {
 	int i;
-	for (i=0;i&lt;queue_size;i++)
-		if (queue[i]==Q_UNUSED)
-			net_send(S3D_P_C_NEW_OBJ,NULL,0);
+	for (i = 0;i &lt; queue_size;i++)
+		if (queue[i] == Q_UNUSED)
+			net_send(S3D_P_C_NEW_OBJ, NULL, 0);
 	return(0);
 }
 /*  we have a new object from the server, trying to find a place for it */
 int _queue_new_object(unsigned int oid)
 {
 	int i;
-	/* 	s3dprintf(LOW,&quot;having a new object (%d) in the queue!!&quot;,oid); */
-	for (i=0;i&lt;queue_size;i++)
-		if (queue[i]==Q_UNUSED) {
-			/* 			s3dprintf(LOW,&quot;placing it at position %d&quot;,i); */
-			queue[i]=oid;
+	/*  s3dprintf(LOW,&quot;having a new object (%d) in the queue!!&quot;,oid); */
+	for (i = 0;i &lt; queue_size;i++)
+		if (queue[i] == Q_UNUSED) {
+			/*    s3dprintf(LOW,&quot;placing it at position %d&quot;,i); */
+			queue[i] = oid;
 			requested--;
 			return(0);
 		}
-	if (queue_size==0) return(-1);  /*  already quit. */
+	if (queue_size == 0) return(-1);  /*  already quit. */
 	/*  if we reach here, all slots all taken.  */
-	/* 	s3dprintf(LOW,&quot;no place for object, resizing stack.&quot;,i); */
-	queue=realloc(queue,sizeof(unsigned int)*(queue_size+1));
-	queue_size+=1;
+	/*  s3dprintf(LOW,&quot;no place for object, resizing stack.&quot;,i); */
+	queue = realloc(queue, sizeof(unsigned int) * (queue_size + 1));
+	queue_size += 1;
 	requested--;
-	queue[queue_size-1]=oid;
+	queue[queue_size-1] = oid;
 	return(0);
 }
 /*  an object is requested!! give one out: */
 unsigned int _queue_want_object()
 {
 	unsigned int ret;
-	int i,j;
-	j=0;
+	int i, j;
+	j = 0;
 	do {
-		for (i=0;i&lt;queue_size;i++)
-			if (queue[i]!=Q_UNUSED) {
-				ret=queue[i];
-				queue[i]=Q_UNUSED;
-				net_send(S3D_P_C_NEW_OBJ,NULL,0);  /*  we already can request a new one. */
+		for (i = 0;i &lt; queue_size;i++)
+			if (queue[i] != Q_UNUSED) {
+				ret = queue[i];
+				queue[i] = Q_UNUSED;
+				net_send(S3D_P_C_NEW_OBJ, NULL, 0);  /*  we already can request a new one. */
 				return(ret);
 			}
 		/*  if we reach this point, our queue is empty. */
 		/*  as other request should have sent S3D_P_C_NEW_OBJ-requests,  */
 		/*  we request one more object than needed to satisfy more load in future. */
-		if (queue_size==0) return(-1);  /*  already quit. */
-		if (requested&lt;MAX_REQ) {
-			net_send(S3D_P_C_NEW_OBJ,NULL,0);
+		if (queue_size == 0) return(-1);  /*  already quit. */
+		if (requested &lt; MAX_REQ) {
+			net_send(S3D_P_C_NEW_OBJ, NULL, 0);
 			requested++;
 		}
 		s3d_net_check();
-		nanosleep(&amp;t,NULL);
-	} while (j++&lt;TIMEOUT);
+		nanosleep(&amp;t, NULL);
+	} while (j++ &lt; TIMEOUT);
 
-	errds(LOW,&quot;_queue_want_object()&quot;,&quot;timeout is reached. server is extremly slow/laggy or dead&quot;);
+	errds(LOW, &quot;_queue_want_object()&quot;, &quot;timeout is reached. server is extremly slow/laggy or dead&quot;);
 	return(-1);
 }
 /*  cleans up */
 int _queue_quit()
 {
-	if (queue!=NULL) {
+	if (queue != NULL) {
 		free(queue);
-		queue=NULL;
+		queue = NULL;
 	}
-	queue_size=0;
+	queue_size = 0;
 	return(0);
 }

Modified: trunk/libs3d/proto_in.c
===================================================================
--- trunk/libs3d/proto_in.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/proto_in.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,135 +26,135 @@
 #include &quot;s3dlib.h&quot;
 #include &lt;proto.h&gt;
 #include &lt;netinet/in.h&gt;  /*  htons(),htonl() */
-#include &lt;errno.h&gt;		 /*  errno */
-#include &lt;stdlib.h&gt;		 /*  malloc(), free() */
+#include &lt;errno.h&gt;   /*  errno */
+#include &lt;stdlib.h&gt;   /*  malloc(), free() */
 /*  this proccesses the commands and pushes s3d-events, or does other things ;) */
 int net_prot_in(uint8_t opcode, uint16_t length, char *buf)
 {
-	uint32_t oid=-1;
-	struct s3d_evt *s3devt=NULL;
+	uint32_t oid = -1;
+	struct s3d_evt *s3devt = NULL;
 	struct mcp_object *mo;
 	struct s3d_obj_info *oi;
 	switch (opcode) {
 	case S3D_P_S_INIT:
-		s3dprintf(MED,&quot;S3D_P_S_INIT: init!!&quot;);
-		_s3d_ready=1;
+		s3dprintf(MED, &quot;S3D_P_S_INIT: init!!&quot;);
+		_s3d_ready = 1;
 		break;
 	case S3D_P_S_QUIT:
-		s3dprintf(MED,&quot;S3D_P_S_QUIT: server wants us to go. well ...&quot;);
+		s3dprintf(MED, &quot;S3D_P_S_QUIT: server wants us to go. well ...&quot;);
 		s3d_quit();
 		break;
 	case S3D_P_S_CLICK:
-		if (length==4) {
-			oid=ntohl(*((uint32_t *)buf));
-			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
-				*((uint32_t *)buf)=oid;  /*  reuse buffer ... */
-				s3devt-&gt;event=S3D_EVENT_OBJ_CLICK;
-				s3devt-&gt;length=4;
-				s3devt-&gt;buf=buf;
+		if (length == 4) {
+			oid = ntohl(*((uint32_t *)buf));
+			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {
+				*((uint32_t *)buf) = oid;  /*  reuse buffer ... */
+				s3devt-&gt;event = S3D_EVENT_OBJ_CLICK;
+				s3devt-&gt;length = 4;
+				s3devt-&gt;buf = buf;
 			}
-			s3dprintf(MED,&quot;S3D_P_S_CLICK: %d got clicked ....&quot;,oid);
+			s3dprintf(MED, &quot;S3D_P_S_CLICK: %d got clicked ....&quot;, oid);
 		}
 		break;
 	case S3D_P_S_NEWOBJ:
-		if (length==4) {
-			oid=ntohl(*((uint32_t *)buf));
+		if (length == 4) {
+			oid = ntohl(*((uint32_t *)buf));
 			_queue_new_object(oid);
 			/*
 			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
 			{
-				*((uint32_t *)buf)=oid;  / *  reuse buffer ... * /
-				s3devt-&gt;event=S3D_EVENT_NEW_OBJECT;
-				s3devt-&gt;length=4;
-				s3devt-&gt;buf=buf;
-				_queue_new_object(*((unsigned int *)newevt-&gt;buf));
+			 *((uint32_t *)buf)=oid;  / *  reuse buffer ... * /
+			 s3devt-&gt;event=S3D_EVENT_NEW_OBJECT;
+			 s3devt-&gt;length=4;
+			 s3devt-&gt;buf=buf;
+			 _queue_new_object(*((unsigned int *)newevt-&gt;buf));
 			}*/
-			s3dprintf(VLOW,&quot;S3D_P_S_NEWOBJ: new object %d&quot;,oid);
+			s3dprintf(VLOW, &quot;S3D_P_S_NEWOBJ: new object %d&quot;, oid);
 		}
 		break;
 	case S3D_P_S_KEY:
-		if (length==8) {
-			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+		if (length == 8) {
+			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {
 				struct s3d_key_event *keyevent;
-				s3devt-&gt;length=2;
-				keyevent=(struct s3d_key_event *)buf;
-				keyevent-&gt;keysym=ntohs(keyevent-&gt;keysym);
-				keyevent-&gt;unicode=ntohs(keyevent-&gt;unicode);
-				keyevent-&gt;modifier=ntohs(keyevent-&gt;modifier);
-				keyevent-&gt;state=ntohs(keyevent-&gt;state);
-				s3devt-&gt;buf=buf;
-				s3devt-&gt;event=(keyevent-&gt;state==0)?S3D_EVENT_KEYDOWN:S3D_EVENT_KEYUP;
+				s3devt-&gt;length = 2;
+				keyevent = (struct s3d_key_event *)buf;
+				keyevent-&gt;keysym = ntohs(keyevent-&gt;keysym);
+				keyevent-&gt;unicode = ntohs(keyevent-&gt;unicode);
+				keyevent-&gt;modifier = ntohs(keyevent-&gt;modifier);
+				keyevent-&gt;state = ntohs(keyevent-&gt;state);
+				s3devt-&gt;buf = buf;
+				s3devt-&gt;event = (keyevent-&gt;state == 0) ? S3D_EVENT_KEYDOWN : S3D_EVENT_KEYUP;
 			}
-			s3dprintf(VLOW,&quot;S3D_P_S_KEY: key %d hit!!&quot;,*((uint16_t *)s3devt-&gt;buf));
+			s3dprintf(VLOW, &quot;S3D_P_S_KEY: key %d hit!!&quot;, *((uint16_t *)s3devt-&gt;buf));
 		}
 		break;
 	case S3D_P_S_MBUTTON:
-		if (length==2) {
-			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
-				s3devt-&gt;event=S3D_EVENT_MBUTTON;
-				s3devt-&gt;length=2;
-				s3devt-&gt;buf=buf;
+		if (length == 2) {
+			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {
+				s3devt-&gt;event = S3D_EVENT_MBUTTON;
+				s3devt-&gt;length = 2;
+				s3devt-&gt;buf = buf;
 			}
-			s3dprintf(VLOW,&quot;S3D_P_S_MBUTTON: mbutton %d, state %d !!&quot;,*((uint8_t *)s3devt-&gt;buf), *(1+(uint8_t *)s3devt-&gt;buf));
+			s3dprintf(VLOW, &quot;S3D_P_S_MBUTTON: mbutton %d, state %d !!&quot;, *((uint8_t *)s3devt-&gt;buf), *(1 + (uint8_t *)s3devt-&gt;buf));
 		}
 		break;
 	case S3D_P_MCP_OBJECT:
-		if (length==sizeof(struct mcp_object)) {
-			/* 				oid=htonl(*((uint32_t *)buf)); */
-			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
-				/* 					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
-				s3devt-&gt;event=S3D_MCP_OBJECT;
-				s3devt-&gt;length=length;
-				mo=(struct mcp_object *)buf;
-				*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
+		if (length == sizeof(struct mcp_object)) {
+			/*     oid=htonl(*((uint32_t *)buf)); */
+			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {
+				/*      *((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
+				s3devt-&gt;event = S3D_MCP_OBJECT;
+				s3devt-&gt;length = length;
+				mo = (struct mcp_object *)buf;
+				*((uint32_t *)buf) = ntohl(*((uint32_t *)buf));  /*  revert oid */
 
-				buf[length-1]='\0';  /*  put a null byte at the end  */
+				buf[length-1] = '\0';  /*  put a null byte at the end  */
 				/*  for the not so careful users */
-				s3devt-&gt;buf=buf;
-				s3dprintf(VLOW,&quot;S3D_P_MCP_OBEJCT: something is happening to object %d, name %s&quot;, 	mo-&gt;object, mo-&gt;name);
+				s3devt-&gt;buf = buf;
+				s3dprintf(VLOW, &quot;S3D_P_MCP_OBEJCT: something is happening to object %d, name %s&quot;,  mo-&gt;object, mo-&gt;name);
 
 			}
-		} else s3dprintf(MED,&quot;wrong length for S3D_P_MCP_OBJECT length %d != %d&quot;,length,sizeof(struct mcp_object));
+		} else s3dprintf(MED, &quot;wrong length for S3D_P_MCP_OBJECT length %d != %d&quot;, length, sizeof(struct mcp_object));
 		break;
 	case S3D_P_S_OINFO:
-		if (length==sizeof(struct s3d_obj_info)) {
-			/* 				oid=htonl(*((uint32_t *)buf)); */
-			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
-				/* 					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
-				s3devt-&gt;event=S3D_EVENT_OBJ_INFO;
-				s3devt-&gt;length=length;
-				oi=(struct s3d_obj_info *)buf;
-				oi-&gt;object	=ntohl(oi-&gt;object);
-				oi-&gt;flags	=ntohl(oi-&gt;flags);
+		if (length == sizeof(struct s3d_obj_info)) {
+			/*     oid=htonl(*((uint32_t *)buf)); */
+			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {
+				/*      *((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
+				s3devt-&gt;event = S3D_EVENT_OBJ_INFO;
+				s3devt-&gt;length = length;
+				oi = (struct s3d_obj_info *)buf;
+				oi-&gt;object = ntohl(oi-&gt;object);
+				oi-&gt;flags = ntohl(oi-&gt;flags);
 
-				buf[length-1]='\0';  /*  put a null byte at the end  */
+				buf[length-1] = '\0';  /*  put a null byte at the end  */
 				/*  for the not so careful users */
-				s3devt-&gt;buf=buf;
-				s3dprintf(VLOW,&quot;S3D_P_S_OINFO: something is happening to object %d, name %s&quot;,
+				s3devt-&gt;buf = buf;
+				s3dprintf(VLOW, &quot;S3D_P_S_OINFO: something is happening to object %d, name %s&quot;,
 				          oi-&gt;object,
 				          oi-&gt;name
 				         );
 
 			}
-		} else s3dprintf(MED,&quot;wrong length for S3D_P_S_OINFO length %d != %d&quot;,length,sizeof(struct s3d_obj_info));
+		} else s3dprintf(MED, &quot;wrong length for S3D_P_S_OINFO length %d != %d&quot;, length, sizeof(struct s3d_obj_info));
 		break;
 
 	case S3D_P_MCP_DEL_OBJECT:
-		if (length==4) {
-			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
-				s3devt-&gt;event=S3D_MCP_DEL_OBJECT;
-				s3devt-&gt;length=length;
-				*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
-				s3dprintf(MED,&quot;S3D_P_MCP_DEL_OBEJCT: deleting object %d&quot;,*((uint32_t *)buf));
-				s3devt-&gt;buf=buf;
+		if (length == 4) {
+			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {
+				s3devt-&gt;event = S3D_MCP_DEL_OBJECT;
+				s3devt-&gt;length = length;
+				*((uint32_t *)buf) = ntohl(*((uint32_t *)buf));  /*  revert oid */
+				s3dprintf(MED, &quot;S3D_P_MCP_DEL_OBEJCT: deleting object %d&quot;, *((uint32_t *)buf));
+				s3devt-&gt;buf = buf;
 			}
 		}
 		break;
 	default:
-		s3dprintf(MED,&quot;don't know command %d&quot;,opcode);
-		if (buf!=NULL) free(buf);
+		s3dprintf(MED, &quot;don't know command %d&quot;, opcode);
+		if (buf != NULL) free(buf);
 	}
-	if (s3devt!=NULL) {
+	if (s3devt != NULL) {
 
 		s3d_push_event(s3devt);
 	}

Modified: trunk/libs3d/proto_out.c
===================================================================
--- trunk/libs3d/proto_out.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/proto_out.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,25 +25,25 @@
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
 #include &lt;proto.h&gt;
-#include &lt;string.h&gt; 	 /*  memset(),strncpy(),strncmp(),memcpy() */
-#include &lt;errno.h&gt;		 /*  errno */
+#include &lt;string.h&gt;   /*  memset(),strncpy(),strncmp(),memcpy() */
+#include &lt;errno.h&gt;   /*  errno */
 #include &lt;netinet/in.h&gt;  /*  htons(),htonl() */
-#include &lt;unistd.h&gt;		 /*  select() */
-#include &lt;stdlib.h&gt;		 /*  getenv(),atoi(), malloc() */
+#include &lt;unistd.h&gt;   /*  select() */
+#include &lt;stdlib.h&gt;   /*  getenv(),atoi(), malloc() */
 #ifdef WIN32
 #define uint32_t uint32_t  /*  sohn */
 #else
-#include &lt;netdb.h&gt;		 /*  gethostbyname()  */
+#include &lt;netdb.h&gt;   /*  gethostbyname()  */
 #endif
 
-#define MF_LEN	65530	 /*  maximum fragmentation length */
+#define MF_LEN 65530  /*  maximum fragmentation length */
 /*  creates a new object */
 int s3d_new_object()
 {
 	int oid;
 
 	cb_lock++; /* please, no callbacks now. */
-	oid=_queue_want_object();
+	oid = _queue_want_object();
 	cb_lock--; /* no new callbacks and nothing happened */
 	return(oid);
 }
@@ -51,8 +51,8 @@
 int s3d_clone(int oid)
 {
 	uint32_t res;
-	res=s3d_new_object();
-	s3d_clone_target(res,oid);
+	res = s3d_new_object();
+	s3d_clone_target(res, oid);
 	return(res);
 }
 
@@ -60,17 +60,17 @@
 int s3d_clone_target(int oid, int toid)
 {
 	uint32_t buf[2];
-	buf[0]=htonl(oid);
-	buf[1]=htonl(toid);
-	net_send(S3D_P_C_CLONE,(char *)&amp;buf,8);
-	/* 	s3dprintf(MED,&quot;... changed clone-target of object %d to %d&quot;, oid, toid); */
+	buf[0] = htonl(oid);
+	buf[1] = htonl(toid);
+	net_send(S3D_P_C_CLONE, (char *)&amp;buf, 8);
+	/*  s3dprintf(MED,&quot;... changed clone-target of object %d to %d&quot;, oid, toid); */
 	return oid;
 }
 /*  deletes an object */
 int s3d_del_object(int oid)
 {
-	uint32_t res=htonl(oid);
-	net_send(S3D_P_C_DEL_OBJ,(char *)&amp;res,4);
+	uint32_t res = htonl(oid);
+	net_send(S3D_P_C_DEL_OBJ, (char *)&amp;res, 4);
 	return oid;
 }
 /*  creates a link from object oid_from to object oid_to in order to copy */
@@ -78,17 +78,17 @@
 int s3d_link(int oid_from, int oid_to)
 {
 	uint32_t buf[2];
-	buf[0]=htonl(oid_from);
-	buf[1]=htonl(oid_to);
-	net_send(S3D_P_C_LINK,(char *)buf,8);
+	buf[0] = htonl(oid_from);
+	buf[1] = htonl(oid_to);
+	net_send(S3D_P_C_LINK, (char *)buf, 8);
 	return(0);
 }
 /*  remove the link to another object */
 int s3d_unlink(int oid)
 {
 	uint32_t buf;
-	buf=htonl(oid);
-	net_send(S3D_P_C_LINK,(char *)&amp;buf,4);
+	buf = htonl(oid);
+	net_send(S3D_P_C_LINK, (char *)&amp;buf, 4);
 	return(0);
 }
 /*  pushing functions */
@@ -96,18 +96,18 @@
 /*  has float always the same size? i'm not quite sure ... */
 int s3d_push_vertex(int object, float x, float y, float z)
 {
-	char				buf[4+3*4],*ptr;
-	int					len=4+3*4;
+	char    buf[4+3*4], *ptr;
+	int     len = 4 + 3 * 4;
 
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=x;
-	ptr+=sizeof(float);
-	*((float *)ptr)=y;
-	ptr+=sizeof(float);
-	*((float *)ptr)=z;
-	ptr+=sizeof(float);
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((float *)ptr) = x;
+	ptr += sizeof(float);
+	*((float *)ptr) = y;
+	ptr += sizeof(float);
+	*((float *)ptr) = z;
+	ptr += sizeof(float);
 	net_send(S3D_P_C_PUSH_VERTEX, buf, len);
 	return(0);
 }
@@ -115,173 +115,173 @@
 /*  it's to be used for file readers or fast coders :) */
 int s3d_push_vertices(int object, float *vbuf, uint16_t n)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int					f,i,len=n*4*3;
-	int					flen,stepl;
-	if (n&lt;1)
+	char    buf[MF_LEN+4], *ptr;
+	int     f, i, len = n * 4 * 3;
+	int     flen, stepl;
+	if (n &lt; 1)
 		return(-1);
-	stepl=((int)((MF_LEN-4)/(4*3)))*(4*3);
-	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
-	/* 	buf=malloc(f&gt;1?MF_LEN:len+4); */
-	for (i=0;i&lt;f;i++) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		if (len-i*stepl&gt;stepl)
-			flen=stepl;
+	stepl = ((int)((MF_LEN - 4) / (4 * 3))) * (4 * 3);
+	f = len / (MF_LEN - 4) + 1;  /*  how many fragments? */
+	/*  buf=malloc(f&gt;1?MF_LEN:len+4); */
+	for (i = 0;i &lt; f;i++) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		if (len - i*stepl &gt; stepl)
+			flen = stepl;
 		else
-			flen=(len-i*stepl);
-		memcpy(ptr,(char *)vbuf+i*stepl,flen);
-		net_send(S3D_P_C_PUSH_VERTEX,buf,flen+4);
+			flen = (len - i * stepl);
+		memcpy(ptr, (char *)vbuf + i*stepl, flen);
+		net_send(S3D_P_C_PUSH_VERTEX, buf, flen + 4);
 	}
-	/* 	free(buf); */
+	/*  free(buf); */
 	return(0);
 }
 
 /*  pushes a new material onto the stack */
 /*  a vectored version of this would be wise ... */
-int s3d_push_material( int object,
-                       float amb_r, float amb_g, float amb_b,
-                       float spec_r, float spec_g, float spec_b,
-                       float diff_r, float diff_g, float diff_b
+int s3d_push_material(int object,
+                      float amb_r, float amb_g, float amb_b,
+                      float spec_r, float spec_g, float spec_b,
+                      float diff_r, float diff_g, float diff_b
                      )
 {
-	char				buf[4+4*12];
-	char				*ptr;
-	int					len=4+4*12;
-	/* 	s3dprintf(LOW, &quot;adding a new material...&quot;); */
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=1.0;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=1.0;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=1.0;
-	ptr+=sizeof(float);
+	char    buf[4+4*12];
+	char    *ptr;
+	int     len = 4 + 4 * 12;
+	/*  s3dprintf(LOW, &quot;adding a new material...&quot;); */
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((float *)ptr) = amb_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = 1.0;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = 1.0;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = 1.0;
+	ptr += sizeof(float);
 
-	net_send(S3D_P_C_PUSH_MAT,buf,len);
+	net_send(S3D_P_C_PUSH_MAT, buf, len);
 	return(0);  /*  nothing yet */
 }
 /*  same as s3d_push_material, but with values for alpha */
-int s3d_push_material_a( int object,
-                         float amb_r, float amb_g, float amb_b, float amb_a,
-                         float spec_r, float spec_g, float spec_b, float spec_a,
-                         float diff_r, float diff_g, float diff_b, float diff_a
+int s3d_push_material_a(int object,
+                        float amb_r, float amb_g, float amb_b, float amb_a,
+                        float spec_r, float spec_g, float spec_b, float spec_a,
+                        float diff_r, float diff_g, float diff_b, float diff_a
                        )
 {
-	char				buf[4+4*12];
-	char				*ptr;
-	int					len=4+4*12;
-	/* 	s3dprintf(LOW, &quot;adding a new material...&quot;); */
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_a;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_a;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_a;
-	ptr+=sizeof(float);
+	char    buf[4+4*12];
+	char    *ptr;
+	int     len = 4 + 4 * 12;
+	/*  s3dprintf(LOW, &quot;adding a new material...&quot;); */
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((float *)ptr) = amb_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_a;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_a;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_a;
+	ptr += sizeof(float);
 
-	net_send(S3D_P_C_PUSH_MAT,buf,len);
+	net_send(S3D_P_C_PUSH_MAT, buf, len);
 	return(0);  /*  nothing yet */
 }
 /*  push a material array (with alpha information!) */
 int s3d_push_materials_a(int object, float *mbuf, uint16_t n)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int					f,i,len=n*4*12;
-	int					flen,stepl;
-	if (n&lt;1)
+	char    buf[MF_LEN+4], *ptr;
+	int     f, i, len = n * 4 * 12;
+	int     flen, stepl;
+	if (n &lt; 1)
 		return(-1);
-	stepl=((int)((MF_LEN-4)/(4*12)))*(4*12);
-	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
-	/* 	buf=malloc(f&gt;1?MF_LEN:len+4); */
-	for (i=0;i&lt;f;i++) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		if (len-i*stepl&gt;stepl)
-			flen=stepl;
+	stepl = ((int)((MF_LEN - 4) / (4 * 12))) * (4 * 12);
+	f = len / (MF_LEN - 4) + 1;  /*  how many fragments? */
+	/*  buf=malloc(f&gt;1?MF_LEN:len+4); */
+	for (i = 0;i &lt; f;i++) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		if (len - i*stepl &gt; stepl)
+			flen = stepl;
 		else
-			flen=(len-i*stepl);
-		memcpy(ptr,(char *)mbuf+i*stepl,flen);
-		net_send(S3D_P_C_PUSH_MAT,buf,flen+4);
+			flen = (len - i * stepl);
+		memcpy(ptr, (char *)mbuf + i*stepl, flen);
+		net_send(S3D_P_C_PUSH_MAT, buf, flen + 4);
 	}
-	/* 	free(buf); */
+	/*  free(buf); */
 	return(0);
 }
 int s3d_push_polygon(int object, uint32_t v1, uint32_t v2, uint32_t v3, uint32_t material)
 {
-	char				buf[4+4*4],*ptr;
-	int					len=4+4*4;
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(v1);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v2);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v3);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(material);
-	ptr+=sizeof(uint32_t);
+	char    buf[4+4*4], *ptr;
+	int     len = 4 + 4 * 4;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((uint32_t *)ptr) = htonl(v1);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(v2);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(v3);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(material);
+	ptr += sizeof(uint32_t);
 
-	net_send(S3D_P_C_PUSH_POLY,buf,len);
+	net_send(S3D_P_C_PUSH_POLY, buf, len);
 	return(0);
 }
 int s3d_push_line(int object, uint32_t v1, uint32_t v2, uint32_t material)
 {
-	char				buf[4+3*4],*ptr;
-	int					len=4+3*4;
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(v1);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v2);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(material);
-	ptr+=sizeof(uint32_t);
+	char    buf[4+3*4], *ptr;
+	int     len = 4 + 3 * 4;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((uint32_t *)ptr) = htonl(v1);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(v2);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(material);
+	ptr += sizeof(uint32_t);
 
-	net_send(S3D_P_C_PUSH_LINE,buf,len);
+	net_send(S3D_P_C_PUSH_LINE, buf, len);
 	return(0);
 }
 
@@ -289,91 +289,91 @@
 /*  assumes to have a list of polys which consists of v1,v2,v3,material */
 int s3d_push_polygons(int object, uint32_t *pbuf, uint16_t n)
 {
-	uint32_t		buf[(MF_LEN+4)/4];
-	uint32_t		*s,*d;
-	int					f,i,j,len=n*4*4;
-	int					flen,stepl;
-	if (n&lt;1)
+	uint32_t  buf[(MF_LEN+4)/4];
+	uint32_t  *s, *d;
+	int     f, i, j, len = n * 4 * 4;
+	int     flen, stepl;
+	if (n &lt; 1)
 		return(-1);
-	stepl=((int)((MF_LEN-4)/(4*4)))*(4*4);
-	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
+	stepl = ((int)((MF_LEN - 4) / (4 * 4))) * (4 * 4);
+	f = len / (MF_LEN - 4) + 1;  /*  how many fragments? */
 
-	buf[0]=htonl(object);
-	d=buf+1;
-	for (i=0;i&lt;f;i++) {
-		if (len-i*stepl&gt;stepl)			flen=stepl;
-		else							flen=(len-i*stepl);
+	buf[0] = htonl(object);
+	d = buf + 1;
+	for (i = 0;i &lt; f;i++) {
+		if (len - i*stepl &gt; stepl)   flen = stepl;
+		else       flen = (len - i * stepl);
 
-		s=pbuf+i*stepl/4;
-		for (j=0;j&lt;flen/4;j++)
-			d[j]=htonl(s[j]);
-		net_send(S3D_P_C_PUSH_POLY,(char *)buf,flen+4);
+		s = pbuf + i * stepl / 4;
+		for (j = 0;j &lt; flen / 4;j++)
+			d[j] = htonl(s[j]);
+		net_send(S3D_P_C_PUSH_POLY, (char *)buf, flen + 4);
 	}
 	return(0);
 }
 int s3d_push_lines(int object, uint32_t *lbuf, uint16_t n)
 {
-	uint32_t		buf[(MF_LEN+4)/4];
-	uint32_t		*s,*d;
-	int					f,i,j,len=n*4*3;
-	int					flen,stepl;
-	if (n&lt;1)
+	uint32_t  buf[(MF_LEN+4)/4];
+	uint32_t  *s, *d;
+	int     f, i, j, len = n * 4 * 3;
+	int     flen, stepl;
+	if (n &lt; 1)
 		return(-1);
-	stepl=((int)((MF_LEN-4)/(4*3)))*(4*3);
-	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
+	stepl = ((int)((MF_LEN - 4) / (4 * 3))) * (4 * 3);
+	f = len / (MF_LEN - 4) + 1;  /*  how many fragments? */
 
-	buf[0]=htonl(object);
-	d=buf+1;
+	buf[0] = htonl(object);
+	d = buf + 1;
 
-	for (i=0;i&lt;f;i++) {
-		if (len-i*stepl&gt;stepl)			flen=stepl;
-		else							flen=(len-i*stepl);
+	for (i = 0;i &lt; f;i++) {
+		if (len - i*stepl &gt; stepl)   flen = stepl;
+		else       flen = (len - i * stepl);
 
-		s=lbuf+i*stepl/4;
-		for (j=0;j&lt;flen/4;j++)
-			d[j]=htonl(s[j]);
+		s = lbuf + i * stepl / 4;
+		for (j = 0;j &lt; flen / 4;j++)
+			d[j] = htonl(s[j]);
 
-		net_send(S3D_P_C_PUSH_LINE,(char *)buf,flen+4);
+		net_send(S3D_P_C_PUSH_LINE, (char *)buf, flen + 4);
 	}
 	return(0);
 }
 int s3d_push_texture(int object, uint16_t w, uint16_t h)
 {
-	char				buf[4+2*2],*ptr;
-	int					len=4+2*2;
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint16_t *)ptr)=htons(w);
-	ptr+=sizeof(uint16_t);
-	*((uint16_t *)ptr)=htons(h);
+	char    buf[4+2*2], *ptr;
+	int     len = 4 + 2 * 2;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((uint16_t *)ptr) = htons(w);
+	ptr += sizeof(uint16_t);
+	*((uint16_t *)ptr) = htons(h);
 
-	net_send(S3D_P_C_PUSH_TEX,buf,len);
+	net_send(S3D_P_C_PUSH_TEX, buf, len);
 	return(0);
 }
 int s3d_push_textures(int object, uint16_t *tbuf, uint16_t n)
 {
-	uint32_t		buf[(MF_LEN+4)/4];
-	uint16_t		*s,*d;
+	uint32_t  buf[(MF_LEN+4)/4];
+	uint16_t  *s, *d;
 
-	int					f,i,j,len=n*2*2;
-	int					flen,stepl;
-	if (n&lt;1)
+	int     f, i, j, len = n * 2 * 2;
+	int     flen, stepl;
+	if (n &lt; 1)
 		return(-1);
-	stepl=((int)((MF_LEN-4)/(2*2)))*(2*2);
-	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
+	stepl = ((int)((MF_LEN - 4) / (2 * 2))) * (2 * 2);
+	f = len / (MF_LEN - 4) + 1;  /*  how many fragments? */
 
-	*((uint32_t *)buf)=htonl(object);
-	d=(uint16_t *)(buf+1);
+	*((uint32_t *)buf) = htonl(object);
+	d = (uint16_t *)(buf + 1);
 
-	for (i=0;i&lt;f;i++) {
-		if (len-i*stepl&gt;stepl)			flen=stepl;
-		else							flen=(len-i*stepl);
+	for (i = 0;i &lt; f;i++) {
+		if (len - i*stepl &gt; stepl)   flen = stepl;
+		else       flen = (len - i * stepl);
 
-		s=tbuf+i*stepl/2;
-		for (j=0;j&lt;flen/2;j++)
-			d[j]=htons(s[j]);
-		net_send(S3D_P_C_PUSH_POLY,(char *)buf,flen+4);
+		s = tbuf + i * stepl / 2;
+		for (j = 0;j &lt; flen / 2;j++)
+			d[j] = htons(s[j]);
+		net_send(S3D_P_C_PUSH_POLY, (char *)buf, flen + 4);
 	}
 	return(0);
 }
@@ -382,516 +382,516 @@
 /*  delete n vertices */
 int s3d_pop_vertex(int object, uint32_t n)
 {
-	uint32_t		buf[2];
-	buf[0]=htonl(object);
-	buf[1]=htonl(n);
-	net_send(S3D_P_C_DEL_VERTEX,(char *)buf,4*2);
+	uint32_t  buf[2];
+	buf[0] = htonl(object);
+	buf[1] = htonl(n);
+	net_send(S3D_P_C_DEL_VERTEX, (char *)buf, 4*2);
 	return(0);
 
 }
 /*  delete n materials */
 int s3d_pop_material(int object, uint32_t n)
 {
-	uint32_t		buf[2];
-	buf[0]=htonl(object);
-	buf[1]=htonl(n);
-	net_send(S3D_P_C_DEL_MAT,(char *)buf,4*2);
+	uint32_t  buf[2];
+	buf[0] = htonl(object);
+	buf[1] = htonl(n);
+	net_send(S3D_P_C_DEL_MAT, (char *)buf, 4*2);
 	return(0);
 
 }
 /*  delete n polygons */
 int s3d_pop_polygon(int object, uint32_t n)
 {
-	uint32_t		buf[2];
-	buf[0]=htonl(object);
-	buf[1]=htonl(n);
-	net_send(S3D_P_C_DEL_POLY,(char *)buf,4*2);
+	uint32_t  buf[2];
+	buf[0] = htonl(object);
+	buf[1] = htonl(n);
+	net_send(S3D_P_C_DEL_POLY, (char *)buf, 4*2);
 	return(0);
 
 }
 /*  delete n lines */
 int s3d_pop_line(int object, uint32_t n)
 {
-	uint32_t		buf[2];
-	buf[0]=htonl(object);
-	buf[1]=htonl(n);
-	net_send(S3D_P_C_DEL_LINE,(char *)buf,4*2);
+	uint32_t  buf[2];
+	buf[0] = htonl(object);
+	buf[1] = htonl(n);
+	net_send(S3D_P_C_DEL_LINE, (char *)buf, 4*2);
 	return(0);
 
 }
 /*  delete n polygons */
 int s3d_pop_texture(int object, uint32_t n)
 {
-	uint32_t		buf[2];
-	buf[0]=htonl(object);
-	buf[1]=htonl(n);
-	net_send(S3D_P_C_DEL_TEX,(char *)buf,4*2);
+	uint32_t  buf[2];
+	buf[0] = htonl(object);
+	buf[1] = htonl(n);
+	net_send(S3D_P_C_DEL_TEX, (char *)buf, 4*2);
 	return(0);
 
 }
 /*  pepping/loading functions */
 
 /*  overwrites the last material with this one */
-int s3d_pep_material( int object,
-                      float amb_r, float amb_g, float amb_b,
-                      float spec_r, float spec_g, float spec_b,
-                      float diff_r, float diff_g, float diff_b
+int s3d_pep_material(int object,
+                     float amb_r, float amb_g, float amb_b,
+                     float spec_r, float spec_g, float spec_b,
+                     float diff_r, float diff_g, float diff_b
                     )
 {
-	char				buf[4+4*12];
-	char				*ptr;
-	int					len=4+4*12;
-	/* 	s3dprintf(LOW, &quot;adding a new material...&quot;); */
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=1.0;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=1.0;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=1.0;
-	ptr+=sizeof(float);
+	char    buf[4+4*12];
+	char    *ptr;
+	int     len = 4 + 4 * 12;
+	/*  s3dprintf(LOW, &quot;adding a new material...&quot;); */
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((float *)ptr) = amb_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = 1.0;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = 1.0;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = 1.0;
+	ptr += sizeof(float);
 
-	net_send(S3D_P_C_PEP_MAT,buf,len);
+	net_send(S3D_P_C_PEP_MAT, buf, len);
 	return(0);  /*  nothing yet */
 }
 /*  same as above, with alpha */
-int s3d_pep_material_a( int object,
-                        float amb_r, float amb_g, float amb_b, float amb_a,
-                        float spec_r, float spec_g, float spec_b, float spec_a,
-                        float diff_r, float diff_g, float diff_b, float diff_a
+int s3d_pep_material_a(int object,
+                       float amb_r, float amb_g, float amb_b, float amb_a,
+                       float spec_r, float spec_g, float spec_b, float spec_a,
+                       float diff_r, float diff_g, float diff_b, float diff_a
                       )
 {
-	char				buf[4+4*12];
-	char				*ptr;
-	int					len=4+4*12;
-	/* 	s3dprintf(LOW, &quot;adding a new material...&quot;); */
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_a;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_a;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_a;
-	ptr+=sizeof(float);
+	char    buf[4+4*12];
+	char    *ptr;
+	int     len = 4 + 4 * 12;
+	/*  s3dprintf(LOW, &quot;adding a new material...&quot;); */
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((float *)ptr) = amb_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_a;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_a;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_a;
+	ptr += sizeof(float);
 
-	net_send(S3D_P_C_PEP_MAT,buf,len);
+	net_send(S3D_P_C_PEP_MAT, buf, len);
 	return(0);  /*  nothing yet */
 }
 int s3d_pep_materials_a(int object, float *mbuf, uint16_t n)
 {
-	char				buf[MF_LEN+4];
-	if ((n*12*sizeof(float)+4)&gt;MF_LEN) {
-		errds(MED,&quot;s3d_pep_materials_a()&quot;,&quot;too much data&quot;);
+	char    buf[MF_LEN+4];
+	if ((n*12*sizeof(float) + 4) &gt; MF_LEN) {
+		errds(MED, &quot;s3d_pep_materials_a()&quot;, &quot;too much data&quot;);
 		return(-1);  /*  impossible */
 	}
-	*((uint32_t *)buf)=htonl(object);			 /*  object id */
-	memcpy(buf+4,mbuf,12*n*sizeof(float));
-	net_send(S3D_P_C_PEP_MAT,buf,n*12*sizeof(float)+4);
+	*((uint32_t *)buf) = htonl(object);  /*  object id */
+	memcpy(buf + 4, mbuf, 12*n*sizeof(float));
+	net_send(S3D_P_C_PEP_MAT, buf, n*12*sizeof(float) + 4);
 	return(0);
 }
 
 /*  adds normal information to the last n polygons. */
-int s3d_pep_polygon_normals(int object, float *nbuf,uint16_t n)
+int s3d_pep_polygon_normals(int object, float *nbuf, uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
-	if ((n*9*sizeof(float)+4)&gt;MF_LEN) {
-		errds(MED,&quot;s3d_pep_polygon_normals()&quot;,&quot;too much data&quot;);
+	if ((n*9*sizeof(float) + 4) &gt; MF_LEN) {
+		errds(MED, &quot;s3d_pep_polygon_normals()&quot;, &quot;too much data&quot;);
 		return(-1);  /*  impossible */
 	}
-	*((uint32_t *)buf)=htonl(object);
-	memcpy(buf+4,nbuf,9*n*sizeof(float));
-	net_send(S3D_P_C_PEP_POLY_NORMAL,(char *)buf,n*9*sizeof(float)+4);
+	*((uint32_t *)buf) = htonl(object);
+	memcpy(buf + 4, nbuf, 9*n*sizeof(float));
+	net_send(S3D_P_C_PEP_POLY_NORMAL, (char *)buf, n*9*sizeof(float) + 4);
 	return(0);
 
 }
 /*  adds normal information to the last n line. */
-int s3d_pep_line_normals(int object, float *nbuf,uint16_t n)
+int s3d_pep_line_normals(int object, float *nbuf, uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
-	if ((n*9*sizeof(float)+4)&gt;MF_LEN) {
-		errds(MED,&quot;s3d_pep_line_normals()&quot;,&quot;too much data&quot;);
+	if ((n*9*sizeof(float) + 4) &gt; MF_LEN) {
+		errds(MED, &quot;s3d_pep_line_normals()&quot;, &quot;too much data&quot;);
 		return(-1);  /*  impossible */
 	}
-	*((uint32_t *)buf)=htonl(object);
-	memcpy(buf+4,nbuf,6*n*sizeof(float));
-	net_send(S3D_P_C_PEP_LINE_NORMAL,(char *)buf,n*6*sizeof(float)+4);
+	*((uint32_t *)buf) = htonl(object);
+	memcpy(buf + 4, nbuf, 6*n*sizeof(float));
+	net_send(S3D_P_C_PEP_LINE_NORMAL, (char *)buf, n*6*sizeof(float) + 4);
 	return(0);
 
 }
 /*  replaces the last vertex. */
 int s3d_pep_vertex(int object, float x, float y, float z)
 {
-	char				buf[4+3*4],*ptr;
-	int					len=4+3*4;
+	char    buf[4+3*4], *ptr;
+	int     len = 4 + 3 * 4;
 
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=x;
-	ptr+=sizeof(float);
-	*((float *)ptr)=y;
-	ptr+=sizeof(float);
-	*((float *)ptr)=z;
-	ptr+=sizeof(float);
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((float *)ptr) = x;
+	ptr += sizeof(float);
+	*((float *)ptr) = y;
+	ptr += sizeof(float);
+	*((float *)ptr) = z;
+	ptr += sizeof(float);
 	net_send(S3D_P_C_PEP_VERTEX, buf, len);
 	return(0);
 }
 /* replaces the last line */
 int s3d_pep_line(int object, int v1, int v2, int material)
 {
-	char				buf[4+3*4],*ptr;
-	int					len=4+3*4;
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(v1);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v2);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(material);
-	ptr+=sizeof(uint32_t);
+	char    buf[4+3*4], *ptr;
+	int     len = 4 + 3 * 4;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((uint32_t *)ptr) = htonl(v1);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(v2);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(material);
+	ptr += sizeof(uint32_t);
 
-	net_send(S3D_P_C_PEP_LINE,buf,len);
+	net_send(S3D_P_C_PEP_LINE, buf, len);
 	return(0);
 }
 
 
 /*  replaces the last n lines. */
-int s3d_pep_lines(int object, uint32_t *lbuf,uint16_t n)
+int s3d_pep_lines(int object, uint32_t *lbuf, uint16_t n)
 {
-	uint32_t 	buf[MF_LEN+4];
-	int				i;
-	if ((n*3*4+4)&gt;MF_LEN) {
-		errds(MED,&quot;s3d_pep_lines()&quot;,&quot;too much data&quot;);
+	uint32_t  buf[MF_LEN+4];
+	int    i;
+	if ((n*3*4 + 4) &gt; MF_LEN) {
+		errds(MED, &quot;s3d_pep_lines()&quot;, &quot;too much data&quot;);
 		return(-1);  /*  impossible */
 	}
-	buf[0]=htonl(object);
-	for (i=0;i&lt;3*n;i++)
-		buf[i+1]=htonl(lbuf[0]);
-	net_send(S3D_P_C_PEP_LINE, (char *)buf,n*3*4+4);
+	buf[0] = htonl(object);
+	for (i = 0;i &lt; 3*n;i++)
+		buf[i+1] = htonl(lbuf[0]);
+	net_send(S3D_P_C_PEP_LINE, (char *)buf, n*3*4 + 4);
 	return(0);
 
 }
 /*  replaces the last n vertices. */
-int s3d_pep_vertices(int object, float *vbuf,uint16_t n)
+int s3d_pep_vertices(int object, float *vbuf, uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
-	if ((n*3*sizeof(float)+4)&gt;MF_LEN) {
-		errds(MED,&quot;s3d_pep_vertices()&quot;,&quot;too much data&quot;);
+	if ((n*3*sizeof(float) + 4) &gt; MF_LEN) {
+		errds(MED, &quot;s3d_pep_vertices()&quot;, &quot;too much data&quot;);
 		return(-1);  /*  impossible */
 	}
-	*((uint32_t *)buf)=htonl(object);
-	memcpy(buf+4,vbuf,3*n*sizeof(float));
-	net_send(S3D_P_C_PEP_VERTEX,(char *)buf,n*3*sizeof(float)+4);
+	*((uint32_t *)buf) = htonl(object);
+	memcpy(buf + 4, vbuf, 3*n*sizeof(float));
+	net_send(S3D_P_C_PEP_VERTEX, (char *)buf, n*3*sizeof(float) + 4);
 	return(0);
 
 }
 /*  peps the last polygon with some texture coords */
 int s3d_pep_polygon_tex_coord(int object, float x1, float y1, float x2, float y2, float x3, float y3)
 {
-	char *ptr,buf[4*6+4];
-	ptr=buf;
-	*((uint32_t *)buf)=htonl(object);
-	ptr+=4;
-	*((float *)ptr)=x1;
-	ptr+=4;
-	*((float *)ptr)=y1;
-	ptr+=4;
-	*((float *)ptr)=x2;
-	ptr+=4;
-	*((float *)ptr)=y2;
-	ptr+=4;
-	*((float *)ptr)=x3;
-	ptr+=4;
-	*((float *)ptr)=y3;
-	ptr+=4;
-	net_send(S3D_P_C_PEP_POLY_TEXC,(char *)buf,6*4+4);
+	char *ptr, buf[4*6+4];
+	ptr = buf;
+	*((uint32_t *)buf) = htonl(object);
+	ptr += 4;
+	*((float *)ptr) = x1;
+	ptr += 4;
+	*((float *)ptr) = y1;
+	ptr += 4;
+	*((float *)ptr) = x2;
+	ptr += 4;
+	*((float *)ptr) = y2;
+	ptr += 4;
+	*((float *)ptr) = x3;
+	ptr += 4;
+	*((float *)ptr) = y3;
+	ptr += 4;
+	net_send(S3D_P_C_PEP_POLY_TEXC, (char *)buf, 6*4 + 4);
 	return(0);
 }
 /*  adds texture coordinates to the last n polygons. */
-int s3d_pep_polygon_tex_coords(int object, float *tbuf,uint16_t n)
+int s3d_pep_polygon_tex_coords(int object, float *tbuf, uint16_t n)
 {
 	char buf[MF_LEN+4];
-	if ((n*6*sizeof(float))&gt;MF_LEN) {
-		errds(MED,&quot;s3d_pep_polygon_tex_coords()&quot;,&quot;too much data&quot;);
+	if ((n*6*sizeof(float)) &gt; MF_LEN) {
+		errds(MED, &quot;s3d_pep_polygon_tex_coords()&quot;, &quot;too much data&quot;);
 		return(-1);  /*  impossible */
 	}
-	*((uint32_t *)buf)=htonl(object);
-	memcpy(buf+4,tbuf,6*n*sizeof(float));
-	net_send(S3D_P_C_PEP_POLY_TEXC,(char *)buf,n*6*sizeof(float)+4);
+	*((uint32_t *)buf) = htonl(object);
+	memcpy(buf + 4, tbuf, 6*n*sizeof(float));
+	net_send(S3D_P_C_PEP_POLY_TEXC, (char *)buf, n*6*sizeof(float) + 4);
 	return(0);
 }
 /*  adds normal information to the last n polygons. */
-int s3d_load_polygon_normals(int object, float *nbuf,uint32_t start, uint16_t n)
+int s3d_load_polygon_normals(int object, float *nbuf, uint32_t start, uint16_t n)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int					f,i,len=n*9*4;
-	int					flen,stepl;
-	uint32_t			mstart;
-	if (n&lt;1)
+	char    buf[MF_LEN+4], *ptr;
+	int     f, i, len = n * 9 * 4;
+	int     flen, stepl;
+	uint32_t   mstart;
+	if (n &lt; 1)
 		return(-1);
-	mstart=start;
-	stepl=((int)((MF_LEN-8)/(9*4)))*(9*4);
-	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i&lt;f;i++) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);
-		ptr+=sizeof(uint32_t);		  /*  start */
-		if (len-i*stepl&gt;stepl)
-			flen=stepl;
+	mstart = start;
+	stepl = ((int)((MF_LEN - 8) / (9 * 4))) * (9 * 4);
+	f = len / (MF_LEN - 8) + 1;  /*  how many fragments? */
+	for (i = 0;i &lt; f;i++) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		*((uint32_t *)ptr) = htonl(mstart);
+		ptr += sizeof(uint32_t);  /*  start */
+		if (len - i*stepl &gt; stepl)
+			flen = stepl;
 		else
-			flen=(len-i*stepl);
-		memcpy(ptr,(char *)nbuf+i*stepl,flen);
-		net_send(S3D_P_C_PEP_POLY_NORMAL,buf,flen+8);
-		mstart+=stepl;
+			flen = (len - i * stepl);
+		memcpy(ptr, (char *)nbuf + i*stepl, flen);
+		net_send(S3D_P_C_PEP_POLY_NORMAL, buf, flen + 8);
+		mstart += stepl;
 	}
 	return(0);
 }
 /*  adds normal information to the last n polygons. */
-int s3d_load_line_normals(int object, float *nbuf,uint32_t start, uint16_t n)
+int s3d_load_line_normals(int object, float *nbuf, uint32_t start, uint16_t n)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int					f,i,len=n*6*4;
-	int					flen,stepl;
-	uint32_t			mstart;
-	if (n&lt;1)
+	char    buf[MF_LEN+4], *ptr;
+	int     f, i, len = n * 6 * 4;
+	int     flen, stepl;
+	uint32_t   mstart;
+	if (n &lt; 1)
 		return(-1);
-	mstart=start;
-	stepl=((int)((MF_LEN-8)/(6*4)))*(6*4);
-	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i&lt;f;i++) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);
-		ptr+=sizeof(uint32_t);		  /*  start */
-		if (len-i*stepl&gt;stepl)
-			flen=stepl;
+	mstart = start;
+	stepl = ((int)((MF_LEN - 8) / (6 * 4))) * (6 * 4);
+	f = len / (MF_LEN - 8) + 1;  /*  how many fragments? */
+	for (i = 0;i &lt; f;i++) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		*((uint32_t *)ptr) = htonl(mstart);
+		ptr += sizeof(uint32_t);  /*  start */
+		if (len - i*stepl &gt; stepl)
+			flen = stepl;
 		else
-			flen=(len-i*stepl);
-		memcpy(ptr,(char *)nbuf+i*stepl,flen);
-		net_send(S3D_P_C_PEP_LINE_NORMAL,buf,flen+8);
-		mstart+=stepl;
+			flen = (len - i * stepl);
+		memcpy(ptr, (char *)nbuf + i*stepl, flen);
+		net_send(S3D_P_C_PEP_LINE_NORMAL, buf, flen + 8);
+		mstart += stepl;
 	}
 	return(0);
 }
 /*  adds texture coordinates to the last n polygons. */
 int s3d_load_polygon_tex_coords(int object, float *tbuf, uint32_t start, uint16_t n)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int					f,i,len=n*6*4;
-	int					flen,stepl;
-	uint32_t			mstart;
-	if (n&lt;1)
+	char    buf[MF_LEN+4], *ptr;
+	int     f, i, len = n * 6 * 4;
+	int     flen, stepl;
+	uint32_t   mstart;
+	if (n &lt; 1)
 		return(-1);
-	mstart=start;
-	stepl=((int)((MF_LEN-8)/(6*4)))*(6*4);
-	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i&lt;f;i++) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);
-		ptr+=sizeof(uint32_t);		  /*  start */
-		if (len-i*stepl&gt;stepl)
-			flen=stepl;
+	mstart = start;
+	stepl = ((int)((MF_LEN - 8) / (6 * 4))) * (6 * 4);
+	f = len / (MF_LEN - 8) + 1;  /*  how many fragments? */
+	for (i = 0;i &lt; f;i++) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		*((uint32_t *)ptr) = htonl(mstart);
+		ptr += sizeof(uint32_t);  /*  start */
+		if (len - i*stepl &gt; stepl)
+			flen = stepl;
 		else
-			flen=(len-i*stepl);
-		memcpy(ptr,(char *)tbuf+i*stepl,flen);
-		net_send(S3D_P_C_PEP_POLY_TEXC,buf,flen+8);
-		mstart+=stepl;
+			flen = (len - i * stepl);
+		memcpy(ptr, (char *)tbuf + i*stepl, flen);
+		net_send(S3D_P_C_PEP_POLY_TEXC, buf, flen + 8);
+		mstart += stepl;
 	}
 	return(0);
 }
 /*  load n materials at position start, overwriting old ones */
 int s3d_load_materials_a(int object, float *mbuf, uint32_t start, uint16_t n)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int					f,i,len=n*12*4;
-	int					flen,stepl;
-	uint32_t			mstart;
-	if (n&lt;1)
+	char    buf[MF_LEN+4], *ptr;
+	int     f, i, len = n * 12 * 4;
+	int     flen, stepl;
+	uint32_t   mstart;
+	if (n &lt; 1)
 		return(-1);
-	mstart=start;
-	stepl=((int)((MF_LEN-8)/(12*4)))*(12*4);
-	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i&lt;f;i++) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);
-		ptr+=sizeof(uint32_t);		  /*  start */
-		if (len-i*stepl&gt;stepl)
-			flen=stepl;
+	mstart = start;
+	stepl = ((int)((MF_LEN - 8) / (12 * 4))) * (12 * 4);
+	f = len / (MF_LEN - 8) + 1;  /*  how many fragments? */
+	for (i = 0;i &lt; f;i++) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		*((uint32_t *)ptr) = htonl(mstart);
+		ptr += sizeof(uint32_t);  /*  start */
+		if (len - i*stepl &gt; stepl)
+			flen = stepl;
 		else
-			flen=(len-i*stepl);
-		memcpy(ptr,(char *)mbuf+i*stepl,flen);
-		net_send(S3D_P_C_PEP_MAT,buf,flen+8);
-		mstart+=stepl;
+			flen = (len - i * stepl);
+		memcpy(ptr, (char *)mbuf + i*stepl, flen);
+		net_send(S3D_P_C_PEP_MAT, buf, flen + 8);
+		mstart += stepl;
 	}
 	return(0);
 }
 int s3d_pep_material_texture(int object, uint32_t tex)
 {
-	char				buf[4*2],*ptr;
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(tex);
-	ptr+=sizeof(uint32_t);		 	 /*  texture index numer */
-	net_send(S3D_P_C_PEP_MAT_TEX,buf,8);
+	char    buf[4*2], *ptr;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((uint32_t *)ptr) = htonl(tex);
+	ptr += sizeof(uint32_t);   /*  texture index numer */
+	net_send(S3D_P_C_PEP_MAT_TEX, buf, 8);
 	return(0);
 }
 /*  load data (which has width w and height h) into object, texture tex at position (xpos,ypos) */
 int s3d_load_texture(int object, uint32_t tex, uint16_t xpos, uint16_t ypos, uint16_t w, uint16_t h, uint8_t *data)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int 				linestep,lines,i;
-	linestep=(MF_LEN-16)/(w*4);
-	if (linestep==0)
+	char    buf[MF_LEN+4], *ptr;
+	int     linestep, lines, i;
+	linestep = (MF_LEN - 16) / (w * 4);
+	if (linestep == 0)
 		return(-1);  /*  won't do that. .. yet */
-	for (i=0;i&lt;h;i+=linestep) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(tex);
-		ptr+=sizeof(uint32_t);		  /*  texture number */
-		*((uint16_t *)ptr)=htons(xpos);
-		ptr+=sizeof(uint16_t);		  /*  xpos */
-		*((uint16_t *)ptr)=htons(ypos+i);
-		ptr+=sizeof(uint16_t);		  /*  ypos */
-		*((uint16_t *)ptr)=htons(w);
-		ptr+=sizeof(uint16_t);		  /*  width */
-		if ((h-i)&gt;linestep)		lines=linestep;
-		else					lines=h-i;
-		*((uint16_t *)ptr)=htons(lines);
-		ptr+=sizeof(uint16_t);		  /*  height */
-		memcpy(ptr,data+(i*w*4),lines*w*4);
-		net_send(S3D_P_C_LOAD_TEX,buf,16+lines*w*4);
+	for (i = 0;i &lt; h;i += linestep) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		*((uint32_t *)ptr) = htonl(tex);
+		ptr += sizeof(uint32_t);  /*  texture number */
+		*((uint16_t *)ptr) = htons(xpos);
+		ptr += sizeof(uint16_t);  /*  xpos */
+		*((uint16_t *)ptr) = htons(ypos + i);
+		ptr += sizeof(uint16_t);  /*  ypos */
+		*((uint16_t *)ptr) = htons(w);
+		ptr += sizeof(uint16_t);  /*  width */
+		if ((h - i) &gt; linestep)  lines = linestep;
+		else     lines = h - i;
+		*((uint16_t *)ptr) = htons(lines);
+		ptr += sizeof(uint16_t);  /*  height */
+		memcpy(ptr, data + (i*w*4), lines*w*4);
+		net_send(S3D_P_C_LOAD_TEX, buf, 16 + lines*w*4);
 	}
 	return(0);
 }
 int s3d_flags_on(int object, uint32_t flags)
 {
-	char				buf[4+1+4],*ptr;
-	int					len=4+1+4;
-	ptr=buf;
-	/* 	s3dprintf(VLOW, &quot;toggling flags on .. %010x&quot;, flags); */
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=4;
-	*ptr=OF_TURN_ON;
-	ptr+=1;
-	*((uint32_t *)ptr)=htonl(flags);
-	ptr+=4;
-	net_send(S3D_P_C_TOGGLE_FLAGS,buf,len);
+	char    buf[4+1+4], *ptr;
+	int     len = 4 + 1 + 4;
+	ptr = buf;
+	/*  s3dprintf(VLOW, &quot;toggling flags on .. %010x&quot;, flags); */
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += 4;
+	*ptr = OF_TURN_ON;
+	ptr += 1;
+	*((uint32_t *)ptr) = htonl(flags);
+	ptr += 4;
+	net_send(S3D_P_C_TOGGLE_FLAGS, buf, len);
 	return(0);
 }
 int s3d_flags_off(int object, uint32_t flags)
 {
-	char				buf[4+1+4],*ptr;
-	int					len=4+1+4;
-	ptr=buf;
-	/* 	s3dprintf(VLOW, &quot;toggling flags off .. %010x&quot;, flags); */
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=4;
-	*ptr=OF_TURN_OFF;
-	ptr+=1;
-	*((uint32_t *)ptr)=htonl(flags);
-	ptr+=4;
-	net_send(S3D_P_C_TOGGLE_FLAGS,buf,len);
+	char    buf[4+1+4], *ptr;
+	int     len = 4 + 1 + 4;
+	ptr = buf;
+	/*  s3dprintf(VLOW, &quot;toggling flags off .. %010x&quot;, flags); */
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += 4;
+	*ptr = OF_TURN_OFF;
+	ptr += 1;
+	*((uint32_t *)ptr) = htonl(flags);
+	ptr += 4;
+	net_send(S3D_P_C_TOGGLE_FLAGS, buf, len);
 	return(0);
 }
 int s3d_translate(int object, float x, float y, float z)
 {
-	char				buf[4+4*3],*ptr;
-	int					len=4+4*3;
-	ptr=buf;
-	/* 	s3dprintf(VLOW, &quot;translating object to  .. %f, %f, %f&quot;, x,y,z); */
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=4;
-	*((float *)ptr)=x;
-	ptr+=4;
-	*((float *)ptr)=y;
-	ptr+=4;
-	*((float *)ptr)=z;
-	net_send(S3D_P_C_TRANSLATE,buf,len);
+	char    buf[4+4*3], *ptr;
+	int     len = 4 + 4 * 3;
+	ptr = buf;
+	/*  s3dprintf(VLOW, &quot;translating object to  .. %f, %f, %f&quot;, x,y,z); */
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += 4;
+	*((float *)ptr) = x;
+	ptr += 4;
+	*((float *)ptr) = y;
+	ptr += 4;
+	*((float *)ptr) = z;
+	net_send(S3D_P_C_TRANSLATE, buf, len);
 	return(0);
 
 }
 /*  rotation about the x-axis, y-axis and z-axis */
 int s3d_rotate(int object, float x, float y, float z)
 {
-	char				buf[4+4*3],*ptr;
-	int					len=4+4*3;
-	ptr=buf;
-	/* 	s3dprintf(VLOW, &quot;rotating object to  .. %f, %f, %f&quot;, x,y,z); */
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=4;
-	*((float *)ptr)=x;
-	ptr+=4;
-	*((float *)ptr)=y;
-	ptr+=4;
-	*((float *)ptr)=z;
-	net_send(S3D_P_C_ROTATE,buf,len);
+	char    buf[4+4*3], *ptr;
+	int     len = 4 + 4 * 3;
+	ptr = buf;
+	/*  s3dprintf(VLOW, &quot;rotating object to  .. %f, %f, %f&quot;, x,y,z); */
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += 4;
+	*((float *)ptr) = x;
+	ptr += 4;
+	*((float *)ptr) = y;
+	ptr += 4;
+	*((float *)ptr) = z;
+	net_send(S3D_P_C_ROTATE, buf, len);
 	return(0);
 }
 /*  scale the object .. */
 
 int s3d_scale(int object, float s)
 {
-	char				buf[4+4],*ptr;
-	int					len=4+4;
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=4;
-	*((float *)ptr)=s;
-	net_send(S3D_P_C_SCALE,buf,len);
+	char    buf[4+4], *ptr;
+	int     len = 4 + 4;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += 4;
+	*((float *)ptr) = s;
+	net_send(S3D_P_C_SCALE, buf, len);
 	return(0);
 }
 /*  sets the focused app through it's mcp object number */
 int s3d_mcp_focus(int object)
 {
-	uint32_t buf=htonl(object);
-	net_send(S3D_P_MCP_FOCUS,(char *)&amp;buf,4);
+	uint32_t buf = htonl(object);
+	net_send(S3D_P_MCP_FOCUS, (char *)&amp;buf, 4);
 	return(0);
 }

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/s3d.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -34,37 +34,37 @@
 
 typedef int (*s3d_cb)(struct s3d_evt *);
 
-#define S3D_EVENT_OBJ_CLICK		1
-#define S3D_EVENT_KEY			2
-#define S3D_EVENT_KEYDOWN		2
-#define S3D_EVENT_MBUTTON		3
-#define S3D_EVENT_KEYUP			4
-#define S3D_EVENT_NEW_OBJECT	16
-#define S3D_EVENT_OBJ_INFO		17
+#define S3D_EVENT_OBJ_CLICK  1
+#define S3D_EVENT_KEY   2
+#define S3D_EVENT_KEYDOWN  2
+#define S3D_EVENT_MBUTTON  3
+#define S3D_EVENT_KEYUP   4
+#define S3D_EVENT_NEW_OBJECT 16
+#define S3D_EVENT_OBJ_INFO  17
 
-#define S3D_EVENT_QUIT			255
+#define S3D_EVENT_QUIT   255
 
 /* TODO: don't keep _MCP_ events .. they're ugly */
-#define S3D_MCP_OBJECT			32
-#define S3D_MCP_DEL_OBJECT		33
+#define S3D_MCP_OBJECT   32
+#define S3D_MCP_DEL_OBJECT  33
 
-#define S3D_PORT				6066
+#define S3D_PORT    6066
 
-#define	S3D_OF_VISIBLE			0x00000001
-#define	S3D_OF_SELECTABLE		0x00000002
-#define S3D_OF_POINTABLE		0x00000004
+#define S3D_OF_VISIBLE   0x00000001
+#define S3D_OF_SELECTABLE  0x00000002
+#define S3D_OF_POINTABLE  0x00000004
 struct mcp_object {
 	uint32_t object;
-	float trans_x,trans_y,trans_z;
+	float trans_x, trans_y, trans_z;
 	float r;
-#define MCP_NEW_OBJECT	1
+#define MCP_NEW_OBJECT 1
 	char name[256];
 };
 struct s3d_obj_info {
 	uint32_t object;
 	uint32_t flags;
-	float trans_x,trans_y,trans_z;
-	float rot_x,rot_y,rot_z;
+	float trans_x, trans_y, trans_z;
+	float rot_x, rot_y, rot_z;
 	float scale;
 	float r;
 	char name[256];
@@ -74,10 +74,10 @@
 	uint8_t state;  /* 0 = down, 1 = up, 2 = moving */
 };
 struct s3d_key_event {
-	uint16_t keysym;		/* the symbol, use this with s3d_keysym.h */
-	uint16_t unicode;		/* the unicode or &quot;actually typed&quot; character */
-	uint16_t modifier;	/* any modifiers involved */
-	uint16_t state;		/* 0 = pressed, 1 = released */
+	uint16_t keysym;  /* the symbol, use this with s3d_keysym.h */
+	uint16_t unicode;  /* the unicode or &quot;actually typed&quot; character */
+	uint16_t modifier; /* any modifiers involved */
+	uint16_t state;  /* 0 = pressed, 1 = released */
 };
 
 /* framework functions */
@@ -92,23 +92,23 @@
 /* object manipulations */
 int s3d_push_vertex(int object, float x, float y, float z);
 int s3d_push_vertices(int object, float *vbuf, uint16_t n);
-int s3d_push_material( int object,
-                       float amb_r, float amb_g, float amb_b,
-                       float spec_r, float spec_g, float spec_b,
-                       float diff_r, float diff_g, float diff_b);
-int s3d_pep_material( int object,
+int s3d_push_material(int object,
                       float amb_r, float amb_g, float amb_b,
                       float spec_r, float spec_g, float spec_b,
                       float diff_r, float diff_g, float diff_b);
-int s3d_push_material_a( int object,
-                         float amb_r, float amb_g, float amb_b, float amb_a,
-                         float spec_r, float spec_g, float spec_b, float spec_a,
-                         float diff_r, float diff_g, float diff_b, float diff_a);
-int s3d_push_materials_a(int object, float *mbuf, uint16_t n);
-int s3d_pep_material_a( int object,
+int s3d_pep_material(int object,
+                     float amb_r, float amb_g, float amb_b,
+                     float spec_r, float spec_g, float spec_b,
+                     float diff_r, float diff_g, float diff_b);
+int s3d_push_material_a(int object,
                         float amb_r, float amb_g, float amb_b, float amb_a,
                         float spec_r, float spec_g, float spec_b, float spec_a,
                         float diff_r, float diff_g, float diff_b, float diff_a);
+int s3d_push_materials_a(int object, float *mbuf, uint16_t n);
+int s3d_pep_material_a(int object,
+                       float amb_r, float amb_g, float amb_b, float amb_a,
+                       float spec_r, float spec_g, float spec_b, float spec_a,
+                       float diff_r, float diff_g, float diff_b, float diff_a);
 
 int s3d_pep_materials_a(int object, float *mbuf, uint16_t n);
 int s3d_load_materials_a(int object, float *mbuf, uint32_t start, uint16_t n);
@@ -124,17 +124,17 @@
 int s3d_pop_texture(int object, uint32_t n);
 int s3d_pop_polygon(int object, uint32_t n);
 int s3d_pop_line(int object, uint32_t n);
-int s3d_pep_line_normals(int object, float *nbuf,uint16_t n);
-int s3d_pep_polygon_normals(int object, float *nbuf,uint16_t n);
+int s3d_pep_line_normals(int object, float *nbuf, uint16_t n);
+int s3d_pep_polygon_normals(int object, float *nbuf, uint16_t n);
 int s3d_pep_polygon_tex_coord(int object, float x1, float y1, float x2, float y2, float x3, float y3);
-int s3d_pep_polygon_tex_coords(int object, float *tbuf,uint16_t n);
+int s3d_pep_polygon_tex_coords(int object, float *tbuf, uint16_t n);
 int s3d_pep_material_texture(int object, uint32_t tex);
 int s3d_pep_vertex(int object, float x, float y, float z);
-int s3d_pep_vertices(int object, float *vbuf,uint16_t n);
+int s3d_pep_vertices(int object, float *vbuf, uint16_t n);
 int s3d_pep_line(int object, int v1, int v2, int material);
-int s3d_pep_lines(int object, uint32_t *lbuf,uint16_t n);
-int s3d_load_line_normals(int object, float *nbuf,uint32_t start, uint16_t n);
-int s3d_load_polygon_normals(int object, float *nbuf,uint32_t start, uint16_t n);
+int s3d_pep_lines(int object, uint32_t *lbuf, uint16_t n);
+int s3d_load_line_normals(int object, float *nbuf, uint32_t start, uint16_t n);
+int s3d_load_polygon_normals(int object, float *nbuf, uint32_t start, uint16_t n);
 int s3d_load_polygon_tex_coords(int object, float *tbuf, uint32_t start, uint16_t n);
 int s3d_load_texture(int object, uint32_t tex, uint16_t xpos, uint16_t ypos, uint16_t w, uint16_t h, uint8_t *data);
 
@@ -157,17 +157,17 @@
 int s3d_import_model_file(char *fname);
 int s3d_open_file(char *fname, char **pointer);
 int s3d_select_font(char *mask);
-int s3d_draw_string( char *str, float *xlen);
-float s3d_strlen( char *str);
+int s3d_draw_string(char *str, float *xlen);
+float s3d_strlen(char *str);
 
 /* some vector calculation helpers */
 
-float s3d_vector_length( float vector[] );
-float s3d_vector_dot_product( float vector1[], float vector2[] );
-void s3d_vector_subtract( float vector1[], float vector2[], float result_vector[] );
-float s3d_vector_angle( float vector1[], float vector2[] );
-float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad );
-void s3d_vector_cross_product( float vector1[], float vector2[], float result_vector[] );
+float s3d_vector_length(float vector[]);
+float s3d_vector_dot_product(float vector1[], float vector2[]);
+void s3d_vector_subtract(float vector1[], float vector2[], float result_vector[]);
+float s3d_vector_angle(float vector1[], float vector2[]);
+float s3d_angle_to_cam(float obj_pos[], float cam_pos[], float *angle_rad);
+void s3d_vector_cross_product(float vector1[], float vector2[], float result_vector[]);
 
 /* event handlers */
 void s3d_push_event(struct s3d_evt *newevt);

Modified: trunk/libs3d/s3d_keysym.h
===================================================================
--- trunk/libs3d/s3d_keysym.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/s3d_keysym.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -35,255 +35,255 @@
 
 typedef enum {
 	/* The keyboard syms have been cleverly chosen to map to ASCII */
-	S3DK_UNKNOWN		= 0,
-	S3DK_FIRST		= 0,
-	S3DK_BACKSPACE		= 8,
-	S3DK_TAB		= 9,
-	S3DK_CLEAR		= 12,
-	S3DK_RETURN		= 13,
-	S3DK_PAUSE		= 19,
-	S3DK_ESCAPE		= 27,
-	S3DK_SPACE		= 32,
-	S3DK_EXCLAIM		= 33,
-	S3DK_QUOTEDBL		= 34,
-	S3DK_HASH		= 35,
-	S3DK_DOLLAR		= 36,
-	S3DK_AMPERSAND		= 38,
-	S3DK_QUOTE		= 39,
-	S3DK_LEFTPAREN		= 40,
-	S3DK_RIGHTPAREN		= 41,
-	S3DK_ASTERISK		= 42,
-	S3DK_PLUS		= 43,
-	S3DK_COMMA		= 44,
-	S3DK_MINUS		= 45,
-	S3DK_PERIOD		= 46,
-	S3DK_SLASH		= 47,
-	S3DK_0			= 48,
-	S3DK_1			= 49,
-	S3DK_2			= 50,
-	S3DK_3			= 51,
-	S3DK_4			= 52,
-	S3DK_5			= 53,
-	S3DK_6			= 54,
-	S3DK_7			= 55,
-	S3DK_8			= 56,
-	S3DK_9			= 57,
-	S3DK_COLON		= 58,
-	S3DK_SEMICOLON		= 59,
-	S3DK_LESS		= 60,
-	S3DK_EQUALS		= 61,
-	S3DK_GREATER		= 62,
-	S3DK_QUESTION		= 63,
-	S3DK_AT			= 64,
+	S3DK_UNKNOWN  = 0,
+	S3DK_FIRST  = 0,
+	S3DK_BACKSPACE  = 8,
+	S3DK_TAB  = 9,
+	S3DK_CLEAR  = 12,
+	S3DK_RETURN  = 13,
+	S3DK_PAUSE  = 19,
+	S3DK_ESCAPE  = 27,
+	S3DK_SPACE  = 32,
+	S3DK_EXCLAIM  = 33,
+	S3DK_QUOTEDBL  = 34,
+	S3DK_HASH  = 35,
+	S3DK_DOLLAR  = 36,
+	S3DK_AMPERSAND  = 38,
+	S3DK_QUOTE  = 39,
+	S3DK_LEFTPAREN  = 40,
+	S3DK_RIGHTPAREN  = 41,
+	S3DK_ASTERISK  = 42,
+	S3DK_PLUS  = 43,
+	S3DK_COMMA  = 44,
+	S3DK_MINUS  = 45,
+	S3DK_PERIOD  = 46,
+	S3DK_SLASH  = 47,
+	S3DK_0   = 48,
+	S3DK_1   = 49,
+	S3DK_2   = 50,
+	S3DK_3   = 51,
+	S3DK_4   = 52,
+	S3DK_5   = 53,
+	S3DK_6   = 54,
+	S3DK_7   = 55,
+	S3DK_8   = 56,
+	S3DK_9   = 57,
+	S3DK_COLON  = 58,
+	S3DK_SEMICOLON  = 59,
+	S3DK_LESS  = 60,
+	S3DK_EQUALS  = 61,
+	S3DK_GREATER  = 62,
+	S3DK_QUESTION  = 63,
+	S3DK_AT   = 64,
 	/*
 	   Skip uppercase letters
 	 */
-	S3DK_LEFTBRACKET	= 91,
-	S3DK_BACKSLASH		= 92,
-	S3DK_RIGHTBRACKET	= 93,
-	S3DK_CARET		= 94,
-	S3DK_UNDERSCORE		= 95,
-	S3DK_BACKQUOTE		= 96,
-	S3DK_a			= 97,
-	S3DK_b			= 98,
-	S3DK_c			= 99,
-	S3DK_d			= 100,
-	S3DK_e			= 101,
-	S3DK_f			= 102,
-	S3DK_g			= 103,
-	S3DK_h			= 104,
-	S3DK_i			= 105,
-	S3DK_j			= 106,
-	S3DK_k			= 107,
-	S3DK_l			= 108,
-	S3DK_m			= 109,
-	S3DK_n			= 110,
-	S3DK_o			= 111,
-	S3DK_p			= 112,
-	S3DK_q			= 113,
-	S3DK_r			= 114,
-	S3DK_s			= 115,
-	S3DK_t			= 116,
-	S3DK_u			= 117,
-	S3DK_v			= 118,
-	S3DK_w			= 119,
-	S3DK_x			= 120,
-	S3DK_y			= 121,
-	S3DK_z			= 122,
-	S3DK_DELETE		= 127,
+	S3DK_LEFTBRACKET = 91,
+	S3DK_BACKSLASH  = 92,
+	S3DK_RIGHTBRACKET = 93,
+	S3DK_CARET  = 94,
+	S3DK_UNDERSCORE  = 95,
+	S3DK_BACKQUOTE  = 96,
+	S3DK_a   = 97,
+	S3DK_b   = 98,
+	S3DK_c   = 99,
+	S3DK_d   = 100,
+	S3DK_e   = 101,
+	S3DK_f   = 102,
+	S3DK_g   = 103,
+	S3DK_h   = 104,
+	S3DK_i   = 105,
+	S3DK_j   = 106,
+	S3DK_k   = 107,
+	S3DK_l   = 108,
+	S3DK_m   = 109,
+	S3DK_n   = 110,
+	S3DK_o   = 111,
+	S3DK_p   = 112,
+	S3DK_q   = 113,
+	S3DK_r   = 114,
+	S3DK_s   = 115,
+	S3DK_t   = 116,
+	S3DK_u   = 117,
+	S3DK_v   = 118,
+	S3DK_w   = 119,
+	S3DK_x   = 120,
+	S3DK_y   = 121,
+	S3DK_z   = 122,
+	S3DK_DELETE  = 127,
 	/* End of ASCII mapped keysyms */
 
 	/* International keyboard syms */
-	S3DK_WORLD_0		= 160,		/* 0xA0 */
-	S3DK_WORLD_1		= 161,
-	S3DK_WORLD_2		= 162,
-	S3DK_WORLD_3		= 163,
-	S3DK_WORLD_4		= 164,
-	S3DK_WORLD_5		= 165,
-	S3DK_WORLD_6		= 166,
-	S3DK_WORLD_7		= 167,
-	S3DK_WORLD_8		= 168,
-	S3DK_WORLD_9		= 169,
-	S3DK_WORLD_10		= 170,
-	S3DK_WORLD_11		= 171,
-	S3DK_WORLD_12		= 172,
-	S3DK_WORLD_13		= 173,
-	S3DK_WORLD_14		= 174,
-	S3DK_WORLD_15		= 175,
-	S3DK_WORLD_16		= 176,
-	S3DK_WORLD_17		= 177,
-	S3DK_WORLD_18		= 178,
-	S3DK_WORLD_19		= 179,
-	S3DK_WORLD_20		= 180,
-	S3DK_WORLD_21		= 181,
-	S3DK_WORLD_22		= 182,
-	S3DK_WORLD_23		= 183,
-	S3DK_WORLD_24		= 184,
-	S3DK_WORLD_25		= 185,
-	S3DK_WORLD_26		= 186,
-	S3DK_WORLD_27		= 187,
-	S3DK_WORLD_28		= 188,
-	S3DK_WORLD_29		= 189,
-	S3DK_WORLD_30		= 190,
-	S3DK_WORLD_31		= 191,
-	S3DK_WORLD_32		= 192,
-	S3DK_WORLD_33		= 193,
-	S3DK_WORLD_34		= 194,
-	S3DK_WORLD_35		= 195,
-	S3DK_WORLD_36		= 196,
-	S3DK_WORLD_37		= 197,
-	S3DK_WORLD_38		= 198,
-	S3DK_WORLD_39		= 199,
-	S3DK_WORLD_40		= 200,
-	S3DK_WORLD_41		= 201,
-	S3DK_WORLD_42		= 202,
-	S3DK_WORLD_43		= 203,
-	S3DK_WORLD_44		= 204,
-	S3DK_WORLD_45		= 205,
-	S3DK_WORLD_46		= 206,
-	S3DK_WORLD_47		= 207,
-	S3DK_WORLD_48		= 208,
-	S3DK_WORLD_49		= 209,
-	S3DK_WORLD_50		= 210,
-	S3DK_WORLD_51		= 211,
-	S3DK_WORLD_52		= 212,
-	S3DK_WORLD_53		= 213,
-	S3DK_WORLD_54		= 214,
-	S3DK_WORLD_55		= 215,
-	S3DK_WORLD_56		= 216,
-	S3DK_WORLD_57		= 217,
-	S3DK_WORLD_58		= 218,
-	S3DK_WORLD_59		= 219,
-	S3DK_WORLD_60		= 220,
-	S3DK_WORLD_61		= 221,
-	S3DK_WORLD_62		= 222,
-	S3DK_WORLD_63		= 223,
-	S3DK_WORLD_64		= 224,
-	S3DK_WORLD_65		= 225,
-	S3DK_WORLD_66		= 226,
-	S3DK_WORLD_67		= 227,
-	S3DK_WORLD_68		= 228,
-	S3DK_WORLD_69		= 229,
-	S3DK_WORLD_70		= 230,
-	S3DK_WORLD_71		= 231,
-	S3DK_WORLD_72		= 232,
-	S3DK_WORLD_73		= 233,
-	S3DK_WORLD_74		= 234,
-	S3DK_WORLD_75		= 235,
-	S3DK_WORLD_76		= 236,
-	S3DK_WORLD_77		= 237,
-	S3DK_WORLD_78		= 238,
-	S3DK_WORLD_79		= 239,
-	S3DK_WORLD_80		= 240,
-	S3DK_WORLD_81		= 241,
-	S3DK_WORLD_82		= 242,
-	S3DK_WORLD_83		= 243,
-	S3DK_WORLD_84		= 244,
-	S3DK_WORLD_85		= 245,
-	S3DK_WORLD_86		= 246,
-	S3DK_WORLD_87		= 247,
-	S3DK_WORLD_88		= 248,
-	S3DK_WORLD_89		= 249,
-	S3DK_WORLD_90		= 250,
-	S3DK_WORLD_91		= 251,
-	S3DK_WORLD_92		= 252,
-	S3DK_WORLD_93		= 253,
-	S3DK_WORLD_94		= 254,
-	S3DK_WORLD_95		= 255,		/* 0xFF */
+	S3DK_WORLD_0  = 160,  /* 0xA0 */
+	S3DK_WORLD_1  = 161,
+	S3DK_WORLD_2  = 162,
+	S3DK_WORLD_3  = 163,
+	S3DK_WORLD_4  = 164,
+	S3DK_WORLD_5  = 165,
+	S3DK_WORLD_6  = 166,
+	S3DK_WORLD_7  = 167,
+	S3DK_WORLD_8  = 168,
+	S3DK_WORLD_9  = 169,
+	S3DK_WORLD_10  = 170,
+	S3DK_WORLD_11  = 171,
+	S3DK_WORLD_12  = 172,
+	S3DK_WORLD_13  = 173,
+	S3DK_WORLD_14  = 174,
+	S3DK_WORLD_15  = 175,
+	S3DK_WORLD_16  = 176,
+	S3DK_WORLD_17  = 177,
+	S3DK_WORLD_18  = 178,
+	S3DK_WORLD_19  = 179,
+	S3DK_WORLD_20  = 180,
+	S3DK_WORLD_21  = 181,
+	S3DK_WORLD_22  = 182,
+	S3DK_WORLD_23  = 183,
+	S3DK_WORLD_24  = 184,
+	S3DK_WORLD_25  = 185,
+	S3DK_WORLD_26  = 186,
+	S3DK_WORLD_27  = 187,
+	S3DK_WORLD_28  = 188,
+	S3DK_WORLD_29  = 189,
+	S3DK_WORLD_30  = 190,
+	S3DK_WORLD_31  = 191,
+	S3DK_WORLD_32  = 192,
+	S3DK_WORLD_33  = 193,
+	S3DK_WORLD_34  = 194,
+	S3DK_WORLD_35  = 195,
+	S3DK_WORLD_36  = 196,
+	S3DK_WORLD_37  = 197,
+	S3DK_WORLD_38  = 198,
+	S3DK_WORLD_39  = 199,
+	S3DK_WORLD_40  = 200,
+	S3DK_WORLD_41  = 201,
+	S3DK_WORLD_42  = 202,
+	S3DK_WORLD_43  = 203,
+	S3DK_WORLD_44  = 204,
+	S3DK_WORLD_45  = 205,
+	S3DK_WORLD_46  = 206,
+	S3DK_WORLD_47  = 207,
+	S3DK_WORLD_48  = 208,
+	S3DK_WORLD_49  = 209,
+	S3DK_WORLD_50  = 210,
+	S3DK_WORLD_51  = 211,
+	S3DK_WORLD_52  = 212,
+	S3DK_WORLD_53  = 213,
+	S3DK_WORLD_54  = 214,
+	S3DK_WORLD_55  = 215,
+	S3DK_WORLD_56  = 216,
+	S3DK_WORLD_57  = 217,
+	S3DK_WORLD_58  = 218,
+	S3DK_WORLD_59  = 219,
+	S3DK_WORLD_60  = 220,
+	S3DK_WORLD_61  = 221,
+	S3DK_WORLD_62  = 222,
+	S3DK_WORLD_63  = 223,
+	S3DK_WORLD_64  = 224,
+	S3DK_WORLD_65  = 225,
+	S3DK_WORLD_66  = 226,
+	S3DK_WORLD_67  = 227,
+	S3DK_WORLD_68  = 228,
+	S3DK_WORLD_69  = 229,
+	S3DK_WORLD_70  = 230,
+	S3DK_WORLD_71  = 231,
+	S3DK_WORLD_72  = 232,
+	S3DK_WORLD_73  = 233,
+	S3DK_WORLD_74  = 234,
+	S3DK_WORLD_75  = 235,
+	S3DK_WORLD_76  = 236,
+	S3DK_WORLD_77  = 237,
+	S3DK_WORLD_78  = 238,
+	S3DK_WORLD_79  = 239,
+	S3DK_WORLD_80  = 240,
+	S3DK_WORLD_81  = 241,
+	S3DK_WORLD_82  = 242,
+	S3DK_WORLD_83  = 243,
+	S3DK_WORLD_84  = 244,
+	S3DK_WORLD_85  = 245,
+	S3DK_WORLD_86  = 246,
+	S3DK_WORLD_87  = 247,
+	S3DK_WORLD_88  = 248,
+	S3DK_WORLD_89  = 249,
+	S3DK_WORLD_90  = 250,
+	S3DK_WORLD_91  = 251,
+	S3DK_WORLD_92  = 252,
+	S3DK_WORLD_93  = 253,
+	S3DK_WORLD_94  = 254,
+	S3DK_WORLD_95  = 255,  /* 0xFF */
 
 	/* Numeric keypad */
-	S3DK_KP0		= 256,
-	S3DK_KP1		= 257,
-	S3DK_KP2		= 258,
-	S3DK_KP3		= 259,
-	S3DK_KP4		= 260,
-	S3DK_KP5		= 261,
-	S3DK_KP6		= 262,
-	S3DK_KP7		= 263,
-	S3DK_KP8		= 264,
-	S3DK_KP9		= 265,
-	S3DK_KP_PERIOD		= 266,
-	S3DK_KP_DIVIDE		= 267,
-	S3DK_KP_MULTIPLY	= 268,
-	S3DK_KP_MINUS		= 269,
-	S3DK_KP_PLUS		= 270,
-	S3DK_KP_ENTER		= 271,
-	S3DK_KP_EQUALS		= 272,
+	S3DK_KP0  = 256,
+	S3DK_KP1  = 257,
+	S3DK_KP2  = 258,
+	S3DK_KP3  = 259,
+	S3DK_KP4  = 260,
+	S3DK_KP5  = 261,
+	S3DK_KP6  = 262,
+	S3DK_KP7  = 263,
+	S3DK_KP8  = 264,
+	S3DK_KP9  = 265,
+	S3DK_KP_PERIOD  = 266,
+	S3DK_KP_DIVIDE  = 267,
+	S3DK_KP_MULTIPLY = 268,
+	S3DK_KP_MINUS  = 269,
+	S3DK_KP_PLUS  = 270,
+	S3DK_KP_ENTER  = 271,
+	S3DK_KP_EQUALS  = 272,
 
 	/* Arrows + Home/End pad */
-	S3DK_UP			= 273,
-	S3DK_DOWN		= 274,
-	S3DK_RIGHT		= 275,
-	S3DK_LEFT		= 276,
-	S3DK_INSERT		= 277,
-	S3DK_HOME		= 278,
-	S3DK_END		= 279,
-	S3DK_PAGEUP		= 280,
-	S3DK_PAGEDOWN		= 281,
+	S3DK_UP   = 273,
+	S3DK_DOWN  = 274,
+	S3DK_RIGHT  = 275,
+	S3DK_LEFT  = 276,
+	S3DK_INSERT  = 277,
+	S3DK_HOME  = 278,
+	S3DK_END  = 279,
+	S3DK_PAGEUP  = 280,
+	S3DK_PAGEDOWN  = 281,
 
 	/* Function keys */
-	S3DK_F1			= 282,
-	S3DK_F2			= 283,
-	S3DK_F3			= 284,
-	S3DK_F4			= 285,
-	S3DK_F5			= 286,
-	S3DK_F6			= 287,
-	S3DK_F7			= 288,
-	S3DK_F8			= 289,
-	S3DK_F9			= 290,
-	S3DK_F10		= 291,
-	S3DK_F11		= 292,
-	S3DK_F12		= 293,
-	S3DK_F13		= 294,
-	S3DK_F14		= 295,
-	S3DK_F15		= 296,
+	S3DK_F1   = 282,
+	S3DK_F2   = 283,
+	S3DK_F3   = 284,
+	S3DK_F4   = 285,
+	S3DK_F5   = 286,
+	S3DK_F6   = 287,
+	S3DK_F7   = 288,
+	S3DK_F8   = 289,
+	S3DK_F9   = 290,
+	S3DK_F10  = 291,
+	S3DK_F11  = 292,
+	S3DK_F12  = 293,
+	S3DK_F13  = 294,
+	S3DK_F14  = 295,
+	S3DK_F15  = 296,
 
 	/* Key state modifier keys */
-	S3DK_NUMLOCK		= 300,
-	S3DK_CAPSLOCK		= 301,
-	S3DK_SCROLLOCK		= 302,
-	S3DK_RSHIFT		= 303,
-	S3DK_LSHIFT		= 304,
-	S3DK_RCTRL		= 305,
-	S3DK_LCTRL		= 306,
-	S3DK_RALT		= 307,
-	S3DK_LALT		= 308,
-	S3DK_RMETA		= 309,
-	S3DK_LMETA		= 310,
-	S3DK_LSUPER		= 311,		/* Left &quot;Windows&quot; key */
-	S3DK_RSUPER		= 312,		/* Right &quot;Windows&quot; key */
-	S3DK_MODE		= 313,		/* &quot;Alt Gr&quot; key */
-	S3DK_COMPOSE		= 314,		/* Multi-key compose key */
+	S3DK_NUMLOCK  = 300,
+	S3DK_CAPSLOCK  = 301,
+	S3DK_SCROLLOCK  = 302,
+	S3DK_RSHIFT  = 303,
+	S3DK_LSHIFT  = 304,
+	S3DK_RCTRL  = 305,
+	S3DK_LCTRL  = 306,
+	S3DK_RALT  = 307,
+	S3DK_LALT  = 308,
+	S3DK_RMETA  = 309,
+	S3DK_LMETA  = 310,
+	S3DK_LSUPER  = 311,  /* Left &quot;Windows&quot; key */
+	S3DK_RSUPER  = 312,  /* Right &quot;Windows&quot; key */
+	S3DK_MODE  = 313,  /* &quot;Alt Gr&quot; key */
+	S3DK_COMPOSE  = 314,  /* Multi-key compose key */
 
 	/* Miscellaneous function keys */
-	S3DK_HELP		= 315,
-	S3DK_PRINT		= 316,
-	S3DK_SYSREQ		= 317,
-	S3DK_BREAK		= 318,
-	S3DK_MENU		= 319,
-	S3DK_POWER		= 320,		/* Power Macintosh power key */
-	S3DK_EURO		= 321,		/* Some european keyboards */
-	S3DK_UNDO		= 322,		/* Atari keyboard has Undo */
+	S3DK_HELP  = 315,
+	S3DK_PRINT  = 316,
+	S3DK_SYSREQ  = 317,
+	S3DK_BREAK  = 318,
+	S3DK_MENU  = 319,
+	S3DK_POWER  = 320,  /* Power Macintosh power key */
+	S3DK_EURO  = 321,  /* Some european keyboards */
+	S3DK_UNDO  = 322,  /* Atari keyboard has Undo */
 
 	/* Add any other keys here */
 
@@ -293,8 +293,8 @@
 /* Enumeration of valid key mods (possibly OR'd together) */
 typedef enum {
 	S3D_KMOD_NONE  = 0x0000,
-	S3D_KMOD_LSHIFT= 0x0001,
-	S3D_KMOD_RSHIFT= 0x0002,
+	S3D_KMOD_LSHIFT = 0x0001,
+	S3D_KMOD_RSHIFT = 0x0002,
 	S3D_KMOD_LCTRL = 0x0040,
 	S3D_KMOD_RCTRL = 0x0080,
 	S3D_KMOD_LALT  = 0x0100,
@@ -307,8 +307,8 @@
 	S3D_KMOD_RESERVED = 0x8000
 } S3DMod;
 
-#define S3D_KMOD_CTRL	(KMOD_LCTRL|KMOD_RCTRL)
-#define S3D_KMOD_SHIFT	(KMOD_LSHIFT|KMOD_RSHIFT)
-#define S3D_KMOD_ALT	(KMOD_LALT|KMOD_RALT)
-#define S3D_KMOD_META	(KMOD_LMETA|KMOD_RMETA)
+#define S3D_KMOD_CTRL (KMOD_LCTRL|KMOD_RCTRL)
+#define S3D_KMOD_SHIFT (KMOD_LSHIFT|KMOD_RSHIFT)
+#define S3D_KMOD_ALT (KMOD_LALT|KMOD_RALT)
+#define S3D_KMOD_META (KMOD_LMETA|KMOD_RMETA)
 

Modified: trunk/libs3d/s3dlib.h
===================================================================
--- trunk/libs3d/s3dlib.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/s3dlib.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -40,30 +40,30 @@
 #endif
 #endif
 
-#define VLOW	1
-#define	LOW		2
-#define MED		3
-#define HIGH	4
-#define	VHIGH	5
+#define VLOW 1
+#define LOW  2
+#define MED  3
+#define HIGH 4
+#define VHIGH 5
 
-#define DBM_MAX			1024	 /*  maximum size of a debug message string */
-#define S3D_NAME_MAX	256		 /*  limit for names [e.g. process names] */
-#define OF_TURN_ON 		1		 /*  logical or */
-#define OF_TURN_OFF 	2		 /*  logical ?! */
-#define OF_TURN_SWAP 	3		 /*  logical ?! */
-#define TIMEOUT			100000
-#define MAX_CB			256		 /*  as much as there are callbacks */
+#define DBM_MAX   1024  /*  maximum size of a debug message string */
+#define S3D_NAME_MAX 256   /*  limit for names [e.g. process names] */
+#define OF_TURN_ON   1   /*  logical or */
+#define OF_TURN_OFF  2   /*  logical ?! */
+#define OF_TURN_SWAP  3   /*  logical ?! */
+#define TIMEOUT   100000
+#define MAX_CB   256   /*  as much as there are callbacks */
 #ifndef NULL
-#define NULL	0
+#define NULL 0
 #endif
-#define CON_NULL	0
-#define CON_SHM		1
-#define CON_TCP		2
-#define SHM_SIZE 	sizeof(key_t)*2  		/* space for the keys */
-#define RB_STD_SIZE		1024*512
-#define RB_OVERHEAD		sizeof(struct buf_t)
+#define CON_NULL 0
+#define CON_SHM  1
+#define CON_TCP  2
+#define SHM_SIZE  sizeof(key_t)*2    /* space for the keys */
+#define RB_STD_SIZE  1024*512
+#define RB_OVERHEAD  sizeof(struct buf_t)
 /*  the callback buiffer: */
-extern int cb_lock;	/* holds the recursion depth */
+extern int cb_lock; /* holds the recursion depth */
 
 extern int _s3d_ready; /* is 1 after s3d_init() was sucessful */
 extern s3d_cb s3d_cb_list[MAX_CB];
@@ -76,8 +76,8 @@
 #pragma GCC visibility push(default) /* Only export following functions */
 #endif
 void s3dprintf(int relevance, const char *fmt, ...);
-void errdn(int relevance, char *func,int en);
-void errds(int relevance,char *func, const char *fmt, ...);
+void errdn(int relevance, char *func, int en);
+void errds(int relevance, char *func, const char *fmt, ...);
 #ifdef HAVE_GCCVISIBILITY
 #pragma GCC visibility pop
 #endif
@@ -93,7 +93,7 @@
                              const char *S3DUNUSED(fmt), ...) {}
 #endif
 
-void errn(char *func,int en);
+void errn(char *func, int en);
 void errs(char *func, char *msg);
 
 /*  fontselect.c */
@@ -112,33 +112,33 @@
 int _tcp_init();
 int _tcp_quit();
 int _s3d_tcp_net_receive();
-int tcp_writen(char *str,int s);
-int tcp_readn(char *str,int s);
+int tcp_writen(char *str, int s);
+int tcp_readn(char *str, int s);
 #endif
 /* shm_ringbuf.c */
 #ifdef SHM
 struct buf_t {
-	uint32_t start,end,bufsize;	/* start/end of the data */
+	uint32_t start, end, bufsize; /* start/end of the data */
 };
-int shm_write(struct buf_t *rb,char *buf, int n);
-int shm_read(struct buf_t *rb,char *buf, int n);
+int shm_write(struct buf_t *rb, char *buf, int n);
+int shm_read(struct buf_t *rb, char *buf, int n);
 /* shm.c */
 int _shm_init(char *ftoken);
 int _shm_quit();
 int _shm_net_receive();
-int shm_writen(char *str,int s);
-int shm_readn(char *str,int s);
+int shm_writen(char *str, int s);
+int shm_readn(char *str, int s);
 #endif
 /* freetype.c */
 struct t_buf {
 	float *vbuf;
 	uint32_t *pbuf;
-	int pn,vn;
+	int pn, vn;
 	float xoff;
 };
 
 /* tesselate.c */
 struct tessp_t {
-	int next,prev,done;
+	int next, prev, done;
 };
-int _s3d_tesselate(struct tessp_t *t,struct t_buf *b);
+int _s3d_tesselate(struct tessp_t *t, struct t_buf *b);

Modified: trunk/libs3d/sei_construct.c
===================================================================
--- trunk/libs3d/sei_construct.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/sei_construct.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -42,9 +42,9 @@
 #include &lt;string.h&gt; /* memset() */
 
 
-node_t qs[QSIZE];		/* Query structure */
-trap_t tr[TRSIZE];		/* Trapezoid structure */
-segment_t seg[SEGSIZE];		/* Segment table */
+node_t qs[QSIZE];  /* Query structure */
+trap_t tr[TRSIZE];  /* Trapezoid structure */
+segment_t seg[SEGSIZE];  /* Segment table */
 
 static int q_idx;
 static int tr_idx;
@@ -55,7 +55,7 @@
 	if (q_idx &lt; QSIZE)
 		return q_idx++;
 	else {
-		errs(&quot;sei:newnode()&quot;,&quot;Query-table overflow&quot;);
+		errs(&quot;sei:newnode()&quot;, &quot;Query-table overflow&quot;);
 		return -1;
 	}
 }
@@ -69,7 +69,7 @@
 		tr[tr_idx].state = ST_VALID;
 		return tr_idx++;
 	} else {
-		errs(&quot;sei:newtrap()&quot;,&quot;Trapezoid-table overflow&quot;);
+		errs(&quot;sei:newtrap()&quot;, &quot;Trapezoid-table overflow&quot;);
 		return -1;
 	}
 }
@@ -166,9 +166,9 @@
  *
  *                4
  *   -----------------------------------
- *  		  \
- *  	1	   \        2
- *  		    \
+ *      \
+ *   1    \        2
+ *        \
  *   -----------------------------------
  *                3
  */
@@ -215,17 +215,17 @@
 	qs[i7].nodetype = T_SINK;
 	qs[i7].parent = i5;
 
-	t1 = newtrap();		/* middle left */
-	t2 = newtrap();		/* middle right */
-	t3 = newtrap();		/* bottom-most */
-	t4 = newtrap();		/* topmost */
+	t1 = newtrap();  /* middle left */
+	t2 = newtrap();  /* middle right */
+	t3 = newtrap();  /* bottom-most */
+	t4 = newtrap();  /* topmost */
 
 	tr[t1].hi = tr[t2].hi = tr[t4].lo = qs[i1].yval;
 	tr[t1].lo = tr[t2].lo = tr[t3].hi = qs[i3].yval;
-	tr[t4].hi.y = (double) (INFINITY);
-	tr[t4].hi.x = (double) (INFINITY);
-	tr[t3].lo.y = (double) -1* (INFINITY);
-	tr[t3].lo.x = (double) -1* (INFINITY);
+	tr[t4].hi.y = (double)(INFINITY);
+	tr[t4].hi.x = (double)(INFINITY);
+	tr[t3].lo.y = (double) - 1 * (INFINITY);
+	tr[t3].lo.x = (double) - 1 * (INFINITY);
 	tr[t1].rseg = tr[t2].lseg = segnum;
 	tr[t1].u0 = tr[t2].u0 = t4;
 	tr[t1].d0 = tr[t2].d0 = t3;
@@ -275,7 +275,7 @@
 				area = -1.0;
 		} else
 			area = CROSS(s-&gt;v0, s-&gt;v1, (*v));
-	} else {			/* v0 &gt; v1 */
+	} else {   /* v0 &gt; v1 */
 		if (FP_EQUAL(s-&gt;v1.y, v-&gt;y)) {
 			if (v-&gt;x &lt; s-&gt;v1.x)
 				area = 1.0;
@@ -331,7 +331,7 @@
 		if (_greater_than(v, &amp;rptr-&gt;yval)) /* above */
 			return locate_endpoint(v, vo, rptr-&gt;right);
 		else if (_equal_to(v, &amp;rptr-&gt;yval)) /* the point is already */
-		{			          /* inserted. */
+		{             /* inserted. */
 			if (_greater_than(vo, &amp;rptr-&gt;yval)) /* above */
 				return locate_endpoint(v, vo, rptr-&gt;right);
 			else
@@ -359,7 +359,7 @@
 			return locate_endpoint(v, vo, rptr-&gt;right); /* right */
 
 	default:
-		errs(&quot;sei:locate_endpoint()&quot;,&quot;Haggu!!!! (whatever)&quot;);
+		errs(&quot;sei:locate_endpoint()&quot;, &quot;Haggu!!!! (whatever)&quot;);
 		break;
 	}
 	return(-1);
@@ -395,7 +395,7 @@
 		if (cond) {
 			if ((tr[t].lseg == tr[tnext].lseg) &amp;&amp;
 			                (tr[t].rseg == tr[tnext].rseg)) /* good neighbours */
-			{			              /* merge them */
+			{                 /* merge them */
 				/* Use the upper node as the new node i.e. t */
 
 				ptnext = qs[tr[tnext].sink].parent;
@@ -403,7 +403,7 @@
 				if (qs[ptnext].left == tr[tnext].sink)
 					qs[ptnext].left = tr[t].sink;
 				else
-					qs[ptnext].right = tr[t].sink;	/* redirect parent */
+					qs[ptnext].right = tr[t].sink; /* redirect parent */
 
 
 				/* Change the upper neighbours of the lower trapezoids */
@@ -425,9 +425,9 @@
 				tr[t].lo = tr[tnext].lo;
 				tr[tnext].state = ST_INVALID; /* invalidate the lower */
 				/* trapezium */
-			} else		   /* not good neighbours */
+			} else     /* not good neighbours */
 				t = tnext;
-		} else		   /* do not satisfy the outer if */
+		} else     /* do not satisfy the outer if */
 			t = tnext;
 
 	} /* end-while */
@@ -471,7 +471,7 @@
 		int tmp_d;
 
 		tu = locate_endpoint(&amp;s.v0, &amp;s.v1, s.root0);
-		tl = newtrap();		/* tl is the new lower trapezoid */
+		tl = newtrap();  /* tl is the new lower trapezoid */
 		tr[tl].state = ST_VALID;
 		tr[tl] = tr[tu];
 		tr[tu].lo.y = tr[tl].hi.y = s.v0.y;
@@ -494,13 +494,13 @@
 		/* Now update the query structure and obtain the sinks for the */
 		/* two trapezoids */
 
-		i1 = newnode();		/* Upper trapezoid sink */
-		i2 = newnode();		/* Lower trapezoid sink */
+		i1 = newnode();  /* Upper trapezoid sink */
+		i2 = newnode();  /* Lower trapezoid sink */
 		sk = tr[tu].sink;
 
 		qs[sk].nodetype = T_Y;
 		qs[sk].yval = s.v0;
-		qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
+		qs[sk].segnum = segnum; /* not really reqd ... maybe later */
 		qs[sk].left = i2;
 		qs[sk].right = i1;
 
@@ -515,7 +515,7 @@
 		tr[tu].sink = i1;
 		tr[tl].sink = i2;
 		tfirst = tl;
-	} else				/* v0 already present */
+	} else    /* v0 already present */
 	{       /* Get the topmost intersecting trapezoid */
 		tfirst = locate_endpoint(&amp;s.v0, &amp;s.v1, s.root0);
 		tritop = 1;
@@ -528,7 +528,7 @@
 
 		tu = locate_endpoint(&amp;s.v1, &amp;s.v0, s.root1);
 
-		tl = newtrap();		/* tl is the new lower trapezoid */
+		tl = newtrap();  /* tl is the new lower trapezoid */
 		tr[tl].state = ST_VALID;
 		tr[tl] = tr[tu];
 		tr[tu].lo.y = tr[tl].hi.y = s.v1.y;
@@ -551,13 +551,13 @@
 		/* Now update the query structure and obtain the sinks for the */
 		/* two trapezoids */
 
-		i1 = newnode();		/* Upper trapezoid sink */
-		i2 = newnode();		/* Lower trapezoid sink */
+		i1 = newnode();  /* Upper trapezoid sink */
+		i2 = newnode();  /* Lower trapezoid sink */
 		sk = tr[tu].sink;
 
 		qs[sk].nodetype = T_Y;
 		qs[sk].yval = s.v1;
-		qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
+		qs[sk].segnum = segnum; /* not really reqd ... maybe later */
 		qs[sk].left = i2;
 		qs[sk].right = i1;
 
@@ -572,7 +572,7 @@
 		tr[tu].sink = i1;
 		tr[tl].sink = i2;
 		tlast = tu;
-	} else				/* v1 already present */
+	} else    /* v1 already present */
 	{       /* Get the lowermost intersecting trapezoid */
 		tlast = locate_endpoint(&amp;s.v1, &amp;s.v0, s.root1);
 		tribot = 1;
@@ -582,7 +582,7 @@
 	/* First, split all the trapezoids which are intersected by s into */
 	/* two */
 
-	t = tfirst;			/* topmost trapezoid */
+	t = tfirst;   /* topmost trapezoid */
 
 	while ((t &gt; 0) &amp;&amp;
 	                _greater_than_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo))
@@ -590,19 +590,19 @@
 	{
 		int t_sav, tn_sav;
 		sk = tr[t].sink;
-		i1 = newnode();		/* left trapezoid sink */
-		i2 = newnode();		/* right trapezoid sink */
+		i1 = newnode();  /* left trapezoid sink */
+		i2 = newnode();  /* right trapezoid sink */
 
 		qs[sk].nodetype = T_X;
 		qs[sk].segnum = segnum;
 		qs[sk].left = i1;
 		qs[sk].right = i2;
 
-		qs[i1].nodetype = T_SINK;	/* left trapezoid (use existing one) */
+		qs[i1].nodetype = T_SINK; /* left trapezoid (use existing one) */
 		qs[i1].trnum = t;
 		qs[i1].parent = sk;
 
-		qs[i2].nodetype = T_SINK;	/* right trapezoid (allocate new) */
+		qs[i2].nodetype = T_SINK; /* right trapezoid (allocate new) */
 		qs[i2].trnum = tn = newtrap();
 		tr[tn].state = ST_VALID;
 		qs[i2].parent = sk;
@@ -621,7 +621,7 @@
 		/* error */
 
 		if ((tr[t].d0 &lt;= 0) &amp;&amp; (tr[t].d1 &lt;= 0)) { /* case cannot arise */
-			errs(&quot;sei:add_segment()&quot;,&quot;error&quot;);
+			errs(&quot;sei:add_segment()&quot;, &quot;error&quot;);
 			break;
 		}
 
@@ -629,8 +629,8 @@
 		/* two resulting trapezoids t and tn as the upper neighbours of */
 		/* the sole lower trapezoid */
 
-		else if ((tr[t].d0 &gt; 0) &amp;&amp; (tr[t].d1 &lt;= 0)) {			/* Only one trapezoid below */
-			if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0)) {			/* continuation of a chain from abv. */
+		else if ((tr[t].d0 &gt; 0) &amp;&amp; (tr[t].d1 &lt;= 0)) {   /* Only one trapezoid below */
+			if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0)) {   /* continuation of a chain from abv. */
 				if (tr[t].usave &gt; 0) { /* three upper neighbours */
 					if (tr[t].uside == S_LEFT) {
 						tr[tn].u0 = tr[t].u1;
@@ -640,7 +640,7 @@
 						tr[tr[t].u0].d0 = t;
 						tr[tr[tn].u0].d0 = tn;
 						tr[tr[tn].u1].d0 = tn;
-					} else {	/* intersects in the right */
+					} else { /* intersects in the right */
 						tr[tn].u1 = -1;
 						tr[tn].u0 = tr[t].u1;
 						tr[t].u1 = tr[t].u0;
@@ -652,32 +652,32 @@
 					}
 
 					tr[t].usave = tr[tn].usave = 0;
-				} else {	/* No usave.... simple case */
+				} else { /* No usave.... simple case */
 					tr[tn].u0 = tr[t].u1;
 					tr[t].u1 = tr[tn].u1 = -1;
 					tr[tr[tn].u0].d0 = tn;
 				}
-			} else {			/* fresh seg. or upward cusp */
+			} else {   /* fresh seg. or upward cusp */
 				int tmp_u = tr[t].u0;
 				int td0, td1;
 				if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp;
-				                ((td1 = tr[tmp_u].d1) &gt; 0)) {		/* upward cusp */
+				                ((td1 = tr[tmp_u].d1) &gt; 0)) {  /* upward cusp */
 					if ((tr[td0].rseg &gt; 0) &amp;&amp;
 					                !is_left_of(tr[td0].rseg, &amp;s.v1)) {
 						tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
 						tr[tr[tn].u0].d1 = tn;
-					} else {	/* cusp going leftwards */
+					} else { /* cusp going leftwards */
 						tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
 						tr[tr[t].u0].d0 = t;
 					}
-				} else {	/* fresh segment */
+				} else { /* fresh segment */
 					tr[tr[t].u0].d0 = t;
 					tr[tr[t].u0].d1 = tn;
 				}
 			}
 
 			if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp;
-			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot) {		/* bottom forms a triangle */
+			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot) {  /* bottom forms a triangle */
 
 				if (is_swapped)
 					tmptriseg = seg[segnum].prev;
@@ -711,8 +711,8 @@
 		}
 
 
-		else if ((tr[t].d0 &lt;= 0) &amp;&amp; (tr[t].d1 &gt; 0)) {			/* Only one trapezoid below */
-			if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0)) {			/* continuation of a chain from abv. */
+		else if ((tr[t].d0 &lt;= 0) &amp;&amp; (tr[t].d1 &gt; 0)) {   /* Only one trapezoid below */
+			if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0)) {   /* continuation of a chain from abv. */
 				if (tr[t].usave &gt; 0) { /* three upper neighbours */
 					if (tr[t].uside == S_LEFT) {
 						tr[tn].u0 = tr[t].u1;
@@ -722,7 +722,7 @@
 						tr[tr[t].u0].d0 = t;
 						tr[tr[tn].u0].d0 = tn;
 						tr[tr[tn].u1].d0 = tn;
-					} else {	/* intersects in the right */
+					} else { /* intersects in the right */
 						tr[tn].u1 = -1;
 						tr[tn].u0 = tr[t].u1;
 						tr[t].u1 = tr[t].u0;
@@ -734,16 +734,16 @@
 					}
 
 					tr[t].usave = tr[tn].usave = 0;
-				} else {	/* No usave.... simple case */
+				} else { /* No usave.... simple case */
 					tr[tn].u0 = tr[t].u1;
 					tr[t].u1 = tr[tn].u1 = -1;
 					tr[tr[tn].u0].d0 = tn;
 				}
-			} else {			/* fresh seg. or upward cusp */
+			} else {   /* fresh seg. or upward cusp */
 				int tmp_u = tr[t].u0;
 				int td0, td1;
 				if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp;
-				                ((td1 = tr[tmp_u].d1) &gt; 0)) {		/* upward cusp */
+				                ((td1 = tr[tmp_u].d1) &gt; 0)) {  /* upward cusp */
 					if ((tr[td0].rseg &gt; 0) &amp;&amp;
 					                !is_left_of(tr[td0].rseg, &amp;s.v1)) {
 						tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
@@ -752,14 +752,14 @@
 						tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
 						tr[tr[t].u0].d0 = t;
 					}
-				} else {	/* fresh segment */
+				} else { /* fresh segment */
 					tr[tr[t].u0].d0 = t;
 					tr[tr[t].u0].d1 = tn;
 				}
 			}
 
 			if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp;
-			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot) {		/* bottom forms a triangle */
+			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot) {  /* bottom forms a triangle */
 
 				if (is_swapped)
 					tmptriseg = seg[segnum].prev;
@@ -809,7 +809,7 @@
 					i_d1 = TRUE;
 			} else {
 				tmppt.y = y0 = tr[t].lo.y;
-				yt = (y0 - s.v0.y)/(s.v1.y - s.v0.y);
+				yt = (y0 - s.v0.y) / (s.v1.y - s.v0.y);
 				tmppt.x = s.v0.x + yt * (s.v1.x - s.v0.x);
 
 				if (_less_than(&amp;tmppt, &amp;tr[t].lo))
@@ -821,7 +821,7 @@
 			/* check continuity from the top so that the lower-neighbour */
 			/* values are properly filled for the upper trapezoid */
 
-			if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0)) {			/* continuation of a chain from abv. */
+			if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0)) {   /* continuation of a chain from abv. */
 				if (tr[t].usave &gt; 0) { /* three upper neighbours */
 					if (tr[t].uside == S_LEFT) {
 						tr[tn].u0 = tr[t].u1;
@@ -831,7 +831,7 @@
 						tr[tr[t].u0].d0 = t;
 						tr[tr[tn].u0].d0 = tn;
 						tr[tr[tn].u1].d0 = tn;
-					} else {	/* intersects in the right */
+					} else { /* intersects in the right */
 						tr[tn].u1 = -1;
 						tr[tn].u0 = tr[t].u1;
 						tr[t].u1 = tr[t].u0;
@@ -843,17 +843,17 @@
 					}
 
 					tr[t].usave = tr[tn].usave = 0;
-				} else {	/* No usave.... simple case */
+				} else { /* No usave.... simple case */
 					tr[tn].u0 = tr[t].u1;
 					tr[tn].u1 = -1;
 					tr[t].u1 = -1;
 					tr[tr[tn].u0].d0 = tn;
 				}
-			} else {			/* fresh seg. or upward cusp */
+			} else {   /* fresh seg. or upward cusp */
 				int tmp_u = tr[t].u0;
 				int td0, td1;
 				if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp;
-				                ((td1 = tr[tmp_u].d1) &gt; 0)) {		/* upward cusp */
+				                ((td1 = tr[tmp_u].d1) &gt; 0)) {  /* upward cusp */
 					if ((tr[td0].rseg &gt; 0) &amp;&amp;
 					                !is_left_of(tr[td0].rseg, &amp;s.v1)) {
 						tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
@@ -862,7 +862,7 @@
 						tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
 						tr[tr[t].u0].d0 = t;
 					}
-				} else {	/* fresh segment */
+				} else { /* fresh segment */
 					tr[tr[t].u0].d0 = t;
 					tr[tr[t].u0].d1 = tn;
 				}
@@ -897,7 +897,7 @@
 				tr[t].d1 = -1;
 
 				tnext = tr[t].d0;
-			} else {		/* intersecting d1 */
+			} else {  /* intersecting d1 */
 				tr[tr[t].d0].u0 = t;
 				tr[tr[t].d0].u1 = -1;
 				tr[tr[t].d1].u0 = t;
@@ -970,7 +970,7 @@
 		seg[i].root0 = seg[i].root1 = root;
 
 	for (h = 1; h &lt;= math_logstar_n(nseg); h++) {
-		for (i = math_N(nseg, h -1) + 1; i &lt;= math_N(nseg, h); i++)
+		for (i = math_N(nseg, h - 1) + 1; i &lt;= math_N(nseg, h); i++)
 			add_segment(choose_segment());
 
 		/* Find a new root for each of the segment endpoints */

Modified: trunk/libs3d/sei_interface.h
===================================================================
--- trunk/libs3d/sei_interface.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/sei_interface.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -43,7 +43,7 @@
 #define TRUE 1
 #define FALSE 0
 
-extern int sei_triangulate_polygon(int, int *, double (*)[2], int (*)[3]);
+extern int sei_triangulate_polygon(int, int *, double(*)[2], int (*)[3]);
 extern int is_point_inside_polygon(double *);
 
 #endif /* __interface_h */

Modified: trunk/libs3d/sei_misc.c
===================================================================
--- trunk/libs3d/sei_misc.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/sei_misc.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -46,7 +46,7 @@
 static int permute[SEGSIZE];
 double mlog2(double x)
 {
-	return log(x)/log(2);
+	return log(x) / log(2);
 }
 
 /* Generate a random permutation of the segments 1..n */
@@ -79,7 +79,7 @@
 /* segments in S */
 int choose_segment()
 {
-	errds(VLOW,&quot;sei:choose_segment()&quot;,&quot;%d&quot;, permute[choose_idx]);
+	errds(VLOW, &quot;sei:choose_segment()&quot;, &quot;%d&quot;, permute[choose_idx]);
 	return permute[choose_idx++];
 }
 
@@ -107,5 +107,5 @@
 	for (i = 0, v = (int) n; i &lt; h; i++)
 		v = mlog2(v);
 
-	return (int) ceil((double) 1.0*n/v);
+	return (int) ceil((double) 1.0*n / v);
 }

Modified: trunk/libs3d/sei_monotone.c
===================================================================
--- trunk/libs3d/sei_monotone.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/sei_monotone.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -55,7 +55,7 @@
 /* polygons touching at the same */
 /* vertex  */
 
-static int mon[SEGSIZE];	/* contains position of any vertex in */
+static int mon[SEGSIZE]; /* contains position of any vertex in */
 /* the monotone chain for the polygon */
 static int visited[TRSIZE];
 static int chain_idx, op_idx, mon_idx;
@@ -111,10 +111,10 @@
 	v1.x = vp1-&gt;x - vp0-&gt;x;
 	v1.y = vp1-&gt;y - vp0-&gt;y;
 
-	if (CROSS_SINE(v0, v1) &gt;= 0)	/* sine is positive */
-		return DOT(v0, v1)/LENGTH(v0)/LENGTH(v1);
+	if (CROSS_SINE(v0, v1) &gt;= 0) /* sine is positive */
+		return DOT(v0, v1) / LENGTH(v0) / LENGTH(v1);
 	else
-		return (-1.0 * DOT(v0, v1)/LENGTH(v0)/LENGTH(v1) - 2);
+		return (-1.0 * DOT(v0, v1) / LENGTH(v0) / LENGTH(v1) - 2);
 }
 
 
@@ -197,7 +197,7 @@
 	/* At this stage, we have got the positions of v0 and v1 in the */
 	/* desired chain. Now modify the linked lists */
 
-	i = new_chain_element();	/* for the new list */
+	i = new_chain_element(); /* for the new list */
 	j = new_chain_element();
 
 	mchain[i].vnum = v0;
@@ -226,8 +226,8 @@
 	vp0-&gt;nextfree++;
 	vp1-&gt;nextfree++;
 
-	errds(VLOW,&quot;sei:make_poly()&quot;,&quot;: mcur = %d, (v0, v1) = (%d, %d)&quot;, mcur, v0, v1);
-	errds(VLOW,&quot;sei:make_poly()&quot;,&quot;next posns = (p, q) = (%d, %d)&quot;, p, q);
+	errds(VLOW, &quot;sei:make_poly()&quot;, &quot;: mcur = %d, (v0, v1) = (%d, %d)&quot;, mcur, v0, v1);
+	errds(VLOW, &quot;sei:make_poly()&quot;, &quot;next posns = (p, q) = (%d, %d)&quot;, p, q);
 
 	mon[mcur] = p;
 	mon[mnew] = i;
@@ -265,8 +265,8 @@
 		mchain[i].next = i + 1;
 		mchain[i].vnum = i;
 		vert[i].pt = seg[i].v0;
-		vert[i].vnext[0] = i + 1;	/* next vertex */
-		vert[i].vpos[0] = i;	/* locn. of next vertex */
+		vert[i].vnext[0] = i + 1; /* next vertex */
+		vert[i].vpos[0] = i; /* locn. of next vertex */
 		vert[i].nextfree = 1;
 	}
 	mchain[1].prev = n;
@@ -275,7 +275,7 @@
 	vert[n].vpos[0] = n;
 	chain_idx = n;
 	mon_idx = 0;
-	mon[0] = 1;			/* position of any vertex in the first */
+	mon[0] = 1;   /* position of any vertex in the first */
 	/* chain  */
 
 #else
@@ -286,13 +286,13 @@
 		mchain[i].vnum = i;
 		vert[i].pt = seg[i].v0;
 		vert[i].vnext[0] = seg[i].next; /* next vertex */
-		vert[i].vpos[0] = i;	/* locn. of next vertex */
+		vert[i].vpos[0] = i; /* locn. of next vertex */
 		vert[i].nextfree = 1;
 	}
 
 	chain_idx = n;
 	mon_idx = 0;
-	mon[0] = 1;			/* position of any vertex in the first */
+	mon[0] = 1;   /* position of any vertex in the first */
 	/* chain  */
 
 #endif
@@ -351,7 +351,7 @@
 				traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
 			}
 		} else {
-			retval = SP_NOSPLIT;	/* Just traverse all neighbours */
+			retval = SP_NOSPLIT; /* Just traverse all neighbours */
 			traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
 			traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
 			traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
@@ -374,7 +374,7 @@
 				traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
 			}
 		} else {
-			retval = SP_NOSPLIT;	/* Just traverse all neighbours */
+			retval = SP_NOSPLIT; /* Just traverse all neighbours */
 			traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
 			traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
 			traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
@@ -402,7 +402,7 @@
 				traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
 				traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
 			}
-		} else {		/* only downward cusp */
+		} else {  /* only downward cusp */
 			if (_equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;lseg].v1)) {
 				v0 = tr[t-&gt;u0].rseg;
 				v1 = seg[t-&gt;lseg].next;
@@ -482,7 +482,7 @@
 					traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
 				}
 			}
-		} else {		/* no cusp */
+		} else {  /* no cusp */
 			if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;lseg].v0) &amp;&amp;
 			                _equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;rseg].v0)) {
 				v0 = t-&gt;rseg;
@@ -522,7 +522,7 @@
 					traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
 					traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
 				}
-			} else {		/* no split possible */
+			} else {  /* no split possible */
 				retval = SP_NOSPLIT;
 				traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
 				traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
@@ -564,7 +564,7 @@
 		while ((v = mchain[p].vnum) != vfirst) {
 			if (mchain[p].marked) {
 				processed = TRUE;
-				break;		/* break from while */
+				break;  /* break from while */
 			} else
 				mchain[p].marked = TRUE;
 
@@ -580,17 +580,17 @@
 			vcount++;
 		}
 
-		if (processed)		/* Go to next polygon */
+		if (processed)  /* Go to next polygon */
 			continue;
 
-		if (vcount == 3) {	/* already a triangle */
+		if (vcount == 3) { /* already a triangle */
 			op[op_idx][0] = mchain[p].vnum;
 			op[op_idx][1] = mchain[mchain[p].next].vnum;
 			op[op_idx][2] = mchain[mchain[p].prev].vnum;
 			op_idx++;
-		} else {		/* triangulate the polygon */
+		} else {  /* triangulate the polygon */
 			v = mchain[mchain[posmax].next].vnum;
-			if (_equal_to(&amp;vert[v].pt, &amp;ymin)) {			/* LHS is a single line */
+			if (_equal_to(&amp;vert[v].pt, &amp;ymin)) {   /* LHS is a single line */
 				triangulate_single_polygon(nvert, posmax, TRI_LHS, op);
 			} else
 				triangulate_single_polygon(nvert, posmax, TRI_RHS, op);
@@ -598,7 +598,7 @@
 	}
 
 	for (i = 0; i &lt; op_idx; i++)
-		errds(VLOW,&quot;sei:triangulate_monotone_polygons()&quot;,&quot;tri #%d: (%d, %d, %d)\n&quot;, i, op[i][0], op[i][1],
+		errds(VLOW, &quot;sei:triangulate_monotone_polygons()&quot;, &quot;tri #%d: (%d, %d, %d)\n&quot;, i, op[i][0], op[i][1],
 		      op[i][2]);
 	return op_idx;
 }
@@ -615,10 +615,10 @@
 int op[][3];
 {
 	register int v;
-	int rc[SEGSIZE], ri = 0;	/* reflex chain */
+	int rc[SEGSIZE], ri = 0; /* reflex chain */
 	int endv, tmp, vpos;
 
-	if (side == TRI_RHS) {	/* RHS segment is a single segment */
+	if (side == TRI_RHS) { /* RHS segment is a single segment */
 		rc[0] = mchain[posmax].vnum;
 		tmp = mchain[posmax].next;
 		rc[1] = mchain[tmp].vnum;
@@ -629,7 +629,7 @@
 
 		if ((endv = mchain[mchain[posmax].prev].vnum) == 0)
 			endv = nvert;
-	} else {			/* LHS is a single segment */
+	} else {   /* LHS is a single segment */
 		tmp = mchain[posmax].next;
 		rc[0] = mchain[tmp].vnum;
 		tmp = mchain[tmp].next;
@@ -643,23 +643,23 @@
 	}
 
 	while ((v != endv) || (ri &gt; 1)) {
-		if (ri &gt; 0) {	/* reflex chain is non-empty */
+		if (ri &gt; 0) { /* reflex chain is non-empty */
 			if (CROSS(vert[v].pt, vert[rc[ri - 1]].pt,
-			                vert[rc[ri]].pt) &gt; 0) {			/* convex corner: cut if off */
+			                vert[rc[ri]].pt) &gt; 0) {   /* convex corner: cut if off */
 				op[op_idx][0] = rc[ri - 1];
 				op[op_idx][1] = rc[ri];
 				op[op_idx][2] = v;
 				op_idx++;
 				ri--;
-			} else		/* non-convex */
-			{		/* add v to the chain */
+			} else  /* non-convex */
+			{  /* add v to the chain */
 				ri++;
 				rc[ri] = v;
 				vpos = mchain[vpos].next;
 				v = mchain[vpos].vnum;
 			}
-		} else			/* reflex-chain empty: add v to the */
-		{			/* reflex chain and advance it  */
+		} else   /* reflex-chain empty: add v to the */
+		{   /* reflex chain and advance it  */
 			rc[++ri] = v;
 			vpos = mchain[vpos].next;
 			v = mchain[vpos].vnum;

Modified: trunk/libs3d/sei_tri.c
===================================================================
--- trunk/libs3d/sei_tri.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/sei_tri.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -65,12 +65,12 @@
  *
  * ncontours: #contours
  * cntr: An array describing the number of points in each
- *	 contour. Thus, cntr[i] = #points in the i'th contour.
+ *  contour. Thus, cntr[i] = #points in the i'th contour.
  * vertices: Input array of vertices. Vertices for each contour
  *           immediately follow those for previous one. Array location
  *           vertices[0] must NOT be used (i.e. i/p starts from
  *           vertices[1] instead. The output triangles are
- *	     specified  w.r.t. the indices of these vertices.
+ *      specified  w.r.t. the indices of these vertices.
  * triangles: Output array to hold triangles.
  *
  * Enough space must be allocated for all the arrays before calling
@@ -81,7 +81,7 @@
 int sei_triangulate_polygon(ncontours, cntr, vertices, triangles)
 int ncontours;
 int cntr[];
-double (*vertices)[2];
+double(*vertices)[2];
 int (*triangles)[3];
 {
 	register int i;
@@ -105,15 +105,15 @@
 
 			if (i == last) {
 				seg[i].next = first;
-				seg[i].prev = i-1;
+				seg[i].prev = i - 1;
 				seg[i-1].v1 = seg[i].v0;
 			} else if (i == first) {
-				seg[i].next = i+1;
+				seg[i].next = i + 1;
 				seg[i].prev = last;
 				seg[last].v1 = seg[i].v0;
 			} else {
-				seg[i].prev = i-1;
-				seg[i].next = i+1;
+				seg[i].prev = i - 1;
+				seg[i].next = i + 1;
 				seg[i-1].v1 = seg[i].v0;
 			}
 
@@ -124,7 +124,7 @@
 	}
 
 	genus = ncontours - 1;
-	n = i-1;
+	n = i - 1;
 
 	initialise(n);
 	construct_trapezoids(n);

Modified: trunk/libs3d/sei_triangulate.h
===================================================================
--- trunk/libs3d/sei_triangulate.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/sei_triangulate.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -54,23 +54,23 @@
 /* Segment attributes */
 
 typedef struct {
-	point_t v0, v1;		/* two endpoints */
-	int is_inserted;		/* inserted in trapezoidation yet ? */
-	int root0, root1;		/* root nodes in Q */
-	int next;			/* Next logical segment */
-	int prev;			/* Previous segment */
+	point_t v0, v1;  /* two endpoints */
+	int is_inserted;  /* inserted in trapezoidation yet ? */
+	int root0, root1;  /* root nodes in Q */
+	int next;   /* Next logical segment */
+	int prev;   /* Previous segment */
 } segment_t;
 
 
 /* Trapezoid attributes */
 
 typedef struct {
-	int lseg, rseg;		/* two adjoining segments */
-	point_t hi, lo;		/* max/min y-values */
+	int lseg, rseg;  /* two adjoining segments */
+	point_t hi, lo;  /* max/min y-values */
 	int u0, u1;
 	int d0, d1;
-	int sink;			/* pointer to corresponding in Q */
-	int usave, uside;		/* I forgot what this means */
+	int sink;   /* pointer to corresponding in Q */
+	int usave, uside;  /* I forgot what this means */
 	int state;
 } trap_t;
 
@@ -78,27 +78,27 @@
 /* Node attributes for every node in the query structure */
 
 typedef struct {
-	int nodetype;			/* Y-node or S-node */
+	int nodetype;   /* Y-node or S-node */
 	int segnum;
 	point_t yval;
 	int trnum;
-	int parent;			/* doubly linked DAG */
-	int left, right;		/* children */
+	int parent;   /* doubly linked DAG */
+	int left, right;  /* children */
 } node_t;
 
 
 typedef struct {
 	int vnum;
-	int next;			/* Circularly linked list  */
-	int prev;			/* describing the monotone */
-	int marked;			/* polygon */
+	int next;   /* Circularly linked list  */
+	int prev;   /* describing the monotone */
+	int marked;   /* polygon */
 } monchain_t;
 
 
 typedef struct {
 	point_t pt;
-	int vnext[4];			/* next vertices for the 4 chains */
-	int vpos[4];			/* position of v in the 4 chains */
+	int vnext[4];   /* next vertices for the 4 chains */
+	int vpos[4];   /* position of v in the 4 chains */
 	int nextfree;
 } vertexchain_t;
 
@@ -112,41 +112,41 @@
 #define T_SINK  3
 
 
-#define SEGSIZE SEI_SS	/* max# of segments. Determines how */
+#define SEGSIZE SEI_SS /* max# of segments. Determines how */
 /* many points can be specified as */
 /* input. If your datasets have large */
 /* number of points, increase this */
 /* value accordingly. */
 
-#define QSIZE   8*SEGSIZE	/* maximum table sizes */
-#define TRSIZE  4*SEGSIZE	/* max# trapezoids */
+#define QSIZE   8*SEGSIZE /* maximum table sizes */
+#define TRSIZE  4*SEGSIZE /* max# trapezoids */
 
 
 #define TRUE  1
 #define FALSE 0
 
 
-#define FIRSTPT 1		/* checking whether pt. is inserted */
+#define FIRSTPT 1  /* checking whether pt. is inserted */
 #define LASTPT  2
 
 
 #define INFINITY 1&lt;&lt;30
-#define C_EPS 1.0e-7		/* tolerance value: Used for making */
+#define C_EPS 1.0e-7  /* tolerance value: Used for making */
 /* all decisions about collinearity or */
 /* left/right of segment. Decrease */
 /* this value if the input points are */
 /* spaced very close together */
 
 
-#define S_LEFT 1		/* for merge-direction */
+#define S_LEFT 1  /* for merge-direction */
 #define S_RIGHT 2
 
 
-#define ST_VALID 1		/* for trapezium state */
+#define ST_VALID 1  /* for trapezium state */
 #define ST_INVALID 2
 
 
-#define SP_SIMPLE_LRUP 1	/* for splitting trapezoids */
+#define SP_SIMPLE_LRUP 1 /* for splitting trapezoids */
 #define SP_SIMPLE_LRDN 2
 #define SP_2UP_2DN     3
 #define SP_2UP_LEFT    4
@@ -155,7 +155,7 @@
 #define SP_2DN_RIGHT   7
 #define SP_NOSPLIT    -1
 
-#define TR_FROM_UP 1		/* for traverse-direction */
+#define TR_FROM_UP 1  /* for traverse-direction */
 #define TR_FROM_DN 2
 
 #define TRI_LHS 1
@@ -166,7 +166,7 @@
 #define MIN(a, b) (((a) &lt; (b)) ? (a) : (b))
 
 #define CROSS(v0, v1, v2) (((v1).x - (v0).x)*((v2).y - (v0).y) - \
-			   ((v1).y - (v0).y)*((v2).x - (v0).x))
+      ((v1).y - (v0).y)*((v2).x - (v0).x))
 
 #define DOT(v0, v1) ((v0).x * (v1).x + (v0).y * (v1).y)
 
@@ -176,9 +176,9 @@
 
 /* Global variables */
 
-extern node_t qs[QSIZE];		/* Query structure */
-extern trap_t tr[TRSIZE];		/* Trapezoid structure */
-extern segment_t seg[SEGSIZE];		/* Segment table */
+extern node_t qs[QSIZE];  /* Query structure */
+extern trap_t tr[TRSIZE];  /* Trapezoid structure */
+extern segment_t seg[SEGSIZE];  /* Segment table */
 
 
 /* Functions */

Modified: trunk/libs3d/shm.c
===================================================================
--- trunk/libs3d/shm.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/shm.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,31 +24,31 @@
 
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
-#include &lt;stdlib.h&gt; 	/* malloc() */
+#include &lt;stdlib.h&gt;  /* malloc() */
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/shm.h&gt;
-#include &lt;netinet/in.h&gt;	/* ntohs() */
-#include &lt;errno.h&gt; 		/* errno */
+#include &lt;netinet/in.h&gt; /* ntohs() */
+#include &lt;errno.h&gt;   /* errno */
 
 #ifndef _POSIX_C_SOURCE
-#define _POSIX_C_SOURCE 199309		/* we want struct timespec to be defined */
+#define _POSIX_C_SOURCE 199309  /* we want struct timespec to be defined */
 #endif
 #ifndef __USE_POSIX199309
 #define __USE_POSIX199309 1
 #endif
-#include &lt;time.h&gt;		 /*  nanosleep() */
+#include &lt;time.h&gt;   /*  nanosleep() */
 
 #ifdef SHM
 
-#define SHM_SIZE 		sizeof(key_t)*2  		/* space for the keys */
-#define SHM_MAXLOOP		100
-#define RB_STD_SIZE		1024*512
-static struct buf_t *data_in,*data_out;
+#define SHM_SIZE   sizeof(key_t)*2    /* space for the keys */
+#define SHM_MAXLOOP  100
+#define RB_STD_SIZE  1024*512
+static struct buf_t *data_in, *data_out;
 static int shmid_in, shmid_out;
-static int shm_idle=0;
-struct timespec t= {
-	0,10*1000*1000
+static int shm_idle = 0;
+struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili second */
 /* char ftoken[]=&quot;/tmp/.s3d_shm&quot;;*/
 
@@ -56,58 +56,58 @@
 {
 	int shmid;
 	uint32_t *next_key;
-	/*	struct shmid_ds *buf; */
-	key_t key,key_out,key_in;
+	/* struct shmid_ds *buf; */
+	key_t key, key_out, key_in;
 
-	s3dprintf(MED,&quot;connecting to shm token %s&quot;,ftoken);
+	s3dprintf(MED, &quot;connecting to shm token %s&quot;, ftoken);
 	/* make the key: */
 	if ((key = ftok(ftoken, 'R')) == -1) {
-		errn(&quot;shm_init():ftok()&quot;,errno);
+		errn(&quot;shm_init():ftok()&quot;, errno);
 		return(1);
 	}
-	s3dprintf(MED,&quot;init key is 0x%08x&quot;,key);
+	s3dprintf(MED, &quot;init key is 0x%08x&quot;, key);
 
 	/* connect to the segment: */
-	if ((shmid = shmget(key, SHM_SIZE, 0644 )) == -1) {
-		errn(&quot;shm_init():shmget()&quot;,errno);
+	if ((shmid = shmget(key, SHM_SIZE, 0644)) == -1) {
+		errn(&quot;shm_init():shmget()&quot;, errno);
 		return(1);
 	}
 
 	/* attach to the segment to get a pointer to it: */
 	next_key = shmat(shmid, (void *)0, 0);
 	if (next_key == (uint32_t *)(-1)) {
-		errn(&quot;shm_init():shmat()&quot;,errno);
+		errn(&quot;shm_init():shmat()&quot;, errno);
 		return(1);
 	}
-	s3dprintf(MED,&quot;right now, next_keys are: %08x, %08x&quot;,next_key[0],next_key[1]);
-	while ((0==(key_in=next_key[1])) || (0==(key_out=next_key[0])));
-	next_key[0]=next_key[1]=0;
-	s3dprintf(MED,&quot;right now, next_keys are: %08x, %08x&quot;,key_in,key_out);
+	s3dprintf(MED, &quot;right now, next_keys are: %08x, %08x&quot;, next_key[0], next_key[1]);
+	while ((0 == (key_in = next_key[1])) || (0 == (key_out = next_key[0])));
+	next_key[0] = next_key[1] = 0;
+	s3dprintf(MED, &quot;right now, next_keys are: %08x, %08x&quot;, key_in, key_out);
 	/* as we have the new key, we  can detach here now. */
 	if (shmdt(next_key) == -1) {
-		errn(&quot;shm_init():shmdt()&quot;,errno);
+		errn(&quot;shm_init():shmdt()&quot;, errno);
 		return(1);
 	}
 	/* get input buffer */
-	if ((shmid_in = shmget(key_in, RB_STD_SIZE, 0644 )) == -1) {
-		errn(&quot;shm_init():shmget()&quot;,errno);
+	if ((shmid_in = shmget(key_in, RB_STD_SIZE, 0644)) == -1) {
+		errn(&quot;shm_init():shmget()&quot;, errno);
 		return(1);
 	}
 	/* attach to the  in segment to get a pointer to it: */
 	data_in = (struct buf_t *) shmat(shmid_in, (void *)0, 0);
 	if (data_in == (struct buf_t *)(-1)) {
-		errn(&quot;shm_init():shmat()&quot;,errno);
+		errn(&quot;shm_init():shmat()&quot;, errno);
 		return(1);
 	}
 	/* get output buffer */
-	if ((shmid_out = shmget(key_out, RB_STD_SIZE, 0644 )) == -1) {
-		errn(&quot;shm_init():shmget()&quot;,errno);
+	if ((shmid_out = shmget(key_out, RB_STD_SIZE, 0644)) == -1) {
+		errn(&quot;shm_init():shmget()&quot;, errno);
 		return(1);
 	}
 	/* attach to the out segment to get a pointer to it: */
 	data_out = (struct buf_t *) shmat(shmid_out, (void *)0, 0);
 	if (data_out == (struct buf_t *)(-1)) {
-		errn(&quot;shm_init():shmat()&quot;,errno);
+		errn(&quot;shm_init():shmat()&quot;, errno);
 		return(1);
 	}
 	return(0);
@@ -116,85 +116,85 @@
 {
 	/* detach from the segment: */
 	if (shmdt(data_in) == -1) {
-		errn(&quot;shm_init():shmdt()&quot;,errno);
+		errn(&quot;shm_init():shmdt()&quot;, errno);
 		return(1);
 	}
 	if (shmdt(data_out) == -1) {
-		errn(&quot;shm_init():shmdt()&quot;,errno);
+		errn(&quot;shm_init():shmdt()&quot;, errno);
 		return(1);
 	}
-	data_in=data_out=NULL;
+	data_in = data_out = NULL;
 	return(0);
 }
 int shm_writen(char *str, int s)
 {
-	int no_left,no_written,wait=0;
+	int no_left, no_written, wait = 0;
 	no_left = s;
 	while (no_left &gt; 0) {
-		no_written = shm_write(data_out,str,no_left);
-		if (no_written &lt;0)
+		no_written = shm_write(data_out, str, no_left);
+		if (no_written &lt; 0)
 			return(no_written);
 		no_left -= no_written;
 		str += no_written;
-		if (wait++&gt;SHM_MAXLOOP) {
-			s3dprintf(HIGH,&quot;shm_writen():waited too long ...&quot;);
+		if (wait++ &gt; SHM_MAXLOOP) {
+			s3dprintf(HIGH, &quot;shm_writen():waited too long ...&quot;);
 			return(-1);
 		}
-		/*		if (wait&gt;10)
-					nanosleep(&amp;t,NULL); */
+		/*  if (wait&gt;10)
+		   nanosleep(&amp;t,NULL); */
 	}
 	return(s - no_left);
 }
-int shm_readn(char *str,int s)
+int shm_readn(char *str, int s)
 {
-	int no_left,no_read,wait=0;
+	int no_left, no_read, wait = 0;
 	no_left = s;
 	while (no_left &gt; 0) {
-		no_read = shm_read(data_in,str,no_left);
-		if (no_read &lt;0)
+		no_read = shm_read(data_in, str, no_left);
+		if (no_read &lt; 0)
 			return(no_read);
 		if (no_read == 0)
 			break;
 		no_left -= no_read;
 		str += no_read;
-		if (wait++&gt;SHM_MAXLOOP) {
-			s3dprintf(HIGH,&quot;shm_readn():waited too long ...&quot;);
+		if (wait++ &gt; SHM_MAXLOOP) {
+			s3dprintf(HIGH, &quot;shm_readn():waited too long ...&quot;);
 			return(-1);
 		}
-		/*		if (wait&gt;10)
-					nanosleep(&amp;t,NULL); */
+		/*  if (wait&gt;10)
+		   nanosleep(&amp;t,NULL); */
 	}
 	return(s - no_left);
 }
 int _shm_net_receive()
 {
-	int 				 found=0;
-	char				 opcode,*buf;
-	u_int16_t		 length;
-	struct shmid_ds		 d;
+	int      found = 0;
+	char     opcode, *buf;
+	u_int16_t   length;
+	struct shmid_ds   d;
 
-	if (data_in==NULL)
+	if (data_in == NULL)
 		return(found);
-	if (data_in-&gt;start!=data_in-&gt;end) {
-		if (1==shm_readn(&amp;opcode,1)) {
-			shm_readn((char *)&amp;length,2);
-			length=ntohs(length);
-			buf=malloc(length);
-			shm_readn(buf,length);
-			net_prot_in(opcode,length,buf);
-			found=1;
+	if (data_in-&gt;start != data_in-&gt;end) {
+		if (1 == shm_readn(&amp;opcode, 1)) {
+			shm_readn((char *)&amp;length, 2);
+			length = ntohs(length);
+			buf = malloc(length);
+			shm_readn(buf, length);
+			net_prot_in(opcode, length, buf);
+			found = 1;
 		} else {
-			s3dprintf(HIGH,&quot;socket seems to be dead ...&quot;);
+			s3dprintf(HIGH, &quot;socket seems to be dead ...&quot;);
 			s3d_quit();
 		}
 	} else {
-		if (shm_idle++&gt;SHM_MAX_IDLE) {
-			shmctl(shmid_in,IPC_STAT,&amp;d);
-			if (d.shm_nattch==1) { /* we're all alone ... remove it!! */
-				s3dprintf(MED,&quot;server vanished ... &quot;);
+		if (shm_idle++ &gt; SHM_MAX_IDLE) {
+			shmctl(shmid_in, IPC_STAT, &amp;d);
+			if (d.shm_nattch == 1) { /* we're all alone ... remove it!! */
+				s3dprintf(MED, &quot;server vanished ... &quot;);
 				s3d_quit();
 			} else
-				shm_idle=0;
+				shm_idle = 0;
 		}
 	}
 	return(found);

Modified: trunk/libs3d/shm_ringbuf.c
===================================================================
--- trunk/libs3d/shm_ringbuf.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/shm_ringbuf.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,77 +25,77 @@
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
 #include &lt;stdint.h&gt; /* uint32_t */
-#include &lt;string.h&gt;	/* memcpy() */
+#include &lt;string.h&gt; /* memcpy() */
 #ifdef SHM
-int shm_write(struct buf_t *rb,char *buf, int n)
+int shm_write(struct buf_t *rb, char *buf, int n)
 {
-	int wrap=0;
+	int wrap = 0;
 	int rs;
-	uint32_t e,s,size;
+	uint32_t e, s, size;
 	char *data;
 
-	e=rb-&gt;end;
-	s=rb-&gt;start;
-	size=rb-&gt;bufsize;
-	data=((char *)rb)+sizeof(struct buf_t);
-	if (e&lt;s) {
-		wrap=1;
+	e = rb-&gt;end;
+	s = rb-&gt;start;
+	size = rb-&gt;bufsize;
+	data = ((char *)rb) + sizeof(struct buf_t);
+	if (e &lt; s) {
+		wrap = 1;
 	}
-	while ((((s+size*(1-wrap))-e)&lt;(n+1))) { /* checking free space */
+	while ((((s + size*(1 - wrap)) - e) &lt; (n + 1))) { /* checking free space */
 		if /*((size*2)&gt;RB_MAX_SIZE)*/ (1) {
-			/*		s3dprintf(MED,&quot;buffer reached maxsize, no resizing possible&quot;);*/
+			/*  s3dprintf(MED,&quot;buffer reached maxsize, no resizing possible&quot;);*/
 			return(0);
 		}
-		/*		printf(&quot;buffer full!! resizing ... (to size %d)&quot;,(int)size*2);
-				if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
-				{
-					printf(&quot;realloc failed - fatal!!&quot;);
-					return(-1);
-				}
-				if (wrap)
-				{
-					memcpy(data+size,data,e);
-					e+=size;
-					wrap=0;
-				}
-				size=rb-&gt;bufsize=size*2;
-				rb-&gt;end=e;*/
+		/*  printf(&quot;buffer full!! resizing ... (to size %d)&quot;,(int)size*2);
+		  if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
+		  {
+		   printf(&quot;realloc failed - fatal!!&quot;);
+		   return(-1);
+		  }
+		  if (wrap)
+		  {
+		   memcpy(data+size,data,e);
+		   e+=size;
+		   wrap=0;
+		  }
+		  size=rb-&gt;bufsize=size*2;
+		  rb-&gt;end=e;*/
 	}
-	if ((e+n)&gt;size) {
-		rs=size-e;
-		memcpy(data+e,buf,rs);			/* copy the first part ... */
-		memcpy(data,buf+rs,n-rs); 		/* .. end the rest */
+	if ((e + n) &gt; size) {
+		rs = size - e;
+		memcpy(data + e, buf, rs);   /* copy the first part ... */
+		memcpy(data, buf + rs, n - rs);   /* .. end the rest */
 	} else {
-		memcpy(data+e,buf,n);			/* plain copy */
+		memcpy(data + e, buf, n);   /* plain copy */
 	}
-	rb-&gt;end=e+n;	/* update end of the buffer */
-	if (rb-&gt;end&gt;=rb-&gt;bufsize) rb-&gt;end-=rb-&gt;bufsize;
+	rb-&gt;end = e + n; /* update end of the buffer */
+	if (rb-&gt;end &gt;= rb-&gt;bufsize) rb-&gt;end -= rb-&gt;bufsize;
 	return(n);
 }
-int shm_read(struct buf_t *rb,char *buf, int n)
+int shm_read(struct buf_t *rb, char *buf, int n)
 {
-	int wrap=0;
-	int mn=n;
+	int wrap = 0;
+	int mn = n;
 	int rs;
-	uint32_t e,s,size;
+	uint32_t e, s, size;
 	char *data;
 
-	e=rb-&gt;end;
-	s=rb-&gt;start;
-	size=rb-&gt;bufsize;
-	data=((char *)rb)+sizeof(struct buf_t);
-	if (e&lt;s) wrap=1;
-	rs=(e+wrap*size-s);
-	mn=(n&gt;rs)?rs:n;
-	if ((wrap) &amp;&amp; (mn&gt;(size-s))) {
-		rs=size-s;	/* size of the first part */
-		memcpy(buf,data+s,rs);
-		memcpy(buf+rs,data,mn-rs);
+	e = rb-&gt;end;
+	s = rb-&gt;start;
+	size = rb-&gt;bufsize;
+	data = ((char *)rb) + sizeof(struct buf_t);
+	if (e &lt; s) wrap = 1;
+	rs = (e + wrap * size - s);
+	mn = (n &gt; rs) ? rs : n;
+	if ((wrap) &amp;&amp; (mn &gt; (size - s))) {
+		rs = size - s; /* size of the first part */
+		memcpy(buf, data + s, rs);
+		memcpy(buf + rs, data, mn - rs);
 	} else { /* no wrap (needed)*/
-		memcpy(buf,data+s,mn);
+		memcpy(buf, data + s, mn);
 	}
-	rb-&gt;start=s+mn;
-	if (rb-&gt;start&gt;=rb-&gt;bufsize) rb-&gt;start-=rb-&gt;bufsize;
+	rb-&gt;start = s + mn;
+	if (rb-&gt;start &gt;= rb-&gt;bufsize) rb-&gt;start -= rb-&gt;bufsize;
 	return(mn);
 }
 #endif

Modified: trunk/libs3d/tcp.c
===================================================================
--- trunk/libs3d/tcp.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/tcp.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,45 +24,45 @@
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
 #include &lt;sys/types.h&gt;
-#include &lt;stdlib.h&gt;		 /*  malloc(), free() */
-#include &lt;unistd.h&gt;		 /*  read(), write() */
-#include &lt;errno.h&gt;		 /*  errno */
-#include &lt;string.h&gt; 	 /*  memcpy() */
+#include &lt;stdlib.h&gt;   /*  malloc(), free() */
+#include &lt;unistd.h&gt;   /*  read(), write() */
+#include &lt;errno.h&gt;   /*  errno */
+#include &lt;string.h&gt;   /*  memcpy() */
 #include &lt;sys/socket.h&gt;
 #include &lt;netinet/in.h&gt;  /*  htons(),htonl() */
 #ifndef WIN32
 #include &lt;sys/select.h&gt;
-#include &lt;netdb.h&gt;		 /*  gethostbyname()  */
+#include &lt;netdb.h&gt;   /*  gethostbyname()  */
 #endif
 #ifdef SIGS
-#define __USE_BSD	1		/* we want sig_t and F_SETOWN to be defined */
-#include &lt;fcntl.h&gt;		 /*  fcntl */
-#include &lt;signal.h&gt;		 /*  signal(), SIGPIPE, SIGIO */
+#define __USE_BSD 1  /* we want sig_t and F_SETOWN to be defined */
+#include &lt;fcntl.h&gt;   /*  fcntl */
+#include &lt;signal.h&gt;   /*  signal(), SIGPIPE, SIGIO */
 extern int _s3d_sigio;
 #endif
 
-int s3d_socket;		 /*  this is the socket which holds the tcp-socket .... */
+int s3d_socket;   /*  this is the socket which holds the tcp-socket .... */
 
 #ifdef SIGS
 void sigpipe_handler(int S3DUNUSED(sig), int S3DUNUSED(code))  /*  ... ? */
 {
-	errs(&quot;sigpipe_handler()&quot;,&quot;there is a broken pipe somewhere&quot;);
+	errs(&quot;sigpipe_handler()&quot;, &quot;there is a broken pipe somewhere&quot;);
 }
 void sigio_handler(int S3DUNUSED(sig), int S3DUNUSED(code))  /*  ... ? */
 {
-	_s3d_sigio=1;
+	_s3d_sigio = 1;
 }
 #endif
 
 int _tcp_init(char *sv, int pn)
 {
-	int 	 			 sd;
-	int 				 res;
-	/*	char			 	*port=NULL;*/
-	struct sockaddr_in 	 sock;
-	struct hostent 		*server=0;
+	int       sd;
+	int      res;
+	/* char     *port=NULL;*/
+	struct sockaddr_in   sock;
+	struct hostent   *server = 0;
 #ifdef SIGS
-	_s3d_sigio=0;
+	_s3d_sigio = 0;
 #endif
 #ifdef WIN32
 	WSADATA datainfo;
@@ -72,70 +72,70 @@
 	}
 #endif
 	if ((sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) {
-		errn(&quot;s3d_init():socket()&quot;,errno);
+		errn(&quot;s3d_init():socket()&quot;, errno);
 		return (-1);
 	}
 	sock.sin_family = AF_INET;
-	if (*sv==0)  /*  no server argument */
-		sv=&quot;127.0.0.1&quot;;
+	if (*sv == 0)  /*  no server argument */
+		sv = &quot;127.0.0.1&quot;;
 	if ((server = gethostbyname(sv)))
 		memcpy(&amp;sock.sin_addr.s_addr, server-&gt;h_addr_list[0], 4);
 	else {
-		errn(&quot;s3d_init():gethostbyname()&quot;,errno);
+		errn(&quot;s3d_init():gethostbyname()&quot;, errno);
 		return(-1);
 	}
 	sock.sin_port = htons(pn);
 
-	res = connect(sd, (struct sockaddr *) &amp;sock, sizeof(struct sockaddr_in));
-	if (res &lt; 0 ) {
-		errn(&quot;s3d_init():connect()&quot;,errno);
+	res = connect(sd, (struct sockaddr *) &amp; sock, sizeof(struct sockaddr_in));
+	if (res &lt; 0) {
+		errn(&quot;s3d_init():connect()&quot;, errno);
 		return(-1);
 	}
 	/*    if ( fcntl(sd, F_SETFL, O_ASYNC | O_NONBLOCK) &lt; 0 ) */
-	/* 		errn(&quot;fcntl()&quot;,errno); */
+	/*   errn(&quot;fcntl()&quot;,errno); */
 #ifdef SIGS
-	if ( fcntl(sd, F_SETFL, O_ASYNC ) &lt; 0 )
-		errn(&quot;fcntl()&quot;,errno);
-	if ( fcntl(sd, F_SETOWN, getpid()) &lt; 0 )
-		errn(&quot;fcntl()&quot;,errno);
+	if (fcntl(sd, F_SETFL, O_ASYNC) &lt; 0)
+		errn(&quot;fcntl()&quot;, errno);
+	if (fcntl(sd, F_SETOWN, getpid()) &lt; 0)
+		errn(&quot;fcntl()&quot;, errno);
 	if (signal(SIGPIPE, (sig_t)sigpipe_handler) == SIG_ERR)
-		errn(&quot;_tcp_init():signal()&quot;,errno);
+		errn(&quot;_tcp_init():signal()&quot;, errno);
 	if (signal(SIGIO, (sig_t)sigio_handler) == SIG_ERR)
-		errn(&quot;_tcp_init():signal()&quot;,errno);
+		errn(&quot;_tcp_init():signal()&quot;, errno);
 #endif
-	s3d_socket=sd;
-	s3dprintf(MED,&quot;connection to %s:%d established&quot;, sv, pn);
+	s3d_socket = sd;
+	s3dprintf(MED, &quot;connection to %s:%d established&quot;, sv, pn);
 	return(0);
 }
 int _tcp_quit()
 {
 	if (s3d_socket) {
-		s3dprintf(MED,&quot;closing socket %d&quot;,s3d_socket);
+		s3dprintf(MED, &quot;closing socket %d&quot;, s3d_socket);
 		close(s3d_socket);
-		s3d_socket=0;
+		s3d_socket = 0;
 	}
 	return(0);
 }
-int tcp_readn(char *str,int s)
+int tcp_readn(char *str, int s)
 {
-	int no_left,no_read;
+	int no_left, no_read;
 	no_left = s;
 	while (no_left &gt; 0) {
-		no_read = read(s3d_socket,str,no_left);
-		if (no_read &lt;0)  return(no_read);
+		no_read = read(s3d_socket, str, no_left);
+		if (no_read &lt; 0)  return(no_read);
 		if (no_read == 0) break;
 		no_left -= no_read;
 		str += no_read;
 	}
 	return(s - no_left);
 }
-int tcp_writen(char *str,int s)
+int tcp_writen(char *str, int s)
 {
-	int no_left,no_written;
+	int no_left, no_written;
 	no_left = s;
 	while (no_left &gt; 0) {
-		no_written = write(s3d_socket,str,no_left);
-		if (no_written &lt;=0)  return(no_written);
+		no_written = write(s3d_socket, str, no_left);
+		if (no_written &lt;= 0)  return(no_written);
 		no_left -= no_written;
 		str += no_written;
 	}
@@ -143,33 +143,33 @@
 }
 int _s3d_tcp_net_receive()
 {
-	fd_set				 fs_proc; 	 /*  filedescriptor set for listening port(s) */
-	struct timeval		 tv;		 /*  time structure */
-	int 				 found=0;
-	char				 opcode,*buf;
-	u_int16_t		 length;
+	fd_set     fs_proc;   /*  filedescriptor set for listening port(s) */
+	struct timeval   tv;   /*  time structure */
+	int      found = 0;
+	char     opcode, *buf;
+	u_int16_t   length;
 
 
-	if (s3d_socket!=-1) {
+	if (s3d_socket != -1) {
 		FD_ZERO(&amp;fs_proc);
-		tv.tv_sec=tv.tv_usec=0;
-		FD_SET(s3d_socket,&amp;fs_proc);
+		tv.tv_sec = tv.tv_usec = 0;
+		FD_SET(s3d_socket, &amp;fs_proc);
 
 		/* s3dprintf(LOW,&quot;Added %d procceses into file descriptor ...&quot;, n); */
-		if (select(FD_SETSIZE, &amp;fs_proc, NULL,NULL,&amp;tv) ==-1) {
-			errn(&quot;select()&quot;,errno);
+		if (select(FD_SETSIZE, &amp;fs_proc, NULL, NULL, &amp;tv) == -1) {
+			errn(&quot;select()&quot;, errno);
 		} else {
 			/*  data is available */
-			if (FD_ISSET(s3d_socket,&amp;fs_proc)) {
-				if (1==tcp_readn(&amp;opcode,1)) {
-					tcp_readn((char *)&amp;length,2);
-					length=ntohs(length);
-					buf=malloc(length);
-					tcp_readn(buf,length);
-					net_prot_in(opcode,length,buf);
-					found=1;
+			if (FD_ISSET(s3d_socket, &amp;fs_proc)) {
+				if (1 == tcp_readn(&amp;opcode, 1)) {
+					tcp_readn((char *)&amp;length, 2);
+					length = ntohs(length);
+					buf = malloc(length);
+					tcp_readn(buf, length);
+					net_prot_in(opcode, length, buf);
+					found = 1;
 				} else {
-					s3dprintf(HIGH,&quot;socket seems to be dead ...&quot;);
+					s3dprintf(HIGH, &quot;socket seems to be dead ...&quot;);
 					s3d_quit();
 				}
 			}

Modified: trunk/libs3d/vector.c
===================================================================
--- trunk/libs3d/vector.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/vector.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,7 +23,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#include &lt;math.h&gt;		/* sqrt() */
+#include &lt;math.h&gt;  /* sqrt() */
 #include &quot;s3d.h&quot;
 
 /***
@@ -36,10 +36,10 @@
  *
  ***/
 
-float s3d_vector_length( float vector[] )
+float s3d_vector_length(float vector[])
 {
 
-	return ( sqrt( vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2] ) );
+	return (sqrt(vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2]));
 
 }
 
@@ -54,7 +54,7 @@
  *
  ***/
 
-void s3d_vector_subtract( float vector1[], float vector2[], float result_vector[] )
+void s3d_vector_subtract(float vector1[], float vector2[], float result_vector[])
 {
 
 	result_vector[0] = vector2[0] - vector1[0];
@@ -74,9 +74,9 @@
  *
  ***/
 
-float s3d_vector_dot_product( float vector1[], float vector2[] )
+float s3d_vector_dot_product(float vector1[], float vector2[])
 {
-	return ( vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2] );
+	return (vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2]);
 }
 
 /***
@@ -85,16 +85,16 @@
  *
  *   vector1         =&gt;   given vector1
  *   vector2         =&gt;   given vector2
- *	 result_vector   =&gt;   save resulting vector here
+ *  result_vector   =&gt;   save resulting vector here
  *   return dot product
  *
  ***/
 
-void s3d_vector_cross_product( float vector1[], float vector2[], float result_vector[] )
+void s3d_vector_cross_product(float vector1[], float vector2[], float result_vector[])
 {
-	result_vector[0]=vector1[1] * vector2[2] - vector1[2] * vector2[1];
-	result_vector[1]=vector1[2] * vector2[0] - vector1[0] * vector2[2];
-	result_vector[2]=vector1[0] * vector2[1] - vector1[1] * vector2[0];
+	result_vector[0] = vector1[1] * vector2[2] - vector1[2] * vector2[1];
+	result_vector[1] = vector1[2] * vector2[0] - vector1[0] * vector2[2];
+	result_vector[2] = vector1[0] * vector2[1] - vector1[1] * vector2[0];
 }
 /***
  *
@@ -109,10 +109,10 @@
  *
  ***/
 
-float s3d_vector_angle( float vector1[], float vector2[] )
+float s3d_vector_angle(float vector1[], float vector2[])
 {
 
-	return ( acos( s3d_vector_dot_product( vector1, vector2 ) / ( s3d_vector_length( vector1 ) * s3d_vector_length( vector2 ) ) ) );
+	return (acos(s3d_vector_dot_product(vector1, vector2) / (s3d_vector_length(vector1) * s3d_vector_length(vector2))));
 
 }
 
@@ -128,7 +128,7 @@
  *
  ***/
 
-float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad )
+float s3d_angle_to_cam(float obj_pos[], float cam_pos[], float *angle_rad)
 {
 
 	float angle, tmp_mov_vec[3], desc_norm_vec[3] = { 0.0, 0.0, -1.0 };
@@ -138,15 +138,15 @@
 	tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
 	tmp_mov_vec[2] = cam_pos[2] - obj_pos[2];
 
-	angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
+	angle = s3d_vector_angle(desc_norm_vec, tmp_mov_vec);
 
 	/* take care of inverse cosinus */
-	if ( tmp_mov_vec[0] &gt; 0 ) {
-		*angle_rad = 90.0/M_PI - angle;
-		angle = 180 - ( 180.0/M_PI * angle );
+	if (tmp_mov_vec[0] &gt; 0) {
+		*angle_rad = 90.0 / M_PI - angle;
+		angle = 180 - (180.0 / M_PI * angle);
 	} else {
-		*angle_rad = 90.0/M_PI + angle;
-		angle = 180 + ( 180.0/M_PI * angle );
+		*angle_rad = 90.0 / M_PI + angle;
+		angle = 180 + (180.0 / M_PI * angle);
 	}
 
 	return angle;

Modified: trunk/libs3dw/animate.c
===================================================================
--- trunk/libs3dw/animate.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/animate.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -28,17 +28,17 @@
 
 /* the animation stack */
 static s3dw_widget *ani_s[MAXANI];
-static int ani_n=0;
-static int animation_on=0;
-int ani_need_arr=0;
+static int ani_n = 0;
+static int animation_on = 0;
+int ani_need_arr = 0;
 
 /* is item f already on stack? */
 int s3dw_ani_onstack(s3dw_widget *f)
 {
 	int i;
-	for (i=0;i&lt;ani_n;i++)
-		if (ani_s[i]==f)
-			return(1);		/* already in list */
+	for (i = 0;i &lt; ani_n;i++)
+		if (ani_s[i] == f)
+			return(1);  /* already in list */
 	return(0);
 
 }
@@ -46,90 +46,90 @@
 void s3dw_ani_add(s3dw_widget *f)
 {
 
-	if ((f-&gt;oid == 0) &amp;&amp; (f-&gt;type!=S3DW_TCAM)) {
-		s3dprintf(HIGH,&quot;s3dw_ani_add() assert failed: weird, moving cam but its not a cam obeject?&quot;);
+	if ((f-&gt;oid == 0) &amp;&amp; (f-&gt;type != S3DW_TCAM)) {
+		s3dprintf(HIGH, &quot;s3dw_ani_add() assert failed: weird, moving cam but its not a cam obeject?&quot;);
 		return;
 	}
-	if ((ani_n&lt;MAXANI) &amp;&amp; (animation_on)) {
+	if ((ani_n &lt; MAXANI) &amp;&amp; (animation_on)) {
 		if (s3dw_ani_onstack(f))
-			return;		/* already in list */
-		ani_s[ani_n]=f;
+			return;  /* already in list */
+		ani_s[ani_n] = f;
 		s3dw_ani_iterate(f);
 		ani_n++;
 	} else /* no place, finish now */
-		s3dw_ani_finish(f,-1);
+		s3dw_ani_finish(f, -1);
 }
 /* delete an item from the animation stack */
 void s3dw_ani_del(int i)
 {
-	if ((i&gt;=0) &amp;&amp; (i&lt;ani_n)) {
-		/*		printf(&quot;[A]ni DEL %d\n&quot;,i);*/
+	if ((i &gt;= 0) &amp;&amp; (i &lt; ani_n)) {
+		/*  printf(&quot;[A]ni DEL %d\n&quot;,i);*/
 		ani_n--;
-		ani_s[i]=ani_s[ani_n]; /* that should also work if i is the last one */
+		ani_s[i] = ani_s[ani_n]; /* that should also work if i is the last one */
 	} else {
-		s3dprintf(MED,&quot;[F]ATAL: can't delete animation!\n&quot;);
+		s3dprintf(MED, &quot;[F]ATAL: can't delete animation!\n&quot;);
 	}
 }
 /* well ... */
 void s3dw_ani_doit(s3dw_widget *f)
 {
-	if ((f-&gt;oid == 0) &amp;&amp; (f-&gt;type!=S3DW_TCAM)) {
-		s3dprintf(HIGH,&quot;s3dw_ani_doit() assert failed: weird, moving cam but its not a cam obeject?&quot;);
+	if ((f-&gt;oid == 0) &amp;&amp; (f-&gt;type != S3DW_TCAM)) {
+		s3dprintf(HIGH, &quot;s3dw_ani_doit() assert failed: weird, moving cam but its not a cam obeject?&quot;);
 	} else {
-		if (f-&gt;oid==0) {
-			s3dprintf(HIGH,&quot;moving cam&quot;);
+		if (f-&gt;oid == 0) {
+			s3dprintf(HIGH, &quot;moving cam&quot;);
 		}
-		s3d_translate(	f-&gt;oid, f-&gt;ax,f-&gt;ay,f-&gt;az);
-		s3d_rotate(		f-&gt;oid, f-&gt;arx,f-&gt;ary,f-&gt;arz);
-		s3d_scale(		f-&gt;oid, f-&gt;as);
+		s3d_translate(f-&gt;oid, f-&gt;ax, f-&gt;ay, f-&gt;az);
+		s3d_rotate(f-&gt;oid, f-&gt;arx, f-&gt;ary, f-&gt;arz);
+		s3d_scale(f-&gt;oid, f-&gt;as);
 	}
 }
 
 /* finish an animation on the stack, stack index i */
 void s3dw_ani_finish(s3dw_widget *f, int i)
 {
-	f-&gt;ax= f-&gt;x;
-	f-&gt;ay= f-&gt;y;
-	f-&gt;az= f-&gt;z;
-	f-&gt;arx= f-&gt;rx;
-	f-&gt;ary= f-&gt;ry;
-	f-&gt;arz= f-&gt;rz;
-	f-&gt;as= f-&gt;s;
+	f-&gt;ax = f-&gt;x;
+	f-&gt;ay = f-&gt;y;
+	f-&gt;az = f-&gt;z;
+	f-&gt;arx = f-&gt;rx;
+	f-&gt;ary = f-&gt;ry;
+	f-&gt;arz = f-&gt;rz;
+	f-&gt;as = f-&gt;s;
 	s3dw_ani_doit(f);
-	if (i!=-1)
+	if (i != -1)
 		s3dw_ani_del(i);
 }
 void s3dw_ani_iterate(s3dw_widget *f)
 {
-	f-&gt;ax=(f-&gt;x + f-&gt;ax*ZOOMS)/(ZOOMS+1);
-	f-&gt;ay=(f-&gt;y + f-&gt;ay*ZOOMS)/(ZOOMS+1);
-	f-&gt;az=(f-&gt;z + f-&gt;az*ZOOMS)/(ZOOMS+1);
-	f-&gt;arx=(f-&gt;rx + f-&gt;arx*ZOOMS)/(ZOOMS+1);
-	f-&gt;ary=(f-&gt;ry + f-&gt;ary*ZOOMS)/(ZOOMS+1);
-	f-&gt;arz=(f-&gt;rz + f-&gt;arz*ZOOMS)/(ZOOMS+1);
-	f-&gt;as=(f-&gt;s + f-&gt;as*ZOOMS)/(ZOOMS+1);
+	f-&gt;ax = (f-&gt;x + f-&gt;ax * ZOOMS) / (ZOOMS + 1);
+	f-&gt;ay = (f-&gt;y + f-&gt;ay * ZOOMS) / (ZOOMS + 1);
+	f-&gt;az = (f-&gt;z + f-&gt;az * ZOOMS) / (ZOOMS + 1);
+	f-&gt;arx = (f-&gt;rx + f-&gt;arx * ZOOMS) / (ZOOMS + 1);
+	f-&gt;ary = (f-&gt;ry + f-&gt;ary * ZOOMS) / (ZOOMS + 1);
+	f-&gt;arz = (f-&gt;rz + f-&gt;arz * ZOOMS) / (ZOOMS + 1);
+	f-&gt;as = (f-&gt;s + f-&gt;as * ZOOMS) / (ZOOMS + 1);
 
 }
 
 /* checks if f is good enough */
 int s3dw_ani_check(s3dw_widget *f)
 {
-	float x,y,z,rx,ry,rz;
-	x=f-&gt;ax - f-&gt;x;
-	y=f-&gt;ay - f-&gt;y;
-	z=f-&gt;az - f-&gt;z;
-	rx=f-&gt;arx - f-&gt;rx;
-	ry=f-&gt;ary - f-&gt;ry;
-	rz=f-&gt;arz - f-&gt;rz;
+	float x, y, z, rx, ry, rz;
+	x = f-&gt;ax - f-&gt;x;
+	y = f-&gt;ay - f-&gt;y;
+	z = f-&gt;az - f-&gt;z;
+	rx = f-&gt;arx - f-&gt;rx;
+	ry = f-&gt;ary - f-&gt;ry;
+	rz = f-&gt;arz - f-&gt;rz;
 
-	if (((fabs(f-&gt;as - f-&gt;s)/f-&gt;s)&gt;0.01) || (sqrt(x*x+y*y+z*z) &gt; 0.01) || (sqrt(rx*rx+ry*ry+rz*rz) &gt; 0.01))
+	if (((fabs(f-&gt;as - f-&gt;s) / f-&gt;s) &gt; 0.01) || (sqrt(x*x + y*y + z*z) &gt; 0.01) || (sqrt(rx*rx + ry*ry + rz*rz) &gt; 0.01))
 		return(0);
 	return(1);
 }
 /* need an arrangement ... */
 void s3dw_ani_needarr()
 {
-	ani_need_arr=1;
+	ani_need_arr = 1;
 	if (!animation_on) {
 		while (ani_need_arr) s3dw_arrange();
 	}
@@ -140,13 +140,13 @@
 {
 	int i;
 	s3dw_widget *f;
-	animation_on=1;			/* animation is activated */
+	animation_on = 1; /* animation is activated */
 	if (ani_need_arr) s3dw_arrange();
-	for (i=0;i&lt;ani_n;i++) {
-		f=ani_s[i];
+	for (i = 0;i &lt; ani_n;i++) {
+		f = ani_s[i];
 		s3dw_ani_iterate(f);
 		if (s3dw_ani_check(f)) {
-			s3dw_ani_finish(f,i);
+			s3dw_ani_finish(f, i);
 			i--; /* a new widget is here now, take care in the next iteration */
 		} else {
 			s3dw_ani_doit(f);

Modified: trunk/libs3dw/arrange.c
===================================================================
--- trunk/libs3dw/arrange.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/arrange.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,121 +25,121 @@
 #include &lt;s3dw.h&gt;
 #include &lt;s3dw_int.h&gt;
 #include &lt;stdlib.h&gt; /* rand(), RAND_MAX */
-#include &lt;math.h&gt;	/* M_PI */
-#define R2D		(180/M_PI)
-s3dw_widget *_s3dw_cam=NULL;
+#include &lt;math.h&gt; /* M_PI */
+#define R2D  (180/M_PI)
+s3dw_widget *_s3dw_cam = NULL;
 extern int ani_need_arr;
 
 void s3dw_arr_widgetcenter(s3dw_widget *widget, float *center)
 {
-	float x,y,z,xt,yt,zt;
-	x=widget-&gt;s*widget-&gt;width/2;
-	y=widget-&gt;s*-widget-&gt;height/2+0.5;
-	z=widget-&gt;s*0.5;
+	float x, y, z, xt, yt, zt;
+	x = widget-&gt;s * widget-&gt;width / 2;
+	y = widget-&gt;s * -widget-&gt;height / 2 + 0.5;
+	z = widget-&gt;s * 0.5;
 	/* calc back rotation */
 	/* around the y axis (horizontal direction) */
-	xt= cos(widget-&gt;ry/R2D)*x + sin(widget-&gt;ry/R2D) *z;
-	yt=y;
-	zt=-sin(widget-&gt;ry/R2D)*x + cos(widget-&gt;ry/R2D) *z;
+	xt = cos(widget-&gt;ry / R2D) * x + sin(widget-&gt;ry / R2D) * z;
+	yt = y;
+	zt = -sin(widget-&gt;ry / R2D) * x + cos(widget-&gt;ry / R2D) * z;
 
 	/* around the x axis (vertical direction) */
-	x=xt;
-	y= cos(widget-&gt;rx/R2D)*yt + sin(widget-&gt;rx/R2D) *zt;
-	z=-sin(widget-&gt;rx/R2D)*yt + cos(widget-&gt;rx/R2D) *zt;
+	x = xt;
+	y = cos(widget-&gt;rx / R2D) * yt + sin(widget-&gt;rx / R2D) * zt;
+	z = -sin(widget-&gt;rx / R2D) * yt + cos(widget-&gt;rx / R2D) * zt;
 
-	center[0]=x;
-	center[1]=y;
-	center[2]=z;
+	center[0] = x;
+	center[1] = y;
+	center[2] = z;
 }
 void s3dw_arr_normdir(float *dir)
 {
-	float dirlen=s3d_vector_length(dir);
-	while ((dirlen=s3d_vector_length(dir))==0) {
+	float dirlen = s3d_vector_length(dir);
+	while ((dirlen = s3d_vector_length(dir)) == 0) {
 		/* make up some random direction if they're exactly the same position */
-		dir[0]=((float)rand() - RAND_MAX/2.0)/RAND_MAX;
-		dir[1]=((float)rand() - RAND_MAX/2.0)/RAND_MAX;
-		dir[2]=((float)rand() - RAND_MAX/2.0)/RAND_MAX;
+		dir[0] = ((float)rand() - RAND_MAX / 2.0) / RAND_MAX;
+		dir[1] = ((float)rand() - RAND_MAX / 2.0) / RAND_MAX;
+		dir[2] = ((float)rand() - RAND_MAX / 2.0) / RAND_MAX;
 	}
-	dir[0]/=dirlen;
-	dir[1]/=dirlen;
-	dir[2]/=dirlen;
+	dir[0] /= dirlen;
+	dir[1] /= dirlen;
+	dir[2] /= dirlen;
 }
 void s3dw_turn()
 {
-	s3dw_widget *w,*root=s3dw_getroot();
+	s3dw_widget *w, *root = s3dw_getroot();
 	int i;
-	float a[3],b[3],rx,ry;
-	float op[3],np[3];
-	a[0]=0;
-	a[1]=0;
-	a[2]=1;
-	for (i=0;i&lt;root-&gt;nobj;i++) {
-		w=root-&gt;pobj[i];
-		if ((w-&gt;oid!=0) &amp;&amp; (w-&gt;flags&amp;S3DW_TURN_CAM)) {
-			s3dw_arr_widgetcenter(w,op);
+	float a[3], b[3], rx, ry;
+	float op[3], np[3];
+	a[0] = 0;
+	a[1] = 0;
+	a[2] = 1;
+	for (i = 0;i &lt; root-&gt;nobj;i++) {
+		w = root-&gt;pobj[i];
+		if ((w-&gt;oid != 0) &amp;&amp; (w-&gt;flags&amp;S3DW_TURN_CAM)) {
+			s3dw_arr_widgetcenter(w, op);
 			/* horizontal movement */
-			b[0]=w-&gt;x + op[0]  - _s3dw_cam-&gt;x;
-			b[1]=0;
-			b[2]=w-&gt;z + op[2]  - _s3dw_cam-&gt;z;
-			ry=180*s3d_vector_angle(a,b)/M_PI;
-			if ((b[0]==0) &amp;&amp; (b[1]==0) &amp;&amp; (b[2]==0)) ry=0;
+			b[0] = w-&gt;x + op[0]  - _s3dw_cam-&gt;x;
+			b[1] = 0;
+			b[2] = w-&gt;z + op[2]  - _s3dw_cam-&gt;z;
+			ry = 180 * s3d_vector_angle(a, b) / M_PI;
+			if ((b[0] == 0) &amp;&amp; (b[1] == 0) &amp;&amp; (b[2] == 0)) ry = 0;
 			/* correct acos incompletness */
-			if (b[0]&lt;0) ry=180-ry;
-			else 		ry=180+ry;
+			if (b[0] &lt; 0) ry = 180 - ry;
+			else   ry = 180 + ry;
 
-			b[2]=sqrt(b[0]*b[0] + b[2]*b[2]);
-			b[1]=w-&gt;y + op[1]   - _s3dw_cam-&gt;y;
-			b[0]=0;
-			rx=180*s3d_vector_angle(a,b)/M_PI;
-			if ((b[0]==0) &amp;&amp; (b[1]==0) &amp;&amp; (b[2]==0)) rx=0;
-			if (b[1]&gt;0) rx=180-rx;
-			else 		rx=180+rx;
-			if 		((rx&gt;90) &amp;&amp; (rx&lt;=180)) 	 rx=180 - rx;
-			else if ((rx&gt;=180) &amp;&amp; (rx&lt;270))  rx=540 - rx ;
+			b[2] = sqrt(b[0] * b[0] + b[2] * b[2]);
+			b[1] = w-&gt;y + op[1]   - _s3dw_cam-&gt;y;
+			b[0] = 0;
+			rx = 180 * s3d_vector_angle(a, b) / M_PI;
+			if ((b[0] == 0) &amp;&amp; (b[1] == 0) &amp;&amp; (b[2] == 0)) rx = 0;
+			if (b[1] &gt; 0) rx = 180 - rx;
+			else   rx = 180 + rx;
+			if ((rx &gt; 90) &amp;&amp; (rx &lt;= 180))   rx = 180 - rx;
+			else if ((rx &gt;= 180) &amp;&amp; (rx &lt; 270))  rx = 540 - rx ;
 
-			w-&gt;rx=rx;
-			w-&gt;ry=ry;
-			if ((w-&gt;arx - w-&gt;rx)&gt;180)  w-&gt;arx-=360;
-			if ((w-&gt;arx - w-&gt;rx)&lt;-180) w-&gt;arx+=360;
-			if ((w-&gt;ary - w-&gt;ry)&gt;180)  w-&gt;ary-=360;
-			if ((w-&gt;ary - w-&gt;ry)&lt;-180) w-&gt;ary+=360;
+			w-&gt;rx = rx;
+			w-&gt;ry = ry;
+			if ((w-&gt;arx - w-&gt;rx) &gt; 180)  w-&gt;arx -= 360;
+			if ((w-&gt;arx - w-&gt;rx) &lt; -180) w-&gt;arx += 360;
+			if ((w-&gt;ary - w-&gt;ry) &gt; 180)  w-&gt;ary -= 360;
+			if ((w-&gt;ary - w-&gt;ry) &lt; -180) w-&gt;ary += 360;
 
 
-			s3dw_arr_widgetcenter(w,np);
-			w-&gt;x-=np[0] - op[0];
-			w-&gt;y-=np[1] - op[1];
-			w-&gt;z-=np[2] - op[2];
+			s3dw_arr_widgetcenter(w, np);
+			w-&gt;x -= np[0] - op[0];
+			w-&gt;y -= np[1] - op[1];
+			w-&gt;z -= np[2] - op[2];
 
 			s3dw_ani_add(w);
 		}
 	}
 }
-#define DIST	40.0
+#define DIST 40.0
 void s3dw_follow()
 {
-	s3dw_widget *w,*root=s3dw_getroot();
+	s3dw_widget *w, *root = s3dw_getroot();
 	int i;
 	float b[3];
 	float op[3];
-	float lsqr,l;
-	for (i=0;i&lt;root-&gt;nobj;i++) {
-		w=root-&gt;pobj[i];
-		if ((w-&gt;oid!=0) &amp;&amp; (w-&gt;flags&amp;S3DW_FOLLOW_CAM))
+	float lsqr, l;
+	for (i = 0;i &lt; root-&gt;nobj;i++) {
+		w = root-&gt;pobj[i];
+		if ((w-&gt;oid != 0) &amp;&amp; (w-&gt;flags&amp;S3DW_FOLLOW_CAM))
 
 		{
-			s3dw_arr_widgetcenter(w,op);
+			s3dw_arr_widgetcenter(w, op);
 			/* horizontal movement */
-			b[0]=_s3dw_cam-&gt;x - (w-&gt;x + op[0]);
-			b[1]=_s3dw_cam-&gt;y - (w-&gt;y + op[1]);
-			b[2]=_s3dw_cam-&gt;z - (w-&gt;z + op[2]);
-			if ((lsqr=(b[0]*b[0] + b[1]*b[1] + b[2]*b[2])) &gt; (DIST * DIST)) {
+			b[0] = _s3dw_cam-&gt;x - (w-&gt;x + op[0]);
+			b[1] = _s3dw_cam-&gt;y - (w-&gt;y + op[1]);
+			b[2] = _s3dw_cam-&gt;z - (w-&gt;z + op[2]);
+			if ((lsqr = (b[0] * b[0] + b[1] * b[1] + b[2] * b[2])) &gt; (DIST * DIST)) {
 				/* need to adjust ... */
-				l=sqrt(lsqr);
-				w-&gt;x+= b[0]-b[0]*DIST/l;
-				w-&gt;y+= b[1]-b[1]*DIST/l;
-				w-&gt;z+= b[2]-b[2]*DIST/l;
-				w-&gt;flags&amp;=~S3DW_ARRANGED;
-				ani_need_arr=1;
+				l = sqrt(lsqr);
+				w-&gt;x += b[0] - b[0] * DIST / l;
+				w-&gt;y += b[1] - b[1] * DIST / l;
+				w-&gt;z += b[2] - b[2] * DIST / l;
+				w-&gt;flags &amp;= ~S3DW_ARRANGED;
+				ani_need_arr = 1;
 				s3dw_ani_add(w);
 
 			}
@@ -148,50 +148,50 @@
 }
 void s3dw_arrange()
 {
-	s3dw_widget *w1,*w2,*root=s3dw_getroot();
-	int i,j,arranged,allarr;
-	float len1,len2, dirlen;
+	s3dw_widget *w1, *w2, *root = s3dw_getroot();
+	int i, j, arranged, allarr;
+	float len1, len2, dirlen;
 	float tomove, move1, move2;
-	float f1[3],f2[3],dir[3];
+	float f1[3], f2[3], dir[3];
 
 	/* test if there is anything to arrange ... */
-	arranged=1;
-	for (i=0;i&lt;root-&gt;nobj;i++)
-		if (!(root-&gt;pobj[i]-&gt;flags&amp;S3DW_ARRANGED)) arranged=0;
+	arranged = 1;
+	for (i = 0;i &lt; root-&gt;nobj;i++)
+		if (!(root-&gt;pobj[i]-&gt;flags&amp;S3DW_ARRANGED)) arranged = 0;
 	if (arranged &amp;&amp; !ani_need_arr) return; /* no arrangement necceasary .... */
 
-	ani_need_arr=0;
-	if (root-&gt;nobj==1) {
-		w1=root-&gt;pobj[0];
-		w1-&gt;flags|=S3DW_ARRANGED; /* done */
+	ani_need_arr = 0;
+	if (root-&gt;nobj == 1) {
+		w1 = root-&gt;pobj[0];
+		w1-&gt;flags |= S3DW_ARRANGED; /* done */
 		return;
 	}
-	allarr=1;
-	for (i=0;i&lt;root-&gt;nobj;i++) {
-		w1=root-&gt;pobj[i];
-		arranged=1;
-		for (j=0;j&lt;root-&gt;nobj;j++) {
-			w2=root-&gt;pobj[j];
-			if ((i!=j) &amp;&amp; ((w1-&gt;oid!=0) &amp;&amp; (w2-&gt;oid!=0))) {
-				s3dw_arr_widgetcenter(w1,f1);
-				s3dw_arr_widgetcenter(w2,f2);
-				len1=s3d_vector_length(f1);
-				len2=s3d_vector_length(f2);
-				dir[0]=(w1-&gt;x+f1[0]) - (w2-&gt;x+f2[0]);
-				dir[1]=(w1-&gt;y+f1[1]) - (w2-&gt;y+f2[1]);
-				dir[2]=(w1-&gt;z+f1[2]) - (w2-&gt;z+f2[2]);
-				dirlen=s3d_vector_length(dir);
-				if (dirlen&lt;(len1+len2)) {
-					allarr=0;
-					arranged=0;
-					w1-&gt;flags&amp;=~S3DW_ARRANGED;
-					w2-&gt;flags&amp;=~S3DW_ARRANGED;
+	allarr = 1;
+	for (i = 0;i &lt; root-&gt;nobj;i++) {
+		w1 = root-&gt;pobj[i];
+		arranged = 1;
+		for (j = 0;j &lt; root-&gt;nobj;j++) {
+			w2 = root-&gt;pobj[j];
+			if ((i != j) &amp;&amp; ((w1-&gt;oid != 0) &amp;&amp; (w2-&gt;oid != 0))) {
+				s3dw_arr_widgetcenter(w1, f1);
+				s3dw_arr_widgetcenter(w2, f2);
+				len1 = s3d_vector_length(f1);
+				len2 = s3d_vector_length(f2);
+				dir[0] = (w1-&gt;x + f1[0]) - (w2-&gt;x + f2[0]);
+				dir[1] = (w1-&gt;y + f1[1]) - (w2-&gt;y + f2[1]);
+				dir[2] = (w1-&gt;z + f1[2]) - (w2-&gt;z + f2[2]);
+				dirlen = s3d_vector_length(dir);
+				if (dirlen &lt; (len1 + len2)) {
+					allarr = 0;
+					arranged = 0;
+					w1-&gt;flags &amp;= ~S3DW_ARRANGED;
+					w2-&gt;flags &amp;= ~S3DW_ARRANGED;
 					/* it's not arranged, turn the flags off! */
 					s3dw_arr_normdir(dir);
-					tomove=((len1+len2+1)-dirlen);
-					move1=len1/(len1+len2);
-					move2=len2/(len1+len2);
-					if (w1-&gt;oid!=0) {
+					tomove = ((len1 + len2 + 1) - dirlen);
+					move1 = len1 / (len1 + len2);
+					move2 = len2 / (len1 + len2);
+					if (w1-&gt;oid != 0) {
 						w1-&gt;x += tomove * move1 *  dir[0];
 						w1-&gt;y += tomove * move1 *  dir[1];
 						w1-&gt;z += tomove * move1 *  dir[2];
@@ -202,7 +202,7 @@
 						w2-&gt;z += tomove * move2 * -dir[2];
 
 					}
-					if (w2-&gt;oid!=0) {
+					if (w2-&gt;oid != 0) {
 						w2-&gt;x += tomove * move2 * -dir[0];
 						w2-&gt;y += tomove * move2 * -dir[1];
 						w2-&gt;z += tomove * move2 * -dir[2];
@@ -216,9 +216,9 @@
 			}
 		}
 		if (arranged)
-			w1-&gt;flags|=S3DW_ARRANGED;
+			w1-&gt;flags |= S3DW_ARRANGED;
 	}
-	if (allarr)	ani_need_arr=0;
+	if (allarr) ani_need_arr = 0;
 	s3dw_turn();
 	s3dw_follow();
 }

Modified: trunk/libs3dw/button.c
===================================================================
--- trunk/libs3dw/button.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/button.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -30,60 +30,60 @@
 /* draw and setup the button */
 void s3dw_button_draw(s3dw_widget *widget)
 {
-	s3dw_button *button=(s3dw_button *)widget;
+	s3dw_button *button = (s3dw_button *)widget;
 	float length;
 	float vertices[8*3];
-	u_int32_t polygons[10*4]={
-		0,4,5,0,
-		0,5,1,0,
-		1,5,6,0,
-		1,6,2,0,
-		2,6,7,0,
-		2,7,3,0,
-		3,7,4,0,
-		3,4,0,0,
-		4,7,6,0,
-		4,6,5,0
+	u_int32_t polygons[10*4] = {
+		0, 4, 5, 0,
+		0, 5, 1, 0,
+		1, 5, 6, 0,
+		1, 6, 2, 0,
+		2, 6, 7, 0,
+		2, 7, 3, 0,
+		3, 7, 4, 0,
+		3, 4, 0, 0,
+		4, 7, 6, 0,
+		4, 6, 5, 0
 	};
 
-	button-&gt;oid_text=s3d_draw_string(button-&gt;text,&amp;length);
-	s3d_pep_materials_a(button-&gt;oid_text,widget-&gt;style-&gt;text_mat,1);
+	button-&gt;oid_text = s3d_draw_string(button-&gt;text, &amp;length);
+	s3d_pep_materials_a(button-&gt;oid_text, widget-&gt;style-&gt;text_mat, 1);
 
 	/* width of the button depends on the length of the text */
-	vertices[0*3+0]=0.0;
-	vertices[0*3+1]=0.0;
-	vertices[0*3+2]=0.0;
-	vertices[1*3+0]=0.0;
-	vertices[1*3+1]=-2.0;
-	vertices[1*3+2]=0.0;
-	vertices[2*3+0]=length+1;
-	vertices[2*3+1]=-2.0;
-	vertices[2*3+2]=0.0;
-	vertices[3*3+0]=length+1;
-	vertices[3*3+1]=0.0;
-	vertices[3*3+2]=0.0;
-	vertices[4*3+0]=0.25;
-	vertices[4*3+1]=-0.25;
-	vertices[4*3+2]=0.25;
-	vertices[5*3+0]=0.25;
-	vertices[5*3+1]=-1.75;
-	vertices[5*3+2]=0.25;
-	vertices[6*3+0]=length+0.75;
-	vertices[6*3+1]=-1.75;
-	vertices[6*3+2]=0.25;
-	vertices[7*3+0]=length+0.75;
-	vertices[7*3+1]=-0.25;
-	vertices[7*3+2]=0.25;
-	widget-&gt;oid=s3d_new_object();
-	s3d_push_materials_a(widget-&gt;oid,widget-&gt;style-&gt;input_mat,1);
-	s3d_push_vertices   (widget-&gt;oid,vertices,8);
-	s3d_push_polygons   (widget-&gt;oid,polygons,10);
-	s3d_link(		   widget-&gt;oid,widget-&gt;parent-&gt;oid);
-	s3d_link(		   button-&gt;oid_text,widget-&gt;oid);
-	s3d_translate(button-&gt;oid_text,0.5,-1.5,0.30);
-	s3d_translate(widget-&gt;oid,widget-&gt;x,-widget-&gt;y,0);
-	widget-&gt;width=length+1;
-	widget-&gt;height=2;
+	vertices[0*3+0] = 0.0;
+	vertices[0*3+1] = 0.0;
+	vertices[0*3+2] = 0.0;
+	vertices[1*3+0] = 0.0;
+	vertices[1*3+1] = -2.0;
+	vertices[1*3+2] = 0.0;
+	vertices[2*3+0] = length + 1;
+	vertices[2*3+1] = -2.0;
+	vertices[2*3+2] = 0.0;
+	vertices[3*3+0] = length + 1;
+	vertices[3*3+1] = 0.0;
+	vertices[3*3+2] = 0.0;
+	vertices[4*3+0] = 0.25;
+	vertices[4*3+1] = -0.25;
+	vertices[4*3+2] = 0.25;
+	vertices[5*3+0] = 0.25;
+	vertices[5*3+1] = -1.75;
+	vertices[5*3+2] = 0.25;
+	vertices[6*3+0] = length + 0.75;
+	vertices[6*3+1] = -1.75;
+	vertices[6*3+2] = 0.25;
+	vertices[7*3+0] = length + 0.75;
+	vertices[7*3+1] = -0.25;
+	vertices[7*3+2] = 0.25;
+	widget-&gt;oid = s3d_new_object();
+	s3d_push_materials_a(widget-&gt;oid, widget-&gt;style-&gt;input_mat, 1);
+	s3d_push_vertices(widget-&gt;oid, vertices, 8);
+	s3d_push_polygons(widget-&gt;oid, polygons, 10);
+	s3d_link(widget-&gt;oid, widget-&gt;parent-&gt;oid);
+	s3d_link(button-&gt;oid_text, widget-&gt;oid);
+	s3d_translate(button-&gt;oid_text, 0.5, -1.5, 0.30);
+	s3d_translate(widget-&gt;oid, widget-&gt;x, -widget-&gt;y, 0);
+	widget-&gt;width = length + 1;
+	widget-&gt;height = 2;
 }
 
 /* create a new button in the surface */
@@ -91,14 +91,14 @@
 {
 	s3dw_button *button;
 	s3dw_widget *widget;
-	button=(s3dw_button *)malloc(sizeof(s3dw_button));
-	button-&gt;text=strdup(text);
-	button-&gt;onclick=s3dw_nothing;
-	widget=s3dw_widget_new((s3dw_widget *)button);
-	widget-&gt;type=S3DW_TBUTTON;
-	widget-&gt;x=posx;
-	widget-&gt;y=posy;
-	widget-&gt;style=((s3dw_widget *)surface)-&gt;style;
+	button = (s3dw_button *)malloc(sizeof(s3dw_button));
+	button-&gt;text = strdup(text);
+	button-&gt;onclick = s3dw_nothing;
+	widget = s3dw_widget_new((s3dw_widget *)button);
+	widget-&gt;type = S3DW_TBUTTON;
+	widget-&gt;x = posx;
+	widget-&gt;y = posy;
+	widget-&gt;style = ((s3dw_widget *)surface)-&gt;style;
 
 	s3dw_widget_append((s3dw_widget *)surface, widget);
 	s3dw_button_draw(widget);
@@ -107,21 +107,21 @@
 /* show, make visible */
 void s3dw_button_show(s3dw_widget *widget)
 {
-	s3dw_button *button=(s3dw_button *)widget;
-	s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(button-&gt;oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_button *button = (s3dw_button *)widget;
+	s3d_flags_on(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(button-&gt;oid_text, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* hide */
 void s3dw_button_hide(s3dw_widget *widget)
 {
-	s3dw_button *button=(s3dw_button *)widget;
-	s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(button-&gt;oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_button *button = (s3dw_button *)widget;
+	s3d_flags_off(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(button-&gt;oid_text, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* destroy s3d structures of the button */
 void s3dw_button_erase(s3dw_widget *widget)
 {
-	s3dw_button *button=(s3dw_button *)widget;
+	s3dw_button *button = (s3dw_button *)widget;
 	s3d_del_object(button-&gt;oid_text);
 	s3d_del_object(widget-&gt;oid);
 }
@@ -129,7 +129,7 @@
 /* destroy the button */
 void s3dw_button_destroy(s3dw_widget *widget)
 {
-	s3dw_button *button=(s3dw_button *)widget;
+	s3dw_button *button = (s3dw_button *)widget;
 	s3dw_button_erase(widget);
 	free(button-&gt;text);
 	free(button);
@@ -143,8 +143,8 @@
 /* handle click on a button */
 int s3dw_button_event_click(s3dw_widget *widget, u_int32_t oid)
 {
-	s3dw_button *button=(s3dw_button *)widget;
-	if ((button-&gt;oid_text==oid) || (widget-&gt;oid==oid)) {
+	s3dw_button *button = (s3dw_button *)widget;
+	if ((button-&gt;oid_text == oid) || (widget-&gt;oid == oid)) {
 		button-&gt;onclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/event.c
===================================================================
--- trunk/libs3dw/event.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/event.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -27,28 +27,28 @@
 extern s3dw_widget *_s3dw_cam;
 int s3dw_handle_click(struct s3d_evt *evt)
 {
-	uint32_t oid=*((uint32_t *)evt-&gt;buf);
-	return(s3dw_widget_event_click(s3dw_getroot(),oid));
+	uint32_t oid = *((uint32_t *)evt-&gt;buf);
+	return(s3dw_widget_event_click(s3dw_getroot(), oid));
 }
 int s3dw_handle_key(struct s3d_evt *evt)
 {
-	struct s3d_key_event *keys=(struct s3d_key_event *)evt-&gt;buf;
-	return(s3dw_widget_event_key(s3dw_getroot(),keys));
+	struct s3d_key_event *keys = (struct s3d_key_event *)evt-&gt;buf;
+	return(s3dw_widget_event_key(s3dw_getroot(), keys));
 }
 
 int s3dw_object_info(struct s3d_evt *evt)
 {
-	struct s3d_obj_info *info=(struct s3d_obj_info *)evt-&gt;buf;
-	if (info-&gt;object==0) { /* the _s3dw_cam */
-		if (_s3dw_cam==NULL)	s3dw_getroot(); /* init, get _s3dw_cam */
-		_s3dw_cam-&gt;ax=_s3dw_cam-&gt;x=info-&gt;trans_x;
-		_s3dw_cam-&gt;ay=_s3dw_cam-&gt;y=info-&gt;trans_y;
-		_s3dw_cam-&gt;az=_s3dw_cam-&gt;z=info-&gt;trans_z;
-		_s3dw_cam-&gt;arx=_s3dw_cam-&gt;rx=info-&gt;rot_x;
-		_s3dw_cam-&gt;ary=_s3dw_cam-&gt;ry=info-&gt;rot_y;
-		_s3dw_cam-&gt;arz=_s3dw_cam-&gt;rz=info-&gt;rot_z;
+	struct s3d_obj_info *info = (struct s3d_obj_info *)evt-&gt;buf;
+	if (info-&gt;object == 0) { /* the _s3dw_cam */
+		if (_s3dw_cam == NULL) s3dw_getroot(); /* init, get _s3dw_cam */
+		_s3dw_cam-&gt;ax = _s3dw_cam-&gt;x = info-&gt;trans_x;
+		_s3dw_cam-&gt;ay = _s3dw_cam-&gt;y = info-&gt;trans_y;
+		_s3dw_cam-&gt;az = _s3dw_cam-&gt;z = info-&gt;trans_z;
+		_s3dw_cam-&gt;arx = _s3dw_cam-&gt;rx = info-&gt;rot_x;
+		_s3dw_cam-&gt;ary = _s3dw_cam-&gt;ry = info-&gt;rot_y;
+		_s3dw_cam-&gt;arz = _s3dw_cam-&gt;rz = info-&gt;rot_z;
 
-		_s3dw_cam-&gt;flags&amp;=~S3DW_ARRANGED;
+		_s3dw_cam-&gt;flags &amp;= ~S3DW_ARRANGED;
 		s3dw_ani_needarr();
 	}
 	return(0);

Modified: trunk/libs3dw/input.c
===================================================================
--- trunk/libs3dw/input.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/input.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -28,130 +28,130 @@
 #include &lt;s3dw_int.h&gt;
 #include &lt;stdlib.h&gt; /* malloc() */
 #include &lt;string.h&gt; /* strdup(),strlen() */
-#include &lt;ctype.h&gt;	/* isprint */
+#include &lt;ctype.h&gt; /* isprint */
 
 uint32_t s3dw_input_draw_string(s3dw_widget *widget)
 {
-	s3dw_input *input=(s3dw_input *)widget;
+	s3dw_input *input = (s3dw_input *)widget;
 	uint32_t oid_text;
 	int i;
 	float tlen;
-	if (widget-&gt;width&lt;1) return(-1);
-	i=0;
-	while (s3d_strlen(input-&gt;text+i) &gt; (widget-&gt;width-1)) i++;
-	oid_text=s3d_draw_string(input-&gt;text+i,&amp;tlen);
-	s3d_pep_materials_a(oid_text,widget-&gt;style-&gt;text_mat,1);
-	s3d_translate( oid_text,0.5,-1.5,0.30);
-	s3d_link(	   oid_text,widget-&gt;oid);
+	if (widget-&gt;width &lt; 1) return(-1);
+	i = 0;
+	while (s3d_strlen(input-&gt;text + i) &gt; (widget-&gt;width - 1)) i++;
+	oid_text = s3d_draw_string(input-&gt;text + i, &amp;tlen);
+	s3d_pep_materials_a(oid_text, widget-&gt;style-&gt;text_mat, 1);
+	s3d_translate(oid_text, 0.5, -1.5, 0.30);
+	s3d_link(oid_text, widget-&gt;oid);
 	return (oid_text);
 }
 void s3dw_input_draw(s3dw_widget *widget)
 {
-	s3dw_input *input=(s3dw_input *)widget;
+	s3dw_input *input = (s3dw_input *)widget;
 	float length;
 	float vertices[12*3];
-	uint32_t polygons[18*4]={
-		0,4,5,1,
-		0,5,1,1,
-		1,5,6,1,
-		1,6,2,1,
-		2,6,7,1,
-		2,7,3,1,
-		3,7,4,1,
-		3,4,0,1,
+	uint32_t polygons[18*4] = {
+		0, 4, 5, 1,
+		0, 5, 1, 1,
+		1, 5, 6, 1,
+		1, 6, 2, 1,
+		2, 6, 7, 1,
+		2, 7, 3, 1,
+		3, 7, 4, 1,
+		3, 4, 0, 1,
 
-		4,8, 9, 1,
-		4,9, 5, 1,
-		5,9, 10,1,
-		5,10,6, 1,
-		6,10,11,1,
-		6,11,7, 1,
-		7,11,8, 1,
-		7,8, 4, 1,
+		4, 8, 9, 1,
+		4, 9, 5, 1,
+		5, 9, 10, 1,
+		5, 10, 6, 1,
+		6, 10, 11, 1,
+		6, 11, 7, 1,
+		7, 11, 8, 1,
+		7, 8, 4, 1,
 
 
-		8,11,10,0,
-		8,10,9, 0
+		8, 11, 10, 0,
+		8, 10, 9, 0
 	};
-	length=widget-&gt;width-1;
-	if (widget-&gt;width&lt;1) return;
-	widget-&gt;height=2;
+	length = widget-&gt;width - 1;
+	if (widget-&gt;width &lt; 1) return;
+	widget-&gt;height = 2;
 	/* width of the input depends on the length of the text */
-	vertices[0*3+0]=0.0;
-	vertices[0*3+1]=0.0;
-	vertices[0*3+2]=0.0;
-	vertices[1*3+0]=0.0;
-	vertices[1*3+1]=-2.0;
-	vertices[1*3+2]=0.0;
-	vertices[2*3+0]=length+1;
-	vertices[2*3+1]=-2.0;
-	vertices[2*3+2]=0.0;
-	vertices[3*3+0]=length+1;
-	vertices[3*3+1]=0.0;
-	vertices[3*3+2]=0.0;
-	vertices[4*3+0]=0.125;
-	vertices[4*3+1]=-0.125;
-	vertices[4*3+2]=0.25;
-	vertices[5*3+0]=0.125;
-	vertices[5*3+1]=-1.875;
-	vertices[5*3+2]=0.25;
-	vertices[6*3+0]=length+0.875;
-	vertices[6*3+1]=-1.875;
-	vertices[6*3+2]=0.25;
-	vertices[7*3+0]=length+0.875;
-	vertices[7*3+1]=-0.125;
-	vertices[7*3+2]=0.25;
-	vertices[8*3+0]=0.25;
-	vertices[8*3+1]=-0.25;
-	vertices[8*3+2]=0.125;
-	vertices[9*3+0]=0.25;
-	vertices[9*3+1]=-1.75;
-	vertices[9*3+2]=0.125;
-	vertices[10*3+0]=length+0.75;
-	vertices[10*3+1]=-1.75;
-	vertices[10*3+2]=0.125;
-	vertices[11*3+0]=length+0.75;
-	vertices[11*3+1]=-0.25;
-	vertices[11*3+2]=0.125;
-	widget-&gt;oid=s3d_new_object();
-	s3d_push_materials_a(widget-&gt;oid,widget-&gt;style-&gt;inputback_mat,1);
-	s3d_push_materials_a(widget-&gt;oid,widget-&gt;style-&gt;input_mat,1);
-	s3d_push_vertices   (widget-&gt;oid,vertices,12);
-	s3d_push_polygons   (widget-&gt;oid,polygons,18);
-	s3d_link(		   widget-&gt;oid,widget-&gt;parent-&gt;oid);
-	s3d_translate(widget-&gt;oid,widget-&gt;x,-widget-&gt;y,0);
+	vertices[0*3+0] = 0.0;
+	vertices[0*3+1] = 0.0;
+	vertices[0*3+2] = 0.0;
+	vertices[1*3+0] = 0.0;
+	vertices[1*3+1] = -2.0;
+	vertices[1*3+2] = 0.0;
+	vertices[2*3+0] = length + 1;
+	vertices[2*3+1] = -2.0;
+	vertices[2*3+2] = 0.0;
+	vertices[3*3+0] = length + 1;
+	vertices[3*3+1] = 0.0;
+	vertices[3*3+2] = 0.0;
+	vertices[4*3+0] = 0.125;
+	vertices[4*3+1] = -0.125;
+	vertices[4*3+2] = 0.25;
+	vertices[5*3+0] = 0.125;
+	vertices[5*3+1] = -1.875;
+	vertices[5*3+2] = 0.25;
+	vertices[6*3+0] = length + 0.875;
+	vertices[6*3+1] = -1.875;
+	vertices[6*3+2] = 0.25;
+	vertices[7*3+0] = length + 0.875;
+	vertices[7*3+1] = -0.125;
+	vertices[7*3+2] = 0.25;
+	vertices[8*3+0] = 0.25;
+	vertices[8*3+1] = -0.25;
+	vertices[8*3+2] = 0.125;
+	vertices[9*3+0] = 0.25;
+	vertices[9*3+1] = -1.75;
+	vertices[9*3+2] = 0.125;
+	vertices[10*3+0] = length + 0.75;
+	vertices[10*3+1] = -1.75;
+	vertices[10*3+2] = 0.125;
+	vertices[11*3+0] = length + 0.75;
+	vertices[11*3+1] = -0.25;
+	vertices[11*3+2] = 0.125;
+	widget-&gt;oid = s3d_new_object();
+	s3d_push_materials_a(widget-&gt;oid, widget-&gt;style-&gt;inputback_mat, 1);
+	s3d_push_materials_a(widget-&gt;oid, widget-&gt;style-&gt;input_mat, 1);
+	s3d_push_vertices(widget-&gt;oid, vertices, 12);
+	s3d_push_polygons(widget-&gt;oid, polygons, 18);
+	s3d_link(widget-&gt;oid, widget-&gt;parent-&gt;oid);
+	s3d_translate(widget-&gt;oid, widget-&gt;x, -widget-&gt;y, 0);
 
-	input-&gt;oid_text=s3dw_input_draw_string(widget);
+	input-&gt;oid_text = s3dw_input_draw_string(widget);
 }
 /* show the input */
 void s3dw_input_show(s3dw_widget *widget)
 {
-	s3dw_input *input=(s3dw_input *)widget;
-	s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(input-&gt;oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_input *input = (s3dw_input *)widget;
+	s3d_flags_on(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(input-&gt;oid_text, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* hides the input */
 void s3dw_input_hide(s3dw_widget *widget)
 {
-	s3dw_input *input=(s3dw_input *)widget;
-	s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(input-&gt;oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_input *input = (s3dw_input *)widget;
+	s3d_flags_off(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(input-&gt;oid_text, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* create a new input in the surface */
 s3dw_input *s3dw_input_new(s3dw_surface *surface, float width, float posx, float posy)
 {
 	s3dw_input *input;
 	s3dw_widget *widget;
-	input=(s3dw_input *)malloc(sizeof(s3dw_input));
-	input-&gt;text=strdup(&quot;&quot;);
-	input-&gt;onclick=s3dw_nothing;
-	input-&gt;onedit=s3dw_nothing;
-	widget=s3dw_widget_new((s3dw_widget *)input);
-	widget-&gt;type=S3DW_TINPUT;
-	widget-&gt;x=posx;
-	widget-&gt;y=posy;
-	widget-&gt;width=width;
-	widget-&gt;height=2;
+	input = (s3dw_input *)malloc(sizeof(s3dw_input));
+	input-&gt;text = strdup(&quot;&quot;);
+	input-&gt;onclick = s3dw_nothing;
+	input-&gt;onedit = s3dw_nothing;
+	widget = s3dw_widget_new((s3dw_widget *)input);
+	widget-&gt;type = S3DW_TINPUT;
+	widget-&gt;x = posx;
+	widget-&gt;y = posy;
+	widget-&gt;width = width;
+	widget-&gt;height = 2;
 
 	s3dw_widget_append((s3dw_widget *)surface, widget);
 	s3dw_input_draw(widget);
@@ -159,7 +159,7 @@
 }
 void s3dw_input_erase(s3dw_widget *widget)
 {
-	s3dw_input *input=(s3dw_input *)widget;
+	s3dw_input *input = (s3dw_input *)widget;
 	s3d_del_object(input-&gt;oid_text);
 	s3d_del_object(widget-&gt;oid);
 
@@ -167,7 +167,7 @@
 /* destroy the input */
 void s3dw_input_destroy(s3dw_widget *widget)
 {
-	s3dw_input *input=(s3dw_input *)widget;
+	s3dw_input *input = (s3dw_input *)widget;
 	s3dw_input_erase(widget);
 	free(input-&gt;text);
 	free(input);
@@ -175,45 +175,45 @@
 /* changes the text of the input */
 void s3dw_input_change_text(s3dw_input *input, char *text)
 {
-	s3dw_widget *widget=(s3dw_widget *)input;
+	s3dw_widget *widget = (s3dw_widget *)input;
 	uint32_t oid_text;
 	/* redraw the text ... */
 	free(input-&gt;text);
-	input-&gt;text=strdup(text);
-	oid_text=s3dw_input_draw_string(widget);
+	input-&gt;text = strdup(text);
+	oid_text = s3dw_input_draw_string(widget);
 	if (widget-&gt;flags&amp;S3DW_ONSCREEN)
-		s3d_flags_on(oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_on(oid_text, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 	s3d_del_object(input-&gt;oid_text);
-	input-&gt;oid_text=oid_text;
+	input-&gt;oid_text = oid_text;
 }
 /* handle key events */
 int s3dw_input_event_key(s3dw_widget *widget, struct s3d_key_event *keys)
 {
-	s3dw_input *input=(s3dw_input *)widget;
+	s3dw_input *input = (s3dw_input *)widget;
 	char *newtext;
-	char key=keys-&gt;unicode; /* unicode support so far ... :/ */
+	char key = keys-&gt;unicode; /* unicode support so far ... :/ */
 	int len;
-	s3dprintf(MED,&quot;edit field got key %d!!&quot;,key);
+	s3dprintf(MED, &quot;edit field got key %d!!&quot;, key);
 	switch (keys-&gt;keysym) {
 	case S3DK_BACKSPACE:
-		len=strlen(input-&gt;text);
-		if ((len=strlen(input-&gt;text))&gt;0) {
-			newtext=malloc(len + 0); /* +1 for the terminating byte, -1 for the deleted character */
-			strncpy(newtext,input-&gt;text,len);
-			newtext[len-1]=0;
-			s3dw_input_change_text(input,newtext);
+		len = strlen(input-&gt;text);
+		if ((len = strlen(input-&gt;text)) &gt; 0) {
+			newtext = malloc(len + 0); /* +1 for the terminating byte, -1 for the deleted character */
+			strncpy(newtext, input-&gt;text, len);
+			newtext[len-1] = 0;
+			s3dw_input_change_text(input, newtext);
 			free(newtext);
 			return(1);
 		}
 		break;
 	default:
 		if (isprint(key)) {
-			len=strlen(input-&gt;text);
-			newtext=malloc(len + 2); /* +1 for the terminating byte, +1 for the new character */
-			strcpy(newtext,input-&gt;text);
-			newtext[len]=key;
-			newtext[len+1]=0;
-			s3dw_input_change_text(input,newtext);
+			len = strlen(input-&gt;text);
+			newtext = malloc(len + 2); /* +1 for the terminating byte, +1 for the new character */
+			strcpy(newtext, input-&gt;text);
+			newtext[len] = key;
+			newtext[len+1] = 0;
+			s3dw_input_change_text(input, newtext);
 			free(newtext);
 			return(1);
 		}
@@ -225,8 +225,8 @@
 
 int s3dw_input_event_click(s3dw_widget *widget, uint32_t oid)
 {
-	s3dw_input *input=(s3dw_input *)widget;
-	if ((input-&gt;oid_text==oid) || (widget-&gt;oid==oid)) {
+	s3dw_input *input = (s3dw_input *)widget;
+	if ((input-&gt;oid_text == oid) || (widget-&gt;oid == oid)) {
 		s3dw_focus(widget);
 		input-&gt;onclick(widget);
 		return(1);

Modified: trunk/libs3dw/label.c
===================================================================
--- trunk/libs3dw/label.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/label.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -30,33 +30,33 @@
 
 void s3dw_label_draw(s3dw_widget *widget)
 {
-	s3dw_label *label=(s3dw_label *)widget;
+	s3dw_label *label = (s3dw_label *)widget;
 	float length;
-	widget-&gt;oid=s3d_draw_string(label-&gt;text,&amp;length);
-	s3d_pep_materials_a(widget-&gt;oid,widget-&gt;style-&gt;text_mat,1);
-	s3d_link(widget-&gt;oid,widget-&gt;parent-&gt;oid);
-	s3d_translate(widget-&gt;oid,widget-&gt;x,-widget-&gt;y,0.1);
-	widget-&gt;width=length+1;
-	widget-&gt;height=2;
+	widget-&gt;oid = s3d_draw_string(label-&gt;text, &amp;length);
+	s3d_pep_materials_a(widget-&gt;oid, widget-&gt;style-&gt;text_mat, 1);
+	s3d_link(widget-&gt;oid, widget-&gt;parent-&gt;oid);
+	s3d_translate(widget-&gt;oid, widget-&gt;x, -widget-&gt;y, 0.1);
+	widget-&gt;width = length + 1;
+	widget-&gt;height = 2;
 }
 /* show the label */
 void s3dw_label_show(s3dw_widget *widget)
 {
-	s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* hides the label */
 void s3dw_label_hide(s3dw_widget *widget)
 {
-	s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* change label text */
 void s3dw_label_change_text(s3dw_label *label, char *text)
 {
-	s3dw_widget *widget=(s3dw_widget *)label;
+	s3dw_widget *widget = (s3dw_widget *)label;
 
 	/* redraw the text ... */
 	free(label-&gt;text);
-	label-&gt;text=strdup(text);
+	label-&gt;text = strdup(text);
 	s3dw_label_erase(widget);
 	s3dw_label_draw(widget);
 	if (widget-&gt;flags&amp;S3DW_ONSCREEN)
@@ -69,13 +69,13 @@
 {
 	s3dw_label *label;
 	s3dw_widget *widget;
-	label=(s3dw_label *)malloc(sizeof(s3dw_label));
-	widget=s3dw_widget_new((s3dw_widget *)label);
-	widget-&gt;type=S3DW_TLABEL;
-	widget-&gt;x=posx;
-	widget-&gt;y=posy;
-	label-&gt;text=strdup(text);
-	label-&gt;onclick=s3dw_nothing;
+	label = (s3dw_label *)malloc(sizeof(s3dw_label));
+	widget = s3dw_widget_new((s3dw_widget *)label);
+	widget-&gt;type = S3DW_TLABEL;
+	widget-&gt;x = posx;
+	widget-&gt;y = posy;
+	label-&gt;text = strdup(text);
+	label-&gt;onclick = s3dw_nothing;
 	s3dw_widget_append((s3dw_widget *)surface, widget);
 	s3dw_label_draw(widget);
 	return(label);
@@ -88,7 +88,7 @@
 /* destroy the label */
 void s3dw_label_destroy(s3dw_widget *widget)
 {
-	s3dw_label *label=(s3dw_label *)widget;
+	s3dw_label *label = (s3dw_label *)widget;
 	s3dw_label_erase(widget);
 	free(label-&gt;text);
 	free(label);
@@ -101,8 +101,8 @@
 /* handle click events */
 int s3dw_label_event_click(s3dw_widget *widget, uint32_t oid)
 {
-	s3dw_label *label=(s3dw_label *)widget;
-	if (widget-&gt;oid==oid) {
+	s3dw_label *label = (s3dw_label *)widget;
+	if (widget-&gt;oid == oid) {
 		label-&gt;onclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/root.c
===================================================================
--- trunk/libs3dw/root.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/root.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,14 +26,14 @@
 #include &lt;s3dw_int.h&gt;
 #include &lt;stdlib.h&gt; /* malloc() */
 #include &lt;stdio.h&gt;   /* printf() */
-s3dw_callback 		s3dwcb_show[S3DW_NTYPES];
-s3dw_callback 		s3dwcb_hide[S3DW_NTYPES];
-s3dw_callback 		s3dwcb_destroy[S3DW_NTYPES];
+s3dw_callback   s3dwcb_show[S3DW_NTYPES];
+s3dw_callback   s3dwcb_hide[S3DW_NTYPES];
+s3dw_callback   s3dwcb_destroy[S3DW_NTYPES];
 s3dw_click_callback s3dwcb_click[S3DW_NTYPES];
-s3dw_key_callback	s3dwcb_key[S3DW_NTYPES];
+s3dw_key_callback s3dwcb_key[S3DW_NTYPES];
 
 
-static s3dw_widget *root=NULL;
+static s3dw_widget *root = NULL;
 extern s3dw_widget *_s3dw_cam;
 
 /* just destroy the widget */
@@ -57,68 +57,68 @@
 /* get the root .... if it's NULL, the lib is not initialized, so do this too ... */
 s3dw_widget *s3dw_getroot()
 {
-	if (root==NULL) {
-		root=(s3dw_widget *)malloc(sizeof(s3dw_widget));
-		root=s3dw_widget_new(root);
-		root-&gt;type=S3DW_TROOT;
-		root-&gt;oid=s3d_new_object();
-		root-&gt;style=&amp;def_style;
-		root-&gt;flags=S3DW_VISIBLE|S3DW_ACTIVE;
-		_s3dw_cam=(s3dw_widget *)malloc(sizeof(s3dw_widget));
+	if (root == NULL) {
+		root = (s3dw_widget *)malloc(sizeof(s3dw_widget));
+		root = s3dw_widget_new(root);
+		root-&gt;type = S3DW_TROOT;
+		root-&gt;oid = s3d_new_object();
+		root-&gt;style = &amp;def_style;
+		root-&gt;flags = S3DW_VISIBLE | S3DW_ACTIVE;
+		_s3dw_cam = (s3dw_widget *)malloc(sizeof(s3dw_widget));
 		s3dw_widget_new(_s3dw_cam);
-		_s3dw_cam-&gt;type=S3DW_TCAM;
-		_s3dw_cam-&gt;oid=0;
-		_s3dw_cam-&gt;style=&amp;def_style;
-		_s3dw_cam-&gt;s=10;
-		_s3dw_cam-&gt;width=1;
-		_s3dw_cam-&gt;height=0;
-		_s3dw_cam-&gt;flags=S3DW_VISIBLE|S3DW_ACTIVE;
+		_s3dw_cam-&gt;type = S3DW_TCAM;
+		_s3dw_cam-&gt;oid = 0;
+		_s3dw_cam-&gt;style = &amp;def_style;
+		_s3dw_cam-&gt;s = 10;
+		_s3dw_cam-&gt;width = 1;
+		_s3dw_cam-&gt;height = 0;
+		_s3dw_cam-&gt;flags = S3DW_VISIBLE | S3DW_ACTIVE;
 
 		s3dw_widget_append(root, _s3dw_cam);
 		/* setup callback tables */
-		s3dwcb_show[S3DW_TROOT]=		s3dw_nothing;
-		s3dwcb_show[S3DW_TCAM]=			s3dw_nothing;
-		s3dwcb_show[S3DW_TSURFACE]=		s3dw_surface_show;
-		s3dwcb_show[S3DW_TBUTTON]=		s3dw_button_show;
-		s3dwcb_show[S3DW_TLABEL]=		s3dw_label_show;
-		s3dwcb_show[S3DW_TINPUT]=		s3dw_input_show;
-		s3dwcb_show[S3DW_TTEXTBOX]=		s3dw_textbox_show;
-		s3dwcb_show[S3DW_TSCROLLBAR]=	s3dw_scrollbar_show;
+		s3dwcb_show[S3DW_TROOT] =  s3dw_nothing;
+		s3dwcb_show[S3DW_TCAM] =   s3dw_nothing;
+		s3dwcb_show[S3DW_TSURFACE] =  s3dw_surface_show;
+		s3dwcb_show[S3DW_TBUTTON] =  s3dw_button_show;
+		s3dwcb_show[S3DW_TLABEL] =  s3dw_label_show;
+		s3dwcb_show[S3DW_TINPUT] =  s3dw_input_show;
+		s3dwcb_show[S3DW_TTEXTBOX] =  s3dw_textbox_show;
+		s3dwcb_show[S3DW_TSCROLLBAR] = s3dw_scrollbar_show;
 
-		s3dwcb_hide[S3DW_TROOT]=		s3dw_nothing;
-		s3dwcb_hide[S3DW_TSURFACE]=		s3dw_surface_hide;
-		s3dwcb_hide[S3DW_TBUTTON]=		s3dw_button_hide;
-		s3dwcb_hide[S3DW_TLABEL]=		s3dw_label_hide;
-		s3dwcb_hide[S3DW_TINPUT]=		s3dw_input_hide;
-		s3dwcb_hide[S3DW_TTEXTBOX]=		s3dw_textbox_hide;
-		s3dwcb_hide[S3DW_TSCROLLBAR]=	s3dw_scrollbar_hide;
+		s3dwcb_hide[S3DW_TROOT] =  s3dw_nothing;
+		s3dwcb_hide[S3DW_TSURFACE] =  s3dw_surface_hide;
+		s3dwcb_hide[S3DW_TBUTTON] =  s3dw_button_hide;
+		s3dwcb_hide[S3DW_TLABEL] =  s3dw_label_hide;
+		s3dwcb_hide[S3DW_TINPUT] =  s3dw_input_hide;
+		s3dwcb_hide[S3DW_TTEXTBOX] =  s3dw_textbox_hide;
+		s3dwcb_hide[S3DW_TSCROLLBAR] = s3dw_scrollbar_hide;
 
-		s3dwcb_destroy[S3DW_TROOT]=		s3dw_root_destroy;
-		s3dwcb_destroy[S3DW_TCAM]=		s3dw_root_destroy;
-		s3dwcb_destroy[S3DW_TSURFACE]=	s3dw_surface_destroy;
-		s3dwcb_destroy[S3DW_TBUTTON]=	s3dw_button_destroy;
-		s3dwcb_destroy[S3DW_TLABEL]=	s3dw_label_destroy;
-		s3dwcb_destroy[S3DW_TINPUT]=	s3dw_input_destroy;
-		s3dwcb_destroy[S3DW_TTEXTBOX]=	s3dw_textbox_destroy;
-		s3dwcb_destroy[S3DW_TSCROLLBAR]=s3dw_scrollbar_destroy;
+		s3dwcb_destroy[S3DW_TROOT] =  s3dw_root_destroy;
+		s3dwcb_destroy[S3DW_TCAM] =  s3dw_root_destroy;
+		s3dwcb_destroy[S3DW_TSURFACE] = s3dw_surface_destroy;
+		s3dwcb_destroy[S3DW_TBUTTON] = s3dw_button_destroy;
+		s3dwcb_destroy[S3DW_TLABEL] = s3dw_label_destroy;
+		s3dwcb_destroy[S3DW_TINPUT] = s3dw_input_destroy;
+		s3dwcb_destroy[S3DW_TTEXTBOX] = s3dw_textbox_destroy;
+		s3dwcb_destroy[S3DW_TSCROLLBAR] = s3dw_scrollbar_destroy;
 
-		s3dwcb_click[S3DW_TROOT]=		s3dw_click_nothing;
-		s3dwcb_click[S3DW_TCAM]=		s3dw_click_nothing;
-		s3dwcb_click[S3DW_TSURFACE]=	s3dw_surface_event_click;
-		s3dwcb_click[S3DW_TBUTTON]=		s3dw_button_event_click;
-		s3dwcb_click[S3DW_TLABEL]=		s3dw_label_event_click;
-		s3dwcb_click[S3DW_TINPUT]=		s3dw_input_event_click;
-		s3dwcb_click[S3DW_TTEXTBOX]=	s3dw_textbox_event_click;
-		s3dwcb_click[S3DW_TSCROLLBAR]=	s3dw_scrollbar_event_click;
+		s3dwcb_click[S3DW_TROOT] =  s3dw_click_nothing;
+		s3dwcb_click[S3DW_TCAM] =  s3dw_click_nothing;
+		s3dwcb_click[S3DW_TSURFACE] = s3dw_surface_event_click;
+		s3dwcb_click[S3DW_TBUTTON] =  s3dw_button_event_click;
+		s3dwcb_click[S3DW_TLABEL] =  s3dw_label_event_click;
+		s3dwcb_click[S3DW_TINPUT] =  s3dw_input_event_click;
+		s3dwcb_click[S3DW_TTEXTBOX] = s3dw_textbox_event_click;
+		s3dwcb_click[S3DW_TSCROLLBAR] = s3dw_scrollbar_event_click;
 
-		s3dwcb_key[S3DW_TROOT]=			s3dw_key_nothing;
-		s3dwcb_key[S3DW_TCAM]=			s3dw_key_nothing;
-		s3dwcb_key[S3DW_TSURFACE]=		s3dw_surface_event_key;
-		s3dwcb_key[S3DW_TBUTTON]=		s3dw_button_event_key;
-		s3dwcb_key[S3DW_TLABEL]=		s3dw_label_event_key;
-		s3dwcb_key[S3DW_TINPUT]=		s3dw_input_event_key;
-		s3dwcb_key[S3DW_TTEXTBOX]=		s3dw_key_nothing;
-		s3dwcb_key[S3DW_TSCROLLBAR]=	s3dw_key_nothing;
+		s3dwcb_key[S3DW_TROOT] =   s3dw_key_nothing;
+		s3dwcb_key[S3DW_TCAM] =   s3dw_key_nothing;
+		s3dwcb_key[S3DW_TSURFACE] =  s3dw_surface_event_key;
+		s3dwcb_key[S3DW_TBUTTON] =  s3dw_button_event_key;
+		s3dwcb_key[S3DW_TLABEL] =  s3dw_label_event_key;
+		s3dwcb_key[S3DW_TINPUT] =  s3dw_input_event_key;
+		s3dwcb_key[S3DW_TTEXTBOX] =  s3dw_key_nothing;
+		s3dwcb_key[S3DW_TSCROLLBAR] = s3dw_key_nothing;
 
 	}
 	return root;

Modified: trunk/libs3dw/s3dw.h
===================================================================
--- trunk/libs3dw/s3dw.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/s3dw.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -31,19 +31,19 @@
 /* we want this widget visible, as long as the widgets below are also visible.
  * on for all widgets, except surfaces which have to be switched visible
  * with s3dw_show() */
-#define		S3DW_VISIBLE	1
+#define  S3DW_VISIBLE 1
 /* widget should accept input. that's on by default. */
-#define 	S3DW_ACTIVE		2
+#define  S3DW_ACTIVE  2
 /* tells us if the widget is currently displayed */
-#define		S3DW_ONSCREEN	256
+#define  S3DW_ONSCREEN 256
 /* if the surface (or widget) is already properly arranged */
-#define 	S3DW_ARRANGED	512
+#define  S3DW_ARRANGED 512
 /* follow the camera */
-#define 	S3DW_FOLLOW_CAM	1024
+#define  S3DW_FOLLOW_CAM 1024
 /* turn to the camera */
-#define 	S3DW_TURN_CAM	2048
+#define  S3DW_TURN_CAM 2048
 /* just a typecaster to beatify code. use it if you like */
-#define 	S3DWIDGET(x)	((s3dw_widget *)x)
+#define  S3DWIDGET(x) ((s3dw_widget *)x)
 
 enum {
 	S3DW_TROOT,
@@ -56,140 +56,140 @@
 	S3DW_TSCROLLBAR,
 	S3DW_NTYPES
 };
-typedef struct _s3dw_widget 	s3dw_widget;
-typedef struct _s3dw_button 	s3dw_button;
-typedef struct _s3dw_label  	s3dw_label;
-typedef struct _s3dw_textbox  	s3dw_textbox;
-typedef struct _s3dw_scrollbar 	s3dw_scrollbar;
-typedef struct _s3dw_input  	s3dw_input;
-typedef struct _s3dw_surface  	s3dw_surface;
-typedef struct _s3dw_style  	s3dw_style;
+typedef struct _s3dw_widget  s3dw_widget;
+typedef struct _s3dw_button  s3dw_button;
+typedef struct _s3dw_label   s3dw_label;
+typedef struct _s3dw_textbox   s3dw_textbox;
+typedef struct _s3dw_scrollbar  s3dw_scrollbar;
+typedef struct _s3dw_input   s3dw_input;
+typedef struct _s3dw_surface   s3dw_surface;
+typedef struct _s3dw_style   s3dw_style;
 typedef void (*s3dw_callback)(s3dw_widget *);
 
 
 struct _s3dw_widget {
 	/* private .. */
-	int   		 type;
+	int      type;
 	s3dw_widget *parent;
 	s3dw_style  *style;
-	int 				  nobj; /* number of children objects */
-	s3dw_widget		 	**pobj; /* pointer to list of children objects */
-	int 		 focus;			/* index of the widget focused in pobj */
-	int   		 flags;			/* flags like visibility */
-	float 		 ax,ay,az;		/* current position for animation */
-	float 		 as;			/* current scale factor */
-	float 		 arx,ary,arz;   /* current rotation */
-	float 		 width,height;	/* width and height of the widget, outer size */
-	uint32_t	 oid;			/* the main object which is used for transformations etc ...*/
+	int       nobj; /* number of children objects */
+	s3dw_widget    **pobj; /* pointer to list of children objects */
+	int    focus;   /* index of the widget focused in pobj */
+	int      flags;   /* flags like visibility */
+	float    ax, ay, az;  /* current position for animation */
+	float    as;   /* current scale factor */
+	float    arx, ary, arz; /* current rotation */
+	float    width, height; /* width and height of the widget, outer size */
+	uint32_t  oid;   /* the main object which is used for transformations etc ...*/
 	/* public */
-	void		*ptr;			/* a pointer to a user structure, to use in callbacks etc */
-	float 		 x,y,z;			/* position, relative to the surface usually */
-	float 		 s;				/* scale factor */
-	float 		 rx,ry,rz;		/* rotation around the axis */
+	void  *ptr;   /* a pointer to a user structure, to use in callbacks etc */
+	float    x, y, z; /* position, relative to the surface usually */
+	float    s;    /* scale factor */
+	float    rx, ry, rz;  /* rotation around the axis */
 };
 
 
 struct _s3dw_button {
 	/* private */
-	s3dw_widget 	 widget;
-	char 			*text;
-	uint32_t  		  oid_text;
+	s3dw_widget   widget;
+	char    *text;
+	uint32_t      oid_text;
 	/* public */
-	s3dw_callback 	 onclick;
+	s3dw_callback   onclick;
 };
 struct _s3dw_label {
 	/* private */
-	s3dw_widget 	 widget;
-	char 			*text;
+	s3dw_widget   widget;
+	char    *text;
 	/* public */
-	s3dw_callback 	 onclick;
+	s3dw_callback   onclick;
 
 };
 struct _s3dw_scrollbar {
 	/* private */
-	s3dw_widget 	 widget;
-	float			 pos,max;
-	int				 type; /* 0 = horizontal, 1 = vertical */
-	int				 loid,roid,baroid;
+	s3dw_widget   widget;
+	float    pos, max;
+	int     type; /* 0 = horizontal, 1 = vertical */
+	int     loid, roid, baroid;
 	/* public */
-	s3dw_callback 	 lonclick;
-	s3dw_callback 	 ronclick;
+	s3dw_callback   lonclick;
+	s3dw_callback   ronclick;
 
 };
 
 struct _s3dw_textbox {
 	/* private */
-	s3dw_widget 	 widget;
-	s3dw_scrollbar	*scroll_vertical,
+	s3dw_widget   widget;
+	s3dw_scrollbar *scroll_vertical,
 	*scroll_horizontal;
-	char 			*text;
-	int				n_lineoids,*p_lineoids;
-	int				window_x,window_y;
+	char    *text;
+	int    n_lineoids, *p_lineoids;
+	int    window_x, window_y;
 	/* public */
-	s3dw_callback 	 onclick;
+	s3dw_callback   onclick;
 
 };
 
 struct _s3dw_input {
 	/* private */
-	s3dw_widget 	 widget;
-	char 			*text;
-	uint32_t   	 oid_text;
+	s3dw_widget   widget;
+	char    *text;
+	uint32_t     oid_text;
 	/* public */
-	s3dw_callback 	 onclick;
-	s3dw_callback 	 onedit;
+	s3dw_callback   onclick;
+	s3dw_callback   onedit;
 };
 
 struct _s3dw_surface {
 	/* private */
-	s3dw_widget 		  widget;
-	uint32_t			  oid_title;
-	uint32_t			  oid_tbar;
-	char				 *title;
+	s3dw_widget     widget;
+	uint32_t     oid_title;
+	uint32_t     oid_tbar;
+	char     *title;
 };
 
 /* style */
 struct _s3dw_style {
-	char *name;					/* name of the style ... kind of redundant */
-	char *fontface;				/* font face for all used fonts */
-	float surface_mat[12];		/* material for the surface background */
-	float input_mat[12];		/* material for buttonboxes and other widgets */
-	float inputback_mat[12];	/* material for inputfield background */
-	float text_mat[12];			/* material for the text on buttons and inputs */
-	float title_mat[12];		/* material for the title bar */
-	float title_text_mat[12];	/* material for the text on the title bar */
+	char *name;     /* name of the style ... kind of redundant */
+	char *fontface;    /* font face for all used fonts */
+	float surface_mat[12];  /* material for the surface background */
+	float input_mat[12];  /* material for buttonboxes and other widgets */
+	float inputback_mat[12]; /* material for inputfield background */
+	float text_mat[12];   /* material for the text on buttons and inputs */
+	float title_mat[12];  /* material for the title bar */
+	float title_text_mat[12]; /* material for the text on the title bar */
 };
 /* button.c */
 #ifdef HAVE_GCCVISIBILITY
 #pragma GCC visibility push(default) /* Only export following functions */
 #endif
-s3dw_button 		*s3dw_button_new(s3dw_surface *surface, char *text, float posx, float posy);
-s3dw_label	 		*s3dw_label_new(s3dw_surface *surface, char *text, float posx, float posy);
-s3dw_input 			*s3dw_input_new(s3dw_surface *surface, float width, float posx, float posy);
-s3dw_textbox 		*s3dw_textbox_new(s3dw_surface *surface, char *text, float posx, float posy, float width, float height);
-char 				*s3dw_input_gettext(s3dw_input *input);
-void 				 s3dw_input_change_text(s3dw_input *input, char *text);
-void 				 s3dw_label_change_text(s3dw_label *label, char *text);
-s3dw_surface 		*s3dw_surface_new(char *title, float width, float height);
+s3dw_button   *s3dw_button_new(s3dw_surface *surface, char *text, float posx, float posy);
+s3dw_label    *s3dw_label_new(s3dw_surface *surface, char *text, float posx, float posy);
+s3dw_input    *s3dw_input_new(s3dw_surface *surface, float width, float posx, float posy);
+s3dw_textbox   *s3dw_textbox_new(s3dw_surface *surface, char *text, float posx, float posy, float width, float height);
+char     *s3dw_input_gettext(s3dw_input *input);
+void      s3dw_input_change_text(s3dw_input *input, char *text);
+void      s3dw_label_change_text(s3dw_label *label, char *text);
+s3dw_surface   *s3dw_surface_new(char *title, float width, float height);
 
-s3dw_widget 		*s3dw_getroot();
-void				 s3dw_moveit(s3dw_widget *widget);
-void 				 s3dw_delete(s3dw_widget *widget);
-void 				 s3dw_show(s3dw_widget *widget);
-void 				 s3dw_focus(s3dw_widget *focus);
+s3dw_widget   *s3dw_getroot();
+void     s3dw_moveit(s3dw_widget *widget);
+void      s3dw_delete(s3dw_widget *widget);
+void      s3dw_show(s3dw_widget *widget);
+void      s3dw_focus(s3dw_widget *focus);
 
-void 				 s3dw_textbox_scrollup(s3dw_textbox *textbox);
-void 				 s3dw_textbox_scrolldown(s3dw_textbox *textbox);
-void 				 s3dw_textbox_scrollleft(s3dw_textbox *textbox);
-void 				 s3dw_textbox_scrollright(s3dw_textbox *textbox);
-void 				 s3dw_textbox_scrollto(s3dw_textbox *textbox, int x, int y);
-void 				 s3dw_textbox_change_text(s3dw_textbox *textbox, char *text);
+void      s3dw_textbox_scrollup(s3dw_textbox *textbox);
+void      s3dw_textbox_scrolldown(s3dw_textbox *textbox);
+void      s3dw_textbox_scrollleft(s3dw_textbox *textbox);
+void      s3dw_textbox_scrollright(s3dw_textbox *textbox);
+void      s3dw_textbox_scrollto(s3dw_textbox *textbox, int x, int y);
+void      s3dw_textbox_change_text(s3dw_textbox *textbox, char *text);
 
-int 				 s3dw_handle_click(struct s3d_evt *evt);
-int 				 s3dw_handle_key(struct s3d_evt *evt);
-int 				 s3dw_object_info(struct s3d_evt *evt);
+int      s3dw_handle_click(struct s3d_evt *evt);
+int      s3dw_handle_key(struct s3d_evt *evt);
+int      s3dw_object_info(struct s3d_evt *evt);
 
-void 				 s3dw_ani_mate();
+void      s3dw_ani_mate();
 #ifdef HAVE_GCCVISIBILITY
 #pragma GCC visibility pop
 #endif

Modified: trunk/libs3dw/s3dw_int.h
===================================================================
--- trunk/libs3dw/s3dw_int.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/s3dw_int.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,16 +22,16 @@
  */
 
 #include &lt;s3dlib.h&gt; /* s3dprintf() */
-#define MAXANI		128
-#define ZOOMS		5
+#define MAXANI  128
+#define ZOOMS  5
 /* constructor and handler callbacks */
 typedef int (*s3dw_click_callback)(s3dw_widget *, uint32_t);
-typedef int (*s3dw_key_callback)(  s3dw_widget *, struct s3d_key_event *);
-extern s3dw_callback 		s3dwcb_show[S3DW_NTYPES];
-extern s3dw_callback 		s3dwcb_hide[S3DW_NTYPES];
-extern s3dw_callback 		s3dwcb_destroy[S3DW_NTYPES];
+typedef int (*s3dw_key_callback)(s3dw_widget *, struct s3d_key_event *);
+extern s3dw_callback   s3dwcb_show[S3DW_NTYPES];
+extern s3dw_callback   s3dwcb_hide[S3DW_NTYPES];
+extern s3dw_callback   s3dwcb_destroy[S3DW_NTYPES];
 extern s3dw_click_callback s3dwcb_click[S3DW_NTYPES];
-extern s3dw_key_callback	s3dwcb_key[S3DW_NTYPES];
+extern s3dw_key_callback s3dwcb_key[S3DW_NTYPES];
 
 /* root.c */
 s3dw_widget *s3dw_getroot();
@@ -93,8 +93,8 @@
 int s3dw_textbox_event_click(s3dw_widget *widget, uint32_t oid);
 
 /* scrollbar.c */
-#define S3DW_SBAR_HORI		0
-#define S3DW_SBAR_VERT		1
+#define S3DW_SBAR_HORI  0
+#define S3DW_SBAR_VERT  1
 s3dw_scrollbar *s3dw_scrollbar_new(s3dw_widget *parent, int type, float posx, float posy, float length);
 void s3dw_scrollbar_show(s3dw_widget *widget);
 void s3dw_scrollbar_hide(s3dw_widget *widget);

Modified: trunk/libs3dw/scrollbar.c
===================================================================
--- trunk/libs3dw/scrollbar.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/scrollbar.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -30,294 +30,294 @@
 
 void s3dw_scrollbar_draw(s3dw_widget *widget)
 {
-	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
+	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
 	float back_vertices[3*32];
-	int i,j;
-	unsigned int back_polygons[44*4]={
+	int i, j;
+	unsigned int back_polygons[44*4] = {
 		/* box outside */
-		0,4,5,0,							0,5,1,0,
-		1,5,6,0,							1,6,2,0,
-		3,2,7,0,							7,2,6,0,
-		3,7,4,0,							3,4,0,0,
+		0, 4, 5, 0,       0, 5, 1, 0,
+		1, 5, 6, 0,       1, 6, 2, 0,
+		3, 2, 7, 0,       7, 2, 6, 0,
+		3, 7, 4, 0,       3, 4, 0, 0,
 
 		/* sides of big box */
-		12,13,9,0,							12,9,8,0,
-		14,15,11,0,							14,11,10,0,
+		12, 13, 9, 0,       12, 9, 8, 0,
+		14, 15, 11, 0,       14, 11, 10, 0,
 
 		/* inlay box */
-		9,16,17,0,							9,17,10,0,
-		17,18,14,0,							17,14,10,0,
-		13,14,18,0,							13,18,19,0,
-		13,19,16,0,							13,16,9,0,
+		9, 16, 17, 0,       9, 17, 10, 0,
+		17, 18, 14, 0,       17, 14, 10, 0,
+		13, 14, 18, 0,       13, 18, 19, 0,
+		13, 19, 16, 0,       13, 16, 9, 0,
 
 		/* inlay box back */
-		19,18,17,0,							19,17,16,0,
+		19, 18, 17, 0,       19, 17, 16, 0,
 
 		/* up arrow background surface */
-		7,6,15,0,
-		7,15,14,0,
-		7,14,13,0,
-		7,13,12,0,
+		7, 6, 15, 0,
+		7, 15, 14, 0,
+		7, 14, 13, 0,
+		7, 13, 12, 0,
 
 		/* up arrow face */
-		20,23,24,0,							20,24,21,0,
-		21,24,25,0,							21,25,22,0,
-		20,22,25,0,							20,25,23,0,
-		23,25,24,0,
+		20, 23, 24, 0,       20, 24, 21, 0,
+		21, 24, 25, 0,       21, 25, 22, 0,
+		20, 22, 25, 0,       20, 25, 23, 0,
+		23, 25, 24, 0,
 
 		/* down arrow background surface */
-		4,8,9,0,
-		4,9,10,0,
-		4,10,11,0,
-		4,11,5,0,
+		4, 8, 9, 0,
+		4, 9, 10, 0,
+		4, 10, 11, 0,
+		4, 11, 5, 0,
 
 		/* down arrow face */
-		26,27,31,0,							26,31,30,0,
-		31,27,28,0,							31,28,29,0,
-		26,30,29,0,							26,29,28,0,
-		30,31,29,0
+		26, 27, 31, 0,       26, 31, 30, 0,
+		31, 27, 28, 0,       31, 28, 29, 0,
+		26, 30, 29, 0,       26, 29, 28, 0,
+		30, 31, 29, 0
 
 	};
-	unsigned int bar_polygons[14*4]={
+	unsigned int bar_polygons[14*4] = {
 		/* front */
-		0,4,5,0,							0,5,1,0,
-		1,5,6,0,							1,6,2,0,
-		3,2,6,0,							3,6,7,0,
-		3,7,4,0,							3,4,0,0,
+		0, 4, 5, 0,       0, 5, 1, 0,
+		1, 5, 6, 0,       1, 6, 2, 0,
+		3, 2, 6, 0,       3, 6, 7, 0,
+		3, 7, 4, 0,       3, 4, 0, 0,
 
-		7,6,4,0,							4,6,5,0,
+		7, 6, 4, 0,       4, 6, 5, 0,
 
 		/* back, only visible sides */
-		2,3,11,0,							2,11,10,0,
-		1,9,8,0,							1,8,0,0
+		2, 3, 11, 0,       2, 11, 10, 0,
+		1, 9, 8, 0,       1, 8, 0, 0
 	};
 	float bar_vertices[12*3];
-	float w,h;
+	float w, h;
 	float temp;
 
 
-	w=(scrollbar-&gt;type==S3DW_SBAR_VERT)? widget-&gt;width : widget-&gt;height;
-	h=(scrollbar-&gt;type==S3DW_SBAR_VERT)? widget-&gt;height : widget-&gt;width;
+	w = (scrollbar-&gt;type == S3DW_SBAR_VERT) ? widget-&gt;width : widget-&gt;height;
+	h = (scrollbar-&gt;type == S3DW_SBAR_VERT) ? widget-&gt;height : widget-&gt;width;
 	/* outside/big  box */
-	back_vertices[0*3+0]=w*0.0;
-	back_vertices[0*3+1]=0.0-h;
-	back_vertices[0*3+2]=0.0;
-	back_vertices[1*3+0]=w*1.0;
-	back_vertices[1*3+1]=0.0-h;
-	back_vertices[1*3+2]=0.0;
-	back_vertices[2*3+0]=w*1.0;
-	back_vertices[2*3+1]=0.0;
-	back_vertices[2*3+2]=0.0;
-	back_vertices[3*3+0]=w*0.0;
-	back_vertices[3*3+1]=0.0;
-	back_vertices[3*3+2]=0.0;
-	back_vertices[4*3+0]=w*0.125;
-	back_vertices[4*3+1]=w*0.125-h;
-	back_vertices[4*3+2]=0.25;
-	back_vertices[5*3+0]=w*0.875;
-	back_vertices[5*3+1]=w*0.125-h;
-	back_vertices[5*3+2]=0.25;
-	back_vertices[6*3+0]=w*0.875;
-	back_vertices[6*3+1]=w*-0.125;
-	back_vertices[6*3+2]=0.25;
-	back_vertices[7*3+0]=w*0.125;
-	back_vertices[7*3+1]=w*-0.125;
-	back_vertices[7*3+2]=0.25;
+	back_vertices[0*3+0] = w * 0.0;
+	back_vertices[0*3+1] = 0.0 - h;
+	back_vertices[0*3+2] = 0.0;
+	back_vertices[1*3+0] = w * 1.0;
+	back_vertices[1*3+1] = 0.0 - h;
+	back_vertices[1*3+2] = 0.0;
+	back_vertices[2*3+0] = w * 1.0;
+	back_vertices[2*3+1] = 0.0;
+	back_vertices[2*3+2] = 0.0;
+	back_vertices[3*3+0] = w * 0.0;
+	back_vertices[3*3+1] = 0.0;
+	back_vertices[3*3+2] = 0.0;
+	back_vertices[4*3+0] = w * 0.125;
+	back_vertices[4*3+1] = w * 0.125 - h;
+	back_vertices[4*3+2] = 0.25;
+	back_vertices[5*3+0] = w * 0.875;
+	back_vertices[5*3+1] = w * 0.125 - h;
+	back_vertices[5*3+2] = 0.25;
+	back_vertices[6*3+0] = w * 0.875;
+	back_vertices[6*3+1] = w * -0.125;
+	back_vertices[6*3+2] = 0.25;
+	back_vertices[7*3+0] = w * 0.125;
+	back_vertices[7*3+1] = w * -0.125;
+	back_vertices[7*3+2] = 0.25;
 
 	/* downside inlay */
-	back_vertices[8*3+0]=w* 0.125;
-	back_vertices[8*3+1]=w-h;
-	back_vertices[8*3+2]=0.25;
-	back_vertices[9*3+0]=w* 0.25;
-	back_vertices[9*3+1]=w-h;
-	back_vertices[9*3+2]=0.25;
-	back_vertices[10*3+0]=w*0.75;
-	back_vertices[10*3+1]=w-h;
-	back_vertices[10*3+2]=0.25;
-	back_vertices[11*3+0]=w*0.875;
-	back_vertices[11*3+1]=w-h;
-	back_vertices[11*3+2]=0.25;
+	back_vertices[8*3+0] = w * 0.125;
+	back_vertices[8*3+1] = w - h;
+	back_vertices[8*3+2] = 0.25;
+	back_vertices[9*3+0] = w * 0.25;
+	back_vertices[9*3+1] = w - h;
+	back_vertices[9*3+2] = 0.25;
+	back_vertices[10*3+0] = w * 0.75;
+	back_vertices[10*3+1] = w - h;
+	back_vertices[10*3+2] = 0.25;
+	back_vertices[11*3+0] = w * 0.875;
+	back_vertices[11*3+1] = w - h;
+	back_vertices[11*3+2] = 0.25;
 
 	/* upside inlay */
-	back_vertices[12*3+0]=w*0.125;
-	back_vertices[12*3+1]=-w;
-	back_vertices[12*3+2]=0.25;
-	back_vertices[13*3+0]=w*0.25;
-	back_vertices[13*3+1]=-w;
-	back_vertices[13*3+2]=0.25;
-	back_vertices[14*3+0]=w*0.75;
-	back_vertices[14*3+1]=-w;
-	back_vertices[14*3+2]=0.25;
-	back_vertices[15*3+0]=w*0.875;
-	back_vertices[15*3+1]=-w;
-	back_vertices[15*3+2]=0.25;
+	back_vertices[12*3+0] = w * 0.125;
+	back_vertices[12*3+1] = -w;
+	back_vertices[12*3+2] = 0.25;
+	back_vertices[13*3+0] = w * 0.25;
+	back_vertices[13*3+1] = -w;
+	back_vertices[13*3+2] = 0.25;
+	back_vertices[14*3+0] = w * 0.75;
+	back_vertices[14*3+1] = -w;
+	back_vertices[14*3+2] = 0.25;
+	back_vertices[15*3+0] = w * 0.875;
+	back_vertices[15*3+1] = -w;
+	back_vertices[15*3+2] = 0.25;
 
 	/* inlay box */
-	back_vertices[16*3+0]=w*0.25;
-	back_vertices[16*3+1]=w*0.125-h+w;
-	back_vertices[16*3+2]=0.125;
-	back_vertices[17*3+0]=w*0.75;
-	back_vertices[17*3+1]=w*0.125-h+w;
-	back_vertices[17*3+2]=0.125;
-	back_vertices[18*3+0]=w*0.75;
-	back_vertices[18*3+1]=w*-0.125-w;
-	back_vertices[18*3+2]=0.125;
-	back_vertices[19*3+0]=w*0.25;
-	back_vertices[19*3+1]=w*-0.125-w;
-	back_vertices[19*3+2]=0.125;
+	back_vertices[16*3+0] = w * 0.25;
+	back_vertices[16*3+1] = w * 0.125 - h + w;
+	back_vertices[16*3+2] = 0.125;
+	back_vertices[17*3+0] = w * 0.75;
+	back_vertices[17*3+1] = w * 0.125 - h + w;
+	back_vertices[17*3+2] = 0.125;
+	back_vertices[18*3+0] = w * 0.75;
+	back_vertices[18*3+1] = w * -0.125 - w;
+	back_vertices[18*3+2] = 0.125;
+	back_vertices[19*3+0] = w * 0.25;
+	back_vertices[19*3+1] = w * -0.125 - w;
+	back_vertices[19*3+2] = 0.125;
 
 	/* arrow up */
-	back_vertices[20*3+0]=w*0.25;
-	back_vertices[20*3+1]=w*-0.875;
-	back_vertices[20*3+2]=0.25;
-	back_vertices[21*3+0]=w*0.75;
-	back_vertices[21*3+1]=w*-0.875;
-	back_vertices[21*3+2]=0.25;
-	back_vertices[22*3+0]=w*0.5;
-	back_vertices[22*3+1]=w*-0.25;
-	back_vertices[22*3+2]=0.25;
-	back_vertices[23*3+0]=w*0.375;
-	back_vertices[23*3+1]=w*-0.75;
-	back_vertices[23*3+2]=0.375;
-	back_vertices[24*3+0]=w*0.625;
-	back_vertices[24*3+1]=w*-0.75;
-	back_vertices[24*3+2]=0.375;
-	back_vertices[25*3+0]=w*0.5;
-	back_vertices[25*3+1]=w*-0.375;
-	back_vertices[25*3+2]=0.375;
+	back_vertices[20*3+0] = w * 0.25;
+	back_vertices[20*3+1] = w * -0.875;
+	back_vertices[20*3+2] = 0.25;
+	back_vertices[21*3+0] = w * 0.75;
+	back_vertices[21*3+1] = w * -0.875;
+	back_vertices[21*3+2] = 0.25;
+	back_vertices[22*3+0] = w * 0.5;
+	back_vertices[22*3+1] = w * -0.25;
+	back_vertices[22*3+2] = 0.25;
+	back_vertices[23*3+0] = w * 0.375;
+	back_vertices[23*3+1] = w * -0.75;
+	back_vertices[23*3+2] = 0.375;
+	back_vertices[24*3+0] = w * 0.625;
+	back_vertices[24*3+1] = w * -0.75;
+	back_vertices[24*3+2] = 0.375;
+	back_vertices[25*3+0] = w * 0.5;
+	back_vertices[25*3+1] = w * -0.375;
+	back_vertices[25*3+2] = 0.375;
 
 	/* arrow down */
-	back_vertices[26*3+0]=w*0.25;
-	back_vertices[26*3+1]=-h+w*0.875;
-	back_vertices[26*3+2]=0.25;
-	back_vertices[27*3+0]=w*0.75;
-	back_vertices[27*3+1]=-h+w*0.875;
-	back_vertices[27*3+2]=0.25;
-	back_vertices[28*3+0]=w*0.5;
-	back_vertices[28*3+1]=-h+w*0.25;
-	back_vertices[28*3+2]=0.25;
-	back_vertices[29*3+0]=w*0.375;
-	back_vertices[29*3+1]=-h+w*0.75;
-	back_vertices[29*3+2]=0.375;
-	back_vertices[30*3+0]=w*0.625;
-	back_vertices[30*3+1]=-h+w*0.75;
-	back_vertices[30*3+2]=0.375;
-	back_vertices[31*3+0]=w*0.5;
-	back_vertices[31*3+1]=-h+w*0.375;
-	back_vertices[31*3+2]=0.375;
+	back_vertices[26*3+0] = w * 0.25;
+	back_vertices[26*3+1] = -h + w * 0.875;
+	back_vertices[26*3+2] = 0.25;
+	back_vertices[27*3+0] = w * 0.75;
+	back_vertices[27*3+1] = -h + w * 0.875;
+	back_vertices[27*3+2] = 0.25;
+	back_vertices[28*3+0] = w * 0.5;
+	back_vertices[28*3+1] = -h + w * 0.25;
+	back_vertices[28*3+2] = 0.25;
+	back_vertices[29*3+0] = w * 0.375;
+	back_vertices[29*3+1] = -h + w * 0.75;
+	back_vertices[29*3+2] = 0.375;
+	back_vertices[30*3+0] = w * 0.625;
+	back_vertices[30*3+1] = -h + w * 0.75;
+	back_vertices[30*3+2] = 0.375;
+	back_vertices[31*3+0] = w * 0.5;
+	back_vertices[31*3+1] = -h + w * 0.375;
+	back_vertices[31*3+2] = 0.375;
 
 	/* scrollbar bar poinst */
-	bar_vertices[0*3+0]=w*0.25;
-	bar_vertices[0*3+1]=-(h-3)+w*0.125;
-	bar_vertices[0*3+2]=0.25;
-	bar_vertices[1*3+0]=w*0.75;
-	bar_vertices[1*3+1]=-(h-3)+w*0.125;
-	bar_vertices[1*3+2]=0.25;
-	bar_vertices[2*3+0]=w*0.75;
-	bar_vertices[2*3+1]=-w*0.125;
-	bar_vertices[2*3+2]=0.25;
-	bar_vertices[3*3+0]=w*0.25;
-	bar_vertices[3*3+1]=-w*0.125;
-	bar_vertices[3*3+2]=0.25;
+	bar_vertices[0*3+0] = w * 0.25;
+	bar_vertices[0*3+1] = -(h - 3) + w * 0.125;
+	bar_vertices[0*3+2] = 0.25;
+	bar_vertices[1*3+0] = w * 0.75;
+	bar_vertices[1*3+1] = -(h - 3) + w * 0.125;
+	bar_vertices[1*3+2] = 0.25;
+	bar_vertices[2*3+0] = w * 0.75;
+	bar_vertices[2*3+1] = -w * 0.125;
+	bar_vertices[2*3+2] = 0.25;
+	bar_vertices[3*3+0] = w * 0.25;
+	bar_vertices[3*3+1] = -w * 0.125;
+	bar_vertices[3*3+2] = 0.25;
 
-	bar_vertices[4*3+0]=w*0.125;
-	bar_vertices[4*3+1]=-(h-3)+w*0.25;
-	bar_vertices[4*3+2]=0.375;
-	bar_vertices[5*3+0]=w*0.875;
-	bar_vertices[5*3+1]=-(h-3)+w*0.25;
-	bar_vertices[5*3+2]=0.375;
-	bar_vertices[6*3+0]=w*0.875;
-	bar_vertices[6*3+1]=-w*0.25;
-	bar_vertices[6*3+2]=0.375;
-	bar_vertices[7*3+0]=w*0.125;
-	bar_vertices[7*3+1]=-w*0.25;
-	bar_vertices[7*3+2]=0.375;
+	bar_vertices[4*3+0] = w * 0.125;
+	bar_vertices[4*3+1] = -(h - 3) + w * 0.25;
+	bar_vertices[4*3+2] = 0.375;
+	bar_vertices[5*3+0] = w * 0.875;
+	bar_vertices[5*3+1] = -(h - 3) + w * 0.25;
+	bar_vertices[5*3+2] = 0.375;
+	bar_vertices[6*3+0] = w * 0.875;
+	bar_vertices[6*3+1] = -w * 0.25;
+	bar_vertices[6*3+2] = 0.375;
+	bar_vertices[7*3+0] = w * 0.125;
+	bar_vertices[7*3+1] = -w * 0.25;
+	bar_vertices[7*3+2] = 0.375;
 
-	bar_vertices[8*3+0]=w*0.125;
-	bar_vertices[8*3+1]=-(h-3)+w*0.25;
-	bar_vertices[8*3+2]=0.175;
-	bar_vertices[9*3+0]=w*0.875;
-	bar_vertices[9*3+1]=-(h-3)+w*0.25;
-	bar_vertices[9*3+2]=0.175;
-	bar_vertices[10*3+0]=w*0.875;
-	bar_vertices[10*3+1]=-w*0.25;
-	bar_vertices[10*3+2]=0.175;
-	bar_vertices[11*3+0]=w*0.125;
-	bar_vertices[11*3+1]=-w*0.25;
-	bar_vertices[11*3+2]=0.175;
+	bar_vertices[8*3+0] = w * 0.125;
+	bar_vertices[8*3+1] = -(h - 3) + w * 0.25;
+	bar_vertices[8*3+2] = 0.175;
+	bar_vertices[9*3+0] = w * 0.875;
+	bar_vertices[9*3+1] = -(h - 3) + w * 0.25;
+	bar_vertices[9*3+2] = 0.175;
+	bar_vertices[10*3+0] = w * 0.875;
+	bar_vertices[10*3+1] = -w * 0.25;
+	bar_vertices[10*3+2] = 0.175;
+	bar_vertices[11*3+0] = w * 0.125;
+	bar_vertices[11*3+1] = -w * 0.25;
+	bar_vertices[11*3+2] = 0.175;
 
 
 
 
-	if (scrollbar-&gt;type==S3DW_SBAR_HORI) { /* rotate x and y for horizontal scrollbar */
-		for (i=0;i&lt;32;i++)	{
-			temp=back_vertices[i*3];
-			back_vertices[i*3]=-back_vertices[i*3+1];
-			back_vertices[i*3+1]=-temp;
+	if (scrollbar-&gt;type == S3DW_SBAR_HORI) { /* rotate x and y for horizontal scrollbar */
+		for (i = 0;i &lt; 32;i++) {
+			temp = back_vertices[i*3];
+			back_vertices[i*3] = -back_vertices[i*3+1];
+			back_vertices[i*3+1] = -temp;
 		}
-		for (i=0;i&lt;44;i++) { /* change clockwiseness */
-			j=back_polygons[i*4];
-			back_polygons[i*4]=back_polygons[i*4+1];
-			back_polygons[i*4+1]=j;
+		for (i = 0;i &lt; 44;i++) { /* change clockwiseness */
+			j = back_polygons[i*4];
+			back_polygons[i*4] = back_polygons[i*4+1];
+			back_polygons[i*4+1] = j;
 		}
-		for (i=0;i&lt;12;i++)	{
-			temp=bar_vertices[i*3];
-			bar_vertices[i*3]=-bar_vertices[i*3+1];
-			bar_vertices[i*3+1]=-temp;
+		for (i = 0;i &lt; 12;i++) {
+			temp = bar_vertices[i*3];
+			bar_vertices[i*3] = -bar_vertices[i*3+1];
+			bar_vertices[i*3+1] = -temp;
 		}
-		for (i=0;i&lt;14;i++) { /* change clockwiseness */
-			j=bar_polygons[i*4];
-			bar_polygons[i*4]=bar_polygons[i*4+1];
-			bar_polygons[i*4+1]=j;
+		for (i = 0;i &lt; 14;i++) { /* change clockwiseness */
+			j = bar_polygons[i*4];
+			bar_polygons[i*4] = bar_polygons[i*4+1];
+			bar_polygons[i*4+1] = j;
 		}
 	}
 
-	widget-&gt;oid=s3d_new_object();
-	scrollbar-&gt;loid=s3d_new_object();
-	scrollbar-&gt;roid=s3d_new_object();
-	scrollbar-&gt;baroid=s3d_new_object();
-	s3d_push_materials_a(widget-&gt;oid,widget-&gt;style-&gt;input_mat,1);
-	s3d_push_materials_a(scrollbar-&gt;loid,widget-&gt;style-&gt;input_mat,1);
-	s3d_push_materials_a(scrollbar-&gt;roid,widget-&gt;style-&gt;input_mat,1);
-	s3d_push_materials_a(scrollbar-&gt;baroid,widget-&gt;style-&gt;input_mat,1);
-	s3d_push_vertices   (widget-&gt;oid,back_vertices,20);
-	s3d_push_vertices   (scrollbar-&gt;loid,back_vertices,32);
-	s3d_push_vertices   (scrollbar-&gt;roid,back_vertices,32);
-	s3d_push_vertices   (scrollbar-&gt;baroid,bar_vertices,12);
+	widget-&gt;oid = s3d_new_object();
+	scrollbar-&gt;loid = s3d_new_object();
+	scrollbar-&gt;roid = s3d_new_object();
+	scrollbar-&gt;baroid = s3d_new_object();
+	s3d_push_materials_a(widget-&gt;oid, widget-&gt;style-&gt;input_mat, 1);
+	s3d_push_materials_a(scrollbar-&gt;loid, widget-&gt;style-&gt;input_mat, 1);
+	s3d_push_materials_a(scrollbar-&gt;roid, widget-&gt;style-&gt;input_mat, 1);
+	s3d_push_materials_a(scrollbar-&gt;baroid, widget-&gt;style-&gt;input_mat, 1);
+	s3d_push_vertices(widget-&gt;oid, back_vertices, 20);
+	s3d_push_vertices(scrollbar-&gt;loid, back_vertices, 32);
+	s3d_push_vertices(scrollbar-&gt;roid, back_vertices, 32);
+	s3d_push_vertices(scrollbar-&gt;baroid, bar_vertices, 12);
 
-	s3d_push_polygons   (widget-&gt;oid,back_polygons ,22);
-	s3d_push_polygons   (scrollbar-&gt;loid,back_polygons +4*22,11);
-	s3d_push_polygons   (scrollbar-&gt;roid,back_polygons +4*33,11);
-	s3d_push_polygons   (scrollbar-&gt;baroid,bar_polygons ,14);
-	s3d_link(		   widget-&gt;oid,widget-&gt;parent-&gt;oid);
-	s3d_link(		   scrollbar-&gt;loid,widget-&gt;oid);
-	s3d_link(		   scrollbar-&gt;roid,widget-&gt;oid);
-	s3d_link(		   scrollbar-&gt;baroid,widget-&gt;oid);
-	s3d_translate(widget-&gt;oid,widget-&gt;x,-widget-&gt;y,0);
-	if (scrollbar-&gt;type==S3DW_SBAR_VERT)
-		s3d_translate(scrollbar-&gt;baroid,0,-1.5,0);
+	s3d_push_polygons(widget-&gt;oid, back_polygons , 22);
+	s3d_push_polygons(scrollbar-&gt;loid, back_polygons + 4*22, 11);
+	s3d_push_polygons(scrollbar-&gt;roid, back_polygons + 4*33, 11);
+	s3d_push_polygons(scrollbar-&gt;baroid, bar_polygons , 14);
+	s3d_link(widget-&gt;oid, widget-&gt;parent-&gt;oid);
+	s3d_link(scrollbar-&gt;loid, widget-&gt;oid);
+	s3d_link(scrollbar-&gt;roid, widget-&gt;oid);
+	s3d_link(scrollbar-&gt;baroid, widget-&gt;oid);
+	s3d_translate(widget-&gt;oid, widget-&gt;x, -widget-&gt;y, 0);
+	if (scrollbar-&gt;type == S3DW_SBAR_VERT)
+		s3d_translate(scrollbar-&gt;baroid, 0, -1.5, 0);
 	else
-		s3d_translate(scrollbar-&gt;baroid,1.5,0,0);
+		s3d_translate(scrollbar-&gt;baroid, 1.5, 0, 0);
 
 }
 /* show the scrollbar */
 void s3dw_scrollbar_show(s3dw_widget *widget)
 {
-	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
-	s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(scrollbar-&gt;loid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(scrollbar-&gt;roid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(scrollbar-&gt;baroid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
+	s3d_flags_on(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(scrollbar-&gt;loid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(scrollbar-&gt;roid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(scrollbar-&gt;baroid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
 }
 /* hides the scrollbar */
 void s3dw_scrollbar_hide(s3dw_widget *widget)
 {
-	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
-	s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(scrollbar-&gt;loid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(scrollbar-&gt;roid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(scrollbar-&gt;baroid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
+	s3d_flags_off(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(scrollbar-&gt;loid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(scrollbar-&gt;roid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(scrollbar-&gt;baroid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 
 /* create a new scrollbar in the surface */
@@ -325,24 +325,24 @@
 {
 	s3dw_scrollbar *scrollbar;
 	s3dw_widget *widget;
-	scrollbar=(s3dw_scrollbar *)malloc(sizeof(s3dw_scrollbar));
-	widget=s3dw_widget_new((s3dw_widget *)scrollbar);
-	widget-&gt;type=S3DW_TSCROLLBAR;
-	if ((scrollbar-&gt;type=type)==S3DW_SBAR_HORI) {
-		widget-&gt;height=1;
-		widget-&gt;width=length;
+	scrollbar = (s3dw_scrollbar *)malloc(sizeof(s3dw_scrollbar));
+	widget = s3dw_widget_new((s3dw_widget *)scrollbar);
+	widget-&gt;type = S3DW_TSCROLLBAR;
+	if ((scrollbar-&gt;type = type) == S3DW_SBAR_HORI) {
+		widget-&gt;height = 1;
+		widget-&gt;width = length;
 	} else {
-		widget-&gt;width=1;
-		widget-&gt;height=length;
+		widget-&gt;width = 1;
+		widget-&gt;height = length;
 	}
-	widget-&gt;x=posx;
-	widget-&gt;y=posy;
-	widget-&gt;oid=-1;
-	scrollbar-&gt;loid=-1;
-	scrollbar-&gt;roid=-1;
-	scrollbar-&gt;baroid=-1;
-	scrollbar-&gt;lonclick=s3dw_nothing;
-	scrollbar-&gt;ronclick=s3dw_nothing;
+	widget-&gt;x = posx;
+	widget-&gt;y = posy;
+	widget-&gt;oid = -1;
+	scrollbar-&gt;loid = -1;
+	scrollbar-&gt;roid = -1;
+	scrollbar-&gt;baroid = -1;
+	scrollbar-&gt;lonclick = s3dw_nothing;
+	scrollbar-&gt;ronclick = s3dw_nothing;
 	s3dw_widget_append(parent, widget);
 	s3dw_scrollbar_draw(widget);
 	return(scrollbar);
@@ -350,7 +350,7 @@
 
 void s3dw_scrollbar_erase(s3dw_widget *widget)
 {
-	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
+	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
 	s3d_del_object(widget-&gt;oid);
 	s3d_del_object(scrollbar-&gt;loid);
 	s3d_del_object(scrollbar-&gt;roid);
@@ -359,7 +359,7 @@
 /* destroy the scrollbar */
 void s3dw_scrollbar_destroy(s3dw_widget *widget)
 {
-	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
+	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
 	s3dw_scrollbar_erase(widget);
 	free(scrollbar);
 }
@@ -371,12 +371,12 @@
 /* handle click events */
 int s3dw_scrollbar_event_click(s3dw_widget *widget, uint32_t oid)
 {
-	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
-	if (scrollbar-&gt;loid==oid) {
+	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
+	if (scrollbar-&gt;loid == oid) {
 		scrollbar-&gt;lonclick(widget);
 		return(1);
 	}
-	if (scrollbar-&gt;roid==oid) {
+	if (scrollbar-&gt;roid == oid) {
 		scrollbar-&gt;ronclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/style.c
===================================================================
--- trunk/libs3dw/style.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/style.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -28,44 +28,44 @@
 
 
 /* default style */
-s3dw_style def_style={
+s3dw_style def_style = {
 	/* name */
 	&quot;default&quot;,
 	/* font face */
 	&quot;vera&quot;,
 	/* surface_mat */
-	{0.7,0.7,0.7,1.0,
-		0.7,0.7,0.7,1.0,
-		0.7,0.7,0.7,1.0
+	{0.7, 0.7, 0.7, 1.0,
+		0.7, 0.7, 0.7, 1.0,
+		0.7, 0.7, 0.7, 1.0
 	},
 	/* input_mat */
-	{0.7,0.7,0.7,1.0,
-	 0.7,0.7,0.7,1.0,
-	 0.7,0.7,0.7,1.0
+	{0.7, 0.7, 0.7, 1.0,
+	 0.7, 0.7, 0.7, 1.0,
+	 0.7, 0.7, 0.7, 1.0
 	},
 	/* inputback_mat */
-	{0.9,0.9,0.9,1.0,
-	 0.9,0.9,0.9,1.0,
-	 0.9,0.9,0.9,1.0
+	{0.9, 0.9, 0.9, 1.0,
+	 0.9, 0.9, 0.9, 1.0,
+	 0.9, 0.9, 0.9, 1.0
 	},
 
 	/* text_mat */
 	{
-		0.0,0.0,0.0,1.0,
-		1.0,1.0,1.0,1.0,
-		0.0,0.0,0.0,1.0
+		0.0, 0.0, 0.0, 1.0,
+		1.0, 1.0, 1.0, 1.0,
+		0.0, 0.0, 0.0, 1.0
 	},
 	/* title_mat */
 	{
-		0.0,0.4,0.8,1.0,
-		1.0,1.0,1.0,1.0,
-		0.0,0.4,0.8,1.0
+		0.0, 0.4, 0.8, 1.0,
+		1.0, 1.0, 1.0, 1.0,
+		0.0, 0.4, 0.8, 1.0
 	},
 	/* title_text_mat */
 	{
-		0.0,0.0,0.0,1.0,
-		0.0,0.0,0.0,1.0,
-		0.0,0.0,0.0,1.0
+		0.0, 0.0, 0.0, 1.0,
+		0.0, 0.0, 0.0, 1.0,
+		0.0, 0.0, 0.0, 1.0
 	}
 };
 

Modified: trunk/libs3dw/surface.c
===================================================================
--- trunk/libs3dw/surface.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/surface.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,105 +26,105 @@
 #include &lt;s3dw_int.h&gt;
 #include &lt;stdlib.h&gt; /* malloc() */
 #include &lt;string.h&gt; /* strdup() */
-#include &lt;math.h&gt;	/* cos(), sin() */
-#define POPUPDIST	20
+#include &lt;math.h&gt; /* cos(), sin() */
+#define POPUPDIST 20
 extern s3dw_widget *_s3dw_cam; /* for correct popup position */
 
 void s3dw_surface_draw(s3dw_widget *widget)
 {
-	s3dw_surface *surface=(s3dw_surface *)widget;
+	s3dw_surface *surface = (s3dw_surface *)widget;
 	int textlen;
 	float length;
-	float vertices[8*3]={
-		0,0,0,
-		1,0,0,
-		1,1,0,
-		0,1,0,
-		0,0,1,
-		1,0,1,
-		1,1,1,
-		0,1,1
+	float vertices[8*3] = {
+		0, 0, 0,
+		1, 0, 0,
+		1, 1, 0,
+		0, 1, 0,
+		0, 0, 1,
+		1, 0, 1,
+		1, 1, 1,
+		0, 1, 1
 	};
 	float sver[8*3], tver[8*3];
-	uint32_t polygon[10*4]={
-		0,1,2,0,
-		0,2,3,0,
-		1,5,6,0,
-		1,6,2,0,
-		2,6,7,0,
-		2,7,3,0,
-		4,0,3,0,
-		4,3,7,0,
-		5,4,7,0,
-		5,7,6,0
+	uint32_t polygon[10*4] = {
+		0, 1, 2, 0,
+		0, 2, 3, 0,
+		1, 5, 6, 0,
+		1, 6, 2, 0,
+		2, 6, 7, 0,
+		2, 7, 3, 0,
+		4, 0, 3, 0,
+		4, 3, 7, 0,
+		5, 4, 7, 0,
+		5, 7, 6, 0
 	};
 	uint32_t tpol[10*4];
 	int i;
 
-	widget-&gt;oid=s3d_new_object();
-	surface-&gt;oid_tbar=s3d_new_object();
+	widget-&gt;oid = s3d_new_object();
+	surface-&gt;oid_tbar = s3d_new_object();
 	s3d_select_font(&quot;vera&quot;);
-	surface-&gt;oid_title=s3d_draw_string(surface-&gt;title,&amp;length);
-	while (length &gt; (widget-&gt;width+1)) {
-		s3dprintf(HIGH,&quot;%f &gt; %f&quot;,length,widget-&gt;width+1);
-		textlen=strlen(surface-&gt;title);
-		if (length&gt;((widget-&gt;width+1)*1.3))
-			textlen=textlen*((widget-&gt;width+1)*1.1/length);
-		if (textlen&gt;4) {
-			surface-&gt;title[textlen-2]=0;
-			surface-&gt;title[textlen-3]='.';
-			surface-&gt;title[textlen-4]='.';
+	surface-&gt;oid_title = s3d_draw_string(surface-&gt;title, &amp;length);
+	while (length &gt; (widget-&gt;width + 1)) {
+		s3dprintf(HIGH, &quot;%f &gt; %f&quot;, length, widget-&gt;width + 1);
+		textlen = strlen(surface-&gt;title);
+		if (length &gt; ((widget-&gt;width + 1)*1.3))
+			textlen = textlen * ((widget-&gt;width + 1) * 1.1 / length);
+		if (textlen &gt; 4) {
+			surface-&gt;title[textlen-2] = 0;
+			surface-&gt;title[textlen-3] = '.';
+			surface-&gt;title[textlen-4] = '.';
 			s3d_del_object(surface-&gt;oid_title);
-			surface-&gt;oid_title=s3d_draw_string(surface-&gt;title,&amp;length);
+			surface-&gt;oid_title = s3d_draw_string(surface-&gt;title, &amp;length);
 		} else {
 			break;
 		}
 	}
 	/* prepare vertices */
-	for (i=0;i&lt;8;i++) {
-		sver[i*3 + 0]=vertices[i*3+0] * widget-&gt;width;
-		sver[i*3 + 1]=vertices[i*3+1] * -widget-&gt;height;
-		sver[i*3 + 2]=vertices[i*3+2] * -1;
-		tver[i*3 + 0]=vertices[i*3+0] * widget-&gt;width;
-		tver[i*3 + 1]=vertices[i*3+1];
-		tver[i*3 + 2]=vertices[i*3+2] * -1;
+	for (i = 0;i &lt; 8;i++) {
+		sver[i*3 + 0] = vertices[i*3+0] * widget-&gt;width;
+		sver[i*3 + 1] = vertices[i*3+1] * -widget-&gt;height;
+		sver[i*3 + 2] = vertices[i*3+2] * -1;
+		tver[i*3 + 0] = vertices[i*3+0] * widget-&gt;width;
+		tver[i*3 + 1] = vertices[i*3+1];
+		tver[i*3 + 2] = vertices[i*3+2] * -1;
 	}
 	/* swap */
-	for (i=0;i&lt;10;i++) {
-		tpol[i*4 + 0]=polygon[i*4 + 1];
-		tpol[i*4 + 1]=polygon[i*4 + 0];
-		tpol[i*4 + 2]=polygon[i*4 + 2];
-		tpol[i*4 + 3]=polygon[i*4 + 3];
+	for (i = 0;i &lt; 10;i++) {
+		tpol[i*4 + 0] = polygon[i*4 + 1];
+		tpol[i*4 + 1] = polygon[i*4 + 0];
+		tpol[i*4 + 2] = polygon[i*4 + 2];
+		tpol[i*4 + 3] = polygon[i*4 + 3];
 	}
-	s3d_push_vertices(widget-&gt;oid,sver,8);
-	s3d_push_vertices(surface-&gt;oid_tbar,tver,8);
-	s3d_push_materials_a(widget-&gt;oid      ,widget-&gt;style-&gt;surface_mat,1);
-	s3d_push_materials_a(surface-&gt;oid_tbar,widget-&gt;style-&gt;title_mat,1);
-	s3d_pep_materials_a(surface-&gt;oid_title,widget-&gt;style-&gt;title_text_mat,1);
-	s3d_push_polygons(widget-&gt;oid,polygon,10);
-	s3d_push_polygons(surface-&gt;oid_tbar,tpol,10);
-	s3d_link(surface-&gt;oid_tbar,widget-&gt;oid);
-	s3d_link(surface-&gt;oid_title,surface-&gt;oid_tbar);
-	s3d_link(widget-&gt;oid,widget-&gt;parent-&gt;oid);
-	s3d_translate(surface-&gt;oid_title,0.5,0.2,0.1);
-	s3d_scale(widget-&gt;oid,	widget-&gt;as);
-	s3d_translate(widget-&gt;oid,	widget-&gt;ax, widget-&gt;ay, widget-&gt;az);
+	s3d_push_vertices(widget-&gt;oid, sver, 8);
+	s3d_push_vertices(surface-&gt;oid_tbar, tver, 8);
+	s3d_push_materials_a(widget-&gt;oid      , widget-&gt;style-&gt;surface_mat, 1);
+	s3d_push_materials_a(surface-&gt;oid_tbar, widget-&gt;style-&gt;title_mat, 1);
+	s3d_pep_materials_a(surface-&gt;oid_title, widget-&gt;style-&gt;title_text_mat, 1);
+	s3d_push_polygons(widget-&gt;oid, polygon, 10);
+	s3d_push_polygons(surface-&gt;oid_tbar, tpol, 10);
+	s3d_link(surface-&gt;oid_tbar, widget-&gt;oid);
+	s3d_link(surface-&gt;oid_title, surface-&gt;oid_tbar);
+	s3d_link(widget-&gt;oid, widget-&gt;parent-&gt;oid);
+	s3d_translate(surface-&gt;oid_title, 0.5, 0.2, 0.1);
+	s3d_scale(widget-&gt;oid, widget-&gt;as);
+	s3d_translate(widget-&gt;oid, widget-&gt;ax, widget-&gt;ay, widget-&gt;az);
 }
 /* show the surface */
 void s3dw_surface_show(s3dw_widget *widget)
 {
-	s3dw_surface *surface=(s3dw_surface *)widget;
-	s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(surface-&gt;oid_title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(surface-&gt;oid_tbar,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_surface *surface = (s3dw_surface *)widget;
+	s3d_flags_on(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(surface-&gt;oid_title, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(surface-&gt;oid_tbar, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* hides the surface */
 void s3dw_surface_hide(s3dw_widget *widget)
 {
-	s3dw_surface *surface=(s3dw_surface *)widget;
-	s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(surface-&gt;oid_title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(surface-&gt;oid_tbar,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_surface *surface = (s3dw_surface *)widget;
+	s3d_flags_off(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(surface-&gt;oid_title, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(surface-&gt;oid_tbar, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* create a new surface */
 s3dw_surface *s3dw_surface_new(char *title, float width, float height)
@@ -133,22 +133,22 @@
 	s3dw_widget  *widget;
 	float f1[3];
 
-	surface=(s3dw_surface *)malloc(sizeof(s3dw_surface));
-	surface-&gt;title=strdup(title);
-	widget=s3dw_widget_new((s3dw_widget *)surface);
-	widget-&gt;type=S3DW_TSURFACE;
-	widget-&gt;width=width;
-	widget-&gt;height=height;
-	widget-&gt;as=0.01;
-	s3dw_arr_widgetcenter(widget,f1);
-	s3dw_widget_append(s3dw_getroot(),widget);
-	widget-&gt;x=-f1[0] + _s3dw_cam-&gt;x - sin( _s3dw_cam-&gt;ry * M_PI/180) * 	cos ( _s3dw_cam-&gt;rx *M_PI/180) * POPUPDIST;
-	widget-&gt;y=-f1[1] + _s3dw_cam-&gt;y + 								   	sin( _s3dw_cam-&gt;rx * M_PI/180 ) *POPUPDIST;
-	widget-&gt;z=-f1[2] + _s3dw_cam-&gt;z - cos( _s3dw_cam-&gt;ry * M_PI/180) * 	cos ( _s3dw_cam-&gt;rx *M_PI/180) * POPUPDIST;
-	widget-&gt;ax=widget-&gt;x;
-	widget-&gt;ay=widget-&gt;y;
-	widget-&gt;az=widget-&gt;z;
-	widget-&gt;flags|=S3DW_FOLLOW_CAM|S3DW_TURN_CAM;
+	surface = (s3dw_surface *)malloc(sizeof(s3dw_surface));
+	surface-&gt;title = strdup(title);
+	widget = s3dw_widget_new((s3dw_widget *)surface);
+	widget-&gt;type = S3DW_TSURFACE;
+	widget-&gt;width = width;
+	widget-&gt;height = height;
+	widget-&gt;as = 0.01;
+	s3dw_arr_widgetcenter(widget, f1);
+	s3dw_widget_append(s3dw_getroot(), widget);
+	widget-&gt;x = -f1[0] + _s3dw_cam-&gt;x - sin(_s3dw_cam-&gt;ry * M_PI / 180) *  cos(_s3dw_cam-&gt;rx * M_PI / 180) * POPUPDIST;
+	widget-&gt;y = -f1[1] + _s3dw_cam-&gt;y +             sin(_s3dw_cam-&gt;rx * M_PI / 180) * POPUPDIST;
+	widget-&gt;z = -f1[2] + _s3dw_cam-&gt;z - cos(_s3dw_cam-&gt;ry * M_PI / 180) *  cos(_s3dw_cam-&gt;rx * M_PI / 180) * POPUPDIST;
+	widget-&gt;ax = widget-&gt;x;
+	widget-&gt;ay = widget-&gt;y;
+	widget-&gt;az = widget-&gt;z;
+	widget-&gt;flags |= S3DW_FOLLOW_CAM | S3DW_TURN_CAM;
 	s3dw_surface_draw(widget);
 	s3dw_ani_needarr();
 	s3dw_ani_add(widget);
@@ -157,7 +157,7 @@
 /* delete objects in the s3d context */
 void s3dw_surface_erase(s3dw_widget *widget)
 {
-	s3dw_surface *surface=(s3dw_surface *)widget;
+	s3dw_surface *surface = (s3dw_surface *)widget;
 	s3d_del_object(widget-&gt;oid);
 	s3d_del_object(surface-&gt;oid_tbar);
 	s3d_del_object(surface-&gt;oid_title);
@@ -165,7 +165,7 @@
 /* destroy the surface */
 void s3dw_surface_destroy(s3dw_widget *widget)
 {
-	s3dw_surface *surface=(s3dw_surface *)widget;
+	s3dw_surface *surface = (s3dw_surface *)widget;
 	s3dw_surface_erase(widget);
 	free(surface-&gt;title);
 	free(surface);
@@ -178,15 +178,15 @@
 /* test widgets of the surface for clicks */
 int s3dw_surface_event_click(s3dw_widget *widget, uint32_t oid)
 {
-	s3dw_surface *surface=(s3dw_surface *)widget;
-	if (widget-&gt;oid==oid) {
+	s3dw_surface *surface = (s3dw_surface *)widget;
+	if (widget-&gt;oid == oid) {
 		s3dw_focus(widget);
-		s3dprintf(MED,&quot;body %s clicked&quot;,surface-&gt;title);
+		s3dprintf(MED, &quot;body %s clicked&quot;, surface-&gt;title);
 		return(1);
 	}
-	if ((surface-&gt;oid_tbar==oid) || (surface-&gt;oid_title==oid)) {
+	if ((surface-&gt;oid_tbar == oid) || (surface-&gt;oid_title == oid)) {
 		s3dw_focus(widget);
-		s3dprintf(MED,&quot;title %s clicked&quot;,surface-&gt;title);
+		s3dprintf(MED, &quot;title %s clicked&quot;, surface-&gt;title);
 		return(1);
 	}
 	return(0);

Modified: trunk/libs3dw/textbox.c
===================================================================
--- trunk/libs3dw/textbox.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/textbox.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -30,152 +30,152 @@
 
 void s3dw_textbox_draw(s3dw_widget *widget)
 {
-	float h,w;
+	float h, w;
 	float vertices[12*3];
-	uint32_t polygons[18*4]={
-		0,4,5,1,
-		0,5,1,1,
-		1,5,6,1,
-		1,6,2,1,
-		2,6,7,1,
-		2,7,3,1,
-		3,7,4,1,
-		3,4,0,1,
+	uint32_t polygons[18*4] = {
+		0, 4, 5, 1,
+		0, 5, 1, 1,
+		1, 5, 6, 1,
+		1, 6, 2, 1,
+		2, 6, 7, 1,
+		2, 7, 3, 1,
+		3, 7, 4, 1,
+		3, 4, 0, 1,
 
-		4,8, 9, 1,
-		4,9, 5, 1,
-		5,9, 10,1,
-		5,10,6, 1,
-		6,10,11,1,
-		6,11,7, 1,
-		7,11,8, 1,
-		7,8, 4, 1,
+		4, 8, 9, 1,
+		4, 9, 5, 1,
+		5, 9, 10, 1,
+		5, 10, 6, 1,
+		6, 10, 11, 1,
+		6, 11, 7, 1,
+		7, 11, 8, 1,
+		7, 8, 4, 1,
 
 
-		8,11,10,0,
-		8,10,9, 0
+		8, 11, 10, 0,
+		8, 10, 9, 0
 	};
-	w=widget-&gt;width-2;
-	h=widget-&gt;height-3;
-	if (widget-&gt;width&lt;1) return;
+	w = widget-&gt;width - 2;
+	h = widget-&gt;height - 3;
+	if (widget-&gt;width &lt; 1) return;
 	/* width of the input depends on the length of the text */
-	vertices[0*3+0]=0.0;
-	vertices[0*3+1]=0.0;
-	vertices[0*3+2]=0.0;
-	vertices[1*3+0]=0.0;
-	vertices[1*3+1]=-h-2.0;
-	vertices[1*3+2]=0.0;
-	vertices[2*3+0]=w+1;
-	vertices[2*3+1]=-h-2.0;
-	vertices[2*3+2]=0.0;
-	vertices[3*3+0]=w+1;
-	vertices[3*3+1]=0.0;
-	vertices[3*3+2]=0.0;
-	vertices[4*3+0]=0.125;
-	vertices[4*3+1]=-0.125;
-	vertices[4*3+2]=0.25;
-	vertices[5*3+0]=0.125;
-	vertices[5*3+1]=-h-1.875;
-	vertices[5*3+2]=0.25;
-	vertices[6*3+0]=w+0.875;
-	vertices[6*3+1]=-h-1.875;
-	vertices[6*3+2]=0.25;
-	vertices[7*3+0]=w+0.875;
-	vertices[7*3+1]=-0.125;
-	vertices[7*3+2]=0.25;
-	vertices[8*3+0]=0.25;
-	vertices[8*3+1]=-0.25;
-	vertices[8*3+2]=0.125;
-	vertices[9*3+0]=0.25;
-	vertices[9*3+1]=-h-1.75;
-	vertices[9*3+2]=0.125;
-	vertices[10*3+0]=w+0.75;
-	vertices[10*3+1]=-h-1.75;
-	vertices[10*3+2]=0.125;
-	vertices[11*3+0]=w+0.75;
-	vertices[11*3+1]=-0.25;
-	vertices[11*3+2]=0.125;
-	widget-&gt;oid=s3d_new_object();
-	s3d_push_materials_a(widget-&gt;oid,widget-&gt;style-&gt;inputback_mat,1);
-	s3d_push_materials_a(widget-&gt;oid,widget-&gt;style-&gt;input_mat,1);
-	s3d_push_vertices   (widget-&gt;oid,vertices,12);
-	s3d_push_polygons   (widget-&gt;oid,polygons,18);
-	s3d_link(		   widget-&gt;oid,widget-&gt;parent-&gt;oid);
-	s3d_translate(widget-&gt;oid,widget-&gt;x,-widget-&gt;y,0);
+	vertices[0*3+0] = 0.0;
+	vertices[0*3+1] = 0.0;
+	vertices[0*3+2] = 0.0;
+	vertices[1*3+0] = 0.0;
+	vertices[1*3+1] = -h - 2.0;
+	vertices[1*3+2] = 0.0;
+	vertices[2*3+0] = w + 1;
+	vertices[2*3+1] = -h - 2.0;
+	vertices[2*3+2] = 0.0;
+	vertices[3*3+0] = w + 1;
+	vertices[3*3+1] = 0.0;
+	vertices[3*3+2] = 0.0;
+	vertices[4*3+0] = 0.125;
+	vertices[4*3+1] = -0.125;
+	vertices[4*3+2] = 0.25;
+	vertices[5*3+0] = 0.125;
+	vertices[5*3+1] = -h - 1.875;
+	vertices[5*3+2] = 0.25;
+	vertices[6*3+0] = w + 0.875;
+	vertices[6*3+1] = -h - 1.875;
+	vertices[6*3+2] = 0.25;
+	vertices[7*3+0] = w + 0.875;
+	vertices[7*3+1] = -0.125;
+	vertices[7*3+2] = 0.25;
+	vertices[8*3+0] = 0.25;
+	vertices[8*3+1] = -0.25;
+	vertices[8*3+2] = 0.125;
+	vertices[9*3+0] = 0.25;
+	vertices[9*3+1] = -h - 1.75;
+	vertices[9*3+2] = 0.125;
+	vertices[10*3+0] = w + 0.75;
+	vertices[10*3+1] = -h - 1.75;
+	vertices[10*3+2] = 0.125;
+	vertices[11*3+0] = w + 0.75;
+	vertices[11*3+1] = -0.25;
+	vertices[11*3+2] = 0.125;
+	widget-&gt;oid = s3d_new_object();
+	s3d_push_materials_a(widget-&gt;oid, widget-&gt;style-&gt;inputback_mat, 1);
+	s3d_push_materials_a(widget-&gt;oid, widget-&gt;style-&gt;input_mat, 1);
+	s3d_push_vertices(widget-&gt;oid, vertices, 12);
+	s3d_push_polygons(widget-&gt;oid, polygons, 18);
+	s3d_link(widget-&gt;oid, widget-&gt;parent-&gt;oid);
+	s3d_translate(widget-&gt;oid, widget-&gt;x, -widget-&gt;y, 0);
 
 	s3dw_textbox_drawtext(widget);
 
 }
 void s3dw_textbox_drawtext(s3dw_widget *widget)
 {
-	s3dw_textbox *textbox=(s3dw_textbox *)widget;
-	char *text,*rest;
+	s3dw_textbox *textbox = (s3dw_textbox *)widget;
+	char *text, *rest;
 	char *linefeedpos;
 	int i;
-	int x,y;
+	int x, y;
 	float width;
-	textbox-&gt;n_lineoids=widget-&gt;height-2;
-	textbox-&gt;p_lineoids=malloc(textbox-&gt;n_lineoids*sizeof(int));
-	width=widget-&gt;width-1.5;
-	y=-textbox-&gt;window_y;
-	x=textbox-&gt;window_x;
-	for (i=0;i&lt;textbox-&gt;n_lineoids;i++)
-		textbox-&gt;p_lineoids[i]=-1;
-	rest=text=strdup(textbox-&gt;text);
-	while (NULL!=(linefeedpos=strchr(rest,'\n'))) { /* process every line */
-		linefeedpos[0]=0;
-		if ((x&lt;strlen(rest)) &amp;&amp; ((y&gt;=0) &amp;&amp; y&lt;textbox-&gt;n_lineoids)) { /* don't bother, if it's not visible anyway */
-			rest+=x;	/* ignore the first x chars because we've scrolled a bit right */
-			while ((strlen(rest)&gt;0) &amp;&amp; (s3d_strlen(rest)&gt;width))
-				rest[strlen(rest)-1]=0; /* remove last character and try again until it fits */
-			if (strlen(rest)&gt;0) {
-				textbox-&gt;p_lineoids[y]=s3d_draw_string(rest,NULL);
-				s3d_pep_materials_a(textbox-&gt;p_lineoids[y],widget-&gt;style-&gt;text_mat,1);
-				s3d_translate( textbox-&gt;p_lineoids[y],0.5,-y-1,0.30);
-				s3d_link(	   textbox-&gt;p_lineoids[y],widget-&gt;oid);
+	textbox-&gt;n_lineoids = widget-&gt;height - 2;
+	textbox-&gt;p_lineoids = malloc(textbox-&gt;n_lineoids * sizeof(int));
+	width = widget-&gt;width - 1.5;
+	y = -textbox-&gt;window_y;
+	x = textbox-&gt;window_x;
+	for (i = 0;i &lt; textbox-&gt;n_lineoids;i++)
+		textbox-&gt;p_lineoids[i] = -1;
+	rest = text = strdup(textbox-&gt;text);
+	while (NULL != (linefeedpos = strchr(rest, '\n'))) { /* process every line */
+		linefeedpos[0] = 0;
+		if ((x &lt; strlen(rest)) &amp;&amp; ((y &gt;= 0) &amp;&amp; y &lt; textbox-&gt;n_lineoids)) { /* don't bother, if it's not visible anyway */
+			rest += x; /* ignore the first x chars because we've scrolled a bit right */
+			while ((strlen(rest) &gt; 0) &amp;&amp; (s3d_strlen(rest) &gt; width))
+				rest[strlen(rest)-1] = 0; /* remove last character and try again until it fits */
+			if (strlen(rest) &gt; 0) {
+				textbox-&gt;p_lineoids[y] = s3d_draw_string(rest, NULL);
+				s3d_pep_materials_a(textbox-&gt;p_lineoids[y], widget-&gt;style-&gt;text_mat, 1);
+				s3d_translate(textbox-&gt;p_lineoids[y], 0.5, -y - 1, 0.30);
+				s3d_link(textbox-&gt;p_lineoids[y], widget-&gt;oid);
 
 			}
 		}
-		rest=linefeedpos+1;
-		y+=1;
+		rest = linefeedpos + 1;
+		y += 1;
 	}
-	if (y&lt;0) textbox-&gt;window_y-=y;
+	if (y &lt; 0) textbox-&gt;window_y -= y;
 
 	free(text);
 }
 void s3dw_textbox_erasetext(s3dw_widget *widget)
 {
-	s3dw_textbox *textbox=(s3dw_textbox *)widget;
+	s3dw_textbox *textbox = (s3dw_textbox *)widget;
 	int i;
 
 
-	if (textbox-&gt;p_lineoids!=NULL) {
-		for (i=0;i&lt;textbox-&gt;n_lineoids;i++)
-			if (textbox-&gt;p_lineoids[i]!=-1)
+	if (textbox-&gt;p_lineoids != NULL) {
+		for (i = 0;i &lt; textbox-&gt;n_lineoids;i++)
+			if (textbox-&gt;p_lineoids[i] != -1)
 				s3d_del_object(textbox-&gt;p_lineoids[i]);
 		free(textbox-&gt;p_lineoids);
-		textbox-&gt;p_lineoids=NULL;
-		textbox-&gt;n_lineoids=0;
+		textbox-&gt;p_lineoids = NULL;
+		textbox-&gt;n_lineoids = 0;
 
 	}
 }
 /* show the textbox */
 void s3dw_textbox_show(s3dw_widget *widget)
 {
-	s3dw_textbox *textbox=(s3dw_textbox *)widget;
+	s3dw_textbox *textbox = (s3dw_textbox *)widget;
 	int i;
-	s3d_flags_on(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	for (i=0;i&lt;textbox-&gt;n_lineoids;i++)
-		s3d_flags_on(textbox-&gt;p_lineoids[i],S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	for (i = 0;i &lt; textbox-&gt;n_lineoids;i++)
+		s3d_flags_on(textbox-&gt;p_lineoids[i], S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* hides the textbox */
 void s3dw_textbox_hide(s3dw_widget *widget)
 {
-	s3dw_textbox *textbox=(s3dw_textbox *)widget;
+	s3dw_textbox *textbox = (s3dw_textbox *)widget;
 	int i;
-	s3d_flags_off(widget-&gt;oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	for (i=0;i&lt;textbox-&gt;n_lineoids;i++)
-		s3d_flags_on(textbox-&gt;p_lineoids[i],S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget-&gt;oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	for (i = 0;i &lt; textbox-&gt;n_lineoids;i++)
+		s3d_flags_on(textbox-&gt;p_lineoids[i], S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
 }
 static void _s3dw_textbox_scrollbar_up(s3dw_widget *widget)
@@ -200,27 +200,27 @@
 {
 	s3dw_textbox *textbox;
 	s3dw_widget *widget;
-	textbox=(s3dw_textbox *)malloc(sizeof(s3dw_textbox));
-	widget=s3dw_widget_new((s3dw_widget *)textbox);
-	widget-&gt;type=S3DW_TTEXTBOX;
-	widget-&gt;x=posx;
-	widget-&gt;y=posy;
-	widget-&gt;width=width;
-	widget-&gt;height=height;
-	textbox-&gt;window_x=0;
-	textbox-&gt;window_y=0;
-	textbox-&gt;p_lineoids=NULL;
-	textbox-&gt;n_lineoids=0;
-	textbox-&gt;text=strdup(text);
-	textbox-&gt;onclick=s3dw_nothing;
-	s3dw_widget_append((s3dw_widget *)surface, widget);		/* append first so the scrollbars inherit the style */
+	textbox = (s3dw_textbox *)malloc(sizeof(s3dw_textbox));
+	widget = s3dw_widget_new((s3dw_widget *)textbox);
+	widget-&gt;type = S3DW_TTEXTBOX;
+	widget-&gt;x = posx;
+	widget-&gt;y = posy;
+	widget-&gt;width = width;
+	widget-&gt;height = height;
+	textbox-&gt;window_x = 0;
+	textbox-&gt;window_y = 0;
+	textbox-&gt;p_lineoids = NULL;
+	textbox-&gt;n_lineoids = 0;
+	textbox-&gt;text = strdup(text);
+	textbox-&gt;onclick = s3dw_nothing;
+	s3dw_widget_append((s3dw_widget *)surface, widget);  /* append first so the scrollbars inherit the style */
 	s3dw_textbox_draw(widget);
-	textbox-&gt;scroll_horizontal=s3dw_scrollbar_new(widget,S3DW_SBAR_HORI,  0,widget-&gt;height-1, widget-&gt;width-1);
-	textbox-&gt;scroll_vertical=s3dw_scrollbar_new(widget,S3DW_SBAR_VERT,  widget-&gt;width-1,0, widget-&gt;height-1);
-	textbox-&gt;scroll_horizontal-&gt;lonclick=_s3dw_textbox_scrollbar_left;
-	textbox-&gt;scroll_horizontal-&gt;ronclick=_s3dw_textbox_scrollbar_right;
-	textbox-&gt;scroll_vertical-&gt;lonclick=_s3dw_textbox_scrollbar_up;
-	textbox-&gt;scroll_vertical-&gt;ronclick=_s3dw_textbox_scrollbar_down;
+	textbox-&gt;scroll_horizontal = s3dw_scrollbar_new(widget, S3DW_SBAR_HORI,  0, widget-&gt;height - 1, widget-&gt;width - 1);
+	textbox-&gt;scroll_vertical = s3dw_scrollbar_new(widget, S3DW_SBAR_VERT,  widget-&gt;width - 1, 0, widget-&gt;height - 1);
+	textbox-&gt;scroll_horizontal-&gt;lonclick = _s3dw_textbox_scrollbar_left;
+	textbox-&gt;scroll_horizontal-&gt;ronclick = _s3dw_textbox_scrollbar_right;
+	textbox-&gt;scroll_vertical-&gt;lonclick = _s3dw_textbox_scrollbar_up;
+	textbox-&gt;scroll_vertical-&gt;ronclick = _s3dw_textbox_scrollbar_down;
 
 	return(textbox);
 }
@@ -234,7 +234,7 @@
 
 void s3dw_textbox_scrollup(s3dw_textbox *textbox)
 {
-	if (textbox-&gt;window_y&gt;0)
+	if (textbox-&gt;window_y &gt; 0)
 		textbox-&gt;window_y--;
 	s3dw_textbox_redraw(S3DWIDGET(textbox));
 }
@@ -246,7 +246,7 @@
 }
 void s3dw_textbox_scrollleft(s3dw_textbox *textbox)
 {
-	if (textbox-&gt;window_x&gt;0)
+	if (textbox-&gt;window_x &gt; 0)
 		textbox-&gt;window_x--;
 	s3dw_textbox_redraw(S3DWIDGET(textbox));
 }
@@ -257,20 +257,20 @@
 }
 void s3dw_textbox_scrollto(s3dw_textbox *textbox, int x, int y)
 {
-	s3dw_widget *widget=(s3dw_widget *)textbox;
-	if (x&lt;0) x=0;
-	if (y&lt;0) y=0;
-	textbox-&gt;window_x=x;
-	textbox-&gt;window_y=y;
+	s3dw_widget *widget = (s3dw_widget *)textbox;
+	if (x &lt; 0) x = 0;
+	if (y &lt; 0) y = 0;
+	textbox-&gt;window_x = x;
+	textbox-&gt;window_y = y;
 	s3dw_textbox_redraw(widget);
 }
 
 void s3dw_textbox_change_text(s3dw_textbox *textbox, char *text)
 {
-	s3dw_widget *widget=(s3dw_widget *)textbox;
+	s3dw_widget *widget = (s3dw_widget *)textbox;
 	/* redraw the text ... */
 	free(textbox-&gt;text);
-	textbox-&gt;text=strdup(text);
+	textbox-&gt;text = strdup(text);
 	s3dw_textbox_redraw(widget);
 }
 void s3dw_textbox_erase(s3dw_widget *widget)
@@ -282,7 +282,7 @@
 /* destroy the textbox */
 void s3dw_textbox_destroy(s3dw_widget *widget)
 {
-	s3dw_textbox *textbox=(s3dw_textbox *)widget;
+	s3dw_textbox *textbox = (s3dw_textbox *)widget;
 	s3dw_textbox_erase(widget);
 	free(textbox-&gt;text);
 	free(textbox);
@@ -295,8 +295,8 @@
 /* handle click events */
 int s3dw_textbox_event_click(s3dw_widget *widget, uint32_t oid)
 {
-	s3dw_textbox *textbox=(s3dw_textbox *)widget;
-	if (widget-&gt;oid==oid) {
+	s3dw_textbox *textbox = (s3dw_textbox *)widget;
+	if (widget-&gt;oid == oid) {
 		textbox-&gt;onclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/widget.c
===================================================================
--- trunk/libs3dw/widget.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/widget.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -28,41 +28,41 @@
 #include &lt;string.h&gt; /* strdup() */
 s3dw_widget *s3dw_widget_new(s3dw_widget *widget)
 {
-	widget-&gt;type=-1;
-	widget-&gt;x=widget-&gt;ax=0;
-	widget-&gt;y=widget-&gt;ay=0;
-	widget-&gt;z=widget-&gt;az=0;
-	widget-&gt;rx=widget-&gt;arx=0;
-	widget-&gt;ry=widget-&gt;ary=0;
-	widget-&gt;rz=widget-&gt;arz=0;
-	widget-&gt;s=widget-&gt;as=1;
-	widget-&gt;width=0;
-	widget-&gt;height=0;
-	widget-&gt;nobj=0;
-	widget-&gt;pobj=NULL;
-	widget-&gt;parent=NULL;
-	widget-&gt;ptr=NULL;
-	widget-&gt;focus=-1;
-	widget-&gt;flags=S3DW_ACTIVE;
-	widget-&gt;oid=-1;
+	widget-&gt;type = -1;
+	widget-&gt;x = widget-&gt;ax = 0;
+	widget-&gt;y = widget-&gt;ay = 0;
+	widget-&gt;z = widget-&gt;az = 0;
+	widget-&gt;rx = widget-&gt;arx = 0;
+	widget-&gt;ry = widget-&gt;ary = 0;
+	widget-&gt;rz = widget-&gt;arz = 0;
+	widget-&gt;s = widget-&gt;as = 1;
+	widget-&gt;width = 0;
+	widget-&gt;height = 0;
+	widget-&gt;nobj = 0;
+	widget-&gt;pobj = NULL;
+	widget-&gt;parent = NULL;
+	widget-&gt;ptr = NULL;
+	widget-&gt;focus = -1;
+	widget-&gt;flags = S3DW_ACTIVE;
+	widget-&gt;oid = -1;
 	return(widget);
 }
 /* widget clicked, call specific function and check kids */
 int s3dw_widget_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	int i;
-	s3dprintf(VLOW,&quot;processing click event for widget %010p of type %d, oid %d (%d), subobjects: %d&quot;,widget,widget-&gt;type, widget-&gt;oid, oid, widget-&gt;nobj);
-	if (s3dwcb_click[widget-&gt;type](widget,oid)) return(1);
-	for (i=0;i&lt;widget-&gt;nobj;i++)
-		if (s3dw_widget_event_click(widget-&gt;pobj[i],oid)) return(1);
+	s3dprintf(VLOW, &quot;processing click event for widget %010p of type %d, oid %d (%d), subobjects: %d&quot;, widget, widget-&gt;type, widget-&gt;oid, oid, widget-&gt;nobj);
+	if (s3dwcb_click[widget-&gt;type](widget, oid)) return(1);
+	for (i = 0;i &lt; widget-&gt;nobj;i++)
+		if (s3dw_widget_event_click(widget-&gt;pobj[i], oid)) return(1);
 	return(0);
 }
 /* widget received key,,call specific function and check (focused) kids */
 int s3dw_widget_event_key(s3dw_widget *widget, struct s3d_key_event *keys)
 {
-	if (s3dwcb_key[widget-&gt;type](widget,keys)) return(1);
-	if (widget-&gt;focus!=-1)
-		if (s3dw_widget_event_key(widget-&gt;pobj[widget-&gt;focus],keys)) return(1);
+	if (s3dwcb_key[widget-&gt;type](widget, keys)) return(1);
+	if (widget-&gt;focus != -1)
+		if (s3dw_widget_event_key(widget-&gt;pobj[widget-&gt;focus], keys)) return(1);
 	return(0);
 }
 
@@ -71,25 +71,25 @@
 void s3dw_widget_append(s3dw_widget *parent, s3dw_widget *widget)
 {
 	parent-&gt;nobj++;
-	parent-&gt;pobj=realloc(parent-&gt;pobj,sizeof(s3dw_widget **) * (parent-&gt;nobj));
-	parent-&gt;pobj[parent-&gt;nobj-1]=widget;
-	widget-&gt;parent=parent;
-	widget-&gt;style=parent-&gt;style;
+	parent-&gt;pobj = realloc(parent-&gt;pobj, sizeof(s3dw_widget **) * (parent-&gt;nobj));
+	parent-&gt;pobj[parent-&gt;nobj-1] = widget;
+	widget-&gt;parent = parent;
+	widget-&gt;style = parent-&gt;style;
 	if (!(parent-&gt;flags&amp;S3DW_VISIBLE))
-		widget-&gt;flags|=S3DW_VISIBLE;
+		widget-&gt;flags |= S3DW_VISIBLE;
 }
 /* removes an widget from it's parent, should have been appended before */
 void s3dw_widget_remove(s3dw_widget *widget)
 {
-	s3dw_widget *parent=widget-&gt;parent;
+	s3dw_widget *parent = widget-&gt;parent;
 	int i;
-	if (parent==NULL) return;
+	if (parent == NULL) return;
 
-	for (i=0;i&lt;parent-&gt;nobj;i++) /* search ... */
-		if (parent-&gt;pobj[i]==widget) { /* ... and destroy */
-			if (parent-&gt;focus==i)					parent-&gt;focus=-1;
-			if (parent-&gt;focus==(parent-&gt;nobj-1))	parent-&gt;focus=i;
-			parent-&gt;pobj[i]=parent-&gt;pobj[parent-&gt;nobj-1]; /* swap last element to the to be deleted one */
+	for (i = 0;i &lt; parent-&gt;nobj;i++) /* search ... */
+		if (parent-&gt;pobj[i] == widget) { /* ... and destroy */
+			if (parent-&gt;focus == i)     parent-&gt;focus = -1;
+			if (parent-&gt;focus == (parent-&gt;nobj - 1)) parent-&gt;focus = i;
+			parent-&gt;pobj[i] = parent-&gt;pobj[parent-&gt;nobj-1]; /* swap last element to the to be deleted one */
 			parent-&gt;nobj--;
 		}
 }
@@ -98,23 +98,23 @@
 {
 	s3dw_widget_remove(widget);
 	/* remove kids */
-	while (widget-&gt;nobj&gt;0) /* will decrease as child-delete will call s3dw_widget_remove() */
+	while (widget-&gt;nobj &gt; 0) /* will decrease as child-delete will call s3dw_widget_remove() */
 		s3dw_delete(widget-&gt;pobj[0]);
 	free(widget-&gt;pobj);
-	s3dwcb_destroy[widget-&gt;type](widget);	/* type-specific destroy */
+	s3dwcb_destroy[widget-&gt;type](widget); /* type-specific destroy */
 }
 /* toggle a widget visible and show it */
 void s3dw_show(s3dw_widget *widget)
 {
-	widget-&gt;flags|=S3DW_VISIBLE;
+	widget-&gt;flags |= S3DW_VISIBLE;
 	s3dw_widget_visible(widget);
 }
 void s3dw_focus(s3dw_widget *focus)
 {
 	int i;
-	for (i=0;i&lt;focus-&gt;parent-&gt;nobj;i++)
-		if (focus-&gt;parent-&gt;pobj[i]==focus) {
-			focus-&gt;parent-&gt;focus=i;
+	for (i = 0;i &lt; focus-&gt;parent-&gt;nobj;i++)
+		if (focus-&gt;parent-&gt;pobj[i] == focus) {
+			focus-&gt;parent-&gt;focus = i;
 			return;
 		}
 }
@@ -124,16 +124,16 @@
 {
 	int i;
 	s3dw_widget *kid;
-	for (i=0;i&lt;widget-&gt;nobj;i++) {
-		kid=widget-&gt;pobj[i];
+	for (i = 0;i &lt; widget-&gt;nobj;i++) {
+		kid = widget-&gt;pobj[i];
 		if (widget-&gt;flags&amp;S3DW_VISIBLE)
 			s3dw_widget_visible(kid);
 	}
-	widget-&gt;flags|=S3DW_ONSCREEN;
+	widget-&gt;flags |= S3DW_ONSCREEN;
 	s3dwcb_show[widget-&gt;type](widget);
 }
 /* apply the moves ... */
-void				 s3dw_moveit(s3dw_widget *widget)
+void     s3dw_moveit(s3dw_widget *widget)
 {
 	s3dw_ani_add(widget);
 }

Modified: trunk/server/allocate.c
===================================================================
--- trunk/server/allocate.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/allocate.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,12 +1,12 @@
 /*
  * allocate.c
  *
- * Copyright (C) 2006 	Marek Lindner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lindner_marek at yahoo.de</A>&gt;
- * 						Thomas Lopatic
- * 						Corinna 'Elektra' Aichele
- * 						Axel Neumann
- * 						Felix Fietkau
- * 						Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ * Copyright (C) 2006  Marek Lindner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lindner_marek at yahoo.de</A>&gt;
+ *       Thomas Lopatic
+ *       Corinna 'Elektra' Aichele
+ *       Axel Neumann
+ *       Felix Fietkau
+ *       Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
@@ -93,7 +93,7 @@
 	struct chunkTrailer *chunkTrailer;
 	unsigned char *chunk;
 
-	/* 	printf(&quot;sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\n&quot;, sizeof (struct chunkHeader), sizeof (struct chunkTrailer)); */
+	/*  printf(&quot;sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\n&quot;, sizeof (struct chunkHeader), sizeof (struct chunkTrailer)); */
 
 	memory = malloc(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer));
 

Modified: trunk/server/allocate.h
===================================================================
--- trunk/server/allocate.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/allocate.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,12 +1,12 @@
 /*
  * allocate.h
  *
- * Copyright (C) 2006 	Marek Lindner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lindner_marek at yahoo.de</A>&gt;
- *						Thomas Lopatic
- * 						Corinna 'Elektra' Aichele
- * 						Axel Neumann
- * 						Felix Fietkau
- * 						Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+ * Copyright (C) 2006  Marek Lindner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lindner_marek at yahoo.de</A>&gt;
+ *      Thomas Lopatic
+ *       Corinna 'Elektra' Aichele
+ *       Axel Neumann
+ *       Felix Fietkau
+ *       Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
  * This file is part of s3d, a 3d network display server.
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.

Modified: trunk/server/config.h
===================================================================
--- trunk/server/config.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/config.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -27,18 +27,18 @@
 /*  to be filled with configure options ...  */
 /*   */
 /*  on which port do we listen? */
-#define S3D_PORT	6066
+#define S3D_PORT 6066
 /*  resolution on startup */
-#define X_RES	800
-#define Y_RES	600
+#define X_RES 800
+#define Y_RES 600
 /* how many frames to wait until test the connection if it's still here */
-#define MAX_IDLE	50
+#define MAX_IDLE 50
 /*  this is to be set dynamicly later on */
-#define VLOW	1
-#define	LOW		2
-#define MED		3
-#define HIGH	4
-#define	VHIGH	5
+#define VLOW 1
+#define LOW  2
+#define MED  3
+#define HIGH 4
+#define VHIGH 5
 /*  which is the minimum level of debugmessage we want to see? */
-/* #define DEBUG	LOW */ 		/* should be set with compile, e.g. -DDEBUG=LOW */
+/* #define DEBUG LOW */   /* should be set with compile, e.g. -DDEBUG=LOW */
 

Modified: trunk/server/cull.c
===================================================================
--- trunk/server/cull.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/cull.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,80 +25,80 @@
 
 
 #include &quot;global.h&quot;
-#include &lt;math.h&gt;	/* sqrt() */
-#include &lt;GL/gl.h&gt;	/* glGetFloatv() */
+#include &lt;math.h&gt; /* sqrt() */
+#include &lt;GL/gl.h&gt; /* glGetFloatv() */
 struct t_plane {
 	struct t_vertex n;
 	float d;
 };
-#define LEFT	0
-#define RIGHT	1
-#define TOP		2
-#define BOTTOM	3
-#define PNEAR	4
-#define PFAR	5
+#define LEFT 0
+#define RIGHT 1
+#define TOP  2
+#define BOTTOM 3
+#define PNEAR 4
+#define PFAR 5
 static struct t_plane frustumPlane[6];
 void cull_get_planes()
 {
-	t_mtrx m,mproj,mmodel;
+	t_mtrx m, mproj, mmodel;
 	struct t_plane *p;
 	int i;
 	float d;
 
 
 	/* get matrices from opengl */
-	glGetFloatv(GL_MODELVIEW_MATRIX,mmodel);
-	glGetFloatv(GL_PROJECTION_MATRIX,mproj);
+	glGetFloatv(GL_MODELVIEW_MATRIX, mmodel);
+	glGetFloatv(GL_PROJECTION_MATRIX, mproj);
 
 	mySetMatrix(mproj);
 	myMultMatrix(mmodel);
 	myGetMatrix(m); /* multiply and have the result in m */
 
-	p=&amp;frustumPlane[RIGHT];
-	p-&gt;n.x=m[3]-m[0];
-	p-&gt;n.y=m[7]-m[4];
-	p-&gt;n.z=m[11]-m[8];
-	p-&gt;d=m[15]-m[12];
+	p = &amp;frustumPlane[RIGHT];
+	p-&gt;n.x = m[3] - m[0];
+	p-&gt;n.y = m[7] - m[4];
+	p-&gt;n.z = m[11] - m[8];
+	p-&gt;d = m[15] - m[12];
 
-	p=&amp;frustumPlane[LEFT];
-	p-&gt;n.x=m[3]+m[0];
-	p-&gt;n.y=m[7]+m[4];
-	p-&gt;n.z=m[11]+m[8];
-	p-&gt;d=m[15]+m[12];
+	p = &amp;frustumPlane[LEFT];
+	p-&gt;n.x = m[3] + m[0];
+	p-&gt;n.y = m[7] + m[4];
+	p-&gt;n.z = m[11] + m[8];
+	p-&gt;d = m[15] + m[12];
 
-	p=&amp;frustumPlane[BOTTOM];
-	p-&gt;n.x=m[3]+m[1];
-	p-&gt;n.y=m[7]+m[5];
-	p-&gt;n.z=m[11]+m[9];
-	p-&gt;d=m[15]+m[13];
+	p = &amp;frustumPlane[BOTTOM];
+	p-&gt;n.x = m[3] + m[1];
+	p-&gt;n.y = m[7] + m[5];
+	p-&gt;n.z = m[11] + m[9];
+	p-&gt;d = m[15] + m[13];
 
-	p=&amp;frustumPlane[TOP];
-	p-&gt;n.x=m[3]-m[1];
-	p-&gt;n.y=m[7]-m[5];
-	p-&gt;n.z=m[11]-m[9];
-	p-&gt;d=m[15]-m[13];
+	p = &amp;frustumPlane[TOP];
+	p-&gt;n.x = m[3] - m[1];
+	p-&gt;n.y = m[7] - m[5];
+	p-&gt;n.z = m[11] - m[9];
+	p-&gt;d = m[15] - m[13];
 
-	p=&amp;frustumPlane[PFAR];
-	p-&gt;n.x=m[3]-m[2];
-	p-&gt;n.y=m[7]-m[6];
-	p-&gt;n.z=m[11]-m[10];
-	p-&gt;d=m[15]-m[14];
+	p = &amp;frustumPlane[PFAR];
+	p-&gt;n.x = m[3] - m[2];
+	p-&gt;n.y = m[7] - m[6];
+	p-&gt;n.z = m[11] - m[10];
+	p-&gt;d = m[15] - m[14];
 
-	p=&amp;frustumPlane[PNEAR];
-	p-&gt;n.x=m[3]+m[2];
-	p-&gt;n.y=m[7]+m[6];
-	p-&gt;n.z=m[11]+m[10];
-	p-&gt;d=m[15]+m[14];
+	p = &amp;frustumPlane[PNEAR];
+	p-&gt;n.x = m[3] + m[2];
+	p-&gt;n.y = m[7] + m[6];
+	p-&gt;n.z = m[11] + m[10];
+	p-&gt;d = m[15] + m[14];
 
 	/* Normalize all plane normals */
-	for (i=0;i&lt;6;i++) {
-		p=&amp;frustumPlane[i];
-		d=sqrt(p-&gt;n.x*p-&gt;n.x + p-&gt;n.y*p-&gt;n.y + p-&gt;n.z*p-&gt;n.z);
-		if (d!=0.0) {
-			p-&gt;n.x/=d;
-			p-&gt;n.y/=d;
-			p-&gt;n.z/=d;
-			p-&gt;d/=d;
+	for (i = 0;i &lt; 6;i++) {
+		p = &amp;frustumPlane[i];
+		d = sqrt(p-&gt;n.x * p-&gt;n.x + p-&gt;n.y * p-&gt;n.y + p-&gt;n.z * p-&gt;n.z);
+		if (d != 0.0) {
+			p-&gt;n.x /= d;
+			p-&gt;n.y /= d;
+			p-&gt;n.z /= d;
+			p-&gt;d /= d;
 		}
 	}
 }
@@ -107,10 +107,10 @@
 {
 	int i;
 	struct t_plane *p;
-	for (i=0;i&lt;6;i++) {
-		p=&amp;frustumPlane[i];
-		if (p-&gt;n.x*center-&gt;x+p-&gt;n.y*center-&gt;y+p-&gt;n.z*center-&gt;z+p-&gt;d &lt;= -radius) {
-			/*			s3dprintf(MED,&quot;out of %d plane (n %f %f %f |d %f)&quot;,i,p-&gt;n.x,p-&gt;n.y,p-&gt;n.z,p-&gt;d);*/
+	for (i = 0;i &lt; 6;i++) {
+		p = &amp;frustumPlane[i];
+		if (p-&gt;n.x*center-&gt;x + p-&gt;n.y*center-&gt;y + p-&gt;n.z*center-&gt;z + p-&gt;d &lt;= -radius) {
+			/*   s3dprintf(MED,&quot;out of %d plane (n %f %f %f |d %f)&quot;,i,p-&gt;n.x,p-&gt;n.y,p-&gt;n.z,p-&gt;d);*/
 			return 0; /* sorry, no ... */
 		}
 	}

Modified: trunk/server/error.c
===================================================================
--- trunk/server/error.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/error.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,49 +23,49 @@
 
 
 #include &quot;global.h&quot;
-#include &lt;stdio.h&gt;	 /*  for printf() */
-#include &lt;stdarg.h&gt;	 /*  va_start, va_end */
+#include &lt;stdio.h&gt;  /*  for printf() */
+#include &lt;stdarg.h&gt;  /*  va_start, va_end */
 #include &lt;string.h&gt;  /*  for strerror() */
 #include &lt;stdlib.h&gt;  /*  for exit() */
-#define 	DBM_MAX		1024  /*  debug message buffer size */
+#define  DBM_MAX  1024  /*  debug message buffer size */
 /*  this function writes an error somewhere */
 /*  basicly, this is for upcoming logfiles, or maybe draw error-messages into */
 /*  the 3d-space */
 /*  this is the generic failure routine ... */
-void errn(char *func,int en)
+void errn(char *func, int en)
 {
-	fprintf(stderr,&quot;error: %s: (%d) %s\n&quot;,func,en, strerror(en));
+	fprintf(stderr, &quot;error: %s: (%d) %s\n&quot;, func, en, strerror(en));
 }
 /*  ... and it's fatal pendant */
-void errnf(char *func,int en)
+void errnf(char *func, int en)
 {
-	fprintf(stderr,&quot;FATAL: %s: (%d) %s\n&quot;,func,en, strerror(en));
+	fprintf(stderr, &quot;FATAL: %s: (%d) %s\n&quot;, func, en, strerror(en));
 	exit(-1);
 }
 
 /*  prints an error with the function and it's error-message */
 void errs(char *func, char *msg)
 {
-	fprintf(stderr,&quot;error: %s: %s\n&quot;,func,msg);
+	fprintf(stderr, &quot;error: %s: %s\n&quot;, func, msg);
 }
 
 void errsf(char *func, char *msg)
 {
-	fprintf(stderr,&quot;FATAL: %s: %s\n&quot;,func,msg);
+	fprintf(stderr, &quot;FATAL: %s: %s\n&quot;, func, msg);
 	exit(-1);
 }
 #ifdef DEBUG
 /*  printing error message */
-void errds(int relevance,char *func, const char *fmt, ...)
+void errds(int relevance, char *func, const char *fmt, ...)
 {
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance &gt;= DEBUG ) {
-		va_start(args,fmt);
-		vsnprintf((char *)&amp;dbm,DBM_MAX,fmt,args);
+	if (relevance &gt;= DEBUG) {
+		va_start(args, fmt);
+		vsnprintf((char *)&amp;dbm, DBM_MAX, fmt, args);
 		va_end(args);
 
-		fprintf(stderr,&quot;error: %s:%s\n&quot;,func,(char *)&amp;dbm);
+		fprintf(stderr, &quot;error: %s:%s\n&quot;, func, (char *)&amp;dbm);
 	}
 }
 /*  printing debug message */
@@ -74,13 +74,13 @@
 {
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance &gt;= DEBUG ) {
-		va_start(args,fmt);
-		vsnprintf((char *)&amp;dbm,DBM_MAX,fmt,args);
+	if (relevance &gt;= DEBUG) {
+		va_start(args, fmt);
+		vsnprintf((char *)&amp;dbm, DBM_MAX, fmt, args);
 		va_end(args);
 
-		/*		fprintf(stderr,&quot;debug: %s\n&quot;,(char *)&amp;dbm);*/
-		fprintf(stdout,&quot;debug: %s\n&quot;,(char *)&amp;dbm);
+		/*  fprintf(stderr,&quot;debug: %s\n&quot;,(char *)&amp;dbm);*/
+		fprintf(stdout, &quot;debug: %s\n&quot;, (char *)&amp;dbm);
 	}
 }
 

Modified: trunk/server/event.c
===================================================================
--- trunk/server/event.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/event.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,7 +24,7 @@
 
 #include &quot;global.h&quot;
 #include &quot;proto.h&quot;
-#include &lt;stdio.h&gt;		/* sprintf() */
+#include &lt;stdio.h&gt;  /* sprintf() */
 #ifdef WIN32
 #include &lt;winsock2.h&gt;
 #else
@@ -32,30 +32,30 @@
 #endif
 #include &lt;string.h&gt;  /*  strlen(),strcpy() */
 extern int focus_oid;
-extern int winw,winh; /* to give aspect ratio to the program */
+extern int winw, winh; /* to give aspect ratio to the program */
 /*  I don't plan to keep this until the end, but it can show us how */
 /*  to interact ... */
 int event_obj_click(struct t_process *p, int32_t oid)
 {
-	uint32_t moid=htonl(oid);
-	s3dprintf(MED,&quot;telling client that oid %d got clicked&quot;,oid);
-	prot_com_out(p,S3D_P_S_CLICK,(uint8_t *)&amp;moid, 4);
+	uint32_t moid = htonl(oid);
+	s3dprintf(MED, &quot;telling client that oid %d got clicked&quot;, oid);
+	prot_com_out(p, S3D_P_S_CLICK, (uint8_t *)&amp;moid, 4);
 	return(0);
 }
 /*  this functions sends keystroke events to the focused program. */
 /*  maybe mcp-keystrokes should be catched here. */
 /*  state = 0 -&gt; pressed, 1 -&gt; released */
-int event_key_pressed(uint16_t key, uint16_t uni, uint16_t mod,int state)
+int event_key_pressed(uint16_t key, uint16_t uni, uint16_t mod, int state)
 {
 	uint16_t k[4];
 	struct t_obj *o;
-	k[0]=htons(key);
-	k[1]=htons(uni);
-	k[2]=htons(mod);
-	k[3]=htons(state);
-	if (OBJ_VALID(get_proc_by_pid(MCP),focus_oid,o))
+	k[0] = htons(key);
+	k[1] = htons(uni);
+	k[2] = htons(mod);
+	k[3] = htons(state);
+	if (OBJ_VALID(get_proc_by_pid(MCP), focus_oid, o))
 		prot_com_out(get_proc_by_pid(o-&gt;n_mat), S3D_P_S_KEY, (uint8_t *)k, 8);
-	prot_com_out(get_proc_by_pid(MCP),S3D_P_S_KEY,(uint8_t *)k, 8); /* mcp always gets a copy */
+	prot_com_out(get_proc_by_pid(MCP), S3D_P_S_KEY, (uint8_t *)k, 8); /* mcp always gets a copy */
 	return(0);
 }
 
@@ -65,26 +65,26 @@
 {
 	struct t_obj *o;
 	uint8_t b[2];
-	b[0]=button;
-	b[1]=state;
-	if (OBJ_VALID(get_proc_by_pid(MCP),focus_oid,o))
+	b[0] = button;
+	b[1] = state;
+	if (OBJ_VALID(get_proc_by_pid(MCP), focus_oid, o))
 		prot_com_out(get_proc_by_pid(o-&gt;n_mat), S3D_P_S_MBUTTON, (uint8_t *)&amp;b, 2);
-	prot_com_out(get_proc_by_pid(MCP),S3D_P_S_MBUTTON,(uint8_t *)&amp;b, 2); /* mcp always gets a copy */
+	prot_com_out(get_proc_by_pid(MCP), S3D_P_S_MBUTTON, (uint8_t *)&amp;b, 2); /* mcp always gets a copy */
 	return(0);
 }
 /*  tell the client something about us */
 int event_init(struct t_process *p)
 {
 	char s[NAME_MAX+3];
-	sprintf(s,&quot;%c%c%c%s&quot;, S3D_SERVER_MAJOR, S3D_SERVER_MINOR, S3D_SERVER_PATCH, S3D_SERVER_NAME); /* thanks award */
-	prot_com_out(p,S3D_P_S_INIT, (uint8_t *)s, strlen(S3D_SERVER_NAME)+4);
+	sprintf(s, &quot;%c%c%c%s&quot;, S3D_SERVER_MAJOR, S3D_SERVER_MINOR, S3D_SERVER_PATCH, S3D_SERVER_NAME); /* thanks award */
+	prot_com_out(p, S3D_P_S_INIT, (uint8_t *)s, strlen(S3D_SERVER_NAME) + 4);
 	return(0);
 }
 /*  this lets a process quit gracefully ... */
 int event_quit(struct t_process *p)
 {
-	prot_com_out(p, S3D_P_S_QUIT, NULL,0);
-	s3dprintf(HIGH,&quot;sending pid %d QUIT signal&quot;,p-&gt;id);
+	prot_com_out(p, S3D_P_S_QUIT, NULL, 0);
+	s3dprintf(HIGH, &quot;sending pid %d QUIT signal&quot;, p-&gt;id);
 	process_del(p-&gt;id);
 	return(0);
 }
@@ -92,23 +92,23 @@
 int event_cam_changed()
 {
 	struct t_process *p;
-	struct t_obj	 *o;
-	p=get_proc_by_pid(MCP);
-	event_obj_info(p,0);
-	if (OBJ_VALID(p,focus_oid,o))
-		event_obj_info(get_proc_by_pid(o-&gt;n_mat),0);
+	struct t_obj  *o;
+	p = get_proc_by_pid(MCP);
+	event_obj_info(p, 0);
+	if (OBJ_VALID(p, focus_oid, o))
+		event_obj_info(get_proc_by_pid(o-&gt;n_mat), 0);
 	return(0);
 }
 /* same for the mouse movement! */
 int event_ptr_changed()
 {
 	struct t_process *p;
-	struct t_obj	 *o;
-	p=get_proc_by_pid(MCP);
-	event_obj_info(p,get_pointer(p));
-	if (OBJ_VALID(p,focus_oid,o)) {
-		p=get_proc_by_pid(o-&gt;n_mat); /* focused program pointer*/
-		event_obj_info(p,get_pointer(p));
+	struct t_obj  *o;
+	p = get_proc_by_pid(MCP);
+	event_obj_info(p, get_pointer(p));
+	if (OBJ_VALID(p, focus_oid, o)) {
+		p = get_proc_by_pid(o-&gt;n_mat); /* focused program pointer*/
+		event_obj_info(p, get_pointer(p));
 	}
 	return(0);
 }
@@ -119,36 +119,36 @@
 	struct t_obj_info mo;
 	struct t_process *ap;
 	struct t_obj *o;
-	if (OBJ_VALID(p,oid,o)) {
-		mo.object=htonl(oid);
-		mo.trans_x=p-&gt;object[oid]-&gt;translate.x;
-		mo.trans_y=p-&gt;object[oid]-&gt;translate.y;
-		mo.trans_z=p-&gt;object[oid]-&gt;translate.z;
+	if (OBJ_VALID(p, oid, o)) {
+		mo.object = htonl(oid);
+		mo.trans_x = p-&gt;object[oid]-&gt;translate.x;
+		mo.trans_y = p-&gt;object[oid]-&gt;translate.y;
+		mo.trans_z = p-&gt;object[oid]-&gt;translate.z;
 
-		mo.rot_x=p-&gt;object[oid]-&gt;rotate.x;
-		mo.rot_y=p-&gt;object[oid]-&gt;rotate.y;
-		mo.rot_z=p-&gt;object[oid]-&gt;rotate.z;
+		mo.rot_x = p-&gt;object[oid]-&gt;rotate.x;
+		mo.rot_y = p-&gt;object[oid]-&gt;rotate.y;
+		mo.rot_z = p-&gt;object[oid]-&gt;rotate.z;
 
-		mo.scale=p-&gt;object[oid]-&gt;scale;
+		mo.scale = p-&gt;object[oid]-&gt;scale;
 
-		mo.r=p-&gt;object[oid]-&gt;r;
+		mo.r = p-&gt;object[oid]-&gt;r;
 
-		memset(mo.name,0,NAME_MAX);
+		memset(mo.name, 0, NAME_MAX);
 		switch (o-&gt;oflags&amp;OF_TYPE) {
 		case OF_VIRTUAL:
-			ap=get_proc_by_pid(o-&gt;n_mat);
-			strncpy(mo.name,ap-&gt;name,NAME_MAX);
+			ap = get_proc_by_pid(o-&gt;n_mat);
+			strncpy(mo.name, ap-&gt;name, NAME_MAX);
 			break;
 		case OF_CAM:
-			mo.scale=(float)((float)winw)/winh; /* give aspect ratio to program */
-			strncpy(mo.name,&quot;sys_camera0&quot;,NAME_MAX);
+			mo.scale = (float)((float)winw) / winh; /* give aspect ratio to program */
+			strncpy(mo.name, &quot;sys_camera0&quot;, NAME_MAX);
 			break;
 		case OF_POINTER:
-			strncpy(mo.name,&quot;sys_pointer0&quot;,NAME_MAX);
+			strncpy(mo.name, &quot;sys_pointer0&quot;, NAME_MAX);
 			break;
 
 		}
-		prot_com_out(p,S3D_P_S_OINFO,(uint8_t *)&amp;mo,sizeof(struct t_obj_info));
+		prot_com_out(p, S3D_P_S_OINFO, (uint8_t *)&amp;mo, sizeof(struct t_obj_info));
 	}
 	return(0);
 }

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/global.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -28,13 +28,13 @@
 #undef SHM
 #endif
 #endif
-#include &lt;stdint.h&gt;		 /*  integer types */
+#include &lt;stdint.h&gt;   /*  integer types */
 #ifdef SHM
 #include &lt;sys/shm.h&gt; /* key_t */
 #endif
 /*  variables and defines */
-extern int frame_mode; 	 /*  GLUT, SDL, ... ? */
-extern int running;		 /*  server running flag */
+extern int frame_mode;   /*  GLUT, SDL, ... ? */
+extern int running;   /*  server running flag */
 /*  relevance macros */
 #ifndef S3DUNUSED
 #if defined(UNUSEDPARAM_ATTRIBUTE)
@@ -45,152 +45,152 @@
 #define S3DUNUSED(x) x
 #endif
 #endif
-#define NAME_MAX	256		 /*  limit for names [e.g. process names] */
-#define MCP			0		 /*  the mcp's pid	 */
-#define TEXTURE_MAX_W	2048
-#define TEXTURE_MAX_H	2048
+#define NAME_MAX 256   /*  limit for names [e.g. process names] */
+#define MCP   0   /*  the mcp's pid  */
+#define TEXTURE_MAX_W 2048
+#define TEXTURE_MAX_H 2048
 /*  server version */
-#define S3D_SERVER_MAJOR	0
-#define S3D_SERVER_MINOR	1
-#define S3D_SERVER_PATCH	1
-#define S3D_SERVER_NAME 	&quot;dotslash s3d server&quot;
+#define S3D_SERVER_MAJOR 0
+#define S3D_SERVER_MINOR 1
+#define S3D_SERVER_PATCH 1
+#define S3D_SERVER_NAME  &quot;dotslash s3d server&quot;
 
-#define MAXPLEN	65536
+#define MAXPLEN 65536
 
-#define RB_STD_SIZE		1024*512
-#define RB_MAX_SIZE		1048*4096
-#define SHM_SIZE 	sizeof(key_t)*2  		/* space for the keys */
+#define RB_STD_SIZE  1024*512
+#define RB_MAX_SIZE  1048*4096
+#define SHM_SIZE  sizeof(key_t)*2    /* space for the keys */
 
-#define RB_OVERHEAD		sizeof(struct buf_t)
+#define RB_OVERHEAD  sizeof(struct buf_t)
 
-#define OBJ_VALID(p,oid,o)	(oid &gt;= 0) &amp;&amp; ((oid &lt; p-&gt;n_obj) &amp;&amp; ((o=p-&gt;object[oid])!=NULL))
+#define OBJ_VALID(p,oid,o) (oid &gt;= 0) &amp;&amp; ((oid &lt; p-&gt;n_obj) &amp;&amp; ((o=p-&gt;object[oid])!=NULL))
 typedef float t_mtrx[16];
 
 struct buf_t {
-	uint32_t start,end,bufsize;	/* start/end of the data */
+	uint32_t start, end, bufsize; /* start/end of the data */
 };
 
 /*  some graphic simple prototypes, they might get into some headerfile later ... */
 /*  our lovely vertex list ... */
 struct t_vertex {
-	float x,y,z;
+	float x, y, z;
 };
 struct t_texc {
-	float x,y;
+	float x, y;
 };
 /*  polygon definition; */
 /*  it's all handled via list types as usually we have only one surface for many polygons, */
 /*  and many vertexes have 2 or more polygons connected. OpenGL will optimize the lists for us */
 /*  anyways, so we shouldn't care ... */
 struct t_poly {
-	uint32_t v[3]; 				 /*  we define a poly as set of 3 vertexes, as its usual */
-	struct t_vertex n[3]; 		 /*  normal vectors */
-	uint32_t mat;  				 /*  material index */
-	struct t_texc tc[3];		 /*  texture coords */
+	uint32_t v[3];      /*  we define a poly as set of 3 vertexes, as its usual */
+	struct t_vertex n[3];    /*  normal vectors */
+	uint32_t mat;       /*  material index */
+	struct t_texc tc[3];   /*  texture coords */
 };
 struct t_line {
 	uint32_t v[2];
-	struct t_vertex n[2];		 /* normal vectors */
+	struct t_vertex n[2];   /* normal vectors */
 	uint32_t mat;
 };
 /*  material of surfaces, as it's usual in the OpenGL standard */
 struct t_mat {
-	float amb_r,amb_g,amb_b,amb_a, 			 /*  ambience */
-	spec_r,spec_g,spec_b,spec_a,	 	 /*  specualar */
-	diff_r,diff_g,diff_b,diff_a;		 /*  diffusion */
-	int32_t tex;							 /*  texture index, -1 if there is no */
+	float amb_r, amb_g, amb_b, amb_a,  /*  ambience */
+	spec_r, spec_g, spec_b, spec_a, /*  specualar */
+	diff_r, diff_g, diff_b, diff_a;   /*  diffusion */
+	int32_t tex;        /*  texture index, -1 if there is no */
 };
 /*  this defines a texture */
 struct t_tex {
-	uint16_t w,h;		 /*  width and height */
-	uint16_t tw,th;		 /*  texture width */
-	uint8_t *buf;		 /*  the data */
-	float xs,ys;		 /*  scale data for gl-implementations which require 2^x */
+	uint16_t w, h;  /*  width and height */
+	uint16_t tw, th;  /*  texture width */
+	uint8_t *buf;   /*  the data */
+	float xs, ys;  /*  scale data for gl-implementations which require 2^x */
 	/*  texture sizes. */
-	int32_t gl_texnum;	 /*  the gl texture number. */
+	int32_t gl_texnum;  /*  the gl texture number. */
 };
 /*  the object type */
 struct t_obj {
-	uint32_t oflags;			 /*  flags, like this object beeing input etc. */
-#define OF_TURN_ON 		1
-#define OF_TURN_OFF 	2
-#define OF_TURN_SWAP 	3
+	uint32_t oflags;    /*  flags, like this object beeing input etc. */
+#define OF_TURN_ON   1
+#define OF_TURN_OFF  2
+#define OF_TURN_SWAP  3
 
-#define	OF_VISIBLE		0x00000001
-#define	OF_SELECTABLE	0x00000002
-#define	OF_POINTABLE	0x00000004
+#define OF_VISIBLE  0x00000001
+#define OF_SELECTABLE 0x00000002
+#define OF_POINTABLE 0x00000004
 
-#define OF_CLONE_SRC	0x01000000
-#define OF_LINK_SRC		0x02000000
-#define OF_LINK			0x04000000
+#define OF_CLONE_SRC 0x01000000
+#define OF_LINK_SRC  0x02000000
+#define OF_LINK   0x04000000
 
 
-#define OF_TYPE			0xF0000000
-#define OF_NODATA		0xF0000000 /* no data allowed! */
+#define OF_TYPE   0xF0000000
+#define OF_NODATA  0xF0000000 /* no data allowed! */
 
-#define OF_CLONE		0x10000000
-#define OF_VIRTUAL		0x20000000
+#define OF_CLONE  0x10000000
+#define OF_VIRTUAL  0x20000000
 
-#define OF_SYSTEM		0x80000000
-#define OF_CAM			0x90000000
-#define OF_POINTER		0xA0000000
-#define OF_3DPOINTER	0xB0000000
+#define OF_SYSTEM  0x80000000
+#define OF_CAM   0x90000000
+#define OF_POINTER  0xA0000000
+#define OF_3DPOINTER 0xB0000000
 
-#define OF_MASK			0x00FFFFFF
+#define OF_MASK   0x00FFFFFF
 	int32_t n_vertex, n_mat, n_poly, n_tex, n_line;
 	/*  if OF_VIRTUAL is set, n_mat contains the pid */
 	/*  if OF_CLONE is set, n_vertex contains the original oid */
 	/*  I know this is dirty, but it would a waste of data if I don't do so ... */
-	int32_t dplist;		 /*  opengl display list number */
-	int32_t linkid;		 /*  linking target, -1 if there is none */
-	int32_t lsub,lnext,lprev;
+	int32_t dplist;   /*  opengl display list number */
+	int32_t linkid;   /*  linking target, -1 if there is none */
+	int32_t lsub, lnext, lprev;
 	/*  pointer to our objects; */
 	struct t_vertex *p_vertex;
-	struct t_mat	*p_mat;
-	struct t_poly	*p_poly;
+	struct t_mat *p_mat;
+	struct t_poly *p_poly;
 	struct t_line   *p_line;
-	struct t_tex	*p_tex;
-	struct t_vertex translate,rotate;
-	float 			scale;
-	t_mtrx			m;
-	int				m_uptodate;
-	float r,or;					 /*  radius, object radius */
+	struct t_tex *p_tex;
+	struct t_vertex translate, rotate;
+	float    scale;
+	t_mtrx   m;
+	int    m_uptodate;
+	float r, or;     /*  radius, object radius */
 };
 #ifdef SHM
 struct t_shmcb {
-	int shmid_ctos,shmid_stoc;
-	key_t key_ctos,key_stoc;
-	char *data_ctos,*data_stoc;
-	int size_ctos,size_stoc;
+	int shmid_ctos, shmid_stoc;
+	key_t key_ctos, key_stoc;
+	char *data_ctos, *data_stoc;
+	int size_ctos, size_stoc;
 	int idle;
 };
 #endif
 
 /*  l_* is a list-type, t_* is the type itself */
 struct t_process {
-	char 				  name[NAME_MAX];		 /*  process name */
-	struct t_obj		**object;				 /*  initial pointer to object list */
-	int32_t				  n_obj;				 /*  number of objects */
-	int32_t				  biggest_obj;			 /*  the biggest object */
-	int32_t				  mcp_oid;				 /*  oid in mcp */
-	int 				  id;					 /*  pid */
-	int					  con_type;				 /*  type of connection, one of following: */
-#define CON_NULL	0
-#define CON_TCP		1
-#define CON_SHM		2
+	char       name[NAME_MAX];   /*  process name */
+	struct t_obj  **object;     /*  initial pointer to object list */
+	int32_t      n_obj;     /*  number of objects */
+	int32_t      biggest_obj;    /*  the biggest object */
+	int32_t      mcp_oid;     /*  oid in mcp */
+	int       id;      /*  pid */
+	int       con_type;     /*  type of connection, one of following: */
+#define CON_NULL 0
+#define CON_TCP  1
+#define CON_SHM  2
 #ifdef TCP
-	int					  sockid;
+	int       sockid;
 #endif
 #ifdef SHM
-	struct t_shmcb		  shmsock;
+	struct t_shmcb    shmsock;
 #endif
 };
 
 struct t_obj_info {
 	int32_t object;
 	uint32_t flags;
-	float trans_x,trans_y,trans_z;
-	float rot_x,rot_y,rot_z;
+	float trans_x, trans_y, trans_z;
+	float rot_x, rot_y, rot_z;
 	float scale;
 	float r;
 	char name[NAME_MAX];
@@ -211,11 +211,11 @@
 int network_init(void);
 int network_quit(void);
 int network_main(void);
-int n_readn(struct t_process *p, uint8_t *str,int s);
-int n_writen(struct t_process *p, uint8_t *str,int s);
+int n_readn(struct t_process *p, uint8_t *str, int s);
+int n_writen(struct t_process *p, uint8_t *str, int s);
 int n_remove(struct t_process *p);
 #ifdef G_SDL
-int	net_turn_off(int interval);
+int net_turn_off(int interval);
 #endif
 /* tcp.c */
 int tcp_init(void);
@@ -223,21 +223,21 @@
 int tcp_pollport(void);
 int tcp_pollproc(void);
 int tcp_prot_com_in(struct t_process *p);
-int tcp_writen(int sock, uint8_t *str,int s);
-int tcp_readn(int sock, uint8_t *str,int s);
+int tcp_writen(int sock, uint8_t *str, int s);
+int tcp_readn(int sock, uint8_t *str, int s);
 int tcp_remove(int sock);
 /* shm.c/shm_ringbuf.c */
 int shm_init(void);
 int shm_quit(void);
 int shm_main(void);
 int shm_remove(struct t_process *p);
-int shm_writen(struct buf_t *rb,uint8_t *buf, int n);
-int shm_readn(struct buf_t *rb,uint8_t *buf, int n);
+int shm_writen(struct buf_t *rb, uint8_t *buf, int n);
+int shm_readn(struct buf_t *rb, uint8_t *buf, int n);
 int shm_prot_com_in(struct t_process *p);
 /* shm_ringbuf.c */
-void ringbuf_init(char *data,uint32_t init_size);
-int shm_write(struct buf_t *rb,char *buf, int n);
-int shm_read(struct buf_t *rb,char *buf, int n);
+void ringbuf_init(char *data, uint32_t init_size);
+int shm_write(struct buf_t *rb, char *buf, int n);
+int shm_read(struct buf_t *rb, char *buf, int n);
 /*  proto.c */
 int prot_com_in(struct t_process *p, uint8_t *pbuf);
 int prot_com_out(struct t_process *p, uint8_t opcode, uint8_t *buf, uint16_t length);
@@ -273,7 +273,7 @@
 void errs(char *func, char *msg);
 void errsf(char *func, char *msg);
 #ifdef DEBUG
-void errds(int relevance,char *func, const char *fmt, ...);
+void errds(int relevance, char *func, const char *fmt, ...);
 void s3dprintf(int relevance, const char *msg, ...);
 #else
 static __inline__ void errds(int relevance __attribute__((unused)),
@@ -297,7 +297,7 @@
 int graphics_quit_sdl(void);
 #endif
 
-void graphics_reshape( int w, int h);
+void graphics_reshape(int w, int h);
 /*  navigation.c */
 void navi_left(void);
 void navi_right(void);
@@ -318,45 +318,45 @@
 struct t_process *process_protinit(struct t_process *p, char *name);
 struct t_process *get_proc_by_pid(int pid);
 /*  object.c */
-int obj_debug			(struct t_process *p, int32_t oid);
-int obj_new				(struct t_process *p);
-int obj_clone			(struct t_process *p, int32_t oid);
-int obj_clone_change	(struct t_process *p, int32_t oid, int32_t toid);
-int obj_link			(struct t_process *p, int32_t oid_from, int32_t oid_to);
-int obj_unlink			(struct t_process *p, int32_t oid);
-int obj_del				(struct t_process *p, int32_t oid);
-int obj_push_vertex		(struct t_process *p, int32_t oid, float *x, int32_t n);
-int obj_push_mat		(struct t_process *p, int32_t oid, float *x, int32_t n);
-int obj_push_poly		(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
-int obj_push_line		(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
-int obj_push_tex		(struct t_process *p, int32_t oid, uint16_t *x, int32_t n);
-int obj_pep_poly_normal	(struct t_process *p, int32_t oid, float *x, int32_t n);
-int obj_pep_line_normal (struct t_process *p, int32_t oid, float *x, int32_t n);
-int obj_pep_poly_texc	(struct t_process *p, int32_t oid, float *x, int32_t  n);
-int obj_pep_mat			(struct t_process *p, int32_t oid, float *x, int32_t n);
-int obj_pep_mat_tex		(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
-int obj_pep_vertex		(struct t_process *p, int32_t oid, float *x, int32_t n);
-int obj_pep_line		(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
+int obj_debug(struct t_process *p, int32_t oid);
+int obj_new(struct t_process *p);
+int obj_clone(struct t_process *p, int32_t oid);
+int obj_clone_change(struct t_process *p, int32_t oid, int32_t toid);
+int obj_link(struct t_process *p, int32_t oid_from, int32_t oid_to);
+int obj_unlink(struct t_process *p, int32_t oid);
+int obj_del(struct t_process *p, int32_t oid);
+int obj_push_vertex(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_push_mat(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_push_poly(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
+int obj_push_line(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
+int obj_push_tex(struct t_process *p, int32_t oid, uint16_t *x, int32_t n);
+int obj_pep_poly_normal(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_pep_line_normal(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_pep_poly_texc(struct t_process *p, int32_t oid, float *x, int32_t  n);
+int obj_pep_mat(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_pep_mat_tex(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
+int obj_pep_vertex(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_pep_line(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
 int obj_load_poly_normal(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
 int obj_load_line_normal(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
-int obj_load_poly_texc	(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
-int obj_load_mat		(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
-int obj_load_tex		(struct t_process *p, int32_t oid, int32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf);
-int obj_del_vertex		(struct t_process *p, int32_t oid, int32_t n);
-int obj_del_mat			(struct t_process *p, int32_t oid, int32_t n);
-int obj_del_poly		(struct t_process *p, int32_t oid, int32_t n);
-int obj_del_line		(struct t_process *p, int32_t oid, int32_t n);
-int obj_del_tex			(struct t_process *p, int32_t oid, int32_t n);
-int obj_toggle_flags	(struct t_process *p, int32_t oid, uint8_t type, uint32_t flags);
-int obj_translate		(struct t_process *p, int32_t oid, float *transv);
-int obj_rotate			(struct t_process *p, int32_t oid, float *rotv);
-int obj_scale			(struct t_process *p, int32_t oid, float scav);
-int obj_render			(struct t_process *p, int32_t oid);
-int obj_free			(struct t_process *p, int32_t oid);
-void obj_get_maximum	(struct t_process *p, struct t_obj *obj);
-void into_position		(struct t_process *p, struct t_obj *obj, int depth);
-void obj_recalc_tmat	(struct t_process *p, int32_t oid);
-void obj_size_update	(struct t_process *p, int32_t oid);
+int obj_load_poly_texc(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
+int obj_load_mat(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
+int obj_load_tex(struct t_process *p, int32_t oid, int32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf);
+int obj_del_vertex(struct t_process *p, int32_t oid, int32_t n);
+int obj_del_mat(struct t_process *p, int32_t oid, int32_t n);
+int obj_del_poly(struct t_process *p, int32_t oid, int32_t n);
+int obj_del_line(struct t_process *p, int32_t oid, int32_t n);
+int obj_del_tex(struct t_process *p, int32_t oid, int32_t n);
+int obj_toggle_flags(struct t_process *p, int32_t oid, uint8_t type, uint32_t flags);
+int obj_translate(struct t_process *p, int32_t oid, float *transv);
+int obj_rotate(struct t_process *p, int32_t oid, float *rotv);
+int obj_scale(struct t_process *p, int32_t oid, float scav);
+int obj_render(struct t_process *p, int32_t oid);
+int obj_free(struct t_process *p, int32_t oid);
+void obj_get_maximum(struct t_process *p, struct t_obj *obj);
+void into_position(struct t_process *p, struct t_obj *obj, int depth);
+void obj_recalc_tmat(struct t_process *p, int32_t oid);
+void obj_size_update(struct t_process *p, int32_t oid);
 void obj_pos_update(struct t_process *p, int32_t oid, int32_t first_oid);
 void obj_check_biggest_object(struct t_process *p, int32_t oid);
 int32_t get_pointer(struct t_process *p);
@@ -392,7 +392,7 @@
 void *debugMalloc(unsigned int length, int tag);
 void *debugRealloc(void *memory, unsigned int length, int tag);
 void debugFree(void *memoryParameter);
-#define malloc(x)		debugMalloc(x,42)
-#define free(x)			debugFree(x);
-#define realloc(x,y)	debugRealloc(x,y,42)
+#define malloc(x)  debugMalloc(x,42)
+#define free(x)   debugFree(x);
+#define realloc(x,y) debugRealloc(x,y,42)
 #endif

Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/graphics.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,18 +22,18 @@
  */
 
 #include &quot;global.h&quot;
-#include &lt;stdlib.h&gt;		 /*  malloc() */
-#include &lt;string.h&gt;		 /*  memcpy() */
+#include &lt;stdlib.h&gt;   /*  malloc() */
+#include &lt;string.h&gt;   /*  memcpy() */
 /*
 #ifdef G_GLUT
-#include &lt;GL/glut.h&gt; 	 *  glutWireTorus() -  to be removed later *
+#include &lt;GL/glut.h&gt;   *  glutWireTorus() -  to be removed later *
 #endif
 */
-#include &lt;GL/gl.h&gt;		 /*  GLint */
+#include &lt;GL/gl.h&gt;   /*  GLint */
 #ifdef G_SDL
-#include &lt;SDL.h&gt;	 /*  SDL_GL_SwapBuffers */
+#include &lt;SDL.h&gt;  /*  SDL_GL_SwapBuffers */
 #endif
-#include &lt;math.h&gt;		 /*  sin(),cos() */
+#include &lt;math.h&gt;   /*  sin(),cos() */
 #ifndef INFINITY
 #define INFINITY 1&lt;&lt;30
 #endif
@@ -41,15 +41,15 @@
 /*  local prototypes ... */
 void render_virtual_object(struct t_obj *o);
 /*  ... and types/variables */
-int select_mode=0;
-int winw,winh;
+int select_mode = 0;
+int winw, winh;
 extern struct t_process *procs_p;
 extern int frame_mode;  /*  GLUT, SDL, ... ? */
 /*  this detects and opens the SDL things */
 
-int graphics_init ()
+int graphics_init()
 {
-	GLfloat shin[]={16.0};
+	GLfloat shin[] = {16.0};
 	switch (frame_mode) {
 #ifdef G_SDL
 	case FRAME_SDL:
@@ -74,13 +74,13 @@
 
 	/* textures */
 	glEnable(GL_TEXTURE_2D);
-	glShadeModel (GL_SMOOTH);
+	glShadeModel(GL_SMOOTH);
 	glDisable(GL_DITHER);
 
 	/* lines */
 	glHint(GL_LINE_SMOOTH_HINT, GL_FASTEST);
 	glLineWidth(1.0);
-	glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
+	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
 
 	/* polygon smoothing */
 	glDisable(GL_POLYGON_SMOOTH);
@@ -89,7 +89,7 @@
 
 	/* normalizing */
 	glDisable(GL_AUTO_NORMAL);
-	glDisable(GL_NORMALIZE); 		/* don't use the expensive GL_NORMALIZE, we use uniform scaling so GL_RESCALE_NORMAL is sufficent */
+	glDisable(GL_NORMALIZE);   /* don't use the expensive GL_NORMALIZE, we use uniform scaling so GL_RESCALE_NORMAL is sufficent */
 	glEnable(GL_RESCALE_NORMAL);
 
 	/* blending */
@@ -98,9 +98,9 @@
 	/*    glBlendFunc(GL_SRC_ALPHA_SATURATE, GL_ONE);*/
 
 	/* set shininess */
-	/* 	glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS,shin); */
-	glMaterialfv(GL_FRONT,GL_SHININESS,shin);
-	graphics_reshape(X_RES,Y_RES);
+	/*  glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS,shin); */
+	glMaterialfv(GL_FRONT, GL_SHININESS, shin);
+	graphics_reshape(X_RES, Y_RES);
 
 	/* face culling */
 	glCullFace(GL_FRONT);
@@ -108,56 +108,56 @@
 	return(0);
 }
 /*  this is to be called when the window is resized or created ... */
-void graphics_reshape( int w, int h)
+void graphics_reshape(int w, int h)
 {
-	glViewport (0, 0, (GLsizei) w, (GLsizei) h);
-	winw=w;
-	winh=h;
-	glMatrixMode (GL_PROJECTION);
-	glLoadIdentity ();
-	if (w&gt;h)
-		glFrustum(-((1.0*w)/h),(1.0*w)/h,-1.0,1.0,1.0,5000);
+	glViewport(0, 0, (GLsizei) w, (GLsizei) h);
+	winw = w;
+	winh = h;
+	glMatrixMode(GL_PROJECTION);
+	glLoadIdentity();
+	if (w &gt; h)
+		glFrustum(-((1.0*w) / h), (1.0*w) / h, -1.0, 1.0, 1.0, 5000);
 	else
-		glFrustum(-1.0,1.0,-(1.0*h)/w,(1.0*h)/w,1.0,5000);
+		glFrustum(-1.0, 1.0, -(1.0*h) / w, (1.0*h) / w, 1.0, 5000);
 	glMatrixMode(GL_MODELVIEW);
-	if (procs_p!=NULL)
+	if (procs_p != NULL)
 		event_cam_changed();
 }
 void render_virtual_object(struct t_obj *o)
 {
 	struct t_process *ap;
-	struct t_vertex x,y;
-	int32_t j,k;
+	struct t_vertex x, y;
+	int32_t j, k;
 	t_mtrx m;
 
 	glPushMatrix();
 	glMultMatrixf(o-&gt;m);
-	glGetFloatv(GL_MODELVIEW_MATRIX,m);
+	glGetFloatv(GL_MODELVIEW_MATRIX, m);
 	cull_get_planes();
-	if (NULL==(ap=get_proc_by_pid(o-&gt;n_mat))) { /*  the clean way */
-		errds(HIGH,&quot;render_by_mcp()&quot;,&quot;not existing pid (%d) referenced by mcp-object!!&quot;, o);
+	if (NULL == (ap = get_proc_by_pid(o-&gt;n_mat))) { /*  the clean way */
+		errds(HIGH, &quot;render_by_mcp()&quot;, &quot;not existing pid (%d) referenced by mcp-object!!&quot;, o);
 	} else {
 		/*  now go throu the objects of our app  */
-		for (j=0;j&lt;ap-&gt;n_obj;j++) {
-			if (ap-&gt;object[j]!=NULL) {
-				if (((select_mode==0) &amp;&amp; ap-&gt;object[j]-&gt;oflags&amp;OF_VISIBLE) || ((select_mode ==1 ) &amp;&amp; (ap-&gt;object[j]-&gt;oflags&amp;OF_SELECTABLE))) { /* either select mode is off or it's selectable */
-					x.x=x.y=x.z=0.0f;
+		for (j = 0;j &lt; ap-&gt;n_obj;j++) {
+			if (ap-&gt;object[j] != NULL) {
+				if (((select_mode == 0) &amp;&amp; ap-&gt;object[j]-&gt;oflags&amp;OF_VISIBLE) || ((select_mode == 1) &amp;&amp; (ap-&gt;object[j]-&gt;oflags&amp;OF_SELECTABLE))) { /* either select mode is off or it's selectable */
+					x.x = x.y = x.z = 0.0f;
 					mySetMatrix(ap-&gt;object[j]-&gt;m); /* get into position ... */
 					myTransformV(&amp;x);
-					y.x=1.0;
-					y.y=y.z=0.0f;
+					y.x = 1.0;
+					y.y = y.z = 0.0f;
 					myTransformV(&amp;y);
-					y.x-=x.x;
-					y.y-=x.y;
-					y.z-=x.z;
+					y.x -= x.x;
+					y.y -= x.y;
+					y.z -= x.z;
 
-					k=cull_sphere_in_frustum(&amp;x,ap-&gt;object[j]-&gt;r * sqrt(y.x*y.x + y.y*y.y + y.z*y.z));
+					k = cull_sphere_in_frustum(&amp;x, ap-&gt;object[j]-&gt;r * sqrt(y.x * y.x + y.y * y.y + y.z * y.z));
 					if (k) {
-						/*						s3dprintf(HIGH,&quot;object %d is in %s frustum&quot;,j,k?&quot;&quot;:&quot;not&quot;);*/
-						if (select_mode==1)
+						/*      s3dprintf(HIGH,&quot;object %d is in %s frustum&quot;,j,k?&quot;&quot;:&quot;not&quot;);*/
+						if (select_mode == 1)
 							glPushName(j);
-						obj_render(ap,j);
-						if (select_mode==1)
+						obj_render(ap, j);
+						if (select_mode == 1)
 							glPopName();
 					}
 				}
@@ -170,57 +170,57 @@
 /*  recursively positiniong the objects into the space. */
 int render_by_mcp()
 {
-	struct t_process *p=get_proc_by_pid(MCP);
+	struct t_process *p = get_proc_by_pid(MCP);
 	int32_t i;
 	struct t_obj *o;
-	struct t_vertex x,y;
+	struct t_vertex x, y;
 	int k;
-	for (i=0 ; i &lt; p-&gt;n_obj ; i++) {  /* check all mcp objects ... */
-		o=p-&gt;object[i];
-		if (o!=NULL) {
-			if ((select_mode==0 &amp;&amp; o-&gt;oflags&amp;OF_VISIBLE) || (select_mode==1 &amp;&amp; o-&gt;oflags&amp;OF_SELECTABLE)) { /*  it's even visible ;) */
+	for (i = 0 ; i &lt; p-&gt;n_obj ; i++) {  /* check all mcp objects ... */
+		o = p-&gt;object[i];
+		if (o != NULL) {
+			if ((select_mode == 0 &amp;&amp; o-&gt;oflags&amp;OF_VISIBLE) || (select_mode == 1 &amp;&amp; o-&gt;oflags&amp;OF_SELECTABLE)) { /*  it's even visible ;) */
 				if (o-&gt;oflags&amp;OF_VIRTUAL) { /*  we have an app here. */
-					if (o-&gt;r!=0.0) {
+					if (o-&gt;r != 0.0) {
 						cull_get_planes();
 						mySetMatrix(o-&gt;m);
-						x.x=x.y=x.z=0.0f;
+						x.x = x.y = x.z = 0.0f;
 						myTransformV(&amp;x);
-						y.x=1.0;
-						y.y=y.z=0.0f;
+						y.x = 1.0;
+						y.y = y.z = 0.0f;
 						myTransformV(&amp;y);
-						y.x-=x.x;
-						y.y-=x.y;
-						y.z-=x.z;
+						y.x -= x.x;
+						y.y -= x.y;
+						y.z -= x.z;
 
-						k=cull_sphere_in_frustum(&amp;x,o-&gt;r * sqrt(y.x*y.x + y.y*y.y + y.z*y.z));
-						s3dprintf(VLOW,&quot;mcp-object %d is in %s frustum&quot;,i,k?&quot;&quot;:&quot;not&quot;);
+						k = cull_sphere_in_frustum(&amp;x, o-&gt;r * sqrt(y.x * y.x + y.y * y.y + y.z * y.z));
+						s3dprintf(VLOW, &quot;mcp-object %d is in %s frustum&quot;, i, k ? &quot;&quot; : &quot;not&quot;);
 						if (k) {
-							if (select_mode==1) {
-								s3dprintf(VLOW,&quot;object %d in culling frustrum!&quot;,i);
+							if (select_mode == 1) {
+								s3dprintf(VLOW, &quot;object %d in culling frustrum!&quot;, i);
 								glLoadName(i);
 							}
 							render_virtual_object(o);
 						} else {
-							if (select_mode==1) {
-								s3dprintf(VLOW,&quot;object %d not in culling frustrum!&quot;,i);
+							if (select_mode == 1) {
+								s3dprintf(VLOW, &quot;object %d not in culling frustrum!&quot;, i);
 							}
 						}
 					}
 				} else if ((o-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[o-&gt;n_vertex]-&gt;oflags&amp;OF_VIRTUAL)) { /* it's a clone of an app */
-					if (select_mode==1)
+					if (select_mode == 1)
 						glLoadName(o-&gt;n_vertex);/*TODO: what to do if a clone is selected?! */
 					glPushMatrix();
 					render_virtual_object(o);
 					render_virtual_object(p-&gt;object[o-&gt;n_vertex]);
 					glPopMatrix();
 				} else { /* it's a &quot;regular&quot; mcp object */
-					if (select_mode==1) {
-						s3dprintf(VLOW,&quot;mcp object no. %d&quot;,i);
+					if (select_mode == 1) {
+						s3dprintf(VLOW, &quot;mcp object no. %d&quot;, i);
 						glLoadName(-1);
 						glPushName(i);
 					}
-					obj_render(p,i);
-					if (select_mode==1)
+					obj_render(p, i);
+					if (select_mode == 1)
 						glPopName();
 				}
 			}
@@ -231,36 +231,36 @@
 /* this picks objects from their screen-positions and sends
  * OBK_CLICK-events for the selected object(s).
  * TODO: how big should the select buffer be? */
-#define SBSIZE	65536
+#define SBSIZE 65536
 int graphics_pick_obj(int x, int y)
 {
-	int i,j;
+	int i, j;
 	GLint viewport[4];
-	GLfloat xpos,ypos;
-	float big,z1,z2;
-	int32_t mcp_o,o;
-	struct t_process *p=get_proc_by_pid(MCP);
-	GLuint select_buf[SBSIZE],*ptr;
+	GLfloat xpos, ypos;
+	float big, z1, z2;
+	int32_t mcp_o, o;
+	struct t_process *p = get_proc_by_pid(MCP);
+	GLuint select_buf[SBSIZE], *ptr;
 	int hits, names;
 	t_mtrx m;
 
-	select_mode=1;
-	glSelectBuffer(SBSIZE,select_buf);
+	select_mode = 1;
+	glSelectBuffer(SBSIZE, select_buf);
 	glRenderMode(GL_SELECT);
 	glMatrixMode(GL_PROJECTION);
 	/*  count the objects .... */
 	glPushMatrix();
 	glLoadIdentity();
 	glGetIntegerv(GL_VIEWPORT, viewport);
-	if (winw&gt;winh) {
-		xpos=((x-winw/2.0)/(winw/2.0))*(((double)winw/winh));
-		ypos=(((winh-y)-winh/2.0)/(winh/2.0));
+	if (winw &gt; winh) {
+		xpos = ((x - winw / 2.0) / (winw / 2.0)) * (((double)winw / winh));
+		ypos = (((winh - y) - winh / 2.0) / (winh / 2.0));
 	} else {
-		xpos=((x-winw/2.0)/(winw/2.0));
-		ypos=(((winh-y)-winh/2.0)/(winh/2.0))*(((double)winh/winw));
+		xpos = ((x - winw / 2.0) / (winw / 2.0));
+		ypos = (((winh - y) - winh / 2.0) / (winh / 2.0)) * (((double)winh / winw));
 	}
 #define mnear 0.001  /*  omg this is so dirty ... but works after all */
-	glFrustum(xpos-mnear,xpos+mnear,ypos-mnear,ypos+mnear,1,5000);
+	glFrustum(xpos - mnear, xpos + mnear, ypos - mnear, ypos + mnear, 1, 5000);
 	glMatrixMode(GL_MODELVIEW);
 	glLoadIdentity();  /*  get into position ... */
 	mySetMatrix(p-&gt;object[0]-&gt;m);
@@ -268,88 +268,88 @@
 	myGetMatrix(m);
 	glMultMatrixf(m);
 	/*
-		glRotatef(-cam.rotate.x, 1.0,0.0,0.0);
-		glRotatef(-cam.rotate.y, 0.0,1.0,0.0);
-		glTranslatef(-cam.translate.x,-cam.translate.y,-cam.translate.z);*/
+	 glRotatef(-cam.rotate.x, 1.0,0.0,0.0);
+	 glRotatef(-cam.rotate.y, 0.0,1.0,0.0);
+	 glTranslatef(-cam.translate.x,-cam.translate.y,-cam.translate.z);*/
 
 	glInitNames();
 	glPushName(0);
 	render_by_mcp();
 	glFlush();
-	hits=glRenderMode(GL_RENDER);
-	if ( hits &gt; 0 ) {
-		big=INFINITY;
-		s3dprintf(LOW,&quot;had %d hits&quot;,hits);
-		ptr=select_buf;
-		mcp_o= o= names= -1;
+	hits = glRenderMode(GL_RENDER);
+	if (hits &gt; 0) {
+		big = INFINITY;
+		s3dprintf(LOW, &quot;had %d hits&quot;, hits);
+		ptr = select_buf;
+		mcp_o = o = names = -1;
 		/* check all the hits, only select the nearest ... */
-		for (i=0 ; i &lt; hits ; i++) {
-			names=*ptr;
+		for (i = 0 ; i &lt; hits ; i++) {
+			names = *ptr;
 			ptr++;
-			z1=(float)*ptr/0x7fffffff;
+			z1 = (float) * ptr / 0x7fffffff;
 			ptr++;
-			z2=(float)*ptr/0x7fffffff;
+			z2 = (float) * ptr / 0x7fffffff;
 			ptr++;
-			if (z1&lt;big) {
-				mcp_o=o=-1;
-				for (j=0;j&lt;names;j++) {
+			if (z1 &lt; big) {
+				mcp_o = o = -1;
+				for (j = 0;j &lt; names;j++) {
 					switch (j) {
 					case 0:
-						mcp_o=	*ptr;
+						mcp_o = *ptr;
 						break;
 					case 1:
-						o=		*ptr;
+						o =  *ptr;
 						break;
 					}
 					ptr++;
 				}
-				big=z1;
+				big = z1;
 			} else
-				for (j=0;j&lt;names;j++)
+				for (j = 0;j &lt; names;j++)
 					ptr++;
-			s3dprintf(VLOW,&quot;[HIT %d] names %d [z1:%f|z2:%f] mcp_o=%d, o=%d &quot;,i,names, z1, z2, mcp_o, o);
+			s3dprintf(VLOW, &quot;[HIT %d] names %d [z1:%f|z2:%f] mcp_o=%d, o=%d &quot;, i, names, z1, z2, mcp_o, o);
 		}
-		s3dprintf(VLOW,&quot;mcp_o= %d, o= %d&quot;,mcp_o,o);
-		ptr=select_buf;
-		if (mcp_o==-1) { /* it's an mcp object */
-			s3dprintf(LOW,&quot;clicked on mcp-object no. %d&quot;,o);
-			event_obj_click(p,o);
+		s3dprintf(VLOW, &quot;mcp_o= %d, o= %d&quot;, mcp_o, o);
+		ptr = select_buf;
+		if (mcp_o == -1) { /* it's an mcp object */
+			s3dprintf(LOW, &quot;clicked on mcp-object no. %d&quot;, o);
+			event_obj_click(p, o);
 		} else
-			if ((names&gt;1) &amp;&amp; ((mcp_o&gt;=0)&amp;&amp;(mcp_o&lt;p-&gt;n_obj))) { /* it's an usual object */
-				s3dprintf(LOW,&quot;clicked on mcp-object %d, object %d&quot;,mcp_o,o);
-				if (p-&gt;object[mcp_o]!=NULL) { /*  that shouldn't happen anyways ... */
-					obj_debug(get_proc_by_pid(p-&gt;object[mcp_o]-&gt;n_mat),o);
-					event_obj_click(get_proc_by_pid(p-&gt;object[mcp_o]-&gt;n_mat),o);
+			if ((names &gt; 1) &amp;&amp; ((mcp_o &gt;= 0) &amp;&amp; (mcp_o &lt; p-&gt;n_obj))) { /* it's an usual object */
+				s3dprintf(LOW, &quot;clicked on mcp-object %d, object %d&quot;, mcp_o, o);
+				if (p-&gt;object[mcp_o] != NULL) { /*  that shouldn't happen anyways ... */
+					obj_debug(get_proc_by_pid(p-&gt;object[mcp_o]-&gt;n_mat), o);
+					event_obj_click(get_proc_by_pid(p-&gt;object[mcp_o]-&gt;n_mat), o);
 				}
 			}
 	}
 	glMatrixMode(GL_PROJECTION);
 	glPopMatrix();
 	glMatrixMode(GL_MODELVIEW);
-	select_mode=0;
+	select_mode = 0;
 	return(0);
 }
 
 
 void graphics_main()
 {
-	struct t_process *p=get_proc_by_pid(MCP);
+	struct t_process *p = get_proc_by_pid(MCP);
 	t_mtrx m;
-	GLfloat pos[]={0,50,50,1.0};
-	GLfloat light0_spec[]={0.7,0.7,0.7,0.0};
-	GLfloat light0_shininess[] ={1.0};
-	GLfloat light0_diff[]={0.5,0.5,0.5,1.0};
-	GLfloat light0_amb[]={1.0,1.0,1.0,1.0};
+	GLfloat pos[] = {0, 50, 50, 1.0};
+	GLfloat light0_spec[] = {0.7, 0.7, 0.7, 0.0};
+	GLfloat light0_shininess[] = {1.0};
+	GLfloat light0_diff[] = {0.5, 0.5, 0.5, 1.0};
+	GLfloat light0_amb[] = {1.0, 1.0, 1.0, 1.0};
 
-	select_mode=0;
+	select_mode = 0;
 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  /*  clear screen */
 	/*  set up the cam ... */
 	glMatrixMode(GL_MODELVIEW);
 
-	glLightfv(GL_LIGHT0,GL_AMBIENT,light0_amb);
-	glLightfv(GL_LIGHT0,GL_DIFFUSE,light0_diff);
-	glLightfv(GL_LIGHT0,GL_SPECULAR,light0_spec);
-	glLightfv(GL_LIGHT0,GL_SHININESS,light0_shininess);
+	glLightfv(GL_LIGHT0, GL_AMBIENT, light0_amb);
+	glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diff);
+	glLightfv(GL_LIGHT0, GL_SPECULAR, light0_spec);
+	glLightfv(GL_LIGHT0, GL_SHININESS, light0_shininess);
 
 	glLoadIdentity();
 
@@ -357,7 +357,7 @@
 	myInvert();
 	myGetMatrix(m);
 	glMultMatrixf(m);
-	glLightfv(GL_LIGHT0,GL_POSITION,pos);
+	glLightfv(GL_LIGHT0, GL_POSITION, pos);
 
 	/*glRotatef(-cam.rotate.z, 0.0,0.0,1.0);
 	glRotatef(-cam.rotate.x, 1.0,0.0,0.0);

Modified: trunk/server/graphics_glut.c
===================================================================
--- trunk/server/graphics_glut.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/graphics_glut.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,24 +26,24 @@
 /*  maybe we are able to choose if we want to use glut or sdl or any other lib later ... */
 
 #include &quot;global.h&quot;
-#include &lt;stdio.h&gt;		/* NULL */
-#include &lt;GL/glut.h&gt; 	 /*  all the glut functions */
-#include &lt;GL/gl.h&gt;		 /*  of course, the gl header */
-#include &lt;stdlib.h&gt;		/* atexit() */
+#include &lt;stdio.h&gt;  /* NULL */
+#include &lt;GL/glut.h&gt;   /*  all the glut functions */
+#include &lt;GL/gl.h&gt;   /*  of course, the gl header */
+#include &lt;stdlib.h&gt;  /* atexit() */
 /*  glut version of graphics init ... */
 int graphics_init_glut()
 {
 	/* XXX: Faking argc and argv is probably not a good idea. */
-	int argc=1;
-	char *argv[]={&quot;s3d&quot;, NULL};
-	s3dprintf(MED,&quot;Using GLUT for GL/windowing ...&quot;);
+	int argc = 1;
+	char *argv[] = {&quot;s3d&quot;, NULL};
+	s3dprintf(MED, &quot;Using GLUT for GL/windowing ...&quot;);
 	glutInit(&amp;argc, argv);
 	glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH | GLUT_RGBA);
-	glutInitWindowSize (X_RES, Y_RES);
+	glutInitWindowSize(X_RES, Y_RES);
 	glutCreateWindow(&quot;grmbl&quot;);
 	glutIdleFunc(one_time);
-	if (0!=(atexit(quit)))
-		s3dprintf(MED,&quot;Error in setting Exit function ...&quot;);
+	if (0 != (atexit(quit)))
+		s3dprintf(MED, &quot;Error in setting Exit function ...&quot;);
 	glutDisplayFunc(graphics_main);
 	glutReshapeFunc(graphics_reshape);
 	return(0);

Modified: trunk/server/graphics_sdl.c
===================================================================
--- trunk/server/graphics_sdl.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/graphics_sdl.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,63 +22,63 @@
  */
 
 #include &quot;global.h&quot;
-int aa_level=4;
+int aa_level = 4;
 
 #include &lt;SDL_opengl.h&gt;
 #include &lt;SDL.h&gt;
 
-int SDLFlags = 0;					 /*  some flags for SDL */
+int SDLFlags = 0;      /*  some flags for SDL */
 int graphics_init_sdl()
 {
 	SDL_Surface *GLwin = NULL;
 	SDL_VideoInfo *VideoInfo;
-	int rgb_size[3]; 				 /*  for SDL_GL attributes */
+	int rgb_size[3];      /*  for SDL_GL attributes */
 	int buffers, samples;
-	s3dprintf(MED,&quot;Using SDL driver ...&quot;);
+	s3dprintf(MED, &quot;Using SDL driver ...&quot;);
 
 	SDLFlags = SDL_OPENGL | SDL_GL_DOUBLEBUFFER | SDL_HWPALETTE | SDL_RESIZABLE;
-	if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) &lt; 0)
-		errsf(&quot;SDL_Init()&quot;,SDL_GetError());
-	if ((VideoInfo = (SDL_VideoInfo *)SDL_GetVideoInfo())==NULL)
-		errs(&quot;SDL_GetVIdeoInfo()&quot;,SDL_GetError());
+	if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) &lt; 0)
+		errsf(&quot;SDL_Init()&quot;, SDL_GetError());
+	if ((VideoInfo = (SDL_VideoInfo *)SDL_GetVideoInfo()) == NULL)
+		errs(&quot;SDL_GetVIdeoInfo()&quot;, SDL_GetError());
 	if (VideoInfo -&gt; hw_available) {
-		s3dprintf(LOW,&quot;detected HW_SURFACE&quot;);
+		s3dprintf(LOW, &quot;detected HW_SURFACE&quot;);
 		SDLFlags |= SDL_HWSURFACE;
 	} else {
-		s3dprintf(LOW,&quot;detected SW_SURFACE&quot;);
+		s3dprintf(LOW, &quot;detected SW_SURFACE&quot;);
 		SDLFlags |= SDL_SWSURFACE;
 	}
 	if (VideoInfo -&gt; blit_hw)
 		SDLFlags |= SDL_HWACCEL;
-	/*     if(SDL_WM_ToggleFullScreen(GLwin) == 0)        	SDLerror(&quot;SDL_WM_ToggleFullScreen&quot;); */
+	/*     if(SDL_WM_ToggleFullScreen(GLwin) == 0)         SDLerror(&quot;SDL_WM_ToggleFullScreen&quot;); */
 
 
 	/*  set some opengl-attributes */
-	/*	SDL_GL_SetAttribute( SDL_GL_RED_SIZE, rgb_size[0] );
-		SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, rgb_size[1] );
-		SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, rgb_size[2] );*/
-	/* 	SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5); */
-	/* 	SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 5); */
-	/* 	SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5); */
-	/* 	SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 ); */
-	SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
+	/* SDL_GL_SetAttribute( SDL_GL_RED_SIZE, rgb_size[0] );
+	 SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, rgb_size[1] );
+	 SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, rgb_size[2] );*/
+	/*  SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5); */
+	/*  SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 5); */
+	/*  SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5); */
+	/*  SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 ); */
+	SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
 	do {
-		if (aa_level&gt;0) {
-			if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1 ))			s3dprintf(VHIGH,&quot;error initializing multisampling&quot;);
-			if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, aa_level ))	s3dprintf(VHIGH,&quot;no multisampling available&quot;);
+		if (aa_level &gt; 0) {
+			if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1))   s3dprintf(VHIGH, &quot;error initializing multisampling&quot;);
+			if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, aa_level)) s3dprintf(VHIGH, &quot;no multisampling available&quot;);
 		}
 
 		/*  more opengl-init-stuff */
-		if ((GLwin = SDL_SetVideoMode(X_RES,Y_RES,16,SDLFlags))==NULL) {
-			if (aa_level&gt;0) {
-				s3dprintf(MED,&quot;retry without multisampling&quot;);
-				aa_level=0;
-				SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 0 );
-				SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 0 );
+		if ((GLwin = SDL_SetVideoMode(X_RES, Y_RES, 16, SDLFlags)) == NULL) {
+			if (aa_level &gt; 0) {
+				s3dprintf(MED, &quot;retry without multisampling&quot;);
+				aa_level = 0;
+				SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 0);
+				SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 0);
 			} else
-				errsf(&quot;SDL_SetVideoMode()&quot;,SDL_GetError());
+				errsf(&quot;SDL_SetVideoMode()&quot;, SDL_GetError());
 		}
-	} while (GLwin==0);
+	} while (GLwin == 0);
 	switch (SDL_GetVideoInfo()-&gt;vfmt-&gt;BitsPerPixel) {
 	case 8:
 		rgb_size[0] = 3;
@@ -97,20 +97,20 @@
 		rgb_size[2] = 8;
 		break;
 	}
-	if (aa_level &gt;0) {
-		SDL_GL_GetAttribute( SDL_GL_MULTISAMPLEBUFFERS, &amp;buffers );
-		SDL_GL_GetAttribute( SDL_GL_MULTISAMPLESAMPLES, &amp;samples );
-		s3dprintf(LOW,&quot;Buffers: %d Samples: %d&quot;, buffers, samples);
+	if (aa_level &gt; 0) {
+		SDL_GL_GetAttribute(SDL_GL_MULTISAMPLEBUFFERS, &amp;buffers);
+		SDL_GL_GetAttribute(SDL_GL_MULTISAMPLESAMPLES, &amp;samples);
+		s3dprintf(LOW, &quot;Buffers: %d Samples: %d&quot;, buffers, samples);
 	}
 
 	/*  print some information */
-	s3dprintf(VLOW,&quot;Screen BPP: %d&quot;, SDL_GetVideoSurface()-&gt;format-&gt;BitsPerPixel);
-	s3dprintf(VLOW,&quot;Vendor     : %s&quot;, glGetString( GL_VENDOR ) );
-	s3dprintf(VLOW,&quot;Renderer   : %s&quot;, glGetString( GL_RENDERER ) );
-	s3dprintf(VLOW,&quot;Version    : %s&quot;, glGetString( GL_VERSION ) );
-	s3dprintf(VLOW,&quot;Extensions : %s&quot;, glGetString( GL_EXTENSIONS ) );
+	s3dprintf(VLOW, &quot;Screen BPP: %d&quot;, SDL_GetVideoSurface()-&gt;format-&gt;BitsPerPixel);
+	s3dprintf(VLOW, &quot;Vendor     : %s&quot;, glGetString(GL_VENDOR));
+	s3dprintf(VLOW, &quot;Renderer   : %s&quot;, glGetString(GL_RENDERER));
+	s3dprintf(VLOW, &quot;Version    : %s&quot;, glGetString(GL_VERSION));
+	s3dprintf(VLOW, &quot;Extensions : %s&quot;, glGetString(GL_EXTENSIONS));
 
-	graphics_reshape(X_RES,Y_RES);
+	graphics_reshape(X_RES, Y_RES);
 	return(0);
 }
 int graphics_quit_sdl()

Modified: trunk/server/main.c
===================================================================
--- trunk/server/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,94 +22,94 @@
  */
 
 
-#include &quot;global.h&quot; 		 /*  contains the prototypes of all modules */
-#include &lt;time.h&gt;		 /* nanosleep() */
-#include &lt;stdlib.h&gt;		 /* exit() */
-#include &lt;unistd.h&gt;		 /* sleep(), fork() */
+#include &quot;global.h&quot;    /*  contains the prototypes of all modules */
+#include &lt;time.h&gt;   /* nanosleep() */
+#include &lt;stdlib.h&gt;   /* exit() */
+#include &lt;unistd.h&gt;   /* sleep(), fork() */
 #ifdef G_GLUT
-#include &lt;GL/glut.h&gt; 	 /*  glutMainLoop() */
+#include &lt;GL/glut.h&gt;   /*  glutMainLoop() */
 #endif
-#define		X_RES	800
-#define		Y_RES	600
-#include &lt;getopt.h&gt;		 /*  getopt() */
-#include &lt;string.h&gt;		 /*  strcmp() */
+#define  X_RES 800
+#define  Y_RES 600
+#include &lt;getopt.h&gt;   /*  getopt() */
+#include &lt;string.h&gt;   /*  strcmp() */
 #ifdef SIGS
-#include &lt;signal.h&gt;		 /*  signal() */
+#include &lt;signal.h&gt;   /*  signal() */
 #endif
-#include &lt;errno.h&gt;		 /*  errno() */
-int frame_mode=0;
-int kidpid=0;
-int norc=0;
+#include &lt;errno.h&gt;   /*  errno() */
+int frame_mode = 0;
+int kidpid = 0;
+int norc = 0;
 int running;
-static char *rc=NULL;
-static char *homerc=&quot;~/.s3drc&quot;;
-static char *etcrc =&quot;/etc/s3drc&quot;;
+static char *rc = NULL;
+static char *homerc = &quot;~/.s3drc&quot;;
+static char *etcrc = &quot;/etc/s3drc&quot;;
 /*static int father_done=0;*/
 extern int aa_level;
-char **s3drc[]={&amp;rc,&amp;homerc,&amp;etcrc};
+char **s3drc[] = {&amp;rc, &amp;homerc, &amp;etcrc};
 
 static void mainloop(void);
 #ifdef SIGS
 /*  handles the SIGINT command. maybe put signals in a special file? */
 void sigint_handler(int S3DUNUSED(sig))
 {
-	s3dprintf(HIGH,&quot;oh my gosh there is a sigint/term signal! running away ...&quot;);
+	s3dprintf(HIGH, &quot;oh my gosh there is a sigint/term signal! running away ...&quot;);
 	quit();
 }
 void sigchld_handler(int S3DUNUSED(sig))
 {
-	if (kidpid!=0) {
-		kidpid=0;
-		s3dprintf(HIGH,&quot;how cruel, my kid died!!&quot;);
+	if (kidpid != 0) {
+		kidpid = 0;
+		s3dprintf(HIGH, &quot;how cruel, my kid died!!&quot;);
 		quit();
 	}
 }
 #endif
 void sigusr_handler(int S3DUNUSED(sig))
 {
-	s3dprintf(HIGH,&quot;father told use he's done, so lets start to think about the rc file ...&quot;);
-	running=1;
+	s3dprintf(HIGH, &quot;father told use he's done, so lets start to think about the rc file ...&quot;);
+	running = 1;
 }
 
 int rc_init(void)
 {
 #ifdef SIGS
-	int ret,i;
-	struct timespec t= {
-		0,10*1000*1000
+	int ret, i;
+	struct timespec t = {
+		0, 10*1000*1000
 	}; /* 10 mili seconds */
-	kidpid=fork();
-	if (kidpid==-1) {
-		errsf(&quot;rc_init()&quot;,&quot;*sobsob*, can't fork&quot;);
+	kidpid = fork();
+	if (kidpid == -1) {
+		errsf(&quot;rc_init()&quot;, &quot;*sobsob*, can't fork&quot;);
 		exit(1);
 	}
-	if (kidpid==0) {
+	if (kidpid == 0) {
 		if (signal(SIGUSR1, sigusr_handler) == SIG_ERR)
-			errn(&quot;init():signal()&quot;,errno);
+			errn(&quot;init():signal()&quot;, errno);
 
 		/* giving the father lots of time to set his signal handler
 		 * and all his sockets up */
 		while (!running)
-			nanosleep(&amp;t,NULL);
-		for (i=0 ; i &lt; ((int)(sizeof(s3drc)/sizeof(char **))) ; i++) {
-			if ((*s3drc[i])!=NULL) {
-				s3dprintf(LOW,&quot;[RC] launching %s&quot;,*s3drc[i]);
-				ret=system(*s3drc[i]);
-				s3dprintf(VLOW,&quot;[RC] system() said %d&quot;,ret);
-				if (ret&lt;128) {
-					s3dprintf(LOW,&quot;V[RC] system() did well, I guess. let's die clean now.&quot;);
+			nanosleep(&amp;t, NULL);
+		for (i = 0 ; i &lt; ((int)(sizeof(s3drc) / sizeof(char **))) ; i++) {
+			if ((*s3drc[i]) != NULL) {
+				s3dprintf(LOW, &quot;[RC] launching %s&quot;, *s3drc[i]);
+				ret = system(*s3drc[i]);
+				s3dprintf(VLOW, &quot;[RC] system() said %d&quot;, ret);
+				if (ret &lt; 128) {
+					s3dprintf(LOW, &quot;V[RC] system() did well, I guess. let's die clean now.&quot;);
 					exit(0);
 				}
 			}
 		}
 		errs(&quot;rc_init()&quot;, &quot;no usuable rc script found.&quot;);
-		if (rc==NULL) {
-			errs(&quot;rc_init()&quot;,&quot;You don't have an rc-script? Think about creating one (~/.s3drc), its handy :)&quot;);
-			errs(&quot;rc_init()&quot;,&quot;Starting anyway ...&quot;);
+		if (rc == NULL) {
+			errs(&quot;rc_init()&quot;, &quot;You don't have an rc-script? Think about creating one (~/.s3drc), its handy :)&quot;);
+			errs(&quot;rc_init()&quot;, &quot;Starting anyway ...&quot;);
 			while (1) sleep(1);
 		} else {
-			errs(&quot;rc_init()&quot;,&quot;no usuable rc script found.&quot;);
-			errs(&quot;rc_init()&quot;,&quot;Check your rc-script!&quot;);
+			errs(&quot;rc_init()&quot;, &quot;no usuable rc script found.&quot;);
+			errs(&quot;rc_init()&quot;, &quot;Check your rc-script!&quot;);
 		}
 		exit(1);
 	} else {
@@ -131,12 +131,12 @@
 /*  things which should be done each time in main loop go here! this is */
 /*  just for the case we use a function for the mainloop like we do for glut... */
 
-struct timespec t= {
-	0,10*1000*1000
+struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 void one_time()
 {
-	nanosleep(&amp;t,NULL);
+	nanosleep(&amp;t, NULL);
 	user_main();
 	network_main();
 	graphics_main();
@@ -144,39 +144,39 @@
 /*  this initalizes all components.  */
 int init()
 {
-#ifdef	__APPLE__
+#ifdef __APPLE__
 	NSApplicationLoad();
 #endif
 #ifdef SIGS
 	if (!norc)
 		rc_init();
 #else
-	s3dprintf(VHIGH,&quot;rc-files won't work without signals :(&quot;);
+	s3dprintf(VHIGH, &quot;rc-files won't work without signals :(&quot;);
 #endif
 	if (!frame_mode) { /*  turn default frame_mode on */
 #ifdef G_SDL
-		frame_mode=FRAME_SDL;
+		frame_mode = FRAME_SDL;
 #else
 #ifdef G_GLUT
-		frame_mode=FRAME_GLUT;
+		frame_mode = FRAME_GLUT;
 #endif
 #endif
 	}
 	if (!frame_mode) {
-		errsf(&quot;init()&quot;,&quot;no framework mode available&quot;);
+		errsf(&quot;init()&quot;, &quot;no framework mode available&quot;);
 		return(-1);
 	}
 	graphics_init();
 	network_init();
 	user_init();
 	process_init();
-	running=1;
+	running = 1;
 #ifdef SIGS
 	if (signal(SIGINT, sigint_handler) == SIG_ERR)
-		errn(&quot;init():signal()&quot;,errno);
+		errn(&quot;init():signal()&quot;, errno);
 	if (signal(SIGTERM, sigint_handler) == SIG_ERR)
-		errn(&quot;init():signal()&quot;,errno);
-	if (kidpid!=0)
+		errn(&quot;init():signal()&quot;, errno);
+	if (kidpid != 0)
 		kill(kidpid, SIGUSR1);
 #endif
 	return(0);
@@ -185,79 +185,79 @@
 /*  things to be cleaned up  */
 void quit()
 {
-	if (running!=0) {
+	if (running != 0) {
 		user_quit();
 		network_quit();
 		graphics_quit();
 		process_quit();
-		if (kidpid!=0) { /* our kid is most probably still alive. kill it!! */
-			s3dprintf(HIGH,&quot;kill all the kids!!&quot;);
-			kill(kidpid,SIGTERM);
-			kidpid=0;
+		if (kidpid != 0) { /* our kid is most probably still alive. kill it!! */
+			s3dprintf(HIGH, &quot;kill all the kids!!&quot;);
+			kill(kidpid, SIGTERM);
+			kidpid = 0;
 		}
 	}
-	running=0;
-	s3dprintf(VHIGH,&quot;byebye, s3d quitting ...&quot;);
+	running = 0;
+	s3dprintf(VHIGH, &quot;byebye, s3d quitting ...&quot;);
 	exit(0);
 }
 /*  processing arguments from the commandline */
 int process_args(int argc, char **argv)
 {
-	int					 lopt_idx;
-	char				 c;
+	int      lopt_idx;
+	char     c;
 	struct option long_options[] = {
-		{&quot;multisample&quot;,		1,0,'m'
-		}, {&quot;rc&quot;,				1,0,'r'}, {&quot;help&quot;,			0,0,'h'}, {&quot;use-glut&quot;,		0,0,'g'}, {&quot;use-sdl&quot;,			0,0,'s'}, {&quot;no-rc&quot;,			0,0,'n'}, {0,0,0,0}
+		{&quot;multisample&quot;,  1, 0, 'm'
+		}, {&quot;rc&quot;,    1, 0, 'r'}, {&quot;help&quot;,   0, 0, 'h'}, {&quot;use-glut&quot;,  0, 0, 'g'}, {&quot;use-sdl&quot;,   0, 0, 's'}, {&quot;no-rc&quot;,   0, 0, 'n'}, {0, 0, 0, 0}
 	};
-	while (-1!=(c=getopt_long(argc,argv,&quot;?hgsnr:m:&quot;,long_options,&amp;lopt_idx))) {
+	while (-1 != (c = getopt_long(argc, argv, &quot;?hgsnr:m:&quot;, long_options, &amp;lopt_idx))) {
 		switch (c) {
 		case 0:
 			break;
 		case 'g':
 #ifdef G_GLUT
-			frame_mode=FRAME_GLUT;
+			frame_mode = FRAME_GLUT;
 #else
-			errsf(&quot;process_args()&quot;,&quot;sorry, GLUT is not available&quot;);
+			errsf(&quot;process_args()&quot;, &quot;sorry, GLUT is not available&quot;);
 #endif
 			break;
 		case 's':
 #ifdef G_SDL
-			frame_mode=FRAME_SDL;
+			frame_mode = FRAME_SDL;
 #else
-			errsf(&quot;process_args()&quot;,&quot;sorry, SDL is not available&quot;);
+			errsf(&quot;process_args()&quot;, &quot;sorry, SDL is not available&quot;);
 #endif
 			break;
 		case 'r':
-			s3dprintf(VHIGH,&quot;using rc file: %s&quot;,optarg);
-			rc=optarg;
+			s3dprintf(VHIGH, &quot;using rc file: %s&quot;, optarg);
+			rc = optarg;
 			break;
 		case 'm':
-			aa_level=atoi(optarg);
-			if (aa_level&gt;=0 || aa_level&lt;=16)
-				s3dprintf(VHIGH,&quot;aa_level: %d&quot;,aa_level);
+			aa_level = atoi(optarg);
+			if (aa_level &gt;= 0 || aa_level &lt;= 16)
+				s3dprintf(VHIGH, &quot;aa_level: %d&quot;, aa_level);
 			else
-				errsf(&quot;process_args()&quot;,&quot;bad multisampling level&quot;);
+				errsf(&quot;process_args()&quot;, &quot;bad multisampling level&quot;);
 			break;
 		case 'n':
-			s3dprintf(VHIGH,&quot;Using no rc file!&quot;);
-			norc=1;
+			s3dprintf(VHIGH, &quot;Using no rc file!&quot;);
+			norc = 1;
 			break;
 
 		case '?':
 		case 'h':
-			s3dprintf(VHIGH,&quot;usage: %s [options]&quot;,argv[0]);
-			s3dprintf(VHIGH,&quot;s3d, the 3d server:&quot;);
-			s3dprintf(VHIGH,&quot; --multisample, -m:\tSpecify Multisampling level (antialiasing) if available.\n\t\t(value 1-16, default 4, 0 = off),&quot;);
-			s3dprintf(VHIGH,&quot; --rc, -r:\tspecify a rc (startup script)&quot;);
-			s3dprintf(VHIGH,&quot; --no-rc, -n:\tdon't use a rc file (useful for debugging mcp's)&quot;);
+			s3dprintf(VHIGH, &quot;usage: %s [options]&quot;, argv[0]);
+			s3dprintf(VHIGH, &quot;s3d, the 3d server:&quot;);
+			s3dprintf(VHIGH, &quot; --multisample, -m:\tSpecify Multisampling level (antialiasing) if available.\n\t\t(value 1-16, default 4, 0 = off),&quot;);
+			s3dprintf(VHIGH, &quot; --rc, -r:\tspecify a rc (startup script)&quot;);
+			s3dprintf(VHIGH, &quot; --no-rc, -n:\tdon't use a rc file (useful for debugging mcp's)&quot;);
 #ifdef G_GLUT
-			s3dprintf(VHIGH,&quot; --use-glut, -g:\tuse GLUT as framework-system&quot;);
+			s3dprintf(VHIGH, &quot; --use-glut, -g:\tuse GLUT as framework-system&quot;);
 #endif
 #ifdef G_SDL
-			s3dprintf(VHIGH,&quot; --use-sdl, -s:\tuse SDL as framework-system&quot;);
+			s3dprintf(VHIGH, &quot; --use-sdl, -s:\tuse SDL as framework-system&quot;);
 #endif
-			s3dprintf(VHIGH,&quot; --help, -?, -h: this helpful text&quot;);
-			errsf(&quot;process_args()&quot;,&quot;exiting for users sake&quot;);
+			s3dprintf(VHIGH, &quot; --help, -?, -h: this helpful text&quot;);
+			errsf(&quot;process_args()&quot;, &quot;exiting for users sake&quot;);
 			return(-1);
 		}
 	}
@@ -266,7 +266,7 @@
 /*  things to be done when program is started */
 int main(int argc, char **argv)
 {
-	process_args(argc,argv);
+	process_args(argc, argv);
 	init();
 	switch (frame_mode) {
 #ifdef G_GLUT

Modified: trunk/server/matrix.c
===================================================================
--- trunk/server/matrix.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/matrix.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,7 +24,7 @@
 /*  this file gives some simple matrix functionality for things I was unable */
 /*  to do with OpenGL */
 #include &quot;global.h&quot;
-#include &lt;string.h&gt;	 /*  memcpy() */
+#include &lt;string.h&gt;  /*  memcpy() */
 
 #define DEG2RAD (M_PI/180.0)
 static t_mtrx MAT;
@@ -36,127 +36,127 @@
 };
 void myLoadIdentity()
 {
-	memcpy(MAT,Identity,sizeof(t_mtrx));
+	memcpy(MAT, Identity, sizeof(t_mtrx));
 }
-#define I(x, y)		x*4+y
-#define M(x, y)		MAT[I(x, y)]
+#define I(x, y)  x*4+y
+#define M(x, y)  MAT[I(x, y)]
 void mat_debug(t_mtrx S)
 {
-	s3dprintf(MED,&quot;MAT_0: %.2f %.2f %.2f %.2f&quot;,S[I(0,0)],S[I(1,0)],S[I(2,0)],S[I(3,0)]);
-	s3dprintf(MED,&quot;MAT_1: %.2f %.2f %.2f %.2f&quot;,S[I(0,1)],S[I(1,1)],S[I(2,1)],S[I(3,1)]);
-	s3dprintf(MED,&quot;MAT_2: %.2f %.2f %.2f %.2f&quot;,S[I(0,2)],S[I(1,2)],S[I(2,2)],S[I(3,2)]);
-	s3dprintf(MED,&quot;MAT_3: %.2f %.2f %.2f %.2f&quot;,S[I(0,3)],S[I(1,3)],S[I(2,3)],S[I(3,3)]);
+	s3dprintf(MED, &quot;MAT_0: %.2f %.2f %.2f %.2f&quot;, S[I(0,0)], S[I(1,0)], S[I(2,0)], S[I(3,0)]);
+	s3dprintf(MED, &quot;MAT_1: %.2f %.2f %.2f %.2f&quot;, S[I(0,1)], S[I(1,1)], S[I(2,1)], S[I(3,1)]);
+	s3dprintf(MED, &quot;MAT_2: %.2f %.2f %.2f %.2f&quot;, S[I(0,2)], S[I(1,2)], S[I(2,2)], S[I(3,2)]);
+	s3dprintf(MED, &quot;MAT_3: %.2f %.2f %.2f %.2f&quot;, S[I(0,3)], S[I(1,3)], S[I(2,3)], S[I(3,3)]);
 }
 void myMultMatrix(t_mtrx mat2)
 {
-	int i,j,k;
+	int i, j, k;
 	t_mtrx mat_d;  /*  destination matrix */
-	for (i=0;i&lt;4;i++)
-		for (j=0;j&lt;4;j++) {
-			mat_d[I(i,j)]=0.0F;
-			for (k=0;k&lt;4;k++)
-				mat_d[I(i,j)]+=M(k,j)*mat2[I(i,k)];
+	for (i = 0;i &lt; 4;i++)
+		for (j = 0;j &lt; 4;j++) {
+			mat_d[I(i,j)] = 0.0F;
+			for (k = 0;k &lt; 4;k++)
+				mat_d[I(i,j)] += M(k, j) * mat2[I(i,k)];
 		}
-	memcpy(MAT,mat_d,sizeof(t_mtrx));
+	memcpy(MAT, mat_d, sizeof(t_mtrx));
 }
 void myGetMatrix(t_mtrx mat)
 {
-	memcpy(mat,MAT,sizeof(t_mtrx));
+	memcpy(mat, MAT, sizeof(t_mtrx));
 }
 void mySetMatrix(t_mtrx mat)
 {
-	memcpy(MAT,mat,sizeof(t_mtrx));
+	memcpy(MAT, mat, sizeof(t_mtrx));
 }
 void myTransform4f(float *v)
 {
 	float w[4];
-	w[0]= v[0]*M(0,0) + v[1]*M(1,0) + v[2]*M(2,0) + v[3]*M(3,0);
-	w[1]= v[0]*M(0,1) + v[1]*M(1,1) + v[2]*M(2,1) + v[3]*M(3,1);
-	w[2]= v[0]*M(0,2) + v[1]*M(1,2) + v[2]*M(2,2) + v[3]*M(3,2);
-	w[3]= v[0]*M(0,3) + v[1]*M(1,3) + v[2]*M(2,3) + v[3]*M(3,3);
-	memcpy(v,w,sizeof(w));
+	w[0] = v[0] * M(0, 0) + v[1] * M(1, 0) + v[2] * M(2, 0) + v[3] * M(3, 0);
+	w[1] = v[0] * M(0, 1) + v[1] * M(1, 1) + v[2] * M(2, 1) + v[3] * M(3, 1);
+	w[2] = v[0] * M(0, 2) + v[1] * M(1, 2) + v[2] * M(2, 2) + v[3] * M(3, 2);
+	w[3] = v[0] * M(0, 3) + v[1] * M(1, 3) + v[2] * M(2, 3) + v[3] * M(3, 3);
+	memcpy(v, w, sizeof(w));
 }
 void myTransform3f(float *v)
 {
 	float w[3];
-	w[0]= v[0]*M(0,0) + v[1]*M(1,0) + v[2]*M(2,0) + 1.0F*M(3,0);
-	w[1]= v[0]*M(0,1) + v[1]*M(1,1) + v[2]*M(2,1) + 1.0F*M(3,1);
-	w[2]= v[0]*M(0,2) + v[1]*M(1,2) + v[2]*M(2,2) + 1.0F*M(3,2);
-	memcpy(v,w,sizeof(w));
+	w[0] = v[0] * M(0, 0) + v[1] * M(1, 0) + v[2] * M(2, 0) + 1.0F * M(3, 0);
+	w[1] = v[0] * M(0, 1) + v[1] * M(1, 1) + v[2] * M(2, 1) + 1.0F * M(3, 1);
+	w[2] = v[0] * M(0, 2) + v[1] * M(1, 2) + v[2] * M(2, 2) + 1.0F * M(3, 2);
+	memcpy(v, w, sizeof(w));
 }
 void myTransformV(struct t_vertex *v)
 {
 	struct t_vertex w;
-	w.x= v-&gt;x*M(0,0) + v-&gt;y*M(1,0) + v-&gt;z*M(2,0) + 1.0F*M(3,0);
-	w.y= v-&gt;x*M(0,1) + v-&gt;y*M(1,1) + v-&gt;z*M(2,1) + 1.0F*M(3,1);
-	w.z= v-&gt;x*M(0,2) + v-&gt;y*M(1,2) + v-&gt;z*M(2,2) + 1.0F*M(3,2);
-	memcpy(v,&amp;w,sizeof(struct t_vertex));
+	w.x = v-&gt;x * M(0, 0) + v-&gt;y * M(1, 0) + v-&gt;z * M(2, 0) + 1.0F * M(3, 0);
+	w.y = v-&gt;x * M(0, 1) + v-&gt;y * M(1, 1) + v-&gt;z * M(2, 1) + 1.0F * M(3, 1);
+	w.z = v-&gt;x * M(0, 2) + v-&gt;y * M(1, 2) + v-&gt;z * M(2, 2) + 1.0F * M(3, 2);
+	memcpy(v, &amp;w, sizeof(struct t_vertex));
 }
 
 #undef M
-#define M(x, y)		Mm[I(x, y)]
-#define P(x, y)		Pm[I(x, y)]
+#define M(x, y)  Mm[I(x, y)]
+#define P(x, y)  Pm[I(x, y)]
 /* this inverts the matrix M into P in the gauss way */
 int myInvert()
 {
-	t_mtrx Mm,Pm;
-	int l,lh; /* line*/
+	t_mtrx Mm, Pm;
+	int l, lh; /* line*/
 	float f; /* factor */
 	int i; /* number */
-	memcpy(Mm,MAT,sizeof(t_mtrx));			/* backup matrix */
-	memcpy(Pm,Identity,sizeof(t_mtrx));		/* target */
+	memcpy(Mm, MAT, sizeof(t_mtrx)); /* backup matrix */
+	memcpy(Pm, Identity, sizeof(t_mtrx));  /* target */
 
-	/*	s3dprintf(MED,&quot;start:&quot;);
-		mat_debug(MAT);*/
+	/* s3dprintf(MED,&quot;start:&quot;);
+	 mat_debug(MAT);*/
 
-	/*	s3dprintf(LOW,&quot;inverting matrix, we shall begin now ...&quot;);*/
+	/* s3dprintf(LOW,&quot;inverting matrix, we shall begin now ...&quot;);*/
 
 	/* step 1 */
-	for (l=0;l&lt;4;l++) {
+	for (l = 0;l &lt; 4;l++) {
 check:
-		if (M(l,l)*M(l,l)&gt;0.00000001F) { /* it won't work with real zero */
+		if (M(l, l)*M(l, l) &gt; 0.00000001F) { /* it won't work with real zero */
 
-			/*			s3dprintf(MED,&quot;normalizing line %d&quot;,l);*/
+			/*   s3dprintf(MED,&quot;normalizing line %d&quot;,l);*/
 			/* normalize */
-			f=1/M(l,l);
-			M(l,l)=1.0;
-			for (i=l+1;i&lt;4;i++)
-				M(i,l)*=f; /* the left side ... */
-			for (i=0;i&lt;4;i++)
-				P(i,l)*=f; /* ... and the right */
-			/*			mat_debug(Mm);
-						s3dprintf(MED,&quot;-&quot;);
-						mat_debug(Pm);*/
+			f = 1 / M(l, l);
+			M(l, l) = 1.0;
+			for (i = l + 1;i &lt; 4;i++)
+				M(i, l) *= f; /* the left side ... */
+			for (i = 0;i &lt; 4;i++)
+				P(i, l) *= f; /* ... and the right */
+			/*   mat_debug(Mm);
+			   s3dprintf(MED,&quot;-&quot;);
+			   mat_debug(Pm);*/
 			/* mult/fac */
-			for (lh=l+1;lh&lt;4;lh++) {
-				/*	s3dprintf(MED,&quot;adding line %d for %d&quot;,lh,l);*/
-				if (M(l,lh)!=0) { /* &quot;first&quot; element of the line */
-					f=-M(l,lh);
-					M(l,lh)=0.0; /* yes, this WILL be zero! ... */
-					for (i=l+1;i&lt;4;i++) /* left side */
-						M(i,lh)+=f*M(i,l);
-					for (i=0;i&lt;4;i++)	/* ... and the right one! */
-						P(i,lh)+=f*P(i,l);
+			for (lh = l + 1;lh &lt; 4;lh++) {
+				/* s3dprintf(MED,&quot;adding line %d for %d&quot;,lh,l);*/
+				if (M(l, lh) != 0) { /* &quot;first&quot; element of the line */
+					f = -M(l, lh);
+					M(l, lh) = 0.0; /* yes, this WILL be zero! ... */
+					for (i = l + 1;i &lt; 4;i++) /* left side */
+						M(i, lh) += f * M(i, l);
+					for (i = 0;i &lt; 4;i++) /* ... and the right one! */
+						P(i, lh) += f * P(i, l);
 				} /*else s3dprintf(MED,&quot;element already zero!&quot;);*/
 			}
 		} else {
-			M(l,l)=0.0F;
-			/*			s3dprintf(MED,&quot;already zero now check and try to swap lines ...&quot;);*/
-			for (lh=l+1;lh&lt;4;lh++)
-				if (M(l,lh)!=0.0) {
-					/*					s3dprintf(MED,&quot;swapping lines %d and %d&quot;,l,lh);*/
-					for (i=0;i&lt;4;i++) {
-						f=M(i,l);
-						M(i,l)=M(i,lh);
-						M(i,lh)=f;
-						f=P(i,l);
-						P(i,l)=P(i,lh);
-						P(i,lh)=f;
+			M(l, l) = 0.0F;
+			/*   s3dprintf(MED,&quot;already zero now check and try to swap lines ...&quot;);*/
+			for (lh = l + 1;lh &lt; 4;lh++)
+				if (M(l, lh) != 0.0) {
+					/*     s3dprintf(MED,&quot;swapping lines %d and %d&quot;,l,lh);*/
+					for (i = 0;i &lt; 4;i++) {
+						f = M(i, l);
+						M(i, l) = M(i, lh);
+						M(i, lh) = f;
+						f = P(i, l);
+						P(i, l) = P(i, lh);
+						P(i, lh) = f;
 
 					}
 					goto check;
 				}
-			s3dprintf(MED,&quot;nothing to swap, can't reverse this matrix! returning ... &quot;);
+			s3dprintf(MED, &quot;nothing to swap, can't reverse this matrix! returning ... &quot;);
 			mat_debug(Mm);
 			return(-1); /* the dead end!! */
 		}
@@ -171,27 +171,27 @@
 	 * */
 
 	/* step 2 */
-	/*	s3dprintf(MED,&quot;S.T.E.P. 2!!&quot;);*/
-	for (l=3;l&gt;0;l--) {
+	/* s3dprintf(MED,&quot;S.T.E.P. 2!!&quot;);*/
+	for (l = 3;l &gt; 0;l--) {
 		/* mult/fac */
-		for (lh=l-1;lh&gt;=0;lh--) {
-			/*			s3dprintf(MED,&quot;adding line %d for %d&quot;,lh,l);*/
-			if (M(l,lh)!=0) { /* &quot;first&quot; element of the line */
-				f=-M(l,lh);
-				M(l,lh)=0;
-				for (i=0;i&lt;4;i++) {	/* ... and the right one! */
-					P(i,lh)+=f*P(i,l);
+		for (lh = l - 1;lh &gt;= 0;lh--) {
+			/*   s3dprintf(MED,&quot;adding line %d for %d&quot;,lh,l);*/
+			if (M(l, lh) != 0) { /* &quot;first&quot; element of the line */
+				f = -M(l, lh);
+				M(l, lh) = 0;
+				for (i = 0;i &lt; 4;i++) { /* ... and the right one! */
+					P(i, lh) += f * P(i, l);
 				}
 
 			}
-			/*			mat_debug(Mm);
-						mat_debug(Pm);*/
+			/*   mat_debug(Mm);
+			   mat_debug(Pm);*/
 		}
 	}
 	/* now, Mm,is Identity and Pm is result!*/
-	/*	s3dprintf(MED,&quot;result:&quot;);
-		mat_debug(Pm);*/
-	memcpy(MAT,Pm,sizeof(t_mtrx)); /* copy result */
+	/* s3dprintf(MED,&quot;result:&quot;);
+	 mat_debug(Pm);*/
+	memcpy(MAT, Pm, sizeof(t_mtrx)); /* copy result */
 	return(0);
 }
 

Modified: trunk/server/mcp.c
===================================================================
--- trunk/server/mcp.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/mcp.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,41 +23,41 @@
 
 
 #include &quot;global.h&quot;
-#include &quot;proto.h&quot; 			 /*  for S3D_P_OBJECT, to be integrated in proto.c */
+#include &quot;proto.h&quot;     /*  for S3D_P_OBJECT, to be integrated in proto.c */
 #ifdef WIN32
 #include &lt;winsock2.h&gt;
 #else
-#include &lt;netinet/in.h&gt; 	 /*  htonl() */
+#include &lt;netinet/in.h&gt;   /*  htonl() */
 #endif
-#include &lt;string.h&gt;			 /*  strncpy() */
+#include &lt;string.h&gt;    /*  strncpy() */
 
 
-extern int 		   focus_oid;		 /*  the focused program */
+extern int      focus_oid;   /*  the focused program */
 
 /*  this interacts with the actual mcp client */
 struct mcp_object {
 	uint32_t object;
-	float trans_x,trans_y,trans_z;
+	float trans_x, trans_y, trans_z;
 	float r;
-	/* 	char event; */
+	/*  char event; */
 	char name[NAME_MAX];
 };
-#define MCP_NEW_OBJECT	1
+#define MCP_NEW_OBJECT 1
 /*  call when a new mcp connects */
 int mcp_init()
 {
 	struct t_process *p;
 	uint32_t i;
-	p=get_proc_by_pid(MCP);
-	i=p-&gt;n_obj;
+	p = get_proc_by_pid(MCP);
+	i = p-&gt;n_obj;
 	while (i--) {
-		if (p-&gt;object[i]!=NULL)
+		if (p-&gt;object[i] != NULL)
 			switch (p-&gt;object[i]-&gt;oflags&amp;OF_TYPE) {
 			case OF_VIRTUAL:
 				mcp_rep_object(i);
 				break;
 			case OF_CAM:
-				event_obj_info(p,i);
+				event_obj_info(p, i);
 				break;
 			}
 	}
@@ -68,28 +68,28 @@
 int mcp_rep_object(int32_t mcp_oid)
 {
 	struct mcp_object mo;
-	struct t_process *p,*ap;
-	p=get_proc_by_pid(MCP);
-	mo.object=htonl(mcp_oid);
-	mo.trans_x=p-&gt;object[mcp_oid]-&gt;translate.x;
-	mo.trans_y=p-&gt;object[mcp_oid]-&gt;translate.y;
-	mo.trans_z=p-&gt;object[mcp_oid]-&gt;translate.z;
-	mo.r=p-&gt;object[mcp_oid]-&gt;r;
-	/* 	mo.event=MCP_NEW_OBJECT; */
-	ap=get_proc_by_pid(p-&gt;object[mcp_oid]-&gt;n_mat);
-	strncpy(mo.name,ap-&gt;name,NAME_MAX);
-	prot_com_out(p,S3D_P_MCP_OBJECT,(uint8_t *)&amp;mo,sizeof(struct mcp_object));
+	struct t_process *p, *ap;
+	p = get_proc_by_pid(MCP);
+	mo.object = htonl(mcp_oid);
+	mo.trans_x = p-&gt;object[mcp_oid]-&gt;translate.x;
+	mo.trans_y = p-&gt;object[mcp_oid]-&gt;translate.y;
+	mo.trans_z = p-&gt;object[mcp_oid]-&gt;translate.z;
+	mo.r = p-&gt;object[mcp_oid]-&gt;r;
+	/*  mo.event=MCP_NEW_OBJECT; */
+	ap = get_proc_by_pid(p-&gt;object[mcp_oid]-&gt;n_mat);
+	strncpy(mo.name, ap-&gt;name, NAME_MAX);
+	prot_com_out(p, S3D_P_MCP_OBJECT, (uint8_t *)&amp;mo, sizeof(struct mcp_object));
 	return(0);
 }
 /* tells the mcp that some program vanished ... */
 int mcp_del_object(int32_t mcp_oid)
 {
-	int32_t oid=htonl(mcp_oid);
-	if (mcp_oid==focus_oid) {
-		s3dprintf(MED,&quot;lost the focus of mcp-oid %d&quot;,mcp_oid);
+	int32_t oid = htonl(mcp_oid);
+	if (mcp_oid == focus_oid) {
+		s3dprintf(MED, &quot;lost the focus of mcp-oid %d&quot;, mcp_oid);
 		mcp_focus(-1);
 	}
-	prot_com_out(get_proc_by_pid(MCP),S3D_P_MCP_DEL_OBJECT,(uint8_t *)&amp;oid,4);
+	prot_com_out(get_proc_by_pid(MCP), S3D_P_MCP_DEL_OBJECT, (uint8_t *)&amp;oid, 4);
 	return(0);
 }
 /* sets a new focus */
@@ -97,13 +97,13 @@
 {
 	struct t_process *p;
 	struct t_obj *o;
-	focus_oid=-1;
-	p=get_proc_by_pid(MCP);
-	s3dprintf(MED,&quot;request to focus %d&quot;,oid);
-	if (OBJ_VALID(p,oid,o))
+	focus_oid = -1;
+	p = get_proc_by_pid(MCP);
+	s3dprintf(MED, &quot;request to focus %d&quot;, oid);
+	if (OBJ_VALID(p, oid, o))
 		if (o-&gt;oflags&amp;OF_VIRTUAL) {
-			focus_oid=oid;
-			obj_pos_update(p,0,0);
+			focus_oid = oid;
+			obj_pos_update(p, 0, 0);
 		}
 	return(0);
 }
@@ -113,6 +113,6 @@
 /* TODO: move things from object.c to this place!
 int mcp_quit(void)
 {
-	return(0);
+ return(0);
 }
 */

Modified: trunk/server/navigation.c
===================================================================
--- trunk/server/navigation.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/navigation.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,97 +24,97 @@
 
 #include &quot;global.h&quot;
 #include &lt;math.h&gt; /* atan() */
-int alphax,alphay;
-float view_x,view_y,view_z;
-extern int winw,winh;
+int alphax, alphay;
+float view_x, view_y, view_z;
+extern int winw, winh;
 void navi_right()
 {
-	navi_pos(1,0);
+	navi_pos(1, 0);
 }
 void navi_left()
 {
-	navi_pos(-1,0);
+	navi_pos(-1, 0);
 }
 void navi_fwd()
 {
-	navi_pos(0,1);
+	navi_pos(0, 1);
 }
 void navi_back()
 {
-	navi_pos(0,-1);
+	navi_pos(0, -1);
 }
 /* simple movements, not needed currently
 void navi_rot_right()
 {
-	cam.rotate.y=cam.rotate.y+2;
-	if (cam.rotate.y&gt;360) cam.rotate.y-=360;
+ cam.rotate.y=cam.rotate.y+2;
+ if (cam.rotate.y&gt;360) cam.rotate.y-=360;
 }
 void navi_rot_left()
 {
-	cam.rotate.y=cam.rotate.y-2;
-	cam.rotate.y=(cam.rotate.y&lt;0)?cam.rotate.y+360:cam.rotate.y;
+ cam.rotate.y=cam.rotate.y-2;
+ cam.rotate.y=(cam.rotate.y&lt;0)?cam.rotate.y+360:cam.rotate.y;
 }
 void navi_rot_up()
 {
-	cam.rotate.x=(cam.rotate.x+2);
-	if (cam.rotate.x&gt;90) cam.rotate.x=90;
+ cam.rotate.x=(cam.rotate.x+2);
+ if (cam.rotate.x&gt;90) cam.rotate.x=90;
 }
 void navi_rot_down()
 {
-	cam.rotate.x=cam.rotate.x-2;
-	if (cam.rotate.x&lt;-90) cam.rotate.x=-90;
+ cam.rotate.x=cam.rotate.x-2;
+ if (cam.rotate.x&lt;-90) cam.rotate.x=-90;
 }*/
 void navi_pos(int xdif, int ydif)
 {
 	float tv[3];
 	struct t_obj *cam;
-	cam=get_proc_by_pid(MCP)-&gt;object[0];
-	tv[0]=cam-&gt;translate.x;
-	tv[1]=cam-&gt;translate.y;
-	tv[2]=cam-&gt;translate.z;
+	cam = get_proc_by_pid(MCP)-&gt;object[0];
+	tv[0] = cam-&gt;translate.x;
+	tv[1] = cam-&gt;translate.y;
+	tv[2] = cam-&gt;translate.z;
 
-	tv[0]+=ydif*sin((-cam-&gt;rotate.y*M_PI)/180);
-	tv[2]-=ydif*cos((-cam-&gt;rotate.y*M_PI)/180);
+	tv[0] += ydif * sin((-cam-&gt;rotate.y * M_PI) / 180);
+	tv[2] -= ydif * cos((-cam-&gt;rotate.y * M_PI) / 180);
 
-	tv[0]-=xdif*cos((-cam-&gt;rotate.y*M_PI)/180);
-	tv[2]-=xdif*sin((-cam-&gt;rotate.y*M_PI)/180);
-	obj_translate(get_proc_by_pid(MCP),0,tv);
+	tv[0] -= xdif * cos((-cam-&gt;rotate.y * M_PI) / 180);
+	tv[2] -= xdif * sin((-cam-&gt;rotate.y * M_PI) / 180);
+	obj_translate(get_proc_by_pid(MCP), 0, tv);
 }
 void navi_rot(int xdif, int ydif)
 {
 	float rv[3];
 	struct t_obj *cam;
-	cam=get_proc_by_pid(MCP)-&gt;object[0];
-	rv[0]=(cam-&gt;rotate.x+ydif);
-	rv[1]=(cam-&gt;rotate.y+xdif);
-	rv[2]=0.0F;
-	if (rv[0]&gt;90) 	rv[0]=90;
-	if (rv[0]&lt;-90) 	rv[0]=-90;
-	if (rv[1]&gt;360) 	rv[1]-=360;
-	if (rv[1]&lt;0) 	rv[1]+=360;
-	obj_rotate(get_proc_by_pid(MCP),0,rv);
+	cam = get_proc_by_pid(MCP)-&gt;object[0];
+	rv[0] = (cam-&gt;rotate.x + ydif);
+	rv[1] = (cam-&gt;rotate.y + xdif);
+	rv[2] = 0.0F;
+	if (rv[0] &gt; 90)  rv[0] = 90;
+	if (rv[0] &lt; -90)  rv[0] = -90;
+	if (rv[1] &gt; 360)  rv[1] -= 360;
+	if (rv[1] &lt; 0)  rv[1] += 360;
+	obj_rotate(get_proc_by_pid(MCP), 0, rv);
 }
 void ptr_move(int x, int y)
 {
-	float tv[3],rv[3],xf,yf;
+	float tv[3], rv[3], xf, yf;
 	struct t_process *p;
 	int ptr;
-	if (winw&gt;winh) {
-		xf=winw/(float)winh;
-		yf=1;
+	if (winw &gt; winh) {
+		xf = winw / (float)winh;
+		yf = 1;
 	} else {
-		xf=1;
-		yf=winh/(float)winw;
+		xf = 1;
+		yf = winh / (float)winw;
 	}
-	tv[0]=(2.0*x/((float)winw)-1.0)*xf;
-	tv[1]=-(2.0*y/((float)winh)-1.0)*yf;
-	tv[2]=-1;
-	rv[0]=1.5*180/M_PI*atan(tv[1]/2); /* TODO: Hm, this is not really correct ... */
-	rv[1]=1.5*180/M_PI*-atan(tv[0]/2);
-	rv[2]=0;
-	p=get_proc_by_pid(MCP);
-	if (-1!=(ptr=get_pointer(p))) {
-		obj_translate(p,ptr,tv);
-		obj_rotate(p,ptr,rv);
+	tv[0] = (2.0 * x / ((float)winw) - 1.0) * xf;
+	tv[1] = -(2.0 * y / ((float)winh) - 1.0) * yf;
+	tv[2] = -1;
+	rv[0] = 1.5 * 180 / M_PI * atan(tv[1] / 2); /* TODO: Hm, this is not really correct ... */
+	rv[1] = 1.5 * 180 / M_PI * -atan(tv[0] / 2);
+	rv[2] = 0;
+	p = get_proc_by_pid(MCP);
+	if (-1 != (ptr = get_pointer(p))) {
+		obj_translate(p, ptr, tv);
+		obj_rotate(p, ptr, rv);
 	}
 }

Modified: trunk/server/network.c
===================================================================
--- trunk/server/network.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/network.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,15 +24,15 @@
 
 #include &quot;global.h&quot;
 #include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;		 /*  free() */
-#include &lt;errno.h&gt;		 /*  errno() */
-#include &lt;unistd.h&gt;		/* close(), read(),write() */
-#include &lt;signal.h&gt;		/* SIGPIPE,SIG_ERR,SIGIO */
+#include &lt;stdlib.h&gt;   /*  free() */
+#include &lt;errno.h&gt;   /*  errno() */
+#include &lt;unistd.h&gt;  /* close(), read(),write() */
+#include &lt;signal.h&gt;  /* SIGPIPE,SIG_ERR,SIGIO */
 #ifdef G_SDL
-#include &lt;SDL.h&gt;	/* SDL_SetTimer() */
+#include &lt;SDL.h&gt; /* SDL_SetTimer() */
 #endif
 #ifdef SIGS
-#include &lt;signal.h&gt;	 /*  sighandler_t SIG_PIPE */
+#include &lt;signal.h&gt;  /*  sighandler_t SIG_PIPE */
 #endif
 /*  here go all the network functions */
 /*  */
@@ -44,25 +44,25 @@
 uint8_t ibuf[MAXPLEN]; /* input buffer for a packet */
 uint8_t obuf[MAXPLEN]; /* output buffer */
 #ifdef SIGS
-int sigio=0;
+int sigio = 0;
 #endif
 
 #ifdef SIGS
 void sigpipe_handler(int S3DUNUSED(unused))
 {
-	errs(&quot;sigpip_handler()&quot;,&quot;there is a broken pipe somewhere&quot;);
+	errs(&quot;sigpip_handler()&quot;, &quot;there is a broken pipe somewhere&quot;);
 }
 
 void sigio_handler(int S3DUNUSED(unused))
 {
-	sigio=1;
+	sigio = 1;
 }
 #endif
 /*  maybe change the errors to fatal errors ... */
 int network_init()
 {
 #ifdef SIGS
-	/*	struct sigaction act;*/
+	/* struct sigaction act;*/
 #endif
 #ifdef TCP
 	tcp_init();
@@ -72,20 +72,20 @@
 #endif
 #ifdef SIGS
 	if (signal(SIGPIPE, sigpipe_handler) == SIG_ERR)
-		errn(&quot;network_init():signal()&quot;,errno);
-	/*	act.sa_handler = (sig_t)sigio_handler;
-		if ( sigaction(SIGIO, &amp;act, 0) &lt; 0 )
-			errn(&quot;network_init():sigaction()&quot;,errno);*/
+		errn(&quot;network_init():signal()&quot;, errno);
+	/* act.sa_handler = (sig_t)sigio_handler;
+	 if ( sigaction(SIGIO, &amp;act, 0) &lt; 0 )
+	  errn(&quot;network_init():sigaction()&quot;,errno);*/
 	if (signal(SIGIO, sigio_handler) == SIG_ERR)
-		errn(&quot;s3d_init():signal()&quot;,errno);
+		errn(&quot;s3d_init():signal()&quot;, errno);
 #endif
 	return(0);
 }
-int					 turn;
-int	net_turn_off(int S3DUNUSED(interval))
+int      turn;
+int net_turn_off(int S3DUNUSED(interval))
 {
-	s3dprintf(VLOW,&quot;Warning: High traffic on Network, interrupting read.&quot;);
-	turn=0;
+	s3dprintf(VLOW, &quot;Warning: High traffic on Network, interrupting read.&quot;);
+	turn = 0;
 	return(0);
 }
 
@@ -94,19 +94,19 @@
 {
 #ifdef TCP
 #ifdef SIGS
-	if (sigio==1) { /*  as long as there is no locking/threadsafety, do like this ... */
+	if (sigio == 1) { /*  as long as there is no locking/threadsafety, do like this ... */
 #endif
-		tcp_pollport();	/*  this polls for new processes */
+		tcp_pollport(); /*  this polls for new processes */
 #ifdef G_SDL
-		SDL_SetTimer(50,(SDL_TimerCallback) net_turn_off);
+		SDL_SetTimer(50, (SDL_TimerCallback) net_turn_off);
 #endif
 		while (turn &amp;&amp; tcp_pollproc());  /*  if there is new data, loop please. this is for testing now, and should be combined with timing later .. */
 #ifdef G_SDL
-		SDL_SetTimer(0,NULL);
+		SDL_SetTimer(0, NULL);
 #endif
 
 #ifdef SIGS
-		sigio=0;
+		sigio = 0;
 	}
 #endif
 #endif
@@ -129,7 +129,7 @@
 		break;
 #endif
 	}
-	p-&gt;con_type=CON_NULL;
+	p-&gt;con_type = CON_NULL;
 	return(-1);
 }
 
@@ -138,11 +138,11 @@
 	switch (p-&gt;con_type) {
 #ifdef TCP
 	case CON_TCP:
-		return(tcp_readn(p-&gt;sockid,str,s));
+		return(tcp_readn(p-&gt;sockid, str, s));
 #endif
 #ifdef SHM
 	case CON_SHM:
-		return(shm_readn((struct buf_t *)p-&gt;shmsock.data_ctos,str,s));
+		return(shm_readn((struct buf_t *)p-&gt;shmsock.data_ctos, str, s));
 #endif
 	}
 	return(-1);
@@ -152,11 +152,11 @@
 	switch (p-&gt;con_type) {
 #ifdef TCP
 	case CON_TCP:
-		return(tcp_writen(p-&gt;sockid,str,s));
+		return(tcp_writen(p-&gt;sockid, str, s));
 #endif
 #ifdef SHM
 	case CON_SHM:
-		return(shm_writen((struct buf_t *)p-&gt;shmsock.data_stoc,str,s));
+		return(shm_writen((struct buf_t *)p-&gt;shmsock.data_stoc, str, s));
 #endif
 	}
 	return(-1);

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/object.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,109 +23,109 @@
 
 
 #include &quot;global.h&quot;
-#include &lt;stdlib.h&gt;		 /*  malloc(),realloc(),free() */
-#include &lt;string.h&gt;		 /*  memcpy() */
-#include &lt;GL/gl.h&gt;		 /*  gl*, GL* */
-#ifndef _ISOC99_SOURCE	/* we want isnan() */
+#include &lt;stdlib.h&gt;   /*  malloc(),realloc(),free() */
+#include &lt;string.h&gt;   /*  memcpy() */
+#include &lt;GL/gl.h&gt;   /*  gl*, GL* */
+#ifndef _ISOC99_SOURCE /* we want isnan() */
 #define _ISOC99_SOURCE
 #endif
-#include &lt;math.h&gt;		 /*  sin(),cos() */
+#include &lt;math.h&gt;   /*  sin(),cos() */
 
-#define MAXLOOP	10
+#define MAXLOOP 10
 /*  if oid is always unsigned, we don't have to check oid&gt;=0 */
 
 extern t_mtrx Identity;
 extern int focus_oid;
 
 
-static void obj_update_tex(struct t_tex *tex,u_int16_t x,u_int16_t y,u_int16_t w,u_int16_t h,u_int8_t *pixbuf);
+static void obj_update_tex(struct t_tex *tex, u_int16_t x, u_int16_t y, u_int16_t w, u_int16_t h, u_int8_t *pixbuf);
 void obj_sys_update(struct t_process *p, int32_t oid);
 
 /*  debugging function for objects, prints out some stuff known about it... */
-int obj_debug			(struct t_process *p, int32_t oid)
+int obj_debug(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o;
-	s3dprintf(HIGH,&quot;about pid %d/obj %d:&quot;,p-&gt;id,oid);
-	if (OBJ_VALID(p,oid,o)) {
-		s3dprintf(HIGH,&quot;vertices: %d, polygons: %d, materials: %d, textures: %d, flags: %010x&quot;,o-&gt;n_vertex,o-&gt;n_poly, o-&gt;n_mat, o-&gt;n_tex,o-&gt;oflags);
-		s3dprintf(HIGH,&quot;linkid %d, displaylist %d&quot;,o-&gt;linkid,o-&gt;dplist);
-		s3dprintf(HIGH,&quot;translation: %f %f %f&quot;,o-&gt;translate.x,o-&gt;translate.y,o-&gt;translate.z);
-		s3dprintf(HIGH,&quot;rotation: %f %f %f&quot;,o-&gt;rotate.x,o-&gt;rotate.y,o-&gt;rotate.z);
-		s3dprintf(HIGH,&quot;scale: %f&quot;,o-&gt;scale);
+	s3dprintf(HIGH, &quot;about pid %d/obj %d:&quot;, p-&gt;id, oid);
+	if (OBJ_VALID(p, oid, o)) {
+		s3dprintf(HIGH, &quot;vertices: %d, polygons: %d, materials: %d, textures: %d, flags: %010x&quot;, o-&gt;n_vertex, o-&gt;n_poly, o-&gt;n_mat, o-&gt;n_tex, o-&gt;oflags);
+		s3dprintf(HIGH, &quot;linkid %d, displaylist %d&quot;, o-&gt;linkid, o-&gt;dplist);
+		s3dprintf(HIGH, &quot;translation: %f %f %f&quot;, o-&gt;translate.x, o-&gt;translate.y, o-&gt;translate.z);
+		s3dprintf(HIGH, &quot;rotation: %f %f %f&quot;, o-&gt;rotate.x, o-&gt;rotate.y, o-&gt;rotate.z);
+		s3dprintf(HIGH, &quot;scale: %f&quot;, o-&gt;scale);
 		if (o-&gt;oflags&amp;OF_SYSTEM) {
-			s3dprintf(HIGH,&quot;it's a system object!!&quot;);
+			s3dprintf(HIGH, &quot;it's a system object!!&quot;);
 		} else if (o-&gt;oflags&amp;OF_CLONE) {
-			s3dprintf(HIGH,&quot;it's a clone linking to %d&quot;,o-&gt;n_vertex);
-			obj_debug(p,o-&gt;n_vertex);
+			s3dprintf(HIGH, &quot;it's a clone linking to %d&quot;, o-&gt;n_vertex);
+			obj_debug(p, o-&gt;n_vertex);
 		}
 	} else {
-		s3dprintf(HIGH,&quot;can't get oid %d pid %d&quot;,oid,p-&gt;id);
+		s3dprintf(HIGH, &quot;can't get oid %d pid %d&quot;, oid, p-&gt;id);
 	}
 	return(0);
 }
 /*  push a few new vertices onto the stack. */
-int obj_push_vertex		(struct t_process *p, int32_t oid, float *x, int32_t n)
+int obj_push_vertex(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_vertex *p_vertex;
 	struct t_vertex *a;
 	struct t_obj *obj;
 	float *px;
 	float r;
 	int is_clnsrc;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_push_vertex()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_push_vertex()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
-		m=obj-&gt;n_vertex;	 /*  saving the first number of vertices */
-		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_vertex=realloc(obj-&gt;p_vertex,sizeof(struct t_vertex) * ( n + (obj-&gt;n_vertex))))) {
+		m = obj-&gt;n_vertex;  /*  saving the first number of vertices */
+		px = x;    /*  movable pointer for x, later */
+		if (NULL != (p_vertex = realloc(obj-&gt;p_vertex, sizeof(struct t_vertex) * (n + (obj-&gt;n_vertex))))) {
 			if (obj-&gt;dplist) {
-				s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-				glDeleteLists(obj-&gt;dplist,1);
-				obj-&gt;dplist=0;
+				s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+				glDeleteLists(obj-&gt;dplist, 1);
+				obj-&gt;dplist = 0;
 			}
-			obj-&gt;p_vertex=p_vertex;
-			for (i=0;i&lt;n;i++) {
-				obj-&gt;p_vertex[m+i].x=*(px++);
-				obj-&gt;p_vertex[m+i].y=*(px++);
-				obj-&gt;p_vertex[m+i].z=*(px++);
+			obj-&gt;p_vertex = p_vertex;
+			for (i = 0;i &lt; n;i++) {
+				obj-&gt;p_vertex[m+i].x = *(px++);
+				obj-&gt;p_vertex[m+i].y = *(px++);
+				obj-&gt;p_vertex[m+i].z = *(px++);
 
-				a=&amp;obj-&gt;p_vertex[m+i];
-				r=obj-&gt;scale * sqrt(
-				          (a-&gt;x * a-&gt;x ) +
-				          (a-&gt;y * a-&gt;y ) +
-				          (a-&gt;z * a-&gt;z ));
-				if (r&gt; obj-&gt;r) obj-&gt;r=r;
-				/*				s3dprintf(VLOW,&quot;added following vertex[%d]: %f, %f, %f&quot;,i,
-												obj-&gt;p_vertex[m+i].x,
-												obj-&gt;p_vertex[m+i].y,
-												obj-&gt;p_vertex[m+i].z);*/
+				a = &amp;obj-&gt;p_vertex[m+i];
+				r = obj-&gt;scale * sqrt(
+				            (a-&gt;x * a-&gt;x) +
+				            (a-&gt;y * a-&gt;y) +
+				            (a-&gt;z * a-&gt;z));
+				if (r &gt; obj-&gt;r) obj-&gt;r = r;
+				/*    s3dprintf(VLOW,&quot;added following vertex[%d]: %f, %f, %f&quot;,i,
+				        obj-&gt;p_vertex[m+i].x,
+				        obj-&gt;p_vertex[m+i].y,
+				        obj-&gt;p_vertex[m+i].z);*/
 
 			}
-			if (p-&gt;id!=MCP) {
+			if (p-&gt;id != MCP) {
 				/* this is doing live update which is quite okay, but we need
 				 * to check for biggest update and clonesources ... */
-				obj_check_biggest_object(p,oid);
+				obj_check_biggest_object(p, oid);
 			}
 			if (p-&gt;object[oid]-&gt;oflags&amp;OF_CLONE_SRC) {
-				is_clnsrc=0;
-				for (i=0;i&lt;p-&gt;n_obj;i++) {
-					if (p-&gt;object[i]!=NULL) {
-						if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex==oid)) { /* if it's pointing to our object ... */
-							is_clnsrc=1;
-							p-&gt;object[i]-&gt;r=obj-&gt;r*(p-&gt;object[i]-&gt;r/obj-&gt;scale); /* give it the new radius too! */
-							obj_check_biggest_object(p,i);
+				is_clnsrc = 0;
+				for (i = 0;i &lt; p-&gt;n_obj;i++) {
+					if (p-&gt;object[i] != NULL) {
+						if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex == oid)) { /* if it's pointing to our object ... */
+							is_clnsrc = 1;
+							p-&gt;object[i]-&gt;r = obj-&gt;r * (p-&gt;object[i]-&gt;r / obj-&gt;scale); /* give it the new radius too! */
+							obj_check_biggest_object(p, i);
 						}
 					}
 				}
 				if (!is_clnsrc)
-					p-&gt;object[oid]-&gt;oflags&amp;=~OF_CLONE_SRC;
+					p-&gt;object[oid]-&gt;oflags &amp;= ~OF_CLONE_SRC;
 			}
 
-			obj-&gt;n_vertex+=n;
+			obj-&gt;n_vertex += n;
 		}
 	} else {
 		return(-1);
@@ -134,42 +134,42 @@
 }
 
 
-int obj_push_mat		(struct t_process *p, int32_t oid, float *x, int32_t n)
+int obj_push_mat(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_mat *p_mat;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_push_mat()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_push_mat()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
-		m=obj-&gt;n_mat;	 /*  saving the first number of materials */
-		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_mat=realloc(obj-&gt;p_mat,sizeof(struct t_mat) * ( n + (obj-&gt;n_mat))))) {
+		m = obj-&gt;n_mat;  /*  saving the first number of materials */
+		px = x;    /*  movable pointer for x, later */
+		if (NULL != (p_mat = realloc(obj-&gt;p_mat, sizeof(struct t_mat) * (n + (obj-&gt;n_mat))))) {
 			if (obj-&gt;dplist) {
-				s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-				glDeleteLists(obj-&gt;dplist,1);
-				obj-&gt;dplist=0;
+				s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+				glDeleteLists(obj-&gt;dplist, 1);
+				obj-&gt;dplist = 0;
 			}
-			obj-&gt;p_mat=p_mat;
-			for (i=0;i&lt;n;i++) {
-				obj-&gt;p_mat[m+i].amb_r=*(px++);
-				obj-&gt;p_mat[m+i].amb_g=*(px++);
-				obj-&gt;p_mat[m+i].amb_b=*(px++);
-				obj-&gt;p_mat[m+i].amb_a=*(px++);
-				obj-&gt;p_mat[m+i].spec_r=*(px++);
-				obj-&gt;p_mat[m+i].spec_g=*(px++);
-				obj-&gt;p_mat[m+i].spec_b=*(px++);
-				obj-&gt;p_mat[m+i].spec_a=*(px++);
-				obj-&gt;p_mat[m+i].diff_r=*(px++);
-				obj-&gt;p_mat[m+i].diff_g=*(px++);
-				obj-&gt;p_mat[m+i].diff_b=*(px++);
-				obj-&gt;p_mat[m+i].diff_a=*(px++);
-				obj-&gt;p_mat[m+i].tex=-1;
+			obj-&gt;p_mat = p_mat;
+			for (i = 0;i &lt; n;i++) {
+				obj-&gt;p_mat[m+i].amb_r = *(px++);
+				obj-&gt;p_mat[m+i].amb_g = *(px++);
+				obj-&gt;p_mat[m+i].amb_b = *(px++);
+				obj-&gt;p_mat[m+i].amb_a = *(px++);
+				obj-&gt;p_mat[m+i].spec_r = *(px++);
+				obj-&gt;p_mat[m+i].spec_g = *(px++);
+				obj-&gt;p_mat[m+i].spec_b = *(px++);
+				obj-&gt;p_mat[m+i].spec_a = *(px++);
+				obj-&gt;p_mat[m+i].diff_r = *(px++);
+				obj-&gt;p_mat[m+i].diff_g = *(px++);
+				obj-&gt;p_mat[m+i].diff_b = *(px++);
+				obj-&gt;p_mat[m+i].diff_a = *(px++);
+				obj-&gt;p_mat[m+i].tex = -1;
 			}
-			obj-&gt;n_mat+=n;
+			obj-&gt;n_mat += n;
 		}
 	} else {
 		return(-1);
@@ -180,38 +180,38 @@
 /*  its always the same ... this time we push some polys on the stack */
 int obj_push_poly(struct t_process *p, int32_t oid, uint32_t *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_poly *p_poly;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_push_poly()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_push_poly()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
-		m=obj-&gt;n_poly;	 /*  saving the first number of polys */
-		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_poly=realloc(obj-&gt;p_poly,sizeof(struct t_poly) * ( n + (obj-&gt;n_poly))))) {
+		m = obj-&gt;n_poly;  /*  saving the first number of polys */
+		px = x;    /*  movable pointer for x, later */
+		if (NULL != (p_poly = realloc(obj-&gt;p_poly, sizeof(struct t_poly) * (n + (obj-&gt;n_poly))))) {
 			if (obj-&gt;dplist) {
-				s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-				glDeleteLists(obj-&gt;dplist,1);
-				obj-&gt;dplist=0;
+				s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+				glDeleteLists(obj-&gt;dplist, 1);
+				obj-&gt;dplist = 0;
 			}
-			obj-&gt;p_poly=p_poly;
-			for (i=0;i&lt;n;i++) {
-				obj-&gt;p_poly[m+i].v[0]=*(px++);
-				obj-&gt;p_poly[m+i].v[1]=*(px++);
-				obj-&gt;p_poly[m+i].v[2]=*(px++);
-				obj-&gt;p_poly[m+i].mat=*(px++);
-				obj-&gt;p_poly[m+i].n[0].x=obj-&gt;p_poly[m+i].n[0].y=obj-&gt;p_poly[m+i].n[0].z=0;
-				obj-&gt;p_poly[m+i].n[1].x=obj-&gt;p_poly[m+i].n[1].y=obj-&gt;p_poly[m+i].n[1].z=0;
-				obj-&gt;p_poly[m+i].n[2].x=obj-&gt;p_poly[m+i].n[2].y=obj-&gt;p_poly[m+i].n[2].z=0;
-				obj-&gt;p_poly[m+i].tc[0].x=obj-&gt;p_poly[m+i].n[0].y=obj-&gt;p_poly[m+i].n[0].z=0;
-				obj-&gt;p_poly[m+i].tc[1].x=obj-&gt;p_poly[m+i].n[1].y=obj-&gt;p_poly[m+i].n[1].z=0;
-				obj-&gt;p_poly[m+i].tc[2].x=obj-&gt;p_poly[m+i].n[2].y=obj-&gt;p_poly[m+i].n[2].z=0;
+			obj-&gt;p_poly = p_poly;
+			for (i = 0;i &lt; n;i++) {
+				obj-&gt;p_poly[m+i].v[0] = *(px++);
+				obj-&gt;p_poly[m+i].v[1] = *(px++);
+				obj-&gt;p_poly[m+i].v[2] = *(px++);
+				obj-&gt;p_poly[m+i].mat = *(px++);
+				obj-&gt;p_poly[m+i].n[0].x = obj-&gt;p_poly[m+i].n[0].y = obj-&gt;p_poly[m+i].n[0].z = 0;
+				obj-&gt;p_poly[m+i].n[1].x = obj-&gt;p_poly[m+i].n[1].y = obj-&gt;p_poly[m+i].n[1].z = 0;
+				obj-&gt;p_poly[m+i].n[2].x = obj-&gt;p_poly[m+i].n[2].y = obj-&gt;p_poly[m+i].n[2].z = 0;
+				obj-&gt;p_poly[m+i].tc[0].x = obj-&gt;p_poly[m+i].n[0].y = obj-&gt;p_poly[m+i].n[0].z = 0;
+				obj-&gt;p_poly[m+i].tc[1].x = obj-&gt;p_poly[m+i].n[1].y = obj-&gt;p_poly[m+i].n[1].z = 0;
+				obj-&gt;p_poly[m+i].tc[2].x = obj-&gt;p_poly[m+i].n[2].y = obj-&gt;p_poly[m+i].n[2].z = 0;
 			}
-			obj-&gt;n_poly+=n;
+			obj-&gt;n_poly += n;
 		}
 	} else {
 		return(-1);
@@ -221,33 +221,33 @@
 /*  its always the same ... this time we push some lines on the stack */
 int obj_push_line(struct t_process *p, int32_t oid, uint32_t *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_line *p_line;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_push_line()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_push_line()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
-		m=obj-&gt;n_line;	 /*  saving the first number of lines */
-		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_line=realloc(obj-&gt;p_line,sizeof(struct t_line) * ( n + (obj-&gt;n_line))))) {
+		m = obj-&gt;n_line;  /*  saving the first number of lines */
+		px = x;    /*  movable pointer for x, later */
+		if (NULL != (p_line = realloc(obj-&gt;p_line, sizeof(struct t_line) * (n + (obj-&gt;n_line))))) {
 			if (obj-&gt;dplist) {
-				s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-				glDeleteLists(obj-&gt;dplist,1);
-				obj-&gt;dplist=0;
+				s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+				glDeleteLists(obj-&gt;dplist, 1);
+				obj-&gt;dplist = 0;
 			}
-			obj-&gt;p_line=p_line;
-			for (i=0;i&lt;n;i++) {
-				obj-&gt;p_line[m+i].v[0]=*(px++);
-				obj-&gt;p_line[m+i].v[1]=*(px++);
-				obj-&gt;p_line[m+i].mat=*(px++);
-				obj-&gt;p_line[m+i].n[0].x=obj-&gt;p_line[m+i].n[0].y=obj-&gt;p_line[m+i].n[0].z=0;
-				obj-&gt;p_line[m+i].n[1].x=obj-&gt;p_line[m+i].n[1].y=obj-&gt;p_line[m+i].n[1].z=0;
+			obj-&gt;p_line = p_line;
+			for (i = 0;i &lt; n;i++) {
+				obj-&gt;p_line[m+i].v[0] = *(px++);
+				obj-&gt;p_line[m+i].v[1] = *(px++);
+				obj-&gt;p_line[m+i].mat = *(px++);
+				obj-&gt;p_line[m+i].n[0].x = obj-&gt;p_line[m+i].n[0].y = obj-&gt;p_line[m+i].n[0].z = 0;
+				obj-&gt;p_line[m+i].n[1].x = obj-&gt;p_line[m+i].n[1].y = obj-&gt;p_line[m+i].n[1].z = 0;
 			}
-			obj-&gt;n_line+=n;
+			obj-&gt;n_line += n;
 		}
 	} else {
 		return(-1);
@@ -258,67 +258,67 @@
  * given through *x */
 int obj_push_tex(struct t_process *p, int32_t oid, uint16_t *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	double d;
 	struct t_tex *p_tex;
 	struct t_obj *obj;
-	uint16_t *px,hm;
-	if (OBJ_VALID(p,oid,obj)) {
+	uint16_t *px, hm;
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_push_tex()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_push_tex()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
-		m=obj-&gt;n_tex;	     /*  saving the first number of textures */
-		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_tex=realloc(obj-&gt;p_tex,sizeof(struct t_tex) * ( n + (obj-&gt;n_tex))))) {
-			/*			if (obj-&gt;dplist)
-						{
-							s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-							glDeleteLists(obj-&gt;dplist,1);
-							obj-&gt;dplist=0;
-						}*/
-			obj-&gt;p_tex=p_tex;
-			for (i=0;i&lt;n;i++) {
-				obj-&gt;p_tex[m+i].gl_texnum=-1;
-				obj-&gt;p_tex[m+i].tw=*(px++);
-				obj-&gt;p_tex[m+i].th=*(px++);
-				if ((obj-&gt;p_tex[m+i].tw&lt;=TEXTURE_MAX_W) &amp;&amp; (obj-&gt;p_tex[m+i].th&lt;=TEXTURE_MAX_H)) {
-					d=log((double)obj-&gt;p_tex[m+i].tw)/log(2.0);
-					hm=pow(2,floor(d));
-					s3dprintf(MED,&quot;hm %d, tw %d&quot;,hm,obj-&gt;p_tex[m+i].tw);
-					if (hm!=obj-&gt;p_tex[m+i].tw) 	{
-						obj-&gt;p_tex[m+i].w=hm*2;
-						obj-&gt;p_tex[m+i].xs=(float)((double)obj-&gt;p_tex[m+i].tw)/((double)obj-&gt;p_tex[m+i].w);
-					} else	{
-						obj-&gt;p_tex[m+i].xs=1.0;
-						obj-&gt;p_tex[m+i].w=obj-&gt;p_tex[m+i].tw;
+		m = obj-&gt;n_tex;    /*  saving the first number of textures */
+		px = x;    /*  movable pointer for x, later */
+		if (NULL != (p_tex = realloc(obj-&gt;p_tex, sizeof(struct t_tex) * (n + (obj-&gt;n_tex))))) {
+			/*   if (obj-&gt;dplist)
+			   {
+			    s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
+			    glDeleteLists(obj-&gt;dplist,1);
+			    obj-&gt;dplist=0;
+			   }*/
+			obj-&gt;p_tex = p_tex;
+			for (i = 0;i &lt; n;i++) {
+				obj-&gt;p_tex[m+i].gl_texnum = -1;
+				obj-&gt;p_tex[m+i].tw = *(px++);
+				obj-&gt;p_tex[m+i].th = *(px++);
+				if ((obj-&gt;p_tex[m+i].tw &lt;= TEXTURE_MAX_W) &amp;&amp; (obj-&gt;p_tex[m+i].th &lt;= TEXTURE_MAX_H)) {
+					d = log((double)obj-&gt;p_tex[m+i].tw) / log(2.0);
+					hm = pow(2, floor(d));
+					s3dprintf(MED, &quot;hm %d, tw %d&quot;, hm, obj-&gt;p_tex[m+i].tw);
+					if (hm != obj-&gt;p_tex[m+i].tw)  {
+						obj-&gt;p_tex[m+i].w = hm * 2;
+						obj-&gt;p_tex[m+i].xs = (float)((double)obj-&gt;p_tex[m+i].tw) / ((double)obj-&gt;p_tex[m+i].w);
+					} else {
+						obj-&gt;p_tex[m+i].xs = 1.0;
+						obj-&gt;p_tex[m+i].w = obj-&gt;p_tex[m+i].tw;
 					}
-					d=log((double)obj-&gt;p_tex[m+i].th)/log(2.0);
-					hm=pow(2,floor(d));
-					s3dprintf(MED,&quot;hm %d, th %d&quot;,hm,obj-&gt;p_tex[m+i].th);
+					d = log((double)obj-&gt;p_tex[m+i].th) / log(2.0);
+					hm = pow(2, floor(d));
+					s3dprintf(MED, &quot;hm %d, th %d&quot;, hm, obj-&gt;p_tex[m+i].th);
 
-					if (hm!=obj-&gt;p_tex[m+i].th) 	{
-						obj-&gt;p_tex[m+i].h=hm*2;
-						obj-&gt;p_tex[m+i].ys=(float)((double)obj-&gt;p_tex[m+i].th)/((double)obj-&gt;p_tex[m+i].h);
-					} else 	{
-						obj-&gt;p_tex[m+i].ys=1.0;
-						obj-&gt;p_tex[m+i].h=obj-&gt;p_tex[m+i].th;
+					if (hm != obj-&gt;p_tex[m+i].th)  {
+						obj-&gt;p_tex[m+i].h = hm * 2;
+						obj-&gt;p_tex[m+i].ys = (float)((double)obj-&gt;p_tex[m+i].th) / ((double)obj-&gt;p_tex[m+i].h);
+					} else  {
+						obj-&gt;p_tex[m+i].ys = 1.0;
+						obj-&gt;p_tex[m+i].h = obj-&gt;p_tex[m+i].th;
 					}
-					obj-&gt;p_tex[m+i].buf=malloc(obj-&gt;p_tex[m+i].h*obj-&gt;p_tex[m+i].w*4);
-					memset(obj-&gt;p_tex[m+i].buf,0,obj-&gt;p_tex[m+i].h*obj-&gt;p_tex[m+i].w*4);
-					errds(LOW,&quot;obj_push_tex()&quot;,&quot;setting up %d %d (in mem: %d %d) texture&quot;,
+					obj-&gt;p_tex[m+i].buf = malloc(obj-&gt;p_tex[m+i].h * obj-&gt;p_tex[m+i].w * 4);
+					memset(obj-&gt;p_tex[m+i].buf, 0, obj-&gt;p_tex[m+i].h*obj-&gt;p_tex[m+i].w*4);
+					errds(LOW, &quot;obj_push_tex()&quot;, &quot;setting up %d %d (in mem: %d %d) texture&quot;,
 					      obj-&gt;p_tex[m+i].tw,
 					      obj-&gt;p_tex[m+i].th,
 					      obj-&gt;p_tex[m+i].w,
 					      obj-&gt;p_tex[m+i].h);
 
-				} else	{
-					errds(MED,&quot;obj_push_tex()&quot;,&quot;bad size for texture %d (requested size: %dx%d, max %dx%d)&quot;,m+i,
-					      obj-&gt;p_tex[m+i].tw,obj-&gt;p_tex[m+i].th,TEXTURE_MAX_W,TEXTURE_MAX_H);
-					obj-&gt;p_tex[m+i].buf=NULL;
+				} else {
+					errds(MED, &quot;obj_push_tex()&quot;, &quot;bad size for texture %d (requested size: %dx%d, max %dx%d)&quot;, m + i,
+					      obj-&gt;p_tex[m+i].tw, obj-&gt;p_tex[m+i].th, TEXTURE_MAX_W, TEXTURE_MAX_H);
+					obj-&gt;p_tex[m+i].buf = NULL;
 				}
 			}
-			obj-&gt;n_tex+=n;
+			obj-&gt;n_tex += n;
 		}
 	} else {
 		return(-1);
@@ -328,39 +328,39 @@
 /*  add some normal information to the polygon buffer */
 int obj_pep_poly_normal(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,j,m;
+	int32_t i, j, m;
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj)) {
-		m=obj-&gt;n_poly;
-		if (m&lt;n)	 /*  saving the first number of polys */
-			n=m;  /*  when more polygons than available should be pepped,  */
+	if (OBJ_VALID(p, oid, obj)) {
+		m = obj-&gt;n_poly;
+		if (m &lt; n)  /*  saving the first number of polys */
+			n = m;  /*  when more polygons than available should be pepped,  */
 		/*  just pep the first m polygons */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_pep_poly_normal()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_pep_poly_normal()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
 		if (obj-&gt;dplist) {
-			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-			glDeleteLists(obj-&gt;dplist,1);
-			obj-&gt;dplist=0;
+			s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+			glDeleteLists(obj-&gt;dplist, 1);
+			obj-&gt;dplist = 0;
 		}
-		s3dprintf(VLOW,&quot;pepping poly's %d to %d&quot;,(m-n),m);
-		for (i=(m-n);i&lt;m;i++) {
-			for (j=0;j&lt;3;j++) {
-				obj-&gt;p_poly[i].n[j].x=*(px++);
-				obj-&gt;p_poly[i].n[j].y=*(px++);
-				obj-&gt;p_poly[i].n[j].z=*(px++);
-				len=sqrt(obj-&gt;p_poly[i].n[j].x*obj-&gt;p_poly[i].n[j].x + obj-&gt;p_poly[i].n[j].y*obj-&gt;p_poly[i].n[j].y +obj-&gt;p_poly[i].n[j].z*obj-&gt;p_poly[i].n[j].z);
-				if (len==0)
-					obj-&gt;p_poly[i].n[j].x=obj-&gt;p_poly[i].n[j].y=obj-&gt;p_poly[i].n[j].z=0;
+		s3dprintf(VLOW, &quot;pepping poly's %d to %d&quot;, (m - n), m);
+		for (i = (m - n);i &lt; m;i++) {
+			for (j = 0;j &lt; 3;j++) {
+				obj-&gt;p_poly[i].n[j].x = *(px++);
+				obj-&gt;p_poly[i].n[j].y = *(px++);
+				obj-&gt;p_poly[i].n[j].z = *(px++);
+				len = sqrt(obj-&gt;p_poly[i].n[j].x * obj-&gt;p_poly[i].n[j].x + obj-&gt;p_poly[i].n[j].y * obj-&gt;p_poly[i].n[j].y + obj-&gt;p_poly[i].n[j].z * obj-&gt;p_poly[i].n[j].z);
+				if (len == 0)
+					obj-&gt;p_poly[i].n[j].x = obj-&gt;p_poly[i].n[j].y = obj-&gt;p_poly[i].n[j].z = 0;
 				else {
-					obj-&gt;p_poly[i].n[j].x/=len;
-					obj-&gt;p_poly[i].n[j].y/=len;
-					obj-&gt;p_poly[i].n[j].z/=len;
+					obj-&gt;p_poly[i].n[j].x /= len;
+					obj-&gt;p_poly[i].n[j].y /= len;
+					obj-&gt;p_poly[i].n[j].z /= len;
 				}
 			}
 		}
@@ -372,39 +372,39 @@
 /*  add some normal information to the line buffer */
 int obj_pep_line_normal(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,j,m;
+	int32_t i, j, m;
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj)) {
-		m=obj-&gt;n_line;
-		if (m&lt;n)	 /*  saving the first number of lines */
-			n=m;  /*  when more lines than available should be pepped,  */
+	if (OBJ_VALID(p, oid, obj)) {
+		m = obj-&gt;n_line;
+		if (m &lt; n)  /*  saving the first number of lines */
+			n = m;  /*  when more lines than available should be pepped,  */
 		/*  just pep the first m liness */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_pep_line_normal()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_pep_line_normal()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
 		if (obj-&gt;dplist) {
-			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-			glDeleteLists(obj-&gt;dplist,1);
-			obj-&gt;dplist=0;
+			s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+			glDeleteLists(obj-&gt;dplist, 1);
+			obj-&gt;dplist = 0;
 		}
-		s3dprintf(VLOW,&quot;pepping line's %d to %d&quot;,(m-n),m);
-		for (i=(m-n);i&lt;m;i++) {
-			for (j=0;j&lt;2;j++) {
-				obj-&gt;p_line[i].n[j].x=*(px++);
-				obj-&gt;p_line[i].n[j].y=*(px++);
-				obj-&gt;p_line[i].n[j].z=*(px++);
-				len=sqrt(obj-&gt;p_line[i].n[j].x*obj-&gt;p_line[i].n[j].x + obj-&gt;p_line[i].n[j].y*obj-&gt;p_line[i].n[j].y +obj-&gt;p_line[i].n[j].z*obj-&gt;p_line[i].n[j].z);
-				if (len==0)
-					obj-&gt;p_line[i].n[j].x=obj-&gt;p_line[i].n[j].y=obj-&gt;p_line[i].n[j].z=0;
+		s3dprintf(VLOW, &quot;pepping line's %d to %d&quot;, (m - n), m);
+		for (i = (m - n);i &lt; m;i++) {
+			for (j = 0;j &lt; 2;j++) {
+				obj-&gt;p_line[i].n[j].x = *(px++);
+				obj-&gt;p_line[i].n[j].y = *(px++);
+				obj-&gt;p_line[i].n[j].z = *(px++);
+				len = sqrt(obj-&gt;p_line[i].n[j].x * obj-&gt;p_line[i].n[j].x + obj-&gt;p_line[i].n[j].y * obj-&gt;p_line[i].n[j].y + obj-&gt;p_line[i].n[j].z * obj-&gt;p_line[i].n[j].z);
+				if (len == 0)
+					obj-&gt;p_line[i].n[j].x = obj-&gt;p_line[i].n[j].y = obj-&gt;p_line[i].n[j].z = 0;
 				else {
-					obj-&gt;p_line[i].n[j].x/=len;
-					obj-&gt;p_line[i].n[j].y/=len;
-					obj-&gt;p_line[i].n[j].z/=len;
+					obj-&gt;p_line[i].n[j].x /= len;
+					obj-&gt;p_line[i].n[j].y /= len;
+					obj-&gt;p_line[i].n[j].z /= len;
 				}
 
 			}
@@ -418,31 +418,31 @@
 /*  add textures coordinates to each vertex of the polygon(s) */
 int obj_pep_poly_texc(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,j,m;
+	int32_t i, j, m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_pep_poly_texc()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_pep_poly_texc()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
-		m=obj-&gt;n_poly;
-		if (m&lt;n)	 /*  saving the first number of polys */
-			n=m;  /*  when more polygons than available should be pepped,  */
+		m = obj-&gt;n_poly;
+		if (m &lt; n)  /*  saving the first number of polys */
+			n = m;  /*  when more polygons than available should be pepped,  */
 		/*  just pep the first m polygons */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 
 		if (obj-&gt;dplist) {
-			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-			glDeleteLists(obj-&gt;dplist,1);
-			obj-&gt;dplist=0;
+			s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+			glDeleteLists(obj-&gt;dplist, 1);
+			obj-&gt;dplist = 0;
 		}
-		s3dprintf(VLOW,&quot;pepping poly's %d to %d&quot;,(m-n),m);
-		for (i=(m-n);i&lt;m;i++) {
-			for (j=0;j&lt;3;j++) {
-				obj-&gt;p_poly[i].tc[j].x=*(px++);
-				obj-&gt;p_poly[i].tc[j].y=*(px++);
+		s3dprintf(VLOW, &quot;pepping poly's %d to %d&quot;, (m - n), m);
+		for (i = (m - n);i &lt; m;i++) {
+			for (j = 0;j &lt; 3;j++) {
+				obj-&gt;p_poly[i].tc[j].x = *(px++);
+				obj-&gt;p_poly[i].tc[j].y = *(px++);
 			}
 		}
 	} else {
@@ -453,38 +453,38 @@
 /*  overwrite n latest materials with some other materials */
 int obj_pep_mat(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj)) {
-		m=obj-&gt;n_mat;	 /*  saving the first number of materials */
-		if (m&lt;n)
-			n=m;  /*  when more mats than available should be pepped,  */
+	if (OBJ_VALID(p, oid, obj)) {
+		m = obj-&gt;n_mat;  /*  saving the first number of materials */
+		if (m &lt; n)
+			n = m;  /*  when more mats than available should be pepped,  */
 		/*  just pep the first m mats */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_pep_mat()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_pep_mat()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 		if (obj-&gt;dplist) {
-			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-			glDeleteLists(obj-&gt;dplist,1);
-			obj-&gt;dplist=0;
+			s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+			glDeleteLists(obj-&gt;dplist, 1);
+			obj-&gt;dplist = 0;
 		}
-		s3dprintf(VLOW,&quot;pepping mats %d to %d&quot;,(m-n),m);
-		for (i=(m-n);i&lt;m;i++) {
-			obj-&gt;p_mat[i].amb_r=*(px++);
-			obj-&gt;p_mat[i].amb_g=*(px++);
-			obj-&gt;p_mat[i].amb_b=*(px++);
-			obj-&gt;p_mat[i].amb_a=*(px++);
-			obj-&gt;p_mat[i].spec_r=*(px++);
-			obj-&gt;p_mat[i].spec_g=*(px++);
-			obj-&gt;p_mat[i].spec_b=*(px++);
-			obj-&gt;p_mat[i].spec_a=*(px++);
-			obj-&gt;p_mat[i].diff_r=*(px++);
-			obj-&gt;p_mat[i].diff_g=*(px++);
-			obj-&gt;p_mat[i].diff_b=*(px++);
-			obj-&gt;p_mat[i].diff_a=*(px++);
+		s3dprintf(VLOW, &quot;pepping mats %d to %d&quot;, (m - n), m);
+		for (i = (m - n);i &lt; m;i++) {
+			obj-&gt;p_mat[i].amb_r = *(px++);
+			obj-&gt;p_mat[i].amb_g = *(px++);
+			obj-&gt;p_mat[i].amb_b = *(px++);
+			obj-&gt;p_mat[i].amb_a = *(px++);
+			obj-&gt;p_mat[i].spec_r = *(px++);
+			obj-&gt;p_mat[i].spec_g = *(px++);
+			obj-&gt;p_mat[i].spec_b = *(px++);
+			obj-&gt;p_mat[i].spec_a = *(px++);
+			obj-&gt;p_mat[i].diff_r = *(px++);
+			obj-&gt;p_mat[i].diff_g = *(px++);
+			obj-&gt;p_mat[i].diff_b = *(px++);
+			obj-&gt;p_mat[i].diff_a = *(px++);
 		}
 	} else {
 		return(-1);
@@ -494,31 +494,31 @@
 /*  overwrite n latest lines with some other lines */
 int obj_pep_line(struct t_process *p, int32_t oid, uint32_t *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj)) {
-		m=obj-&gt;n_line;	 /*  saving the first number of lines */
-		if (m&lt;n)
-			n=m;  /*  when more lines than available should be pepped,  */
+	if (OBJ_VALID(p, oid, obj)) {
+		m = obj-&gt;n_line;  /*  saving the first number of lines */
+		if (m &lt; n)
+			n = m;  /*  when more lines than available should be pepped,  */
 		/*  just pep the first m lines */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_pep_line()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_pep_line()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 		if (obj-&gt;dplist) {
-			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-			glDeleteLists(obj-&gt;dplist,1);
-			obj-&gt;dplist=0;
+			s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+			glDeleteLists(obj-&gt;dplist, 1);
+			obj-&gt;dplist = 0;
 		}
-		s3dprintf(VLOW,&quot;pepping lines %d to %d&quot;,(m-n),m);
-		for (i=(m-n);i&lt;m;i++) {
-			obj-&gt;p_line[i].v[0]=*(px++);
-			obj-&gt;p_line[i].v[1]=*(px++);
-			obj-&gt;p_line[i].mat=*(px++);
-			obj-&gt;p_line[i].n[0].x=obj-&gt;p_line[i].n[0].y=obj-&gt;p_line[i].n[0].z=0;
-			obj-&gt;p_line[i].n[1].x=obj-&gt;p_line[i].n[1].y=obj-&gt;p_line[i].n[1].z=0;
+		s3dprintf(VLOW, &quot;pepping lines %d to %d&quot;, (m - n), m);
+		for (i = (m - n);i &lt; m;i++) {
+			obj-&gt;p_line[i].v[0] = *(px++);
+			obj-&gt;p_line[i].v[1] = *(px++);
+			obj-&gt;p_line[i].mat = *(px++);
+			obj-&gt;p_line[i].n[0].x = obj-&gt;p_line[i].n[0].y = obj-&gt;p_line[i].n[0].z = 0;
+			obj-&gt;p_line[i].n[1].x = obj-&gt;p_line[i].n[1].y = obj-&gt;p_line[i].n[1].z = 0;
 		}
 	} else {
 		return(-1);
@@ -530,57 +530,57 @@
 /*  overwrite n latest vertices with some other vertices */
 int obj_pep_vertex(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	float r;
 	struct t_vertex *a;
 	struct t_obj *obj;
 	float *px;
 	int is_clnsrc;
-	if (OBJ_VALID(p,oid,obj)) {
-		m=obj-&gt;n_vertex;	 /*  saving the first number of vertices */
-		if (m&lt;n)
-			n=m;  /*  when more mats than available should be pepped,  */
+	if (OBJ_VALID(p, oid, obj)) {
+		m = obj-&gt;n_vertex;  /*  saving the first number of vertices */
+		if (m &lt; n)
+			n = m;  /*  when more mats than available should be pepped,  */
 		/*  just pep the first m mats */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_pep_vertices()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_pep_vertices()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 		if (obj-&gt;dplist) {
-			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-			glDeleteLists(obj-&gt;dplist,1);
-			obj-&gt;dplist=0;
+			s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+			glDeleteLists(obj-&gt;dplist, 1);
+			obj-&gt;dplist = 0;
 		}
-		s3dprintf(VLOW,&quot;pepping vertices %d to %d&quot;,(m-n),m-1);
-		for (i=(m-n);i&lt;m;i++) {
-			obj-&gt;p_vertex[i].x=*(px++);
-			obj-&gt;p_vertex[i].y=*(px++);
-			obj-&gt;p_vertex[i].z=*(px++);
-			a=&amp;obj-&gt;p_vertex[i];
-			r=obj-&gt;scale * sqrt(
-			          (a-&gt;x * a-&gt;x ) +
-			          (a-&gt;y * a-&gt;y ) +
-			          (a-&gt;z * a-&gt;z ));
-			if (r&gt; obj-&gt;r) obj-&gt;r=r;
+		s3dprintf(VLOW, &quot;pepping vertices %d to %d&quot;, (m - n), m - 1);
+		for (i = (m - n);i &lt; m;i++) {
+			obj-&gt;p_vertex[i].x = *(px++);
+			obj-&gt;p_vertex[i].y = *(px++);
+			obj-&gt;p_vertex[i].z = *(px++);
+			a = &amp;obj-&gt;p_vertex[i];
+			r = obj-&gt;scale * sqrt(
+			            (a-&gt;x * a-&gt;x) +
+			            (a-&gt;y * a-&gt;y) +
+			            (a-&gt;z * a-&gt;z));
+			if (r &gt; obj-&gt;r) obj-&gt;r = r;
 		}
-		if (p-&gt;id!=MCP) {
+		if (p-&gt;id != MCP) {
 			/* this is doing live update which is quite okay, but we need
 			 * to check for biggest update and clonesources ... */
-			obj_check_biggest_object(p,oid);
+			obj_check_biggest_object(p, oid);
 		}
 		if (p-&gt;object[oid]-&gt;oflags&amp;OF_CLONE_SRC) {
-			is_clnsrc=0;
-			for (i=0;i&lt;p-&gt;n_obj;i++) {
-				if (p-&gt;object[i]!=NULL) {
-					if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex==oid)) { /* if it's pointing to our object ... */
-						is_clnsrc=1;
-						p-&gt;object[i]-&gt;r=obj-&gt;r*(p-&gt;object[i]-&gt;r/obj-&gt;scale); /* give it the new radius too! */
-						obj_check_biggest_object(p,i);
+			is_clnsrc = 0;
+			for (i = 0;i &lt; p-&gt;n_obj;i++) {
+				if (p-&gt;object[i] != NULL) {
+					if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex == oid)) { /* if it's pointing to our object ... */
+						is_clnsrc = 1;
+						p-&gt;object[i]-&gt;r = obj-&gt;r * (p-&gt;object[i]-&gt;r / obj-&gt;scale); /* give it the new radius too! */
+						obj_check_biggest_object(p, i);
 					}
 				}
 			}
 			if (!is_clnsrc)
-				p-&gt;object[oid]-&gt;oflags&amp;=~OF_CLONE_SRC;
+				p-&gt;object[oid]-&gt;oflags &amp;= ~OF_CLONE_SRC;
 		}
 	} else {
 		return(-1);
@@ -590,27 +590,27 @@
 /*  assign textures to the last n materials */
 int obj_pep_mat_tex(struct t_process *p, int32_t oid, uint32_t *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj)) {
-		m=obj-&gt;n_mat;	 /*  saving the first number of vertices */
-		if (m&lt;n)	 /*  saving the first number of polys */
-			n=m;  /*  when more mats than available should be pepped,  */
+	if (OBJ_VALID(p, oid, obj)) {
+		m = obj-&gt;n_mat;  /*  saving the first number of vertices */
+		if (m &lt; n)  /*  saving the first number of polys */
+			n = m;  /*  when more mats than available should be pepped,  */
 		/*  just pep the first m mats */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_pep_mat_tex()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_pep_mat_tex()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 		if (obj-&gt;dplist) {
-			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-			glDeleteLists(obj-&gt;dplist,1);
-			obj-&gt;dplist=0;
+			s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+			glDeleteLists(obj-&gt;dplist, 1);
+			obj-&gt;dplist = 0;
 		}
-		s3dprintf(MED,&quot;pepping mats %d to %d&quot;,(m-n),m);
-		for (i=(m-n);i&lt;m;i++)
-			obj-&gt;p_mat[i].tex=*(px++);
+		s3dprintf(MED, &quot;pepping mats %d to %d&quot;, (m - n), m);
+		for (i = (m - n);i &lt; m;i++)
+			obj-&gt;p_mat[i].tex = *(px++);
 	} else {
 		return(-1);
 	}
@@ -619,38 +619,38 @@
 /*  add some normal information to the polygon buffer */
 int obj_load_poly_normal(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n)
 {
-	int32_t i,j,m;
+	int32_t i, j, m;
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (start &lt; 0) return(-1);
-		m=obj-&gt;n_poly;
-		if (m&lt;(start+n))
-			n=m-start;
-		px=x;
+		m = obj-&gt;n_poly;
+		if (m &lt; (start + n))
+			n = m - start;
+		px = x;
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_load_poly_normal()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_load_poly_normal()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
 		if (obj-&gt;dplist) {
-			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-			glDeleteLists(obj-&gt;dplist,1);
-			obj-&gt;dplist=0;
+			s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+			glDeleteLists(obj-&gt;dplist, 1);
+			obj-&gt;dplist = 0;
 		}
-		for (i=start;i&lt;(start+n);i++) {
-			for (j=0;j&lt;3;j++) {
-				obj-&gt;p_poly[i].n[j].x=*(px++);
-				obj-&gt;p_poly[i].n[j].y=*(px++);
-				obj-&gt;p_poly[i].n[j].z=*(px++);
-				len=sqrt(obj-&gt;p_poly[i].n[j].x*obj-&gt;p_poly[i].n[j].x + obj-&gt;p_poly[i].n[j].y*obj-&gt;p_poly[i].n[j].y +obj-&gt;p_poly[i].n[j].z*obj-&gt;p_poly[i].n[j].z);
-				if (len==0)
-					obj-&gt;p_poly[i].n[j].x=obj-&gt;p_poly[i].n[j].y=obj-&gt;p_poly[i].n[j].z=0;
+		for (i = start;i &lt; (start + n);i++) {
+			for (j = 0;j &lt; 3;j++) {
+				obj-&gt;p_poly[i].n[j].x = *(px++);
+				obj-&gt;p_poly[i].n[j].y = *(px++);
+				obj-&gt;p_poly[i].n[j].z = *(px++);
+				len = sqrt(obj-&gt;p_poly[i].n[j].x * obj-&gt;p_poly[i].n[j].x + obj-&gt;p_poly[i].n[j].y * obj-&gt;p_poly[i].n[j].y + obj-&gt;p_poly[i].n[j].z * obj-&gt;p_poly[i].n[j].z);
+				if (len == 0)
+					obj-&gt;p_poly[i].n[j].x = obj-&gt;p_poly[i].n[j].y = obj-&gt;p_poly[i].n[j].z = 0;
 				else {
-					obj-&gt;p_poly[i].n[j].x/=len;
-					obj-&gt;p_poly[i].n[j].y/=len;
-					obj-&gt;p_poly[i].n[j].z/=len;
+					obj-&gt;p_poly[i].n[j].x /= len;
+					obj-&gt;p_poly[i].n[j].y /= len;
+					obj-&gt;p_poly[i].n[j].z /= len;
 				}
 
 			}
@@ -662,38 +662,38 @@
 /*  add some normal information to the line  buffer */
 int obj_load_line_normal(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n)
 {
-	int32_t i,j,m;
+	int32_t i, j, m;
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (start &lt; 0) return(-1);
-		m=obj-&gt;n_line;
-		if (m&lt;(start+n))
-			n=m-start;
-		px=x;
+		m = obj-&gt;n_line;
+		if (m &lt; (start + n))
+			n = m - start;
+		px = x;
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_load_line_normal()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_load_line_normal()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
 		if (obj-&gt;dplist) {
-			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-			glDeleteLists(obj-&gt;dplist,1);
-			obj-&gt;dplist=0;
+			s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+			glDeleteLists(obj-&gt;dplist, 1);
+			obj-&gt;dplist = 0;
 		}
-		for (i=start;i&lt;(start+n);i++) {
-			for (j=0;j&lt;2;j++) {
-				obj-&gt;p_line[i].n[j].x=*(px++);
-				obj-&gt;p_line[i].n[j].y=*(px++);
-				obj-&gt;p_line[i].n[j].z=*(px++);
-				len=sqrt(obj-&gt;p_line[i].n[j].x*obj-&gt;p_line[i].n[j].x + obj-&gt;p_line[i].n[j].y*obj-&gt;p_line[i].n[j].y +obj-&gt;p_line[i].n[j].z*obj-&gt;p_line[i].n[j].z);
-				if (len==0)
-					obj-&gt;p_line[i].n[j].x=obj-&gt;p_line[i].n[j].y=obj-&gt;p_line[i].n[j].z=0;
+		for (i = start;i &lt; (start + n);i++) {
+			for (j = 0;j &lt; 2;j++) {
+				obj-&gt;p_line[i].n[j].x = *(px++);
+				obj-&gt;p_line[i].n[j].y = *(px++);
+				obj-&gt;p_line[i].n[j].z = *(px++);
+				len = sqrt(obj-&gt;p_line[i].n[j].x * obj-&gt;p_line[i].n[j].x + obj-&gt;p_line[i].n[j].y * obj-&gt;p_line[i].n[j].y + obj-&gt;p_line[i].n[j].z * obj-&gt;p_line[i].n[j].z);
+				if (len == 0)
+					obj-&gt;p_line[i].n[j].x = obj-&gt;p_line[i].n[j].y = obj-&gt;p_line[i].n[j].z = 0;
 				else {
-					obj-&gt;p_line[i].n[j].x/=len;
-					obj-&gt;p_line[i].n[j].y/=len;
-					obj-&gt;p_line[i].n[j].z/=len;
+					obj-&gt;p_line[i].n[j].x /= len;
+					obj-&gt;p_line[i].n[j].y /= len;
+					obj-&gt;p_line[i].n[j].z /= len;
 				}
 
 			}
@@ -705,29 +705,29 @@
 /*  add textures coordinates to each vertex of the polygon(s) */
 int obj_load_poly_texc(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n)
 {
-	int32_t i,j,m;
+	int32_t i, j, m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (start &lt; 0) return(-1);
-		m=obj-&gt;n_poly;
-		if (m&lt;(start+n))
-			n=m-start;
-		px=x; 				 /*  movable pointer for x, later */
+		m = obj-&gt;n_poly;
+		if (m &lt; (start + n))
+			n = m - start;
+		px = x;    /*  movable pointer for x, later */
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_load_poly_texc()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_load_poly_texc()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 
 		if (obj-&gt;dplist) {
-			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-			glDeleteLists(obj-&gt;dplist,1);
-			obj-&gt;dplist=0;
+			s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+			glDeleteLists(obj-&gt;dplist, 1);
+			obj-&gt;dplist = 0;
 		}
-		for (i=start;i&lt;(start+n);i++) {
-			for (j=0;j&lt;3;j++) {
-				obj-&gt;p_poly[i].tc[j].x=*(px++);
-				obj-&gt;p_poly[i].tc[j].y=*(px++);
+		for (i = start;i &lt; (start + n);i++) {
+			for (j = 0;j &lt; 3;j++) {
+				obj-&gt;p_poly[i].tc[j].x = *(px++);
+				obj-&gt;p_poly[i].tc[j].y = *(px++);
 			}
 		}
 	} else
@@ -739,98 +739,98 @@
 /*  load at position start n materials, overwriting old ones */
 int obj_load_mat(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (start &lt; 0) return(-1);
-		m=obj-&gt;n_mat;
-		if (m&lt;(start+n))
-			n=m-start;
-		px=x; 				 /*  movable pointer for x, later */
+		m = obj-&gt;n_mat;
+		if (m &lt; (start + n))
+			n = m - start;
+		px = x;    /*  movable pointer for x, later */
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_pep_mat()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_pep_mat()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
 		if (obj-&gt;dplist) {
-			s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-			glDeleteLists(obj-&gt;dplist,1);
-			obj-&gt;dplist=0;
+			s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+			glDeleteLists(obj-&gt;dplist, 1);
+			obj-&gt;dplist = 0;
 		}
-		s3dprintf(MED,&quot;pepping %d mats, starting at %d&quot;,n,start);
-		for (i=start;i&lt;(start+n);i++) {
-			obj-&gt;p_mat[i].amb_r=*(px++);
-			obj-&gt;p_mat[i].amb_g=*(px++);
-			obj-&gt;p_mat[i].amb_b=*(px++);
-			obj-&gt;p_mat[i].amb_a=*(px++);
-			obj-&gt;p_mat[i].spec_r=*(px++);
-			obj-&gt;p_mat[i].spec_g=*(px++);
-			obj-&gt;p_mat[i].spec_b=*(px++);
-			obj-&gt;p_mat[i].spec_a=*(px++);
-			obj-&gt;p_mat[i].diff_r=*(px++);
-			obj-&gt;p_mat[i].diff_g=*(px++);
-			obj-&gt;p_mat[i].diff_b=*(px++);
-			obj-&gt;p_mat[i].diff_a=*(px++);
+		s3dprintf(MED, &quot;pepping %d mats, starting at %d&quot;, n, start);
+		for (i = start;i &lt; (start + n);i++) {
+			obj-&gt;p_mat[i].amb_r = *(px++);
+			obj-&gt;p_mat[i].amb_g = *(px++);
+			obj-&gt;p_mat[i].amb_b = *(px++);
+			obj-&gt;p_mat[i].amb_a = *(px++);
+			obj-&gt;p_mat[i].spec_r = *(px++);
+			obj-&gt;p_mat[i].spec_g = *(px++);
+			obj-&gt;p_mat[i].spec_b = *(px++);
+			obj-&gt;p_mat[i].spec_a = *(px++);
+			obj-&gt;p_mat[i].diff_r = *(px++);
+			obj-&gt;p_mat[i].diff_g = *(px++);
+			obj-&gt;p_mat[i].diff_b = *(px++);
+			obj-&gt;p_mat[i].diff_a = *(px++);
 		}
 	} else
 		return(-1);
 	return(0);
 }
 /* the interal texture updating function ... this is for opengl*/
-static void obj_update_tex(struct t_tex *tex,u_int16_t S3DUNUSED(x),u_int16_t S3DUNUSED(y),u_int16_t S3DUNUSED(w),u_int16_t S3DUNUSED(h),u_int8_t *S3DUNUSED(pixbuf))
+static void obj_update_tex(struct t_tex *tex, u_int16_t S3DUNUSED(x), u_int16_t S3DUNUSED(y), u_int16_t S3DUNUSED(w), u_int16_t S3DUNUSED(h), u_int8_t *S3DUNUSED(pixbuf))
 {
 	GLuint t;
-	if ((tex-&gt;gl_texnum)!=-1) {
-		t= tex-&gt;gl_texnum;
+	if ((tex-&gt;gl_texnum) != -1) {
+		t = tex-&gt;gl_texnum;
 		/* s3dprintf(MED,&quot;updating texture %d at [%d %d] with a [%d %d] pixbuf&quot;,t,x,y,w,h); */
-		/* 		glTexSubImage2D(t,0,x,y,w,h,GL_RGBA,GL_UNSIGNED_BYTE,pixbuf); */
+		/*   glTexSubImage2D(t,0,x,y,w,h,GL_RGBA,GL_UNSIGNED_BYTE,pixbuf); */
 
-		glDeleteTextures(1,&amp;t);
-		tex-&gt;gl_texnum=-1;
+		glDeleteTextures(1, &amp;t);
+		tex-&gt;gl_texnum = -1;
 	}
 }
 /*  loads some data into the pixbuf */
-int obj_load_tex		(struct t_process *p, int32_t oid, int32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf)
+int obj_load_tex(struct t_process *p, int32_t oid, int32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf)
 {
 	struct t_obj *obj;
 	struct t_tex *t;
-	int32_t i,p1,p2,m;
+	int32_t i, p1, p2, m;
 	int16_t mw;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_load_tex()&quot;,&quot;error: no data on object allowed!&quot;);
+			errds(MED, &quot;obj_load_tex()&quot;, &quot;error: no data on object allowed!&quot;);
 			return(-1);
 		}
-		if ( tex &lt; 0 ) return(-1);
-		if ( tex &lt; obj-&gt;n_tex) {
-			t=&amp;obj-&gt;p_tex[tex];
-			if (t-&gt;buf!=NULL) {
+		if (tex &lt; 0) return(-1);
+		if (tex &lt; obj-&gt;n_tex) {
+			t = &amp;obj-&gt;p_tex[tex];
+			if (t-&gt;buf != NULL) {
 				if (obj-&gt;dplist) {
-					s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-					glDeleteLists(obj-&gt;dplist,1);
-					obj-&gt;dplist=0;
+					s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+					glDeleteLists(obj-&gt;dplist, 1);
+					obj-&gt;dplist = 0;
 				}
 
-				m=(t-&gt;w-1)*t-&gt;th+t-&gt;tw; 			 /*  maximum: position of the last pixel in the buffer */
-				if ((x+w)&gt;t-&gt;tw) mw=(t-&gt;tw-x);
-				else mw=w;
-				if (mw&lt;=0)	 /*  nothing to do */
+				m = (t-&gt;w - 1) * t-&gt;th + t-&gt;tw;     /*  maximum: position of the last pixel in the buffer */
+				if ((x + w) &gt; t-&gt;tw) mw = (t-&gt;tw - x);
+				else mw = w;
+				if (mw &lt;= 0)  /*  nothing to do */
 					return(-1);
-				for (i=0;i&lt;h;i++) {
-					p1=(y+i)*t-&gt;w+x;  /*  scanline start position */
-					p2=mw;			 /*  and length */
-					if (p1&gt;m)
+				for (i = 0;i &lt; h;i++) {
+					p1 = (y + i) * t-&gt;w + x;  /*  scanline start position */
+					p2 = mw;  /*  and length */
+					if (p1 &gt; m)
 						return(0);   /*  need to break here. */
-					if ((p1+w)&gt;m)
-						p2=m-p1;	 /*  only draw a part of the scanline */
-					memcpy(	t-&gt;buf+	4*p1,			 /*  draw at p1 position ... */
-					        pixbuf+	4*i*w,			 /*  scanline number i ... */
-					        4*p2);
+					if ((p1 + w) &gt; m)
+						p2 = m - p1;  /*  only draw a part of the scanline */
+					memcpy(t-&gt;buf + 4*p1,    /*  draw at p1 position ... */
+					       pixbuf + 4*i*w,   /*  scanline number i ... */
+					       4*p2);
 				}
-				obj_update_tex(t,x,y,w,h,pixbuf);
+				obj_update_tex(t, x, y, w, h, pixbuf);
 				return(0);
 			} else {
-				errds(HIGH,&quot;obj_load_tex()&quot;,&quot;no buffer to draw to in oid %d, texture %d&quot;,oid,tex);
+				errds(HIGH, &quot;obj_load_tex()&quot;, &quot;no buffer to draw to in oid %d, texture %d&quot;, oid, tex);
 			}
 		}
 	}
@@ -841,22 +841,22 @@
 	struct t_obj *obj;
 	uint32_t f;
 
-	f=flags&amp;OF_MASK;
-	if (OBJ_VALID(p,oid,obj)) {
+	f = flags &amp; OF_MASK;
+	if (OBJ_VALID(p, oid, obj)) {
 		switch (type) {
 		case OF_TURN_ON:
-			obj-&gt;oflags|=f;
+			obj-&gt;oflags |= f;
 			break;
 		case OF_TURN_OFF:
-			obj-&gt;oflags&amp;=~f;
+			obj-&gt;oflags &amp;= ~f;
 			break;
 		case OF_TURN_SWAP:
-			obj-&gt;oflags^=f;
+			obj-&gt;oflags ^= f;
 			break;
 		default:
 			return(-1);
 		}
-		/* 		s3dprintf(VLOW,&quot;toggled %d-&gt;oflags=%010x with %010x [%d]&quot;,oid,obj-&gt;oflags,flags,type); */
+		/*   s3dprintf(VLOW,&quot;toggled %d-&gt;oflags=%010x with %010x [%d]&quot;,oid,obj-&gt;oflags,flags,type); */
 	}
 	return(0);
 }
@@ -866,31 +866,31 @@
 	int32_t m;
 	struct t_vertex *p_vertex;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_del_vertex()&quot;,&quot;error: can't delete vertices in this object!&quot;);
+			errds(MED, &quot;obj_del_vertex()&quot;, &quot;error: can't delete vertices in this object!&quot;);
 			return(-1);
 		}
 
-		s3dprintf(VLOW,&quot;deleting %d vertices of pid %d/ oid %d&quot;,n,p-&gt;id,oid);
-		m=obj-&gt;n_vertex;	 /*  saving the first number of vertices */
-		if (n&gt;=m) {
-			if (m&gt;0)
+		s3dprintf(VLOW, &quot;deleting %d vertices of pid %d/ oid %d&quot;, n, p-&gt;id, oid);
+		m = obj-&gt;n_vertex;  /*  saving the first number of vertices */
+		if (n &gt;= m) {
+			if (m &gt; 0)
 				free(obj-&gt;p_vertex);
-			obj-&gt;n_vertex=0;
-			obj-&gt;p_vertex=NULL;
-		} else if (n&gt;0) {
-			if (NULL!=(p_vertex=realloc(obj-&gt;p_vertex,sizeof(struct t_vertex) * ( m - n)))) {
+			obj-&gt;n_vertex = 0;
+			obj-&gt;p_vertex = NULL;
+		} else if (n &gt; 0) {
+			if (NULL != (p_vertex = realloc(obj-&gt;p_vertex, sizeof(struct t_vertex) * (m - n)))) {
 				if (obj-&gt;dplist) {
-					s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-					glDeleteLists(obj-&gt;dplist,1);
-					obj-&gt;dplist=0;
+					s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+					glDeleteLists(obj-&gt;dplist, 1);
+					obj-&gt;dplist = 0;
 				}
-				obj-&gt;p_vertex=p_vertex;
-				obj-&gt;n_vertex-=n;
+				obj-&gt;p_vertex = p_vertex;
+				obj-&gt;n_vertex -= n;
 			}
 		}
-		obj_size_update(p,oid);
+		obj_size_update(p, oid);
 	} else {
 		return(-1);
 	}
@@ -902,28 +902,28 @@
 	int32_t m;
 	struct t_mat *p_mat;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_del_mat()&quot;,&quot;error: can't delete materials in this object!&quot;);
+			errds(MED, &quot;obj_del_mat()&quot;, &quot;error: can't delete materials in this object!&quot;);
 			return(-1);
 		}
 
-		s3dprintf(VLOW,&quot;deleting %d materials of pid %d/ oid %d&quot;,n,p-&gt;id,oid);
-		m=obj-&gt;n_mat;	 /*  saving the first number of materials */
-		if (n&gt;=m) {
-			if (m&gt;0)
+		s3dprintf(VLOW, &quot;deleting %d materials of pid %d/ oid %d&quot;, n, p-&gt;id, oid);
+		m = obj-&gt;n_mat;  /*  saving the first number of materials */
+		if (n &gt;= m) {
+			if (m &gt; 0)
 				free(obj-&gt;p_mat);
-			obj-&gt;n_mat=0;
-			obj-&gt;p_mat=NULL;
-		} else if (n&gt;0)
-			if (NULL!=(p_mat=realloc(obj-&gt;p_mat,sizeof(struct t_mat) * ( m - n)))) {
+			obj-&gt;n_mat = 0;
+			obj-&gt;p_mat = NULL;
+		} else if (n &gt; 0)
+			if (NULL != (p_mat = realloc(obj-&gt;p_mat, sizeof(struct t_mat) * (m - n)))) {
 				if (obj-&gt;dplist) {
-					s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-					glDeleteLists(obj-&gt;dplist,1);
-					obj-&gt;dplist=0;
+					s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+					glDeleteLists(obj-&gt;dplist, 1);
+					obj-&gt;dplist = 0;
 				}
-				obj-&gt;p_mat=p_mat;
-				obj-&gt;n_mat-=n;
+				obj-&gt;p_mat = p_mat;
+				obj-&gt;n_mat -= n;
 			}
 	} else
 		return(-1);
@@ -935,28 +935,28 @@
 	int32_t m;
 	struct t_poly *p_poly;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_del_poly()&quot;,&quot;error: can't delete poly in this object!&quot;);
+			errds(MED, &quot;obj_del_poly()&quot;, &quot;error: can't delete poly in this object!&quot;);
 			return(-1);
 		}
 
-		s3dprintf(VLOW,&quot;deleting %d polys of pid %d/ oid %d&quot;,n,p-&gt;id,oid);
-		m=obj-&gt;n_poly;	 /*  saving the first number of poly  */
-		if (n&gt;=m) {
-			if (m&gt;0)
+		s3dprintf(VLOW, &quot;deleting %d polys of pid %d/ oid %d&quot;, n, p-&gt;id, oid);
+		m = obj-&gt;n_poly;  /*  saving the first number of poly  */
+		if (n &gt;= m) {
+			if (m &gt; 0)
 				free(obj-&gt;p_poly);
-			obj-&gt;n_poly=0;
-			obj-&gt;p_poly=NULL;
-		} else if (n&gt;0)
-			if (NULL!=(p_poly=realloc(obj-&gt;p_poly,sizeof(struct t_poly) * ( m - n)))) {
+			obj-&gt;n_poly = 0;
+			obj-&gt;p_poly = NULL;
+		} else if (n &gt; 0)
+			if (NULL != (p_poly = realloc(obj-&gt;p_poly, sizeof(struct t_poly) * (m - n)))) {
 				if (obj-&gt;dplist) {
-					s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-					glDeleteLists(obj-&gt;dplist,1);
-					obj-&gt;dplist=0;
+					s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+					glDeleteLists(obj-&gt;dplist, 1);
+					obj-&gt;dplist = 0;
 				}
-				obj-&gt;p_poly=p_poly;
-				obj-&gt;n_poly-=n;
+				obj-&gt;p_poly = p_poly;
+				obj-&gt;n_poly -= n;
 			}
 	} else
 		return(-1);
@@ -968,28 +968,28 @@
 	int32_t m;
 	struct t_line *p_line;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_del_line()&quot;,&quot;error: can't delete line in this object!&quot;);
+			errds(MED, &quot;obj_del_line()&quot;, &quot;error: can't delete line in this object!&quot;);
 			return(-1);
 		}
 
-		s3dprintf(VLOW,&quot;deleting %d lines of pid %d/ oid %d&quot;,n,p-&gt;id,oid);
-		m=obj-&gt;n_line;	 /*  saving the first number of line  */
-		if (n&gt;=m) {
-			if (m&gt;0)
+		s3dprintf(VLOW, &quot;deleting %d lines of pid %d/ oid %d&quot;, n, p-&gt;id, oid);
+		m = obj-&gt;n_line;  /*  saving the first number of line  */
+		if (n &gt;= m) {
+			if (m &gt; 0)
 				free(obj-&gt;p_line);
-			obj-&gt;n_line=0;
-			obj-&gt;p_line=NULL;
-		} else if (n&gt;0)
-			if (NULL!=(p_line=realloc(obj-&gt;p_line,sizeof(struct t_line) * ( m - n)))) {
+			obj-&gt;n_line = 0;
+			obj-&gt;p_line = NULL;
+		} else if (n &gt; 0)
+			if (NULL != (p_line = realloc(obj-&gt;p_line, sizeof(struct t_line) * (m - n)))) {
 				if (obj-&gt;dplist) {
-					s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-					glDeleteLists(obj-&gt;dplist,1);
-					obj-&gt;dplist=0;
+					s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+					glDeleteLists(obj-&gt;dplist, 1);
+					obj-&gt;dplist = 0;
 				}
-				obj-&gt;p_line=p_line;
-				obj-&gt;n_line-=n;
+				obj-&gt;p_line = p_line;
+				obj-&gt;n_line -= n;
 			}
 	} else
 		return(-1);
@@ -1003,45 +1003,45 @@
 	struct t_tex *p_tex;
 	struct t_obj *obj;
 	GLuint t;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj-&gt;oflags&amp;OF_NODATA) {
-			errds(MED,&quot;obj_del_tex()&quot;,&quot;error: can't delete textures in this object!&quot;);
+			errds(MED, &quot;obj_del_tex()&quot;, &quot;error: can't delete textures in this object!&quot;);
 			return(-1);
 		}
 
-		s3dprintf(VLOW,&quot;deleting %d textures of pid %d/ oid %d&quot;,n,p-&gt;id,oid);
-		m=obj-&gt;n_tex;	 /*  saving the first number of textures  */
-		if (n&gt;=m) {
-			for (i=0;i&lt;m;i++) {
-				if ((obj-&gt;p_tex[i].buf)!=NULL)
+		s3dprintf(VLOW, &quot;deleting %d textures of pid %d/ oid %d&quot;, n, p-&gt;id, oid);
+		m = obj-&gt;n_tex;  /*  saving the first number of textures  */
+		if (n &gt;= m) {
+			for (i = 0;i &lt; m;i++) {
+				if ((obj-&gt;p_tex[i].buf) != NULL)
 					free(obj-&gt;p_tex[i].buf);
 				if (obj-&gt;p_tex[i].gl_texnum) {
-					t=obj-&gt;p_tex[i].gl_texnum;
-					glDeleteTextures(1,&amp;t);
+					t = obj-&gt;p_tex[i].gl_texnum;
+					glDeleteTextures(1, &amp;t);
 				}
 			}
-			if (m&gt;0)
+			if (m &gt; 0)
 				free(obj-&gt;p_tex);
-			obj-&gt;n_tex=0;
-			obj-&gt;p_tex=NULL;
-		} else if (n&gt;0) {
-			for (i=(m-n);i&lt;m;i++) {
-				if (obj-&gt;p_tex[i].buf!=NULL)
+			obj-&gt;n_tex = 0;
+			obj-&gt;p_tex = NULL;
+		} else if (n &gt; 0) {
+			for (i = (m - n);i &lt; m;i++) {
+				if (obj-&gt;p_tex[i].buf != NULL)
 					free(obj-&gt;p_tex[i].buf);
 				if (obj-&gt;p_tex[i].gl_texnum) {
-					t=obj-&gt;p_tex[i].gl_texnum;
-					glDeleteTextures(1,&amp;t);
+					t = obj-&gt;p_tex[i].gl_texnum;
+					glDeleteTextures(1, &amp;t);
 				}
 
 			}
-			if (NULL!=(p_tex=realloc(obj-&gt;p_tex,sizeof(struct t_tex) * ( m - n)))) {
+			if (NULL != (p_tex = realloc(obj-&gt;p_tex, sizeof(struct t_tex) * (m - n)))) {
 				if (obj-&gt;dplist) {
-					s3dprintf(VLOW,&quot;freeing display list %d to get new data&quot;,obj-&gt;dplist);
-					glDeleteLists(obj-&gt;dplist,1);
-					obj-&gt;dplist=0;
+					s3dprintf(VLOW, &quot;freeing display list %d to get new data&quot;, obj-&gt;dplist);
+					glDeleteLists(obj-&gt;dplist, 1);
+					obj-&gt;dplist = 0;
 				}
-				obj-&gt;p_tex=p_tex;
-				obj-&gt;n_tex=n;
+				obj-&gt;p_tex = p_tex;
+				obj-&gt;n_tex = n;
 			}
 		}
 	} else
@@ -1053,32 +1053,32 @@
 int obj_translate(struct t_process *p, int32_t oid, float *transv)
 {
 	struct t_obj *obj;
-	struct t_process *mcp_p=get_proc_by_pid(MCP);
+	struct t_process *mcp_p = get_proc_by_pid(MCP);
 	float v[3];
-	if (OBJ_VALID(p,oid,obj)) {
-		if (isnan(transv[0])||isinf(transv[0])) return(-1);
-		if (isnan(transv[1])||isinf(transv[1])) return(-1);
-		if (isnan(transv[2])||isinf(transv[2])) return(-1);
-		if ((p-&gt;id!=MCP) &amp;&amp; (obj-&gt;oflags&amp;OF_SYSTEM)) {
-			if (focus_oid==p-&gt;mcp_oid) {
-				v[0]=transv[0];
-				v[1]=transv[1];
-				v[2]=transv[2];
+	if (OBJ_VALID(p, oid, obj)) {
+		if (isnan(transv[0]) || isinf(transv[0])) return(-1);
+		if (isnan(transv[1]) || isinf(transv[1])) return(-1);
+		if (isnan(transv[2]) || isinf(transv[2])) return(-1);
+		if ((p-&gt;id != MCP) &amp;&amp; (obj-&gt;oflags&amp;OF_SYSTEM)) {
+			if (focus_oid == p-&gt;mcp_oid) {
+				v[0] = transv[0];
+				v[1] = transv[1];
+				v[2] = transv[2];
 				mySetMatrix(mcp_p-&gt;object[p-&gt;mcp_oid]-&gt;m);
 				myTransform3f(v);
-				/*				mySetMatrix(mcp_p-&gt;object[oid]-&gt;m);
-								myInvert();
-								myTransform3f(v);
-								s3dprintf(LOW,&quot;%3.3f %3.3f %3.3f&quot;,v[0],v[1],v[2]);*/
-				obj_translate(mcp_p,oid,v);
+				/*    mySetMatrix(mcp_p-&gt;object[oid]-&gt;m);
+				    myInvert();
+				    myTransform3f(v);
+				    s3dprintf(LOW,&quot;%3.3f %3.3f %3.3f&quot;,v[0],v[1],v[2]);*/
+				obj_translate(mcp_p, oid, v);
 			}
 		} else {
-			obj-&gt;translate.x=*transv;
-			obj-&gt;translate.y=*(transv+1);
-			obj-&gt;translate.z=*(transv+2);
-			obj_pos_update(p,oid,oid);
+			obj-&gt;translate.x = *transv;
+			obj-&gt;translate.y = *(transv + 1);
+			obj-&gt;translate.z = *(transv + 2);
+			obj_pos_update(p, oid, oid);
 		}
-		s3dprintf(VLOW,&quot;[translate|pid %d] %d: %3.3f %3.3f %3.3f&quot;,p-&gt;id,oid,obj-&gt;translate.x,obj-&gt;translate.y,obj-&gt;translate.z);
+		s3dprintf(VLOW, &quot;[translate|pid %d] %d: %3.3f %3.3f %3.3f&quot;, p-&gt;id, oid, obj-&gt;translate.x, obj-&gt;translate.y, obj-&gt;translate.z);
 	}
 	return(0);
 }
@@ -1086,36 +1086,36 @@
 int obj_rotate(struct t_process *p, int32_t oid, float *rotv)
 {
 	struct t_obj *obj;
-	struct t_process *mcp_p=get_proc_by_pid(MCP);
+	struct t_process *mcp_p = get_proc_by_pid(MCP);
 	float v[3];
 	float f;
-	if (OBJ_VALID(p,oid,obj)) {
-		if (isnan(rotv[0])||isinf(rotv[0])) return(-1);
-		if (isnan(rotv[1])||isinf(rotv[1])) return(-1);
-		if (isnan(rotv[2])||isinf(rotv[2])) return(-1);
-		if ((p-&gt;id!=MCP) &amp;&amp; (obj-&gt;oflags&amp;OF_SYSTEM)) {
-			if (focus_oid==p-&gt;mcp_oid) {
-				v[0]=obj-&gt;rotate.x + (rotv[0] - obj-&gt;rotate.x);
-				v[1]=obj-&gt;rotate.y + (rotv[1] - obj-&gt;rotate.y);
-				v[2]=obj-&gt;rotate.z + (rotv[2] - obj-&gt;rotate.z);
-				obj_rotate(mcp_p,oid,v);
+	if (OBJ_VALID(p, oid, obj)) {
+		if (isnan(rotv[0]) || isinf(rotv[0])) return(-1);
+		if (isnan(rotv[1]) || isinf(rotv[1])) return(-1);
+		if (isnan(rotv[2]) || isinf(rotv[2])) return(-1);
+		if ((p-&gt;id != MCP) &amp;&amp; (obj-&gt;oflags&amp;OF_SYSTEM)) {
+			if (focus_oid == p-&gt;mcp_oid) {
+				v[0] = obj-&gt;rotate.x + (rotv[0] - obj-&gt;rotate.x);
+				v[1] = obj-&gt;rotate.y + (rotv[1] - obj-&gt;rotate.y);
+				v[2] = obj-&gt;rotate.z + (rotv[2] - obj-&gt;rotate.z);
+				obj_rotate(mcp_p, oid, v);
 			}
 		} else {
-			f=*rotv;
-			if (f&lt;0.0)		f+=(float)((int)-f/360)*360;
-			if (f&gt;360.0)	f+=(float)((int)f/360)*-360;
-			obj-&gt;rotate.x=f;
-			f=*(rotv+1);
-			if (f&lt;0.0)		f+=(float)((int)-f/360)*360;
-			if (f&gt;360.0)	f+=(float)((int)f/360)*-360;
-			obj-&gt;rotate.y=f;
-			f=*(rotv+2);
-			if (f&lt;0.0)		f+=(float)((int)-f/360)*360;
-			if (f&gt;360.0)	f+=(float)((int)f/360)*-360;
-			obj-&gt;rotate.z=f;
-			obj_pos_update(p,oid,oid);
+			f = *rotv;
+			if (f &lt; 0.0)  f += (float)((int) - f / 360) * 360;
+			if (f &gt; 360.0) f += (float)((int)f / 360) * -360;
+			obj-&gt;rotate.x = f;
+			f = *(rotv + 1);
+			if (f &lt; 0.0)  f += (float)((int) - f / 360) * 360;
+			if (f &gt; 360.0) f += (float)((int)f / 360) * -360;
+			obj-&gt;rotate.y = f;
+			f = *(rotv + 2);
+			if (f &lt; 0.0)  f += (float)((int) - f / 360) * 360;
+			if (f &gt; 360.0) f += (float)((int)f / 360) * -360;
+			obj-&gt;rotate.z = f;
+			obj_pos_update(p, oid, oid);
 		}
-		s3dprintf(VLOW,&quot;[rotate|pid %d] %d: %3.3f %3.3f %3.3f&quot;,p-&gt;id,oid,obj-&gt;rotate.x,obj-&gt;rotate.y,obj-&gt;rotate.z);
+		s3dprintf(VLOW, &quot;[rotate|pid %d] %d: %3.3f %3.3f %3.3f&quot;, p-&gt;id, oid, obj-&gt;rotate.x, obj-&gt;rotate.y, obj-&gt;rotate.z);
 	}
 	return(0);
 }
@@ -1123,16 +1123,16 @@
 int obj_scale(struct t_process *p, int32_t oid, float scav)
 {
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj)) {
-		if ((p-&gt;id==MCP) || (!(obj-&gt;oflags&amp;OF_SYSTEM)))
-			if (!isinf(scav) &amp;&amp; !isnan(scav) &amp;&amp; !((scav&lt;1.0e-10) &amp;&amp; (scav&gt;-1.0e-10))) { /* ignore very low values */
-				s3dprintf(VLOW,&quot;[scale|pid %d] obj %d to %f&quot;,p-&gt;id,oid,scav);
-				obj-&gt;scale=scav;
-				/*		obj-&gt;scale.x=*scav;
-						obj-&gt;scale.y=*(scav+1);
-						obj-&gt;scale.z=*(scav+2);*/
-				obj_size_update(p,oid);
-				obj_pos_update(p,oid,oid);
+	if (OBJ_VALID(p, oid, obj)) {
+		if ((p-&gt;id == MCP) || (!(obj-&gt;oflags&amp;OF_SYSTEM)))
+			if (!isinf(scav) &amp;&amp; !isnan(scav) &amp;&amp; !((scav &lt; 1.0e-10) &amp;&amp; (scav &gt; -1.0e-10))) { /* ignore very low values */
+				s3dprintf(VLOW, &quot;[scale|pid %d] obj %d to %f&quot;, p-&gt;id, oid, scav);
+				obj-&gt;scale = scav;
+				/*  obj-&gt;scale.x=*scav;
+				  obj-&gt;scale.y=*(scav+1);
+				  obj-&gt;scale.z=*(scav+2);*/
+				obj_size_update(p, oid);
+				obj_pos_update(p, oid, oid);
 			}
 	}
 	return(0);
@@ -1141,70 +1141,70 @@
 void into_position(struct t_process *p, struct t_obj *obj, int depth)
 {
 	struct t_obj *on;
-	if ((obj-&gt;oflags&amp;OF_LINK) &amp;&amp; (depth&lt;p-&gt;n_obj)) {
+	if ((obj-&gt;oflags&amp;OF_LINK) &amp;&amp; (depth &lt; p-&gt;n_obj)) {
 		/* TODO: only MultMatrix if m_uptodate ?! */
-		if (OBJ_VALID(p,obj-&gt;linkid,on)) {
-			into_position(p,on,depth+1);
+		if (OBJ_VALID(p, obj-&gt;linkid, on)) {
+			into_position(p, on, depth + 1);
 		} else {
-			obj-&gt;oflags&amp;=~OF_LINK;
-			s3dprintf(LOW,&quot;link object is broken, removing link&quot;);
+			obj-&gt;oflags &amp;= ~OF_LINK;
+			s3dprintf(LOW, &quot;link object is broken, removing link&quot;);
 		}
 	}
 	/* if (depth&gt;=MAXLOOP) */
-	if (depth&gt;=p-&gt;n_obj)
-		s3dprintf(MED,&quot;too much looping ...&quot;);
-	glTranslatef(obj-&gt;translate.x,obj-&gt;translate.y,obj-&gt;translate.z);
-	glRotatef(obj-&gt;rotate.y,0.0,1.0,0.0);
-	glRotatef(obj-&gt;rotate.x,1.0,0.0,0.0);
-	glRotatef(obj-&gt;rotate.z,0.0,0.0,1.0);
-	/*	glScalef(obj-&gt;scale.x,obj-&gt;scale.y,obj-&gt;scale.z);*/
-	glScalef(obj-&gt;scale,obj-&gt;scale,obj-&gt;scale);
+	if (depth &gt;= p-&gt;n_obj)
+		s3dprintf(MED, &quot;too much looping ...&quot;);
+	glTranslatef(obj-&gt;translate.x, obj-&gt;translate.y, obj-&gt;translate.z);
+	glRotatef(obj-&gt;rotate.y, 0.0, 1.0, 0.0);
+	glRotatef(obj-&gt;rotate.x, 1.0, 0.0, 0.0);
+	glRotatef(obj-&gt;rotate.z, 0.0, 0.0, 1.0);
+	/* glScalef(obj-&gt;scale.x,obj-&gt;scale.y,obj-&gt;scale.z);*/
+	glScalef(obj-&gt;scale, obj-&gt;scale, obj-&gt;scale);
 }
 
 void obj_size_update(struct t_process *p, int32_t oid)
 {
-	struct t_obj *o,*o2;
-	struct t_vertex *a,*vp;
+	struct t_obj *o, *o2;
+	struct t_vertex *a, *vp;
 	float r;
-	int vn,is_clnsrc;
+	int vn, is_clnsrc;
 	int32_t i;
-	if (p-&gt;id==MCP) return; /*  mcp does not need that. */
-	if (OBJ_VALID(p,oid,o)) {
+	if (p-&gt;id == MCP) return; /*  mcp does not need that. */
+	if (OBJ_VALID(p, oid, o)) {
 		if (o-&gt;oflags&amp;OF_SYSTEM) {
-			o-&gt;r=o-&gt;or=0; /* we don't care about system objects */
+			o-&gt;r = o-&gt;or = 0; /* we don't care about system objects */
 			return;
 		}
-		vp=o-&gt;p_vertex;
-		vn=o-&gt;n_vertex;
+		vp = o-&gt;p_vertex;
+		vn = o-&gt;n_vertex;
 		if (o-&gt;oflags&amp;OF_CLONE) {
-			o2=p-&gt;object[o-&gt;n_vertex];	 /*  get the target into o2*/
-			o-&gt;r= o2-&gt;r * (o-&gt;scale/o2-&gt;scale);
-			obj_check_biggest_object(p,oid);
+			o2 = p-&gt;object[o-&gt;n_vertex];  /*  get the target into o2*/
+			o-&gt;r = o2-&gt;r * (o-&gt;scale / o2-&gt;scale);
+			obj_check_biggest_object(p, oid);
 			return;
 		} else {
-			/* 			printf(MED,&quot;looking through vertices...&quot;); */
-			for (i=0;i&lt;vn;i++) {
-				a=&amp;(vp[i]);
-				r=o-&gt;scale * sqrt(
-				          (a-&gt;x  * a-&gt;x ) +
-				          (a-&gt;y  * a-&gt;y ) +
-				          (a-&gt;z  * a-&gt;z ));
-				if (r &gt; o-&gt;r) o-&gt;r=r;
+			/*    printf(MED,&quot;looking through vertices...&quot;); */
+			for (i = 0;i &lt; vn;i++) {
+				a = &amp;(vp[i]);
+				r = o-&gt;scale * sqrt(
+				            (a-&gt;x  * a-&gt;x) +
+				            (a-&gt;y  * a-&gt;y) +
+				            (a-&gt;z  * a-&gt;z));
+				if (r &gt; o-&gt;r) o-&gt;r = r;
 			}
-			obj_check_biggest_object(p,oid);
+			obj_check_biggest_object(p, oid);
 			if (p-&gt;object[oid]-&gt;oflags&amp;OF_CLONE_SRC) {
-				is_clnsrc=0;
-				for (i=0;i&lt;p-&gt;n_obj;i++) {
-					if (p-&gt;object[i]!=NULL) {
-						if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex== oid)) { /* if it's pointing to our object ... */
-							is_clnsrc=1;
-							p-&gt;object[i]-&gt;r=o-&gt;r*(p-&gt;object[i]-&gt;r/o-&gt;scale); /* give it the new radius too! */
-							obj_check_biggest_object(p,i);
+				is_clnsrc = 0;
+				for (i = 0;i &lt; p-&gt;n_obj;i++) {
+					if (p-&gt;object[i] != NULL) {
+						if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex == oid)) { /* if it's pointing to our object ... */
+							is_clnsrc = 1;
+							p-&gt;object[i]-&gt;r = o-&gt;r * (p-&gt;object[i]-&gt;r / o-&gt;scale); /* give it the new radius too! */
+							obj_check_biggest_object(p, i);
 						}
 					}
 				}
 				if (!is_clnsrc)
-					p-&gt;object[oid]-&gt;oflags&amp;=~OF_CLONE_SRC;
+					p-&gt;object[oid]-&gt;oflags &amp;= ~OF_CLONE_SRC;
 			}
 		}
 	}
@@ -1213,39 +1213,39 @@
 /*  is valid */
 void obj_check_biggest_object(struct t_process *p, int32_t oid)
 {
-	struct t_obj *o,*mcp_o;
+	struct t_obj *o, *mcp_o;
 	struct t_process *mcp_p;
-	float r,r2;
+	float r, r2;
 	int32_t i;
 	int found;
-	mcp_p=get_proc_by_pid(MCP);
-	mcp_o=mcp_p-&gt;object[p-&gt;mcp_oid];
-	o=p-&gt;object[oid];
+	mcp_p = get_proc_by_pid(MCP);
+	mcp_o = mcp_p-&gt;object[p-&gt;mcp_oid];
+	o = p-&gt;object[oid];
 	if (o-&gt;oflags&amp;OF_SYSTEM)
 		return; /* we don't care, system objects don't count. */
-	r=o-&gt;r+o-&gt;or;
-	if (r&gt;mcp_o-&gt;r) {	 /*  this is now the biggest object. */
-		mcp_o-&gt;r=r;
-		p-&gt;biggest_obj=oid;
-		/*		s3dprintf(MED,&quot;there is a new biggest object in [%d:\&quot;\&quot;]&quot;,p-&gt;id,p-&gt;name);*/
-		mcp_rep_object(p-&gt;mcp_oid);	  /*  and tell the mcp */
+	r = o-&gt;r + o-&gt;or;
+	if (r &gt; mcp_o-&gt;r) {  /*  this is now the biggest object. */
+		mcp_o-&gt;r = r;
+		p-&gt;biggest_obj = oid;
+		/*  s3dprintf(MED,&quot;there is a new biggest object in [%d:\&quot;\&quot;]&quot;,p-&gt;id,p-&gt;name);*/
+		mcp_rep_object(p-&gt;mcp_oid);   /*  and tell the mcp */
 	} else {
-		if (p-&gt;biggest_obj==oid) { /*  oid might now lose the status of the &quot;biggest object&quot;. let's check: */
-			found=0;
-			for (i=0;i&lt;p-&gt;n_obj;i++)
-				if (p-&gt;object[i]!=NULL) {
-					if ((r2=p-&gt;object[i]-&gt;r+p-&gt;object[i]-&gt;or)&gt;r) { /*  this object is bigger than the old biggest one. */
+		if (p-&gt;biggest_obj == oid) { /*  oid might now lose the status of the &quot;biggest object&quot;. let's check: */
+			found = 0;
+			for (i = 0;i &lt; p-&gt;n_obj;i++)
+				if (p-&gt;object[i] != NULL) {
+					if ((r2 = p-&gt;object[i]-&gt;r + p-&gt;object[i]-&gt;or) &gt; r) { /*  this object is bigger than the old biggest one. */
 						if (!(p-&gt;object[i]-&gt;oflags&amp;OF_SYSTEM)) {
-							p-&gt;biggest_obj=oid;
-							r=r2;
-							found=1;
+							p-&gt;biggest_obj = oid;
+							r = r2;
+							found = 1;
 						}
 					}
 				}
 			if (found) {
-				s3dprintf(VLOW,&quot;there is a new biggest object in [%d:\&quot;\&quot;]&quot;,p-&gt;id,p-&gt;name);
-				mcp_o-&gt;r=r;  /*  save the new size */
-				mcp_rep_object(p-&gt;mcp_oid);	  /*  and tell the mcp */
+				s3dprintf(VLOW, &quot;there is a new biggest object in [%d:\&quot;\&quot;]&quot;, p-&gt;id, p-&gt;name);
+				mcp_o-&gt;r = r;  /*  save the new size */
+				mcp_rep_object(p-&gt;mcp_oid);   /*  and tell the mcp */
 			}
 		}   /*  if it wasn't the biggest object, no one cares if it's smaller than process */
 		/*  radius */
@@ -1256,104 +1256,104 @@
 {
 	GLint matrixmode;
 	if (!p-&gt;object[oid]-&gt;m_uptodate) {
-		glGetIntegerv(GL_MATRIX_MODE,&amp;matrixmode); 		 /*  save matrixmode */
-		glMatrixMode(GL_MODELVIEW); 					 /*  go into modelview */
+		glGetIntegerv(GL_MATRIX_MODE, &amp;matrixmode);   /*  save matrixmode */
+		glMatrixMode(GL_MODELVIEW);       /*  go into modelview */
 		glPushMatrix();
 		glLoadIdentity();
-		into_position(p,p-&gt;object[oid],0);
-		glGetFloatv( GL_MODELVIEW_MATRIX, p-&gt;object[oid]-&gt;m );
+		into_position(p, p-&gt;object[oid], 0);
+		glGetFloatv(GL_MODELVIEW_MATRIX, p-&gt;object[oid]-&gt;m);
 		glPopMatrix();
 		glMatrixMode(matrixmode);
-		p-&gt;object[oid]-&gt;m_uptodate=1;
+		p-&gt;object[oid]-&gt;m_uptodate = 1;
 	}
 }
 void obj_sys_update(struct t_process *p, int32_t oid)
 {
-	struct t_process *mcp_p=get_proc_by_pid(MCP);
-	struct t_obj	 *o;
-	struct t_vertex	 fs,fa;
-	float 			 ss,sa,v[3];
-	fs.x=fs.y=fs.z=0.0F;
-	fa.x=fa.y=fa.z=0.0F;
-	sa=ss=1.0F;
+	struct t_process *mcp_p = get_proc_by_pid(MCP);
+	struct t_obj  *o;
+	struct t_vertex  fs, fa;
+	float     ss, sa, v[3];
+	fs.x = fs.y = fs.z = 0.0F;
+	fa.x = fa.y = fa.z = 0.0F;
+	sa = ss = 1.0F;
 	/* find the angel of the sys object */
-	o=mcp_p-&gt;object[oid];
-	while (o!=NULL) {
-		fs.x+=o-&gt;rotate.x;
-		fs.y+=o-&gt;rotate.y;
-		fs.z+=o-&gt;rotate.z;
-		ss*=o-&gt;scale;
+	o = mcp_p-&gt;object[oid];
+	while (o != NULL) {
+		fs.x += o-&gt;rotate.x;
+		fs.y += o-&gt;rotate.y;
+		fs.z += o-&gt;rotate.z;
+		ss *= o-&gt;scale;
 		if (o-&gt;oflags&amp;OF_LINK)
-			o=mcp_p-&gt;object[o-&gt;linkid];
-		else o=NULL;
+			o = mcp_p-&gt;object[o-&gt;linkid];
+		else o = NULL;
 	}
 	/* mov in the mcp space */
 	mySetMatrix(mcp_p-&gt;object[oid]-&gt;m);
-	v[0]=v[1]=v[2]=0.0;
+	v[0] = v[1] = v[2] = 0.0;
 	myTransform3f(v);
 
-	o=mcp_p-&gt;object[p-&gt;mcp_oid];
-	while (o!=NULL) {
-		fa.x+=o-&gt;rotate.x;
-		fa.y+=o-&gt;rotate.y;
-		fa.z+=o-&gt;rotate.z;
-		sa*=o-&gt;scale;
+	o = mcp_p-&gt;object[p-&gt;mcp_oid];
+	while (o != NULL) {
+		fa.x += o-&gt;rotate.x;
+		fa.y += o-&gt;rotate.y;
+		fa.z += o-&gt;rotate.z;
+		sa *= o-&gt;scale;
 		if (o-&gt;oflags&amp;OF_LINK)
-			o=mcp_p-&gt;object[o-&gt;linkid];
-		else o=NULL;
+			o = mcp_p-&gt;object[o-&gt;linkid];
+		else o = NULL;
 	}
 	/* reverse in the application space */
 	mySetMatrix(mcp_p-&gt;object[p-&gt;mcp_oid]-&gt;m);
 	if (myInvert()) return; /* we don't bother if the matrix doesn't work. */
 	myTransform3f(v);
 
-	p-&gt;object[oid]-&gt;rotate.x=fs.x-fa.x;
-	p-&gt;object[oid]-&gt;rotate.y=fs.y-fa.y;
-	p-&gt;object[oid]-&gt;rotate.z=fs.z-fa.z;
+	p-&gt;object[oid]-&gt;rotate.x = fs.x - fa.x;
+	p-&gt;object[oid]-&gt;rotate.y = fs.y - fa.y;
+	p-&gt;object[oid]-&gt;rotate.z = fs.z - fa.z;
 
-	p-&gt;object[oid]-&gt;translate.x=v[0];
-	p-&gt;object[oid]-&gt;translate.y=v[1];
-	p-&gt;object[oid]-&gt;translate.z=v[2];
+	p-&gt;object[oid]-&gt;translate.x = v[0];
+	p-&gt;object[oid]-&gt;translate.y = v[1];
+	p-&gt;object[oid]-&gt;translate.z = v[2];
 
-	p-&gt;object[oid]-&gt;scale=ss/sa;
+	p-&gt;object[oid]-&gt;scale = ss / sa;
 
-	/*	obj_debug(p,oid);*/
-	obj_pos_update(p,oid,oid); /* now also update the matrix and the objects linking to our sys-object ... */
+	/* obj_debug(p,oid);*/
+	obj_pos_update(p, oid, oid); /* now also update the matrix and the objects linking to our sys-object ... */
 }
 /*  recalculate the position of an object. this assumes that oid is valid. */
 void obj_pos_update(struct t_process *p, int32_t oid, int32_t first_oid)
 {
 	float v[3];
-	struct t_obj 		*ao,*o;
-	struct t_process	*ap;
-	o=p-&gt;object[oid];
-	s3dprintf(VLOW,&quot;[obj_pos_upd|pid %d] %d&quot;,p-&gt;id, oid,first_oid);
-	o-&gt;m_uptodate=0;
-	obj_recalc_tmat(p,oid);
-	if (p-&gt;id!=MCP) {/*  mcp does not need that. */
+	struct t_obj   *ao, *o;
+	struct t_process *ap;
+	o = p-&gt;object[oid];
+	s3dprintf(VLOW, &quot;[obj_pos_upd|pid %d] %d&quot;, p-&gt;id, oid, first_oid);
+	o-&gt;m_uptodate = 0;
+	obj_recalc_tmat(p, oid);
+	if (p-&gt;id != MCP) {/*  mcp does not need that. */
 		/*  save the matrixmode to reset it later on */
-		v[0]=v[1]=v[2]=0.0F;
+		v[0] = v[1] = v[2] = 0.0F;
 		mySetMatrix(o-&gt;m);
 		myTransform3f(v);
 		/*  and get it's destination point. phew */
-		o-&gt;or=sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
+		o-&gt;or = sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
 	} else
 		if (o-&gt;oflags&amp;OF_SYSTEM) /* TODO: what will we do if $sys_object is linked to another? */
 		{ /* a system object changed position? let's update the focus'ed sys-objects */
-			if (OBJ_VALID(p,focus_oid,ao))
-				if (NULL!=(ap=get_proc_by_pid(ao-&gt;n_mat))) {
-					if (OF_POINTER==(o-&gt;oflags&amp;0xF0000000)) { /* we dont have to do that much in this case ... */
-						if (OBJ_VALID(ap,get_pointer(ap),ao)) { /* we can redefine ao here -&gt; ao = focused app's pointer*/
-							ao-&gt;rotate.x=o-&gt;rotate.x;
-							ao-&gt;rotate.y=o-&gt;rotate.y;
-							ao-&gt;rotate.z=o-&gt;rotate.z;
-							ao-&gt;translate.x=o-&gt;translate.x;
-							ao-&gt;translate.y=o-&gt;translate.y;
-							ao-&gt;translate.z=o-&gt;translate.z; /* just copy */
-							obj_pos_update(ap,get_pointer(ap),get_pointer(ap));
+			if (OBJ_VALID(p, focus_oid, ao))
+				if (NULL != (ap = get_proc_by_pid(ao-&gt;n_mat))) {
+					if (OF_POINTER == (o-&gt;oflags&amp;0xF0000000)) { /* we dont have to do that much in this case ... */
+						if (OBJ_VALID(ap, get_pointer(ap), ao)) { /* we can redefine ao here -&gt; ao = focused app's pointer*/
+							ao-&gt;rotate.x = o-&gt;rotate.x;
+							ao-&gt;rotate.y = o-&gt;rotate.y;
+							ao-&gt;rotate.z = o-&gt;rotate.z;
+							ao-&gt;translate.x = o-&gt;translate.x;
+							ao-&gt;translate.y = o-&gt;translate.y;
+							ao-&gt;translate.z = o-&gt;translate.z; /* just copy */
+							obj_pos_update(ap, get_pointer(ap), get_pointer(ap));
 						}
 					} else {
-						obj_sys_update(ap,oid);
+						obj_sys_update(ap, oid);
 					}
 				}
 			switch (o-&gt;oflags&amp;0xF0000000) {
@@ -1364,57 +1364,57 @@
 				event_ptr_changed();
 				break;
 			default:
-				s3dprintf(LOW,&quot;[obj_pos_upd|pid %d] %d unknown system event&quot;,p-&gt;id,oid);
+				s3dprintf(LOW, &quot;[obj_pos_upd|pid %d] %d unknown system event&quot;, p-&gt;id, oid);
 
 			}
 
 		}
 	/* if it's the root (oid==first_oid), only go down */
 
-	if (o-&gt;lsub!=-1)						obj_pos_update(p,o-&gt;lsub,first_oid);
-	if ((o-&gt;lnext!=-1) &amp;&amp; (oid!=first_oid))	obj_pos_update(p,o-&gt;lnext,first_oid);
-	if (p-&gt;id!=MCP)
-		obj_check_biggest_object(p,oid);
+	if (o-&gt;lsub != -1)      obj_pos_update(p, o-&gt;lsub, first_oid);
+	if ((o-&gt;lnext != -1) &amp;&amp; (oid != first_oid)) obj_pos_update(p, o-&gt;lnext, first_oid);
+	if (p-&gt;id != MCP)
+		obj_check_biggest_object(p, oid);
 }
 /*  calculates the normal for one polygon, if not present. */
 int calc_normal(struct t_obj *obj, uint32_t pn)
 {
-	struct t_vertex a,b,n;
+	struct t_vertex a, b, n;
 	struct t_vertex *v[3];
-	int32_t vp,i;
+	int32_t vp, i;
 
 	float len;
-	for (i=0;i&lt;3;i++) { /*  set and check */
-		vp= obj-&gt;p_poly[pn].v[i];  /*  ... get the vertices ... */
-		if ( vp &lt; obj-&gt;n_vertex)
-			v[i]=&amp;(obj-&gt;p_vertex[vp]);
+	for (i = 0;i &lt; 3;i++) { /*  set and check */
+		vp = obj-&gt;p_poly[pn].v[i]; /*  ... get the vertices ... */
+		if (vp &lt; obj-&gt;n_vertex)
+			v[i] = &amp;(obj-&gt;p_vertex[vp]);
 		else return(-1);
 	}
 	/*  check for already set normal */
-	if ((obj-&gt;p_poly[pn].n[0].x*obj-&gt;p_poly[pn].n[0].x+
-	                obj-&gt;p_poly[pn].n[0].y*obj-&gt;p_poly[pn].n[0].y+
-	                obj-&gt;p_poly[pn].n[0].z*obj-&gt;p_poly[pn].n[0].z)==0) {/*  normal already defined? */
-		a.x=v[1]-&gt;x-v[0]-&gt;x;
-		a.y=v[1]-&gt;y-v[0]-&gt;y;
-		a.z=v[1]-&gt;z-v[0]-&gt;z;
-		b.x=v[2]-&gt;x-v[0]-&gt;x;
-		b.y=v[2]-&gt;y-v[0]-&gt;y;
-		b.z=v[2]-&gt;z-v[0]-&gt;z;
-		n.x=a.y*b.z - a.z*b.y;
-		n.y=a.z*b.x - a.x*b.z;
-		n.z=a.x*b.y - a.y*b.x;
+	if ((obj-&gt;p_poly[pn].n[0].x*obj-&gt;p_poly[pn].n[0].x +
+	                obj-&gt;p_poly[pn].n[0].y*obj-&gt;p_poly[pn].n[0].y +
+	                obj-&gt;p_poly[pn].n[0].z*obj-&gt;p_poly[pn].n[0].z) == 0) {/*  normal already defined? */
+		a.x = v[1]-&gt;x - v[0]-&gt;x;
+		a.y = v[1]-&gt;y - v[0]-&gt;y;
+		a.z = v[1]-&gt;z - v[0]-&gt;z;
+		b.x = v[2]-&gt;x - v[0]-&gt;x;
+		b.y = v[2]-&gt;y - v[0]-&gt;y;
+		b.z = v[2]-&gt;z - v[0]-&gt;z;
+		n.x = a.y * b.z - a.z * b.y;
+		n.y = a.z * b.x - a.x * b.z;
+		n.z = a.x * b.y - a.y * b.x;
 
-		len=sqrt(n.x*n.x+n.y*n.y+n.z*n.z);
-		if (len==0.0F) {
-			/* 		errds(VLOW,&quot;bad polygon (can't normalize ...)&quot;); */
+		len = sqrt(n.x * n.x + n.y * n.y + n.z * n.z);
+		if (len == 0.0F) {
+			/*   errds(VLOW,&quot;bad polygon (can't normalize ...)&quot;); */
 		} else {
-			n.x=n.x/len;
-			n.y=n.y/len;
-			n.z=n.z/len;
-			for (i=0;i&lt;3;i++) {
-				obj-&gt;p_poly[pn].n[i].x=n.x;
-				obj-&gt;p_poly[pn].n[i].y=n.y;
-				obj-&gt;p_poly[pn].n[i].z=n.z;
+			n.x = n.x / len;
+			n.y = n.y / len;
+			n.z = n.z / len;
+			for (i = 0;i &lt; 3;i++) {
+				obj-&gt;p_poly[pn].n[i].x = n.x;
+				obj-&gt;p_poly[pn].n[i].y = n.y;
+				obj-&gt;p_poly[pn].n[i].z = n.z;
 			}
 		}
 	}
@@ -1425,20 +1425,20 @@
 int check_line_normal(struct t_obj *obj, uint32_t pn)
 {
 	struct t_vertex *v[2];
-	int i,vp;
-	for (i=0;i&lt;2;i++) { /*  set and check */
-		vp= obj-&gt;p_line[pn].v[i];  /*  ... get the vertices ... */
+	int i, vp;
+	for (i = 0;i &lt; 2;i++) { /*  set and check */
+		vp = obj-&gt;p_line[pn].v[i]; /*  ... get the vertices ... */
 		if (vp &lt; (int)obj-&gt;n_vertex)
-			v[i]=&amp;(obj-&gt;p_vertex[vp]);
+			v[i] = &amp;(obj-&gt;p_vertex[vp]);
 		else return(-1);
 	}
-	if ((obj-&gt;p_line[pn].n[0].x*obj-&gt;p_line[pn].n[0].x+
-	                obj-&gt;p_line[pn].n[0].y*obj-&gt;p_line[pn].n[0].y+
-	                obj-&gt;p_line[pn].n[0].z*obj-&gt;p_line[pn].n[0].z)==0) { /* guess we have nothing set yet, so set something */
-		for (i=0;i&lt;2;i++) {
-			obj-&gt;p_line[pn].n[0].x=0;
-			obj-&gt;p_line[pn].n[0].y=0;
-			obj-&gt;p_line[pn].n[0].z=1;
+	if ((obj-&gt;p_line[pn].n[0].x*obj-&gt;p_line[pn].n[0].x +
+	                obj-&gt;p_line[pn].n[0].y*obj-&gt;p_line[pn].n[0].y +
+	                obj-&gt;p_line[pn].n[0].z*obj-&gt;p_line[pn].n[0].z) == 0) { /* guess we have nothing set yet, so set something */
+		for (i = 0;i &lt; 2;i++) {
+			obj-&gt;p_line[pn].n[0].x = 0;
+			obj-&gt;p_line[pn].n[0].y = 0;
+			obj-&gt;p_line[pn].n[0].z = 1;
 		}
 	}
 	return(0);
@@ -1446,40 +1446,40 @@
 }
 
 /* activate/bind texture for object */
-static struct t_tex *get_texture(struct t_obj *obj,struct t_mat *m) {
+static struct t_tex *get_texture(struct t_obj *obj, struct t_mat *m) {
 	GLuint t;
-	struct t_tex *tex=NULL;
+	struct t_tex *tex = NULL;
 	GLfloat matgl[4];
-	/* 	int i,j; */
+	/*  int i,j; */
 	if (m-&gt;tex &lt; obj-&gt;n_tex) {
-		tex=&amp;obj-&gt;p_tex[m-&gt;tex];
-		if (tex-&gt;buf!=NULL) { /*  texture seems to be okay, select it. */
-			matgl[0]=0.5f;
-			matgl[1]=0.5f;
-			matgl[2]=0.5f;
-			matgl[3]=1.0f;
-			glMaterialfv(GL_FRONT,GL_AMBIENT,matgl);
-			glMaterialfv(GL_FRONT,GL_DIFFUSE,matgl);
-			glMaterialfv(GL_FRONT,GL_SPECULAR,matgl);
-			if (tex-&gt;gl_texnum!=-1) {
-				glBindTexture( GL_TEXTURE_2D,tex-&gt;gl_texnum);
+		tex = &amp;obj-&gt;p_tex[m-&gt;tex];
+		if (tex-&gt;buf != NULL) { /*  texture seems to be okay, select it. */
+			matgl[0] = 0.5f;
+			matgl[1] = 0.5f;
+			matgl[2] = 0.5f;
+			matgl[3] = 1.0f;
+			glMaterialfv(GL_FRONT, GL_AMBIENT, matgl);
+			glMaterialfv(GL_FRONT, GL_DIFFUSE, matgl);
+			glMaterialfv(GL_FRONT, GL_SPECULAR, matgl);
+			if (tex-&gt;gl_texnum != -1) {
+				glBindTexture(GL_TEXTURE_2D, tex-&gt;gl_texnum);
 			} else {
-				glGenTextures(1,&amp;t);
-				glBindTexture( GL_TEXTURE_2D, t);
-				tex-&gt;gl_texnum=t;
-				s3dprintf(HIGH,&quot;generated texture %d [%dx%d, in memory %dx%d]&quot;,t,tex-&gt;tw,tex-&gt;th,tex-&gt;w,tex-&gt;h);
-				/*				for (j=0;j&lt;tex-&gt;th;j++)
-								for (i=0;i&lt;tex-&gt;tw;i++)
-								{
-									s3dprintf(MED,&quot;pixel[%d,%d], %d %d %d %d&quot;,i,j,
-													tex-&gt;buf[(j*tex-&gt;w+i)*4+0],
-													tex-&gt;buf[(j*tex-&gt;w+i)*4+1],
-													tex-&gt;buf[(j*tex-&gt;w+i)*4+2],
-													tex-&gt;buf[(j*tex-&gt;w+i)*4+3]);
-								}*/
-				glTexImage2D(	GL_TEXTURE_2D,0, GL_RGBA,
-				              tex-&gt;w,tex-&gt;h,0,  /*  no border. */
-				              GL_RGBA,GL_UNSIGNED_BYTE,tex-&gt;buf);
+				glGenTextures(1, &amp;t);
+				glBindTexture(GL_TEXTURE_2D, t);
+				tex-&gt;gl_texnum = t;
+				s3dprintf(HIGH, &quot;generated texture %d [%dx%d, in memory %dx%d]&quot;, t, tex-&gt;tw, tex-&gt;th, tex-&gt;w, tex-&gt;h);
+				/*    for (j=0;j&lt;tex-&gt;th;j++)
+				    for (i=0;i&lt;tex-&gt;tw;i++)
+				    {
+				     s3dprintf(MED,&quot;pixel[%d,%d], %d %d %d %d&quot;,i,j,
+				         tex-&gt;buf[(j*tex-&gt;w+i)*4+0],
+				         tex-&gt;buf[(j*tex-&gt;w+i)*4+1],
+				         tex-&gt;buf[(j*tex-&gt;w+i)*4+2],
+				         tex-&gt;buf[(j*tex-&gt;w+i)*4+3]);
+				    }*/
+				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
+				             tex-&gt;w, tex-&gt;h, 0,  /*  no border. */
+				             GL_RGBA, GL_UNSIGNED_BYTE, tex-&gt;buf);
 				/*  texture has to be generated yet ... */
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
@@ -1490,148 +1490,148 @@
 
 			}
 		} else { /* . can't use a texture  */
-			tex=NULL;
+			tex = NULL;
 		}
 	}
 	return(tex);
 }
 /*  finally, the rendering portion. */
-int obj_render(struct t_process *p,int32_t oid)
+int obj_render(struct t_process *p, int32_t oid)
 {
 	int32_t pn;
-	int32_t mat,omat=-1;
+	int32_t mat, omat = -1;
 	int32_t v;
-	/* 	int link_obj; */
+	/*  int link_obj; */
 	struct t_vertex *on;
 	struct t_obj *obj;
 	struct t_mat *m;
-	struct t_tex *tex=NULL;
+	struct t_tex *tex = NULL;
 	GLfloat matgl[4];
 	int32_t i;
 
-	obj=p-&gt;object[oid];
+	obj = p-&gt;object[oid];
 	glPushMatrix();
 	glMultMatrixf(obj-&gt;m);
-	/*	into_position(p,obj,0);*/
-	if (obj-&gt;oflags&amp;OF_SYSTEM)		return(-1); 					/* can't render system objects */
-	if (obj-&gt;oflags&amp;OF_CLONE)		obj=p-&gt;object[obj-&gt;n_vertex]; 	/* it's a clone - draw the clone! */
+	/* into_position(p,obj,0);*/
+	if (obj-&gt;oflags&amp;OF_SYSTEM)  return(-1);      /* can't render system objects */
+	if (obj-&gt;oflags&amp;OF_CLONE)  obj = p-&gt;object[obj-&gt;n_vertex];  /* it's a clone - draw the clone! */
 	if (!obj-&gt;dplist) {
-		obj-&gt;dplist=glGenLists(1);
-		if (obj-&gt;dplist)	glNewList(obj-&gt;dplist,GL_COMPILE); /* only compile and calling later should save time. maybe. */
-		else 				s3dprintf(LOW,&quot;couldn't get a new list :/&quot;);
-		omat=-1;
-		for (pn=0; pn&lt;obj-&gt;n_poly; pn++) { /*  cycle throu our polygons ... */
-			if (calc_normal(obj,pn)) {
-				s3dprintf(HIGH,&quot;something is wrong with polygon %d!&quot;,pn);
+		obj-&gt;dplist = glGenLists(1);
+		if (obj-&gt;dplist) glNewList(obj-&gt;dplist, GL_COMPILE); /* only compile and calling later should save time. maybe. */
+		else     s3dprintf(LOW, &quot;couldn't get a new list :/&quot;);
+		omat = -1;
+		for (pn = 0; pn &lt; obj-&gt;n_poly; pn++) { /*  cycle throu our polygons ... */
+			if (calc_normal(obj, pn)) {
+				s3dprintf(HIGH, &quot;something is wrong with polygon %d!&quot;, pn);
 				if (obj-&gt;dplist) glEndList();
 				glPopMatrix(); /* clean up GL-stuff */
 				return(-1);
 			}
-			/* 		glNormal3f(-n.x,-n.y,-n.z); */
-			mat= obj-&gt;p_poly[pn].mat;
-			if (mat!=omat) {
-				tex=NULL;
-				if (mat&lt; obj-&gt;n_mat) {
-					m=&amp;obj-&gt;p_mat[mat];
-					if (m-&gt;tex!=-1)		tex=get_texture(obj,m);
-					if (tex==NULL) {	/* still NULL? then it couldn't get the texture. */
-						/*						s3dprintf(VLOW,&quot;no texture, using standard material...&quot;);*/
-						glBindTexture( GL_TEXTURE_2D,0);
-						matgl[0]=m-&gt;amb_r/2;
-						matgl[1]=m-&gt;amb_g/2;
-						matgl[2]=m-&gt;amb_b/2;
-						matgl[3]=m-&gt;amb_a;
-						/* 				glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
-						glMaterialfv(GL_FRONT,GL_AMBIENT,matgl);
-						matgl[0]=m-&gt;diff_r/2;
-						matgl[1]=m-&gt;diff_g/2;
-						matgl[2]=m-&gt;diff_b/2;
-						matgl[3]=m-&gt;diff_a;
-						/* 				glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
-						glMaterialfv(GL_FRONT,GL_DIFFUSE,matgl);
-						matgl[0]=m-&gt;spec_r/2;
-						matgl[1]=m-&gt;spec_g/2;
-						matgl[2]=m-&gt;spec_b/2;
-						matgl[3]=m-&gt;spec_a;
-						/* 				glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
-						glMaterialfv(GL_FRONT,GL_SPECULAR,matgl);
+			/*   glNormal3f(-n.x,-n.y,-n.z); */
+			mat = obj-&gt;p_poly[pn].mat;
+			if (mat != omat) {
+				tex = NULL;
+				if (mat &lt; obj-&gt;n_mat) {
+					m = &amp;obj-&gt;p_mat[mat];
+					if (m-&gt;tex != -1)  tex = get_texture(obj, m);
+					if (tex == NULL) { /* still NULL? then it couldn't get the texture. */
+						/*      s3dprintf(VLOW,&quot;no texture, using standard material...&quot;);*/
+						glBindTexture(GL_TEXTURE_2D, 0);
+						matgl[0] = m-&gt;amb_r / 2;
+						matgl[1] = m-&gt;amb_g / 2;
+						matgl[2] = m-&gt;amb_b / 2;
+						matgl[3] = m-&gt;amb_a;
+						/*     glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
+						glMaterialfv(GL_FRONT, GL_AMBIENT, matgl);
+						matgl[0] = m-&gt;diff_r / 2;
+						matgl[1] = m-&gt;diff_g / 2;
+						matgl[2] = m-&gt;diff_b / 2;
+						matgl[3] = m-&gt;diff_a;
+						/*     glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
+						glMaterialfv(GL_FRONT, GL_DIFFUSE, matgl);
+						matgl[0] = m-&gt;spec_r / 2;
+						matgl[1] = m-&gt;spec_g / 2;
+						matgl[2] = m-&gt;spec_b / 2;
+						matgl[3] = m-&gt;spec_a;
+						/*     glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
+						glMaterialfv(GL_FRONT, GL_SPECULAR, matgl);
 					}
 				} else {
-					s3dprintf(MED,&quot;something is wrong with polygon %d! material: [%d,%d]&quot;,pn, mat,obj-&gt;n_mat);
+					s3dprintf(MED, &quot;something is wrong with polygon %d! material: [%d,%d]&quot;, pn, mat, obj-&gt;n_mat);
 					if (obj-&gt;dplist) glEndList();
 					glEnd();
 					glPopMatrix();
 					return(-1);
 				}
 			}
-			omat=mat;		 /*  saving old material */
+			omat = mat; /*  saving old material */
 			glBegin(GL_TRIANGLES);
-			for (i=0; i&lt;3; i++) {
-				on=&amp;(obj-&gt;p_poly[pn].n[i]);
-				glNormal3f(-on-&gt;x,-on-&gt;y,-on-&gt;z);
-				if (tex!=NULL) {
-					/*						s3dprintf(MED,&quot;using texture coordinate (%f,%f) for polygon %d point %d&quot;,
-															obj-&gt;p_poly[pn].tc[i].x *tex-&gt;xs,
-															obj-&gt;p_poly[pn].tc[i].y *tex-&gt;ys,
-															pn,i);*/
+			for (i = 0; i &lt; 3; i++) {
+				on = &amp;(obj-&gt;p_poly[pn].n[i]);
+				glNormal3f(-on-&gt;x, -on-&gt;y, -on-&gt;z);
+				if (tex != NULL) {
+					/*      s3dprintf(MED,&quot;using texture coordinate (%f,%f) for polygon %d point %d&quot;,
+					          obj-&gt;p_poly[pn].tc[i].x *tex-&gt;xs,
+					          obj-&gt;p_poly[pn].tc[i].y *tex-&gt;ys,
+					          pn,i);*/
 
-					glTexCoord2f(	obj-&gt;p_poly[pn].tc[i].x *tex-&gt;xs,
-					              (obj-&gt;p_poly[pn].tc[i].y *tex-&gt;ys));
+					glTexCoord2f(obj-&gt;p_poly[pn].tc[i].x *tex-&gt;xs,
+					             (obj-&gt;p_poly[pn].tc[i].y *tex-&gt;ys));
 				}
-				v= obj-&gt;p_poly[pn].v[i];  /*  ... get the vertices ... */
+				v = obj-&gt;p_poly[pn].v[i]; /*  ... get the vertices ... */
 				glVertex3f(obj-&gt;p_vertex[v].x, obj-&gt;p_vertex[v].y, obj-&gt;p_vertex[v].z);  /*  ...and draw them */
 			}
 			glEnd();
 		}
-		if (tex!=NULL)			glBindTexture( GL_TEXTURE_2D, 0);  /*  switch back to standard texture */
-		for (pn=0;pn&lt;obj-&gt;n_line; pn++) {
-			if (check_line_normal(obj,pn)) {
-				s3dprintf(HIGH,&quot;something is wrong with line %d!&quot;,pn);
+		if (tex != NULL)   glBindTexture(GL_TEXTURE_2D, 0); /*  switch back to standard texture */
+		for (pn = 0;pn &lt; obj-&gt;n_line; pn++) {
+			if (check_line_normal(obj, pn)) {
+				s3dprintf(HIGH, &quot;something is wrong with line %d!&quot;, pn);
 				if (obj-&gt;dplist) glEndList();
 				glPopMatrix(); /* clean up GL-stuff */
 				return(-1);
 			}
 
-			mat= obj-&gt;p_line[pn].mat;
-			if (mat!=omat) {
-				tex=NULL;
-				if (mat&lt; obj-&gt;n_mat) {
-					m=&amp;obj-&gt;p_mat[mat];
+			mat = obj-&gt;p_line[pn].mat;
+			if (mat != omat) {
+				tex = NULL;
+				if (mat &lt; obj-&gt;n_mat) {
+					m = &amp;obj-&gt;p_mat[mat];
 					/* dont need to care about textures ...  it's rather impossible
 					 * to get some textures on a line. at least it would look ugly ;)*/
-					matgl[0]=m-&gt;amb_r/2;
-					matgl[1]=m-&gt;amb_g/2;
-					matgl[2]=m-&gt;amb_b/2;
-					matgl[3]=m-&gt;amb_a;
-					/* 			glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
-					glMaterialfv(GL_FRONT,GL_AMBIENT,matgl);
-					matgl[0]=m-&gt;diff_r/2;
-					matgl[1]=m-&gt;diff_g/2;
-					matgl[2]=m-&gt;diff_b/2;
-					matgl[3]=m-&gt;diff_a;
-					/* 			glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
-					glMaterialfv(GL_FRONT,GL_DIFFUSE,matgl);
-					matgl[0]=m-&gt;spec_r/2;
-					matgl[1]=m-&gt;spec_g/2;
-					matgl[2]=m-&gt;spec_b/2;
-					matgl[3]=m-&gt;spec_a;
-					/* 			glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
-					glMaterialfv(GL_FRONT,GL_SPECULAR,matgl);
+					matgl[0] = m-&gt;amb_r / 2;
+					matgl[1] = m-&gt;amb_g / 2;
+					matgl[2] = m-&gt;amb_b / 2;
+					matgl[3] = m-&gt;amb_a;
+					/*    glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
+					glMaterialfv(GL_FRONT, GL_AMBIENT, matgl);
+					matgl[0] = m-&gt;diff_r / 2;
+					matgl[1] = m-&gt;diff_g / 2;
+					matgl[2] = m-&gt;diff_b / 2;
+					matgl[3] = m-&gt;diff_a;
+					/*    glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
+					glMaterialfv(GL_FRONT, GL_DIFFUSE, matgl);
+					matgl[0] = m-&gt;spec_r / 2;
+					matgl[1] = m-&gt;spec_g / 2;
+					matgl[2] = m-&gt;spec_b / 2;
+					matgl[3] = m-&gt;spec_a;
+					/*    glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
+					glMaterialfv(GL_FRONT, GL_SPECULAR, matgl);
 				} else {
-					s3dprintf(MED,&quot;something is wrong with line %d! material: [%d,%d]&quot;,pn, mat,obj-&gt;n_mat);
+					s3dprintf(MED, &quot;something is wrong with line %d! material: [%d,%d]&quot;, pn, mat, obj-&gt;n_mat);
 					if (obj-&gt;dplist) glEndList();
 					glEnd();
 					glPopMatrix();
 					return(-1);
 				}
 			}
-			omat=mat;		 /*  saving old material */
+			omat = mat; /*  saving old material */
 			glBegin(GL_LINES);
-			for (i=0; i&lt;2; i++) {
-				on=&amp;(obj-&gt;p_line[pn].n[i]);
-				glNormal3f(-on-&gt;x,-on-&gt;y,-on-&gt;z);
+			for (i = 0; i &lt; 2; i++) {
+				on = &amp;(obj-&gt;p_line[pn].n[i]);
+				glNormal3f(-on-&gt;x, -on-&gt;y, -on-&gt;z);
 
-				v= obj-&gt;p_line[pn].v[i];  /*  ... get the vertices ... */
+				v = obj-&gt;p_line[pn].v[i]; /*  ... get the vertices ... */
 				glVertex3f(obj-&gt;p_vertex[v].x, obj-&gt;p_vertex[v].y, obj-&gt;p_vertex[v].z);  /*  ...and draw them */
 			}
 			glEnd();
@@ -1639,7 +1639,7 @@
 		if (obj-&gt;dplist) glEndList();
 	}
 	if (obj-&gt;dplist)
-		glCallList(obj-&gt;dplist);		/* call the just compiled ore old display list */
+		glCallList(obj-&gt;dplist);  /* call the just compiled ore old display list */
 	glPopMatrix();
 	return(0);
 }
@@ -1647,80 +1647,80 @@
 /* remove the oid out of the link chain */
 void link_delete(struct t_process *p, int32_t oid)
 {
-	struct t_obj *o,*o2;
-	if (OBJ_VALID(p,oid,o)) {
-		s3dprintf(VLOW,&quot;link_delete(): [%d] unlinking %d from %d&quot;,p-&gt;id, oid, o-&gt;linkid);
-		if (o-&gt;linkid!=-1) {
-			if (o-&gt;lprev!=-1)
-				if (OBJ_VALID(p,o-&gt;lprev,o2)) { /* we have a previous pointer linking to us */
-					o2-&gt;lnext=o-&gt;lnext; /* might also be -1 */
+	struct t_obj *o, *o2;
+	if (OBJ_VALID(p, oid, o)) {
+		s3dprintf(VLOW, &quot;link_delete(): [%d] unlinking %d from %d&quot;, p-&gt;id, oid, o-&gt;linkid);
+		if (o-&gt;linkid != -1) {
+			if (o-&gt;lprev != -1)
+				if (OBJ_VALID(p, o-&gt;lprev, o2)) { /* we have a previous pointer linking to us */
+					o2-&gt;lnext = o-&gt;lnext; /* might also be -1 */
 				}
-			if (OBJ_VALID(p,o-&gt;linkid,o2)) {
-				if (o2-&gt;lsub==oid) {/* parent is having oid as it's first link in chain */
-					o2-&gt;lsub=o-&gt;lnext;
+			if (OBJ_VALID(p, o-&gt;linkid, o2)) {
+				if (o2-&gt;lsub == oid) {/* parent is having oid as it's first link in chain */
+					o2-&gt;lsub = o-&gt;lnext;
 				}
 			}
-			if (o-&gt;lnext!=-1)
-				if (OBJ_VALID(p,o-&gt;lnext,o2)) { /* fixing next's previous pointer */
-					o2-&gt;lprev=o-&gt;lprev;
+			if (o-&gt;lnext != -1)
+				if (OBJ_VALID(p, o-&gt;lnext, o2)) { /* fixing next's previous pointer */
+					o2-&gt;lprev = o-&gt;lprev;
 				}
 		}
-		o-&gt;lnext=-1;
-		o-&gt;lprev=-1;
-		o-&gt;linkid=-1;
-		o-&gt;oflags&amp;=~OF_LINK;
+		o-&gt;lnext = -1;
+		o-&gt;lprev = -1;
+		o-&gt;linkid = -1;
+		o-&gt;oflags &amp;= ~OF_LINK;
 	}
 }
 /* add an element into the link chain */
 void link_insert(struct t_process *p, int32_t oid, int32_t target)
 {
-	struct t_obj *o,*ot,*o2;
-	if (OBJ_VALID(p,oid,o) &amp;&amp; OBJ_VALID(p,target,ot)) {
-		s3dprintf(VLOW,&quot;link_insert(): [%d] linking %d to %d&quot;,p-&gt;id, oid, target);
-		o-&gt;oflags|=OF_LINK;
-		o-&gt;linkid=target;
-		o-&gt;lnext=ot-&gt;lsub; /* we have a new &quot;first&quot; element */
-		if (o-&gt;lnext!=-1) if (OBJ_VALID(p,o-&gt;lnext,o2))  /* if we already had an element
-														  in the chain, create the backlink */
+	struct t_obj *o, *ot, *o2;
+	if (OBJ_VALID(p, oid, o) &amp;&amp; OBJ_VALID(p, target, ot)) {
+		s3dprintf(VLOW, &quot;link_insert(): [%d] linking %d to %d&quot;, p-&gt;id, oid, target);
+		o-&gt;oflags |= OF_LINK;
+		o-&gt;linkid = target;
+		o-&gt;lnext = ot-&gt;lsub; /* we have a new &quot;first&quot; element */
+		if (o-&gt;lnext != -1) if (OBJ_VALID(p, o-&gt;lnext, o2))  /* if we already had an element
+                in the chain, create the backlink */
 			{
-				o2-&gt;lprev=oid;
+				o2-&gt;lprev = oid;
 			}
-		ot-&gt;lsub=oid;
+		ot-&gt;lsub = oid;
 	}
 }
 /*  creates a link from object from an object to another  */
 /*  to have a translation or anything move with other things */
 int obj_link(struct t_process *p, int32_t oid_from, int32_t oid_to)
 {
-	struct t_obj *o,*o2;
-	if (OBJ_VALID(p,oid_from,o) &amp;&amp; OBJ_VALID(p,oid_to,o2)) {
-		if (oid_to==oid_from) {
-			errds(VHIGH,&quot;obj_link()&quot;,&quot;can't link to itself!!&quot;);
+	struct t_obj *o, *o2;
+	if (OBJ_VALID(p, oid_from, o) &amp;&amp; OBJ_VALID(p, oid_to, o2)) {
+		if (oid_to == oid_from) {
+			errds(VHIGH, &quot;obj_link()&quot;, &quot;can't link to itself!!&quot;);
 			return(-1);
 		}
-		if (OF_POINTER==(o-&gt;oflags&amp;0xF0000000)) {
-			errds(VHIGH,&quot;obj_link()&quot;,&quot;may not change the link of a pointer&quot;);
+		if (OF_POINTER == (o-&gt;oflags&amp;0xF0000000)) {
+			errds(VHIGH, &quot;obj_link()&quot;, &quot;may not change the link of a pointer&quot;);
 			return(-1);
 		}
 
 		while (o2-&gt;oflags&amp;OF_LINK) {
-			if (o2-&gt;linkid==oid_from) { /*  circular link!! we can't do that */
-				errds(VHIGH,&quot;obj_link()&quot;,&quot;link from %d to %d would produce a circular link!&quot;,oid_from,oid_to);
+			if (o2-&gt;linkid == oid_from) { /*  circular link!! we can't do that */
+				errds(VHIGH, &quot;obj_link()&quot;, &quot;link from %d to %d would produce a circular link!&quot;, oid_from, oid_to);
 				return(-1);
 			}
-			o2=p-&gt;object[o2-&gt;linkid];  /*   move to the next object in the linkchain */
+			o2 = p-&gt;object[o2-&gt;linkid];  /*   move to the next object in the linkchain */
 		}
-		if ((o-&gt;oflags&amp;OF_SYSTEM) &amp;&amp; (p-&gt;id==MCP)) {
-			errds(VHIGH,&quot;obj_link()&quot;,&quot;can't link system-objects in non-mcp-apps!&quot;);
+		if ((o-&gt;oflags&amp;OF_SYSTEM) &amp;&amp; (p-&gt;id == MCP)) {
+			errds(VHIGH, &quot;obj_link()&quot;, &quot;can't link system-objects in non-mcp-apps!&quot;);
 			return(-1);
 		}
-		s3dprintf(VLOW,&quot;[link|pid %d] %d -&gt; %d&quot;,p-&gt;id, oid_from,oid_to);
-		if (oid_to!=o-&gt;linkid) { /* only if something changed ... */
-			if (o-&gt;linkid!=-1)
-				link_delete(p,oid_from);
-			link_insert(p,oid_from,oid_to);
-			p-&gt;object[oid_to]-&gt;oflags|=OF_LINK_SRC;
-			obj_pos_update(p,oid_from,oid_from);
+		s3dprintf(VLOW, &quot;[link|pid %d] %d -&gt; %d&quot;, p-&gt;id, oid_from, oid_to);
+		if (oid_to != o-&gt;linkid) { /* only if something changed ... */
+			if (o-&gt;linkid != -1)
+				link_delete(p, oid_from);
+			link_insert(p, oid_from, oid_to);
+			p-&gt;object[oid_to]-&gt;oflags |= OF_LINK_SRC;
+			obj_pos_update(p, oid_from, oid_from);
 		}
 		return(0);
 	}
@@ -1730,15 +1730,15 @@
 int obj_unlink(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o;
-	if (OBJ_VALID(p,oid,o)) {
-		if (OF_POINTER==(o-&gt;oflags&amp;0xF0000000)) {
-			errds(VHIGH,&quot;obj_link()&quot;,&quot;may not change the link of a pointer&quot;);
+	if (OBJ_VALID(p, oid, o)) {
+		if (OF_POINTER == (o-&gt;oflags&amp;0xF0000000)) {
+			errds(VHIGH, &quot;obj_link()&quot;, &quot;may not change the link of a pointer&quot;);
 			return(-1);
 		}
-		link_delete(p,oid);
-		s3dprintf(VLOW,&quot;removing link of object %d from pid %d&quot;,oid,p-&gt;id);
+		link_delete(p, oid);
+		s3dprintf(VLOW, &quot;removing link of object %d from pid %d&quot;, oid, p-&gt;id);
 
-		obj_pos_update(p,oid,oid);
+		obj_pos_update(p, oid, oid);
 		return(0);
 	}
 	return(-1);
@@ -1747,42 +1747,42 @@
 int obj_new(struct t_process *p)
 {
 	struct t_obj *obj;
-	int32_t pos,reuse=0;
-	obj=malloc(sizeof(struct t_obj));  /*  get an object and define it with our data */
-	memset(obj,0,sizeof(struct t_obj));
-	obj-&gt;linkid=-1;
-	obj-&gt;lsub=-1;
-	obj-&gt;lnext=-1;
-	obj-&gt;lprev=-1;
-	obj-&gt;rotate.x=obj-&gt;rotate.y=obj-&gt;rotate.z=0.0F;
-	obj-&gt;translate.x=obj-&gt;translate.y=obj-&gt;translate.z=0.0F;
-	obj-&gt;scale=1.0F;
-	obj-&gt;n_vertex=obj-&gt;n_poly=obj-&gt;n_mat=obj-&gt;n_tex=0;
-	obj-&gt;r=obj-&gt;or=0.0F;
-	obj-&gt;m_uptodate=0;
-	memcpy(obj-&gt;m,Identity,sizeof(t_mtrx));
+	int32_t pos, reuse = 0;
+	obj = malloc(sizeof(struct t_obj));  /*  get an object and define it with our data */
+	memset(obj, 0, sizeof(struct t_obj));
+	obj-&gt;linkid = -1;
+	obj-&gt;lsub = -1;
+	obj-&gt;lnext = -1;
+	obj-&gt;lprev = -1;
+	obj-&gt;rotate.x = obj-&gt;rotate.y = obj-&gt;rotate.z = 0.0F;
+	obj-&gt;translate.x = obj-&gt;translate.y = obj-&gt;translate.z = 0.0F;
+	obj-&gt;scale = 1.0F;
+	obj-&gt;n_vertex = obj-&gt;n_poly = obj-&gt;n_mat = obj-&gt;n_tex = 0;
+	obj-&gt;r = obj-&gt;or = 0.0F;
+	obj-&gt;m_uptodate = 0;
+	memcpy(obj-&gt;m, Identity, sizeof(t_mtrx));
 	/*  fresh and clean ... */
-	if (p!=NULL) {
+	if (p != NULL) {
 		/*  look for an old object for reuse ... */
-		for (pos=0; pos &lt; p-&gt;n_obj ; pos++) {
-			if (p-&gt;object[pos]==NULL) {
-				reuse=1;
+		for (pos = 0; pos &lt; p-&gt;n_obj ; pos++) {
+			if (p-&gt;object[pos] == NULL) {
+				reuse = 1;
 				break;
-				/* 				s3dprintf(HIGH,&quot;reusing position %d&quot;,pos); */
+				/*     s3dprintf(HIGH,&quot;reusing position %d&quot;,pos); */
 			}
 		}
 		if (!reuse) {
-			if (p-&gt;n_obj&gt;0)
-				p-&gt;object=realloc(p-&gt;object,sizeof(struct t_obj *)*(p-&gt;n_obj+1));
-			else p-&gt;object=malloc(sizeof(struct t_obj *)*(p-&gt;n_obj+1));
-			pos=p-&gt;n_obj; 				 /*  add object at the end */
-			p-&gt;n_obj++;					 /*  increment counter */
+			if (p-&gt;n_obj &gt; 0)
+				p-&gt;object = realloc(p-&gt;object, sizeof(struct t_obj *) * (p-&gt;n_obj + 1));
+			else p-&gt;object = malloc(sizeof(struct t_obj *) * (p-&gt;n_obj + 1));
+			pos = p-&gt;n_obj;    /*  add object at the end */
+			p-&gt;n_obj++;      /*  increment counter */
 		}
-		p-&gt;object[pos]=obj;
-		s3dprintf(VLOW,&quot;pid %d added new object %d at %010p [pos %d]&quot;,p-&gt;id,pos,obj,pos);
+		p-&gt;object[pos] = obj;
+		s3dprintf(VLOW, &quot;pid %d added new object %d at %010p [pos %d]&quot;, p-&gt;id, pos, obj, pos);
 		return (pos);
 	} else {
-		s3dprintf(HIGH,&quot;obj_new(): no such process %d&quot;,p-&gt;id);
+		s3dprintf(HIGH, &quot;obj_new(): no such process %d&quot;, p-&gt;id);
 		return(-1);
 	}
 }
@@ -1791,50 +1791,50 @@
 /*  this will check and supress looplinks and clonechains */
 int obj_clone_change(struct t_process *p, int32_t oid, int32_t toid)
 {
-	struct t_obj *o,*no;
-	int already_clone,is_clnsrc;
+	struct t_obj *o, *no;
+	int already_clone, is_clnsrc;
 	int32_t i;
-	if (OBJ_VALID(p,oid,o) &amp;&amp; OBJ_VALID(p,toid,no)) {
+	if (OBJ_VALID(p, oid, o) &amp;&amp; OBJ_VALID(p, toid, no)) {
 		if ((o-&gt;oflags&amp;OF_SYSTEM) || (no-&gt;oflags&amp;OF_SYSTEM)) {
-			s3dprintf(MED,&quot;can't clone from or to system objects&quot;);
+			s3dprintf(MED, &quot;can't clone from or to system objects&quot;);
 		}
 		/*  get obj pointer and check for availability of the other object. */
-		if (((already_clone=(o-&gt;oflags&amp;OF_CLONE)) || (!(o-&gt;n_vertex|o-&gt;n_mat|o-&gt;n_poly|o-&gt;n_tex))) &amp;&amp; (!(o-&gt;oflags&amp;OF_VIRTUAL))) {
-			if (no-&gt;oflags&amp;OF_CLONE) {	 /*  target is clone */
-				errds(VHIGH,&quot;obj_clone_change()&quot;,&quot;couldn't clone %d from %d (on pid %d): clone target is already clone.&quot;,oid,toid,p-&gt;id,oid);
+		if (((already_clone = (o-&gt;oflags &amp; OF_CLONE)) || (!(o-&gt;n_vertex | o-&gt;n_mat | o-&gt;n_poly | o-&gt;n_tex))) &amp;&amp; (!(o-&gt;oflags &amp; OF_VIRTUAL))) {
+			if (no-&gt;oflags&amp;OF_CLONE) {  /*  target is clone */
+				errds(VHIGH, &quot;obj_clone_change()&quot;, &quot;couldn't clone %d from %d (on pid %d): clone target is already clone.&quot;, oid, toid, p-&gt;id, oid);
 				return(-1);
 			}
 			if (!already_clone) { /*  some other object could link to us, so we check the other objects and forward them just in case. */
 				if (p-&gt;object[oid]-&gt;oflags&amp;OF_CLONE_SRC) {
-					is_clnsrc=0;
-					for (i=0;i&lt;p-&gt;n_obj;i++)
-						if (p-&gt;object[i]!=NULL)
-							if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex==oid)) { /*  it's linking to our object! */
-								errds(VHIGH,&quot;obj_clone_change()&quot;,&quot;couldn't clone %d from %d (on pid %d): object %d is already cloning from object %d.&quot;,
-								      oid,toid,p-&gt;id,oid,i,oid);
+					is_clnsrc = 0;
+					for (i = 0;i &lt; p-&gt;n_obj;i++)
+						if (p-&gt;object[i] != NULL)
+							if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex == oid)) { /*  it's linking to our object! */
+								errds(VHIGH, &quot;obj_clone_change()&quot;, &quot;couldn't clone %d from %d (on pid %d): object %d is already cloning from object %d.&quot;,
+								      oid, toid, p-&gt;id, oid, i, oid);
 								return(-1);
 							}
 					if (!is_clnsrc) {
-						s3dprintf(MED,&quot;obj_clone_change(): %d in process %d is no longer a clone-source&quot;,oid,p-&gt;id);
-						p-&gt;object[oid]-&gt;oflags&amp;=~OF_CLONE_SRC;
+						s3dprintf(MED, &quot;obj_clone_change(): %d in process %d is no longer a clone-source&quot;, oid, p-&gt;id);
+						p-&gt;object[oid]-&gt;oflags &amp;= ~OF_CLONE_SRC;
 					}
 				}
 			}
-			if (oid!=toid) { /*  don't looplink */
-				o-&gt;oflags|=OF_CLONE;
-				no-&gt;oflags|=OF_CLONE_SRC;
-				o-&gt;n_vertex=toid;  /*  n_vertex is not used for this as it's just cloned, so we can use it ... */
-				obj_size_update(p,oid);
-				s3dprintf(LOW,&quot;changed clone-target of obj %d to %d of process %d&quot;,oid,toid,p-&gt;id);
-				if (p-&gt;id!=MCP) obj_check_biggest_object(p,oid);
+			if (oid != toid) { /*  don't looplink */
+				o-&gt;oflags |= OF_CLONE;
+				no-&gt;oflags |= OF_CLONE_SRC;
+				o-&gt;n_vertex = toid;  /*  n_vertex is not used for this as it's just cloned, so we can use it ... */
+				obj_size_update(p, oid);
+				s3dprintf(LOW, &quot;changed clone-target of obj %d to %d of process %d&quot;, oid, toid, p-&gt;id);
+				if (p-&gt;id != MCP) obj_check_biggest_object(p, oid);
 			} else {
-				errds(MED,&quot;obj_clone_change()&quot;,&quot;couldn't clone %d from %d (on pid %d): cloning from itself doesn't make sense!&quot;,oid,toid,p-&gt;id,oid);
+				errds(MED, &quot;obj_clone_change()&quot;, &quot;couldn't clone %d from %d (on pid %d): cloning from itself doesn't make sense!&quot;, oid, toid, p-&gt;id, oid);
 				return(-1);
 			}
 		} else {
-			errds(MED,&quot;obj_clone_change()&quot;,&quot;couldn't clone %d from %d (on pid %d): object %d is not empty&quot;,oid,toid,p-&gt;id,oid);
-			obj_debug(p,oid);
-			obj_debug(p,toid);
+			errds(MED, &quot;obj_clone_change()&quot;, &quot;couldn't clone %d from %d (on pid %d): object %d is not empty&quot;, oid, toid, p-&gt;id, oid);
+			obj_debug(p, oid);
+			obj_debug(p, toid);
 			return(-1);
 		}
 	}
@@ -1847,53 +1847,53 @@
 {
 	struct t_process *mcp_p;
 	struct t_obj *o;
-	float r,mr;
+	float r, mr;
 	int32_t i;
-	int32_t mcp_oid=-1;
-	mcp_p=get_proc_by_pid(MCP);
-	if (OBJ_VALID(p,oid,o)) {
+	int32_t mcp_oid = -1;
+	mcp_p = get_proc_by_pid(MCP);
+	if (OBJ_VALID(p, oid, o)) {
 		if (o-&gt;oflags&amp;OF_SYSTEM) {
-			s3dprintf(HIGH,&quot;can't delete system object!&quot;);
+			s3dprintf(HIGH, &quot;can't delete system object!&quot;);
 			return(0);
 		}
 
 
-		if (p-&gt;id==MCP) {
+		if (p-&gt;id == MCP) {
 			if (o-&gt;oflags&amp;OF_VIRTUAL) { /*  only delete if virtual */
-				s3dprintf(HIGH,&quot;the mcp wants %d to be closed&quot;,o-&gt;n_mat);
+				s3dprintf(HIGH, &quot;the mcp wants %d to be closed&quot;, o-&gt;n_mat);
 				event_quit(get_proc_by_pid(o-&gt;n_mat));
 				return(0);
 			}
 		} else
-			mcp_oid=p-&gt;mcp_oid;
+			mcp_oid = p-&gt;mcp_oid;
 
-		if (OBJ_VALID(p,oid,o)) {
-			obj_free(p,oid);
-			if ((p-&gt;id!=MCP) &amp;&amp; (p-&gt;biggest_obj==oid)) { /*  if object was the biggest object, find a new one. */
-				mr=-1;
-				p-&gt;biggest_obj=-1;
-				for (i=0;i&lt;p-&gt;n_obj;i++)
-					if (p-&gt;object[i]!=NULL) {
-						r=p-&gt;object[i]-&gt;r+p-&gt;object[i]-&gt;or;
-						if (r&gt;mr) {
+		if (OBJ_VALID(p, oid, o)) {
+			obj_free(p, oid);
+			if ((p-&gt;id != MCP) &amp;&amp; (p-&gt;biggest_obj == oid)) { /*  if object was the biggest object, find a new one. */
+				mr = -1;
+				p-&gt;biggest_obj = -1;
+				for (i = 0;i &lt; p-&gt;n_obj;i++)
+					if (p-&gt;object[i] != NULL) {
+						r = p-&gt;object[i]-&gt;r + p-&gt;object[i]-&gt;or;
+						if (r &gt; mr) {
 							if (!(p-&gt;object[i]-&gt;oflags&amp;OF_SYSTEM)) {
-								p-&gt;biggest_obj=i;
-								mr=r;
+								p-&gt;biggest_obj = i;
+								mr = r;
 							}
 						}
 					}
-				mcp_p-&gt;object[mcp_oid]-&gt;r=mr;
-				s3dprintf(MED,&quot;new biggest object is :%d (size: %f)&quot;,p-&gt;biggest_obj,mr);
+				mcp_p-&gt;object[mcp_oid]-&gt;r = mr;
+				s3dprintf(MED, &quot;new biggest object is :%d (size: %f)&quot;, p-&gt;biggest_obj, mr);
 			}
 			/*  check if someone depended on this object as clone.... */
 			if (o-&gt;oflags&amp;OF_CLONE_SRC)
-				for (i=0;i&lt;p-&gt;n_obj;i++)
-					if (p-&gt;object[i]!=NULL)
-						if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex==oid)) { /*  it's linking to our object! */
-							p-&gt;object[i]-&gt;oflags&amp;=~OF_CLONE;  	 /*  disable clone flag */
-							p-&gt;object[i]-&gt;n_vertex=0; 			 /*  and &quot;clone reference&quot; to 0 */
-							p-&gt;object[i]-&gt;r=0.0F;				 /*  empty object, so radius is zero! */
-							if (p-&gt;id!=MCP) obj_check_biggest_object(p,i);
+				for (i = 0;i &lt; p-&gt;n_obj;i++)
+					if (p-&gt;object[i] != NULL)
+						if ((p-&gt;object[i]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (p-&gt;object[i]-&gt;n_vertex == oid)) { /*  it's linking to our object! */
+							p-&gt;object[i]-&gt;oflags &amp;= ~OF_CLONE;  /*  disable clone flag */
+							p-&gt;object[i]-&gt;n_vertex = 0;   /*  and &quot;clone reference&quot; to 0 */
+							p-&gt;object[i]-&gt;r = 0.0F;   /*  empty object, so radius is zero! */
+							if (p-&gt;id != MCP) obj_check_biggest_object(p, i);
 						}
 			return(0);
 		}
@@ -1902,53 +1902,53 @@
 }
 
 /*  this is the &quot;direct&quot; freeing function, without checking for perfomance */
-int obj_free(struct t_process *p,int32_t oid)
+int obj_free(struct t_process *p, int32_t oid)
 {
 	int32_t i;
 	GLuint t;
-	struct t_obj *o=p-&gt;object[oid];
-	s3dprintf(HIGH,&quot;deleting object %d of process %d&quot;,oid,p-&gt;id);
+	struct t_obj *o = p-&gt;object[oid];
+	s3dprintf(HIGH, &quot;deleting object %d of process %d&quot;, oid, p-&gt;id);
 
 	/* clearing links */
-	if (o-&gt;linkid!=-1)		link_delete(p,oid);
-	while (o-&gt;lsub!=-1) {
-		i=o-&gt;lsub;
-		link_delete(p,o-&gt;lsub);
-		if (i==o-&gt;lsub) {
-			s3dprintf(HIGH,&quot;something is wrong!!&quot;);
-			o=NULL; /* segfault */
-			o-&gt;lsub=-1;
+	if (o-&gt;linkid != -1)  link_delete(p, oid);
+	while (o-&gt;lsub != -1) {
+		i = o-&gt;lsub;
+		link_delete(p, o-&gt;lsub);
+		if (i == o-&gt;lsub) {
+			s3dprintf(HIGH, &quot;something is wrong!!&quot;);
+			o = NULL; /* segfault */
+			o-&gt;lsub = -1;
 		}
 	}
 
 	if (!(o-&gt;oflags&amp;OF_NODATA)) {
-		if (o-&gt;n_vertex&gt;0) free(o-&gt;p_vertex);
-		if (o-&gt;n_poly&gt;0) free(o-&gt;p_poly);
-		if (o-&gt;n_mat&gt;0) free(o-&gt;p_mat);
-		for (i=0;i&lt;o-&gt;n_tex;i++) {
-			if (o-&gt;p_tex[i].buf!=NULL)
+		if (o-&gt;n_vertex &gt; 0) free(o-&gt;p_vertex);
+		if (o-&gt;n_poly &gt; 0) free(o-&gt;p_poly);
+		if (o-&gt;n_mat &gt; 0) free(o-&gt;p_mat);
+		for (i = 0;i &lt; o-&gt;n_tex;i++) {
+			if (o-&gt;p_tex[i].buf != NULL)
 				free(o-&gt;p_tex[i].buf);
 			if (o-&gt;p_tex[i].gl_texnum) {
-				t=o-&gt;p_tex[i].gl_texnum;
-				glDeleteTextures(1,&amp;t);
+				t = o-&gt;p_tex[i].gl_texnum;
+				glDeleteTextures(1, &amp;t);
 			}
 		}
-		if (o-&gt;n_tex&gt;0) free(o-&gt;p_tex);
+		if (o-&gt;n_tex &gt; 0) free(o-&gt;p_tex);
 
 	}
 	if (o-&gt;dplist) {
-		if (!(o-&gt;oflags&amp;(OF_CLONE|OF_SYSTEM))) {
-			s3dprintf(VLOW,&quot;freeing display list %d&quot;,o-&gt;dplist);
-			glDeleteLists(o-&gt;dplist,1);
+		if (!(o-&gt;oflags&amp;(OF_CLONE | OF_SYSTEM))) {
+			s3dprintf(VLOW, &quot;freeing display list %d&quot;, o-&gt;dplist);
+			glDeleteLists(o-&gt;dplist, 1);
 		}
 	}
 	free(o);
-	p-&gt;object[oid]=NULL;
-	if (oid==(p-&gt;n_obj-1)) {
-		i=oid;
-		while ((i!=-1) &amp;&amp; (p-&gt;object[i]==NULL)) i--;
-		p-&gt;n_obj=i+1;
-		p-&gt;object=realloc(p-&gt;object,sizeof(struct t_obj *)*(p-&gt;n_obj));
+	p-&gt;object[oid] = NULL;
+	if (oid == (p-&gt;n_obj - 1)) {
+		i = oid;
+		while ((i != -1) &amp;&amp; (p-&gt;object[i] == NULL)) i--;
+		p-&gt;n_obj = i + 1;
+		p-&gt;object = realloc(p-&gt;object, sizeof(struct t_obj *) * (p-&gt;n_obj));
 	}
 	return(0);
 }
@@ -1956,9 +1956,9 @@
 int32_t get_pointer(struct t_process *p)
 {
 	int32_t i;
-	for (i=0;i&lt;p-&gt;n_obj;i++) {
+	for (i = 0;i &lt; p-&gt;n_obj;i++) {
 
-		if (OF_POINTER==(p-&gt;object[i]-&gt;oflags&amp;0xF0000000)) {
+		if (OF_POINTER == (p-&gt;object[i]-&gt;oflags&amp;0xF0000000)) {
 			return(i);
 		}
 	}

Modified: trunk/server/process.c
===================================================================
--- trunk/server/process.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/process.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,13 +24,13 @@
 
 #include &quot;global.h&quot;
 #include &lt;stdlib.h&gt;  /*  for malloc, free */
-#include &lt;string.h&gt;	 /*  strncmp(), strncpy() */
+#include &lt;string.h&gt;  /*  strncmp(), strncpy() */
 /*  this piece of code handles processes */
 
 #define mcp_p (&amp;procs_p[0])
-struct t_process  *procs_p=NULL;				/* pointer to the processes */
-int 			   procs_n; 					/* number of processes */
-static int p_del(struct t_process *p);			/*  local prototype */
+struct t_process  *procs_p = NULL;  /* pointer to the processes */
+int       procs_n;      /* number of processes */
+static int p_del(struct t_process *p);   /*  local prototype */
 static int process_list_rm(int pid);
 int process_sys_init(struct t_process *p);
 
@@ -38,29 +38,29 @@
 struct t_process *process_protinit(struct t_process *p, char *name) {
 	int con_type;
 	int32_t mcp_oid;
-	if ((strncmp(name,&quot;sys_&quot;,4)==0)) { /* we don't like &quot;sys_&quot;-apps, kicking this */
-		errds(VHIGH,&quot;process_protinit()&quot;,&quot;appnames starting with 'sys_' not allowed.&quot;);
+	if ((strncmp(name, &quot;sys_&quot;, 4) == 0)) { /* we don't like &quot;sys_&quot;-apps, kicking this */
+		errds(VHIGH, &quot;process_protinit()&quot;, &quot;appnames starting with 'sys_' not allowed.&quot;);
 		return(NULL);
 	}
-	if ((p-&gt;id!=MCP) &amp;&amp; (strncmp(name,&quot;mcp&quot;,3)==0)) {
-		if (procs_p[MCP].con_type==CON_NULL) {
-			s3dprintf(MED,&quot;free mcp place, pid %d becoming mcp!&quot;,p-&gt;id);
-			con_type=p-&gt;con_type; /* move connection data */
+	if ((p-&gt;id != MCP) &amp;&amp; (strncmp(name, &quot;mcp&quot;, 3) == 0)) {
+		if (procs_p[MCP].con_type == CON_NULL) {
+			s3dprintf(MED, &quot;free mcp place, pid %d becoming mcp!&quot;, p-&gt;id);
+			con_type = p-&gt;con_type; /* move connection data */
 #ifdef TCP
-			procs_p[MCP].sockid=p-&gt;sockid; /* don't save contype yet,
-									or p_del will notify mcp about a deleted
-									mcp-object (which is itselfs, actually) */
+			procs_p[MCP].sockid = p-&gt;sockid; /* don't save contype yet,
+         or p_del will notify mcp about a deleted
+         mcp-object (which is itselfs, actually) */
 #endif
 #ifdef SHM
-			memcpy(&amp;procs_p[MCP].shmsock,&amp;p-&gt;shmsock,sizeof(struct t_shmcb));
+			memcpy(&amp;procs_p[MCP].shmsock, &amp;p-&gt;shmsock, sizeof(struct t_shmcb));
 #endif
 			p_del(p); /* deleting data/mcp object */
-			procs_p[MCP].con_type=con_type;
+			procs_p[MCP].con_type = con_type;
 			mcp_init();
 			process_list_rm(p-&gt;id); /* remove old process, but don't kill connection */
 			return(&amp;procs_p[MCP]);
 		} else {
-			s3dprintf(LOW,&quot;the place for the mcp is already taken ...&quot;);
+			s3dprintf(LOW, &quot;the place for the mcp is already taken ...&quot;);
 			return(NULL);
 		}
 	} else {
@@ -68,20 +68,20 @@
 		process_sys_init(p);
 
 		/* register the new process in the mcp */
-		if (-1!=(mcp_oid= obj_new(&amp;procs_p[MCP]))) {
-			mcp_p-&gt;object[mcp_oid]-&gt;oflags|=OF_VIRTUAL|OF_VISIBLE|OF_SELECTABLE;
-			mcp_p-&gt;object[mcp_oid]-&gt;n_mat=p-&gt;id;
+		if (-1 != (mcp_oid = obj_new(&amp;procs_p[MCP]))) {
+			mcp_p-&gt;object[mcp_oid]-&gt;oflags |= OF_VIRTUAL | OF_VISIBLE | OF_SELECTABLE;
+			mcp_p-&gt;object[mcp_oid]-&gt;n_mat = p-&gt;id;
 
-			/* 		mcp_p-&gt;object[mcp_oid]-&gt;p_mat=(struct t_material *)new_p; */
+			/*   mcp_p-&gt;object[mcp_oid]-&gt;p_mat=(struct t_material *)new_p; */
 			/*  dirty, but it's just a pointer after all ... */
-			p-&gt;mcp_oid=mcp_oid;
-			s3dprintf(LOW,&quot;process %d now has mcp_oid %d&quot;,p-&gt;id,mcp_oid);
+			p-&gt;mcp_oid = mcp_oid;
+			s3dprintf(LOW, &quot;process %d now has mcp_oid %d&quot;, p-&gt;id, mcp_oid);
 			mcp_rep_object(mcp_oid);
-			if (mcp_p-&gt;con_type==CON_NULL) { /*  there is no mcp connected! setting focus to the new program: */
+			if (mcp_p-&gt;con_type == CON_NULL) { /*  there is no mcp connected! setting focus to the new program: */
 				mcp_focus(mcp_oid);
 			}
 		} else {
-			s3dprintf(LOW,&quot;couldn't add object to mcp ...&quot;);
+			s3dprintf(LOW, &quot;couldn't add object to mcp ...&quot;);
 		}
 	}
 	return(p);
@@ -89,38 +89,38 @@
 /* adds system objects to the app, like camera, pointers etc ... */
 int process_sys_init(struct t_process *p)
 {
-	int cam,ptr;
+	int cam, ptr;
 	struct t_obj *o;
-	cam=obj_new(p);
-	ptr=obj_new(p);
-	if (p-&gt;id==MCP) {   /* this is only called once within process_init, later mcp's are
-		   will be registered as &quot;real&quot; apps first */
-		p-&gt;object[cam]-&gt;translate.z=5;
-		p-&gt;object[cam]-&gt;oflags=OF_CAM;
-		p-&gt;object[ptr]-&gt;translate.z=-1;
-		p-&gt;object[ptr]-&gt;oflags=OF_POINTER;
-		link_insert(p,ptr,cam);
+	cam = obj_new(p);
+	ptr = obj_new(p);
+	if (p-&gt;id == MCP) {   /* this is only called once within process_init, later mcp's are
+     will be registered as &quot;real&quot; apps first */
+		p-&gt;object[cam]-&gt;translate.z = 5;
+		p-&gt;object[cam]-&gt;oflags = OF_CAM;
+		p-&gt;object[ptr]-&gt;translate.z = -1;
+		p-&gt;object[ptr]-&gt;oflags = OF_POINTER;
+		link_insert(p, ptr, cam);
 	} else {
 		/* TODO: ... get the cam and ptr position of the mcp, somehow */
-		p-&gt;object[cam]-&gt;oflags=OF_CAM;
+		p-&gt;object[cam]-&gt;oflags = OF_CAM;
 
-		if (OBJ_VALID(mcp_p,get_pointer(mcp_p),o)) { /* get parent pointer, copy parent */
-			p-&gt;object[ptr]-&gt;rotate.x=o-&gt;rotate.x;
-			p-&gt;object[ptr]-&gt;rotate.y=o-&gt;rotate.y;
-			p-&gt;object[ptr]-&gt;rotate.z=o-&gt;rotate.z;
-			p-&gt;object[ptr]-&gt;translate.x=o-&gt;translate.x;
-			p-&gt;object[ptr]-&gt;translate.y=o-&gt;translate.y;
-			p-&gt;object[ptr]-&gt;translate.z=o-&gt;translate.z;
+		if (OBJ_VALID(mcp_p, get_pointer(mcp_p), o)) { /* get parent pointer, copy parent */
+			p-&gt;object[ptr]-&gt;rotate.x = o-&gt;rotate.x;
+			p-&gt;object[ptr]-&gt;rotate.y = o-&gt;rotate.y;
+			p-&gt;object[ptr]-&gt;rotate.z = o-&gt;rotate.z;
+			p-&gt;object[ptr]-&gt;translate.x = o-&gt;translate.x;
+			p-&gt;object[ptr]-&gt;translate.y = o-&gt;translate.y;
+			p-&gt;object[ptr]-&gt;translate.z = o-&gt;translate.z;
 		}
-		p-&gt;object[ptr]-&gt;oflags=OF_POINTER;
-		link_insert(p,ptr,cam);
+		p-&gt;object[ptr]-&gt;oflags = OF_POINTER;
+		link_insert(p, ptr, cam);
 	}
-	s3dprintf(MED,&quot;process_sys_init(): added object cam0 %d&quot;,cam);
-	s3dprintf(MED,&quot;process_sys_init(): added object ptr0 %d&quot;,ptr);
-	obj_pos_update(get_proc_by_pid(MCP),cam,cam);
-	obj_pos_update(get_proc_by_pid(MCP),ptr,ptr);
-	/*	obj_recalc_tmat(p,0);*/
-	event_obj_info(p,0); /* tell the new program about the thing */
+	s3dprintf(MED, &quot;process_sys_init(): added object cam0 %d&quot;, cam);
+	s3dprintf(MED, &quot;process_sys_init(): added object ptr0 %d&quot;, ptr);
+	obj_pos_update(get_proc_by_pid(MCP), cam, cam);
+	obj_pos_update(get_proc_by_pid(MCP), ptr, ptr);
+	/* obj_recalc_tmat(p,0);*/
+	event_obj_info(p, 0); /* tell the new program about the thing */
 
 	return(0);
 }
@@ -129,30 +129,30 @@
 struct t_process *process_add() {
 	struct t_process *new_p;
 	procs_n++;
-	procs_p=realloc(procs_p,sizeof(struct t_process)*procs_n); /* increase the block */
-	new_p=&amp;procs_p[procs_n-1];
+	procs_p = realloc(procs_p, sizeof(struct t_process)*procs_n); /* increase the block */
+	new_p = &amp;procs_p[procs_n-1];
 
-	new_p-&gt;id	  = procs_n-1;
-	/*	if (new_p-&gt;id==0)
-			mcp_p=&amp;procs_p[0];*/
+	new_p-&gt;id   = procs_n - 1;
+	/* if (new_p-&gt;id==0)
+	  mcp_p=&amp;procs_p[0];*/
 	new_p-&gt;object = NULL;
 	new_p-&gt;n_obj  = 0;
-	/*	new_p-&gt;netin  = 0;*/
+	/* new_p-&gt;netin  = 0;*/
 	new_p-&gt;mcp_oid = -1;
-	new_p-&gt;biggest_obj=-1;
-	new_p-&gt;con_type=CON_NULL;	/* this is to be changed by the caller */
-	new_p-&gt;name[0]='\0';
+	new_p-&gt;biggest_obj = -1;
+	new_p-&gt;con_type = CON_NULL; /* this is to be changed by the caller */
+	new_p-&gt;name[0] = '\0';
 	return(new_p);
 }
 /* deletes the process with pid */
 int process_del(int pid)
 {
-	if (pid==MCP) {
+	if (pid == MCP) {
 		n_remove(&amp;procs_p[pid]);
 		p_del(&amp;procs_p[pid]);
 		return(0);
 	}
-	if ((pid&gt;0) &amp;&amp; (pid&lt;procs_n)) {
+	if ((pid &gt; 0) &amp;&amp; (pid &lt; procs_n)) {
 		n_remove(&amp;procs_p[pid]);
 		p_del(&amp;procs_p[pid]);
 		process_list_rm(pid);
@@ -163,21 +163,21 @@
 /* just kick process out of the process list, no network/mcp-oid cleanup */
 int process_list_rm(int pid)
 {
-	if (pid!=(procs_n-1)) { /* copy last block, swap pid */
-		memcpy(&amp;procs_p[pid],&amp;procs_p[procs_n-1],sizeof(struct t_process));
-		procs_p[pid].id=pid; /* change the pid of the new procs_p */
-		if (procs_p[pid].mcp_oid!=-1) /* the last process could just appear without initializing yet ... */
-			procs_p[0].object[procs_p[pid].mcp_oid]-&gt;n_mat=pid;
+	if (pid != (procs_n - 1)) { /* copy last block, swap pid */
+		memcpy(&amp;procs_p[pid], &amp;procs_p[procs_n-1], sizeof(struct t_process));
+		procs_p[pid].id = pid; /* change the pid of the new procs_p */
+		if (procs_p[pid].mcp_oid != -1) /* the last process could just appear without initializing yet ... */
+			procs_p[0].object[procs_p[pid].mcp_oid]-&gt;n_mat = pid;
 		/* change the mcp-objects pid-pointer to the right position! */
 		/* this is kind of pointer madness */
 	}
 	procs_n--;
-	procs_p=realloc(procs_p,sizeof(struct t_process)*procs_n); /* decrease the block,
-		wipe the last one */
+	procs_p = realloc(procs_p, sizeof(struct t_process) * procs_n); /* decrease the block,
+  wipe the last one */
 	return(0);
 }
 struct t_process *get_proc_by_pid(int pid) {
-	if ((pid&gt;=0) &amp;&amp; (pid&lt;procs_n))
+	if ((pid &gt;= 0) &amp;&amp; (pid &lt; procs_n))
 		return(&amp;procs_p[pid]);
 	return(NULL);
 }
@@ -185,58 +185,58 @@
 /* it's quite the same as the original version, but without free() */
 static int p_del(struct t_process *p)
 {
-	int j,i=p-&gt;n_obj;
-	if (p-&gt;id!=MCP) {
-		if (p-&gt;mcp_oid!=-1) {
-			for (j=0;j&lt;mcp_p-&gt;n_obj;j++)	 /*  remove clones and links pointing on this app-object ... */
-				if (mcp_p-&gt;object[j]!=NULL) {
+	int j, i = p-&gt;n_obj;
+	if (p-&gt;id != MCP) {
+		if (p-&gt;mcp_oid != -1) {
+			for (j = 0;j &lt; mcp_p-&gt;n_obj;j++)  /*  remove clones and links pointing on this app-object ... */
+				if (mcp_p-&gt;object[j] != NULL) {
 					if ((mcp_p-&gt;object[j]-&gt;oflags&amp;OF_CLONE) &amp;&amp; (mcp_p-&gt;object[j]-&gt;n_vertex == p-&gt;mcp_oid)) { /*  it's linking to our object! */
-						mcp_p-&gt;object[j]-&gt;oflags&amp;=~OF_CLONE;  	 /*  disable clone flag */
-						mcp_p-&gt;object[j]-&gt;n_vertex=0; 			 /*  and &quot;clone reference&quot; to 0 */
-						mcp_p-&gt;object[j]-&gt;r=0.0F;				 /*  empty object, so radius is zero! */
+						mcp_p-&gt;object[j]-&gt;oflags &amp;= ~OF_CLONE;  /*  disable clone flag */
+						mcp_p-&gt;object[j]-&gt;n_vertex = 0;   /*  and &quot;clone reference&quot; to 0 */
+						mcp_p-&gt;object[j]-&gt;r = 0.0F;   /*  empty object, so radius is zero! */
 					}
 				}
-			obj_free(mcp_p,p-&gt;mcp_oid); 	 /*  free the mcp-app-object. */
-			mcp_del_object(p-&gt;mcp_oid); 	 /*  tell MCP that it's object is beeing deleted. */
+			obj_free(mcp_p, p-&gt;mcp_oid);  /*  free the mcp-app-object. */
+			mcp_del_object(p-&gt;mcp_oid);   /*  tell MCP that it's object is beeing deleted. */
 		} else /*
-			errs(&quot;p_del()&quot;,&quot;bad mcp_oid, unable to free mcp object&quot;);*/
-			if (i&gt;0) {
-				for (i=0;i&lt;p-&gt;n_obj;i++)
-					if (p-&gt;object[i]) obj_free(p,i);
+   errs(&quot;p_del()&quot;,&quot;bad mcp_oid, unable to free mcp object&quot;);*/
+			if (i &gt; 0) {
+				for (i = 0;i &lt; p-&gt;n_obj;i++)
+					if (p-&gt;object[i]) obj_free(p, i);
 				free(p-&gt;object);
 			}
 	} else {
 		/*  the mcp keeps in our memory ... */
 		/*  so we just delete the objects added */
 		/*  by the last mcp */
-		s3dprintf(MED,&quot;clean up mcp's junk ...&quot;);
-		for (i=0;i&lt;p-&gt;n_obj;i++) {
-			if (p-&gt;object[i]!=NULL)
-				if (!(p-&gt;object[i]-&gt;oflags&amp;(OF_SYSTEM|OF_VIRTUAL)))
-					obj_free(p,i);
+		s3dprintf(MED, &quot;clean up mcp's junk ...&quot;);
+		for (i = 0;i &lt; p-&gt;n_obj;i++) {
+			if (p-&gt;object[i] != NULL)
+				if (!(p-&gt;object[i]-&gt;oflags&amp;(OF_SYSTEM | OF_VIRTUAL)))
+					obj_free(p, i);
 		}
 	}
 	return(0);  /*  successfully deleted */
 }
 int process_init()
 {
-	procs_n=0;
-	procs_p=NULL;
+	procs_n = 0;
+	procs_p = NULL;
 	process_add();
 	/* set up mcp */
-	strncpy(mcp_p-&gt;name,&quot;mcp&quot;,NAME_MAX);
-	mcp_p-&gt;con_type=CON_NULL;
+	strncpy(mcp_p-&gt;name, &quot;mcp&quot;, NAME_MAX);
+	mcp_p-&gt;con_type = CON_NULL;
 	process_sys_init(mcp_p);
 	return(0);
 }
 int process_quit()
 {
 	int i;
-	s3dprintf(HIGH,&quot;telling %d processes to go away&quot;,procs_n);
-	for (i=(procs_n-1);i&gt;=0;i--) {
-		s3dprintf(HIGH,&quot;[QUIT] for %d&quot;,i);
+	s3dprintf(HIGH, &quot;telling %d processes to go away&quot;, procs_n);
+	for (i = (procs_n - 1);i &gt;= 0;i--) {
+		s3dprintf(HIGH, &quot;[QUIT] for %d&quot;, i);
 		event_quit(&amp;procs_p[i]);
-		/*		process_del(procs_p[i].id);*/
+		/*  process_del(procs_p[i].id);*/
 	}
 	free(procs_p);
 	return(0);

Modified: trunk/server/proto.c
===================================================================
--- trunk/server/proto.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/proto.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -35,361 +35,361 @@
 /*  this code should do the protocol work .... */
 /*  */
 extern uint8_t obuf[MAXPLEN];
-int focus_oid=-1;  /*  initially focus the pid */
+int focus_oid = -1;  /*  initially focus the pid */
 /*  handle an incoming command from the client .. */
 
 
 int prot_com_in(struct t_process *p, uint8_t *pbuf)
 {
-	uint8_t 	command;
-	int 	i;
-	char 	name[NAME_MAX];
+	uint8_t  command;
+	int  i;
+	char  name[NAME_MAX];
 	struct t_process *np;
-	uint8_t	*buf,*cptr=NULL;
+	uint8_t *buf, *cptr = NULL;
 	uint16_t length;
 	uint16_t num;
-	uint16_t w,h,x,y;
-	uint32_t oid,toid;
-	uint8_t	type;
-	int32_t flags,mcp_oid=-1;
-	command=pbuf[0];
-	if (p-&gt;id!=0) {
-		mcp_oid=p-&gt;mcp_oid;		 /*  get mcp-oid if we need to report something to */
+	uint16_t w, h, x, y;
+	uint32_t oid, toid;
+	uint8_t type;
+	int32_t flags, mcp_oid = -1;
+	command = pbuf[0];
+	if (p-&gt;id != 0) {
+		mcp_oid = p-&gt;mcp_oid; /*  get mcp-oid if we need to report something to */
 		/*  the mcp */
-		if ((mcp_oid==-1) &amp;&amp; (command!=S3D_P_C_INIT)) {
-			s3dprintf(MED,&quot;prot_com_in(): commands without beeing initialized ?! no way, kicking ...&quot;);
+		if ((mcp_oid == -1) &amp;&amp; (command != S3D_P_C_INIT)) {
+			s3dprintf(MED, &quot;prot_com_in(): commands without beeing initialized ?! no way, kicking ...&quot;);
 			event_quit(p);
 		}
 	}
-	length=ntohs(*((uint16_t *)((uint8_t *)pbuf+1)));
-	cptr=buf=pbuf+3;
-	/* 	if (mcp_oid==-1) s3dprintf(HIGH,&quot;couldn't find mcp-oid for pid %d!&quot;,p-&gt;id); */
+	length = ntohs(*((uint16_t *)((uint8_t *)pbuf + 1)));
+	cptr = buf = pbuf + 3;
+	/*  if (mcp_oid==-1) s3dprintf(HIGH,&quot;couldn't find mcp-oid for pid %d!&quot;,p-&gt;id); */
 	switch (command) {
 	case S3D_P_C_INIT:
-		memset(name,0,NAME_MAX);
-		if (length&gt;NAME_MAX) i=NAME_MAX;
-		else i=length;
-		strncpy(name,(char *)buf,i);
-		s3dprintf(LOW,&quot;[%d]\&quot;%s\&quot; logged in&quot;, p-&gt;id,name);
-		if (NULL==(np=process_protinit(p,name)))
+		memset(name, 0, NAME_MAX);
+		if (length &gt; NAME_MAX) i = NAME_MAX;
+		else i = length;
+		strncpy(name, (char *)buf, i);
+		s3dprintf(LOW, &quot;[%d]\&quot;%s\&quot; logged in&quot;, p-&gt;id, name);
+		if (NULL == (np = process_protinit(p, name)))
 			event_quit(p);  /*  couldn't get process */
 		else
 			event_init(np);
 		break;
 	case S3D_P_C_NEW_OBJ:
-		oid=htonl(obj_new(p));
-		/* 				s3dprintf(LOW,&quot;pid %d registering new object %d&quot;,p-&gt;id,ntohl(oid)); */
-		prot_com_out(p,S3D_P_S_NEWOBJ,(uint8_t *)&amp;oid, 4);
+		oid = htonl(obj_new(p));
+		/*     s3dprintf(LOW,&quot;pid %d registering new object %d&quot;,p-&gt;id,ntohl(oid)); */
+		prot_com_out(p, S3D_P_S_NEWOBJ, (uint8_t *)&amp;oid, 4);
 		break;
 	case S3D_P_C_DEL_OBJ:
-		if (length==4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			obj_del(p,oid);
+		if (length == 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			obj_del(p, oid);
 		}
 		break;
 	case S3D_P_C_CLONE:
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			obj_clone_change(p,oid,toid);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			obj_clone_change(p, oid, toid);
 		}
 		break;
 	case S3D_P_C_LINK:
-		if (length==4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			obj_unlink(p,oid);
+		if (length == 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			obj_unlink(p, oid);
 		}
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			obj_link(p,oid,toid);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			obj_link(p, oid, toid);
 		}
 		break;
 	case S3D_P_C_QUIT:
-		s3dprintf(LOW,&quot;QUIT issued&quot;);
+		s3dprintf(LOW, &quot;QUIT issued&quot;);
 		event_quit(p);
 		break;
 	case S3D_P_C_PUSH_VERTEX:
-		if (length&gt;4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*3);
-			/* 					s3dprintf(LOW,&quot;received %d new vertices for object oid...%d&quot;, num, oid); */
-			obj_push_vertex(p,oid, (float  *)cptr, num);
+		if (length &gt; 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 3);
+			/*      s3dprintf(LOW,&quot;received %d new vertices for object oid...%d&quot;, num, oid); */
+			obj_push_vertex(p, oid, (float  *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PUSH_MAT:
-		if (length&gt;4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*12);
-			/* 					s3dprintf(LOW,&quot;received %d new materials for object oid...%d&quot;, num, oid); */
-			obj_push_mat(p,oid, (float *)cptr, num);
+		if (length &gt; 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 12);
+			/*      s3dprintf(LOW,&quot;received %d new materials for object oid...%d&quot;, num, oid); */
+			obj_push_mat(p, oid, (float *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PUSH_POLY:
-		if (length&gt;4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*4);
-			/* 					s3dprintf(LOW,&quot;received %d new polygons for object oid...%d&quot;, num, oid); */
-			for (i=0;i&lt;(num*4);i++)
-				*((uint32_t *)cptr+i)=
-				        ntohl(*((uint32_t *)cptr+i));
+		if (length &gt; 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 4);
+			/*      s3dprintf(LOW,&quot;received %d new polygons for object oid...%d&quot;, num, oid); */
+			for (i = 0;i &lt; (num*4);i++)
+				*((uint32_t *)cptr + i) =
+				        ntohl(*((uint32_t *)cptr + i));
 			/*  convert index names */
-			obj_push_poly(p,oid, (uint32_t *)cptr, num);
+			obj_push_poly(p, oid, (uint32_t *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PUSH_LINE:
-		if (length&gt;4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*3);
-			s3dprintf(VLOW,&quot;received %d new lines for object oid...%d&quot;, num, oid);
-			for (i=0;i&lt;(num*3);i++)
-				*((uint32_t *)cptr+i)=
-				        ntohl(*((uint32_t *)cptr+i));
+		if (length &gt; 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 3);
+			s3dprintf(VLOW, &quot;received %d new lines for object oid...%d&quot;, num, oid);
+			for (i = 0;i &lt; (num*3);i++)
+				*((uint32_t *)cptr + i) =
+				        ntohl(*((uint32_t *)cptr + i));
 			/*  convert index names */
-			obj_push_line(p,oid, (uint32_t *)cptr, num);
+			obj_push_line(p, oid, (uint32_t *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PUSH_TEX:
-		if (length&gt;4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(2*2);
-			s3dprintf(LOW,&quot;received %d new textures for object oid...%d&quot;, num, oid);
-			for (i=0;i&lt;(num*2);i++)
-				*((uint16_t *)cptr+i)=
-				        ntohs(*((uint16_t *)cptr+i));
+		if (length &gt; 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (2 * 2);
+			s3dprintf(LOW, &quot;received %d new textures for object oid...%d&quot;, num, oid);
+			for (i = 0;i &lt; (num*2);i++)
+				*((uint16_t *)cptr + i) =
+				        ntohs(*((uint16_t *)cptr + i));
 			/*  convert index names */
-			obj_push_tex(p,oid, (uint16_t *)cptr, num);
+			obj_push_tex(p, oid, (uint16_t *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PEP_POLY_NORMAL:
-		if (length&gt;4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(9*4);
-			s3dprintf(VLOW,&quot;PEP_POLY_NORMAL[%d]: oid %d, %f polys&quot;,length,oid, (length-4)/(9.0*4.0));
-			obj_pep_poly_normal(p,oid, (float *)cptr, num);
+		if (length &gt; 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (9 * 4);
+			s3dprintf(VLOW, &quot;PEP_POLY_NORMAL[%d]: oid %d, %f polys&quot;, length, oid, (length - 4) / (9.0*4.0));
+			obj_pep_poly_normal(p, oid, (float *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PEP_LINE_NORMAL:
-		if (length&gt;4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(6*4);
-			s3dprintf(VLOW,&quot;PEP_LINE_NORMAL[%d]: oid %d, %.1f lines&quot;,length,oid, (length-4)/(6.0*4.0));
-			obj_pep_line_normal(p,oid, (float *)cptr, num);
+		if (length &gt; 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (6 * 4);
+			s3dprintf(VLOW, &quot;PEP_LINE_NORMAL[%d]: oid %d, %.1f lines&quot;, length, oid, (length - 4) / (6.0*4.0));
+			obj_pep_line_normal(p, oid, (float *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PEP_POLY_TEXC:
-		if (length&gt;4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(6*4);
-			s3dprintf(VLOW,&quot;PEP_POLY_TEXC[%d]: oid %d, %f polys&quot;,length,oid, (length-4)/(6.0*4.0));
-			obj_pep_poly_texc(p,oid, (float *)cptr, num);
+		if (length &gt; 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (6 * 4);
+			s3dprintf(VLOW, &quot;PEP_POLY_TEXC[%d]: oid %d, %f polys&quot;, length, oid, (length - 4) / (6.0*4.0));
+			obj_pep_poly_texc(p, oid, (float *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PEP_MAT:
-		if (length&gt;4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*12);
-			s3dprintf(VLOW,&quot;PEP_MAT[%d]: %d materials for object oid...%d&quot;, length, num, oid);
-			obj_pep_mat(p,oid, (float *)cptr, num);
+		if (length &gt; 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 12);
+			s3dprintf(VLOW, &quot;PEP_MAT[%d]: %d materials for object oid...%d&quot;, length, num, oid);
+			obj_pep_mat(p, oid, (float *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PEP_VERTEX:
-		if (length&gt;4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*3);
-			s3dprintf(VLOW,&quot;pepping %d new vertices for object oid...%d&quot;, num, oid);
-			obj_pep_vertex(p,oid, (float  *)cptr, num);
+		if (length &gt; 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 3);
+			s3dprintf(VLOW, &quot;pepping %d new vertices for object oid...%d&quot;, num, oid);
+			obj_pep_vertex(p, oid, (float  *)cptr, num);
 		}
 		break;
 
 	case S3D_P_C_PEP_MAT_TEX:
-		if (length&gt;4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4);
-			s3dprintf(VLOW,&quot;PEP_MAT_TEX[%d]: %d materials for object oid...%d&quot;, length, num, oid);
-			obj_pep_mat_tex(p,oid, (uint32_t *)cptr, num);
+		if (length &gt; 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4);
+			s3dprintf(VLOW, &quot;PEP_MAT_TEX[%d]: %d materials for object oid...%d&quot;, length, num, oid);
+			obj_pep_mat_tex(p, oid, (uint32_t *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PEP_LINE:
-		if (length&gt;4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*3);
-			s3dprintf(VLOW,&quot;pepping %d new lines for object oid...%d&quot;, num, oid);
-			for (i=0;i&lt;(num*3);i++)
-				*((uint32_t *)cptr+i)=
-				        ntohl(*((uint32_t *)cptr+i));
-			obj_pep_line(p,oid, (uint32_t *)cptr, num);
+		if (length &gt; 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 3);
+			s3dprintf(VLOW, &quot;pepping %d new lines for object oid...%d&quot;, num, oid);
+			for (i = 0;i &lt; (num*3);i++)
+				*((uint32_t *)cptr + i) =
+				        ntohl(*((uint32_t *)cptr + i));
+			obj_pep_line(p, oid, (uint32_t *)cptr, num);
 		}
 		break;
 	case S3D_P_C_LOAD_LINE_NORMAL:
-		if (length&gt;8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-8)/(6*4);
-			s3dprintf(VLOW,&quot;LOAD_POLY_NORMAL[%d]: oid %d, %.2f lines&quot;,length,oid, (length-8)/(6.0*4.0));
-			obj_load_line_normal(p,oid, (float *)cptr, toid, num);
+		if (length &gt; 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 8) / (6 * 4);
+			s3dprintf(VLOW, &quot;LOAD_POLY_NORMAL[%d]: oid %d, %.2f lines&quot;, length, oid, (length - 8) / (6.0*4.0));
+			obj_load_line_normal(p, oid, (float *)cptr, toid, num);
 		}
 		break;
 	case S3D_P_C_LOAD_POLY_NORMAL:
-		if (length&gt;8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-8)/(9*4);
-			s3dprintf(MED,&quot;LOAD_POLY_NORMAL[%d]: oid %d, %f polys&quot;,length,oid, (length-8)/(9.0*4.0));
-			obj_load_poly_normal(p,oid, (float *)cptr, toid, num);
+		if (length &gt; 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 8) / (9 * 4);
+			s3dprintf(MED, &quot;LOAD_POLY_NORMAL[%d]: oid %d, %f polys&quot;, length, oid, (length - 8) / (9.0*4.0));
+			obj_load_poly_normal(p, oid, (float *)cptr, toid, num);
 		}
 		break;
 	case S3D_P_C_LOAD_POLY_TEXC:
-		if (length&gt;8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-8)/(6*4);
-			s3dprintf(MED,&quot;LOAD_POLY_TEXC[%d]: oid %d, %f polys&quot;,length,oid, (length-8)/(6.0*4.0));
-			obj_load_poly_texc(p,oid, (float *)cptr, toid, num);
+		if (length &gt; 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 8) / (6 * 4);
+			s3dprintf(MED, &quot;LOAD_POLY_TEXC[%d]: oid %d, %f polys&quot;, length, oid, (length - 8) / (6.0*4.0));
+			obj_load_poly_texc(p, oid, (float *)cptr, toid, num);
 		}
 		break;
 	case S3D_P_C_LOAD_MAT:
-		if (length&gt;8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-8)/(4*12);
-			s3dprintf(LOW,&quot;LOAD_MAT[%d]: %d materials for object oid...%d&quot;, length, num, oid);
-			obj_load_mat(p,oid, (float *)cptr, toid, num);
+		if (length &gt; 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 8) / (4 * 12);
+			s3dprintf(LOW, &quot;LOAD_MAT[%d]: %d materials for object oid...%d&quot;, length, num, oid);
+			obj_load_mat(p, oid, (float *)cptr, toid, num);
 		}
 		break;
 	case S3D_P_C_LOAD_TEX:
-		if (length&gt;8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			x=ntohs(*((uint16_t *)cptr));
-			cptr+=2;
-			y=ntohs(*((uint16_t *)cptr));
-			cptr+=2;
-			w=ntohs(*((uint16_t *)cptr));
-			cptr+=2;
-			h=ntohs(*((uint16_t *)cptr));
-			cptr+=2;
-			num=length-16;
-			/* 				s3dprintf(MED,&quot;LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)&quot;,length, oid,toid,w,h,x,y,num,w*h*4,num); */
-			if ((w*h*4)==num)  /*  check correct size */
-				obj_load_tex(p,oid, toid, x, y, w, h, cptr);
+		if (length &gt; 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			x = ntohs(*((uint16_t *)cptr));
+			cptr += 2;
+			y = ntohs(*((uint16_t *)cptr));
+			cptr += 2;
+			w = ntohs(*((uint16_t *)cptr));
+			cptr += 2;
+			h = ntohs(*((uint16_t *)cptr));
+			cptr += 2;
+			num = length - 16;
+			/*     s3dprintf(MED,&quot;LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)&quot;,length, oid,toid,w,h,x,y,num,w*h*4,num); */
+			if ((w*h*4) == num)  /*  check correct size */
+				obj_load_tex(p, oid, toid, x, y, w, h, cptr);
 		}
 		break;
 	case S3D_P_C_DEL_VERTEX:
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			/* 					s3dprintf(LOW,&quot;deleting %d vertices for object oid...%d&quot;, num, oid); */
-			obj_del_vertex(p,oid,num);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			/*      s3dprintf(LOW,&quot;deleting %d vertices for object oid...%d&quot;, num, oid); */
+			obj_del_vertex(p, oid, num);
 		}
 		break;
 	case S3D_P_C_DEL_POLY:
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			/* 					s3dprintf(LOW,&quot;deleting %d vertices for object oid...%d&quot;, num, oid); */
-			obj_del_poly(p,oid,num);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			/*      s3dprintf(LOW,&quot;deleting %d vertices for object oid...%d&quot;, num, oid); */
+			obj_del_poly(p, oid, num);
 		}
 		break;
 	case S3D_P_C_DEL_LINE:
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			s3dprintf(VLOW,&quot;deleting %d lines for object oid...%d&quot;, num, oid);
-			obj_del_line(p,oid,num);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			s3dprintf(VLOW, &quot;deleting %d lines for object oid...%d&quot;, num, oid);
+			obj_del_line(p, oid, num);
 		}
 		break;
 
 	case S3D_P_C_DEL_MAT:
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			/* 					s3dprintf(LOW,&quot;deleting %d materials for object oid...%d&quot;, num, oid); */
-			obj_del_mat(p,oid,num);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			/*      s3dprintf(LOW,&quot;deleting %d materials for object oid...%d&quot;, num, oid); */
+			obj_del_mat(p, oid, num);
 		}
 		break;
 	case S3D_P_C_DEL_TEX:
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			/* 					s3dprintf(LOW,&quot;deleting %d textures for object oid...%d&quot;, num, oid); */
-			obj_del_tex(p,oid,num);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			/*      s3dprintf(LOW,&quot;deleting %d textures for object oid...%d&quot;, num, oid); */
+			obj_del_tex(p, oid, num);
 		}
 		break;
 	case S3D_P_C_TOGGLE_FLAGS:
-		if (length==9) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			type=*cptr;
-			cptr+=1;
-			flags=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			obj_toggle_flags(p,oid, type, flags);
+		if (length == 9) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			type = *cptr;
+			cptr += 1;
+			flags = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			obj_toggle_flags(p, oid, type, flags);
 		}
 		break;
 	case S3D_P_C_TRANSLATE:
-		if (length&gt;=16) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			obj_translate(p,oid,(float *)cptr);
+		if (length &gt;= 16) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			obj_translate(p, oid, (float *)cptr);
 		}
 		break;
 	case S3D_P_C_ROTATE:
-		if (length&gt;=16) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			obj_rotate(p,oid,(float *)cptr);
+		if (length &gt;= 16) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			obj_rotate(p, oid, (float *)cptr);
 		}
 		break;
 	case S3D_P_C_SCALE:
-		if (length&gt;=8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			obj_scale(p,oid,*((float *)cptr));
+		if (length &gt;= 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			obj_scale(p, oid, *((float *)cptr));
 		}
 		break;
 	case S3D_P_MCP_FOCUS:
-		if ((p-&gt;id==MCP) &amp;&amp; (length==4)) {
-			oid=ntohl(*((uint32_t *)cptr));
+		if ((p-&gt;id == MCP) &amp;&amp; (length == 4)) {
+			oid = ntohl(*((uint32_t *)cptr));
 			mcp_focus(oid);
 		}
 		break;
 	default:
-		s3dprintf(LOW,&quot;don't know this command (%d)&quot;,command);
+		s3dprintf(LOW, &quot;don't know this command (%d)&quot;, command);
 	}
 	return(0);
 }
@@ -397,14 +397,14 @@
 int prot_com_out(struct t_process *p, uint8_t opcode, uint8_t *buf, uint16_t length)
 {
 	uint8_t *ptr;
-	if (p-&gt;con_type!=CON_NULL) {
-		*(obuf)=opcode;
-		ptr=obuf+1;
-		*((uint16_t *) ptr)=htons(length);
+	if (p-&gt;con_type != CON_NULL) {
+		*(obuf) = opcode;
+		ptr = obuf + 1;
+		*((uint16_t *) ptr) = htons(length);
 		if (length)
-			memcpy(obuf+3,buf,length);
-		if (n_writen(p,obuf,length+3)&lt;0) {
-			s3dprintf(LOW,&quot;prot_com_out():n_writen(): connection seems to be dead (pid %d)&quot;, p-&gt;id);
+			memcpy(obuf + 3, buf, length);
+		if (n_writen(p, obuf, length + 3) &lt; 0) {
+			s3dprintf(LOW, &quot;prot_com_out():n_writen(): connection seems to be dead (pid %d)&quot;, p-&gt;id);
 			process_del(p-&gt;id);
 		}
 		return(0);

Modified: trunk/server/proto.h
===================================================================
--- trunk/server/proto.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/proto.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -34,151 +34,151 @@
 /*  C/S defines if who can invoke the command  */
 /*  */
 /*  every command is 1 byte long, arguments differ. */
-#define S3D_P_C_INIT			1
-/*  max 256b: 	name */
-#define S3D_P_C_QUIT			2  /*  no argument */
+#define S3D_P_C_INIT   1
+/*  max 256b:  name */
+#define S3D_P_C_QUIT   2  /*  no argument */
 
-#define S3D_P_C_NEW_OBJ			3  /*  add a new object */
-/*  return: 4b:	object id  */
-#define S3D_P_C_DEL_OBJ			4
-/*  4b:			object id */
-#define S3D_P_C_CLONE			5
-/*  4b:			object id */
+#define S3D_P_C_NEW_OBJ   3  /*  add a new object */
+/*  return: 4b: object id  */
+#define S3D_P_C_DEL_OBJ   4
+/*  4b:   object id */
+#define S3D_P_C_CLONE   5
+/*  4b:   object id */
 /*  return: 4b: object id */
-/*  if 8b: 		 */
-/*  4b:			object id */
-/*  4b:			target oid */
-#define S3D_P_C_LINK			6
+/*  if 8b:    */
+/*  4b:   object id */
+/*  4b:   target oid */
+#define S3D_P_C_LINK   6
 /*  if 4b: */
-/*  4b:		oid (for unlink) */
+/*  4b:  oid (for unlink) */
 /*  if 8b: */
-/*  4b:		oid from */
-/*  4b:		oid to */
-#define S3D_P_C_PUSH_LINE		7
-/*  4b: 		object id */
-/*  n*3d		from vertex, to vertex, color */
-#define S3D_P_C_PUSH_VERTEX		8
-/*  4b:		object id */
-/*  n*3f:	vertexes, each with x,y,z in float */
-#define S3D_P_C_PUSH_MAT		9
-/*  4b:		object id */
-/*  3*4f:	material elements [amb,spec,diff with r,g,b,a] */
-#define S3D_P_C_PUSH_POLY		10
-/*  4b:		object id */
-#define S3D_P_C_PUSH_TEX		11
-/*  4b: 			object id */
-/*  nx(2x2b):	width,height */
-#define S3D_P_C_DEL_VERTEX		12
-/*  4b:		object id */
-/*  4b:		number */
-#define S3D_P_C_DEL_POLY		13
-/*  4b:		object id */
-/*  4b:		number */
-#define S3D_P_C_DEL_MAT			14
-/*  4b:		object id */
-/*  4b:		number */
-#define S3D_P_C_DEL_TEX			15
-/*  4b:		object id */
-/*  4b:		number */
-#define S3D_P_C_PEP_POLY_NORMAL	16
-/*  4b:		object id */
-/*  n*9f:		normals (3* x/y/z for each vertex of the poly) */
-#define S3D_P_C_PEP_POLY_TEXC	17
-/*  4b:		object id */
-/*  n*6f		poly texture coordinates (3* u/v for each vertex of the poly) */
-#define S3D_P_C_PEP_MAT			18
-/*  4b:		object id */
-/*  3*4f:		material elements [amb,spec,diff with r,g,b,a] */
-#define S3D_P_C_PEP_MAT_TEX		19
-/*  4b:		object id */
-/*  4b:		texture index references */
-#define S3D_P_C_PEP_VERTEX		20
-/*  4b:		object id */
-/*  n*3f:	vertexes, each with x,y,z in float */
-#define S3D_P_C_PEP_LINE		21
-/* 4b:			object id */
-/* n*3u:		line information (from,to,color)*/
-#define S3D_P_C_DEL_LINE		22
-/*  4b:		object id */
-/*  4b:		number */
-#define S3D_P_C_PEP_LINE_NORMAL	23
-/*  4b:		object id */
-/*  n*6f:		normals (2* x/y/z for each vertex of the line) */
-#define S3D_P_C_LOAD_POLY_NORMAL	24
-/*  4b:		object id */
-/*  4b:		position */
-/*  n*9f:	normals (3* x/y/z for each vertex of the poly) */
-#define S3D_P_C_LOAD_POLY_TEXC	25
-/*  4b:		object id */
-/*  4b:		position */
-/*  n*6f		poly texture coordinates (3* u/v for each vertex of the poly) */
-#define S3D_P_C_LOAD_MAT		26
-/*  4b:		object id */
-/*  4b:		position */
-/*  3*4f:	material elements [amb,spec,diff with r,g,b,a] */
-#define S3D_P_C_LOAD_TEX		28
-/*  4b:		object id */
-/*  4b:		texture number */
-/*  4*2b:	xpos,ypos,width,height */
-/*  n*2b:	pixbuf (16bit) */
-#define S3D_P_C_LOAD_MAT_TEX	29
-/*  4b:		object id */
-/*  4b:		texture index references */
+/*  4b:  oid from */
+/*  4b:  oid to */
+#define S3D_P_C_PUSH_LINE  7
+/*  4b:   object id */
+/*  n*3d  from vertex, to vertex, color */
+#define S3D_P_C_PUSH_VERTEX  8
+/*  4b:  object id */
+/*  n*3f: vertexes, each with x,y,z in float */
+#define S3D_P_C_PUSH_MAT  9
+/*  4b:  object id */
+/*  3*4f: material elements [amb,spec,diff with r,g,b,a] */
+#define S3D_P_C_PUSH_POLY  10
+/*  4b:  object id */
+#define S3D_P_C_PUSH_TEX  11
+/*  4b:    object id */
+/*  nx(2x2b): width,height */
+#define S3D_P_C_DEL_VERTEX  12
+/*  4b:  object id */
+/*  4b:  number */
+#define S3D_P_C_DEL_POLY  13
+/*  4b:  object id */
+/*  4b:  number */
+#define S3D_P_C_DEL_MAT   14
+/*  4b:  object id */
+/*  4b:  number */
+#define S3D_P_C_DEL_TEX   15
+/*  4b:  object id */
+/*  4b:  number */
+#define S3D_P_C_PEP_POLY_NORMAL 16
+/*  4b:  object id */
+/*  n*9f:  normals (3* x/y/z for each vertex of the poly) */
+#define S3D_P_C_PEP_POLY_TEXC 17
+/*  4b:  object id */
+/*  n*6f  poly texture coordinates (3* u/v for each vertex of the poly) */
+#define S3D_P_C_PEP_MAT   18
+/*  4b:  object id */
+/*  3*4f:  material elements [amb,spec,diff with r,g,b,a] */
+#define S3D_P_C_PEP_MAT_TEX  19
+/*  4b:  object id */
+/*  4b:  texture index references */
+#define S3D_P_C_PEP_VERTEX  20
+/*  4b:  object id */
+/*  n*3f: vertexes, each with x,y,z in float */
+#define S3D_P_C_PEP_LINE  21
+/* 4b:   object id */
+/* n*3u:  line information (from,to,color)*/
+#define S3D_P_C_DEL_LINE  22
+/*  4b:  object id */
+/*  4b:  number */
+#define S3D_P_C_PEP_LINE_NORMAL 23
+/*  4b:  object id */
+/*  n*6f:  normals (2* x/y/z for each vertex of the line) */
+#define S3D_P_C_LOAD_POLY_NORMAL 24
+/*  4b:  object id */
+/*  4b:  position */
+/*  n*9f: normals (3* x/y/z for each vertex of the poly) */
+#define S3D_P_C_LOAD_POLY_TEXC 25
+/*  4b:  object id */
+/*  4b:  position */
+/*  n*6f  poly texture coordinates (3* u/v for each vertex of the poly) */
+#define S3D_P_C_LOAD_MAT  26
+/*  4b:  object id */
+/*  4b:  position */
+/*  3*4f: material elements [amb,spec,diff with r,g,b,a] */
+#define S3D_P_C_LOAD_TEX  28
+/*  4b:  object id */
+/*  4b:  texture number */
+/*  4*2b: xpos,ypos,width,height */
+/*  n*2b: pixbuf (16bit) */
+#define S3D_P_C_LOAD_MAT_TEX 29
+/*  4b:  object id */
+/*  4b:  texture index references */
 #define S3D_P_C_LOAD_LINE_NORMAL 30
-/*  4b:		object id */
-/*  4b:		position */
-/*  n*6f:		normals (2* x/y/z for each vertex of the line) */
+/*  4b:  object id */
+/*  4b:  position */
+/*  n*6f:  normals (2* x/y/z for each vertex of the line) */
 
 
-#define S3D_P_C_TOGGLE_FLAGS 	32
-/*  4b:		object id */
-/*  1b:		type  */
-/*  4b:		flags */
-#define S3D_P_C_TRANSLATE 		33
-/*  4b:		object id */
-/*  3f:		position */
-#define S3D_P_C_ROTATE			34
-/*  4b:		object id */
-/*  3f:		rotation angle over x,y,z axis */
-#define S3D_P_C_SCALE			35
-/*  4b: 		object id */
-/*  1f:		scale */
-#define S3D_P_C_GET_SIZE		36
+#define S3D_P_C_TOGGLE_FLAGS  32
+/*  4b:  object id */
+/*  1b:  type  */
+/*  4b:  flags */
+#define S3D_P_C_TRANSLATE   33
+/*  4b:  object id */
+/*  3f:  position */
+#define S3D_P_C_ROTATE   34
+/*  4b:  object id */
+/*  3f:  rotation angle over x,y,z axis */
+#define S3D_P_C_SCALE   35
+/*  4b:   object id */
+/*  1f:  scale */
+#define S3D_P_C_GET_SIZE  36
 /*  4b: object id */
-#define S3D_P_MCP_FOCUS			66		 /*  set the app which should get the keystrokes etc */
-/*  4b:		object id/pid */
+#define S3D_P_MCP_FOCUS   66   /*  set the app which should get the keystrokes etc */
+/*  4b:  object id/pid */
 /*  */
 /*  */
 /*   */
-#define S3D_P_MCP_OBJECT	67
-/*  4b: 		oid */
-/*  3*f:		translate */
+#define S3D_P_MCP_OBJECT 67
+/*  4b:   oid */
+/*  3*f:  translate */
 /*  ... ? */
 /*  max 256b:name */
 #define S3D_P_MCP_DEL_OBJECT 68
 
-#define S3D_P_S_INIT	1
+#define S3D_P_S_INIT 1
 /*  1b: acknowledged */
 /*  3b: version,major,minor */
 /*  description string */
-#define S3D_P_S_QUIT	2
-#define S3D_P_S_CLICK	3
+#define S3D_P_S_QUIT 2
+#define S3D_P_S_CLICK 3
 /*  4b: oid */
-#define	S3D_P_S_KEY		4
+#define S3D_P_S_KEY  4
 /*  2b: button */
 /*  2b: unicode translation */
 /*  2b: modifier information */
 /*  2b: state */
-#define S3D_P_S_MBUTTON	5
+#define S3D_P_S_MBUTTON 5
 /*  1b: button number */
 /*  2b: butotn state */
-#define S3D_P_S_NEWOBJ	16
+#define S3D_P_S_NEWOBJ 16
 /*  4b: oid */
 
-#define S3D_P_S_OINFO	32
-/*  4b: 		oid */
-/*  3*f:		translate */
-/*  3*f:		rotate */
-/*  1*f:		scale */
-/*  1*f:		radius */
+#define S3D_P_S_OINFO 32
+/*  4b:   oid */
+/*  3*f:  translate */
+/*  3*f:  rotate */
+/*  1*f:  scale */
+/*  1*f:  radius */
 /*  max 256b:name */

Modified: trunk/server/shm.c
===================================================================
--- trunk/server/shm.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/shm.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,15 +24,15 @@
 
 #include &quot;global.h&quot;
 #ifdef G_SDL
-#include &lt;SDL.h&gt;	/* SDL_SetTimer() */
+#include &lt;SDL.h&gt; /* SDL_SetTimer() */
 #endif
 #ifdef SHM
 #include &lt;stdio.h&gt;  /* printf(),fopen(),fclose() */
-#include &lt;unistd.h&gt;	/* unlink(),usleep() */
+#include &lt;unistd.h&gt; /* unlink(),usleep() */
 #include &lt;stdlib.h&gt; /* realloc(),free() */
 #include &lt;string.h&gt; /* memcpy() */
-#include &lt;signal.h&gt;	/* signal() */
-#include &lt;errno.h&gt;	/* errno */
+#include &lt;signal.h&gt; /* signal() */
+#include &lt;errno.h&gt; /* errno */
 #ifdef WIN32  /*  sohn wars */
 #include &lt;winsock2.h&gt;
 #else  /* sohn wars */
@@ -41,23 +41,23 @@
 #include &lt;sys/types.h&gt;
 #include &lt;sys/ipc.h&gt;
 #include &lt;sys/shm.h&gt;
-#include &lt;time.h&gt;	/* nanosleep() */
+#include &lt;time.h&gt; /* nanosleep() */
 
 extern uint8_t ibuf[MAXPLEN];
 extern struct t_process *procs_p;
 extern int procs_n;
 struct t_shmcb waiting_comblock;
 
-key_t *data=NULL;
-char ftoken[]=&quot;/tmp/.s3d&quot;;
+key_t *data = NULL;
+char ftoken[] = &quot;/tmp/.s3d&quot;;
 int shmid;
-int mkey;	/* increasing key */
+int mkey; /* increasing key */
 
 static int shm_new_comblock(key_t *data);
 
 static int next_key(int oldkey)
 {
-	return(oldkey+1);
+	return(oldkey + 1);
 }
 int shm_init()
 {
@@ -65,25 +65,25 @@
 	key_t key;
 
 	/* create an empty token file */
-	fp=fopen(ftoken,&quot;w&quot;);
+	fp = fopen(ftoken, &quot;w&quot;);
 	fclose(fp);
 	/* make the key: */
 	if ((key = ftok(ftoken, 'R')) == -1) {
-		errnf(&quot;shm_init():ftok()&quot;,errno);
+		errnf(&quot;shm_init():ftok()&quot;, errno);
 		return(1);
 	}
-	s3dprintf(LOW,&quot;shm_init(): init key is 0x%08x&quot;,key);
-	mkey=next_key(key);
+	s3dprintf(LOW, &quot;shm_init(): init key is 0x%08x&quot;, key);
+	mkey = next_key(key);
 	/* connect to (and possibly create) the segment: */
 	if ((shmid = shmget(key, SHM_SIZE, 0644 | IPC_CREAT)) == -1) {
-		errnf(&quot;shm_init():shmget()&quot;,errno);
+		errnf(&quot;shm_init():shmget()&quot;, errno);
 		return(1);
 	}
 
 	/* attach to the segment to get a pointer to it: */
 	data = shmat(shmid, (void *)0, 0);
 	if (data == (key_t *)(-1)) {
-		errnf(&quot;shm_init():shmat()&quot;,errno);
+		errnf(&quot;shm_init():shmat()&quot;, errno);
 		return(1);
 	}
 	shm_new_comblock(data);
@@ -91,136 +91,136 @@
 }
 void comblock_init(struct t_shmcb *p_cb)
 {
-	p_cb-&gt;shmid_ctos=-1;
-	p_cb-&gt;shmid_stoc=-1;
-	p_cb-&gt;key_stoc=-1;
-	p_cb-&gt;key_ctos=-1;
-	p_cb-&gt;data_ctos=NULL;
-	p_cb-&gt;data_stoc=NULL;
+	p_cb-&gt;shmid_ctos = -1;
+	p_cb-&gt;shmid_stoc = -1;
+	p_cb-&gt;key_stoc = -1;
+	p_cb-&gt;key_ctos = -1;
+	p_cb-&gt;data_ctos = NULL;
+	p_cb-&gt;data_stoc = NULL;
 }
 /* registers a communication block, and sets waiting_comblock */
 static int shm_new_comblock(key_t *data)
 {
 	struct t_shmcb *mycb;
 	comblock_init(&amp;waiting_comblock);
-	mycb=&amp;waiting_comblock;
-	mycb-&gt;key_stoc=mkey;
-	mkey=next_key(mkey);
-	mycb-&gt;key_ctos=mkey;
-	mkey=next_key(mkey);
-	s3dprintf(MED,&quot;shm_open_comblock():stoc: %08x, ctos: %08x&quot;,mycb-&gt;key_stoc,mycb-&gt;key_ctos);
+	mycb = &amp;waiting_comblock;
+	mycb-&gt;key_stoc = mkey;
+	mkey = next_key(mkey);
+	mycb-&gt;key_ctos = mkey;
+	mkey = next_key(mkey);
+	s3dprintf(MED, &quot;shm_open_comblock():stoc: %08x, ctos: %08x&quot;, mycb-&gt;key_stoc, mycb-&gt;key_ctos);
 	/* connect &amp; create the client to server segment: */
 	if ((mycb-&gt;shmid_ctos = shmget(mycb-&gt;key_ctos, RB_STD_SIZE, 0644 | IPC_CREAT)) == -1) {
-		errn(&quot;shm_open_comblock:shmget()&quot;,errno);
+		errn(&quot;shm_open_comblock:shmget()&quot;, errno);
 		return(1);
 	}
 	mycb-&gt;data_ctos = shmat(mycb-&gt;shmid_ctos, (void *)0, 0);
 	if (mycb-&gt;data_ctos == (char *)(-1)) {
-		errn(&quot;shm_open_comblock:shmat()&quot;,errno);
+		errn(&quot;shm_open_comblock:shmat()&quot;, errno);
 		return(1);
 	}
 	/* connect &amp; create the client to server segment: */
 	if ((mycb-&gt;shmid_stoc = shmget(mycb-&gt;key_stoc, RB_STD_SIZE, 0644 | IPC_CREAT)) == -1) {
-		errn(&quot;shm_open_comblock:shmget()&quot;,errno);
+		errn(&quot;shm_open_comblock:shmget()&quot;, errno);
 		return(1);
 	}
 	mycb-&gt;data_stoc = shmat(mycb-&gt;shmid_stoc, (void *)0, 0);
 	if (mycb-&gt;data_stoc == (char *)(-1)) {
-		errn(&quot;shm_open_comblock:shmat()&quot;,errno);
+		errn(&quot;shm_open_comblock:shmat()&quot;, errno);
 		return(1);
 	}
 
 	/* init ringbuffers */
-	ringbuf_init(mycb-&gt;data_stoc,RB_STD_SIZE);
-	ringbuf_init(mycb-&gt;data_ctos,RB_STD_SIZE);
-	data[0]=mycb-&gt;key_ctos;
-	data[1]=mycb-&gt;key_stoc;
-	mycb-&gt;idle=0;
-	s3dprintf(LOW,&quot;shm_open_comblock():data: %08x, %08x&quot;,data[0],data[1]);
+	ringbuf_init(mycb-&gt;data_stoc, RB_STD_SIZE);
+	ringbuf_init(mycb-&gt;data_ctos, RB_STD_SIZE);
+	data[0] = mycb-&gt;key_ctos;
+	data[1] = mycb-&gt;key_stoc;
+	mycb-&gt;idle = 0;
+	s3dprintf(LOW, &quot;shm_open_comblock():data: %08x, %08x&quot;, data[0], data[1]);
 	return(0);
 }
 
 int shm_quit()
 {
 	/* detach from the segment: */
-	s3dprintf(LOW,&quot;shm_quit()...&quot;);
+	s3dprintf(LOW, &quot;shm_quit()...&quot;);
 	unlink(ftoken);
-	if (data!=NULL) {
-		data[0]=data[1]=0;
-		data=0;
-		s3dprintf(MED,&quot;shm_quit():removing init block&quot;);
+	if (data != NULL) {
+		data[0] = data[1] = 0;
+		data = 0;
+		s3dprintf(MED, &quot;shm_quit():removing init block&quot;);
 		if (shmdt(data) == -1)
-			errn(&quot;shm_quit():shmdt()&quot;,errno);
+			errn(&quot;shm_quit():shmdt()&quot;, errno);
 		if (shmctl(shmid, IPC_RMID, NULL) == -1)
-			errn(&quot;shm_quit():shmctl()&quot;,errno);
+			errn(&quot;shm_quit():shmctl()&quot;, errno);
 	}
 	return(0);
 }
 int shm_remove(struct t_process *p)
 {
-	s3dprintf(MED,&quot;shm_remove(): removing pid %d&quot;,p-&gt;id);
-	s3dprintf(MED,&quot;shm_remove():freeing keys: %08x, %08x&quot;,p-&gt;shmsock.key_ctos,p-&gt;shmsock.key_stoc);
+	s3dprintf(MED, &quot;shm_remove(): removing pid %d&quot;, p-&gt;id);
+	s3dprintf(MED, &quot;shm_remove():freeing keys: %08x, %08x&quot;, p-&gt;shmsock.key_ctos, p-&gt;shmsock.key_stoc);
 	if (shmdt(p-&gt;shmsock.data_ctos) == -1)
-		errn(&quot;shm_rmove():shmdt()&quot;,errno);
+		errn(&quot;shm_rmove():shmdt()&quot;, errno);
 	if (shmctl(p-&gt;shmsock.shmid_ctos, IPC_RMID, NULL) == -1)
-		errn(&quot;shm_quit():shmctl()&quot;,errno);
+		errn(&quot;shm_quit():shmctl()&quot;, errno);
 	if (shmdt(p-&gt;shmsock.data_stoc) == -1)
-		errn(&quot;shm_quit():shmdt()&quot;,errno);
+		errn(&quot;shm_quit():shmdt()&quot;, errno);
 	if (shmctl(p-&gt;shmsock.shmid_stoc, IPC_RMID, NULL) == -1)
-		errn(&quot;shm_quit():shmctl()&quot;,errno);
+		errn(&quot;shm_quit():shmctl()&quot;, errno);
 	return(0);
 }
 
-extern int	turn;	/* set turn to 0 when timeslice is over */
+extern int turn; /* set turn to 0 when timeslice is over */
 int shm_main()
 {
-	int 				 i/*,found*/;
-	struct buf_t 		*dai; /* data in, data out */
-	struct t_process	*new_p;
-	struct shmid_ds		 d;
-	/*	do*/
+	int      i/*,found*/;
+	struct buf_t   *dai; /* data in, data out */
+	struct t_process *new_p;
+	struct shmid_ds   d;
+	/* do*/
 	{
-		/*		found=0;*/
-		turn=1;
-		for (i=0;i&lt;procs_n;i++) {
+		/*  found=0;*/
+		turn = 1;
+		for (i = 0;i &lt; procs_n;i++) {
 #ifdef G_SDL
-			SDL_SetTimer(100,(SDL_TimerCallback) net_turn_off);
+			SDL_SetTimer(100, (SDL_TimerCallback) net_turn_off);
 #endif
-			if (procs_p[i].con_type==CON_SHM) {
-				dai=(struct buf_t *) procs_p[i].shmsock.data_ctos;
-				if (dai-&gt;start!=dai-&gt;end) {
-					/*					found=1;*/
-					procs_p[i].shmsock.idle=0;
+			if (procs_p[i].con_type == CON_SHM) {
+				dai = (struct buf_t *) procs_p[i].shmsock.data_ctos;
+				if (dai-&gt;start != dai-&gt;end) {
+					/*     found=1;*/
+					procs_p[i].shmsock.idle = 0;
 					shm_prot_com_in(&amp;procs_p[i]);
 					if (turn)
 						i--; /* evil hack: decrease i so it will be our turn again in the next round */
 					else {
-						s3dprintf(MED,&quot;client %d [%s] seems to want to keep us busy ... &quot;,i, procs_p[i].name);
-						turn=1; /* don't decrease, it's next connections turn */
+						s3dprintf(MED, &quot;client %d [%s] seems to want to keep us busy ... &quot;, i, procs_p[i].name);
+						turn = 1; /* don't decrease, it's next connections turn */
 					}
 				} else {
-					if (procs_p[i].shmsock.idle++&gt;MAX_IDLE) { /* maybe the function timed out somehow ...? let's check ...*/
-						shmctl(procs_p[i].shmsock.shmid_ctos,IPC_STAT,&amp;d);
-						if (d.shm_nattch==1) { /* we're all alone ... remove it!! */
-							s3dprintf(MED,&quot;client [%s] detached, removing ... &quot;,procs_p[i].name);
+					if (procs_p[i].shmsock.idle++ &gt; MAX_IDLE) { /* maybe the function timed out somehow ...? let's check ...*/
+						shmctl(procs_p[i].shmsock.shmid_ctos, IPC_STAT, &amp;d);
+						if (d.shm_nattch == 1) { /* we're all alone ... remove it!! */
+							s3dprintf(MED, &quot;client [%s] detached, removing ... &quot;, procs_p[i].name);
 							process_del(procs_p[i].id);
 						} else {
-							procs_p[i].shmsock.idle=0;
+							procs_p[i].shmsock.idle = 0;
 						}
 					}
 				}
 			}
 		}
 #ifdef G_SDL
-		SDL_SetTimer(0,NULL);
+		SDL_SetTimer(0, NULL);
 #endif
 	} /*while (found);*/
-	if ((data[0]==0) &amp;&amp; (data[1]==0)) {
-		new_p=process_add();
-		new_p-&gt;con_type=CON_SHM;
-		memcpy(&amp;new_p-&gt;shmsock,&amp;waiting_comblock,sizeof(struct t_shmcb));
-		s3dprintf(HIGH,&quot;shm_main():registered new connection (keys %d, %d) as pid %d&quot;,new_p-&gt;shmsock.key_ctos,new_p-&gt;shmsock.key_stoc, new_p-&gt;id);
-		s3dprintf(LOW,&quot;shm_main():new client attached! allocating shm block for further clients ...&quot;);
+	if ((data[0] == 0) &amp;&amp; (data[1] == 0)) {
+		new_p = process_add();
+		new_p-&gt;con_type = CON_SHM;
+		memcpy(&amp;new_p-&gt;shmsock, &amp;waiting_comblock, sizeof(struct t_shmcb));
+		s3dprintf(HIGH, &quot;shm_main():registered new connection (keys %d, %d) as pid %d&quot;, new_p-&gt;shmsock.key_ctos, new_p-&gt;shmsock.key_stoc, new_p-&gt;id);
+		s3dprintf(LOW, &quot;shm_main():new client attached! allocating shm block for further clients ...&quot;);
 		if (shm_new_comblock(data))
 			return(1);
 	}
@@ -228,60 +228,60 @@
 }
 int shm_prot_com_in(struct t_process *p)
 {
-	uint16_t	length;
+	uint16_t length;
 	struct buf_t *dai;
-	dai=(struct buf_t *)p-&gt;shmsock.data_ctos;
-	if (dai!=NULL)
-		/*	if ((pid=get_proc_by_dai( */
-		if (3==shm_readn(dai,ibuf,3)) {
-			length=ntohs(*((uint16_t *)((uint8_t *)ibuf+1)));
-			s3dprintf(VLOW,&quot;command %d, length %d&quot;,ibuf[0], length);
-			if (length&gt;0) {
-				shm_readn(dai,ibuf+3,length);
+	dai = (struct buf_t *)p-&gt;shmsock.data_ctos;
+	if (dai != NULL)
+		/* if ((pid=get_proc_by_dai( */
+		if (3 == shm_readn(dai, ibuf, 3)) {
+			length = ntohs(*((uint16_t *)((uint8_t *)ibuf + 1)));
+			s3dprintf(VLOW, &quot;command %d, length %d&quot;, ibuf[0], length);
+			if (length &gt; 0) {
+				shm_readn(dai, ibuf + 3, length);
 			}
-			prot_com_in(p,ibuf);
+			prot_com_in(p, ibuf);
 		}
 	return(0);
 }
-#define SHM_MAXLOOP		20
-static	struct timespec t= {
-	0,1000*1000
+#define SHM_MAXLOOP  20
+static struct timespec t = {
+	0, 1000*1000
 }; /* 1 mili seconds */
-int shm_writen(struct buf_t *rb,uint8_t *buf, int n)
+int shm_writen(struct buf_t *rb, uint8_t *buf, int n)
 {
-	int no_left,no_written,wait=0;
+	int no_left, no_written, wait = 0;
 	no_left = n;
 	while (no_left &gt; 0) {
-		no_written = shm_write(rb,(char *)buf,no_left);
-		if (no_written &lt;=0)
+		no_written = shm_write(rb, (char *)buf, no_left);
+		if (no_written &lt;= 0)
 			return(no_written);
 		no_left -= no_written;
 		buf += no_written;
-		if (wait++&gt;SHM_MAXLOOP) {
-			s3dprintf(HIGH,&quot;shm_writen():waited too long ...&quot;);
+		if (wait++ &gt; SHM_MAXLOOP) {
+			s3dprintf(HIGH, &quot;shm_writen():waited too long ...&quot;);
 			return(-1);
 		}
-		if (wait&gt;10)		nanosleep(&amp;t,NULL);
+		if (wait &gt; 10)  nanosleep(&amp;t, NULL);
 	}
 	return(n - no_left);
 }
-int shm_readn(struct buf_t *rb,uint8_t *buf, int n)
+int shm_readn(struct buf_t *rb, uint8_t *buf, int n)
 {
-	int no_left,no_read,wait=0;
+	int no_left, no_read, wait = 0;
 	no_left = n;
 	while (no_left &gt; 0) {
-		no_read = shm_read(rb,(char *)buf,no_left);
-		if (no_read &lt;0)
+		no_read = shm_read(rb, (char *)buf, no_left);
+		if (no_read &lt; 0)
 			return(no_read);
 		if (no_read == 0)
 			break;
 		no_left -= no_read;
 		buf += no_read;
-		if (wait++&gt;SHM_MAXLOOP) {
-			s3dprintf(HIGH,&quot;shm_readn():waited too long ...&quot;);
+		if (wait++ &gt; SHM_MAXLOOP) {
+			s3dprintf(HIGH, &quot;shm_readn():waited too long ...&quot;);
 			return(-1);
 		}
-		if (wait&gt;10)		nanosleep(&amp;t,NULL);
+		if (wait &gt; 10)  nanosleep(&amp;t, NULL);
 	}
 	return(n - no_left);
 }

Modified: trunk/server/shm_ringbuf.c
===================================================================
--- trunk/server/shm_ringbuf.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/shm_ringbuf.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,88 +23,88 @@
 
 
 #include &quot;global.h&quot;
-#include &lt;stdio.h&gt;	/* printf(), getchar() */
+#include &lt;stdio.h&gt; /* printf(), getchar() */
 #include &lt;stdint.h&gt; /* uint32_t */
-#include &lt;string.h&gt;	/* memcpy() */
-int shm_write(struct buf_t *rb,char *buf, int n)
+#include &lt;string.h&gt; /* memcpy() */
+int shm_write(struct buf_t *rb, char *buf, int n)
 {
-	int wrap=0;
+	int wrap = 0;
 	int rs;
-	int32_t e,s,size;
+	int32_t e, s, size;
 	char *data;
 
-	e=rb-&gt;end;
-	s=rb-&gt;start;
-	size=rb-&gt;bufsize;
-	data=((char *)rb)+sizeof(struct buf_t);
-	if (e&lt;s) {
-		wrap=1;
+	e = rb-&gt;end;
+	s = rb-&gt;start;
+	size = rb-&gt;bufsize;
+	data = ((char *)rb) + sizeof(struct buf_t);
+	if (e &lt; s) {
+		wrap = 1;
 	}
-	while ((((s+size*(1-wrap))-e) &lt; (n+1))) { /* checking free space */
+	while ((((s + size*(1 - wrap)) - e) &lt; (n + 1))) { /* checking free space */
 		if /*((size*2)&gt;RB_MAX_SIZE)*/ (1) {
 			printf(&quot;buffer reached maxsize, no resizing possible&quot;);
 			return(-1);
 		}
-		/*		printf(&quot;buffer full!! resizing ... (to size %d)&quot;,(int)size*2);
-				if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
-				{
-					printf(&quot;realloc failed - fatal!!&quot;);
-					return(-1);
-				}
-				if (wrap)
-				{
-					memcpy(data+size,data,e);
-					e+=size;
-					wrap=0;
-				}
-				size=rb-&gt;bufsize=size*2;
-				rb-&gt;end=e;*/
+		/*  printf(&quot;buffer full!! resizing ... (to size %d)&quot;,(int)size*2);
+		  if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
+		  {
+		   printf(&quot;realloc failed - fatal!!&quot;);
+		   return(-1);
+		  }
+		  if (wrap)
+		  {
+		   memcpy(data+size,data,e);
+		   e+=size;
+		   wrap=0;
+		  }
+		  size=rb-&gt;bufsize=size*2;
+		  rb-&gt;end=e;*/
 	}
-	if ((e+n)&gt;size) {
-		rs=size-e;
-		memcpy(data+e,buf,rs);			/* copy the first part ... */
-		memcpy(data,buf+rs,n-rs); 		/* .. end the rest */
+	if ((e + n) &gt; size) {
+		rs = size - e;
+		memcpy(data + e, buf, rs);   /* copy the first part ... */
+		memcpy(data, buf + rs, n - rs);   /* .. end the rest */
 	} else {
-		memcpy(data+e,buf,n);			/* plain copy */
+		memcpy(data + e, buf, n);   /* plain copy */
 	}
-	rb-&gt;end=e+n;	/* update end of the buffer */
-	if (rb-&gt;end&gt;=rb-&gt;bufsize) rb-&gt;end-=rb-&gt;bufsize;
+	rb-&gt;end = e + n; /* update end of the buffer */
+	if (rb-&gt;end &gt;= rb-&gt;bufsize) rb-&gt;end -= rb-&gt;bufsize;
 	return(0);
 }
-int shm_read(struct buf_t *rb,char *buf, int n)
+int shm_read(struct buf_t *rb, char *buf, int n)
 {
-	int wrap=0;
-	int mn=n;
+	int wrap = 0;
+	int mn = n;
 	int rs;
-	int32_t e,s,size;
+	int32_t e, s, size;
 	char *data;
 
-	e=rb-&gt;end;
-	s=rb-&gt;start;
-	size=rb-&gt;bufsize;
-	data=((char *)rb)+sizeof(struct buf_t);
-	if (e&lt;s) wrap=1;
-	rs=(e+wrap*size-s);
-	mn=(n&gt;rs)?rs:n;
-	if ((wrap) &amp;&amp; (mn&gt;(size-s))) {
-		rs=size-s;	/* size of the first part */
-		memcpy(buf,data+s,rs);
-		memcpy(buf+rs,data,mn-rs);
+	e = rb-&gt;end;
+	s = rb-&gt;start;
+	size = rb-&gt;bufsize;
+	data = ((char *)rb) + sizeof(struct buf_t);
+	if (e &lt; s) wrap = 1;
+	rs = (e + wrap * size - s);
+	mn = (n &gt; rs) ? rs : n;
+	if ((wrap) &amp;&amp; (mn &gt; (size - s))) {
+		rs = size - s; /* size of the first part */
+		memcpy(buf, data + s, rs);
+		memcpy(buf + rs, data, mn - rs);
 	} else { /* no wrap (needed)*/
-		memcpy(buf,data+s,mn);
+		memcpy(buf, data + s, mn);
 	}
-	rb-&gt;start=s+mn;
-	if (rb-&gt;start&gt;=rb-&gt;bufsize) rb-&gt;start-=rb-&gt;bufsize;
+	rb-&gt;start = s + mn;
+	if (rb-&gt;start &gt;= rb-&gt;bufsize) rb-&gt;start -= rb-&gt;bufsize;
 	return(mn);
 }
-void ringbuf_init(char *data,uint32_t init_size)
+void ringbuf_init(char *data, uint32_t init_size)
 {
-	struct buf_t *ringbuf=(struct buf_t *)data;
-	/*	ringbuf=malloc(init_size); */
-	ringbuf-&gt;start=0;
-	ringbuf-&gt;end=0;
-	ringbuf-&gt;bufsize=init_size-RB_OVERHEAD;
-	/*	return (ringbuf); */
+	struct buf_t *ringbuf = (struct buf_t *)data;
+	/* ringbuf=malloc(init_size); */
+	ringbuf-&gt;start = 0;
+	ringbuf-&gt;end = 0;
+	ringbuf-&gt;bufsize = init_size - RB_OVERHEAD;
+	/* return (ringbuf); */
 }
 
 

Modified: trunk/server/tcp.c
===================================================================
--- trunk/server/tcp.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/tcp.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,25 +24,25 @@
 
 #include &quot;global.h&quot;
 #ifdef TCP
-#include &lt;errno.h&gt;		 /*  errno */
-#include &lt;string.h&gt;		 /*  memset() */
+#include &lt;errno.h&gt;   /*  errno */
+#include &lt;string.h&gt;   /*  memset() */
 #ifdef WIN32  /*  sohn wars */
 #include &lt;winsock2.h&gt;
 #else  /* sohn wars */
 #include &lt;sys/types.h&gt;   /* fd_set, FD*, socket, accept ... */
 #include &lt;sys/socket.h&gt;  /* socket, accept ... */
 #include &lt;sys/select.h&gt;  /* fd_set,FD* */
-#include &lt;sys/time.h&gt;	 /* fd_set,FD* */
+#include &lt;sys/time.h&gt;  /* fd_set,FD* */
 #include &lt;netinet/in.h&gt;  /* ntohs(),htons(),htonl(),ntohl() */
 #include &lt;arpa/inet.h&gt;   /* network */
 #endif   /*  sohn wars */
-#include &lt;time.h&gt;		 /*  select() timeval things */
-#include &lt;fcntl.h&gt;		 /*  fcntl(),F_SETOWN */
+#include &lt;time.h&gt;   /*  select() timeval things */
+#include &lt;fcntl.h&gt;   /*  fcntl(),F_SETOWN */
 #ifndef F_SETOWN /* somehow it is not set with -ansi */
-#define F_SETOWN	8
+#define F_SETOWN 8
 #endif
-#include &lt;unistd.h&gt;		 /*  read(),write(),getpid(),close() */
-#include &lt;stdlib.h&gt;		 /*  malloc(),free() */
+#include &lt;unistd.h&gt;   /*  read(),write(),getpid(),close() */
+#include &lt;stdlib.h&gt;   /*  malloc(),free() */
 
 extern struct t_con *con_list;
 extern struct t_con mcp;
@@ -51,35 +51,35 @@
 int tcp_sockid;
 int tcp_init()
 {
-	int yes=1;
+	int yes = 1;
 	struct sockaddr_in my_addr;
-	s3dprintf(LOW,&quot;server: creating socket&quot;);
+	s3dprintf(LOW, &quot;server: creating socket&quot;);
 #ifdef WIN32  /*  sohn wars */
 	WSADATA datainfo;
 	if (WSAStartup(257, &amp;datainfo) != 0)
 		errnf(&quot;startup()&quot;, 0);
 #endif  /*  auch sohn */
-	if ((tcp_sockid = socket(AF_INET,SOCK_STREAM,0)) &lt; 0)
+	if ((tcp_sockid = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
 		errnf(&quot;socket()&quot;, errno);
 
-	s3dprintf(LOW,&quot;server: binding my local socket&quot;);
+	s3dprintf(LOW, &quot;server: binding my local socket&quot;);
 	/*  allow addresses to be reused */
 	/*  this seems to have something to do with servers using one port */
-	if ( setsockopt(tcp_sockid, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int)) == -1 )
-		errn(&quot;setsockopt(...,SO_REUSEADDR...)&quot;,errno );
-	memset((char *) &amp;my_addr,0,sizeof(my_addr));
+	if (setsockopt(tcp_sockid, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int)) == -1)
+		errn(&quot;setsockopt(...,SO_REUSEADDR...)&quot;, errno);
+	memset((char *) &amp;my_addr, 0, sizeof(my_addr));
 	my_addr.sin_family = AF_INET;
 	my_addr.sin_port = htons(S3D_PORT);
 	my_addr.sin_addr.s_addr = htons(INADDR_ANY);
-	if (bind(tcp_sockid ,(struct sockaddr *) &amp;my_addr,sizeof(my_addr)) &lt; 0)
-		errnf(&quot;bind()&quot;,errno);
-	if (listen(tcp_sockid,5) &lt; 0)
-		errnf(&quot;listen()&quot;,errno);
+	if (bind(tcp_sockid , (struct sockaddr *) &amp;my_addr, sizeof(my_addr)) &lt; 0)
+		errnf(&quot;bind()&quot;, errno);
+	if (listen(tcp_sockid, 5) &lt; 0)
+		errnf(&quot;listen()&quot;, errno);
 #ifdef SIGS
-	if ( fcntl(tcp_sockid, F_SETFL, O_ASYNC | O_NONBLOCK) &lt; 0 )
-		errnf(&quot;fcntl()&quot;,errno);
-	if ( fcntl(tcp_sockid, F_SETOWN, getpid()) &lt; 0 )
-		errnf(&quot;fcntl()&quot;,errno);
+	if (fcntl(tcp_sockid, F_SETFL, O_ASYNC | O_NONBLOCK) &lt; 0)
+		errnf(&quot;fcntl()&quot;, errno);
+	if (fcntl(tcp_sockid, F_SETOWN, getpid()) &lt; 0)
+		errnf(&quot;fcntl()&quot;, errno);
 #endif
 	return(0);
 
@@ -95,40 +95,40 @@
 /*  watches the port for new connections */
 int tcp_pollport()
 {
-	fd_set				 fs_port; 	 /*  filedescriptor set for listening port(s) */
-	int 				 newsd; 	 /*  new socket descriptor */
-	struct timeval		 tv;		 /*  time structure */
-	/*	struct t_con 		*new_con;	*/ /*  pointer to new connection */
-	struct t_process	*new_p;		 /*  pointer to new process */
-	struct sockaddr		 client_addr;  /*  new client's address */
-	socklen_t			 clilen=sizeof(client_addr);		 /*  length of client's address */
+	fd_set     fs_port;   /*  filedescriptor set for listening port(s) */
+	int      newsd;   /*  new socket descriptor */
+	struct timeval   tv;   /*  time structure */
+	/* struct t_con   *new_con; */ /*  pointer to new connection */
+	struct t_process *new_p;   /*  pointer to new process */
+	struct sockaddr   client_addr;  /*  new client's address */
+	socklen_t    clilen = sizeof(client_addr); /*  length of client's address */
 	/* int i; */
 	FD_ZERO(&amp;fs_port);
-	FD_SET(tcp_sockid,&amp;fs_port);
+	FD_SET(tcp_sockid, &amp;fs_port);
 select_again:
-	tv.tv_sec=tv.tv_usec=0;
-	if (select(FD_SETSIZE, &amp;fs_port, NULL,NULL,&amp;tv)&lt;0) {
-		if (errno==EINTR) { /*  interruption by some evil signal, just do again :) */
-			errn(&quot;tcp_pollport():select()&quot;,errno);
+	tv.tv_sec = tv.tv_usec = 0;
+	if (select(FD_SETSIZE, &amp;fs_port, NULL, NULL, &amp;tv) &lt; 0) {
+		if (errno == EINTR) { /*  interruption by some evil signal, just do again :) */
+			errn(&quot;tcp_pollport():select()&quot;, errno);
 			goto select_again;  /*  oh no, a goto!! that's evil */
 		} else
-			errn(&quot;tcp_pollport():select()&quot;,errno);
+			errn(&quot;tcp_pollport():select()&quot;, errno);
 	} else
-		if (FD_ISSET(tcp_sockid,&amp;fs_port)) {  /* redundant, I guess */
-			s3dprintf(HIGH,&quot;select(): new connection!!&quot;);
-			if ((newsd = accept(tcp_sockid ,(struct sockaddr *) &amp;client_addr,&amp;clilen)) &lt; 0)
-				errn(&quot;accept()&quot;,errno);
+		if (FD_ISSET(tcp_sockid, &amp;fs_port)) { /* redundant, I guess */
+			s3dprintf(HIGH, &quot;select(): new connection!!&quot;);
+			if ((newsd = accept(tcp_sockid , (struct sockaddr *) &amp; client_addr, &amp;clilen)) &lt; 0)
+				errn(&quot;accept()&quot;, errno);
 			else {
 #ifdef SIGS
-				if ( fcntl(newsd, F_SETFL, O_ASYNC ) &lt; 0 )
-					errnf(&quot;fcntl()&quot;,errno);
-				if ( fcntl(newsd, F_SETOWN, getpid()) &lt; 0 )
-					errnf(&quot;fcntl()&quot;,errno);
+				if (fcntl(newsd, F_SETFL, O_ASYNC) &lt; 0)
+					errnf(&quot;fcntl()&quot;, errno);
+				if (fcntl(newsd, F_SETOWN, getpid()) &lt; 0)
+					errnf(&quot;fcntl()&quot;, errno);
 #endif
-				new_p=process_add();
-				new_p-&gt;con_type=CON_TCP;
-				new_p-&gt;sockid=newsd;
-				s3dprintf(HIGH,&quot;registered new connection %d as pid %d&quot;,new_p-&gt;sockid, new_p-&gt;id);
+				new_p = process_add();
+				new_p-&gt;con_type = CON_TCP;
+				new_p-&gt;sockid = newsd;
+				s3dprintf(HIGH, &quot;registered new connection %d as pid %d&quot;, new_p-&gt;sockid, new_p-&gt;id);
 			}
 		}
 	return(0);
@@ -139,24 +139,24 @@
 /*  returns 1 when there was new data. */
 int tcp_pollproc()
 {
-	fd_set				 fs_proc; 	 /*  filedescriptor set for listening port(s) */
-	struct timeval		 tv;		 /*  time structure */
-	struct t_process	*p;
-	int 				 found=0;
-	int 				 i,unfinished,n,off;
-	off=0;
+	fd_set     fs_proc;   /*  filedescriptor set for listening port(s) */
+	struct timeval   tv;   /*  time structure */
+	struct t_process *p;
+	int      found = 0;
+	int      i, unfinished, n, off;
+	off = 0;
 	do {
 		FD_ZERO(&amp;fs_proc);
-		unfinished=0;
-		n=0;
-		for (i=off;i&lt;procs_n;i++) {
-			p=&amp;procs_p[i];
-			if (p-&gt;con_type==CON_TCP) {
-				FD_SET(p-&gt;sockid,&amp;fs_proc);
+		unfinished = 0;
+		n = 0;
+		for (i = off;i &lt; procs_n;i++) {
+			p = &amp;procs_p[i];
+			if (p-&gt;con_type == CON_TCP) {
+				FD_SET(p-&gt;sockid, &amp;fs_proc);
 				n++;
-				if (n&gt;=FD_SETSIZE) {	/* don't overflow the setsize! */
-					off=i;
-					unfinished=1;
+				if (n &gt;= FD_SETSIZE) { /* don't overflow the setsize! */
+					off = i;
+					unfinished = 1;
 					break;
 				}
 			}
@@ -164,23 +164,23 @@
 		/*  maybe having a global fd_set for all the processes would have been better */
 		/*  than generating them new in every poll. to be optimized... */
 select_again_poll:
-		tv.tv_sec=tv.tv_usec=0;
-		if (select(FD_SETSIZE, &amp;fs_proc, NULL,NULL,&amp;tv) ==-1) {
-			if (errno==EINTR) {
-				errn(&quot;tcp_pollproc():select()&quot;,errno);
+		tv.tv_sec = tv.tv_usec = 0;
+		if (select(FD_SETSIZE, &amp;fs_proc, NULL, NULL, &amp;tv) == -1) {
+			if (errno == EINTR) {
+				errn(&quot;tcp_pollproc():select()&quot;, errno);
 				goto select_again_poll;
 			} else {
-				errn(&quot;tcp_pollproc():select()&quot;,errno);
+				errn(&quot;tcp_pollproc():select()&quot;, errno);
 			}
 		} else {
 			/*  data is available */
-			for (i=0;i&lt;procs_n;i++) {
-				p=&amp;procs_p[i];
-				if (p-&gt;con_type==CON_TCP) {
-					if (FD_ISSET(p-&gt;sockid,&amp;fs_proc)) {
-						FD_CLR(p-&gt;sockid,&amp;fs_proc);  /*  clear it from the fd */
+			for (i = 0;i &lt; procs_n;i++) {
+				p = &amp;procs_p[i];
+				if (p-&gt;con_type == CON_TCP) {
+					if (FD_ISSET(p-&gt;sockid, &amp;fs_proc)) {
+						FD_CLR(p-&gt;sockid, &amp;fs_proc); /*  clear it from the fd */
 						tcp_prot_com_in(p);
-						found=1;
+						found = 1;
 					}
 				}
 			}
@@ -191,29 +191,29 @@
 /* read some data from the line, pushes it into the buffer and calls prot_com_in */
 int tcp_prot_com_in(struct t_process *p)
 {
-	uint16_t	length;
-	if (3==tcp_readn(p-&gt;sockid, ibuf,3)) {
-		length=ntohs(*((uint16_t *)((uint8_t *)ibuf+1)));
-		s3dprintf(VLOW,&quot;command %d, length %d&quot;,ibuf[0], length);
-		if (length&gt;0) {
-			tcp_readn(p-&gt;sockid,ibuf+3,length);	  /*  uint16_t is limited to 65536, so  */
+	uint16_t length;
+	if (3 == tcp_readn(p-&gt;sockid, ibuf, 3)) {
+		length = ntohs(*((uint16_t *)((uint8_t *)ibuf + 1)));
+		s3dprintf(VLOW, &quot;command %d, length %d&quot;, ibuf[0], length);
+		if (length &gt; 0) {
+			tcp_readn(p-&gt;sockid, ibuf + 3, length);   /*  uint16_t is limited to 65536, so  */
 			/*  length can't be bigger than that ... lucky */
 		}
-		prot_com_in(p,ibuf);
+		prot_com_in(p, ibuf);
 	} else {
-		s3dprintf(LOW,&quot;tcp_prot_com_in():n_readn():fd seems to be dead (pid %d, sock %d)&quot;, p-&gt;id, p-&gt;sockid);
+		s3dprintf(LOW, &quot;tcp_prot_com_in():n_readn():fd seems to be dead (pid %d, sock %d)&quot;, p-&gt;id, p-&gt;sockid);
 		process_del(p-&gt;id);
 	}
 	return(0);
 }
 /*  shamelessly ripped from simple ftp server */
-int tcp_readn(int sock, uint8_t *str,int s)
+int tcp_readn(int sock, uint8_t *str, int s)
 {
-	int no_left,no_read;
+	int no_left, no_read;
 	no_left = s;
 	while (no_left &gt; 0) {
-		no_read = read(sock,str,no_left);
-		if (no_read &lt;0) {
+		no_read = read(sock, str, no_left);
+		if (no_read &lt; 0) {
 			errn(&quot;read()&quot;, errno);
 			return(no_read);
 		}
@@ -223,14 +223,14 @@
 	}
 	return(s - no_left);
 }
-int tcp_writen(int sock, uint8_t *str,int s)
+int tcp_writen(int sock, uint8_t *str, int s)
 {
-	int no_left,no_written;
+	int no_left, no_written;
 	no_left = s;
 	while (no_left &gt; 0) {
-		no_written = write(sock,str,no_left);
-		if (no_written &lt;=0) {
-			errn(&quot;write()&quot;,errno);
+		no_written = write(sock, str, no_left);
+		if (no_written &lt;= 0) {
+			errn(&quot;write()&quot;, errno);
 			return(no_written);
 		}
 		no_left -= no_written;

Modified: trunk/server/user.c
===================================================================
--- trunk/server/user.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/user.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,9 +24,9 @@
 
 #include &quot;global.h&quot;
 /*  this file reads user input */
-static int ox,oy;
+static int ox, oy;
 static int pressed;
-int but=-1;
+int but = -1;
 int user_init()
 {
 	switch (frame_mode) {
@@ -43,8 +43,8 @@
 	default:
 		return(-1);
 	}
-	pressed=0;
-	ox=oy=0xFFFFFF;
+	pressed = 0;
+	ox = oy = 0xFFFFFF;
 	return(0);
 }
 int user_main()
@@ -65,7 +65,7 @@
 }
 void user_key(uint16_t key, uint16_t unicode, uint16_t mod, int state)
 {
-	event_key_pressed(key,unicode,mod,state);
+	event_key_pressed(key, unicode, mod, state);
 }
 void user_mouse(int button, int state, int x, int y)
 {
@@ -73,15 +73,15 @@
 	case 0: /*  mouse_down ... */
 		switch (button) {
 		case 0:
-			graphics_pick_obj(x,y);
+			graphics_pick_obj(x, y);
 			break;
 		case 1:
-			if ((ox!=0xFFFFFF) &amp;&amp; (oy!=0xFFFFFF))
-				navi_pos(ox-x,oy-y);
+			if ((ox != 0xFFFFFF) &amp;&amp; (oy != 0xFFFFFF))
+				navi_pos(ox - x, oy - y);
 			break;
 		case 2:
-			if ((ox!=0xFFFFFF) &amp;&amp; (oy!=0xFFFFFF))
-				navi_rot(ox-x,oy-y);
+			if ((ox != 0xFFFFFF) &amp;&amp; (oy != 0xFFFFFF))
+				navi_rot(ox - x, oy - y);
 			break;
 		case 3:
 			navi_fwd();
@@ -90,26 +90,26 @@
 			navi_back();
 			break;
 		default:
-			s3dprintf(VLOW,&quot;button is ... %d&quot;, button);
+			s3dprintf(VLOW, &quot;button is ... %d&quot;, button);
 		}
-		ox=x;
-		oy=y;
-		event_mbutton_clicked(button,state);
+		ox = x;
+		oy = y;
+		event_mbutton_clicked(button, state);
 		break;
 	case 1:  /*  mouse up */
-		ox=oy=0xFFFFFF;
-		event_mbutton_clicked(button,state);
-		/*		s3dprintf(LOW,&quot;state is: %d,button is %d&quot;,state,button);*/
+		ox = oy = 0xFFFFFF;
+		event_mbutton_clicked(button, state);
+		/*  s3dprintf(LOW,&quot;state is: %d,button is %d&quot;,state,button);*/
 		break;
-	case 2:	 /*  mouse still down */
+	case 2:  /*  mouse still down */
 		switch (button) {
 		case 1:
-			if ((ox!=0xFFFFFF) &amp;&amp; (oy!=0xFFFFFF))
-				navi_pos(ox-x,oy-y);
+			if ((ox != 0xFFFFFF) &amp;&amp; (oy != 0xFFFFFF))
+				navi_pos(ox - x, oy - y);
 			break;
 		case 2:
-			if ((ox!=0xFFFFFF) &amp;&amp; (oy!=0xFFFFFF))
-				navi_rot(ox-x,oy-y);
+			if ((ox != 0xFFFFFF) &amp;&amp; (oy != 0xFFFFFF))
+				navi_rot(ox - x, oy - y);
 			break;
 		case 3:
 			navi_fwd();
@@ -118,15 +118,15 @@
 			navi_back();
 			break;
 		default:
-			s3dprintf(VLOW,&quot;button is ... %d&quot;, button);
+			s3dprintf(VLOW, &quot;button is ... %d&quot;, button);
 		}
-		ox=x;
-		oy=y;
+		ox = x;
+		oy = y;
 		break;
 	}
-	but=button;
+	but = button;
 	/* mouse changed? */
-	ptr_move(x,y);
+	ptr_move(x, y);
 }
 int user_quit()
 {

Modified: trunk/server/user_glut.c
===================================================================
--- trunk/server/user_glut.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/user_glut.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,7 +23,7 @@
 
 
 #include &quot;global.h&quot;
-#include &lt;GL/glut.h&gt; 	 /*  all the glut functions */
+#include &lt;GL/glut.h&gt;   /*  all the glut functions */
 #include &lt;s3d_keysym.h&gt; /* our very own (haha) keysyms */
 /*  local prototypes */
 void keyboard(uint8_t key, int x, int y);
@@ -34,10 +34,10 @@
 /*  init user input things for glut */
 int user_init_glut()
 {
-	s3dprintf(MED,&quot;using GLUT for user input&quot;);
-	glutKeyboardFunc (keyboard);
-	glutSpecialFunc (special);
-	glutMouseFunc (user_mouse);
+	s3dprintf(MED, &quot;using GLUT for user input&quot;);
+	glutKeyboardFunc(keyboard);
+	glutSpecialFunc(special);
+	glutMouseFunc(user_mouse);
 	glutMotionFunc(mouse_motion);
 	glutPassiveMotionFunc(passive_mouse_motion);
 	return(0);
@@ -45,89 +45,89 @@
 
 void keyboard(uint8_t key, int x, int y)
 {
-	user_key(key,key,0,0);
-	user_key(key,key,0,1);
+	user_key(key, key, 0, 0);
+	user_key(key, key, 0, 1);
 }
 void special(int skey, int x, int y)
 {
 	uint16_t mkey;
 	switch (skey) { /* handle special keys */
 	case GLUT_KEY_F1:
-		mkey=S3DK_F1;
+		mkey = S3DK_F1;
 		break;
 	case GLUT_KEY_F2:
-		mkey=S3DK_F2;
+		mkey = S3DK_F2;
 		break;
 	case GLUT_KEY_F3:
-		mkey=S3DK_F3;
+		mkey = S3DK_F3;
 		break;
 	case GLUT_KEY_F4:
-		mkey=S3DK_F4;
+		mkey = S3DK_F4;
 		break;
 	case GLUT_KEY_F5:
-		mkey=S3DK_F5;
+		mkey = S3DK_F5;
 		break;
 	case GLUT_KEY_F6:
-		mkey=S3DK_F6;
+		mkey = S3DK_F6;
 		break;
 	case GLUT_KEY_F7:
-		mkey=S3DK_F7;
+		mkey = S3DK_F7;
 		break;
 	case GLUT_KEY_F8:
-		mkey=S3DK_F8;
+		mkey = S3DK_F8;
 		break;
 	case GLUT_KEY_F9:
-		mkey=S3DK_F9;
+		mkey = S3DK_F9;
 		break;
 	case GLUT_KEY_F10:
-		mkey=S3DK_F10;
+		mkey = S3DK_F10;
 		break;
 	case GLUT_KEY_F11:
-		mkey=S3DK_F11;
+		mkey = S3DK_F11;
 		break;
 	case GLUT_KEY_F12:
-		mkey=S3DK_F12;
+		mkey = S3DK_F12;
 		break;
 	case GLUT_KEY_LEFT:
-		mkey=S3DK_LEFT;
+		mkey = S3DK_LEFT;
 		break;
 	case GLUT_KEY_RIGHT:
-		mkey=S3DK_RIGHT;
+		mkey = S3DK_RIGHT;
 		break;
 	case GLUT_KEY_UP:
-		mkey=S3DK_UP;
+		mkey = S3DK_UP;
 		break;
 	case GLUT_KEY_DOWN:
-		mkey=S3DK_DOWN;
+		mkey = S3DK_DOWN;
 		break;
 	case GLUT_KEY_PAGE_UP:
-		mkey=S3DK_PAGEUP;
+		mkey = S3DK_PAGEUP;
 		break;
 	case GLUT_KEY_PAGE_DOWN:
-		mkey=S3DK_PAGEDOWN;
+		mkey = S3DK_PAGEDOWN;
 		break;
 	case GLUT_KEY_HOME:
-		mkey=S3DK_HOME;
+		mkey = S3DK_HOME;
 		break;
 	case GLUT_KEY_END:
-		mkey=S3DK_END;
+		mkey = S3DK_END;
 		break;
 	case GLUT_KEY_INSERT:
-		mkey=S3DK_INSERT;
+		mkey = S3DK_INSERT;
 		break;
 	default:
-		mkey=skey;
+		mkey = skey;
 		break;
 	}
-	s3dprintf(MED,&quot;special(): %d -&gt; %d&quot;,skey,mkey);
-	user_key(mkey,0,0,0);
-	user_key(mkey,0,0,1);
+	s3dprintf(MED, &quot;special(): %d -&gt; %d&quot;, skey, mkey);
+	user_key(mkey, 0, 0, 0);
+	user_key(mkey, 0, 0, 1);
 }
 void mouse_motion(int x, int y)
 {
-	user_mouse(but,2,x,y);
+	user_mouse(but, 2, x, y);
 }
 void passive_mouse_motion(int x, int y)
 {
-	user_mouse(-1,-1,x,y);
+	user_mouse(-1, -1, x, y);
 }

Modified: trunk/server/user_sdl.c
===================================================================
--- trunk/server/user_sdl.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/user_sdl.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -35,124 +35,124 @@
 }
 int user_main_sdl()
 {
-	SDL_Event 	event;
+	SDL_Event  event;
 	SDL_Surface *GLwin = NULL;
 	while (SDL_PollEvent(&amp;event)) {
 		switch (event.type) {
 		case SDL_MOUSEMOTION:
-			/* 			s3dprintf(VLOW,&quot;Current mouse position is: (%d, %d),button %d&quot;, event.motion.x, event.motion.y,event.button.button); */
+			/*    s3dprintf(VLOW,&quot;Current mouse position is: (%d, %d),button %d&quot;, event.motion.x, event.motion.y,event.button.button); */
 			switch (event.button.button) {
 			case SDL_BUTTON_LEFT:
-				user_mouse(0,2,event.motion.x,event.motion.y);
+				user_mouse(0, 2, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_MIDDLE:
-				user_mouse(1,2,event.motion.x,event.motion.y);
+				user_mouse(1, 2, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_RIGHT:
 			case SDL_BUTTON_RMASK:
-				user_mouse(2,2,event.motion.x,event.motion.y);
+				user_mouse(2, 2, event.motion.x, event.motion.y);
 				break;
-				/*				case SDL_BUTTON_WHEELUP:
-							 		user_mouse(3,2,event.motion.x,event.motion.y);break;
-								case SDL_BUTTON_WHEELDOWN:
-							 		user_mouse(4,2,event.motion.x,event.motion.y);break;*/
+				/*    case SDL_BUTTON_WHEELUP:
+				      user_mouse(3,2,event.motion.x,event.motion.y);break;
+				    case SDL_BUTTON_WHEELDOWN:
+				      user_mouse(4,2,event.motion.x,event.motion.y);break;*/
 			case 0:
-				user_mouse(-1,-1,event.motion.x,event.motion.y);
+				user_mouse(-1, -1, event.motion.x, event.motion.y);
 				break;
 				/*  no button ... */
 			default:
-				s3dprintf(LOW,&quot;don't know button %d&quot;, event.button.button);
+				s3dprintf(LOW, &quot;don't know button %d&quot;, event.button.button);
 
 			}
 			break;
 		case SDL_MOUSEBUTTONDOWN:
 			switch (event.button.button) {
 			case SDL_BUTTON_LEFT:
-				user_mouse(0,0,event.motion.x,event.motion.y);
+				user_mouse(0, 0, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_MIDDLE:
-				user_mouse(1,0,event.motion.x,event.motion.y);
+				user_mouse(1, 0, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_RIGHT:
-				user_mouse(2,0,event.motion.x,event.motion.y);
+				user_mouse(2, 0, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_WHEELUP:
-				user_mouse(3,0,event.motion.x,event.motion.y);
+				user_mouse(3, 0, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_WHEELDOWN:
-				user_mouse(4,0,event.motion.x,event.motion.y);
+				user_mouse(4, 0, event.motion.x, event.motion.y);
 				break;
 			default:
-				s3dprintf(LOW,&quot;don't know button %d&quot;, event.button.button);
+				s3dprintf(LOW, &quot;don't know button %d&quot;, event.button.button);
 			}
 			break;
 		case SDL_MOUSEBUTTONUP:
 			switch (event.button.button) {
 			case SDL_BUTTON_LEFT:
-				user_mouse(0,1,event.motion.x,event.motion.y);
+				user_mouse(0, 1, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_MIDDLE:
-				user_mouse(1,1,event.motion.x,event.motion.y);
+				user_mouse(1, 1, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_RIGHT:
-				user_mouse(2,1,event.motion.x,event.motion.y);
+				user_mouse(2, 1, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_WHEELUP:
-				user_mouse(3,1,event.motion.x,event.motion.y);
+				user_mouse(3, 1, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_WHEELDOWN:
-				user_mouse(4,1,event.motion.x,event.motion.y);
+				user_mouse(4, 1, event.motion.x, event.motion.y);
 				break;
 			default:
-				s3dprintf(LOW,&quot;don't know button %d&quot;, event.button.button);
+				s3dprintf(LOW, &quot;don't know button %d&quot;, event.button.button);
 			}
 			break;
 
 		case SDL_KEYDOWN:
-			user_key(event.key.keysym.sym,event.key.keysym.unicode,event.key.keysym.mod,0);
+			user_key(event.key.keysym.sym, event.key.keysym.unicode, event.key.keysym.mod, 0);
 			break;
 		case SDL_KEYUP:
-			user_key(event.key.keysym.sym,event.key.keysym.unicode,event.key.keysym.mod,1);
+			user_key(event.key.keysym.sym, event.key.keysym.unicode, event.key.keysym.mod, 1);
 			break;
 		case SDL_QUIT:
-			s3dprintf(HIGH,&quot;SDL_QUIT&quot;);
+			s3dprintf(HIGH, &quot;SDL_QUIT&quot;);
 			quit();
 			break;
 			/*  these events are not processed right now ... */
 		case SDL_ACTIVEEVENT:
-			s3dprintf(VLOW,&quot;SDL_ACTIVEEVENT&quot;);
+			s3dprintf(VLOW, &quot;SDL_ACTIVEEVENT&quot;);
 			break;
 		case SDL_SYSWMEVENT:
-			s3dprintf(VLOW,&quot;SDL_SYSWMEVENT&quot;);
+			s3dprintf(VLOW, &quot;SDL_SYSWMEVENT&quot;);
 			break;
 		case SDL_VIDEORESIZE:
-			if ((GLwin = SDL_SetVideoMode(event.resize.w,event.resize.h,16,SDLFlags))==NULL)
-				errsf(&quot;SDL_SetVideoMode()&quot;,SDL_GetError());
-			graphics_reshape(event.resize.w,event.resize.h);
+			if ((GLwin = SDL_SetVideoMode(event.resize.w, event.resize.h, 16, SDLFlags)) == NULL)
+				errsf(&quot;SDL_SetVideoMode()&quot;, SDL_GetError());
+			graphics_reshape(event.resize.w, event.resize.h);
 			break;
 		case SDL_VIDEOEXPOSE:
-			s3dprintf(VLOW,&quot;SDL_VIDEOEXPOSE&quot;);
+			s3dprintf(VLOW, &quot;SDL_VIDEOEXPOSE&quot;);
 			break;
 		case SDL_USEREVENT:
-			s3dprintf(VLOW,&quot;SDL_USEREVENT&quot;);
+			s3dprintf(VLOW, &quot;SDL_USEREVENT&quot;);
 			break;
 		case SDL_JOYAXISMOTION:
-			s3dprintf(VLOW,&quot;SDL_JOYAXISMOTION&quot;);
+			s3dprintf(VLOW, &quot;SDL_JOYAXISMOTION&quot;);
 			break;
 		case SDL_JOYBALLMOTION:
-			s3dprintf(VLOW,&quot;SDL_JOYBALLMOTION&quot;);
+			s3dprintf(VLOW, &quot;SDL_JOYBALLMOTION&quot;);
 			break;
 		case SDL_JOYHATMOTION:
-			s3dprintf(VLOW,&quot;SDL_JOYHATMOTION&quot;);
+			s3dprintf(VLOW, &quot;SDL_JOYHATMOTION&quot;);
 			break;
 		case SDL_JOYBUTTONDOWN:
-			s3dprintf(VLOW,&quot;SDL_JOYBUTTONDOWN&quot;);
+			s3dprintf(VLOW, &quot;SDL_JOYBUTTONDOWN&quot;);
 			break;
 		case SDL_JOYBUTTONUP:
-			s3dprintf(VLOW,&quot;SDL_JOYBUTTONUP&quot;);
+			s3dprintf(VLOW, &quot;SDL_JOYBUTTONUP&quot;);
 			break;
 		default:
-			s3dprintf(MED,&quot;SDL_PollEvent(): unhandled event&quot;);
+			s3dprintf(MED, &quot;SDL_PollEvent(): unhandled event&quot;);
 			break;
 		}
 	}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000658.html">[S3d-svn] r666 - trunk/apps/s3dosm
</A></li>
	<LI>Next message: <A HREF="000660.html">[S3d-svn] r668 - in trunk: . libs3dw
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#659">[ date ]</a>
              <a href="thread.html#659">[ thread ]</a>
              <a href="subject.html#659">[ subject ]</a>
              <a href="author.html#659">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/s3d-svn">More information about the S3d-svn
mailing list</a><br>
</body></html>
