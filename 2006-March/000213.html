<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [S3d-svn] r217 - in trunk: . Documentation Documentation/s3dapi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/s3d-svn/2006-March/index.html" >
   <LINK REL="made" HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r217%20-%20in%20trunk%3A%20.%20Documentation%20Documentation/s3dapi&In-Reply-To=%3C200603191920.k2JJKQB3017815%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000212.html">
   <LINK REL="Next"  HREF="000214.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[S3d-svn] r217 - in trunk: . Documentation Documentation/s3dapi</H1>
    <B>dotslash at BerliOS</B> 
    <A HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r217%20-%20in%20trunk%3A%20.%20Documentation%20Documentation/s3dapi&In-Reply-To=%3C200603191920.k2JJKQB3017815%40sheep.berlios.de%3E"
       TITLE="[S3d-svn] r217 - in trunk: . Documentation Documentation/s3dapi">dotslash at berlios.de
       </A><BR>
    <I>Sun Mar 19 20:20:26 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000212.html">[S3d-svn] r216 - trunk/apps/olsrs3d
</A></li>
        <LI>Next message: <A HREF="000214.html">[S3d-svn] r218 - in trunk: . apps/dot_mcp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#213">[ date ]</a>
              <a href="thread.html#213">[ thread ]</a>
              <a href="subject.html#213">[ subject ]</a>
              <a href="author.html#213">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dotslash
Date: 2006-03-19 20:20:23 +0100 (Sun, 19 Mar 2006)
New Revision: 217

Added:
   trunk/Documentation/s3dapi/
   trunk/Documentation/s3dapi/bookinfo.docbook
   trunk/Documentation/s3dapi/s3dapi.docbook
Removed:
   trunk/Documentation/s3dlib.txt
Modified:
   trunk/
Log:
 <A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">r329 at balthasar</A>:  dotslash | 2006-03-19 20:20:02 +0100
 - Docbook documentation!!!
 - oudated s3dlib.txt becomes obsolete



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:323
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:329

Added: trunk/Documentation/s3dapi/bookinfo.docbook
===================================================================
--- trunk/Documentation/s3dapi/bookinfo.docbook	2006-03-19 13:56:11 UTC (rev 216)
+++ trunk/Documentation/s3dapi/bookinfo.docbook	2006-03-19 19:20:23 UTC (rev 217)
@@ -0,0 +1,26 @@
+&lt;bookinfo&gt;
+&lt;title&gt;The s3d manual&lt;/title&gt;
+&lt;authorgroup&gt;
+&lt;author&gt;
+&lt;firstname&gt;Simon&lt;/firstname&gt;
+&lt;surname&gt;Wunderlich&lt;/surname&gt;
+&lt;/author&gt;
+&lt;/authorgroup&gt;
+
+&lt;date&gt;03/19/2006&lt;/date&gt;
+&lt;releaseinfo&gt;0.1&lt;/releaseinfo&gt;
+
+&lt;abstract&gt;
+&lt;para&gt;
+This Manual is the programmers guide to the s3d API.
+&lt;/para&gt;
+&lt;/abstract&gt;
+
+&lt;keywordset&gt;
+&lt;keyword&gt;s3d&lt;/keyword&gt;
+&lt;keyword&gt;API&lt;/keyword&gt;
+&lt;keyword&gt;handbook&lt;/keyword&gt;
+&lt;keyword&gt;guide&lt;/keyword&gt;
+&lt;/keywordset&gt;
+
+&lt;/bookinfo&gt;

Added: trunk/Documentation/s3dapi/s3dapi.docbook
===================================================================
--- trunk/Documentation/s3dapi/s3dapi.docbook	2006-03-19 13:56:11 UTC (rev 216)
+++ trunk/Documentation/s3dapi/s3dapi.docbook	2006-03-19 19:20:23 UTC (rev 217)
@@ -0,0 +1,1695 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
+&lt;!DOCTYPE book PUBLIC &quot;-//OASIS//DTD DocBook XML V4.2//EN&quot; [
+  &lt;!ENTITY introduction SYSTEM &quot;bookinfo.docbook&quot;&gt;
+]&gt;
+&lt;book id=&quot;s3dapi&quot; lang=&quot;en&quot;&gt;
+ 
+&lt;bookinfo&gt;
+&lt;title&gt;The &lt;application&gt;s3d&lt;/application&gt; API manual&lt;/title&gt;
+&lt;/bookinfo&gt;
+&lt;chapter id=&quot;introduction&quot;&gt;
+&lt;title&gt;Introduction&lt;/title&gt;
+ &lt;para&gt;I'm trying to cover as much as possible, please drop me a line if 
+ there is something missing or not clear enough. please beware: anything may change anytime,
+ as i'm sometimes in the mood of changing deep internal things.
+ &lt;/para&gt;
+ &lt;para&gt;
+ Thanks to David Rugge, Mark Glassi and Eric Bischoff for their great &lt;ulink url=&quot;<A HREF="http://opensource.bureau-cornavin.com/crash-course/">http://opensource.bureau-cornavin.com/crash-course/</A>&quot;&gt;Docbook Crash Course&lt;/ulink&gt;, this Doc wouldn't be here without that :)
+ &lt;/para&gt;
+ &lt;para&gt;
+ And of course THANKS to the whole s3d team - Yd, Marek, 2x Andreas, Mog - and all the people who support &lt;application&gt;s3d&lt;/application&gt;!!
+ &lt;/para&gt;
+&lt;/chapter&gt;
+&lt;chapter id=&quot;using&quot;&gt;
+&lt;title&gt;Using the &lt;application&gt;s3d&lt;/application&gt; library&lt;/title&gt;
+&lt;sect1 id=&quot;setup&quot;&gt;
+&lt;title&gt;Setting &lt;application&gt;s3d&lt;/application&gt; up&lt;/title&gt;
+ &lt;para&gt;
+ Install the lib using the usual usual mechanism:
+ &lt;programlisting&gt;
+ ./configure
+ make
+ make install
+ &lt;/programlisting&gt;
+ You might need to have superuser rights in order to do make install. You should now have the server,
+ the library and some applications installed somewhere.
+ &lt;/para&gt;
+&lt;/sect1&gt;
+&lt;sect1 id=&quot;gettingstarted&quot;&gt;
+&lt;title&gt;Getting started&lt;/title&gt;
+&lt;para&gt;
+ After having &lt;application&gt;s3d&lt;/application&gt; installed, you can write your own &lt;application&gt;s3d&lt;/application&gt; programs (yeah, that is what this guide is about ;)
+ &lt;programlisting&gt;
+ &lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;
+ &lt;/programlisting&gt;
+ should be enough to access the 3d functions. If you want to use keyboard interaction, do
+ &lt;programlisting&gt;
+ &lt;![CDATA[#include &lt;s3d_keysym.h&gt;]]&gt;
+ &lt;/programlisting&gt;
+ for the keycode table.
+ Now you can compile your program with 
+ &lt;screen&gt;
+ &lt;prompt&gt;bash$&lt;/prompt&gt; &lt;command&gt; gcc &lt;replaceable&gt;program&lt;/replaceable&gt;.c -ls3d -o &lt;replaceable&gt;program&lt;/replaceable&gt; &lt;/command&gt;
+ That wasn't that hard, wasn't it?
+ &lt;/screen&gt;
+&lt;/para&gt;
+&lt;/sect1&gt;
+&lt;/chapter&gt;
+
+
+&lt;chapter id=&quot;functions&quot;&gt;
+&lt;title&gt;function reference&lt;/title&gt;
+
+&lt;sect1 id=&quot;s3d_init&quot;&gt;
+&lt;title&gt;s3d_init&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_init&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int *&lt;parameter&gt;argc&lt;/parameter&gt;.
+char ***&lt;parameter&gt;argv&lt;/parameter&gt;
+char *&lt;parameter&gt;name&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+This will initialize the &lt;application&gt;s3d&lt;/application&gt;-library and the connection to the Server. It will return 0 on
+success in Server initializion. name specifies the your programs name.
+&lt;/para&gt;
+&lt;programlisting&gt;
+int main(char argc, char **argv)
+{
+	if (!&lt;emphasis&gt;s3d_init(&lt;![CDATA[&amp;argc,&amp;argv]]&gt;,&quot;Hello world&quot;)&lt;/emphasis&gt;) 
+	{
+		...
+		&lt;link linkend=&quot;s3d_quit&quot;&gt;s3d_quit()&lt;/link&gt;;
+	}
+	return(0);
+}
+			   
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;s3d_quit&quot;&gt;
+&lt;title&gt;s3d_quit&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_quit&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;void &lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+closes the connection and cleares the event-stack. it can also be used to leave
+the &lt;link linkend=&quot;s3d_mainloop&quot;&gt;s3d_mainloop&lt;/link&gt;.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_usage&quot;&gt;
+&lt;title&gt;s3d_usage&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;void &lt;function&gt;s3d_usage&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;void &lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Prints the possible parameter for the client library (which can be passed in 
+&lt;link linkend=&quot;s3d_init&quot;&gt;s3d_init()&lt;/link&gt;)
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_mainloop&quot;&gt;
+&lt;title&gt;s3d_mainloop&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_mainloop&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;void (*&lt;parameter&gt;f&lt;/parameter&gt;)()&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+takes a function as argument. it will loop this function until a quit-event is
+received. you can pass NULL if you have no function to be looped, but its
+better to sleep some time if you have nothing to do anyway to save cpu-time.
+&lt;/para&gt;
+&lt;programlisting&gt;
+void mainloop()
+{
+    usleep(1000); // sleep 1 ms in every cycle
+}
+...
+
+&lt;emphasis&gt;s3d_mainloop&lt;/emphasis&gt;(mainloop());
+
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;s3d_push_vertex&quot;&gt;
+&lt;title&gt;s3d_push_vertex&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_push_vertex&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float &lt;parameter&gt;x&lt;/parameter&gt;, float &lt;parameter&gt;y&lt;/parameter&gt;, float &lt;parameter&gt;z&lt;/parameter&gt;&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+pushes a vertex onto the vertex stack. make sure that you count how many
+vertices you've pushed because you'll need that for referencing when you push
+your polygons.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_push_vertices&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_push_vertices&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, float *&lt;parameter&gt;vbuf&lt;/parameter&gt;, unsigned short &lt;parameter&gt;n&lt;/parameter&gt;&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+push some vertices from an array. that's much better for performing than
+using &lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex()&lt;/link&gt; if you have a lot of vertices (and that's probably the
+usual case).
+&lt;/para&gt;
+&lt;programlisting&gt;
+float vertices[] = { 0.0, 0.0, 0.0,
+                     1.0, 2.0, 3,0,
+                     3.0, 2.0, 1.0};
+&lt;emphasis&gt;s3d_push_vertices&lt;/emphasis&gt;(object, vertices, 3); /* pushing 3 vertices */
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;s3d_push_material&quot;&gt;
+&lt;title&gt;s3d_push_material&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_push_material&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float &lt;parameter&gt;amb_r&lt;/parameter&gt;,
+float &lt;parameter&gt;amb_g&lt;/parameter&gt;,
+float &lt;parameter&gt;amb_b&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_r&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_g&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_b&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_r&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_g&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_b&lt;/parameter&gt;,
+
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+pushes a material for an object. you will have to count them yourself too, as
+polygons will ask for the material index number. the material properties are
+given in rgb (red/green/blue) color codes, in float. 0.0 is the minimum,
+1.0 is the maximum a color value can be.
+the specular color is the color which is directly reflected from the light
+source. the diffuse color is the color which can be seen in the bright side
+of the object, and the ambience color is the color of the shadow side of the
+object.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_push_material_a&quot;&gt;
+&lt;title&gt;s3d_push_material_a&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_push_material_a&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float &lt;parameter&gt;amb_r&lt;/parameter&gt;,
+float &lt;parameter&gt;amb_g&lt;/parameter&gt;,
+float &lt;parameter&gt;amb_b&lt;/parameter&gt;,
+float &lt;parameter&gt;amb_a&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_r&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_g&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_b&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_a&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_r&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_g&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_b&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_a&lt;/parameter&gt;
+
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Same as &lt;link linkend=&quot;s3d_push_material&quot;&gt;s3d_push_material&lt;/link&gt;, but color has &lt;link linkend=&quot;alpha&quot;&gt;alpha value&lt;/link&gt; added.
+Use &lt;link linkend=&quot;s3d_push_materials_a&quot;&gt;s3d_push_materials_a()&lt;/link&gt; if you have a lot of materials to push.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;s3d_push_materials_a&quot;&gt;
+&lt;title&gt;s3d_push_materials_a&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_push_materials_a&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float *&lt;parameter&gt;mbuf&lt;/parameter&gt;, 
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;
+
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Pushes a buffer of Materials. Those Materials are in the format float[n*12], with
+&lt;itemizedlist&gt;
+&lt;listitem&gt;&lt;para&gt;mbuf[n*12 + 0-3] - ambience&lt;/para&gt;&lt;/listitem&gt;
+&lt;listitem&gt;&lt;para&gt;mbuf[n*12 + 4-7] - specular&lt;/para&gt;&lt;/listitem&gt;
+&lt;listitem&gt;&lt;para&gt;mbuf[n *12 + 8-11] - diffusion values &lt;/para&gt;&lt;/listitem&gt;
+&lt;/itemizedlist&gt;
+of each entry. n is the number of materials pushed. The values are in the order r,g,b,a.
+If you only want to push one material, use the more easy &lt;link linkend=&quot;s3d_push_material_a&quot;&gt;s3d_push_material_a()&lt;/link&gt;
+function.
+&lt;/para&gt;
+&lt;programlisting&gt;
+/* each line has r,g,b,a value */
+float bla[24]=
+	{1,0,0,1,
+	 1,0,0,1,
+	 1,0,0,1,
+	 0,1,1,1,
+	 0,1,1,1,
+	 0,1,1,1};
+
+s3d_push_materials_a(object,mbuf,2); /* push a red and a cyan material */
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_push_polygon&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_push_polygon&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
+int &lt;parameter&gt;v1&lt;/parameter&gt;,
+int &lt;parameter&gt;v2&lt;/parameter&gt;,
+int &lt;parameter&gt;v3&lt;/parameter&gt;,
+int &lt;parameter&gt;material&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+push one polygon on the polygonstack of the object. it takes 3 vertex-index-
+numbers and one material material-index-nr. as argument.
+&lt;/para&gt;
+&lt;programlisting&gt;
+int oid=&lt;link linkend=&quot;s3d_new_object&quot;&gt;s3d_new_object&lt;/link&gt;();   /* create a new object */
+&lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex&lt;/link&gt;(oid,0.0,0.0,0.0);
+&lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex&lt;/link&gt;(oid,0.0,1.0,0.0);
+&lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex&lt;/link&gt;(oid,1.0,0.0,0.0);
+&lt;link linkend=&quot;s3d_push_material&quot;&gt;s3d_push_material&lt;/link&gt;(oid,0.3,0.0,0.0, 1.0,1.0,1.0, 1.0,0.0,0.0);
+&lt;emphasis&gt;s3d_push_polygon&lt;/emphasis&gt;(oid,0,1,2,0);
+/* this will create a red polygon */
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_push_polygons&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_push_polygons&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
+unsigned long &lt;parameter&gt;*pbuf&lt;/parameter&gt;,
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+as for vertices, you can push arrays of polygons to have greater performance.
+the pbuf should contain n polygons which consist of 4 unsigned long values
+of 3 vertices indeces and 1 material index.
+&lt;/para&gt;
+&lt;programlisting&gt;
+unsigned long pbuf[] = { 0,1,2,0};
+int oid=&lt;link linkend=&quot;s3d_new_object&quot;&gt;s3d_new_object&lt;/link&gt;();   /* create a new object */
+&lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex&lt;/link&gt;(oid,0.0,0.0,0.0);
+&lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex&lt;/link&gt;(oid,0.0,1.0,0.0);
+&lt;link linkend=&quot;s3d_push_vertex&quot;&gt;s3d_push_vertex&lt;/link&gt;(oid,1.0,0.0,0.0);
+&lt;link linkend=&quot;s3d_push_material&quot;&gt;s3d_push_material&lt;/link&gt;(oid,0.3,0.0,0.0, 1.0,1.0,1.0, 1.0,0.0,0.0);
+&lt;emphasis&gt;s3d_push_polygons&lt;/emphasis&gt;(oid,pbuf,1);
+/* push one polygon with the pbuf data */
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;s3d_push_line&quot;&gt;
+&lt;title&gt;s3d_push_line&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_push_line&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
+int &lt;parameter&gt;v1&lt;/parameter&gt;,
+int &lt;parameter&gt;v2&lt;/parameter&gt;,
+int &lt;parameter&gt;material&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Push one line on the linestack of the object. It takes 2 vertex-index-
+numbers and one material material-index-nr. as argument. If you have
+a lot of lines to push, use &lt;link linkend=&quot;s3d_push_lines&quot;&gt;s3d_push_lines()&lt;/link&gt;
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_push_lines&quot;&gt;
+&lt;title&gt;s3d_push_lines&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_push_line&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
+unsigned  long *&lt;parameter&gt;*lbuf&lt;/parameter&gt;,
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Pushing n lines on the linestack of the object, each lbuf has a size of n*3,
+each entry has the index number of the first vertex, second vertex and material number just
+as in &lt;link linkend=&quot;s3d_push_line&quot;&gt;s3d_push_line()&lt;/link&gt;.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_push_texture&quot;&gt;
+&lt;title&gt;s3d_push_texture&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_push_line&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
+int &lt;parameter&gt;w&lt;/parameter&gt;,
+int &lt;parameter&gt;h&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Adds a new texture with height w and height h on the texturestack.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_pop_vertex&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pop_vertex&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Deletes the latest n vertices from the vertex stack of the object.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_pop_polygon&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pop_polygon&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Deletes the latest n polygon from the polygon stack of the object.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_pop_material&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pop_material&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Deletes the latest n material from the material stack of the object.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_pop_texture&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pop_texture&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Deletes the latest n textures from the texture stack of the object.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_pop_line&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pop_line&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;int &lt;parameter&gt;object&lt;/parameter&gt;, 
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Deletes the latest n lines from the line stack of the object.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_pep_polygon_normals&quot;&gt;
+&lt;title&gt;s3d_pep_polygon_normals&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pep_polygon_normals&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float *&lt;parameter&gt;nbuf&lt;/parameter&gt;,
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;,
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Adds normal information to polygons, giving each vertex of a polygon a normal information. With this, you can
+archive smoothed edge effects. nbuf holds n*9 float values, 3 (x,y,z) vector values for each vertex of the Polygon.
+Don't worry if you don't use this, it's kind of hard to calculate and the server will use some always use some
+proper normal values (same for every vertex, calculated by the plane which is defined by the 3 points of the polygon.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_pep_tex_coord&quot;&gt;
+&lt;title&gt;s3d_pep_tex_coord&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pep_tex_coord&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float &lt;parameter&gt;x1&lt;/parameter&gt;, 
+float &lt;parameter&gt;y1&lt;/parameter&gt;, 
+float &lt;parameter&gt;x2&lt;/parameter&gt;, 
+float &lt;parameter&gt;y2&lt;/parameter&gt;, 
+float &lt;parameter&gt;x3&lt;/parameter&gt;, 
+float &lt;parameter&gt;y3&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Pimp the last polygon pushed with some textures coordinates, x and y values for each vertex point respectively.
+Those values may be between 0 and 1 and are vertex points on the &lt;link linkend=&quot;s3d_pep_material_texture&quot;&gt;
+texture defined in the material&lt;/link&gt; of the polygon. If you have more polygons which should get a texture, use
+&lt;link linkend=&quot;s3d_pep_tex_coords&quot;&gt;s3d_pep_tex_coords()&lt;/link&gt;
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_pep_tex_coords&quot;&gt;
+&lt;title&gt;s3d_pep_tex_coords&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pep_tex_coords&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float *&lt;parameter&gt;tbuf&lt;/parameter&gt;, 
+int &lt;parameter&gt;n&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Pimp the latest n polygons with texture coordinates. tbuf has 6*n float values for its entries, which are supplied in the order
+as in &lt;link linkend=&quot;s3d_pep_tex_coord&quot;&gt;s3d_pep_polygon_tex_coord()&lt;/link&gt;
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_pep_material_texture&quot;&gt;
+&lt;title&gt;s3d_pep_material_texture&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material_texture&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+unsigned long &lt;parameter&gt;tex&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Assign the latest material a texture referenced by the index tex. Of course, you will
+have pushed this texture with &lt;link linkend=&quot;s3d_push_texture&quot;&gt;s3d_push_texture&lt;/link&gt;
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;s3d_pep_vertex&quot;&gt;
+&lt;title&gt;s3d_pep_vertex&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pep_vertex&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float &lt;parameter&gt;x&lt;/parameter&gt;,
+float &lt;parameter&gt;y&lt;/parameter&gt;,
+float &lt;parameter&gt;z&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Alter the latest pushed vertex, overwriting with the supplied values.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_pep_vertices&quot;&gt;
+&lt;title&gt;s3d_pep_vertices&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pep_vertices&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float *&lt;parameter&gt;vbuf&lt;/parameter&gt;,
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Alter the latest n pushed vertex. vbuf holds the values which
+are used to overwrite the old data, n entries with each 3 floats
+specifying x,y,z of the vertices.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_pep_line&quot;&gt;
+&lt;title&gt;s3d_pep_line&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pep_line&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+unsigned long &lt;parameter&gt;v1&lt;/parameter&gt;,
+unsigned long &lt;parameter&gt;v2&lt;/parameter&gt;,
+unsigned long &lt;parameter&gt;material&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Alter the latest pushed line, overwriting with the supplied values.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_pep_lines&quot;&gt;
+&lt;title&gt;s3d_pep_lines&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pep_lines&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+unsigned long *&lt;parameter&gt;lbuf&lt;/parameter&gt;,
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Alter the latest n pushed lines. lbuf holds the values which
+are used to overwrite the old data, n entries with each 3 unsigned longs
+specifying first, second vertex and material of each line.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+
+&lt;sect1 id=&quot;s3d_pep_material&quot;&gt;
+&lt;title&gt;s3d_pep_material&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float &lt;parameter&gt;amb_r&lt;/parameter&gt;,
+float &lt;parameter&gt;amb_g&lt;/parameter&gt;,
+float &lt;parameter&gt;amb_b&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_r&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_g&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_b&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_r&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_g&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_b&lt;/parameter&gt;,
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Overwriting the latest pushed Material, overwriting the current value with the specified one.
+See &lt;link linkend=&quot;s3d_pep_materials_a&quot;&gt;s3d_pep_materials_a&lt;/link&gt; if you want to pep more materials.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+
+&lt;sect1 id=&quot;s3d_pep_material_a&quot;&gt;
+&lt;title&gt;s3d_pep_material_a&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pep_material_a&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float &lt;parameter&gt;amb_r&lt;/parameter&gt;,
+float &lt;parameter&gt;amb_g&lt;/parameter&gt;,
+float &lt;parameter&gt;amb_b&lt;/parameter&gt;,
+float &lt;parameter&gt;amb_a&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_r&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_g&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_b&lt;/parameter&gt;,
+float &lt;parameter&gt;spec_a&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_r&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_g&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_b&lt;/parameter&gt;,
+float &lt;parameter&gt;diff_a&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Overwriting the latest pushed Material, overwriting the current value with the specified one, with 
+&lt;link linkend=&quot;alpha&quot;&gt;alpha value&lt;/link&gt; in contrast to &lt;link linkend=&quot;s3d_pep_material&quot;&gt;s3d_pep_material&lt;/link&gt;
+See &lt;link linkend=&quot;s3d_pep_materials_a&quot;&gt;s3d_push_materials_a&lt;/link&gt; if you want to pep more materials.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_pep_materials_a&quot;&gt;
+&lt;title&gt;s3d_pep_materials_a&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_pep_materials_a&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float *&lt;parameter&gt;mbuf&lt;/parameter&gt;, 
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;
+
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Alters the last n pushed Materials. See &lt;link linkend=&quot;s3d_push_materials_a&quot;&gt;s3d_push_materials_a()&lt;/link&gt; for
+more information how mbuf should look like. Use &lt;link linkend=&quot;s3d_pep_material_a&quot;&gt;s3d_pep_material_a()&lt;/link&gt;
+if you only want to alter the latest material.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_load_materials_a&quot;&gt;
+&lt;title&gt;s3d_load_materials_a&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_load_materials_a&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float *&lt;parameter&gt;mbuf&lt;/parameter&gt;, 
+unsigned longs &lt;parameter&gt;start&lt;/parameter&gt;,
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Loads n materials starting from index position start into the Material stack.
+See &lt;link linkend=&quot;s3d_push_materials_a&quot;&gt;s3d_push_materials_a&lt;/link&gt; for more informatino about the values in mbuf.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+
+&lt;sect1 id=&quot;s3d_load_polygon_normals&quot;&gt;
+&lt;title&gt;s3d_load_polygon_normals&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_load_polygon_normals&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float *&lt;parameter&gt;nbuf&lt;/parameter&gt;,
+int &lt;parameter&gt;start&lt;/parameter&gt;,
+unsigned short &lt;parameter&gt;n&lt;/parameter&gt;,
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Just as &lt;link linkend=&quot;s3d_pep_polygon_normals&quot;&gt;s3d_pep_polygon_normals()&lt;/link&gt;, with the difference you won't alter 
+the latest n polygons but n polygons starting with index start.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;s3d_load_tex_coords&quot;&gt;
+&lt;title&gt;s3d_load_tex_coords&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_load_tex_coords&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+float *&lt;parameter&gt;tbuf&lt;/parameter&gt;, 
+int &lt;parameter&gt;start&lt;/parameter&gt;,
+int &lt;parameter&gt;n&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Just as &lt;link linkend=&quot;s3d_pep_tex_coords&quot;&gt;s3d_load_tex_coords()&lt;/link&gt;, with the difference you won't alter 
+the latest n polygons but n polygons starting with index start.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_load_texture&quot;&gt;
+&lt;title&gt;s3d_load_texture&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_load_texture&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;, 
+unsigned long &lt;parameter&gt;tex&lt;/parameter&gt;,
+unsigned short &lt;parameter&gt;xpos&lt;/parameter&gt;,
+unsigned short &lt;parameter&gt;ypos&lt;/parameter&gt;,
+unsigned short &lt;parameter&gt;w&lt;/parameter&gt;,
+unsigned short &lt;parameter&gt;h&lt;/parameter&gt;,
+unsgined char *&lt;parameter&gt;data&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+This will load an 32bit rgba image supplied in data at position xpos,ypos of the texture tex. The image has
+the width w and height h. This can be used to update only parts of the texture. It's no problem to supply big textures,
+as the image will be sent to server in fragments. Of course, you will have created the texture with 
+&lt;link linkend=&quot;s3d_push_texture&quot;&gt;s3d_push_texture&lt;/link&gt;, have an material assigned to the texture with &lt;link linkend=&quot;s3d_pep_material_texture&quot;&gt;
+s3d_pep_material_texture()&lt;/link&gt; and have your polygons set sane polygon texture coords 
+using &lt;link linkend=&quot;s3d_pep_tex_coord&quot;&gt;s3d_pep_tex_coord()&lt;/link&gt;.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;s3d_new_object&quot;&gt;
+&lt;title&gt;s3d_new_object&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_new_object&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+void
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Creates a new object, returning the object id.
+&lt;warning&gt;&lt;para&gt;Of course, you won't forget to &lt;link linkend=&quot;s3d_flags_on&quot;&gt;toggle&lt;/link&gt; it &lt;link linkend=&quot;S3D_OF_VISIBLE&quot;&gt;visible&lt;/link&gt;, won't you?&lt;/para&gt;&lt;/warning&gt;
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_del_object&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_del_object&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;oid&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Deletes the object referenced by oid.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;s3d_clone_object&quot;&gt;
+&lt;title&gt;s3d_clone_object&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_clone_object&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;oid&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Clones an already exisiting object. They get just look the same as the
+parent-object and will change when the parent-object changes.
+Cloning especially makes sense if you want to use the same object a lot of
+times. Move and transform is independent from the parent.
+The function returns the childs object id.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_clone_object_target&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_clone_object_target&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;oid&lt;/parameter&gt;,
+int &lt;parameter&gt;toid&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Changes the clone target of oid to another object (toid). This assumes you've got
+oid from &lt;link linkend=&quot;s3d_clone_object&quot;&gt;s3d_clone_object&lt;/link&gt; before.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_link&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_link&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;oid_from&lt;/parameter&gt;,
+int &lt;parameter&gt;oid_to&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+A linked object will move along with it's link parent. For example if you have
+a book on a table, you can link the book to the table so the book will 
+&quot;keep on the table&quot; if you move the table around in space.
+It will also rotate with the table etc.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_unlink&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_unlink&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;oid&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Remove the link of object oid to its target.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_import_3ds&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_import_3ds&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+char *&lt;parameter&gt;buf&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Imports a 3ds-file from memory (assuming that you have already loaded the 3ds-file and it's located at *buf).
+&lt;/para&gt;
+&lt;warning&gt;&lt;para&gt;Of course, you won't forget to &lt;link linkend=&quot;s3d_flags_on&quot;&gt;toggle&lt;/link&gt; it &lt;link linkend=&quot;S3D_OF_VISIBLE&quot;&gt;visible&lt;/link&gt;, won't you?&lt;/para&gt;&lt;/warning&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_import_3ds_file&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_import_3ds_file&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+char *&lt;parameter&gt;fname&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Opens the 3ds file referenced by 3ds. The function will also look in your object directories (maybe /usr/share/s3d, depending
+on your installation), so you can also use relative paths.
+&lt;/para&gt;
+&lt;warning&gt;&lt;para&gt;Of course, you won't forget to &lt;link linkend=&quot;s3d_flags_on&quot;&gt;toggle&lt;/link&gt; it &lt;link linkend=&quot;S3D_OF_VISIBLE&quot;&gt;visible&lt;/link&gt;, won't you?&lt;/para&gt;&lt;/warning&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;s3d_select_font&quot;&gt;
+&lt;title&gt;s3d_select_font&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_select_font&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+char *&lt;parameter&gt;mask&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+This selects a font for the &lt;link linkend=&quot;s3d_draw_string&quot;&gt;s3d_draw_string()&lt;/link&gt; function.
+&lt;/para&gt;
+&lt;warning&gt;&lt;para&gt;Of course, you won't forget to &lt;link linkend=&quot;s3d_flags_on&quot;&gt;toggle&lt;/link&gt; it &lt;link linkend=&quot;S3D_OF_VISIBLE&quot;&gt;visible&lt;/link&gt;, won't you?&lt;/para&gt;&lt;/warning&gt;
+&lt;programlisting&gt;
+    s3d_select_font(&quot;vera&quot;); /* will use the vera font face */
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;s3d_draw_string&quot;&gt;
+&lt;title&gt;s3d_draw_string&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_draw_string&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+char *&lt;parameter&gt;str&lt;/parameter&gt;,
+float *&lt;parameter&gt;len&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Renders the string str with in Truetype format with the height 1, returns
+the length of the rendered string in *len (or set len=NULL to disable this).
+
+&lt;/para&gt;
+&lt;programlisting&gt;
+	char str=&quot;hello world!&quot;;
+	float len;
+	&lt;link linkend=&quot;s3d_select_font&quot;&gt;s3d_select_font&lt;/link&gt;(&quot;vera&quot;);
+	&lt;emphasis&gt;s3d_draw_string&lt;/emphasis&gt;(str,len);
+
+	/* not interested in the length? do that:
+	 * &lt;emphasis&gt;s3d_draw_string&lt;/emphasis&gt;(str,NULL); */
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_open_file&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_open_file&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+char *&lt;parameter&gt;fname&lt;/parameter&gt;,
+char **&lt;parameter&gt;pointer&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+This opens the file fname, setting *pointer to it's memory position. the
+function will return the size of buffer. you can free() the pointer when
+you're finished.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+
+&lt;sect1 id=&quot;s3d_flags_on&quot;&gt;
+&lt;title&gt;s3d_flags_on&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_flags_on&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;,
+unsigned long &lt;parameter&gt;flags&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+turn some flags on for object.
+&lt;/para&gt;
+&lt;warning&gt;&lt;para&gt;if you don't toggle OF_VISIBLE on, you won't see your object. usually you want this. 
+(at least after you *push()d all your content)&lt;/para&gt;&lt;/warning&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_flags_off&quot;&gt;
+&lt;title&gt;s3d_flags_off&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_flags_off&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;,
+unsigned long &lt;parameter&gt;flags&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+turn some flags off for object.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_translate&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_translate&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;,
+float &lt;parameter&gt;x&lt;/parameter&gt;,
+float &lt;parameter&gt;y&lt;/parameter&gt;,
+float &lt;parameter&gt;z&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Move the object to some position in space. when you create an object, it's 
+always located at 0.0 , 0.0, 0.0.
+&lt;/para&gt;
+&lt;important&gt;&lt;para&gt;Translation is absolute, not relative!&lt;/para&gt;&lt;/important&gt;
+&lt;programlisting&gt;
+&lt;emphasis&gt;s3d_translate&lt;/emphasis&gt;(object,2,0,0);
+&lt;emphasis&gt;s3d_translate&lt;/emphasis&gt;(object,4,0,0);
+/* object will end up at 4,0,0 and not 6,0,0!! */
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_rotate&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_rotate&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;,
+float &lt;parameter&gt;x&lt;/parameter&gt;,
+float &lt;parameter&gt;y&lt;/parameter&gt;,
+float &lt;parameter&gt;z&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+rotate an object around the x, y and z-axis respectively. x,y,z may have values
+between [0,360] degrees. 
+&lt;/para&gt;
+&lt;para&gt;
+You will usually only rotate around one axis, leaving the unused fields on 0, I guess. 
+If you want to rotate around more than one axis, please note: The order of the rotation
+applies is y-axis, x-axis, and then z-axis. You can think of it as the earth position coordinates:
+x is the longitude, y is the latitude, and z is the rotation at this point of the earth around your
+bodies axis. (I wonder if that makes it any clearer ;)
+&lt;/para&gt;
+&lt;important&gt;&lt;para&gt;Rotate is absolute, not relative!&lt;/para&gt;&lt;/important&gt;
+&lt;programlisting&gt;
+&lt;emphasis&gt;s3d_rotate&lt;/emphasis&gt;(object,90,0,0);
+&lt;emphasis&gt;s3d_rotate&lt;/emphasis&gt;(object,180,0,0);
+/* object will be rotated 180 degrees around the x-axis, not 270 degress! */
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_scale&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_scale&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;,
+float &lt;parameter&gt;s&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Scales the object. about factor s. s=1 will be the original size, -1 will mirror it.
+&lt;/para&gt;
+&lt;important&gt;&lt;para&gt;s=0 is forbidden and will be ignored! s3d_scale is also absolute, not relative!&lt;/para&gt;&lt;/important&gt;
+&lt;/sect1&gt;
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_push_event&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_push_event&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+struct s3d_evt &lt;parameter&gt;*newevt&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Pushes an &lt;link linkend=&quot;s3d_evt&quot;&gt;event&lt;/link&gt; onto the event-stack. Usually you don't need to do this manually.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_pop_event&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;struct s3d_evt *&lt;function&gt;s3d_pop_event&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;void
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Pops the latest event from the stack. Don't forget to free() both the event
+and its buffer! Returns a pointer to &lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt&lt;/link&gt;.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_find_event&quot;&gt;
+&lt;title&gt;s3d_find_event&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;struct s3d_evt *&lt;function&gt;s3d_find_event&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+unsigned char &lt;parameter&gt;event&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Finds the latest occurence of an event, giving the event type as argument.
+Returns a pointer to &lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt&lt;/link&gt;.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_delete_event&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_delete_event&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+struct s3d_evt *&lt;parameter&gt;devt&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+deletes an event, the argument is the pointer to the &lt;link linkend=&quot;s3d_evt&quot;&gt;event&lt;/link&gt; which is to be 
+deleted (maybe obtained from &lt;link linkend=&quot;s3d_find_event&quot;&gt;s3d_find_event&lt;/link&gt;).
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_set_callback&quot;&gt;
+&lt;title&gt;s3d_set_callback&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_set_callback&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+unsigned char &lt;parameter&gt;event&lt;/parameter&gt;
+s3d_cb &lt;parameter&gt;func&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+sets a &lt;link linkend=&quot;s3d_cb&quot;&gt;callback&lt;/link&gt; for a certain event. this is very useful for event-oriented 
+applications. event callbacks will not interrupt each other or the mainloop.
+&lt;/para&gt;
+&lt;important&gt;&lt;para&gt;Defining callbacks will only work after calling &lt;link linkend=&quot;s3d_init&quot;&gt;s3d_init()&lt;/link&gt;&lt;/para&gt;&lt;/important&gt;
+&lt;programlisting&gt;
+void obj_click(&lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt&lt;/link&gt; event)
+{
+	printf(&quot;object id %d got clicked&quot;, *((unsigned long *)event-&gt;buf));
+}
+...
+	&lt;link linkend=&quot;s3d_set_callback&quot;&gt;s3d_set_callback&lt;/link&gt;(&lt;link linkend=&quot;S3D_EVENT_NEW_OBJECT&quot;&gt;S3D_EVENT_NEW_OBJECT&lt;/link&gt;, obj_click);
+
+/* this will tell you when a object got clicked */
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_clear_callback&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;void &lt;function&gt;s3d_clear_callback&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+unsigned char &lt;parameter&gt;event&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Clears the callback which is associated with the event.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_get_callback&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;s3d_cb &lt;function&gt;s3d_get_callback&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+unsigned char &lt;parameter&gt;event&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Returns the &lt;link linkend=&quot;s3d_cb&quot;&gt;Callback-function&lt;/link&gt; of the event.
+&lt;/para&gt;
+&lt;programlisting&gt;
+	&lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt&lt;/link&gt; e;
+	...
+	&lt;emphasis&gt;s3d_get_callback&lt;/emphasis&gt;(&lt;link linkend=&quot;S3D_EVENT_KEY&quot;&gt;S3D_EVENT_KEY&lt;/link&gt;)(e);
+	/* will call the key-handling function with argument e.  */
+
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_process_stack&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;void &lt;function&gt;s3d_process_callback&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;void
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+This function goes through all function of the event-stack and will call 
+functions. this is useful when you define a new function but still have a lot 
+of events of this type on the stack. 
+&lt;/para&gt;
+&lt;note&gt;&lt;para&gt;This is probably obsolete&lt;/para&gt;&lt;/note&gt;
+&lt;/sect1&gt;
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_vector_length&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;float &lt;function&gt;s3d_vector_length&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+float &lt;parameter&gt;vector&lt;/parameter&gt;[]
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Calculates and returns the length of the given vector (which should be of the type float[3]).
+More info &lt;ulink url=&quot;<A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Length_of_a_vector">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Length_of_a_vector</A>&quot;&gt;on wikipedia&lt;/ulink&gt;.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_vector_substract&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;void &lt;function&gt;s3d_vector_substract&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+float &lt;parameter&gt;vector1&lt;/parameter&gt;[],
+float &lt;parameter&gt;vector2&lt;/parameter&gt;[],
+float &lt;parameter&gt;result_vector&lt;/parameter&gt;[]
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Substracts vector1 from vector2, writing result into result_vector.
+All vectors should have the format  float[3].
+More info &lt;ulink url=&quot;<A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction</A>&quot;&gt;on wikipedia&lt;/ulink&gt;.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_vector_dot_product&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;float &lt;function&gt;s3d_vector_dot_product&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+float &lt;parameter&gt;vector1&lt;/parameter&gt;[],
+float &lt;parameter&gt;vector2&lt;/parameter&gt;[]
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Calculates and returns the dot product of vector1 and vector2.
+All vectors should have the format  float[3].
+More info &lt;ulink url=&quot;<A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product</A>&quot;&gt;on wikipedia&lt;/ulink&gt;.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_vector_angle&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;float &lt;function&gt;s3d_vector_angle&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+float &lt;parameter&gt;vector1&lt;/parameter&gt;[],
+float &lt;parameter&gt;vector2&lt;/parameter&gt;[]
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+Calculates and returns the angle between vector1 and vector2. Please note that the resulting angle is between 0 and PI, therefore not covering the whole period! To convert in degrees just do result*180/M_PI.
+All vectors should have the format  float[3].
+More info &lt;ulink url=&quot;<A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product</A>&quot;&gt;on wikipedia&lt;/ulink&gt;.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1&gt;
+&lt;title&gt;s3d_mcp_focus&lt;/title&gt;
+&lt;funcsynopsis&gt;
+&lt;funcsynopsisinfo&gt;&lt;![CDATA[#include &lt;s3d.h&gt;]]&gt;&lt;/funcsynopsisinfo&gt;
+&lt;funcprototype&gt;
+&lt;funcdef&gt;int &lt;function&gt;s3d_mcp_focus&lt;/function&gt;&lt;/funcdef&gt;
+&lt;paramdef&gt;
+int &lt;parameter&gt;object&lt;/parameter&gt;
+&lt;/paramdef&gt;
+&lt;/funcprototype&gt;
+&lt;/funcsynopsis&gt;
+&lt;para&gt;
+This is an mcp-only function. It gives focus (for receiving key-strokes etc.)
+to an app referenced by it's mcp-object-id. 
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;/chapter&gt;
+
+
+&lt;chapter id=&quot;data_types&quot;&gt;
+&lt;title&gt;Data types&lt;/title&gt;
+
+&lt;sect1 id=&quot;s3d_obj_info&quot;&gt;
+&lt;title&gt;struct s3d_but_info&lt;/title&gt;
+&lt;programlisting&gt;
+struct s3d_obj_info 
+{
+	unsigned long object;
+	unsigned long flags;
+	float trans_x,trans_y,trans_z;
+	float rot_x,rot_y,rot_z;
+	float scale;
+	float r;
+	char name[256]; 
+};
+&lt;/programlisting&gt;
+&lt;para&gt;
+Can be used on the buffer of an &lt;link linkend=&quot;s3d_evt&quot;&gt;event&lt;/link&gt; of type &lt;link linkend=&quot;S3D_EVENT_OBJ_INFO&quot;&gt;S3D_EVENT_OBJ_INFO&lt;/link&gt;.
+name will usually contain nothing for usual objects, but mcp objects will contain the applications names here. r is the radius of the convex sphere
+an object, which will also be interesting for the mcp.
+&lt;/para&gt;
+&lt;para&gt;
+Special objects like camera, pointer will have the &quot;sys_&quot; prefix in the name and will be named &quot;pointer0&quot;, &quot;pointer1&quot; ... or &quot;cam0&quot;, &quot;cam1&quot; ...
+For cam object, scale will contain the aspect ratio.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+
+&lt;sect1 id=&quot;s3d_but_info&quot;&gt;
+&lt;title&gt;struct s3d_but_info&lt;/title&gt;
+&lt;programlisting&gt;
+struct s3d_but_info     
+{                       
+    unsigned char button, state;
+};                      
+&lt;/programlisting&gt;
+&lt;para&gt;
+Can be used on the buffer of an &lt;link linkend=&quot;s3d_evt&quot;&gt;event&lt;/link&gt; of type &lt;link linkend=&quot;S3D_EVENT_MBUTTON&quot;&gt;S3D_EVENT_MBUTTON&lt;/link&gt;.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;mcp_object&quot;&gt;
+&lt;title&gt;struct mcp_object&lt;/title&gt;
+&lt;programlisting&gt;
+struct mcp_object 
+{
+	unsigned long object;
+	float trans_x,trans_y,trans_z;
+	float r;
+	char name[256]; 
+};
+
+&lt;/programlisting&gt;
+&lt;para&gt;
+obsolete, deprecated, don't use, to be removed soon (use &lt;link linkend=&quot;s3d_but_info&quot;&gt;struct s3d_but_info&lt;/link&gt;). ;)
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_evt&quot;&gt;
+&lt;title&gt;struct s3d_evt&lt;/title&gt;
+&lt;programlisting&gt;
+struct s3d_evt {
+	unsigned char event;
+	int length;
+	char *buf;
+	struct s3d_evt *next;
+};
+&lt;/programlisting&gt;
+&lt;para&gt;
+
+This is the event information holder. 
+&lt;variablelist&gt;
+&lt;varlistentry&gt;
+&lt;term&gt;event&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;gives the &lt;link linkend=&quot;s3d_events&quot;&gt;event type&lt;/link&gt;&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+&lt;varlistentry&gt;
+&lt;term&gt;length&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;gives the length of the buffer *buf&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+&lt;varlistentry&gt;
+&lt;term&gt;*buf&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;is the pointer to the multiple purpose buffer, which will have more specific information about the object&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+&lt;varlistentry&gt;
+&lt;term&gt;*next&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;can be safely ignored ;)&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+&lt;/variablelist&gt;
+
+Depending on the event, buf can contain the keycode pressed on keyboard event, the &lt;link linkend=&quot;s3d_but_info&quot;&gt;mouse button state&lt;/link&gt; on a mouse event, &lt;link linkend=&quot;s3d_obj_info&quot;&gt;object information&lt;/link&gt; etc.
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;sect1 id=&quot;s3d_cb&quot;&gt;
+&lt;title&gt;typedef s3d_cb&lt;/title&gt;
+&lt;programlisting&gt;
+typedef void (*&lt;emphasis&gt;s3d_cb&lt;/emphasis&gt;)(&lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt&lt;/link&gt; *);
+&lt;/programlisting&gt;
+&lt;para&gt;
+This defines the callback format. Each callback should return void and take an argument of &lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt *&lt;/link&gt;.
+Callbacks can be defined with &lt;link linkend=&quot;s3d_set_callback&quot;&gt;s3d_set_callback()&lt;/link&gt;.
+&lt;/para&gt;
+&lt;programlisting&gt;
+/* a callback handler could look like this: */
+void my_key_handler(struct s3d_evt *event_data)
+{
+	...
+}
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+&lt;/chapter&gt;
+
+
+
+
+&lt;chapter id=&quot;definitions&quot;&gt;
+&lt;title&gt;Definitions&lt;/title&gt;
+
+
+
+
+&lt;sect1 id=&quot;s3d_events&quot;&gt;
+&lt;title&gt;S3D events&lt;/title&gt;
+&lt;para&gt;
+This defines the callback format. Each callback should return void and take an argument of &lt;link linkend=&quot;s3d_evt&quot;&gt;struct s3d_evt *&lt;/link&gt;.
+Callbacks can be defined with &lt;link linkend=&quot;s3d_set_callback&quot;&gt;s3d_set_callback()&lt;/link&gt;.
+&lt;variablelist&gt;
+
+&lt;varlistentry&gt;
+&lt;term&gt;&lt;anchor id=&quot;S3D_EVENT_OBJ_CLICK&quot;/&gt;S3D_EVENT_OBJ_CLICK&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;
+An object got clicked (when you set the flag &lt;link linkend=&quot;S3D_OF_SELECTABLE&quot;&gt;S3D_OF_SELECTABLE&lt;/link&gt;), buf will contain the object id
+of the object which got clicked (unsigned long, 4 byte)
+&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+
+&lt;varlistentry&gt;
+&lt;term&gt;&lt;anchor id=&quot;S3D_EVENT_KEY&quot;/&gt;S3D_EVENT_KEY&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;
+A key was pressed, buf will contain a keycode. use  &lt;![CDATA[#include &lt;s3d_keysym.h&gt;]]&gt; to have the keycodes available. buf is a 2 byte unsigned short keycode.
+&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+
+
+&lt;varlistentry&gt;
+&lt;term&gt;&lt;anchor id=&quot;S3D_EVENT_MBUTTON&quot;/&gt;S3D_EVENT_MBUTTON&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;
+A mouse button was clicked. Use &lt;link linkend=&quot;s3d_but_info&quot;&gt;struct s3d_but_info&lt;/link&gt; on buf to get more info.
+&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+
+&lt;varlistentry&gt;
+&lt;term&gt;&lt;anchor id=&quot;S3D_EVENT_NEW_OBJECT&quot;/&gt;S3D_EVENT_NEW_OBJECT&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;
+deprecated, will use &lt;link linkend=&quot;S3D_EVENT_OBJ_INFO&quot;&gt;S3D_EVENT_OBJ_INFO&lt;/link&gt;
+&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+
+
+&lt;varlistentry&gt;
+&lt;term&gt;&lt;anchor id=&quot;S3D_EVENT_OBJ_INFO&quot;/&gt;S3D_EVENT_OBJ_INFO&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;
+Something happened to an object. This can happen if the camera was moved, the mouse (pointer) was moved or an application appeared/changed in the mcp
+
+&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+
+&lt;varlistentry&gt;
+&lt;term&gt;&lt;anchor id=&quot;S3D_MCP_OBJECT&quot;/&gt;S3D_MCP_OBJECT&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;
+As the name suggests, those will only happen to the MCP. 
+This tells it about new/changed application object. &lt;link linkend=&quot;mcp_object&quot;&gt;struct mcp_object&lt;/link&gt;
+can be used on buf. To be removed in the future.
+&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+
+&lt;varlistentry&gt;
+&lt;term&gt;&lt;anchor id=&quot;S3D_MCP_DEL_OBJECT&quot;/&gt;S3D_MCP_DEL_OBJECT&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;
+As the name suggests, those will only happen to the MCP. 
+This tells it about deleted application object. &lt;link linkend=&quot;mcp_object&quot;&gt;struct mcp_object&lt;/link&gt;
+can be used on buf. To be removed in the future.
+&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+
+
+&lt;varlistentry&gt;
+&lt;term&gt;&lt;anchor id=&quot;S3D_EVENT_QUIT&quot;/&gt;S3D_EVENT_QUIT&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;
+Server sent the quit signal, or the connection was terminated. Usually, this is only processed internally.
+&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+
+
+
+&lt;/variablelist&gt;
+&lt;/para&gt;
+&lt;programlisting&gt;
+/* a callback handler could look like this: */
+void my_key_handler(struct s3d_evt *event_data)
+{
+	...
+}
+&lt;/programlisting&gt;
+&lt;/sect1&gt;
+
+
+&lt;sect1 id=&quot;s3d_object_flags&quot;&gt;
+&lt;title&gt;S3D Object Flags&lt;/title&gt;
+&lt;para&gt;
+Objects can have several flags to change their behaviour in the server and can be set with 
+&lt;link linkend=&quot;s3d_flags_on&quot;&gt;s3d_flags_on()&lt;/link&gt; and
+&lt;link linkend=&quot;s3d_flags_off&quot;&gt;s3d_flags_off()&lt;/link&gt;
+&lt;variablelist&gt;
+&lt;varlistentry&gt;
+&lt;term&gt;&lt;anchor id=&quot;S3D_OF_VISIBLE&quot;/&gt;S3D_OF_VISIBLE&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;default:off&lt;/para&gt;&lt;para&gt;
+Obviously, if this flag is toggled the user can see it, if not it will be hidden. ;)
+&lt;/para&gt;&lt;para&gt;
+When an object is created it's turned off, so you will be able push your geometry data and
+turn it on after you're done. That avaoids flickering and stuff.
+&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+
+&lt;varlistentry&gt;
+&lt;term&gt;&lt;anchor id=&quot;S3D_OF_SELECTABLE&quot;/&gt;S3D_OF_SELECTABLE&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;default:off&lt;/para&gt;&lt;para&gt;
+When this is toggled on, you will receive &lt;link linkend=&quot;S3D_EVENT_OBJ_CLICK&quot;&gt;click events&lt;/link&gt;.
+Don't use it if you don't need it, it will eat performance.
+&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+
+&lt;varlistentry&gt;
+&lt;term&gt;&lt;anchor id=&quot;S3D_OF_POINTABLE&quot;/&gt;S3D_OF_POINTABLE&lt;/term&gt;
+&lt;listitem&gt;&lt;para&gt;default:off&lt;/para&gt;&lt;para&gt;
+Placeholder for pointer (onmouseover-event enabler) events. Not implemented yet.
+&lt;/para&gt;&lt;/listitem&gt;
+&lt;/varlistentry&gt;
+
+&lt;/variablelist&gt;
+&lt;/para&gt;
+&lt;/sect1&gt;
+
+&lt;/chapter&gt;
+
+&lt;chapter id=&quot;Notes&quot;&gt;
+&lt;title&gt;Additional Notes&lt;/title&gt;
+&lt;sect1 id=&quot;alpha&quot;&gt;
+&lt;title&gt;About alpha transparency&lt;/title&gt;
+&lt;para&gt;
+Alpha transparency works, but polygons don't get ordered in view direction on the server yet. So please don't
+use this feature yet. If you have an easy idea how to do that with opengl please drop me a line.
+&lt;/para&gt;
+&lt;/sect1&gt;
+&lt;/chapter&gt;
+
+
+
+
+&lt;chapter id=&quot;About&quot;&gt;
+&lt;title&gt;About&lt;/title&gt;
+&lt;para&gt;
+Copyright &#169; 2006 Simon Wunderlich &lt;email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&lt;/email&gt;
+&lt;/para&gt;
+&lt;para&gt;
+All Rights reserved. That is, because I currently don't know how to license this. You may distribute or copy it as long this 
+Documentation is unmodified and complete (I'd love to receive patches and corrections though). Don't hesitate to ask
+if you want to use this doc in any way or have some license recommendation.
+&lt;/para&gt;
+&lt;/chapter&gt;
+
+&lt;/book&gt;
+

Deleted: trunk/Documentation/s3dlib.txt
===================================================================
--- trunk/Documentation/s3dlib.txt	2006-03-19 13:56:11 UTC (rev 216)
+++ trunk/Documentation/s3dlib.txt	2006-03-19 19:20:23 UTC (rev 217)
@@ -1,409 +0,0 @@
-  ___________________________________________________________________________
- /                                                                           \
-|       libs3d documentation                                                  |
- \___________________________________________________________________________/
-
-14.03.06: PLEASE NOTE
-
-- This Document is slightly outdated, I would like to create a HTML/man page for this
-  -&gt; see OPEN_PROBLEMS
-
-this is just a plain raw text documentatio of the libs3d api. maybe i'll do 
-some docbook version later :) please beware: anything may change anytime,
-as i'm sometimes in the mood of changing deep internal things. 
-if you miss something, just drop me a line &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt; :)
-
-------- instructions ----------------------------------------------------------
-
-instructions:
-include the s3d-header with
-
-#include &lt;s3d.h&gt;
-
-make sure that the s3d.h file is in your include path. you can either use
-dynamic linking with the libs3d.so (/dll?!) or statically with the libs3d.a
-file.
-------- data types ------------------------------------------------------------
-
-struct mcp_object 
-{
-	unsigned long object;
-	float trans_x,trans_y,trans_z;
-//	char event;
-#define MCP_NEW_OBJECT	1
-	char name[256]; 
-}
-
-this is the structure of an event-&gt;buf of a S3D_MCP_OBJECT type. it gives 
-infromation about the virtual object which is in fact a logged in application.
-
-_______________________________________________________________________________
-
-typedef void (*s3d_cb)(struct s3d_evt *);
-
-the callback definition. each callback-functions takes a struct s3d_evt 
-pointer as argument. it will contain the information what actually happened
-(e.g which key was pressed, which object was clicked etc)
-
-------- constants -------------------------------------------------------------
-
-#define S3D_EVENT_OBJ_CLICK		1
-
-an object got clicked. the buffer contains a 4byte unsigned long number which
-is the object id. of the clicked object.
-
-#define S3D_EVENT_KEY			2
-
-a key has been pressed. contains a 2byte unsigned short keycode.
-
-#define S3D_MCP_OBJECT			17
-
-information about a virtual object. only an mcp will receive this.
-
-#define S3D_MCP_DEL_OBJECT		18
-
-a virtual object disappeared. (e.g. the app logged out)
-
-#define	S3D_OF_VISIBLE		0x00000001
-
-the object can be seen.
-
-#define	S3D_OF_SELECTABLE	0x00000002
-
-the object can be clicked.
-
-------- functions -------------------------------------------------------------
-
-int s3d_init(int *argc, char ***argv, char *name);
-
-initializes the s3dlibrary, builds the connection to the server and does some
-internal stuff. the argc/argv pointer can be given from 
-main(int argc, char *argv[])
-
-example:
-
-int main(int argc, char *argv[])
-{
-	s3d_init(&amp;argc,&amp;argv,&quot;my program&quot;);
-	...
-_______________________________________________________________________________
-
-
-int s3d_quit();
-
-closes the connection and cleares the event-stack. it can also be used to leave
-the s3d_mainloop
-
-_______________________________________________________________________________
-
-
-int s3d_mainloop(void (*f)());
-
-takes a function as argument. it will loop this function until a quit-event is 
-received. you can pass NULL if you have no function to be looped, but its
-better to sleep some time if you have nothing to do anyway to save cpu-time.
-
-example:
-
-void mainloop()
-{
-	usleep(1000); // sleep 1 ms in every cycle
-}
-...
-
-	s3d_mainloop(mainloop();
-
-_______________________________________________________________________________
-
-int s3d_push_vertex(int object, float x, float y, float z);
-
-pushes a vertex onto the vertex stack. make sure that you count how many
-vertices you've pushed because you'll need that for referencing when you push
-your polygons.
-
-_______________________________________________________________________________
-
-int s3d_push_vertex_array(int object, float *vbuf, unsigned short n);
-
-push some vertices from an array. that's much better for performing than
-using s3d_push_vertex() if you have a lot of vertices (and that's probably the 
-usual case).
-
-example:
-
-	float vertices[] = { 0.0, 0.0, 0.0,
-						 1.0, 2.0, 3,0,
-						 3.0, 2.0, 1.0};
-	s3d_push_vertex_array(object, vertices, 3); // pushing 3 vertices
-
-_______________________________________________________________________________
-
-int s3d_push_material( int object, 
-						float amb_r, float amb_g, float amb_b,
-						float spec_r, float spec_g, float spec_b,
-						float diff_r, float diff_g, float diff_b
-						);
-
-pushes a material for an object. you will have to count them yourself too, as
-polygons will ask for the material index number. the material properties are
-given in rgb (red/green/blue) color codes, in float. 0.0 is the minimum, 
-1.0 is the maximum a color value can be. 
-the specular color is the color which is directly reflected from the light
-source. the diffuse color is the color which can be seen in the bright side
-of the object, and the ambience color is the color of the shadow side of the
-object.
-
-_______________________________________________________________________________
-
-int s3d_push_polygon(int object, int v1, int v2, int v3, int material);
-
-push one polygon on the polygonstack of the object. it takes 3 vertex-index-
-numbers and one material material-index-nr. as argument.
-
-example:
-	int oid=s3d_new_object();	// create a new object
-	s3d_push_vertex(oid,0.0,0.0,0.0);
-	s3d_push_vertex(oid,0.0,1.0,0.0);
-	s3d_push_vertex(oid,1.0,0.0,0.0);
-	s3d_push_material(oid,0.3,0.0,0.0, 1.0,1.0,1.0, 1.0,0.0,0.0);
-	s3d_push_polygon(oid,0,1,2,0);
-	// this will create a red polygon
-
-_______________________________________________________________________________
-
-int s3d_push_polygon_array(int object, unsigned long *pbuf, unsigned short n);
-
-as for vertices, you can push arrays of polygons to have greater performance.
-the pbuf should contain n polygons which consist of 4 unsigned long values
-of 3 vertices indeces and 1 material index.
-
-example:
-	unsigned long pbuf[] = { 0,1,2,0};
-	int oid=s3d_new_object();	// create a new object
-	s3d_push_vertex(oid,0.0,0.0,0.0);
-	s3d_push_vertex(oid,0.0,1.0,0.0);
-	s3d_push_vertex(oid,1.0,0.0,0.0);
-	s3d_push_material(oid,0.3,0.0,0.0, 1.0,1.0,1.0, 1.0,0.0,0.0);
-	s3d_push_polygon_array(oid,pbuf,1);
-	// push one polygon with the pbuf data
-
-_______________________________________________________________________________
-
-int s3d_pop_vertex(int object, unsigned short n);
-int s3d_pop_polygon(int object, unsigned short n);
-int s3d_pop_material(int object, unsigned short n);
-
-deletes the latest n vertices/polygons/materials from the vertex/polygon/
-material stack
-
-_______________________________________________________________________________
-
-int s3d_new_object();
-
-creates a new object, returning the object id.
-
-_______________________________________________________________________________
-
-int s3d_del_object(unsigned long oid);
-
-deletes the object referenced by oid.
-
-_______________________________________________________________________________
-
-int s3d_clone_object(unsigned long oid);
-
-clones an already exisiting object. they get just look the same as the 
-parent-object and will change when the parent-object changes.
-cloning especially makes sense if you want to use the same object a lot of
-times. move and transform is independent from the parent.
-the function returns child's object id.
-
-_______________________________________________________________________________
-
-int s3d_change_clone_target(unsigned long oid, unsigned long toid);
-
-changes the clone target to another object.
-
-_______________________________________________________________________________
-
-int s3d_link(unsigned long oid_from, unsigned long oid_to);
-
-a linked object will move along with it's link parent. for example if you have
-a book on a table, you can link the book to the table so the book will 
-&quot;keep on the table&quot; if you move the table around in space.
-it will also rotate with the table.
-
-_______________________________________________________________________________
-
-int s3d_unlink_object(unsigned long oid);
-
-remove the link to the parent.
-
-_______________________________________________________________________________
-
-int s3d_import_3ds_file(char *fname);
-
-imports a 3ds-file, returning the object id of the loaded file. fname should
-be the path to the 3ds-file.
-
-_______________________________________________________________________________
-
-int s3d_import_3ds(char *buf);
-
-imports a 3ds-file from memory.
-
-_______________________________________________________________________________
-
-int s3d_open_file(char *fname, char **pointer);
-
-this opens the file fname, setting *pointer to it's memory position. the
-function will return the size of buffer. you can free() the pointer when
-you're finished.
-
-_______________________________________________________________________________
-
-int s3d_select_font(char *mask);
-
-this selects a font for the s3d_draw_string() function. 
-
-example:
-
-	s3d_select_font(&quot;vera&quot;);
-	// will use the vera font face
-
-_______________________________________________________________________________
-
-int s3d_draw_string( char *str,float *len);
-
-renders the string str with len in truetype format with the height 1, returns
-the length of the string rendered in *len (or set len=NULL to disable this)
-
-example:
-	
-	char str=&quot;hello world!&quot;;
-	float len;
-	s3d_select_font(&quot;vera&quot;);
-	s3d_draw_string(str,len);
-
-	/* not interested in the length? do that:
-	 * s3d_draw_string(str,NULL); */
-
-_______________________________________________________________________________
-
-int s3d_flags_on(int object, unsigned long flags);
-
-put some flags on for an object.
-
-!!! HINT:
-if you don't toggle OF_VISIBLE on, you won't see your object. usually you want
-this.
-
-_______________________________________________________________________________
-
-int s3d_flags_off(int object, unsigned long flags);
-
-turns some flags off.
-_______________________________________________________________________________
-
-int s3d_translate(int object, float x, float y, float z);
-
-move the object to some position in space. when you create an object, it's 
-always located at 0.0,0.0,0.0
-
-_______________________________________________________________________________
-
-int s3d_rotate(int object, float x, float y, float z);
-
-rotate an object around the x, y and z-axis respectively. x,y,z may have values
-between [0,360].
-
-_______________________________________________________________________________
-
-int s3d_scale(int object, float x, float y, float z);
-
-enlarge an object about the factor of x, y, z for each axis respectively.
-
-_______________________________________________________________________________
-
-float s3d_get_radius(unsigned long oid);
-
-get the radius the sphere which would exactly enclose the object.
-this is useful to get the size of an object, but is slow as it needs 
-interaction with the server (maybe i'll remove this function later ...).
-
-_______________________________________________________________________________
-
-void s3d_push_event(struct s3d_evt *newevt);
-
-push an event onto the event-stack. usually you don't need to do this manually
-
-_______________________________________________________________________________
-
-struct s3d_evt *s3d_pop_event();
-
-pops the latest event from the stack. don't forget to free() it's buffer 
-and the event itself.
-
-_______________________________________________________________________________
-
-struct s3d_evt *s3d_find_event(unsigned char event);
-
-finds an the latest occurence of an event, giving the event type as argument.
-
-_______________________________________________________________________________
-
-int s3d_delete_event(struct s3d_evt *devt);
-
-deletes an event, the argument is the pointer to the event which is to be 
-deleted (maybe obtained from s3d_find_event).
-
-_______________________________________________________________________________
-
-void s3d_set_callback(unsigned char event, s3d_cb func);
-
-sets a callback for a certain event. this is very useful for event-oriented 
-applications. event callbacks will not interrupt each other or the mainloop.
-
-example:
-
-void obj_click(struct s3d_evt event)
-{
-	printf(&quot;object id %d got clicked&quot;, *((unsigned long *)event-&gt;buf));
-}
-...
-	s3d_set_callback(S3D_EVENT_NEW_OBJECT, obj_click);
-
-// this will tell you when a object got clicked
-
-_______________________________________________________________________________
-
-void s3d_clear_callback(unsigned char event);
-
-clears the callback associated with event.
-
-_______________________________________________________________________________
-
-s3d_cb s3d_get_callback(unsigned char event);
-
-returns the callback-function of the event.
-
-example:
-	struct s3d_evt e;
-	...
-	s3d_get_callback(S3D_EVENT_KEY)(e);
-	// will call the key-handling function with argument e. 
-
-_______________________________________________________________________________
-
-void s3d_process_stack();
-
-this function gos through all function of the event-stack and will call 
-functions. this is useful when you define a new function but still have a lot 
-of events of this type on the stack. 
-
-_______________________________________________________________________________
-
-int s3d_mcp_focus(int object);
-
-this is an mcp-only function. it gives focus (for receiving key-strokes etc.)
-to an app referenced by it's mcp-object-id. 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000212.html">[S3d-svn] r216 - trunk/apps/olsrs3d
</A></li>
	<LI>Next message: <A HREF="000214.html">[S3d-svn] r218 - in trunk: . apps/dot_mcp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#213">[ date ]</a>
              <a href="thread.html#213">[ thread ]</a>
              <a href="subject.html#213">[ subject ]</a>
              <a href="author.html#213">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/s3d-svn">More information about the S3d-svn
mailing list</a><br>
</body></html>
