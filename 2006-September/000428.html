<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [S3d-svn] r435 - in trunk: . libs3d/libg3d/plugins/import
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/s3d-svn/2006-September/index.html" >
   <LINK REL="made" HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r435%20-%20in%20trunk%3A%20.%20libs3d/libg3d/plugins/import&In-Reply-To=%3C200609251942.k8PJg5ps011028%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000427.html">
   <LINK REL="Next"  HREF="000429.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[S3d-svn] r435 - in trunk: . libs3d/libg3d/plugins/import</H1>
    <B>dotslash at BerliOS</B> 
    <A HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r435%20-%20in%20trunk%3A%20.%20libs3d/libg3d/plugins/import&In-Reply-To=%3C200609251942.k8PJg5ps011028%40sheep.berlios.de%3E"
       TITLE="[S3d-svn] r435 - in trunk: . libs3d/libg3d/plugins/import">dotslash at mail.berlios.de
       </A><BR>
    <I>Mon Sep 25 21:42:05 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000427.html">[S3d-svn] r434 - in trunk: . objs
</A></li>
        <LI>Next message: <A HREF="000429.html">[S3d-svn] r436 - in trunk: . apps/dot_mcp apps/olsrs3d libs3d
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#428">[ date ]</a>
              <a href="thread.html#428">[ thread ]</a>
              <a href="subject.html#428">[ subject ]</a>
              <a href="author.html#428">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dotslash
Date: 2006-09-25 21:42:04 +0200 (Mon, 25 Sep 2006)
New Revision: 435

Added:
   trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.h
Modified:
   trunk/
Log:
 <A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">r1048 at balthasar</A>:  dotslash | 2006-09-25 21:41:50 +0200
 - add it again (after all, it must be included in the distribution too ...)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1046
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1048

Added: trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.h	2006-09-25 17:10:56 UTC (rev 434)
+++ trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.h	2006-09-25 19:42:04 UTC (rev 435)
@@ -0,0 +1,325 @@
+#ifndef vrml_v1_yyHEADER_H
+#define vrml_v1_yyHEADER_H 1
+#define vrml_v1_yyIN_HEADER 1
+
+#line 6 &quot;imp_vrml_v1.h&quot;
+
+#line 8 &quot;imp_vrml_v1.h&quot;
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 31
+#if YY_FLEX_SUBMINOR_VERSION &gt; 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;stdlib.h&gt;
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have &lt;inttypes.h&gt;. Non-C99 systems may or may not. */
+
+#if defined __STDC_VERSION__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L
+#include &lt;inttypes.h&gt;
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The &quot;const&quot; storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* An opaque pointer. */
+#ifndef YY_TYPEDEF_YY_SCANNER_T
+#define YY_TYPEDEF_YY_SCANNER_T
+typedef void* yyscan_t;
+#endif
+
+/* For convenience, these vars (plus the bison vars far below)
+   are macros in the reentrant scanner. */
+#define yyin yyg-&gt;yyin_r
+#define yyout yyg-&gt;yyout_r
+#define yyextra yyg-&gt;yyextra_r
+#define yyleng yyg-&gt;yyleng_r
+#define yytext yyg-&gt;yytext_r
+#define yylineno (YY_CURRENT_BUFFER_LVALUE-&gt;yy_bs_lineno)
+#define yycolumn (YY_CURRENT_BUFFER_LVALUE-&gt;yy_bs_column)
+#define yy_flex_debug yyg-&gt;yy_flex_debug_r
+
+int vrml_v1_yylex_init (yyscan_t* scanner);
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we &quot;own&quot; the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an &quot;interactive&quot; input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**&lt; The line count. */
+    int yy_bs_column; /**&lt; The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+void vrml_v1_yyrestart (FILE *input_file ,yyscan_t yyscanner );
+void vrml_v1_yy_switch_to_buffer (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
+YY_BUFFER_STATE vrml_v1_yy_create_buffer (FILE *file,int size ,yyscan_t yyscanner );
+void vrml_v1_yy_delete_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
+void vrml_v1_yy_flush_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
+void vrml_v1_yypush_buffer_state (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
+void vrml_v1_yypop_buffer_state (yyscan_t yyscanner );
+
+YY_BUFFER_STATE vrml_v1_yy_scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner );
+YY_BUFFER_STATE vrml_v1_yy_scan_string (yyconst char *yy_str ,yyscan_t yyscanner );
+YY_BUFFER_STATE vrml_v1_yy_scan_bytes (yyconst char *bytes,int len ,yyscan_t yyscanner );
+
+void *vrml_v1_yyalloc (yy_size_t ,yyscan_t yyscanner );
+void *vrml_v1_yyrealloc (void *,yy_size_t ,yyscan_t yyscanner );
+void vrml_v1_yyfree (void * ,yyscan_t yyscanner );
+
+/* Begin user sect3 */
+
+#define yytext_ptr yytext_r
+
+#ifdef YY_HEADER_EXPORT_START_CONDITIONS
+#define INITIAL 0
+#define VRMLHEADER 1
+#define COMMENT 2
+
+#endif
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for &quot;unistd.h&quot;, since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include &lt;unistd.h&gt;
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (yyscan_t yyscanner );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int vrml_v1_yylex_destroy (yyscan_t yyscanner );
+
+int vrml_v1_yyget_debug (yyscan_t yyscanner );
+
+void vrml_v1_yyset_debug (int debug_flag ,yyscan_t yyscanner );
+
+YY_EXTRA_TYPE vrml_v1_yyget_extra (yyscan_t yyscanner );
+
+void vrml_v1_yyset_extra (YY_EXTRA_TYPE user_defined ,yyscan_t yyscanner );
+
+FILE *vrml_v1_yyget_in (yyscan_t yyscanner );
+
+void vrml_v1_yyset_in  (FILE * in_str ,yyscan_t yyscanner );
+
+FILE *vrml_v1_yyget_out (yyscan_t yyscanner );
+
+void vrml_v1_yyset_out  (FILE * out_str ,yyscan_t yyscanner );
+
+int vrml_v1_yyget_leng (yyscan_t yyscanner );
+
+char *vrml_v1_yyget_text (yyscan_t yyscanner );
+
+int vrml_v1_yyget_lineno (yyscan_t yyscanner );
+
+void vrml_v1_yyset_lineno (int line_number ,yyscan_t yyscanner );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern &quot;C&quot; int vrml_v1_yywrap (yyscan_t yyscanner );
+#else
+extern int vrml_v1_yywrap (yyscan_t yyscanner );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int ,yyscan_t yyscanner);
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * ,yyscan_t yyscanner);
+#endif
+
+#ifndef YY_NO_INPUT
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int vrml_v1_yylex (yyscan_t yyscanner);
+
+#define YY_DECL int vrml_v1_yylex (yyscan_t yyscanner)
+#endif /* !YY_DECL */
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+#undef YY_NEW_FILE
+#undef YY_FLUSH_BUFFER
+#undef yy_set_bol
+#undef yy_new_buffer
+#undef yy_set_interactive
+#undef yytext_ptr
+#undef YY_DO_BEFORE_ACTION
+
+#ifdef YY_DECL_IS_OURS
+#undef YY_DECL_IS_OURS
+#undef YY_DECL
+#endif
+#line 425 &quot;imp_vrml_v1.l&quot;
+
+
+#line 324 &quot;imp_vrml_v1.h&quot;
+#undef vrml_v1_yyIN_HEADER
+#endif /* vrml_v1_yyHEADER_H */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000427.html">[S3d-svn] r434 - in trunk: . objs
</A></li>
	<LI>Next message: <A HREF="000429.html">[S3d-svn] r436 - in trunk: . apps/dot_mcp apps/olsrs3d libs3d
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#428">[ date ]</a>
              <a href="thread.html#428">[ thread ]</a>
              <a href="subject.html#428">[ subject ]</a>
              <a href="author.html#428">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/s3d-svn">More information about the S3d-svn
mailing list</a><br>
</body></html>
