<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [S3d-svn] r381 - in trunk: example libs3d libs3d/libg3d/include/g3d	libs3d/libg3d/plugins/image libs3d/libg3d/plugins/import	libs3d/libg3d/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/s3d-svn/2006-September/index.html" >
   <LINK REL="made" HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r381%20-%20in%20trunk%3A%20example%20libs3d%20libs3d/libg3d/include/g3d%0A%09libs3d/libg3d/plugins/image%20libs3d/libg3d/plugins/import%0A%09libs3d/libg3d/src&In-Reply-To=%3C200609151623.k8FGNI4d018431%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000373.html">
   <LINK REL="Next"  HREF="000375.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[S3d-svn] r381 - in trunk: example libs3d libs3d/libg3d/include/g3d	libs3d/libg3d/plugins/image libs3d/libg3d/plugins/import	libs3d/libg3d/src</H1>
    <B>marec at BerliOS</B> 
    <A HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r381%20-%20in%20trunk%3A%20example%20libs3d%20libs3d/libg3d/include/g3d%0A%09libs3d/libg3d/plugins/image%20libs3d/libg3d/plugins/import%0A%09libs3d/libg3d/src&In-Reply-To=%3C200609151623.k8FGNI4d018431%40sheep.berlios.de%3E"
       TITLE="[S3d-svn] r381 - in trunk: example libs3d libs3d/libg3d/include/g3d	libs3d/libg3d/plugins/image libs3d/libg3d/plugins/import	libs3d/libg3d/src">marec at mail.berlios.de
       </A><BR>
    <I>Fri Sep 15 18:23:18 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000373.html">[S3d-svn] r380 - in trunk: . apps/s3dfm
</A></li>
        <LI>Next message: <A HREF="000375.html">[S3d-svn] r382 - trunk/libs3d
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#374">[ date ]</a>
              <a href="thread.html#374">[ thread ]</a>
              <a href="subject.html#374">[ subject ]</a>
              <a href="author.html#374">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: marec
Date: 2006-09-15 18:23:16 +0200 (Fri, 15 Sep 2006)
New Revision: 381

Added:
   trunk/libs3d/libg3d/include/g3d/config.h
   trunk/libs3d/libg3d/plugins/import/imp_3ds.h
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.h
   trunk/libs3d/libg3d/plugins/import/imp_3ds_chunks.h
   trunk/libs3d/libg3d/plugins/import/imp_iob.h
   trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.c
   trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.h
   trunk/libs3d/libg3d/plugins/import/imp_iob_chunks.h
   trunk/libs3d/libg3d/plugins/import/imp_lwo.h
   trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.c
   trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.h
   trunk/libs3d/libg3d/plugins/import/imp_lwo_chunks.h
   trunk/libs3d/libg3d/plugins/import/imp_maya.c
   trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.c
   trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.h
   trunk/libs3d/libg3d/plugins/import/imp_maya_chunks.h
   trunk/libs3d/libg3d/plugins/import/imp_maya_obj.c
   trunk/libs3d/libg3d/plugins/import/imp_maya_obj.h
   trunk/libs3d/libg3d/plugins/import/imp_maya_var.c
   trunk/libs3d/libg3d/plugins/import/imp_maya_var.h
   trunk/libs3d/libg3d/plugins/import/imp_r4.c
   trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.c
   trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.h
   trunk/libs3d/libg3d/plugins/import/imp_r4_chunks.h
   trunk/libs3d/libg3d/plugins/import/imp_test.c
   trunk/libs3d/libg3d/src/object-orig.c
Removed:
   trunk/libs3d/libg3d/plugins/image/img_bmp.c.patch
   trunk/libs3d/libg3d/plugins/image/img_bmp_org.c
Modified:
   trunk/example/3dsloader_g3d.c
   trunk/libs3d/3dsread.c
   trunk/libs3d/libg3d/include/g3d/iff.h
   trunk/libs3d/libg3d/include/g3d/matrix.h
   trunk/libs3d/libg3d/include/g3d/model.h
   trunk/libs3d/libg3d/include/g3d/primitive.h
   trunk/libs3d/libg3d/include/g3d/read.h
   trunk/libs3d/libg3d/include/g3d/texture.h
   trunk/libs3d/libg3d/include/g3d/types.h
   trunk/libs3d/libg3d/plugins/image/img_bmp.c
   trunk/libs3d/libg3d/plugins/import/imp_3dmf.c
   trunk/libs3d/libg3d/plugins/import/imp_3ds.c
   trunk/libs3d/libg3d/plugins/import/imp_cob.c
   trunk/libs3d/libg3d/plugins/import/imp_iob.c
   trunk/libs3d/libg3d/plugins/import/imp_leocad.c
   trunk/libs3d/libg3d/plugins/import/imp_leocad_library.c
   trunk/libs3d/libg3d/plugins/import/imp_lwo.c
   trunk/libs3d/libg3d/plugins/import/imp_obj.c
   trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.l
   trunk/libs3d/libg3d/src/iff.c
   trunk/libs3d/libg3d/src/matrix.c
   trunk/libs3d/libg3d/src/model.c
   trunk/libs3d/libg3d/src/object.c
   trunk/libs3d/libg3d/src/plugins.c
   trunk/libs3d/libg3d/src/primitive.c
   trunk/libs3d/libg3d/src/read.c
   trunk/libs3d/libg3d/src/texture.c
   trunk/libs3d/libg3d/src/vector.c
Log:
libg3d update

Modified: trunk/example/3dsloader_g3d.c
===================================================================
--- trunk/example/3dsloader_g3d.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/example/3dsloader_g3d.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -130,7 +130,7 @@
 			while ( oitem ) {
 
 				object = (G3DObject *)oitem-&gt;data;
-				
+
 				/* push vertices */
 				for ( j = 0; j &lt; object-&gt;vertex_count; j++ ) {
 					/* 3. and 4. param have to change places otherwise the object will be turned */
@@ -202,9 +202,10 @@
 					/* face with texture */
 					if ( ( mat2tex-&gt;texture_id != -1 ) &amp;&amp; ( face-&gt;flags &amp; G3D_FLAG_FAC_TEXMAP ) ) {
 
-						/* printf( &quot;neues face: %i\n&quot;, face-&gt;tex_vertex_count ); */
-						s3d_pep_polygon_tex_coord( obj_id, face-&gt;tex_vertex_data[5], face-&gt;tex_vertex_data[4], face-&gt;tex_vertex_data[3], face-&gt;tex_vertex_data[2], face-&gt;tex_vertex_data[1], face-&gt;tex_vertex_data[0] );
+						/* printf( &quot;text_coords: %f:%f %f:%f %f:%f\n&quot;, face-&gt;tex_vertex_data[0], face-&gt;tex_vertex_data[1], face-&gt;tex_vertex_data[2], face-&gt;tex_vertex_data[3], face-&gt;tex_vertex_data[4], face-&gt;tex_vertex_data[5] ); */
 
+						s3d_pep_polygon_tex_coord( obj_id, face-&gt;tex_vertex_data[0], face-&gt;tex_vertex_data[1], face-&gt;tex_vertex_data[2], face-&gt;tex_vertex_data[3], face-&gt;tex_vertex_data[4], face-&gt;tex_vertex_data[5] );
+
 					}
 
 
@@ -216,6 +217,7 @@
 				oitem = oitem-&gt;next;
 
 			}
+
 			s3d_flags_on( obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE );
 
 			s3d_mainloop(mainloop);

Modified: trunk/libs3d/3dsread.c
===================================================================
--- trunk/libs3d/3dsread.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/3dsread.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -38,14 +38,14 @@
 #ifndef OBJSDIR
 #define OBJSDIR 	&quot;./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/&quot;
 #endif
-	
+
 	strncpy(searchpath,OBJSDIR,1023);
 	searchpath[1023]=0;							/* just in case */
 	next=ptr=searchpath;
 	while (next!=NULL)
 	{
 		next=NULL;
-		
+
 		if (NULL!=(next=strchr(ptr,':')))
 		{
 			*next=0; 							/* clear the delimiter */
@@ -97,7 +97,7 @@
 	min=0;
 	for (i=0;i&lt;polynum;i++)
 	{
-		if (smooth_list[i]&lt;minv) 
+		if (smooth_list[i]&lt;minv)
 		{
 			min=i;
 			minv=smooth_list[i];
@@ -108,7 +108,7 @@
 #define EL	4*sizeof(unsigned long)
 		memcpy(polyel,poly_buf,EL);  /* save */
 		memcpy(poly_buf,poly_buf+4*min,EL);  /* put at first place */
-		memcpy(poly_buf+4*min,polyel,EL); 
+		memcpy(poly_buf+4*min,polyel,EL);
 		 /*  now the same with smooth_list */
 		i=smooth_list[0];
 		smooth_list[0]=smooth_list[min];
@@ -119,7 +119,7 @@
 	{
 		sort_poly(smooth_list+1,poly_buf+4,polynum-1);
 	}
-	
+
 }
 struct t_vertex_normal
 {
@@ -168,7 +168,7 @@
 						v_t_buf[k].n[n]=0;
 					v_t_buf[k].g=-1;  /*  we're telling this by setting group to -1 */
 				}
-				else 
+				else
 					for (n=0;n&lt;3;n++)
 						v_t_buf[k].n[n]/=len;
 				v_t_buf[k].num=1;
@@ -224,7 +224,7 @@
 			}
 		}
 		 /* s3dprintf(LOW,&quot;polygon [%d/%d]: %d %d %d is in smoothlist %d&quot;,i,polynum,v[0],v[1],v[2],g); */
-		
+
 		normal(	vertex_buf+v[0]*3,
 				vertex_buf+v[1]*3,
 				vertex_buf+v[2]*3,
@@ -276,7 +276,7 @@
 	char materials[256][MAXSTRN+1];
 	int clen,cid;
 	int filesize=1;  /*  just so it hops above the main chunk ... */
-	int vertex_offset=0; 
+	int vertex_offset=0;
 	int v=0;
 	int col_obj=-1;
 	unsigned long *poly_buf=NULL,*tpbuf,*smooth_list=NULL;
@@ -294,7 +294,7 @@
 	{
 		cid=gints(ptr);
 		clen=gintl(ptr+2);
-		
+
 		s3dprintf (VLOW,&quot;[pos %x]: \t%04x [len:%d]&quot;,(ptr-buf),cid,(clen-6));
 		if ((ptr==buf) &amp;&amp; (cid!=0x4d4d))
 		{
@@ -304,7 +304,7 @@
 		ptr=ptr+6;  /*  point to the data .. */
 		switch (cid)
 		{
-		  case 0x4d4d: 
+		  case 0x4d4d:
 			  s3dprintf(VLOW,&quot;-- the main chunk!!&quot;);
 			  filesize=clen;
 			  if (cur_oid==-1)
@@ -331,7 +331,7 @@
 			  smooth_list=NULL;
 			  mesh_end=ptr+(clen-6);
 			  break;
-		  case 0x4110: 
+		  case 0x4110:
 			  vertexnum=gints(ptr);
 			  ptr+=sizeof(unsigned short);
 			  s3dprintf(VLOW,&quot;-- vertices list!! number of vertices: %d&quot;,vertexnum);
@@ -355,7 +355,7 @@
 			if (poly_buf==NULL) break;
 		    for (j=0; j&lt;polynum; j++)
 			{
-				poly_buf[j*4+0]=vertex_offset+gints(ptr+0); 
+				poly_buf[j*4+0]=vertex_offset+gints(ptr+0);
 				poly_buf[j*4+1]=vertex_offset+gints(ptr+4);
 				poly_buf[j*4+2]=vertex_offset+gints(ptr+2);
 				poly_buf[j*4+3]=col_obj;  /*  we should have a default material .... */
@@ -381,7 +381,7 @@
 			{
 				j=gints(ptr+2*i);
 				if (j&gt;=0 &amp;&amp; j&lt;polynum)
-					poly_buf[gints(ptr+2*i)*4+3]=col_obj; 
+					poly_buf[gints(ptr+2*i)*4+3]=col_obj;
 				else {
 					errds(MED,&quot;s3d_import_3ds()&quot;,&quot;polygon %d out of range!&quot;,j);
 				}
@@ -390,10 +390,12 @@
 			break;
 		  case 0x4150:
 			s3dprintf(VLOW,&quot;-- smoothing group information (length %d [%d])&quot;, clen,clen/4);
+			printf( &quot;-- smoothing group information (length %d [%d])&quot;, clen, clen/4 );
 			smooth_list=(unsigned long *)ptr;
 			for (j=0;j&lt;(clen/4);j++)
 			{
 				smooth_list[j]=gintl(ptr+j*4);
+				printf( &quot;smooth_list[%i] = %i&quot;, j, smooth_list[j] );
 			}
 
 			ptr=(char *)ptr+(clen-6);
@@ -496,7 +498,7 @@
 		{
 			mesh_end=NULL;
 			if ((vertex_buf!=NULL))
-			    s3d_push_vertices(cur_oid, vertex_buf, vertexnum); 
+			    s3d_push_vertices(cur_oid, vertex_buf, vertexnum);
 			if (poly_buf!=NULL)
 			{
 				if (smooth_list!=NULL)

Added: trunk/libs3d/libg3d/include/g3d/config.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/config.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/config.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,149 @@
+/* libs3d/libg3d/include/g3d/config.h.  Generated from config.h.in by configure.  */
+/* libs3d/libg3d/include/g3d/config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Use GLUT */
+/* #undef G_GLUT */
+
+/* Use SDL */
+#define G_SDL 1
+
+/* Define to 1 if you have the &lt;dirent.h&gt; header file, and it defines `DIR'.
+   */
+#define HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the &lt;dlfcn.h&gt; header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the &lt;fcntl.h&gt; header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the &lt;inttypes.h&gt; header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the &lt;memory.h&gt; header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the &lt;ndir.h&gt; header file, and it defines `DIR'. */
+/* #undef HAVE_NDIR_H */
+
+/* Define to 1 if you have the `select' function. */
+#define HAVE_SELECT 1
+
+/* Define to 1 if you have the `shmget' function. */
+#define HAVE_SHMGET 1
+
+/* Define to 1 if you have the `signal' function. */
+#define HAVE_SIGNAL 1
+
+/* Define to 1 if you have the `socket' function. */
+#define HAVE_SOCKET 1
+
+/* Define to 1 if you have the &lt;stdint.h&gt; header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the &lt;stdlib.h&gt; header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the &lt;strings.h&gt; header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the &lt;string.h&gt; header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strtod' function. */
+#define HAVE_STRTOD 1
+
+/* Define to 1 if you have the `strtol' function. */
+#define HAVE_STRTOL 1
+
+/* Define to 1 if you have the &lt;sys/dir.h&gt; header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define to 1 if you have the &lt;sys/ioctl.h&gt; header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the &lt;sys/ndir.h&gt; header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define to 1 if you have the &lt;sys/stat.h&gt; header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the &lt;sys/time.h&gt; header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the &lt;sys/types.h&gt; header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the &lt;unistd.h&gt; header file. */
+#define HAVE_UNISTD_H 1
+
+/* Name of package */
+#define PACKAGE &quot;s3d&quot;
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT &quot;&quot;
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME &quot;s3d&quot;
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING &quot;s3d 0.1&quot;
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME &quot;s3d&quot;
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION &quot;0.1&quot;
+
+/* Plugin directory */
+#define PLUGIN_DIR &quot;/usr/local/lib/s3d/plugins&quot;
+
+/* Define to 1 if the C compiler supports function prototypes. */
+#define PROTOTYPES 1
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* Define to 1 if the `setvbuf' function takes the buffering type as its
+   second argument and the buffer pointer as the third, as on System V before
+   release 3. */
+/* #undef SETVBUF_REVERSED */
+
+/* Define if shared memory networking code should be compiled */
+#define SHM 1
+
+/* Define if signal code should be compiled */
+#define SIGS 1
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define if TCP/IP network code should be compiled */
+#define TCP 1
+
+/* Define to 1 if you can safely include both &lt;sys/time.h&gt; and &lt;time.h&gt;. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define to 1 if your &lt;sys/time.h&gt; declares `struct tm'. */
+/* #undef TM_IN_SYS_TIME */
+
+/* Version number of package */
+#define VERSION &quot;0.1&quot;
+
+/* Define to 1 if the X Window System is missing or not being used. */
+/* #undef X_DISPLAY_MISSING */
+
+/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
+   `char[]'. */
+#define YYTEXT_POINTER 1
+
+/* Define like PROTOTYPES; this can be used by system headers. */
+#define __PROTOTYPES 1
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */

Modified: trunk/libs3d/libg3d/include/g3d/iff.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/iff.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/iff.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -26,6 +26,16 @@
 #include &lt;stdio.h&gt;
 #include &lt;glib.h&gt;
 
+#include &lt;g3d/types.h&gt;
+
+#define G3D_IFF_PAD1   0x01
+#define G3D_IFF_PAD2   0x02
+#define G3D_IFF_PAD4   0x04
+#define G3D_IFF_PAD8   0x08
+
+#define G3D_IFF_SUBCHUNK_LEN16   0x10
+#define G3D_IFF_LEN16            0x20
+
 #define G3D_IFF_MKID(a,b,c,d) ( \
 	(((guint32)(a))&lt;&lt;24) | \
 	(((guint32)(b))&lt;&lt;16) | \
@@ -34,6 +44,37 @@
 
 G_BEGIN_DECLS
 
+/* global data */
+typedef struct {
+	G3DContext *context;
+	G3DModel *model;
+	FILE *f;
+	guint32 flags;
+	gpointer user_data;
+	long int max_fpos;
+} g3d_iff_gdata;
+
+/* local data */
+typedef struct {
+	guint32 id;
+	guint32 parent_id;
+	gpointer object;
+	gint32 level;
+	gpointer level_object;
+	gint32 nb;
+	gboolean finalize;
+} g3d_iff_ldata;
+
+typedef gboolean (*g3d_iff_chunk_callback)(
+	g3d_iff_gdata *global, g3d_iff_ldata *local);
+
+typedef struct {
+	gchar *id;
+	gchar *description;
+	gboolean container;
+	g3d_iff_chunk_callback callback;
+} g3d_iff_chunk_info;
+
 /**
  * g3d_iff_open:
  * @filename: file name of IFF file
@@ -51,13 +92,22 @@
  * @f: the open IFF file pointer
  * @id: ID of chunk (out)
  * @len: length of chunk (excluding header) (out)
+ * @flags: flags
  *
  * Reads one chunk header from an IFF file.
  *
  * Returns: real length of chunk including header and possible padding byte
  */
-int g3d_iff_readchunk(FILE *f, guint32 *id, guint32 *len);
+int g3d_iff_readchunk(FILE *f, guint32 *id, guint32 *len, guint32 flags);
 
+gchar *g3d_iff_id_to_text(guint32 id);
+
+gboolean g3d_iff_chunk_matches(guint32 id, gchar *tid);
+
+gboolean g3d_iff_read_ctnr(g3d_iff_gdata *global, g3d_iff_ldata *local,
+	g3d_iff_chunk_info *chunks, guint32 flags);
+
+
 G_END_DECLS
 
 #endif

Modified: trunk/libs3d/libg3d/include/g3d/matrix.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/matrix.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/matrix.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -27,6 +27,13 @@
 
 G_BEGIN_DECLS
 
+/*
+ * gfloat matrix[16]:
+ *
+ * matrix[col * 4 + row] = f;
+ *
+ */
+
 /**
  * g3d_matrix_identity:
  * @matrix: 4x4 matrix (float[16])
@@ -90,6 +97,39 @@
  */
 gboolean g3d_matrix_rotate_xyz(gfloat rx, gfloat ry, gfloat rz, gfloat *rm);
 
+/**
+ * g3d_matrix_scale:
+ * @x: x factor
+ * @y: y factor
+ * @z: z factor
+ * @rm: resulting matrix
+ *
+ * Adds a scaling to the matrix.
+ *
+ * Returns: TRUE on success, FALSE else
+ */
+gboolean g3d_matrix_scale(gfloat x, gfloat y, gfloat z, gfloat *rm);
+
+/**
+ * g3d_matrix_transpose:
+ * @matrix: the matrix
+ *
+ * Transposes the matrix.
+ *
+ * Returns: TRUE on success, FALSE else
+ */
+gboolean g3d_matrix_transpose(gfloat *matrix);
+
+/**
+ * g3d_matrix_dump:
+ * @matrix: the matrix
+ *
+ * If debugging is enabled, this function dump the matrix to stderr.
+ *
+ * Returns: TRUE if matrix is dumped, FALSE else
+ */
+gboolean g3d_matrix_dump(gfloat *matrix);
+
 G_END_DECLS
 
 #endif /* __G3D_MATRIX_H__ */

Modified: trunk/libs3d/libg3d/include/g3d/model.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/model.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/model.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -85,6 +85,17 @@
  */
 void g3d_model_free(G3DModel *model);
 
+/**
+ * g3d_model_get_object_by_name:
+ * @model: the model containing all objects
+ * @name: the name of the requested object
+ *
+ * Searches the object tree for an object with the given name.
+ *
+ * Returns: the requested object or NULL if non was found
+ */
+G3DObject *g3d_model_get_object_by_name(G3DModel *model, const gchar *name);
+
 G_END_DECLS
 
 #endif /* __G3D_MODEL_H__ */

Modified: trunk/libs3d/libg3d/include/g3d/primitive.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/primitive.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/primitive.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -27,6 +27,9 @@
 
 G_BEGIN_DECLS
 
+G3DObject *g3d_primitive_cube(gfloat width, gfloat height, gfloat depth,
+	G3DMaterial *material);
+
 /**
  * g3d_primitive_cylinder:
  * @radius: the radius of the cylinder
@@ -60,6 +63,20 @@
 G3DObject *g3d_primitive_tube(gfloat r_in, gfloat r_out, gfloat height,
 	guint32 sides, gboolean top, gboolean bottom, G3DMaterial *material);
 
+/**
+ * g3d_primitive_sphere:
+ * @radius: radius
+ * @vseg: number of vertical segments
+ * @hseg: number of horizontal segments
+ * @materal: material to use for faces
+ *
+ * Generates an object containing a sphere.
+ *
+ * Returns: sphere object
+ */
+G3DObject *g3d_primitive_sphere(gfloat radius, guint32 vseg, guint32 hseg,
+	G3DMaterial *material);
+
 G_END_DECLS
 
 #endif /* __G3D_PRIMITIVE_H__ */

Modified: trunk/libs3d/libg3d/include/g3d/read.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/read.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/read.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -98,6 +98,30 @@
  */
 gfloat g3d_read_float_le(FILE *f);
 
+/**
+ * g3d_read_double_be:
+ * @f: the file to read from
+ *
+ * Read a 8 byte big-endian double-precision floating point number from file.
+ *
+ * Returns: The read value, 0 in case of error
+ */
+gdouble g3d_read_double_be(FILE *f);
+
+/**
+ * g3d_read_double_be:
+ * @f: the file to read from
+ *
+ * Read a 8 byte little-endian double-precision floating point number from
+ * file.
+ *
+ * Returns: The read value, 0 in case of error
+ */
+
+gdouble g3d_read_double_le(FILE *f);
+
+gint32 g3d_read_cstr(FILE *f, gchar *buffer, gint32 max_len);
+
 G_END_DECLS
 
 #endif /* __G3D_READ_H__ */

Modified: trunk/libs3d/libg3d/include/g3d/texture.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/texture.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/texture.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -27,6 +27,8 @@
 
 G_BEGIN_DECLS
 
+G3DImage *g3d_texture_load(G3DContext *context, const gchar *filename);
+
 /**
  * g3d_texture_load_cached:
  * @context: a valid context
@@ -41,6 +43,8 @@
 G3DImage *g3d_texture_load_cached(G3DContext *context, G3DModel *model,
 	const gchar *filename);
 
+void g3d_texture_free(G3DImage *texture);
+
 /**
  * g3d_texture_prepare:
  * @texture: a texture image
@@ -53,6 +57,10 @@
  */
 gboolean g3d_texture_prepare(G3DImage *texture);
 
+gboolean g3d_texture_flip_y(G3DImage *texture);
+
+G3DImage *g3d_texture_merge_alpha(G3DImage *image, G3DImage *aimage);
+
 G_END_DECLS
 
 #endif /* __G3D_TEXTURE_H__ */

Modified: trunk/libs3d/libg3d/include/g3d/types.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/types.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/types.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -85,6 +85,16 @@
 } G3DFace;
 
 /*****************************************************************************
+ * G3DTransformation
+ *****************************************************************************/
+
+typedef struct {
+	gfloat matrix[16];
+	guint32 flags;
+} G3DTransformation;
+
+
+/*****************************************************************************
  * G3DObject
  *****************************************************************************/
 typedef struct {
@@ -94,6 +104,9 @@
 	GSList *faces;
 	GSList *objects;
 
+	/* transformation, may be NULL */
+	G3DTransformation *transformation;
+
 	/* don't render this object */
 	gboolean hide;
 

Modified: trunk/libs3d/libg3d/plugins/image/img_bmp.c
===================================================================
--- trunk/libs3d/libg3d/plugins/image/img_bmp.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/image/img_bmp.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -57,7 +57,7 @@
 	headsize = g3d_read_int32_le(f);      /* size of header */
 	image-&gt;width  = g3d_read_int32_le(f); /* width */
 	image-&gt;height = g3d_read_int32_le(f); /* height */
-	g3d_read_int16_le(f);                               /* num of color planes */
+	g3d_read_int16_le(f);                 /* num of color planes */
 	image-&gt;depth  = g3d_read_int16_le(f); /* bits per pixel */
 	compression   = g3d_read_int32_le(f); /* compression */
 	g3d_read_int32_le(f);                 /* image size */

Deleted: trunk/libs3d/libg3d/plugins/image/img_bmp.c.patch
===================================================================
--- trunk/libs3d/libg3d/plugins/image/img_bmp.c.patch	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/image/img_bmp.c.patch	2006-09-15 16:23:16 UTC (rev 381)
@@ -1,11 +0,0 @@
---- img_bmp_org.c	2006-01-24 11:04:19.000000000 +0100
-+++ img_bmp.c	2006-05-18 18:11:23.000000000 +0200
-@@ -32,7 +32,7 @@
- {
- 	FILE *f;
- 	guint32 filesize, offset, headsize, compression;
--	guint32 x, y;
-+	gint32 x, y;
- 
- 	f = fopen(filename, &quot;r&quot;);
- 	if(f == NULL)

Deleted: trunk/libs3d/libg3d/plugins/image/img_bmp_org.c
===================================================================
--- trunk/libs3d/libg3d/plugins/image/img_bmp_org.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/image/img_bmp_org.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -1,130 +0,0 @@
-/* $Id: img_bmp.c,v 1.1.2.2 2006/01/23 16:44:28 dahms Exp $ */
-
-/*
-    libg3d - 3D object loading library
-
-    Copyright (C) 2005, 2006  Markus Dahms &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">mad at automagically.de</A>&gt;
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;errno.h&gt;
-
-#include &lt;g3d/types.h&gt;
-#include &lt;g3d/read.h&gt;
-
-gboolean plugin_load_image(G3DContext *context, const gchar *filename,
-	G3DImage *image, gpointer user_data)
-{
-	FILE *f;
-	guint32 filesize, offset, headsize, compression;
-	guint32 x, y;
-
-	f = fopen(filename, &quot;r&quot;);
-	if(f == NULL)
-	{
-		g_printerr(&quot;couldn't open image file '%s': %s\n&quot;, filename,
-			strerror(errno));
-		return FALSE;
-	}
-
-	/* bitmap file always starts with 'BM' */
-	if(g3d_read_int16_le(f) != ('B' | ('M' &lt;&lt; 8)))
-	{
-		g_printerr(&quot;bitmap magic not found: image seems to be corrupt\n&quot;);
-		return FALSE;
-	}
-
-	image-&gt;name = g_strdup(filename);
-
-	filesize = g3d_read_int32_le(f);      /* file size */
-	g3d_read_int32_le(f);                 /* 2 x UINT16 reserved */
-	offset   = g3d_read_int32_le(f);      /* offset of data */
-	headsize = g3d_read_int32_le(f);      /* size of header */
-	image-&gt;width  = g3d_read_int32_le(f); /* width */
-	image-&gt;height = g3d_read_int32_le(f); /* height */
-	g3d_read_int16_le(f);                               /* num of color planes */
-	image-&gt;depth  = g3d_read_int16_le(f); /* bits per pixel */
-	compression   = g3d_read_int32_le(f); /* compression */
-	g3d_read_int32_le(f);                 /* image size */
-	g3d_read_int32_le(f);                 /* v/res (dpi) */
-	g3d_read_int32_le(f);                 /* h/res (dpi) */
-
-	fseek(f, offset, SEEK_SET);
-
-#define ALL32BIT
-#ifndef ALL32BIT /* always 32bit for now.. */
-	image-&gt;pixeldata = g_malloc0(image-&gt;width*image-&gt;height*(image-&gt;depth/8));
-#else
-	image-&gt;pixeldata = g_malloc0(image-&gt;width * image-&gt;height * 4);
-#endif
-
-	for(y=image-&gt;height-1; y&gt;=0; y--)
-	{
-#if DEBUG &gt; 5
-		g_printerr(&quot;| &quot;);
-#endif
-		for(x=0; x&lt;image-&gt;width; x++)
-		{
-			switch(image-&gt;depth)
-			{
-				case 8:
-#ifndef ALL32BIT
-					image-&gt;pixeldata[y*image-&gt;width+x] = g3d_read_int8(f);
-#else
-					image-&gt;pixeldata[(y*image-&gt;width+x)*4+0] = g3d_read_int8(f);
-					image-&gt;pixeldata[(y*image-&gt;width+x)*4+3] = 0xFF;
-#endif
-#if DEBUG &gt; 5
-					g_printerr(&quot;%2.2X &quot;, image-&gt;pixeldata[y*image-&gt;width+x]);
-#endif
-					break;
-				case 24:
-					image-&gt;pixeldata[(y*image-&gt;width+x)*4+0] = g3d_read_int8(f);
-					image-&gt;pixeldata[(y*image-&gt;width+x)*4+1] = g3d_read_int8(f);
-					image-&gt;pixeldata[(y*image-&gt;width+x)*4+2] = g3d_read_int8(f);
-					image-&gt;pixeldata[(y*image-&gt;width+x)*4+3] = 0xFF;
-					break;
-				default:
-					break;
-			}
-		}
-#if DEBUG &gt; 5
-		g_printerr(&quot;\n&quot;);
-#endif
-	}
-	image-&gt;depth = 32;
-#if DEBUG &gt; 2
-	g_printerr(&quot;bitmap successfully loaded\n&quot;);
-#endif
-
-	return TRUE;
-}
-
-gchar *plugin_description(G3DContext *context)
-{ 
-	return g_strdup(
-		&quot;Plugin to read Windows Bitmap (.bmp) images\n&quot;
-		&quot;(for use as textures or height fields)\n&quot;
-		&quot;Author: Markus Dahms&quot;);
-}
-
-gchar **plugin_extensions(G3DContext *context)
-{
-	return g_strsplit(&quot;bmp&quot;, &quot;:&quot;, 0);
-}
-

Modified: trunk/libs3d/libg3d/plugins/import/imp_3dmf.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3dmf.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_3dmf.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -72,7 +72,7 @@
 		return FALSE;
 	}
 
-	g3d_iff_readchunk(f, &amp;id, &amp;len);
+	g3d_iff_readchunk(f, &amp;id, &amp;len, 0);
 	if((id != G3D_IFF_MKID('3', 'D', 'M', 'F')) ||
 		(len != 16))
 	{
@@ -409,7 +409,7 @@
 
 	object = x3dmf_object_new(f, model);
 
-	g3d_iff_readchunk(f, &amp;id, &amp;len);
+	g3d_iff_readchunk(f, &amp;id, &amp;len, 0);
 	switch(id)
 	{
 		case G3D_IFF_MKID('c', 't', 'n', 'r'):
@@ -438,7 +438,7 @@
 	{
 		if(feof(f)) break;
 
-		g3d_iff_readchunk(f, &amp;id, &amp;len);
+		g3d_iff_readchunk(f, &amp;id, &amp;len, 0);
 		length -= 8;
 
 		if(id == 0)

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -29,19 +29,9 @@
 #include &lt;g3d/material.h&gt;
 #include &lt;g3d/texture.h&gt;
 
-int x3ds_container(FILE *f, guint32 nb, G3DContext *context, G3DModel *model,
-	gpointer pobject, gint32 level, gint32 parent);
-int x3ds_read_cstr(FILE *f, char *string);
-int x3ds_read_pointarray(FILE *f, int nb, G3DObject *object, int level);
-int x3ds_read_facearray(FILE *f, int nb, G3DObject *object);
-int x3ds_read_meshmatgrp(FILE *f, int nb, G3DModel *model, G3DObject *object,
-	int level);
-void x3ds_debug(int level, char *format, ...);
-G3DObject *x3ds_newobject(G3DModel *model, const char *name);
+#include &quot;imp_3ds.h&quot;
+#include &quot;imp_3ds_chunks.h&quot;
 
-/* FIXME: replace */
-float x3ds_global_scale = 1.0;
-
 /*****************************************************************************/
 /* plugin interface                                                          */
 /*****************************************************************************/
@@ -51,6 +41,9 @@
 {
 	FILE *f;
 	gint32 nbytes, magic;
+	x3ds_global_data global;
+	x3ds_parent_data *parent;
+	long int fpos;
 
 	f = fopen(filename, &quot;r&quot;);
 	if(f == NULL)
@@ -70,7 +63,29 @@
 	nbytes -= 6;
 	g_printerr(&quot;[%4.4X] 3DS file: main length: %d\n&quot;, magic, nbytes);
 
+	global.context = context;
+	global.model = model;
+	global.f = f;
+	global.scale = 1.0;
+	global.max_tex_id = 0;
+
+	/* get size of file */
+	fpos = ftell(global.f);
+	fseek(global.f, 0, SEEK_END);
+	global.max_fpos = ftell(global.f);
+	fseek(global.f, fpos, SEEK_SET);
+
+	parent = g_new0(x3ds_parent_data, 1);
+	parent-&gt;id = magic;
+	parent-&gt;nb = nbytes;
+
+	x3ds_read_ctnr(&amp;global, parent);
+
+	g_free(parent);
+
+	/*
 	x3ds_container(f, nbytes, context, model, NULL, 1, magic);
+	*/
 
 	fclose(f);
 #if DEBUG &gt; 0
@@ -92,380 +107,94 @@
 
 /*****************************************************************************/
 
-int x3ds_container(FILE *f, guint32 nb, G3DContext *context, G3DModel *model,
-	gpointer pobject, gint32 level, gint32 parent)
+gboolean x3ds_read_ctnr(x3ds_global_data *global, x3ds_parent_data *parent)
 {
-	gint32 chunk_id, chunk_len, nbytes, toread;
-	char name[2048];
-	G3DObject *new_object;
+	gint32 chunk_id, chunk_len, i;
+	x3ds_parent_data *subparent;
+	gpointer level_object;
 
-	nbytes = nb;
-	while(nbytes &gt; 0)
+	level_object = NULL;
+
+	while(parent-&gt;nb &gt; 0)
 	{
-		chunk_id  = g3d_read_int16_le(f);
-		chunk_len = g3d_read_int32_le(f);
-		nbytes -= 6;
+		chunk_id  = g3d_read_int16_le(global-&gt;f);
+		chunk_len = g3d_read_int32_le(global-&gt;f);
+		parent-&gt;nb -= 6;
 		chunk_len -= 6;
-		toread = chunk_len;
-		switch(chunk_id)
-		{
-			case 0x0002: { /* M3D version */
-				int version = g3d_read_int32_le(f);
-				x3ds_debug(level, &quot;[%4.4XH] M3D Version: %d.%d (%d byte)\n&quot;,
-					 chunk_id, version &amp; 0xFF, version &gt;&gt; 16, toread);
-				toread -= 4; }
-				break;
-			case 0x0011: { /* color 24 */
-				int r,g,b;
-				r = g3d_read_int8(f);
-				g = g3d_read_int8(f);
-				b = g3d_read_int8(f);
-				x3ds_debug(level,
-					&quot;[%4.4XH] color (24 bit): #%.2X%.2X%.2X (%d byte)\n&quot;,
-					chunk_id, r,g,b, toread);
-				if((parent == 0xA010) || /* ambient color */
-					 (parent == 0xA020))   /* diffuse */
-				{
-					((G3DMaterial*)pobject)-&gt;r = (float)r / 255.0;
-					((G3DMaterial*)pobject)-&gt;g = (float)g / 255.0;
-					((G3DMaterial*)pobject)-&gt;b = (float)b / 255.0;
-				}
-				else if(parent == 0xA030) /* specular */
-				{
-					((G3DMaterial*)pobject)-&gt;specular[0] = (float)r / 255.0;
-					((G3DMaterial*)pobject)-&gt;specular[1] = (float)g / 255.0;
-					((G3DMaterial*)pobject)-&gt;specular[2] = (float)b / 255.0;
-					((G3DMaterial*)pobject)-&gt;specular[3] = 0.25;
-				}
-				else g_printerr(&quot;*** unhandled ***\n&quot;);
-				toread -= 3; }
-				break;
-			case 0x0030: { /* short percentage */
-				int percent = g3d_read_int16_le(f);
-				x3ds_debug(level, &quot;[%4.4XH] percentage: %d%% (%d byte)\n&quot;,
-					chunk_id, percent, toread);
-				toread -= 2;
-				if(parent == 0xA040) /* shininess */
-				{
-					((G3DMaterial*)pobject)-&gt;shininess =
-						(gfloat)percent / 100.0;
-				}
-				else if(parent == 0xA050) /* transparency */
-				{
-					((G3DMaterial*)pobject)-&gt;a =
-						1.0 - ((gfloat)percent / 100.0);
-				}
-				else g_printerr(&quot;*** unhandled ***\n&quot;);
-				} break;
 
-			case 0x0031: { /* float percentage */
-				float fpercent = g3d_read_float_le(f);
-				x3ds_debug(level, &quot;[%4.4XH] float percentage: %f (%d byte)\n&quot;,
-					chunk_id, fpercent, toread);
-				toread -= 4;
-				if(parent == 0xA040) /* shininess */
-				{
-					((G3DMaterial*)pobject)-&gt;shininess = fpercent;
-				}
-				else g_printerr(&quot;*** unhandled ***\n&quot;);
-				} break;
+		i = 0;
+		while((x3ds_chunks[i].id != 0) &amp;&amp; (x3ds_chunks[i].id != chunk_id))
+			i ++;
 
-			case 0x0100: /* global scale */
-				x3ds_global_scale = g3d_read_float_le(f);
-				x3ds_debug(level, &quot;[%4.4XH] master scale: %f (%d byte)\n&quot;,
-									 chunk_id, x3ds_global_scale, toread);
-				toread -= 4;
-				break;
-			case 0x3D3D: /* mesh */
-				x3ds_debug(level, &quot;[%4.4XH] 3DS mesh object (%d byte)\n&quot;,
-									 chunk_id, toread);
-				x3ds_container(f, toread, context, model, NULL, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0x3D3E: { /* mesh version */
-				int minor, major;
-				major = g3d_read_int16_le(f);
-				minor = g3d_read_int16_le(f);
-				x3ds_debug(level, &quot;[%4.4XH] mesh version %d.%d (%d byte)\n&quot;,
-					chunk_id, major, minor, toread);
-				toread -= 4; }
-				break;
-			case 0x4000: /* named object */
-				toread -= x3ds_read_cstr(f, name);
-				new_object = x3ds_newobject(model, name);
-				x3ds_debug(level,
-					&quot;[%4.4XH] named object: %s (%d byte)\n&quot;, chunk_id,
-					 name, toread);
-				x3ds_container(f, toread, context, model, new_object,
-					level + 1, chunk_id);
-				toread = 0;
-				break;
-			case 0x4100: /* named triangle object */
-				x3ds_debug(level,
-					&quot;[%4.4XH] named triangle object: %s (%d byte)\n&quot;,
-					chunk_id, &quot;&quot;, chunk_len);
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0x4110: /* point array */
-				toread = x3ds_read_pointarray(f, toread, (G3DObject*)pobject,
-					level);
-				break;
-			case 0x4111: /* point flag array */
-				x3ds_debug(level, &quot;[%4.4XH] point flag array (%d byte)\n&quot;,
-					chunk_id, toread);
-				fseek(f, toread, SEEK_CUR);
-				toread = 0;
-				break;
-			case 0x4120: /* face array */
-				x3ds_debug(level, &quot;[%4.4XH] face array (%d byte)\n&quot;,
-									 chunk_id, toread);
-				toread = x3ds_read_facearray(f, toread, (G3DObject*)pobject);
-				if(toread != 0)
-				{
-					x3ds_container(f, toread, context, model, pobject,
-						level + 1, 0x4120);
-					toread = 0;
-				}
-				break;
-			case 0x4130: /* mesh mat group */
-				toread = x3ds_read_meshmatgrp(f, toread, model,
-					(G3DObject*)pobject, level);
-				break;
-			case 0x4140: { /* texture vertices */
-				G3DObject *object = (G3DObject*)pobject;
-				int i, bytes = toread;
-				object-&gt;tex_vertex_count = g3d_read_int16_le(f);
-				toread -= 2;
-				object-&gt;tex_vertex_data =
-					g_new0(gfloat, object-&gt;tex_vertex_count * 2);
-				for(i=0; i&lt;object-&gt;tex_vertex_count; i++)
-				{
-					object-&gt;tex_vertex_data[i*2+0] = g3d_read_float_le(f);
-					object-&gt;tex_vertex_data[i*2+1] = g3d_read_float_le(f);
-					toread -= 8;
-				}
-				x3ds_debug(level,
-					&quot;[%4.4XH] texture vertices: %d verts (%d byte)\n&quot;,
-					chunk_id, object-&gt;tex_vertex_count, bytes);
-				} break;
-			case 0x4150: /* smooth group */
-				x3ds_debug(level, &quot;[%4.4XH] smooth group (%d byte)\n&quot;,
-					chunk_id, toread);
-				fseek(f, toread, SEEK_CUR);
-				toread = 0;
-				break;
-			case 0x4160: { /* mesh matrix / local axis */
-				gfloat matrix[16];
-				int w, h;
-				x3ds_debug(level, &quot;[%4.4XH] mesh matrix (%d byte)\n&quot;,
-					chunk_id, toread);
-				for(w = 0; w &lt; 4; w ++)
-				{
-#if DEBUG &gt; 0
-					g_print(&quot;MATRIX:&quot;);
-#endif
-					for(h = 0; h &lt; 3; h ++)
-					{
-						matrix[h * 4 + w] = g3d_read_float_le(f);
-#if DEBUG &gt; 0
-						g_print(&quot; %+2.2f&quot;, matrix[h * 4 + w]);
-#endif
-					}
-#if DEBUG &gt; 0
-					g_print(&quot;\n&quot;);
-#endif
-				}
+		if(x3ds_chunks[i].id == chunk_id)
+		{
+			x3ds_debug(parent-&gt;level, &quot;[0x%04X][%c%c] %s (%d bytes)\n&quot;,
+				chunk_id,
+				x3ds_chunks[i].container ? 'c' : ' ',
+				x3ds_chunks[i].callback ? 'f' : ' ',
+				x3ds_chunks[i].desc, chunk_len);
 
-				matrix[12] = matrix[13] = matrix[14] = 0.0;
-				matrix[15] = 1.0;
+			subparent = g_new0(x3ds_parent_data, 1);
+			subparent-&gt;id = parent-&gt;id;
+			subparent-&gt;object = parent-&gt;object;
+			subparent-&gt;level = parent-&gt;level + 1;
+			subparent-&gt;level_object = level_object;
+			subparent-&gt;nb = chunk_len;
 
-#if 0
-				for(i = 0; i &lt; object-&gt;vertex_count; i ++)
-					g3d_vector_transform(
-						&amp;(object-&gt;vertices[i * 3 + 0]),
-						&amp;(object-&gt;vertices[i * 3 + 1]),
-						&amp;(object-&gt;vertices[i * 3 + 2]),
-						matrix);
-#endif
-				toread -= 48;
-				} break;
+			if(x3ds_chunks[i].callback)
+			{
+				/* callback may change &quot;nb&quot; and &quot;object&quot; of
+				 * &quot;subparent&quot; structure for following container run */
 
-			case 0x4165: /* mesh color */
-				x3ds_debug(level, &quot;[%4.4XH] mesh color %d (%d byte)\n&quot;,
-					chunk_id, g3d_read_int8(f), toread);
-				toread -= 1;
-				fseek(f, toread, SEEK_CUR);
-				toread = 0;
-				break;
+				x3ds_chunks[i].callback(global, subparent);
+			}
 
-			case 0x4170: /* texture info */
-				x3ds_debug(level, &quot;[%4.4XH] texture info (%d byte)\n&quot;,
-					chunk_id, toread);
-				g3d_read_int16_le(f); /* map_type */
-				toread -= 2;
-				g3d_read_float_le(f); /* x_tiling */
-				g3d_read_float_le(f); /* y_tiling */
-				toread -= 8;
-				g3d_read_float_le(f); /* icon_x */
-				g3d_read_float_le(f); /* icon_y */
-				g3d_read_float_le(f); /* icon_z */
-				toread -= 12;
-				fseek(f, 4 * 12, SEEK_CUR); /* matrix (4 x 3) */
-				toread -= 4 * 12;
-				g3d_read_float_le(f); /* scaling */
-				g3d_read_float_le(f); /* plan_icon_w */
-				g3d_read_float_le(f); /* plan_icon_h */
-				g3d_read_float_le(f); /* cyl_icon_h */
-				toread -= 16;
-				break;
+			subparent-&gt;id = chunk_id;
 
-			case 0xA000: /* material name */
-				toread -= x3ds_read_cstr(f, name);
-				if(pobject != NULL)
-				{
-					((G3DMaterial*)pobject)-&gt;name = g_strdup(name);
-				}
-				else
-				{
-					g_printerr(&quot;material object = NULL :(\n&quot;);
-				}
-				x3ds_debug(level, &quot;[%4.4XH] material name: %s (%d byte)\n&quot;,
-									 chunk_id, name, chunk_len);
-				break;
+			if(x3ds_chunks[i].container)
+			{
+				x3ds_read_ctnr(global, subparent);
+			}
 
-			case 0xA010: /* ambient color */
-			case 0xA020: /* diffuse color */
-			case 0xA030: /* specular color */
-				x3ds_debug(level, &quot;[%4.4XH] material color (%d byte)\n&quot;,
-					chunk_id, toread);
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0xA040: /* shininess */
-				x3ds_debug(level, &quot;[%4.4XH] shininess (%d byte)\n&quot;, chunk_id,
-									 toread);
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0xA050: /* transparency */
-				x3ds_debug(level, &quot;[%4.4XH] transparency (%d byte)\n&quot;, chunk_id,
-									 toread);
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0xA052: /* XPFALL? */
-				x3ds_debug(level, &quot;[%4.4XH] fallthrough?? (%d byte)\n&quot;, chunk_id,
-									 toread);
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0xA053: /* REFBLUR? */
-				x3ds_debug(level, &quot;[%4.4XH] blur?? (%d byte)\n&quot;, chunk_id,
-									 toread);
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0xA081:
-				x3ds_debug(level, &quot;[%4.4XH] mat two side (%d byte)\n&quot;, chunk_id,
-									 toread);
-				((G3DMaterial*)pobject)-&gt;flags |= G3D_FLAG_MAT_TWOSIDE;
-				break;
-			case 0xA100: { /* shading */
-				int shade = g3d_read_int16_le(f);
-				x3ds_debug(level, &quot;[%4.4XH] shading: %d (%d byte)\n&quot;, chunk_id,
-									 shade, toread);
-				toread -= 2; }
-				break;
-			case 0xA200: /* texture map */
-				x3ds_debug(level, &quot;[%4.4XH] texture map (%d byte)\n&quot;, chunk_id,
-									 toread);
-				((G3DMaterial*)pobject)-&gt;flags |= G3D_FLAG_FAC_TEXMAP;
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0xA300: /* map name */
-				if(parent == 0xA200)
-				{
-					G3DMaterial *material = (G3DMaterial*)pobject;
-					toread -= x3ds_read_cstr(f, name);
-					x3ds_debug(level, &quot;[%4.4XH] map name \&quot;%s\&quot; (%d byte)\n&quot;,
-						chunk_id, name, toread);
-					material-&gt;tex_image = g3d_texture_load_cached(context,
-						model, name);
-					if(material-&gt;tex_image)
-					{
-						/* FIXME: better way to generate unique texture ids */
-						material-&gt;tex_image-&gt;tex_id = g_random_int();
-						/*
-						g3d_texture_prepare(material-&gt;texture);
-						*/
-					}
-				}
-				break;
+			if(subparent-&gt;nb)
+			{
+				fseek(global-&gt;f, subparent-&gt;nb, SEEK_CUR);
+			}
 
-			case 0xA351: /* map tiling */
-				x3ds_debug(level, &quot;[%4.4XH] texture map tiling (%d byte)\n&quot;,
-					chunk_id, toread);
-				g3d_read_int16_le(f);
-				toread -= 2;
-				break;
+			level_object = subparent-&gt;level_object;
 
-			case 0xA352: /* old map blurring */
-				x3ds_debug(level,
-					&quot;[%4.4XH] texture map blurring (old) (%d byte)\n&quot;,
-					chunk_id, toread);
-				break;
-
-			case 0xA353: /* map blurring */
-				x3ds_debug(level, &quot;[%4.4XH] texture map blurring (%d byte)\n&quot;,
-					chunk_id, toread);
-				g3d_read_float_le(f);
-				toread -= 4;
-				break;
-
-			case 0xAFFF: { /* material entry */
-				G3DMaterial *material = g3d_material_new();
-				x3ds_debug(level, &quot;[%4.4XH] material entry (%d byte)\n&quot;,
-					chunk_id, toread);
-				model-&gt;materials = g_slist_append(model-&gt;materials, material);
-#if DEBUG &gt; 3
-				g_printerr(&quot;DEBUG: material created &amp; appended\n&quot;);
-#endif
-				x3ds_container(f, toread, context, model, material, level + 1,
-					chunk_id);
-				toread = 0; }
-				break;
-			default: /* unknown chunk type */
-				x3ds_debug(level, &quot;[%4.4XH] unknown (%d byte)\n&quot;,
-					chunk_id, toread);
-				fseek(f, toread, SEEK_CUR);
-				toread = 0;
+			g_free(subparent);
 		}
-		if(toread != 0)
+		else
 		{
-			g_printerr(&quot;WARNING: toread != 0 (%d), chunk_id: %4.4X\n&quot;, 
-								 toread, chunk_id);
-			fseek(f, toread, SEEK_CUR);
+			g_printerr(&quot;[3DS] unknown chunk type 0x%04X\n&quot;, chunk_id);
+			fseek(global-&gt;f, chunk_len, SEEK_CUR);
 		}
-		nbytes -= chunk_len;
+
+		parent-&gt;nb -= chunk_len;
+
+		/* update progress bar */
+		x3ds_update_progress(global);
 	}
+
 	return TRUE;
 }
 
-int x3ds_read_cstr(FILE *f, char *string)
+void x3ds_update_progress(x3ds_global_data *global)
 {
+	long int fpos;
+
+	/* update progress bar */
+	fpos = ftell(global-&gt;f);
+	g3d_context_update_progress_bar(global-&gt;context,
+		((gfloat)fpos / (gfloat)global-&gt;max_fpos), TRUE);
+}
+
+gint32 x3ds_read_cstr(FILE *f, char *string)
+{
 	gint32 n = 0;
 	char c;
-	do 
+	do
 	{
 		c = g3d_read_int8(f);
 		string[n] = c;
@@ -474,134 +203,6 @@
 	return n;
 }
 
-int x3ds_read_pointarray(FILE *f, int nb, G3DObject *object, int level)
-{
-	int i, nbytes = nb;
-
-	object-&gt;vertex_count = g3d_read_int16_le(f);
-
-	x3ds_debug(level, &quot;[%4.4XH] point array: %d verts (%d bytes)\n&quot;,
-			0x4110, object-&gt;vertex_count, nbytes);
-
-	object-&gt;vertex_data = g_new0(gfloat, object-&gt;vertex_count * 3);
-	nbytes -= 2;
-	nbytes -= (object-&gt;vertex_count * 3 * 4);
-	for(i=0; i&lt;object-&gt;vertex_count; i++)
-	{
-		object-&gt;vertex_data[i*3+0] = g3d_read_float_le(f) * x3ds_global_scale;
-		object-&gt;vertex_data[i*3+1] = g3d_read_float_le(f) * x3ds_global_scale;
-		object-&gt;vertex_data[i*3+2] = g3d_read_float_le(f) * x3ds_global_scale;
-	}
-	return nbytes;
-}
-
-int x3ds_read_facearray(FILE *f, int nb, G3DObject *object)
-{
-	int nbytes = nb;
-	int i, flags, nfaces = g3d_read_int16_le(f);
-#if 1
-	int p1=-1, p2=-1;
-#endif
-	nbytes -= 2;
-#if DEBUG &gt; 3
-	g_printerr(&quot;faces: %d\n&quot;, nfaces);
-#endif
-	for(i=0; i&lt;nfaces; i++)
-	{
-		G3DFace *face = g_malloc0(sizeof(G3DFace));
-
-		face-&gt;vertex_count = 3;
-		face-&gt;vertex_indices = g_malloc(3 * sizeof(int));
-		face-&gt;vertex_indices[0] = g3d_read_int16_le(f);
-		face-&gt;vertex_indices[1] = g3d_read_int16_le(f);
-		face-&gt;vertex_indices[2] = g3d_read_int16_le(f);
-		flags = g3d_read_int16_le(f); /* flags */
-
-#if 1
-		if((p1 == face-&gt;vertex_indices[0]) &amp;&amp; (p2 == face-&gt;vertex_indices[1]))
-		{
-			int bottle = face-&gt;vertex_indices[0];
-			face-&gt;vertex_indices[0] = face-&gt;vertex_indices[2];
-			face-&gt;vertex_indices[2] = bottle;
-		}
-#endif
-#if DEBUG &gt; 3
-		g_printerr(&quot;x3ds_read_facearray: (%d|%d|%d) flags: 0x%4.4X\n&quot;,
-			face-&gt;vertex_indices[0], face-&gt;vertex_indices[1],
-			face-&gt;vertex_indices[2], flags);
-#endif
-#if 1
-		p1 = face-&gt;vertex_indices[0];
-		p2 = face-&gt;vertex_indices[1];
-#endif
-		nbytes -= 8;
-		face-&gt;material = g_slist_nth_data(object-&gt;materials, 0);
-
-		object-&gt;faces = g_slist_append(object-&gt;faces, face);
-	}
-	return nbytes;
-}
-
-int x3ds_read_meshmatgrp(FILE *f, int nb, G3DModel *model, G3DObject *object,
-	int level)
-{
-	int nbytes = nb;
-	char name[2048];
-	int nfaces, i, j, facenum;
-	G3DMaterial *material = NULL;
-	GSList *mlist;
-
-	nbytes -= x3ds_read_cstr(f, name);
-	x3ds_debug(level, &quot;[%4.4XH] mesh mat group: %s\n&quot;, 0x4130, name);
-
-	mlist = model-&gt;materials;
-	while(mlist != NULL)
-	{
-		G3DMaterial *mat = (G3DMaterial*)mlist-&gt;data;
-		if(strcmp(mat-&gt;name, name) == 0)
-		{
-			material = mat;
-			break;
-		}
-		mlist = mlist-&gt;next;
-	}
-
-	nfaces = g3d_read_int16_le(f);
-	nbytes -= 2;
-	for(i=0; i&lt;nfaces; i++)
-	{
-		facenum = g3d_read_int16_le(f);
-		nbytes -= 2;
-		if(material != NULL)
-		{
-			G3DFace *face = (G3DFace*)g_slist_nth_data(object-&gt;faces, facenum);
-			if(face != NULL) face-&gt;material = material;
-
-			if(face-&gt;material-&gt;tex_image &amp;&amp; object-&gt;tex_vertex_data)
-			{
-#if DEBUG &gt; 5
-				g_print(&quot;3ds: textured face\n&quot;);
-#endif
-				face-&gt;flags |= G3D_FLAG_FAC_TEXMAP;
-				face-&gt;tex_image = face-&gt;material-&gt;tex_image;
-				face-&gt;tex_vertex_count = 3;
-				face-&gt;tex_vertex_data = g_new0(gfloat, 6);
-				for(j = 0; j &lt; 3; j ++)
-				{
-					face-&gt;tex_vertex_data[j * 2 + 0] =
-						object-&gt;tex_vertex_data[
-							face-&gt;vertex_indices[j] * 2 + 0];
-					face-&gt;tex_vertex_data[j * 2 + 1] =
-						object-&gt;tex_vertex_data[
-							face-&gt;vertex_indices[j] * 2 + 1];
-				}
-			} /* textured face */
-
-		}
-	}
-	return nbytes;
-}
-
 void x3ds_debug(int level, char *format, ...)
 {
 #if DEBUG &gt; 0

Added: trunk/libs3d/libg3d/plugins/import/imp_3ds.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,36 @@
+#ifndef _IMP_3DS_H
+#define _IMP_3DS_H
+
+#include &lt;stdio.h&gt;
+#include &lt;glib.h&gt;
+#include &lt;g3d/g3d.h&gt;
+
+typedef struct {
+    G3DContext *context;
+    G3DModel *model;
+    FILE *f;
+    gfloat scale;
+	gint32 max_tex_id;
+	long int max_fpos;
+} x3ds_global_data;
+
+typedef struct {
+    gint32 id;
+    gpointer object;
+	gpointer misc_object;
+    gint32 level;
+	gpointer level_object;
+    guint32 nb;
+} x3ds_parent_data;
+
+typedef gboolean (* x3ds_callback)(x3ds_global_data *global,
+    x3ds_parent_data *parent);
+
+
+gboolean x3ds_read_ctnr(x3ds_global_data *global, x3ds_parent_data *parent);
+void x3ds_update_progress(x3ds_global_data *global);
+gint32 x3ds_read_cstr(FILE *f, char *string);
+G3DObject *x3ds_newobject(G3DModel *model, const char *name);
+void x3ds_debug(int level, char *format, ...);
+
+#endif /* _IMP_3DS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,838 @@
+#include &lt;string.h&gt;
+
+#include &lt;g3d/read.h&gt;
+#include &lt;g3d/texture.h&gt;
+#include &lt;g3d/vector.h&gt;
+#include &lt;g3d/matrix.h&gt;
+
+#include &quot;imp_3ds_callbacks.h&quot;
+
+#define X3DS_FLAG_TENSION       0x01
+#define X3DS_FLAG_CONTINUITY    0x02
+#define X3DS_FLAG_BIAS          0x04
+#define X3DS_FLAG_EASE_TO       0x08
+#define X3DS_FLAG_EASE_FROM     0x10
+
+gboolean x3ds_cb_0x0002(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	gint32 version;
+
+	version = g3d_read_int32_le(global-&gt;f);
+	parent-&gt;nb -= 4;
+#if DEBUG &gt; 0
+	g_printerr(&quot;[3DS] M3D version %d\n&quot;, version);
+#endif
+	return TRUE;
+}
+
+/* color float */
+gboolean x3ds_cb_0x0010(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	gfloat r, g, b;
+
+	r = g3d_read_float_le(global-&gt;f);
+	g = g3d_read_float_le(global-&gt;f);
+	b = g3d_read_float_le(global-&gt;f);
+	parent-&gt;nb -= 12;
+
+	switch(parent-&gt;id)
+	{
+		case 0x1200: /* SOLID_BGND */
+			g3d_context_set_bgcolor(global-&gt;context, r, g, b, 1.0);
+			break;
+
+		case 0xA010: /* ambient color */
+		case 0xA020: /* diffuse color */
+			material = (G3DMaterial *)parent-&gt;object;
+			g_return_val_if_fail(material, FALSE);
+
+			material-&gt;r = r;
+			material-&gt;g = g;
+			material-&gt;b = b;
+			break;
+
+		case 0xA030: /* specular color */
+			material = (G3DMaterial *)parent-&gt;object;
+			g_return_val_if_fail(material, FALSE);
+
+			material-&gt;specular[0] = r;
+			material-&gt;specular[1] = g;
+			material-&gt;specular[2] = b;
+			material-&gt;specular[3] = 0.25;
+			break;
+
+		default:
+			g_printerr(&quot;[3DS] unhandled COLOR_F in 0x%04X\n&quot;, parent-&gt;id);
+			break;
+	}
+
+	return TRUE;
+}
+
+/* color 24 */
+gboolean x3ds_cb_0x0011(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	gint32 r, g, b;
+
+	material = (G3DMaterial *)parent-&gt;object;
+	g_return_val_if_fail(material, FALSE);
+
+	r = g3d_read_int8(global-&gt;f);
+	g = g3d_read_int8(global-&gt;f);
+	b = g3d_read_int8(global-&gt;f);
+	parent-&gt;nb -= 3;
+
+	switch(parent-&gt;id)
+	{
+#if 0
+		case 0xA010: /* ambient color */
+#endif
+		case 0xA020: /* diffuse color */
+			material-&gt;r = (gfloat)r / 255.0;
+			material-&gt;g = (gfloat)g / 255.0;
+			material-&gt;b = (gfloat)b / 255.0;
+			break;
+
+		case 0xA030: /* specular color */
+			material-&gt;specular[0] = (gfloat)r / 255.0;
+			material-&gt;specular[1] = (gfloat)g / 255.0;
+			material-&gt;specular[2] = (gfloat)b / 255.0;
+			material-&gt;specular[3] = 0.25;
+			break;
+
+		default:
+			g_printerr(&quot;[3DS] unhandled COLOR_24 in 0x%04X\n&quot;, parent-&gt;id);
+			break;
+	}
+
+	return TRUE;
+}
+
+/* short percentage */
+gboolean x3ds_cb_0x0030(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	gint32 percent;
+
+	material = (G3DMaterial *)parent-&gt;object;
+	g_return_val_if_fail(material, FALSE);
+
+	percent = g3d_read_int16_le(global-&gt;f);
+	parent-&gt;nb -= 2;
+
+	switch(parent-&gt;id)
+	{
+		case 0xA040: /* shininess */
+			material-&gt;shininess = (gfloat)percent / 100.0;
+			break;
+
+		case 0xA041: /* shininess (2) */
+			/* TODO: do something here? */
+			break;
+
+		case 0xA050: /* transparency */
+			material-&gt;a = 1.0 - ((gfloat)percent / 100.0);
+			break;
+
+		case 0xA052: /* fallthrough */
+			/* TODO: do something here? */
+			break;
+
+		case 0xA053: /* blur */
+			/* TODO: do something here? */
+			break;
+
+		case 0xA084: /* self illumination */
+			/* TODO: do something here? */
+			break;
+
+		case 0xA200: /* texture map */
+			/* TODO: do something here? */
+			break;
+
+		case 0xA210: /* opacity map */
+			/* TODO: do something here? */
+			g_printerr(&quot;[3DS] opacity percentage: %d%%\n&quot;, percent);
+			break;
+
+		case 0xA220: /* reflection map */
+			/* TODO: do something here? */
+			break;
+
+		case 0xA230: /* bump map */
+			/* TODO: do something here? */
+			break;
+
+		default:
+			g_printerr(&quot;[3DS] unhandled INT_PERCENTAGE in 0x%04X\n&quot;,
+				parent-&gt;id);
+			break;
+	}
+
+	return TRUE;
+}
+
+/* float percentage */
+gboolean x3ds_cb_0x0031(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	gfloat percent;
+
+	material = (G3DMaterial *)parent-&gt;object;
+	g_return_val_if_fail(material, FALSE);
+
+	percent = g3d_read_float_le(global-&gt;f);
+	parent-&gt;nb -= 4;
+
+	switch(parent-&gt;id)
+	{
+		case 0xA040: /* shininess */
+			material-&gt;shininess = percent;
+			break;
+
+		case 0xA050: /* transparency */
+			material-&gt;a = 1.0 - percent;
+			break;
+
+		default:
+			g_printerr(&quot;[3DS] unhandled FLOAT_PERCENTAGE in 0x%04X\n&quot;,
+				parent-&gt;id);
+			break;
+	}
+
+	return TRUE;
+}
+
+/* master scale */
+gboolean x3ds_cb_0x0100(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	global-&gt;scale = g3d_read_float_le(global-&gt;f);
+	parent-&gt;nb -= 4;
+
+	return TRUE;
+}
+
+/* named object */
+gboolean x3ds_cb_0x4000(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	gchar buffer[1024];
+
+	parent-&gt;nb -= x3ds_read_cstr(global-&gt;f, buffer);
+	parent-&gt;object = x3ds_newobject(global-&gt;model, buffer);
+
+	return TRUE;
+}
+
+/* point array */
+gboolean x3ds_cb_0x4110(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DObject *object;
+	gint32 i;
+
+	object = (G3DObject *)parent-&gt;object;
+	g_return_val_if_fail(object, FALSE);
+
+	object-&gt;vertex_count = g3d_read_int16_le(global-&gt;f);
+	parent-&gt;nb -= 2;
+
+	object-&gt;vertex_data = g_new0(gfloat, object-&gt;vertex_count * 3);
+	for(i = 0; i &lt; object-&gt;vertex_count; i ++)
+	{
+		object-&gt;vertex_data[i * 3 + 0] = g3d_read_float_le(global-&gt;f);
+		object-&gt;vertex_data[i * 3 + 1] = g3d_read_float_le(global-&gt;f);
+		object-&gt;vertex_data[i * 3 + 2] = g3d_read_float_le(global-&gt;f);
+		parent-&gt;nb -= 12;
+
+		if((i % 1000) == 0) x3ds_update_progress(global);
+	}
+	return TRUE;
+}
+
+/* face array */
+gboolean x3ds_cb_0x4120(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	gint32 i, flags, nfaces;
+#define X3DS_REORDER_FACES
+#ifdef X3DS_REORDER_FACES
+	gint32 p1 = -1, p2 = -1, bottle;
+#endif
+	G3DFace *face;
+	G3DObject *object;
+
+	object = (G3DObject *)parent-&gt;object;
+	g_return_val_if_fail(object, FALSE);
+
+	nfaces = g3d_read_int16_le(global-&gt;f);
+	parent-&gt;nb -= 2;
+
+	for(i = 0; i &lt; nfaces; i ++)
+	{
+		face = g_new0(G3DFace, 1);
+
+		face-&gt;vertex_count = 3;
+		face-&gt;vertex_indices = g_malloc(3 * sizeof(guint32));
+
+		face-&gt;vertex_indices[0] = g3d_read_int16_le(global-&gt;f);
+		face-&gt;vertex_indices[1] = g3d_read_int16_le(global-&gt;f);
+		face-&gt;vertex_indices[2] = g3d_read_int16_le(global-&gt;f);
+		flags = g3d_read_int16_le(global-&gt;f);
+		parent-&gt;nb -= 8;
+
+#ifdef X3DS_REORDER_FACES
+		/* try to put all faces in the same direction */
+		if((p1 == face-&gt;vertex_indices[0]) &amp;&amp; (p2 == face-&gt;vertex_indices[1]))
+		{
+			bottle = face-&gt;vertex_indices[0];
+			face-&gt;vertex_indices[0] = face-&gt;vertex_indices[2];
+			face-&gt;vertex_indices[2] = bottle;
+		}
+
+		p1 = face-&gt;vertex_indices[0];
+		p2 = face-&gt;vertex_indices[1];
+#endif
+
+		face-&gt;material = g_slist_nth_data(object-&gt;materials, 0);
+
+		object-&gt;faces = g_slist_append(object-&gt;faces, face);
+
+		if((i % 1000) == 0) x3ds_update_progress(global);
+	}
+
+	return TRUE;
+}
+
+/* mesh mat group */
+gboolean x3ds_cb_0x4130(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DObject *object;
+	gint32 i, j, facenum, nfaces;
+	gchar buffer[512];
+	G3DMaterial *material = NULL, *mat;
+	G3DFace *face;
+	GSList *mlist;
+
+	object = (G3DObject *)parent-&gt;object;
+	g_return_val_if_fail(object, FALSE);
+
+	/* name of material */
+	parent-&gt;nb -= x3ds_read_cstr(global-&gt;f, buffer);
+
+	/* find material in list */
+	mlist = global-&gt;model-&gt;materials;
+	while(mlist != NULL)
+	{
+		mat = (G3DMaterial*)mlist-&gt;data;
+		if(strcmp(mat-&gt;name, buffer) == 0)
+		{
+			material = mat;
+			break;
+		}
+		mlist = mlist-&gt;next;
+	}
+
+	nfaces = g3d_read_int16_le(global-&gt;f);
+	parent-&gt;nb -= 2;
+
+	for(i = 0; i &lt; nfaces; i ++)
+	{
+		facenum = g3d_read_int16_le(global-&gt;f);
+		parent-&gt;nb -= 2;
+
+		if(material != NULL)
+		{
+			face = (G3DFace*)g_slist_nth_data(object-&gt;faces, facenum);
+			if(face == NULL) continue;
+
+			face-&gt;material = material;
+
+			if(face-&gt;material-&gt;tex_image &amp;&amp; object-&gt;tex_vertex_data)
+			{
+				face-&gt;flags |= G3D_FLAG_FAC_TEXMAP;
+				face-&gt;tex_image = face-&gt;material-&gt;tex_image;
+				face-&gt;tex_vertex_count = 3;
+				face-&gt;tex_vertex_data = g_new0(gfloat, 6);
+				for(j = 0; j &lt; 3; j ++)
+				{
+					face-&gt;tex_vertex_data[j * 2 + 0] = object-&gt;tex_vertex_data[
+						face-&gt;vertex_indices[j] * 2 + 0];
+					face-&gt;tex_vertex_data[j * 2 + 1] = object-&gt;tex_vertex_data[
+						face-&gt;vertex_indices[j] * 2 + 1];
+				}
+			} /* textured face */
+		} /* material != NULL */
+
+		if((i % 1000) == 0) x3ds_update_progress(global);
+	} /* 0..nfaces */
+
+	return TRUE;
+}
+
+/* texture vertices */
+gboolean x3ds_cb_0x4140(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DObject *object;
+	gint32 i;
+
+	object = (G3DObject *)parent-&gt;object;
+	g_return_val_if_fail(object, FALSE);
+
+	object-&gt;tex_vertex_count = g3d_read_int16_le(global-&gt;f);
+	parent-&gt;nb -= 2;
+
+	object-&gt;tex_vertex_data = g_new0(gfloat, object-&gt;tex_vertex_count * 2);
+
+	for(i = 0; i &lt; object-&gt;tex_vertex_count; i ++)
+	{
+		object-&gt;tex_vertex_data[i * 2 + 0] = g3d_read_float_le(global-&gt;f);
+		object-&gt;tex_vertex_data[i * 2 + 1] = g3d_read_float_le(global-&gt;f);
+		parent-&gt;nb -= 8;
+
+		if((i % 1000) == 0) x3ds_update_progress(global);
+	}
+
+	return TRUE;
+}
+
+/* texture vertices */
+gboolean x3ds_cb_0x4150(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+// 	G3DObject *object;
+// 	gint32 i;
+//
+// 	object = (G3DObject *)parent-&gt;object;
+// 	g_return_val_if_fail(object, FALSE);
+//
+// 	object-&gt;tex_vertex_count = g3d_read_int16_le(global-&gt;f);
+// 	parent-&gt;nb -= 2;
+//
+// 	object-&gt;tex_vertex_data = g_new0(gfloat, object-&gt;tex_vertex_count * 2);
+//
+// 	for(i = 0; i &lt; object-&gt;tex_vertex_count; i ++)
+// 	{
+// 		object-&gt;tex_vertex_data[i * 2 + 0] = g3d_read_float_le(global-&gt;f);
+// 		object-&gt;tex_vertex_data[i * 2 + 1] = g3d_read_float_le(global-&gt;f);
+// 		parent-&gt;nb -= 8;
+//
+// 		if((i % 1000) == 0) x3ds_update_progress(global);
+// 	}
+
+	return TRUE;
+}
+
+/* mesh matrix */
+gboolean x3ds_cb_0x4160(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	gfloat matrix[16];
+	gint32 i;
+
+	g3d_matrix_identity(matrix);
+	for(i = 0; i &lt; 12; i ++)
+		matrix[i] = g3d_read_float_le(global-&gt;f);
+
+#if 0
+	for(w = 0; w &lt; 4; w ++)
+	{
+		for(h = 0; h &lt; 3; h ++)
+		{
+			matrix[w * 4 + h] = g3d_read_float_le(global-&gt;f);
+		}
+	}
+#endif
+
+	parent-&gt;nb -= 48;
+
+/* #define X3DS_MESH_TRANSFORM */
+#ifdef X3DS_MESH_TRANSFORM
+	if(parent-&gt;object)
+	{
+		gint32 i;
+		G3DObject *object = (G3DObject *)parent-&gt;object;
+
+		for(i = 0; i &lt; object-&gt;vertex_count; i ++)
+		{
+			g3d_vector_transform(
+				&amp;(object-&gt;vertex_data[i * 3 + 0]),
+				&amp;(object-&gt;vertex_data[i * 3 + 1]),
+				&amp;(object-&gt;vertex_data[i * 3 + 2]),
+				matrix);
+		}
+	}
+#endif
+
+	return TRUE;
+}
+
+/* material name */
+gboolean x3ds_cb_0xA000(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	gchar buffer[1024];
+
+	g_return_val_if_fail(parent-&gt;object, FALSE);
+
+	parent-&gt;nb -= x3ds_read_cstr(global-&gt;f, buffer);
+	material = (G3DMaterial *)(parent-&gt;object);
+
+	material-&gt;name = g_strdup(buffer);
+
+	return TRUE;
+}
+
+/* two sided material */
+gboolean x3ds_cb_0xA081(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+
+	material = (G3DMaterial *)parent-&gt;object;
+	g_return_val_if_fail(material, FALSE);
+
+	material-&gt;flags |= G3D_FLAG_MAT_TWOSIDE;
+
+	return TRUE;
+}
+
+/* texture map name */
+gboolean x3ds_cb_0xA300(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	G3DImage *image;
+	gchar buffer[512];
+
+	material = (G3DMaterial *)parent-&gt;object;
+	g_return_val_if_fail(material, FALSE);
+
+	parent-&gt;nb -= x3ds_read_cstr(global-&gt;f, buffer);
+
+	switch(parent-&gt;id)
+	{
+		case 0xA200: /* texture map */
+			material-&gt;tex_image = g3d_texture_load_cached(global-&gt;context,
+				global-&gt;model, buffer);
+			if(material-&gt;tex_image)
+			{
+				g3d_texture_flip_y(material-&gt;tex_image);
+				material-&gt;tex_image-&gt;tex_id = ++ global-&gt;max_tex_id;
+			}
+			break;
+
+		case 0xA210: /* opacity map */
+			image = g3d_texture_load(global-&gt;context, buffer);
+			if(image != NULL)
+			{
+				g3d_texture_flip_y(image);
+				material-&gt;tex_image = g3d_texture_merge_alpha(
+					material-&gt;tex_image, image);
+				g3d_texture_free(image);
+			}
+			break;
+
+		case 0xA220: /* reflection map */
+			/* TODO: implement */
+			break;
+
+		case 0xA230: /* bump map */
+			/* TODO: implement */
+			break;
+
+		default:
+			g_printerr(&quot;[3DS] unhandled texture name in 0x%04X\n&quot;, parent-&gt;id);
+			break;
+	}
+
+	return TRUE;
+}
+
+/* texture map scale u */
+gboolean x3ds_cb_0xA354(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	G3DImage *image;
+	gfloat scale;
+
+	material = (G3DMaterial *)parent-&gt;object;
+	g_return_val_if_fail(material, FALSE);
+
+	image = material-&gt;tex_image;
+	g_return_val_if_fail(image, FALSE);
+
+	scale = g3d_read_float_le(global-&gt;f);
+	parent-&gt;nb -= 4;
+
+	image-&gt;tex_scale_u = scale;
+#if DEBUG &gt; 3
+	g_print(&quot;[3DS] scale_u: %f\n&quot;, image-&gt;tex_scale_u);
+#endif
+
+	return TRUE;
+}
+
+/* texture map scale v */
+gboolean x3ds_cb_0xA356(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	G3DImage *image;
+	gfloat scale;
+
+	material = (G3DMaterial *)parent-&gt;object;
+	g_return_val_if_fail(material, FALSE);
+
+	image = material-&gt;tex_image;
+	g_return_val_if_fail(image, FALSE);
+
+	scale = g3d_read_float_le(global-&gt;f);
+	parent-&gt;nb -= 4;
+
+	image-&gt;tex_scale_v = scale;
+#if DEBUG &gt; 3
+	g_print(&quot;[3DS] scale_v: %f\n&quot;, image-&gt;tex_scale_v);
+#endif
+
+	return TRUE;
+}
+
+/* material */
+gboolean x3ds_cb_0xAFFF(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	G3DObject *object;
+
+	material = g3d_material_new();
+
+	if(parent-&gt;object)
+	{
+		object = (G3DObject *)parent-&gt;object;
+		object-&gt;materials = g_slist_append(object-&gt;materials, material);
+	}
+	else
+	{
+		global-&gt;model-&gt;materials = g_slist_append(global-&gt;model-&gt;materials,
+			material);
+	}
+
+	parent-&gt;object = material;
+
+	return TRUE;
+}
+
+/* keyframe data header */
+gboolean x3ds_cb_0xB00A(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	gint32 rev, len;
+	gchar buffer[512];
+
+	rev = g3d_read_int16_le(global-&gt;f);
+	parent-&gt;nb -= 2;
+	parent-&gt;nb -= x3ds_read_cstr(global-&gt;f, buffer);
+	len = g3d_read_int16_le(global-&gt;f);
+	parent-&gt;nb -= 2;
+
+#if DEBUG &gt; 0
+	g_printerr(&quot;[3DS] keyframe data: r%d, %d frames, \&quot;%s\&quot;\n&quot;,
+		rev, len, buffer);
+#endif
+	return TRUE;
+}
+
+/* node header */
+gboolean x3ds_cb_0xB010(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	GSList *olist;
+	G3DObject *object;
+	gchar buffer[512];
+
+	parent-&gt;nb -= x3ds_read_cstr(global-&gt;f, buffer);
+#if DEBUG &gt; 3
+	g_printerr(&quot;[3DS] NODE_HDR: %s\n&quot;, buffer);
+#endif
+
+	/* find object by name */
+	olist = global-&gt;model-&gt;objects;
+	while(olist)
+	{
+		object = (G3DObject *)olist-&gt;data;
+		if(strcmp(object-&gt;name, buffer) == 0)
+		{
+			parent-&gt;level_object = object;
+			break;
+		}
+		olist = olist-&gt;next;
+	}
+
+	g3d_read_int16_le(global-&gt;f); /* flags 1 */
+	g3d_read_int16_le(global-&gt;f); /* flags 2 */
+	g3d_read_int16_le(global-&gt;f); /* ? */
+	parent-&gt;nb -= 6;
+
+	return TRUE;
+}
+
+/* pivot */
+gboolean x3ds_cb_0xB013(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DObject *object;
+#if 0
+	gint32 i;
+#endif
+	gfloat x, y, z;
+
+	object = parent-&gt;level_object;
+	if(object == NULL) return FALSE;
+
+	x = g3d_read_float_le(global-&gt;f);
+	y = g3d_read_float_le(global-&gt;f);
+	z = g3d_read_float_le(global-&gt;f);
+	parent-&gt;nb -= 12;
+
+#if DEBUG &gt; 3
+	g_printerr(&quot;[3DS]: PIVOT: (%.2f,%.2f,%.2f)\n&quot;, x, y, z);
+#endif
+
+	return TRUE;
+}
+
+#define X3DS_ENABLE_POS_TRACK_TAG 0
+
+/* position tracking tag */
+gboolean x3ds_cb_0xB020(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DObject *object;
+	gint32 i, flags, fflags, nkeys, fnum;
+#if X3DS_ENABLE_POS_TRACK_TAG
+	gint32 j;
+#endif
+	gfloat x, y, z;
+
+	object = parent-&gt;level_object;
+	if(object == NULL) return FALSE;
+
+	flags = g3d_read_int16_le(global-&gt;f);
+	fseek(global-&gt;f, 8, SEEK_CUR);
+	nkeys = g3d_read_int32_le(global-&gt;f);
+
+	parent-&gt;nb -= 14;
+
+	for(i = 0; i &lt; nkeys; i ++)
+	{
+		fnum = g3d_read_int32_le(global-&gt;f);
+		fflags = g3d_read_int16_le(global-&gt;f);
+		parent-&gt;nb -= 6;
+
+		if(fflags &amp; X3DS_FLAG_TENSION)
+		{
+			g3d_read_float_le(global-&gt;f);
+			parent-&gt;nb -= 4;
+		}
+		if(fflags &amp; X3DS_FLAG_CONTINUITY)
+		{
+			g3d_read_float_le(global-&gt;f);
+			parent-&gt;nb -= 4;
+		}
+		if(fflags &amp; X3DS_FLAG_BIAS)
+		{
+			g3d_read_float_le(global-&gt;f);
+			parent-&gt;nb -= 4;
+		}
+		if(fflags &amp; X3DS_FLAG_EASE_TO)
+		{
+			g3d_read_float_le(global-&gt;f);
+			parent-&gt;nb -= 4;
+		}
+		if(fflags &amp; X3DS_FLAG_EASE_FROM)
+		{
+			g3d_read_float_le(global-&gt;f);
+			parent-&gt;nb -= 4;
+		}
+
+		x = g3d_read_float_le(global-&gt;f);
+		y = g3d_read_float_le(global-&gt;f);
+		z = g3d_read_float_le(global-&gt;f);
+		parent-&gt;nb -= 12;
+#if DEBUG &gt; 2
+		g_printerr(&quot;[3DS]: POS_TRACK_TAG: frame %d: (%.2f,%.2f,%.2f) (0x%X)\n&quot;,
+			fnum, x, y, z, fflags);
+#endif
+
+#if X3DS_ENABLE_POS_TRACK_TAG
+		if(fnum == 0)
+		{
+			for(j = 0; j &lt; object-&gt;vertex_count; j ++)
+			{
+				object-&gt;vertex_data[j * 3 + 0] -= x;
+				object-&gt;vertex_data[j * 3 + 1] -= y;
+				object-&gt;vertex_data[j * 3 + 2] -= z;
+			}
+		}
+#endif
+	}
+
+	return TRUE;
+}
+
+/* rotation tracking tag */
+gboolean x3ds_cb_0xB021(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DObject *object;
+	gint32 i, j, flags, nkeys, fnum;
+	gfloat x, y, z, rot;
+	gfloat matrix[16];
+
+	object = parent-&gt;level_object;
+	if(object == NULL) return FALSE;
+
+	flags = g3d_read_int16_le(global-&gt;f);
+	fseek(global-&gt;f, 8, SEEK_CUR);
+	nkeys = g3d_read_int16_le(global-&gt;f);
+	g3d_read_int16_le(global-&gt;f);
+	parent-&gt;nb -= 14;
+
+	for(i = 0; i &lt; nkeys; i ++)
+	{
+		fnum = g3d_read_int16_le(global-&gt;f);
+		g3d_read_int32_le(global-&gt;f);
+		parent-&gt;nb -= 6;
+
+		rot = g3d_read_float_le(global-&gt;f);
+		x = g3d_read_float_le(global-&gt;f);
+		y = g3d_read_float_le(global-&gt;f);
+		z = g3d_read_float_le(global-&gt;f);
+		parent-&gt;nb -= 16;
+#if DEBUG &gt; 3
+		g_printerr(
+			&quot;[3DS]: ROT_TRACK_TAG: frame %d: (%.2f,%.2f,%.2f), %.2f rad\n&quot;,
+			fnum, x, y, z, rot);
+#endif
+		if(fnum == -1)
+		{
+			g3d_matrix_identity(matrix);
+			g3d_matrix_rotate(rot, x, y, z, matrix);
+
+			for(j = 0; j &lt; object-&gt;vertex_count; j ++)
+			{
+				g3d_vector_transform(
+					&amp;(object-&gt;vertex_data[j * 3 + 0]),
+					&amp;(object-&gt;vertex_data[j * 3 + 1]),
+					&amp;(object-&gt;vertex_data[j * 3 + 2]),
+					matrix);
+			}
+		}
+	}
+
+	return TRUE;
+
+}
+
+/* node id */
+gboolean x3ds_cb_0xB030(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	gint32 id;
+
+	id = g3d_read_int16_le(global-&gt;f);
+	parent-&gt;nb -= 2;
+#if DEBUG &gt; 3
+	g_printerr(&quot;[3DS] NODE_ID: %d\n&quot;, id);
+#endif
+
+	return TRUE;
+}

Added: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,35 @@
+#ifndef _IMP_3DS_CALLBACKS_H
+#define _IMP_3DS_CALLBACKS_H
+
+#include &quot;imp_3ds.h&quot;
+
+gboolean x3ds_cb_0x0002(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x0010(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x0011(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x0030(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x0031(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x0100(x3ds_global_data *global, x3ds_parent_data *parent);
+
+gboolean x3ds_cb_0x4000(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x4110(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x4120(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x4130(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x4140(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x4150(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x4160(x3ds_global_data *global, x3ds_parent_data *parent);
+
+gboolean x3ds_cb_0xA000(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xA081(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xA300(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xA354(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xA356(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xAFFF(x3ds_global_data *global, x3ds_parent_data *parent);
+
+gboolean x3ds_cb_0xB00A(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xB010(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xB013(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xB020(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xB021(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xB030(x3ds_global_data *global, x3ds_parent_data *parent);
+
+#endif /* _IMP_3DS_CALLBACKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_3ds_chunks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_chunks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_chunks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,135 @@
+#ifndef _IMP_3DS_CHUNKS_H
+#define _IMP_3DS_CHUNKS_H
+
+#include &lt;glib.h&gt;
+
+#include &quot;imp_3ds_callbacks.h&quot;
+
+typedef struct {
+	guint32 id;
+	char *desc;
+	gboolean container;
+	x3ds_callback callback;
+} x3ds_chunk_desc;
+
+static x3ds_chunk_desc x3ds_chunks[] = {
+	{ 0x0002, &quot;M3D version&quot;,                0, x3ds_cb_0x0002 },
+	{ 0x0001, &quot;(unknown)&quot;,                  0, NULL },
+	{ 0x0010, &quot;color (float)&quot;,              0, x3ds_cb_0x0010 },
+	{ 0x0011, &quot;color (24 bit)&quot;,             0, x3ds_cb_0x0011 },
+	{ 0x0012, &quot;line color (24 bit)&quot;,        0, NULL },
+	{ 0x0013, &quot;line color (float)&quot;,         0, NULL },
+	{ 0x0030, &quot;percentage (short)&quot;,         0, x3ds_cb_0x0030 },
+	{ 0x0031, &quot;percentage (float)&quot;,         0, x3ds_cb_0x0031 },
+	{ 0x0100, &quot;global scale&quot;,               0, NULL },
+
+	{ 0x1100, &quot;BIT_MAP&quot;,                    0, NULL },
+	{ 0x1200, &quot;SOLID_BGND&quot;,                 1, NULL },
+	{ 0x1201, &quot;USE_SOLID_BGND&quot;,             0, NULL },
+	{ 0x1300, &quot;V_GRADIENT&quot;,                 0, NULL },
+	{ 0x1301, &quot;USE_V_GRADIENT&quot;,             0, NULL },
+	{ 0x1400, &quot;LO_SHADOW_BIAS&quot;,             0, NULL },
+	{ 0x1410, &quot;HI_SHADOW_BIAS&quot;,             0, NULL },
+	{ 0x1420, &quot;SHADOW_MAP_SIZE&quot;,            0, NULL },
+	{ 0x1430, &quot;SHADOW_SAMPLES&quot;,             0, NULL },
+	{ 0x1440, &quot;SHADOW_RANGE&quot;,               0, NULL },
+	{ 0x1450, &quot;SHADOW_FILTER&quot;,              0, NULL },
+	{ 0x1460, &quot;RAY_BIAS&quot;,                   0, NULL },
+	{ 0x1500, &quot;O_CONSTS&quot;,                   0, NULL },
+
+	{ 0x2100, &quot;AMBIENT_LIGHT&quot;,              0, NULL },
+	{ 0x2200, &quot;FOG&quot;,                        0, NULL },
+	{ 0x2300, &quot;DISTANCE_CUE&quot;,               0, NULL },
+	{ 0x2301, &quot;USE_DISTANCE_CUE&quot;,           0, NULL },
+	{ 0x2302, &quot;LAYER_FOG&quot;,                  0, NULL },
+
+	{ 0x3000, &quot;default view&quot;,               0, NULL },
+	{ 0x3D3D, &quot;mesh&quot;,                       1, NULL },
+	{ 0x3D3E, &quot;mesh version&quot;,               0, NULL },
+
+	{ 0x4000, &quot;named object&quot;,               1, x3ds_cb_0x4000 },
+	{ 0x4100, &quot;triangle object&quot;,            1, NULL },
+	{ 0x4110, &quot;point array&quot;,                0, x3ds_cb_0x4110 },
+	{ 0x4111, &quot;point flag array&quot;,           0, NULL },
+	{ 0x4120, &quot;face array&quot;,                 1, x3ds_cb_0x4120 },
+	{ 0x4130, &quot;mesh mat group&quot;,             0, x3ds_cb_0x4130 },
+	{ 0x4140, &quot;texture vertices&quot;,           0, x3ds_cb_0x4140 },
+	{ 0x4150, &quot;smooth group&quot;,               0, x3ds_cb_0x4150 },
+	{ 0x4160, &quot;mesh matrix&quot;,                0, x3ds_cb_0x4160 },
+	{ 0x4165, &quot;mesh color&quot;,                 0, NULL },
+	{ 0x4170, &quot;texture info&quot;,               0, NULL },
+	{ 0x4600, &quot;N_DIRECT_LIGHT&quot;,             0, NULL },
+	{ 0x4700, &quot;N_CAMERA&quot;,                   0, NULL },
+
+	{ 0x7001, &quot;VIEWPORT_LAYOUT&quot;,            0, NULL },
+
+	{ 0xA000, &quot;material name&quot;,              0, x3ds_cb_0xA000 },
+	{ 0xA010, &quot;ambient color&quot;,              1, NULL },
+	{ 0xA020, &quot;diffuse color&quot;,              1, NULL },
+	{ 0xA030, &quot;specular color&quot;,             1, NULL },
+	{ 0xA040, &quot;shininess&quot;,                  1, NULL },
+	{ 0xA041, &quot;shininess (2)&quot;,              1, NULL },
+	{ 0xA042, &quot;shininess (3)&quot;,              1, NULL },
+	{ 0xA050, &quot;transparency&quot;,               1, NULL },
+	{ 0xA052, &quot;fallthrough&quot;,                1, NULL },
+	{ 0xA053, &quot;blur&quot;,                       1, NULL },
+	{ 0xA081, &quot;two-sided&quot;,                  0, x3ds_cb_0xA081 },
+	{ 0xA084, &quot;self illumination&quot;,          1, NULL },
+	{ 0xA085, &quot;wire&quot;,                       0, NULL },
+	{ 0xA086, &quot;super-sampling&quot;,             0, NULL },
+	{ 0xA087, &quot;wire size&quot;,                  0, NULL },
+	{ 0xA08A, &quot;MAT_XPFALLIN&quot;,               0, NULL },
+	{ 0xA08C, &quot;MAT_PHONGSOFT&quot;,              0, NULL },
+	{ 0xA08E, &quot;MAT_WIREABS&quot;,                0, NULL },
+	{ 0xA100, &quot;shading&quot;,                    0, NULL },
+	{ 0xA200, &quot;texture map&quot;,                1, NULL },
+	{ 0xA210, &quot;opacity map&quot;,                1, NULL },
+	{ 0xA220, &quot;reflection map&quot;,             1, NULL },
+	{ 0xA230, &quot;bump map&quot;,                   1, NULL },
+	{ 0xA250, &quot;MAT_USE_REFBLUR&quot;,            0, NULL },
+	{ 0xA252, &quot;bump percentage&quot;,            0, NULL },
+	{ 0xA300, &quot;texture map name&quot;,           0, x3ds_cb_0xA300 },
+	{ 0xA351, &quot;texture map tiling&quot;,         0, NULL },
+	{ 0xA352, &quot;texture map blurring (old)&quot;, 0, NULL },
+	{ 0xA353, &quot;texture map blurring&quot;,       0, NULL },
+	{ 0xA354, &quot;texture map scale u&quot;,        0, x3ds_cb_0xA354 },
+	{ 0xA356, &quot;texture map scale v&quot;,        0, x3ds_cb_0xA356 },
+	{ 0xA358, &quot;texture map offset u&quot;,       0, NULL },
+	{ 0xA35A, &quot;texture map offset v&quot;,       0, NULL },
+	{ 0xAFFF, &quot;material&quot;,                   1, x3ds_cb_0xAFFF },
+
+	{ 0xB000, &quot;keyframe data&quot;,              1, NULL },
+	{ 0xB001, &quot;ambient data node&quot;,          1, NULL },
+	{ 0xB002, &quot;object node&quot;,                1, NULL },
+	{ 0xB003, &quot;camera node&quot;,                1, NULL },
+	{ 0xB004, &quot;target node&quot;,                1, NULL },
+	{ 0xB005, &quot;light node&quot;,                 1, NULL },
+	{ 0xB006, &quot;L_TARGET_NODE_TAG&quot;,          1, NULL },
+	{ 0xB007, &quot;spotlight node&quot;,             1, NULL },
+	{ 0xB008, &quot;KFSEG&quot;,                      0, NULL },
+	{ 0xB009, &quot;KFCURTIME&quot;,                  0, NULL },
+	{ 0xB00A, &quot;keyframe data header&quot;,       0, x3ds_cb_0xB00A },
+	{ 0xB010, &quot;node header&quot;,                0, x3ds_cb_0xB010 },
+	{ 0xB011, &quot;instance name&quot;,              0, NULL },
+	{ 0xB012, &quot;PRESCALE&quot;,                   0, NULL },
+	{ 0xB013, &quot;pivot&quot;,                      0, x3ds_cb_0xB013 },
+	{ 0xB014, &quot;bounding box&quot;,               0, NULL },
+	{ 0xB015, &quot;MORPH_SMOOTH&quot;,               0, NULL },
+	{ 0xB020, &quot;position tracking tag&quot;,      0, x3ds_cb_0xB020 },
+	{ 0xB021, &quot;rotation tracking tag&quot;,      0, x3ds_cb_0xB021 },
+	{ 0xB022, &quot;scale tracking tag&quot;,         0, NULL },
+	{ 0xB023, &quot;FOV_TRACK_TAG&quot;,              0, NULL },
+	{ 0xB024, &quot;ROLL_TRACK_TAG&quot;,             0, NULL },
+	{ 0xB025, &quot;COL_TRACK_TAG&quot;,              0, NULL },
+	{ 0xB026, &quot;MORPH_TRACK_TAG&quot;,            0, NULL },
+	{ 0xB027, &quot;HOT_TRACK_TAG&quot;,              0, NULL },
+	{ 0xB028, &quot;FALL_TRACK_TAG&quot;,             0, NULL },
+	{ 0xB029, &quot;HIDE_TRACK_TAG&quot;,             0, NULL },
+	{ 0xB030, &quot;node identification&quot;,        0, x3ds_cb_0xB030 },
+
+	{ 0xD000, &quot;VPDATA&quot;,                     0, NULL },
+
+	{ 0x0000, NULL, 0, NULL }
+};
+
+#endif

Modified: trunk/libs3d/libg3d/plugins/import/imp_cob.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_cob.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_cob.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -28,6 +28,7 @@
 #include &lt;g3d/context.h&gt;
 #include &lt;g3d/material.h&gt;
 #include &lt;g3d/vector.h&gt;
+#include &lt;g3d/matrix.h&gt;
 #include &lt;g3d/read.h&gt;
 #include &lt;g3d/iff.h&gt;
 
@@ -188,23 +189,15 @@
 	len -= 48;
 
 	/* current position: 3 x 16 */
-	curpos[12] = curpos[13] = curpos[14] = 0.0;
-	curpos[15] = 1.0;
-
+	g3d_matrix_identity(curpos);
 	for(i = 0; i &lt; 12; i ++)
 	{
 		curpos[i] = cob_read_e(f, float, is_be);
 		len -= 4;
 	}
+	g3d_matrix_transpose(curpos);
 
-#if DEBUG &gt; 0
-	for(i = 0; i &lt; 4; i ++)
-	{
-		g_print(&quot;COB: PolH: CurPos: %+1.2f %+1.2f %+1.2f %+1.2f\n&quot;,
-			curpos[i * 4 + 0], curpos[i * 4 + 1],
-			curpos[i * 4 + 2], curpos[i * 4 + 3]);
-	}
-#endif
+	/*g3d_matrix_dump(curpos);*/
 
 	/* vertex list */
 	object-&gt;vertex_count = cob_read_e(f, int32, is_be);

Modified: trunk/libs3d/libg3d/plugins/import/imp_iob.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_iob.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_iob.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -31,12 +31,13 @@
 #include &lt;g3d/read.h&gt;
 #include &lt;g3d/iff.h&gt;
 
-int iob_read_directory(FILE *f, guint32 nbytes, G3DModel *model,
-	void *pobject, guint32 parentid, int level, G3DContext *context);
+#include &quot;imp_iob_chunks.h&quot;
 
 gboolean plugin_load_model(G3DContext *context, const gchar *filename,
 	G3DModel *model, gpointer user_data)
 {
+	g3d_iff_gdata *global;
+	g3d_iff_ldata *local;
 	guint32 id, len;
 	FILE *f;
 
@@ -48,8 +49,21 @@
 		return FALSE;
 	}
 
-	iob_read_directory(f, len, model, NULL, id, 1, context);
+	local = g_new0(g3d_iff_ldata, 1);
+	global = g_new0(g3d_iff_gdata, 1);
 
+	global-&gt;context = context;
+	global-&gt;model = model;
+	global-&gt;f = f;
+
+	local-&gt;parent_id = id;
+	local-&gt;nb = len;
+
+	g3d_iff_read_ctnr(global, local, iob_chunks, G3D_IFF_PAD2);
+
+	g_free(local);
+	g_free(global);
+
 	return TRUE;
 }
 
@@ -69,428 +83,9 @@
 /* IOB specific                                                              */
 /*****************************************************************************/
 
-
-int iob_read_pnts(FILE *f, int nbytes, G3DObject* object, int type);
-int *iob_read_edges(FILE *f, int nbytes, G3DObject* object, int type);
-int iob_read_mat_lists(FILE *f, int nbytes, G3DObject* object, int type);
-int iob_read_faces(FILE *f, int nbytes, G3DObject* object, int *edges,
-	int type);
-gfloat iob_read_fract(FILE *f);
-
-int iob_read_directory(FILE *f, guint32 nbytes, G3DModel *model,
-	void *pobject, guint32 parentid, int level, G3DContext *context)
-{
-	guint32 id, len;
-	gint32 toread = nbytes;
-#if DEBUG &gt; 0
-	int i;
-#endif
-	int *iob_edges = NULL;
-	guint32 typeShape, typeLamp;
-	gdouble offx, offy, offz;
-	G3DObject *iob_object = NULL;
-	G3DMaterial *material;
-
-	while(toread &gt; 0)
-	{
-		toread -= g3d_iff_readchunk(f, &amp;id, &amp;len);
-#if DEBUG &gt; 0
-		for(i=0; i&lt;level; i++) g_printerr(&quot;  &quot;);
-		g_printerr(&quot;[%c%c%c%c] %d bytes\n&quot;,
-			(id &gt;&gt; 24) &amp; 0xFF, (id &gt;&gt; 16) &amp; 0xFF,
-			(id &gt;&gt; 8) &amp; 0xFF, id &amp; 0xFF, len);
-#endif
-		switch(id)
-		{
-			case G3D_IFF_MKID('A','X','I','S'):
-				/* direction vectors for coordinate system */
-				/* x */
-				iob_read_fract(f);
-				iob_read_fract(f);
-				iob_read_fract(f);
-				/* y */
-				iob_read_fract(f);
-				iob_read_fract(f);
-				iob_read_fract(f);
-				/* z */
-				iob_read_fract(f);
-				iob_read_fract(f);
-				iob_read_fract(f);
-				break;
-
-			case G3D_IFF_MKID('O','B','J',' '):
-				iob_read_directory(f, len, model, NULL, id, level+1, context);
-				break;
-
-			case G3D_IFF_MKID('D','E','S','C'):
-				iob_object = g_new0(G3DObject, 1);
-				model-&gt;objects = g_slist_append(model-&gt;objects, iob_object);
-				material = g3d_material_new();
-				material-&gt;flags |= G3D_FLAG_MAT_TWOSIDE;
-				iob_object-&gt;materials = g_slist_append(iob_object-&gt;materials,
-					material);
-				material-&gt;name = g_strdup(&quot;material&quot;);
-				iob_read_directory(f, len, model, iob_object, id, level+1,
-					context);
-				break;
-
-			case G3D_IFF_MKID('N','A','M','E'):
-				((G3DObject*)pobject)-&gt;name = g_malloc0(19);
-				fread(((G3DObject*)pobject)-&gt;name, 1, len, f);
-				break;
-
-			case G3D_IFF_MKID('S','H','P','2'):
-				typeShape = g3d_read_int16_be(f);
-				typeLamp  = g3d_read_int16_be(f);
-#if DEBUG &gt; 3
-				g_printerr(&quot;shapes: shape: 0x%4.4X lamp 0x%4.4X\n&quot;,
-					 typeShape, typeLamp);
-#endif
-				break;
-
-			case G3D_IFF_MKID('P','O','S','I'):
-				offx = (gdouble)g3d_read_int32_be(f) / 0xFFFF;
-				offy = (gdouble)g3d_read_int32_be(f) / 0xFFFF;
-				offz = (gdouble)g3d_read_int32_be(f) / 0xFFFF;
-				break;
-
-			case G3D_IFF_MKID('P','N','T','S'):
-			case G3D_IFF_MKID('P','N','T','2'):
-				iob_read_pnts(f,len,(G3DObject*)pobject, id);
-				break;
-
-			case G3D_IFF_MKID('E','D','G','E'):
-			case G3D_IFF_MKID('E','D','G','2'):
-				iob_edges = iob_read_edges(f, len, (G3DObject*)pobject, id);
-				break;
-
-			case G3D_IFF_MKID('F','A','C','E'):
-			case G3D_IFF_MKID('F','A','C','2'):
-				iob_read_faces(f, len, (G3DObject*)pobject, iob_edges, id);
-				break;
-
-#if 0
-			/* too slow and maybe buggy for now */
-			case G3D_IFF_MKID('C','L','S','T'):
-			case G3D_IFF_MKID('R','L','S','T'):
-			case G3D_IFF_MKID('T','L','S','T'):
-			case G3D_IFF_MKID('C','L','S','2'):
-			case G3D_IFF_MKID('R','L','S','2'):
-			case G3D_IFF_MKID('T','L','S','2'):
-				iob_read_mat_lists(f, len, (G3DObject*)pobject, id);
-				break;
-#endif
-
-			case G3D_IFF_MKID('C','O','L','R'):
-				material = g_slist_nth_data(((G3DObject*)pobject)-&gt;materials,
-					0);
-				g3d_read_int8(f);
-				material-&gt;r = (float)g3d_read_int8(f) / 255.0;
-				material-&gt;g = (float)g3d_read_int8(f) / 255.0;
-				material-&gt;b = (float)g3d_read_int8(f) / 255.0;
-#if DEBUG &gt; 3
-				g_printerr(&quot;rgb: %f,%f,%f\n&quot;, material-&gt;r, material-&gt;g,
-					material-&gt;b);
-#endif
-				break;
-			case G3D_IFF_MKID('R','E','F','L'): {
-				int r,g,b;
-				material = g_slist_nth_data(((G3DObject*)pobject)-&gt;materials,
-					0);
-				g3d_read_int8(f);
-				r = g3d_read_int8(f);
-				g = g3d_read_int8(f);
-				b = g3d_read_int8(f);
-				material-&gt;specular[0] = (float)r / 255.0;
-				material-&gt;specular[1] = (float)g / 255.0;
-				material-&gt;specular[2] = (float)b / 255.0;
-				} break;
-
-			case G3D_IFF_MKID('T','O','B','J'):
-				/* end of child objects */
-				break;
-
-			case G3D_IFF_MKID('T','R','A','N'): {
-				int r,g,b;
-				material = g_slist_nth_data(((G3DObject*)pobject)-&gt;materials,
-					0);
-				g3d_read_int8(f);
-				r = g3d_read_int8(f);
-				g = g3d_read_int8(f);
-				b = g3d_read_int8(f);
-#if DEBUG &gt; 3
-				g_printerr(&quot;rgb: %d,%d,%d\n&quot;, r, g, b);
-#endif
-				material-&gt;a = 1.0 - ((float)r / 255.0);
-				} break;
-
-			default:
-#if DEBUG &gt; 0
-				g_printerr(&quot;*** unhandled ***\n&quot;);
-#endif
-				fseek(f, len+(len%2), SEEK_CUR);
-		}
-
-		g3d_context_update_interface(context);
-	}
-	if(iob_edges != NULL) g_free(iob_edges);
-	return TRUE;
-}
-
 gfloat iob_read_fract(FILE *f)
 {
 	gint32 i = g3d_read_int32_be(f);
 	return (gfloat)(i / 0xFFFF);
 }
 
-int iob_read_pnts(FILE *f, int nbytes, G3DObject* object, int type)
-{
-	int i, toread = nbytes;
-
-	g_return_val_if_fail(object != NULL, FALSE);
-
-	if(type == G3D_IFF_MKID('P','N','T','S'))
-	{
-		object-&gt;vertex_count = g3d_read_int16_be(f);
-		toread -= 2;
-	}
-	else
-	{
-		object-&gt;vertex_count = g3d_read_int32_be(f);
-		toread -= 4;
-	}
-	object-&gt;vertex_data = g_new0(gfloat, object-&gt;vertex_count * 3);
-#if DEBUG &gt; 3
-	g_printerr(&quot;iob_read_pnts: malloc'ed object-&gt;vertices (%d vertices)\n&quot;,
-						 object-&gt;vertex_count);
-#endif
-	for(i=0; i&lt;object-&gt;vertex_count; i++)
-	{
-		object-&gt;vertex_data[i * 3 + 0] = iob_read_fract(f);
-		object-&gt;vertex_data[i * 3 + 1] = iob_read_fract(f);
-		object-&gt;vertex_data[i * 3 + 2] = iob_read_fract(f);
-		toread -= 12;
-#if DEBUG &gt; 3
-	g_printerr(&quot;iob_read_pnts: reading vertex #%d (%le|%le|%le)\n&quot;, i+1,
-		object-&gt;vertex_data[i*3+0], object-&gt;vertex_data[i*3+1],
-		object-&gt;vertex_data[i*3+2]);
-#endif
-	}
-	if(toread != 0)
-	{
-		g_printerr(&quot;error in PNTS chunk (%d bytes to read)\n&quot;, toread);
-		fseek(f, toread, SEEK_CUR);
-		return FALSE;
-	}
-	return TRUE;
-}
-
-int *iob_read_edges(FILE *f, int nbytes, G3DObject* object, int type)
-{
-	int i, nedges;
-	int toread = nbytes;
-	int *edges = NULL;
-
-	if(type == G3D_IFF_MKID('E','D','G','E'))
-	{
-		nedges = g3d_read_int16_be(f);
-		toread -= 2;
-	}
-	else
-	{
-		nedges = g3d_read_int32_be(f);
-		toread -= 4;
-	}
-#if DEBUG &gt; 3
-	g_printerr(&quot;iob_read_edges: %d edges\n&quot;, nedges);
-#endif
-	edges = g_malloc(nedges * 2 * sizeof(int));
-	for(i=0; i&lt;nedges; i++)
-	{
-		if(type == G3D_IFF_MKID('E','D','G','E'))
-		{
-			edges[i*2+0] = g3d_read_int16_be(f);
-			edges[i*2+1] = g3d_read_int16_be(f);
-			toread -= 4;
-		}
-		else
-		{
-			edges[i*2+0] = g3d_read_int32_be(f);
-			edges[i*2+1] = g3d_read_int32_be(f);
-			toread -= 8;
-		}
-	}
-	if(toread != 0)
-	{
-		g_printerr(&quot;error in EDGE chunk (%d bytes to read)\n&quot;, toread);
-		fseek(f, toread, SEEK_CUR);
-	}
-	return edges;
-}
-
-int iob_read_mat_lists(FILE *f, int nbytes, G3DObject* object, int type)
-{
-	guint32 nitems;
-	guint32 i;
-	G3DMaterial *material;
-	G3DFace *face;
-
-	if((type &amp; 0xFF) == '2')
-		nitems = g3d_read_int32_be(f);
-	else
-		nitems = g3d_read_int16_be(f);
-
-#if DEBUG &gt; 0
-	g_print(&quot;IOB: xLST / xLS2: %d items\n&quot;, nitems);
-#endif
-	for(i = 0; i &lt; nitems; i ++)
-	{
-		/* default material + nth */
-		material = g_slist_nth_data(object-&gt;materials, i + 1);
-		if(material == NULL)
-		{
-			material = g3d_material_new();
-			material-&gt;name = g_strdup_printf(&quot;per face material #%d&quot;, i);
-			object-&gt;materials = g_slist_append(object-&gt;materials, material);
-
-			/* assign to face */
-			face = g_slist_nth_data(object-&gt;faces, i);
-			if(face)
-			{
-				face-&gt;material = material;
-			}
-		}
-
-		switch(type)
-		{
-			case G3D_IFF_MKID('C', 'L', 'S', 'T'):
-			case G3D_IFF_MKID('C', 'L', 'S', '2'):
-				material-&gt;r = (gfloat)(g3d_read_int8(f) / 255.0);
-				material-&gt;g = (gfloat)(g3d_read_int8(f) / 255.0);
-				material-&gt;b = (gfloat)(g3d_read_int8(f) / 255.0);
-				break;
-
-			case G3D_IFF_MKID('R', 'L', 'S', 'T'):
-			case G3D_IFF_MKID('R', 'L', 'S', '2'):
-				material-&gt;specular[0] = (gfloat)(g3d_read_int8(f) / 255.0);
-				material-&gt;specular[1] = (gfloat)(g3d_read_int8(f) / 255.0);
-				material-&gt;specular[2] = (gfloat)(g3d_read_int8(f) / 255.0);
-				break;
-
-			case G3D_IFF_MKID('T', 'L', 'S', 'T'):
-			case G3D_IFF_MKID('T', 'L', 'S', '2'):
-				material-&gt;a = 1.0 - (
-					(gfloat)(g3d_read_int8(f) / 255.0) +
-					(gfloat)(g3d_read_int8(f) / 255.0) +
-					(gfloat)(g3d_read_int8(f) / 255.0)) / 3.0;
-				break;
-		}
-	}
-
-	/* padding */
-	if(nitems % 2)
-		g3d_read_int8(f);
-
-	return TRUE;
-}
-
-void iob_order_array(int *array, int numelems)
-{
-	int elem = 0;
-
-	while(elem &lt; numelems)
-	{
-		int i;
-		for(i=elem+1; i&lt;numelems; i++)
-		{
-			if(array[elem] &gt; array[i])
-			{
-				int bottle = array[elem];
-				array[elem] = array[i];
-				array[i] = bottle;
-			}
-		}
-		elem++;
-	}
-}
-
-int iob_read_faces(FILE *f, int nbytes, G3DObject* object, int *edges, 
-									 int type)
-{
-	int i, nfaces;
-	int toread = nbytes;
-	int v1, v2, v3;
-	int e[3];
-
-	if(type == G3D_IFF_MKID('F','A','C','E'))
-	{
-		nfaces = g3d_read_int16_be(f);
-		toread -= 2;
-	}
-	else
-	{
-		nfaces = g3d_read_int32_be(f);
-		toread -= 4;
-	}
-
-	for(i=0; i&lt;nfaces; i++)
-	{
-		G3DFace *face = g_new0(G3DFace, 1);
-		face-&gt;vertex_count = 3;
-		face-&gt;vertex_indices = g_new0(guint32, 3);
-		if(type == G3D_IFF_MKID('F','A','C','E'))
-		{
-			e[0] = g3d_read_int16_be(f);
-			e[1] = g3d_read_int16_be(f);
-			e[2] = g3d_read_int16_be(f);
-			toread -= 6;
-		}
-		else
-		{
-			e[0] = g3d_read_int32_be(f);
-			e[1] = g3d_read_int32_be(f);
-			e[2] = g3d_read_int32_be(f);
-			toread -= 12;
-		}
-#if DEBUG &gt; 3
-		g_printerr(&quot;iob_read_faces: #%d (%d|%d)-(%d|%d)-(%d|%d)\n&quot;, i,
-			edges[e[0]*2], edges[e[0]*2+1],
-			edges[e[1]*2], edges[e[1]*2+1],
-			edges[e[2]*2], edges[e[2]*2+1]);
-#endif
-#if 0 /* all mats twoside */
-		iob_order_array(e, 3);
-#endif
-		face-&gt;vertex_indices[0] = v1 = edges[e[0]*2+0];
-		face-&gt;vertex_indices[1] = v2 = edges[e[0]*2+1];
-
-		if((v1!=edges[e[1]*2+0]) &amp;&amp; (v2!=edges[e[1]*2+0]))
-			v3=edges[e[1]*2+0];
-		else if((v1!=edges[e[1]*2+1]) &amp;&amp; (v2!=edges[e[1]*2+1]))
-			v3=edges[e[1]*2+1];
-		else if((v1!=edges[e[2]*2+0]) &amp;&amp; (v2!=edges[e[2]*2+0]))
-			v3=edges[e[2]*2+0];
-		else
-			v3 = edges[e[2]*2+1];
-
-		face-&gt;vertex_indices[2] = v3;
-
-		face-&gt;material = g_slist_nth_data(object-&gt;materials, 0);
-		object-&gt;faces = g_slist_prepend(object-&gt;faces, face);
-
-#if DEBUG &gt; 3
-		g_printerr(&quot;iob_read_faces: face: #%d (%d/%d/%d)\n&quot;, i+1,
-			face-&gt;vertex_indices[0], face-&gt;vertex_indices[1],
-			face-&gt;vertex_indices[2]);
-#endif
-	}
-	if(toread != 0)
-	{
-		g_printerr(&quot;error in FACE chunk (%d bytes to read)\n&quot;, toread);
-		fseek(f, toread, SEEK_CUR);
-		return FALSE;
-	}
-	return TRUE;
-}
-
-

Added: trunk/libs3d/libg3d/plugins/import/imp_iob.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_iob.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_iob.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,9 @@
+#ifndef _IMP_IOB_H
+#define _IMP_IOB_H
+
+#include &lt;stdio.h&gt;
+#include &lt;glib.h&gt;
+
+gfloat iob_read_fract(FILE *f);
+
+#endif /* _IMP_IOB_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,324 @@
+#include &lt;g3d/iff.h&gt;
+#include &lt;g3d/read.h&gt;
+#include &lt;g3d/material.h&gt;
+
+#include &quot;imp_iob.h&quot;
+
+gboolean iob_cb_xLSx(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	G3DMaterial *material;
+	G3DFace *face;
+	gint32 i, nitems;
+
+	object = (G3DObject *)local-&gt;object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	if((local-&gt;id &amp; 0xFF) == '2')
+	{
+		nitems = g3d_read_int32_be(global-&gt;f);
+		local-&gt;nb -= 4;
+	}
+	else
+	{
+		nitems = g3d_read_int16_be(global-&gt;f);
+		local-&gt;nb -= 2;
+	}
+
+	for(i = 0; i &lt; nitems; i ++)
+	{
+		/* TODO: find material by parameters, don't create too much
+		 * materials */
+
+		/* default material + nth */
+		material = g_slist_nth_data(object-&gt;materials, i + 1);
+		if(material == NULL)
+		{
+			material = g3d_material_new();
+			material-&gt;name = g_strdup_printf(&quot;per face material #%d&quot;, i);
+			object-&gt;materials = g_slist_append(object-&gt;materials, material);
+
+			/* assign to face */
+			face = g_slist_nth_data(object-&gt;faces, i);
+			if(face)
+				face-&gt;material = material;
+		}
+
+		switch(local-&gt;id)
+		{
+			case G3D_IFF_MKID('C', 'L', 'S', 'T'):
+			case G3D_IFF_MKID('C', 'L', 'S', '2'):
+				material-&gt;r = (gfloat)g3d_read_int8(global-&gt;f) / 255.0;
+				material-&gt;g = (gfloat)g3d_read_int8(global-&gt;f) / 255.0;
+				material-&gt;b = (gfloat)g3d_read_int8(global-&gt;f) / 255.0;
+				break;
+
+			case G3D_IFF_MKID('R', 'L', 'S', 'T'):
+			case G3D_IFF_MKID('R', 'L', 'S', '2'):
+				material-&gt;specular[0] =
+					(gfloat)g3d_read_int8(global-&gt;f) / 255.0;
+				material-&gt;specular[1] =
+					(gfloat)g3d_read_int8(global-&gt;f) / 255.0;
+				material-&gt;specular[2] =
+					(gfloat)g3d_read_int8(global-&gt;f) / 255.0;
+				break;
+
+			case G3D_IFF_MKID('T', 'L', 'S', 'T'):
+			case G3D_IFF_MKID('T', 'L', 'S', '2'):
+				material-&gt;a = 1.0 - (
+					(gfloat)g3d_read_int8(global-&gt;f) / 255.0 +
+					(gfloat)g3d_read_int8(global-&gt;f) / 255.0 +
+					(gfloat)g3d_read_int8(global-&gt;f) / 255.0) / 3.0;
+				break;
+		}
+
+		local-&gt;nb -= 3;
+	}
+
+	return TRUE;
+}
+
+gboolean iob_cb_COLR(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	G3DMaterial *material;
+
+	object = (G3DObject *)local-&gt;object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	material = g_slist_nth_data(object-&gt;materials, 0);
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	g3d_read_int8(global-&gt;f);
+	material-&gt;r = (float)g3d_read_int8(global-&gt;f) / 255.0;
+	material-&gt;g = (float)g3d_read_int8(global-&gt;f) / 255.0;
+	material-&gt;b = (float)g3d_read_int8(global-&gt;f) / 255.0;
+	local-&gt;nb -= 4;
+
+	return TRUE;
+}
+
+gboolean iob_cb_DESC(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	G3DMaterial *material;
+
+	if(local-&gt;finalize) return TRUE;
+
+	object = g_new0(G3DObject, 1);
+	global-&gt;model-&gt;objects = g_slist_append(global-&gt;model-&gt;objects, object);
+
+	material = g3d_material_new();
+	material-&gt;flags |= G3D_FLAG_MAT_TWOSIDE;
+	material-&gt;name = g_strdup(&quot;(default material)&quot;);
+
+	object-&gt;materials = g_slist_append(object-&gt;materials, material);
+
+	local-&gt;object = object;
+
+	return TRUE;
+}
+
+gboolean iob_cb_EDGx(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	gint32 i, nedges;
+	gint32 *edges;
+
+	object = (G3DObject *)local-&gt;object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	if(local-&gt;id == G3D_IFF_MKID('E','D','G','E'))
+	{
+		nedges = g3d_read_int16_be(global-&gt;f);
+		local-&gt;nb -= 2;
+	}
+	else
+	{
+		nedges = g3d_read_int32_be(global-&gt;f);
+		local-&gt;nb -= 4;
+	}
+
+	edges = g_malloc(nedges * 2 * sizeof(gint32));
+	for(i = 0; i &lt; nedges; i ++)
+	{
+		if(local-&gt;id == G3D_IFF_MKID('E','D','G','E'))
+		{
+			edges[i * 2 + 0] = g3d_read_int16_be(global-&gt;f);
+			edges[i * 2 + 1] = g3d_read_int16_be(global-&gt;f);
+			local-&gt;nb -= 4;
+		}
+		else
+		{
+			edges[i * 2 + 0] = g3d_read_int32_be(global-&gt;f);
+			edges[i * 2 + 1] = g3d_read_int32_be(global-&gt;f);
+			local-&gt;nb -= 8;
+		}
+	}
+
+	local-&gt;level_object = edges;
+
+	return TRUE;
+}
+
+gboolean iob_cb_FACx(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	gint32 *edges, e[3], v1, v2, v3;
+	gint32 i, nfaces;
+
+	object = (G3DObject *)local-&gt;object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	/* edges are read in EDGE/EDG2 chunk */
+	edges = (gint32 *)local-&gt;level_object;
+	g_return_val_if_fail(edges != NULL, FALSE);
+
+	if(local-&gt;id == G3D_IFF_MKID('F','A','C','E'))
+	{
+		nfaces = g3d_read_int16_be(global-&gt;f);
+		local-&gt;nb -= 2;
+	}
+	else
+	{
+		nfaces = g3d_read_int32_be(global-&gt;f);
+		local-&gt;nb -= 4;
+	}
+
+	for(i = 0; i &lt; nfaces; i ++)
+	{
+		G3DFace *face = g_new0(G3DFace, 1);
+		face-&gt;vertex_count = 3;
+		face-&gt;vertex_indices = g_new0(guint32, 3);
+
+		if(local-&gt;id == G3D_IFF_MKID('F','A','C','E'))
+		{
+			e[0] = g3d_read_int16_be(global-&gt;f);
+			e[1] = g3d_read_int16_be(global-&gt;f);
+			e[2] = g3d_read_int16_be(global-&gt;f);
+			local-&gt;nb -= 6;
+		}
+		else
+		{
+			e[0] = g3d_read_int32_be(global-&gt;f);
+			e[1] = g3d_read_int32_be(global-&gt;f);
+			e[2] = g3d_read_int32_be(global-&gt;f);
+			local-&gt;nb -= 12;
+		}
+
+		face-&gt;vertex_indices[0] = v1 = edges[e[0] * 2 + 0];
+		face-&gt;vertex_indices[1] = v2 = edges[e[0] * 2 + 1];
+		if((v1 != edges[e[1] * 2 + 0]) &amp;&amp; (v2 != edges[e[1] * 2 + 0]))
+			v3 = edges[e[1] * 2 + 0];
+		else if((v1 != edges[e[1] * 2 + 1]) &amp;&amp; (v2 != edges[e[1] * 2 + 1]))
+			v3 = edges[e[1] * 2 + 1];
+		else if((v1 != edges[e[2] * 2 + 0]) &amp;&amp; (v2 != edges[e[2] * 2 + 0]))
+			v3 = edges[e[2] * 2 + 0];
+		else
+			v3 = edges[e[2] * 2 + 1];
+
+		face-&gt;vertex_indices[2] = v3;
+
+		face-&gt;material = g_slist_nth_data(object-&gt;materials, 0);
+		object-&gt;faces = g_slist_append(object-&gt;faces, face);
+	}
+
+	/* free edges now */
+	g_free(edges);
+	local-&gt;level_object = NULL;
+
+	return TRUE;
+}
+
+gboolean iob_cb_NAME(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	gchar buffer[512];
+
+	object = (G3DObject *)local-&gt;object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	fread(buffer, 1, local-&gt;nb, global-&gt;f);
+
+	object-&gt;name = g_convert(buffer, local-&gt;nb,
+		&quot;UTF-8&quot;, &quot;ISO-8859-1&quot;,
+		NULL, NULL, NULL);
+
+	local-&gt;nb = 0;
+
+	return TRUE;
+}
+
+gboolean iob_cb_PNTx(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	gint32 i;
+
+	object = (G3DObject *)local-&gt;object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	if(local-&gt;id == G3D_IFF_MKID('P','N','T','S'))
+	{
+		object-&gt;vertex_count = g3d_read_int16_be(global-&gt;f);
+		local-&gt;nb -= 2;
+	}
+	else
+	{
+		object-&gt;vertex_count = g3d_read_int32_be(global-&gt;f);
+		local-&gt;nb -= 4;
+	}
+
+	object-&gt;vertex_data = g_new0(gfloat, object-&gt;vertex_count * 3);
+
+	for(i = 0; i &lt; object-&gt;vertex_count; i ++)
+	{
+		object-&gt;vertex_data[i * 3 + 0] = iob_read_fract(global-&gt;f);
+		object-&gt;vertex_data[i * 3 + 1] = iob_read_fract(global-&gt;f);
+		object-&gt;vertex_data[i * 3 + 2] = iob_read_fract(global-&gt;f);
+		local-&gt;nb -= 12;
+	}
+
+	return TRUE;
+}
+
+gboolean iob_cb_REFL(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	G3DMaterial *material;
+
+	object = (G3DObject *)local-&gt;object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	material = g_slist_nth_data(object-&gt;materials, 0);
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	g3d_read_int8(global-&gt;f);
+	material-&gt;specular[0] = (float)g3d_read_int8(global-&gt;f) / 255.0;
+	material-&gt;specular[1] = (float)g3d_read_int8(global-&gt;f) / 255.0;
+	material-&gt;specular[2] = (float)g3d_read_int8(global-&gt;f) / 255.0;
+	local-&gt;nb -= 4;
+
+	return TRUE;
+}
+
+gboolean iob_cb_TRAN(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	G3DMaterial *material;
+
+	object = (G3DObject *)local-&gt;object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	material = g_slist_nth_data(object-&gt;materials, 0);
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	g3d_read_int8(global-&gt;f);
+	material-&gt;a = 1.0 - (
+		(gfloat)g3d_read_int8(global-&gt;f) / 255.0 +
+		(gfloat)g3d_read_int8(global-&gt;f) / 255.0 +
+		(gfloat)g3d_read_int8(global-&gt;f) / 255.0) / 3.0;
+	local-&gt;nb -= 4;
+
+	return TRUE;
+}
+

Added: trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,16 @@
+#ifndef _IMP_IOB_CALLBACKS_H
+#define _IMP_IOB_CALLBACKS_H
+
+#include &lt;g3d/iff.h&gt;
+
+gboolean iob_cb_xLSx(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_COLR(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_DESC(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_EDGx(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_FACx(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_NAME(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_PNTx(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_REFL(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_TRAN(g3d_iff_gdata *global, g3d_iff_ldata *local);
+
+#endif /* _IMP_IOB_CALLBACKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_iob_chunks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_iob_chunks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_iob_chunks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,52 @@
+#ifndef _IMP_IOB_CHUNKS_H
+#define _IMP_IOB_CHUNKS_H
+
+#include &lt;g3d/iff.h&gt;
+
+#include &quot;imp_iob_callbacks.h&quot;
+
+static g3d_iff_chunk_info iob_chunks[] = {
+	{ &quot;AXIS&quot;, &quot;coordinate system&quot;,                0, NULL },
+	{ &quot;BBOX&quot;, &quot;bounding box data&quot;,                0, NULL },
+	{ &quot;BRS4&quot;, &quot;brush (4)&quot;,                        0, NULL },
+	{ &quot;BRS5&quot;, &quot;brush (5)&quot;,                        0, NULL },
+	{ &quot;COLR&quot;, &quot;color&quot;,                            0, iob_cb_COLR },
+	{ &quot;CLS2&quot;, &quot;color list (2)&quot;,                   0, iob_cb_xLSx },
+	{ &quot;CLST&quot;, &quot;color list&quot;,                       0, iob_cb_xLSx },
+	{ &quot;DESC&quot;, &quot;object description&quot;,               1, iob_cb_DESC },
+	{ &quot;EDG2&quot;, &quot;edges&quot;,                            0, iob_cb_EDGx },
+	{ &quot;EDGE&quot;, &quot;edges&quot;,                            0, iob_cb_EDGx },
+	{ &quot;EFLG&quot;, &quot;edge flags&quot;,                       0, NULL },
+	{ &quot;FACE&quot;, &quot;faces&quot;,                            0, iob_cb_FACx },
+	{ &quot;FAC2&quot;, &quot;faces (2)&quot;,                        0, iob_cb_FACx },
+	{ &quot;FGR2&quot;, &quot;face group (2)&quot;,                   0, NULL },
+	{ &quot;FGR3&quot;, &quot;face group (3)&quot;,                   0, NULL },
+	{ &quot;FGR4&quot;, &quot;face group (4)&quot;,                   0, NULL },
+	{ &quot;INT1&quot;, &quot;light intensity (1)&quot;,              0, NULL },
+	{ &quot;NAME&quot;, &quot;name&quot;,                             0, iob_cb_NAME },
+	{ &quot;OBJ &quot;, &quot;object&quot;,                           1, NULL },
+	{ &quot;PART&quot;, &quot;particle parameters&quot;,              0, NULL },
+	{ &quot;PNT2&quot;, &quot;points (2)&quot;,                       0, iob_cb_PNTx },
+	{ &quot;PNTS&quot;, &quot;points&quot;,                           0, iob_cb_PNTx },
+	{ &quot;POSI&quot;, &quot;position in world&quot;,                0, NULL },
+	{ &quot;PRP1&quot;, &quot;properties (1)&quot;,                   0, NULL },
+	{ &quot;PRP2&quot;, &quot;properties (2)&quot;,                   0, NULL },
+	{ &quot;REFL&quot;, &quot;reflection&quot;,                       0, iob_cb_REFL },
+	{ &quot;RLS2&quot;, &quot;reflection list (2)&quot;,              0, iob_cb_xLSx },
+	{ &quot;RLST&quot;, &quot;reflection list&quot;,                  0, iob_cb_xLSx },
+	{ &quot;SPC1&quot;, &quot;specularity (1)&quot;,                  0, NULL },
+	{ &quot;SPC2&quot;, &quot;specularity (2)&quot;,                  0, NULL },
+	{ &quot;SHAP&quot;, &quot;shape type&quot;,                       0, NULL },
+	{ &quot;SHP2&quot;, &quot;shape type (2)&quot;,                   0, NULL },
+	{ &quot;SIZE&quot;, &quot;size&quot;,                             0, NULL },
+	{ &quot;TLS2&quot;, &quot;transparency list&quot;,                0, iob_cb_xLSx },
+	{ &quot;TLST&quot;, &quot;transparency list (2)&quot;,            0, iob_cb_xLSx },
+	{ &quot;TOBJ&quot;, &quot;end of object&quot;,                    0, NULL },
+	{ &quot;TRAN&quot;, &quot;transparency&quot;,                     0, iob_cb_TRAN },
+	{ &quot;TXT3&quot;, &quot;texture data (3)&quot;,                 0, NULL },
+	{ &quot;TXT4&quot;, &quot;texture data (4)&quot;,                 0, NULL },
+
+	{ NULL, NULL, 0, NULL }
+};
+
+#endif /* _IMP_IOB_CHUNKS_H */

Modified: trunk/libs3d/libg3d/plugins/import/imp_leocad.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_leocad.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_leocad.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -67,7 +67,9 @@
 	LeoCadLibrary *library;
 
 	library = (LeoCadLibrary *)user_data;
-	leocad_library_free(library);
+
+	if(library)
+		leocad_library_free(library);
 }
 
 gboolean plugin_load_model(G3DContext *context, const gchar *filename,
@@ -157,9 +159,15 @@
 						switch(ktype)
 						{
 							case 0x00: /* translation */
+#if 1
 								mloc[0 * 4 + 3] = param[0];
 								mloc[1 * 4 + 3] = param[1];
 								mloc[2 * 4 + 3] = param[2];
+#else
+								mloc[3 * 4 + 0] = param[0];
+								mloc[3 * 4 + 1] = param[1];
+								mloc[3 * 4 + 2] = param[2];
+#endif
 								g3d_matrix_multiply(matrix, mloc, matrix);
 								valid_matrix = TRUE;
 								break;
@@ -216,8 +224,12 @@
 								if((j % 4) == 0)
 									g_print(&quot;LeoCAD: matrix:&quot;);
 #endif
+#if 0
 								matrix[(j % 4) * 4 + j / 4] =
 									g3d_read_float_le(f);
+#else
+								matrix[j] = g3d_read_float_le(f);
+#endif
 #if DEBUG &gt; 2
 								g_print(&quot; %+.2f&quot;, matrix[j]);
 								if((j % 4) == 3)
@@ -335,10 +347,15 @@
 	if(!valid_matrix)
 	{
 		/* translation */
+#if 0
 		mloc[0 * 4 + 3] = offx;
 		mloc[1 * 4 + 3] = offy;
 		mloc[2 * 4 + 3] = offz;
-
+#else
+		mloc[3 * 4 + 0] = offx;
+		mloc[3 * 4 + 1] = offy;
+		mloc[3 * 4 + 2] = offz;
+#endif
 		/* rotation */
 		rotx = (gfloat)(rotx * M_PI) / 180.0;
 		roty = (gfloat)(roty * M_PI) / 180.0;
@@ -350,6 +367,8 @@
 		g3d_matrix_multiply(mloc, matrix, matrix);
 	}
 
+	/*g3d_matrix_dump(matrix);*/
+
 	/* transform vertices */
 	for(i = 0; i &lt; object-&gt;vertex_count; i ++)
 		g3d_vector_transform(

Modified: trunk/libs3d/libg3d/plugins/import/imp_leocad_library.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_leocad_library.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_leocad_library.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -44,6 +44,7 @@
 #define LEOCAD_FLAG_PIECE_SMALL         0x10
 #define LEOCAD_FLAG_PIECE_MEDIUM        0x20
 #define LEOCAD_FLAG_LONGDATA_RUNTIME    0x40
+#define LEOCAD_FLAG_PIECE_RENAMED       0x80
 
 #define LEOCAD_TYPE_MESH                0x01
 #define LEOCAD_TYPE_STUD                0x02
@@ -99,11 +100,45 @@
 	return library;
 }
 
+static gboolean leocad_free_piece_cb(gpointer key, gpointer value,
+	gpointer user_data)
+{
+	LeoCadPiece *piece;
+
+	piece = (LeoCadPiece *)value;
+
+#if DEBUG &gt; 3
+	g_print(&quot;D: freeing piece %s\n&quot;, piece-&gt;name);
+#endif
+
+	if(piece-&gt;name) g_free(piece-&gt;name);
+	if(piece-&gt;description) g_free(piece-&gt;description);
+	if(piece-&gt;moved_to) g_free(piece-&gt;moved_to);
+
+	if(!(piece-&gt;flags &amp; LEOCAD_FLAG_PIECE_RENAMED))
+		if(piece-&gt;object) g3d_object_free(piece-&gt;object);
+
+	g_free(piece);
+
+	return TRUE;
+}
+
 void leocad_library_free(LeoCadLibrary *library)
 {
+	GSList *mlist;
+	G3DMaterial *material;
+
 	/* remove materials */
+	mlist = library-&gt;materials;
+	while(mlist)
+	{
+		material = (G3DMaterial *)mlist-&gt;data;
+		mlist = g_slist_remove(mlist, material);
+		g3d_material_free(material);
+	}
+
 	/* remove pieces */
-	/* FIXME: remove pieces */
+	g_hash_table_foreach_remove(library-&gt;pieces, leocad_free_piece_cb, NULL);
 	g_hash_table_destroy(library-&gt;pieces);
 
 	/* free library */
@@ -408,8 +443,13 @@
 
 						g3d_matrix_identity(matrix);
 						for(j = 0; j &lt; 12; j ++)
-							matrix[(j % 3) * 4 + (j / 3)] =
+#if 1
+							matrix[(j / 3) * 4 + (j % 3)] =
 								g3d_read_float_le(bin);
+#else
+							matrix[j] = g3d_read_float_le(bin);
+#endif
+							/* g3d_matrix_dump(matrix); */
 
 						if(stud &amp;&amp; piece-&gt;object)
 						{
@@ -542,7 +582,7 @@
 	gchar magic[32], nameold[9], namenew[9];
 	guint8 version, lastupdate;
 	guint32 nmoved, nbinsize, npieces, i;
-	LeoCadPiece *piece;
+	LeoCadPiece *piece, *newpiece;
 
 	fread(magic, 1, 32, idx);
 	if(strncmp(magic, &quot;LeoCAD piece library index file&quot;, 31) != 0)
@@ -583,7 +623,17 @@
 
 		piece = g_hash_table_lookup(library-&gt;pieces, namenew);
 		if(piece)
-			g_hash_table_insert(library-&gt;pieces, g_strdup(nameold), piece);
+		{
+			newpiece = g_new0(LeoCadPiece, 1);
+			memcpy(newpiece, piece, sizeof(LeoCadPiece));
+			newpiece-&gt;name = g_strdup(nameold);
+			newpiece-&gt;description = g_strdup(piece-&gt;description);
+			newpiece-&gt;moved_to = g_strdup(namenew);
+			newpiece-&gt;object = piece-&gt;object;
+			newpiece-&gt;flags |= LEOCAD_FLAG_PIECE_RENAMED;
+
+			g_hash_table_insert(library-&gt;pieces, piece-&gt;name, newpiece);
+		}
 	}
 
 	return TRUE;

Modified: trunk/libs3d/libg3d/plugins/import/imp_lwo.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_lwo.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_lwo.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -39,24 +39,26 @@
 
 #define LW_MAX_POINTS   200
 #define LW_MAX_NAME_LEN 500
+#define LW_F_LWO2 1
 
-#define LW_F_LWO2		(1 &lt;&lt; 0)
+#include &quot;imp_lwo.h&quot;
+#include &quot;imp_lwo_chunks.h&quot;
 
-static gboolean lwo_read_directory(FILE *f, guint32 nbytes, G3DModel *model,
-	gpointer pobject, guint32 parentid, guint32 level, guint32 flags,
-	G3DContext *context);
-
 /*****************************************************************************/
 /* plugin interface                                                          */
 /*****************************************************************************/
 
+static void lwo_fix_texfaces(G3DModel *model);
+
 gboolean plugin_load_model(G3DContext *context, const gchar *filename,
 	G3DModel *model, gpointer user_data)
 {
-	G3DObject *lwo_object = NULL;
+	LwoObject *obj;
 	G3DMaterial *material;
 	FILE *f;
-	guint32 id, len, flags = 0;
+	guint32 id, len;
+	g3d_iff_gdata *global;
+	g3d_iff_ldata *local;
 
 	f = g3d_iff_open(filename, &amp;id, &amp;len);
 	if(f == NULL)
@@ -73,26 +75,51 @@
 		return FALSE;
 	}
 
-	/* LWO2 object file */
+	obj = g_new0(LwoObject, 1);
+
+	global = g_new0(g3d_iff_gdata, 1);
+	global-&gt;f = f;
+	global-&gt;context = context;
+	global-&gt;model = model;
 	if(id == G3D_IFF_MKID('L','W','O','2'))
-		flags |= LW_F_LWO2;
+		global-&gt;flags |= LWO_FLAG_LWO2;
+	global-&gt;user_data = obj;
 
-	g3d_context_update_progress_bar(context, 0.0, TRUE);
+	local = g_new0(g3d_iff_ldata, 1);
+	local-&gt;id = id;
+	local-&gt;nb = len;
 
 	material = g3d_material_new();
 	material-&gt;name = g_strdup(&quot;fallback material&quot;);
 	model-&gt;materials = g_slist_append(model-&gt;materials, material);
 
-	lwo_read_directory(f, len, model, lwo_object, id, 1, flags, context);
+	g3d_iff_read_ctnr(global, local, lwo_chunks,
+		G3D_IFF_PAD2 | G3D_IFF_SUBCHUNK_LEN16);
 
+	lwo_fix_texfaces(model);
+
+	/* cleanup */
+	if(obj-&gt;ntags)
+		g_strfreev(obj-&gt;tags);
+
+	if(obj-&gt;nclips)
+	{
+		g_free(obj-&gt;clips);
+		g_strfreev(obj-&gt;clipfiles);
+	}
+
+	if(obj-&gt;tex_vertices)
+		g_free(obj-&gt;tex_vertices);
+
+	g_free(obj);
+
+	g_free(local);
+	g_free(global);
+
 	fclose(f);
 
 	g3d_context_update_progress_bar(context, 0.0, FALSE);
 
-#if DEBUG &gt; 2
-	g_printerr(&quot;DEBUG: lwo file loaded\n&quot;);
-#endif
-
 	return TRUE;
 }
 
@@ -100,7 +127,7 @@
 {
 	return g_strdup(
 		&quot;Import plugin to load LightWave Objects (.lwo files)\n&quot;
-		&quot;Author: Markus Dahms, heavily copied from gtkglarea examples\n&quot;);
+		&quot;Author: Markus Dahms\n&quot;);
 }
 
 gchar **plugin_extensions(G3DContext *context)
@@ -112,16 +139,7 @@
 /* private                                                                   */
 /*****************************************************************************/
 
-static gint lwo_read_string(FILE *f, char *s);
-static void lwo_read_srfs(FILE *f, gint nbytes, G3DObject *object);
-static void lwo_read_surf(FILE *f, gint nbytes, G3DObject *object,
-	guint32 flags);
-static void lwo_read_pols(FILE *f, gint nbytes,
-	G3DModel *model, G3DObject *object, guint32 flags, G3DContext *context);
-static void lwo_read_pnts(FILE *f, gint nbytes, G3DObject *object,
-	G3DContext *context);
-
-static G3DObject *lwo_create_object(FILE *f, G3DModel *model, guint32 flags)
+G3DObject *lwo_create_object(FILE *f, G3DModel *model, guint32 flags)
 {
 	G3DObject *object = g_new0(G3DObject, 1);
 	object-&gt;name = g_strdup_printf(&quot;LWO%c object @ 0x%08lx&quot;,
@@ -136,73 +154,11 @@
 	return object;
 }
 
-static gboolean lwo_read_directory(FILE *f, guint32 nbytes, G3DModel *model,
-	gpointer pobject, guint32 parentid, guint32 level, guint32 flags,
-	G3DContext *context)
-{
-	G3DObject *object = NULL;
-	int toread = nbytes;
-	float pscale = (float)toread / 100.0;
-	while(toread &gt; 0)
-	{
-		guint32 id, len;
-
-		if(level == 0)
-		{
-			g3d_context_update_progress_bar(context,
-				100.0 - (float)toread / pscale, TRUE);
-		}
-
-		toread -= g3d_iff_readchunk(f, &amp;id, &amp;len);
-#if DEBUG &gt; 0
-		g_printerr(&quot;%.*s[%c%c%c%c] @ 0x%08lx (%d bytes)\n&quot;,
-			level * 2, &quot;                   &quot;,
-			(id &gt;&gt; 24) &amp; 0xFF, (id &gt;&gt; 16) &amp; 0xFF,
-			(id &gt;&gt; 8) &amp; 0xFF, id &amp; 0xFF,
-			ftell(f) - 8, len);
-#endif
-		switch(id)
-		{
-			case G3D_IFF_MKID('P','N','T','S'):
-				if(object == NULL)
-					object = lwo_create_object(f, model, flags);
-				lwo_read_pnts(f, len, object, context);
-				break;
-
-			case G3D_IFF_MKID('P','O','L','S'):
-				lwo_read_pols(f, len, model, object, flags, context);
-				break;
-
-			case G3D_IFF_MKID('S','R','F','S'):
-				/* LWOB: surfaces */
-				if(object == NULL)
-					object = lwo_create_object(f, model, flags);
-				lwo_read_srfs(f, len, object);
-				break;
-
-			case G3D_IFF_MKID('S','U','R','F'):
-				lwo_read_surf(f, len, object, flags);
-				break;
-
-			case G3D_IFF_MKID('T','A','G','S'):
-				/* LWO2: first (used) chunk of object */
-				object = lwo_create_object(f, model, flags);
-				lwo_read_srfs(f, len, object);
-				break;
-
-			default:
-				fseek(f, len + (len%2), SEEK_CUR);
-				break;
-		}
-	}
-	return TRUE;
-}
-
 /*****************************************************************************/
 /* LWO specific                                                              */
 /*****************************************************************************/
 
-static gint lwo_read_string(FILE *f, char *s)
+gint lwo_read_string(FILE *f, char *s)
 {
 	gint c;
 	gint cnt = 0;
@@ -222,7 +178,7 @@
 	return cnt;
 }
 
-static guint32 lwo_read_vx(FILE *f, guint *index)
+guint32 lwo_read_vx(FILE *f, guint *index)
 {
 	*index = g3d_read_int16_be(f);
 	if((*index &amp; 0xFF00) == 0xFF00)
@@ -238,319 +194,32 @@
 	}
 }
 
-static void lwo_read_srfs(FILE *f, gint nbytes, G3DObject *object)
+static void lwo_fix_texfaces(G3DModel *model)
 {
-#if DEBUG &gt; 2
-	g_printerr(&quot;lwo_read_srfs {&quot;);
-#endif
-	while(nbytes &gt; 0)
-	{
-		char text[1024];
-		G3DMaterial *material = g3d_material_new();
-
-		nbytes -= lwo_read_string(f, text);
-		material-&gt;name = g_strdup(text);
-		object-&gt;materials = g_slist_append(object-&gt;materials, material);
-	}
-#if DEBUG &gt; 2
-	g_printerr(&quot; }\n&quot;);
-#endif
-}
-
-static void lwo_read_surf(FILE *f, gint nbytes, G3DObject *object,
-	guint32 flags)
-{
-	GSList *mlist;
-	G3DMaterial *material = NULL, *tmat;
-	gfloat tmpf;
-	char name[LW_MAX_NAME_LEN];
-	guint32 len = 0, tmp;
-
-	len = lwo_read_string(f, name);
-	nbytes -= len;
-
-	if(flags &amp; LW_F_LWO2)
-	{
-		g3d_read_int16_be(f);
-		nbytes -= 2;
-	}
-
-	mlist = object-&gt;materials;
-	g_return_if_fail(mlist != NULL);
-	while(mlist != NULL)
-	{
-		tmat = (G3DMaterial*)mlist-&gt;data;
-		if(strcmp(name, tmat-&gt;name) == 0)
-		{
-			material = tmat;
-			break;
-		}
-		mlist = mlist-&gt;next;
-	}
-	g_return_if_fail(material != NULL);
-#if DEBUG &gt; 1
-	g_print(&quot;LWO: surf: %s\n&quot;, material-&gt;name);
-#endif
-
-	material-&gt;a = 1.0;
-
-	while(nbytes &gt; 0)
-	{
-		gint32 id = g3d_read_int32_be(f);
-		nbytes -= 4;
-		len = g3d_read_int16_be(f);
-		nbytes -= 2;
-
-		switch(id)
-		{
-			case G3D_IFF_MKID('C','O','L','R'):
-				if(flags &amp; LW_F_LWO2)
-				{
-					material-&gt;r = g3d_read_float_be(f);
-					material-&gt;g = g3d_read_float_be(f);
-					material-&gt;b = g3d_read_float_be(f);
-#if DEBUG &gt; 0
-					g_print(&quot;LWO: SURF: COLR: %+1.2f %+1.2f %+1.2f\n&quot;,
-						material-&gt;r, material-&gt;g, material-&gt;b);
-#endif
-					g3d_read_int16_be(f);
-					nbytes -= 14;
-				}
-				else
-				{
-					material-&gt;r = g3d_read_int8(f) / 255.0;
-					material-&gt;g = g3d_read_int8(f) / 255.0;
-					material-&gt;b = g3d_read_int8(f) / 255.0;
-					g3d_read_int8(f);
-					nbytes -= 4;
-				}
-				break;
-
-			case G3D_IFF_MKID('D','I','F','F'):
-				/* diffuse */
-				if(flags &amp; LW_F_LWO2)
-				{
-					g3d_read_float_be(f); /* intensity */
-					nbytes -= 4;
-					nbytes -= lwo_read_vx(f, &amp;tmp); /* envelope ?? */
-				}
-				else
-				{
-					g3d_read_int16_be(f);
-					nbytes -= 2;
-				}
-				break;
-
-			case G3D_IFF_MKID('S','P','E','C'):
-				/* specular */
-				if(flags &amp; LW_F_LWO2)
-				{
-					tmpf = 1.0 - g3d_read_float_be(f); /* intensity */
-					nbytes -= 4;
-					nbytes -= lwo_read_vx(f, &amp;tmp); /* envelope ?? */
-				}
-				else
-				{
-					tmpf = 1.0 - (float)g3d_read_int16_be(f) / 256.0;
-					nbytes -= 2;
-				}
-
-				material-&gt;specular[0] = material-&gt;r * tmpf;
-				material-&gt;specular[1] = material-&gt;g * tmpf;
-				material-&gt;specular[2] = material-&gt;b * tmpf;
-				break;
-
-			case G3D_IFF_MKID('T','R','A','N'):
-				/* transparency */
-				if(flags &amp; LW_F_LWO2)
-				{
-					material-&gt;a = 1.0 - g3d_read_float_be(f); /* intensity */
-					nbytes -= 4;
-					nbytes -= lwo_read_vx(f, &amp;tmp); /* envelope ?? */
-				}
-				else
-				{
-					material-&gt;a = 1.0 - (float)g3d_read_int16_be(f) / 256.0;
-					nbytes -= 2;
-				}
-				if(material-&gt;a &lt; 0.1)
-					material-&gt;a = 0.1;
-				break;
-
-			default:
-#if DEBUG &gt; 0
-				g_print(&quot;LWO: surf: [%c%c%c%c] (%d bytes)\n&quot;,
-					(id &gt;&gt; 24) &amp; 0xFF, (id &gt;&gt; 16) &amp; 0xFF,
-					(id &gt;&gt; 8) &amp; 0xFF, id &amp; 0xFF,
-					len);
-#endif
-				fseek(f, len+(len%2), SEEK_CUR);
-				nbytes -= len+(len%2);
-				break;
-		}
-	}
-#if DEBUG &gt; 2
-	g_printerr(&quot; }\n&quot;);
-#endif
-}
-
-static void lwo_read_pols(FILE *f, gint nbytes,
-	G3DModel *model, G3DObject *object, guint32 flags, G3DContext *context)
-{
+	GSList *olist, *flist;
+	G3DObject *object;
 	G3DFace *face;
-	guint32 n = 0, type, i;
-	gint16 nmat;
 
-	if(flags &amp; LW_F_LWO2)
+	olist = model-&gt;objects;
+	while(olist)
 	{
-		type = g3d_read_int32_be(f);
-		nbytes -= 4;
+		object = (G3DObject *)olist-&gt;data;
+		olist = olist-&gt;next;
 
-		if(type != G3D_IFF_MKID('F', 'A', 'C', 'E'))
+		flist = object-&gt;faces;
+		while(flist)
 		{
-			fseek(f, nbytes, SEEK_CUR);
-			return;
-		}
-	}
+			face = (G3DFace *)flist-&gt;data;
+			flist = flist-&gt;next;
 
-	while(nbytes &gt; 0)
-	{
-		n++;
-		face = g_new0(G3DFace, 1);
-		face-&gt;vertex_count = g3d_read_int16_be(f);
-		nbytes -= 2;
-
-		if(flags &amp; LW_F_LWO2)
-			face-&gt;vertex_count &amp;= 0x03FF; /* 6 high order bits are flags */
-
-		face-&gt;vertex_indices = g_new0(guint32, face-&gt;vertex_count);
-
-		for(i = 0; i &lt; face-&gt;vertex_count; i ++)
-		{
-			if(flags &amp; LW_F_LWO2)
+			if(face-&gt;flags &amp; G3D_FLAG_FAC_TEXMAP)
 			{
-				nbytes -= lwo_read_vx(f, &amp;(face-&gt;vertex_indices[i]));
-#if DEBUG &gt; 0
-				if(face-&gt;vertex_indices[i] &gt;= object-&gt;vertex_count)
+				face-&gt;tex_image = face-&gt;material-&gt;tex_image;
+				if(face-&gt;tex_image == NULL)
 				{
-					g_print(
-						&quot;LWO: vertex_indices[%d] (%d) &gt;= vertex_count (%d)\n&quot;,
-						i, face-&gt;vertex_indices[i], object-&gt;vertex_count);
+					face-&gt;flags &amp;= ~G3D_FLAG_FAC_TEXMAP;
 				}
-#endif
 			}
-			else
-			{
-				face-&gt;vertex_indices[i] = g3d_read_int16_be(f);
-				nbytes -= 2;
-
-				if(face-&gt;vertex_indices[i] &gt; object-&gt;vertex_count)
-				{
-#if DEBUG &gt; 0
-					g_print(
-						&quot;LWO: vertex_indices[%d] (%d) &gt;= vertex_count (%d)\n&quot;,
-						i, face-&gt;vertex_indices[i], object-&gt;vertex_count);
-#endif
-					face-&gt;vertex_indices[i] = 0;
-				}
-			}
-			g3d_context_update_interface(context);
 		}
-
-		if(!(flags &amp; LW_F_LWO2))
-		{
-			nmat = g3d_read_int16_be(f);
-			nbytes -= 2;
-
-			if(nmat &lt; 0)
-			{
-				/* detail polygons, skipped */
-				int det_cnt = g3d_read_int16_be(f);
-				nbytes -= 2;
-				nmat *= -1;
-				while(det_cnt-- &gt; 0)
-				{
-					int cnt = g3d_read_int16_be(f);
-					nbytes -= 2;
-
-					fseek(f, cnt*2+2, SEEK_CUR);
-					nbytes -= cnt*2+2;
-					g3d_context_update_interface(context);
-				}
-			}
-			else if(nmat == 0)
-			{
-				nmat = 1;
-			}
-
-			face-&gt;material = g_slist_nth_data(object-&gt;materials,
-				(guint) nmat - 1);
-			if(face-&gt;material == NULL)
-			{
-#if DEBUG &gt; 0
-				g_print(&quot;LWO: face-&gt;material is NULL (#%d)\n&quot;, nmat - 1);
-#endif
-				face-&gt;material = g_slist_nth_data(model-&gt;materials, 0);
-			}
-#if DEBUG &gt; 3
-			g_printerr(&quot;lwo_read_pols: face #%d (nbytes: %d)\n&quot;, n, nb);
-#endif
-		} /* ! LW_F_LWO2 */
-		else
-		{
-			face-&gt;material = g_slist_nth_data(object-&gt;materials, 0);
-			if(face-&gt;material == NULL)
-				face-&gt;material = g_slist_nth_data(model-&gt;materials, 0);
-		}
-
-		if(face-&gt;vertex_count &lt; 3)
-		{
-			g_free(face-&gt;vertex_indices);
-			g_free(face);
-		}
-		else
-			object-&gt;faces = g_slist_prepend(object-&gt;faces, face);
-	} /* nb &gt; 0 */
-
-#if DEBUG &gt; 0
-	g_print(&quot;LWO: POLS: %d faces\n&quot;, g_slist_length(object-&gt;faces));
-#endif
-
-	if(nbytes != 0)
-	{
-		fseek(f, nbytes, SEEK_CUR);
-#if DEBUG &gt; 0
-		g_print(&quot;LWO: POLS: had to seek %d bytes&quot;, nbytes);
-#endif
 	}
 }
-
-static void lwo_read_pnts(FILE *f, gint nbytes, G3DObject *object,
-	G3DContext *context)
-{
-	guint32 i, off;
-
-	off = object-&gt;vertex_count;
-	object-&gt;vertex_count += (nbytes / 12);
-	if(object-&gt;vertex_count &lt; 3)
-	{
-#if DEBUG &gt; 0
-		g_print(&quot;LWO: PNTS: object-&gt;vertex_count &lt; 3 (%d)\n&quot;,
-			object-&gt;vertex_count);
-#endif
-		return;
-	}
-
-	object-&gt;vertex_data = g_realloc(object-&gt;vertex_data,
-		sizeof(gfloat) * object-&gt;vertex_count * 3);
-
-	for(i = off; i &lt; object-&gt;vertex_count; i ++)
-	{
-		object-&gt;vertex_data[i * 3 + 0] = g3d_read_float_be(f);
-		object-&gt;vertex_data[i * 3 + 1] = g3d_read_float_be(f);
-		object-&gt;vertex_data[i * 3 + 2] = g3d_read_float_be(f);
-		g3d_context_update_interface(context);
-	}
-}
-
-

Added: trunk/libs3d/libg3d/plugins/import/imp_lwo.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_lwo.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_lwo.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,28 @@
+#ifndef _IMP_LWO_H
+#define _IMP_LWO_H
+
+#include &lt;stdio.h&gt;
+#include &lt;g3d/types.h&gt;
+
+#define LWO_FLAG_LWO2          (1 &lt;&lt; 0)
+
+typedef struct
+{
+	gint32 ntags;
+	gchar **tags;
+
+	gint32 nclips;
+	guint32 *clips;
+	gchar **clipfiles;
+
+	gfloat *tex_vertices;
+
+	G3DObject *object;
+}
+LwoObject;
+
+G3DObject *lwo_create_object(FILE *f, G3DModel *model, guint32 flags);
+gint lwo_read_string(FILE *f, char *s);
+guint32 lwo_read_vx(FILE *f, guint *index);
+
+#endif /* _IMP_LWO_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,584 @@
+
+#include &lt;string.h&gt;
+
+#include &lt;glib.h&gt;
+
+#include &lt;g3d/context.h&gt;
+#include &lt;g3d/material.h&gt;
+#include &lt;g3d/texture.h&gt;
+#include &lt;g3d/iff.h&gt;
+#include &lt;g3d/read.h&gt;
+
+#include &quot;imp_lwo.h&quot;
+
+gboolean lwo_cb_CLIP(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	guint32 index;
+
+	obj = (LwoObject *)global-&gt;user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	if(!local-&gt;finalize)
+	{
+		index = g3d_read_int32_be(global-&gt;f);
+		local-&gt;nb -= 4;
+
+		obj-&gt;nclips ++;
+		obj-&gt;clips = g_realloc(obj-&gt;clips, obj-&gt;nclips * sizeof(guint32));
+		obj-&gt;clipfiles = g_realloc(obj-&gt;clipfiles,
+			(obj-&gt;nclips + 1) * sizeof(gchar *));
+
+		obj-&gt;clips[obj-&gt;nclips - 1] = index;
+		obj-&gt;clipfiles[obj-&gt;nclips - 1] = g_strdup(&quot;undef&quot;);
+		obj-&gt;clipfiles[obj-&gt;nclips] = NULL;
+	}
+
+	return TRUE;
+}
+
+gboolean lwo_cb_COLR(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DMaterial *material;
+
+	material = (G3DMaterial *)local-&gt;object;
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	if(global-&gt;flags &amp; LWO_FLAG_LWO2)
+	{
+		material-&gt;r = g3d_read_float_be(global-&gt;f);
+		material-&gt;g = g3d_read_float_be(global-&gt;f);
+		material-&gt;b = g3d_read_float_be(global-&gt;f);
+		local-&gt;nb -= 12;
+		g3d_read_int16_be(global-&gt;f);
+		local-&gt;nb -= 2;
+	}
+	else
+	{
+		material-&gt;r = g3d_read_int8(global-&gt;f) / 255.0;
+		material-&gt;g = g3d_read_int8(global-&gt;f) / 255.0;
+		material-&gt;b = g3d_read_int8(global-&gt;f) / 255.0;
+		g3d_read_int8(global-&gt;f);
+		local-&gt;nb -= 4;
+	}
+
+	return TRUE;
+}
+
+/* image index */
+gboolean lwo_cb_IMAG(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DMaterial *material;
+	guint32 index, i;
+
+	obj = (LwoObject *)global-&gt;user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	material = (G3DMaterial *)local-&gt;object;
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	local-&gt;nb -= lwo_read_vx(global-&gt;f, &amp;index);
+
+	for(i = 0; i &lt; obj-&gt;nclips; i ++)
+	{
+		if(obj-&gt;clips[i] == index)
+			break;
+	}
+
+	if(obj-&gt;clips[i] == index)
+	{
+		material-&gt;tex_image = g3d_texture_load_cached(
+			global-&gt;context, global-&gt;model, obj-&gt;clipfiles[i]);
+	}
+
+	return TRUE;
+}
+
+/* points */
+gboolean lwo_cb_PNTS(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DObject *object;
+	gint32 i, off;
+
+	obj = (LwoObject *)global-&gt;user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	if(global-&gt;flags &amp; LWO_FLAG_LWO2)
+	{
+		object = lwo_create_object(global-&gt;f, global-&gt;model, global-&gt;flags);
+		obj-&gt;object = object;
+
+		if(obj-&gt;tex_vertices)
+		{
+			g_free(obj-&gt;tex_vertices);
+			obj-&gt;tex_vertices = NULL;
+		}
+	}
+	else
+	{
+		object = (G3DObject *)obj-&gt;object;
+		if(object == NULL)
+		{
+			object = lwo_create_object(global-&gt;f, global-&gt;model,
+				global-&gt;flags);
+			obj-&gt;object = object;
+		}
+	}
+
+	off = object-&gt;vertex_count;
+	object-&gt;vertex_count += (local-&gt;nb / 12);
+	g_return_val_if_fail(object-&gt;vertex_count &gt;= 3, FALSE);
+
+	object-&gt;vertex_data = g_realloc(object-&gt;vertex_data,
+		sizeof(gfloat) * object-&gt;vertex_count * 3);
+
+	for(i = off; i &lt; object-&gt;vertex_count; i ++)
+	{
+		object-&gt;vertex_data[i * 3 + 0] = g3d_read_float_be(global-&gt;f);
+		object-&gt;vertex_data[i * 3 + 1] = g3d_read_float_be(global-&gt;f);
+		object-&gt;vertex_data[i * 3 + 2] = g3d_read_float_be(global-&gt;f);
+		local-&gt;nb -= 12;
+	}
+
+	return TRUE;
+}
+
+/* polygons */
+gboolean lwo_cb_POLS(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DObject *object;
+	G3DFace *face;
+	guint32 type;
+	gint32 n = 0, i, nmat, det_cnt, cnt;
+	gint16 i16;
+	gchar *tmp;
+
+	obj = (LwoObject *)global-&gt;user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	object = (G3DObject *)obj-&gt;object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	if(global-&gt;flags &amp; LWO_FLAG_LWO2)
+	{
+		type = g3d_read_int32_be(global-&gt;f);
+		local-&gt;nb -= 4;
+
+		if(type != G3D_IFF_MKID('F', 'A', 'C', 'E'))
+		{
+			tmp = g3d_iff_id_to_text(type);
+			g_warning(&quot;[LWO] unhandled polygon type %s&quot;, tmp);
+			g_free(tmp);
+			return FALSE;
+		}
+	}
+
+	while(local-&gt;nb &gt; 0)
+	{
+		n ++;
+		face = g_new0(G3DFace, 1);
+		face-&gt;vertex_count = g3d_read_int16_be(global-&gt;f);
+		local-&gt;nb -= 2;
+
+		if(global-&gt;flags &amp; LWO_FLAG_LWO2)
+			face-&gt;vertex_count &amp;= 0x03FF;
+
+		face-&gt;vertex_indices = g_new0(guint32, face-&gt;vertex_count);
+
+		if(obj-&gt;tex_vertices)
+		{
+			face-&gt;flags |= G3D_FLAG_FAC_TEXMAP;
+			face-&gt;tex_vertex_count = face-&gt;vertex_count;
+			face-&gt;tex_vertex_data = g_new0(gfloat, face-&gt;tex_vertex_count * 2);
+		}
+
+		for(i = 0; i &lt; face-&gt;vertex_count; i ++)
+		{
+			if(global-&gt;flags &amp; LWO_FLAG_LWO2)
+			{
+				local-&gt;nb -= lwo_read_vx(global-&gt;f,
+					&amp;(face-&gt;vertex_indices[i]));
+			}
+			else
+			{
+				face-&gt;vertex_indices[i] = g3d_read_int16_be(global-&gt;f);
+				local-&gt;nb -= 2;
+#if 0
+				i16 = g3d_read_int16_be(global-&gt;f);
+				local-&gt;nb -= 2;
+
+				if(i16 &lt; 0)
+					face-&gt;vertex_indices[i] = - i16;
+				else
+					face-&gt;vertex_indices[i] = i16;
+#endif
+
+				if(face-&gt;vertex_indices[i] &gt; object-&gt;vertex_count)
+					face-&gt;vertex_indices[i] = 0;
+			}
+
+			if(obj-&gt;tex_vertices)
+			{
+				face-&gt;tex_vertex_data[i * 2 + 0] =
+					obj-&gt;tex_vertices[face-&gt;vertex_indices[i] * 2 + 0];
+				face-&gt;tex_vertex_data[i * 2 + 1] =
+					obj-&gt;tex_vertices[face-&gt;vertex_indices[i] * 2 + 1];
+			}
+		} /* i: 0..face-&gt;vertex_count */
+
+		if(!(global-&gt;flags &amp; LWO_FLAG_LWO2))
+		{
+			nmat = g3d_read_int16_be(global-&gt;f);
+			local-&gt;nb -= 2;
+
+			if(nmat &lt; 0)
+			{
+				/* detail polygons, skipped */
+				det_cnt = g3d_read_int16_be(global-&gt;f);
+				local-&gt;nb -= 2;
+				nmat *= -1;
+				while(det_cnt-- &gt; 0)
+				{
+					cnt = g3d_read_int16_be(global-&gt;f);
+					local-&gt;nb -= 2;
+
+					fseek(global-&gt;f, cnt * 2 + 2, SEEK_CUR);
+					local-&gt;nb -= cnt * 2 + 2;
+				}
+			}
+			else if(nmat == 0)
+			{
+				nmat = 1;
+			}
+
+			face-&gt;material = g_slist_nth_data(global-&gt;model-&gt;materials, nmat);
+
+			if(face-&gt;material == NULL)
+			{
+#if 0
+				g_warning(&quot;[LWO] face-&gt;material is NULL (#%d)\n&quot;, nmat - 1);
+#endif
+				face-&gt;material = g_slist_nth_data(global-&gt;model-&gt;materials, 0);
+			}
+
+		} /* !LWO2 */
+		else
+		{
+			face-&gt;material = g_slist_nth_data(global-&gt;model-&gt;materials, 0);
+		} /* LWO2 */
+
+		if(face-&gt;vertex_count &lt; 3)
+		{
+			g_free(face-&gt;vertex_indices);
+			g_free(face);
+		}
+		else
+		{
+			object-&gt;faces = g_slist_prepend(object-&gt;faces, face);
+		}
+
+		g3d_context_update_interface(global-&gt;context);
+	} /* local-&gt;nb &gt; 0 */
+
+	return TRUE;
+}
+
+/* poly tag mapping */
+gboolean lwo_cb_PTAG(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DObject *object;
+	G3DMaterial *material, *tmat;
+	G3DFace *face;
+	GSList *mlist;
+	gint32 id, fmax;
+	guint32 poly, tag;
+
+	obj = (LwoObject *)global-&gt;user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	object = (G3DObject *)obj-&gt;object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	id = g3d_read_int32_be(global-&gt;f);
+	local-&gt;nb -= 4;
+
+	if(id != G3D_IFF_MKID('S','U','R','F'))
+		return FALSE;
+
+	fmax = g_slist_length(object-&gt;faces) - 1;
+
+	while(local-&gt;nb &gt; 0)
+	{
+		local-&gt;nb -= lwo_read_vx(global-&gt;f, &amp;poly);
+		tag = g3d_read_int16_be(global-&gt;f);
+		local-&gt;nb -= 2;
+
+		face = (G3DFace *)g_slist_nth_data(object-&gt;faces, fmax - poly);
+		g_return_val_if_fail(face != NULL, FALSE);
+
+		if(tag &gt; obj-&gt;ntags)
+		{
+			g_printerr(&quot;[LWO] tag %d not listed (%d tags)\n&quot;, tag, obj-&gt;ntags);
+			continue;
+		}
+
+		material = NULL;
+		mlist = global-&gt;model-&gt;materials;
+		while(mlist != NULL)
+		{
+			tmat = (G3DMaterial*)mlist-&gt;data;
+			if(strcmp(obj-&gt;tags[tag], tmat-&gt;name) == 0)
+			{
+				material = tmat;
+				break;
+			}
+			mlist = mlist-&gt;next;
+		}
+
+		if(material)
+			face-&gt;material = material;
+		else
+			g_printerr(&quot;[LWO] unknown material tag %s\n&quot;, obj-&gt;tags[tag]);
+	}
+
+	return TRUE;
+}
+
+/* specularity */
+gboolean lwo_cb_SPEC(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DMaterial *material;
+	gfloat tmpf;
+
+	material = (G3DMaterial *)local-&gt;object;
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	if(global-&gt;flags &amp; LWO_FLAG_LWO2)
+	{
+		tmpf = 1.0 - g3d_read_float_be(global-&gt;f);
+		local-&gt;nb -= 4;
+	}
+	else
+	{
+		tmpf = 1.0 - (gfloat)g3d_read_int16_be(global-&gt;f) / 256.0;
+		local-&gt;nb -= 2;
+	}
+
+	material-&gt;specular[0] = material-&gt;r * tmpf;
+	material-&gt;specular[1] = material-&gt;g * tmpf;
+	material-&gt;specular[2] = material-&gt;b * tmpf;
+
+	return TRUE;
+}
+
+/* surfaces */
+gboolean lwo_cb_SRFS(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DMaterial *material;
+	gchar buffer[512];
+
+	obj = (LwoObject *)global-&gt;user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	while(local-&gt;nb &gt; 0)
+	{
+		material = g3d_material_new();
+		local-&gt;nb -= lwo_read_string(global-&gt;f, buffer);
+		material-&gt;name = g_strdup(buffer);
+		global-&gt;model-&gt;materials = g_slist_append(global-&gt;model-&gt;materials,
+			material);
+
+	}
+
+	return TRUE;
+}
+
+/* still image */
+gboolean lwo_cb_STIL(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+
+	gchar buffer[512];
+
+    obj = (LwoObject *)global-&gt;user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	local-&gt;nb -= lwo_read_string(global-&gt;f, buffer);
+
+	g_free(obj-&gt;clipfiles[obj-&gt;nclips - 1]);
+	obj-&gt;clipfiles[obj-&gt;nclips - 1] = g_strdup(buffer);
+	obj-&gt;clipfiles[obj-&gt;nclips] = NULL;
+
+	return TRUE;
+}
+
+/* surface */
+gboolean lwo_cb_SURF(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DObject *object;
+	G3DMaterial *material = NULL, *tmat;
+	GSList *mlist;
+	gchar name[512];
+
+	obj = (LwoObject *)global-&gt;user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	object = (G3DObject *)obj-&gt;object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	if(!local-&gt;finalize)
+	{
+		local-&gt;nb -= lwo_read_string(global-&gt;f, name);
+
+		if(global-&gt;flags &amp; LWO_FLAG_LWO2)
+		{
+			g3d_read_int16_be(global-&gt;f);
+			local-&gt;nb -= 2;
+		}
+
+		mlist = global-&gt;model-&gt;materials;
+		while(mlist != NULL)
+		{
+			tmat = (G3DMaterial*)mlist-&gt;data;
+			if(strcmp(name, tmat-&gt;name) == 0)
+			{
+				material = tmat;
+				break;
+			}
+			mlist = mlist-&gt;next;
+		}
+
+		if(material == NULL)
+		{
+			material = g3d_material_new();
+			material-&gt;name = g_strdup(name);
+			global-&gt;model-&gt;materials = g_slist_append(global-&gt;model-&gt;materials,
+				material);
+		}
+
+		local-&gt;object = material;
+	}
+
+	return TRUE;
+}
+
+/* tags */
+gboolean lwo_cb_TAGS(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DMaterial *material;
+	gchar buffer[512];
+
+	obj = (LwoObject *)global-&gt;user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	if(obj-&gt;ntags)
+	{
+		g_strfreev(obj-&gt;tags);
+		obj-&gt;ntags = 0;
+	}
+
+	/* read tags */
+	while(local-&gt;nb &gt; 0)
+	{
+		local-&gt;nb -= lwo_read_string(global-&gt;f, buffer);
+		obj-&gt;ntags ++;
+		obj-&gt;tags = g_realloc(obj-&gt;tags, (1 + obj-&gt;ntags) * sizeof(gchar *));
+		obj-&gt;tags[obj-&gt;ntags - 1] = g_strdup(buffer);
+		obj-&gt;tags[obj-&gt;ntags] = NULL;
+
+		material = g3d_material_new();
+		material-&gt;name = g_strdup(buffer);
+		global-&gt;model-&gt;materials = g_slist_append(global-&gt;model-&gt;materials,
+			material);
+	}
+
+	return TRUE;
+}
+
+/* transparency */
+gboolean lwo_cb_TRAN(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DMaterial *material;
+
+	material = (G3DMaterial *)local-&gt;object;
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	if(global-&gt;flags &amp; LWO_FLAG_LWO2)
+	{
+		material-&gt;a = 1.0 - g3d_read_float_be(global-&gt;f);
+		local-&gt;nb -= 4;
+	}
+	else
+	{
+		material-&gt;a = 1.0 - (gfloat)g3d_read_int16_be(global-&gt;f) / 256.0;
+		local-&gt;nb -= 2;
+	}
+
+	if(material-&gt;a &lt; 0.1)
+		material-&gt;a = 0.1;
+
+	return TRUE;
+}
+
+/* vertex mapping */
+gboolean lwo_cb_VMAP(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	guint32 index, type, dim;
+	gchar buffer[512], *tmp;
+
+	obj = (LwoObject *)global-&gt;user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	tmp = g3d_iff_id_to_text(local-&gt;parent_id);
+	g_debug(&quot;[LWO][VMAP] parent is %s&quot;, tmp);
+	g_free(tmp);
+
+	if(local-&gt;parent_id == G3D_IFF_MKID('L','W','O','2'))
+	{
+		type = g3d_read_int32_be(global-&gt;f);
+		local-&gt;nb -= 4;
+
+		dim = g3d_read_int16_be(global-&gt;f);
+		local-&gt;nb -= 2;
+
+		local-&gt;nb -= lwo_read_string(global-&gt;f, buffer);
+
+		if(type == G3D_IFF_MKID('T','X','U','V'))
+		{
+			g_debug(&quot;[LWO][VMAP] **TXUV**&quot;);
+
+			g_return_val_if_fail(obj-&gt;tex_vertices == NULL, FALSE);
+
+			obj-&gt;tex_vertices = g_new0(gfloat,
+				obj-&gt;object-&gt;vertex_count * 2);
+
+			while(local-&gt;nb &gt; 0)
+			{
+				local-&gt;nb -= lwo_read_vx(global-&gt;f, &amp;index);
+				g_return_val_if_fail(index &lt; obj-&gt;object-&gt;vertex_count, FALSE);
+
+				obj-&gt;tex_vertices[index * 2 + 0] =
+					g3d_read_float_be(global-&gt;f);
+				obj-&gt;tex_vertices[index * 2 + 1] =
+					1.0 - g3d_read_float_be(global-&gt;f);
+				local-&gt;nb -= 8;
+			}
+		}
+		else
+		{
+			tmp = g3d_iff_id_to_text(type);
+			g_warning(&quot;[LWO][VMAP] unhandled vertex mapping %s&quot;, tmp);
+			g_free(tmp);
+		}
+	}
+
+	return TRUE;
+}

Added: trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,18 @@
+#ifndef _IMP_LWO_CALLBACKS_H
+#define _IMP_LWO_CALLBACKS_H
+
+gboolean lwo_cb_CLIP(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_COLR(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_IMAG(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_PNTS(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_POLS(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_PTAG(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_SPEC(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_SRFS(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_STIL(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_SURF(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_TAGS(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_TRAN(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_VMAP(g3d_iff_gdata *global, g3d_iff_ldata *local);
+
+#endif

Added: trunk/libs3d/libg3d/plugins/import/imp_lwo_chunks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_lwo_chunks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_lwo_chunks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,98 @@
+#ifndef _IMP_LWO_CHUNKS_H
+#define _IMP_LWO_CHUNKS_H
+
+#include &lt;g3d/iff.h&gt;
+
+#include &quot;imp_lwo_callbacks.h&quot;
+
+static g3d_iff_chunk_info lwo_chunks[] = {
+	{ &quot;AAST&quot;, &quot;antialiasing strength&quot;,       0, NULL },
+	{ &quot;ALPH&quot;, &quot;alpha mode&quot;,                  0, NULL },
+	{ &quot;AXIS&quot;, &quot;major axis&quot;,                  0, NULL },
+	{ &quot;BBOX&quot;, &quot;bounding box&quot;,                0, NULL },
+	{ &quot;BLOK&quot;, &quot;block&quot;,                       1, NULL },
+	{ &quot;BTEX&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;BUMP&quot;, &quot;bump intensity&quot;,              0, NULL },
+	{ &quot;CLIP&quot;, &quot;image or image sequence&quot;,     1, lwo_cb_CLIP },
+	{ &quot;CLRF&quot;, &quot;color filter&quot;,                0, NULL },
+	{ &quot;CLRH&quot;, &quot;color highlights&quot;,            0, NULL },
+	{ &quot;CMNT&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;COLR&quot;, &quot;color&quot;,                       0, lwo_cb_COLR },
+	{ &quot;CTEX&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;DESC&quot;, &quot;description&quot;,                 0, NULL },
+	{ &quot;DIFF&quot;, &quot;diffuse&quot;,                     0, NULL },
+	{ &quot;DTEX&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;FKEY&quot;, &quot;gradient key values&quot;,         0, NULL },
+	{ &quot;FLAG&quot;, &quot;flags&quot;,                       0, NULL },
+	{ &quot;FUNC&quot;, &quot;algorithm and parameters&quot;,    0, NULL },
+	{ &quot;GLOS&quot;, &quot;specular glossiness&quot;,         0, NULL },
+	{ &quot;GRAD&quot;, &quot;gradient texture (header)&quot;,   0, NULL },
+	{ &quot;GREN&quot;, &quot;gradient end&quot;,                0, NULL },
+	{ &quot;GRPT&quot;, &quot;gradient repeat mode&quot;,        0, NULL },
+	{ &quot;GRST&quot;, &quot;gradient start&quot;,              0, NULL },
+	{ &quot;ICON&quot;, &quot;icon&quot;,                        0, NULL },
+	{ &quot;IKEY&quot;, &quot;gradient key parameters&quot;,     0, NULL },
+	{ &quot;IMAG&quot;, &quot;image index&quot;,                 0, lwo_cb_IMAG },
+	{ &quot;IMAP&quot;, &quot;image map (header)&quot;,          0, NULL },
+	{ &quot;INAM&quot;, &quot;item name&quot;,                   0, NULL },
+	{ &quot;LAYR&quot;, &quot;layer&quot;,                       0, NULL },
+	{ &quot;LTEX&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;LUMI&quot;, &quot;luminosity&quot;,                  0, NULL },
+	{ &quot;PIXB&quot;, &quot;pixel blending&quot;,              0, NULL },
+	{ &quot;PNAM&quot;, &quot;parameter name&quot;,              0, NULL },
+	{ &quot;PNTS&quot;, &quot;points&quot;,                      0, lwo_cb_PNTS },
+	{ &quot;POLS&quot;, &quot;polygons&quot;,                    0, lwo_cb_POLS },
+	{ &quot;PROC&quot;, &quot;procedural texture (header)&quot;, 0, NULL },
+	{ &quot;PROJ&quot;, &quot;projection mode&quot;,             0, NULL },
+	{ &quot;PTAG&quot;, &quot;polygon tag mapping&quot;,         0, lwo_cb_PTAG },
+	{ &quot;REFL&quot;, &quot;reflection&quot;,                  0, NULL },
+	{ &quot;RFLT&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;RFOP&quot;, &quot;reflection options&quot;,          0, NULL },
+	{ &quot;RIMG&quot;, &quot;reflection map image&quot;,        0, NULL },
+	{ &quot;RIND&quot;, &quot;refractive index&quot;,            0, NULL },
+	{ &quot;RSAN&quot;, &quot;reflection map seam angle&quot;,   0, NULL },
+	{ &quot;SIDE&quot;, &quot;polygon sidedness&quot;,           0, NULL },
+	{ &quot;SMAN&quot;, &quot;max smooting angle&quot;,          0, NULL },
+	{ &quot;SPEC&quot;, &quot;specular&quot;,                    0, lwo_cb_SPEC },
+	{ &quot;SRFS&quot;, &quot;surface materials&quot;,           0, lwo_cb_SRFS },
+	{ &quot;STEX&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;STIL&quot;, &quot;still image&quot;,                 0, lwo_cb_STIL },
+	{ &quot;SURF&quot;, &quot;surface material&quot;,            1, lwo_cb_SURF },
+	{ &quot;TAAS&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TAGS&quot;, &quot;tags&quot;,                        0, lwo_cb_TAGS },
+	{ &quot;TAMP&quot;, &quot;texture amplitude&quot;,           0, NULL },
+	{ &quot;TCLR&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TCTR&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TEXT&quot;, &quot;commentary text&quot;,             0, NULL },
+	{ &quot;TFAL&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TFLG&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TFP0&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TFP1&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TFP2&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TFP3&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TFRQ&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TIMG&quot;, &quot;refraction map image&quot;,        0, NULL },
+	{ &quot;TIP0&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TMAP&quot;, &quot;texture map&quot;,                 0, NULL },
+	{ &quot;TRAN&quot;, &quot;transparency&quot;,                0, lwo_cb_TRAN },
+	{ &quot;TRNL&quot;, &quot;translucency&quot;,                0, NULL },
+	{ &quot;TROP&quot;, &quot;transparency options&quot;,        0, NULL },
+	{ &quot;TSIZ&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TSP0&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TTEX&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;TVAL&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;VALU&quot;, &quot;basic value&quot;,                 0, NULL },
+	{ &quot;VDIF&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;VMAD&quot;, &quot;discontinuous vertex map&quot;,    0, NULL },
+	{ &quot;VMAP&quot;, &quot;uv vertex map&quot;,               0, lwo_cb_VMAP },
+	{ &quot;VRFL&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;VSPC&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;VTRN&quot;, &quot;unknown&quot;,                     0, NULL },
+	{ &quot;WRAP&quot;, &quot;image wrap options&quot;,          0, NULL },
+	{ &quot;WRPH&quot;, &quot;wrap amount (width)&quot;,         0, NULL },
+	{ &quot;WRPW&quot;, &quot;wrap amount (height)&quot;,        0, NULL },
+
+	{ NULL, NULL, 0, NULL }
+};
+
+#endif /* _IMP_LWO_CHUNKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_maya.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,77 @@
+/* $Id: imp_iob.c,v 1.1.2.2 2006/01/23 17:03:06 dahms Exp $ */
+
+/*
+    libg3d - 3D object loading library
+
+    Copyright (C) 2005, 2006  Markus Dahms &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">mad at automagically.de</A>&gt;
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;glib.h&gt;
+
+#include &lt;g3d/iff.h&gt;
+
+#include &quot;imp_maya_chunks.h&quot;
+
+gboolean plugin_load_model(G3DContext *context, const gchar *filename,
+	G3DModel *model, gpointer user_data)
+{
+	g3d_iff_gdata *global;
+	g3d_iff_ldata *local;
+	guint32 id, len;
+	FILE *f;
+
+	f = g3d_iff_open(filename, &amp;id, &amp;len);
+	if(id != G3D_IFF_MKID('M','a','y','a'))
+	{
+		g_warning(&quot;file is not an Maya file %s&quot;, filename);
+		if(f) fclose(f);
+		return FALSE;
+	}
+
+	local = g_new0(g3d_iff_ldata, 1);
+	global = g_new0(g3d_iff_gdata, 1);
+
+	global-&gt;context = context;
+	global-&gt;model = model;
+	global-&gt;f = f;
+
+	local-&gt;parent_id = id;
+	local-&gt;nb = len;
+
+	g3d_iff_read_ctnr(global, local, maya_chunks, G3D_IFF_PAD4);
+
+	g_free(local);
+	g_free(global);
+
+	return TRUE;
+}
+
+gchar *plugin_description(void)
+{
+	return g_strdup(
+		&quot;import plugin for Maya files\n&quot;);
+}
+
+gchar **plugin_extensions(void)
+{
+	return g_strsplit(&quot;mb&quot;, &quot;:&quot;, 0);
+}
+
+

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,494 @@
+#include &lt;string.h&gt;
+
+#include &lt;g3d/iff.h&gt;
+#include &lt;g3d/model.h&gt;
+#include &lt;g3d/material.h&gt;
+#include &lt;g3d/primitive.h&gt;
+#include &lt;g3d/read.h&gt;
+#include &lt;g3d/matrix.h&gt;
+
+#include &quot;imp_maya_obj.h&quot;
+#include &quot;imp_maya_var.h&quot;
+
+/* compound? */
+gboolean maya_cb_CMPD(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gint32 flags, i;
+	gdouble *val;
+	gchar *var;
+	gchar *padding = &quot;                    &quot;;
+
+	if(local-&gt;nb &lt; 26)
+	{
+		g_warning(&quot;[Maya][CMPD] size: %d&quot;, local-&gt;nb);
+		return FALSE;
+	}
+
+	/* var */
+	var = g_new0(gchar, local-&gt;nb - 25);
+	fread(var, 1, local-&gt;nb - 25, global-&gt;f);
+	local-&gt;nb -= (local-&gt;nb - 25);
+
+	/* flags ? */
+	flags = g3d_read_int8(global-&gt;f);
+	local-&gt;nb -= 1;
+
+	val = g_new0(gdouble, 3);
+
+	for(i = 0; i &lt; 3; i ++)
+	{
+		val[i] = g3d_read_double_be(global-&gt;f);
+		local-&gt;nb -= 8;
+	}
+
+	g_debug(&quot;%s[Maya][CMPD] %s = [%g %g %g]&quot;,
+		padding + (strlen(padding) - local-&gt;level) + 1,
+		var,
+		val[0], val[1], val[2]);
+
+	g_free(val);
+	g_free(var);
+
+	return TRUE;
+}
+
+/* creator */
+gboolean maya_cb_CREA(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	MayaObject *obj;
+	gint32 max_len, flags;
+	gchar *buffer, *name;
+	gchar *padding = &quot;                    &quot;;
+
+	/* flags ? */
+	flags = g3d_read_int8(global-&gt;f);
+	local-&gt;nb -= 1;
+
+	max_len = local-&gt;nb;
+	buffer = g_malloc(max_len + 1);
+
+	/* object name */
+	local-&gt;nb -= g3d_read_cstr(global-&gt;f, buffer, max_len);
+	name = g_strdup(buffer);
+
+	obj = (MayaObject *)local-&gt;object;
+	if(obj)
+		obj-&gt;name = g_strdup(buffer);
+
+	/* parent name */
+	if(local-&gt;nb &gt; 0)
+		local-&gt;nb -= g3d_read_cstr(global-&gt;f, buffer, max_len);
+	else
+		*buffer = '\0';
+
+	if(obj &amp;&amp; *buffer)
+		obj-&gt;parent = g_strdup(buffer);
+
+	g_debug(&quot;%s[Maya][CREA] %s (%s)&quot;,
+		padding + (strlen(padding) - local-&gt;level) + 1,
+		name, *buffer ? buffer : &quot;none&quot;);
+
+	g_free(buffer);
+	g_free(name);
+
+	return TRUE;
+}
+
+/* double # */
+gboolean maya_cb_DBLn(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gint32 len, flags, ndbl, i;
+	gdouble *val;
+	gchar *var;
+	gchar *padding = &quot;                         &quot;;
+
+	len = local-&gt;nb - 9;
+	var = g_malloc(len);
+	fread(var, 1, len, global-&gt;f);
+	local-&gt;nb -= len;
+
+	flags = g3d_read_int8(global-&gt;f);
+	local-&gt;nb -= 1;
+
+	ndbl = local-&gt;nb / 8;
+	val = g_new0(gdouble, ndbl);
+	for(i = 0; i &lt; ndbl; i ++)
+	{
+		val[i] = g3d_read_double_be(global-&gt;f);
+		local-&gt;nb -= 8;
+	}
+
+	g_debug(&quot;%s[Maya][DBL#] %s (%d doubles) (0x%02X)&quot;,
+		padding + (strlen(padding) - local-&gt;level) + 1,
+		var, ndbl, flags);
+
+	if(local-&gt;object)
+		maya_var_set((MayaObject *)local-&gt;object, var, val);
+	else
+		g_free(val);
+
+	g_free(var);
+
+	return TRUE;
+}
+
+/* double 2 */
+gboolean maya_cb_DBL2(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gint32 len, flags;
+	gdouble *val;
+	gchar *var;
+	gchar *padding = &quot;                         &quot;;
+
+	len = local-&gt;nb - 17;
+	var = g_malloc(len);
+	fread(var, 1, len, global-&gt;f);
+	local-&gt;nb -= len;
+
+	flags = g3d_read_int8(global-&gt;f);
+	local-&gt;nb -= 1;
+
+	val = g_new0(gdouble, 2);
+	val[0] = g3d_read_double_be(global-&gt;f);
+	val[1] = g3d_read_double_be(global-&gt;f);
+	local-&gt;nb -= 16;
+
+	g_debug(&quot;%s[Maya][DBL2] %s = (%g,%g) (0x%02X)&quot;,
+		padding + (strlen(padding) - local-&gt;level) + 1,
+		var, val[0], val[1], flags);
+
+	if(local-&gt;object)
+		maya_var_set((MayaObject *)local-&gt;object, var, val);
+	else
+		g_free(val);
+
+	g_free(var);
+
+	return TRUE;
+}
+
+/* double 3 */
+gboolean maya_cb_DBL3(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gint32 len, flags;
+	gdouble *val;
+	gchar *var;
+	gchar *padding = &quot;                         &quot;;
+
+	len = local-&gt;nb - 25;
+	var = g_malloc(len);
+	fread(var, 1, len, global-&gt;f);
+	local-&gt;nb -= len;
+
+	flags = g3d_read_int8(global-&gt;f);
+	local-&gt;nb -= 1;
+
+	val = g_new0(gdouble, 3);
+	val[0] = g3d_read_double_be(global-&gt;f);
+	val[1] = g3d_read_double_be(global-&gt;f);
+	val[2] = g3d_read_double_be(global-&gt;f);
+	local-&gt;nb -= 24;
+
+	g_debug(&quot;%s[Maya][DBL3] %s = (%g,%g,%g) (0x%02X)&quot;,
+		padding + (strlen(padding) - local-&gt;level) + 1,
+		var, val[0], val[1], val[2], flags);
+
+	if(local-&gt;object)
+		maya_var_set((MayaObject *)local-&gt;object, var, val);
+	else
+		g_free(val);
+
+	g_free(var);
+
+	return TRUE;
+}
+
+/* double */
+gboolean maya_cb_DBLE(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gint32 len, flags;
+	gdouble val;
+	gchar *var;
+	gchar *padding = &quot;                         &quot;;
+
+	len = local-&gt;nb - 9;
+	if(len &lt;= 0)
+	{
+		g_warning(&quot;[Maya][DBLE] length of chunk: %d&quot;, local-&gt;nb);
+		return FALSE;
+	}
+
+	var = g_malloc(len);
+	fread(var, 1, len, global-&gt;f);
+	local-&gt;nb -= len;
+
+	flags = g3d_read_int8(global-&gt;f);
+	local-&gt;nb -= 1;
+
+	val = g3d_read_double_be(global-&gt;f);
+	local-&gt;nb -= 8;
+
+	g_debug(&quot;%s[Maya][DBLE] %s = %g (0x%02X)&quot;,
+		padding + (strlen(padding) - local-&gt;level) + 1,
+		var, val, flags);
+
+	if(local-&gt;object)
+		maya_var_set_double((MayaObject *)local-&gt;object, var, val);
+
+	g_free(var);
+
+	return TRUE;
+}
+
+/* mesh object */
+gboolean maya_cb_DMSH(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	MayaObject *obj;
+	G3DObject *object;
+	G3DMaterial *material;
+
+	if(local-&gt;finalize)
+	{
+		obj = (MayaObject *)local-&gt;object;
+
+		object = (G3DObject *)obj-&gt;user_data;
+		object-&gt;name = obj-&gt;name ? g_strdup(obj-&gt;name) : &quot;(unnamed mesh)&quot;;
+
+		maya_obj_add_to_tree(obj, global-&gt;model, object);
+		maya_obj_free(obj);
+	}
+	else
+	{
+		obj = maya_obj_new();
+		local-&gt;object = obj;
+
+		material = g3d_material_new();
+		material-&gt;name = g_strdup(&quot;(default material)&quot;);
+
+		object = g_new0(G3DObject, 1);
+		object-&gt;materials = g_slist_append(object-&gt;materials, material);
+
+		obj-&gt;user_data = object;
+	}
+
+	return TRUE;
+}
+
+/* float 3 */
+gboolean maya_cb_FLT3(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gint32 len, flags;
+	gfloat *val;
+	gchar *var;
+	gchar *padding = &quot;                         &quot;;
+
+	len = local-&gt;nb - 13;
+	var = g_malloc(len);
+	fread(var, 1, len, global-&gt;f);
+	local-&gt;nb -= len;
+
+	flags = g3d_read_int8(global-&gt;f);
+	local-&gt;nb -= 1;
+
+	val = g_new0(gfloat, 3);
+	val[0] = g3d_read_float_be(global-&gt;f);
+	val[1] = g3d_read_float_be(global-&gt;f);
+	val[2] = g3d_read_float_be(global-&gt;f);
+	local-&gt;nb -= 12;
+
+	g_debug(&quot;%s[Maya][DBL3] %s = (%g; %g; %g) (0x%02X)&quot;,
+		padding + (strlen(padding) - local-&gt;level) + 1,
+		var, val[0], val[1], val[2], flags);
+
+	if(local-&gt;object)
+		maya_var_set((MayaObject *)local-&gt;object, var, val);
+	else
+		g_free(val);
+
+	g_free(var);
+
+	return TRUE;
+}
+
+/* mesh */
+gboolean maya_cb_MESH(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	G3DMaterial *material;
+	G3DFace *face;
+	gint32 x1, x2, x3, x4, i, i1, i2;
+
+	x1 = g3d_read_int16_be(global-&gt;f);
+	x2 = g3d_read_int16_be(global-&gt;f);
+	x3 = g3d_read_int16_be(global-&gt;f);
+	x4 = g3d_read_int16_be(global-&gt;f);
+	local-&gt;nb -= 8;
+
+	object = (G3DObject *)((MayaObject *)local-&gt;object)-&gt;user_data;
+	material = (G3DMaterial *)g_slist_nth_data(object-&gt;materials, 0);
+
+	if(x1 == 0x6369)
+	{
+		object-&gt;vertex_count = x4 / 3;
+		object-&gt;vertex_data = g_new0(gfloat, object-&gt;vertex_count * 3);
+
+		for(i = 0; i &lt; object-&gt;vertex_count; i ++)
+		{
+			object-&gt;vertex_data[i * 3 + 0] = g3d_read_float_be(global-&gt;f);
+			object-&gt;vertex_data[i * 3 + 1] = g3d_read_float_be(global-&gt;f);
+			object-&gt;vertex_data[i * 3 + 2] = g3d_read_float_be(global-&gt;f);
+			local-&gt;nb -= 12;
+		}
+
+		x3 = g3d_read_int16_be(global-&gt;f);
+		x4 = g3d_read_int16_be(global-&gt;f);
+		local-&gt;nb -= 4;
+#if 0
+		g_debug(&quot;[Maya][MESH] %d %d&quot;, x3, x4);
+#endif
+		i1 = -1;
+		i2 = -1;
+		for(i = 0; i &lt; x4 / 2; i ++)
+		{
+			if(i1 == -1)
+			{
+				i1 = g3d_read_int32_be(global-&gt;f) &amp; 0xFFFFFF;
+				i2 = g3d_read_int32_be(global-&gt;f) &amp; 0xFFFFFF;
+				local-&gt;nb -= 8;
+			}
+			else
+			{
+				face = g_new0(G3DFace, 1);
+				face-&gt;vertex_count = 4;
+				face-&gt;vertex_indices = g_new0(guint32, 4);
+				face-&gt;vertex_indices[0] = i1;
+				face-&gt;vertex_indices[1] = i2;
+				face-&gt;vertex_indices[2] =
+					g3d_read_int32_be(global-&gt;f) &amp; 0xFFFFFF;
+				face-&gt;vertex_indices[3] =
+					g3d_read_int32_be(global-&gt;f) &amp; 0xFFFFFF;
+				face-&gt;material = material;
+				local-&gt;nb -= 8;
+				i1 = face-&gt;vertex_indices[3];
+				i2 = face-&gt;vertex_indices[2];
+
+				object-&gt;faces = g_slist_append(object-&gt;faces, face);
+			}
+		}
+
+		x3 = g3d_read_int16_be(global-&gt;f);
+		x4 = g3d_read_int16_be(global-&gt;f);
+		local-&gt;nb -= 4;
+	}
+	return TRUE;
+}
+
+/* poly cube */
+gboolean maya_cb_PCUB(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	MayaObject *obj;
+	G3DObject *object;
+	G3DMaterial *material;
+	gdouble w, h, d;
+
+	if(local-&gt;finalize)
+	{
+		obj = (MayaObject *)local-&gt;object;
+		g_return_val_if_fail(obj != NULL, FALSE);
+
+		w = maya_var_get_double(obj, &quot;sw&quot;, 1.0);
+		h = maya_var_get_double(obj, &quot;sh&quot;, 1.0);
+		d = maya_var_get_double(obj, &quot;sd&quot;, 1.0);
+
+		material = g3d_material_new();
+		object = g3d_primitive_cube(w, h, d, material);
+		object-&gt;name = obj-&gt;name ? g_strdup(obj-&gt;name) : &quot;(unnamed cube)&quot;;
+
+		object-&gt;materials = g_slist_append(object-&gt;materials, material);
+		maya_obj_add_to_tree(obj, global-&gt;model, object);
+
+		/* destroy object */
+		maya_obj_free(obj);
+	}
+	else
+	{
+		/* create object */
+		obj = maya_obj_new();
+		local-&gt;object = obj;
+	}
+
+	return TRUE;
+}
+
+/* string */
+gboolean maya_cb_STR_(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gchar *buffer, *var;
+	gchar *padding = &quot;                       &quot;;
+
+	/* variable */
+	buffer = g_malloc(local-&gt;nb);
+	local-&gt;nb -= g3d_read_cstr(global-&gt;f, buffer, local-&gt;nb);
+	var = g_strdup(buffer);
+
+	/* value */
+	local-&gt;nb -= g3d_read_cstr(global-&gt;f, buffer, local-&gt;nb);
+
+	g_debug(&quot;%s[Maya][STR ] %s = '%.*s' (%d characters)&quot;,
+		padding + (strlen(padding) - local-&gt;level) + 1,
+		var, 40, buffer, strlen(buffer));
+
+	if(local-&gt;object)
+		maya_var_set((MayaObject *)local-&gt;object, var, g_strdup(buffer));
+
+	g_free(buffer);
+	g_free(var);
+
+	return TRUE;
+}
+
+/* transformation */
+gboolean maya_cb_XFRM(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	MayaObject *obj;
+	G3DObject *object;
+	G3DTransformation *tf;
+	gdouble *val;
+
+	if(local-&gt;finalize)
+	{
+		obj = (MayaObject *)local-&gt;object;
+
+		object = maya_obj_to_g3d(obj);
+
+		tf = g_new0(G3DTransformation, 1);
+		g3d_matrix_identity(tf-&gt;matrix);
+
+		val = maya_var_get(obj, &quot;t&quot;);
+		if(val)
+			g3d_matrix_translate(val[0], val[1], val[2], tf-&gt;matrix);
+
+		val = maya_var_get(obj, &quot;r&quot;);
+		if(val)
+			g3d_matrix_rotate_xyz(val[0], val[1], val[2], tf-&gt;matrix);
+
+		val = maya_var_get(obj, &quot;s&quot;);
+		if(val)
+			g3d_matrix_scale(val[0], val[1], val[2], tf-&gt;matrix);
+
+		/* g3d_matrix_dump(tf-&gt;matrix); */
+
+		object-&gt;transformation = tf;
+
+		maya_obj_add_to_tree(obj, global-&gt;model, object);
+
+		maya_obj_free(obj);
+	}
+	else
+	{
+		obj = maya_obj_new();
+		local-&gt;object = obj;
+	}
+
+	return TRUE;
+}

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,19 @@
+#ifndef _IMP_MAYA_CALLBACKS_H
+#define _IMP_MAYA_CALLBACKS_H
+
+#include &lt;g3d/iff.h&gt;
+
+gboolean maya_cb_CMPD(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_CREA(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_DBLn(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_DBL2(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_DBL3(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_DBLE(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_DMSH(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_FLT3(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_MESH(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_PCUB(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_STR_(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_XFRM(g3d_iff_gdata *global, g3d_iff_ldata *local);
+
+#endif /* _IMP_MAYA_CALLBACKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_chunks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_chunks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_chunks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,109 @@
+#ifndef _IMP_MAYA_CHUNKS_H
+#define _IMP_MAYA_CHUNKS_H
+
+#include &lt;g3d/iff.h&gt;
+
+#include &quot;imp_maya_callbacks.h&quot;
+
+static g3d_iff_chunk_info maya_chunks[] = {
+	{ &quot;ATTR&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;AUDI&quot;, &quot;audio&quot;,                             1, NULL }, /* FOR4 */
+	{ &quot;AUNI&quot;, &quot;angle unit&quot;,                        0, NULL },
+	{ &quot;BRSH&quot;, &quot;brush&quot;,                             1, NULL }, /* FOR4 */
+	{ &quot;CHNG&quot;, &quot;changes&quot;,                           0, NULL },
+	{ &quot;CMP#&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;CMPD&quot;, &quot;compound&quot;,                          0, maya_cb_CMPD },
+	{ &quot;CONN&quot;, &quot;unknown&quot;,                           1, NULL }, /* FOR4 */
+	{ &quot;CONS&quot;, &quot;unknown&quot;,                           1, NULL }, /* LIS4 */
+	{ &quot;CWFL&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;CREA&quot;, &quot;creator&quot;,                           0, maya_cb_CREA },
+	{ &quot;DBL#&quot;, &quot;double #&quot;,                          0, maya_cb_DBLn },
+	{ &quot;DBL2&quot;, &quot;double 2&quot;,                          0, maya_cb_DBL2 },
+	{ &quot;DBL3&quot;, &quot;double 3&quot;,                          0, maya_cb_DBL3 },
+	{ &quot;DBLE&quot;, &quot;double&quot;,                            0, maya_cb_DBLE },
+	{ &quot;DCAM&quot;, &quot;camera&quot;,                            1, NULL }, /* FOR4 */
+	{ &quot;DECT&quot;, &quot;delete component&quot;,                  1, NULL }, /* FOR4 */
+	{ &quot;DELA&quot;, &quot;unknown&quot;,                           1, NULL }, /* FOR4 */
+	{ &quot;DELL&quot;, &quot;unknown&quot;,                           1, NULL }, /* LIS4 */
+	{ &quot;DISC&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;DISL&quot;, &quot;unknown&quot;,                           1, NULL }, /* LIS4 */
+	{ &quot;DMSH&quot;, &quot;mesh&quot;,                              1, maya_cb_DMSH },
+	{ &quot;DMTI&quot;, &quot;material info&quot;,                     1, NULL }, /* FOR4 */
+	{ &quot;DPLM&quot;, &quot;layer manager&quot;,                     1, NULL }, /* FOR4 */
+	{ &quot;DSPL&quot;, &quot;layer ?&quot;,                           1, NULL }, /* FOR4 */
+	{ &quot;FINF&quot;, &quot;file information&quot;,                  0, maya_cb_STR_ },
+	{ &quot;FDFL&quot;, &quot;flare ?&quot;,                           1, NULL }, /* FOR4 */
+	{ &quot;FLGS&quot;, &quot;flags&quot;,                             0, NULL },
+	{ &quot;FLT2&quot;, &quot;float 2&quot;,                           0, NULL },
+	{ &quot;FLT3&quot;, &quot;float 3&quot;,                           0, maya_cb_FLT3 },
+	{ &quot;FMPT&quot;, &quot;unknown&quot;,                           1, NULL }, /* FOR4 */
+	{ &quot;FNLD&quot;, &quot;unknown&quot;,                           1, NULL }, /* FOR4 */
+	{ &quot;GPID&quot;, &quot;group id&quot;,                          1, NULL }, /* FOR4 */
+	{ &quot;GRPP&quot;, &quot;group parts&quot;,                       1, NULL }, /* FOR4 */
+	{ &quot;HEAD&quot;, &quot;header&quot;,                            1, NULL }, /* FOR4 */
+	{ &quot;ICON&quot;, &quot;icon&quot;,                              0, NULL },
+	{ &quot;INCL&quot;, &quot;includes&quot;,                          0, NULL },
+	{ &quot;INFO&quot;, &quot;information&quot;,                       0, NULL },
+	{ &quot;LUNI&quot;, &quot;length unit&quot;,                       0, NULL },
+	{ &quot;MADE&quot;, &quot;creation date&quot;,                     0, NULL },
+	{ &quot;MATR&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;MESH&quot;, &quot;mesh&quot;,                              0, maya_cb_MESH },
+	{ &quot;NPLN&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;NRBS&quot;, &quot;NURBS ?&quot;,                           0, NULL },
+	{ &quot;NSRF&quot;, &quot;surface&quot;,                           1, NULL }, /* FOR4 */
+	{ &quot;OBJN&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;OBST&quot;, &quot;unknown&quot;,                           1, NULL }, /* FOR4 */
+	{ &quot;PAUP&quot;, &quot;poly auto proj&quot;,                    1, NULL }, /* FOR4 */
+	{ &quot;PBOP&quot;, &quot;poly boolean operation&quot;,            1, NULL }, /* FOR4 */
+	{ &quot;PBVL&quot;, &quot;poly bevel&quot;,                        1, NULL }, /* FOR4 */
+	{ &quot;PCRE&quot;, &quot;poly create face&quot;,                  1, NULL }, /* FOR4 */
+	{ &quot;PCTA&quot;, &quot;poly rotate ?&quot;,                     1, NULL }, /* FOR4 */
+	{ &quot;PCTL&quot;, &quot;poly translate ?&quot;,                  1, NULL }, /* FOR4 */
+	{ &quot;PCTU&quot;, &quot;poly scale ?&quot;,                      1, NULL }, /* FOR4 */
+	{ &quot;PCUB&quot;, &quot;poly cube&quot;,                         1, maya_cb_PCUB },
+	{ &quot;PCYL&quot;, &quot;poly cylinder&quot;,                     1, NULL }, /* FOR4 */
+	{ &quot;PEXE&quot;, &quot;poly extrude&quot;,                      1, NULL }, /* FOR4 */
+	{ &quot;PEXF&quot;, &quot;poly extrude face&quot;,                 1, NULL }, /* FOR4 */
+	{ &quot;PFUV&quot;, &quot;poly flip UV&quot;,                      1, NULL }, /* FOR4 */
+	{ &quot;PING&quot;, &quot;unknown&quot;,                           1, NULL }, /* FOR4 */
+	{ &quot;PLUG&quot;, &quot;plugin ?&quot;,                          0, NULL },
+	{ &quot;PMIR&quot;, &quot;poly mirror&quot;,                       1, NULL }, /* FOR4 */
+	{ &quot;PMVE&quot;, &quot;poly merge vertices&quot;,               1, NULL }, /* FOR4 */
+	{ &quot;PPCT&quot;, &quot;poly cut&quot;,                          1, NULL }, /* FOR4 */
+	{ &quot;PPIP&quot;, &quot;poly pipe&quot;,                         1, NULL }, /* FOR4 */
+	{ &quot;PRNS&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;PRNT&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;PSEP&quot;, &quot;poly separate&quot;,                     1, NULL }, /* FOR4 */
+	{ &quot;PSMF&quot;, &quot;poly smooth face&quot;,                  1, NULL }, /* FOR4 */
+	{ &quot;PSOE&quot;, &quot;poly soft edge&quot;,                    1, NULL }, /* FOR4 */
+	{ &quot;PSPH&quot;, &quot;poly sphere&quot;,                       1, NULL }, /* FOR4 */
+	{ &quot;PSPL&quot;, &quot;poly split&quot;,                        1, NULL }, /* FOR4 */
+	{ &quot;PTRI&quot;, &quot;poly triangulate&quot;,                  1, NULL }, /* FOR4 */
+	{ &quot;PTUV&quot;, &quot;poly tweak UV&quot;,                     1, NULL }, /* FOR4 */
+	{ &quot;PTWK&quot;, &quot;poly tweak&quot;,                        1, NULL }, /* FOR4 */
+	{ &quot;PUNI&quot;, &quot;poly unite&quot;,                        1, NULL }, /* FOR4 */
+	{ &quot;RANI&quot;, &quot;anisotropic&quot;,                       1, NULL }, /* FOR4 */
+	{ &quot;RBLN&quot;, &quot;unknown&quot;,                           1, NULL }, /* FOR4 */
+	{ &quot;RLAM&quot;, &quot;lambert&quot;,                           1, NULL }, /* FOR4 */
+	{ &quot;RLLK&quot;, &quot;light linker&quot;,                      1, NULL }, /* FOR4 */
+	{ &quot;RNDL&quot;, &quot;render layer&quot;,                      1, NULL }, /* FOR4 */
+	{ &quot;RNLM&quot;, &quot;render layer manager&quot;,              1, NULL }, /* FOR4 */
+	{ &quot;RPHO&quot;, &quot;phong ?&quot;,                           1, NULL }, /* FOR4 */
+	{ &quot;RPL2&quot;, &quot;place texture&quot;,                     1, NULL }, /* FOR4 */
+	{ &quot;RPLD&quot;, &quot;place texture&quot;,                     1, NULL }, /* FOR4 */
+	{ &quot;RPRJ&quot;, &quot;projection&quot;,                        1, NULL }, /* FOR4 */
+	{ &quot;RTFT&quot;, &quot;texture file&quot;,                      1, NULL }, /* FOR4 */
+	{ &quot;SCRP&quot;, &quot;script&quot;,                            1, NULL }, /* FOR4 */
+	{ &quot;SHAD&quot;, &quot;shadow&quot;,                            1, NULL }, /* FOR4 */
+	{ &quot;SLCT&quot;, &quot;unknown&quot;,                           0, NULL }, /* evil ;) */
+	{ &quot;STR &quot;, &quot;string&quot;,                            0, maya_cb_STR_ },
+	{ &quot;TGEO&quot;, &quot;transform geometry&quot;,                1, NULL }, /* FOR4 */
+	{ &quot;TUNI&quot;, &quot;time unit&quot;,                         0, NULL },
+	{ &quot;UVER&quot;, &quot;minor version?&quot;,                    0, NULL },
+	{ &quot;VERS&quot;, &quot;version&quot;,                           0, NULL },
+	{ &quot;XFRM&quot;, &quot;transformation&quot;,                    1, maya_cb_XFRM },
+
+	{ NULL, NULL, 0, NULL }
+};
+
+#endif /* _IMP_MAYA_CHUNKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_obj.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_obj.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_obj.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,89 @@
+#include &lt;string.h&gt;
+
+#include &lt;g3d/model.h&gt;
+
+#include &quot;imp_maya_obj.h&quot;
+
+MayaObject *maya_obj_new(void)
+{
+	MayaObject *obj;
+
+	obj = g_new0(MayaObject, 1);
+	obj-&gt;vars = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+
+	return obj;
+}
+
+void maya_obj_free(MayaObject *obj)
+{
+	g_hash_table_destroy(obj-&gt;vars);
+	if(obj-&gt;name) g_free(obj-&gt;name);
+	g_free(obj);
+}
+
+G3DObject *maya_obj_to_g3d(MayaObject *obj)
+{
+	G3DObject *object;
+
+	object = g_new0(G3DObject, 1);
+	object-&gt;name = obj-&gt;name ? g_strdup(obj-&gt;name) : &quot;(unnamed)&quot;;
+
+	return object;
+}
+
+static G3DObject *get_by_path(G3DModel *model, gchar *path)
+{
+	gchar **parts, **partp;
+	G3DObject *object = NULL;
+	GSList *olist;
+
+	partp = parts = g_strsplit(path, &quot;|&quot;, 0);
+	olist = model-&gt;objects;
+	while(*partp)
+	{
+		while(olist)
+		{
+			object = (G3DObject *)olist-&gt;data;
+
+			if(strcmp(object-&gt;name, *partp) == 0) break;
+
+			olist = olist-&gt;next;
+			object = NULL;
+		}
+
+		if(object == NULL) return NULL;
+
+		partp ++;
+		olist = object-&gt;objects;
+	}
+
+	g_strfreev(parts);
+
+	return object;
+}
+
+gboolean maya_obj_add_to_tree(MayaObject *obj, G3DModel *model,
+	G3DObject *object)
+{
+	G3DObject *parent = NULL;
+
+	if(obj-&gt;parent)
+	{
+		if(*(obj-&gt;parent) == '|')
+			parent = get_by_path(model, obj-&gt;parent + 1);
+		else
+			parent = g3d_model_get_object_by_name(model, obj-&gt;parent);
+
+		if(parent == NULL)
+			g_warning(
+				&quot;[Maya] maya_obj_add_to_tree: parent object '%s' not found&quot;,
+				obj-&gt;parent);
+	}
+
+	if(parent != NULL)
+		parent-&gt;objects = g_slist_append(parent-&gt;objects, object);
+	else
+		model-&gt;objects = g_slist_append(model-&gt;objects, object);
+
+	return TRUE;
+}

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_obj.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_obj.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_obj.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,20 @@
+#ifndef _IMP_MAYA_OBJ_H
+#define _IMP_MAYA_OBJ_H
+
+#include &lt;glib.h&gt;
+#include &lt;g3d/types.h&gt;
+
+typedef struct {
+	gchar *name;
+	gchar *parent;
+	GHashTable *vars;
+	gpointer user_data;
+} MayaObject;
+
+MayaObject *maya_obj_new(void);
+void maya_obj_free(MayaObject *obj);
+G3DObject *maya_obj_to_g3d(MayaObject *obj);
+gboolean maya_obj_add_to_tree(MayaObject *obj, G3DModel *model,
+	G3DObject *object);
+
+#endif /* _IMP_MAYA_OBJ_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_var.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_var.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_var.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,39 @@
+#include &lt;glib.h&gt;
+
+#include &quot;imp_maya_obj.h&quot;
+
+gboolean maya_var_set(MayaObject *obj, const gchar *var, gpointer value)
+{
+	g_hash_table_replace(obj-&gt;vars, g_strdup(var), value);
+
+	return TRUE;
+}
+
+gpointer maya_var_get(MayaObject *obj, const gchar *var)
+{
+	gpointer val;
+
+	val = g_hash_table_lookup(obj-&gt;vars, var);
+	return val;
+}
+
+gboolean maya_var_set_double(MayaObject *obj, const gchar *var, gdouble value)
+{
+	gdouble *pval;
+
+	pval = g_new0(gdouble, 1);
+	*pval = value;
+
+	return maya_var_set(obj, var, pval);
+}
+
+gdouble maya_var_get_double(MayaObject *obj, const gchar *var, gdouble defval)
+{
+	gdouble *pval;
+
+	pval = maya_var_get(obj, var);
+	if(pval == NULL)
+		return defval;
+
+	return *pval;
+}

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_var.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_var.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_var.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,12 @@
+#ifndef _IMP_MAYA_VAR_H
+#define _IMP_MAYA_VAR_H
+
+#include &quot;imp_maya_obj.h&quot;
+
+gboolean maya_var_set(MayaObject *obj, const gchar *var, gpointer value);
+gpointer maya_var_get(MayaObject *obj, const gchar *var);
+
+gboolean maya_var_set_double(MayaObject *obj, const gchar *var, gdouble value);
+gdouble maya_var_get_double(MayaObject *obj, const gchar *var, gdouble defval);
+
+#endif /* _IMP_MAYA_VAR_H */

Modified: trunk/libs3d/libg3d/plugins/import/imp_obj.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_obj.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_obj.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -31,6 +31,7 @@
 
 static G3DObject *obj_createobject(G3DModel *model, const gchar *name);
 static gboolean obj_tryloadmat(G3DModel *model, const gchar *filename);
+static G3DMaterial *obj_usemat(G3DModel *model, const gchar *matname);
 
 gboolean plugin_load_model(G3DContext *context, const gchar *filename,
 	G3DModel *model, gpointer user_data)
@@ -75,6 +76,7 @@
 					}
 					else if(sscanf(line, &quot;g %s&quot;, oname) == 1)
 					{
+						material = obj_usemat(model, oname);
 #if 0
 						object = obj_createobject(model, oname);
 						v_off += v_cnt;
@@ -158,18 +160,7 @@
 				case 's':
 					if(sscanf(line, &quot;usemtl %s&quot;, matname) == 1)
 					{
-						/* sets new active material from named list */
-						GSList *mlist = model-&gt;materials;
-						while(mlist != NULL)
-						{
-							G3DMaterial *mat = (G3DMaterial*)mlist-&gt;data;
-							if(strcmp(matname, mat-&gt;name) == 0)
-							{
-								material = mat;
-								break;
-							}
-							mlist = mlist-&gt;next;
-						}
+						material = obj_usemat(model, matname);
 					}
 					else if(sscanf(line, &quot;mtllib %s&quot;, matfile) == 1)
 					{
@@ -227,7 +218,7 @@
 	if(f == NULL)
 	{
 #if DEBUG &gt; 1
-		g_printerr(&quot;obj_tryloadmat: loading '%s' failed: %s\n&quot;, filename, 
+		g_printerr(&quot;obj_tryloadmat: loading '%s' failed: %s\n&quot;, filename,
 							 strerror(errno));
 #endif
 		return FALSE;
@@ -240,7 +231,7 @@
 		char line[2048];
 		float r,g,b, t1,t2, ni;
 		int tf, ns, il;
-	 
+
 		fgets(line, 2048, f);
 		if(strlen(line))
 		{
@@ -294,3 +285,21 @@
 	}
 	return TRUE;
 }
+
+G3DMaterial *obj_usemat(G3DModel *model, const gchar *matname)
+{
+	/* sets new active material from named list */
+	GSList *mlist = model-&gt;materials;
+	while(mlist != NULL)
+	{
+		G3DMaterial *mat = (G3DMaterial*)mlist-&gt;data;
+		if(strcmp(matname, mat-&gt;name) == 0)
+		{
+			return mat;
+		}
+		mlist = mlist-&gt;next;
+	}
+
+	return NULL;
+}
+

Added: trunk/libs3d/libg3d/plugins/import/imp_r4.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_r4.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_r4.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,77 @@
+/* $Id: imp_iob.c,v 1.1.2.2 2006/01/23 17:03:06 dahms Exp $ */
+
+/*
+    libg3d - 3D object loading library
+
+    Copyright (C) 2005, 2006  Markus Dahms &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">mad at automagically.de</A>&gt;
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;glib.h&gt;
+
+#include &lt;g3d/iff.h&gt;
+
+#include &quot;imp_r4_chunks.h&quot;
+
+gboolean plugin_load_model(G3DContext *context, const gchar *filename,
+	G3DModel *model, gpointer user_data)
+{
+	g3d_iff_gdata *global;
+	g3d_iff_ldata *local;
+	guint32 id, len;
+	FILE *f;
+
+	f = g3d_iff_open(filename, &amp;id, &amp;len);
+	if(id != G3D_IFF_MKID('R','E','F','L'))
+	{
+		g_warning(&quot;file is not an .r4 (REFL) file %s&quot;, filename);
+		fclose(f);
+		return FALSE;
+	}
+
+	local = g_new0(g3d_iff_ldata, 1);
+	global = g_new0(g3d_iff_gdata, 1);
+
+	global-&gt;context = context;
+	global-&gt;model = model;
+	global-&gt;f = f;
+
+	local-&gt;parent_id = id;
+	local-&gt;nb = len;
+
+	g3d_iff_read_ctnr(global, local, r4_chunks, G3D_IFF_PAD1);
+
+	g_free(local);
+	g_free(global);
+
+	return TRUE;
+}
+
+gchar *plugin_description(void)
+{
+	return g_strdup(
+		&quot;import plugin for Reflections R4\n&quot;);
+}
+
+gchar **plugin_extensions(void)
+{
+	return g_strsplit(&quot;r4&quot;, &quot;:&quot;, 0);
+}
+
+

Added: trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,49 @@
+#include &lt;g3d/iff.h&gt;
+#include &lt;g3d/read.h&gt;
+
+#include &quot;imp_r4_chunks.h&quot;
+
+/* camera related */
+gboolean r4_cb_RKA2(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	guint32 chunk_id, chunk_len;
+	g3d_iff_ldata *sublocal;
+
+	/* RGE1 chunk */
+	g3d_iff_readchunk(global-&gt;f, &amp;chunk_id, &amp;chunk_len, 0);
+	local-&gt;nb -= 8;
+
+	sublocal = g_new0(g3d_iff_ldata, 1);
+	sublocal-&gt;parent_id = local-&gt;id;
+	sublocal-&gt;id = chunk_id;
+	sublocal-&gt;object = local-&gt;object;
+	sublocal-&gt;level = local-&gt;level + 1;
+	sublocal-&gt;nb = chunk_len;
+	g3d_iff_read_ctnr(global, sublocal, r4_chunks, G3D_IFF_PAD1);
+	g_free(sublocal);
+
+	/* more stuff... */
+	/* TODO: */
+
+	return TRUE;
+}
+
+/* object name */
+gboolean r4_cb_ROBJ(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gchar buffer[512];
+	gint32 len;
+
+	len = g3d_read_int16_be(global-&gt;f);
+	local-&gt;nb -= 2;
+
+	fread(buffer, 1, len, global-&gt;f);
+	local-&gt;nb -= len;
+	buffer[len] = '\0';
+
+#if DEBUG &gt; 0
+	g_printerr(&quot;[R4] ROBJ: %s\n&quot;, buffer);
+#endif
+
+	return TRUE;
+}

Added: trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,9 @@
+#ifndef _G3D_R4_CALLBACKS_H
+#define _G3D_R4_CALLBACKS_H
+
+#include &lt;g3d/iff.h&gt;
+
+gboolean r4_cb_RKA2(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean r4_cb_ROBJ(g3d_iff_gdata *global, g3d_iff_ldata *local);
+
+#endif /* _G3D_R4_CALLBACKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_r4_chunks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_r4_chunks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_r4_chunks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,25 @@
+#ifndef _IMP_R4_CHUNKS_H
+#define _IMP_R4_CHUNKS_H
+
+#include &lt;g3d/iff.h&gt;
+
+#include &quot;imp_r4_callbacks.h&quot;
+
+static g3d_iff_chunk_info r4_chunks[] = {
+	{ &quot;INFO&quot;, &quot;information&quot;,                       0, NULL },
+	{ &quot;DRE2&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;GMAT&quot;, &quot;unknown&quot;,                           1, NULL },
+	{ &quot;KSYS&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;LGH3&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;PKTM&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;RGE1&quot;, &quot;unknown&quot;,                           1, NULL },
+	{ &quot;RKA2&quot;, &quot;unknown&quot;,                           0, r4_cb_RKA2 },
+	{ &quot;ROBJ&quot;, &quot;unknown&quot;,                           0, r4_cb_ROBJ },
+	{ &quot;SURF&quot;, &quot;unknown&quot;,                           0, NULL },
+	{ &quot;TXM1&quot;, &quot;unknown&quot;,                           1, NULL },
+	{ &quot;TXO1&quot;, &quot;unknown&quot;,                           0, NULL },
+
+	{ NULL, NULL, 0, NULL }
+};
+
+#endif /* _IMP_R4_CHUNKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_test.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_test.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_test.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,91 @@
+/* $Id:$ */
+
+/*
+    libg3d - 3D object loading library
+
+    Copyright (C) 2005, 2006  Markus Dahms &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">mad at automagically.de</A>&gt;
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include &lt;g3d/types.h&gt;
+#include &lt;g3d/context.h&gt;
+#include &lt;g3d/material.h&gt;
+#include &lt;g3d/matrix.h&gt;
+#include &lt;g3d/primitive.h&gt;
+#include &lt;g3d/object.h&gt;
+
+/*****************************************************************************/
+/* plugin interface                                                          */
+/*****************************************************************************/
+
+gboolean plugin_load_model(G3DContext *context, const gchar *filename,
+	G3DModel *model, gpointer user_data)
+{
+	G3DObject *sphere, *cntr;
+	G3DMaterial *material;
+	G3DTransformation *tf;
+	gfloat matrix[16];
+	gint32 i, j;
+
+	cntr = g_new0(G3DObject, 1);
+	cntr-&gt;name = g_strdup(&quot;container&quot;);
+
+	tf = g_new0(G3DTransformation, 1);
+	g3d_matrix_identity(tf-&gt;matrix);
+	g3d_matrix_scale(1.0, 1.0, 2.0, tf-&gt;matrix);
+	cntr-&gt;transformation = tf;
+	model-&gt;objects = g_slist_append(model-&gt;objects, cntr);
+
+	material = g3d_material_new();
+	model-&gt;materials = g_slist_append(model-&gt;materials, material);
+
+	/* 1 */
+	sphere = g3d_primitive_sphere(1.0, 36, 36, material);
+	cntr-&gt;objects = g_slist_append(cntr-&gt;objects, sphere);
+
+	/* 2 */
+	sphere = g3d_primitive_sphere(1.0, 6, 6, material);
+	cntr-&gt;objects = g_slist_append(cntr-&gt;objects, sphere);
+
+	tf = g_new0(G3DTransformation, 1);
+	g3d_matrix_identity(tf-&gt;matrix);
+	g3d_matrix_translate(2.5, 1.0, 1.0, tf-&gt;matrix);
+	sphere-&gt;transformation = tf;
+
+	/* 3 */
+	sphere = g3d_primitive_sphere(1.0, 12, 12, material);
+	cntr-&gt;objects = g_slist_append(cntr-&gt;objects, sphere);
+
+	g3d_matrix_identity(matrix);
+	g3d_matrix_translate(5, 2.0, 2.0, matrix);
+	g3d_matrix_scale(2.0, 2.0, 1.0, matrix);
+	g3d_object_transform(sphere, matrix);
+
+	return TRUE;
+}
+
+gchar *plugin_description(G3DContext *context)
+{
+	return g_strdup(
+		&quot;Test plugin\n&quot;
+		);
+}
+
+gchar **plugin_extensions(G3DContext *context)
+{
+	return g_strsplit(&quot;test&quot;, &quot;:&quot;, 0);
+}
+

Modified: trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.l
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.l	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.l	2006-09-15 16:23:16 UTC (rev 381)
@@ -309,23 +309,23 @@
 	{
 		if(sscanf(yytext, &quot;%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f&quot;,
 			&amp;matrix[0 * 4 + 0],
+			&amp;matrix[0 * 4 + 1],
+			&amp;matrix[0 * 4 + 2],
+			&amp;matrix[0 * 4 + 3],
+
 			&amp;matrix[1 * 4 + 0],
+            &amp;matrix[1 * 4 + 1],
+            &amp;matrix[1 * 4 + 2],
+            &amp;matrix[1 * 4 + 3],
+
 			&amp;matrix[2 * 4 + 0],
+            &amp;matrix[2 * 4 + 1],
+            &amp;matrix[2 * 4 + 2],
+            &amp;matrix[2 * 4 + 3],
+
 			&amp;matrix[3 * 4 + 0],
-
-			&amp;matrix[0 * 4 + 1],
-            &amp;matrix[1 * 4 + 1],
-            &amp;matrix[2 * 4 + 1],
             &amp;matrix[3 * 4 + 1],
-
-			&amp;matrix[0 * 4 + 2],
-            &amp;matrix[1 * 4 + 2],
-            &amp;matrix[2 * 4 + 2],
             &amp;matrix[3 * 4 + 2],
-
-			&amp;matrix[0 * 4 + 3],
-            &amp;matrix[1 * 4 + 3],
-            &amp;matrix[2 * 4 + 3],
             &amp;matrix[3 * 4 + 3]) != 16)
 		{
 			g_warning(&quot;VRML: failed to read matrix line (%s)&quot;, yytext);

Modified: trunk/libs3d/libg3d/src/iff.c
===================================================================
--- trunk/libs3d/libg3d/src/iff.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/iff.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -20,25 +20,33 @@
     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
 
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+
 #include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
 #include &lt;g3d/read.h&gt;
 #include &lt;g3d/iff.h&gt;
+#include &lt;g3d/context.h&gt;
 
 FILE *g3d_iff_open(const gchar *filename, guint32 *id, guint32 *len)
 {
 	FILE *f;
-	guint32 form_bytes;
+	guint32 form_bytes, magic;
 
 	f = fopen(filename, &quot;r&quot;);
 	if(f == NULL)
 	{
-		g_warning(&quot;can't open file '%s'&quot;, filename);
+		g_critical(&quot;can't open file '%s'&quot;, filename);
 		return NULL;
 	}
 
-	if(g3d_read_int32_be(f) != G3D_IFF_MKID('F','O','R','M'))
+	magic = g3d_read_int32_be(f);
+	if((magic != G3D_IFF_MKID('F','O','R','M')) &amp;&amp;
+		(magic != G3D_IFF_MKID('F','O','R','4')))
 	{
-		g_warning(&quot;file %s is not an IFF file&quot;, filename);
+		g_critical(&quot;file %s is not an IFF file&quot;, filename);
 		fclose(f);
 		return NULL;
 	}
@@ -51,10 +59,203 @@
 	return f;
 }
 
-int g3d_iff_readchunk(FILE *f, guint32 *id, guint32 *len)
+int g3d_iff_readchunk(FILE *f, guint32 *id, guint32 *len, guint32 flags)
 {
 	*id = g3d_read_int32_be(f);
-	*len = g3d_read_int32_be(f);
-	return 8 + *len + (*len % 2);
+	if(flags &amp; G3D_IFF_LEN16)
+	{
+		*len = g3d_read_int16_be(f);
+		return 6 + *len + (*len % 2);
+	}
+	else
+	{
+		*len = g3d_read_int32_be(f);
+		return 8 + *len + (*len % 2);
+	}
 }
 
+gchar *g3d_iff_id_to_text(guint32 id)
+{
+	gchar *tid;
+
+	tid = g_new0(gchar, 5);
+
+	tid[0] = (id &gt;&gt; 24) &amp; 0xFF;
+	tid[1] = (id &gt;&gt; 16) &amp; 0xFF;
+	tid[2] = (id &gt;&gt; 8) &amp; 0xFF;
+	tid[3] = id &amp; 0xFF;
+
+	return tid;
+}
+
+gboolean g3d_iff_chunk_matches(guint32 id, gchar *tid)
+{
+	if(((id &gt;&gt; 24) &amp; 0xFF) != tid[0]) return FALSE;
+	if(((id &gt;&gt; 16) &amp; 0xFF) != tid[1]) return FALSE;
+	if(((id &gt;&gt; 8) &amp; 0xFF) != tid[2]) return FALSE;
+	return (id &amp; 0xFF) == tid[3];
+}
+
+gboolean g3d_iff_read_ctnr(g3d_iff_gdata *global, g3d_iff_ldata *local,
+	g3d_iff_chunk_info *chunks, guint32 flags)
+{
+	g3d_iff_ldata *sublocal;
+	guint32 chunk_id, chunk_len, chunk_mod, chunk_type;
+	gint32 i;
+	gchar *tid;
+	gpointer level_object;
+	gchar *padding = &quot;                                   &quot;;
+	long int fpos;
+
+	level_object = NULL;
+
+	if(global-&gt;max_fpos == 0)
+		global-&gt;max_fpos = local-&gt;nb + 12;
+
+	while(local-&gt;nb &gt;= ((flags &amp; G3D_IFF_LEN16) ? 6 : 8))
+	{
+		chunk_id = 0;
+
+		g3d_iff_readchunk(global-&gt;f, &amp;chunk_id, &amp;chunk_len, flags);
+		local-&gt;nb -= ((flags &amp; G3D_IFF_LEN16) ? 6 : 8);
+
+		chunk_mod = flags &amp; 0x0F;
+		if(chunk_mod == 0)
+		{
+			g_warning(&quot;[IFF] mod = 0 (flags: 0x%02X\n)&quot;, flags);
+			chunk_mod = 2;
+		}
+		chunk_type = ' ';
+
+		/* handle special chunks */
+		switch(chunk_id)
+		{
+			case 0:
+			case 0xFFFFFFFF:
+				g_warning(
+					&quot;[IFF] got invalid ID, skipping %d bytes @ 0x%08x&quot;,
+					local-&gt;nb, (unsigned int)ftell(global-&gt;f));
+
+				/* skip rest of parent chunk */
+				if(local-&gt;nb &gt; 0)
+				{
+					fseek(global-&gt;f, local-&gt;nb, SEEK_CUR);
+					local-&gt;nb = 0;
+				}
+				return FALSE;
+				break;
+
+			case G3D_IFF_MKID('F','O','R','4'):
+				chunk_id = g3d_read_int32_be(global-&gt;f);
+				chunk_len -= 4;
+				chunk_mod = 4;
+				chunk_type = 'F';
+				local-&gt;nb -= 4;
+				break;
+
+			case G3D_IFF_MKID('L','I','S','4'):
+				chunk_id = g3d_read_int32_be(global-&gt;f);
+				chunk_len -= 4;
+				chunk_mod = 4;
+				chunk_type = 'L';
+				local-&gt;nb -= 4;
+				break;
+
+			default:
+				break;
+		}
+
+		i = 0;
+		while(chunks[i].id &amp;&amp; !g3d_iff_chunk_matches(chunk_id, chunks[i].id))
+			i ++;
+
+		if(chunks[i].id)
+		{
+			tid = g3d_iff_id_to_text(chunk_id);
+			g_debug(&quot;%s[%s][%c%c%c] %s (%d) - %d bytes left&quot;,
+				padding + (strlen(padding) - local-&gt;level),
+				tid,
+				chunk_type,
+				chunks[i].container ? 'c' : ' ',
+				chunks[i].callback ? 'f' : ' ',
+				chunks[i].description,
+				chunk_len,
+				local-&gt;nb);
+			g_free(tid);
+
+			sublocal = g_new0(g3d_iff_ldata, 1);
+			sublocal-&gt;parent_id = local-&gt;id;
+			sublocal-&gt;id = chunk_id;
+			sublocal-&gt;object = local-&gt;object;
+			sublocal-&gt;level = local-&gt;level + 1;
+			sublocal-&gt;level_object = level_object;
+			sublocal-&gt;nb = chunk_len;
+
+			if(chunks[i].callback)
+			{
+				chunks[i].callback(global, sublocal);
+			}
+
+			if(chunks[i].container)
+			{
+				/* LWO has 16 bit length in subchunks */
+				if(flags &amp; G3D_IFF_SUBCHUNK_LEN16)
+				{
+					g3d_iff_read_ctnr(global, sublocal, chunks,
+						flags | G3D_IFF_LEN16);
+				}
+				else
+				{
+					g3d_iff_read_ctnr(global, sublocal, chunks, flags);
+				}
+			}
+
+			if(chunks[i].container &amp;&amp; chunks[i].callback)
+			{
+				sublocal-&gt;finalize = TRUE;
+				chunks[i].callback(global, sublocal);
+			}
+
+			if(sublocal-&gt;nb &gt; 0)
+			{
+				fseek(global-&gt;f, sublocal-&gt;nb, SEEK_CUR);
+			}
+
+			level_object = sublocal-&gt;level_object;
+
+			g_free(sublocal);
+		}
+		else
+		{
+			tid = g3d_iff_id_to_text(chunk_id);
+			g_warning(&quot;[IFF] unknown chunk type \&quot;%s\&quot; (%d) @ 0x%08x&quot;,
+				tid, chunk_len, (unsigned int)ftell(global-&gt;f) - 8);
+			g_free(tid);
+			fseek(global-&gt;f, chunk_len, SEEK_CUR);
+		}
+
+		local-&gt;nb -= chunk_len;
+
+		if(chunk_len % chunk_mod)
+		{
+			fseek(global-&gt;f, chunk_mod - (chunk_len % chunk_mod), SEEK_CUR);
+			local-&gt;nb -= (chunk_mod - (chunk_len % chunk_mod));
+		}
+
+		fpos = ftell(global-&gt;f);
+		g3d_context_update_progress_bar(global-&gt;context,
+			((gfloat)fpos / (gfloat)global-&gt;max_fpos), TRUE);
+	} /* nb &gt;= 8/6 */
+
+	if(local-&gt;nb &gt; 0)
+	{
+		g_warning(&quot;[IFF] skipping %d bytes at the end of chunk&quot;,
+			local-&gt;nb);
+
+		fseek(global-&gt;f, local-&gt;nb, SEEK_CUR);
+		local-&gt;nb = 0;
+	}
+
+	return TRUE;
+}
+

Modified: trunk/libs3d/libg3d/src/matrix.c
===================================================================
--- trunk/libs3d/libg3d/src/matrix.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/matrix.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -44,11 +44,19 @@
 
 	for(i = 0; i &lt; 4; i ++)
 		for(j = 0; j &lt; 4; j ++)
+#if 0
 			matrix[i * 4 + j] =
 				m2[0 * 4 + j] * m1[i * 4 + 0] +
 				m2[1 * 4 + j] * m1[i * 4 + 1] +
 				m2[2 * 4 + j] * m1[i * 4 + 2] +
 				m2[3 * 4 + j] * m1[i * 4 + 3];
+#else
+			matrix[j * 4 + i] =
+				m2[j * 4 + 0] * m1[0 * 4 + i] +
+				m2[j * 4 + 1] * m1[1 * 4 + i] +
+				m2[j * 4 + 2] * m1[2 * 4 + i] +
+				m2[j * 4 + 3] * m1[3 * 4 + i];
+#endif
 
 	memcpy(rm, matrix, 16 * sizeof(gfloat));
 	return TRUE;
@@ -60,6 +68,7 @@
 	g3d_vector_unify(&amp;ax, &amp;ay, &amp;az);
 	g3d_matrix_identity(rm);
 
+#if 0
 	rm[0 * 4 + 0] = cos(angle) + (ax * ax) * (1 - cos(angle));
 	rm[0 * 4 + 1] = ax * ay * (1 - cos(angle)) - az * sin(angle);
 	rm[0 * 4 + 2] = ax * az * (1 - cos(angle)) + ay * sin(angle);
@@ -71,7 +80,20 @@
 	rm[2 * 4 + 0] = az * ax * (1 - cos(angle)) - ay * sin(angle);
 	rm[2 * 4 + 1] = az * ay * (1 - cos(angle)) + ax * sin(angle);
 	rm[2 * 4 + 2] = cos(angle) + (az * az) * (1 - cos(angle));
+#else
+	rm[0 * 4 + 0] = cos(angle) + (ax * ax) * (1 - cos(angle));
+	rm[1 * 4 + 0] = ax * ay * (1 - cos(angle)) - az * sin(angle);
+	rm[2 * 4 + 0] = ax * az * (1 - cos(angle)) + ay * sin(angle);
 
+	rm[0 * 4 + 1] = ay * ax * (1 - cos(angle)) + az * sin(angle);
+	rm[1 * 4 + 1] = cos(angle) + (ay * ay) * (1 - cos(angle));
+	rm[2 * 4 + 1] = ay * az * (1 - cos(angle)) - ax * sin(angle);
+
+	rm[0 * 4 + 2] = az * ax * (1 - cos(angle)) - ay * sin(angle);
+	rm[1 * 4 + 2] = az * ay * (1 - cos(angle)) + ax * sin(angle);
+	rm[2 * 4 + 2] = cos(angle) + (az * az) * (1 - cos(angle));
+#endif
+
 	return TRUE;
 }
 
@@ -97,12 +119,69 @@
 {
 	guint32 i;
 
+#if 0
 	for(i = 0; i &lt; 4; i ++)
+		rm[i * 4 + 3] =
+			rm[i * 4 + 0] * x +
+			rm[i * 4 + 1] * y +
+			rm[i * 4 + 2] * z +
+			rm[i * 4 + 3];
+#else
+	for(i = 0; i &lt; 4; i ++)
 		rm[3 * 4 + i] =
 			rm[0 * 4 + i] * x +
 			rm[1 * 4 + i] * y +
 			rm[2 * 4 + i] * z +
 			rm[3 * 4 + i];
+#endif
+	return TRUE;
+}
 
+gboolean g3d_matrix_scale(gfloat x, gfloat y, gfloat z, gfloat *rm)
+{
+	gfloat sm[16];
+
+	g3d_matrix_identity(sm);
+	sm[0] = x;
+	sm[5] = y;
+	sm[10] = z;
+
+	g3d_matrix_multiply(rm, sm, rm);
+
 	return TRUE;
 }
+
+gboolean g3d_matrix_transpose(gfloat *matrix)
+{
+	gfloat tmp[16];
+	gint32 i, j;
+
+	memcpy(tmp, matrix, 16 * sizeof(gfloat));
+
+	for(i = 0; i &lt; 4; i ++)
+		for(j = 0; j &lt; 4; j ++)
+			matrix[i * 4 + j] = tmp[j * 4 + i];
+
+	return TRUE;
+}
+
+gboolean g3d_matrix_dump(gfloat *matrix)
+{
+#if DEBUG &gt; 0
+	gint32 row, col;
+
+	for(row = 0; row &lt; 4; row ++)
+	{
+		g_printerr(&quot;[Matrix]&quot;);
+		for(col = 0; col &lt; 4; col ++)
+		{
+			g_printerr(&quot; %-2.2f&quot;, matrix[col * 4 + row]);
+		}
+		g_printerr(&quot;\n&quot;);
+	}
+
+	return TRUE;
+#else
+	return FALSE;
+#endif
+}

Modified: trunk/libs3d/libg3d/src/model.c
===================================================================
--- trunk/libs3d/libg3d/src/model.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/model.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -20,6 +20,8 @@
     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
 
+#include &lt;string.h&gt;
+
 #include &lt;g3d/types.h&gt;
 #include &lt;g3d/context.h&gt;
 #include &lt;g3d/model.h&gt;
@@ -79,58 +81,14 @@
 	}
 }
 
-G3DModel *g3d_model_load(G3DContext *context, const gchar *filename)
+static gboolean objects_check(GSList *objects)
 {
-	G3DModel *model;
-	gdouble max_rad;
-
-	model = g3d_model_new();
-
-	g3d_context_update_progress_bar(context, 0.0, TRUE);
-
-	if(g3d_plugins_load_model(context, filename, model))
-	{
-		g3d_context_update_progress_bar(context, 0.0, FALSE);
-
-		/* check model */
-		if(!g3d_model_check(model))
-		{
-			g3d_model_free(model);
-			return NULL;
-		}
-
-		/* center model */
-		g3d_model_center(model);
-
-		/* get maximum radius of all objects */
-		max_rad = objects_max_radius(model-&gt;objects);
-
-		/* scale and optimize objects */
-		objects_post_load(model-&gt;objects, max_rad);
-
-		/* save filename */
-		if(model-&gt;filename == NULL)
-			model-&gt;filename = g_strdup(filename);
-
-		return model;
-	}
-	else
-	{
-		g3d_context_update_progress_bar(context, 0.0, FALSE);
-		g3d_model_free(model);
-	}
-
-	return NULL;
-}
-
-gboolean g3d_model_check(G3DModel *model)
-{
 	G3DFace *face;
 	G3DObject *object;
 	GSList *fitem, *oitem;
 	guint32 i, no = 0, nf;
 
-	oitem = model-&gt;objects;
+	oitem = objects;
 	while(oitem)
 	{
 		object = (G3DObject *)oitem-&gt;data;
@@ -171,50 +129,110 @@
 			nf ++;
 			fitem = fitem-&gt;next;
 		} /* while(fitem) */
+
+		if(objects_check(object-&gt;objects) == FALSE)
+			return FALSE;
+
 		oitem = oitem-&gt;next;
 	} /* while(oitem) */
 	return TRUE;
+
 }
 
-gboolean g3d_model_center(G3DModel *model)
+gboolean g3d_model_check(G3DModel *model)
 {
-	gdouble min_x = 10.0e99, min_y = 10.0e99, min_z = 10.0e99;
-	gdouble max_x = -9.9e99, max_y = -9.9e99, max_z = -9.9e99;
-	gdouble off_x, off_y, off_z;
+	return objects_check(model-&gt;objects);
+}
+
+
+G3DModel *g3d_model_load(G3DContext *context, const gchar *filename)
+{
+	G3DModel *model;
+	gdouble max_rad;
+
+	model = g3d_model_new();
+
+	g3d_context_update_progress_bar(context, 0.0, TRUE);
+
+	if(g3d_plugins_load_model(context, filename, model))
+	{
+		g3d_context_update_progress_bar(context, 0.0, FALSE);
+
+		/* check model */
+		if(!g3d_model_check(model))
+		{
+			g3d_model_free(model);
+			return NULL;
+		}
+
+		/* center model */
+		g3d_model_center(model);
+
+		/* get maximum radius of all objects */
+		max_rad = objects_max_radius(model-&gt;objects);
+
+		/* scale and optimize objects */
+		objects_post_load(model-&gt;objects, max_rad);
+
+		/* save filename */
+		if(model-&gt;filename == NULL)
+			model-&gt;filename = g_strdup(filename);
+
+		return model;
+	}
+	else
+	{
+		g3d_context_update_progress_bar(context, 0.0, FALSE);
+		g3d_model_free(model);
+	}
+
+	return NULL;
+}
+
+static void objects_max_extension(GSList *objects,
+	gdouble *min_x, gdouble *min_y, gdouble *min_z,
+	gdouble *max_x,	gdouble *max_y, gdouble *max_z)
+{
 	GSList *oitem;
 	G3DObject *object;
 	guint32 i;
 
-	/* determine maximum extension */
-	oitem = model-&gt;objects;
+	oitem = objects;
 	while(oitem)
 	{
 		object = (G3DObject *)oitem-&gt;data;
 		for(i = 0; i &lt; object-&gt;vertex_count; i ++)
 		{
-			if(object-&gt;vertex_data[i * 3 + 0] &lt; min_x)
-				min_x = object-&gt;vertex_data[i * 3 + 0];
-			if(object-&gt;vertex_data[i * 3 + 1] &lt; min_y)
-				min_y = object-&gt;vertex_data[i * 3 + 1];
-			if(object-&gt;vertex_data[i * 3 + 2] &lt; min_z)
-				min_z = object-&gt;vertex_data[i * 3 + 2];
+			if(object-&gt;vertex_data[i * 3 + 0] &lt; *min_x)
+				*min_x = object-&gt;vertex_data[i * 3 + 0];
+			if(object-&gt;vertex_data[i * 3 + 1] &lt; *min_y)
+				*min_y = object-&gt;vertex_data[i * 3 + 1];
+			if(object-&gt;vertex_data[i * 3 + 2] &lt; *min_z)
+				*min_z = object-&gt;vertex_data[i * 3 + 2];
 
-			if(object-&gt;vertex_data[i * 3 + 0] &gt; max_x)
-				max_x = object-&gt;vertex_data[i * 3 + 0];
-			if(object-&gt;vertex_data[i * 3 + 1] &gt; max_y)
-				max_y = object-&gt;vertex_data[i * 3 + 1];
-			if(object-&gt;vertex_data[i * 3 + 2] &gt; max_z)
-				max_z = object-&gt;vertex_data[i * 3 + 2];
+			if(object-&gt;vertex_data[i * 3 + 0] &gt; *max_x)
+				*max_x = object-&gt;vertex_data[i * 3 + 0];
+			if(object-&gt;vertex_data[i * 3 + 1] &gt; *max_y)
+				*max_y = object-&gt;vertex_data[i * 3 + 1];
+			if(object-&gt;vertex_data[i * 3 + 2] &gt; *max_z)
+				*max_z = object-&gt;vertex_data[i * 3 + 2];
 		}
+
+		objects_max_extension(object-&gt;objects,
+			min_x, min_y, min_z, max_x, max_y, max_z);
+
 		oitem = oitem-&gt;next;
 	}
+}
 
-	/* move model */
-	off_x = max_x - ((max_x - min_x) / 2.0);
-	off_y = max_y - ((max_y - min_y) / 2.0);
-	off_z = max_z - ((max_z - min_z) / 2.0);
+static void objects_move(GSList *objects,
+	gdouble off_x, gdouble off_y, gdouble off_z)
+{
+	GSList *oitem;
+	G3DObject *object;
+	guint32 i;
 
-	oitem = model-&gt;objects;
+	oitem = objects;
 	while(oitem)
 	{
 		object = (G3DObject *)oitem-&gt;data;
@@ -224,9 +242,30 @@
 			object-&gt;vertex_data[i * 3 + 1] -= off_y;
 			object-&gt;vertex_data[i * 3 + 2] -= off_z;
 		}
+
+		objects_move(object-&gt;objects, off_x, off_y, off_z);
+
 		oitem = oitem-&gt;next;
 	}
+}
 
+gboolean g3d_model_center(G3DModel *model)
+{
+	gdouble min_x = 10.0e99, min_y = 10.0e99, min_z = 10.0e99;
+	gdouble max_x = -9.9e99, max_y = -9.9e99, max_z = -9.9e99;
+	gdouble off_x, off_y, off_z;
+
+	/* determine maximum extension */
+	objects_max_extension(model-&gt;objects,
+		&amp;min_x, &amp;min_y, &amp;min_z, &amp;max_x, &amp;max_y, &amp;max_z);
+
+	/* move model */
+	off_x = max_x - ((max_x - min_x) / 2.0);
+	off_y = max_y - ((max_y - min_y) / 2.0);
+	off_z = max_z - ((max_z - min_z) / 2.0);
+
+	objects_move(model-&gt;objects, off_x, off_y, off_z);
+
 	return TRUE;
 }
 
@@ -246,25 +285,33 @@
 	return TRUE;
 }
 
-void g3d_model_clear(G3DModel *model)
+static void objects_clear(GSList *objects)
 {
 	GSList *list, *next;
 	G3DObject *object;
-	G3DMaterial *mat;
 
-	/* lights */
-	/* TODO */
-
-	/* objects */
-	list = model-&gt;objects;
+	list = objects;
 	while(list)
 	{
 		object = (G3DObject*)list-&gt;data;
+		objects_clear(object-&gt;objects);
 		g3d_object_free(object);
 		next = list-&gt;next;
 		g_slist_free_1(list);
 		list = next;
 	}
+}
+
+void g3d_model_clear(G3DModel *model)
+{
+	GSList *list, *next;
+	G3DMaterial *mat;
+
+	/* lights */
+	/* TODO */
+
+	/* objects */
+	objects_clear(model-&gt;objects);
 	model-&gt;objects = NULL;
 
 	/* materials */
@@ -293,4 +340,30 @@
 	g_free(model);
 }
 
+static G3DObject *objects_get_by_name(GSList *objects, const gchar *name)
+{
+	GSList *olist;
+	G3DObject *object;
 
+	olist = objects;
+	while(olist)
+	{
+		object = (G3DObject *)olist-&gt;data;
+
+		if((object-&gt;name != NULL) &amp;&amp; (strcmp(object-&gt;name, name) == 0))
+			return object;
+
+		object = objects_get_by_name(object-&gt;objects, name);
+		if(object != NULL)
+			return object;
+
+		olist = olist-&gt;next;
+	}
+	return NULL;
+}
+
+G3DObject *g3d_model_get_object_by_name(G3DModel *model, const gchar *name)
+{
+	return objects_get_by_name(model-&gt;objects, name);
+}
+

Added: trunk/libs3d/libg3d/src/object-orig.c
===================================================================
--- trunk/libs3d/libg3d/src/object-orig.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/object-orig.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,368 @@
+/* $Id: object.c,v 1.1.2.7 2006/01/23 16:38:47 dahms Exp $ */
+
+/*
+    libg3d - 3D object loading library
+
+    Copyright (C) 2005, 2006  Markus Dahms &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">mad at automagically.de</A>&gt;
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+
+#include &lt;g3d/types.h&gt;
+#include &lt;g3d/vector.h&gt;
+#include &lt;g3d/matrix.h&gt;
+#include &lt;g3d/face.h&gt;
+
+void g3d_object_free(G3DObject *object)
+{
+	GSList *slist, *snext;
+	G3DMaterial *mat;
+	G3DFace *face;
+
+	if(object-&gt;name != NULL)
+		g_free(object-&gt;name);
+
+	/* materials */
+	slist = object-&gt;materials;
+	while(slist != NULL)
+	{
+		mat = (G3DMaterial*)slist-&gt;data;
+		snext = slist-&gt;next;
+		g_slist_free_1(slist);
+		slist = snext;
+	}
+
+	/* faces */
+	slist = object-&gt;faces;
+	while(slist != NULL)
+	{
+		face = (G3DFace*)slist-&gt;data;
+		g3d_face_free(face);
+		snext = slist-&gt;next;
+		g_slist_free_1(slist);
+		slist = snext;
+	}
+
+	/* vertices */
+	if(object-&gt;vertex_data != NULL) g_free(object-&gt;vertex_data);
+	if(object-&gt;tex_vertex_data != NULL) g_free(object-&gt;tex_vertex_data);
+	if(object-&gt;_normals != NULL) g_free(object-&gt;_normals);
+	if(object-&gt;_indices != NULL) g_free(object-&gt;_indices);
+	if(object-&gt;_materials != NULL) g_free(object-&gt;_materials);
+	if(object-&gt;_flags != NULL) g_free(object-&gt;_flags);
+
+	g_free(object);
+}
+
+gdouble g3d_object_radius(G3DObject *object)
+{
+	guint32 i;
+	gdouble max_radius = 0.0, r;
+	gfloat *v;
+
+	for(i = 0; i &lt; object-&gt;vertex_count; i ++)
+	{
+		v = &amp;object-&gt;vertex_data[i * 3];
+		r = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
+		if(r &gt; max_radius)
+			max_radius = r;
+	}
+
+	return sqrt(max_radius);
+}
+
+gboolean g3d_object_scale(G3DObject *object, gfloat scale)
+{
+	guint32 i;
+	gfloat *matrix;
+
+	for(i = 0; i &lt; object-&gt;vertex_count; i ++)
+	{
+		object-&gt;vertex_data[i * 3 + 0] *= scale;
+		object-&gt;vertex_data[i * 3 + 1] *= scale;
+		object-&gt;vertex_data[i * 3 + 2] *= scale;
+	}
+
+	if(object-&gt;transformation)
+	{
+		matrix = object-&gt;transformation-&gt;matrix;
+		g3d_matrix_translate(
+			- (matrix[12] - (matrix[12] * scale)),
+			- (matrix[13] - (matrix[13] * scale)),
+			- (matrix[14] - (matrix[14] * scale)),
+			matrix);
+	}
+
+	return TRUE;
+}
+
+#define G3D_OBJECT_TRANSFORM_NORMALS 0
+
+gboolean g3d_object_transform(G3DObject *object, gfloat *matrix)
+{
+	guint32 i;
+#if G3D_OBJECT_TRANSFORM_NORMALS
+	G3DFace *face;
+	GSList *fitem;
+#endif
+
+	/* transform vertices */
+	for(i = 0; i &lt; object-&gt;vertex_count; i ++)
+	{
+		g3d_vector_transform(
+			&amp;(object-&gt;vertex_data[i * 3 + 0]),
+			&amp;(object-&gt;vertex_data[i * 3 + 1]),
+			&amp;(object-&gt;vertex_data[i * 3 + 2]),
+			matrix);
+	}
+
+#if G3D_OBJECT_TRANSFORM_NORMALS
+	fitem = object-&gt;faces;
+	while(fitem)
+	{
+		face = (G3DFace *)fitem-&gt;data;
+
+		if(face-&gt;flags &amp; G3D_FLAG_FAC_NORMALS)
+		{
+			for(i = 0; i &lt; face-&gt;vertex_count; i ++)
+			{
+				g3d_vector_transform(
+					&amp;(face-&gt;normals[i * 3 + 0]),
+					&amp;(face-&gt;normals[i * 3 + 1]),
+					&amp;(face-&gt;normals[i * 3 + 2]),
+					matrix);
+				g3d_vector_unify(
+					&amp;(face-&gt;normals[i * 3 + 0]),
+					&amp;(face-&gt;normals[i * 3 + 1]),
+					&amp;(face-&gt;normals[i * 3 + 2]));
+			}
+		}
+
+		fitem = fitem-&gt;next;
+	}
+#endif
+
+	return TRUE;
+}
+
+G3DObject *g3d_object_duplicate(G3DObject *object)
+{
+	G3DObject *new;
+	G3DFace *face, *oface;
+	GSList *litem;
+
+	new = g_new0(G3DObject, 1);
+
+	/* name */
+	if(object-&gt;name)
+		new-&gt;name = g_strdup(object-&gt;name);
+
+	/* vertices */
+	new-&gt;vertex_count = object-&gt;vertex_count;
+	new-&gt;vertex_data = g_new0(gfloat, new-&gt;vertex_count * 3);
+	memcpy(new-&gt;vertex_data, object-&gt;vertex_data,
+		new-&gt;vertex_count * 3 * sizeof(gfloat));
+
+	/* texture stuff */
+	/* TODO: implement? */
+
+	/* faces */
+	litem = object-&gt;faces;
+	while(litem)
+	{
+		oface = (G3DFace *)litem-&gt;data;
+
+		face = g_new0(G3DFace, 1);
+		face-&gt;material = oface-&gt;material;
+		face-&gt;vertex_count = oface-&gt;vertex_count;
+		face-&gt;vertex_indices = g_new0(guint32, face-&gt;vertex_count);
+		memcpy(face-&gt;vertex_indices, oface-&gt;vertex_indices,
+			face-&gt;vertex_count * sizeof(guint32));
+		face-&gt;flags = oface-&gt;flags;
+		if(face-&gt;flags &amp; G3D_FLAG_FAC_NORMALS)
+		{
+			face-&gt;normals = g_new0(gfloat, face-&gt;vertex_count * 3);
+			memcpy(face-&gt;normals, oface-&gt;normals,
+				face-&gt;vertex_count * 3 * sizeof(gfloat));
+		}
+		if(face-&gt;flags &amp; G3D_FLAG_FAC_TEXMAP)
+		{
+			face-&gt;tex_image = oface-&gt;tex_image;
+			face-&gt;tex_vertex_count = oface-&gt;tex_vertex_count;
+			face-&gt;tex_vertex_data = g_new0(gfloat, face-&gt;tex_vertex_count * 2);
+			memcpy(face-&gt;tex_vertex_data, oface-&gt;tex_vertex_data,
+				face-&gt;tex_vertex_count * 2 * sizeof(gfloat));
+		}
+
+		new-&gt;faces = g_slist_prepend(new-&gt;faces, face);
+
+		litem = litem-&gt;next;
+	}
+
+	return new;
+}
+
+gboolean g3d_object_merge(G3DObject *o1, G3DObject *o2)
+{
+	G3DFace *face;
+	GSList *fitem;
+	guint32 i, voff, foff = 0;
+
+	/* copy vertices */
+	voff = o1-&gt;vertex_count;
+	o1-&gt;vertex_count += o2-&gt;vertex_count;
+
+	o1-&gt;vertex_data = g_realloc(o1-&gt;vertex_data,
+		o1-&gt;vertex_count * 3 * sizeof(gfloat));
+
+	memcpy(o1-&gt;vertex_data + voff * 3, o2-&gt;vertex_data,
+		o2-&gt;vertex_count * 3 * sizeof(gfloat));
+
+	/* attach faces to first object */
+	fitem = o2-&gt;faces;
+	while(fitem)
+	{
+		face = (G3DFace *)fitem-&gt;data;
+		foff ++;
+
+		if(face-&gt;vertex_count &gt; 100)
+		{
+			g_printerr(&quot;face-&gt;vertex_count &gt; 100: %d (%dth)&quot;,
+				face-&gt;vertex_count, foff);
+		}
+
+		for(i = 0; i &lt; face-&gt;vertex_count; i ++)
+			face-&gt;vertex_indices[i] += voff;
+
+		o1-&gt;faces = g_slist_prepend(o1-&gt;faces, face);
+
+		fitem = fitem-&gt;next;
+	}
+
+	/* FIXME: clean up o2 or copy faces */
+
+	return TRUE;
+}
+
+gboolean g3d_object_smooth(G3DObject *object)
+{
+	/* FIXME: implement */
+	return FALSE;
+}
+
+gboolean g3d_object_optimize(G3DObject *object)
+{
+	G3DFace *face;
+	guint32 index = 0, i, j;
+	GSList *fitem;
+	gfloat nx, ny, nz;
+
+	/* count number of faces (optimized) */
+	object-&gt;_num_faces = 0;
+	fitem = object-&gt;faces;
+	while(fitem)
+	{
+		face = (G3DFace *)fitem-&gt;data;
+		object-&gt;_num_faces += face-&gt;vertex_count - 2;
+
+		fitem = fitem-&gt;next;
+	}
+
+	object-&gt;_normals = g_new0(gfloat, object-&gt;_num_faces * 9);
+	object-&gt;_materials = g_new0(G3DMaterial *, object-&gt;_num_faces);
+	object-&gt;_flags = g_new0(guint32, object-&gt;_num_faces);
+	object-&gt;_indices = g_new0(guint32, object-&gt;_num_faces * 3);
+	object-&gt;_tex_images = g_new0(guint32, object-&gt;_num_faces);
+	object-&gt;_tex_coords = g_new0(gfloat, object-&gt;_num_faces * 6);
+
+	/* copy faces */
+	fitem = object-&gt;faces;
+	while(fitem)
+	{
+		face = (G3DFace *)fitem-&gt;data;
+
+		/* generate default normal for face */
+		if(!(face-&gt;flags &amp; G3D_FLAG_FAC_NORMALS))
+		{
+			if(!g3d_face_get_normal(face, object, &amp;nx, &amp;ny, &amp;nz))
+			{
+				fitem = fitem-&gt;next;
+				object-&gt;_num_faces -= face-&gt;vertex_count - 2;
+			}
+
+			g3d_vector_unify(&amp;nx, &amp;ny, &amp;nz);
+		}
+
+		for(i = 0; i &lt; (face-&gt;vertex_count - 2); i ++)
+		{
+			object-&gt;_materials[index] = face-&gt;material;
+			object-&gt;_flags[index] = face-&gt;flags;
+
+			if(face-&gt;flags &amp; G3D_FLAG_FAC_TEXMAP)
+				object-&gt;_tex_images[index] = face-&gt;tex_image-&gt;tex_id;
+
+			for(j = 0; j &lt; 3; j ++)
+			{
+				/* vertex stuff */
+				if(j == 0)
+					object-&gt;_indices[index * 3] = face-&gt;vertex_indices[0];
+				else
+					object-&gt;_indices[index * 3+j] = face-&gt;vertex_indices[i+j];
+
+				/* normal stuff */
+				if(face-&gt;flags &amp; G3D_FLAG_FAC_NORMALS)
+				{
+					object-&gt;_normals[(index * 3 + j) * 3 + 0] =
+						face-&gt;normals[(i + j) * 3 + 0];
+					object-&gt;_normals[(index * 3 + j) * 3 + 1] =
+						face-&gt;normals[(i + j) * 3 + 1];
+					object-&gt;_normals[(index * 3 + j) * 3 + 2] =
+						face-&gt;normals[(i + j) * 3 + 2];
+				}
+				else
+				{
+					object-&gt;_normals[(index * 3 + j) * 3 + 0] = nx;
+					object-&gt;_normals[(index * 3 + j) * 3 + 1] = ny;
+					object-&gt;_normals[(index * 3 + j) * 3 + 2] = nz;
+				}
+
+				/* texture stuff */
+				if(face-&gt;flags &amp; G3D_FLAG_FAC_TEXMAP)
+				{
+					/* u */
+					object-&gt;_tex_coords[(index * 3 + j) * 2 + 0] =
+						(j == 0) ?
+							face-&gt;tex_vertex_data[0] :
+							face-&gt;tex_vertex_data[(i + j) * 2 + 0];
+					/* v */
+					object-&gt;_tex_coords[(index * 3 + j) * 2 + 1] =
+						(j == 0) ?
+							face-&gt;tex_vertex_data[1] :
+							face-&gt;tex_vertex_data[(i + j) * 2 + 1];
+				}
+			} /* j: 0 &lt; 3 */
+
+			index ++;
+		} /* i: 0 &lt; vertex_count - 2 */
+
+		fitem = fitem-&gt;next;
+	} /* while(fitem) */
+
+	return TRUE;
+}
+

Modified: trunk/libs3d/libg3d/src/object.c
===================================================================
--- trunk/libs3d/libg3d/src/object.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/object.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -25,6 +25,7 @@
 
 #include &lt;g3d/types.h&gt;
 #include &lt;g3d/vector.h&gt;
+#include &lt;g3d/matrix.h&gt;
 #include &lt;g3d/face.h&gt;
 
 void g3d_object_free(G3DObject *object)
@@ -88,6 +89,7 @@
 gboolean g3d_object_scale(G3DObject *object, gfloat scale)
 {
 	guint32 i;
+	gfloat *matrix;
 
 	for(i = 0; i &lt; object-&gt;vertex_count; i ++)
 	{
@@ -96,14 +98,28 @@
 		object-&gt;vertex_data[i * 3 + 2] *= scale;
 	}
 
+	if(object-&gt;transformation)
+	{
+		matrix = object-&gt;transformation-&gt;matrix;
+		g3d_matrix_translate(
+			- (matrix[12] - (matrix[12] * scale)),
+			- (matrix[13] - (matrix[13] * scale)),
+			- (matrix[14] - (matrix[14] * scale)),
+			matrix);
+	}
+
 	return TRUE;
 }
 
+#define G3D_OBJECT_TRANSFORM_NORMALS 0
+
 gboolean g3d_object_transform(G3DObject *object, gfloat *matrix)
 {
 	guint32 i;
+#if G3D_OBJECT_TRANSFORM_NORMALS
 	G3DFace *face;
 	GSList *fitem;
+#endif
 
 	/* transform vertices */
 	for(i = 0; i &lt; object-&gt;vertex_count; i ++)
@@ -115,6 +131,7 @@
 			matrix);
 	}
 
+#if G3D_OBJECT_TRANSFORM_NORMALS
 	fitem = object-&gt;faces;
 	while(fitem)
 	{
@@ -138,6 +155,7 @@
 
 		fitem = fitem-&gt;next;
 	}
+#endif
 
 	return TRUE;
 }

Modified: trunk/libs3d/libg3d/src/plugins.c
===================================================================
--- trunk/libs3d/libg3d/src/plugins.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/plugins.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -122,10 +122,10 @@
 					{
 						if(plugin-&gt;type == G3D_PLUGIN_IMAGE)
 							g_hash_table_insert(context-&gt;exts_image,
-								g_strdup(*ext), plugin);
+								*ext, plugin);
 						else if(plugin-&gt;type == G3D_PLUGIN_IMPORT)
 							g_hash_table_insert(context-&gt;exts_import,
-								g_strdup(*ext), plugin);
+								*ext, plugin);
 
 						ext ++;
 					}
@@ -158,15 +158,60 @@
 	context-&gt;exts_import = g_hash_table_new(g_str_hash, g_str_equal);
 	context-&gt;exts_image = g_hash_table_new(g_str_hash, g_str_equal);
 
-	printf(&quot;Loading plugins from &quot; PLUGIN_DIR &quot;\n&quot;);
 	plugins_loaddirectory(context, PLUGIN_DIR &quot;/image&quot;);
 	plugins_loaddirectory(context, PLUGIN_DIR &quot;/import&quot;);
+
 	return TRUE;
 }
 
+/**
+ * g3d_plugins_cleanup:
+ * @context: an initialized context
+ *
+ * Tries to free any memory allocated during g3d_plugins_init.
+ */
+
 void g3d_plugins_cleanup(G3DContext *context)
 {
-	/* TODO: implement */
+	GSList *plist;
+	G3DPlugin *plugin;
+	gchar **pext;
+
+	plist = context-&gt;plugins;
+	while(plist)
+	{
+		plugin = (G3DPlugin *)plist-&gt;data;
+
+#if DEBUG &gt; 2
+		g_print(&quot;D: cleaning up plugin '%s'\n&quot;, plugin-&gt;name);
+#endif
+
+		/* cleanup plugin-specific data */
+		if(plugin-&gt;cleanup_func)
+			plugin-&gt;cleanup_func(plugin-&gt;user_data);
+
+		/* remove extensions from hash tables */
+		pext = plugin-&gt;extensions;
+		while(*pext)
+		{
+			if(plugin-&gt;type == G3D_PLUGIN_IMAGE)
+				g_hash_table_remove(context-&gt;exts_image, *pext);
+			else if(plugin-&gt;type == G3D_PLUGIN_IMPORT)
+				g_hash_table_remove(context-&gt;exts_import, *pext);
+
+			pext ++;
+		}
+
+		/* cleanup struct data */
+		plugins_free_plugin(plugin);
+
+		/* free list item */
+		plist = g_slist_remove(plist, plugin);
+	}
+
+	/* remove hash tables */
+	g_hash_table_destroy(context-&gt;exts_image);
+	g_hash_table_destroy(context-&gt;exts_import);
 }
 
 gchar *g3d_plugins_get_filetype(const gchar *filename)

Modified: trunk/libs3d/libg3d/src/primitive.c
===================================================================
--- trunk/libs3d/libg3d/src/primitive.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/primitive.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -21,6 +21,7 @@
 */
 
 #include &lt;math.h&gt;
+#include &lt;string.h&gt;
 
 #ifndef M_PI
 #	define M_PI 3.14159265358979323846
@@ -29,6 +30,73 @@
 #include &lt;g3d/types.h&gt;
 #include &lt;g3d/vector.h&gt;
 
+G3DObject *g3d_primitive_cube(gfloat width, gfloat height, gfloat depth,
+	G3DMaterial *material)
+{
+	G3DObject *object;
+	G3DFace *face;
+	gint32 faces[6][4] = {
+		{ 0, 1, 2, 3 },
+		{ 4, 5, 6, 7 },
+		{ 0, 1, 5, 4 },
+		{ 2, 3, 7, 6 },
+		{ 1, 2, 6, 5 },
+		{ 0, 4, 7, 3 }};
+	gint32 i, j;
+
+	object = g_new0(G3DObject, 1);
+
+	object-&gt;vertex_count = 8;
+	object-&gt;vertex_data = g_new0(gfloat, object-&gt;vertex_count * 3);
+
+	object-&gt;vertex_data[0 * 3 + 0] = -(width / 2);
+	object-&gt;vertex_data[0 * 3 + 1] = -(height / 2);
+	object-&gt;vertex_data[0 * 3 + 2] = -(depth / 2);
+
+	object-&gt;vertex_data[1 * 3 + 0] = -(width / 2);
+	object-&gt;vertex_data[1 * 3 + 1] = -(height / 2);
+	object-&gt;vertex_data[1 * 3 + 2] = (depth / 2);
+
+	object-&gt;vertex_data[2 * 3 + 0] = (width / 2);
+	object-&gt;vertex_data[2 * 3 + 1] = -(height / 2);
+	object-&gt;vertex_data[2 * 3 + 2] = (depth / 2);
+
+	object-&gt;vertex_data[3 * 3 + 0] = (width / 2);
+	object-&gt;vertex_data[3 * 3 + 1] = -(height / 2);
+	object-&gt;vertex_data[3 * 3 + 2] = -(depth / 2);
+
+	object-&gt;vertex_data[4 * 3 + 0] = -(width / 2);
+	object-&gt;vertex_data[4 * 3 + 1] = (height / 2);
+	object-&gt;vertex_data[4 * 3 + 2] = -(depth / 2);
+
+	object-&gt;vertex_data[5 * 3 + 0] = -(width / 2);
+	object-&gt;vertex_data[5 * 3 + 1] = (height / 2);
+	object-&gt;vertex_data[5 * 3 + 2] = (depth / 2);
+
+	object-&gt;vertex_data[6 * 3 + 0] = (width / 2);
+	object-&gt;vertex_data[6 * 3 + 1] = (height / 2);
+	object-&gt;vertex_data[6 * 3 + 2] = (depth / 2);
+
+	object-&gt;vertex_data[7 * 3 + 0] = (width / 2);
+	object-&gt;vertex_data[7 * 3 + 1] = (height / 2);
+	object-&gt;vertex_data[7 * 3 + 2] = -(depth / 2);
+
+	for(i = 0; i &lt; 6; i ++)
+	{
+		face = g_new0(G3DFace, 1);
+		face-&gt;vertex_count = 4;
+		face-&gt;vertex_indices = g_new0(guint32, 4);
+		for(j = 0; j &lt; 4; j ++)
+		{
+			face-&gt;vertex_indices[j] = faces[i][j];
+		}
+		face-&gt;material = material;
+		object-&gt;faces = g_slist_append(object-&gt;faces, face);
+	}
+
+	return object;
+}
+
 G3DObject *g3d_primitive_cylinder(gfloat radius, gfloat height,
 	guint32 sides, gboolean top, gboolean bottom, G3DMaterial *material)
 {
@@ -328,3 +396,128 @@
 
 	return object;
 }
+
+G3DObject *g3d_primitive_sphere(gfloat radius, guint32 vseg, guint32 hseg,
+	G3DMaterial *material)
+{
+	G3DObject *object;
+	G3DFace *face;
+	GSList *flist;
+	gint32 sh, sv, i;
+	gdouble x, y, z, u;
+
+	g_return_val_if_fail(vseg &gt;= 2, NULL);
+	g_return_val_if_fail(hseg &gt;= 3, NULL);
+
+	object = g_new0(G3DObject, 1);
+	object-&gt;vertex_count = (vseg - 1) * hseg + 2;
+	object-&gt;vertex_data = g_new0(gfloat, 3 * object-&gt;vertex_count);
+
+	for(sv = 1; sv &lt; vseg; sv ++)
+	{
+		y = radius * cos(M_PI * sv / vseg);
+		u = radius * sin(M_PI * sv / vseg);
+		for(sh = 0; sh &lt; hseg; sh ++)
+		{
+			x = radius * cos(M_PI * 2 * sh / hseg) * u;
+			z = radius * sin(M_PI * 2 * sh / hseg) * u;
+
+			object-&gt;vertex_data[((sv - 1) * hseg + sh) * 3 + 0] = x;
+			object-&gt;vertex_data[((sv - 1) * hseg + sh) * 3 + 1] = y;
+			object-&gt;vertex_data[((sv - 1) * hseg + sh) * 3 + 2] = z;
+
+			if(sv &gt; 1)
+			{
+				/* first triangle */
+				face = g_new0(G3DFace, 1);
+				face-&gt;material = material;
+				face-&gt;vertex_count = 3;
+				face-&gt;vertex_indices = g_new0(guint32, 3);
+				face-&gt;vertex_indices[0] = (sv - 1) * hseg + sh;
+				face-&gt;vertex_indices[1] = (sh == (hseg - 1)) ?
+					(sv - 1) * hseg :
+					(sv - 1) * hseg + sh + 1;
+				face-&gt;vertex_indices[2] = (sv - 2) * hseg + sh;
+				object-&gt;faces = g_slist_append(object-&gt;faces, face);
+
+				/* second triangle */
+				face = g_new0(G3DFace, 1);
+				face-&gt;material = material;
+				face-&gt;vertex_count = 3;
+				face-&gt;vertex_indices = g_new0(guint32, 3);
+				face-&gt;vertex_indices[0] = (sv - 2) * hseg + sh;
+				face-&gt;vertex_indices[1] = (sh == (hseg - 1)) ?
+					(sv - 1) * hseg :
+					(sv - 1) * hseg + sh + 1;
+				face-&gt;vertex_indices[2] = (sh == (hseg - 1)) ?
+					(sv - 2) * hseg :
+					(sv - 2) * hseg + sh + 1;
+				object-&gt;faces = g_slist_append(object-&gt;faces, face);
+			} /* sv &gt; 1 */
+		} /* hseg */
+	} /* vseg */
+
+	object-&gt;vertex_data[(object-&gt;vertex_count - 1) * 3 + 0] = 0;
+	object-&gt;vertex_data[(object-&gt;vertex_count - 1) * 3 + 1] = radius;
+	object-&gt;vertex_data[(object-&gt;vertex_count - 1) * 3 + 2] = 0;
+
+	object-&gt;vertex_data[(object-&gt;vertex_count - 2) * 3 + 0] = 0;
+	object-&gt;vertex_data[(object-&gt;vertex_count - 2) * 3 + 1] = -radius;
+	object-&gt;vertex_data[(object-&gt;vertex_count - 2) * 3 + 2] = 0;
+
+	for(sh = 0; sh &lt; hseg; sh ++)
+	{
+		/* top */
+		face = g_new0(G3DFace, 1);
+		face-&gt;material = material;
+		face-&gt;vertex_count = 3;
+		face-&gt;vertex_indices = g_new0(guint32, 3);
+
+		face-&gt;vertex_indices[0] = object-&gt;vertex_count - 1;
+		face-&gt;vertex_indices[1] = sh;
+		face-&gt;vertex_indices[2] = (sh == (hseg - 1)) ? 0 : sh + 1;
+
+		object-&gt;faces = g_slist_append(object-&gt;faces, face);
+
+		/* bottom */
+		face = g_new0(G3DFace, 1);
+		face-&gt;material = material;
+		face-&gt;vertex_count = 3;
+		face-&gt;vertex_indices = g_new0(guint32, 3);
+
+		face-&gt;vertex_indices[2] = object-&gt;vertex_count - 2;
+		face-&gt;vertex_indices[1] = (vseg - 2) * hseg + sh;
+		face-&gt;vertex_indices[0] = (sh == (hseg - 1)) ?
+			(vseg - 2) * hseg :
+			(vseg - 2) * hseg + sh + 1;
+
+		object-&gt;faces = g_slist_append(object-&gt;faces, face);
+	}
+
+	/* generate normals */
+	flist = object-&gt;faces;
+	while(flist)
+	{
+		face = (G3DFace *)flist-&gt;data;
+		face-&gt;flags |= G3D_FLAG_FAC_NORMALS;
+		face-&gt;normals = g_new0(gfloat, face-&gt;vertex_count * 3);
+		for(i = 0; i &lt; face-&gt;vertex_count; i ++)
+		{
+			face-&gt;normals[i * 3 + 0] =
+				- object-&gt;vertex_data[face-&gt;vertex_indices[i] * 3 + 0];
+			face-&gt;normals[i * 3 + 1] =
+				- object-&gt;vertex_data[face-&gt;vertex_indices[i] * 3 + 1];
+			face-&gt;normals[i * 3 + 2] =
+				- object-&gt;vertex_data[face-&gt;vertex_indices[i] * 3 + 2];
+
+			g3d_vector_unify(
+				&amp;(face-&gt;normals[i * 3 + 0]),
+				&amp;(face-&gt;normals[i * 3 + 1]),
+				&amp;(face-&gt;normals[i * 3 + 2]));
+		}
+
+		flist = flist-&gt;next;
+	}
+
+	return object;
+}

Modified: trunk/libs3d/libg3d/src/read.c
===================================================================
--- trunk/libs3d/libg3d/src/read.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/read.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -84,3 +84,48 @@
 	return u.f;
 }
 
+gdouble g3d_read_double_be(FILE *f)
+{
+	union {
+		gdouble d;
+		guint8 u[8];
+	} u;
+	gint32 i;
+
+	for(i = 7; i &gt;= 0; i --)
+		u.u[i] = g3d_read_int8(f);
+
+	return u.d;
+}
+
+gdouble g3d_read_double_le(FILE *f)
+{
+	union {
+		gdouble d;
+		guint8 u[8];
+	} u;
+	gint32 i;
+
+	for(i = 0; i &lt; 8; i ++)
+		u.u[i] = g3d_read_int8(f);
+
+	return u.d;
+}
+
+gint32 g3d_read_cstr(FILE *f, gchar *buffer, gint32 max_len)
+{
+	gint32 n = 0;
+	gchar c;
+
+	do
+	{
+		c = g3d_read_int8(f);
+		buffer[n] = c;
+		n ++;
+	}
+	while((c != 0) &amp;&amp; (n &lt; max_len));
+
+	buffer[max_len - 1] = '\0';
+
+	return n;
+}

Modified: trunk/libs3d/libg3d/src/texture.c
===================================================================
--- trunk/libs3d/libg3d/src/texture.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/texture.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -27,56 +27,96 @@
 
 static gboolean dump_ppm(G3DImage *image, const gchar *filename);
 
-G3DImage *g3d_texture_load_cached(G3DContext *context, G3DModel *model,
-	const gchar *filename)
+G3DImage *g3d_texture_load(G3DContext *context, const gchar *filename)
 {
 	G3DImage *image;
-	gchar *basename, *ppmname, *path;
+	gchar *basename, *path, *casedup, *caseddown, *realfile = NULL;
 
 	/* convert DOS path separator */
 	path = g_strdup(filename);
 	g_strdelimit(path, &quot;\\&quot;, '/');
 
-	/* create hash table if it does not exist yet */
-	if(model-&gt;tex_images == NULL)
-		model-&gt;tex_images = g_hash_table_new(g_str_hash, g_str_equal);
-
-	/* if already loaded, return cached image */
-	image = g_hash_table_lookup(model-&gt;tex_images, path);
-	if(image != NULL)
-		return image;
-
-	/* create emtpy G3DImage */
-	image = g_new0(G3DImage, 1);
-	image-&gt;tex_scale_u = 1.0;
-	image-&gt;tex_scale_v = 1.0;
-	if(g3d_plugins_load_image(context, path, image))
+	if(g_file_test(path, G_FILE_TEST_EXISTS))
 	{
-		g_hash_table_insert(model-&gt;tex_images, (gpointer)g_strdup(path),
-			image);
+		realfile = g_strdup(path);
 	}
 	else
 	{
-		/* try to load file without path */
 		basename = g_path_get_basename(path);
-		if(g3d_plugins_load_image(context, basename, image))
+		if(g_file_test(basename, G_FILE_TEST_EXISTS))
 		{
-			g_hash_table_insert(model-&gt;tex_images,
-				(gpointer)g_strdup(path), image);
+			realfile = g_strdup(basename);
 		}
 		else
 		{
-			g_free(image);
-			image = NULL;
+			casedup = g_ascii_strup(basename, -1);
+			if(g_file_test(casedup, G_FILE_TEST_EXISTS))
+			{
+				realfile = g_strdup(casedup);
+			}
+			else
+			{
+				caseddown = g_ascii_strdown(basename, -1);
+				if(g_file_test(caseddown, G_FILE_TEST_EXISTS))
+				{
+					realfile = g_strdup(caseddown);
+				}
+				g_free(caseddown);
+			}
+			g_free(casedup);
 		}
 		g_free(basename);
 	}
-
 	g_free(path);
 
+	if(realfile == NULL)
+	{
+		g_printerr(&quot;failed to find a file matching '%s'\n&quot;, filename);
+		return NULL;
+	}
+
+	/* create emtpy G3DImage */
+	image = g_new0(G3DImage, 1);
+	image-&gt;tex_scale_u = 1.0;
+	image-&gt;tex_scale_v = 1.0;
+
+	if(g3d_plugins_load_image(context, realfile, image))
+	{
+		g_free(realfile);
+		return image;
+	}
+
+	g_free(image);
+	g_free(realfile);
+
+	return NULL;
+}
+
+G3DImage *g3d_texture_load_cached(G3DContext *context, G3DModel *model,
+	const gchar *filename)
+{
+	G3DImage *image;
+	gchar *basename, *ppmname;
+
+	/* create hash table if it does not exist yet */
+	if(model-&gt;tex_images == NULL)
+		model-&gt;tex_images = g_hash_table_new(g_str_hash, g_str_equal);
+
+	/* if already loaded, return cached image */
+	image = g_hash_table_lookup(model-&gt;tex_images, filename);
+	if(image != NULL)
+		return image;
+
+	image = g3d_texture_load(context, filename);
+	if(image != NULL)
+	{
+		g_hash_table_insert(model-&gt;tex_images, (gpointer)g_strdup(filename),
+			image);
+	}
+
 	if(0 &amp;&amp; image)
 	{
-		basename = g_path_get_basename(path);
+		basename = g_path_get_basename(filename);
 		ppmname = g_strdup_printf(&quot;/tmp/%s.ppm&quot;, basename);
 		dump_ppm(image, ppmname);
 		g_free(ppmname);
@@ -86,11 +126,42 @@
 	return image;
 }
 
+void g3d_texture_free(G3DImage *texture)
+{
+	if(texture-&gt;name) g_free(texture-&gt;name);
+	if(texture-&gt;pixeldata) g_free(texture-&gt;pixeldata);
+	g_free(texture);
+}
+
 gboolean g3d_texture_prepare(G3DImage *texture)
 {
 	return FALSE;
 }
 
+gboolean g3d_texture_flip_y(G3DImage *texture)
+{
+	guint8 *newpixel;
+	gint32 y;
+
+	g_return_val_if_fail(texture != NULL, FALSE);
+
+	newpixel = g_new0(guint8, texture-&gt;width * texture-&gt;height * 4);
+
+	for(y = 0; y &lt; texture-&gt;height; y ++)
+	{
+		memcpy(
+			newpixel + (y * texture-&gt;width * 4),
+			texture-&gt;pixeldata + (
+				(texture-&gt;height - y - 1) * texture-&gt;width * 4),
+			texture-&gt;width * 4);
+	}
+
+	g_free(texture-&gt;pixeldata);
+	texture-&gt;pixeldata = newpixel;
+
+	return TRUE;
+}
+
 static gboolean dump_ppm(G3DImage *image, const gchar *filename)
 {
 	FILE *f;
@@ -116,3 +187,54 @@
 	fclose(f);
 	return TRUE;
 }
+
+G3DImage *g3d_texture_merge_alpha(G3DImage *image, G3DImage *aimage)
+{
+	G3DImage *texture;
+	gint32 x, y;
+	gboolean negative;
+
+	g_return_val_if_fail(aimage != NULL, NULL);
+
+	if(image &amp;&amp; (
+			(image-&gt;width != aimage-&gt;width) ||
+			(image-&gt;height != aimage-&gt;height)))
+	{
+		/* size doesn't match, don't do something */
+		return image;
+	}
+
+	if(image)
+	{
+		texture = image;
+	}
+	else
+	{
+		texture = g_new0(G3DImage, 1);
+		texture-&gt;tex_scale_u = 1.0;
+		texture-&gt;tex_scale_v = 1.0;
+		texture-&gt;width = aimage-&gt;width;
+		texture-&gt;height = aimage-&gt;height;
+		texture-&gt;depth = 4;
+		texture-&gt;pixeldata = g_malloc(texture-&gt;width * texture-&gt;height * 4);
+	}
+
+	/* negative map? */
+	/* FIXME: better solution? */
+	if(aimage-&gt;pixeldata[0] == 0)
+		negative = TRUE;
+	else
+		negative = FALSE;
+
+	for(y = 0; y &lt; texture-&gt;height; y ++)
+	{
+		for(x = 0; x &lt; texture-&gt;width; x ++)
+		{
+			texture-&gt;pixeldata[(y * image-&gt;width + x) * 4 + 3] = (negative ?
+				255 - aimage-&gt;pixeldata[(y * image-&gt;width + x) * 4 + 0] :
+				aimage-&gt;pixeldata[(y * image-&gt;width + x) * 4 + 0]);
+		}
+	}
+
+	return texture;
+}

Modified: trunk/libs3d/libg3d/src/vector.c
===================================================================
--- trunk/libs3d/libg3d/src/vector.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/vector.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -63,7 +63,11 @@
 		result[i] = 0.0;
 
 		for(k = 0; k &lt; 4; k ++)
+#if 0
 			result[i] += matrix[i * 4 + k] * vector[k];
+#else
+			result[i] += matrix[k * 4 + i] * vector[k];
+#endif
 	}
 
 	*x = result[0];


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000373.html">[S3d-svn] r380 - in trunk: . apps/s3dfm
</A></li>
	<LI>Next message: <A HREF="000375.html">[S3d-svn] r382 - trunk/libs3d
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#374">[ date ]</a>
              <a href="thread.html#374">[ thread ]</a>
              <a href="subject.html#374">[ subject ]</a>
              <a href="author.html#374">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/s3d-svn">More information about the S3d-svn
mailing list</a><br>
</body></html>
