<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [S3d-svn] r391 - in trunk: apps/dot_mcp apps/olsrs3d	apps/s3d_x11gate apps/s3dfm apps/s3dgps apps/s3dvt example	libs3d libs3d/libg3d/plugins/import
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/s3d-svn/2006-September/index.html" >
   <LINK REL="made" HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r391%20-%20in%20trunk%3A%20apps/dot_mcp%20apps/olsrs3d%0A%09apps/s3d_x11gate%20apps/s3dfm%20apps/s3dgps%20apps/s3dvt%20example%0A%09libs3d%20libs3d/libg3d/plugins/import&In-Reply-To=%3C200609160044.k8G0iJGV003229%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000383.html">
   <LINK REL="Next"  HREF="000385.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[S3d-svn] r391 - in trunk: apps/dot_mcp apps/olsrs3d	apps/s3d_x11gate apps/s3dfm apps/s3dgps apps/s3dvt example	libs3d libs3d/libg3d/plugins/import</H1>
    <B>dotslash at BerliOS</B> 
    <A HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r391%20-%20in%20trunk%3A%20apps/dot_mcp%20apps/olsrs3d%0A%09apps/s3d_x11gate%20apps/s3dfm%20apps/s3dgps%20apps/s3dvt%20example%0A%09libs3d%20libs3d/libg3d/plugins/import&In-Reply-To=%3C200609160044.k8G0iJGV003229%40sheep.berlios.de%3E"
       TITLE="[S3d-svn] r391 - in trunk: apps/dot_mcp apps/olsrs3d	apps/s3d_x11gate apps/s3dfm apps/s3dgps apps/s3dvt example	libs3d libs3d/libg3d/plugins/import">dotslash at mail.berlios.de
       </A><BR>
    <I>Sat Sep 16 02:44:19 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000383.html">[S3d-svn] r390 - in trunk/libs3d/libg3d: plugins/import src
</A></li>
        <LI>Next message: <A HREF="000385.html">[S3d-svn] r392 - in trunk: apps/dot_mcp apps/olsrs3d	apps/s3d_x11gate apps/s3dfm apps/s3dgps apps/s3dvt example libs3d
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#384">[ date ]</a>
              <a href="thread.html#384">[ thread ]</a>
              <a href="subject.html#384">[ subject ]</a>
              <a href="author.html#384">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dotslash
Date: 2006-09-16 02:44:17 +0200 (Sat, 16 Sep 2006)
New Revision: 391

Added:
   trunk/example/modelloader.c
Removed:
   trunk/example/3dsloader.c
   trunk/example/3dsloader_g3d.c
Modified:
   trunk/apps/dot_mcp/main.c
   trunk/apps/dot_mcp/menu.c
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/net.c
   trunk/apps/olsrs3d/process.c
   trunk/apps/olsrs3d/search.c
   trunk/apps/s3d_x11gate/s3d_x11gate.c
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/fs.c
   trunk/apps/s3dfm/icon.c
   trunk/apps/s3dfm/main.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dgps/s3dgps.c
   trunk/apps/s3dvt/main.c
   trunk/apps/s3dvt/terminal.c
   trunk/example/Makefile.am
   trunk/example/filebrowser.c
   trunk/example/hudtest.c
   trunk/example/katze.c
   trunk/example/linetest.c
   trunk/example/nichtsnutz.c
   trunk/example/ptrtest.c
   trunk/example/radius_test.c
   trunk/example/s3dclock.c
   trunk/example/snowman.c
   trunk/example/strtest.c
   trunk/example/texturetest.c
   trunk/example/widgets.c
   trunk/libs3d/3dsread.c
   trunk/libs3d/Makefile.am
   trunk/libs3d/libg3d/plugins/import/Makefile.am
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
   trunk/libs3d/s3d.h
Log:
- 3ds -&gt; model
- now using new 3dsloader!! (yay)

Modified: trunk/apps/dot_mcp/main.c
===================================================================
--- trunk/apps/dot_mcp/main.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/dot_mcp/main.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,525 +0,0 @@
-/*
- * main.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of dot_mcp, a mcp for s3d.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * dot_mcp is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * dot_mcp is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with dot_mcp; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include &lt;s3d.h&gt;
-#include &lt;s3d_keysym.h&gt;
-#include &quot;dot_mcp.h&quot;
-#include &lt;unistd.h&gt;  /*  sleep() */
-#include &lt;stdlib.h&gt;  /*  free(), malloc() */
-#include &lt;string.h&gt;  /*  strncpy() */
-#include &lt;stdio.h&gt;  /*  printf() */
-#include &lt;math.h&gt;	/* sin(), cos() */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,33*1000*1000}; 
-
-#define bsize 	0.2
-struct tver
-{
-	float x,y,z;
-};
-struct tver campos, camrot;
-float xdif=0,ydif=0;
-
-struct app {
-	unsigned int oid,oid_c;
-	float r;
-	int init;
-	float trans_x,trans_y,trans_z;
-	float textw;
-	char name[256]; 
-	int min_but,close_but,title;
-	int sphere;
-	struct app *next;
-};
-int ego_mode=0;
-float asp=1.0;
-struct app *apps=NULL;
-float bottom=-1.0;
-float left=-1.0;
-float zoom=5.0;
-int n_app=0;
-int rot_flag=0;
-struct app *focus=NULL;
-float focus_r=0;
-float alpha=0;
-unsigned int min_but,rotate,close_but,sphere,reset,menu=-1;
-
-void place_apps();
-
-#define SIDES	60
-#define RINGS	60
-int greentorus()
-{
-	int o,i,j;
-	float R,r,a;
-	float ia,ja,iap,jap;
-	float v[SIDES*RINGS*3];
-	float n[SIDES*12]; /* normals */
-	unsigned long l[SIDES*RINGS*6];
-	o=s3d_new_object();
-	R=100; /* outer radius */
-	r=100; /* inner radius */
-	a=M_PI/180;
-	s3d_push_material_a(o, 0.2,0.6,0.2,0.5,
-						   1  ,1  ,1  ,0.5,
-						   0.2,0.6,0.2,0.5);
-	for (i=0;i&lt;RINGS;i++)
-	{
-		for (j=0;j&lt;SIDES;j++)
-		{
-			ia=a*((float)i*360.0/RINGS);
-			ja=a*((float)j*360.0/SIDES);
-			iap=a*((float)(i+1)*360.0/RINGS);
-			jap=a*((float)(j+1)*360.0/SIDES);
-
-			v[i*SIDES*3+ j*3 +0]=(R+r*cos(ja))* cos(ia);
-			v[i*SIDES*3+ j*3 +1]=r*sin(ja);
-			v[i*SIDES*3+ j*3 +2]=(R+r*cos(ja))* sin(ia);
-		
-			l[i*SIDES*6+ j*6 +0]=i*SIDES+ j;
-			l[i*SIDES*6+ j*6 +1]=i*SIDES+ (j+1)%SIDES;
-			l[i*SIDES*6+ j*6 +2]=0;
-			l[i*SIDES*6+ j*6 +3]=i*SIDES+ j;
-			l[i*SIDES*6+ j*6 +4]=((i+1)%RINGS)*SIDES+ j;
-			l[i*SIDES*6+ j*6 +5]=0;
-			
-			n[j*12 +0] =R*r*cos(ja)*    cos(ia) + r*r*cos(ja)* cos(ia)*cos(ia);
-			n[j*12 +1] =R*r*sin(ja)*    cos(ia) + r*r*sin(ja)* cos(ia)*cos(ia);
-			n[j*12 +2] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
-			n[j*12 +3] =R*r*cos(jap)*    cos(ia)+ r*r*cos(jap)*cos(ia)*cos(ia);
-			n[j*12 +4] =R*r*sin(jap)*    cos(ia)+ r*r*sin(jap)*cos(ia)*cos(ia);
-			n[j*12 +5] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
-
-			n[j*12 +6] =R*r*cos(ja)*    cos(ia) + r*r*cos(ja)* cos(ia)*cos(ia);
-			n[j*12 +7] =R*r*sin(ja)*    cos(ia) + r*r*sin(ja)* cos(ia)*cos(ia);
-			n[j*12 +8] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
-			n[j*12 +9] =R*r*cos(ja)*    cos(iap)+ r*r*cos(ja)* cos(ia)*cos(iap);
-			n[j*12 +10]=R*r*sin(ja)*    cos(iap)+ r*r*sin(ja)* cos(ia)*cos(iap);
-			n[j*12 +11]=R*r*sin(iap) 			+ r*r*sin(iap)*cos(iap);
-		}
-		s3d_push_vertices(o,&amp;v[i*SIDES*3],SIDES);
-		s3d_push_lines(o,   &amp;l[i*SIDES*6],SIDES*2);
-		s3d_pep_line_normals(o,n,SIDES*2);
-	}
-/*	s3d_push_vertices(o,v,SIDES*RINGS);
-	s3d_push_lines(o,   l,SIDES*RINGS*2);*/
-
-	s3d_flags_on(o,S3D_OF_VISIBLE);
-	return(o);
-}
-void set_focus(struct app *a)
-{
-	if (focus!=a)
-		/* resetting old focus */
-		if (focus!=NULL)
-		{
-			printf(&quot;unfocusing app name %s\n&quot;,focus-&gt;name);
-			s3d_scale(focus-&gt;oid,1/focus-&gt;r);
-			s3d_scale(focus-&gt;sphere,focus-&gt;r);
-
-  			s3d_flags_on(focus-&gt;sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_off(focus-&gt;min_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_translate(	focus-&gt;title,-focus-&gt;textw-1.2,0.0,0);
-			s3d_translate(	focus-&gt;close_but,bsize*focus-&gt;textw/2,1.2,0);
-			s3d_link(		focus-&gt;close_but,focus-&gt;sphere);
-			s3d_link(		focus-&gt;oid,0); 
-		}
-	focus=a;
-	if (a==NULL)
-	{
-		focus_r=n_app;
-		s3d_mcp_focus(-1);
-		s3d_flags_off(rotate,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_off(reset,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		rot_flag=0;
-	} else {
-		/* set the new focus app up */
-		s3d_translate(	a-&gt;title,-a-&gt;textw-9.6,0.0,0);
-		s3d_translate(	reset,-7.2,0.0,0);
-		s3d_translate(	rotate,-4.8,0.0,0);
-		s3d_translate(	a-&gt;min_but,-2.4,0.0,0);
-		s3d_link(		a-&gt;close_but,0);
-		s3d_link(		rotate,a-&gt;close_but);
-		s3d_link(		reset,a-&gt;close_but);
-		s3d_flags_on(	a-&gt;min_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(	rotate,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(	reset,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_off(	a-&gt;sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_unlink(a-&gt;oid);
-		s3d_rotate(a-&gt;oid,		0,0,0);
-		s3d_translate(a-&gt;oid,	0,0,0);
-		focus_r=a-&gt;r;
-		s3d_scale(a-&gt;oid,1);
-		s3d_mcp_focus(	a-&gt;oid);
-	}
-	place_apps();
-}
-
-int add_app(struct app *a)
-{
-	struct app *prev=NULL,*a2=apps;
-	while ((a2)!=NULL)
-	{
-		prev=a2;
-		if (a2-&gt;oid==a-&gt;oid)
-		{  /*  already added, so free() and return */
-			free(a);
-			return(1);
-		}
-		a2=a2-&gt;next;  /*  go to the end */
-	}
-	a-&gt;next=NULL;
-	if (prev==NULL)
-		apps=a;
-	else 
-		prev-&gt;next=a;
-	n_app+=1;
-	return(0);
-}
-void *find_app(int oid)
-{
-	struct app *a=apps;
-	while (a!=NULL)
-	{
-		if (oid==a-&gt;oid)
-			break;
-		a=a-&gt;next;
-	}
-	return(a);
-}
-void *del_app(int oid)
-{
-	struct app *prev=NULL,*a=apps;
-	while ((a!=NULL)  &amp;&amp; (a-&gt;oid!=oid))
-	{
-		prev=a;
-		a=a-&gt;next;
-	}
-	if (a!=NULL)
-	{  /*  found ... */
-		if (a-&gt;init)
-		{
-			s3d_del_object(a-&gt;close_but);
-			s3d_del_object(a-&gt;min_but);
-			s3d_del_object(a-&gt;title);
-			s3d_del_object(a-&gt;sphere);
-			s3d_del_object(a-&gt;oid);
-		}
-		if (prev==NULL) 
-			apps=a-&gt;next;  /*  new head */
-		else
-			prev-&gt;next=a-&gt;next;
-		n_app--;
-		if (focus==a)
-		{
-			set_focus(NULL);
-			focus=NULL;
-		}
-		free(a);
-		place_apps();
-	} 
-	return(a);
-}
-void stop()
-{
-	s3d_quit();
-}
-void place_apps()
-{
-	struct app *a=apps;
-	int j=0;
-	float u[3],v[3],ya,xa;
-	while (a!=NULL)
-	{
-		if (a-&gt;init)	
-		{
-/*			printf(&quot;placing app [%d,'%s'], oid %d, r=%f\n&quot;,j,a-&gt;name,a-&gt;oid,a-&gt;r); */
-			if (focus==a)
-			{
-				s3d_translate(a-&gt;close_but,(-left)*zoom-0.4,(-bottom)*zoom-0.4,-zoom);
-			}
-			else 
-			{
-				s3d_translate(	a-&gt;oid,	zoom*(left)+j*2+1.0,zoom*bottom+1.0,-zoom);
-				s3d_rotate(		a-&gt;oid,	0,10,0);
-				j++;
-			}
-		}
-		a=a-&gt;next;
-	}
-	s3d_translate(menu,	left*zoom+0.4,(-bottom)*zoom-0.4,-zoom);
-	
-	v[0]=0;				v[1]=0;					v[2]=1;
-	u[0]=left*zoom+0.4; u[1]=0;					u[2]=-zoom;
-	ya=s3d_vector_angle(v,u);
-	u[0]=0; 			u[1]=(-bottom)*zoom;	u[2]=-zoom;
-	xa=s3d_vector_angle(v,u);
-	s3d_rotate(menu, 0 ,30,0); 
-}
-void mcp_object(struct s3d_evt *hrmz)
-{
-	struct mcp_object *mo;
-	struct app *a;
-	mo=(struct mcp_object *)hrmz-&gt;buf;
-	if (NULL==(a=find_app(mo-&gt;object)))
-	{
-		printf(&quot;adding new object ......&quot;);
-		a=malloc(sizeof(struct app));
-		a-&gt;oid=mo-&gt;object;
-		a-&gt;r=mo-&gt;r;
-		strncpy(a-&gt;name,mo-&gt;name,256);
-		a-&gt;init=0;
-		add_app(a);
-		place_apps();
-		printf(&quot;..%s\n&quot;,a-&gt;name);
-	} else {
-/*		printf(&quot;updating app %d\n&quot;,a-&gt;oid);*/
-		a-&gt;trans_x=mo-&gt;trans_x;
-		a-&gt;trans_y=mo-&gt;trans_y;
-		a-&gt;trans_z=mo-&gt;trans_z;
-		a-&gt;r=mo-&gt;r;
-		if (a-&gt;init)
-		{
-			if (a==focus)
-			{
-				focus_r=a-&gt;r;
-			} else {
-				s3d_scale(a-&gt;sphere,a-&gt;r);
-				s3d_scale(a-&gt;oid,1/a-&gt;r);
-			}
-		}
-		place_apps();
-	}
-}
-void app_init(struct app *a)
-{
-	printf(&quot;building some window decorations on %d ['%s']\n&quot;,a-&gt;oid,a-&gt;name);
-	printf(&quot;radius of object %d is %f\n&quot;,a-&gt;oid,a-&gt;r);
-	s3d_scale(a-&gt;oid,		1/a-&gt;r);
-
-	a-&gt;sphere=s3d_clone(sphere);
-	s3d_scale(		a-&gt;sphere,a-&gt;r);
-	s3d_link(		a-&gt;sphere,a-&gt;oid);
-  	s3d_flags_on(	a-&gt;sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-
-	a-&gt;title=s3d_draw_string(a-&gt;name,&amp;a-&gt;textw);
-
-	a-&gt;close_but=s3d_clone(close_but);
-	s3d_translate(	a-&gt;close_but,bsize*a-&gt;textw/2.0,1.2f,0.0f);
-	s3d_link(		a-&gt;close_but,a-&gt;sphere);
-  	s3d_flags_on(	a-&gt;close_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-
-
-	s3d_translate(	a-&gt;title,-a-&gt;textw-1.2f,0.0f,0.0f);
-	s3d_link(		a-&gt;title,a-&gt;close_but);
-   	s3d_flags_on(	a-&gt;title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	
-	a-&gt;min_but=s3d_clone(min_but);
-	s3d_link(		a-&gt;min_but,a-&gt;close_but);
-	
-	
-	s3d_scale(		a-&gt;close_but,bsize);
-	
-	s3d_link(		a-&gt;oid,0);
-	a-&gt;init=1;
-/*	if (focus==NULL)
-		set_focus(a);
-	else*/
-		place_apps();
-}
-void mcp_del_object(struct s3d_evt *hrmz)
-{
-	struct mcp_object *mo;
-	printf(&quot;omg, something got deleted!!\n&quot;);
-	mo=(struct mcp_object *)hrmz-&gt;buf;
-	del_app(mo-&gt;object);
-}
-void object_click(struct s3d_evt *hrmz)
-{
-	struct app *a;
-	unsigned int i, oid;
-	oid=*((unsigned int *)hrmz-&gt;buf);
-	printf(&quot;%d got clicked\n&quot;,oid);
-	a=apps;i=0;
-	if (oid==rotate)
-	{
-		rot_flag=!rot_flag;
-		return;
-	}
-	if (oid==reset)
-	{
-		s3d_translate(0,0.0,0.0,5.0);
-		s3d_rotate(0,0,0,0);
-	}
-	while (a!=NULL)
-	{
-		if (oid==a-&gt;close_but)
-		{
-			del_app(a-&gt;oid);
-			return;
-		} else 	if (oid==a-&gt;min_but)
-		{
-			if (a==focus)
-			{
-				set_focus(NULL); /* nothing is focused now */
-			}
-			return;
-		} else 	if (((oid==a-&gt;title) || (oid==a-&gt;sphere)) || (oid==a-&gt;oid))
-		{
-			printf(&quot;giving focus to [%s], %d\n&quot;,a-&gt;name,oid);
-			set_focus(a);
-			return;
-		}
-		i++;
-		a=a-&gt;next;
-	}
-	menu_click(oid);
-}
-void object_info(struct s3d_evt *hrmz)
-{
-	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
-	if (inf-&gt;object==0)
-	{
-		campos.x=inf-&gt;trans_x;
-		campos.y=inf-&gt;trans_y;
-		campos.z=inf-&gt;trans_z;
-		camrot.x=inf-&gt;rot_x;
-		camrot.y=inf-&gt;rot_y;
-		camrot.z=inf-&gt;rot_z;
-
-		if (asp!=inf-&gt;scale)
-		{
-			asp=inf-&gt;scale;
-			printf(&quot;screen aspect: %f\n&quot;,asp);
-			if (asp&gt;1.0) /* wide screen */
-			{
-				bottom=-1.0;
-				left=-asp;
-			} else {  /* high screen */
-				bottom=(-1.0/asp);
-				left=-1.0;
-			}
-			place_apps(); /* replace apps */
-		}
-	}
-}
-void mainloop()
-{
-	struct app *a;
-	float al,r;
-	int i;
-	a=apps;i=0;
-	while (a!=NULL)
-	{
-		if (!a-&gt;init)
-			app_init(a);
-		i++;
-		a=a-&gt;next;
-	}
-	if (rot_flag)
-	{
-		al=(alpha*M_PI/180);
-		r=(focus_r&gt;20.0)?20.0:focus_r;
-		s3d_translate(0,sin(al)*(r+5),0,cos(al)*(r+5));
-		s3d_rotate(0,0,alpha,0);
-		alpha=alpha+0.1;
-		if (alpha&gt;360.0) alpha=0.0;
-	}
-	if (ego_mode)
-	{
-		if ((ydif!=0) || (xdif!=0))
-		{
-			campos.x+=ydif*sin((camrot.y*M_PI)/180);
-			campos.z+=ydif*cos((camrot.y*M_PI)/180);
-			campos.x+=xdif*cos((-camrot.y*M_PI)/180);
-			campos.z+=xdif*sin((-camrot.y*M_PI)/180);
-			campos.y+=ydif*sin((-camrot.x*M_PI)/180);
-			s3d_translate(	0,campos.x,campos.y,campos.z);
-		}
-	}
-	nanosleep(&amp;t,NULL); 
-}
-
-void keydown(struct s3d_evt *event)
-{
-	struct s3d_key_event *keys=(struct s3d_key_event *)event-&gt;buf;
-	switch (keys-&gt;keysym)
-	{
-		case S3DK_F1:  ego_mode=(ego_mode+1)%2;
-				 xdif=0;
-			     ydif=0;
-				 printf(&quot;ego mode %d\n&quot;,ego_mode);
-				 break;
-		case 'w':ydif+=-1.0;break;
-		case 'a':xdif+=-1.0;break;
-		case 's':ydif+= 1.0;break;
-		case 'd':xdif+= 1.0;break;
-	}
-}
-void keyup(struct s3d_evt *event)
-{
-	struct s3d_key_event *keys=(struct s3d_key_event *)event-&gt;buf;
-	switch (keys-&gt;keysym)
-	{
-		case 'w':ydif-=-1.0;break;
-		case 'a':xdif-=-1.0;break;
-		case 's':ydif-= 1.0;break;
-		case 'd':xdif-= 1.0;break;
-	}
-
-}
-
-int main (int argc, char **argv)
-{
-	s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-	s3d_set_callback(S3D_MCP_OBJECT,mcp_object);
-	s3d_set_callback(S3D_EVENT_QUIT,stop);
-	s3d_set_callback(S3D_MCP_DEL_OBJECT,mcp_del_object);
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-	s3d_set_callback(S3D_EVENT_KEYDOWN,keydown);
-	s3d_set_callback(S3D_EVENT_KEYUP,keyup);
-
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;mcp&quot;))	
-	{
-		greentorus(); /* just call ... */
-
-		if (s3d_select_font(&quot;vera&quot;))
-		{
-			printf(&quot;font not found\n&quot;);
-		}
-		min_but=s3d_import_3ds_file(&quot;objs/btn_minimize.3ds&quot;);
-		rotate=s3d_import_3ds_file(&quot;objs/btn_rotate.3ds&quot;);
-		reset=s3d_import_3ds_file(&quot;objs/reset.3ds&quot;);
-		close_but=s3d_import_3ds_file(&quot;objs/btn_close.3ds&quot;);
-		sphere=s3d_import_3ds_file(&quot;objs/ringsystem.3ds&quot;);
-		menu=menu_init();
-		s3d_link(menu,0);
-		s3d_scale(menu,bsize);
-		place_apps();
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/apps/dot_mcp/menu.c
===================================================================
--- trunk/apps/dot_mcp/menu.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/dot_mcp/menu.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,111 +0,0 @@
-/*
- * menu.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of dot_mcp, a mcp for s3d.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * dot_mcp is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * dot_mcp is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with dot_mcp; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include &quot;s3d.h&quot;
-#include &quot;dot_mcp.h&quot;
-#include &lt;unistd.h&gt; /* fork(), execl() */
-#include &lt;stdio.h&gt; /* printf() */
-#include &lt;stdlib.h&gt; /* exit() */
-#include &lt;string.h&gt; /* strlen(),strncpy(), strncat() */
-struct menu_entry {
-	char *icon, *name, *path;
-	int icon_oid, str_oid;
-};
-static int go=-1;
-static int act;
-static struct menu_entry menu[]={
-		{&quot;objs/comp.3ds&quot;,&quot;terminal&quot;,&quot;s3dvt&quot;,				0,0},
-		{&quot;objs/comp.3ds&quot;,&quot;olsrs3d&quot;,&quot;olsrs3d&quot;,				0,0},
-		{&quot;objs/comp.3ds&quot;,&quot;s3d_x11gate&quot;,&quot;s3d_x11gate&quot;,		0,0},
-		{&quot;objs/comp.3ds&quot;,&quot;filebrowser&quot;,&quot;filebrowser&quot;,		0,0}, 
-		{&quot;objs/comp.3ds&quot;,&quot;logout&quot;,&quot;LOGOUT&quot;,					0,0}, 
-};
-void menu_click(int oid)
-{
-	unsigned int i;
-	char exec[256];
-	printf(&quot;%d got clicked\n&quot;,oid);
-	if (oid==go)
-	{
-		act=!act;
-		for (i=0;i&lt;(sizeof(menu)/sizeof(struct menu_entry));i++)
-		{
-			if (act)
-			{
-				s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-				s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			} else {
-				s3d_flags_off(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-				s3d_flags_off(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			}
-
-		}
-		return;
-	}
-	if (act)
-	{
-		for (i=0;i&lt;(sizeof(menu)/sizeof(struct menu_entry));i++)
-		{
-			if ((oid==menu[i].icon_oid) || (oid==menu[i].str_oid))
-			{
-				if (0==strncmp(menu[i].path,&quot;LOGOUT&quot;,6))
-				{
-					s3d_quit();
-					return;
-				}
-				strncpy(exec,menu[i].path,256);
-				strncat(exec,&quot;&gt; /dev/null 2&gt;&amp;1 &amp;&quot;,256); /* ignoring output, starting in background */
-				printf(&quot;executing [%s]\n&quot;,exec);
-				system(exec);
-				return;
-			}
-		}
-	}
-}
-int menu_init ()
-{
-	int i,menu_o;
-	menu_o=s3d_new_object();
-	act=0; /* menu deactived */
-	go=s3d_import_3ds_file(&quot;objs/s3dstart.3ds&quot;);
-	s3d_flags_on(go,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_link(go,menu_o);
-	for (i=0;i&lt;(sizeof(menu)/sizeof(struct menu_entry));i++)
-	{
-		if (-1==(menu[i].icon_oid=s3d_import_3ds_file(menu[i].icon)))
-				menu[i].icon_oid=s3d_new_object();
-		menu[i].str_oid=s3d_draw_string(menu[i].name,NULL);
-		s3d_link(menu[i].str_oid,menu[i].icon_oid);
-		s3d_link(menu[i].icon_oid,menu_o);
-		s3d_translate(menu[i].icon_oid,0,-3+(-3*i),0);
-		s3d_translate(menu[i].str_oid,2,0,0);
-/*		s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);*/
-		printf(&quot;menu item menu[%d], icon_oid=%d, icon_str=%d\n&quot;,i,menu[i].icon_oid,menu[i].str_oid);
-	}
-	return(menu_o);
-}
-
-

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/olsrs3d/main.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,1102 +0,0 @@
-/*
- * main.c
- *
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *                         Marek Lindner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lindner_marek at yahoo.de</A>&gt;
- *                         Andreas Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">andreas_lbg at gmx.de</A>&gt;
- *
- * This file is part of olsrs3d, an olsr topology visualizer for s3d.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- *
- * olsrs3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * olsrs3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include &lt;stdio.h&gt;
-#include &lt;s3d.h&gt;
-#include &lt;s3d_keysym.h&gt;
-#include &lt;s3dw.h&gt;
-#include &lt;time.h&gt;	      /* nanosleep() */
-#include &lt;string.h&gt;	/* strncpy() */
-#include &lt;math.h&gt;		/* sqrt() */
-#include &lt;getopt.h&gt;	/* getopt() */
-#include &lt;stdlib.h&gt;	/* exit() */
-#include &quot;olsrs3d.h&quot;
-#include &quot;search.h&quot;
-
-#define SPEED		10.0
-
-static struct timespec sleep_time = { 0, 100 * 1000 * 1000 };   /* 100 mili seconds */
-
-int Debug = 0;
-
-char Olsr_host[256];   /* ip or hostname of olsr node with running dot_draw plugin */
-
-struct olsr_con *Con_begin = NULL;   /* begin of connection list */
-struct olsr_node *Olsr_root = NULL;   /* top of olsr node tree */
-struct Obj_to_ip *Obj_to_ip_head, *Obj_to_ip_end, *List_ptr;   /* needed pointer for linked list */
-
-int Olsr_node_count = 0, Last_olsr_node_count = -1;
-int Olsr_node_count_obj = -1;
-int Olsr_ip_label_obj = -1;
-int Output_border[4];
-int *Olsr_neighbour_label_obj = NULL;
-int Size;
-
-
-int Net_read_count;
-int Output_block_counter = 0;
-int Output_block_completed = 0;
-
-int Olsr_node_obj, Olsr_node_inet_obj, Olsr_node_hna_net;
-
-float Asp = 1.0;
-float Bottom = -1.0;
-float Left = -1.0;
-
-float CamPosition[2][3];	/* CamPosition[trans|rot][x-z] */
-float CamPosition2[2][3];	/* CamPosition[trans|rot][x-z] */
-
-/* needed ? */
-/* float ZeroPosition[3] = {0,0,0};	 current position zero position */
-
-int ZeroPoint;   /* object zeropoint */
-float Zp_rotate = 0.0;
-int ColorSwitch = 0;   /* enable/disable colored olsr connections */
-int RotateSwitch = 0;
-float RotateSpeed = 0.5;
-float Factor = 0.6;	/* Factor in calc_olsr_node_mov */
-struct olsr_node *Olsr_node_pEtx;
-
-int Btn_close_id = -1;
-
-int Btn_close_obj;
-float Title_len;
-
-/***
- *
- * print usage info
- *
- ***/
-
-void print_usage( void ) {
-
-	printf( &quot;Usage is olsrs3d [options] [-- [s3d options]]\n&quot; );
-	printf( &quot;olsrs3d options:\n&quot; );
-	printf( &quot;   -h\tprint this short help\n&quot; );
-	printf( &quot;   -d\tenable debug mode\n&quot; );
-	printf( &quot;   -H\tconnect to olsr node [default: localhost]\n&quot; );
-	s3d_usage();
-
-}
-
-
-
-/***
- *
- * print error and exit
- *
- ***/
-
-void out_of_mem( void ) {
-
-	printf( &quot;Sorry - you ran out of memory !\n&quot; );
-	exit(8);
-
-}
-
-
-
-/***
- *
- * calculate distance between 2 vectors =&gt; <A HREF="http://en.wikipedia.org/wiki/Euclidean_distance">http://en.wikipedia.org/wiki/Euclidean_distance</A>
- *
- *   p1   =&gt;   vector of node 1
- *   p2   =&gt;   vector of node 2
- *
- *   return distance
- *
- ***/
-
-float dist(float p1[], float p2[])
-{
-	float p[3];
-	p[0]=p1[0]-p2[0];
-	p[1]=p1[1]-p2[1];
-	p[2]=p1[2]-p2[2];
-	return (sqrt(p[0]*p[0]   +  p[1]*p[1]  +  p[2]*p[2]));
-
-}
-
-
-
-/***
- *
- * calculate distance between 2 vectors and substract vector1 from vector2
- *  =&gt; <A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction</A>
- *
- *   p1   =&gt;   vector of node 1
- *   p2   =&gt;   vector of node 2
- *
- *   return distance
- *
- ***/
-
-float dirt(float p1[], float p2[], float p3[])
-{
-	float d;
-	d=dist(p1,p2);
-	if (d!=0.0)
-	{
-		p3[0]=p2[0]-p1[0];
-		p3[1]=p2[1]-p1[1];
-		p3[2]=p2[2]-p1[2];
-	} else {
-		p3[0]=p2[0]=p1[0]=0.0;
-	}
-	return(d);
-}
-
-
-
-/***
- *
- * calculate new movement of node by adding the product of the factor and the vector to the movement vector
- *  =&gt; <A HREF="http://en.wikipedia.org/wiki/Vector_%28spatial%29#Scalar_multiplication">http://en.wikipedia.org/wiki/Vector_%28spatial%29#Scalar_multiplication</A>
- *
- *   mov  =&gt;   current mov vector
- *   p    =&gt;   vector of node
- *   fac  =&gt;   factor which is
- *
- ***/
-
-void mov_add(float mov[], float p[], float fac)
-{
-/*	if (fac&gt;1000)
-		return;
-	fac=1000; */
-	mov[0]+=fac*p[0];
-	mov[1]+=fac*p[1];
-	mov[2]+=fac*p[2];
-}
-
-
-
-/***
- *
- * check whether is a new / modified / vanished node and handle it accordingly
- *
- *   *olsr_node =&gt;   pointer to current olsr_node
- *
- ***/
-
-void handle_olsr_node( struct olsr_node *olsr_node ) {
-
-	float distance, angle, angle_rad;
-	float tmp_mov_vec[3], desc_norm_vec[3] = {0,0,-1};
-	struct olsr_node *other_node;
-	struct Obj_to_ip *Obj_to_ip_curr;
-	struct olsr_neigh_list *olsr_neigh_list, *prev_olsr_neigh_list, *other_node_neigh_list, *tmp_olsr_neigh_list;
-
-	/* no more nodes left */
-	if ( olsr_node == NULL ) return;
-
-	/* olsr node vanished */
-	if ( ( olsr_node-&gt;last_seen &lt; Output_block_counter - 1 ) &amp;&amp; ( olsr_node-&gt;visible ) ) {
-
-		if ( Debug ) printf( &quot;olsr node vanished: %s\n&quot;, olsr_node-&gt;ip );
-
-		Olsr_node_count--;
-
-		olsr_node-&gt;visible = 0;
-
-		/* delete shape */
-		if ( olsr_node-&gt;obj_id != -1 ) {
-
-			/* remove element from ob2ip list */
-			lst_del( olsr_node-&gt;obj_id );
-			/* remove object from s3d server */
-			s3d_del_object( olsr_node-&gt;obj_id );
-
-			olsr_node-&gt;obj_id = -1;
-
-		}
-
-		if ( olsr_node-&gt;desc_id != -1 ) {
-
-			s3d_del_object( olsr_node-&gt;desc_id );
-			olsr_node-&gt;desc_id = -1;
-
-		}
-
-		/* delete olsr connections of this node */
-		olsr_neigh_list = olsr_node-&gt;olsr_neigh_list;
-
-		while ( olsr_neigh_list != NULL ) {
-
-			/* get connection list of 'other' node */
-			if ( olsr_neigh_list-&gt;olsr_con-&gt;left_olsr_node == olsr_node ) {
-				other_node = olsr_neigh_list-&gt;olsr_con-&gt;right_olsr_node;
-			} else {
-				other_node = olsr_neigh_list-&gt;olsr_con-&gt;left_olsr_node;
-			}
-
-			/* find this connection in 'other' nodes connection list ... */
-			prev_olsr_neigh_list = NULL;
-			other_node_neigh_list = other_node-&gt;olsr_neigh_list;
-
-			while ( other_node_neigh_list != NULL ) {
-
-				if ( other_node_neigh_list-&gt;olsr_con == olsr_neigh_list-&gt;olsr_con ) {
-
-					/* and delete it ! */
-					if ( prev_olsr_neigh_list != NULL ) {
-						/* is first, any or last element in the list */
-						prev_olsr_neigh_list-&gt;next_olsr_neigh_list = other_node_neigh_list-&gt;next_olsr_neigh_list;
-					} else {
-						/* the only element in the list */
-						other_node-&gt;olsr_neigh_list = NULL;
-					}
-
-					free( other_node_neigh_list );
-
-					break;
-
-				}
-
-				prev_olsr_neigh_list = other_node_neigh_list;
-				other_node_neigh_list = other_node_neigh_list-&gt;next_olsr_neigh_list;
-
-			}
-
-			s3d_del_object( olsr_neigh_list-&gt;olsr_con-&gt;obj_id );
-
-			/* delete connection */
-			if ( olsr_neigh_list-&gt;olsr_con-&gt;prev_olsr_con != NULL ) olsr_neigh_list-&gt;olsr_con-&gt;prev_olsr_con-&gt;next_olsr_con = olsr_neigh_list-&gt;olsr_con-&gt;next_olsr_con;
-			if ( olsr_neigh_list-&gt;olsr_con-&gt;next_olsr_con != NULL ) olsr_neigh_list-&gt;olsr_con-&gt;next_olsr_con-&gt;prev_olsr_con = olsr_neigh_list-&gt;olsr_con-&gt;prev_olsr_con;
-
-			tmp_olsr_neigh_list = olsr_neigh_list;
-
-			olsr_neigh_list = olsr_neigh_list-&gt;next_olsr_neigh_list;
-
-			free( tmp_olsr_neigh_list-&gt;olsr_con );
-			free( tmp_olsr_neigh_list );
-
-		}
-
-		olsr_node-&gt;olsr_neigh_list = NULL;
-
-	} else if ( olsr_node-&gt;visible ) {
-
-		/* olsr node shape has been modified */
-		if ( olsr_node-&gt;node_type_modified ) {
-
-			/* delete old shape */
-			if ( olsr_node-&gt;obj_id != -1 ) {
-				/* remove element from ob2ip list */
-				lst_del( olsr_node-&gt;obj_id );
-				s3d_del_object( olsr_node-&gt;obj_id );
-			}
-
-			if ( olsr_node-&gt;desc_id != -1 ) s3d_del_object( olsr_node-&gt;desc_id );
-
-			/* create new shape */
-			if ( olsr_node-&gt;node_type == 1 ) {
-				/* olsr node offers internet access */
-				olsr_node-&gt;obj_id = s3d_clone( Olsr_node_inet_obj );
-			} else if ( olsr_node-&gt;node_type == 2 ) {
-				/* via hna announced network */
-				olsr_node-&gt;obj_id = s3d_clone( Olsr_node_hna_net );
-			} else {
-				/* normal olsr node */
-				olsr_node-&gt;obj_id = s3d_clone( Olsr_node_obj );
-			}
-
-			s3d_flags_on( olsr_node-&gt;obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-
-			/* link newly created object to ZeroPoint */
-			s3d_link( olsr_node-&gt;obj_id, ZeroPoint );
-			/* add object_id and olsr_node to linked list */
-			lst_add(olsr_node-&gt;obj_id,&amp;olsr_node);
-
-			/* create olsr node text and attach (link) it to the node */
-			olsr_node-&gt;desc_id = s3d_draw_string( olsr_node-&gt;ip, &amp;olsr_node-&gt;desc_length );
-			s3d_link( olsr_node-&gt;desc_id, olsr_node-&gt;obj_id );
-			s3d_translate( olsr_node-&gt;desc_id, - olsr_node-&gt;desc_length / 2, -2, 0 );
-			s3d_flags_on( olsr_node-&gt;desc_id, S3D_OF_VISIBLE );
-
-			olsr_node-&gt;node_type_modified = 0;
-
-		}
-
-
-		/* rotate node description so that they are always readable */
-		tmp_mov_vec[0] = CamPosition2[0][0] - olsr_node-&gt;pos_vec[0];
-		tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
-		tmp_mov_vec[2] = CamPosition2[0][2] - olsr_node-&gt;pos_vec[2];
-
-		angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
-
-		/* take care of inverse cosinus */
-		if ( tmp_mov_vec[0] &gt; 0 ) {
-			angle_rad = 90.0/M_PI - angle;
-			angle = 180 - ( 180.0/M_PI * angle );
-		} else {
-			angle_rad = 90.0/M_PI + angle;
-			angle = 180 + ( 180.0/M_PI * angle );
-		}
-
-		s3d_rotate( olsr_node-&gt;desc_id, 0, angle , 0 );
-		s3d_translate( olsr_node-&gt;desc_id, -cos(angle_rad)*olsr_node-&gt;desc_length/2 ,-1.5, sin(angle_rad)*olsr_node-&gt;desc_length/2 );
-
-
-		/* drift away from unrelated nodes */
-		Obj_to_ip_curr = Obj_to_ip_head-&gt;next;
-		while ( Obj_to_ip_curr != Obj_to_ip_end ) {
-
-			/* myself ... */
-			if ( olsr_node != Obj_to_ip_curr-&gt;olsr_node ) {
-
-				olsr_neigh_list = olsr_node-&gt;olsr_neigh_list;
-				while ( olsr_neigh_list != NULL ) {
-
-					/* nodes are related */
-					if ( ( olsr_neigh_list-&gt;olsr_con-&gt;left_olsr_node-&gt;visible == 1 ) &amp;&amp; ( olsr_neigh_list-&gt;olsr_con-&gt;right_olsr_node-&gt;visible == 1 ) ) {
-
-						if ( ( olsr_neigh_list-&gt;olsr_con-&gt;left_olsr_node == Obj_to_ip_curr-&gt;olsr_node ) || (  olsr_neigh_list-&gt;olsr_con-&gt;right_olsr_node == Obj_to_ip_curr-&gt;olsr_node ) ) break;
-
-					}
-
-					olsr_neigh_list = olsr_neigh_list-&gt;next_olsr_neigh_list;
-
-				}
-
-				/* nodes are not related - so drift */
-				if ( olsr_neigh_list == NULL ) {
-
-					distance = dirt( olsr_node-&gt;pos_vec, Obj_to_ip_curr-&gt;olsr_node-&gt;pos_vec, tmp_mov_vec );
-					if ( distance &lt; 0.1 ) distance = 0.1;
-					mov_add( olsr_node-&gt;mov_vec, tmp_mov_vec,-100 / ( distance * distance ) );
-					mov_add( Obj_to_ip_curr-&gt;olsr_node-&gt;mov_vec, tmp_mov_vec, 100 / ( distance * distance ) );
-
-				}
-
-			}
-
-			Obj_to_ip_curr = Obj_to_ip_curr-&gt;next;
-
-		}
-
-	}
-
-	handle_olsr_node( olsr_node-&gt;left );
-	handle_olsr_node( olsr_node-&gt;right );
-
-}
-
-
-
-/***
- *
- * calculate movement vector of all olsr nodes
- *
- ***/
-
-void calc_olsr_node_mov( void ) {
-
-	float distance;
-	float tmp_mov_vec[3];
-	float f;
-	struct olsr_con *olsr_con = Con_begin;
-
-	while ( olsr_con != NULL ) {
-
-		distance = dirt( olsr_con-&gt;left_olsr_node-&gt;pos_vec, olsr_con-&gt;right_olsr_node-&gt;pos_vec, tmp_mov_vec );
-		f = ( ( olsr_con-&gt;left_etx_sqrt + olsr_con-&gt;left_etx_sqrt ) / 4.0 ) / distance;
-
-		/***
-		 * drift factor - 0.0 &lt; factor &lt; 1.0 ( best results: 0.3 &lt; factor &lt; 0.9
-		 * small factor: fast and strong drift to neighbours
-		 ***/
-		if ( f &lt; Factor ) f = Factor;
-
-		mov_add( olsr_con-&gt;left_olsr_node-&gt;mov_vec, tmp_mov_vec, 1 / f - 1 );
-		mov_add( olsr_con-&gt;right_olsr_node-&gt;mov_vec, tmp_mov_vec, - ( 1 / f - 1 ) );
-
-		olsr_con = olsr_con-&gt;next_olsr_con;
-
-	}
-
-}
-
-
-
-/***
- *
- * move all olsr nodes and their connections
- *
- ***/
-
-void move_olsr_nodes( void ) {
-
-	float null_vec[3] = {0,0,0}, vertex_buf[6];
-	float tmp_mov_vec[3];
-	float distance, etx, rgb;
-	struct olsr_con *olsr_con = Con_begin;
-
-	while ( olsr_con != NULL ) {
-
-		/* move left olsr node if it has not been moved yet */
-		if ( !( ( olsr_con-&gt;left_olsr_node-&gt;mov_vec[0] == 0 ) &amp;&amp; ( olsr_con-&gt;left_olsr_node-&gt;mov_vec[1] == 0 ) &amp;&amp; ( olsr_con-&gt;left_olsr_node-&gt;mov_vec[2] == 0 ) ) &amp;&amp; olsr_con-&gt;left_olsr_node-&gt;visible ) {
-
-			distance = dirt( olsr_con-&gt;left_olsr_node-&gt;pos_vec, null_vec, tmp_mov_vec );
-			mov_add( olsr_con-&gt;left_olsr_node-&gt;mov_vec, tmp_mov_vec, distance / 100 ); /* move a little bit to point zero */
-			mov_add( olsr_con-&gt;left_olsr_node-&gt;mov_vec, tmp_mov_vec, 1 ); /* move a little bit to point zero */
-
-			if ( ( distance = dist( olsr_con-&gt;left_olsr_node-&gt;mov_vec, null_vec ) ) &gt; 10.0 ) {
-				mov_add( olsr_con-&gt;left_olsr_node-&gt;pos_vec, olsr_con-&gt;left_olsr_node-&gt;mov_vec, 1.0 / ( ( float ) distance ) );
-			} else {
-				mov_add( olsr_con-&gt;left_olsr_node-&gt;pos_vec, olsr_con-&gt;left_olsr_node-&gt;mov_vec, 0.1 );
-			}
-
-			s3d_translate( olsr_con-&gt;left_olsr_node-&gt;obj_id, olsr_con-&gt;left_olsr_node-&gt;pos_vec[0], olsr_con-&gt;left_olsr_node-&gt;pos_vec[1], olsr_con-&gt;left_olsr_node-&gt;pos_vec[2] );
-
-			/* reset movement vector */
-			olsr_con-&gt;left_olsr_node-&gt;mov_vec[0] = olsr_con-&gt;left_olsr_node-&gt;mov_vec[1] = olsr_con-&gt;left_olsr_node-&gt;mov_vec[2] = 0.0;
-
-		}
-
-		/* move right olsr node if it has not been moved yet */
-		if ( !( ( olsr_con-&gt;right_olsr_node-&gt;mov_vec[0] == 0 ) &amp;&amp; ( olsr_con-&gt;right_olsr_node-&gt;mov_vec[1] == 0 ) &amp;&amp; ( olsr_con-&gt;right_olsr_node-&gt;mov_vec[2] == 0 ) ) &amp;&amp; olsr_con-&gt;right_olsr_node-&gt;visible ) {
-
-			distance = dirt( olsr_con-&gt;right_olsr_node-&gt;pos_vec, null_vec, tmp_mov_vec );
-			mov_add( olsr_con-&gt;right_olsr_node-&gt;mov_vec, tmp_mov_vec, distance / 100 ); /* move a little bit to point zero */
-			mov_add( olsr_con-&gt;right_olsr_node-&gt;mov_vec, tmp_mov_vec, 1 ); /* move a little bit to point zero */
-
-			if ( ( distance = dist( olsr_con-&gt;right_olsr_node-&gt;mov_vec, null_vec ) ) &gt; 10.0 ) {
-				mov_add( olsr_con-&gt;right_olsr_node-&gt;pos_vec, olsr_con-&gt;right_olsr_node-&gt;mov_vec, 1.0 / ( ( float ) distance ) );
-			} else {
-				mov_add( olsr_con-&gt;right_olsr_node-&gt;pos_vec, olsr_con-&gt;right_olsr_node-&gt;mov_vec, 0.1 );
-			}
-
-			s3d_translate( olsr_con-&gt;right_olsr_node-&gt;obj_id, olsr_con-&gt;right_olsr_node-&gt;pos_vec[0], olsr_con-&gt;right_olsr_node-&gt;pos_vec[1], olsr_con-&gt;right_olsr_node-&gt;pos_vec[2] );
-
-			/* reset movement vector */
-			olsr_con-&gt;right_olsr_node-&gt;mov_vec[0] = olsr_con-&gt;right_olsr_node-&gt;mov_vec[1] = olsr_con-&gt;right_olsr_node-&gt;mov_vec[2] = 0.0;
-
-		}
-
-
-		/* move connection between left and right olsr node */
-		vertex_buf[0] = olsr_con-&gt;left_olsr_node-&gt;pos_vec[0];
-		vertex_buf[1] = olsr_con-&gt;left_olsr_node-&gt;pos_vec[1];
-		vertex_buf[2] = olsr_con-&gt;left_olsr_node-&gt;pos_vec[2];
-		vertex_buf[3] = olsr_con-&gt;right_olsr_node-&gt;pos_vec[0];
-		vertex_buf[4] = olsr_con-&gt;right_olsr_node-&gt;pos_vec[1];
-		vertex_buf[5] = olsr_con-&gt;right_olsr_node-&gt;pos_vec[2];
-
-		s3d_pep_vertices( olsr_con-&gt;obj_id, vertex_buf, 2 );
-
-
-		if ( ColorSwitch ) {
-
-			/* HNA */
-			if ( olsr_con-&gt;left_etx == -1000.00 ) {
-
-				if(olsr_con-&gt;color != 1) {
-					s3d_pep_material( olsr_con-&gt;obj_id,
-								   0.0,0.0,1.0,
-								   0.0,0.0,1.0,
-								   0.0,0.0,1.0);
-					olsr_con-&gt;color = 1;
-				}
-
-			} else {
-
-				etx = ( olsr_con-&gt;left_etx + olsr_con-&gt;right_etx ) / 2.0;
-
-				/* very good link - bright blue */
-				if ( ( etx &gt;= 1.0 ) &amp;&amp; ( etx &lt; 1.5 ) ) {
-
-					if(olsr_con-&gt;color != 2) {
-						s3d_pep_material( olsr_con-&gt;obj_id,
-								0.5,1.0,1.0,
-								0.5,1.0,1.0,
-								0.5,1.0,1.0);
-						olsr_con-&gt;color = 2;
-					}
-
-				/* good link - bright yellow */
-				} else if ( ( etx &gt;= 1.5 ) &amp;&amp; ( etx &lt; 2.0 ) ) {
-
-					rgb = 2.0 - etx;
-					if( olsr_con-&gt;color != 3 || (olsr_con-&gt;color == 3 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10))) {
-						s3d_pep_material( olsr_con-&gt;obj_id,
-								1.0,1.0,rgb,
-								1.0,1.0,rgb,
-								1.0,1.0,rgb);
-						olsr_con-&gt;color = 3;
-
-						olsr_con-&gt;rgb =  rgb;
-					}
-
-				/* not so good link - orange */
-				} else if ( ( etx &gt;= 2.0 ) &amp;&amp; ( etx &lt; 3.0 ) ) {
-
-					rgb = 1.5 - ( etx / 2.0 );
-					if( olsr_con-&gt;color != 4 || (olsr_con-&gt;color == 4 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10))) {
-						s3d_pep_material( olsr_con-&gt;obj_id,
-								1.0,rgb,0.0,
-								1.0,rgb,0.0,
-								1.0,rgb,0.0);
-						olsr_con-&gt;color = 4;
-
-						olsr_con-&gt;rgb = rgb;
-					}
-
-				/* bad link (almost dead) - brown */
-				} else if ( ( etx &gt;= 3.0 ) &amp;&amp; ( etx &lt; 5.0 ) ) {
-
-					rgb = 1.75 - ( etx / 4.0 );
-
-					if( olsr_con-&gt;color != 5 || (olsr_con-&gt;color == 5 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10)) ) {
-
-						s3d_pep_material( olsr_con-&gt;obj_id,
-								rgb,rgb - 0.5,0.0,
-								rgb,rgb - 0.5,0.0,
-								rgb,rgb - 0.5,0.0);
-						olsr_con-&gt;color = 5;
-
-						olsr_con-&gt;rgb = rgb;
-					}
-
-				/* zombie link - grey */
-				} else if ( ( etx &gt;= 5.0 ) &amp;&amp; ( etx &lt; 1000.0 ) ) {
-
-					rgb = 1000.0 / ( 1500.0 + etx );
-
-					if( olsr_con-&gt;color != 6 || (olsr_con-&gt;color == 6 &amp;&amp; (int) rintf(olsr_con-&gt;rgb * 10) !=  (int) rintf(rgb * 10)) ) {
-
-						s3d_pep_material( olsr_con-&gt;obj_id,
-								rgb,rgb,rgb,
-								rgb,rgb,rgb,
-								rgb,rgb,rgb);
-						olsr_con-&gt;color = 6;
-
-						olsr_con-&gt;rgb = rgb;
-					}
-
-				/* wtf - dark grey */
-				} else {
-
-					if(olsr_con-&gt;color != 7) {
-						s3d_pep_material( olsr_con-&gt;obj_id,
-								0.3,0.3,0.3,
-								0.3,0.3,0.3,
-								0.3,0.3,0.3);
-						olsr_con-&gt;color = 7;
-					}
-
-				}
-
-			}
-
-		} else {
-
-			if(olsr_con-&gt;color != 0) {
-				s3d_pep_material( olsr_con-&gt;obj_id,
-							1.0,1.0,1.0,
-							1.0,1.0,1.0,
-							1.0,1.0,1.0);
-				olsr_con-&gt;color = 0;
-			}
-
-		}
-
-
-		olsr_con = olsr_con-&gt;next_olsr_con;
-
-	}
-
-}
-
-
-
-void mainloop() {
-
-	int net_result;   /* result of function net_main */
-	char nc_str[20];
-	float strLen;
-	
-	/* calculate new movement vector */
-	calc_olsr_node_mov();
-
-	/* prepare nodes */
-	handle_olsr_node( Olsr_root );
-
-	/* move it */
-	move_olsr_nodes();
-
-	/* if we have more or less nodes now - redraw node count */
-	if ( Olsr_node_count != Last_olsr_node_count ) {
-
-		if ( Olsr_node_count_obj != -1 ) s3d_del_object( Olsr_node_count_obj );
-		snprintf( nc_str, 20, &quot;node count: %d&quot;, Olsr_node_count );
-		Olsr_node_count_obj = s3d_draw_string( nc_str, &amp;strLen );
-		s3d_link( Olsr_node_count_obj, 0 );
-		s3d_flags_on( Olsr_node_count_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_node_count_obj, 0.2 );
-		s3d_translate( Olsr_node_count_obj, -Left*3.0-(strLen * 0.2), -Bottom*3.0-0.5, -3.0 );
-		Last_olsr_node_count = Olsr_node_count;
-
-	}
-
-	if ( Output_block_completed ) {
-
-		Output_block_counter++;
-		Output_block_completed = 0;
-
-	}
-
-	/* read data from socket */
-	Net_read_count = 0;
-	while ( ( net_result = net_main() ) != 0 ) {
-		if ( net_result == -1 ) {
-			s3d_quit();
-			break;
-		}
-	}
-	
-	/* rotate modus */
-	if(RotateSwitch) {
-		Zp_rotate = ( Zp_rotate + RotateSpeed ) &gt; 360 ? 0.0 : ( Zp_rotate + RotateSpeed );	
-		s3d_rotate(ZeroPoint,0,Zp_rotate,0);
-	}
-
-	/* calc for node description */
-	CamPosition2[0][0]=  CamPosition[0][0]*cos(Zp_rotate*M_PI/180.0) - CamPosition[0][2] * sin (Zp_rotate*M_PI/180.0);
-	CamPosition2[0][1]=  CamPosition[0][1];
-	CamPosition2[0][2]=  CamPosition[0][0]*sin(Zp_rotate*M_PI/180.0) + CamPosition[0][2] * cos (Zp_rotate*M_PI/180.0);
-
-	/* check search status */
-	if( get_search_status() == WIDGET )
-		move_to_search_widget( CamPosition[0], CamPosition[1] );
-	if( get_search_status() == FOLLOW )
-		follow_node( CamPosition[0], CamPosition[1], Zp_rotate );
-	if( get_search_status() == ABORT )
-		move_to_return_point( CamPosition[0], CamPosition[1] );
-	
-
-	if( Olsr_ip_label_obj != -1 )
-	{
-		print_etx();
-	}
-
-	nanosleep( &amp;sleep_time, NULL );
-
-	return;
-
-}
-
-void stop() {
-
-	s3d_quit();
-	net_quit();
-
-}
-
-/***
- *
- * eventhandler when key pressed
- *
- ***/
-
-void keypress(struct s3d_evt *event) {
-
-	struct s3d_key_event *key=(struct s3d_key_event *)event-&gt;buf;
-	printf(&quot;%d\n&quot;,key-&gt;unicode);	
-	if( get_search_status() != WIDGET )
-	{
-		switch(key-&gt;unicode)
-		{
-			case S3DK_ESCAPE: /* abort action */
-			
-				set_search_status( get_search_status() == WIDGET ? ABORT : NOTHING );
-				break;
-				
-			case S3DK_s: /* move to search widget, give widget focus */
-
-				set_search_status(WIDGET);							/* set status for mainloop */
-				set_return_point(CamPosition[0],CamPosition[1]);	/* save the return position */
-				set_node_root( Olsr_root );
-				break;
-			
-			case S3DK_c: /* color on/off */
-				
-				ColorSwitch =  ColorSwitch ? 0 : 1;
-				break;
-				
-			case S3DK_r: /* rotate start/stop*/
-				
-				RotateSwitch = RotateSwitch ? 0 : 1;
-				break;
-				
-			case S3DK_PLUS: /* rotate speed increase */
-				
-				if(RotateSwitch &amp;&amp; RotateSpeed &lt; 5)
-				{
-					if(RotateSpeed &gt;= 1.0)
-						RotateSpeed += 1.0;
-					else
-						RotateSpeed += 0.1;
-					printf(&quot;%f,\n&quot;,RotateSpeed);
-				}
-				break;
-				
-			case S3DK_MINUS: /* - -&gt; rotate speed decrease */
-				
-				if(RotateSwitch)
-				{
-					if( RotateSpeed &gt;= 2.0 )
-						RotateSpeed -= 1.0;
-					else {
-						if(RotateSpeed &gt; 0.2)
-							RotateSpeed -= 0.1;
-					}
-					printf(&quot;%f,\n&quot;,RotateSpeed);
-				}
-				break;
-				
-			case 16: /* strg + p -&gt; reset nodes ( zeroPoint to 0,0,0 ) */
-				
-				s3d_rotate(ZeroPoint, 0, 0, 0);
-				Zp_rotate = 0.0;
-				break;
-				
-			case S3DK_PAGEUP: /* change factor in calc_olsr_node_mov */
-				
-				if(Factor &lt; 0.9)
-					Factor += 0.1;
-				break;
-				
-			case S3DK_PAGEDOWN: /* change factor in calc_olsr_node_mov */
-				
-				if(Factor &gt; 0.3)
-					Factor -= 0.1;
-				break;
-				
-		}
-	} else {
-		if( (key-&gt;unicode &gt;= S3DK_PERIOD &amp;&amp; key-&gt;unicode &lt;= S3DK_9) || key-&gt;unicode == S3DK_COMMA || key-&gt;unicode == S3DK_RETURN || key-&gt;unicode == S3DK_BACKSPACE )
-			search_widget_write( key-&gt;unicode );
-	}
-}
-
-/***
- *
- * eventhandler when object clicked
- *
- ***/
-
-void object_click(struct s3d_evt *evt)
-{
-	int oid,i;
-	char ip_str[50];
-
-	if( get_search_status() == WIDGET )
-	{
-		s3dw_handle_click(evt);	
-		return;
-	}
-	
-	oid=(int)*((unsigned long *)evt-&gt;buf);
-
-	if( oid == Btn_close_id )
-	{
-		s3d_del_object(Btn_close_id);
-		s3d_del_object(Olsr_ip_label_obj);
-		Btn_close_id = Olsr_ip_label_obj = -1;
-		for(i=0; i &lt; Size; i++)
-			s3d_del_object( Olsr_neighbour_label_obj[i] );
-		free(Olsr_neighbour_label_obj);
-		Olsr_neighbour_label_obj = NULL;
-		for(i = 0; i &lt; 4; i++)
-		{
-			if(Output_border[i] != -1)
-				s3d_del_object(Output_border[i]);
-			Output_border[i] = -1;
-		}
-		return;
-	}
-
-	Olsr_node_pEtx = *lst_search(oid);
-
-	if( Olsr_node_pEtx != NULL )
-	{
-		if( Btn_close_id == -1 )
-		{
-			Btn_close_id = s3d_clone( Btn_close_obj );
-			s3d_link(Btn_close_id,0);
-			s3d_flags_on(Btn_close_id,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_scale( Btn_close_id, 0.10 );
-			s3d_translate( Btn_close_id,-Left*3.0-0.150, -Bottom*3.0-0.9, -3.0 );
-		}
-		
-		if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
-		snprintf( ip_str, 35, &quot;ip: %s&quot;, Olsr_node_pEtx-&gt;ip );
-		Olsr_ip_label_obj = s3d_draw_string( ip_str, &amp;Title_len );
-		s3d_link( Olsr_ip_label_obj, 0 );
-		s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_ip_label_obj, 0.2 );
-		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.2, -3.0 );
-		/*
-		cam_go=1;
-		if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
-		snprintf( ip_str, 35, &quot;ip: %s&quot;, Olsr_node_pEtx-&gt;ip );
-		Olsr_ip_label_obj = s3d_draw_string( ip_str, &amp;Title_len );
-		s3d_link( Olsr_ip_label_obj, 0 );
-		s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_ip_label_obj, 0.2 );
-		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
-		*/
-	} 
-}
-
-void print_etx()
-{
-	struct olsr_neigh_list *tmpNeighbour;
-	float p = 1.4;
-	int i;
-	float len = 0.0, max_len=0.0;
-
-	if( Olsr_neighbour_label_obj != NULL )
-	{
-		/* int n = sizeof(Olsr_neighbour_label_obj) / sizeof(int);*/
-		for(i=0; i &lt; Size; i++)
-			s3d_del_object( Olsr_neighbour_label_obj[i] );
-		free(Olsr_neighbour_label_obj);
-		Olsr_neighbour_label_obj = NULL;
-	}
-
-	tmpNeighbour = Olsr_node_pEtx-&gt;olsr_neigh_list;
-
-	Size = 0;
-	while(tmpNeighbour != NULL)
-	{
-		Size++;
-		tmpNeighbour = tmpNeighbour-&gt;next_olsr_neigh_list;
-	}
-
-	Olsr_neighbour_label_obj = malloc(Size*sizeof(int));
-	tmpNeighbour = Olsr_node_pEtx-&gt;olsr_neigh_list;
-
-	for(i = 0; i &lt; Size ;i++)
-	{
-		char nIpStr[60];
-		float mEtx = ( tmpNeighbour-&gt;olsr_con-&gt;left_etx + tmpNeighbour-&gt;olsr_con-&gt;right_etx ) / 2;
-
-		if( mEtx != -1000 )
-			snprintf(nIpStr, 60, &quot;%15s --&gt; %.2f&quot;,(strcmp(Olsr_node_pEtx-&gt;ip,tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip)?tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip:tmpNeighbour-&gt;olsr_con-&gt;left_olsr_node-&gt;ip),mEtx);
-		else
-			snprintf(nIpStr, 60, &quot;%15s --&gt; HNA&quot;,(strcmp(Olsr_node_pEtx-&gt;ip,tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip)?tmpNeighbour-&gt;olsr_con-&gt;right_olsr_node-&gt;ip:tmpNeighbour-&gt;olsr_con-&gt;left_olsr_node-&gt;ip));
-
-		Olsr_neighbour_label_obj[i] = s3d_draw_string( nIpStr, &amp;len );
-		s3d_link(Olsr_neighbour_label_obj[i], 0);
-		s3d_flags_on(Olsr_neighbour_label_obj[i], S3D_OF_VISIBLE );
-		s3d_scale(Olsr_neighbour_label_obj[i], 0.2 );
-		s3d_translate(Olsr_neighbour_label_obj[i], -Left*3.0-(len * 0.2)-0.15, -Bottom*3.0-p, -3.0 );
-		tmpNeighbour = tmpNeighbour-&gt;next_olsr_neigh_list;
-		p += 0.2;
-		max_len = (len &gt; max_len - 0.2)?len+0.2:max_len;
-		max_len = (Title_len &gt; max_len - 0.2)?len+0.2:max_len;
-		/* printf(&quot;title: %f len: %f maxlen: %f %s\n&quot;,Title_len,len,max_len-0.2,nIpStr);*/
-	}
-
-	if( Btn_close_id != -1)
-	{
-		if( Output_border[0] == -1 )
-		{
-			for(i = 0; i &lt; 4; i++)
-			{
-				Output_border[i] = s3d_new_object();
-				s3d_push_material( Output_border[i],
-					1.0,1.0,1.0,
-					1.0,1.0,1.0,
-					1.0,1.0,1.0);
-			}
-			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,			-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-1.0, -3.0);
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
-
-			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
-			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
-
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
-
-			s3d_push_line( Output_border[0], 0,1,0);
-			s3d_push_line( Output_border[1], 0,1,0);
-			s3d_push_line( Output_border[2], 0,1,0);
-			s3d_push_line( Output_border[3], 0,1,0);
-
-			s3d_flags_on( Output_border[0], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[1], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[2], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[3], S3D_OF_VISIBLE);
-
-			s3d_link( Output_border[0], 0);
-			s3d_link( Output_border[1], 0);
-			s3d_link( Output_border[2], 0);
-			s3d_link( Output_border[3], 0);
-		} else {
-			s3d_pop_vertex(Output_border[0], 2);
-			s3d_pop_vertex(Output_border[1], 2);
-			s3d_pop_vertex(Output_border[2], 2);
-			s3d_pop_vertex(Output_border[3], 2);
-			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,				-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-1.0, -3.0);
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
-
-			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
-			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p,	 -3.0);
-
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	 -3.0);
-		}
-	}
-}
-
-
-
-/***
- *
- * eventhandler when object change by user
- * such as Cam
- *
- ***/
-
-void object_info(struct s3d_evt *hrmz)
-{
-	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
-	if (inf-&gt;object==0)
-	{
-		CamPosition[0][0] = inf-&gt;trans_x;
-		CamPosition[0][1] = inf-&gt;trans_y;
-		CamPosition[0][2] = inf-&gt;trans_z;
-		CamPosition[1][0] = inf-&gt;rot_x;
-		CamPosition[1][1] = inf-&gt;rot_y;
-		CamPosition[1][2] = inf-&gt;rot_z;
-		Asp=inf-&gt;scale;
-		if (Asp&gt;1.0) /* wide screen */
-		{
-			Bottom=-1.0;
-			Left=-Asp;
-		} else {  /* high screen */
-			Bottom=(-1.0/Asp);
-			Left=-1.0;
-
-		}
-
-	}
-	/* printf(&quot;%f %f %f\n&quot;,inf-&gt;trans_x,inf-&gt;trans_y,inf-&gt;trans_z); */
-}
-
-void mbutton_press(struct s3d_evt *hrmz)
-{
-	struct s3d_but_info *inf;
-	inf=(struct s3d_but_info *)hrmz-&gt;buf;
-	printf(&quot;button %d, state %d\n&quot;, inf-&gt;button,inf-&gt;state);
-	return;
-}
-
-int main( int argc, char *argv[] ) {
-
-	int optchar;
-	strncpy( Olsr_host, &quot;127.0.0.1&quot;, 256 );
-	lbuf[0] = '\0';   /* init lbuf */
-
-	while ( ( optchar = getopt ( argc, argv, &quot;dhH:&quot; ) ) != -1 ) {
-
-		switch ( optchar ) {
-
-			case 'd':
-				Debug = 1;
-				break;
-
-			case 'H':
-				strncpy( Olsr_host, optarg, 256 );
-				break;
-
-			case 'h':
-			default:
-				print_usage();
-				return (0);
-
-		}
-
-	}
-
-	if ( Debug ) printf( &quot;debug mode enabled ...\n&quot; );
-
-	/* initialize obj2ip linked list */
-	lst_initialize();
-
-	/* delete olsrs3d options */
-	while ( ( optind &lt; argc ) &amp;&amp; ( argv[optind][0] != '-' ) ) optind++;   /* optind may point to ip addr of '-H' */
-	optind--;
-	argv[optind] = argv[0];   /* save program path */
-	argc -= optind;   /* jump over olsrs3d options */
-	argv += optind;
-
-	/* set extern int optind = 0 for parse_args in io.c */
-	optind = 0;
-
-
-	if (!net_init(Olsr_host))
-	{
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-		s3d_set_callback(S3D_EVENT_KEY,keypress);
-		s3d_set_callback(S3D_EVENT_QUIT,stop);
-
-		if (!s3d_init(&amp;argc,&amp;argv,&quot;olsrs3d&quot;))
-		{
-
-			if (s3d_select_font(&quot;vera&quot;))
-				printf(&quot;font not found\n&quot;);
-
-			Olsr_node_obj = s3d_import_3ds_file( &quot;objs/accesspoint.3ds&quot; );
-			Olsr_node_inet_obj = s3d_import_3ds_file( &quot;objs/accesspoint_inet.3ds&quot; );
-			Olsr_node_hna_net = s3d_import_3ds_file( &quot;objs/internet.3ds&quot; );
-			Btn_close_obj = s3d_import_3ds_file( &quot;objs/btn_close.3ds&quot; );
-			create_search_widget( 0, 0, 300 );			
-			
-			ZeroPoint = s3d_new_object();
-			Output_border[0] = Output_border[1] = Output_border[2] = Output_border[3] = -1;
-			
-			s3d_mainloop(mainloop);
-			s3d_quit();
-			net_quit();
-		}
-	}
-	return(0);
-}
-

Modified: trunk/apps/olsrs3d/net.c
===================================================================
--- trunk/apps/olsrs3d/net.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/olsrs3d/net.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,129 +0,0 @@
-/*
- * net.c
- *
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *                         Marek Lindner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lindner_marek at yahoo.de</A>&gt;
- *                         Andreas Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">andreas_lbg at gmx.de</A>&gt;
- *
- * This file is part of olsrs3d, an olsr topology visualizer for s3d.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- *
- * olsrs3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * olsrs3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;unistd.h&gt;	/* close() */
-#include &lt;errno.h&gt;
-#include &lt;string.h&gt; 	/* strlen(), memmove(), strncpy(), strncat() */
-#include &lt;netdb.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;netinet/in.h&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;fcntl.h&gt;		/* fnctl() */
-#include &quot;olsrs3d.h&quot;
-
-#define PORT 2004 		/* the port client will be connecting to  */
-char buf[MAXDATASIZE];
-
-
-int sockfd, numbytes;
-int net_init(char *host)
-{
-    struct hostent *he;
-    struct sockaddr_in their_addr; /* connector's address information  */
-
-    if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
-        herror(&quot;gethostbyname&quot;);
-        return(1);
-    }
-
-    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
-        perror(&quot;socket&quot;);
-        return(1);
-    }
-
-    their_addr.sin_family = AF_INET;    /* host byte order  */
-    their_addr.sin_port = htons(PORT);  /* short, network byte order  */
-    their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
-    memset(&amp;(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
-
-    if (connect(sockfd, (struct sockaddr *)&amp;their_addr,
-                                          sizeof(struct sockaddr)) == -1) {
-        perror(&quot;connect&quot;);
-        return(1);
-    }
-	fcntl(sockfd,F_SETFL, O_NONBLOCK);
-	return(0);
-}
-
-int net_main() {
-
-	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
-		if (errno==EAGAIN)
-			return(0); /* well, that's okay ... */
-		perror(&quot;recv&quot;);
-		return(-1);
-	}
-
-	if (numbytes==0) {
-		printf(&quot;connection reset\n&quot;);
-		return(-1);
-	}
-
-	buf[numbytes] = '\0';
-
-	/* check for potential buffer overflow */
-	if ( ( strlen( lbuf ) + strlen( buf ) ) &lt; MAXLINESIZE ) {
-
-		strncat( lbuf, buf, MAXLINESIZE );
-
-	} else {
-
-		/* hope that carriage return is now in buf */
-		if ( strlen( lbuf ) &lt; MAXLINESIZE ) {
-
-			if ( Debug ) printf( &quot;WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n&quot; );
-			strncat( lbuf, buf, MAXLINESIZE - strlen( lbuf ) );
-
-		} else {
-
-			if ( Debug ) printf( &quot;ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n&quot; );
-			strncpy( lbuf, buf, MAXLINESIZE );
-
-		}
-
-	}
-
-	process_main();
-
-	if ( ++Net_read_count &gt; 5 ) {
-		return(0);   /* continue mainloop */
-	} else {
-		return(1);   /* continue reading data from socket */
-	}
-
-}
-
-int net_quit()
-{
-    close(sockfd);
-
-    return 0;
-}
-
-

Modified: trunk/apps/olsrs3d/process.c
===================================================================
--- trunk/apps/olsrs3d/process.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/olsrs3d/process.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,517 +0,0 @@
-/*
- * process.c
- *
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *                         Marek Lindner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lindner_marek at yahoo.de</A>&gt;
- *                         Andreas Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">andreas_lbg at gmx.de</A>&gt;
- *
- * This file is part of olsrs3d, an olsr topology visualizer for s3d.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- *
- * olsrs3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * olsrs3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include &lt;stdio.h&gt; 	/* NULL */
-#include &lt;string.h&gt; 	/* strlen(), memmove() */
-#include &lt;stdlib.h&gt; 	/* rand(), malloc(), realloc(), free() */
-#include &lt;s3d.h&gt;
-#include &lt;math.h&gt;       /* sqrt() */
-#include &quot;olsrs3d.h&quot;
-#include &lt;sys/socket.h&gt;
-#include &lt;netinet/in.h&gt;
-#include &lt;arpa/inet.h&gt;
-
-
-char lbuf[MAXLINESIZE];
-
-
-
-/***
- *
- * create new or alter connection between 2 nodes
- *
- *   con_from =&gt;   current node
- *   con_to   =&gt;   node to connect to
- *   etx      =&gt;   ETX
- *
- ***/
-
-int add_olsr_con( struct olsr_node *con_from, struct olsr_node *con_to, float etx ) {
-
-	struct olsr_con **olsr_con = &amp;Con_begin;
-	struct olsr_con *prev_olsr_con = NULL;   /* previous olsr connection */
-	struct olsr_neigh_list **olsr_neigh_list;
-
-	while ( (*olsr_con) != NULL ) {
-
-		/* connection already exists */
-		if ( ( strncmp( (*olsr_con)-&gt;left_olsr_node-&gt;ip, con_from-&gt;ip, NAMEMAX ) == 0 ) &amp;&amp; ( strncmp( (*olsr_con)-&gt;right_olsr_node-&gt;ip, con_to-&gt;ip, NAMEMAX ) == 0 ) ) {
-			(*olsr_con)-&gt;left_etx = etx;
-			(*olsr_con)-&gt;left_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
-			break;
-
-		} else if ( ( strncmp( (*olsr_con)-&gt;right_olsr_node-&gt;ip, con_from-&gt;ip, NAMEMAX ) == 0 ) &amp;&amp; ( strncmp( (*olsr_con)-&gt;left_olsr_node-&gt;ip, con_to-&gt;ip, NAMEMAX ) == 0 ) ) {
-
-			(*olsr_con)-&gt;right_etx = etx;
-			(*olsr_con)-&gt;right_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
-			break;
-
-		}
-
-		/* save previous olsr connection for later use */
-		prev_olsr_con = (*olsr_con);
-
-		olsr_con = &amp;(*olsr_con)-&gt;next_olsr_con;
-
-	}
-
-	/* new connection */
-	if ( (*olsr_con) == NULL ) {
-
-		(*olsr_con) = malloc( sizeof( struct olsr_con ) );
-		if ( (*olsr_con) == NULL ) out_of_mem();
-
-		/* create connection object */
-		(*olsr_con)-&gt;obj_id = s3d_new_object();
-
-		/* add olsr node to new olsr connection in order to access the nodes from the connection list */
-		(*olsr_con)-&gt;left_olsr_node = con_from;
-		(*olsr_con)-&gt;right_olsr_node = con_to;
-
-		/* add connection color */
-		(*olsr_con)-&gt;color = 0;
-		s3d_push_material( (*olsr_con)-&gt;obj_id,
-				  1.0,1.0,1.0,
-				  1.0,1.0,1.0,
-				  1.0,1.0,1.0);
-
-		/* add connection endpoints */
-		s3d_push_vertex( (*olsr_con)-&gt;obj_id, (*olsr_con)-&gt;left_olsr_node-&gt;pos_vec[0], (*olsr_con)-&gt;left_olsr_node-&gt;pos_vec[1], (*olsr_con)-&gt;left_olsr_node-&gt;pos_vec[2] );
-		s3d_push_vertex( (*olsr_con)-&gt;obj_id, (*olsr_con)-&gt;right_olsr_node-&gt;pos_vec[0], (*olsr_con)-&gt;right_olsr_node-&gt;pos_vec[1], (*olsr_con)-&gt;right_olsr_node-&gt;pos_vec[2] );
-
-		s3d_push_line( (*olsr_con)-&gt;obj_id, 0,1,0 );
-
-		s3d_flags_on( (*olsr_con)-&gt;obj_id, S3D_OF_VISIBLE );
-
-		s3d_link( (*olsr_con)-&gt;obj_id,  ZeroPoint );
-
-		/* HNA */
-		if ( etx == -1000.00 ) {
-
-			(*olsr_con)-&gt;left_etx = etx;
-			(*olsr_con)-&gt;left_etx_sqrt = 10.0;
-			(*olsr_con)-&gt;right_etx = etx;
-			(*olsr_con)-&gt;right_etx_sqrt = 10.0;
-
-		} else {
-
-			(*olsr_con)-&gt;left_etx = etx;
-			(*olsr_con)-&gt;left_etx_sqrt = sqrt( etx );
-			(*olsr_con)-&gt;right_etx = 999.0;
-			(*olsr_con)-&gt;right_etx_sqrt = sqrt( 999.0 );
-
-		}
-
-		(*olsr_con)-&gt;next_olsr_con = NULL;
-		(*olsr_con)-&gt;prev_olsr_con = prev_olsr_con;
-
-		/* add new olsr connection to olsr nodes in order to access the connection from the olsr node */
-		olsr_neigh_list = &amp;(*olsr_con)-&gt;left_olsr_node-&gt;olsr_neigh_list;
-		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &amp;(*olsr_neigh_list)-&gt;next_olsr_neigh_list;
-		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
-		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
-		(*olsr_neigh_list)-&gt;olsr_con = (*olsr_con);
-		(*olsr_neigh_list)-&gt;next_olsr_neigh_list = NULL;
-
-		olsr_neigh_list = &amp;(*olsr_con)-&gt;right_olsr_node-&gt;olsr_neigh_list;
-		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &amp;(*olsr_neigh_list)-&gt;next_olsr_neigh_list;
-		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
-		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
-		(*olsr_neigh_list)-&gt;olsr_con = (*olsr_con);
-		(*olsr_neigh_list)-&gt;next_olsr_neigh_list = NULL;
-
-	}
-
-	return(0);
-
-}
-
-
-
-/***
- *
- * get pointer to olsr node or create new node if node string could not be found
- *
- *   **node =&gt;   pointer to current olsr_node
- *   *ip    =&gt;   node ip
- *
- *   return olsr node pointer
- *
- ***/
-
-void *get_olsr_node( struct olsr_node **olsr_node, char *ip ) {
-
-	int result;   /* result of strcmp */
-
-	while ( (*olsr_node) != NULL ) {
-
-		result = strncmp( (*olsr_node)-&gt;ip, ip, NAMEMAX );
-
-		/* we found the node */
-		if ( result == 0 ) {
-
-			(*olsr_node)-&gt;last_seen = Output_block_counter;
-
-			/* former invisble (deleted) node */
-			if ( (*olsr_node)-&gt;visible == 0 ) {
-
-				(*olsr_node)-&gt;node_type = 0;
-				(*olsr_node)-&gt;node_type_modified = 1;
-
-				(*olsr_node)-&gt;visible = 1;
-
-				(*olsr_node)-&gt;mov_vec[0] = (*olsr_node)-&gt;mov_vec[1] = (*olsr_node)-&gt;mov_vec[2] = 0.0;
-
-				if ( Debug ) printf( &quot;new olsr node: %s\n&quot;, (*olsr_node)-&gt;ip );
-
-				Olsr_node_count++;
-
-			}
-
-			return (*olsr_node);
-
-		}
-
-		/* the searched node must be in the subtree */
-		if ( result &lt; 0 ) {
-			olsr_node = &amp;(*olsr_node)-&gt;right;
-		} else {
-			olsr_node = &amp;(*olsr_node)-&gt;left;
-		}
-
-	}
-
-	/* if node is NULL we reached the end of the tree and must create a new olsr_node */
-	if ( (*olsr_node) == NULL ) {
-
-		(*olsr_node) = malloc( sizeof( struct olsr_node ) );
-		if ( (*olsr_node) == NULL ) out_of_mem();
-
-		(*olsr_node)-&gt;left = NULL;
-		(*olsr_node)-&gt;right = NULL;
-
-		strncpy( (*olsr_node)-&gt;ip, ip, NAMEMAX );
-
-		(*olsr_node)-&gt;node_type = 0;
-		(*olsr_node)-&gt;node_type_modified = 1;
-
-		(*olsr_node)-&gt;last_seen = Output_block_counter;
-		(*olsr_node)-&gt;visible = 1;
-
-		if ( Debug ) printf( &quot;new olsr node: %s\n&quot;, (*olsr_node)-&gt;ip );
-
-		Olsr_node_count++;
-
-		(*olsr_node)-&gt;pos_vec[0] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)-&gt;pos_vec[1] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)-&gt;pos_vec[2] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)-&gt;mov_vec[0] = (*olsr_node)-&gt;mov_vec[1] = (*olsr_node)-&gt;mov_vec[2] = 0.0;
-
-		(*olsr_node)-&gt;obj_id = -1;
-		(*olsr_node)-&gt;desc_id = -1;
-		(*olsr_node)-&gt;olsr_neigh_list = NULL;
-
-		return (*olsr_node);
-
-	}
-	return(0);
-}
-
-/*
- *
- * initialize the struct for a linked list obj2ip
- *
- */
-
-void lst_initialize() {
-	Obj_to_ip_head = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	Obj_to_ip_end = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	if(Obj_to_ip_head == NULL || Obj_to_ip_end == NULL)
-		out_of_mem();
-	Obj_to_ip_head-&gt;id = 0;
-	Obj_to_ip_end-&gt;id = 0;
-	Obj_to_ip_head-&gt;prev = Obj_to_ip_end-&gt;prev = Obj_to_ip_head;
-	Obj_to_ip_head-&gt;next = Obj_to_ip_end-&gt;next = Obj_to_ip_end;
-	List_ptr = Obj_to_ip_head;
-}
-
-/*
- *
- * add a link object_id to olsr_node, to get ip adress and coordinates per object_id
- *                 id =&gt; object_id, returned from s3d_clone or s3d_new_object
- *  **olsr_node =&gt; pointer to pointer of current olsr_node
- *
- */
-
-void lst_add(int id,struct olsr_node **olsr_node) {
-	struct Obj_to_ip *new;
-	new = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	if(new == NULL)
-		out_of_mem();
-	new-&gt;id = id;
-	new-&gt;olsr_node = *olsr_node;
-	move_lst_ptr(&amp;id);
-	new-&gt;prev = List_ptr;
-	new-&gt;next = List_ptr-&gt;next;
-	List_ptr-&gt;next-&gt;prev = new;
-	List_ptr-&gt;next = new;
-	/* printf(&quot;obj2ip: add object %d between %d .. %d ip %s to list\n&quot;,new-&gt;id,new-&gt;prev-&gt;id,new-&gt;next-&gt;id,new-&gt;olsr_node-&gt;ip); */
-}
-
-/*
- *void move_lst_ptr(int *id)
- * remove element from obj2ip linked list
- * id =&gt; object_id, returned from s3d_clone or s3d_new_object
- *
- */
-
-void lst_del(int id) {
-	struct Obj_to_ip *del;
-	move_lst_ptr(&amp;id);
-	if(id != List_ptr-&gt;id)
-	{
-		printf(&quot;obj2ip: remove id %d failed move_lst_ptr return id %d\n&quot;,id,List_ptr-&gt;next-&gt;id);
-	} else {
-		del = List_ptr;
-		List_ptr-&gt;next-&gt;prev = List_ptr-&gt;prev;
-		List_ptr-&gt;prev-&gt;next = List_ptr-&gt;next;
-		/* printf(&quot;obj2ip: remove object %d --&gt; %d &lt;-- %d ip %s from list\n&quot;,List_ptr-&gt;prev-&gt;id,del-&gt;id,List_ptr-&gt;next-&gt;id,del-&gt;olsr_node-&gt;ip); */
-		free(del);
-	}
-}
-
-/*
- *
- * move the List_ptr one positon ahead the searched element
- *	*id =&gt; pointer of object_id , returned from s3d_clone or s3d_new_object
- *
- */
-
-void move_lst_ptr(int *id) {
-	/* printf(&quot;obj2ip: move for %d\n&quot;,*id); */
-	/* head to point at end or id lass then first element in linked list*/
-	if(Obj_to_ip_head-&gt;next == Obj_to_ip_head || *id &lt; Obj_to_ip_head-&gt;next-&gt;id)
-		List_ptr = Obj_to_ip_head;
- 	/* id is greather then last element in linked list */
-	else if(*id &gt; Obj_to_ip_end-&gt;prev-&gt;id)
-		List_ptr = Obj_to_ip_end-&gt;prev;
-	else {
-		/* printf(&quot;obj2ip: ok i search deeper ;-) for id=%d\n&quot;,*id); */
-		if((*id - (int) Obj_to_ip_head-&gt;next-&gt;id) &lt;= ((int)(Obj_to_ip_end-&gt;prev-&gt;id)-*id)) {
-			List_ptr = Obj_to_ip_head;
-			/* printf(&quot;obj2ip: start at head id %d - %d &lt;= %d - %d \n&quot;,*id,Obj_to_ip_head-&gt;next-&gt;id,Obj_to_ip_end-&gt;prev-&gt;id,*id); */
-			while(*id &gt;= List_ptr-&gt;next-&gt;id) {
-				/* printf(&quot;obj2ip: %d &gt; %d move to &quot;,*id,List_ptr-&gt;id); */
-				List_ptr = List_ptr-&gt;next;
-				/* printf(&quot;%d\n&quot;,List_ptr-&gt;id); */
-			}
-		} else {
-			List_ptr = Obj_to_ip_end;
-			/* printf(&quot;obj2ip: start at end id %d - %d &gt; %d - %d \n&quot;,*id,Obj_to_ip_head-&gt;next-&gt;id,Obj_to_ip_end-&gt;prev-&gt;id,*id);  */
-			/*  do List_ptr = List_ptr-&gt;prev; while(*id &gt; List_ptr-&gt;prev-&gt;id); */
-			while(*id &lt; List_ptr-&gt;prev-&gt;id) {
-				/* printf(&quot;obj2ip: %d &lt; %d move to &quot;,*id,List_ptr-&gt;id); */
-				List_ptr = List_ptr-&gt;prev;
-				/* printf(&quot;%d\n&quot;,List_ptr-&gt;id); */
-			}
-			List_ptr = List_ptr-&gt;prev;
-		}
-		/* printf(&quot;obj2ip: found id to insert between %d--&gt; .. &lt;--%d to search/delete %d--&gt; .. &lt;--%d\n&quot;,List_ptr-&gt;id,List_ptr-&gt;next-&gt;next-&gt;id,List_ptr-&gt;prev-&gt;id,List_ptr-&gt;next-&gt;id); */
-	}
-}
-
-/*
- *
- * search a object_id in linked list and return pointer on struct olsr_node
- *	id =&gt; object_id , returned from s3d_clone or s3d_new_object
- *
- * &lt;example&gt;
- *     struct olsr_node *olsr_node;
- *     olsr_node = *lst_search(oid);
- *     printf(&quot;obj2ip: search return %s\n&quot;,olsr_node-&gt;ip);
- * &lt;/example&gt;
- *
- */
-
-struct olsr_node **lst_search(int id) {
-	move_lst_ptr(&amp;id);
-	/* TODO: return NULL when no node found */
-	/* if(id != List_ptr-&gt;id) */
-		/* printf(&quot;obj2ip: search id....id not found\n&quot;); */
-	/* else */
-		/* printf(&quot;obj2ip: search found objekt_id=%d objekt_ip=%s\n&quot;,List_ptr-&gt;id,List_ptr-&gt;olsr_node-&gt;ip); */
-	return(&amp;List_ptr-&gt;olsr_node);
-}
-
-void lst_out() {
-	struct Obj_to_ip *ptr;
-	ptr = Obj_to_ip_head;
-	while(ptr != ptr-&gt;next) {
-		printf(&quot;id-&gt; %d\n&quot;,ptr-&gt;id);
-		ptr = ptr-&gt;next;
-	}
-}
-
-int process_main() {
-
-	int dn;
-	float f;
-	char *lbuf_ptr, *last_cr_ptr, *con_from, *con_from_end, *con_to, *con_to_end, *etx, *etx_end, *tmpChar;
-	struct olsr_node *olsr_node1;   /* pointer to olsr nodes */
-	struct olsr_node *olsr_node2;
-	int address;
-	char hna_name[NAMEMAX];
-	char hna_node[NAMEMAX];
-
-	lbuf_ptr = lbuf;
-	last_cr_ptr = NULL;
-
-	con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
-	dn = 0;
-
-	/*printf(&quot;---lbuf-start---\n%s\n---lbuf-end---\n&quot;,lbuf);*/
-
-	while ( (*lbuf_ptr) != '\0' ) {
-
-		/* printf( &quot;%c&quot;,(*lbuf_ptr) ); */
-
-		if ( (*lbuf_ptr) == '\n' ) {
-
-			last_cr_ptr = lbuf_ptr;
-			con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
-			dn = 0;
-
-		}
-
-		if ( (*lbuf_ptr) == '&quot;' ) {
-
-			switch ( dn ) {
-
-				case 0:
-					con_from = lbuf_ptr + 1;
-					break;
-				case 1:
-					con_from_end = lbuf_ptr;
-					break;
-				case 2:
-					con_to = lbuf_ptr + 1;
-					break;
-				case 3:
-					con_to_end = lbuf_ptr;
-					break;
-				case 4:
-					etx = lbuf_ptr + 1;
-					break;
-				case 5:
-					etx_end = lbuf_ptr;
-					break;
-
-			}
-
-			if ( ++dn == 6 ) {
-
-				/* terminate strings - but not before 6 times '&quot;' */
-				(*con_from_end) = (*con_to_end) = (*etx_end) = '\0';
-
-				/* printf( &quot;con_from: %s, con_to: %s, etx: %s\n&quot;, con_from, con_to, etx ); */
-
-				/* announced network via HNA */
-				if ( strncmp( etx, &quot;HNA&quot;, NAMEMAX ) == 0 ) {
-
-					/* connection to internet */
-					if ( strncmp( con_to, &quot;0.0.0.0/0.0.0.0&quot;, NAMEMAX ) == 0 ) {
-
-						olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );
-
-						if ( olsr_node1-&gt;node_type != 1 ) {
-
-							olsr_node1-&gt;node_type = 1;
-							olsr_node1-&gt;node_type_modified = 1;
-							if ( Debug ) printf( &quot;new internet: %s\n&quot;, olsr_node1-&gt;ip );
-
-						}
-
-					/* normal HNA */
-					} else {
-						memmove(hna_node,con_to,NAMEMAX);
-						if( (tmpChar = strchr(hna_node, (int)'/')))
-						{
-							tmpChar++;
-							address = (int)-inet_network(tmpChar);
-							sprintf(hna_name,&quot;%d&quot;,(int)(32 - ceil(log(address)/log(2))));
-							strcpy(tmpChar,hna_name);
-						}
-
-						olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );
-						olsr_node2 = get_olsr_node( &amp;Olsr_root, hna_node );
-
-						if ( olsr_node2-&gt;node_type != 2 ) {
-
-							olsr_node2-&gt;node_type = 2;
-							olsr_node2-&gt;node_type_modified = 1;
-							if ( Debug ) printf( &quot;new hna network: %s\n&quot;, olsr_node2-&gt;ip );
-
-						}
-						if ( olsr_node1-&gt;visible &amp;&amp; olsr_node2-&gt;visible )
-							add_olsr_con( olsr_node1, olsr_node2, -1000.00 );
-
-					}
-
-				/* normal node */
-				} else {
-
-					olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );
-					olsr_node2 = get_olsr_node( &amp;Olsr_root, con_to );
-					f = strtod(etx,NULL);
-					if ( f &lt; 1.0 )
-						f = 999.0;
-					add_olsr_con( olsr_node1, olsr_node2, f );
-				}
-				/* remove zerobyte */
-				(*con_from_end) = (*con_to_end) = (*etx_end) = '&quot;';
-
-				con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
-				dn = 0;
-				last_cr_ptr = lbuf_ptr;
-
-			}
-
-		} else if ( ( (*lbuf_ptr) == '}' ) &amp;&amp; ( (*(lbuf_ptr + 1)) == '\n' ) ) {
-
-			Output_block_completed = 1;
-
-		}
-
-		lbuf_ptr++;
-
-	}
-
-	if ( last_cr_ptr != NULL ) memmove( lbuf, last_cr_ptr + 1, strlen( last_cr_ptr ) );
-	/*printf(&quot;---memmove-lbuf-start---\n%s\n---memmove-lbuf-end---\n&quot;,lbuf);*/
-	return(0);
-
-}

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/olsrs3d/search.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,304 +0,0 @@
-/*
- * search.c
- * 
- * Copyright (C) 2006 Andreas Langer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">andreas_lbg at gmx.de</A>&gt;
- *
- * This file is part of the olsrs3d, an olsr topology visualizer for s3d.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include &lt;s3d.h&gt;
-#include &lt;s3dw.h&gt;
-#include &lt;s3d_keysym.h&gt;
-#include &lt;math.h&gt;
-#include &lt;stdio.h&gt;	/* TODO can remove then no more printf needed */
-#include &lt;string.h&gt;
-#include &quot;structs.h&quot;
-#include &quot;search.h&quot;
-
-s3dw_surface	*_search_surface;
-s3dw_input		*_search_input;
-s3dw_widget		*_search_widget;
-
-struct olsr_node *_node_root = NULL;
-struct olsr_node **search_node = NULL;
-
-float	_return_point[2][3];				/* cam position before move to the widget */
-int		_search_status = NOTHING;			/* status of search */
-											
-void _search_node(s3dw_widget *dummy);
-void _abort_search(s3dw_widget *dummy);
-
-/* public */
-void follow_node(float cam_position_t[], float cam_position_r[],float rotate)
-{
-	float real_node_pos[3],
-		  cam_target[3],
-		  tmp_vec[3],
-		  diff_vec[3],
-		  angle;
-	
-	real_node_pos[0] =  (*search_node)-&gt;pos_vec[0] * cos( rotate * M_PI / 180.0 ) - (*search_node)-&gt;pos_vec[2] * -sin ( rotate * M_PI / 180.0 );
-	real_node_pos[1] =  (*search_node)-&gt;pos_vec[1];
-	real_node_pos[2] =  (*search_node)-&gt;pos_vec[0] * -sin( rotate * M_PI / 180.0) + (*search_node)-&gt;pos_vec[2] * cos ( rotate * M_PI / 180.0 );
-
-	cam_target[0] = ( real_node_pos[0] + 7);
-	cam_target[1] =   real_node_pos[1];
-	cam_target[2] = ( real_node_pos[2] + 7);
-	
-	cam_position_t[0]=( cam_position_t[0] * 4 + cam_target[0] ) / 5;
-	cam_position_t[1]=( cam_position_t[1] * 4 + cam_target[1] ) / 5;
-	cam_position_t[2]=( cam_position_t[2] * 4 + cam_target[2] ) / 5;
-	
-	tmp_vec[0] =  0.0;
-	tmp_vec[1] =  0.0;
-	tmp_vec[2] = -1.0;
-	
-	diff_vec[0] = cam_position_t[0] - real_node_pos[0];
-	diff_vec[1] = 0.0;
-	diff_vec[2] = cam_position_t[2] - real_node_pos[2];
-	angle = s3d_vector_angle( diff_vec, tmp_vec );
-	/* angle = ( real_node_pos[0] &gt; 0) ? ( 180 - ( 180 / M_PI * angle ) ) : ( 180 + ( 180 / M_PI * angle ) ); */
-	angle = 180 - ( 180 / M_PI * angle );
-	cam_position_r[1] = ( cam_position_r[1] * 4 + angle ) / 5;
-	
-	s3d_translate( 0, cam_position_t[0], cam_position_t[1], cam_position_t[2] );
-	s3d_rotate( 0, cam_position_r[0], cam_position_r[1], cam_position_r[2] );
-}
-
-/* public */
-void create_search_widget(float x, float y, float z)
-{
-	s3dw_button *search_button, *abort_button;
-	
-	_search_surface	= s3dw_surface_new( &quot;Node Search&quot;, 17, 10 );
-	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
-	
-	s3dw_label_new( _search_surface, &quot;Enter the IP of the node.&quot;, 1, 2);
-	s3dw_focus( S3DWIDGET( _search_input ) );
-	
-	search_button = s3dw_button_new( _search_surface, &quot;Search&quot;, 11.5, 7 );
-	abort_button  = s3dw_button_new( _search_surface, &quot;Abort&quot;, 1, 7 );
-	search_button-&gt;onclick = _search_node;
-	abort_button-&gt;onclick = _abort_search;
-
-	/* TODO calc position for ok button */
-	
-	s3dw_focus	( S3DWIDGET( _search_input ) );	
-	s3dw_focus	( S3DWIDGET( _search_surface ) );
-	s3dw_show	( S3DWIDGET( _search_surface ) );
-	
-	_search_widget	= s3dw_getroot();
-	move_search_widget( x, y, z );
-
-	_search_widget-&gt;ary = 180;
-	s3d_rotate( _search_widget-&gt;oid, _search_widget-&gt;arx, _search_widget-&gt;ary, _search_widget-&gt;arz );
-}
-
-/* public */
-void move_search_widget(float x, float y, float z)
-{
-	_search_widget-&gt;x = x; _search_widget-&gt;y = y; _search_widget-&gt;z = z;
-	s3dw_moveit( _search_widget );
-}
-
-/* public */
-void move_to_search_widget(float cam_position_t[], float cam_position_r[])
-{
-	float target, current;
-	
-	set_search_status(WIDGET);
-	cam_position_t[0] = ( cam_position_t[0] * 4 + _search_widget-&gt;x ) / 5;
-	cam_position_t[1] = ( cam_position_t[1] * 4 + _search_widget-&gt;y ) / 5;
-	cam_position_t[2] = ( cam_position_t[2] * 4 + ( _search_widget-&gt;z - 10 ) ) / 5;
-
-	target = _search_widget-&gt;arx;
-	current = cam_position_r[0];
-
-	if( _search_widget-&gt;arx - cam_position_r[0] &gt; 180 )
-		target -= 360;
-	if( _search_widget-&gt;arx - cam_position_r[0] &lt; -180 )
-		current -= 360;
-	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
-
-	target = _search_widget-&gt;ary;
-	current = cam_position_r[1];
-
-	if( _search_widget-&gt;ary - cam_position_r[1] &gt; 180 )
-		target -= 360;
-	if( _search_widget-&gt;ary - cam_position_r[1] &lt; -180 )
-		current -= 360;
-	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
-
-	target = _search_widget-&gt;arz;
-	current = cam_position_r[2];
-
-	if( _search_widget-&gt;arz - cam_position_r[2] &gt; 180 )
-		target -= 360;
-	if( _search_widget-&gt;arz - cam_position_r[2] &lt; -180 )
-		current -= 360;
-	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
-	
-	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
-	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
-	
-	if ( sqrt(  (( cam_position_t[0] - _search_widget-&gt;x)*( cam_position_t[0] - _search_widget-&gt;x)) + 
-				(( cam_position_t[1] - _search_widget-&gt;y)*( cam_position_t[1] - _search_widget-&gt;y)) + 
-				(( cam_position_t[2] - _search_widget-&gt;z)*( cam_position_t[2] - _search_widget-&gt;z)) ) &lt; 0.2 )
-	{
-		s3d_translate( 0, _search_widget-&gt;x, _search_widget-&gt;y, ( _search_widget-&gt;z - 10 ) );
-		s3d_rotate( 0, _search_widget-&gt;arx, _search_widget-&gt;ary, _search_widget-&gt;arz );
-	}
-}
-
-/* public */
-void move_to_return_point(float cam_position_t[], float cam_position_r[])
-{
-	float target, current;
-
-	cam_position_t[0] = ( cam_position_t[0] * 4 + _return_point[0][0] ) / 5;
-	cam_position_t[1] = ( cam_position_t[1] * 4 + _return_point[0][1] ) / 5;
-	cam_position_t[2] = ( cam_position_t[2] * 4 + _return_point[0][2] ) / 5;
-
-	target = _return_point[1][0];
-	current = cam_position_r[0];
-
-	if( _return_point[1][0] - cam_position_r[0] &gt; 180 )
-		target -= 360;
-	if( _return_point[1][0] - cam_position_r[0] &lt; -180 )
-		current -= 360;
-	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
-
-	target = _return_point[1][1];
-	current = cam_position_r[1];
-
-	if( _return_point[1][1] - cam_position_r[1] &gt; 180 )
-		target -= 360;
-	if( _return_point[1][1] - cam_position_r[1] &lt; -180 )
-		current -= 360;
-	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
-
-	target = _return_point[1][2];
-	current = cam_position_r[2];
-
-	if( _return_point[1][2] - cam_position_r[2] &gt; 180 )
-		target -= 360;
-	if( _return_point[1][2] - cam_position_r[2] &lt; -180 )
-		current -= 360;
-	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
-	
-	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
-	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
-	
-	if ( sqrt(  (( cam_position_t[0] - _return_point[0][0])*( cam_position_t[0] - _return_point[0][0])) + 
-				(( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) + 
-				(( cam_position_t[2] - _return_point[0][2])*( cam_position_t[2] - _return_point[0][2])) ) &lt; 0.2 )
-	{
-		s3d_translate( 0, _return_point[0][0], _return_point[0][1], _return_point[0][2] );
-		s3d_rotate( 0, _return_point[1][0], _return_point[1][1], _return_point[1][2] );
-		set_search_status(NOTHING);
-	}
-}
-
-/* public */
-void search_widget_write(int key)
-{
-	static char s[20];
-	int ln = strlen(s);
-	
-	if( key == S3DK_COMMA ) key = S3DK_PERIOD;
-	
-	if( key != S3DK_RETURN )
-	{
-		if( key == S3DK_BACKSPACE )
-		{
-			if( ln &gt; 0 )
-				s[ln-1] = '\0';
-		} else {
-			if( ln &lt; 20 )
-				s[ln] = key;
-		}
-		s3dw_input_change_text( _search_input, s );
-	} else {
-		_search_node( _search_widget );	
-	}
-}
-
-/* public */
-void set_return_point(float cam_position_t[], float cam_position_r[])
-{
-	int i;
-	for( i = 0; i &lt; 3; i++ )
-		_return_point[0][i] = cam_position_t[i];
-	for( i = 0; i &lt; 3; i++ )
-		_return_point[1][i] = cam_position_r[i];
-}
-
-/* public */
-int get_search_status(void)
-{
-	return _search_status;
-}
-
-/* public */
-void set_search_status(int stat)
-{
-	/* TODO check if stat between 0-3 else debug printf */
-	_search_status = stat;
-}
-
-/* public */
-void set_node_root(struct olsr_node *root)
-{
-	_node_root = root;
-}
-
-/* private */
-void _search_node(s3dw_widget *dummy)
-{
-	char *ip;
-	int result;
-	
-	search_node = &amp;_node_root;
-	
-	ip = s3dw_input_gettext( _search_input );
-	
-	while ( (*search_node) != NULL )
-	{
-
-		result = strncmp( (*search_node)-&gt;ip, ip, NAMEMAX );
-
-		if ( result == 0 ) 
-			break;
-		
-		if ( result &lt; 0 )
-			(*search_node) = (*search_node)-&gt;right;
-		else
-			(*search_node) = (*search_node)-&gt;left;
-	}
-
-	if( (*search_node) != NULL )
-		set_search_status( FOLLOW );
-}
-
-/* private */
-void _abort_search(s3dw_widget *dummy)
-{
-	set_search_status(ABORT);
-}
-
-	

Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,217 +0,0 @@
-/*
- * s3d_x11gate.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d_x11gate, a 3d gateway for x11 desktops.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d_x11gate is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d_x11gate is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d_x11gate; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include &lt;s3d.h&gt;		 /*  s3d_*() */
-#include &lt;stdlib.h&gt; 	 /*  getenv() */
-#include &lt;stdio.h&gt;		 /*  printf() */
-#include &lt;X11/Xlib.h&gt;	 /*  Ximage, Display, X*() */
-#include &lt;X11/Xutil.h&gt;	 /*  XDestroyImage() */
-#define XK_MISCELLANY
-#include &lt;X11/keysymdef.h&gt;	 /* keysyms */
-#include &lt;X11/extensions/XTest.h&gt;	/* keyboard/mouse input via s3d */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
-
-int oid;
-XImage *image;
-Display *dpy=0;
-int window,scr;
-int width,height;
-char *tex_image=NULL,*otex_image=NULL,*img1,*img2;
-int get_shift(unsigned long t)
-{
-	int i=0;
-	while (t)
-	{
-		t&gt;&gt;=1;
-		i++;
-	}
-	return(i);
-}
-void mainloop()
-{
-	int x,y;
-	int rs,gs,bs;
-	unsigned long d;
-	int bpp;
-	char *swap_timg;
-	int last_change,start_change;
-	image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);
-	if (image-&gt;format==ZPixmap)
-	{
-		printf(&quot;Ximage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n&quot;,image-&gt;width,image-&gt;height,image-&gt;format,ZPixmap,
-					image-&gt;bits_per_pixel,image-&gt;depth,image-&gt;bitmap_pad);
-		rs=get_shift(image-&gt;red_mask)-8;
-		gs=get_shift(image-&gt;green_mask)-8;
-		bs=get_shift(image-&gt;blue_mask)-8;
-
-		bpp=(image-&gt;bits_per_pixel/8);
-		/* rgb is not bgr */
-		rs=rs;
-		gs=gs-8;
-		bs=bs-16;
-		printf(&quot;Ximage: rgb: %d|%d|%d\n&quot;,	rs,gs,bs);;
-/*		printf(&quot;red: size %d, offset %d\n&quot;,rs,roff);
-		printf(&quot;green: size %d, offset %d\n&quot;,gs,goff);
-		printf(&quot;blue: size %d, offset %d\n&quot;,bs,boff);
-		printf(&quot;bits per pixel:%d\n&quot;,bpp);*/
-		last_change=-1;
-		start_change=-1;
-		for (y=0;y&lt;height;y++)
-		{
-			
-			for (x=0;x&lt;width;x++)
-			{
-				d=*((unsigned long *)(image-&gt;data+(y*width+x)*bpp));
-				((unsigned long *)tex_image)[(y*width+x)]=
-						(rs&gt;0?((d&amp;image-&gt;red_mask)&gt;&gt;rs):	((d&amp;image-&gt;red_mask)&lt;&lt;-rs))|
-						(gs&gt;0?((d&amp;image-&gt;green_mask)&gt;&gt;gs):	((d&amp;image-&gt;green_mask)&lt;&lt;-gs))|
-						(bs&gt;0?((d&amp;image-&gt;blue_mask)&gt;&gt;bs):	((d&amp;image-&gt;blue_mask)&lt;&lt;-bs))|
-						255&lt;&lt;24;
-				if (((unsigned long *)tex_image)[(y*width+x)]!=
-					((unsigned long *)otex_image)[(y*width+x)])
-					last_change=y;
-			}
-			if (last_change!=-1)
-			{
-				if (start_change==-1)
-				{
-					start_change=y;
-/* 					printf(&quot;setting start_change to %d\n&quot;,start_change); */
-				}
-				if (last_change!=y)
-				{	 /*  last change is already over, post it! */
-/*					printf(&quot;[%d to %d]&quot;,start_change,last_change);*/
-					s3d_load_texture(oid,0,0,start_change,width,last_change-start_change+1,(unsigned char *)tex_image+start_change*width*4);
-					start_change=-1;
-					last_change=-1;
-				}
-			}
-		}
-		 /*  posting the last bit, maybe */
-		if (last_change!=-1)
-		{
-/*			printf(&quot;last one: [%d-%d]&quot;,start_change,last_change);*/
-			s3d_load_texture(oid,0,0,start_change,width,last_change-start_change,(unsigned char *)tex_image+start_change*width*4);
-		}
-/* 		s3d_load_texture(oid,0,0,0,width,height,tex_image); */
-		 /*  swap images */
-		swap_timg=tex_image;
-		tex_image=otex_image;
-		otex_image=swap_timg;
-	}
-	XDestroyImage(image);
-
-	nanosleep(&amp;t,NULL); 
-}
-void keypress(struct s3d_evt *event)
-{
-	int key;
-	int kc;
-	key=*((unsigned short *)event-&gt;buf);
-	printf(&quot;received key %d &quot;,key);
-    kc = XKeysymToKeycode(dpy, key);
-	if (kc==0) 
-	{
-	    kc = XKeysymToKeycode(dpy, 0xFF00+ key);
-		printf(&quot; (%04x) &quot;,0xFF00+key);
-	}
-	if (kc==0)
-	{
-		if (key==8)
-		{
-			kc=22; printf(&quot;!backspace!&quot;);
-		}
-	}
-	printf(&quot;using key: %d, keycode %d (%04x)\n&quot;,key,kc,kc);
-	if (kc!=0)
-	    XTestFakeKeyEvent(dpy, kc, 1, 1);
-/*	    XTestFakeKeyEvent(dpy, kc, 0, 1);*/
-
-}
-void mouseclick(struct s3d_evt *event)
-{
-	printf(&quot;not processing mouse clicks yet ... \n&quot;);
-}
-int main(int argc, char **argv)
-{
-	char *disp=NULL;
-	int a,b,c,d;
-	int xt;
-	if (disp==NULL) disp=getenv(&quot;DISPLAY&quot;);
-	if (disp==NULL) disp=&quot;&quot;;  /*  fallback */
-	dpy = XOpenDisplay(disp);
-	if (!dpy)
-	{
-		printf(&quot;couldn't open display\n&quot;);
-		return(-1);
-	}
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;X11-gate&quot;))
-	{
-		scr = DefaultScreen(dpy);
-		window = RootWindow(dpy, scr);
-		width = DisplayWidth(dpy, scr);
-		height = DisplayHeight(dpy, scr);
-		XLockDisplay(dpy);
-		xt=XTestQueryExtension(dpy,&amp;a,&amp;b,&amp;c,&amp;d);
-		XUnlockDisplay(dpy);
-		if (xt)
-		{
-			printf(&quot;having xtest extension ...\n&quot;);
-		}
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,mouseclick);
-		s3d_set_callback(S3D_EVENT_KEY,keypress);
-		printf(&quot;screen: %dx%d\n&quot;,width,height);
-		img1=malloc(width*height*4);
-		img2=malloc(width*height*4);
-		tex_image=img1;
-		otex_image=img2;
-		oid=s3d_new_object();
-		s3d_push_vertex(oid,-5,-5,0);
-		s3d_push_vertex(oid, 5,-5,0);
-		s3d_push_vertex(oid, 5, 5,0);
-		s3d_push_vertex(oid,-5, 5,0);
-		s3d_push_material_a(oid,
-						0.8,	0.0,	0.0	,1.0,
-						1.0,	1.0,	1.0	,1.0,
-						0.8,	0.0,	0.0	,1.0);
-		s3d_push_polygon(oid,0,2,1,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,1.0, 
-									   1.0,0.0,
-									   1.0,1.0);
-		s3d_push_polygon(oid,0,3,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,1.0, 
-									   0.0,0.0,
-									   1.0,0.0);
-		s3d_push_texture(oid,width,height);
-					 /*  push data on texture 0 position (0,0) */
-		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
-		s3d_flags_on(oid,S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-		free(img1);
-		free(img2);
-	}
-	s3d_quit();
-	return(0);
-}

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/animation.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,172 +0,0 @@
-/*
- * animation.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3dfm, a s3d file manager.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include &quot;s3dfm.h&quot;
-#include &lt;s3dw.h&gt;
-#include &lt;stdio.h&gt; 	 /*  printf(),NULL */
-#include &lt;math.h&gt;	 /*  fabs() */
-#define SCALE 	1
-
-/* the animation stack */
-static t_item *ani_s[MAXANI];
-static int ani_n=0;
-extern t_item root,cam;
-int moveon=1;
-
-/* get the scale for the rootbox zoom */
-float ani_get_scale(t_item *f)
-{
-	float scale,s;
-	s=0.2;
-	scale=1/s;
-	if (f-&gt;parent!=NULL)
-		scale=1/s*ani_get_scale(f-&gt;parent);
-	else
-		return(1.0);
-	root.px-=f-&gt;px;
-	root.pz-=f-&gt;pz;
-	root.py-=BOXHEIGHT+f-&gt;detached*DETHEIGHT;
-	root.px*=1/s;
-	root.py*=1/s;
-	root.pz*=1/s;
-	
-	return(scale);
-}
-/* center f for the viewer, therefore moving the root box ... */
-void ani_focus(t_item *f)
-{
-	root.px=0.0;
-	root.py=0.0;
-	root.pz=0.0;
-	moveon=1;
-/*	printf(&quot;[Z]ooming to %s\n&quot;,f-&gt;name);*/
-	box_collapse_grandkids(f);
-	root.scale=ani_get_scale(f);
-	root.py-=1.5;
-/*	printf(&quot;[R]escaling to %f\n&quot;,root.scale);
-	printf(&quot;px: %f py:%f pz: %f\n&quot;,root.px,root.py,root.pz);*/
-
-	ani_add(&amp;root);
-	if (((cam.dpx-cam.px)* (cam.dpx-cam.px) + (cam.dpy-cam.py)* (cam.dpy-cam.py) 
-		  + (cam.dpz-cam.pz)* (cam.dpz-cam.pz))	&gt; ( 10 * 10))
-	{
-		cam.px=0;
-		cam.py=0;
-		cam.pz=5;
-		ani_add(&amp;cam);
-	}
-}
-/* is item f already on stack? */
-int ani_onstack(t_item *f)
-{
-	int i;
-	for (i=0;i&lt;ani_n;i++)
-		if (ani_s[i]==f)
-			return(1);		/* already in list */
-	return(0);
-
-}
-/* add an item on the animation stack */
-void ani_add(t_item *f)
-{
-	if (ani_n&lt;MAXANI)
-	{
-		if (ani_onstack(f))
-			return;		/* already in list */
-		ani_s[ani_n]=f;
-		ani_iterate(f);
-	/*	printf(&quot;[A]ni ADD %d\n&quot;,ani_n); */
-		ani_n++;
-	}
-	else /* no place, finish now */
-		ani_finish(f,-1);
-}
-/* delete an item from the animation stack */
-void ani_del(int i)
-{
-	if ((i&gt;=0) &amp;&amp; (i&lt;ani_n))
-	{
-/*		printf(&quot;[A]ni DEL %d\n&quot;,i);*/
-		ani_n--;
-		ani_s[i]=ani_s[ani_n]; /* that should also work if i is the last one */
-	} else {
-		printf(&quot;[F]ATAL: can't delete animation!\n&quot;);
-	}
-}
-/* well ... */
-void ani_doit(t_item *f)
-{
-	s3d_translate(	f-&gt;block, f-&gt;dpx,f-&gt;dpy,f-&gt;dpz);
-	s3d_scale(		f-&gt;block, f-&gt;dscale);
-}
-
-/* finish an animation on the stack, stack index i */
-void ani_finish(t_item *f, int i)
-{
-	f-&gt;dpx= f-&gt;px;
-	f-&gt;dpy= f-&gt;py;
-	f-&gt;dpz= f-&gt;pz;
-	f-&gt;dscale= f-&gt;scale;
-	ani_doit(f);
-	if (i!=-1)
-		ani_del(i);
-}
-void ani_iterate(t_item *f)
-{
-	f-&gt;dpx=(f-&gt;px + f-&gt;dpx*ZOOMS)/(ZOOMS+1);
-	f-&gt;dpy=(f-&gt;py + f-&gt;dpy*ZOOMS)/(ZOOMS+1);
-	f-&gt;dpz=(f-&gt;pz + f-&gt;dpz*ZOOMS)/(ZOOMS+1);
-	f-&gt;dscale=(f-&gt;scale + f-&gt;dscale*ZOOMS)/(ZOOMS+1);
-
-}
-
-/* checks if f is good enough */
-int ani_check(t_item *f)
-{
-	float x,y,z;
-	x=f-&gt;dpx - f-&gt;px;
-	y=f-&gt;dpy - f-&gt;py;
-	z=f-&gt;dpz - f-&gt;pz;
-	if (((fabs(f-&gt;dscale - f-&gt;scale)/f-&gt;scale)&gt;0.01) || (sqrt(x*x+y*y+z*z) &gt; 0.01))
-		return(0);
-	return(1);
-}
-/* doing the whole animation thing */
-void ani_mate()
-{
-	int i;
-	t_item *f;
-	s3dw_ani_mate();
-	for (i=0;i&lt;ani_n;i++)
-	{
-		f=ani_s[i];
-		ani_iterate(f);
-		if (ani_check(f))
-		{
-			ani_finish(f,i);
-			i--; /* a new object is here now, take care in the next iteration */
-		} else {
-			ani_doit(f);
-		}
-	}
-}

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/box.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,399 +0,0 @@
-/*
- * box.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3dfm, a s3d file manager.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include &quot;s3dfm.h&quot;
-#include &lt;stdio.h&gt; 	 /*  printf() */
-#include &lt;math.h&gt;	 /*  sin(),cos() */
-#include &lt;string.h&gt;  /*  strlen() */
-
-
-/* remove old items on the box */
-void box_dissolve(t_item *dir)
-{
-	if (dir-&gt;close!=-1)		{	s3d_del_object(dir-&gt;close);		dir-&gt;close=-1; }
-	if (dir-&gt;select!=-1)	{	s3d_del_object(dir-&gt;select);	dir-&gt;select=-1; }
-	if (dir-&gt;title!=-1)		{	s3d_del_object(dir-&gt;title);		dir-&gt;title=-1; }
-	if (dir-&gt;titlestr!=-1)	{	s3d_del_object(dir-&gt;titlestr);	dir-&gt;titlestr=-1; }
-	if (dir-&gt;block!=-1)			s3d_del_object(dir-&gt;block);
-
-}
-
-
-
-/* places the string at the left side of the cube */
-void box_sidelabel(t_item *dir)
-{
-
-	s3d_rotate(dir-&gt;str,0,90,0);
-	s3d_translate(dir-&gt;str,1.1,0.3,1);
-	s3d_scale(dir-&gt;str,(float)1.8/(dir-&gt;len));
-	s3d_scale(dir-&gt;str,(float)1.8/(dir-&gt;len));
-	s3d_link(dir-&gt;str,dir-&gt;block);
-	s3d_flags_on(dir-&gt;str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-}
-
-/* creates a big block which will hold files and subdirs on top */
-int box_buildblock(t_item *dir)
-{
-	char fname[30];
-	char *fullname=fname;
-	t_item *d;
-	int i,j;
-	float len;
-	float vertices[]=
-			{-BHP,0,-BHP,
-			 -BHP,0, BHP,
-			  BHP,0, BHP,
-			  BHP,0,-BHP,
-			 -BHP,BHH,-BHP,
-			 -BHP,BHH, BHP,
-			  BHP,BHH, BHP,
-			  BHP,BHH,-BHP,
-			 -1,0, 0.8,
-			 -1,BOXHEIGHT, 0.8,
-			  1,BOXHEIGHT, 0.8,
-			  1,0, 0.8
-				};
-	float xvertices[]=
-			{
-			  0.8,BHH-0.2, 0.8,
-			  0.8,BHH    , 0.8,
-			  BHP,BHH    , 0.8,
-			  BHP,BHH-0.2, 0.8,
-			  0.8,BHH-0.2, 1.0,
-			  0.8,BHH    , 1.0,
-			  BHP,BHH    , 1.0,
-			  BHP,BHH-0.2, 1.0
-			 };
-	float svertices[]=
-			{
-			  0.6,BHH-0.2, 0.8,
-			  0.6,BHH    , 0.8,
-			  0.8,BHH    , 0.8,
-			  0.8,BHH-0.2, 0.8,
-			  0.6,BHH-0.2, 1.0,
-			  0.6,BHH    , 1.0,
-			  0.8,BHH    , 1.0,
-			  0.8,BHH-0.2, 1.0
-			 };
-	float tvertices[]=
-			{
-			  -BHP,BHH-0.2, 0.8,
-			  -BHP,BHH    , 0.8,
-			  0.6, BHH    , 0.8,
-			  0.6, BHH-0.2, 0.8,
-			  -BHP,BHH-0.2, 1.0,
-			  -BHP,BHH    , 1.0,
-			  0.6, BHH    , 1.0,
-			  0.6, BHH-0.2, 1.0
-			 };
-	unsigned long bar_poly[]={
-		4,5,6,0,
-		4,6,7,0,
-		3,7,4,0,
-		3,4,0,0
-	};
-/*	printf(&quot;new block for %s\n&quot;,dir-&gt;name);*/
-
-	dir-&gt;block=s3d_new_object();
-	s3d_push_vertices(dir-&gt;block,vertices,sizeof(vertices)/(3*sizeof(float)));
-	s3d_push_material(dir-&gt;block,
-						0.5,0.5,0.5,
-						0.5,0.5,0.5,
-						0.5,0.5,0.5
-					);
-	s3d_push_material(dir-&gt;block,
-						0.5,0.5,0.6,
-						0.5,0.5,0.6,
-						0.5,0.5,0.6);
-
-	s3d_push_polygon(dir-&gt;block,4,6,5,1);
-	s3d_push_polygon(dir-&gt;block,4,7,6,1);
-
-	s3d_push_polygon(dir-&gt;block,0,4,5,0);
-	s3d_push_polygon(dir-&gt;block,0,5,1,0);
-	
-	s3d_push_polygon(dir-&gt;block,3,7,4,0);
-	s3d_push_polygon(dir-&gt;block,3,4,0,0);
-
-	s3d_push_polygon(dir-&gt;block,2,6,7,0);
-	s3d_push_polygon(dir-&gt;block,2,7,3,0);
-	
-	s3d_push_polygon(dir-&gt;block,8,9,10,0);
-	s3d_push_polygon(dir-&gt;block,8,10,11,0);
-
-	dir-&gt;close=s3d_new_object();
-	s3d_push_material(dir-&gt;close,
-						0.5,0.3,0.3,
-						0.5,0.3,0.3,
-						0.5,0.3,0.3
-					);
-	s3d_push_vertices(dir-&gt;close,xvertices,sizeof(xvertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir-&gt;close,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
-	s3d_link(dir-&gt;close,dir-&gt;block);
-	
-	dir-&gt;select=s3d_new_object();
-	s3d_push_material(dir-&gt;select,
-						0.1,0.1,0.3,
-						0.1,0.1,0.3,
-						0.1,0.1,0.3
-					);
-	s3d_push_vertices(dir-&gt;select,svertices,sizeof(svertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir-&gt;select,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
-	s3d_link(dir-&gt;select,dir-&gt;block);
-	
-	dir-&gt;title=s3d_new_object();
-	s3d_push_material(dir-&gt;title,
-						0.3,0.3,0.3,
-						0.3,0.3,0.3,
-						0.3,0.3,0.3
-					);
-	s3d_push_vertices(dir-&gt;title,tvertices,sizeof(tvertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir-&gt;title,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
-	s3d_link(dir-&gt;title,dir-&gt;block);
-	i=28;
-	fullname[29]=0;
-	d=dir;
-	do {
-		j=strlen(d-&gt;name)-1;
-		if (NULL!=(d-&gt;parent))
-		{
-			fullname[i]='/';
-			i--;
-		}
-		while ((i &gt;= 0) &amp;&amp; (j &gt;= 0))
-		{
-			fullname[i]=d-&gt;name[j];
-			j--;
-			i--;
-		}
-		if (i&lt;0) 
-			break;
-
-
-	} while ((d=d-&gt;parent)!=NULL);
-	if (i&lt;0)
-		fullname[0]=fullname[1]='.';
-	else 
-		fullname=(char *)fullname+i+1; /* jump to start of the string */
-	dir-&gt;titlestr=s3d_draw_string(fullname,&amp;len);
-	if (len&gt;(1.6*5.0))
-		s3d_scale(dir-&gt;titlestr,1.6/len);
-	else
-		s3d_scale(dir-&gt;titlestr,0.2);
-	s3d_translate(dir-&gt;titlestr,-1.0,1.05,1.01);
-	s3d_link(dir-&gt;titlestr,dir-&gt;block);
-	dir-&gt;disp=D_DIR;
-/*	printf(&quot;FULLNAME is [%s]\n&quot;,fullname);*/
-	return(0);
-}
-int undisplay(t_item *dir)
-{
-	switch (dir-&gt;disp)
-	{
-		case D_DIR: return(box_undisplay(dir));break;
-		case D_ICON:return(icon_undisplay(dir));break;
-		default:	return(-1);
-	}
-}
-/* display a directoy on the top of another, draw it's icons etc ... */
-int box_expand(t_item *dir)
-{
-	int i;
-	float  px,pz;
-	int dirn;
-	px=pz=0.0;
-	printf(&quot;box_expand( %s )\n&quot;,dir-&gt;name);
-	if (dir-&gt;disp)		undisplay(dir);
-	box_buildblock(dir);
-	if (dir-&gt;parent!=NULL)
-		dir-&gt;parent-&gt;dirs_opened++;
- /* count directories */
-	dirn=0;
-	for (i=0;i&lt;dir-&gt;n_item;i++)
-	{
-		if (dir-&gt;list[i].type==T_FOLDER) dirn++;
-	}
-
-	/* draw icons, if necceasry */
-	for (i=0;i&lt;dir-&gt;n_item;i++)
-	{
-		if (!dir-&gt;list[i].disp)	icon_draw(dir,i);
-		else {
-			printf(&quot;link %d to the block %d of %s\n&quot;,dir-&gt;list[i].block,dir-&gt;block,dir-&gt;name);
-			s3d_link(dir-&gt;list[i].block,dir-&gt;block); /* if it's already displayed, make sure it linked properly ... */
-		}
-	}
-	if (dir-&gt;parent!=NULL)
-	{
-		s3d_link(dir-&gt;block,dir-&gt;parent-&gt;block);
-		dir-&gt;dpx=0.0;
-		dir-&gt;dpy=BOXHEIGHT;
-		dir-&gt;dpz=0.0;
-		dir-&gt;dscale=0.0;
-		box_position_kids(dir-&gt;parent);
-		ani_doit(dir);
-	}
-	for (i=0;i&lt;dir-&gt;n_item;i++)
-	{
-		s3d_flags_on(dir-&gt;list[i].block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(dir-&gt;list[i].str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	}
-	box_sidelabel(dir);
-    s3d_flags_on(dir-&gt;block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir-&gt;close,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir-&gt;title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir-&gt;select,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir-&gt;titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	dir-&gt;disp=D_DIR;
-	return(0);
-}
-int box_undisplay(t_item *dir)
-{
-	int i;
-	t_item *par;
-	printf(&quot;box_undisplay( %s )\n&quot;,dir-&gt;name);
-	for (i=0;i&lt;dir-&gt;n_item;i++)
-	{
-		if (dir-&gt;list[i].disp==D_ICON)	icon_undisplay(&amp;(dir-&gt;list[i]));
-		else if (dir-&gt;list[i].disp!=0)	
-				printf(&quot;not undisplaying: %s (disp = %d)\n&quot;,dir-&gt;list[i].name, dir-&gt;list[i].disp);
-	}
-	if ((par=dir-&gt;parent)!=NULL) /* we can't do this on root.... */
-	{
-		for (i=0;i&lt;par-&gt;n_item;i++)
-			if (&amp;par-&gt;list[i]==dir)
-				break;
-		if (i!=par-&gt;n_item) /* if it actually was in the parents item list */
-		{
-			icon_draw(par,i);
-			s3d_flags_on(dir-&gt;block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_on(dir-&gt;str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		}
-		par-&gt;dirs_opened--;
-	} else {
-		/* we're root ... */
-		box_dissolve(dir);
-	}
-	printf(&quot;[U]ndisplayed %s\n&quot;,dir-&gt;name);
-/*	dir-&gt;dirs_opened=0;*/
-	dir-&gt;detached=0;
-	return(0);
-}
-/* undisplay a directory, thus recursively removing the kids.*/
-int box_collapse(t_item *dir,int force)
-{
-	int i;
-	int ret;
-	printf(&quot;box_collapse( %s )\n&quot;,dir-&gt;name);
-	if (&amp;root==dir)
-	{
-		printf(&quot;won't undisplay root window ... \n&quot;);
-		return(-1);
-	}
-	if (dir-&gt;detached &amp;&amp; !force)
-		return(1);
-	if (dir-&gt;disp!=D_DIR)
-	{
-		printf(&quot;[A]lready undisplayed %s, nothing to do ...\n&quot;,dir-&gt;name);
-		return(-1);
-	}
-	/* undisplaying kids. ret will be != 0 if any of the kids did not close correctly */
-	ret=0;
-	for (i=0;i&lt;dir-&gt;n_item;i++)
-		if (dir-&gt;list[i].disp==D_DIR)
-			ret|=box_collapse(&amp;dir-&gt;list[i],force);
-
-	if (ret &amp;&amp; !force) return(ret); /* if anything got wrong, return here ... */
-	undisplay(dir);
-	if (dir-&gt;parent!=NULL)
-	{
-		box_position_kids(dir-&gt;parent);
-	}
-	return(ret);
-}
-/* only display dir and its kids, but nothing below. */
-int box_collapse_grandkids(t_item *dir)
-{
-	int i,j;
-	t_item *kid;
-	for (i=0;i&lt;dir-&gt;n_item;i++)
-		if (dir-&gt;list[i].disp==D_DIR)
-		{
-			kid=&amp;dir-&gt;list[i];
-			for (j=0;j&lt;kid-&gt;n_item;j++)
-			if (kid-&gt;list[j].disp==D_DIR)
-				box_collapse(&amp;kid-&gt;list[j],0);
-		}
-	return(0);
-}
-/* orders the directory objects on top of its parent objects 
- * to be called after adding or removing things ...*/
-void box_position_kids(t_item *dir)
-{
-	int i,j;
-	printf(&quot;box_position_kids( %s ): %d dirs opened\n&quot;,dir-&gt;name,dir-&gt;dirs_opened);
-	switch (dir-&gt;dirs_opened)
-	{
-		case 0: return;
-		case 1:
-			for (i=0;i&lt;dir-&gt;n_item;i++)
-			{
-				if (dir-&gt;list[i].disp==D_DIR)
-				{
-					dir-&gt;list[i].px=0.0;
-					dir-&gt;list[i].py=BOXHEIGHT+dir-&gt;list[i].detached*DETHEIGHT;
-					dir-&gt;list[i].pz=0.0;
-					dir-&gt;list[i].scale=0.2;
-					ani_add(&amp;dir-&gt;list[i]);
-				}
-			}
-			break;
-		default:
-			j=0;
-			for (i=0;i&lt;dir-&gt;n_item;i++)
-			{
-				if (dir-&gt;list[i].disp==D_DIR)
-				{
-					dir-&gt;list[i].px=0.8 * sin(((float)j*2*M_PI)/((float)dir-&gt;dirs_opened));
-					dir-&gt;list[i].py=BOXHEIGHT+dir-&gt;list[i].detached*DETHEIGHT;
-					dir-&gt;list[i].pz=0.8 * cos(((float)j*2*M_PI)/((float)dir-&gt;dirs_opened));
-					dir-&gt;list[i].scale=0.2;
-					ani_add(&amp;dir-&gt;list[i]);
-					j++;
-				}
-
-			}
-	}
-}
-void box_select(t_item *dir)
-{
-	dir-&gt;detached=dir-&gt;detached?0:1; /* swapping, not sure if !dir-&gt;detached would do the same .. */
-	if ((dir-&gt;type==T_FOLDER) &amp;&amp; dir-&gt;disp)
-	{
-		if (dir-&gt;parent!=NULL)
-			box_position_kids(dir-&gt;parent);
-	} else {
-		/* nothing yet ... */
-	}
-}

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/dialog.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,357 +0,0 @@
-/*
- * dialog.c
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3dfm, a s3d file manager.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include &quot;s3dfm.h&quot;
-#include &lt;s3d_keysym.h&gt;
-#include &lt;s3dw.h&gt;
-#include &lt;stdio.h&gt; 	/* NULL, printf() */
-#include &lt;string.h&gt; /* strlen() */
-#include &lt;stdlib.h&gt; /* realloc(),malloc() */
-#include &lt;errno.h&gt;  /* errno */
-#include &lt;sys/stat.h&gt; /* mkdir() */
-#include &lt;sys/types.h&gt; /* mkdir() */
-extern t_item *focus;
-filelist fp={NULL,0};
-int typeinput=0;
-/* keyevent handler */
-void key_handler(struct s3d_evt *evt)
-{
-	struct s3d_key_event *keys=(struct s3d_key_event *)evt-&gt;buf;
-	char path[M_DIR];
-	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */	
-			printf(&quot;inputting text ...\n&quot;);
-			s3dw_handle_key(evt); 
-			return; 
-	}
-	get_path(focus,path);
-	switch (keys-&gt;keysym)
-	{
-		case 'i':
-		case 'I':
-				{
-				window_info(path);
-				}
-				break;
-		case 'r':
-		case 'R':
-				{/* refresh this window ... */
-					printf(&quot;[R]efreshing %s\n&quot;,focus-&gt;name);
-					parse_again(focus);
-					ani_focus(focus);
-				}
-				break;
-		case S3DK_F1:
-				window_help();
-				break;
-		case S3DK_F5:
-				window_copy(path);
-				break;
-		case S3DK_F6:
-				window_move(path);
-				break;
-		case S3DK_F7:
-				window_mkdir(path);
-				break;
-
-
-	}
-	s3dw_handle_key(evt);
-}
-
-/* object click handler */
-void object_click(struct s3d_evt *evt)
-{
-	int oid;
-	t_item *f;
-	s3dw_handle_click(evt);
-	oid=(int)*((unsigned long *)evt-&gt;buf);
-	if (NULL!=(f=finditem(&amp;root,oid)))
-	{
-		if (f-&gt;close==oid)
-		{
-			box_collapse(f,1);
-/*			if (f-&gt;parent!=NULL)
-				ani_focus(f-&gt;parent);*/
-			return;
-		}
-		if (f-&gt;select==oid)
-		{
-			printf(&quot;[S]electing %s\n&quot;,f-&gt;name);
-			box_select(f);
-			return;
-		}
-		if (f-&gt;type==T_FOLDER)
-		{
-			if (f-&gt;disp == D_DIR)
-			{
-				printf(&quot;[F]ound, Already displayed - ani_focus( %s )\n&quot;,f-&gt;name);
-			} else {
-				if (!f-&gt;parsed)	parse_dir(f);
-				box_expand(f);
-			}
-			focus=f;
-			ani_focus(f);
-		} else
-			printf(&quot;[F]ound, but %s is no folder\n&quot;,f-&gt;name);
-	} else {
-/*		printf(&quot;[C]ould not find :/\n&quot;);*/
-	}
-}
-void close_win(s3dw_widget *button)
-{
-	s3dw_delete(button-&gt;parent); /* parent =surface. this means close containing window */
-}
-/* add some dots to an integer value for better readability */
-void dotted_int(char *s,unsigned int i)
-{
-	char st[M_DIR];
-	int p;
-	p=0;
-	st[0]=0;
-	while (i&gt;0)
-	{
-		if ((p+1)%4==0) {
-			st[p]='.';
-			p++;
-		}
-		st[p]=(i%10)+'0';
-		i=i/10;
-		p++;
-	}
-	if (p&gt;0) p--;
-	st[p+1]=0;
-	for (i=0;i&lt;p+1;i++)
-		s[i]=st[p-i];
-	s[p+1]=0;
-}
-/* add all selected dirs in the new filelist */
-int get_selected(filelist *fp, t_item *dir)
-{
-	int i;
-	char *s;
-	for (i=0;i&lt;dir-&gt;n_item;i++)
-	{
-		if (dir-&gt;list[i].list!=NULL)	get_selected(fp,&amp;(dir-&gt;list[i])); /* scan subdir */
-		if (dir-&gt;list[i].detached)
-		{
-			fp-&gt;n++;
-			fp-&gt;p=realloc(fp-&gt;p,sizeof(char *) * fp-&gt;n);
-			s=malloc(M_DIR);
-			get_path(&amp;(dir-&gt;list[i]),s);
-			fp-&gt;p[fp-&gt;n - 1]=s;
-		}
-	}
-	return(0);
-}
-void window_help()
-{
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-	infwin=s3dw_surface_new(&quot;Help Window&quot;,12,12);
-	s3dw_label_new(infwin,&quot;F1 - This Help Window&quot;,1,2);
-	s3dw_label_new(infwin,&quot;F5 - Copy&quot;,1,3);
-	s3dw_label_new(infwin,&quot;F6 - Move&quot;,1,4);
-	s3dw_label_new(infwin,&quot;F7 - Create Directory&quot;,1,5);
-	s3dw_label_new(infwin,&quot;R - Refresh&quot;,1,6);
-	s3dw_label_new(infwin,&quot;I - Info&quot;,1,7);
-
-	button=s3dw_button_new(infwin,&quot;OK&quot;,4,10);
-	button-&gt;onclick=close_win;
-	s3dw_show(S3DWIDGET(infwin));
-
-}
-void window_fs_another()
-{
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-	infwin=s3dw_surface_new(&quot;Error&quot;,12,8);
-	s3dw_label_new(infwin,&quot;Sorry, another FS Action is in Progress&quot;,1,2);
-	button=s3dw_button_new(infwin,&quot;OK&quot;,5,5);
-	button-&gt;onclick=close_win;
-	s3dw_show(S3DWIDGET(infwin));
-}
-void window_fs_nothing()
-{
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-	infwin=s3dw_surface_new(&quot;Error&quot;,12,8);
-	s3dw_label_new(infwin,&quot;Nothing selected :(&quot;,1,2);
-	button=s3dw_button_new(infwin,&quot;OK&quot;,5,5);
-	button-&gt;onclick=close_win;
-	s3dw_show(S3DWIDGET(infwin));
-
-}
-void window_fs_errno(char *errmsg)
-{
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-	char string[M_DIR];
-	float l;
-	snprintf(string,M_DIR,&quot;%s: %s&quot;,errmsg,strerror(errno));
-	l=strlen(string)*0.7;
-	infwin=s3dw_surface_new(&quot;Error&quot;,l,8);
-	s3dw_label_new(infwin,string,1,2);
-	button=s3dw_button_new(infwin,&quot;OK&quot;,l/2-1,5);
-	button-&gt;onclick=close_win;
-	s3dw_show(S3DWIDGET(infwin));
-}
-
-void window_fs_abort(s3dw_widget *button)
-{
-	int i;
-	for (i=0;i&lt;fp.n;i++)
-		free(fp.p[i]);
-	if (fp.p!=NULL) free(fp.p);
-	fp.n=0;
-	fp.p=NULL;
-	typeinput=0;
-	s3dw_delete(button-&gt;parent); /* parent =surface. this means close containing window */
-}
-void window_copy(char *path)
-{
-	s3dw_surface *infwin;
-	s3dw_button  *okbutton,*abortbutton;
-	float l;
-	char destdir[M_DIR];
-
-	int i,m;
-
-	if (fp.n!=0) 	{	window_fs_another(); 	return; }
-	fp.n=0;
-	fp.p=NULL;
-	get_selected(&amp;fp,&amp;root);
-	printf(&quot;selected %d nodes\n&quot;,fp.n);
-	if (fp.n == 0)	{	window_fs_nothing();	return;	}
-	m=10;
-	for (i=0;i&lt;fp.n;i++)
-	{
-		if (strlen(fp.p[i])&gt;m) m=strlen(fp.p[i]);
-		printf(&quot;%d: %s\n&quot;,i,fp.p[i]);
-	}
-
-	l=(m+3)*0.7;
-	infwin=s3dw_surface_new(&quot;Copy Window&quot;,l,fp.n+8);
-	s3dw_label_new(infwin,&quot;Copy: &quot;,1,1);
-	for (i=0;i&lt;fp.n;i++)
-		s3dw_label_new(infwin,fp.p[i],3,2+i);
-	s3dw_label_new(infwin,&quot;to:&quot;,1,fp.n+3);
-	get_path(focus,destdir);
-	s3dw_label_new(infwin,destdir,3,fp.n+4);
-
-	okbutton=s3dw_button_new(infwin,&quot;OK&quot;,l/2-3,fp.n+5);
-	okbutton-&gt;onclick=window_fs_abort;
-	abortbutton=s3dw_button_new(infwin,&quot;abort&quot;,l/2,fp.n+5);
-	abortbutton-&gt;onclick=window_fs_abort;
-
-	s3dw_show(S3DWIDGET(infwin));
-
-}
-s3dw_input	 *input;
-void window_fs_mkdir(s3dw_widget *button)
-{
-	char *dir;
-	t_item *item;
-	dir=s3dw_input_gettext(input);
-	printf(&quot;creating Directory ...%s\n&quot;,dir);
-	if (-1==mkdir(dir,0777)) /* umask ?! */
-		window_fs_errno(&quot;could not create directory&quot;);
-	else {
-		/* success, now refresh it */
-		item=get_item(dir);
-		if (item==NULL)
-		{
-			printf(&quot;cannot refresh\n&quot;);
-		} else {
-			printf(&quot;refreshing %s\n&quot;,item-&gt;name);
-			parse_again(item);
-
-		}
-				
-	}
-	window_fs_abort(button); /* finish */
-
-}
-void window_mkdir(char *path)
-{
-	s3dw_surface *infwin;
-	s3dw_button  *okbutton,*abortbutton;
-	char string1[M_DIR];
-	float l;
-	if (fp.n!=0) {window_fs_another(); return; }
-	snprintf(string1,M_DIR,&quot;Create Directory in %s&quot;,path);
-	l=strlen(string1)*0.7;
-	infwin=s3dw_surface_new(&quot;Create Directory&quot;,l,8);
-	s3dw_label_new(infwin,string1,1,2);
-	input=s3dw_input_new(infwin,10,1,3);
-	s3dw_input_change_text(input, path);
-	s3dw_focus(S3DWIDGET(input));
-	s3dw_focus(S3DWIDGET(infwin));
-	typeinput=1;
-	okbutton=s3dw_button_new(infwin,&quot;OK&quot;,l/2-3,fp.n+5);
-	okbutton-&gt;onclick=window_fs_mkdir;
-	abortbutton=s3dw_button_new(infwin,&quot;abort&quot;,l/2,fp.n+5);
-	abortbutton-&gt;onclick=window_fs_abort;
-	s3dw_show(S3DWIDGET(infwin));
-
-}
-
-void window_move(char *path)
-{
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-	if (fp.n!=0) {window_fs_another(); return; }
-	infwin=s3dw_surface_new(&quot;Info Window&quot;,20,8);
-	s3dw_label_new(infwin,&quot;Sorry, moving is not implemented yet.. :(&quot;,1,2);
-	button=s3dw_button_new(infwin,&quot;Too bad&quot;,7,5);
-	button-&gt;onclick=close_win;
-	s3dw_show(S3DWIDGET(infwin));
-
-}
-/* a small window which counts directories/files and displays the result */
-void window_info(char *path)
-{
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-	char string1[M_DIR];
-	char string2[M_DIR];
-	int b,d,f;
-	char bd[M_DIR];
-	float l;
-	snprintf(string1,M_DIR,&quot;Info for %s&quot;,path);
-	fs_approx(path, &amp;f, &amp;d, &amp;b);
-	dotted_int(bd,b);
-	snprintf(string2 ,M_DIR,&quot;%s bytes in %d files and %d Directories&quot;,bd,f,d);
-	
-	l=((strlen(string1)&gt;strlen(string2)) ? strlen(string1) :strlen(string2))*0.7;
-	
-	infwin=s3dw_surface_new(&quot;Info Window&quot;,l,12);
-
-	s3dw_label_new(infwin,string1,1,2);
-	s3dw_label_new(infwin,string2,1,4);
-
-	button=s3dw_button_new(infwin,&quot;OK&quot;,l/2-1,6);
-	/* clicking on the button will exit ... */
-	button-&gt;onclick=close_win;
-	/* of couse, show it */
-	s3dw_show(S3DWIDGET(infwin));
-}

Modified: trunk/apps/s3dfm/fs.c
===================================================================
--- trunk/apps/s3dfm/fs.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/fs.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,302 +0,0 @@
-/*
- * fs.c 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3dfm, a s3d file manager.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include &quot;s3dfm.h&quot;
-#include &lt;stdio.h&gt;	/*  printf() */
-#include &lt;dirent.h&gt;	/* scandir() */
-#include &lt;stdlib.h&gt;	/*  malloc() */
-
-/* we want GNU version of basename */
-#define _GNU_SOURCE 
-#include &lt;string.h&gt;	/*  strlen(), strncmp(), strrchr() */
-#include &lt;libgen.h&gt; /* basename() */
-
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;unistd.h&gt;
-
-#include &lt;errno.h&gt;
-
-
-
-
-/* generates the file list */
-filelist *fl_new(char *path)
-{
-	struct dirent **namelist;
-	filelist *fl;
-	int n,i,j;
-	char *name;
-
-	fl=malloc(sizeof(filelist));
-	fl-&gt;p=NULL;
-	fl-&gt;n=0;
-    n = scandir(path, &amp;namelist, 0, alphasort);
-    if (n &lt;= 2) /* . and .. is always included. */
-	{
-		if (n&lt;0)
-	        perror(&quot;scandir&quot;);
-	} else {
-		j=0;
-		fl-&gt;n=n-2 ; /* ignore . and .. */
-		fl-&gt;p=malloc(sizeof(char *)*fl-&gt;n);
-		for (i=0;i&lt;n;i++)
-		{
-			name=namelist[i]-&gt;d_name;
-			if (!((strcmp(name,&quot;.&quot;)==0) || (strcmp(name,&quot;..&quot;)==0))) /* ignore */
-			{
-				fl-&gt;p[j]=malloc(strlen(name)+strlen(path)+2);
-				strcpy(fl-&gt;p[j],path);
-				strcat(fl-&gt;p[j],&quot;/&quot;);
-				strcat(fl-&gt;p[j],name);
-				j++;
-			}
-			free(namelist[i]);
-		}
-		if (j!=fl-&gt;n)
-		{
-			printf(&quot;assertion failed\n&quot;);
-			exit(-1);
-		}
-		free (namelist);
-	}
-	return(fl);	
-}
-/* delete the filelist */
-void fl_del(filelist *fl)
-{
-	int i;
-	for (i=0;i&lt;fl-&gt;n;i++)
-	{
-		free(fl-&gt;p[i]);
-	}
-	free(fl);
-}
-/* approximate the heaviness of a single */
-void fs_approx(char *source, int *files, int *dirs, int *bytes)
-{
-	int sfiles,sdirs,sbytes; 	/* for subdirs */
-	filelist *fl;
-	struct stat s;
-
-	*files=	sfiles=	0;
-	*dirs=	sdirs=	0;
-	*bytes=	sbytes=	0;
-
-/*	printf(&quot;start: %d files, %d dirs, %d bytes in %s\n&quot;,*files,*dirs,*bytes,source);*/
-	if (-1==stat(source,&amp;s))
-		return;
-/*	printf(&quot;%s: %08x (%db)\n&quot;,source,s.st_mode,(int)s.st_size);*/
-	if ((s.st_mode&amp;S_IFMT) == S_IFDIR)
-	{
-		
-		fl=fl_new(source);
-		if (fl-&gt;n&gt;0)
-			fs_fl_approx(fl,&amp;sfiles,&amp;sdirs,&amp;sbytes);
-		fl_del(fl);
-/*		printf(&quot;%d files, %d dirs, %d bytes in %s\n&quot;,sfiles,sdirs,sbytes,source);*/
-
-		*files=		sfiles;
-		*bytes+=	sbytes;
-		*dirs=		sdirs;
-		*dirs+=		1;
-	} else 
-		*files=		1;
-	*bytes+=s.st_size;
-/*	printf(&quot;end: %d files, %d dirs, %d bytes in %s\n&quot;,*files,*dirs,*bytes,source);*/
-}
-/* approximate the heaviness of our source ...*/
-void fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes)
-{
-	int i;
-	int sfiles,sdirs,sbytes; 	/* for subdirs */
-
-	*files=0;
-	*dirs=0;
-	*bytes=0;
-
-	for (i=0;i&lt;fl-&gt;n;i++)
-	{
-		fs_approx(fl-&gt;p[i],&amp;sfiles,&amp;sdirs,&amp;sbytes);
-		*files+=		sfiles;
-		*dirs+=			sdirs;
-		*bytes+=		sbytes;
-	}
-}
-/* copy a certain file */
-int fs_copy(char *source, char *dest)
-{
-	FILE *fps, *fpd;
-	filelist *fl;
-	struct stat s;
-	char buf[1024];
-	int n;
-	if (-1==stat(source,&amp;s))
-		return(0);
-	switch (s.st_mode&amp;S_IFMT)
-	{
-		case S_IFDIR:
-			fl=fl_new(source);
-		
-			printf(&quot;mkdir %s\n&quot;,dest);
-			mkdir(dest,0777);
-		
-			fs_fl_copy(fl, dest);
-
-			fl_del(fl);
-			break;
-		case S_IFIFO:
-			printf(&quot;link the fifo\n&quot;);
-
-			link(source,dest);
-			break;
-		default:
-			printf(&quot;atomic copy ... from %s to %s\n&quot;, source, dest);
-			if (NULL==(fps=fopen(source,&quot;r&quot;))) return(-1);
-			if (NULL==(fpd=fopen(dest,&quot;w&quot;))) return(-1);
-			/* TODO: overwrite protection etc */
-		
-			while (!feof(fps))
-			{
-				n=fread(buf,1,1024,fps);
-				fwrite(buf,1,n,fpd);
-			}
-			fclose(fps);
-			fclose(fpd);
-
-	}
-	return(0);
-}
-/* copy the source to the destination, destination should be a directory. */
-int fs_fl_copy(filelist *fl, char *dest)
-{
-	int i;
-	int r;
-	char *sdest;
-	char *bname;
-	r=0;
-	for (i=0;i&lt;fl-&gt;n;i++)
-	{
-		bname=basename(fl-&gt;p[i]);
-		sdest=malloc(strlen(dest)+strlen(bname)+2);
-
-		strcpy(sdest,dest);
-		strcat(sdest,&quot;/&quot;);
-		strcat(sdest,bname);
-		r|=fs_copy(fl-&gt;p[i],sdest);
-
-		free(sdest);
-	}
-
-	return(r);
-}
-/* recursively unlink a dir or file. */
-int fs_unlink(char *dest)
-{
-	filelist *fl;
-	struct stat s;
-	
-	if (-1==stat(dest,&amp;s))		return(-1);
-	if ((s.st_mode&amp;S_IFMT) == S_IFDIR)
-	{
-		printf(&quot;%s is a dir, removing below ...\n&quot;,dest);
-		fl=fl_new(dest);
-		if (fs_fl_unlink(fl)) {
-			fl_del(fl);
-			return(-1);
-		} else {
-			fl_del(fl);
-			printf(&quot;removing %s\n&quot;,dest);
-			if (rmdir(dest)==-1)
-			{
-				perror(&quot;fs_fl_unlink(): rmdir()&quot;);
-				return(-1);
-			}
-		}
-	} else {
-		if (unlink(dest)==-1)
-		{
-			perror(&quot;fs_fl_unlink(): unlink()&quot;);
-			return(-1);
-		}
-	}
-	return(0);
-}
-/* remove a lot of files */
-int fs_fl_unlink(filelist *fl)
-{
-	int i,r;
-	r=0;
-	for (i=0;i&lt;fl-&gt;n;i++)
-	{
-		printf(&quot;-&gt; atomic unlink %s\n&quot;,fl-&gt;p[i]);
-		r|=fs_unlink(fl-&gt;p[i]);
-	}
-	return(r);
-
-}
-int fs_move(char *source, char *dest)
-{
-	if (!rename(source,dest))
-	{
-		switch (errno)
-		{
-			case EXDEV:
-				fs_copy(source,dest);
-				fs_unlink(source);
-				break;
-			default: 
-				perror(&quot;fs_move()&quot;);
-				return(-1); /* can't help it */
-			
-		}
-	}
-	return(0);	
-}
-
-/* moves the source to the destination */
-int fs_fl_move(filelist *fl, char *dest)
-{
-	int i;
-	int r;
-	char *sdest;
-	char *bname;
-	r=0;
-	for (i=0;i&lt;fl-&gt;n;i++)
-	{
-		bname=basename(fl-&gt;p[i]);
-		sdest=malloc(strlen(dest)+strlen(bname)+2);
-
-		strcpy(sdest,dest);
-		strcat(sdest,&quot;/&quot;);
-		strcat(sdest,bname);
-		r|=fs_move(fl-&gt;p[i],sdest);
-
-		free(sdest);
-	}
-
-	return(r);
-
-	return(0);
-}
-
-

Modified: trunk/apps/s3dfm/icon.c
===================================================================
--- trunk/apps/s3dfm/icon.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/icon.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,110 +0,0 @@
-/*
- * icon.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3dfm, a s3d file manager.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include &quot;s3dfm.h&quot;
-#include &lt;stdio.h&gt; 	 /*  printf() */
-#include &lt;math.h&gt;	 /*  sin(),cos() */
-#include &lt;string.h&gt;  /*  strlen() */
-/* draws icon i in the block of dir */
-int icon_draw(t_item *dir,int i)
-{
-	float vertices[]={	-1,-0.5,0,
-						-1, 0.5,0,
-						 1, 0.5,0,
-						 1,-0.5,0,
-						-1,-0.5,-1,
-						-1, 0.5,-1,
-						 1, 0.5,-1,
-						 1,-0.5,-1};
-	unsigned long polys[]={
-				1,3,0,0,				2,3,1,0,
-				5,6,2,0,				1,5,2,0,
-				2,6,7,0,				2,7,3,0,
-				0,3,7,0,				0,7,4,0,
-				5,1,0,0,				5,0,4,0	
-				};
-	float len;
-	float d;
-	int dps;
-	printf(&quot;icon_draw( %s )\n&quot;,dir-&gt;list[i].name);
-	dps=ceil(sqrt(dir-&gt;n_item)); /* directories per line */
-	/* find position for the new block in our directory box */
-	dir-&gt;list[i].dpx = dir-&gt;list[i].px=-1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
-	dir-&gt;list[i].dpy = dir-&gt;list[i].py=0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
-	dir-&gt;list[i].dpz = dir-&gt;list[i].pz=1.0;
-	dir-&gt;list[i].scale = dir-&gt;list[i].dscale = (float)1.0/((float)dps);
-	/* create the block */
-	box_dissolve(&amp;(dir-&gt;list[i]));
-	dir-&gt;list[i].block=s3d_new_object();
-	s3d_push_vertices(dir-&gt;list[i].block,vertices,8);
-	d=((int)(((i+(dps+1)%2*(i/dps)))%2))*0.2;
-	switch (dir-&gt;list[i].type)
-	{
-		case T_FOLDER:
-			s3d_push_material(dir-&gt;list[i].block,
-									0.4-d,0.4-d,0,
-									0.4-d,0.4-d,0,
-									0.4-d,0.4-d,0);
-			break;
-		default:
-			s3d_push_material(dir-&gt;list[i].block,
-									0,0,0.5-d,
-									0,0,0.5-d,
-									0,0,0.5-d);
-	};
-	s3d_push_polygons(dir-&gt;list[i].block,polys,10);
-	s3d_link(dir-&gt;list[i].block,dir-&gt;block);
-
-	/* draw and position the string */
-	if (dir-&gt;list[i].str==-1)
-	{
-		dir-&gt;list[i].str=s3d_draw_string(dir-&gt;list[i].name,&amp;len);
-		if (len&lt;2) len=2;
-		dir-&gt;list[i].len=len;
-	}
-	else 
-		len=dir-&gt;list[i].len;
-	s3d_scale(dir-&gt;list[i].str,(float)1.8/len);
-	s3d_translate(dir-&gt;list[i].str,-0.9,-0.3,0.1);
-	s3d_rotate(dir-&gt;list[i].str,0,0,0);
-	s3d_link(dir-&gt;list[i].str,dir-&gt;list[i].block);
-	ani_finish(&amp;dir-&gt;list[i],-1); /* apply transformation */
-	dir-&gt;list[i].disp=D_ICON;
-	return(0);
-}
-int icon_undisplay(t_item *dir)
-{
-	printf(&quot;icon_undisplay( %s )\n&quot;,dir-&gt;name);
-	if (dir-&gt;block!=-1)
-	{
-		s3d_del_object(dir-&gt;block);
-		dir-&gt;block=-1;
-	}
-	if (dir-&gt;str!=-1)
-	{
-		s3d_del_object(dir-&gt;str);
-		dir-&gt;str=-1;
-	}
-	dir-&gt;disp=0;
-	return(0);
-}

Modified: trunk/apps/s3dfm/main.c
===================================================================
--- trunk/apps/s3dfm/main.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/main.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,175 +0,0 @@
-/*
- * main.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3dfm, a s3d file manager.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include &quot;s3dfm.h&quot;
-#include &lt;s3dw.h&gt;	 /* s3dw_ani_mate() */
-#include &lt;stdio.h&gt; 	 /*  printf() */
-#include &lt;dirent.h&gt;  /*  dirent */
-#include &lt;stdlib.h&gt;	 /*  malloc() */
-#include &lt;string.h&gt;  /*  strlen(), strncmp(), strrchr() */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,33*1000*1000}; 
-t_item root,cam,*focus;
-
-/* save concatting 2 strings, this version takes argument n
- * as the size of the buffer of dest. */
-char *mstrncat(char *dest, const char *src, int n)
-{
-	int i,j;
-	dest[n-1]=0;						/* for malformed destinations */
-	j=0;
-	for (i=strlen(dest);i&lt;(n-1);i++)
-	{
-		dest[i]=src[j]; 
-		if (dest[i]==0) break;
-		j++;
-	}
-	for (;i&lt;n;i++)
-		dest[i]=0; /* pad the rest with zero */
-	return(dest);
-}
-/* same as strncpy, but have a terminating zero even if
- * source is too big */
-char *mstrncpy(char *dest, const char *src, int n)
-{
-	strncpy(dest,src,n);
-	dest[n-1]=0;
-	return(dest);
-}
-/* writes the path of dir into *path. path should be of type path[M_DIR] */
-void get_path(t_item *dir, char *path)
-{
-	if (dir-&gt;parent!=NULL)
-	{
-		get_path(dir-&gt;parent,path);
-		mstrncat(path,dir-&gt;name,M_DIR);
-		mstrncat(path,&quot;/&quot;,M_DIR);
-	} else
-		mstrncpy(path,dir-&gt;name,M_DIR);
-}
-/* find the item to a path, return NULL if not parsed yet */
-t_item *get_item(char *path)
-{
-	char p[M_DIR];
-	char *s,*match;
-	t_item *cur;
-	int i;
-	
-	if (path==NULL) return NULL;
-	if (path[0]=='/')
-	{
-		strncpy(p,path,M_DIR);
-		s=p+1;
-		cur=&root;
-	} else return NULL; /* TODO: also process local paths. right now, we are to lazy */
-	printf(&quot;processing rest of string %s\n&quot;,s);
-	match=s;
-	while ((s=index(s,'/'))!=NULL) { /* while we have slashes inside */
-		s[0]=0; /* mark the slash with space */
-		s++;	/* move to the next */
-		/* parse ... */
-		printf(&quot;looking for a match for %s\n&quot;,match);
-		for (i=0;i&lt;cur-&gt;n_item;i++)
-			if (0==strcmp(cur-&gt;list[i].name,match))
-			{ /* found !! */
-				cur=&amp;(cur-&gt;list[i]); /* forward */
-				match=s; /* select next */
-				break;
-			}
-		if (i==cur-&gt;n_item) {
-			printf(&quot;found no match for %s :(\n&quot;,match);
-			return NULL; /* not found */
-		}
-	}
-	return(cur);
-}
-/* finds an item in the tree by oid */
-t_item *finditem(t_item *t, int oid)
-{
-	int i;
-	t_item *f;
-	if (t-&gt;block==oid)		return(t);
-	if (t-&gt;str==oid)		return(t);
-	if (t-&gt;close==oid)		return(t);
-	if (t-&gt;select==oid)		return(t);
-	if (t-&gt;title==oid)		return(t);
-	if (t-&gt;titlestr==oid)	return(t);
-	if (t-&gt;type==T_FOLDER)
-		for (i=0;i&lt;t-&gt;n_item;i++)
-			if ((f=finditem(&amp;(t-&gt;list[i]),oid))!=NULL)
-				return(f);
-	return(NULL);
-}
-/* info packets handler, we're just interested in the cam */
-void object_info(struct s3d_evt *hrmz)
-{
-	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
-	if ((inf-&gt;object==0) &amp;&amp; (!ani_onstack(&amp;cam)))
-	{
-		cam.dpx=inf-&gt;trans_x;
-		cam.dpy=inf-&gt;trans_y;
-		cam.dpz=inf-&gt;trans_z;
-	}
-	s3dw_object_info(hrmz);
-}
-void mainloop()
-{
-	ani_mate();
-	s3dw_ani_mate();
-	nanosleep(&amp;t,NULL); 
-}
-int main (int argc, char **argv)
-{
-
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-	s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-	s3d_set_callback(S3D_EVENT_KEY,key_handler);
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;s3dfm&quot;))	
-	{
-		s3d_select_font(&quot;vera&quot;);
-
-		
-		/* set up file system representation */
-		node_init(&amp;root);
-		strncpy(root.name,&quot;/&quot;,M_NAME);
-		focus=&root;
-		root.dscale=0.1;
-		root.type=T_FOLDER;
-		root.str=s3d_draw_string(root.name,&amp;root.len);
-		if (root.len&lt;2) root.len=2;
-		parse_dir(&amp;root);
-		box_expand(&amp;root);
-		ani_doit(&amp;root);
-		ani_focus(&amp;root);
-		
-		node_init(&amp;cam); /* a virtual object, just to push the cam throu our animation stack */
-		cam.block=0;
-		
-		
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/parse.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,189 +0,0 @@
-/*
- * main.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3dfm, a s3d file manager.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include &quot;s3dfm.h&quot;
-#include &lt;s3dw.h&gt;	 /* s3dw_ani_mate() */
-#include &lt;stdio.h&gt; 	 /*  printf() */
-#include &lt;dirent.h&gt;  /*  dirent */
-#include &lt;stdlib.h&gt;	 /*  malloc() */
-#include &lt;string.h&gt;  /*  strlen(), strncmp(), strrchr() */
-#include &lt;time.h&gt;	/* nanosleep() */
-
-
-/* clear the dirs attributes */
-int node_init(t_item *dir)
-{
-	dir-&gt;parent=NULL;
-	dir-&gt;list=NULL;
-	dir-&gt;n_item=-1;
-
-	dir-&gt;block=-1;
-	dir-&gt;str=-1;
-	dir-&gt;close=-1;
-	dir-&gt;select=-1;
-	dir-&gt;title=-1;
-	dir-&gt;titlestr=-1;
-
-	dir-&gt;len=0;
-	dir-&gt;disp=0;
-	dir-&gt;parsed=0;
-
-	dir-&gt;px=root.pz=0.0;
-	dir-&gt;dirs_opened=0;
-	dir-&gt;type=T_DUNO;
-	dir-&gt;px=dir-&gt;py=dir-&gt;pz=0.0;
-	dir-&gt;dpx=dir-&gt;dpy=dir-&gt;dpz=0.0;
-	dir-&gt;scale=dir-&gt;dscale=1.0;
-	dir-&gt;detached=0;
-
-	return(0);
-}
-int parse_dir(t_item *dir)
-{
-	t_item *list;
-	struct dirent **namelist;
-	int n,i;
-	char *ext,*nstr;
-	char path[M_DIR];
-	char ndir[M_DIR]; 
-	
-	printf(&quot;parse_dir( %s )&quot;,dir-&gt;name);
-/*	if (dir-&gt;parsed) return(-1);*/
-	get_path(dir,path);
-/*	printf(&quot;scanning %s\n&quot;,path);*/
-    n = i = scandir(path, &amp;namelist, 0, alphasort);
-	
-    if (n &lt; 0)
-	{
-        perror(&quot;scandir&quot;);
-		return(-1);
-	} else {
-		list=malloc(sizeof(t_item)*i);
-		dir-&gt;list=list;
-		dir-&gt;n_item=n;
-        while(n--) {
-			/* setup kids in the list */
-			node_init(&amp;list[n]);
-			nstr=namelist[n]-&gt;d_name;
-			strncpy(list[n].name,nstr,M_NAME);
- 		    if ((0==strncmp(nstr,&quot;.&quot;,1)) &amp;&amp; (strlen(nstr)==1))
-				list[n].type=T_LOCALDIR;
-			else if (0==strncmp(nstr,&quot;..&quot;,strlen(nstr)&lt;2?strlen(nstr):2))
-			   list[n].type=T_BACKDIR;
-			else {
-				ext=strrchr(nstr,'.');
-				strncpy(ndir,path,M_DIR);
-		    	strncat(ndir,namelist[n]-&gt;d_name,M_DIR);
-			    if ((namelist[n]-&gt;d_type==DT_DIR) ||
-					((namelist[n]-&gt;d_type==DT_UNKNOWN) &amp;&amp; (opendir(ndir)!=NULL)))
-						list[n].type=T_FOLDER;
-				else 
-				{
-				   if (ext!=NULL)
-				   {
-					   if (0==strncmp(ext,&quot;.3ds&quot;,strlen(ext)&lt;4?strlen(ext):4))
-							   list[n].type=T_GEOMETRY;
-					   else if (0==strncmp(ext,&quot;.mp3&quot;,strlen(ext)&lt;4?strlen(ext):4))
-							   list[n].type=T_MUSIC;
-				   }
-				}
-			}
-			list[n].parent=dir;
-        	free(namelist[n]);
-		}
-		free(namelist);
-		dir-&gt;parsed=1;
-   	}
-	return(0);
-}
-void parse_again(t_item *dir)
-{
-	int oldn,redisp;
-	t_item *oldlist;
-	int i,j;
-	oldlist=dir-&gt;list;
-	oldn   =dir-&gt;n_item;
-	redisp=0;
-	printf(&quot;parse_again( %s )\n&quot;,dir-&gt;name);
-	if (dir-&gt;disp==D_DIR)	/* undisplay it later */
-	{ 
-		box_undisplay(dir); 
-		redisp=1; 
-	}
-	parse_dir(dir);
-
-	printf(&quot;oldn = %d\n&quot;,oldn);
-	if (oldn&gt;0)
-	{
-		/* find old, already displayed contents, and copy the data, or remove them if 
-		 * deleted */
-		
-		for (i=0;i&lt;oldn;i++)
-		{
-			if (oldlist[i].disp == D_DIR)	/* old things expanded as directory */
-			{
-				/* see if it's also in the new list */
-				for (j=0;j&lt;dir-&gt;n_item;j++)
-				{
-					if (0==strcmp(oldlist[i].name,dir-&gt;list[j].name))
-					{
-						printf(&quot;we still have %s - %s (%d,%d) , copy to new list ... \n&quot;,dir-&gt;list[j].name, oldlist[i].name,j,i);
-						memcpy(&amp;(dir-&gt;list[j]),&amp;oldlist[i],sizeof(t_item));
-						break; /* found */
-					}
-				}
-				if (j == dir-&gt;n_item) /* not found, collapse it */
-					node_free(&amp;oldlist[i]);
-				else {}/* don't collapse it!! keep as it is */
-			} else node_free(&amp;oldlist[i]);
-		}
-		free(oldlist);
-
-		printf(&quot;finished copying old content, redisplay if neccesary\n&quot;);
-		if (redisp)
-		{
-			printf(&quot;redisplay ... (opened: %d) &quot;, dir-&gt;dirs_opened);
-			/* if it was displayed, redisplay it ... */
-			box_expand(dir);
-			printf(&quot;done (opened: %d)\n&quot;, dir-&gt;dirs_opened);
-		}
-	}	
-}
-void node_free(t_item *t)
-{
-	int i;
-	printf(&quot;node_free( %s )\n&quot;,t-&gt;name);
-	switch (t-&gt;disp)
-	{
-			case D_DIR:  box_collapse(t,1); /* collapse this and its kids */
-			case D_ICON: icon_undisplay(t);
-	}
-	if (t-&gt;n_item&gt;0) {
-		for (i=0;i&lt;t-&gt;n_item;i++)
-			node_free(&amp;(t-&gt;list[i]));
-		free(t-&gt;list);
-	}
-	t-&gt;n_item=0;
-}
-

Modified: trunk/apps/s3dgps/s3dgps.c
===================================================================
--- trunk/apps/s3dgps/s3dgps.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dgps/s3dgps.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,395 +0,0 @@
-/*
- * s3dgps.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3dgps, a gps navigator for s3d.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3dgps is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dgps is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dgps; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include &lt;s3d.h&gt;
-#include &lt;gps.h&gt; 	/* gps_*() */
-#ifdef NMEA_CHANNELS
-#define GPS_NEW
-#endif
-#include &lt;stdio.h&gt; 	/* printf() */
-#include &lt;errno.h&gt;  /* errno */
-#include &lt;stdlib.h&gt;	/* malloc(), free() */
-#include &lt;string.h&gt; /* strlen() */
-#include &lt;math.h&gt;	/* sin(),cos(), M_PI */
-#include &lt;simage.h&gt; /* simage things */
-
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,33*1000*1000}; /* 30 fps */
-
-
-#define PIXELFACT	2817.947378
-#define PIXELFACTN	281794.7378
-#define BFS			1024
-
-#define ICON_ARROW	0
-
-#define ICON_MAX	1
-
-struct map_t {
-	int lng, lat,scale;
-	char path[BFS];
-	struct map_t *next;
-};
-struct point_t {
-	int lng,lat;
-	char name[BFS];
-	int icon;
-	struct point_t *next;
-};
-
-struct gps_data_t 	*dgps;
-int 				 frame=0;
-struct point_t		 posicon;
-int					 iconlist[ICON_MAX];
-char				*iconnames[]={&quot;objs/arrow.3ds&quot;};
-
-unsigned char 		*recode_image(unsigned char *data, int nc, int w, int h);
-int 				 load_mapimage(char *path,float lng, float lat, int scale);
-void 				 parse_mapkoords();
-void				 load_icons();
-void 				 show_gpsdata(struct gps_data_t *dgps);
-void				 show_position(struct gps_data_t *dgps);
-void				 calc_position(float lng, float lat, float *x, float *y, float *z);
-
-void mainloop()
-{
-	if ((frame%60)==0)
-	{
-		printf(&quot;polling ...\n&quot;);
-		if (gps_poll(dgps) &lt; 0) 
-		{
-			printf(&quot;read error on server socket\n&quot;);
-			s3d_quit();
-			return;
-		}
-		printf(&quot;done&quot;);
-		printf(&quot;calling show_gpsdata&quot;);
-		show_gpsdata(dgps);
-	}
-	show_position(dgps);
-	frame++;
-
-	nanosleep(&amp;t,NULL); 
-}
-
-/* a bad 2d-calculation right now ... */
-void				 calc_position(float lng, float lat, float *x, float *y, float *z)
-{
-	*x=-(lng-12.934980)*50;
-	*y=-3;
-	*z=(lat-50.817515)*50;
-/*	*x=sinf(M_PI*lng/180.0)*cosf(M_PI*lat/180.0);
-	*y=cosf(M_PI*lat/180.0);
-	*z=cosf(M_PI*lng/180.0)*cosf(M_PI*lat/180.0);
-	printf(&quot;position for lng/lat %f %f, xyz: %f %f %f, sin-lng:%f\n&quot;,lng,lat,*x,*y,*z,sinf(M_PI*lng/180.0));*/
-}
-/* recodes the image if it's not in rgba format */
-unsigned char *recode_image(unsigned char *data, int nc, int w, int h)
-{
-	unsigned char *new_block=NULL;
-	int x,y;
-	switch (nc)
-	{
-		case 1:	new_block=malloc(w*h*4);
-			  	for (y=0;y&lt;h;y++)
-					for (x=0;x&lt;w;x++)
-					{
-						 new_block[(y*w+x)*4]=
-						 new_block[(y*w+x)*4+1]=
-						 new_block[(y*w+x)*4+2]=data[y*w+x];
-						 new_block[(y*w+x)*4+3]=255;
-					}
-				puts(&quot;grayscale&quot;);
-				free(data);
-			   	break;
-		case 2:	new_block=malloc(w*h*4);
-			  	for (y=0;y&lt;h;y++)
-					for (x=0;x&lt;w;x++)
-					{
-						 new_block[(y*w+x)*4]=
-						 new_block[(y*w+x)*4+1]=
-						 new_block[(y*w+x)*4+2]=data[(y*w+x)*2];
-						 new_block[(y*w+x)*4+3]=data[(y*w+x)*2+1];
-					}
-				puts(&quot;grayscale+a&quot;);
-				free(data);
-				break;
-		case 3:	new_block=malloc(w*h*4);
-			  	for (y=0;y&lt;h;y++)
-					for (x=0;x&lt;w;x++)
-					{
-						 new_block[(y*w+x)*4]=data[(y*w+x)*3];
-						 new_block[(y*w+x)*4+1]=data[(y*w+x)*3+1];
-						 new_block[(y*w+x)*4+2]=data[(y*w+x)*3+2];
-						 new_block[(y*w+x)*4+3]=255;
-					}
-				puts(&quot;rgb&quot;);
-				free(data);
-				break;
-		case 4:	new_block=data;
-			   	puts(&quot;rgba&quot;);
-				break;
-	}
-	return(new_block);
-}
-int 				 load_mapimage(char *path,float lng, float lat, int scale)
-{
-	int w,h,nc;
-	float x,y,z;
-	double wr,hr,er;
-	unsigned char *data;
-	int oid=-1;
-	if (simage_check_supported(path))
-	{
-		printf(&quot;file %s can be loaded!!\n&quot;,path);
-		data=simage_read_image(path,&amp;w,&amp;h,&amp;nc);
-		data=recode_image(data,nc,w,h);
-		oid=s3d_new_object();
-		er=6378.2; /* earth radius */
-		hr=(180*asin(((1.024*scale)/(PIXELFACT*2))/er))/M_PI; /* half height of card in degress */
-		er=6378.2*cos((lat*180)/M_PI); /* radius at latitude position ... */
-		wr=-(180*asin(((1.37*scale)/(PIXELFACT*2))/er))/M_PI; /* half width of card in degress */
-		printf(&quot;wr = %f, hr = %f slice radius for wr =%f \n&quot;,hr,wr,er);
-		calc_position(lng-wr,lat-hr,&amp;x,&amp;y,&amp;z);
-		y-=scale/10000000.0;
-		s3d_push_vertex(oid,x,y,z);
-		calc_position(lng+wr,lat-hr,&amp;x,&amp;y,&amp;z);
-		y-=scale/10000000.0;
-		s3d_push_vertex(oid,x,y,z);
-		calc_position(lng+wr,lat+hr,&amp;x,&amp;y,&amp;z);
-		y-=scale/10000000.0;
-		s3d_push_vertex(oid,x,y,z);
-		calc_position(lng-wr,lat+hr,&amp;x,&amp;y,&amp;z);
-		y-=scale/10000000.0;
-		s3d_push_vertex(oid,x,y,z);
-		s3d_push_material_a(oid,
-						0.8,	0.0,	0.0	,1.0,
-						1.0,	1.0,	1.0	,1.0,
-						0.8,	0.0,	0.0	,1.0);
-		s3d_push_polygon(oid,0,1,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
-									   1.0,0.0,
-									   1.0,1.0);
-		s3d_push_polygon(oid,0,2,3,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
-									   1.0,1.0,
-									   0.0,1.0);
-		s3d_push_texture(oid,w,h);		
-		s3d_load_texture(oid,0,0,0,w,h,(unsigned char *)data);
-		free(data);
-		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
-	} else {
-		printf(&quot;can't load %s\n&quot;,path);
-	}
-	return(oid);
-}
-void load_icons()
-{
-	int i;
-	
-	for (i=0;i&lt;ICON_MAX;i++)
-		iconlist[i]=s3d_import_3ds_file(iconnames[i]);	
-}
-void show_gpsdata(struct gps_data_t *dgps)
-{
-/*	if (!dgps-&gt;online) 
-		printf(&quot;WARNING: no connection to gps device\n&quot;);
-	printf(&quot;[%d] lat/long: [%f|%f], altitude %f\n&quot;,frame,dgps-&gt;latitude,dgps-&gt;longitude,dgps-&gt;altitude);
-	printf(&quot;speed [kph]: %f&quot;,dgps-&gt;speed/KNOTS_TO_KPH);
-	printf(&quot;used %d/%d satellits\n&quot;,dgps-&gt;satellites_used,dgps-&gt;satellites);
-	switch (dgps-&gt;status)
-	{
-		case STATUS_NO_FIX:		printf(&quot;status: no fix&quot;);break;
-		case STATUS_FIX:		printf(&quot;status: fix&quot;);break;
-		case STATUS_DGPS_FIX:	printf(&quot;status: dgps fix&quot;);break;
-	}
-	switch (dgps-&gt;mode)
-	{
-		case MODE_NOT_SEEN:	printf(&quot;mode: not seen yet\n&quot;);break;
-		case MODE_NO_FIX:	printf(&quot;mode: no fix\n&quot;);break;
-		case MODE_2D:		printf(&quot;mode: 2d fix\n&quot;);break;
-		case MODE_3D:		printf(&quot;mode: 3d fix\n&quot;);break;
-	}*/
-}
-int lastfix=0;
-void show_position(struct gps_data_t *dgps)
-{
-	int fix=1;
-	float x,y,z,p;
-#ifdef GPS_NEW
-	if (!dgps-&gt;online) 
-		fix=0;
-	switch (dgps-&gt;fix.mode)
-	{
-		case MODE_NOT_SEEN:	fix=0;break;
-		case MODE_NO_FIX:	fix=0;break;
-	}
-	if (fix) {
-		calc_position(dgps-&gt;fix.longitude,dgps-&gt;fix.latitude,&amp;x,&amp;y,&amp;z);
-#else
-	if (!dgps-&gt;online) 
-		fix=0;
-	switch (dgps-&gt;mode)
-	{
-		case MODE_NOT_SEEN:	fix=0;break;
-		case MODE_NO_FIX:	fix=0;break;
-	}
-	if (fix) {
-		calc_position(dgps-&gt;longitude,dgps-&gt;latitude,&amp;x,&amp;y,&amp;z);
-#endif
-/*		calc_position(dgps-&gt;latitude,dgps-&gt;longitude,&amp;x,&amp;y,&amp;z);*/
-		p=sin(M_PI*((2*frame)%180)/180.0);
-/*		if (p&lt;0.0) p*=-1.0;*/
-		s3d_translate(posicon.icon,x,y+p,z);
-		if (!lastfix)
-			s3d_flags_on(posicon.icon,S3D_OF_VISIBLE);
-	}
-	else 
-		if (lastfix)
-			s3d_flags_off(posicon.icon,S3D_OF_VISIBLE);
-	lastfix=fix;
-}
-/*
-static void update(struct gps_data_t *gpsdata, char *message)
-{
-	printf(&quot;updating!!&quot;);
-}*/
-void parse_mapkoords()
-{
-	FILE *fp;
-	char buf[BFS],*ptr,*sptr,*filename=NULL,c;
-	char path[BFS];
-	char *prefix=&quot;/home/dotslash/.s3dgps/&quot;;
-	int len;
-	int word;
-	double lng,lat;
-	int i;
-	long scale;
-	lng=lat=0;
-	scale=0;
-	
-	strncpy(path,prefix,BFS);
-	strncpy(path+strlen(path),&quot;map_koord.txt&quot;,BFS);
-	if (NULL!=(fp=fopen(path,&quot;r&quot;)))
-	{
-		while (!feof(fp))
-		{
-			ptr=buf;
-			/* read one line */
-			while ((ptr&lt;(buf+BFS+2)))
-			{
-				if (!fread(ptr,1,1,fp))
-					break;
-				c=*ptr;
-				if ((c=='\n') || (c=='\0'))
-					break;
-				ptr++;
-			}
-			*ptr='\0';
-			len=strlen(buf);
-			/* now we have one line in the buffer, proably */
-			sptr=buf;
-			word=0;
-			do {
-				ptr=sptr;
-				/* get word */
-				while ((ptr-buf)&lt;len)
-				{
-					c=*ptr;
-					if ((c=='\t') || (c=='\n') || (c==' ') || (c=='\0'))
-					break;
-					ptr++;
-				}
-				*(ptr)='\0';
-				switch (word)
-				{
-					case 0: filename=sptr;break;
-					case 1: lat=strtod(sptr,NULL);break;
-					case 2: lng=strtod(sptr,NULL);break;
-					case 3: scale=strtol(sptr,NULL,10);break;
-				}
-				if (word==3)
-				{
-					strncpy(path,prefix,BFS);
-					strncpy(path+strlen(path),filename,BFS);
-					printf(&quot;going to load %s (located at %f %f with scale %d)\n&quot;,path,lng,lat,(int)scale);
-/*					if ((scale&gt;1000) &amp;&amp; (scale&lt;100000))*/
-					{
-						i=load_mapimage(path,lng,lat,scale);
-						s3d_flags_on(i,S3D_OF_VISIBLE);
-					}
-				}
-				sptr=(ptr+1); /* move to next word */
-				word++;
-			} while ((ptr-buf)&lt;len);
-		}
-		fclose(fp);
-	}
-}
-int main(int argc, char **argv)
-{
-	char *gpshost;
-	char *err_str;
-	if (argc&gt;1)
-		gpshost=argv[1];
-	else 
-		gpshost=&quot;localhost&quot;;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;s3dgps&quot;)) 
-	{
-		printf(&quot;connecting to %s\n&quot;,gpshost);
-		dgps=gps_open(gpshost,&quot;2947&quot;);
-	    if (dgps==NULL) {
-			switch ( errno ) {
-				case NL_NOSERVICE: 	err_str = &quot;can't get service entry&quot;; break;
-				case NL_NOHOST: 	err_str = &quot;can't get host entry&quot;; break;
-				case NL_NOPROTO: 	err_str = &quot;can't get protocol entry&quot;; break;
-				case NL_NOSOCK: 	err_str = &quot;can't create socket&quot;; break;
-				case NL_NOSOCKOPT: 	err_str = &quot;error SETSOCKOPT SO_REUSEADDR&quot;; break;
-				case NL_NOCONNECT: 	err_str = &quot;can't connect to host&quot;; break;
-				default:             	err_str = &quot;Unknown&quot;; break;
-			}
-			printf(&quot;no connection to gpsd\n&quot;);
-			fprintf( stderr, &quot;xgps: no gpsd running or network error: %d, %s\n&quot;	, errno, err_str);
-		} else {
-			parse_mapkoords();
-			load_icons();
-			/* init the position */
-			posicon.lng=0;
-			posicon.lat=0;
-			posicon.icon=s3d_clone(iconlist[ICON_ARROW]);
-			posicon.next=NULL;
-			
-			printf(&quot;connection established !!\n&quot;);
-			printf(&quot;query ...\n&quot;);
-			gps_query(dgps, &quot;w+x\n&quot;);
-			printf(&quot;done\n&quot;);
-			s3d_mainloop(mainloop);
-			printf(&quot;done\n&quot;);
-			gps_close(dgps);
-		}
-		s3d_quit(); 
-	}
-	printf(&quot;program finished\n&quot;);
-	return(0);
-}

Modified: trunk/apps/s3dvt/main.c
===================================================================
--- trunk/apps/s3dvt/main.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dvt/main.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,594 +0,0 @@
-/*
- * main.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- * Copyright (C) 2002 Alexander Graf &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">helly at gmx.net</A>&gt;
- *
- * This file is part of s3dvt, a 3d terminal emulator for s3d.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3dvt is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dvt is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dvt; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include &quot;s3dvt.h&quot;
-#include &lt;stdio.h&gt; 		 /*  FILE,NULL */
-#include &lt;unistd.h&gt; 	 /*  read(),write(), sleep(),close() ... */
-#include &lt;errno.h&gt;		 /*  errno() */
-#include &lt;fcntl.h&gt; 		 /*  open() */
-#include &lt;signal.h&gt;		 /*  signal() */
-#include &lt;stdlib.h&gt;		 /*  exit(),getenv(),setenv() */
-#include &lt;sys/ioctl.h&gt; 	 /*  ioctl() */
-#include &lt;pthread.h&gt;	 /*  pthread_create() */
-#include &lt;s3d.h&gt;		 /*  s3d_* */
-#include &lt;s3d_keysym.h&gt;	 /*  key symbols */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-
-
-static int pid;
-static int term_mode=0;
-
-static int cursor;		/* the object id of the cursor */
-
-static pthread_t term_thread;
-
-#ifdef M_PIPE
-static int mpipe_in[2];
-static int mpipe_out[2];
-#endif
-#ifdef M_PTY
-static int curtty,curpty;
-#endif
-
-#ifdef M_CHAR
-static unsigned int charbuf[256];
-static unsigned int screenbuf[MAX_LINES*MAX_CHARS];
-static char 		last_c[MAX_LINES*MAX_CHARS];
-#endif
-
-#ifdef M_LINE
-static int 			lines[MAX_LINES];
-#endif
-
-void *thread_terminal(void *a)
-{
-	int iscon=1,ret;
-	char buffer[1024];
-	while(iscon) 
-	{
-		switch (term_mode)
-		{
-			case M_PIPE:
-				ret=read(mpipe_out[0], &amp;buffer, 1000);
-				break;
-			case M_PTY:
-				ret=read(curpty, &amp;buffer, 1000);
-				break;
-			default:
-				ret=-1;
-		}
-		if(ret&gt;0) 
-		{ 
-			buffer[ret]='\0';
-			printf(&quot;&lt;&lt;&lt;new data(%d bytes)\n&quot;, ret);
-			AddChar(buffer);
-		} else {
-			if (ret==-1)
-			{
-				perror(&quot;read()&quot;);
-				printf(&quot;Connection to pty lost (ret=%d)\n&quot;,ret); 
-				close(mpipe_in[0]);
-				close(mpipe_out[1]);
-		/* 		close(curpty);  */
-		/* 		close(curtty);  */
-				printf(&quot;********CONNECTION TO PTY LOST!*******\n&quot;);
-				sleep(1);
-				s3d_quit();
-				exit(0);
-			}
-		}
-    }
-	return(NULL); /* huh?! */
-}
-int pty_init_terminal()
-{
-    int i;
-    char buf[256];
-    char tmpstr[1024];
-    int curtty;
-    int uid=0,gid=0;
-    char exe[]=&quot;/bin/bash&quot;;
-    char curchar;
-    char *disp;
-    
-    disp=getenv(&quot;DISPLAY&quot;);
-    uid=getuid();
-    gid=getgid();
-	term_mode=M_PTY;
-    for(curchar='p'; curchar&lt;'z';curchar++) 
-	{
-		for(i=0;i &lt; 16;i++) 
-		{
-			sprintf(buf, &quot;/dev/pty%c%x&quot;, curchar, i);
-			curpty=open(buf, O_RDWR);
-			if (curpty &gt;= 0) 
-				goto endloop;
-		}
-    }
-endloop:
-    if(curpty &lt; 0) {
-		printf(&quot;Error opening pty\n&quot;); 
-		return 0; 
-	}
-/* 	fnctl(F_SETFL,O_NONBLOCK); */
-	signal(SIGCHLD, SIG_IGN);
-    pid = fork();
-	if(!pid) 
-	{
-	    buf[5]='t';
-	    curtty=open(buf, O_RDWR);
-	    if (curtty &lt; 0) { 
-			printf(&quot;Error opening tty\n&quot;); 
-			return 0; 
-		}
-	    setuid(uid);
-	    setgid(gid);
-	    if(setsid()&lt;0) 
-			printf(&quot;ERROR (setsid)\n&quot;); 
-	/*     tcflush(curpty, TCIOFLUSH); */
-	    if(ioctl(curtty, TIOCSCTTY, NULL)) 
-			printf(&quot;ERROR! (ttyflush)\n&quot;);;
-	    dup2(curtty, 0);
-	    dup2(curtty, 1);
-	    dup2(curtty, 2);
-	    sprintf(tmpstr, &quot;%d&quot;, MAX_LINES-1);
-	    setenv(&quot;LINES&quot;, tmpstr, 1);
-	    sprintf(tmpstr, &quot;%d&quot;, MAX_CHARS-1);
-	    setenv(&quot;COLUMNS&quot;, tmpstr, 1);
-	    setenv(&quot;TERM&quot;, &quot;rxvt&quot;, 1);
-	    execl(exe, exe, NULL);
-		sleep(1);
-		printf(&quot;that's it, exiting&quot;);
-		close(curtty);
-		exit(0);
-	} else if(pid&lt;0) {
-		printf(&quot;Cant fork()\n&quot;);
-		exit(0);
-	} else {
-    	pthread_create(&amp;term_thread, NULL, thread_terminal, NULL);
-	}
-    return 1;
-}
-/*  terminal.c */
-void term_addchar(char toprint)
-{
-/*    printf(&quot;sending: %.3d\n&quot;, toprint);*/
-	switch (term_mode)
-	{
-		case M_PIPE:
-			write(mpipe_in[1],&amp;toprint,1);
-			write(mpipe_out[1],&amp;toprint,1);
-			break;
-		case M_PTY:
-			write(curpty, &amp;toprint, 1);
-			break;
-	}
-}
-
-
-int pipe_init_terminal()
-{
-    char buf[256];
-    int uid=0,gid=0;
-    char *exe=&quot;/bin/bash&quot;;
-    char *args=&quot;-i&quot;;
-    char *disp;
-
-	term_mode=M_PIPE;
-	if ((pipe(mpipe_in)==-1) || (pipe(mpipe_out)==-1))
-	{
-		printf(&quot;pipe failed\n&quot;);
-		return(-1);
-	}
-    disp=getenv(&quot;DISPLAY&quot;);
-    uid=getuid();
-    gid=getgid();
-    pid = fork();
-	if(pid==0) 
-	{  /*  the child */
-	    char tmpstr[1024];
-	    buf[5]='t';
-	    setuid(uid);
-	    setgid(gid);
-	    if(setsid()&lt;0) 
-			printf(&quot;ERROR (setsid)\n&quot;); 
-/*     tcflush(curpty, TCIOFLUSH); */
-/*     if(ioctl(curtty, TIOCSCTTY, NULL)) printf(&quot;ERROR! (ttyflush)\n&quot;);; */
-		setvbuf(stdout,(char*)NULL,_IONBF,0);
-	    dup2(mpipe_in[0], fileno(stdin));
-	    dup2(mpipe_out[1], fileno(stdout));
-	    dup2(mpipe_out[1], fileno(stderr));
-		 /*  close unneded things: */
-		close(mpipe_out[0]); 
-		close(mpipe_in[1]); 
-	    sprintf(tmpstr, &quot;%d&quot;, MAX_LINES-1);
-	    setenv(&quot;LINES&quot;, tmpstr, 1);
-	    sprintf(tmpstr, &quot;%d&quot;, MAX_CHARS-1);
-	    setenv(&quot;COLUMNS&quot;, tmpstr, 1);
-	    setenv(&quot;TERM&quot;, &quot;rxvt&quot;, 1);
-	    execl(exe, exe, args,NULL);
-		printf(&quot;that's it, exiting&quot;);
-		close(curtty);
-		exit(0);
-   } else if(pid&lt;0) {
-    printf(&quot;Cant fork()\n&quot;);
-	exit(0);
-   } else {
-	 /*  close unneded things... */
-		close(mpipe_in[0]);
-	    pthread_create(&amp;term_thread, NULL, thread_terminal, NULL);
-   }
-    return 1;
-}
-int init_terminal()
-{
-	int i;
-	for (i=0;i&lt;5;i++)
-		if (pty_init_terminal())  /*  find an open pty. */
-			return(0);
-	return(pipe_init_terminal());  /*  if not, fallback to pipe mode */
-}
-void term_unload()
-{
-	printf(&quot;unloading tty!!\n&quot;);
-	switch (term_mode)
-	{
-		case M_PTY:
-			write(curpty, '\0', 1);  /*  send an EOF, just in case */
-		    close(curpty);
-		    close(curtty);
-			 /* kill(pid); */
-			break;
-		case M_PIPE:
-			 /*  bash should fade with &quot;broken pipe&quot; */
-			close(mpipe_in[1]);
-			close(mpipe_out[0]);
-			break;
-	}
-}
-#ifdef M_CHAR
-void paintit()
-{
-	int cline;
-	int c;
-	unsigned char ch,och;
-	unsigned int ci;
-	int i,line_end;
-
-	s3d_translate(	cursor,cx*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cy*CS + CS*MAX_LINES/2,0);
-	s3d_scale(		cursor,CS);
-	for(cline=0;cline&lt;MAX_LINES;cline++)
-	{
-		line_end=0;
-		for (c=0;c&lt;MAX_CHARS;c++)
-		{
-			i=cline*MAX_CHARS+c;			 /*  calculate position */
-			if (((ch=line[cline].chars[c].character)!=(och=last_c[i])))
-			{
-				if (screenbuf[i]==-1)
-				{
-					screenbuf[i]=s3d_new_object();
-					s3d_translate(screenbuf[i],c*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cline*CS + CS*MAX_LINES/2,0);
-					s3d_scale(screenbuf[i],CS);
-					s3d_flags_on(screenbuf[i],S3D_OF_VISIBLE);
-				}
-				if ((ch==0) || (line_end))
-				{	/*  the new character is zero! delete! */
-					line[cline].chars[c].character=0;
-					ci=charbuf[' '];
-					s3d_clone_target(screenbuf[i],ci);
-					line_end=1;
-/* 					printf(&quot;-%03d&quot;,ch); */
-				} else {
-					ci=charbuf[ch];
-/* 					printf(&quot;!%03d&quot;,ch); */
-					s3d_clone_target(screenbuf[i],ci);
-				}
-			} else {
-/* 				printf(&quot;=%03d&quot;,ch); */
-			} 
-			last_c[i]=ch;			
-		}
-/* 		printf(&quot;\n&quot;); */
-	}
-	gotnewdata=0;
-}
-#endif
-#ifdef M_LINE
-void paintit()
-{
-	int cline;
-	int oid,c;
-	int len;
-	int changed;
-	char cl[MAX_CHARS];
-	for(cline=0;cline&lt;MAX_LINES;cline++)
-	{
-		len=MAX_CHARS;
-		changed=0;
-		for (c=MAX_CHARS;c&gt;=0;c--)
-		{
-			cl[c]=line[cline].chars[c].character;
-			if (line[cline].chars[c].character!=line[cline].chars[c].last_c)
-			{
-				changed=c+1;
-/*				printf(&quot;changed [%d/%d] from %d to %d\n&quot;,cline,c,
-								line[cline].chars[c].last_c,
-								line[cline].chars[c].character
-								);*/
-				line[cline].chars[c].last_c=line[cline].chars[c].character;
-			}
-			if (cl[c]==0) len=c;
-		}
-		if (changed)
-		{
-		if (len&gt;0)
-		{
-			printf(&quot;[p: line %d [len: %d/changed: %d]\n&quot;,cline,len,changed);
-			oid=s3d_draw_string(cl,NULL);
-			s3d_translate(oid,0,-cline,0);
-			if (lines[cline]!=-1) 
-			{
-				s3d_del_object(lines[cline]);
-				lines[cline]=-1;
-			}
-			s3d_flags_on(oid,S3D_OF_VISIBLE);
-			lines[cline]=oid;
-		} else {
-			if (lines[cline]!=-1)
-			{
-				s3d_del_object(lines[cline]);
-				lines[cline]=-1;
-			}
-		}
-		}
-		
-	}
-	gotnewdata=0;
-}
-#endif
-/*
-void paint_chars()
-{
-	char c;
-	int oid;
-	int cline,cchar;
-	for(cline=0;cline&lt;MAX_LINES;cline++)
-	{
-	    for(cchar=0;cchar&lt;MAX_CHARS;cchar++)
-		{
-			c=line[cline].chars[cchar].character;
-/ * 			printf(&quot;%02x|&quot;,c); * /
-	        if(!islastchar(cline,cchar))
-	         if(line[cline].chars[cchar].character &amp;&amp; line[cline].chars[cchar].character != ' ')
-			 {
-/ * 				if (screenbuf[MAX_LINES*MAX_CHARS]!=-1) s3d_del_object(screenbuf[MAX_LINES*MAX_CHARS]); * /
-				oid=s3d_clone(cobjs[c]);
-				s3d_translate(oid,10*cchar,10*cline,0);
-				s3d_flags_on(oid,S3D_OF_VISIBLE);
-				screenbuf[MAX_LINES*MAX_CHARS]=oid;
-			 }
-	    }
-/ * 		printf(&quot;\n&quot;); * / 
-	}
-}*/
-void keypress(struct s3d_evt *event)
-{
-	struct s3d_key_event *keys=(struct s3d_key_event *)event-&gt;buf;
-	int key;
-/*	printf(&quot;received key: %d\n&quot;,key);*/
-	switch (key=keys-&gt;keysym)
-	{
-		case S3DK_F1:
-		case S3DK_F2:
-		case S3DK_F3:
-		case S3DK_F4:
-		case S3DK_F5:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('1');
-			term_addchar(key-S3DK_F1+'1');
-			break;
-		case S3DK_F6:
-		case S3DK_F7:
-		case S3DK_F8:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('1');
-			term_addchar((key-S3DK_F6)+'7');
-			break;
-		case S3DK_F9:
-		case S3DK_F10:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('2');
-			term_addchar((key-S3DK_F9)+'0');
-			break;
-		case S3DK_F11:
-		case S3DK_F12:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('2');
-			term_addchar((key-S3DK_F11)+'3');
-			break;
-		case S3DK_UP:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('A');
-			break;
-		case S3DK_DOWN:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('B');
-			break;
-		case S3DK_RIGHT:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('C');
-			break;
-		case S3DK_LEFT:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('D');
-			break;
-		case S3DK_PAGEUP:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('5');
-			term_addchar('~');
-			break;
-		case S3DK_PAGEDOWN:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('6');
-			term_addchar('~');
-			break;
-		case S3DK_HOME:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('7');
-			term_addchar('~');
-			break;
-		case S3DK_END:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('8');
-			term_addchar('~');
-			break;
-		case 13:
-			term_addchar(10);
-			break;
-		default:
-			if ((char)keys-&gt;unicode)  /*  \0 is no good idea .. */
-				term_addchar((char)keys-&gt;unicode);
-	}
-
-}
-int i=0;
-void mainloop()
-{
-	usleep(10000);
-	nanosleep(&amp;t,NULL); 
-
-	if ((i+=2)&gt;100)
-	{
-		if (i%2)
-		{
-			s3d_flags_on(cursor,S3D_OF_VISIBLE);
-			i=0;
-		}
-		else
-		{
-			s3d_flags_off(cursor,S3D_OF_VISIBLE);
-			i=1;
-		}
-	}
-	if (gotnewdata) {
-/* 		printf(&quot;got new data,displaying\n&quot;); */
-		paintit();
-	}
-}
-void stop(struct s3d_evt *event)
-{
-	s3d_quit();
-}
-unsigned int draw_background()
-{
-	unsigned int b;
-	b=s3d_new_object();
-	s3d_push_vertex(b,-MAX_CHARS/2*X_RATIO*CS	,CS	+CS*MAX_LINES/2		,-0.01);
-	s3d_push_vertex(b, MAX_CHARS/2*X_RATIO*CS	,CS	+CS*MAX_LINES/2		,-0.01);
-	s3d_push_vertex(b, MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
-	s3d_push_vertex(b,-MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
-	s3d_push_material_a(b,0.5,0.5,0.5,0.7,
-						  1,1,1,0.7,
-						  0,0,0,0.7);
-	s3d_push_polygon(b,1,2,0,0);
-	s3d_push_polygon(b,2,3,0,0);
-	s3d_flags_on(b,S3D_OF_VISIBLE);
-	return(b);
-}
-void chars_s3d_init()
-{
-#ifdef M_CHAR
-	char c[2];
-	c[1]='\0';
-	for (i=0;i&lt;128;i++)
-	{
-		c[0]=i;
-		charbuf[i]=s3d_draw_string(c,NULL);
-	}
-	for (i=128;i&lt;256;i++)
-	{
-		charbuf[i]=s3d_new_object();
-	}
-	cursor=s3d_new_object();
-	s3d_clone_target(cursor,charbuf['_']);
-#endif
-}
-void chars_init()
-{
-#ifdef M_CHAR
-	int x,y;
-	for (y=0;y&lt;(MAX_LINES);y++)
-	for (x=0;x&lt;(MAX_CHARS);x++)
-	{
-		line[y].chars[x].character=line[y].chars[x].character=0;
-		i=y*MAX_CHARS+x;
-		screenbuf[i]=-1;
-		last_c[i]=0;
-	}
-#endif
-#ifdef M_LINE
-	int i;
-	for (i=0;i&lt;MAX_LINES;i++)
-		lines[i]=-1;
-#endif
-}
-int main (int argc, char **argv)
-{
-	unsigned int b;
-	chars_init();
-   	init_terminal();
-	s3d_set_callback(S3D_EVENT_QUIT,stop);
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,stop);
-	s3d_set_callback(S3D_EVENT_KEY,keypress);
-
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;s3dvt&quot;))	
-	{
-		if (s3d_select_font(&quot;vera&quot;))
-		{
-			printf(&quot;font not found&quot;);
-			exit(-1);
-		}
-		b=draw_background();
-		chars_s3d_init();
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	term_unload();
-	return(0);
-}

Modified: trunk/apps/s3dvt/terminal.c
===================================================================
--- trunk/apps/s3dvt/terminal.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dvt/terminal.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,513 +0,0 @@
-/*
- * terminal.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- * Copyright (C) 2002 Alexander Graf &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">helly at gmx.net</A>&gt;
- *
- * This file is part of s3dvt, a 3d terminal emulator for s3d.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3dvt is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dvt is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dvt; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include &quot;s3dvt.h&quot;
-#include &lt;stdio.h&gt; 		 /*  NULL,perror() */
-#include &lt;string.h&gt;		 /*  memcpy() */
-#include &lt;stdlib.h&gt;		 /*  atoi() */
-#define MOVE_RIGHT 	1
-#define MOVE_LEFT 	2
-#define MOVE_UP	 	3
-#define MOVE_DOWN 	4
-
-
-int cx=0,cy=0;
-
-int gotnewdata=1;
-t_line line[MAX_LINES+1];
-static int isansi=0;
-static int isansi2=0;
-
-static int bottom=MAX_LINES-1;
-static int top=0;
-
-static int curfgcolor=DEFAULT_FGCOLOR;
-static int curbgcolor=DEFAULT_BGCOLOR;
-
-void move_all_lines_up()
-{
-    t_line *pfirstline=(t_line*)&line;
-    t_line *psecondline=(t_line*)&amp;line+1;
-    t_line tmpline[MAX_LINES];
-    memcpy(&amp;tmpline, psecondline, (MAX_LINES-1)*sizeof(struct line_struct));
-    memcpy(pfirstline, &amp;tmpline, (MAX_LINES-1)*sizeof(struct line_struct));
-}
-
-void clear_char(int lineid, int charid)
-{
-    line[lineid].chars[charid].character=0;
-    line[lineid].chars[charid].fgcolor=DEFAULT_FGCOLOR;
-    line[lineid].chars[charid].bgcolor=DEFAULT_BGCOLOR;
-}
-
-void clear_line(int lineid)
-{
-    int i;
-    for(i=0;i&lt;MAX_CHARS;i++)
-		clear_char(lineid, i);
-}
-
-void clear_line_after_lastchar()
-{
-    int i;
-    for(i=cx;i&lt;MAX_CHARS;i++) 
-		clear_char(cy, i);
-}
-
-t_line *line_is_full()
-{
-    t_line *pcurline=(t_line*)&amp;line+cy;
-    cy++;
-    if (cy&gt;=MAX_LINES) {       /*  damn it ... our display is filled ... let's move everything upwards */
-		cy=MAX_LINES-1;
-		pcurline=(t_line*)&amp;line+cy;
-        move_all_lines_up();
-        clear_line(cy);
-		gotnewdata=1;
-    } else {
-        pcurline=(t_line*)&amp;line+cy;
-    }
-	cx=0;
-    return pcurline;
-}
-
-void add_char_append(char toappend)
-{
-    int shouldinc=1;
-    t_line *pcurline=(t_line*)&amp;line+cy;
-    if (cx==MAX_CHARS-1)
-	{ 
-		pcurline=line_is_full(); 
-		shouldinc=0; 
-	}  /*  our line is full */
-    pcurline-&gt;chars[cx].character=toappend;
-    pcurline-&gt;chars[cx].fgcolor=curfgcolor;
-    pcurline-&gt;chars[cx].bgcolor=curbgcolor;
-    if(shouldinc) 
-		cx++;
-}
-
-void backspace()
-{
-    if(cx&gt;0)
-		cx--;
-    else 
-		cx=0;
-}
-
-void endansi()
-{
-    printf(&quot; [/ANSI(%d)]\n&quot;, isansi2);
-    isansi=0;
-    isansi2=0;
-}
-
-/*
-              Parameter                              Parameter Meaning                                     
-	      
-	      0                                      Attributes off                                                                                      
-	      1                                      Bold or increased intensity                                                                                       
-	      4                                      Underscore                                                                                            
-	      5                                      Blink                                                                                                     
-	      7                                      Negative (reverse) image                                                                           
-*/	      
-
-void ansi_change_graphic(char **args)
-{
-    int curcol;
-    int i;
-    
-    if (args[0][0]=='\0') 
-	{
-		args[0][0]='0';
-		args[0][1]='\0';
-	}
-    
-    for(i=0;i&lt;5;i++)
-	{
-		if(args[i][0])
-		{
-		    curcol=atoi(args[i]);
-			
-			switch(curcol)
-			{
-			    case 0:
-					curbgcolor=DEFAULT_BGCOLOR;
-					curfgcolor=DEFAULT_FGCOLOR;
-					break;
-			    case 1:	 /*  Bold or increased intensity */
-			    case 4:	 /*  Underscore */
-			    case 5:	 /*  Blink */
-			    case 7:	 /*  Negative (reverse) image */
-			    case 10:	 /*  primary font */
-			    case 11:	 /*  alternate font */
-					break;
-				case 30:
-				case 31:
-				case 32:
-				case 33:
-				case 34:
-				case 35:
-				case 36:
-				case 37:
-					curfgcolor=curcol-30;
-					break;
-			    case 39:
-					curbgcolor=DEFAULT_FGCOLOR;
-					break;
-				case 40:
-				case 41:
-				case 42:
-				case 43:
-				case 44:
-				case 45:
-				case 46:
-				case 47:
-					curbgcolor=curcol-40;
-					break;
-	
-			    case 49:
-					curbgcolor=DEFAULT_BGCOLOR;
-					break;
-	
-			    default:
-					printf(&quot;*** don't know color-code %d\n&quot;, curcol);
-					break;
-		    }
-		}
-    }
-}
-void move_up_x_lines(char *arg)
-{
-    t_line *pfirstline;
-    t_line *psecondline;
-    t_line tmpline[MAX_LINES];
-    int amount;
-    int i;
-    
-    if(arg[0]) amount=atoi(arg); else amount=0;
-    
-    printf(&quot;moving up %d lines&quot;, amount);
-    
-    for(i=0;i&lt;amount;i++)
-	{
-    
-		pfirstline=(t_line*)&amp;line+cy;
-		psecondline=pfirstline+1;
-    
-		memcpy(&amp;tmpline, psecondline, (bottom-top)*sizeof(struct line_struct));
-		memcpy(pfirstline, &amp;tmpline,  (bottom-top)*sizeof(struct line_struct));
-    
-    }
-}
-
-void move_down_x_lines(char *arg)
-{
-    t_line *pfirstline;
-    t_line *psecondline;
-    t_line tmpline[MAX_LINES];
-    int amount;
-    int i;
-    
-    if(arg[0]) amount=atoi(arg); else amount=0;
-    
-    printf(&quot;moving down %d lines&quot;, amount);
-    
-    for(i=0;i&lt;amount;i++)
-	{
-		pfirstline=(t_line*)&amp;line+cy;
-		psecondline=pfirstline+1;
-    
-		memcpy(&amp;tmpline, pfirstline, (bottom-top)*sizeof(struct line_struct));
-		memcpy(psecondline, &amp;tmpline,  (bottom-top)*sizeof(struct line_struct));
-    }
-}
-void delete_x_letters(char *arg1)
-{
-    int tmpint;t_line *pcurline;int i;
-	if(arg1[0]) tmpint=atoi(arg1);
-	else	    tmpint=1;
-	pcurline=(t_line*)&amp;line+cy;
-	if (tmpint+cx&gt;MAX_CHARS) 
-		tmpint=MAX_CHARS-cx;
-	for(i=cx;i&lt;cx+tmpint;i++)
-	    clear_char(cy,i);
-}
-void move_x_letters(int mode, char *arg1)
-{
-    int tmpint;t_line *pcurline;int i;
-	if(arg1[0])
-	    tmpint=atoi(arg1);
-	else
-	    tmpint=1;
-	pcurline=(t_line*)&amp;line+cy;
-	switch(mode) {
-	    case MOVE_RIGHT:
-	        for(i=0;i&lt;tmpint;i++)
-			{
-/*	    	    pcurline-&gt;nextchar++; 
-				lastchar++;*/
-				cx++;
-		    	if (cx==MAX_CHARS) 
-					pcurline=line_is_full();  /*  our line is full */
-			}
-			break;
-	    case MOVE_LEFT:
-	        for(i=0;i&lt;tmpint;i++)
-			{
-				cx--;
-			    if(cx==-1) 
-				{ 
-					cy--; 
-					pcurline=(t_line*)&amp;line+cy; 
-					cx=MAX_CHARS-1; 
-				}  /*  need to go up one line */
-			}
-			break;
-	    case MOVE_UP:
-			cy--;
-			break;
-	    case MOVE_DOWN:
-			line_is_full();
-			break;
-	    default:
-			break;
-	}
-}
-void remove_beginning_from_curpos()
-{
-    int i,j=cx;
-    for(i=cy;i&lt;MAX_LINES;i++) {
-	for(;j&lt;MAX_CHARS;j++){
-	    clear_char(i,j);
-	}
-	j=0;
-    }
-}
-
-int parseansi(char curchar)
-{
-	static char arg1[16]=&quot;&quot;;
-	static char arg2[16]=&quot;&quot;;
-	static char arg3[16]=&quot;&quot;;
-	static char arg4[16]=&quot;&quot;;
-	static char arg5[16]=&quot;&quot;;
-	static char curindex=0;
-	static char curarg=0;
-	static char *args[]={arg1,arg2,arg3,arg4,arg5};
-	/* 	static char *args[]={&amp;arg1,&amp;arg2,&amp;arg3,&amp;arg4,&amp;arg5}; */
-	    printf(&quot;%c&quot;, curchar);
-	switch (isansi2)
-	{
-	case 1:
-		switch(curchar)
-		{
-		    case '0':
-		    case '1':
-		    case '2':
-		    case '3':
-		    case '4':
-		    case '5':
-		    case '6':
-		    case '7':
-		    case '8':
-		    case '9':  /*  we got an argument */
-				args[(int)curarg][(int)curindex]=curchar;
-				curindex++; 
-				args[(int)curarg][(int)curindex]='\0';
-				break;
-		    case ';':  /*  some arg is finished */
-				curarg++; 
-				curindex=0; 
-				args[(int)curarg][0]='\0';
-				break;
-		    case 'J':  /*  remove beginning from current cursor to end of screen */
-				remove_beginning_from_curpos();
-				gotnewdata=1;
-				break;
-		    case 'K':  /*  remove everything in line beginning from lastchar */
-				clear_line_after_lastchar();
-				break;
-		    case 'H':  /*  move to position x=arg1 y=arg2 */
-				if(arg1[0]) cy=atoi(arg1)-1; 
-					else 	cy=0;
-				if(arg2[0]) cx=atoi(arg2)-1; 
-					else 	cx=0;
-				break;
-		    case 'G':  /*  move to position x=arg1 y=MAX */
-				if(arg1[0]) cx=atoi(arg1)-1; else cx=-1;
-				cy=bottom-1;
-				break;
-		    case 'd':  /*  move to position x=MAX y=arg1 */
-				if(arg1[0]) cy=atoi(arg1)-1; else cy=0;
-				cy=top+cy;
-				cx=MAX_CHARS-1;
-				break;
-		    case 'm':  /*  change graphic */
-				ansi_change_graphic(args);
-				break;
-		    case 'M':  /*  Move memory in range ('r') one uo */
-				move_up_x_lines(arg1);
-				break;
-		    case 'L':  /*  Move memory in range ('r') one down */
-				move_down_x_lines(arg1);
-				break;
-		    case 'l':
-	/*		RM -- Reset Mode
-			
-			ESC [ Ps ; Ps ; . . . ; Ps l                                                                                                          default value: none
-			
-			Resets one or more VT100 modes as specified by each selective parameter in the parameter string. Each mode to be reset is specified by a separate
-			parameter. [See Set Mode (SM) control sequence]. (See Modes following this section).*/
-			
-			 /*  mc only resets the '4' !?! =&gt; IRM (Insert/Replacement-Mode) */
-			 /*  perhaps Set Cursor to Block mode ? */
-				break;
-			case 'r':  /*  define scroll-range  */
-				if(arg1[0]) top=atoi(arg1); else top=0;
-				if(arg2[0]) bottom=atoi(arg2); else bottom=0;
-				cy=0; 
-				cx=0;
-				break;
-			case 'a':
-			case 'A':  /*  move x letters up */
-				move_x_letters(MOVE_UP, arg1);	break;
-			case 'B':  /*  move x letters down */
-				move_x_letters(MOVE_DOWN, arg1);	break;
-			case 'C':  /*  move x letters right */
-				move_x_letters(MOVE_RIGHT, arg1);	break;
-			case 'D':  /*  move x letters left */
-				move_x_letters(MOVE_LEFT, arg1);	break;
-			case 'P':  /*  delete x letters */
-				delete_x_letters(arg1);	break;
-			case '?':
-				isansi2=4;
-				return 0;
-			default:
-				printf(&quot;***unknown***&quot;);
-		}
-		if(!((curchar&gt;='0' &amp;&amp; curchar&lt;='9') || curchar==';'))
-		{  /*  clean our args */
-			args[0][0]='\0';
-			args[1][0]='\0';
-			args[2][0]='\0';
-			args[3][0]='\0';
-			args[4][0]='\0';
-			curindex=0;
-			curarg=0;
-			endansi();
-		} 
-		break;
-	case 0:
-		switch(curchar)
-		{
-		    case '[': isansi2=1; break;
-		    case '(': isansi2=2; break;
-		    case ')': isansi2=3; break;
-		    case ']': isansi2=5; break;
-		    default:
-			endansi();
-			break;
-		}
-		break;
-	case 4:
-		if (curchar&gt;'9' || curchar&lt;'0') 
-			endansi();
-		break;
-	case 5:
-		if(curchar==7) endansi(); /* FIXME: Window Title*/
-		break;
-	default:
-		endansi();
-		break;
-    }
-	return(0);
-}
-
-void AddChar(char *_toadd)
-{
-    char *toadd;
-    char curchar;
-
-    for(toadd=_toadd;toadd[0];toadd++) 
-	{
-		curchar=toadd[0];
-	/*	printf(&quot;%.3d (&quot;, curchar);*/
-		if(isansi) 
-			parseansi(curchar); 
-		else
-		{
-			switch(curchar) 
-			{
-			case 7:
-			    printf(&quot;&lt;BEEP&gt;\n&quot;);
-			    break;
-			case 8:
-			    printf(&quot;&lt;BS&gt;\n&quot;);
-			    backspace();
-			    break;
-			case 27:
-			     /*  ANSI */
-			    printf(&quot;&lt;ESC&gt;[ANSI] &quot;);
-			    isansi=1;
-			    break;
-			case 10:
-			    printf(&quot;&lt;LF&gt;\n&quot;);/* get onto the next line */
-			    line_is_full();
-			    break;
-			case 13:
-			    printf(&quot;&lt;CR&gt;\n&quot;);/* carriage return, get back */
-				if (cx==MAX_CHARS-1) 
-					line_is_full();
-				cx=0;
-			    break;
-			default:
-				if ((curchar&gt;=32) &amp;&amp; (curchar&lt;127))
-				{
-			/*	    printf(&quot;%c&quot;, curchar);*/
-				    add_char_append(curchar);
-				}
-			    break;
-		    }
-/*	printf(&quot;)\n&quot;);*/
-		}
-    }
-    gotnewdata=1;
-}
-void init_line()
-{
-    int i;
-    for(i=0;i&lt;MAX_LINES;i++){
-		clear_line(i);
-    }
-}
-void term_addstring(char *toprint)
-{
-    char *ns;
-    for(ns=toprint;ns[0];ns++)
-	{
-		term_addchar(ns[0]);
-    }  /*  better method */
-}

Deleted: trunk/example/3dsloader.c
===================================================================
--- trunk/example/3dsloader.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/3dsloader.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,63 +0,0 @@
-/*
- * 3dsloader.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-
-#include &lt;s3d.h&gt;
-#include &lt;stdio.h&gt;  /* NULL */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
-int i,oid;
-void mainloop()
-{
-	s3d_rotate(oid,0,i,0);
-	i++;
-	nanosleep(&amp;t,NULL); 
-}
-void object_click(struct s3d_evt *evt)
-{
-	s3d_quit();
-}
-	
-int main (int argc, char **argv)
-{
-	if (argc&lt;2)
-	{
-		printf(&quot;usage: %s [somefile.3ds]\n&quot;,argv[0]);
-		return(-1);
-	}
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;3dsloader&quot;))	
-	{
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-	    if (-1!=(oid=s3d_import_3ds_file(argv[1])))
-		{
-		    s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_mainloop(mainloop);
-		} else {
-			printf(&quot;file not found ... \n&quot;);
-		}
-		s3d_quit();
-	}
-	return(0);
-}

Deleted: trunk/example/3dsloader_g3d.c
===================================================================
--- trunk/example/3dsloader_g3d.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/3dsloader_g3d.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,234 +0,0 @@
-/*
- * 3dsloader_g3d.c
- *
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *                         Marek Lindner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">lindner_marek at yahoo.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- *
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-
-#include &lt;s3d.h&gt;
-#include &lt;stdio.h&gt;  /* NULL */
-#include &lt;time.h&gt;	/* nanosleep() */
-#include &lt;g3d/g3d.h&gt;
-#include &lt;stdlib.h&gt;
-
-
-struct material2texture {
-	struct material2texture *next_ptr;   /* pointer to next */
-	void *material_ptr;
-	void *texture_ptr;
-	int material_id;
-	int texture_id;
-};
-
-
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
-struct material2texture *mat2tex_root = NULL;
-int i,obj_id;
-
-
-
-void mainloop() {
-	s3d_rotate(obj_id,0,i,0);
-	i++;
-	nanosleep(&amp;t,NULL);
-}
-
-
-
-void object_click(struct s3d_evt *evt) {
-	s3d_quit();
-}
-
-
-
-void *get_mat2tex( struct material2texture **mat2tex, void *mat_ptr ) {
-
-	while ( (*mat2tex) != NULL ) {
-
-		if ( (*mat2tex)-&gt;material_ptr == mat_ptr ) return (*mat2tex);
-
-		mat2tex = &amp;(*mat2tex)-&gt;next_ptr;
-
-	}
-
-	if ( (*mat2tex) == NULL ) {
-
-		(*mat2tex) = malloc( sizeof( struct material2texture ) );
-
-		if ( (*mat2tex) == NULL ) {
-			printf( &quot;Sorry - you ran out of memory !\n&quot; );
-			exit(8);
-		}
-
-		(*mat2tex)-&gt;next_ptr = NULL;
-		(*mat2tex)-&gt;material_ptr = mat_ptr;
-		(*mat2tex)-&gt;texture_ptr = NULL;
-		(*mat2tex)-&gt;material_id = -1;
-		(*mat2tex)-&gt;texture_id = -1;
-
-		return (*mat2tex);
-
-	}
-
-	return(0);
-
-}
-
-
-
-int main (int argc, char **argv) {
-
-	G3DContext *context;
-	G3DModel *model;
-	G3DObject *object;
-	G3DFace *face;
-	GSList *oitem, *oface;
-	struct material2texture *mat2tex;
-	int j, k, material_count, texture_count, voff;
-	int polys=0;
-	unsigned char *s3d_pixeldata = NULL;
-
-	if (argc&lt;2) {
-		printf(&quot;usage: %s [somefile.3ds]\n&quot;,argv[0]);
-		return(-1);
-	}
-
-	context = g3d_context_new();
-
-	if ( !s3d_init( &amp;argc,&amp;argv,&quot;3dsloader_g3d&quot; ) ) {
-
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-
-		model = g3d_model_load(context, argv[1]);
-
-		if ( model ) {
-
-			oitem = model-&gt;objects;
-			obj_id = s3d_new_object();
-			material_count = texture_count = voff = 0;
-
-			while ( oitem ) {
-
-				object = (G3DObject *)oitem-&gt;data;
-
-				/* push vertices */
-				for ( j = 0; j &lt; object-&gt;vertex_count; j++ ) {
-					/* 3. and 4. param have to change places otherwise the object will be turned */
-					printf(&quot;vertex: %d/%d: %f %f %f\n&quot;,j, object-&gt;vertex_count, object-&gt;vertex_data[j * 3], object-&gt;vertex_data[j * 3 + 2], object-&gt;vertex_data[j * 3 + 1]);
-					s3d_push_vertex( obj_id, object-&gt;vertex_data[j * 3], object-&gt;vertex_data[j * 3 + 2], object-&gt;vertex_data[j * 3 + 1] );
-				}
-
-
-				oface = object-&gt;faces;
-
-				while ( oface ) {
-
-					face = (G3DFace *)oface-&gt;data;
-
-					mat2tex = get_mat2tex( &amp;mat2tex_root, face-&gt;material );
-
-					if ( mat2tex-&gt;material_id == -1 ) {
-
-						/* printf( &quot;push material: %i\n&quot;, material_count ); */
-
-						s3d_push_material_a( obj_id, face-&gt;material-&gt;r, face-&gt;material-&gt;g, face-&gt;material-&gt;b, face-&gt;material-&gt;a, face-&gt;material-&gt;specular[0], face-&gt;material-&gt;specular[1], face-&gt;material-&gt;specular[2], face-&gt;material-&gt;specular[3], face-&gt;material-&gt;r, face-&gt;material-&gt;g, face-&gt;material-&gt;b, face-&gt;material-&gt;a );
-
-						mat2tex-&gt;material_id = material_count;
-						material_count++;
-
-						if ( face-&gt;tex_image != NULL ) {
-
-							/* reorder pixeldata - s3d wants rgba */
-							if ( s3d_pixeldata != NULL ) free( s3d_pixeldata );
-
-							s3d_pixeldata = malloc( sizeof( unsigned char ) * face-&gt;tex_image-&gt;width * face-&gt;tex_image-&gt;height * 32 );
-
-							if ( s3d_pixeldata == NULL ) {
-								printf( &quot;Sorry - you ran out of memory !\n&quot; );
-								exit(8);
-							}
-
-							for ( j = ( face-&gt;tex_image-&gt;height - 1 ); j &gt;= 0; j-- ) {
-
-								for ( k = 0; k &lt; face-&gt;tex_image-&gt;width; k++ ) {
-
-									s3d_pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 0 ] = face-&gt;tex_image-&gt;pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 2 ];
-									s3d_pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 1 ] = face-&gt;tex_image-&gt;pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 1 ];
-									s3d_pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 2 ] = face-&gt;tex_image-&gt;pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 0 ];
-									s3d_pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 3 ] = face-&gt;tex_image-&gt;pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 3 ];
-
-								}
-
-							}
-
-							s3d_push_texture( obj_id, face-&gt;tex_image-&gt;width, face-&gt;tex_image-&gt;height );
-							s3d_pep_material_texture( obj_id, texture_count );
-							s3d_load_texture( obj_id, texture_count, 0, 0, face-&gt;tex_image-&gt;width, face-&gt;tex_image-&gt;height, s3d_pixeldata );
-
-							mat2tex-&gt;texture_id = texture_count;
-							texture_count++;
-
-						}
-
-					}
-
-					/* printf( &quot;push polygone with material: %i\n&quot;, mat2tex-&gt;material_id ); */
-
-					/* push polygones */
-					s3d_push_polygon( obj_id, face-&gt;vertex_indices[0] + voff, face-&gt;vertex_indices[1] + voff , face-&gt;vertex_indices[2] + voff, mat2tex-&gt;material_id );
-
-					/* has polygone normals */
-					if ( face-&gt;flags &amp; G3D_FLAG_FAC_NORMALS ) s3d_pep_polygon_normals( obj_id, face-&gt;normals, 1 );
-
-					/* face with texture */
-					if ( ( mat2tex-&gt;texture_id != -1 ) &amp;&amp; ( face-&gt;flags &amp; G3D_FLAG_FAC_TEXMAP ) ) {
-
-						/* printf( &quot;text_coords: %f:%f %f:%f %f:%f\n&quot;, face-&gt;tex_vertex_data[0], face-&gt;tex_vertex_data[1], face-&gt;tex_vertex_data[2], face-&gt;tex_vertex_data[3], face-&gt;tex_vertex_data[4], face-&gt;tex_vertex_data[5] ); */
-
-						s3d_pep_polygon_tex_coord( obj_id, face-&gt;tex_vertex_data[0], face-&gt;tex_vertex_data[1], face-&gt;tex_vertex_data[2], face-&gt;tex_vertex_data[3], face-&gt;tex_vertex_data[4], face-&gt;tex_vertex_data[5] );
-
-					}
-
-
-					oface = oface-&gt;next;
-
-				}
-
-				voff += object-&gt;vertex_count; /* increase vertex offset */
-				oitem = oitem-&gt;next;
-
-			}
-
-			s3d_flags_on( obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE );
-
-			s3d_mainloop(mainloop);
-
-		}
-
-		s3d_quit();
-
-	}
-
-	return(0);
-
-}

Modified: trunk/example/Makefile.am
===================================================================
--- trunk/example/Makefile.am	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/Makefile.am	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,10 +1,10 @@
 noinst_PROGRAMS=	hudtest katze \
 			ptrtest radius_test s3dclock snowman \
 			strtest texturetest linetest widgets \
-			3dsloader_g3d nichtsnutz
-bin_PROGRAMS= filebrowser 3dsloader
+			nichtsnutz
+bin_PROGRAMS= filebrowser modelloader
 			
-3dsloader_SOURCES=		3dsloader.c
+3dsloader_SOURCES=		modelloader.c
 widgets_SOURCES=		widgets.c
 filebrowser_SOURCES=	filebrowser.c
 hudtest_SOURCES=		hudtest.c
@@ -16,15 +16,12 @@
 strtest_SOURCES=		strtest.c
 texturetest_SOURCES=	texturetest.c
 ptrtest_SOURCES=		ptrtest.c
-3dsloader_g3d_SOURCES=	3dsloader_g3d.c
 nichtsnutz_SOURCES=		nichtsnutz.c
 
 CPPFLAGS=		-I$(top_srcdir)/server -I$(top_srcdir)/libs3d 
 LIBS=			$(top_builddir)/libs3d/libs3d.la  
-3dsloader_g3d_CFLAGS=	-I$(top_srcdir)/libs3d/libg3d/include @GLIB_CFLAGS@
 widgets_CFLAGS=			-I$(top_srcdir)/libs3dw 
 widgets_LDFLAGS=		$(top_builddir)/libs3dw/libs3dw.la
-3dsloader_g3d_LDFLAGS=	$(top_builddir)/libs3d/libg3d/src/libg3d.la
 
 EXTRA_DIST=	\
 	TODO

Modified: trunk/example/filebrowser.c
===================================================================
--- trunk/example/filebrowser.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/filebrowser.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,245 +0,0 @@
-/*
- * filebrowser.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-
-#include &lt;s3d.h&gt;
-#include &lt;stdio.h&gt; 	 /*  printf() */
-#include &lt;dirent.h&gt;  /*  dirent */
-#include &lt;stdlib.h&gt;	 /*  malloc() */
-#include &lt;string.h&gt;  /*  strlen(), strncmp(), strrchr() */
-#include &lt;unistd.h&gt;	 /*  chdir() */
-#include &lt;math.h&gt;	 /*  sin(),cos() */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
-
-#define T_DUNO		0
-#define T_LOCALDIR	1
-#define T_BACKDIR	2
-#define T_FOLDER	3
-#define T_GEOMETRY	4
-#define T_MUSIC		5
-#define	T_MOVIE		6
-
-#define M_DIR		512
-#define M_NAME		256
-int folder,geometry,mp3,movie,duno,dot,dotdot;
-struct t_item {
-	int icon_oid, descr_oid, pie_oid;
-	char name[M_NAME];
-	int type;
-};
-struct t_item *item;
-int n_item=0;
-int display_dir(char *dir, int depth, int  posx, int posy, int posz)
-{
-	struct dirent **namelist;
-	int n,i;
-	int  px,py,pz;
-	char *ext;
-	char *nstr;
-	float alpha,al,radius,f;
-	char ndir[M_DIR+1];
-	if (n_item)
-	{
-		printf(&quot;freeing %d old items\n&quot;,n_item);
-		for (i=0;i&lt;n_item;i++)
-		{
-			printf(&quot;deleting %d and %d\n&quot;,item[i].icon_oid,	item[i].descr_oid);
-			s3d_del_object(item[i].descr_oid);
-			s3d_del_object(item[i].icon_oid);
-			s3d_del_object(item[i].pie_oid);
-		}
-		free(item);
-		
-	}
-    n = i = scandir(dir, &amp;namelist, 0, alphasort);
-    if (n &lt; 0)
-	{
-        perror(&quot;scandir&quot;);
-		return(-1);
-	}
-    else {
-		item=malloc(sizeof(struct t_item)*i);
-		n_item=i;
-        while(n--) {
-			item[n].type=T_DUNO;
-			nstr=namelist[n]-&gt;d_name;
-			strncpy(item[n].name,nstr,M_NAME);
- 		    if ((0==strncmp(nstr,&quot;.&quot;,1)) &amp;&amp; (strlen(nstr)==1))
-				item[n].type=T_LOCALDIR;
-			else if (0==strncmp(nstr,&quot;..&quot;,strlen(nstr)&lt;2?strlen(nstr):2))
-			   item[n].type=T_BACKDIR;
-			else {
-				ext=strrchr(nstr,'.');
-			    strncpy(ndir,dir,M_DIR);
-				ndir[M_DIR]=0;		/* just in case */
-			    strncat(ndir,&quot;/&quot;,M_DIR-strlen(ndir));
-		    	strncat(ndir,namelist[n]-&gt;d_name,M_DIR-strlen(ndir));
-/* 				printf(&quot;displaying %s\n&quot;,ndir); */
-			    if ((namelist[n]-&gt;d_type==DT_DIR) ||
-					((namelist[n]-&gt;d_type==DT_UNKNOWN) &amp;&amp; (opendir(ndir)!=NULL)))
-					item[n].type=T_FOLDER;
-				else 
-				{
-				   if (ext!=NULL)
-				   {
-					   if (0==strncmp(ext,&quot;.3ds&quot;,strlen(ext)&lt;4?strlen(ext):4))
-							   item[n].type=T_GEOMETRY;
-					   else if (0==strncmp(ext,&quot;.mp3&quot;,strlen(ext)&lt;4?strlen(ext):4))
-							   item[n].type=T_MUSIC;
-					   else if (0==strncmp(ext,&quot;.mpg&quot;,strlen(ext)&lt;4?strlen(ext):4))
-							   item[n].type=T_MOVIE;
-
-				   }
-				}
-			}
-			switch (item[n].type)
-			{
-				case T_LOCALDIR:   	item[n].icon_oid=s3d_clone(dot);break;
-				case T_BACKDIR:   	item[n].icon_oid=s3d_clone(dotdot);break;
-				case T_FOLDER:   	item[n].icon_oid=s3d_clone(folder);
-									break;
-				case T_GEOMETRY:   	item[n].icon_oid=s3d_clone(geometry);break;
-				case T_MUSIC:	   	item[n].icon_oid=s3d_clone(mp3);break;
-				case T_MOVIE:		item[n].icon_oid=s3d_clone(movie);break;
-				default:   			printf(&quot;don't know type, defaulting to duno %d...\n&quot;,duno);
-									item[n].icon_oid=s3d_clone(duno);break;
-			}
-
-			px=posx;py=posy;pz=posz;
-			alpha=((360.0*n)/((float)i));
-			radius=((n_item*10)/(M_PI*4));
-			if (n_item&lt;5)
-				radius=((50)/(M_PI*4));
-			else
-				radius=((n_item*10)/(M_PI*4));
-			px=posx-sin(alpha*M_PI/180.0)*radius;
-			pz=posy;
-			pz=posz-cos(alpha*M_PI/180.0)*radius;
-
-			item[n].pie_oid=s3d_new_object();
-			s3d_push_vertex(item[n].pie_oid,0,-2,0);
-			al=((360.0*(n-0.5))/((float)i));
-			s3d_push_vertex(item[n].pie_oid,		
-						posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
-			al=((360.0*(n+0.5))/((float)i));
-			s3d_push_vertex(item[n].pie_oid,		
-						posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
-			
-			f=1.0-0.05*(n%2);
-			switch (item[n].type)
-			{
-				case T_LOCALDIR:s3d_push_material(item[n].pie_oid,		0,f,0,			0.5,0.5,0.5,		f,f,f);		break;
-				case T_BACKDIR:	s3d_push_material(item[n].pie_oid,		0,f/2,0,		0.5,0.5,0.5,		f,f,f);		break;
-				case T_FOLDER:	s3d_push_material(item[n].pie_oid,		f,f,0,			0.5,0.5,0.0,		f,f,1);		break;
-				default:		s3d_push_material(item[n].pie_oid,		f,f,f,			0.5,0.5,0.5,		f,f,f);		break;
-			}
-			s3d_push_polygon(item[n].pie_oid,	0,2,1,	0);
-
-			s3d_push_vertex(item[n].pie_oid,pz,-2,0);
-			s3d_translate(item[n].icon_oid,px,py,pz);
-			s3d_rotate(item[n].icon_oid,0,alpha,0);
-		    s3d_flags_on(item[n].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		    s3d_flags_on(item[n].pie_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			item[n].descr_oid=s3d_draw_string(nstr,NULL);
-			s3d_link(item[n].descr_oid,item[n].icon_oid);
-			s3d_translate(item[n].descr_oid,-1,-2,0); 
-/* 			r=s3d_get_radius(p); */
-/* 			s3d_scale(p,1.0/r,1.0/r,1.0/r); */
-		    s3d_flags_on(item[n].descr_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-            printf(&quot;%s [%d]\n&quot;, nstr,namelist[n]-&gt;d_type);
-			printf(&quot;string %d linked to %d\n&quot;,item[n].descr_oid,item[n].icon_oid);
-        	free(namelist[n]);
-        }
-		free(namelist);
-   	}
-	return(0);
-}
-
-void object_click(struct s3d_evt *evt)
-{
-	int i,oid;
-	char execstr[256];
-	oid=(int)*((unsigned long *)evt-&gt;buf);
-	printf(&quot;!!!!!!!!! clicked object %d\n&quot;,oid);
-	for (i=0;i&lt;n_item;i++)
-	{
-		if (((oid==item[i].icon_oid) || (oid==item[i].descr_oid)) ||
-			(oid==item[i].pie_oid) )
-		{
-			switch (item[i].type)
-			{
-				case T_BACKDIR:
-				case T_FOLDER:
-				case T_LOCALDIR:
-						printf(&quot;going into %s\n&quot;,item[i].name);
-						chdir(item[i].name);
-						display_dir(&quot;.&quot;,0,0,0,0);
-						return;
-						break;
-				case T_GEOMETRY:
-						printf(&quot;loading geometry %s\n&quot;,item[i].name);
-						snprintf(execstr,256,&quot;3dsloader \&quot;%s\&quot;&amp;\n&quot;,item[i].name);
-						system(execstr);
-						return;
-						break;
-				case T_MOVIE:
-						printf(&quot;playing %s\n&quot;,item[i].name);
-						snprintf(execstr,256,&quot;mplayer -vo s3d \&quot;%s\&quot;&amp;\n&quot;,item[i].name);
-						system(execstr);
-						return;
-						break;
-
-						
-			}
-		}
-	}
-}
-void mainloop()
-{
-	nanosleep(&amp;t,NULL); 
-}
-int main (int argc, char **argv)
-{
-	int i;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;filebrowser&quot;))	
-	{
-		i=0;
-		 /*  load the object files */
-		folder=s3d_import_3ds_file(&quot;objs/folder.3ds&quot;);
-		geometry=s3d_import_3ds_file(&quot;objs/geometry.3ds&quot;);
-		mp3=s3d_import_3ds_file(&quot;objs/notes.3ds&quot;);
-		movie=s3d_import_3ds_file(&quot;objs/film.3ds&quot;);
-		duno=s3d_import_3ds_file(&quot;objs/duno.3ds&quot;);
-		dot=s3d_import_3ds_file(&quot;objs/dot.3ds&quot;);
-		dotdot=s3d_import_3ds_file(&quot;objs/dotdot.3ds&quot;);
-		s3d_select_font(&quot;vera&quot;);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-		display_dir(&quot;.&quot;,0,0,0,0);
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/example/hudtest.c
===================================================================
--- trunk/example/hudtest.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/hudtest.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,51 +0,0 @@
-/*
- * hudtest.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include &lt;s3d.h&gt;
-#include &lt;unistd.h&gt;  /*  sleep() */
-#include &lt;stdio.h&gt;  /*  printf() */
-void mainloop()
-{
-	sleep(1);
-}
-int main(int argc, char **argv)
-{
-	int o,m;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;hud-test&quot;))
-	{
-		if (s3d_select_font(&quot;vera&quot;))
-			printf(&quot;font not found\n&quot;);
-		o=s3d_draw_string(&quot;hud-test&quot;,NULL);
-		m=s3d_import_3ds_file(&quot;objs/star.3ds&quot;);
-		s3d_translate(o,0,0,-5);
-		s3d_link(o,0);
-		s3d_flags_on(o,S3D_OF_VISIBLE);
-		s3d_flags_on(m,S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-
-}

Modified: trunk/example/katze.c
===================================================================
--- trunk/example/katze.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/katze.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,91 +0,0 @@
-/*
- * katze.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-
-#include &lt;s3d.h&gt;
-#include &lt;math.h&gt;	/* sin() */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-
-int a;
-int rot_point,body,legfr,legbr,legfl,legbl,tail;
-
-void mainloop()
-{
-	float pos;
-	a=(a+2)%360;
-	pos=sin((5*a*M_PI)/180)*20;
-	s3d_rotate(legfr,0,90,180+pos);
-	s3d_rotate(legfl,0,90,180-pos);
-	s3d_rotate(legbr,0,0,180+pos);
-	s3d_rotate(legbl,0,0,180-pos);
-
-	s3d_rotate(tail,0,30,110+pos);
-	s3d_rotate(rot_point,0,-a,0);
-	nanosleep(&amp;t,NULL); 
-}
-int main(int argc, char **argv)
-{
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;running cat&quot;))
-	{
-			
-		rot_point=s3d_new_object();
-		body=s3d_import_3ds_file(&quot;objs/katze_body.3ds&quot;);
-		legfr=s3d_import_3ds_file(&quot;objs/katze_leg.3ds&quot;);
-		tail=s3d_import_3ds_file(&quot;objs/katze_tail.3ds&quot;);
-		legfl=s3d_clone(legfr);
-		legbl=s3d_clone(legfr);
-		legbr=s3d_clone(legfr);
-		s3d_translate(legfl,2.3,1.0,0.5);
-		s3d_translate(legfr,0,1.0,0.2);
-		s3d_translate(legbl,-1.2,1.0,-1.8);
-		s3d_translate(legbr,-1.2,1.0,0.0);
-		s3d_translate(tail,-1.6,1.6,-0.8);
-		s3d_translate(body,1.3,0.0,-1.3);
-		s3d_link(legfr,body);
-		s3d_link(legfl,body);
-		s3d_link(legbr,body);
-		s3d_link(legbl,body);
-		s3d_link(tail,body);
-		s3d_link(body,rot_point);
-/*		s3d_link(oid_foot,oid_head);
- *		s3d_link(oid_middle,oid_head);
- *		s3d_translate(oid_head,0,4,0);
-		
- *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
- *		s3d_translate(oid_foot,0,-3.5,0); */
-		
-
-		s3d_flags_on(body,S3D_OF_VISIBLE);
-		s3d_flags_on(legfr,S3D_OF_VISIBLE);
-		s3d_flags_on(legfl,S3D_OF_VISIBLE);
-		s3d_flags_on(legbr,S3D_OF_VISIBLE);
-		s3d_flags_on(legbl,S3D_OF_VISIBLE);
-		s3d_flags_on(tail,S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/example/linetest.c
===================================================================
--- trunk/example/linetest.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/linetest.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,95 +0,0 @@
-/*
- * linetest.c
- * 
- * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include &lt;s3d.h&gt;
-#include &lt;stdio.h&gt;  /*  NULL*/
-#include &lt;unistd.h&gt; /* sleep() */
-int i;
-int o;
-void stop(struct s3d_evt *evt)
-{
-	s3d_quit();
-}
-
-void mainloop()
-{
-	i=(i+1)%2;
-	if (i)
-	{
-		s3d_pep_vertex(o,1,-2,0);
-		s3d_pep_line(o,0,2,3);
-	}
-	else
-	{
-		s3d_pep_vertex(o,1,-1,0);
-		s3d_pep_line(o,0,1,0);
-
-	}
-/* 	printf(&quot;now it's %s\n&quot;,time_str); */
-	sleep(1);
-
-}
-int main (int argc, char **argv)
-{
-	i=0;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;linetest&quot;))	
-	{
-		o=s3d_new_object();
-		
-		s3d_push_material(o,
-						1,0,0,
-						1,0,0,
-						1,0,0);
-		s3d_push_material(o,
-						0,1,0,
-						0,1,0,
-						0,1,0);
-		s3d_push_material(o,
-						0,1,0,
-						0,1,0,
-						0,1,0);
-		s3d_push_material(o,
-						1,1,0,
-						1,1,0,
-						1,1,0);
-		s3d_push_vertex(o,-1,-1,0);
-		s3d_push_vertex(o,-1,1,0);
-		s3d_push_vertex(o,1,1,0);
-		s3d_push_vertex(o,1,-1,0);
-		s3d_push_line(o,2,3,1);
-		s3d_push_line(o,0,1,0);
-
-		s3d_flags_on(o,S3D_OF_VISIBLE);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
-		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
-		s3d_quit();
-	}
-	return(0);
-}
-
-
-

Copied: trunk/example/modelloader.c (from rev 229, trunk/example/3dsloader.c)
===================================================================

Modified: trunk/example/nichtsnutz.c
===================================================================
--- trunk/example/nichtsnutz.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/nichtsnutz.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,167 +0,0 @@
-/*
- * nichtsnutz.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-
-#include &lt;s3d.h&gt;
-#include &lt;s3d_keysym.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;math.h&gt;
-#include &lt;time.h&gt;	
-
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-
-int object,foll;
-float al, r, rc ,alpha=0.0, Asp, Bottom, Left, angle;
-float CamPosition[2][3],
-	  TmpMove[3],
-	  Tmp[3],
-	  TmpCam[2][3],
-	  RotCam[2][3],
-	  CatPos[3];
-
-float length;
-
-void mainloop()
-{
-	
-	al=(alpha*M_PI/180);
-    r = 5.0;
-	rc = 12.0;
-	
-	CatPos[0] = sin(al)*r;
-	CatPos[1] = 0;
-	CatPos[2] = cos(al)*r;
-	/*
-	RotCam[0][0] = sin(al) * rc;
-	RotCam[0][1] = 0.0;
-	RotCam[0][2] = cos(al) * rc;
-	*/
-	s3d_translate(object,CatPos[0] ,CatPos[1], CatPos[2]);
-	s3d_rotate(object, 0, alpha, 0);
-	alpha = alpha+0.1;
-	if (alpha&gt;360.0) alpha=0.0;
-	
-	length = s3d_vector_length(CatPos);
-
-
-	RotCam[0][0] = ( CatPos[0] * 12.0 ) / length;
-	RotCam[0][1] = ( CatPos[1] * 12.0 ) / length;
-	RotCam[0][2] = ( CatPos[2] * 12.0 ) / length;
-	
-	
-	if( foll )
-	{
-		
-		CamPosition[0][0] = ((CamPosition[0][0]*4 + RotCam[0][0])/5);
-		CamPosition[0][1] = ((CamPosition[0][1]*4 + RotCam[0][1])/5);
-		CamPosition[0][2] = ((CamPosition[0][2]*4 + RotCam[0][2])/5);
-		s3d_translate(0,CamPosition[0][0],CamPosition[0][1],CamPosition[0][2]);
-
-		TmpMove[0] = 0.0;
-		TmpMove[1] = 0.0;
-		TmpMove[2] = -1.0;
-
-		Tmp[0] = CamPosition[0][0] - CatPos[0];
-		Tmp[1] = 0.0;
-		Tmp[2] = CamPosition[0][2] - CatPos[2];
-		
-		angle = s3d_vector_angle(Tmp,TmpMove);
-		angle = (CatPos[0] &gt; 0)?(180-(180 / M_PI * angle)):(180+(180 / M_PI * angle));
-		printf(&quot;%f %f\n&quot;,angle,al);
-	
-		CamPosition[1][1] = (CamPosition[1][1]*4 + angle)/5;
-		s3d_rotate(0,CamPosition[1][0], CamPosition[1][1], CamPosition[1][2]);
-	}
-	
-
-	
-	nanosleep(&amp;t,NULL); 
-}
-
-void object_info(struct s3d_evt *hrmz)
-{
-	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
-	
-	if (inf-&gt;object==0)
-	{
-		CamPosition[0][0] = inf-&gt;trans_x;
-		CamPosition[0][1] = inf-&gt;trans_y;
-		CamPosition[0][2] = inf-&gt;trans_z;
-		CamPosition[1][0] = inf-&gt;rot_x;
-		CamPosition[1][1] = inf-&gt;rot_y;
-		CamPosition[1][2] = inf-&gt;rot_z;
-
-		Asp=inf-&gt;scale;
-		if (Asp&gt;1.0) /* wide screen */
-		{
-			Bottom=-1.0;
-			Left=-Asp;
-		} else {  /* high screen */
-			Bottom=(-1.0/Asp);
-			Left=-1.0;
-		}
-	}
-}
-
-
-
-void keypress(struct s3d_evt *event)
-{
-	int key;
-	key=*((unsigned short *)event-&gt;buf);
-	switch(key)
-	{
-		case 'f':
-				foll = foll ? 0 : 1;
-				if( foll )
-				{
-					TmpCam[0][0] = CamPosition[0][0];
-					TmpCam[0][1] = CamPosition[0][1];
-					TmpCam[0][2] = CamPosition[0][2];
-					TmpCam[1][0] = CamPosition[1][0];
-					TmpCam[1][1] = CamPosition[1][1];
-					TmpCam[1][2] = CamPosition[1][2];
-				}
-				break;
-	}
-}
-
-
-int main(int argc, char **argv)
-{
-	
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;running cat&quot;))
-	{
-		s3d_set_callback(S3D_EVENT_KEY,keypress);
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-		
-		object = s3d_import_3ds_file(&quot;objs/katze_body.3ds&quot;);
-		s3d_flags_on(object, S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/example/ptrtest.c
===================================================================
--- trunk/example/ptrtest.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/ptrtest.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,114 +0,0 @@
-/*
- * ptrtest.c
- * 
- * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include &lt;s3d.h&gt;
-#include &lt;stdio.h&gt;  /*  NULL*/
-#include &lt;time.h&gt;	/* nanosleep() */
-#include &lt;math.h&gt;	/* sin(), cos() */
-int i;
-int o;
-float bottom=-1.0;
-float left=-1.0;
-float asp=1.0;
-float len=1.0;
-int alpha=0;
-static struct timespec t={0,10*1000*1000}; /* 100 mili seconds */
-void stop(struct s3d_evt *evt)
-{
-	s3d_quit();
-}
-
-void mainloop()
-{
-	float a;
-	alpha=(alpha+1)%360;
-	s3d_rotate(o,alpha,0,0);
-	a=(((float)alpha)*M_PI/180);
-	s3d_translate(0,sin(a)*30,0,30+cos(a)*30);
-	s3d_rotate(0,sin(a)*30,alpha,0);
-	nanosleep(&amp;t,NULL); 
-}
-void object_info(struct s3d_evt *hrmz)
-{
-	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz-&gt;buf;
-	if (inf-&gt;object==0)
-	{
-		if (asp!=inf-&gt;scale)
-		{
-			asp=inf-&gt;scale;
-			printf(&quot;screen aspect: %f\n&quot;,asp);
-			if (asp&gt;1.0) /* wide screen */
-			{
-				bottom=-1.0;
-				left=-asp;
-			} else {  /* high screen */
-				bottom=(-1.0/asp);
-				left=-1.0;
-			}
-		}
-	}
-	if (inf-&gt;object==1)
-	{ /* of course, a link s3d_link(o,1 would be much easier ... */
-		s3d_translate(o,(inf-&gt;trans_x)*2.0,(inf-&gt;trans_y)*2.0,-2);
-	}
-}
-void mbutton_press(struct s3d_evt *hrmz)
-{
-	struct s3d_but_info *inf;
-	char s[256];
-	inf=(struct s3d_but_info *)hrmz-&gt;buf;
-	snprintf(s,256,&quot;please, watch your stomach! button %d, state %d&quot;, inf-&gt;button,inf-&gt;state);
-	printf(&quot;button %d, state %d\n&quot;, inf-&gt;button,inf-&gt;state);
-	s3d_del_object(o);
-	o=s3d_draw_string(s,&amp;len);
-	s3d_translate(o,0,0,-2);
-	s3d_scale(o,0.2);
-	s3d_link(o,0);			/* link to cam */
-/*	s3d_link(o,1);*/
-	s3d_flags_on(o,S3D_OF_VISIBLE);
-}
-int main (int argc, char **argv)
-{
-	i=0;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;ptr and cam test&quot;))	
-	{
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-		s3d_set_callback(S3D_EVENT_MBUTTON,mbutton_press);
-		s3d_set_callback(S3D_EVENT_QUIT,stop);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,stop);
-		s3d_select_font(&quot;vera&quot;);
-		o=s3d_draw_string(&quot;hello&quot;,&amp;len);
-		s3d_translate(o,0,0,-2);
-		s3d_link(o,0);			/* link to cam */
-/*		s3d_link(o,1);*/
-		s3d_scale(o,0.2);
-		s3d_flags_on(o,S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
-		s3d_quit();
-	}
-	return(0);
-}
-

Modified: trunk/example/radius_test.c
===================================================================
--- trunk/example/radius_test.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/radius_test.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,75 +0,0 @@
-/*
- * radius_test.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include &lt;s3d.h&gt;
-#include &lt;stdio.h&gt;  /*  NULL */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-
-#include &lt;math.h&gt;	/* sin(), cos() */
-int item1, item2, item3;
-int i=0;
-void mainloop()
-{
-	float f,g,h;
-	f=sin((M_PI*(i%360))/180.0);
-	g=cos((M_PI*(i%360))/180.0);
-	h=sin((M_PI*((3*i)%360))/180.0);
-	
-	s3d_translate(item1,f*10,h*2, g*5);
-	s3d_rotate(item1,0,i%360,0);
-/*	s3d_scale(item1,h+3,h+3,h+3);*/
-
-/*	s3d_translate(item2,f*10,0, g*5);*/
-	s3d_translate(item2,0,0,10);
-/*	s3d_rotate(item2,i%360,0,-i%360);
-	s3d_scale(item2,2*f+5,2*f+5,2*f+5);*/
-
-	s3d_translate(item3,0,0,10);
-/*	s3d_rotate(item3,((8*i)%360),0,-((8*i)%360));
-	s3d_scale(item3,2*f+5,2*f+5,2*f+5);*/
-
-	
-
-	i++;
-	nanosleep(&amp;t,NULL); 
-}
-int main (int argc, char **argv)
-{
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;radius test&quot;))	
-	{
-		item1=s3d_import_3ds_file(&quot;objs/cubeyholes.3ds&quot;);
-		item2=s3d_import_3ds_file(&quot;objs/folder.3ds&quot;);
-		s3d_select_font(&quot;vera&quot;);
-		item3=s3d_draw_string(&quot;radius test&quot;,NULL);
-		s3d_link(item2,item1);
-		s3d_link(item3,item2);
-	    s3d_flags_on(item1,S3D_OF_VISIBLE);
-	    s3d_flags_on(item2,S3D_OF_VISIBLE);
-	    s3d_flags_on(item3,S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-			 /*  wait for some object to be clicked */
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/example/s3dclock.c
===================================================================
--- trunk/example/s3dclock.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/s3dclock.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,87 +0,0 @@
-/*
- * s3dclock.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include &lt;s3d.h&gt;
-#include &lt;stdio.h&gt;  /*  NULL, sprintf() */
-#include &lt;time.h&gt;	 /*  nanosleep(), struct tm, time_t...  */
-#include &lt;string.h&gt;  /*  strlen() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
-int big_p,lil_p,bg,sec_p;
-int str_oid=-1, o_str_oid;
-struct tm *mytime;
-time_t now,onow;
-char time_str[256];
-
-void stop(struct s3d_evt *evt)
-{
-	s3d_quit();
-}
-
-void mainloop()
-{
-	onow=now;
-	now=time(NULL);
-	if (now!=onow)
-	{
-		o_str_oid=str_oid;
-		mytime=localtime(&amp;now);	
-		s3d_rotate(lil_p,0,0,-((mytime-&gt;tm_hour%12)/12.0)*360.0);
-		s3d_rotate(big_p,0,0,-(mytime-&gt;tm_min/60.0)*360.0);
-		s3d_rotate(sec_p,0,0,-(mytime-&gt;tm_sec/60.0)*360.0);
-		sprintf(time_str,&quot;%02d:%02d:%02d&quot;,mytime-&gt;tm_hour,mytime-&gt;tm_min,mytime-&gt;tm_sec);
-		str_oid=s3d_draw_string(time_str,NULL);
-		s3d_translate(str_oid,-1,-1.3,0);
-		s3d_scale(str_oid,0.5);
-		s3d_flags_on(str_oid,S3D_OF_VISIBLE);
-		if (str_oid!=-1)
-			s3d_del_object(o_str_oid);
-	}
-/* 	printf(&quot;now it's %s\n&quot;,time_str); */
-	nanosleep(&amp;t,NULL); 
-
-}
-int main (int argc, char **argv)
-{
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;clock&quot;))	
-	{
-		lil_p=s3d_import_3ds_file(&quot;objs/lil_p.3ds&quot;);
-		big_p=s3d_import_3ds_file(&quot;objs/big_p.3ds&quot;);
-		sec_p=s3d_import_3ds_file(&quot;objs/sec_p.3ds&quot;);
-		bg=s3d_import_3ds_file(&quot;objs/clock_bg.3ds&quot;);
-
-		s3d_flags_on(big_p,S3D_OF_VISIBLE);
-		s3d_flags_on(lil_p,S3D_OF_VISIBLE);
-		s3d_flags_on(sec_p,S3D_OF_VISIBLE);
-		s3d_flags_on(bg,S3D_OF_VISIBLE);
-		s3d_select_font(&quot;vera&quot;);
-
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
-		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
-		s3d_quit();
-	}
-	return(0);
-}
-

Modified: trunk/example/snowman.c
===================================================================
--- trunk/example/snowman.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/snowman.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,74 +0,0 @@
-/*
- * snowman.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include &lt;s3d.h&gt;
-#include &lt;math.h&gt;	/* sin() */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-
-int a;
-int oid_head;
-int oid_middle;
-int oid_foot;
-
-void mainloop()
-{
-	float pos;
-	a=(a+3)%360;
-	pos=sin((a*M_PI)/180)*5;
-	if (pos&lt;0) pos*=-1;
-	s3d_rotate(oid_head,0,a,0);
-	s3d_rotate(oid_middle,0,a,0);
-	s3d_rotate(oid_foot,0,a,0);
-	s3d_translate(oid_head,		0,1.5 +2.00*pos,0);
-	s3d_translate(oid_middle,	0,0   +1.25*pos,0);
-	s3d_translate(oid_foot,		0,-2  +1.00*pos,0);
-	nanosleep(&amp;t,NULL); 
-}
-int main(int argc, char **argv)
-{
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;snowman&quot;))
-	{
-			
-		oid_head=s3d_import_3ds_file(&quot;objs/snow_head.3ds&quot;);
-		oid_middle=s3d_import_3ds_file(&quot;objs/snow_body.3ds&quot;);
-		oid_foot=s3d_import_3ds_file(&quot;objs/snow_foot.3ds&quot;);
-
-/*		s3d_link(oid_foot,oid_head);
- *		s3d_link(oid_middle,oid_head);
- *		s3d_translate(oid_head,0,4,0);
-		
- *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
- *		s3d_translate(oid_foot,0,-3.5,0); */
-		
-		s3d_scale(oid_middle,1.25);
-		s3d_scale(oid_foot,1.5);
-
-		s3d_flags_on(oid_head,S3D_OF_VISIBLE);
-		s3d_flags_on(oid_middle,S3D_OF_VISIBLE);
-		s3d_flags_on(oid_foot,S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/example/strtest.c
===================================================================
--- trunk/example/strtest.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/strtest.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,64 +0,0 @@
-/*
- * strtest.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include &lt;s3d.h&gt;
-#include &lt;stdio.h&gt;  /*  NULL*/
-#include &lt;unistd.h&gt; /* sleep() */
-int o;
-void stop(struct s3d_evt *evt)
-{
-	s3d_quit();
-}
-
-void mainloop()
-{
-/* 	printf(&quot;now it's %s\n&quot;,time_str); */
-	sleep(1);
-
-}
-int main (int argc, char **argv)
-{
-	char c[256];
-	int i;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;strtest&quot;))	
-	{
-		s3d_select_font(&quot;vera&quot;);
-/*		o=s3d_draw_string(&quot;The lazy fox is bored enough to jump over everything it sees. weird, isn't it?!&quot;,NULL);  */
-		for (i=0;i&lt;256;i++)
-			c[255-i]=i;
-		o=s3d_draw_string(c,NULL);
-/*		o=s3d_draw_string(&quot;A&quot;,NULL);*/
-		s3d_flags_on(o,S3D_OF_VISIBLE);
-
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
-		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
-		s3d_quit();
-	}
-	return(0);
-}
-
-

Modified: trunk/example/texturetest.c
===================================================================
--- trunk/example/texturetest.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/texturetest.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,86 +0,0 @@
-/*
- * texturetest.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include &lt;s3d.h&gt;
-#include &lt;stdio.h&gt;  /*  NULL */
-#include &lt;stdlib.h&gt;  /* malloc(),free() */
-#include &lt;time.h&gt;	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-
-int i,oid;
-void mainloop()
-{
-	i=(i+1)%360;
-	s3d_rotate(oid,0,i,0);
-	nanosleep(&amp;t,NULL); 
-}
-#define MAXX	300
-#define MAXY	300
-int main (int argc, char **argv)
-{
-	unsigned int x,y;
-	unsigned char *data;
-						
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;texturetest&quot;))	
-	{
-		data=malloc(MAXX*MAXY*4);
-		oid=s3d_new_object();
-		s3d_push_vertex(oid,-1,-1,0);
-		s3d_push_vertex(oid, 1,-1,0);
-		s3d_push_vertex(oid, 1, 1,0);
-		s3d_push_vertex(oid,-1, 1,0);
-		s3d_push_material_a(oid,
-						0.8,	0.0,	0.0	,1.0,
-						1.0,	1.0,	1.0	,1.0,
-						0.8,	0.0,	0.0	,1.0);
-		s3d_push_polygon(oid,0,1,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
-									   1.0,0.0,
-									   1.0,1.0);
-		s3d_push_polygon(oid,0,2,3,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
-									   1.0,1.0,
-									   0.0,1.0);
-		s3d_translate(oid,0,0,5);
-		for (y=0;y&lt;MAXY;y++)
-			for (x=0;x&lt;MAXX;x++)
-			{
-				data[(y*MAXX+x)*4+0]=(char)((x*255)/MAXX);
-				data[(y*MAXX+x)*4+1]=((x*y)/(MAXX*MAXY));
-				data[(y*MAXX+x)*4+2]=((y*255)/MAXX);
-				data[(y*MAXX+x)*4+3]=255;
-			}
-		s3d_push_texture(oid,MAXX,MAXY);		
-		s3d_load_texture(oid,0,0,0,MAXX,MAXY,data);
-					 /*  push data on texture 0 position (0,0) */
-		free(data);
-		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
-		s3d_flags_on(oid,S3D_OF_VISIBLE);
-		i=0;
-		s3d_mainloop(mainloop);
-			 /*  wait for some object to be clicked */
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/example/widgets.c
===================================================================
--- trunk/example/widgets.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/widgets.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,174 +0,0 @@
-/*
- * widgets.c
- * 
- * Copyright (C) 2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
- *
- * This file is part of s3d, a 3d network display server.
- * See <A HREF="http://s3d.berlios.de/">http://s3d.berlios.de/</A> for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-
-#include &lt;s3d.h&gt;
-#include &lt;s3dw.h&gt;
-#include &lt;stdio.h&gt;  /* NULL */
-#include &lt;time.h&gt;	/* nanosleep() */
-#include &lt;stdlib.h&gt;	/* free() */
-#include &lt;string.h&gt; /* strlen() */
-
-s3dw_surface *surface;
-s3dw_input *input;
-static struct timespec t={0,33*1000*1000}; /* 33 mili seconds */
-void mainloop()
-{
-	/* keep this in your mainloop. this will do smooth animations for you ... */
-	s3dw_ani_mate();
-	nanosleep(&amp;t,NULL); 
-}
-/* you should always put the s3dw-handler in your own event handler,
- * if you want s3dw to react on clicks or keys ... and i'm sure you
- * want that ... */
-void click(struct s3d_evt *evt)
-{
-	s3dw_handle_click(evt);
-}
-void key_button(s3dw_widget *button)
-{
-	s3dw_delete(button-&gt;parent); /* parent =surface. this means close containing window */
-}
-void key(struct s3d_evt *evt)
-{
-	struct s3d_key_event *key=(struct s3d_key_event *)evt-&gt;buf;
-	char string[8];
-	s3dw_surface *miniwin;
-	s3dw_button  *button;
-	
-	s3dw_handle_key(evt);
-	/* okay, that's a little bit insane ... ;) 
-	 * we create some little windows with the actual key pressed. */
-
-	if (key-&gt;unicode!=0)
-	{
-		miniwin=s3dw_surface_new(&quot;Key&quot;,6,6);
-		sprintf(string,&quot;%c&quot;,key-&gt;unicode);
-		s3dw_label_new(miniwin,string,1,2);
-		button=s3dw_button_new(miniwin,&quot;OK&quot;,2,4);
-		/* clicking on the button will exit ... */
-		button-&gt;onclick=key_button;
-		/* of couse, show it */
-		s3dw_show(S3DWIDGET(miniwin));
-	}
-
-}
-
-void done_button(s3dw_widget *dummy)
-{
-	s3d_quit();
-}
-
-void okay_button(s3dw_widget *dummy)
-{
-	s3dw_button *button;
-	char string[32];
-	char *age;
-
-	/* get the input of the text ... before its destroyed, of course*/
-	age=s3dw_input_gettext(input);
-
-	/* delete the old surface with it subwidgets */
-	s3dw_delete(S3DWIDGET(surface));
-	
-	/* and create a new one ... */
-	surface=s3dw_surface_new(&quot;Ah!&quot;,10,7);
-	
-	/* just cutting the string if it's too long */
-	if (strlen(age)&gt;8) age[8]=0;
-	
-	/* assemble the string ..*/
-	sprintf(string,&quot;I see, %s!!&quot;,age);
-
-	s3dw_label_new(surface,string,1,2);
-	button=s3dw_button_new(surface,&quot;Great&quot;,4,4);
-	/* clicking on the button will exit ... */
-	button-&gt;onclick=done_button;
-	
-	/* of couse, show it */
-	s3dw_show(S3DWIDGET(surface));
-
-	/* we don't need it anymore. always free strings, don't leak around */
-	free(age); 
-}
-void no_button(s3dw_widget *dummy)
-{
-	s3dw_button *button;
-	s3dw_delete(S3DWIDGET(surface));
-	surface=s3dw_surface_new(&quot;Well ...&quot;,10,7);
-	s3dw_label_new(surface,&quot;If you don't want to tell me ...&quot;,1,2);
-	button=s3dw_button_new(surface,&quot;Bye&quot;,4,4);
-	/* clicking on the button will exit ... */
-	
-	button-&gt;onclick=done_button;
-	/* of couse, show it */
-	
-	s3dw_show(S3DWIDGET(surface));
-}
-
-int main (int argc, char **argv)
-{
-	s3dw_button *button;
-	if (!s3d_init(&amp;argc,&amp;argv,&quot;widgettest&quot;))
-	{
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,click);
-		s3d_set_callback(S3D_EVENT_KEY,key);
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,s3dw_object_info);
-		/* this creates the &quot;window&quot; */
-		surface=s3dw_surface_new(&quot;Hello World&quot;,20,10);
-		
-		/* put a label (which is simply text) at position x=1, y=2 */
-		s3dw_label_new(surface,&quot;How old are you?&quot;,1,2);
-
-		/* put an input box right below. we grab the pointer because we want to focus it (need for reference) */
-		input=s3dw_input_new(surface,8,1,4);
-		
-		/* we want the input-field be focused on our widget */
-		s3dw_focus(S3DWIDGET(input));
-
-		/* create the okay button */
-		button=s3dw_button_new(surface,&quot;OK&quot;,1,7);
-
-		/* define the callback when the button is clicked. in our case, okay_button() will handle the event */
-		button-&gt;onclick=okay_button;
-
-		/* another button  */
-		button=s3dw_button_new(surface,&quot;Won't tell you&quot;,10,7);
-
-		/* we will tell him how sad we are ... */
-		button-&gt;onclick=no_button;
-
-		/* this widget is focused (of course, it's our only one ... */
-		s3dw_focus(S3DWIDGET(surface));
-
-		/* show it. without showing, things would be boring... */
-		s3dw_show(S3DWIDGET(surface));
-
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}
-

Modified: trunk/libs3d/3dsread.c
===================================================================
--- trunk/libs3d/3dsread.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/libs3d/3dsread.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,5 +1,5 @@
 /*
- * 3dsread.c
+ * modelread.c
  *
  * Copyright (C) 2004-2006 Simon Wunderlich &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
  *
@@ -24,17 +24,31 @@
 
 #include &quot;s3d.h&quot;
 #include &quot;s3dlib.h&quot;
+#include &lt;g3d/g3d.h&gt;
 #include &lt;stdlib.h&gt; 	 /*  exit(), malloc() */
 #include &lt;math.h&gt;		 /*  sqrt() */
 #include &lt;string.h&gt; 	 /*  strncpy() */
 #include &lt;errno.h&gt; 		 /*  errno */
+
+
+struct material2texture {
+	struct material2texture *next_ptr;   /* pointer to next */
+	void *material_ptr;
+	void *texture_ptr;
+	int material_id;
+	int texture_id;
+};
+struct material2texture *mat2tex_root = NULL;
+
 #define MAXSTRN		20
+static int model_load(char *file);
 /*  just a helper function for reading from file instead of memory. */
-int s3d_import_3ds_file(char *fname)
+int s3d_import_model_file(char *fname)
 {
 	char *buf,*ptr,*next;
 	char searchpath[1024];
 	char path[1024];
+	int oid;
 #ifndef OBJSDIR
 #define OBJSDIR 	&quot;./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/&quot;
 #endif
@@ -56,494 +70,177 @@
 			strcpy(path,ptr); 					/* can use &quot;unsafe&quot; functions because size was verified above */
 			strcat(path,fname);
 			if (s3d_open_file(path,&amp;buf)!=-1)  /* found something */
-				return(s3d_import_3ds(buf));
+			{
+				free(buf); /* TODO: badbadbad ... */
+				if (-1!=(oid=model_load(path))) return(oid);
+
+			}
 		}
 		if (next!=NULL)
 			ptr=next;							/* move pointer to the next position */
 	}
-	errds(LOW,&quot;s3d_import_3ds_file()&quot;,&quot;Could not open %s&quot;, fname);
+	errds(LOW,&quot;s3d_import_model_file()&quot;,&quot;Could not open %s&quot;, fname);
 	return(-1); /* nothing in search path ... */
 }
-static void normal(float *p0, float *p1, float *p2, float *r)
-{
-	float a[3],b[3],n[3];
-	float len;
-	a[0]=p1[0]-p0[0];
-	a[1]=p1[1]-p0[1];
-	a[2]=p1[2]-p0[2];
-	b[0]=p2[0]-p0[0];
-	b[1]=p2[1]-p0[1];
-	b[2]=p2[2]-p0[2];
-	n[0]=a[1]*b[2] - a[2]*b[1];
-	n[1]=a[2]*b[0] - a[0]*b[2];
-	n[2]=a[0]*b[1] - a[1]*b[0];
 
-	len=sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);
-	if (len!=0.0F)
-	{
-		r[0]=n[0]/len;
-		r[1]=n[1]/len;
-		r[2]=n[2]/len;
-	} else {
-		s3dprintf(VLOW,&quot;normal(): couldn't calc normal&quot;);
-		r[0]=r[1]=r[2]=0.0F;
+void *get_mat2tex( struct material2texture **mat2tex, void *mat_ptr ) {
+
+	while ( (*mat2tex) != NULL ) {
+
+		if ( (*mat2tex)-&gt;material_ptr == mat_ptr ) return (*mat2tex);
+
+		mat2tex = &amp;(*mat2tex)-&gt;next_ptr;
+
 	}
-}
-void sort_poly(unsigned long *smooth_list, unsigned long *poly_buf,int polynum)
-{
-	unsigned long min,minv,i;
-	unsigned long polyel[4];
-	minv=-1;
-	min=0;
-	for (i=0;i&lt;polynum;i++)
-	{
-		if (smooth_list[i]&lt;minv)
-		{
-			min=i;
-			minv=smooth_list[i];
-		}
-	}
-	if (min!=0)  /*  swap */
-	{
-#define EL	4*sizeof(unsigned long)
-		memcpy(polyel,poly_buf,EL);  /* save */
-		memcpy(poly_buf,poly_buf+4*min,EL);  /* put at first place */
-		memcpy(poly_buf+4*min,polyel,EL);
-		 /*  now the same with smooth_list */
-		i=smooth_list[0];
-		smooth_list[0]=smooth_list[min];
-		smooth_list[min]=i;
-#undef EL
-	}
-	if (polynum&gt;1)
-	{
-		sort_poly(smooth_list+1,poly_buf+4,polynum-1);
-	}
 
-}
-struct t_vertex_normal
-{
-	float n[3];
-	unsigned long g,num;
-};
-/*  this functions takes a shitload of arguments, but that's because of optimization.  */
-/*  we add normals of the polygons's vertices so each vertex will finally have */
-/*  the sum of the polygons normals where the vertex is part of. */
-static int smooth(float *vbuf,int voff, unsigned long *pbuf, float *pnbuf, float *nbuf, struct t_vertex_normal *v_t_buf, int pnum, int g)
-{
-	int i,j,n;
-	unsigned long k;
-	float len;
-	 /*  run1: add normals on themselves into the v_t_buf */
-	for (i=0;i&lt;pnum;i++)
-	{
-		for (j=0;j&lt;3;j++)
-		{
-			k=pbuf[i*4+j]-voff;
-			if (v_t_buf[k].g!=g)  /*  not added in this group yet */
-			{
-				for (n=0;n&lt;3;n++)
-					v_t_buf[k].n[n]=(pnbuf+i*3)[n];
-				v_t_buf[k].num=1;
-				v_t_buf[k].g=g;  /*  now it's  in our group. */
-			} else {
-				for (n=0;n&lt;3;n++)
-					v_t_buf[k].n[n]+=(pnbuf+i*3)[n];
-				v_t_buf[k].num++;
-			}
+	if ( (*mat2tex) == NULL ) {
+
+		(*mat2tex) = malloc( sizeof( struct material2texture ) );
+
+		if ( (*mat2tex) == NULL ) {
+			errs( &quot;model_import()&quot;, &quot;Sorry - you ran out of memory !\n&quot; );
+			exit(8);
 		}
+
+		(*mat2tex)-&gt;next_ptr = NULL;
+		(*mat2tex)-&gt;material_ptr = mat_ptr;
+		(*mat2tex)-&gt;texture_ptr = NULL;
+		(*mat2tex)-&gt;material_id = -1;
+		(*mat2tex)-&gt;texture_id = -1;
+
+		return (*mat2tex);
+
 	}
-	 /*  run2: apply to the final vertex buffer */
-	for (i=0;i&lt;pnum;i++)
-	{
-		for (j=0;j&lt;3;j++)
-		{
-			k=pbuf[i*4+j]-voff;
-			if (v_t_buf[k].num&gt;1)  /*  if more than 1, normalize. */
-			{
-				len=sqrt(v_t_buf[k].n[0]*v_t_buf[k].n[0]+v_t_buf[k].n[1]*v_t_buf[k].n[1]+v_t_buf[k].n[2]*v_t_buf[k].n[2]);
-				if (len==0.0F)   /*  this should not happen. well ... */
-				{
-					for (n=0;n&lt;3;n++)
-						v_t_buf[k].n[n]=0;
-					v_t_buf[k].g=-1;  /*  we're telling this by setting group to -1 */
-				}
-				else
-					for (n=0;n&lt;3;n++)
-						v_t_buf[k].n[n]/=len;
-				v_t_buf[k].num=1;
-			}
-			if (v_t_buf[k].g==g)  /*  just making sure, or for the case of bad normals. */
-				memcpy(nbuf+i*9+j*3,v_t_buf[k].n,sizeof(float)*3);  /*  finally, we save the normal in our normal buffer */
-			else  /*  use the pbuf normal */
-			{
-				memcpy(nbuf+i*9+j*3,pnbuf+i*3,sizeof(float)*3);
-			}
-		}
-	}
+
 	return(0);
+
 }
-/*  calculates the normals: */
-static float *calc_normals(float *vertex_buf, int vertexnum, unsigned long *poly_buf,
-				int polynum, int voff,unsigned long *smooth_list)
+
+
+
+int model_load(char *file)
 {
-	int i,j,n=0;
-	float *pnormal_list, *nbuf;  /*  pnormal_list has the space for normals per polygon, */
-								 /*  nbuf has 3 normals per polygon for each vertex */
-	struct t_vertex_normal *v_t_buf;
-								 /*  this buffer will save temporary normals for each vector */
-								 /*  along with the information of group (each group might */
-								 /*  have another normal for a certain vertex) and of polygons */
-								 /*  sharing this vertex. */
-	unsigned long v[3];
-	unsigned long lg,g;  /*  last group and group */
-	lg=-1;g=0;
-	pnormal_list=malloc(sizeof(float)*3*polynum);
-	nbuf=malloc(sizeof(float)*3*3*polynum);
-	v_t_buf=malloc(sizeof(struct t_vertex_normal)*vertexnum);
-	memset(v_t_buf,0,sizeof(struct t_vertex_normal)*vertexnum);
-	sort_poly(smooth_list, poly_buf, polynum);
-	for (i=0;i&lt;polynum;i++)
-	{
-		g=smooth_list[i];
-		if (lg!=g)  /*  a different group */
-		{
-			if (n&gt;0)  /*  that should only be false in the first loop */
-			{
-				smooth(vertex_buf,voff,poly_buf+(i-n)*4,pnormal_list+(i-n)*3, nbuf+(i-n)*9,v_t_buf,n,g);
-			}
-			n=0;  /*  no elements so far in the new group */
-		}
-		for (j=0;j&lt;3;j++)
-		{
-			v[j]=poly_buf[i*4+j]-voff;
-			if (v[j]&gt;=vertexnum)  /*  bad input */
-			{
-				errds(VHIGH,&quot;calc_normals()&quot;,&quot;bad input, polygon vertex index out of range&quot;);
-				return(NULL);
-			}
-		}
-		 /* s3dprintf(LOW,&quot;polygon [%d/%d]: %d %d %d is in smoothlist %d&quot;,i,polynum,v[0],v[1],v[2],g); */
+	G3DContext			 	*context;
+	G3DModel				*model;
+	G3DObject 				*object;
+	G3DFace 				*face;
+	GSList 					*oitem, *oface;
+	struct material2texture *mat2tex;
+	int						 i, j, k, material_count, texture_count, voff,obj_id;
+#define 					PMAX	100
+	unsigned long 			 polybuf[PMAX * 4],npoly,oldflags;
+	float					 normalbuf[PMAX * 9],texcoordbuf[PMAX * 6];
+	float 					 swaph;				/* swap helper */
+	unsigned char 			*s3d_pixeldata = NULL;
 
-		normal(	vertex_buf+v[0]*3,
-				vertex_buf+v[1]*3,
-				vertex_buf+v[2]*3,
-				pnormal_list+i*3);
-		lg=g; 	 /*  save the last group */
-		n++;	 /*  save the number of how much elements are in the group now. */
-	}
+	context = g3d_context_new();
+	obj_id=-1;
+	model = g3d_model_load(context, file);
 
+	if ( model ) {
 
+		oitem = model-&gt;objects;
+		obj_id = s3d_new_object();
+		material_count = texture_count = voff = 0;
 
-	 /* s3dprintf(MED,&quot;processing the final group ... %d (%d members)&quot;,g,n); */
-	smooth(vertex_buf,voff,poly_buf+(i-n)*4,pnormal_list+(i-n)*3, nbuf+(i-n)*9,v_t_buf,n,g);
-/*	for (i=0;i&lt;polynum;i++)
-	{
-		for (j=0;j&lt;3;j++)
-			s3dprintf(MED,&quot;poly[%d/%d],point[%d/3]: %f %f %f&quot;,i,polynum,j,
-							nbuf[i*9+j*3],
-							nbuf[i*9+j*3+1],
-							nbuf[i*9+j*3+2]);
-	}*/
-	free(pnormal_list);
-	free(v_t_buf);
-	return(nbuf);
-}
-/* get the intergers in the right order */
-unsigned short gints(char *ptr)
-{
-	register unsigned short i;
-	i= ((unsigned char )ptr[0]);
-	i+=((unsigned char )ptr[1])*0x100;
-	return i;
-}
-unsigned long gintl(char *ptr)
-{
-	register unsigned long i;
-	i= ((unsigned char )ptr[0]);
-	i+=((unsigned char )ptr[1])*0x100;
-	i+=((unsigned char )ptr[2])*0x10000;
-	i+=((unsigned char )ptr[3])*0x1000000;
-	return i;
-}
-/*  imports a 3ds file as ONE object, even it virtually contains more. */
-/*  it returns the object id ... */
-int s3d_import_3ds(char *buf)
-{
-	char *ptr,*ptr2,*mesh_end=NULL;
-	int i,j,polynum=0,vertexnum=0;
-	char ostr[MAXSTRN+1];
-	char materials[256][MAXSTRN+1];
-	int clen,cid;
-	int filesize=1;  /*  just so it hops above the main chunk ... */
-	int vertex_offset=0;
-	int v=0;
-	int col_obj=-1;
-	unsigned long *poly_buf=NULL,*tpbuf,*smooth_list=NULL;
-	unsigned char r1,g1,b1,r2,g2,b2,r3,g3,b3;
-	unsigned char r_amb=255,g_amb=255,b_amb=255,
-				  r_diff=255,g_diff=255,b_diff=255,
-				  r_spec=255,g_spec=255,b_spec=255;
-	unsigned char color=0;
-	unsigned short nfaces;
-	float *vertex_buf=NULL, *nbuf=NULL,*tnbuf;
-	int cur_oid=-1;
-	if (buf==NULL) return(-1);
-	ptr=buf;
-	while (((ptr)&gt;=buf) &amp;&amp; ((ptr)&lt;(buf+filesize)))
-	{
-		cid=gints(ptr);
-		clen=gintl(ptr+2);
+		while ( oitem ) {
 
-		s3dprintf (VLOW,&quot;[pos %x]: \t%04x [len:%d]&quot;,(ptr-buf),cid,(clen-6));
-		if ((ptr==buf) &amp;&amp; (cid!=0x4d4d))
-		{
-			errs(&quot;3d_import_3ds()&quot;,&quot;file doesn't start with 0x4d4d, maybe file corrupt?&quot;);
-			return(-1);
-		}
-		ptr=ptr+6;  /*  point to the data .. */
-		switch (cid)
-		{
-		  case 0x4d4d:
-			  s3dprintf(VLOW,&quot;-- the main chunk!!&quot;);
-			  filesize=clen;
-			  if (cur_oid==-1)
-			  {
-				  cur_oid=s3d_new_object();
-				   /*  standard material for fallback reasons */
-			      s3d_push_material(cur_oid,0.2,0.2,0,0.2,0.2,0,0.2,0.2,0);
-				  col_obj++;
-			  }
+			object = (G3DObject *)oitem-&gt;data;
 
-           	  break;
-		  case 0x3D3D:
-			  s3dprintf(VLOW,&quot;-- the 3d editor chunk!&quot;);
-			  break;
-		  case 0x4000:
-			  s3dprintf(VLOW,&quot;-- an object block. let's see ...&quot;);
-			  strncpy((char *)ostr,(char *)ptr,MAXSTRN);
-			  vertex_offset+=v;
-			  v=0;
-			  ptr=(ptr+strlen(ostr)+1);
-			  break;
-		  case 0x4100:
-			  s3dprintf(VLOW,&quot;-- Triangular mesh&quot;);
-			  smooth_list=NULL;
-			  mesh_end=ptr+(clen-6);
-			  break;
-		  case 0x4110:
-			  vertexnum=gints(ptr);
-			  ptr+=sizeof(unsigned short);
-			  s3dprintf(VLOW,&quot;-- vertices list!! number of vertices: %d&quot;,vertexnum);
-			  vertex_buf=malloc(sizeof(float)*3*vertexnum);
-			  if (vertex_buf==NULL) break;
-/* 			  memcpy(vertex_buf,ptr,sizeof(float)*3*i); */
-			  for (j=0; j&lt;vertexnum; j++)
-		 	  {
-				*(vertex_buf+j*3+0)=*((float *)ptr+0);
-				*(vertex_buf+j*3+1)=*((float *)ptr+2);
-				*(vertex_buf+j*3+2)=-*((float *)ptr+1);
-				ptr+=sizeof(float)*3;
-			  }
-			  v+=vertexnum;  /*  for the correct vertex offset */
-			break;
-		  case 0x4120:
-			polynum=gints(ptr);
-			ptr+=sizeof(unsigned short);
-			s3dprintf(VLOW,&quot;-- polygon list!! number of polygons: %d&quot;,polynum);
-			poly_buf=malloc(sizeof(unsigned long)*4*polynum);
-			if (poly_buf==NULL) break;
-		    for (j=0; j&lt;polynum; j++)
-			{
-				poly_buf[j*4+0]=vertex_offset+gints(ptr+0);
-				poly_buf[j*4+1]=vertex_offset+gints(ptr+4);
-				poly_buf[j*4+2]=vertex_offset+gints(ptr+2);
-				poly_buf[j*4+3]=col_obj;  /*  we should have a default material .... */
-				ptr+=sizeof(unsigned short)*4;
-		    }
-			break;
-		  case 0x4130:
-			ptr2=(char *)ptr+(clen-6);  /*  backup our endpointer ... */
-			s3dprintf(VLOW,&quot;-- material information for faces .....&quot;);
-			strncpy((char *)ostr,(char *)ptr,MAXSTRN);
-			ptr+=strlen(ptr)+1;
-			s3dprintf(VLOW,&quot;.. material string name is %s&quot;,ostr);
-			col_obj=0;
-			while (col_obj&lt;256 &amp;&amp; (strncmp(ostr,materials[col_obj],MAXSTRN)!=0)) col_obj++;
-			if (col_obj&gt;=256)
-			{
-				errds(MED,&quot;s3d_import_3ds()&quot;,&quot;couldn't find material %s&quot;,ostr);
-				col_obj=0;
+			/* push vertices */
+			for ( j = 0; j &lt; object-&gt;vertex_count; j++ ) {
+				/* 2. and 3. coord have to change places otherwise the object will be turned */
+				swaph=							 object-&gt;vertex_data[j * 3 + 2];
+				object-&gt;vertex_data[j * 3 + 2] = object-&gt;vertex_data[j * 3 + 1];
+				object-&gt;vertex_data[j * 3 + 1] = swaph;
 			}
-			nfaces=gints(ptr);
-			ptr+=2;
-			for (i=0;i&lt;nfaces;i++)
-			{
-				j=gints(ptr+2*i);
-				if (j&gt;=0 &amp;&amp; j&lt;polynum)
-					poly_buf[gints(ptr+2*i)*4+3]=col_obj;
-				else {
-					errds(MED,&quot;s3d_import_3ds()&quot;,&quot;polygon %d out of range!&quot;,j);
-				}
-			}
-			ptr=ptr2;
-			break;
-		  case 0x4150:
-			s3dprintf(VLOW,&quot;-- smoothing group information (length %d [%d])&quot;, clen,clen/4);
-			smooth_list=(unsigned long *)ptr;
-			for (j=0;j&lt;(clen/4);j++)
-			{
-				smooth_list[j]=gintl(ptr+j*4);
-				s3dprintf(VLOW, &quot;smooth_list[%i] = %i&quot;, j, smooth_list[j] );
-			}
+			s3d_push_vertices( obj_id, object-&gt;vertex_data, object-&gt;vertex_count);
+					
 
-			ptr=(char *)ptr+(clen-6);
-			break;
-		  case 0x4160:
-			  s3dprintf(VLOW,&quot;-- translation matrix&quot;);
-			  for (j=0; j&lt;4; j++)
-		 	  {
-				s3dprintf(VLOW,&quot;[%f:%f:%f:%f]&quot;,
-								*((float *)ptr),
-								*((float *)ptr+1),
-								*((float *)ptr+2),
-								((j==3)?1.0:0.0)
-								);
-				ptr+=sizeof(float)*3;
-			  }
-			  break;
-		  case 0xafff:
-			  s3dprintf(VLOW,&quot;-- material chunk O_o&quot;);
-			  break;
-		  case 0xa000:
-			  strncpy((char *)ostr,(char *)ptr,MAXSTRN);
-			  s3dprintf(VLOW,&quot;-- material string name is %s&quot;,ostr);
-			  ptr=(char *)ptr+(clen-6);
-			  color|=8;
-			  break;
-		  case 0xa010:
-			  r1=(unsigned char)*(ptr);
-			  g1=(unsigned char)*(ptr+1);
-			  b1=(unsigned char)*(ptr+2);
-			  r2=(unsigned char)*(ptr+3);
-			  g2=(unsigned char)*(ptr+4);
-			  b2=(unsigned char)*(ptr+5);
-			  r3=(unsigned char)*(ptr+6);
-			  g3=(unsigned char)*(ptr+7);
-			  b3=(unsigned char)*(ptr+8);
-			  s3dprintf(VLOW,&quot;-- ambient color 3:&gt;&gt; [rgb] [%x %x %x]&quot;,r3,g3,b3);
-			  r_amb=r3;g_amb=g3;b_amb=b3;
-			  color=color|1;
-			  ptr=(char *)ptr+(clen-6);
-			  break;
-		  case 0xa020:
-			  r1=(unsigned char)*(ptr);
-			  g1=(unsigned char)*(ptr+1);
-			  b1=(unsigned char)*(ptr+2);
-			  r2=(unsigned char)*(ptr+3);
-			  g2=(unsigned char)*(ptr+4);
-			  b2=(unsigned char)*(ptr+5);
-			  r3=(unsigned char)*(ptr+6);
-			  g3=(unsigned char)*(ptr+7);
-			  b3=(unsigned char)*(ptr+8);
-			  s3dprintf(VLOW,&quot;-- diffuse color 3:&gt;&gt; [rgb] [%x %x %x]&quot;,r3,g3,b3);
-			  r_diff=r3;g_diff=g3;b_diff=b3;
-			  color=color|2;
-			  ptr=(char *)ptr+(clen-6);
-			  break;
-		  case 0xa030:
-			  r1=(unsigned char)*(ptr);
-			  g1=(unsigned char)*(ptr+1);
-			  b1=(unsigned char)*(ptr+2);
-			  r2=(unsigned char)*(ptr+3);
-			  g2=(unsigned char)*(ptr+4);
-			  b2=(unsigned char)*(ptr+5);
-			  r3=(unsigned char)*(ptr+6);
-			  g3=(unsigned char)*(ptr+7);
-			  b3=(unsigned char)*(ptr+8);
-			  s3dprintf(VLOW,&quot;-- spec color 3:&gt;&gt; [rgb] [%x %x %x]&quot;,r3,g3,b3);
-			  r_spec=r3;g_spec=g3;b_spec=b3;
-			  color=color|4;
-			  ptr=(char *)ptr+(clen-6);
-			  break;
-		  default:
-			ptr=(char *)ptr+(clen-6);
-		}
-		 /*  color finished? then upload. I know, this is not real implementation ... */
-		if (color==15)
-		{
-			col_obj++;
-			if (col_obj&lt;256)  /*  TODO: we currently don't support  */
-							  /*  more than 256 materials ...  */
-							  /*  that's just because i'm lazy */
-			{
-				strncpy(materials[col_obj],ostr,MAXSTRN);
-				s3dprintf(VLOW,&quot;assigned material %s on position %d&quot;,
-								materials[col_obj],col_obj);
-			}
-			s3dprintf(VLOW,&quot;-- [%d]colors... amb: %d %d %d, spec %d %d %d, diff %d %d %d&quot;,col_obj,
-							r_amb,g_amb,b_amb,
-							r_spec,g_spec,b_spec,
-							r_diff,g_diff,b_diff
-				   );
-			s3d_push_material(cur_oid,
-							r_amb/255.0,g_amb/255.0,b_amb/255.0,
-							r_spec/255.0,g_spec/255.0,b_spec/255.0,
-							r_diff/255.0,g_diff/255.0,b_diff/255.0
-							);
-			color=0;
-		}
-		if ((mesh_end!=NULL) &amp;&amp; (ptr&gt;=mesh_end))
-		{
-			mesh_end=NULL;
-			if ((vertex_buf!=NULL))
-			    s3d_push_vertices(cur_oid, vertex_buf, vertexnum);
-			if (poly_buf!=NULL)
-			{
-				if (smooth_list!=NULL)
-					nbuf=calc_normals(vertex_buf,vertexnum,poly_buf,polynum,vertex_offset,smooth_list);
 
-				 /*  do in 1000 chunks */
-				s3dprintf(LOW,&quot;committing %d polys&quot;,polynum);
-				tnbuf=nbuf;
-				tpbuf=poly_buf;
-#define CSIZE	1000
-				while (polynum&gt;CSIZE)
+			oface = object-&gt;faces;
+			npoly=0;
+			oldflags = ((G3DFace *) (oface-&gt;data))-&gt;flags;
+
+			while ( oface ) {
+
+				face = (G3DFace *)oface-&gt;data;
+				mat2tex = get_mat2tex( &amp;mat2tex_root, face-&gt;material );
+
+				if ( mat2tex-&gt;material_id == -1 ) { /* create a new texture if nothing found */
+					s3d_push_material_a( obj_id, 	face-&gt;material-&gt;r, face-&gt;material-&gt;g, face-&gt;material-&gt;b,face-&gt;material-&gt;a, 
+													face-&gt;material-&gt;specular[0], face-&gt;material-&gt;specular[1], face-&gt;material-&gt;specular[2], face-&gt;material-&gt;specular[3],
+													face-&gt;material-&gt;r, face-&gt;material-&gt;g, face-&gt;material-&gt;b, face-&gt;material-&gt;a );
+
+					mat2tex-&gt;material_id = material_count;
+					material_count++;
+
+					if ( face-&gt;tex_image != NULL ) {
+
+						/* reorder pixeldata - s3d wants rgba */
+						if ( s3d_pixeldata != NULL ) free( s3d_pixeldata );
+
+						s3d_pixeldata = malloc( sizeof( unsigned char ) * face-&gt;tex_image-&gt;width * face-&gt;tex_image-&gt;height * 32 );
+
+						if ( s3d_pixeldata == NULL ) {
+							errs(&quot;model_load()&quot;, &quot;Sorry - you ran out of memory !\n&quot; );
+							exit(8);
+						}
+
+						for ( j = ( face-&gt;tex_image-&gt;height - 1 ); j &gt;= 0; j-- ) {
+							for ( k = 0; k &lt; face-&gt;tex_image-&gt;width; k++ ) {
+								s3d_pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 0 ] = face-&gt;tex_image-&gt;pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 2 ];
+								s3d_pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 1 ] = face-&gt;tex_image-&gt;pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 1 ];
+								s3d_pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 2 ] = face-&gt;tex_image-&gt;pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 0 ];
+								s3d_pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 3 ] = face-&gt;tex_image-&gt;pixeldata[ ( j * face-&gt;tex_image-&gt;width + k ) * 4 + 3 ];
+							}
+						}
+
+						s3d_push_texture( obj_id, face-&gt;tex_image-&gt;width, face-&gt;tex_image-&gt;height );
+						s3d_pep_material_texture( obj_id, texture_count );
+						s3d_load_texture( obj_id, texture_count, 0, 0, face-&gt;tex_image-&gt;width, face-&gt;tex_image-&gt;height, s3d_pixeldata );
+
+						mat2tex-&gt;texture_id = texture_count;
+						texture_count++;
+
+					}
+				}
+				if (face-&gt;flags != oldflags || npoly&gt;=PMAX)
 				{
-					s3d_push_polygons(cur_oid, tpbuf, CSIZE);
-					if (nbuf!=NULL)
-						s3d_pep_polygon_normals(cur_oid,tnbuf, CSIZE);
-					tnbuf+=	CSIZE*9;
-					tpbuf+=	CSIZE*4;
-					polynum-=CSIZE;
+					/* push things so far */
+					s3d_push_polygons(obj_id, polybuf, npoly);
+					if (oldflags &amp; G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
+					if (oldflags &amp; G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);
+					npoly=0;
 				}
-				s3d_push_polygons(cur_oid, tpbuf, polynum);
-				if (nbuf!=NULL)
-					s3d_pep_polygon_normals(cur_oid,tnbuf, polynum);
-			}
+				oldflags=face-&gt;flags;
 
+				/* add polygon to the polygon buffer */
+				for (i=0;i&lt;3;i++)
+					polybuf[npoly*4+i]=face-&gt;vertex_indices[i] + voff;
+				polybuf[npoly*4+3]=mat2tex-&gt;material_id;
 
-			 /*  clean things up */
-			if (vertex_buf!=NULL)
-			{
-				free(vertex_buf);vertex_buf=NULL;
+				if ( face-&gt;flags &amp; G3D_FLAG_FAC_NORMALS ) memcpy( normalbuf + npoly*9,  face-&gt;normals, sizeof(float) * 9);
+				if ( face-&gt;flags &amp; G3D_FLAG_FAC_TEXMAP )  memcpy( texcoordbuf + npoly*6,  face-&gt;tex_vertex_data, sizeof(float) * 6);
+				npoly++;
+				oface = oface-&gt;next;
 			}
-			if (poly_buf!=NULL)
+			/* push the last packets in buffer */
+			if (npoly &gt; 0)
 			{
-				free(poly_buf);poly_buf=NULL;
+				s3d_push_polygons(obj_id, polybuf, npoly);
+				if (oldflags &amp; G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
+				if (oldflags &amp; G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);
+				npoly=0;
 			}
-			if (smooth_list!=NULL)
-			{
-				/*FIXME: free(smooth_list);*/
-				smooth_list=NULL;
-			}
-			if (nbuf!=NULL)
-			{
-				free(nbuf);nbuf=NULL;
-			}
+	
+			voff += object-&gt;vertex_count; /* increase vertex offset */
+			oitem = oitem-&gt;next;
 		}
 	}
-	s3dprintf(VLOW,&quot;-- done [ptr:%010p,buf:%010p]...&quot;,ptr,buf);
-	free(buf);
-	return(cur_oid);
+	g3d_model_free(model);
+	g3d_context_free(context);
+	
+	return(obj_id);
 }
+

Modified: trunk/libs3d/Makefile.am
===================================================================
--- trunk/libs3d/Makefile.am	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/libs3d/Makefile.am	2006-09-16 00:44:17 UTC (rev 391)
@@ -10,7 +10,7 @@
 noinst_HEADERS=		config.h s3dlib.h sei_triangulate.h sei_interface.h
 
 libs3d_la_CPPFLAGS=	-I${top_srcdir}/server
-libs3d_la_CFLAGS=	@FONTCONFIG_CFLAGS@ @FREETYPE_CFLAGS@ 
-libs3d_la_LIBADD=	@FONTCONFIG_LIBS@ @FREETYPE_LIBS@ @LIBM@
+libs3d_la_CFLAGS=	@FONTCONFIG_CFLAGS@ @FREETYPE_CFLAGS@ -I$(top_srcdir)/libs3d/libg3d/include @GLIB_CFLAGS@
+libs3d_la_LIBADD=	@FONTCONFIG_LIBS@ @FREETYPE_LIBS@ @LIBM@ $(top_builddir)/libs3d/libg3d/src/libg3d.la
 
 EXTRA_DIST=		lgpl.txt

Modified: trunk/libs3d/libg3d/plugins/import/Makefile.am
===================================================================
--- trunk/libs3d/libg3d/plugins/import/Makefile.am	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/libs3d/libg3d/plugins/import/Makefile.am	2006-09-16 00:44:17 UTC (rev 391)
@@ -29,8 +29,8 @@
 AM_CFLAGS = \
 	-Wall -ansi -pedantic \
 	-DG_LOG_DOMAIN=\&quot;LibG3D\&quot; \
-	@DBG_CFLAGS@ -DDEBUG=1 \
-	@GLIB_CFLAGS@
+	@DBG_CFLAGS@ \
+	@GLIB_CFLAGS@ #-DDEBUG=1 
 
 INCLUDES = -I$(top_builddir)/libs3d/libg3d/include
 

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -406,7 +406,7 @@
 	GSList *oface;
 	gint32 i, j, k, n=0, polynum, group;
 	guint32 *smooth_list;
-	gfloat *pnormal_list, *v_t_buf;
+	gfloat *pnormal_list, *vertex_normal_buf;			 	
 	gfloat a[3],b[3], *p0,*p1,*p2,*r;
 	gfloat len;
 
@@ -418,13 +418,11 @@
 	polynum=0;
 	for (oface=object-&gt;faces; oface != NULL ; oface=oface-&gt;next) polynum++; /* count polygons */
 
-	pnormal_list=	g_new(float, 3*polynum);							/* polygon normal list */
-	v_t_buf=		g_new0(float,3*object-&gt;vertex_count);				/* normals per vertice */
-	smooth_list = 	g_new(guint32, polynum);
-	printf(&quot;reading %d int32 values\n&quot;,polynum);
+	pnormal_list=		g_new(float, 3*polynum);							/* polygon normal list */
+	vertex_normal_buf=	g_new0(float,3*object-&gt;vertex_count);				/* normals per vertice */
+	smooth_list = 		g_new(guint32, polynum);
 	for ( i=0 ; i&lt;polynum ; i++ ) 
 		smooth_list[i] = g3d_read_int32_le(global-&gt;f);
-
 	parent-&gt;nb -= polynum * 4;
 	/* first, we calculate the normal by the polygon vertices (just vector product) */
 	i=0;
@@ -435,7 +433,7 @@
 		p0=&amp;(object-&gt;vertex_data[3* face-&gt;vertex_indices[0]]);
 		p1=&amp;(object-&gt;vertex_data[3* face-&gt;vertex_indices[1]]);
 		p2=&amp;(object-&gt;vertex_data[3* face-&gt;vertex_indices[2]]);
-
+		
 		a[0]=p1[0] - p0[0];
 		a[1]=p1[1] - p0[1];
 		a[2]=p1[2] - p0[2];
@@ -445,7 +443,7 @@
 		r[0]=a[1]*b[2] - a[2]*b[1];
 		r[1]=a[2]*b[0] - a[0]*b[2];
 		r[2]=a[0]*b[1] - a[1]*b[0];
-
+	
 		len=sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);
 		if (len!=0.0F)
 		{
@@ -458,26 +456,23 @@
 		face-&gt;flags|=G3D_FLAG_FAC_NORMALS;
 		i++;
 	}
-
 	do {
 		/* find a suitable group. -1 means we've already taken care */
 		group=-1;
 		for (i=0;i&lt;polynum;i++)
 			if ((group=smooth_list[i])!=-1) /* found a group */
 				break;
-		printf(&quot;handling group %d\n&quot;,group);
 		/* handle this group */
 		if (group!=-1)
 		{
 			/* SMOOTH */
-			/*  this functions takes a shitload of arguments, but that's because of optimization.  */
 			/*  we add normals of the polygons's vertices so each vertex will finally have */
 			/*  the sum of the polygons normals where the vertex is part of. */
 
-			/* run0: clear the v_t_buf for this group */
+			/* run0: clear the vertex_normal_buf for this group */
 			for (i=0;i&lt;object-&gt;vertex_count*3;i++)
-				v_t_buf[i]=0.0;
-			 /*  run1: add normals on themselves into the v_t_buf */
+				vertex_normal_buf[i]=0.0;
+			 /*  run1: add normals on themselves into the vertex_normal_buf */
 			i=0;
 			for (oface=object-&gt;faces; oface != NULL ; oface=oface-&gt;next)
 			{
@@ -488,7 +483,7 @@
 					{
 						k=face-&gt;vertex_indices[j];
 						for (n=0;n&lt;3;n++)
-							v_t_buf[ k*3+n ]+= pnormal_list[i*3 + n];
+							vertex_normal_buf[ k*3+n ]+= pnormal_list[i*3 + n];
 					}
 				}
 				i++;
@@ -504,18 +499,15 @@
 					for (j=0;j&lt;3;j++)
 					{
 						k=face-&gt;vertex_indices[j];
-						len=sqrt(	v_t_buf[k*3]   * v_t_buf[k]+
-									v_t_buf[k*3+1] * v_t_buf[k*3+1]+
-									v_t_buf[k*3+2] * v_t_buf[k*3+2]);
-						printf(&quot;vertex buffer : %f %f %f ... len = %f\n&quot;,v_t_buf[k*3],v_t_buf[k*3+1],v_t_buf[k*3+2],len);
+						len=sqrt(	vertex_normal_buf[k*3]   * vertex_normal_buf[k*3]+
+									vertex_normal_buf[k*3+1] * vertex_normal_buf[k*3+1]+
+									vertex_normal_buf[k*3+2] * vertex_normal_buf[k*3+2]);
 						if (len==0.0F)   /*  this should not happen. well ... */
-								for (n=0;n&lt;3;n++)	v_t_buf[k*3 + n]=0;
-						else	for (n=0;n&lt;3;n++)	v_t_buf[k*3 + n]/=len; /* normalize it */
-
-						if (len!=0.0) 	memcpy(face-&gt;normals +j*3, v_t_buf+ 	k*3,sizeof(gfloat)*3);	/*  finally, we save the normal in our normal buffer */
-						else  			{memcpy(face-&gt;normals +j*3, pnormal_list+i*3,sizeof(gfloat)*3);	/*  use the pbuf normal */
-							printf(&quot;using pnormal_list as fallback\n&quot;);
-						}
+								for (n=0;n&lt;3;n++)	vertex_normal_buf[k*3 + n]=0;
+						else	for (n=0;n&lt;3;n++)	vertex_normal_buf[k*3 + n]/=len; /* normalize it */
+						
+						if (len!=0.0) 	memcpy(face-&gt;normals +j*3, vertex_normal_buf+ 	k*3,sizeof(gfloat)*3);	/*  finally, we save the normal in our normal buffer */
+						else  			memcpy(face-&gt;normals +j*3, pnormal_list+i*3,sizeof(gfloat)*3);	/*  use the pbuf normal */
 					}
 					smooth_list[i]=-1; /* finished this polygon */
 				}
@@ -526,7 +518,7 @@
 	} while (group!=-1);
 
 	g_free(pnormal_list);
-	g_free(v_t_buf);
+	g_free(vertex_normal_buf);
 	g_free(smooth_list);
 	return TRUE;
 }

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/libs3d/s3d.h	2006-09-16 00:44:17 UTC (rev 391)
@@ -151,8 +151,7 @@
 int s3d_scale(int object, float s);
 
 /* high-level object creating */
-int s3d_import_3ds_file(char *fname);
-int s3d_import_3ds(char *buf);
+int s3d_import_model_file(char *fname);
 int s3d_open_file(char *fname, char **pointer);
 int s3d_select_font(char *mask);
 int s3d_draw_string( char *str, float *xlen);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000383.html">[S3d-svn] r390 - in trunk/libs3d/libg3d: plugins/import src
</A></li>
	<LI>Next message: <A HREF="000385.html">[S3d-svn] r392 - in trunk: apps/dot_mcp apps/olsrs3d	apps/s3d_x11gate apps/s3dfm apps/s3dgps apps/s3dvt example libs3d
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#384">[ date ]</a>
              <a href="thread.html#384">[ thread ]</a>
              <a href="subject.html#384">[ subject ]</a>
              <a href="author.html#384">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/s3d-svn">More information about the S3d-svn
mailing list</a><br>
</body></html>
