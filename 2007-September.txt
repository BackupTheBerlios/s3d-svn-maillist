From dotslash at mail.berlios.de  Sat Sep  1 14:49:23 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 1 Sep 2007 14:49:23 +0200
Subject: [S3d-svn] r659 - in trunk: . apps/s3dosm
Message-ID: <200709011249.l81CnNdD019677@sheep.berlios.de>

Author: dotslash
Date: 2007-09-01 14:49:22 +0200 (Sat, 01 Sep 2007)
New Revision: 659

Removed:
   trunk/apps/s3dosm/net.c
   trunk/apps/s3dosm/olsrs3d.c
   trunk/apps/s3dosm/process.c
   trunk/apps/s3dosm/search.c
Modified:
   trunk/
   trunk/apps/s3dosm/CMakeLists.txt
   trunk/apps/s3dosm/main.c
   trunk/apps/s3dosm/ui.c
Log:
 r2272 at kero:  dotslash | 2007-09-01 14:26:44 +0200
 - remove olsr part out of s3dosm. it's not needed anyway, the olsrs3d 
   program alone makes much more sense



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2265
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2272

Modified: trunk/apps/s3dosm/CMakeLists.txt
===================================================================
--- trunk/apps/s3dosm/CMakeLists.txt	2007-08-28 16:57:21 UTC (rev 658)
+++ trunk/apps/s3dosm/CMakeLists.txt	2007-09-01 12:49:22 UTC (rev 659)
@@ -5,8 +5,8 @@
 	include_directories(${s3d_SOURCE_DIR}/libs3d ${s3d_SOURCE_DIR}/libs3dw)
 
 	add_executable(s3dosm db.c draw.c gps.c http_error_codes.c http_fetcher.c#
-		io.c kismet.c main.c nav.c net.c object.c olsrs3d.c osm.c
-		process.c search.c tag.c ui.c)
+		io.c kismet.c main.c nav.c object.c osm.c
+		tag.c ui.c)
 
 	target_link_libraries(s3dosm s3d s3dw ${LIBXML2_LIBRARIES} ${SQLITE3_LIBRARIES})
 

Modified: trunk/apps/s3dosm/main.c
===================================================================
--- trunk/apps/s3dosm/main.c	2007-08-28 16:57:21 UTC (rev 658)
+++ trunk/apps/s3dosm/main.c	2007-09-01 12:49:22 UTC (rev 659)
@@ -36,7 +36,6 @@
 		nanosleep(&t,NULL); 
 		gps_main();
 		nav_main();
-		olsr_main();
 		s3dw_ani_mate();
 	} /* else {
 		s3d_net_check(); / * we are not yet in the mainloop of 
@@ -56,20 +55,17 @@
 	ui_init();
 	if (db_init(":memory:")) return(-1);
 	if (db_create()) return(-1);
-	olsr_parse_args(argc, argv); /* if it returns !=0, it was -h and should also be handled by process_args itself */
 	if (process_args(argc,argv)) return(-1);
 	nav_init();
 	nav_autocenter();
 	draw_all_layers();
 	gps_init("localhost");
-	olsr_init();
 	ready=1;
 	return(0);
 }
 int quit() 
 {
 	ready=0;
-	olsr_quit();
 	gps_quit();
 	s3d_quit();
 	db_quit();

Deleted: trunk/apps/s3dosm/net.c
===================================================================
--- trunk/apps/s3dosm/net.c	2007-08-28 16:57:21 UTC (rev 658)
+++ trunk/apps/s3dosm/net.c	2007-09-01 12:49:22 UTC (rev 659)
@@ -1,132 +0,0 @@
-/*
- * net.c
- *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *                         Marek Lindner <lindner_marek at yahoo.de>
- *                         Andreas Langer <andreas_lbg at gmx.de>
- *
- * This file is part of olsrs3d, an olsr topology visualizer for s3d.
- * See http://s3d.berlios.de/ for more updates.
- *
- * olsrs3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * olsrs3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with olsrs3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>	/* close() */
-#include <errno.h>
-#include <string.h> 	/* strlen(), memmove(), strncpy(), strncat() */
-#include <netdb.h>
-#include <sys/types.h>
-#include <netinet/in.h>
-#include <sys/socket.h>
-#include <fcntl.h>		/* fnctl() */
-#include "olsrs3d.h"
-
-#define PORT 2004 		/* the port client will be connecting to  */
-char buf[MAXDATASIZE];
-
-
-int sockfd, numbytes;
-int net_init(char *host)
-{
-    struct hostent *he;
-    struct sockaddr_in their_addr; /* connector's address information  */
-
-    if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
-		fprintf(stderr,"Can't connect to host %s\n",host);
-        herror("olsr_net:gethostbyname");
-        return(1);
-    }
-
-    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
-		fprintf(stderr,"Can't connect to host %s\n",host);
-        perror("olsr_net:socket");
-        return(1);
-    }
-
-    their_addr.sin_family = AF_INET;    /* host byte order  */
-    their_addr.sin_port = htons(PORT);  /* short, network byte order  */
-    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
-    memset(&(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
-
-    if (connect(sockfd, (struct sockaddr *)&their_addr,
-                                          sizeof(struct sockaddr)) == -1) {
-		fprintf(stderr,"Can't connect to host %s\n",host);
-        perror("olsr_net:connect");
-        return(1);
-    }
-	fcntl(sockfd,F_SETFL, O_NONBLOCK);
-	return(0);
-}
-
-int net_main() {
-
-	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
-		if (errno==EAGAIN)
-			return(0); /* well, that's okay ... */
-		perror("recv");
-		return(-1);
-	}
-
-	if (numbytes==0) {
-		printf("connection reset\n");
-		return(-1);
-	}
-
-	buf[numbytes] = '\0';
-
-	/* check for potential buffer overflow */
-	if ( ( strlen( lbuf ) + strlen( buf ) ) < MAXLINESIZE ) {
-
-		strncat( lbuf, buf, MAXLINESIZE );
-
-	} else {
-
-		/* hope that carriage return is now in buf */
-		if ( strlen( lbuf ) < MAXLINESIZE ) {
-
-			if ( Debug ) printf( "WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n" );
-			strncat( lbuf, buf, MAXLINESIZE - strlen( lbuf ) );
-
-		} else {
-
-			if ( Debug ) printf( "ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n" );
-			strncpy( lbuf, buf, MAXLINESIZE );
-
-		}
-
-	}
-
-	process_main();
-
-	if ( ++Net_read_count > 5 ) {
-		return(0);   /* continue mainloop */
-	} else {
-		return(1);   /* continue reading data from socket */
-	}
-
-}
-
-int net_quit()
-{
-    close(sockfd);
-
-    return 0;
-}
-
-

Deleted: trunk/apps/s3dosm/olsrs3d.c
===================================================================
--- trunk/apps/s3dosm/olsrs3d.c	2007-08-28 16:57:21 UTC (rev 658)
+++ trunk/apps/s3dosm/olsrs3d.c	2007-09-01 12:49:22 UTC (rev 659)
@@ -1,1130 +0,0 @@
-/*
- * olsrs3d.c
- *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *                         Marek Lindner <lindner_marek at yahoo.de>
- *                         Andreas Langer <andreas_lbg at gmx.de>
- *
- * This file is part of olsrs3d, an olsr topology visualizer for s3d.
- * See http://s3d.berlios.de/ for more updates.
- *
- * olsrs3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * olsrs3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with olsrs3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include <stdio.h>
-#include <s3d.h>
-#include <s3d_keysym.h>
-#include <s3dw.h>
-#include <sys/time.h>	 /* gettimeofday() */
-#include <time.h>	     /* nanosleep() */
-#include <string.h>		 /* strncpy() */
-#include <math.h>		 /* sqrt() */
-#include <getopt.h>		 /* getopt() */
-#include <stdlib.h>		 /* exit() */
-#include <stdint.h>		 /* uintXX_t */
-#include "olsrs3d.h"
-#include "s3dosm.h"
-#include "search.h"
-
-#define SPEED		10.0
-
-int Debug = 0;
-
-extern float olsr_node_init[6];
-extern int oidy; /* zeropoint of s3dosm to link to */
-static int olsr_ready=0; /* olsr is not initialized yet */
-
-char Olsr_host[256];   /* ip or hostname of olsr node with running dot_draw plugin */
-
-struct olsr_con *Con_begin = NULL;   /* begin of connection list */
-struct olsr_node *Olsr_root = NULL;   /* top of olsr node tree */
-struct Obj_to_ip *Obj_to_ip_head, *Obj_to_ip_end, *List_ptr;   /* needed pointer for linked list */
-
-int Olsr_node_count = 0, Last_olsr_node_count = -1;
-int Olsr_node_count_obj = -1;
-int Olsr_ip_label_obj = -1;
-int Output_border[4];
-int *Olsr_neighbour_label_obj = NULL;
-int Size;
-
-
-int Net_read_count;
-int Output_block_counter = 0;
-int Output_block_completed = 0;
-
-int Olsr_node_obj, Olsr_node_inet_obj, Olsr_node_hna_net, S3d_obj;
-
-float Asp = 1.0;
-float Bottom = -1.0;
-float Left = -1.0;
-
-float CamPosition[2][3];	/* CamPosition[trans|rot][x-z] */
-float CamPosition2[2][3];	/* CamPosition[trans|rot][x-z] */
-
-/* needed ? */
-/* float ZeroPosition[3] = {0,0,0};	 current position zero position */
-
-int ZeroPoint;   /* object zeropoint */
-int ColorSwitch = 0;   /* enable/disable colored olsr connections */
-float Factor = 0.6;	/* Factor in calc_olsr_node_mov */
-struct olsr_node *Olsr_node_pEtx;
-
-int Btn_close_id = -1;
-
-int Btn_close_obj;
-int Last_Click_Time = 0;
-int Last_Click_Oid = 0;
-float Title_len;
-
-/***
- *
- * print usage info
- *
- ***/
-
-void print_usage( void ) {
-
-	printf( "Usage is olsrs3d [options] [-- [s3d options]]\n" );
-	printf( "olsrs3d options:\n" );
-	printf( "   -h\tprint this short help\n" );
-	printf( "   -d\tenable debug mode\n" );
-	printf( "   -H\tconnect to olsr node [default: localhost]\n" );
-	s3d_usage();
-
-}
-
-
-void close_win(s3dw_widget *button) {
-	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
-}
-
-
-
-void window_help() {
-
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-
-	infwin = s3dw_surface_new( "Help Window", 20, 19 );
-
-	/*s3dw_label_new(infwin,"C        - Colour On/Off",1,2);*/
-	s3dw_label_new(infwin,"c",1,2);
-	s3dw_label_new(infwin,"- Colour On/Off",6,2);
-	/*s3dw_label_new(infwin,"r        - Rotation On/Off",1,4);*/
-	s3dw_label_new(infwin,"r",1,4);
-	s3dw_label_new(infwin,"- Rotation On/Off",6,4);
-	s3dw_label_new(infwin,"+",1,5);
-	s3dw_label_new(infwin,"- Increase Rotation Speed",6,5);
-	s3dw_label_new(infwin,"-",1,6);
-	s3dw_label_new(infwin,"- Decrease Rotation Speed",6,6);
-	s3dw_label_new(infwin,"F3",1,8);
-	s3dw_label_new(infwin,"- Search IP",6,8);
-	s3dw_label_new(infwin,"ESC",1,9);
-	s3dw_label_new(infwin,"- Disable FollowMode",6,9);
-	s3dw_label_new(infwin,"PGUP",1,11);
-	s3dw_label_new(infwin,"- Increase Drift Factor",6,11);
-	s3dw_label_new(infwin,"PGDOWN",1,12);
-	s3dw_label_new(infwin,"- Decrease Drift Factor",6,12);
-	s3dw_label_new(infwin,"STRG + p",1,14);
-	s3dw_label_new(infwin,"- Reset Nodes",6,14);
-
-	button=s3dw_button_new(infwin,"OK",9,16);
-	button->onclick = close_win;
-	s3dw_show(S3DWIDGET(infwin));
-
-}
-
-
-void window_error(char *msg) {
-
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-
-	infwin = s3dw_surface_new( "Error", 12, 6 );
-	s3dw_label_new(infwin,msg,1,2);
-
-	button=s3dw_button_new(infwin,"OK",4,4);
-	button->onclick = close_win;
-	s3dw_show(S3DWIDGET(infwin));
-
-}
-
-
-/***
- *
- * print error and exit
- *
- ***/
-
-void out_of_mem( void ) {
-
-	printf( "Sorry - you ran out of memory !\n" );
-	exit(8);
-
-}
-
-
-
-unsigned int get_time(void) {
-
-	struct timeval tv;
-
-	gettimeofday(&tv, NULL);
-
-	return tv.tv_sec * 1000 + tv.tv_usec / 1000;
-
-}
-
-
-
-/***
- *
- * calculate distance between 2 vectors => http://en.wikipedia.org/wiki/Euclidean_distance
- *
- *   p1   =>   vector of node 1
- *   p2   =>   vector of node 2
- *
- *   return distance
- *
- ***/
-
-float dist(float p1[], float p2[])
-{
-	float p[3];
-	p[0]=p1[0]-p2[0];
-	p[1]=p1[1]-p2[1];
-	p[2]=p1[2]-p2[2];
-	return (sqrt(p[0]*p[0]   +  p[1]*p[1]  +  p[2]*p[2]));
-
-}
-
-
-
-/***
- *
- * calculate distance between 2 vectors and subtract vector1 from vector2
- *  => http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction
- *
- *   p1   =>   vector of node 1
- *   p2   =>   vector of node 2
- *
- *   return distance
- *
- ***/
-
-float dirt(float p1[], float p2[], float p3[])
-{
-	float d;
-	d=dist(p1,p2);
-	if (d==0) {
-		p3[0]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		p3[1]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		p3[2]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		d=s3d_vector_length(p3);
-	} else {
-		p3[0]=p2[0]-p1[0];
-		p3[1]=p2[1]-p1[1];
-		p3[2]=p2[2]-p1[2];
-	}
-	return(d);
-}
-
-
-
-/***
- *
- * calculate new movement of node by adding the product of the factor and the vector to the movement vector
- *  => http://en.wikipedia.org/wiki/Vector_%28spatial%29#Scalar_multiplication
- *
- *   mov  =>   current mov vector
- *   p    =>   vector of node
- *   fac  =>   factor which is
- *
- ***/
-
-void mov_add(float mov[], float p[], float fac)
-{
-/*	if (fac>1000)
-		return;
-	fac=1000; */
-	mov[0]+=fac*p[0];
-	mov[1]+=fac*p[1];
-	mov[2]+=fac*p[2];
-}
-
-
-
-/***
- *
- * check whether is a new / modified / vanished node and handle it accordingly
- *
- *   *olsr_node =>   pointer to current olsr_node
- *
- ***/
-
-void handle_olsr_node( struct olsr_node *olsr_node ) {
-
-	float distance, angle, angle_rad;
-	float tmp_mov_vec[3], desc_norm_vec[3] = {0,0,-1};
-	struct olsr_node *other_node;
-	struct Obj_to_ip *Obj_to_ip_curr;
-	struct olsr_neigh_list *olsr_neigh_list, *prev_olsr_neigh_list, *other_node_neigh_list, *tmp_olsr_neigh_list;
-
-	/* no more nodes left */
-	if ( olsr_node == NULL ) return;
-
-	/* olsr node vanished */
-	if ( ( olsr_node->last_seen < Output_block_counter - 1 ) && ( olsr_node->visible ) ) {
-
-		if ( Debug )
-			printf( "olsr node vanished: %s\n", olsr_node->ip );
-
-		Olsr_node_count--;
-
-		olsr_node->visible = 0;
-
-		/* delete shape */
-		if ( olsr_node->obj_id != -1 ) {
-
-			/* remove element from ob2ip list */
-			lst_del( olsr_node->obj_id );
-			/* remove object from s3d server */
-			s3d_del_object( olsr_node->obj_id );
-
-			olsr_node->obj_id = -1;
-
-		}
-
-		if ( olsr_node->desc_id != -1 ) {
-
-			s3d_del_object( olsr_node->desc_id );
-			olsr_node->desc_id = -1;
-
-		}
-
-		/* delete olsr connections of this node */
-		olsr_neigh_list = olsr_node->olsr_neigh_list;
-
-		while ( olsr_neigh_list != NULL ) {
-
-			/* get connection list of 'other' node */
-			if ( olsr_neigh_list->olsr_con->left_olsr_node == olsr_node ) {
-				other_node = olsr_neigh_list->olsr_con->right_olsr_node;
-			} else {
-				other_node = olsr_neigh_list->olsr_con->left_olsr_node;
-			}
-
-			/* find this connection in 'other' nodes connection list ... */
-			prev_olsr_neigh_list = NULL;
-			other_node_neigh_list = other_node->olsr_neigh_list;
-
-			while ( other_node_neigh_list != NULL ) {
-
-				if ( other_node_neigh_list->olsr_con == olsr_neigh_list->olsr_con ) {
-
-					/* and delete it ! */
-					if ( prev_olsr_neigh_list != NULL ) {
-						/* is first, any or last element in the list */
-						prev_olsr_neigh_list->next_olsr_neigh_list = other_node_neigh_list->next_olsr_neigh_list;
-					} else {
-						/* the only element in the list */
-						other_node->olsr_neigh_list = NULL;
-					}
-
-					free( other_node_neigh_list );
-
-					break;
-
-				}
-
-				prev_olsr_neigh_list = other_node_neigh_list;
-				other_node_neigh_list = other_node_neigh_list->next_olsr_neigh_list;
-
-			}
-
-			s3d_del_object( olsr_neigh_list->olsr_con->obj_id );
-
-			/* delete connection */
-			if ( olsr_neigh_list->olsr_con->prev_olsr_con != NULL ) olsr_neigh_list->olsr_con->prev_olsr_con->next_olsr_con = olsr_neigh_list->olsr_con->next_olsr_con;
-			if ( olsr_neigh_list->olsr_con->next_olsr_con != NULL ) olsr_neigh_list->olsr_con->next_olsr_con->prev_olsr_con = olsr_neigh_list->olsr_con->prev_olsr_con;
-
-			tmp_olsr_neigh_list = olsr_neigh_list;
-
-			olsr_neigh_list = olsr_neigh_list->next_olsr_neigh_list;
-
-			free( tmp_olsr_neigh_list->olsr_con );
-			free( tmp_olsr_neigh_list );
-
-		}
-
-		olsr_node->olsr_neigh_list = NULL;
-
-	} else if ( olsr_node->visible ) {
-
-		/* olsr node shape has been modified */
-		if ( olsr_node->node_type_modified ) {
-			float lo, la;
-
-			/* delete old shape */
-			if ( olsr_node->obj_id != -1 ) {
-				/* remove element from ob2ip list */
-				lst_del( olsr_node->obj_id );
-				s3d_del_object( olsr_node->obj_id );
-			}
-
-			if ( olsr_node->desc_id != -1 ) s3d_del_object( olsr_node->desc_id );
-
-			/* create new shape */
-			if ( olsr_node->node_type == 1 ) {
-				/* olsr node offers internet access */
-				olsr_node->obj_id = s3d_clone( Olsr_node_inet_obj );
-			} else if ( olsr_node->node_type == 2 ) {
-				/* via hna announced network */
-				olsr_node->obj_id = s3d_clone( Olsr_node_hna_net );
-			} else {
-				/* normal olsr node */
-				olsr_node->obj_id = s3d_clone( Olsr_node_obj );
-			}
-			la=olsr_node_init[3];
-			lo=olsr_node_init[4];
-			s3d_rotate(olsr_node->obj_id,(90-la),lo,0);
-
-			s3d_flags_on( olsr_node->obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-
-			/* link newly created object to ZeroPoint */
-			s3d_link( olsr_node->obj_id, ZeroPoint );
-			/* add object_id and olsr_node to linked list */
-			lst_add(olsr_node->obj_id,&olsr_node);
-
-			/* create olsr node text and attach (link) it to the node */
-			olsr_node->desc_id = s3d_draw_string( olsr_node->ip, &olsr_node->desc_length );
-			s3d_link( olsr_node->desc_id, olsr_node->obj_id );
-			s3d_translate( olsr_node->desc_id, - olsr_node->desc_length / 2, -2, 0 );
-			s3d_flags_on( olsr_node->desc_id, S3D_OF_VISIBLE );
-
-			olsr_node->node_type_modified = 0;
-
-		}
-
-
-		/* rotate node description so that they are always readable */
-		tmp_mov_vec[0] = CamPosition2[0][0] - olsr_node->pos_vec[0];
-		tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
-		tmp_mov_vec[2] = CamPosition2[0][2] - olsr_node->pos_vec[2];
-
-		angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
-
-		/* take care of inverse cosinus */
-		if ( tmp_mov_vec[0] > 0 ) {
-			angle_rad = 90.0/M_PI - angle;
-			angle = 180 - ( 180.0/M_PI * angle );
-		} else {
-			angle_rad = 90.0/M_PI + angle;
-			angle = 180 + ( 180.0/M_PI * angle );
-		}
-
-		s3d_rotate( olsr_node->desc_id, 0, angle , 0 );
-		s3d_translate( olsr_node->desc_id, -cos(angle_rad)*olsr_node->desc_length/2 ,-1.5, sin(angle_rad)*olsr_node->desc_length/2 );
-
-
-		/* drift away from unrelated nodes */
-		Obj_to_ip_curr = Obj_to_ip_head->next;
-		while ( Obj_to_ip_curr != Obj_to_ip_end ) {
-
-			/* myself ... */
-			if ( olsr_node != Obj_to_ip_curr->olsr_node ) {
-
-				olsr_neigh_list = olsr_node->olsr_neigh_list;
-				while ( olsr_neigh_list != NULL ) {
-
-					/* nodes are related */
-					if ( ( olsr_neigh_list->olsr_con->left_olsr_node->visible == 1 ) && ( olsr_neigh_list->olsr_con->right_olsr_node->visible == 1 ) ) {
-
-						if ( ( olsr_neigh_list->olsr_con->left_olsr_node == Obj_to_ip_curr->olsr_node ) || (  olsr_neigh_list->olsr_con->right_olsr_node == Obj_to_ip_curr->olsr_node ) ) break;
-
-					}
-
-					olsr_neigh_list = olsr_neigh_list->next_olsr_neigh_list;
-
-				}
-
-				/* nodes are not related - so drift */
-				if ( olsr_neigh_list == NULL ) {
-
-					distance = dirt( olsr_node->pos_vec, Obj_to_ip_curr->olsr_node->pos_vec, tmp_mov_vec );
-					if ( distance < 0.1 ) distance = 0.1;
-					mov_add( olsr_node->mov_vec, tmp_mov_vec,-10 / ( distance * distance ) );
-					mov_add( Obj_to_ip_curr->olsr_node->mov_vec, tmp_mov_vec, 10 / ( distance * distance ) );
-
-				}
-
-			}
-
-			Obj_to_ip_curr = Obj_to_ip_curr->next;
-
-		}
-
-	}
-
-	handle_olsr_node( olsr_node->left );
-	handle_olsr_node( olsr_node->right );
-
-}
-
-
-
-/***
- *
- * calculate movement vector of all olsr nodes
- *
- ***/
-
-void calc_olsr_node_mov( void ) {
-
-	float distance;
-	float tmp_mov_vec[3];
-	float f;
-	struct olsr_con *olsr_con = Con_begin;
-
-	while ( olsr_con != NULL ) {
-
-		distance = dirt( olsr_con->left_olsr_node->pos_vec, olsr_con->right_olsr_node->pos_vec, tmp_mov_vec );
-		f = ( ( olsr_con->left_etx_sqrt + olsr_con->left_etx_sqrt ) / 4.0 ) / distance;
-
-		/***
-		 * drift factor - 0.0 < factor < 1.0 ( best results: 0.3 < factor < 0.9
-		 * small factor: fast and strong drift to neighbours
-		 ***/
-		if ( f < Factor ) f = Factor;
-
-		mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, 1 / f - 1 );
-		mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, - ( 1 / f - 1 ) );
-
-		olsr_con = olsr_con->next_olsr_con;
-
-	}
-
-}
-
-
-
-/***
- *
- * move all olsr nodes and their connections
- *
- ***/
-
-void move_olsr_nodes( void ) {
-
-	float null_vec[3] = {0,0,0}, vertex_buf[6];
-	float target_vec[3];
-	float tmp_mov_vec[3];
-	float distance, etx, rgb;
-	struct olsr_con *olsr_con = Con_begin;
-	int n=0;
-	
-	while ( olsr_con != NULL ) {
-		n++;
-		/* move left olsr node if it has not been moved yet */
-		if ( !( ( olsr_con->left_olsr_node->mov_vec[0] == 0 ) && ( olsr_con->left_olsr_node->mov_vec[1] == 0 ) && ( olsr_con->left_olsr_node->mov_vec[2] == 0 ) ) && olsr_con->left_olsr_node->visible ) {
-			distance = dirt( olsr_con->left_olsr_node->pos_vec, olsr_node_init, tmp_mov_vec );
-			if (distance>5000)		printf("distance = %3.3f %s | %3.3f %3.3f %3.3f\n",distance,olsr_con->left_olsr_node->ip,
-							olsr_con->left_olsr_node->pos_vec[0],
-							olsr_con->left_olsr_node->pos_vec[1],
-							olsr_con->left_olsr_node->pos_vec[2]);
-
-
-			distance = dirt( olsr_con->left_olsr_node->pos_vec, null_vec, tmp_mov_vec );
-			target_vec[0]=olsr_con->left_olsr_node->pos_vec[0]/distance * (ESIZE+10);
-			target_vec[1]=olsr_con->left_olsr_node->pos_vec[1]/distance * (ESIZE+10);
-			target_vec[2]=olsr_con->left_olsr_node->pos_vec[2]/distance * (ESIZE+10);
-			distance = dirt( olsr_con->left_olsr_node->pos_vec, target_vec, tmp_mov_vec );
-			mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, distance );  /* move a little bit to earth height */
-
-			if ( ! olsr_con->left_olsr_node->static_node) {
-				if ( ( distance = dist( olsr_con->left_olsr_node->mov_vec, null_vec ) ) > 10.0 ) {
-					mov_add( olsr_con->left_olsr_node->pos_vec, olsr_con->left_olsr_node->mov_vec, 1.0/ ( ( float ) distance) );
-				} else {
-					mov_add( olsr_con->left_olsr_node->pos_vec, olsr_con->left_olsr_node->mov_vec, 0.1 );
-				}
-			}
-
-			s3d_translate( olsr_con->left_olsr_node->obj_id, olsr_con->left_olsr_node->pos_vec[0], olsr_con->left_olsr_node->pos_vec[1], olsr_con->left_olsr_node->pos_vec[2] );
-
-			/* reset movement vector */
-			olsr_con->left_olsr_node->mov_vec[0] = olsr_con->left_olsr_node->mov_vec[1] = olsr_con->left_olsr_node->mov_vec[2] = 0.0;
-
-		}
-
-		/* move right olsr node if it has not been moved yet */
-		if ( !( ( olsr_con->right_olsr_node->mov_vec[0] == 0 ) && ( olsr_con->right_olsr_node->mov_vec[1] == 0 ) && ( olsr_con->right_olsr_node->mov_vec[2] == 0 ) ) && olsr_con->right_olsr_node->visible ) {
-
-			distance = dirt( olsr_con->right_olsr_node->pos_vec, olsr_node_init, tmp_mov_vec );
-			if (distance>5000)		printf("distance = %3.3f %s| %3.3f %3.3f %3.3f\n",distance,olsr_con->right_olsr_node->ip,
-							olsr_con->right_olsr_node->pos_vec[0],
-							olsr_con->right_olsr_node->pos_vec[1],
-							olsr_con->right_olsr_node->pos_vec[2]);
-
-			distance = dirt( olsr_con->right_olsr_node->pos_vec, null_vec, tmp_mov_vec );
-			target_vec[0]=olsr_con->right_olsr_node->pos_vec[0]/distance * (ESIZE+10);
-			target_vec[1]=olsr_con->right_olsr_node->pos_vec[1]/distance * (ESIZE+10);
-			target_vec[2]=olsr_con->right_olsr_node->pos_vec[2]/distance * (ESIZE+10);
-			distance = dirt( olsr_con->right_olsr_node->pos_vec, target_vec, tmp_mov_vec );
-
-			mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, distance ); /* move a little bit to earth height */
-					
-			if ( ! olsr_con->right_olsr_node->static_node) {
-				distance = dist( olsr_con->right_olsr_node->mov_vec, null_vec );
-				if ( distance > 10.0 ) {
-					mov_add( olsr_con->right_olsr_node->pos_vec, olsr_con->right_olsr_node->mov_vec, 1.0/ ( ( float ) distance) );
-				} else {
-					mov_add( olsr_con->right_olsr_node->pos_vec, olsr_con->right_olsr_node->mov_vec, 0.1 );
-				}
-			}
-			s3d_translate( olsr_con->right_olsr_node->obj_id, olsr_con->right_olsr_node->pos_vec[0], olsr_con->right_olsr_node->pos_vec[1], olsr_con->right_olsr_node->pos_vec[2] );
-
-			/* reset movement vector */
-			olsr_con->right_olsr_node->mov_vec[0] = olsr_con->right_olsr_node->mov_vec[1] = olsr_con->right_olsr_node->mov_vec[2] = 0.0;
-
-		}
-
-
-		/* move connection between left and right olsr node */
-		vertex_buf[0] = olsr_con->left_olsr_node->pos_vec[0];
-		vertex_buf[1] = olsr_con->left_olsr_node->pos_vec[1];
-		vertex_buf[2] = olsr_con->left_olsr_node->pos_vec[2];
-		vertex_buf[3] = olsr_con->right_olsr_node->pos_vec[0];
-		vertex_buf[4] = olsr_con->right_olsr_node->pos_vec[1];
-		vertex_buf[5] = olsr_con->right_olsr_node->pos_vec[2];
-
-		s3d_pep_vertices( olsr_con->obj_id, vertex_buf, 2 );
-
-
-		if ( ColorSwitch ) {
-
-			/* HNA */
-			if ( olsr_con->left_etx == -1000.00 ) {
-
-				if(olsr_con->color != 1) {
-					s3d_pep_material( olsr_con->obj_id,
-								   0.0,0.0,1.0,
-								   0.0,0.0,1.0,
-								   0.0,0.0,1.0);
-					olsr_con->color = 1;
-				}
-
-			} else {
-
-				etx = ( olsr_con->left_etx + olsr_con->right_etx ) / 2.0;
-
-				/* very good link - bright blue */
-				if ( ( etx >= 1.0 ) && ( etx < 1.5 ) ) {
-
-					if(olsr_con->color != 2) {
-						s3d_pep_material( olsr_con->obj_id,
-								0.5,1.0,1.0,
-								0.5,1.0,1.0,
-								0.5,1.0,1.0);
-						olsr_con->color = 2;
-					}
-
-				/* good link - bright yellow */
-				} else if ( ( etx >= 1.5 ) && ( etx < 2.0 ) ) {
-
-					rgb = 2.0 - etx;
-					if( olsr_con->color != 3 || (olsr_con->color == 3 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
-						s3d_pep_material( olsr_con->obj_id,
-								1.0,1.0,rgb,
-								1.0,1.0,rgb,
-								1.0,1.0,rgb);
-						olsr_con->color = 3;
-
-						olsr_con->rgb =  rgb;
-					}
-
-				/* not so good link - orange */
-				} else if ( ( etx >= 2.0 ) && ( etx < 3.0 ) ) {
-
-					rgb = 1.5 - ( etx / 2.0 );
-					if( olsr_con->color != 4 || (olsr_con->color == 4 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
-						s3d_pep_material( olsr_con->obj_id,
-								1.0,rgb,0.0,
-								1.0,rgb,0.0,
-								1.0,rgb,0.0);
-						olsr_con->color = 4;
-
-						olsr_con->rgb = rgb;
-					}
-
-				/* bad link (almost dead) - brown */
-				} else if ( ( etx >= 3.0 ) && ( etx < 5.0 ) ) {
-
-					rgb = 1.75 - ( etx / 4.0 );
-
-					if( olsr_con->color != 5 || (olsr_con->color == 5 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
-
-						s3d_pep_material( olsr_con->obj_id,
-								rgb,rgb - 0.5,0.0,
-								rgb,rgb - 0.5,0.0,
-								rgb,rgb - 0.5,0.0);
-						olsr_con->color = 5;
-
-						olsr_con->rgb = rgb;
-					}
-
-				/* zombie link - grey */
-				} else if ( ( etx >= 5.0 ) && ( etx < 1000.0 ) ) {
-
-					rgb = 1000.0 / ( 1500.0 + etx );
-
-					if( olsr_con->color != 6 || (olsr_con->color == 6 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
-
-						s3d_pep_material( olsr_con->obj_id,
-								rgb,rgb,rgb,
-								rgb,rgb,rgb,
-								rgb,rgb,rgb);
-						olsr_con->color = 6;
-
-						olsr_con->rgb = rgb;
-					}
-
-				/* wtf - dark grey */
-				} else {
-
-					if(olsr_con->color != 7) {
-						s3d_pep_material( olsr_con->obj_id,
-								0.3,0.3,0.3,
-								0.3,0.3,0.3,
-								0.3,0.3,0.3);
-						olsr_con->color = 7;
-					}
-
-				}
-
-			}
-
-		} else {
-
-			if(olsr_con->color != 0) {
-				s3d_pep_material( olsr_con->obj_id,
-							1.0,1.0,1.0,
-							1.0,1.0,1.0,
-							1.0,1.0,1.0);
-				olsr_con->color = 0;
-			}
-
-		}
-
-
-		olsr_con = olsr_con->next_olsr_con;
-
-	}
-
-}
-
-
-
-void olsr_main() {
-
-	int net_result;   /* result of function net_main */
-	char nc_str[20];
-	float strLen;
-	if (!olsr_ready) return;
-
-	/* calculate new movement vector */
-	calc_olsr_node_mov();
-
-	/* prepare nodes */
-	handle_olsr_node( Olsr_root );
-
-	/* move it */
-	move_olsr_nodes();
-
-	/* if we have more or less nodes now - redraw node count */
-	if ( Olsr_node_count != Last_olsr_node_count ) {
-
-		if ( Olsr_node_count_obj != -1 ) s3d_del_object( Olsr_node_count_obj );
-		snprintf( nc_str, 20, "node count: %d", Olsr_node_count );
-		Olsr_node_count_obj = s3d_draw_string( nc_str, &strLen );
-		s3d_link( Olsr_node_count_obj, 0 );
-		s3d_flags_on( Olsr_node_count_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_node_count_obj, 0.2 );
-		s3d_translate( Olsr_node_count_obj, -Left*3.0-(strLen * 0.2), -Bottom*3.0-0.5, -3.0 );
-		Last_olsr_node_count = Olsr_node_count;
-
-	}
-
-	if ( Output_block_completed ) {
-
-		Output_block_counter++;
-		Output_block_completed = 0;
-
-	}
-
-	/* read data from socket */
-	Net_read_count = 0;
-	while ( ( net_result = net_main() ) != 0 ) {
-		if ( net_result == -1 ) {
-			s3d_quit();
-			break;
-		}
-	}
-	nav_campos(CamPosition[0], CamPosition2[0]);
-	
-	/* calc for node description */
-
-	/* check search status */
-/*	if( get_search_status() == WIDGET )
-		move_to_search_widget( CamPosition[0], CamPosition[1] );*/
-	if( get_search_status() == FOLLOW )
-		follow_node( CamPosition[0], CamPosition[1], 0 );
-/*	if( get_search_status() == ABORT )
-		move_to_return_point( CamPosition[0], CamPosition[1] );*/
-
-
-	if( Olsr_ip_label_obj != -1 )
-	{
-		print_etx();
-	}
-
-
-	return;
-
-}
-
-/***
- *
- * eventhandler when key pressed
- *
- ***/
-
-int olsr_keypress(struct s3d_evt *event) {
-
-	struct s3d_key_event *key=(struct s3d_key_event *)event->buf;
-	if (!olsr_ready) return(0);
-	if( get_search_status() != WIDGET )
-	{
-		switch(key->keysym)
-		{
-			case S3DK_F1: /* help */
-
-				window_help();
-				break;
-
-			case S3DK_ESCAPE: /* abort action */
-
-				set_search_status( get_search_status() == WIDGET ? ABORT : NOTHING );
-				break;
-
-			case S3DK_F3: /* move to search widget, give widget focus */
-
-				set_search_status(WIDGET);							/* set status for mainloop */
-				set_node_root( Olsr_root );
-				show_search_window();
-/*				set_return_point(CamPosition[0],CamPosition[1]);	/ * save the return position * /
-				set_node_root( Olsr_root );*/
-
-				break;
-
-			case S3DK_c: /* color on/off */
-
-				ColorSwitch =  ColorSwitch ? 0 : 1;
-				break;
-
-
-			case S3DK_PAGEUP: /* change factor in calc_olsr_node_mov */
-
-				if(Factor < 0.9)
-					Factor += 0.1;
-				break;
-
-			case S3DK_PAGEDOWN: /* change factor in calc_olsr_node_mov */
-
-				if(Factor > 0.3)
-					Factor -= 0.1;
-				break;
-
-		}
-	} else {
-		if( (key->keysym >= S3DK_PERIOD && key->keysym <= S3DK_9) || key->keysym == S3DK_COMMA || key->keysym == S3DK_RETURN || key->keysym == S3DK_BACKSPACE )
-			search_widget_write( key->keysym );
-	}
-	return(0);
-}
-
-/***
- *
- * eventhandler when object clicked
- *
- ***/
-
-int olsr_object_click(struct s3d_evt *evt)
-{
-/*	int i
-	char ip_str[50];
-	struct timeval tv;*/
-	struct olsr_node *olsr_node;
-	int oid;
-	if (!olsr_ready) return(0);
-
-
-	oid=(int)*((uint32_t *)evt->buf);
-
-
-	if ( ( get_search_status() != FOLLOW ) && ( Last_Click_Oid == oid ) && ( Last_Click_Time + 250 > get_time() ) ) {
-
-		olsr_node = lst_search(oid);
-
-		if ( olsr_node != NULL ) 
-			follow_node_by_click( olsr_node );
-
-	}
-
-	Last_Click_Oid = oid;
-	Last_Click_Time = get_time();
-
-	return(0);
-}
-
-void print_etx()
-{
-	struct olsr_neigh_list *tmpNeighbour;
-	float p = 1.4;
-	int i;
-	float len = 0.0, max_len=0.0;
-
-	if( Olsr_neighbour_label_obj != NULL )
-	{
-		/* int n = sizeof(Olsr_neighbour_label_obj) / sizeof(int);*/
-		for(i=0; i < Size; i++)
-			s3d_del_object( Olsr_neighbour_label_obj[i] );
-		free(Olsr_neighbour_label_obj);
-		Olsr_neighbour_label_obj = NULL;
-	}
-
-	tmpNeighbour = Olsr_node_pEtx->olsr_neigh_list;
-
-	Size = 0;
-	while(tmpNeighbour != NULL)
-	{
-		Size++;
-		tmpNeighbour = tmpNeighbour->next_olsr_neigh_list;
-	}
-
-	Olsr_neighbour_label_obj = malloc(Size*sizeof(int));
-	tmpNeighbour = Olsr_node_pEtx->olsr_neigh_list;
-
-	for(i = 0; i < Size ;i++)
-	{
-		char nIpStr[60];
-		float mEtx = ( tmpNeighbour->olsr_con->left_etx + tmpNeighbour->olsr_con->right_etx ) / 2;
-
-		if( mEtx != -1000 )
-			snprintf(nIpStr, 60, "%15s --> %.2f",(strcmp(Olsr_node_pEtx->ip,tmpNeighbour->olsr_con->right_olsr_node->ip)?tmpNeighbour->olsr_con->right_olsr_node->ip:tmpNeighbour->olsr_con->left_olsr_node->ip),mEtx);
-		else
-			snprintf(nIpStr, 60, "%15s --> HNA",(strcmp(Olsr_node_pEtx->ip,tmpNeighbour->olsr_con->right_olsr_node->ip)?tmpNeighbour->olsr_con->right_olsr_node->ip:tmpNeighbour->olsr_con->left_olsr_node->ip));
-
-		Olsr_neighbour_label_obj[i] = s3d_draw_string( nIpStr, &len );
-		s3d_link(Olsr_neighbour_label_obj[i], 0);
-		s3d_flags_on(Olsr_neighbour_label_obj[i], S3D_OF_VISIBLE );
-		s3d_scale(Olsr_neighbour_label_obj[i], 0.2 );
-		s3d_translate(Olsr_neighbour_label_obj[i], -Left*3.0-(len * 0.2)-0.15, -Bottom*3.0-p, -3.0 );
-		tmpNeighbour = tmpNeighbour->next_olsr_neigh_list;
-		p += 0.2;
-		max_len = (len > max_len - 0.2)?len+0.2:max_len;
-		max_len = (Title_len > max_len - 0.2)?len+0.2:max_len;
-		/* printf("title: %f len: %f maxlen: %f %s\n",Title_len,len,max_len-0.2,nIpStr);*/
-	}
-
-	if( Btn_close_id != -1)
-	{
-		if( Output_border[0] == -1 )
-		{
-			for(i = 0; i < 4; i++)
-			{
-				Output_border[i] = s3d_new_object();
-				s3d_push_material( Output_border[i],
-					1.0,1.0,1.0,
-					1.0,1.0,1.0,
-					1.0,1.0,1.0);
-			}
-			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,			-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-1.0, -3.0);
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
-
-			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
-			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
-
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
-
-			s3d_push_line( Output_border[0], 0,1,0);
-			s3d_push_line( Output_border[1], 0,1,0);
-			s3d_push_line( Output_border[2], 0,1,0);
-			s3d_push_line( Output_border[3], 0,1,0);
-
-			s3d_flags_on( Output_border[0], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[1], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[2], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[3], S3D_OF_VISIBLE);
-
-			s3d_link( Output_border[0], 0);
-			s3d_link( Output_border[1], 0);
-			s3d_link( Output_border[2], 0);
-			s3d_link( Output_border[3], 0);
-		} else {
-			s3d_pop_vertex(Output_border[0], 2);
-			s3d_pop_vertex(Output_border[1], 2);
-			s3d_pop_vertex(Output_border[2], 2);
-			s3d_pop_vertex(Output_border[3], 2);
-			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,				-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-1.0, -3.0);
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
-
-			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
-			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p,	 -3.0);
-
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	 -3.0);
-		}
-	}
-}
-
-
-
-/***
- *
- * eventhandler when object change by user
- * such as Cam
- *
- ***/
-
-int olsr_object_info(struct s3d_evt *hrmz)
-{
-	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz->buf;
-	if (!olsr_ready) return(0);
-	s3dw_object_info(hrmz);
-	if (inf->object==0)
-	{
-		CamPosition[0][0] = inf->trans_x;
-		CamPosition[0][1] = inf->trans_y;
-		CamPosition[0][2] = inf->trans_z;
-		CamPosition[1][0] = inf->rot_x;
-		CamPosition[1][1] = inf->rot_y;
-		CamPosition[1][2] = inf->rot_z;
-		Asp=inf->scale;
-		if (Asp>1.0) /* wide screen */
-		{
-			Bottom=-1.0;
-			Left=-Asp;
-		} else {  /* high screen */
-			Bottom=(-1.0/Asp);
-			Left=-1.0;
-
-		}
-
-	}
-	/* printf("%f %f %f\n",inf->trans_x,inf->trans_y,inf->trans_z); */
-	return(0);
-}
-
-int mbutton_press(struct s3d_evt *hrmz)
-{
-	struct s3d_but_info *inf;
-	inf=(struct s3d_but_info *)hrmz->buf;
-	printf("button %d, state %d\n", inf->button,inf->state);
-	return(0);
-}
-
-int olsr_parse_args(int argc, char **argv) {
-	int optchar;
-	strncpy( Olsr_host, "127.0.0.1", 256 );
-	lbuf[0] = '\0';   /* init lbuf */
-	opterr=0;
-
-	while ( ( optchar = getopt ( argc, argv, "dhH:" ) ) != -1 ) {
-
-		switch ( optchar ) {
-
-			case 'd':
-				Debug = 1;
-				break;
-
-			case 'H':
-				strncpy( Olsr_host, optarg, 256 );
-				break;
-
-			case 'h':
-			default:
-				print_usage();
-				return (1);
-			case '?':
-				/* not handled by olsr-part */
-				break;
-		}
-
-	}
-	return(0);
-}
-int olsr_init()
-{
-	if ( Debug )
-		printf( "debug mode enabled ...\n" );
-
-	if (net_init(Olsr_host)) return(1);
-	/* initialize obj2ip linked list */
-	lst_initialize();
-
-	/* set extern int optind = 0 for parse_args in io.c */
-	optind = 0;
-	
-	Olsr_node_obj = s3d_import_model_file( "objs/accesspoint.3ds" );
-	Olsr_node_inet_obj = s3d_import_model_file( "objs/accesspoint_inet.3ds" );
-	Olsr_node_hna_net = s3d_import_model_file( "objs/internet.3ds" );
-	Btn_close_obj = s3d_import_model_file( "objs/btn_close.3ds" );
-
-	S3d_obj = s3d_import_model_file( "objs/s3d_berlios_de.3ds" );
-	s3d_translate( S3d_obj, 0.75, -0.75, -1 );
-	s3d_scale( S3d_obj, 0.07 );
-	s3d_link( S3d_obj, 0 );
-	s3d_flags_on( S3d_obj, S3D_OF_VISIBLE );
-
-	ZeroPoint = s3d_new_object();
-	Output_border[0] = Output_border[1] = Output_border[2] = Output_border[3] = -1;
-	db_olsr_node_init(olsr_node_init);
-
-	s3d_link(ZeroPoint, oidy);
-
-	/* create_search_widget( 0, 0, 300 ); */
-	olsr_ready=1;
-	return(0);
-
-}
-int olsr_quit()
-{
-	if (!olsr_ready) return(0);
-	olsr_ready=0;
-	/* TODO: remove nodes and objects here */
-	net_quit();
-	return(0);
-}
-

Deleted: trunk/apps/s3dosm/process.c
===================================================================
--- trunk/apps/s3dosm/process.c	2007-08-28 16:57:21 UTC (rev 658)
+++ trunk/apps/s3dosm/process.c	2007-09-01 12:49:22 UTC (rev 659)
@@ -1,529 +0,0 @@
-/*
- * process.c
- *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *                         Marek Lindner <lindner_marek at yahoo.de>
- *                         Andreas Langer <andreas_lbg at gmx.de>
- *
- * This file is part of olsrs3d, an olsr topology visualizer for s3d.
- * See http://s3d.berlios.de/ for more updates.
- *
- * olsrs3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * olsrs3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with olsrs3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include <stdio.h> 	/* NULL */
-#include <string.h> 	/* strlen(), memmove() */
-#include <stdlib.h> 	/* rand(), malloc(), realloc(), free() */
-#include <s3d.h>
-#include <math.h>       /* sqrt() */
-#include "olsrs3d.h"
-#include "s3dosm.h"	/* db_check_olsr() */
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-
-
-char lbuf[MAXLINESIZE];
-float olsr_node_init[6]={0,0,0,0,0,0};
-
-
-
-/***
- *
- * create new or alter connection between 2 nodes
- *
- *   con_from =>   current node
- *   con_to   =>   node to connect to
- *   etx      =>   ETX
- *
- ***/
-
-int add_olsr_con( struct olsr_node *con_from, struct olsr_node *con_to, float etx ) {
-
-	struct olsr_con **olsr_con = &Con_begin;
-	struct olsr_con *prev_olsr_con = NULL;   /* previous olsr connection */
-	struct olsr_neigh_list **olsr_neigh_list;
-
-	while ( (*olsr_con) != NULL ) {
-
-		/* connection already exists */
-		if ( ( strncmp( (*olsr_con)->left_olsr_node->ip, con_from->ip, NAMEMAX ) == 0 ) && ( strncmp( (*olsr_con)->right_olsr_node->ip, con_to->ip, NAMEMAX ) == 0 ) ) {
-			(*olsr_con)->left_etx = etx;
-			(*olsr_con)->left_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
-			break;
-
-		} else if ( ( strncmp( (*olsr_con)->right_olsr_node->ip, con_from->ip, NAMEMAX ) == 0 ) && ( strncmp( (*olsr_con)->left_olsr_node->ip, con_to->ip, NAMEMAX ) == 0 ) ) {
-
-			(*olsr_con)->right_etx = etx;
-			(*olsr_con)->right_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
-			break;
-
-		}
-
-		/* save previous olsr connection for later use */
-		prev_olsr_con = (*olsr_con);
-
-		olsr_con = &(*olsr_con)->next_olsr_con;
-
-	}
-
-	/* new connection */
-	if ( (*olsr_con) == NULL ) {
-
-		(*olsr_con) = malloc( sizeof( struct olsr_con ) );
-		if ( (*olsr_con) == NULL ) out_of_mem();
-
-		/* create connection object */
-		(*olsr_con)->obj_id = s3d_new_object();
-
-		/* add olsr node to new olsr connection in order to access the nodes from the connection list */
-		(*olsr_con)->left_olsr_node = con_from;
-		(*olsr_con)->right_olsr_node = con_to;
-
-		/* add connection color */
-		(*olsr_con)->color = 0;
-		s3d_push_material( (*olsr_con)->obj_id,
-				  1.0,1.0,1.0,
-				  1.0,1.0,1.0,
-				  1.0,1.0,1.0);
-
-		/* add connection endpoints */
-		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->left_olsr_node->pos_vec[0], (*olsr_con)->left_olsr_node->pos_vec[1], (*olsr_con)->left_olsr_node->pos_vec[2] );
-		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->right_olsr_node->pos_vec[0], (*olsr_con)->right_olsr_node->pos_vec[1], (*olsr_con)->right_olsr_node->pos_vec[2] );
-
-		s3d_push_line( (*olsr_con)->obj_id, 0,1,0 );
-
-		s3d_flags_on( (*olsr_con)->obj_id, S3D_OF_VISIBLE );
-
-		s3d_link( (*olsr_con)->obj_id,  ZeroPoint );
-
-		/* HNA */
-		if ( etx == -1000.00 ) {
-
-			(*olsr_con)->left_etx = etx;
-			(*olsr_con)->left_etx_sqrt = 10.0;
-			(*olsr_con)->right_etx = etx;
-			(*olsr_con)->right_etx_sqrt = 10.0;
-
-		} else {
-
-			(*olsr_con)->left_etx = etx;
-			(*olsr_con)->left_etx_sqrt = sqrt( etx );
-			(*olsr_con)->right_etx = 999.0;
-			(*olsr_con)->right_etx_sqrt = sqrt( 999.0 );
-
-		}
-
-		(*olsr_con)->next_olsr_con = NULL;
-		(*olsr_con)->prev_olsr_con = prev_olsr_con;
-
-		/* add new olsr connection to olsr nodes in order to access the connection from the olsr node */
-		olsr_neigh_list = &(*olsr_con)->left_olsr_node->olsr_neigh_list;
-		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
-		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
-		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
-		(*olsr_neigh_list)->olsr_con = (*olsr_con);
-		(*olsr_neigh_list)->next_olsr_neigh_list = NULL;
-
-		olsr_neigh_list = &(*olsr_con)->right_olsr_node->olsr_neigh_list;
-		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
-		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
-		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
-		(*olsr_neigh_list)->olsr_con = (*olsr_con);
-		(*olsr_neigh_list)->next_olsr_neigh_list = NULL;
-
-	}
-
-	return(0);
-
-}
-
-
-
-/***
- *
- * get pointer to olsr node or create new node if node string could not be found
- *
- *   **node =>   pointer to current olsr_node
- *   *ip    =>   node ip
- *
- *   return olsr node pointer
- *
- ***/
-void *get_olsr_node( struct olsr_node **olsr_node, char *ip ) {
-
-	int result;   /* result of strcmp */
-
-	while ( (*olsr_node) != NULL ) {
-
-		result = strncmp( (*olsr_node)->ip, ip, NAMEMAX );
-
-		/* we found the node */
-		if ( result == 0 ) {
-
-			(*olsr_node)->last_seen = Output_block_counter;
-
-			/* former invisble (deleted) node */
-			if ( (*olsr_node)->visible == 0 ) {
-				(*olsr_node)->node_type = 0;
-				(*olsr_node)->node_type_modified = 1;
-
-				(*olsr_node)->visible = 1;
-
-				(*olsr_node)->mov_vec[0] = (*olsr_node)->mov_vec[1] = (*olsr_node)->mov_vec[2] = 0.0;
-
-				if ( Debug ) printf( "new olsr node: %s\n", (*olsr_node)->ip );
-
-				Olsr_node_count++;
-
-			}
-
-			return (*olsr_node);
-
-		}
-
-		/* the searched node must be in the subtree */
-		if ( result < 0 ) {
-			olsr_node = &(*olsr_node)->right;
-		} else {
-			olsr_node = &(*olsr_node)->left;
-		}
-
-	}
-
-	/* if node is NULL we reached the end of the tree and must create a new olsr_node */
-	if ( (*olsr_node) == NULL ) {
-
-		(*olsr_node) = malloc( sizeof( struct olsr_node ) );
-		if ( (*olsr_node) == NULL ) out_of_mem();
-
-		(*olsr_node)->left = NULL;
-		(*olsr_node)->right = NULL;
-
-		strncpy( (*olsr_node)->ip, ip, NAMEMAX );
-
-		(*olsr_node)->node_type = 0;
-		(*olsr_node)->node_type_modified = 1;
-
-		(*olsr_node)->last_seen = Output_block_counter;
-		(*olsr_node)->visible = 1;
-
-		if ( Debug ) printf( "new olsr node: %s\n", (*olsr_node)->ip );
-
-		Olsr_node_count++;
-
-		(*olsr_node)->pos_vec[0] = olsr_node_init[0]+ ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)->pos_vec[1] = olsr_node_init[1]+ ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)->pos_vec[2] = olsr_node_init[2]+ ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)->static_node=0;
-
-		if (db_olsr_check((*olsr_node)->ip,(*olsr_node)->pos_vec)) {
-			/* pos_vec will be overwritten if there is a database hit */
-			(*olsr_node)->static_node=1;
-			/* little elevation over the earth */
-		} 
-
-
-		(*olsr_node)->mov_vec[0] = (*olsr_node)->mov_vec[1] = (*olsr_node)->mov_vec[2] = 0.0;
-
-		(*olsr_node)->obj_id = -1;
-		(*olsr_node)->desc_id = -1;
-		(*olsr_node)->olsr_neigh_list = NULL;
-
-		return (*olsr_node);
-
-	}
-	return(0);
-}
-
-/*
- *
- * initialize the struct for a linked list obj2ip
- *
- */
-
-void lst_initialize() {
-	Obj_to_ip_head = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	Obj_to_ip_end = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	if(Obj_to_ip_head == NULL || Obj_to_ip_end == NULL)
-		out_of_mem();
-	Obj_to_ip_head->id = 0;
-	Obj_to_ip_end->id = 0;
-	Obj_to_ip_head->prev = Obj_to_ip_end->prev = Obj_to_ip_head;
-	Obj_to_ip_head->next = Obj_to_ip_end->next = Obj_to_ip_end;
-	List_ptr = Obj_to_ip_head;
-}
-
-/*
- *
- * add a link object_id to olsr_node, to get ip adress and coordinates per object_id
- *                 id => object_id, returned from s3d_clone or s3d_new_object
- *  **olsr_node => pointer to pointer of current olsr_node
- *
- */
-
-void lst_add(int id,struct olsr_node **olsr_node) {
-	struct Obj_to_ip *new;
-	new = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	if(new == NULL)
-		out_of_mem();
-	new->id = id;
-	new->olsr_node = *olsr_node;
-	move_lst_ptr(&id);
-	new->prev = List_ptr;
-	new->next = List_ptr->next;
-	List_ptr->next->prev = new;
-	List_ptr->next = new;
-	/* printf("obj2ip: add object %d between %d .. %d ip %s to list\n",new->id,new->prev->id,new->next->id,new->olsr_node->ip); */
-}
-
-/*
- *void move_lst_ptr(int *id)
- * remove element from obj2ip linked list
- * id => object_id, returned from s3d_clone or s3d_new_object
- *
- */
-
-void lst_del(int id) {
-	struct Obj_to_ip *del;
-	move_lst_ptr(&id);
-	if(id != List_ptr->id)
-	{
-		printf("obj2ip: remove id %d failed move_lst_ptr return id %d\n",id,List_ptr->next->id);
-	} else {
-		del = List_ptr;
-		List_ptr->next->prev = List_ptr->prev;
-		List_ptr->prev->next = List_ptr->next;
-		/* printf("obj2ip: remove object %d --> %d <-- %d ip %s from list\n",List_ptr->prev->id,del->id,List_ptr->next->id,del->olsr_node->ip); */
-		free(del);
-	}
-}
-
-/*
- *
- * move the List_ptr one positon ahead the searched element
- *	*id => pointer of object_id , returned from s3d_clone or s3d_new_object
- *
- */
-
-struct olsr_node *move_lst_ptr(int *id) {
-	/* printf("obj2ip: move for %d\n",*id); */
-	/* head to point at end or id lass then first element in linked list*/
-	if(Obj_to_ip_head->next == Obj_to_ip_head || *id < Obj_to_ip_head->next->id) {
-		List_ptr = Obj_to_ip_head;
-		return NULL;
- 	/* id is greather then last element in linked list */
-	} else if(*id > Obj_to_ip_end->prev->id) {
-		List_ptr = Obj_to_ip_end->prev;
-		return NULL;
-	} else {
-		/* printf("obj2ip: ok i search deeper ;-) for id=%d\n",*id); */
-		if((*id - (int) Obj_to_ip_head->next->id) <= ((int)(Obj_to_ip_end->prev->id)-*id)) {
-			List_ptr = Obj_to_ip_head;
-			/* printf("obj2ip: start at head id %d - %d <= %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id); */
-			while(*id >= List_ptr->next->id) {
-				/* printf("obj2ip: %d > %d move to ",*id,List_ptr->id); */
-				List_ptr = List_ptr->next;
-				/* printf("%d\n",List_ptr->id); */
-			}
-		} else {
-			List_ptr = Obj_to_ip_end;
-			/* printf("obj2ip: start at end id %d - %d > %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id);  */
-			/*  do List_ptr = List_ptr->prev; while(*id > List_ptr->prev->id); */
-			while(*id < List_ptr->prev->id) {
-				/* printf("obj2ip: %d < %d move to ",*id,List_ptr->id); */
-				List_ptr = List_ptr->prev;
-				/* printf("%d\n",List_ptr->id); */
-			}
-			List_ptr = List_ptr->prev;
-		}
-
-		if ( List_ptr->id == *id )
-			return List_ptr->olsr_node;
-		else
-			return NULL;
-
-		/* printf("obj2ip: found id to insert between %d--> .. <--%d to search/delete %d--> .. <--%d\n",List_ptr->id,List_ptr->next->next->id,List_ptr->prev->id,List_ptr->next->id); */
-	}
-}
-
-/*
- *
- * search a object_id in linked list and return pointer on struct olsr_node
- *	id => object_id , returned from s3d_clone or s3d_new_object
- *
- * <example>
- *     struct olsr_node *olsr_node;
- *     olsr_node = *lst_search(oid);
- *     printf("obj2ip: search return %s\n",olsr_node->ip);
- * </example>
- *
- */
-
-struct olsr_node *lst_search(int id) {
-
-	return( move_lst_ptr(&id) );
-
-}
-
-void lst_out() {
-	struct Obj_to_ip *ptr;
-	ptr = Obj_to_ip_head;
-	while(ptr != ptr->next) {
-		printf("id-> %d\n",ptr->id);
-		ptr = ptr->next;
-	}
-}
-
-int process_main() {
-
-	int dn;
-	float f;
-	char *lbuf_ptr, *last_cr_ptr, *con_from, *con_from_end, *con_to, *con_to_end, *etx, *etx_end, *tmpChar;
-	struct olsr_node *olsr_node1;   /* pointer to olsr nodes */
-	struct olsr_node *olsr_node2;
-	int address;
-	char hna_name[NAMEMAX];
-	char hna_node[NAMEMAX];
-
-	lbuf_ptr = lbuf;
-	last_cr_ptr = NULL;
-
-	con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
-	dn = 0;
-
-	/*printf("---lbuf-start---\n%s\n---lbuf-end---\n",lbuf);*/
-
-	while ( (*lbuf_ptr) != '\0' ) {
-
-		/* printf( "%c",(*lbuf_ptr) ); */
-
-		if ( (*lbuf_ptr) == '\n' ) {
-
-			last_cr_ptr = lbuf_ptr;
-			con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
-			dn = 0;
-
-		}
-
-		if ( (*lbuf_ptr) == '"' ) {
-
-			switch ( dn ) {
-
-				case 0:
-					con_from = lbuf_ptr + 1;
-					break;
-				case 1:
-					con_from_end = lbuf_ptr;
-					break;
-				case 2:
-					con_to = lbuf_ptr + 1;
-					break;
-				case 3:
-					con_to_end = lbuf_ptr;
-					break;
-				case 4:
-					etx = lbuf_ptr + 1;
-					break;
-				case 5:
-					etx_end = lbuf_ptr;
-					break;
-
-			}
-
-			if ( ++dn == 6 ) {
-
-				/* terminate strings - but not before 6 times '"' */
-				(*con_from_end) = (*con_to_end) = (*etx_end) = '\0';
-
-				/* printf( "con_from: %s, con_to: %s, etx: %s\n", con_from, con_to, etx ); */
-
-				/* announced network via HNA */
-				if ( strncmp( etx, "HNA", NAMEMAX ) == 0 ) {
-
-					/* connection to internet */
-					if ( strncmp( con_to, "0.0.0.0/0.0.0.0", NAMEMAX ) == 0 ) {
-
-						olsr_node1 = get_olsr_node( &Olsr_root, con_from );
-
-						if ( olsr_node1->node_type != 1 ) {
-
-							olsr_node1->node_type = 1;
-							olsr_node1->node_type_modified = 1;
-							if ( Debug ) printf( "new internet: %s\n", olsr_node1->ip );
-
-						}
-
-					/* normal HNA */
-					} else {
-						memmove(hna_node,con_to,NAMEMAX);
-						if( (tmpChar = strchr(hna_node, (int)'/')))
-						{
-							tmpChar++;
-							address = (int)-inet_network(tmpChar);
-							sprintf(hna_name,"%d",(int)(32 - ceil(log(address)/log(2))));
-							strcpy(tmpChar,hna_name);
-						}
-
-						olsr_node1 = get_olsr_node( &Olsr_root, con_from );
-						olsr_node2 = get_olsr_node( &Olsr_root, hna_node );
-
-						if ( olsr_node2->node_type != 2 ) {
-
-							olsr_node2->node_type = 2;
-							olsr_node2->node_type_modified = 1;
-							if ( Debug ) printf( "new hna network: %s\n", olsr_node2->ip );
-
-						}
-						if ( olsr_node1->visible && olsr_node2->visible )
-							add_olsr_con( olsr_node1, olsr_node2, -1000.00 );
-
-					}
-
-				/* normal node */
-				} else {
-
-					olsr_node1 = get_olsr_node( &Olsr_root, con_from );
-					olsr_node2 = get_olsr_node( &Olsr_root, con_to );
-					f = strtod(etx,NULL);
-					if ( f < 1.0 )
-						f = 999.0;
-					add_olsr_con( olsr_node1, olsr_node2, f );
-				}
-				/* remove zerobyte */
-				(*con_from_end) = (*con_to_end) = (*etx_end) = '"';
-
-				con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
-				dn = 0;
-				last_cr_ptr = lbuf_ptr;
-
-			}
-
-		} else if ( ( (*lbuf_ptr) == '}' ) && ( (*(lbuf_ptr + 1)) == '\n' ) ) {
-
-			Output_block_completed = 1;
-
-		}
-
-		lbuf_ptr++;
-
-	}
-
-	if ( last_cr_ptr != NULL ) memmove( lbuf, last_cr_ptr + 1, strlen( last_cr_ptr ) );
-	/*printf("---memmove-lbuf-start---\n%s\n---memmove-lbuf-end---\n",lbuf);*/
-	return(0);
-
-}

Deleted: trunk/apps/s3dosm/search.c
===================================================================
--- trunk/apps/s3dosm/search.c	2007-08-28 16:57:21 UTC (rev 658)
+++ trunk/apps/s3dosm/search.c	2007-09-01 12:49:22 UTC (rev 659)
@@ -1,387 +0,0 @@
-/*
- * search.c
- *
- * Copyright (C) 2006 Andreas Langer <andreas_lbg at gmx.de>
- *
- * This file is part of the olsrs3d, an olsr topology visualizer for s3d.
- * See http://s3d.berlios.de/ for more updates.
- *
- * olsrs3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * olsrs3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with olsrs3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include <s3d.h>
-#include <s3dw.h>
-#include <s3d_keysym.h>
-#include <math.h>
-#include <stdio.h>	/* TODO can remove then no more printf needed */
-#include <string.h>
-#include "olsrs3d.h"	/* for window_error(), structs */
-/* #include "structs.h"  already included by olsrs3d.h */
-#include "search.h"
-
-s3dw_surface	*_search_surface;
-s3dw_input		*_search_input;
-s3dw_widget		*_search_widget;
-
-struct olsr_node *_node_root = NULL;
-struct olsr_node **search_node = NULL;
-
-float	_return_point[2][3];				/* cam position before move to the widget */
-int		_search_status = NOTHING;			/* status of search */
-
-void _search_node(s3dw_widget *dummy);
-void _new_search_node(s3dw_widget *dummy);
-void _abort_search(s3dw_widget *dummy);
-
-
-/* public */
-void follow_node(float cam_position_t[], float cam_position_r[],float rotate)
-{
-	float real_node_pos[3],
-		  cam_target[3],
-		  tmp_vec[3],
-		  diff_vec[3],
-		  angle;
-
-	real_node_pos[0] =  (*search_node)->pos_vec[0] * cos( rotate * M_PI / 180.0 ) - (*search_node)->pos_vec[2] * -sin ( rotate * M_PI / 180.0 );
-	real_node_pos[1] =  (*search_node)->pos_vec[1];
-	real_node_pos[2] =  (*search_node)->pos_vec[0] * -sin( rotate * M_PI / 180.0) + (*search_node)->pos_vec[2] * cos ( rotate * M_PI / 180.0 );
-
-	cam_target[0] = ( real_node_pos[0] + 7);
-	cam_target[1] =   real_node_pos[1];
-	cam_target[2] = ( real_node_pos[2] + 7);
-
-	cam_position_t[0]=( cam_position_t[0] * 4 + cam_target[0] ) / 5;
-	cam_position_t[1]=( cam_position_t[1] * 4 + cam_target[1] ) / 5;
-	cam_position_t[2]=( cam_position_t[2] * 4 + cam_target[2] ) / 5;
-
-	tmp_vec[0] =  0.0;
-	tmp_vec[1] =  0.0;
-	tmp_vec[2] = -1.0;
-
-	diff_vec[0] = cam_position_t[0] - real_node_pos[0];
-	diff_vec[1] = 0.0;
-	diff_vec[2] = cam_position_t[2] - real_node_pos[2];
-	angle = s3d_vector_angle( diff_vec, tmp_vec );
-	/* angle = ( real_node_pos[0] > 0) ? ( 180 - ( 180 / M_PI * angle ) ) : ( 180 + ( 180 / M_PI * angle ) ); */
-	angle = 180 - ( 180 / M_PI * angle );
-	cam_position_r[1] = ( cam_position_r[1] * 4 + angle ) / 5;
-
-	s3d_translate( 0, cam_position_t[0], cam_position_t[1], cam_position_t[2] );
-	s3d_rotate( 0, cam_position_r[0], cam_position_r[1], cam_position_r[2] );
-}
-void _abort_search_window(s3dw_widget *bwidget)
-{
-	s3dw_delete(bwidget->parent); /* remove the window cointaining the button */
-	_search_surface=NULL;
-	_search_input=NULL;
-	_search_widget=NULL;
-	set_search_status(NOTHING);
-}
-void show_search_window()
-{
-	s3dw_button *search_button, *abort_button;
-
-	_search_surface	= s3dw_surface_new( "Node Search", 17, 10 );
-	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
-
-	s3dw_label_new( _search_surface, "Enter the IP of the node.", 1, 2);
-	s3dw_focus( S3DWIDGET( _search_input ) );
-
-	search_button = s3dw_button_new( _search_surface, "Search", 11.5, 7 );
-	abort_button  = s3dw_button_new( _search_surface, "Abort", 1, 7 );
-	search_button->onclick = _new_search_node;
-	abort_button->onclick = _abort_search_window;
-
-	/* TODO calc position for ok button */
-
-	s3dw_focus	( S3DWIDGET( _search_input ) );
-	s3dw_focus	( S3DWIDGET( _search_surface ) );
-	s3dw_show	( S3DWIDGET( _search_surface ) );
-
-	_search_widget	= S3DWIDGET(search_button);
-}
-
-/* public */
-void create_search_widget(float x, float y, float z)
-{
-	s3dw_button *search_button, *abort_button;
-
-	_search_surface	= s3dw_surface_new( "Node Search", 17, 10 );
-	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
-
-	s3dw_label_new( _search_surface, "Enter the IP of the node.", 1, 2);
-	s3dw_focus( S3DWIDGET( _search_input ) );
-
-	search_button = s3dw_button_new( _search_surface, "Search", 11.5, 7 );
-	abort_button  = s3dw_button_new( _search_surface, "Abort", 1, 7 );
-	search_button->onclick = _search_node;
-	abort_button->onclick = _abort_search;
-
-	/* TODO calc position for ok button */
-
-	s3dw_focus	( S3DWIDGET( _search_input ) );
-	s3dw_focus	( S3DWIDGET( _search_surface ) );
-	s3dw_show	( S3DWIDGET( _search_surface ) );
-
-	/* disabled for autofollowing mode */
-	/*_search_widget	= s3dw_getroot();
-	move_search_widget( x, y, z );
-
-	_search_widget->ary = 180;
-	s3d_rotate( _search_widget->oid, _search_widget->arx, _search_widget->ary, _search_widget->arz );*/
-}
-
-/* public */
-void move_search_widget(float x, float y, float z)
-{
-	_search_widget->x = x; _search_widget->y = y; _search_widget->z = z;
-	s3dw_moveit( _search_widget );
-}
-
-/* public */
-void move_to_search_widget(float cam_position_t[], float cam_position_r[])
-{
-	float target, current;
-
-	set_search_status(WIDGET);
-	cam_position_t[0] = ( cam_position_t[0] * 4 + _search_widget->x ) / 5;
-	cam_position_t[1] = ( cam_position_t[1] * 4 + _search_widget->y ) / 5;
-	cam_position_t[2] = ( cam_position_t[2] * 4 + ( _search_widget->z - 10 ) ) / 5;
-
-	target = _search_widget->arx;
-	current = cam_position_r[0];
-
-	if( _search_widget->arx - cam_position_r[0] > 180 )
-		target -= 360;
-	if( _search_widget->arx - cam_position_r[0] < -180 )
-		current -= 360;
-	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
-
-	target = _search_widget->ary;
-	current = cam_position_r[1];
-
-	if( _search_widget->ary - cam_position_r[1] > 180 )
-		target -= 360;
-	if( _search_widget->ary - cam_position_r[1] < -180 )
-		current -= 360;
-	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
-
-	target = _search_widget->arz;
-	current = cam_position_r[2];
-
-	if( _search_widget->arz - cam_position_r[2] > 180 )
-		target -= 360;
-	if( _search_widget->arz - cam_position_r[2] < -180 )
-		current -= 360;
-	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
-
-	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
-	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
-
-	if ( sqrt(  (( cam_position_t[0] - _search_widget->x)*( cam_position_t[0] - _search_widget->x)) +
-				(( cam_position_t[1] - _search_widget->y)*( cam_position_t[1] - _search_widget->y)) +
-				(( cam_position_t[2] - _search_widget->z)*( cam_position_t[2] - _search_widget->z)) ) < 0.2 )
-	{
-		s3d_translate( 0, _search_widget->x, _search_widget->y, ( _search_widget->z - 10 ) );
-		s3d_rotate( 0, _search_widget->arx, _search_widget->ary, _search_widget->arz );
-	}
-}
-
-/* public */
-void move_to_return_point(float cam_position_t[], float cam_position_r[])
-{
-	float target, current;
-
-	cam_position_t[0] = ( cam_position_t[0] * 4 + _return_point[0][0] ) / 5;
-	cam_position_t[1] = ( cam_position_t[1] * 4 + _return_point[0][1] ) / 5;
-	cam_position_t[2] = ( cam_position_t[2] * 4 + _return_point[0][2] ) / 5;
-
-	target = _return_point[1][0];
-	current = cam_position_r[0];
-
-	if( _return_point[1][0] - cam_position_r[0] > 180 )
-		target -= 360;
-	if( _return_point[1][0] - cam_position_r[0] < -180 )
-		current -= 360;
-	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
-
-	target = _return_point[1][1];
-	current = cam_position_r[1];
-
-	if( _return_point[1][1] - cam_position_r[1] > 180 )
-		target -= 360;
-	if( _return_point[1][1] - cam_position_r[1] < -180 )
-		current -= 360;
-	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
-
-	target = _return_point[1][2];
-	current = cam_position_r[2];
-
-	if( _return_point[1][2] - cam_position_r[2] > 180 )
-		target -= 360;
-	if( _return_point[1][2] - cam_position_r[2] < -180 )
-		current -= 360;
-	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
-
-	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
-	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
-
-	if ( sqrt(  (( cam_position_t[0] - _return_point[0][0])*( cam_position_t[0] - _return_point[0][0])) +
-				(( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) +
-				(( cam_position_t[2] - _return_point[0][2])*( cam_position_t[2] - _return_point[0][2])) ) < 0.2 )
-	{
-		s3d_translate( 0, _return_point[0][0], _return_point[0][1], _return_point[0][2] );
-		s3d_rotate( 0, _return_point[1][0], _return_point[1][1], _return_point[1][2] );
-		set_search_status(NOTHING);
-	}
-}
-
-/* public */
-/* TODO: WTF?!
- * please fix:
- *  - s is not initialized but still strlen() is used?!
- *  - s will vanish after the function is processed. global variable would be better
- *  - don't forget the terminating \0 after writing a key */
-void search_widget_write(int key)
-{
-	static char s[20];
-	int ln = strlen(s);
-
-	if( key == S3DK_COMMA ) key = S3DK_PERIOD;
-
-	if( key != S3DK_RETURN )
-	{
-		if( key == S3DK_BACKSPACE )
-		{
-			if( ln > 0 )
-				s[ln-1] = '\0';
-		} else {
-			if( ln < 20 )
-				s[ln] = key;
-		}
-		s3dw_input_change_text( _search_input, s );
-	} else {
-		_new_search_node( _search_widget );
-	}
-}
-
-/* public */
-void set_return_point(float cam_position_t[], float cam_position_r[])
-{
-	int i;
-	for( i = 0; i < 3; i++ )
-		_return_point[0][i] = cam_position_t[i];
-	for( i = 0; i < 3; i++ )
-		_return_point[1][i] = cam_position_r[i];
-}
-
-/* public */
-int get_search_status(void)
-{
-	return _search_status;
-}
-
-/* public */
-void set_search_status(int stat)
-{
-	/* TODO check if stat between 0-3 else debug printf */
-	_search_status = stat;
-}
-
-/* public */
-void set_node_root(struct olsr_node *root)
-{
-	_node_root = root;
-}
-/* private */
-void _new_search_node(s3dw_widget *dummy)
-{
-	char *ip;
-	int result;
-
-	search_node = &_node_root;
-
-	ip = s3dw_input_gettext( _search_input );
-
-	while ( (*search_node) != NULL )
-	{
-
-		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
-
-		if ( result == 0 )
-			break;
-
-		if ( result < 0 )
-			(*search_node) = (*search_node)->right;
-		else
-			(*search_node) = (*search_node)->left;
-	}
-	s3dw_delete(dummy->parent); /* remove the window cointaining the button */
-	_search_surface=NULL;
-	_search_input=NULL;
-	_search_widget=NULL;
-
-
-	if( (*search_node) != NULL )
-	{
-		set_search_status( FOLLOW );
-	}
-	else
-	{
-		window_error("Sorry, could not find...");
-		set_search_status( NOTHING );
-	}
-}
-/* public */
-void follow_node_by_click(struct olsr_node *olsr_node) {
-	search_node = &_node_root;
-	(*search_node) = olsr_node;
-	set_search_status( FOLLOW );
-}
-
-/* private */
-void _search_node(s3dw_widget *dummy)
-{
-	char *ip;
-	int result;
-
-	search_node = &_node_root;
-
-	ip = s3dw_input_gettext( _search_input );
-
-	while ( (*search_node) != NULL )
-	{
-
-		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
-
-		if ( result == 0 )
-			break;
-
-		if ( result < 0 )
-			(*search_node) = (*search_node)->right;
-		else
-			(*search_node) = (*search_node)->left;
-	}
-
-	if( (*search_node) != NULL )
-		set_search_status( FOLLOW );
-}
-
-/* private */
-void _abort_search(s3dw_widget *dummy)
-{
-	set_search_status(ABORT);
-}

Modified: trunk/apps/s3dosm/ui.c
===================================================================
--- trunk/apps/s3dosm/ui.c	2007-08-28 16:57:21 UTC (rev 658)
+++ trunk/apps/s3dosm/ui.c	2007-09-01 12:49:22 UTC (rev 659)
@@ -108,7 +108,6 @@
 	int oid=(int)*((uint32_t *)evt->buf);
 	char query[MAXQ];
 	if (s3dw_handle_click(evt)) return(0);
-	if (olsr_object_click(evt)) return(0);
 	snprintf(query,MAXQ,"SELECT * FROM node WHERE s3doid=%d;",oid);
 	db_exec(query, ui_getinfo_node, 0);
 	snprintf(query,MAXQ,"SELECT * FROM way WHERE s3doid=%d;",oid);
@@ -120,13 +119,11 @@
 {
 /*	struct s3d_key_event *key=(struct s3d_key_event *)evt->buf;*/
 	if (s3dw_handle_key(evt)) return(0);
-	if (olsr_keypress(evt)) return(0);
 	return(0);
 }
 int ui_oinfo(struct s3d_evt *evt)
 {
 	s3dw_object_info(evt);	
-	olsr_object_info(evt);
 	return(0);
 }
 int ui_init()



From dotslash at mail.berlios.de  Sat Sep  1 14:49:33 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 1 Sep 2007 14:49:33 +0200
Subject: [S3d-svn] r660 - in trunk: . apps/s3dosm
Message-ID: <200709011249.l81CnX8X019765@sheep.berlios.de>

Author: dotslash
Date: 2007-09-01 14:49:32 +0200 (Sat, 01 Sep 2007)
New Revision: 660

Modified:
   trunk/
   trunk/apps/s3dosm/db.c
Log:
 r2294 at kero:  dotslash | 2007-09-01 14:49:18 +0200
 - forgot to update filename



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2272
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2294

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2007-09-01 12:49:22 UTC (rev 659)
+++ trunk/apps/s3dosm/db.c	2007-09-01 12:49:32 UTC (rev 660)
@@ -1,5 +1,5 @@
 /*
- * kismet.c
+ * db.c
  * 
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *



From dotslash at mail.berlios.de  Sun Sep  2 11:39:41 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 2 Sep 2007 11:39:41 +0200
Subject: [S3d-svn] r661 - in trunk: . server
Message-ID: <200709020939.l829dfaA023995@sheep.berlios.de>

Author: dotslash
Date: 2007-09-02 11:39:40 +0200 (Sun, 02 Sep 2007)
New Revision: 661

Modified:
   trunk/
   trunk/server/event.c
   trunk/server/global.h
   trunk/server/graphics.c
   trunk/server/main.c
   trunk/server/mcp.c
   trunk/server/object.c
   trunk/server/process.c
   trunk/server/proto.c
   trunk/server/shm_ringbuf.c
Log:
 r2297 at kero:  dotslash | 2007-09-02 11:39:35 +0200
 - change most of the ids from uint32_t to int32_t. I wonder what hit me when I changed them all to unsigned ...
 - remove the compiler warnings in the server



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2294
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2297

Modified: trunk/server/event.c
===================================================================
--- trunk/server/event.c	2007-09-01 12:49:32 UTC (rev 660)
+++ trunk/server/event.c	2007-09-02 09:39:40 UTC (rev 661)
@@ -35,7 +35,7 @@
 extern int winw,winh; /* to give aspect ratio to the program */
 /*  I don't plan to keep this until the end, but it can show us how */
 /*  to interact ... */
-int event_obj_click(struct t_process *p, uint32_t oid)
+int event_obj_click(struct t_process *p, int32_t oid)
 {
 	uint32_t moid=htonl(oid);
 	s3dprintf(MED,"telling client that oid %d got clicked",oid);
@@ -53,7 +53,7 @@
 	k[1]=htons(uni);
 	k[2]=htons(mod);
 	k[3]=htons(state);
-	if (obj_valid(get_proc_by_pid(MCP),focus_oid,o))
+	if (OBJ_VALID(get_proc_by_pid(MCP),focus_oid,o))
 		prot_com_out(get_proc_by_pid(o->n_mat), S3D_P_S_KEY, (uint8_t *)k, 8);
 	prot_com_out(get_proc_by_pid(MCP),S3D_P_S_KEY,(uint8_t *)k, 8); /* mcp always gets a copy */
 	return(0);
@@ -67,7 +67,7 @@
 	uint8_t b[2];
 	b[0]=button;
 	b[1]=state;
-	if (obj_valid(get_proc_by_pid(MCP),focus_oid,o))
+	if (OBJ_VALID(get_proc_by_pid(MCP),focus_oid,o))
 		prot_com_out(get_proc_by_pid(o->n_mat), S3D_P_S_MBUTTON, (uint8_t *)&b, 2);
 	prot_com_out(get_proc_by_pid(MCP),S3D_P_S_MBUTTON,(uint8_t *)&b, 2); /* mcp always gets a copy */
 	return(0);
@@ -95,7 +95,7 @@
 	struct t_obj	 *o;
 	p=get_proc_by_pid(MCP);
 	event_obj_info(p,0);
-	if (obj_valid(p,focus_oid,o))
+	if (OBJ_VALID(p,focus_oid,o))
 		event_obj_info(get_proc_by_pid(o->n_mat),0);
 	return(0);
 }
@@ -106,7 +106,7 @@
 	struct t_obj	 *o;
 	p=get_proc_by_pid(MCP);
 	event_obj_info(p,get_pointer(p));
-	if (obj_valid(p,focus_oid,o))
+	if (OBJ_VALID(p,focus_oid,o))
 	{
 		p=get_proc_by_pid(o->n_mat); /* focused program pointer*/
 		event_obj_info(p,get_pointer(p));
@@ -115,12 +115,12 @@
 }
 
 /* this should replace the mcp_rep_object() function later ... */
-int event_obj_info(struct t_process *p, uint32_t oid)
+int event_obj_info(struct t_process *p, int32_t oid)
 {
 	struct t_obj_info mo;
 	struct t_process *ap;
 	struct t_obj *o;
-	if (obj_valid(p,oid,o))
+	if (OBJ_VALID(p,oid,o))
 	{
 		mo.object=htonl(oid);
 		mo.trans_x=p->object[oid]->translate.x;

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2007-09-01 12:49:32 UTC (rev 660)
+++ trunk/server/global.h	2007-09-02 09:39:40 UTC (rev 661)
@@ -63,7 +63,7 @@
 
 #define RB_OVERHEAD		sizeof(struct buf_t)
 
-#define obj_valid(p,oid,o)	((oid<p->n_obj) && ((o=p->object[oid])!=NULL))
+#define OBJ_VALID(p,oid,o)	(oid >= 0) && ((oid < p->n_obj) && ((o=p->object[oid])!=NULL))
 typedef float t_mtrx[16];
 
 struct buf_t
@@ -104,7 +104,7 @@
 	float amb_r,amb_g,amb_b,amb_a, 			 /*  ambience */
 		  spec_r,spec_g,spec_b,spec_a,	 	 /*  specualar */
 		  diff_r,diff_g,diff_b,diff_a;		 /*  diffusion */
-	uint32_t tex;							 /*  texture index, -1 if there is no */
+	int32_t tex;							 /*  texture index, -1 if there is no */
 };
 /*  this defines a texture */
 struct t_tex
@@ -114,7 +114,7 @@
 	uint8_t *buf;		 /*  the data */
 	float xs,ys;		 /*  scale data for gl-implementations which require 2^x */
 						 /*  texture sizes. */
-	uint32_t gl_texnum;	 /*  the gl texture number. */
+	int32_t gl_texnum;	 /*  the gl texture number. */
 };
 /*  the object type */
 struct t_obj
@@ -145,13 +145,13 @@
 #define OF_3DPOINTER	0xB0000000
 
 #define OF_MASK			0x00FFFFFF
-		uint32_t n_vertex, n_mat, n_poly, n_tex, n_line;
+		int32_t n_vertex, n_mat, n_poly, n_tex, n_line;
 					 /*  if OF_VIRTUAL is set, n_mat contains the pid */
 					 /*  if OF_CLONE is set, n_vertex contains the original oid */
 					 /*  I know this is dirty, but it would a waste of data if I don't do so ... */
-		uint32_t dplist;	 /*  opengl display list number */
-		uint32_t linkid;	 /*  linking target, -1 if there is none */
-		uint32_t lsub,lnext,lprev;
+		int32_t dplist;		 /*  opengl display list number */
+		int32_t linkid;		 /*  linking target, -1 if there is none */
+		int32_t lsub,lnext,lprev;
 		 /*  pointer to our objects; */
 		struct t_vertex *p_vertex;
 		struct t_mat	*p_mat;
@@ -179,9 +179,9 @@
 {
 	char 				  name[NAME_MAX];		 /*  process name */
 	struct t_obj		**object;				 /*  initial pointer to object list */
-	uint32_t			  n_obj;				 /*  number of objects */
-	uint32_t			  biggest_obj;			 /*  the biggest object */
-	uint32_t			  mcp_oid;				 /*  oid in mcp */
+	int32_t				  n_obj;				 /*  number of objects */
+	int32_t				  biggest_obj;			 /*  the biggest object */
+	int32_t				  mcp_oid;				 /*  oid in mcp */
 	int 				  id;					 /*  pid */
 	int					  con_type;				 /*  type of connection, one of following: */
 #define CON_NULL	0
@@ -197,7 +197,7 @@
 
 struct t_obj_info 
 {
-	uint32_t object;
+	int32_t object;
 	uint32_t flags;
 	float trans_x,trans_y,trans_z;
 	float rot_x,rot_y,rot_z;
@@ -252,8 +252,8 @@
 int prot_com_in(struct t_process *p, uint8_t *pbuf);
 int prot_com_out(struct t_process *p, uint8_t opcode, uint8_t *buf, uint16_t length);
 /* event.c */
-int event_obj_info(struct t_process *p, uint32_t oid);
-int event_obj_click(struct t_process *p, uint32_t oid);
+int event_obj_info(struct t_process *p, int32_t oid);
+int event_obj_click(struct t_process *p, int32_t oid);
 int event_key_pressed(uint16_t key, uint16_t uni, uint16_t mod, int state);
 int event_mbutton_clicked(uint8_t button, uint8_t state);
 int event_cam_changed(void);
@@ -328,53 +328,53 @@
 struct t_process *process_protinit(struct t_process *p, char *name);
 struct t_process *get_proc_by_pid(int pid);
 /*  object.c */
-int obj_debug			(struct t_process *p, uint32_t oid);
+int obj_debug			(struct t_process *p, int32_t oid);
 int obj_new				(struct t_process *p);
-int obj_clone			(struct t_process *p, uint32_t oid);
-int obj_clone_change	(struct t_process *p, uint32_t oid, uint32_t toid);
-int obj_link			(struct t_process *p, uint32_t oid_from, uint32_t oid_to);
-int obj_unlink			(struct t_process *p, uint32_t oid);
-int obj_del				(struct t_process *p, uint32_t oid);
-int obj_push_vertex		(struct t_process *p, uint32_t oid, float *x, uint32_t n);
-int obj_push_mat		(struct t_process *p, uint32_t oid, float *x, uint32_t n);
-int obj_push_poly		(struct t_process *p, uint32_t oid, uint32_t *x, uint32_t n);
-int obj_push_line		(struct t_process *p, uint32_t oid, uint32_t *x, uint32_t n);
-int obj_push_tex		(struct t_process *p, uint32_t oid, uint16_t *x, uint32_t n);
-int obj_pep_poly_normal	(struct t_process *p, uint32_t oid, float *x, uint32_t n);
-int obj_pep_line_normal (struct t_process *p, uint32_t oid, float *x, uint32_t n);
-int obj_pep_poly_texc	(struct t_process *p, uint32_t oid, float *x, uint32_t  n);
-int obj_pep_mat			(struct t_process *p, uint32_t oid, float *x, uint32_t n);
-int obj_pep_mat_tex		(struct t_process *p, uint32_t oid, uint32_t *x, uint32_t n);
-int obj_pep_vertex		(struct t_process *p, uint32_t oid, float *x, uint32_t n);
-int obj_pep_line		(struct t_process *p, uint32_t oid, uint32_t *x, uint32_t n);
-int obj_load_poly_normal(struct t_process *p, uint32_t oid, float *x, uint32_t start, uint32_t n);
-int obj_load_line_normal(struct t_process *p, uint32_t oid, float *x, uint32_t start, uint32_t n);
-int obj_load_poly_texc	(struct t_process *p, uint32_t oid, float *x, uint32_t start, uint32_t n);
-int obj_load_mat		(struct t_process *p, uint32_t oid, float *x, uint32_t start, uint32_t n);
-int obj_load_tex		(struct t_process *p, uint32_t oid, uint32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf);
-int obj_del_vertex		(struct t_process *p, uint32_t oid, uint32_t n);
-int obj_del_mat			(struct t_process *p, uint32_t oid, uint32_t n);
-int obj_del_poly		(struct t_process *p, uint32_t oid, uint32_t n);
-int obj_del_line		(struct t_process *p, uint32_t oid, uint32_t n);
-int obj_del_tex			(struct t_process *p, uint32_t oid, uint32_t n);
-int obj_toggle_flags	(struct t_process *p, uint32_t oid, uint8_t type, uint32_t flags);
-int obj_translate		(struct t_process *p, uint32_t oid, float *transv);
-int obj_rotate			(struct t_process *p, uint32_t oid, float *rotv);
-int obj_scale			(struct t_process *p, uint32_t oid, float scav);
-int obj_render			(struct t_process *p, uint32_t oid);
-int obj_free			(struct t_process *p, uint32_t oid);
+int obj_clone			(struct t_process *p, int32_t oid);
+int obj_clone_change	(struct t_process *p, int32_t oid, int32_t toid);
+int obj_link			(struct t_process *p, int32_t oid_from, int32_t oid_to);
+int obj_unlink			(struct t_process *p, int32_t oid);
+int obj_del				(struct t_process *p, int32_t oid);
+int obj_push_vertex		(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_push_mat		(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_push_poly		(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
+int obj_push_line		(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
+int obj_push_tex		(struct t_process *p, int32_t oid, uint16_t *x, int32_t n);
+int obj_pep_poly_normal	(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_pep_line_normal (struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_pep_poly_texc	(struct t_process *p, int32_t oid, float *x, int32_t  n);
+int obj_pep_mat			(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_pep_mat_tex		(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
+int obj_pep_vertex		(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_pep_line		(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
+int obj_load_poly_normal(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
+int obj_load_line_normal(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
+int obj_load_poly_texc	(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
+int obj_load_mat		(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
+int obj_load_tex		(struct t_process *p, int32_t oid, int32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf);
+int obj_del_vertex		(struct t_process *p, int32_t oid, int32_t n);
+int obj_del_mat			(struct t_process *p, int32_t oid, int32_t n);
+int obj_del_poly		(struct t_process *p, int32_t oid, int32_t n);
+int obj_del_line		(struct t_process *p, int32_t oid, int32_t n);
+int obj_del_tex			(struct t_process *p, int32_t oid, int32_t n);
+int obj_toggle_flags	(struct t_process *p, int32_t oid, uint8_t type, uint32_t flags);
+int obj_translate		(struct t_process *p, int32_t oid, float *transv);
+int obj_rotate			(struct t_process *p, int32_t oid, float *rotv);
+int obj_scale			(struct t_process *p, int32_t oid, float scav);
+int obj_render			(struct t_process *p, int32_t oid);
+int obj_free			(struct t_process *p, int32_t oid);
 void obj_get_maximum	(struct t_process *p, struct t_obj *obj);
 void into_position		(struct t_process *p, struct t_obj *obj, int depth);
-void obj_recalc_tmat	(struct t_process *p, uint32_t oid);
-void obj_size_update	(struct t_process *p, uint32_t oid);
-void obj_pos_update(struct t_process *p, uint32_t oid, uint32_t first_oid);
-void obj_check_biggest_object(struct t_process *p, uint32_t oid);
-uint32_t get_pointer(struct t_process *p);
-void link_delete(struct t_process *p, uint32_t oid);
-void link_insert(struct t_process *p, uint32_t oid, uint32_t target);
+void obj_recalc_tmat	(struct t_process *p, int32_t oid);
+void obj_size_update	(struct t_process *p, int32_t oid);
+void obj_pos_update(struct t_process *p, int32_t oid, int32_t first_oid);
+void obj_check_biggest_object(struct t_process *p, int32_t oid);
+int32_t get_pointer(struct t_process *p);
+void link_delete(struct t_process *p, int32_t oid);
+void link_insert(struct t_process *p, int32_t oid, int32_t target);
 /*  mcp.c */
-int mcp_rep_object(uint32_t mcp_oid);
-int mcp_del_object(uint32_t mcp_oid);
+int mcp_rep_object(int32_t mcp_oid);
+int mcp_del_object(int32_t mcp_oid);
 int mcp_init(void);
 int mcp_focus(int oid);
 /*  matrix.c */

Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2007-09-01 12:49:32 UTC (rev 660)
+++ trunk/server/graphics.c	2007-09-02 09:39:40 UTC (rev 661)
@@ -123,7 +123,7 @@
 {
 	struct t_process *ap;
 	struct t_vertex x,y;
-	uint32_t j,k;
+	int32_t j,k;
 	t_mtrx m;
 
 	glPushMatrix();
@@ -171,11 +171,11 @@
 int render_by_mcp()
 {
 	struct t_process *p=get_proc_by_pid(MCP);
-	uint32_t i;
+	int32_t i;
 	struct t_obj *o;
 	struct t_vertex x,y;
 	int k;
-	for (i=0;i<p->n_obj;i++)
+	for (i=0 ; i < p->n_obj ; i++)
 	{   /* check all mcp objects ... */
 		o=p->object[i];
 		if (o!=NULL)
@@ -247,9 +247,10 @@
 	GLint viewport[4];
 	GLfloat xpos,ypos;
 	float big,z1,z2;
-	uint32_t mcp_o,o;
+	int32_t mcp_o,o;
 	struct t_process *p=get_proc_by_pid(MCP);
-	GLuint select_buf[SBSIZE],*ptr,names,hits;
+	GLuint select_buf[SBSIZE],*ptr;
+	int hits, names;
 	t_mtrx m;
 
 	select_mode=1;
@@ -286,14 +287,14 @@
 	render_by_mcp();
 	glFlush();
 	hits=glRenderMode(GL_RENDER);
-	if (hits>0)
+	if ( hits > 0 )
 	{
 		big=INFINITY;
 		s3dprintf(LOW,"had %d hits",hits);
 		ptr=select_buf;
-		mcp_o=o=names=-1;
+		mcp_o= o= names= -1;
 		/* check all the hits, only select the nearest ... */
-		for (i=0;i<hits;i++)
+		for (i=0 ; i < hits ; i++)
 		{
 			names=*ptr;						ptr++;
 			z1=(float)*ptr/0x7fffffff;		ptr++;

Modified: trunk/server/main.c
===================================================================
--- trunk/server/main.c	2007-09-01 12:49:32 UTC (rev 660)
+++ trunk/server/main.c	2007-09-02 09:39:40 UTC (rev 661)
@@ -92,7 +92,7 @@
 		 * and all his sockets up */
 		while (!running)  
 			nanosleep(&t,NULL); 	
-		for (i=0;i<(sizeof(s3drc)/sizeof(char **));i++)
+		for (i=0 ; i < ((int)(sizeof(s3drc)/sizeof(char **))) ; i++)
 		{
 			if ((*s3drc[i])!=NULL)
 			{

Modified: trunk/server/mcp.c
===================================================================
--- trunk/server/mcp.c	2007-09-01 12:49:32 UTC (rev 660)
+++ trunk/server/mcp.c	2007-09-02 09:39:40 UTC (rev 661)
@@ -68,7 +68,7 @@
 	return(0);
 }
 /*  report the mcp about our object */
-int mcp_rep_object(uint32_t mcp_oid)
+int mcp_rep_object(int32_t mcp_oid)
 {
 	struct mcp_object mo;
 	struct t_process *p,*ap;
@@ -85,9 +85,9 @@
 	return(0);
 }
 /* tells the mcp that some program vanished ... */
-int mcp_del_object(uint32_t mcp_oid)
+int mcp_del_object(int32_t mcp_oid)
 {
-	uint32_t oid=htonl(mcp_oid);
+	int32_t oid=htonl(mcp_oid);
 	if (mcp_oid==focus_oid)
 	{
 		s3dprintf(MED,"lost the focus of mcp-oid %d",mcp_oid);
@@ -104,7 +104,7 @@
 	focus_oid=-1;
 	p=get_proc_by_pid(MCP);
 	s3dprintf(MED,"request to focus %d",oid);
-	if (obj_valid(p,oid,o))
+	if (OBJ_VALID(p,oid,o))
 		if (o->oflags&OF_VIRTUAL)
 		{
 			focus_oid=oid;

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-09-01 12:49:32 UTC (rev 660)
+++ trunk/server/object.c	2007-09-02 09:39:40 UTC (rev 661)
@@ -39,14 +39,14 @@
 
 
 static void obj_update_tex(struct t_tex *tex,u_int16_t x,u_int16_t y,u_int16_t w,u_int16_t h,u_int8_t *pixbuf);
-void obj_sys_update(struct t_process *p, uint32_t oid);
+void obj_sys_update(struct t_process *p, int32_t oid);
 
 /*  debugging function for objects, prints out some stuff known about it... */
-int obj_debug			(struct t_process *p, uint32_t oid)
+int obj_debug			(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o;
 	s3dprintf(HIGH,"about pid %d/obj %d:",p->id,oid);
-	if (obj_valid(p,oid,o))
+	if (OBJ_VALID(p,oid,o))
 	{
 		s3dprintf(HIGH,"vertices: %d, polygons: %d, materials: %d, textures: %d, flags: %010x",o->n_vertex,o->n_poly, o->n_mat, o->n_tex,o->oflags);
 		s3dprintf(HIGH,"linkid %d, displaylist %d",o->linkid,o->dplist);
@@ -68,16 +68,16 @@
 	return(0);
 }
 /*  push a few new vertices onto the stack. */
-int obj_push_vertex		(struct t_process *p, uint32_t oid, float *x, uint32_t n)
+int obj_push_vertex		(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	uint32_t i,m;
+	int32_t i,m;
 	struct t_vertex *p_vertex;
 	struct t_vertex *a;
 	struct t_obj *obj;
 	float *px;
 	float r;
 	int is_clnsrc;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (obj->oflags&OF_NODATA)
 		{
@@ -149,13 +149,13 @@
 }
 
 
-int obj_push_mat		(struct t_process *p, uint32_t oid, float *x, uint32_t n)
+int obj_push_mat		(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	uint32_t i,m;
+	int32_t i,m;
 	struct t_mat *p_mat;
 	struct t_obj *obj;
 	float *px;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (obj->oflags&OF_NODATA)
 		{
@@ -199,13 +199,13 @@
 }
 
 /*  its always the same ... this time we push some polys on the stack */
-int obj_push_poly(struct t_process *p, uint32_t oid, uint32_t *x, uint32_t n)
+int obj_push_poly(struct t_process *p, int32_t oid, uint32_t *x, int32_t n)
 {
-	uint32_t i,m;
+	int32_t i,m;
 	struct t_poly *p_poly;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (obj->oflags&OF_NODATA)
 		{
@@ -246,13 +246,13 @@
 	return(0);
 }
 /*  its always the same ... this time we push some lines on the stack */
-int obj_push_line(struct t_process *p, uint32_t oid, uint32_t *x, uint32_t n)
+int obj_push_line(struct t_process *p, int32_t oid, uint32_t *x, int32_t n)
 {
-	uint32_t i,m;
+	int32_t i,m;
 	struct t_line *p_line;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (obj->oflags&OF_NODATA)
 		{
@@ -289,14 +289,14 @@
 }
 /* creates n new textures on the texture stack, of object oid, with (w,h)
  * given through *x */
-int obj_push_tex(struct t_process *p, uint32_t oid, uint16_t *x, uint32_t n)
+int obj_push_tex(struct t_process *p, int32_t oid, uint16_t *x, int32_t n)
 {
-	uint32_t i,m;
+	int32_t i,m;
 	double d;
 	struct t_tex *p_tex;
 	struct t_obj *obj;
 	uint16_t *px,hm;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (obj->oflags&OF_NODATA)
 		{
@@ -365,13 +365,13 @@
 	return(0);
 }
 /*  add some normal information to the polygon buffer */
-int obj_pep_poly_normal(struct t_process *p, uint32_t oid, float *x, uint32_t n)
+int obj_pep_poly_normal(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	uint32_t i,j,m;
+	int32_t i,j,m;
 	struct t_obj *obj;
 	float *px;
  	float len; 
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		m=obj->n_poly;
 		if (m<n)	 /*  saving the first number of polys */
@@ -415,13 +415,13 @@
 	return(0);
 }
 /*  add some normal information to the line buffer */
-int obj_pep_line_normal(struct t_process *p, uint32_t oid, float *x, uint32_t n)
+int obj_pep_line_normal(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	uint32_t i,j,m;
+	int32_t i,j,m;
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		m=obj->n_line;
 		if (m<n)	 /*  saving the first number of lines */
@@ -467,12 +467,12 @@
 }
 
 /*  add textures coordinates to each vertex of the polygon(s) */
-int obj_pep_poly_texc(struct t_process *p, uint32_t oid, float *x, uint32_t n)
+int obj_pep_poly_texc(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	uint32_t i,j,m;
+	int32_t i,j,m;
 	struct t_obj *obj;
 	float *px;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (obj->oflags&OF_NODATA)
 		{
@@ -508,12 +508,12 @@
 	return(0);
 }
 /*  overwrite n latest materials with some other materials */
-int obj_pep_mat(struct t_process *p, uint32_t oid, float *x, uint32_t n)
+int obj_pep_mat(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	uint32_t i,m;
+	int32_t i,m;
 	struct t_obj *obj;
 	float *px;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		m=obj->n_mat;	 /*  saving the first number of materials */
 		if (m<n)	
@@ -554,12 +554,12 @@
 	return(0);
 }
 /*  overwrite n latest lines with some other lines */
-int obj_pep_line(struct t_process *p, uint32_t oid, uint32_t *x, uint32_t n)
+int obj_pep_line(struct t_process *p, int32_t oid, uint32_t *x, int32_t n)
 {
-	uint32_t i,m;
+	int32_t i,m;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		m=obj->n_line;	 /*  saving the first number of lines */
 		if (m<n)	
@@ -595,15 +595,15 @@
 
 
 /*  overwrite n latest vertices with some other vertices */
-int obj_pep_vertex(struct t_process *p, uint32_t oid, float *x, uint32_t n)
+int obj_pep_vertex(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	uint32_t i,m;
+	int32_t i,m;
 	float r;
 	struct t_vertex *a;
 	struct t_obj *obj;
 	float *px;
 	int is_clnsrc;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		m=obj->n_vertex;	 /*  saving the first number of vertices */
 		if (m<n)	 
@@ -665,12 +665,12 @@
 	return(0);
 }
 /*  assign textures to the last n materials */
-int obj_pep_mat_tex(struct t_process *p, uint32_t oid, uint32_t *x, uint32_t n)
+int obj_pep_mat_tex(struct t_process *p, int32_t oid, uint32_t *x, int32_t n)
 {
-	uint32_t i,m;
+	int32_t i,m;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		m=obj->n_mat;	 /*  saving the first number of vertices */
 		if (m<n)	 /*  saving the first number of polys */
@@ -698,14 +698,15 @@
 	return(0);
 }
 /*  add some normal information to the polygon buffer */
-int obj_load_poly_normal(struct t_process *p, uint32_t oid, float *x, uint32_t start, uint32_t n)
+int obj_load_poly_normal(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n)
 {
-	uint32_t i,j,m;
+	int32_t i,j,m;
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
+		if (start < 0) return(-1);
 		m=obj->n_poly;
 		if (m<(start+n))	
 			n=m-start; 
@@ -745,14 +746,15 @@
 	return(0);
 }
 /*  add some normal information to the line  buffer */
-int obj_load_line_normal(struct t_process *p, uint32_t oid, float *x, uint32_t start, uint32_t n)
+int obj_load_line_normal(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n)
 {
-	uint32_t i,j,m;
+	int32_t i,j,m;
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
+		if (start < 0) return(-1);
 		m=obj->n_line;
 		if (m<(start+n))	
 			n=m-start; 
@@ -792,13 +794,14 @@
 	return(0);
 }
 /*  add textures coordinates to each vertex of the polygon(s) */
-int obj_load_poly_texc(struct t_process *p, uint32_t oid, float *x, uint32_t start, uint32_t n)
+int obj_load_poly_texc(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n)
 {
-	uint32_t i,j,m;
+	int32_t i,j,m;
 	struct t_obj *obj;
 	float *px;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
+		if (start < 0) return(-1);
 		m=obj->n_poly;
 		if (m<(start+n))	
 			n=m-start; 
@@ -830,13 +833,14 @@
 
 
 /*  load at position start n materials, overwriting old ones */
-int obj_load_mat(struct t_process *p, uint32_t oid, float *x, uint32_t start, uint32_t n)
+int obj_load_mat(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n)
 {
-	uint32_t i,m;
+	int32_t i,m;
 	struct t_obj *obj;
 	float *px;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
+		if (start < 0) return(-1);
 		m=obj->n_mat;	
 		if (m<(start+n))	
 			n=m-start; 
@@ -876,8 +880,9 @@
 static void obj_update_tex(struct t_tex *tex,u_int16_t S3DUNUSED(x),u_int16_t S3DUNUSED(y),u_int16_t S3DUNUSED(w),u_int16_t S3DUNUSED(h),u_int8_t *S3DUNUSED(pixbuf))
 {
 	GLuint t;
-	if ((t=tex->gl_texnum)!=-1)
+	if ((tex->gl_texnum)!=-1)
 	{
+		t= tex->gl_texnum;
 /* s3dprintf(MED,"updating texture %d at [%d %d] with a [%d %d] pixbuf",t,x,y,w,h); */
 /* 		glTexSubImage2D(t,0,x,y,w,h,GL_RGBA,GL_UNSIGNED_BYTE,pixbuf); */
 
@@ -886,20 +891,21 @@
 	}
 }
 /*  loads some data into the pixbuf */
-int obj_load_tex		(struct t_process *p, uint32_t oid, uint32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf)
+int obj_load_tex		(struct t_process *p, int32_t oid, int32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf)
 {
 	struct t_obj *obj;
 	struct t_tex *t;
-	uint32_t i,p1,p2,m;
+	int32_t i,p1,p2,m;
 	int16_t mw;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (obj->oflags&OF_NODATA)
 		{
 			errds(MED,"obj_load_tex()","error: no data on object allowed!");
 			return(-1);
 		}
-		if (tex<obj->n_tex)
+		if ( tex < 0 ) return(-1);
+		if ( tex < obj->n_tex)
 		{
 			t=&obj->p_tex[tex];
 			if (t->buf!=NULL)
@@ -937,13 +943,13 @@
 	} 
 	return(-1);
 }
-int obj_toggle_flags(struct t_process *p, uint32_t oid, uint8_t type, uint32_t flags)
+int obj_toggle_flags(struct t_process *p, int32_t oid, uint8_t type, uint32_t flags)
 {
 	struct t_obj *obj;
 	uint32_t f;
 
 	f=flags&OF_MASK;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		switch (type)
 		{
@@ -957,12 +963,12 @@
 	return(0);
 }
 /*  deletes the last n vertices of the stack. if n>=n_vertex, delete all vertices */
-int obj_del_vertex(struct t_process *p, uint32_t oid, uint32_t n)
+int obj_del_vertex(struct t_process *p, int32_t oid, int32_t n)
 {
-	uint32_t m;
+	int32_t m;
 	struct t_vertex *p_vertex;
 	struct t_obj *obj;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (obj->oflags&OF_NODATA)
 		{
@@ -1001,12 +1007,12 @@
 	return(0);
 }
 /*  deletes the last n materials of the stack. if n>=n_mat, delete all materials */
-int obj_del_mat(struct t_process *p, uint32_t oid, uint32_t n)
+int obj_del_mat(struct t_process *p, int32_t oid, int32_t n)
 {
-	uint32_t m;
+	int32_t m;
 	struct t_mat *p_mat;
 	struct t_obj *obj;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (obj->oflags&OF_NODATA)
 		{
@@ -1040,12 +1046,12 @@
 	return(0);
 }
 /*  deletes the last n polys of the stack. if n>=n_poly, delete all polys */
-int obj_del_poly(struct t_process *p, uint32_t oid, uint32_t n)
+int obj_del_poly(struct t_process *p, int32_t oid, int32_t n)
 {
-	uint32_t m;
+	int32_t m;
 	struct t_poly *p_poly;
 	struct t_obj *obj;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (obj->oflags&OF_NODATA)
 		{
@@ -1079,12 +1085,12 @@
 	return(0);
 }
 /*  deletes the last n lines of the stack. if n>=n_line, delete all lines */
-int obj_del_line(struct t_process *p, uint32_t oid, uint32_t n)
+int obj_del_line(struct t_process *p, int32_t oid, int32_t n)
 {
-	uint32_t m;
+	int32_t m;
 	struct t_line *p_line;
 	struct t_obj *obj;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (obj->oflags&OF_NODATA)
 		{
@@ -1118,14 +1124,14 @@
 	return(0);
 }
 /*  delete texture object */
-int obj_del_tex(struct t_process *p, uint32_t oid, uint32_t n)
+int obj_del_tex(struct t_process *p, int32_t oid, int32_t n)
 {
-	uint32_t m;
-	uint32_t i;
+	int32_t m;
+	int32_t i;
 	struct t_tex *p_tex;
 	struct t_obj *obj;
 	GLuint t;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (obj->oflags&OF_NODATA)
 		{
@@ -1182,12 +1188,12 @@
 }
 
 /*  from proto.c, translates the object. */
-int obj_translate(struct t_process *p, uint32_t oid, float *transv)
+int obj_translate(struct t_process *p, int32_t oid, float *transv)
 {
 	struct t_obj *obj;
 	struct t_process *mcp_p=get_proc_by_pid(MCP);
 	float v[3];
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (isnan(transv[0])||isinf(transv[0])) return(-1);
 		if (isnan(transv[1])||isinf(transv[1])) return(-1);
@@ -1218,13 +1224,13 @@
 	return(0);
 }
 /*  set rotate vector .... */
-int obj_rotate(struct t_process *p, uint32_t oid, float *rotv)
+int obj_rotate(struct t_process *p, int32_t oid, float *rotv)
 {
 	struct t_obj *obj;
 	struct t_process *mcp_p=get_proc_by_pid(MCP);
 	float v[3];
 	float f;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if (isnan(rotv[0])||isinf(rotv[0])) return(-1);
 		if (isnan(rotv[1])||isinf(rotv[1])) return(-1);
@@ -1258,10 +1264,10 @@
 	return(0);
 }
 /*  and scaling ! */
-int obj_scale(struct t_process *p, uint32_t oid, float scav)
+int obj_scale(struct t_process *p, int32_t oid, float scav)
 {
 	struct t_obj *obj;
-	if (obj_valid(p,oid,obj))
+	if (OBJ_VALID(p,oid,obj))
 	{
 		if ((p->id==MCP) || (!(obj->oflags&OF_SYSTEM)))
 		if (!isinf(scav) && !isnan(scav) && !((scav<1.0e-10) && (scav>-1.0e-10))) /* ignore very low values */
@@ -1284,7 +1290,7 @@
 	if ((obj->oflags&OF_LINK) && (depth<p->n_obj))
 	{
 		/* TODO: only MultMatrix if m_uptodate ?! */
-		if (obj_valid(p,obj->linkid,on))
+		if (OBJ_VALID(p,obj->linkid,on))
 		{
 			into_position(p,on,depth+1);
 		} else {
@@ -1303,15 +1309,15 @@
 	glScalef(obj->scale,obj->scale,obj->scale);
 }
 
-void obj_size_update(struct t_process *p, uint32_t oid)
+void obj_size_update(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o,*o2;
 	struct t_vertex *a,*vp;
 	float r;
 	int vn,is_clnsrc;
-	uint32_t i;
+	int32_t i;
 	if (p->id==MCP) return; /*  mcp does not need that. */
-	if (obj_valid(p,oid,o))
+	if (OBJ_VALID(p,oid,o))
 	{
 		if (o->oflags&OF_SYSTEM)
 		{
@@ -1345,7 +1351,7 @@
 				{
 					if (p->object[i]!=NULL)
 					{
-						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid))
+						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex== oid))
 						{ /* if it's pointing to our object ... */
 							is_clnsrc=1;
 							p->object[i]->r=o->r*(p->object[i]->r/o->scale); /* give it the new radius too! */
@@ -1361,12 +1367,12 @@
 }
 /*  checks if the object is (still) the biggest object. assumes that oid */
 /*  is valid */
-void obj_check_biggest_object(struct t_process *p, uint32_t oid)
+void obj_check_biggest_object(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o,*mcp_o;
 	struct t_process *mcp_p;
 	float r,r2;
-	uint32_t i;
+	int32_t i;
 	int found;
 	mcp_p=get_proc_by_pid(MCP);
 	mcp_o=mcp_p->object[p->mcp_oid];
@@ -1408,7 +1414,7 @@
 	}
 }
 /* calculates and saves the transformation matrix, if needed */
-void obj_recalc_tmat(struct t_process *p, uint32_t oid)
+void obj_recalc_tmat(struct t_process *p, int32_t oid)
 {
 	GLint matrixmode;
 	if (!p->object[oid]->m_uptodate)
@@ -1424,7 +1430,7 @@
 		p->object[oid]->m_uptodate=1;
 	}
 }
-void obj_sys_update(struct t_process *p, uint32_t oid)
+void obj_sys_update(struct t_process *p, int32_t oid)
 {
 	struct t_process *mcp_p=get_proc_by_pid(MCP);
 	struct t_obj	 *o;
@@ -1480,7 +1486,7 @@
 	obj_pos_update(p,oid,oid); /* now also update the matrix and the objects linking to our sys-object ... */
 }
 /*  recalculate the position of an object. this assumes that oid is valid. */
-void obj_pos_update(struct t_process *p, uint32_t oid, uint32_t first_oid)
+void obj_pos_update(struct t_process *p, int32_t oid, int32_t first_oid)
 {
 	float v[3];
 	struct t_obj 		*ao,*o;
@@ -1500,12 +1506,12 @@
 	} else 
 		if (o->oflags&OF_SYSTEM) /* TODO: what will we do if $sys_object is linked to another? */
 		{ /* a system object changed position? let's update the focus'ed sys-objects */
-			if (obj_valid(p,focus_oid,ao))
+			if (OBJ_VALID(p,focus_oid,ao))
 				if (NULL!=(ap=get_proc_by_pid(ao->n_mat)))
 				{
 					if (OF_POINTER==(o->oflags&0xF0000000))
 					{ /* we dont have to do that much in this case ... */
-						if (obj_valid(ap,get_pointer(ap),ao)) /* we can redefine ao here -> ao = focused app's pointer*/
+						if (OBJ_VALID(ap,get_pointer(ap),ao)) /* we can redefine ao here -> ao = focused app's pointer*/
 						{
 							ao->rotate.x=o->rotate.x;
 							ao->rotate.y=o->rotate.y;
@@ -1545,13 +1551,13 @@
 {
 	struct t_vertex a,b,n;
 	struct t_vertex *v[3];
-	uint32_t vp,i;
+	int32_t vp,i;
 	
 	float len;
 	for (i=0;i<3;i++)  /*  set and check */
 	{
 		vp= obj->p_poly[pn].v[i];  /*  ... get the vertices ... */
-		if (vp<obj->n_vertex)
+		if ( vp < obj->n_vertex)
 			v[i]=&(obj->p_vertex[vp]);
 		else return(-1);
 	}
@@ -1589,7 +1595,7 @@
 	return(0);
 }
 
-/* checks if a normal is set for a line object, or set some default oif not */
+/* checks if a normal is set for a line object, or set some default if not */
 int check_line_normal(struct t_obj *obj, uint32_t pn)
 {
 	struct t_vertex *v[2];
@@ -1597,7 +1603,7 @@
 	for (i=0;i<2;i++)  /*  set and check */
 	{
 		vp= obj->p_line[pn].v[i];  /*  ... get the vertices ... */
-		if (vp<obj->n_vertex)
+		if (vp < (int)obj->n_vertex)
 			v[i]=&(obj->p_vertex[vp]);
 		else return(-1);
 	}
@@ -1623,7 +1629,7 @@
 	struct t_tex *tex=NULL;
 	GLfloat matgl[4];
 /* 	int i,j; */
-	if (m->tex<obj->n_tex)
+	if (m->tex < obj->n_tex)
 	{
 		tex=&obj->p_tex[m->tex];
 		if (tex->buf!=NULL)
@@ -1672,18 +1678,18 @@
 	return(tex);
 }
 /*  finally, the rendering portion. */
-int obj_render(struct t_process *p,uint32_t oid)
+int obj_render(struct t_process *p,int32_t oid)
 {
-	uint32_t pn;
-	uint32_t mat,omat=-1;
-	uint32_t v;
+	int32_t pn;
+	int32_t mat,omat=-1;
+	int32_t v;
 /* 	int link_obj; */
 	struct t_vertex *on;
 	struct t_obj *obj;
 	struct t_mat *m;
 	struct t_tex *tex=NULL;
 	GLfloat matgl[4];
-	uint32_t i;
+	int32_t i;
 
 	obj=p->object[oid];
 	glPushMatrix();
@@ -1825,20 +1831,20 @@
 }
 
 /* remove the oid out of the link chain */
-void link_delete(struct t_process *p, uint32_t oid)
+void link_delete(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o,*o2;
-	if (obj_valid(p,oid,o))
+	if (OBJ_VALID(p,oid,o))
 	{
 		s3dprintf(VLOW,"link_delete(): [%d] unlinking %d from %d",p->id, oid, o->linkid);
 		if (o->linkid!=-1) 
 		{
 			if (o->lprev!=-1)
-				if (obj_valid(p,o->lprev,o2))
+				if (OBJ_VALID(p,o->lprev,o2))
 				{ /* we have a previous pointer linking to us */
 					o2->lnext=o->lnext; /* might also be -1 */
 				}
-			if (obj_valid(p,o->linkid,o2))
+			if (OBJ_VALID(p,o->linkid,o2))
 			{
 				if (o2->lsub==oid)
 				{/* parent is having oid as it's first link in chain */
@@ -1846,7 +1852,7 @@
 				}
 			}
 			if (o->lnext!=-1)
-				if (obj_valid(p,o->lnext,o2))
+				if (OBJ_VALID(p,o->lnext,o2))
 				{ /* fixing next's previous pointer */
 					o2->lprev=o->lprev;
 				}
@@ -1858,16 +1864,16 @@
 	}
 }
 /* add an element into the link chain */
-void link_insert(struct t_process *p, uint32_t oid, uint32_t target)
+void link_insert(struct t_process *p, int32_t oid, int32_t target)
 {
 	struct t_obj *o,*ot,*o2;
-	if (obj_valid(p,oid,o) && obj_valid(p,target,ot))
+	if (OBJ_VALID(p,oid,o) && OBJ_VALID(p,target,ot))
 	{
 		s3dprintf(VLOW,"link_insert(): [%d] linking %d to %d",p->id, oid, target);
 		o->oflags|=OF_LINK;
 		o->linkid=target;
 		o->lnext=ot->lsub; /* we have a new "first" element */
-		if (o->lnext!=-1) if (obj_valid(p,o->lnext,o2))  /* if we already had an element
+		if (o->lnext!=-1) if (OBJ_VALID(p,o->lnext,o2))  /* if we already had an element
 														  in the chain, create the backlink */
 		{
 			o2->lprev=oid;
@@ -1877,10 +1883,10 @@
 }
 /*  creates a link from object from an object to another  */
 /*  to have a translation or anything move with other things */
-int obj_link(struct t_process *p, uint32_t oid_from, uint32_t oid_to)
+int obj_link(struct t_process *p, int32_t oid_from, int32_t oid_to)
 {
 	struct t_obj *o,*o2;
-	if (obj_valid(p,oid_from,o) && obj_valid(p,oid_to,o2))
+	if (OBJ_VALID(p,oid_from,o) && OBJ_VALID(p,oid_to,o2))
 	{
 		if (oid_to==oid_from)
 		{
@@ -1921,10 +1927,10 @@
 	return(-1);
 }
 /*  this unlinks an object ... */
-int obj_unlink(struct t_process *p, uint32_t oid)
+int obj_unlink(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o;
-	if (obj_valid(p,oid,o))
+	if (OBJ_VALID(p,oid,o))
 	{
 		if (OF_POINTER==(o->oflags&0xF0000000))
 		{
@@ -1943,7 +1949,7 @@
 int obj_new(struct t_process *p)
 {
 	struct t_obj *obj;
-	uint32_t pos,reuse=0;
+	int32_t pos,reuse=0;
 	obj=malloc(sizeof(struct t_obj));  /*  get an object and define it with our data */
 	memset(obj,0,sizeof(struct t_obj));
 	obj->linkid=-1;
@@ -1961,7 +1967,7 @@
 	if (p!=NULL)
 	{
 		 /*  look for an old object for reuse ... */
-		for (pos=0;pos<p->n_obj;pos++)
+		for (pos=0; pos < p->n_obj ; pos++)
 		{
 			if (p->object[pos]==NULL)
 			{
@@ -1989,12 +1995,12 @@
 
 /*  this changes the clone-target or sets up a new clone link. */
 /*  this will check and supress looplinks and clonechains */
-int obj_clone_change(struct t_process *p, uint32_t oid, uint32_t toid)
+int obj_clone_change(struct t_process *p, int32_t oid, int32_t toid)
 {
 	struct t_obj *o,*no;
 	int already_clone,is_clnsrc;
-	uint32_t i;
-	if (obj_valid(p,oid,o) && obj_valid(p,toid,no))
+	int32_t i;
+	if (OBJ_VALID(p,oid,o) && OBJ_VALID(p,toid,no))
 	{
 		if ((o->oflags&OF_SYSTEM) || (no->oflags&OF_SYSTEM))
 		{
@@ -2052,15 +2058,15 @@
 
 
 /*  object-deletion request from proto.c */
-int obj_del(struct t_process *p, uint32_t oid)
+int obj_del(struct t_process *p, int32_t oid)
 {
 	struct t_process *mcp_p;
 	struct t_obj *o;
 	float r,mr;
-	uint32_t i;
-	uint32_t mcp_oid=-1;
+	int32_t i;
+	int32_t mcp_oid=-1;
 	mcp_p=get_proc_by_pid(MCP);
-	if (obj_valid(p,oid,o))
+	if (OBJ_VALID(p,oid,o))
 	{
 		if (o->oflags&OF_SYSTEM)
 		{
@@ -2080,7 +2086,7 @@
 		} else 
 			mcp_oid=p->mcp_oid;
 
-		if (obj_valid(p,oid,o))
+		if (OBJ_VALID(p,oid,o))
 		{
 			obj_free(p,oid);
 			if ((p->id!=MCP) && (p->biggest_obj==oid))
@@ -2121,9 +2127,9 @@
 }
 
 /*  this is the "direct" freeing function, without checking for perfomance */
-int obj_free(struct t_process *p,uint32_t oid)
+int obj_free(struct t_process *p,int32_t oid)
 {
-	uint32_t i;
+	int32_t i;
 	GLuint t;
 	struct t_obj *o=p->object[oid];
 	s3dprintf(HIGH,"deleting object %d of process %d",oid,p->id);
@@ -2180,9 +2186,9 @@
 	return(0);
 }
 /* get the object of the pointer (that's 1, usually */
-uint32_t get_pointer(struct t_process *p)
+int32_t get_pointer(struct t_process *p)
 {
-	uint32_t i;
+	int32_t i;
 	for (i=0;i<p->n_obj;i++)
 	{
 

Modified: trunk/server/process.c
===================================================================
--- trunk/server/process.c	2007-09-01 12:49:32 UTC (rev 660)
+++ trunk/server/process.c	2007-09-02 09:39:40 UTC (rev 661)
@@ -38,7 +38,7 @@
 struct t_process *process_protinit(struct t_process *p, char *name)
 {
 	int con_type;
-	uint32_t mcp_oid;
+	int32_t mcp_oid;
 	if ((strncmp(name,"sys_",4)==0))
 	{ /* we don't like "sys_"-apps, kicking this */
 		errds(VHIGH,"process_protinit()","appnames starting with 'sys_' not allowed.");
@@ -72,7 +72,7 @@
 		process_sys_init(p);
 
 	/* register the new process in the mcp */
-		if (-1!=(mcp_oid=obj_new(&procs_p[MCP])))
+		if (-1!=(mcp_oid= obj_new(&procs_p[MCP])))
 		{
 			mcp_p->object[mcp_oid]->oflags|=OF_VIRTUAL|OF_VISIBLE|OF_SELECTABLE;
 			mcp_p->object[mcp_oid]->n_mat=p->id;
@@ -111,7 +111,7 @@
 		/* TODO: ... get the cam and ptr position of the mcp, somehow */
 		p->object[cam]->oflags=OF_CAM;
 		
-		if (obj_valid(mcp_p,get_pointer(mcp_p),o)) /* get parent pointer, copy parent */
+		if (OBJ_VALID(mcp_p,get_pointer(mcp_p),o)) /* get parent pointer, copy parent */
 		{
 			p->object[ptr]->rotate.x=o->rotate.x;
 			p->object[ptr]->rotate.y=o->rotate.y;
@@ -206,7 +206,7 @@
 			for (j=0;j<mcp_p->n_obj;j++)	 /*  remove clones and links pointing on this app-object ... */
 				if (mcp_p->object[j]!=NULL)
 				{
-					if ((mcp_p->object[j]->oflags&OF_CLONE) && (mcp_p->object[j]->n_vertex==p->mcp_oid))  /*  it's linking to our object! */
+					if ((mcp_p->object[j]->oflags&OF_CLONE) && (mcp_p->object[j]->n_vertex == p->mcp_oid))  /*  it's linking to our object! */
 					{
 						mcp_p->object[j]->oflags&=~OF_CLONE;  	 /*  disable clone flag */
 						mcp_p->object[j]->n_vertex=0; 			 /*  and "clone reference" to 0 */

Modified: trunk/server/proto.c
===================================================================
--- trunk/server/proto.c	2007-09-01 12:49:32 UTC (rev 660)
+++ trunk/server/proto.c	2007-09-02 09:39:40 UTC (rev 661)
@@ -51,7 +51,7 @@
 	uint16_t w,h,x,y;
 	uint32_t oid,toid;
 	uint8_t	type;
-	uint32_t flags,mcp_oid=-1;
+	int32_t flags,mcp_oid=-1;
 	command=pbuf[0];
 	if (p->id!=0)
 	{

Modified: trunk/server/shm_ringbuf.c
===================================================================
--- trunk/server/shm_ringbuf.c	2007-09-01 12:49:32 UTC (rev 660)
+++ trunk/server/shm_ringbuf.c	2007-09-02 09:39:40 UTC (rev 661)
@@ -30,7 +30,7 @@
 {
 	int wrap=0;
 	int rs;
-	uint32_t e,s,size;
+	int32_t e,s,size;
 	char *data;
 
 	e=rb->end;
@@ -40,7 +40,7 @@
 	if (e<s) {
 		wrap=1;
 	} 
-	while ((((s+size*(1-wrap))-e)<(n+1))) /* checking free space */
+	while ((((s+size*(1-wrap))-e) < (n+1))) /* checking free space */
 	{
 		if /*((size*2)>RB_MAX_SIZE)*/ (1)
 		{
@@ -79,7 +79,7 @@
 	int wrap=0;
 	int mn=n;
 	int rs;
-	uint32_t e,s,size;
+	int32_t e,s,size;
 	char *data;
 
 	e=rb->end;



From lazhur at mail.berlios.de  Mon Sep  3 11:42:10 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 3 Sep 2007 11:42:10 +0200
Subject: [S3d-svn] r662 - trunk/server
Message-ID: <200709030942.l839gA8L028568@sheep.berlios.de>

Author: lazhur
Date: 2007-09-03 11:42:09 +0200 (Mon, 03 Sep 2007)
New Revision: 662

Modified:
   trunk/server/network.c
Log:
Close a scope in an "#ifdef SIGS" block when you opened in an "#ifdef SIGS" block

Modified: trunk/server/network.c
===================================================================
--- trunk/server/network.c	2007-09-02 09:39:40 UTC (rev 661)
+++ trunk/server/network.c	2007-09-03 09:42:09 UTC (rev 662)
@@ -108,9 +108,9 @@
 
 #ifdef SIGS
 		sigio=0;
-#endif
 	}
 #endif
+#endif
 #ifdef SHM
 	shm_main();
 #endif



From dotslash at mail.berlios.de  Sun Sep  9 15:28:49 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 9 Sep 2007 15:28:49 +0200
Subject: [S3d-svn] r663 - in trunk: . libs3d
Message-ID: <200709091328.l89DSncO023886@sheep.berlios.de>

Author: dotslash
Date: 2007-09-09 15:28:48 +0200 (Sun, 09 Sep 2007)
New Revision: 663

Modified:
   trunk/
   trunk/libs3d/freetype.c
Log:
 r2374 at kero:  dotslash | 2007-09-09 15:28:38 +0200
 - don't allocate things if there is no character to draw. 



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2297
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2374

Modified: trunk/libs3d/freetype.c
===================================================================
--- trunk/libs3d/freetype.c	2007-09-03 09:42:09 UTC (rev 662)
+++ trunk/libs3d/freetype.c	2007-09-09 13:28:48 UTC (rev 663)
@@ -283,6 +283,7 @@
 	return(0);
 }
 
+/* draws one charachter a */
 int _s3d_draw_tessbuf(int oid,uint16_t a,int *voff, float *xoff)
 {
 	float *vbuf;
@@ -290,38 +291,42 @@
 	int i;
 	if (!(tess_buf[a].vbuf && tess_buf[a].pbuf))
 		_s3d_add_tessbuf(a);
-	vbuf=malloc(sizeof(float)*3*tess_buf[a].vn);
-	pbuf=malloc(sizeof(uint32_t)*4*tess_buf[a].pn);
-	memcpy(vbuf,tess_buf[a].vbuf,sizeof(float)*3*tess_buf[a].vn);
-	memcpy(pbuf,tess_buf[a].pbuf,sizeof(uint32_t)*4*tess_buf[a].pn);
-	 /*  prepare the buffs ... */
-/* 	s3dprintf(LOW,"drawing [%c] (%d vertices, %d polys",a,tess_buf[a].vn,tess_buf[a].pn); */
-	for (i=0;i<tess_buf[a].vn;i++)
-	{
-		vbuf[i*3]+=*xoff;
-/*		s3dprintf(LOW,"vertex [%c:%d] %f %f %f",a,i,
-						vbuf[i*3],
-						vbuf[i*3+1],
-						vbuf[i*3+2]);*/
+	/* only draw if it has some information in it */
+	if ((tess_buf[a].pn != 0) && (tess_buf[a].vn != 0)) {
+	
+		vbuf=malloc(sizeof(float)*3*tess_buf[a].vn);
+		pbuf=malloc(sizeof(uint32_t)*4*tess_buf[a].pn);
+		memcpy(vbuf,tess_buf[a].vbuf,sizeof(float)*3*tess_buf[a].vn);
+		memcpy(pbuf,tess_buf[a].pbuf,sizeof(uint32_t)*4*tess_buf[a].pn);
+		 /*  prepare the buffs ... */
+	/* 	s3dprintf(LOW,"drawing [%c] (%d vertices, %d polys",a,tess_buf[a].vn,tess_buf[a].pn); */
+		for (i=0;i<tess_buf[a].vn;i++)
+		{
+			vbuf[i*3]+=*xoff;
+	/*		s3dprintf(LOW,"vertex [%c:%d] %f %f %f",a,i,
+							vbuf[i*3],
+							vbuf[i*3+1],
+							vbuf[i*3+2]);*/
+		}
+		for (i=0;i<tess_buf[a].pn;i++)
+		{
+			pbuf[i*4]+=*voff;
+			pbuf[i*4+1]+=*voff;
+			pbuf[i*4+2]+=*voff;
+	/*		s3dprintf(LOW,"poly [%c:%d] %d %d %d | %d (voff %d)",a,i,
+							pbuf[i*4],
+							pbuf[i*4+1],
+							pbuf[i*4+2],
+							pbuf[i*4+3],*voff);*/
+		}
+		s3dprintf(VLOW,"commiting %d vertices, %d polygons",tess_buf[a].vn,tess_buf[a].pn);
+		s3d_push_vertices(oid,vbuf,tess_buf[a].vn);
+		s3d_push_polygons(oid,pbuf,tess_buf[a].pn);
+		*voff+=tess_buf[a].vn;
+		free(vbuf);
+		free(pbuf);
 	}
-	for (i=0;i<tess_buf[a].pn;i++)
-	{
-		pbuf[i*4]+=*voff;
-		pbuf[i*4+1]+=*voff;
-		pbuf[i*4+2]+=*voff;
-/*		s3dprintf(LOW,"poly [%c:%d] %d %d %d | %d (voff %d)",a,i,
-						pbuf[i*4],
-						pbuf[i*4+1],
-						pbuf[i*4+2],
-						pbuf[i*4+3],*voff);*/
-	}
-	s3dprintf(VLOW,"commiting %d vertices, %d polygons",tess_buf[a].vn,tess_buf[a].pn);
-	s3d_push_vertices(oid,vbuf,tess_buf[a].vn);
-	s3d_push_polygons(oid,pbuf,tess_buf[a].pn);
 	*xoff+=tess_buf[a].xoff;  /*  xoffset */
-	*voff+=tess_buf[a].vn;
-	free(vbuf);
-	free(pbuf);
 	return(0);
 }
 int s3d_select_font(char *path)



From lazhur at mail.berlios.de  Mon Sep 17 12:10:18 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 17 Sep 2007 12:10:18 +0200
Subject: [S3d-svn] r664 - trunk
Message-ID: <200709171010.l8HAAIcm024161@sheep.berlios.de>

Author: lazhur
Date: 2007-09-17 12:10:18 +0200 (Mon, 17 Sep 2007)
New Revision: 664

Modified:
   trunk/INSTALL
Log:
Changed --enable-profiling to -DPROFILING=ON in INSTALL


Modified: trunk/INSTALL
===================================================================
--- trunk/INSTALL	2007-09-09 13:28:48 UTC (rev 663)
+++ trunk/INSTALL	2007-09-17 10:10:18 UTC (rev 664)
@@ -36,8 +36,7 @@
 binaries will get installed into /usr/local/bin, libraries into /usr/local/lib,
 and documentation into /usr/local/share/doc/s3d-version. If you are intending to
 work on s3d, you can use the -DDEBUG argument to enable building a debug
-version. Likewise, --enable-profiling will enable a version compiled for
-profiling.
+version. Likewise, -DPROFILING=ON will enable a version compiled for profiling.
 
 You can use ccmake to ccmake to set additional cmake cache variables.
 



From lazhur at mail.berlios.de  Mon Sep 17 15:33:39 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 17 Sep 2007 15:33:39 +0200
Subject: [S3d-svn] r665 - in trunk: apps/dot_mcp apps/kism3d apps/meshs3d
	apps/olsrs3d apps/s3d_x11gate apps/s3dfm apps/s3dosm
	apps/s3dvt example libs3d libs3dw server
Message-ID: <200709171333.l8HDXdqs025921@sheep.berlios.de>

Author: lazhur
Date: 2007-09-17 15:33:24 +0200 (Mon, 17 Sep 2007)
New Revision: 665

Modified:
   trunk/apps/dot_mcp/dot_mcp.h
   trunk/apps/dot_mcp/main.c
   trunk/apps/dot_mcp/menu.c
   trunk/apps/kism3d/gui.c
   trunk/apps/kism3d/kism3d.c
   trunk/apps/kism3d/list.h
   trunk/apps/meshs3d/allocate.c
   trunk/apps/meshs3d/hash.c
   trunk/apps/meshs3d/main.c
   trunk/apps/meshs3d/meshs3d.h
   trunk/apps/meshs3d/net.c
   trunk/apps/meshs3d/process.c
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/net.c
   trunk/apps/olsrs3d/process.c
   trunk/apps/olsrs3d/search.c
   trunk/apps/olsrs3d/structs.h
   trunk/apps/s3d_x11gate/s3d_x11gate.c
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/event.c
   trunk/apps/s3dfm/fly.c
   trunk/apps/s3dfm/focus.c
   trunk/apps/s3dfm/fs.c
   trunk/apps/s3dfm/icon.c
   trunk/apps/s3dfm/main.c
   trunk/apps/s3dfm/node.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dfm/s3dfm.h
   trunk/apps/s3dfm/string.c
   trunk/apps/s3dosm/db.c
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/gps.c
   trunk/apps/s3dosm/http_error_codes.c
   trunk/apps/s3dosm/http_fetcher.c
   trunk/apps/s3dosm/http_fetcher.h
   trunk/apps/s3dosm/io.c
   trunk/apps/s3dosm/kismet.c
   trunk/apps/s3dosm/main.c
   trunk/apps/s3dosm/nav.c
   trunk/apps/s3dosm/object.c
   trunk/apps/s3dosm/osm.c
   trunk/apps/s3dosm/s3dosm.h
   trunk/apps/s3dosm/structs.h
   trunk/apps/s3dosm/tag.c
   trunk/apps/s3dosm/ui.c
   trunk/apps/s3dvt/main.c
   trunk/apps/s3dvt/s3dvt.h
   trunk/apps/s3dvt/terminal.c
   trunk/example/filebrowser.c
   trunk/example/hudtest.c
   trunk/example/katze.c
   trunk/example/linetest.c
   trunk/example/modelloader.c
   trunk/example/nichtsnutz.c
   trunk/example/ptrtest.c
   trunk/example/radius_test.c
   trunk/example/s3dclock.c
   trunk/example/snowman.c
   trunk/example/strtest.c
   trunk/example/texturetest.c
   trunk/example/widgets.c
   trunk/example/wiresphere.c
   trunk/libs3d/callback.c
   trunk/libs3d/config.h
   trunk/libs3d/error.c
   trunk/libs3d/event.c
   trunk/libs3d/fontselect.c
   trunk/libs3d/freetype.c
   trunk/libs3d/io.c
   trunk/libs3d/modelread.c
   trunk/libs3d/network.c
   trunk/libs3d/object_queue.c
   trunk/libs3d/proto_in.c
   trunk/libs3d/proto_out.c
   trunk/libs3d/s3d.h
   trunk/libs3d/s3d_keysym.h
   trunk/libs3d/s3dlib.h
   trunk/libs3d/sei_construct.c
   trunk/libs3d/sei_interface.h
   trunk/libs3d/sei_misc.c
   trunk/libs3d/sei_monotone.c
   trunk/libs3d/sei_tri.c
   trunk/libs3d/sei_triangulate.h
   trunk/libs3d/shm.c
   trunk/libs3d/shm_ringbuf.c
   trunk/libs3d/tcp.c
   trunk/libs3d/vector.c
   trunk/libs3dw/animate.c
   trunk/libs3dw/arrange.c
   trunk/libs3dw/button.c
   trunk/libs3dw/event.c
   trunk/libs3dw/input.c
   trunk/libs3dw/label.c
   trunk/libs3dw/root.c
   trunk/libs3dw/s3dw.h
   trunk/libs3dw/s3dw_int.h
   trunk/libs3dw/scrollbar.c
   trunk/libs3dw/style.c
   trunk/libs3dw/surface.c
   trunk/libs3dw/textbox.c
   trunk/libs3dw/widget.c
   trunk/server/allocate.c
   trunk/server/allocate.h
   trunk/server/config.h
   trunk/server/cull.c
   trunk/server/error.c
   trunk/server/event.c
   trunk/server/global.h
   trunk/server/graphics.c
   trunk/server/graphics_glut.c
   trunk/server/graphics_sdl.c
   trunk/server/main.c
   trunk/server/matrix.c
   trunk/server/mcp.c
   trunk/server/navigation.c
   trunk/server/network.c
   trunk/server/object.c
   trunk/server/process.c
   trunk/server/proto.c
   trunk/server/proto.h
   trunk/server/shm.c
   trunk/server/shm_ringbuf.c
   trunk/server/tcp.c
   trunk/server/user.c
   trunk/server/user_glut.c
   trunk/server/user_sdl.c
Log:
Reformatted to look like made for the Linux kernel coding style


Modified: trunk/apps/dot_mcp/dot_mcp.h
===================================================================
--- trunk/apps/dot_mcp/dot_mcp.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/dot_mcp/dot_mcp.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * dot_mcp.h
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of dot_mcp, a mcp for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * dot_mcp is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * dot_mcp is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with dot_mcp; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

Modified: trunk/apps/dot_mcp/main.c
===================================================================
--- trunk/apps/dot_mcp/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/dot_mcp/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * main.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of dot_mcp, a mcp for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * dot_mcp is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * dot_mcp is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with dot_mcp; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -32,11 +32,12 @@
 #include <stdio.h>  /*  printf() */
 #include <math.h>	/* sin(), cos() */
 #include <time.h>	/* nanosleep() */
-static struct timespec t={0,33*1000*1000}; 
+static struct timespec t= {
+	0,33*1000*1000
+};
 
 #define bsize 	0.2
-struct tver
-{
+struct tver {
 	float x,y,z;
 };
 struct tver campos, camrot;
@@ -48,7 +49,7 @@
 	int init;
 	float trans_x,trans_y,trans_z;
 	float textw;
-	char name[256]; 
+	char name[256];
 	int min_but,close_but,title;
 	int sphere;
 	struct app *next;
@@ -83,12 +84,10 @@
 	r=100; /* inner radius */
 	a=M_PI/180;
 	s3d_push_material_a(o, 0.2,0.6,0.2,0.5,
-						   1  ,1  ,1  ,0.5,
-						   0.2,0.6,0.2,0.5);
-	for (i=0;i<RINGS;i++)
-	{
-		for (j=0;j<SIDES;j++)
-		{
+	                    1  ,1  ,1  ,0.5,
+	                    0.2,0.6,0.2,0.5);
+	for (i=0;i<RINGS;i++) {
+		for (j=0;j<SIDES;j++) {
 			ia=a*((float)i*360.0/RINGS);
 			ja=a*((float)j*360.0/SIDES);
 			iap=a*((float)(i+1)*360.0/RINGS);
@@ -97,14 +96,14 @@
 			v[i*SIDES*3+ j*3 +0]=(R+r*cos(ja))* cos(ia);
 			v[i*SIDES*3+ j*3 +1]=r*sin(ja);
 			v[i*SIDES*3+ j*3 +2]=(R+r*cos(ja))* sin(ia);
-		
+
 			l[i*SIDES*6+ j*6 +0]=i*SIDES+ j;
 			l[i*SIDES*6+ j*6 +1]=i*SIDES+ (j+1)%SIDES;
 			l[i*SIDES*6+ j*6 +2]=0;
 			l[i*SIDES*6+ j*6 +3]=i*SIDES+ j;
 			l[i*SIDES*6+ j*6 +4]=((i+1)%RINGS)*SIDES+ j;
 			l[i*SIDES*6+ j*6 +5]=0;
-			
+
 			n[j*12 +0] =R*r*cos(ja)*    cos(ia) + r*r*cos(ja)* cos(ia)*cos(ia);
 			n[j*12 +1] =R*r*sin(ja)*    cos(ia) + r*r*sin(ja)* cos(ia)*cos(ia);
 			n[j*12 +2] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
@@ -123,8 +122,8 @@
 		s3d_push_lines(o,   &l[i*SIDES*6],SIDES*2);
 		s3d_pep_line_normals(o,n,SIDES*2);
 	}
-/*	s3d_push_vertices(o,v,SIDES*RINGS);
-	s3d_push_lines(o,   l,SIDES*RINGS*2);*/
+	/*	s3d_push_vertices(o,v,SIDES*RINGS);
+		s3d_push_lines(o,   l,SIDES*RINGS*2);*/
 
 	s3d_flags_on(o,S3D_OF_VISIBLE);
 	return(o);
@@ -133,22 +132,20 @@
 {
 	if (focus!=a)
 		/* resetting old focus */
-		if (focus!=NULL)
-		{
+		if (focus!=NULL) {
 			printf("unfocusing app name %s\n",focus->name);
 			s3d_scale(focus->oid,1/focus->r);
 			s3d_scale(focus->sphere,focus->r);
 
-  			s3d_flags_on(focus->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(focus->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			s3d_flags_off(focus->min_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			s3d_translate(	focus->title,-focus->textw-1.2,0.0,0);
 			s3d_translate(	focus->close_but,bsize*focus->textw/2,1.2,0);
 			s3d_link(		focus->close_but,focus->sphere);
-			s3d_link(		focus->oid,0); 
+			s3d_link(		focus->oid,0);
 		}
 	focus=a;
-	if (a==NULL)
-	{
+	if (a==NULL) {
 		focus_r=n_app;
 		s3d_mcp_focus(-1);
 		s3d_flags_off(rotate,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
@@ -180,11 +177,9 @@
 int add_app(struct app *a)
 {
 	struct app *prev=NULL,*a2=apps;
-	while ((a2)!=NULL)
-	{
+	while ((a2)!=NULL) {
 		prev=a2;
-		if (a2->oid==a->oid)
-		{  /*  already added, so free() and return */
+		if (a2->oid==a->oid) { /*  already added, so free() and return */
 			free(a);
 			return(1);
 		}
@@ -193,7 +188,7 @@
 	a->next=NULL;
 	if (prev==NULL)
 		apps=a;
-	else 
+	else
 		prev->next=a;
 	n_app+=1;
 	return(0);
@@ -201,8 +196,7 @@
 void *find_app(int oid)
 {
 	struct app *a=apps;
-	while (a!=NULL)
-	{
+	while (a!=NULL) {
 		if (oid==a->oid)
 			break;
 		a=a->next;
@@ -212,34 +206,30 @@
 void *del_app(int oid)
 {
 	struct app *prev=NULL,*a=apps;
-	while ((a!=NULL)  && (a->oid!=oid))
-	{
+	while ((a!=NULL)  && (a->oid!=oid)) {
 		prev=a;
 		a=a->next;
 	}
-	if (a!=NULL)
-	{  /*  found ... */
-		if (a->init)
-		{
+	if (a!=NULL) { /*  found ... */
+		if (a->init) {
 			s3d_del_object(a->close_but);
 			s3d_del_object(a->min_but);
 			s3d_del_object(a->title);
 			s3d_del_object(a->sphere);
 			s3d_del_object(a->oid);
 		}
-		if (prev==NULL) 
+		if (prev==NULL)
 			apps=a->next;  /*  new head */
 		else
 			prev->next=a->next;
 		n_app--;
-		if (focus==a)
-		{
+		if (focus==a) {
 			set_focus(NULL);
 			focus=NULL;
 		}
 		free(a);
 		place_apps();
-	} 
+	}
 	return(a);
 }
 int stop()
@@ -252,17 +242,12 @@
 	struct app *a=apps;
 	int j=0;
 	float u[3],v[3],ya,xa;
-	while (a!=NULL)
-	{
-		if (a->init)	
-		{
-/*			printf("placing app [%d,'%s'], oid %d, r=%f\n",j,a->name,a->oid,a->r); */
-			if (focus==a)
-			{
+	while (a!=NULL) {
+		if (a->init) {
+			/*			printf("placing app [%d,'%s'], oid %d, r=%f\n",j,a->name,a->oid,a->r); */
+			if (focus==a) {
 				s3d_translate(a->close_but,(-left)*zoom-0.4,(-bottom)*zoom-0.4,-zoom);
-			}
-			else 
-			{
+			} else {
 				s3d_translate(	a->oid,	zoom*(left)+j*2+1.0,zoom*bottom+1.0,-zoom);
 				s3d_rotate(		a->oid,	0,10,0);
 				j++;
@@ -271,21 +256,26 @@
 		a=a->next;
 	}
 	s3d_translate(menu,	left*zoom+0.4,(-bottom)*zoom-0.4,-zoom);
-	
-	v[0]=0;				v[1]=0;					v[2]=1;
-	u[0]=left*zoom+0.4; u[1]=0;					u[2]=-zoom;
+
+	v[0]=0;
+	v[1]=0;
+	v[2]=1;
+	u[0]=left*zoom+0.4;
+	u[1]=0;
+	u[2]=-zoom;
 	ya=s3d_vector_angle(v,u);
-	u[0]=0; 			u[1]=(-bottom)*zoom;	u[2]=-zoom;
+	u[0]=0;
+	u[1]=(-bottom)*zoom;
+	u[2]=-zoom;
 	xa=s3d_vector_angle(v,u);
-	s3d_rotate(menu, 0 ,30,0); 
+	s3d_rotate(menu, 0 ,30,0);
 }
 int mcp_object(struct s3d_evt *hrmz)
 {
 	struct mcp_object *mo;
 	struct app *a;
 	mo=(struct mcp_object *)hrmz->buf;
-	if (NULL==(a=find_app(mo->object)))
-	{
+	if (NULL==(a=find_app(mo->object))) {
 		printf("adding new object ......");
 		a=malloc(sizeof(struct app));
 		a->oid=mo->object;
@@ -296,15 +286,13 @@
 		place_apps();
 		printf("..%s\n",a->name);
 	} else {
-/*		printf("updating app %d\n",a->oid);*/
+		/*		printf("updating app %d\n",a->oid);*/
 		a->trans_x=mo->trans_x;
 		a->trans_y=mo->trans_y;
 		a->trans_z=mo->trans_z;
 		a->r=mo->r;
-		if (a->init)
-		{
-			if (a==focus)
-			{
+		if (a->init) {
+			if (a==focus) {
 				focus_r=a->r;
 			} else {
 				s3d_scale(a->sphere,a->r);
@@ -324,32 +312,32 @@
 	a->sphere=s3d_clone(sphere);
 	s3d_scale(		a->sphere,a->r);
 	s3d_link(		a->sphere,a->oid);
-  	s3d_flags_on(	a->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(	a->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 
 	a->title=s3d_draw_string(a->name,&a->textw);
 
 	a->close_but=s3d_clone(close_but);
 	s3d_translate(	a->close_but,bsize*a->textw/2.0,1.2f,0.0f);
 	s3d_link(		a->close_but,a->sphere);
-  	s3d_flags_on(	a->close_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(	a->close_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 
 
 	s3d_translate(	a->title,-a->textw-1.2f,0.0f,0.0f);
 	s3d_link(		a->title,a->close_but);
-   	s3d_flags_on(	a->title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	
+	s3d_flags_on(	a->title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+
 	a->min_but=s3d_clone(min_but);
 	s3d_link(		a->min_but,a->close_but);
-	
-	
+
+
 	s3d_scale(		a->close_but,bsize);
-	
+
 	s3d_link(		a->oid,0);
 	a->init=1;
-/*	if (focus==NULL)
-		set_focus(a);
-	else*/
-		place_apps();
+	/*	if (focus==NULL)
+			set_focus(a);
+		else*/
+	place_apps();
 }
 int mcp_del_object(struct s3d_evt *hrmz)
 {
@@ -363,32 +351,26 @@
 	struct app *a;
 	unsigned int i, oid;
 	oid=*((unsigned int *)hrmz->buf);
-	a=apps;i=0;
-	if (oid==rotate)
-	{
+	a=apps;
+	i=0;
+	if (oid==rotate) {
 		rot_flag=!rot_flag;
 		return(0);
 	}
-	if (oid==reset)
-	{
+	if (oid==reset) {
 		s3d_translate(0,0.0,0.0,5.0);
 		s3d_rotate(0,0,0,0);
 	}
-	while (a!=NULL)
-	{
-		if (oid==a->close_but)
-		{
+	while (a!=NULL) {
+		if (oid==a->close_but) {
 			del_app(a->oid);
 			return(0);
-		} else 	if (oid==a->min_but)
-		{
-			if (a==focus)
-			{
+		} else 	if (oid==a->min_but) {
+			if (a==focus) {
 				set_focus(NULL); /* nothing is focused now */
 			}
 			return(0);
-		} else 	if (((oid==a->title) || (oid==a->sphere)) || (oid==a->oid))
-		{
+		} else 	if (((oid==a->title) || (oid==a->sphere)) || (oid==a->oid)) {
 			printf("giving focus to [%s], %d\n",a->name,oid);
 			set_focus(a);
 			return(0);
@@ -403,8 +385,7 @@
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz->buf;
-	if (inf->object==0)
-	{
+	if (inf->object==0) {
 		campos.x=inf->trans_x;
 		campos.y=inf->trans_y;
 		campos.z=inf->trans_z;
@@ -412,12 +393,10 @@
 		camrot.y=inf->rot_y;
 		camrot.z=inf->rot_z;
 
-		if (asp!=inf->scale)
-		{
+		if (asp!=inf->scale) {
 			asp=inf->scale;
 			printf("screen aspect: %f\n",asp);
-			if (asp>1.0) /* wide screen */
-			{
+			if (asp>1.0) { /* wide screen */
 				bottom=-1.0;
 				left=-asp;
 			} else {  /* high screen */
@@ -434,16 +413,15 @@
 	struct app *a;
 	float al,r;
 	int i;
-	a=apps;i=0;
-	while (a!=NULL)
-	{
+	a=apps;
+	i=0;
+	while (a!=NULL) {
 		if (!a->init)
 			app_init(a);
 		i++;
 		a=a->next;
 	}
-	if (rot_flag)
-	{
+	if (rot_flag) {
 		al=(alpha*M_PI/180);
 		r=(focus_r>20.0)?20.0:focus_r;
 		s3d_translate(0,sin(al)*(r+5),0,cos(al)*(r+5));
@@ -451,10 +429,8 @@
 		alpha=alpha+0.1;
 		if (alpha>360.0) alpha=0.0;
 	}
-	if (ego_mode)
-	{
-		if ((ydif!=0) || (xdif!=0))
-		{
+	if (ego_mode) {
+		if ((ydif!=0) || (xdif!=0)) {
 			campos.x+=ydif*sin((camrot.y*M_PI)/180);
 			campos.z+=ydif*cos((camrot.y*M_PI)/180);
 			campos.x+=xdif*cos((-camrot.y*M_PI)/180);
@@ -463,35 +439,50 @@
 			s3d_translate(	0,campos.x,campos.y,campos.z);
 		}
 	}
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 }
 
 int keydown(struct s3d_evt *event)
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
-	switch (keys->keysym)
-	{
-		case S3DK_F2:  ego_mode=(ego_mode+1)%2;
-				 xdif=0;
-			     ydif=0;
-				 printf("ego mode %d\n",ego_mode);
-				 break;
-		case 'w':ydif+=-1.0;break;
-		case 'a':xdif+=-1.0;break;
-		case 's':ydif+= 1.0;break;
-		case 'd':xdif+= 1.0;break;
+	switch (keys->keysym) {
+	case S3DK_F2:
+		ego_mode=(ego_mode+1)%2;
+		xdif=0;
+		ydif=0;
+		printf("ego mode %d\n",ego_mode);
+		break;
+	case 'w':
+		ydif+=-1.0;
+		break;
+	case 'a':
+		xdif+=-1.0;
+		break;
+	case 's':
+		ydif+= 1.0;
+		break;
+	case 'd':
+		xdif+= 1.0;
+		break;
 	}
 	return(0);
 }
 int keyup(struct s3d_evt *event)
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
-	switch (keys->keysym)
-	{
-		case 'w':ydif-=-1.0;break;
-		case 'a':xdif-=-1.0;break;
-		case 's':ydif-= 1.0;break;
-		case 'd':xdif-= 1.0;break;
+	switch (keys->keysym) {
+	case 'w':
+		ydif-=-1.0;
+		break;
+	case 'a':
+		xdif-=-1.0;
+		break;
+	case 's':
+		ydif-= 1.0;
+		break;
+	case 'd':
+		xdif-= 1.0;
+		break;
 	}
 	return(0);
 
@@ -507,13 +498,11 @@
 	s3d_set_callback(S3D_EVENT_KEYDOWN,keydown);
 	s3d_set_callback(S3D_EVENT_KEYUP,keyup);
 
-	if (!s3d_init(&argc,&argv,"mcp"))	
-	{
+	if (!s3d_init(&argc,&argv,"mcp")) {
 		if (!((argc>1) && (0==strcmp(argv[1],"--notorus"))))
-		greentorus(); /* just call ... */
+			greentorus(); /* just call ... */
 
-		if (s3d_select_font("vera"))
-		{
+		if (s3d_select_font("vera")) {
 			printf("font not found\n");
 		}
 		min_but=s3d_import_model_file("objs/btn_minimize.3ds");

Modified: trunk/apps/dot_mcp/menu.c
===================================================================
--- trunk/apps/dot_mcp/menu.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/dot_mcp/menu.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * menu.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of dot_mcp, a mcp for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * dot_mcp is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * dot_mcp is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with dot_mcp; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,25 +35,19 @@
 };
 static int go=-1;
 static int act;
-static struct menu_entry menu[]={
-		{"objs/comp.3ds","terminal","s3dvt",				0,0},
-		{"objs/comp.3ds","olsrs3d","olsrs3d",				0,0},
-		{"objs/comp.3ds","s3d_x11gate","s3d_x11gate",		0,0},
-		{"objs/comp.3ds","filebrowser","filebrowser",		0,0}, 
-		{"objs/comp.3ds","logout","LOGOUT",					0,0}, 
+static struct menu_entry menu[]= {
+	{"objs/comp.3ds","terminal","s3dvt",				0,0
+	}, {"objs/comp.3ds","olsrs3d","olsrs3d",				0,0}, {"objs/comp.3ds","s3d_x11gate","s3d_x11gate",		0,0}, {"objs/comp.3ds","filebrowser","filebrowser",		0,0}, {"objs/comp.3ds","logout","LOGOUT",					0,0},
 };
 void menu_click(int oid)
 {
 	unsigned int i;
 	char exec[256];
 	printf("%d got clicked\n",oid);
-	if (oid==go)
-	{
+	if (oid==go) {
 		act=!act;
-		for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++)
-		{
-			if (act)
-			{
+		for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++) {
+			if (act) {
 				s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 				s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			} else {
@@ -64,14 +58,10 @@
 		}
 		return;
 	}
-	if (act)
-	{
-		for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++)
-		{
-			if ((oid==menu[i].icon_oid) || (oid==menu[i].str_oid))
-			{
-				if (0==strncmp(menu[i].path,"LOGOUT",6))
-				{
+	if (act) {
+		for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++) {
+			if ((oid==menu[i].icon_oid) || (oid==menu[i].str_oid)) {
+				if (0==strncmp(menu[i].path,"LOGOUT",6)) {
 					s3d_quit();
 					return;
 				}
@@ -92,17 +82,16 @@
 	go=s3d_import_model_file("objs/s3dstart.3ds");
 	s3d_flags_on(go,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	s3d_link(go,menu_o);
-	for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++)
-	{
+	for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++) {
 		if (-1==(menu[i].icon_oid=s3d_import_model_file(menu[i].icon)))
-				menu[i].icon_oid=s3d_new_object();
+			menu[i].icon_oid=s3d_new_object();
 		menu[i].str_oid=s3d_draw_string(menu[i].name,NULL);
 		s3d_link(menu[i].str_oid,menu[i].icon_oid);
 		s3d_link(menu[i].icon_oid,menu_o);
 		s3d_translate(menu[i].icon_oid,0,-3+(-3*i),0);
 		s3d_translate(menu[i].str_oid,2,0,0);
-/*		s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);*/
+		/*		s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+				s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);*/
 		printf("menu item menu[%d], icon_oid=%d, icon_str=%d\n",i,menu[i].icon_oid,menu[i].str_oid);
 	}
 	return(menu_o);

Modified: trunk/apps/kism3d/gui.c
===================================================================
--- trunk/apps/kism3d/gui.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/kism3d/gui.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -43,7 +43,9 @@
 
 int Client_obj;
 
-struct timespec sleeptime = { 0, 100 * 1000 * 1000 };   /* 100 mili seconds */
+struct timespec sleeptime = {
+	0, 100 * 1000 * 1000
+};   /* 100 mili seconds */
 
 
 
@@ -73,8 +75,7 @@
 	i=0;
 	for (x=0;x<slices;x++) {
 		for (y=0;y<stacks;y++) {
-			if ((y!=0) && (y!=stacks)) /* no horizontal lines at the poles */
-			{
+			if ((y!=0) && (y!=stacks)) { /* no horizontal lines at the poles */
 				l[i*3+0]=(x*(stacks+1))+y;
 				l[i*3+1]=(((x+1)%slices)*(stacks+1))+y;
 				l[i*3+2]=0;
@@ -104,8 +105,8 @@
 	}
 	o=s3d_new_object();
 	s3d_push_material(o,0,0,1,
-			  1,0,0,
-			  0,1,0);
+	                  1,0,0,
+	                  0,1,0);
 	s3d_push_vertices(o,v,num_v);
 	s3d_push_lines(o,l,num_l);
 	s3d_load_line_normals(o,n,0,num_l);
@@ -117,7 +118,8 @@
 
 
 
-int handle_networks() {
+int handle_networks()
+{
 
 	struct list_head *network_pos;
 	struct wlan_network *wlan_network;
@@ -244,7 +246,8 @@
 
 
 
-int handle_clients() {
+int handle_clients()
+{
 
 	struct list_head *client_pos;
 	struct wlan_client *wlan_client;
@@ -307,7 +310,8 @@
  *
  ***/
 
-int object_click(struct s3d_evt *evt) {
+int object_click(struct s3d_evt *evt)
+{
 
 	struct list_head *network_pos;
 	struct wlan_network *wlan_network;
@@ -350,7 +354,8 @@
  *
  ***/
 
-int object_info(struct s3d_evt *hrmz) {
+int object_info(struct s3d_evt *hrmz)
+{
 
 	struct s3d_obj_info *inf;
 
@@ -375,7 +380,8 @@
 
 
 
-void mainloop() {
+void mainloop()
+{
 
 	float angle, diff_vec[3], tmp_vec[3] = { 0.0, 0.0, -1.0 };
 
@@ -417,7 +423,8 @@
 
 
 
-void* gui_main( void *unused ) {
+void* gui_main( void *unused )
+{
 
 	if ( !s3d_init( NULL, NULL, "kism3d" ) ) {
 

Modified: trunk/apps/kism3d/kism3d.c
===================================================================
--- trunk/apps/kism3d/kism3d.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/kism3d/kism3d.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -52,7 +52,8 @@
 
 
 
-void *alloc_memory( int len ) {
+void *alloc_memory( int len )
+{
 
 	void *res = malloc( len );
 
@@ -69,7 +70,8 @@
 
 
 
-void *realloc_memory( void *ptr, int len ) {
+void *realloc_memory( void *ptr, int len )
+{
 
 	void *res = realloc( ptr, len );
 
@@ -86,7 +88,8 @@
 
 
 
-unsigned int get_time( void ) {
+unsigned int get_time( void )
+{
 
 	struct timeval tv;
 
@@ -98,7 +101,8 @@
 
 
 
-void parse_buffer( struct kismet_src *kismet_src ) {
+void parse_buffer( struct kismet_src *kismet_src )
+{
 
 	struct wlan_network *wlan_network;
 	struct wlan_client *wlan_client;
@@ -129,44 +133,44 @@
 
 					switch ( kismet_src->enable_level ) {
 
-						case 0:
-							if ( write( kismet_src->sock, enable_alert, sizeof( enable_alert ) ) < 0 ) {
+					case 0:
+						if ( write( kismet_src->sock, enable_alert, sizeof( enable_alert ) ) < 0 ) {
 
-								printf( "Warning - can't send ENABLE ALERT message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno) );
+							printf( "Warning - can't send ENABLE ALERT message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno) );
 
-							}
+						}
 
-							break;
+						break;
 
-						case 1:
-							if ( write( kismet_src->sock, enable_client, sizeof( enable_client ) ) < 0 ) {
+					case 1:
+						if ( write( kismet_src->sock, enable_client, sizeof( enable_client ) ) < 0 ) {
 
-								printf( "Warning - can't send ENABLE CLIENT message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno) );
+							printf( "Warning - can't send ENABLE CLIENT message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno) );
 
-							}
+						}
 
-							break;
+						break;
 
-						case 2:
+					case 2:
 
-							if ( write( kismet_src->sock, enable_network, sizeof( enable_network ) ) < 0 ) {
+						if ( write( kismet_src->sock, enable_network, sizeof( enable_network ) ) < 0 ) {
 
-								printf( "Warning - can't send ENABLE NETWORK message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno) );
+							printf( "Warning - can't send ENABLE NETWORK message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno) );
 
-							}
+						}
 
-							break;
+						break;
 
-						case 3:
+					case 3:
 
-							if ( !thread_running ) {
+						if ( !thread_running ) {
 
-								thread_running++;
-								pthread_create( &s3d_thread_id, NULL, &gui_main, NULL );
+							thread_running++;
+							pthread_create( &s3d_thread_id, NULL, &gui_main, NULL );
 
-							}
+						}
 
-							break;
+						break;
 
 					}
 
@@ -188,33 +192,33 @@
 
 						switch ( count ) {
 
-							case 0:
-								bssid = parse_begin_ptr;
-								break;
+						case 0:
+							bssid = parse_begin_ptr;
+							break;
 
-							case 1:
-								type = parse_begin_ptr;
-								break;
+						case 1:
+							type = parse_begin_ptr;
+							break;
 
-							case 2:
-								channel = parse_begin_ptr;
-								break;
+						case 2:
+							channel = parse_begin_ptr;
+							break;
 
-							case 3:
-								/* ssids with spaces are quoted by kismet */
-								if ( parse_begin_ptr[0] == '\001' ) {
+						case 3:
+							/* ssids with spaces are quoted by kismet */
+							if ( parse_begin_ptr[0] == '\001' ) {
 
-									parse_begin_ptr++;
+								parse_begin_ptr++;
 
-									parse_end_ptr = strchr( parse_begin_ptr, '\001' );
-									*parse_end_ptr = '\0';
+								parse_end_ptr = strchr( parse_begin_ptr, '\001' );
+								*parse_end_ptr = '\0';
 
-									count++;
+								count++;
 
-								}
+							}
 
-								ssid = parse_begin_ptr;
-								break;
+							ssid = parse_begin_ptr;
+							break;
 
 						}
 
@@ -267,17 +271,17 @@
 
 						switch ( count ) {
 
-							case 0:
-								bssid = parse_begin_ptr;
-								break;
+						case 0:
+							bssid = parse_begin_ptr;
+							break;
 
-							case 1:
-								mac = parse_begin_ptr;
-								break;
+						case 1:
+							mac = parse_begin_ptr;
+							break;
 
-							case 2:
-								ip = parse_begin_ptr;
-								break;
+						case 2:
+							ip = parse_begin_ptr;
+							break;
 
 						}
 
@@ -353,7 +357,8 @@
 
 
 
-int main( int argc, char *argv[] ) {
+int main( int argc, char *argv[] )
+{
 
 	struct in_addr tmp_ip_holder;
 	struct kismet_src *kismet_src;

Modified: trunk/apps/kism3d/list.h
===================================================================
--- trunk/apps/kism3d/list.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/kism3d/list.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -76,8 +76,8 @@
  * the prev/next entries already!
  */
 static inline void __list_add(struct list_head *new,
-			      struct list_head *prev,
-			      struct list_head *next)
+                              struct list_head *prev,
+                              struct list_head *next)
 {
 	next->prev = new;
 	new->next = next;

Modified: trunk/apps/meshs3d/allocate.c
===================================================================
--- trunk/apps/meshs3d/allocate.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/meshs3d/allocate.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -34,16 +34,14 @@
 
 struct chunkHeader *chunkList = NULL;
 
-struct chunkHeader
-{
+struct chunkHeader {
 	struct chunkHeader *next;
 	uint32_t length;
 	int32_t tag;
 	uint32_t magicNumber;
 };
 
-struct chunkTrailer
-{
+struct chunkTrailer {
 	uint32_t magicNumber;
 };
 
@@ -54,8 +52,7 @@
 struct memoryUsage *memoryList = NULL;
 
 
-struct memoryUsage
-{
+struct memoryUsage {
 	struct memoryUsage *next;
 	uint32_t length;
 	uint32_t counter;
@@ -63,7 +60,8 @@
 };
 
 
-void addMemory( uint32_t length, int32_t tag ) {
+void addMemory( uint32_t length, int32_t tag )
+{
 
 	struct memoryUsage *walker;
 
@@ -95,7 +93,8 @@
 }
 
 
-void removeMemory( int32_t tag, int32_t freetag ) {
+void removeMemory( int32_t tag, int32_t freetag )
+{
 
 	struct memoryUsage *walker;
 
@@ -154,10 +153,8 @@
 #endif
 
 
-	for (walker = chunkList; walker != NULL; walker = walker->next)
-	{
-		if (walker->magicNumber != MAGIC_NUMBER)
-		{
+	for (walker = chunkList; walker != NULL; walker = walker->next) {
+		if (walker->magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, "checkIntegrity - invalid magic number in header: %08x, malloc tag = %d\n", walker->magicNumber, walker->tag);
 			exit(1);
 		}
@@ -166,8 +163,7 @@
 
 		chunkTrailer = (struct chunkTrailer *)(memory + sizeof(struct chunkHeader) + walker->length);
 
-		if (chunkTrailer->magicNumber != MAGIC_NUMBER)
-		{
+		if (chunkTrailer->magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, "checkIntegrity - invalid magic number in trailer: %08x, malloc tag = %d\n", chunkTrailer->magicNumber, walker->tag);
 			exit(1);
 		}
@@ -193,8 +189,7 @@
 
 	memory = malloc(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer));
 
-	if (memory == NULL)
-	{
+	if (memory == NULL) {
 		fprintf(stderr, "Cannot allocate %u bytes, malloc tag = %d\n", (unsigned int)(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer)), tag);
 		exit(1);
 	}
@@ -233,16 +228,14 @@
 		memory = memoryParameter;
 		chunkHeader = (struct chunkHeader *)(memory - sizeof(struct chunkHeader));
 
-		if (chunkHeader->magicNumber != MAGIC_NUMBER)
-		{
+		if (chunkHeader->magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, "debugRealloc - invalid magic number in header: %08x, malloc tag = %d\n", chunkHeader->magicNumber, chunkHeader->tag);
 			exit(1);
 		}
 
 		chunkTrailer = (struct chunkTrailer *)(memory + chunkHeader->length);
 
-		if (chunkTrailer->magicNumber != MAGIC_NUMBER)
-		{
+		if (chunkTrailer->magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, "debugRealloc - invalid magic number in trailer: %08x, malloc tag = %d\n", chunkTrailer->magicNumber, chunkHeader->tag);
 			exit(1);
 		}
@@ -275,24 +268,21 @@
 	memory = memoryParameter;
 	chunkHeader = (struct chunkHeader *)(memory - sizeof(struct chunkHeader));
 
-	if (chunkHeader->magicNumber != MAGIC_NUMBER)
-	{
+	if (chunkHeader->magicNumber != MAGIC_NUMBER) {
 		fprintf(stderr, "debugFree - invalid magic number in header: %08x, malloc tag = %d, free tag = %d\n", chunkHeader->magicNumber, chunkHeader->tag, tag);
 		exit(1);
 	}
 
 	previous = NULL;
 
-	for (walker = chunkList; walker != NULL; walker = walker->next)
-	{
+	for (walker = chunkList; walker != NULL; walker = walker->next) {
 		if (walker == chunkHeader)
 			break;
 
 		previous = walker;
 	}
 
-	if (walker == NULL)
-	{
+	if (walker == NULL) {
 		fprintf(stderr, "Double free detected, malloc tag = %d, free tag = %d\n", chunkHeader->tag, tag);
 		exit(1);
 	}
@@ -305,8 +295,7 @@
 
 	chunkTrailer = (struct chunkTrailer *)(memory + chunkHeader->length);
 
-	if (chunkTrailer->magicNumber != MAGIC_NUMBER)
-	{
+	if (chunkTrailer->magicNumber != MAGIC_NUMBER) {
 		fprintf(stderr, "debugFree - invalid magic number in trailer: %08x, malloc tag = %d, free tag = %d\n", chunkTrailer->magicNumber, chunkHeader->tag, tag);
 		exit(1);
 	}
@@ -337,8 +326,7 @@
 
 	result = malloc(length);
 
-	if (result == NULL)
-	{
+	if (result == NULL) {
 		fprintf(stderr, "Cannot allocate %u bytes, malloc tag = %d\n", length, tag);
 		exit(1);
 	}
@@ -352,8 +340,7 @@
 
 	result = realloc(memory, length);
 
-	if (result == NULL)
-	{
+	if (result == NULL) {
 		fprintf(stderr, "Cannot re-allocate %u bytes, malloc tag = %d\n", length, tag);
 		exit(1);
 	}

Modified: trunk/apps/meshs3d/hash.c
===================================================================
--- trunk/apps/meshs3d/hash.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/meshs3d/hash.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -24,7 +24,8 @@
 
 
 /* clears the hash */
-void hash_init(struct hashtable_t *hash) {
+void hash_init(struct hashtable_t *hash)
+{
 	int i;
 	hash->elements=0;
 	for (i=0 ; i<hash->size ; i++) {
@@ -36,7 +37,8 @@
 /* remove the hash structure. if hashdata_free_cb != NULL,
  * this function will be called to remove the elements inside of the hash.
  * if you don't remove the elements, memory might be leaked. */
-void hash_delete(struct hashtable_t *hash, hashdata_free_cb free_cb) {
+void hash_delete(struct hashtable_t *hash, hashdata_free_cb free_cb)
+{
 	struct element_t *bucket, *last_bucket;
 	int i;
 
@@ -61,7 +63,8 @@
 
 
 /* free only the hashtable and the hash itself. */
-void hash_destroy(struct hashtable_t *hash) {
+void hash_destroy(struct hashtable_t *hash)
+{
 
 	debugFree( hash->table, 1302 );
 	debugFree( hash, 1303 );
@@ -128,7 +131,7 @@
 
 	iter->index++;
 	while ( iter->index < hash->size ) {		/* go through the entries of the hash table */
-		if ((hash->table[ iter->index ]) != NULL){
+		if ((hash->table[ iter->index ]) != NULL) {
 			iter->prev_bucket = NULL;
 			iter->bucket = hash->table[ iter->index ];
 			iter->first_bucket = &hash->table[ iter->index ];
@@ -164,7 +167,8 @@
 
 
 /* adds data to the hashtable. returns 0 on success, -1 on error */
-int hash_add(struct hashtable_t *hash, void *data) {
+int hash_add(struct hashtable_t *hash, void *data)
+{
 	int index;
 	struct element_t *bucket, *prev_bucket = NULL;
 
@@ -198,7 +202,8 @@
 
 }
 /* finds data, based on the key in keydata. returns the found data on success, or NULL on error */
-void *hash_find(struct hashtable_t *hash, void *keydata) {
+void *hash_find(struct hashtable_t *hash, void *keydata)
+{
 	int index;
 	struct element_t *bucket;
 
@@ -219,7 +224,8 @@
 /* remove bucket (this might be used in hash_iterate() if you already found the bucket
  * you want to delete and don't need the overhead to find it again with hash_remove().
  * But usually, you don't want to use this function, as it fiddles with hash-internals. */
-void *hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t) {
+void *hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t)
+{
 	void *data_save;
 
 	data_save = hash_it_t->bucket->data;	/* save the pointer to the data */
@@ -242,7 +248,8 @@
  * so you can remove the used structure yourself, or NULL on error .
  * data could be the structure you use with just the key filled,
  * we just need the key for comparing. */
-void *hash_remove(struct hashtable_t *hash, void *data) {
+void *hash_remove(struct hashtable_t *hash, void *data)
+{
 	struct hash_it_t hash_it_t;
 
 	hash_it_t.index = hash->choose( data, hash->size );
@@ -290,7 +297,8 @@
 
 
 /* print the hash table for debugging */
-void hash_debug(struct hashtable_t *hash) {
+void hash_debug(struct hashtable_t *hash)
+{
 	int i;
 	struct element_t *bucket;
 

Modified: trunk/apps/meshs3d/main.c
===================================================================
--- trunk/apps/meshs3d/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/meshs3d/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -40,7 +40,9 @@
 
 /* global vars */
 struct glob Global;
-static struct timespec sleep_time = { 0, 100 * 1000 * 1000 };   /* 100 mili seconds */
+static struct timespec sleep_time = {
+	0, 100 * 1000 * 1000
+};   /* 100 mili seconds */
 
 
 void init_globals( void )
@@ -52,7 +54,7 @@
 	Global.obj_btn_close = 0;
 	Global.obj_s3d_url = 0;
 	Global.obj_zero_point = 0;
-		
+
 }
 
 
@@ -98,17 +100,15 @@
 	struct node *node;
 	struct hash_it_t *hashit;
 
-	if( node_hash->elements == 0 )
+	if ( node_hash->elements == 0 )
 		return;
 	hashit = NULL;
-	while ( NULL != ( hashit = hash_iterate( node_hash, hashit ) ) )
-	{
+	while ( NULL != ( hashit = hash_iterate( node_hash, hashit ) ) ) {
 		node = (struct node *) hashit->bucket->data;
-		if( node->node_type_modified ) {
-			
+		if ( node->node_type_modified ) {
+
 			node->node_type_modified = 0;
-			if ( node->obj_id != -1 )
-			{
+			if ( node->obj_id != -1 ) {
 				s3d_del_object( node->obj_id );
 			}
 
@@ -131,15 +131,16 @@
 
 void mov_add(float mov[], float p[], float fac)
 {
-/*	if (fac>1000)
-		return;
-	fac=1000; */
+	/*	if (fac>1000)
+			return;
+		fac=1000; */
 	mov[0]+=fac*p[0];
 	mov[1]+=fac*p[1];
 	mov[2]+=fac*p[2];
 }
 
-void move_meshnode( struct node *node ) {
+void move_meshnode( struct node *node )
+{
 	float null_vec[3] = {0,0,0};
 	float tmp_mov_vec[3];
 	float distance;
@@ -155,12 +156,13 @@
 			mov_add( node->pos_vec, node->mov_vec, 0.1 );
 
 		s3d_translate( node->obj_id, node->pos_vec[0], node->pos_vec[1], node->pos_vec[2] );
-			/* reset movement vector */
+		/* reset movement vector */
 		node->mov_vec[0] = node->mov_vec[1] = node->mov_vec[2] = 0.0;
 	}
 }
 
-void calc_node_mov( void ) {
+void calc_node_mov( void )
+{
 
 	float distance;
 	float tmp_mov_vec[3],vertex_buf[6];
@@ -170,28 +172,24 @@
 	struct node *first_node, *sec_node;
 	struct hash_it_t *hashit1, *hashit2;
 
-	if( con_hash->elements == 0 )
+	if ( con_hash->elements == 0 )
 		return;
 	hashit1 = hashit2 = NULL;
-	while ( NULL != ( hashit1 = hash_iterate( node_hash, hashit1 ) ) )
-	{
+	while ( NULL != ( hashit1 = hash_iterate( node_hash, hashit1 ) ) ) {
 		first_node = (struct node *) hashit1->bucket->data;
-		while ( NULL != ( hashit2 = hash_iterate( node_hash, hashit2 ) ) )
-		{
+		while ( NULL != ( hashit2 = hash_iterate( node_hash, hashit2 ) ) ) {
 			sec_node = (struct node *) hashit2->bucket->data;
-			if( first_node != sec_node )
-			{
+			if ( first_node != sec_node ) {
 				ip[0] = max(first_node->ip, sec_node->ip);
 				ip[1] = min(first_node->ip, sec_node->ip);
 				distance = dirt( first_node->pos_vec, sec_node->pos_vec, tmp_mov_vec );
-				if( NULL != ( con = hash_find(con_hash, ip ) ) )
-				{
+				if ( NULL != ( con = hash_find(con_hash, ip ) ) ) {
 					/* we have a connection */
 					f = ( ( con->etx1_sqrt + con->etx2_sqrt ) / 4.0 ) / distance;
 					mov_add( first_node->mov_vec, tmp_mov_vec,  1 / f - 1 );
 					mov_add( sec_node->mov_vec, tmp_mov_vec, -( 1 / f - 1 ) );
 					printf("------co---------\n%s %.2f %.2f %.2f\n%s %.2f %.2f %.2f\n", first_node->ip_string,first_node->mov_vec[0],first_node->mov_vec[1],first_node->mov_vec[2],
-						sec_node->ip_string,sec_node->mov_vec[0],sec_node->mov_vec[1],sec_node->mov_vec[2]  );
+					       sec_node->ip_string,sec_node->mov_vec[0],sec_node->mov_vec[1],sec_node->mov_vec[2]  );
 
 					vertex_buf[0] = first_node->pos_vec[0];
 					vertex_buf[1] = first_node->pos_vec[1];
@@ -202,10 +200,10 @@
 					s3d_pep_vertices( con->obj_id, vertex_buf, 2 );
 
 					s3d_pep_material( con->obj_id,
-						1.0,1.0,1.0,
-						1.0,1.0,1.0,
-						1.0,1.0,1.0
-					);
+					                  1.0,1.0,1.0,
+					                  1.0,1.0,1.0,
+					                  1.0,1.0,1.0
+					                );
 
 				} else {
 					/* we have no connection */
@@ -213,7 +211,7 @@
 					mov_add( first_node->mov_vec, tmp_mov_vec, 100 / ( distance * distance ) );
 					mov_add( sec_node->mov_vec, tmp_mov_vec, -100 / ( distance * distance ) );
 					printf("------nco---------\n%s %.2f %.2f %.2f\n%s %.2f %.2f %.2f\n", first_node->ip_string,first_node->mov_vec[0],first_node->mov_vec[1],first_node->mov_vec[2],
-						sec_node->ip_string,sec_node->mov_vec[0],sec_node->mov_vec[1],sec_node->mov_vec[2]  );
+					       sec_node->ip_string,sec_node->mov_vec[0],sec_node->mov_vec[1],sec_node->mov_vec[2]  );
 				}
 				move_meshnode( first_node );
 				move_meshnode( sec_node );
@@ -229,7 +227,7 @@
 		 * small factor: fast and strong drift to neighbours
 		 ***/
 		/* if ( f < Factor ) f = Factor; */
-		
+
 	}
 
 }
@@ -254,10 +252,11 @@
 }
 
 
-int main( int argc, char *argv[] ) {
+int main( int argc, char *argv[] )
+{
 	int optchar;
 	char olsr_host[256];
-	
+
 	init_globals();
 	strncpy( olsr_host, "127.0.0.1", 256 );
 	lbuf[0] = '\0';
@@ -266,18 +265,18 @@
 
 		switch ( optchar ) {
 
-			case 'd':
-				Global.debug = 1;
-				break;
+		case 'd':
+			Global.debug = 1;
+			break;
 
-			case 'H':
-				strncpy( olsr_host, optarg, 256 );
-				break;
+		case 'H':
+			strncpy( olsr_host, optarg, 256 );
+			break;
 
-			case 'h':
-			default:
-				print_usage();
-				return (0);
+		case 'h':
+		default:
+			print_usage();
+			return (0);
 
 		}
 
@@ -301,15 +300,13 @@
 
 	process_init();
 
-	if (!net_init(olsr_host))
-	{
+	if (!net_init(olsr_host)) {
 		/* s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
 		s3d_set_callback(S3D_EVENT_KEY,keypress);
 		s3d_set_callback(S3D_EVENT_QUIT,stop); */
 
-		if (!s3d_init(&argc,&argv,"meshs3d"))
-		{
+		if (!s3d_init(&argc,&argv,"meshs3d")) {
 
 			if (s3d_select_font("vera"))
 				printf("font not found\n");

Modified: trunk/apps/meshs3d/meshs3d.h
===================================================================
--- trunk/apps/meshs3d/meshs3d.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/meshs3d/meshs3d.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -30,8 +30,7 @@
 #define MAXDATASIZE 100			/* max number of bytes we can get at once  */
 
 /* linked list for the all connections */
-struct node_con
-{
+struct node_con {
 	unsigned int ip[2];
 	float etx1;							/* etx of left olsr node */
 	float etx2;						/* etx of right olsr node */
@@ -43,16 +42,14 @@
 };
 
 /* linked list for the neighbours of each olsr node */
-struct olsr_neigh_list
-{
+struct olsr_neigh_list {
 	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
 	struct olsr_con *olsr_con;							/* pointer to the connection */
 };
 
 
 /* we contruct a binary tree to handle the nodes */
-struct node 
-{
+struct node {
 	unsigned int ip;
 	char ip_string[NAMEMAX];		/* host ip */
 	int node_type;					/* normal = 0, internet gateway = 1, via hna announced network = 2 */
@@ -67,8 +64,7 @@
 };
 
 
-struct obj_to_ip
-{
+struct obj_to_ip {
 	int id;
 	struct olsr_node *olsr_node;
 	struct obj_to_ip *next;

Modified: trunk/apps/meshs3d/net.c
===================================================================
--- trunk/apps/meshs3d/net.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/meshs3d/net.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -43,36 +43,37 @@
 
 int net_init(char *host)
 {
-    struct hostent *he;
-    struct sockaddr_in their_addr; /* connector's address information  */
+	struct hostent *he;
+	struct sockaddr_in their_addr; /* connector's address information  */
 
-    if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
-        herror("gethostbyname");
-        return(1);
-    }
+	if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
+		herror("gethostbyname");
+		return(1);
+	}
 
-    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
-        perror("socket");
-        return(1);
-    }
+	if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
+		perror("socket");
+		return(1);
+	}
 
-    their_addr.sin_family = AF_INET;    /* host byte order  */
-    their_addr.sin_port = htons(PORT);  /* short, network byte order  */
-    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
-    memset(&(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
+	their_addr.sin_family = AF_INET;    /* host byte order  */
+	their_addr.sin_port = htons(PORT);  /* short, network byte order  */
+	their_addr.sin_addr = *((struct in_addr *)he->h_addr);
+	memset(&(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
 
-    if (connect(sockfd, (struct sockaddr *)&their_addr,
-                                          sizeof(struct sockaddr)) == -1) {
-        perror("connect");
-        return(1);
-    }
+	if (connect(sockfd, (struct sockaddr *)&their_addr,
+	                sizeof(struct sockaddr)) == -1) {
+		perror("connect");
+		return(1);
+	}
 	fcntl(sockfd,F_SETFL, O_NONBLOCK);
 	return(0);
 }
 
-int net_main() {
+int net_main()
+{
 	static int net_read_count = 0;
-	
+
 	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
 		if (errno==EAGAIN)
 			return(0); /* well, that's okay ... */
@@ -122,9 +123,9 @@
 
 int net_quit()
 {
-    close(sockfd);
+	close(sockfd);
 
-    return 0;
+	return 0;
 }
 
 

Modified: trunk/apps/meshs3d/process.c
===================================================================
--- trunk/apps/meshs3d/process.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/meshs3d/process.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -57,8 +57,7 @@
 	uint32_t hash = 0;
 	size_t i;
 
-	for (i = 0; i < 8; i++)
-	{
+	for (i = 0; i < 8; i++) {
 		hash += key[i];
 		hash += (hash << 10);
 		hash ^= (hash >> 6);
@@ -124,8 +123,7 @@
 	ip[1] = min(ip1,ip2);
 
 	con = ( struct node_con* ) hash_find( con_hash, ip);
-	if( con == NULL )
-	{
+	if ( con == NULL ) {
 		con = ( struct node_con * ) debugMalloc( sizeof( struct node_con ), 102 );
 		con->ip[0] = ip[0];
 		con->ip[1] = ip[1];
@@ -139,8 +137,7 @@
 		hash_add( con_hash, con );
 	}
 
-	if( con->ip[0] == ip1 )
-	{
+	if ( con->ip[0] == ip1 ) {
 		con->etx1 = etx;
 		con->etx1_sqrt = sqrt( etx );
 	} else {
@@ -149,8 +146,7 @@
 	}
 
 
-	if ( con_hash->elements * 4 > con_hash->size )
-	{
+	if ( con_hash->elements * 4 > con_hash->size ) {
 		swaphash = hash_resize( con_hash, con_hash->size * 2 );
 		if ( swaphash == NULL )
 			exit_error("Couldn't resize hash table \n");
@@ -164,8 +160,7 @@
 	struct node *orig_node;
 	struct hashtable_t *swaphash;
 
-	if ( node_hash->elements * 4 > node_hash->size )
-	{
+	if ( node_hash->elements * 4 > node_hash->size ) {
 		swaphash = hash_resize( node_hash, node_hash->size * 2 );
 		if ( swaphash == NULL )
 			exit_error("Couldn't resize hash table \n" );
@@ -173,8 +168,7 @@
 	}
 	orig_node = (struct node *) hash_find( node_hash, ip );
 
-	if( NULL == orig_node )
-	{
+	if ( NULL == orig_node ) {
 		orig_node = (struct node *)debugMalloc( sizeof(struct node), 101 );
 		orig_node->ip = *ip;
 		strncpy( orig_node->ip_string, ip_string, NAMEMAX );
@@ -213,63 +207,55 @@
 	dn = 0;
 
 
-	while ( (*lbuf_ptr) != '\0' )
-	{
-		if ( (*lbuf_ptr) == '\n' )
-		{
+	while ( (*lbuf_ptr) != '\0' ) {
+		if ( (*lbuf_ptr) == '\n' ) {
 			last_cr_ptr = lbuf_ptr;
 			con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
 			dn = 0;
 		}
 
-		if ( (*lbuf_ptr) == '"' )
-		{
-			switch ( dn )
-			{
-				case 0:
-					con_from = lbuf_ptr + 1;
-					break;
-				case 1:
-					con_from_end = lbuf_ptr;
-					break;
-				case 2:
-					con_to = lbuf_ptr + 1;
-					break;
-				case 3:
-					con_to_end = lbuf_ptr;
-					break;
-				case 4:
-					etx = lbuf_ptr + 1;
-					break;
-				case 5:
-					etx_end = lbuf_ptr;
-					break;
+		if ( (*lbuf_ptr) == '"' ) {
+			switch ( dn ) {
+			case 0:
+				con_from = lbuf_ptr + 1;
+				break;
+			case 1:
+				con_from_end = lbuf_ptr;
+				break;
+			case 2:
+				con_to = lbuf_ptr + 1;
+				break;
+			case 3:
+				con_to_end = lbuf_ptr;
+				break;
+			case 4:
+				etx = lbuf_ptr + 1;
+				break;
+			case 5:
+				etx_end = lbuf_ptr;
+				break;
 			}
 
-			if ( ++dn == 6 )
-			{
+			if ( ++dn == 6 ) {
 
 				(*con_from_end) = (*con_to_end) = (*etx_end) = '\0';
 
 				/* if( Global.debug ) printf( "con_from: %s, con_to: %s, etx: %s\n", con_from, con_to, etx ); */
 
 				/* announced network via HNA */
-				if ( strncmp( etx, "HNA", NAMEMAX ) == 0 )
-				{
+				if ( strncmp( etx, "HNA", NAMEMAX ) == 0 ) {
 
 				} else {
 
 					f = strtod(etx,NULL);
 					if ( f < 1.0 )
 						f = 999.0;
-				
-					if( inet_pton(AF_INET, con_from, &int_con_from ) < 1 )
-					{
+
+					if ( inet_pton(AF_INET, con_from, &int_con_from ) < 1 ) {
 						printf("%s is not a valid ip address\n", con_from );
 						continue;
 					}
-					if( inet_pton(AF_INET, con_to, &int_con_to ) < 1 )
-					{
+					if ( inet_pton(AF_INET, con_to, &int_con_to ) < 1 ) {
 						printf("%s is not a valid ip address\n", con_to );
 						continue;
 					}

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/olsrs3d/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -41,7 +41,9 @@
 
 #define SPEED		10.0
 
-static struct timespec sleep_time = { 0, 100 * 1000 * 1000 };   /* 100 mili seconds */
+static struct timespec sleep_time = {
+	0, 100 * 1000 * 1000
+};   /* 100 mili seconds */
 
 int Debug = 0;
 
@@ -96,7 +98,8 @@
  *
  ***/
 
-void print_usage( void ) {
+void print_usage( void )
+{
 
 	printf( "Usage is olsrs3d [options] [-- [s3d options]]\n" );
 	printf( "olsrs3d options:\n" );
@@ -108,13 +111,15 @@
 }
 
 
-void close_win(s3dw_widget *button) {
+void close_win(s3dw_widget *button)
+{
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 }
 
 
 
-void window_help() {
+void window_help()
+{
 
 	s3dw_surface *infwin;
 	s3dw_button  *button;
@@ -149,7 +154,8 @@
 }
 
 
-void window_error(char *msg) {
+void window_error(char *msg)
+{
 
 	s3dw_surface *infwin;
 	s3dw_button  *button;
@@ -170,7 +176,8 @@
  *
  ***/
 
-void out_of_mem( void ) {
+void out_of_mem( void )
+{
 
 	printf( "Sorry - you ran out of memory !\n" );
 	exit(8);
@@ -179,7 +186,8 @@
 
 
 
-unsigned int get_time(void) {
+unsigned int get_time(void)
+{
 
 	struct timeval tv;
 
@@ -258,9 +266,9 @@
 
 void mov_add(float mov[], float p[], float fac)
 {
-/*	if (fac>1000)
-		return;
-	fac=1000; */
+	/*	if (fac>1000)
+			return;
+		fac=1000; */
 	mov[0]+=fac*p[0];
 	mov[1]+=fac*p[1];
 	mov[2]+=fac*p[2];
@@ -276,7 +284,8 @@
  *
  ***/
 
-void handle_olsr_node( struct olsr_node *olsr_node ) {
+void handle_olsr_node( struct olsr_node *olsr_node )
+{
 
 	float distance, angle, angle_rad;
 	float tmp_mov_vec[3], desc_norm_vec[3] = {0,0,-1};
@@ -489,7 +498,8 @@
  *
  ***/
 
-void calc_olsr_node_mov( void ) {
+void calc_olsr_node_mov( void )
+{
 
 	float distance;
 	float tmp_mov_vec[3];
@@ -524,7 +534,8 @@
  *
  ***/
 
-void move_olsr_nodes( void ) {
+void move_olsr_nodes( void )
+{
 
 	float null_vec[3] = {0,0,0}, vertex_buf[6];
 	float tmp_mov_vec[3];
@@ -590,11 +601,11 @@
 			/* HNA */
 			if ( olsr_con->left_etx == -1000.00 ) {
 
-				if(olsr_con->color != 1) {
+				if (olsr_con->color != 1) {
 					s3d_pep_material( olsr_con->obj_id,
-								   0.0,0.0,1.0,
-								   0.0,0.0,1.0,
-								   0.0,0.0,1.0);
+					                  0.0,0.0,1.0,
+					                  0.0,0.0,1.0,
+					                  0.0,0.0,1.0);
 					olsr_con->color = 1;
 				}
 
@@ -605,82 +616,82 @@
 				/* very good link - bright blue */
 				if ( ( etx >= 1.0 ) && ( etx < 1.5 ) ) {
 
-					if(olsr_con->color != 2) {
+					if (olsr_con->color != 2) {
 						s3d_pep_material( olsr_con->obj_id,
-								0.5,1.0,1.0,
-								0.5,1.0,1.0,
-								0.5,1.0,1.0);
+						                  0.5,1.0,1.0,
+						                  0.5,1.0,1.0,
+						                  0.5,1.0,1.0);
 						olsr_con->color = 2;
 					}
 
-				/* good link - bright yellow */
+					/* good link - bright yellow */
 				} else if ( ( etx >= 1.5 ) && ( etx < 2.0 ) ) {
 
 					rgb = 2.0 - etx;
-					if( olsr_con->color != 3 || (olsr_con->color == 3 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
+					if ( olsr_con->color != 3 || (olsr_con->color == 3 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
 						s3d_pep_material( olsr_con->obj_id,
-								1.0,1.0,rgb,
-								1.0,1.0,rgb,
-								1.0,1.0,rgb);
+						                  1.0,1.0,rgb,
+						                  1.0,1.0,rgb,
+						                  1.0,1.0,rgb);
 						olsr_con->color = 3;
 
 						olsr_con->rgb =  rgb;
 					}
 
-				/* not so good link - orange */
+					/* not so good link - orange */
 				} else if ( ( etx >= 2.0 ) && ( etx < 3.0 ) ) {
 
 					rgb = 1.5 - ( etx / 2.0 );
-					if( olsr_con->color != 4 || (olsr_con->color == 4 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
+					if ( olsr_con->color != 4 || (olsr_con->color == 4 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
 						s3d_pep_material( olsr_con->obj_id,
-								1.0,rgb,0.0,
-								1.0,rgb,0.0,
-								1.0,rgb,0.0);
+						                  1.0,rgb,0.0,
+						                  1.0,rgb,0.0,
+						                  1.0,rgb,0.0);
 						olsr_con->color = 4;
 
 						olsr_con->rgb = rgb;
 					}
 
-				/* bad link (almost dead) - brown */
+					/* bad link (almost dead) - brown */
 				} else if ( ( etx >= 3.0 ) && ( etx < 5.0 ) ) {
 
 					rgb = 1.75 - ( etx / 4.0 );
 
-					if( olsr_con->color != 5 || (olsr_con->color == 5 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
+					if ( olsr_con->color != 5 || (olsr_con->color == 5 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
 
 						s3d_pep_material( olsr_con->obj_id,
-								rgb,rgb - 0.5,0.0,
-								rgb,rgb - 0.5,0.0,
-								rgb,rgb - 0.5,0.0);
+						                  rgb,rgb - 0.5,0.0,
+						                  rgb,rgb - 0.5,0.0,
+						                  rgb,rgb - 0.5,0.0);
 						olsr_con->color = 5;
 
 						olsr_con->rgb = rgb;
 					}
 
-				/* zombie link - grey */
+					/* zombie link - grey */
 				} else if ( ( etx >= 5.0 ) && ( etx < 1000.0 ) ) {
 
 					rgb = 1000.0 / ( 1500.0 + etx );
 
-					if( olsr_con->color != 6 || (olsr_con->color == 6 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
+					if ( olsr_con->color != 6 || (olsr_con->color == 6 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
 
 						s3d_pep_material( olsr_con->obj_id,
-								rgb,rgb,rgb,
-								rgb,rgb,rgb,
-								rgb,rgb,rgb);
+						                  rgb,rgb,rgb,
+						                  rgb,rgb,rgb,
+						                  rgb,rgb,rgb);
 						olsr_con->color = 6;
 
 						olsr_con->rgb = rgb;
 					}
 
-				/* wtf - dark grey */
+					/* wtf - dark grey */
 				} else {
 
-					if(olsr_con->color != 7) {
+					if (olsr_con->color != 7) {
 						s3d_pep_material( olsr_con->obj_id,
-								0.3,0.3,0.3,
-								0.3,0.3,0.3,
-								0.3,0.3,0.3);
+						                  0.3,0.3,0.3,
+						                  0.3,0.3,0.3,
+						                  0.3,0.3,0.3);
 						olsr_con->color = 7;
 					}
 
@@ -690,11 +701,11 @@
 
 		} else {
 
-			if(olsr_con->color != 0) {
+			if (olsr_con->color != 0) {
 				s3d_pep_material( olsr_con->obj_id,
-							1.0,1.0,1.0,
-							1.0,1.0,1.0,
-							1.0,1.0,1.0);
+				                  1.0,1.0,1.0,
+				                  1.0,1.0,1.0,
+				                  1.0,1.0,1.0);
 				olsr_con->color = 0;
 			}
 
@@ -709,7 +720,8 @@
 
 
 
-void mainloop() {
+void mainloop()
+{
 
 	int net_result;   /* result of function net_main */
 	char nc_str[20];
@@ -755,7 +767,7 @@
 	}
 
 	/* rotate modus */
-	if(RotateSwitch) {
+	if (RotateSwitch) {
 		Zp_rotate = ( Zp_rotate + RotateSpeed ) > 360 ? 0.0 : ( Zp_rotate + RotateSpeed );
 		s3d_rotate(ZeroPoint,0,Zp_rotate,0);
 	}
@@ -766,16 +778,15 @@
 	CamPosition2[0][2]=  CamPosition[0][0]*sin(Zp_rotate*M_PI/180.0) + CamPosition[0][2] * cos (Zp_rotate*M_PI/180.0);
 
 	/* check search status */
-/*	if( get_search_status() == WIDGET )
-		move_to_search_widget( CamPosition[0], CamPosition[1] );*/
-	if( get_search_status() == FOLLOW )
+	/*	if( get_search_status() == WIDGET )
+			move_to_search_widget( CamPosition[0], CamPosition[1] );*/
+	if ( get_search_status() == FOLLOW )
 		follow_node( CamPosition[0], CamPosition[1], Zp_rotate );
-/*	if( get_search_status() == ABORT )
-		move_to_return_point( CamPosition[0], CamPosition[1] );*/
+	/*	if( get_search_status() == ABORT )
+			move_to_return_point( CamPosition[0], CamPosition[1] );*/
 
 
-	if( Olsr_ip_label_obj != -1 )
-	{
+	if ( Olsr_ip_label_obj != -1 ) {
 		print_etx();
 	}
 	s3dw_ani_mate();
@@ -786,7 +797,8 @@
 
 }
 
-int stop() {
+int stop()
+{
 	s3d_quit();
 	net_quit();
 	return(0);
@@ -798,90 +810,86 @@
  *
  ***/
 
-int keypress(struct s3d_evt *event) {
+int keypress(struct s3d_evt *event)
+{
 
 	struct s3d_key_event *key=(struct s3d_key_event *)event->buf;
-	if( get_search_status() != WIDGET )
-	{
-		switch(key->keysym)
-		{
-			case S3DK_F1: /* help */
+	if ( get_search_status() != WIDGET ) {
+		switch (key->keysym) {
+		case S3DK_F1: /* help */
 
-				window_help();
-				break;
+			window_help();
+			break;
 
-			case S3DK_ESCAPE: /* abort action */
+		case S3DK_ESCAPE: /* abort action */
 
-				set_search_status( get_search_status() == WIDGET ? ABORT : NOTHING );
-				break;
+			set_search_status( get_search_status() == WIDGET ? ABORT : NOTHING );
+			break;
 
-			case S3DK_s: /* move to search widget, give widget focus */
+		case S3DK_s: /* move to search widget, give widget focus */
 
-				set_search_status(WIDGET);							/* set status for mainloop */
-				set_node_root( Olsr_root );
-				show_search_window();
-/*				set_return_point(CamPosition[0],CamPosition[1]);	/ * save the return position * /
-				set_node_root( Olsr_root );*/
+			set_search_status(WIDGET);							/* set status for mainloop */
+			set_node_root( Olsr_root );
+			show_search_window();
+			/*				set_return_point(CamPosition[0],CamPosition[1]);	/ * save the return position * /
+							set_node_root( Olsr_root );*/
 
-				break;
+			break;
 
-			case S3DK_c: /* color on/off */
+		case S3DK_c: /* color on/off */
 
-				ColorSwitch =  ColorSwitch ? 0 : 1;
-				break;
+			ColorSwitch =  ColorSwitch ? 0 : 1;
+			break;
 
-			case S3DK_r: /* rotate start/stop*/
+		case S3DK_r: /* rotate start/stop*/
 
-				RotateSwitch = RotateSwitch ? 0 : 1;
-				break;
+			RotateSwitch = RotateSwitch ? 0 : 1;
+			break;
 
-			case S3DK_PLUS: /* rotate speed increase */
+		case S3DK_PLUS: /* rotate speed increase */
 
-				if(RotateSwitch && RotateSpeed < 5)
-				{
-					if(RotateSpeed >= 1.0)
-						RotateSpeed += 1.0;
-					else
-						RotateSpeed += 0.1;
-				}
-				break;
+			if (RotateSwitch && RotateSpeed < 5) {
+				if (RotateSpeed >= 1.0)
+					RotateSpeed += 1.0;
+				else
+					RotateSpeed += 0.1;
+			}
+			break;
 
-			case S3DK_MINUS: /* - -> rotate speed decrease */
+		case S3DK_MINUS: /* - -> rotate speed decrease */
 
-				if(RotateSwitch)
-				{
-					if( RotateSpeed >= 2.0 )
-						RotateSpeed -= 1.0;
-					else {
-						if(RotateSpeed > 0.2)
-							RotateSpeed -= 0.1;
-					}
+			if (RotateSwitch) {
+				if ( RotateSpeed >= 2.0 )
+					RotateSpeed -= 1.0;
+				else {
+					if (RotateSpeed > 0.2)
+						RotateSpeed -= 0.1;
 				}
-				break;
+			}
+			break;
 
-			case S3DK_p: /* strg + p -> reset nodes ( zeroPoint to 0,0,0 ) */
-				if (key->modifier&(S3D_KMOD_LCTRL|S3D_KMOD_RCTRL))
-				{
-					s3d_rotate(ZeroPoint, 0, 0, 0);
-					Zp_rotate = 0.0;
-				}
-				break;
+		case S3DK_p: /* strg + p -> reset nodes ( zeroPoint to 0,0,0 ) */
+			if (key->modifier&(S3D_KMOD_LCTRL|S3D_KMOD_RCTRL)) {
+				s3d_rotate(ZeroPoint, 0, 0, 0);
+				Zp_rotate = 0.0;
+			}
+			break;
 
-			case S3DK_PAGEUP: /* change factor in calc_olsr_node_mov */
+		case S3DK_PAGEUP: /* change factor in calc_olsr_node_mov */
 
-				if(Factor < 0.9)
-					Factor += 0.1;
-				break;
+			if (Factor < 0.9)
+				Factor += 0.1;
+			break;
 
-			case S3DK_PAGEDOWN: /* change factor in calc_olsr_node_mov */
+		case S3DK_PAGEDOWN: /* change factor in calc_olsr_node_mov */
 
-				if(Factor > 0.3)
-					Factor -= 0.1;
-				break;
+			if (Factor > 0.3)
+				Factor -= 0.1;
+			break;
 
 		}
 	} else {
-		if( (key->keysym >= S3DK_PERIOD && key->keysym <= S3DK_9) || key->keysym == S3DK_COMMA || key->keysym == S3DK_RETURN || key->keysym == S3DK_BACKSPACE )
+		if ( (key->keysym >= S3DK_PERIOD && key->keysym <= S3DK_9) || key->keysym == S3DK_COMMA || key->keysym == S3DK_RETURN || key->keysym == S3DK_BACKSPACE )
 			search_widget_write( key->keysym );
 	}
 	return(0);
@@ -895,18 +903,18 @@
 
 int object_click(struct s3d_evt *evt)
 {
-/*	int i
-	char ip_str[50];
-	struct timeval tv;*/
+	/*	int i
+		char ip_str[50];
+		struct timeval tv;*/
 	struct olsr_node *olsr_node;
 	int oid;
 
 	s3dw_handle_click(evt);
-/*	if( get_search_status() == WIDGET )
-	{
-		s3dw_handle_click(evt);
-		return;
-	}*/
+	/*	if( get_search_status() == WIDGET )
+		{
+			s3dw_handle_click(evt);
+			return;
+		}*/
 
 	oid=(int)*((uint32_t *)evt->buf);
 
@@ -924,55 +932,55 @@
 	Last_Click_Time = get_time();
 
 
-/*	if( oid == Btn_close_id )
-	{
-		s3d_del_object(Btn_close_id);
-		s3d_del_object(Olsr_ip_label_obj);
-		Btn_close_id = Olsr_ip_label_obj = -1;
-		for(i=0; i < Size; i++)
-			s3d_del_object( Olsr_neighbour_label_obj[i] );
-		free(Olsr_neighbour_label_obj);
-		Olsr_neighbour_label_obj = NULL;
-		for(i = 0; i < 4; i++)
+	/*	if( oid == Btn_close_id )
 		{
-			if(Output_border[i] != -1)
-				s3d_del_object(Output_border[i]);
-			Output_border[i] = -1;
+			s3d_del_object(Btn_close_id);
+			s3d_del_object(Olsr_ip_label_obj);
+			Btn_close_id = Olsr_ip_label_obj = -1;
+			for(i=0; i < Size; i++)
+				s3d_del_object( Olsr_neighbour_label_obj[i] );
+			free(Olsr_neighbour_label_obj);
+			Olsr_neighbour_label_obj = NULL;
+			for(i = 0; i < 4; i++)
+			{
+				if(Output_border[i] != -1)
+					s3d_del_object(Output_border[i]);
+				Output_border[i] = -1;
+			}
+			return;
 		}
-		return;
-	}
 
-	Olsr_node_pEtx = *lst_search(oid);
+		Olsr_node_pEtx = *lst_search(oid);
 
-	if( Olsr_node_pEtx != NULL )
-	{
-		if( Btn_close_id == -1 )
+		if( Olsr_node_pEtx != NULL )
 		{
-			Btn_close_id = s3d_clone( Btn_close_obj );
-			s3d_link(Btn_close_id,0);
-			s3d_flags_on(Btn_close_id,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_scale( Btn_close_id, 0.10 );
-			s3d_translate( Btn_close_id,-Left*3.0-0.150, -Bottom*3.0-0.9, -3.0 );
-		}
+			if( Btn_close_id == -1 )
+			{
+				Btn_close_id = s3d_clone( Btn_close_obj );
+				s3d_link(Btn_close_id,0);
+				s3d_flags_on(Btn_close_id,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+				s3d_scale( Btn_close_id, 0.10 );
+				s3d_translate( Btn_close_id,-Left*3.0-0.150, -Bottom*3.0-0.9, -3.0 );
+			}
 
-		if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
-		snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
-		Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
-		s3d_link( Olsr_ip_label_obj, 0 );
-		s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_ip_label_obj, 0.2 );
-		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.2, -3.0 );
+			if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
+			snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
+			Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
+			s3d_link( Olsr_ip_label_obj, 0 );
+			s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
+			s3d_scale( Olsr_ip_label_obj, 0.2 );
+			s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.2, -3.0 );
 
-		cam_go=1;
-		if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
-		snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
-		Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
-		s3d_link( Olsr_ip_label_obj, 0 );
-		s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_ip_label_obj, 0.2 );
-		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
+			cam_go=1;
+			if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
+			snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
+			Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
+			s3d_link( Olsr_ip_label_obj, 0 );
+			s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
+			s3d_scale( Olsr_ip_label_obj, 0.2 );
+			s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
 
-	}*/
+		}*/
 	return(0);
 }
 
@@ -983,10 +991,9 @@
 	int i;
 	float len = 0.0, max_len=0.0;
 
-	if( Olsr_neighbour_label_obj != NULL )
-	{
+	if ( Olsr_neighbour_label_obj != NULL ) {
 		/* int n = sizeof(Olsr_neighbour_label_obj) / sizeof(int);*/
-		for(i=0; i < Size; i++)
+		for (i=0; i < Size; i++)
 			s3d_del_object( Olsr_neighbour_label_obj[i] );
 		free(Olsr_neighbour_label_obj);
 		Olsr_neighbour_label_obj = NULL;
@@ -995,8 +1002,7 @@
 	tmpNeighbour = Olsr_node_pEtx->olsr_neigh_list;
 
 	Size = 0;
-	while(tmpNeighbour != NULL)
-	{
+	while (tmpNeighbour != NULL) {
 		Size++;
 		tmpNeighbour = tmpNeighbour->next_olsr_neigh_list;
 	}
@@ -1004,12 +1010,11 @@
 	Olsr_neighbour_label_obj = malloc(Size*sizeof(int));
 	tmpNeighbour = Olsr_node_pEtx->olsr_neigh_list;
 
-	for(i = 0; i < Size ;i++)
-	{
+	for (i = 0; i < Size ;i++) {
 		char nIpStr[60];
 		float mEtx = ( tmpNeighbour->olsr_con->left_etx + tmpNeighbour->olsr_con->right_etx ) / 2;
 
-		if( mEtx != -1000 )
+		if ( mEtx != -1000 )
 			snprintf(nIpStr, 60, "%15s --> %.2f",(strcmp(Olsr_node_pEtx->ip,tmpNeighbour->olsr_con->right_olsr_node->ip)?tmpNeighbour->olsr_con->right_olsr_node->ip:tmpNeighbour->olsr_con->left_olsr_node->ip),mEtx);
 		else
 			snprintf(nIpStr, 60, "%15s --> HNA",(strcmp(Olsr_node_pEtx->ip,tmpNeighbour->olsr_con->right_olsr_node->ip)?tmpNeighbour->olsr_con->right_olsr_node->ip:tmpNeighbour->olsr_con->left_olsr_node->ip));
@@ -1026,17 +1031,14 @@
 		/* printf("title: %f len: %f maxlen: %f %s\n",Title_len,len,max_len-0.2,nIpStr);*/
 	}
 
-	if( Btn_close_id != -1)
-	{
-		if( Output_border[0] == -1 )
-		{
-			for(i = 0; i < 4; i++)
-			{
+	if ( Btn_close_id != -1) {
+		if ( Output_border[0] == -1 ) {
+			for (i = 0; i < 4; i++) {
 				Output_border[i] = s3d_new_object();
 				s3d_push_material( Output_border[i],
-					1.0,1.0,1.0,
-					1.0,1.0,1.0,
-					1.0,1.0,1.0);
+				                   1.0,1.0,1.0,
+				                   1.0,1.0,1.0,
+				                   1.0,1.0,1.0);
 			}
 			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,			-Bottom*3.0-0.9, -3.0);
 			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
@@ -1098,8 +1100,7 @@
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz->buf;
 	s3dw_object_info(hrmz);
-	if (inf->object==0)
-	{
+	if (inf->object==0) {
 		CamPosition[0][0] = inf->trans_x;
 		CamPosition[0][1] = inf->trans_y;
 		CamPosition[0][2] = inf->trans_z;
@@ -1107,8 +1108,7 @@
 		CamPosition[1][1] = inf->rot_y;
 		CamPosition[1][2] = inf->rot_z;
 		Asp=inf->scale;
-		if (Asp>1.0) /* wide screen */
-		{
+		if (Asp>1.0) { /* wide screen */
 			Bottom=-1.0;
 			Left=-Asp;
 		} else {  /* high screen */
@@ -1130,7 +1130,8 @@
 	return(0);
 }
 
-int main( int argc, char *argv[] ) {
+int main( int argc, char *argv[] )
+{
 
 	int optchar;
 	strncpy( Olsr_host, "127.0.0.1", 256 );
@@ -1140,18 +1141,18 @@
 
 		switch ( optchar ) {
 
-			case 'd':
-				Debug = 1;
-				break;
+		case 'd':
+			Debug = 1;
+			break;
 
-			case 'H':
-				strncpy( Olsr_host, optarg, 256 );
-				break;
+		case 'H':
+			strncpy( Olsr_host, optarg, 256 );
+			break;
 
-			case 'h':
-			default:
-				print_usage();
-				return (0);
+		case 'h':
+		default:
+			print_usage();
+			return (0);
 
 		}
 
@@ -1174,15 +1175,13 @@
 	optind = 0;
 
 
-	if (!net_init(Olsr_host))
-	{
+	if (!net_init(Olsr_host)) {
 		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
 		s3d_set_callback(S3D_EVENT_KEY,keypress);
 		s3d_set_callback(S3D_EVENT_QUIT,stop);
 
-		if (!s3d_init(&argc,&argv,"olsrs3d"))
-		{
+		if (!s3d_init(&argc,&argv,"olsrs3d")) {
 
 			if (s3d_select_font("vera"))
 				printf("font not found\n");

Modified: trunk/apps/olsrs3d/net.c
===================================================================
--- trunk/apps/olsrs3d/net.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/olsrs3d/net.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -44,34 +44,35 @@
 int sockfd, numbytes;
 int net_init(char *host)
 {
-    struct hostent *he;
-    struct sockaddr_in their_addr; /* connector's address information  */
+	struct hostent *he;
+	struct sockaddr_in their_addr; /* connector's address information  */
 
-    if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
-        herror("gethostbyname");
-        return(1);
-    }
+	if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
+		herror("gethostbyname");
+		return(1);
+	}
 
-    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
-        perror("socket");
-        return(1);
-    }
+	if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
+		perror("socket");
+		return(1);
+	}
 
-    their_addr.sin_family = AF_INET;    /* host byte order  */
-    their_addr.sin_port = htons(PORT);  /* short, network byte order  */
-    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
-    memset(&(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
+	their_addr.sin_family = AF_INET;    /* host byte order  */
+	their_addr.sin_port = htons(PORT);  /* short, network byte order  */
+	their_addr.sin_addr = *((struct in_addr *)he->h_addr);
+	memset(&(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
 
-    if (connect(sockfd, (struct sockaddr *)&their_addr,
-                                          sizeof(struct sockaddr)) == -1) {
-        perror("connect");
-        return(1);
-    }
+	if (connect(sockfd, (struct sockaddr *)&their_addr,
+	                sizeof(struct sockaddr)) == -1) {
+		perror("connect");
+		return(1);
+	}
 	fcntl(sockfd,F_SETFL, O_NONBLOCK);
 	return(0);
 }
 
-int net_main() {
+int net_main()
+{
 
 	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
 		if (errno==EAGAIN)
@@ -121,9 +122,9 @@
 
 int net_quit()
 {
-    close(sockfd);
+	close(sockfd);
 
-    return 0;
+	return 0;
 }
 
 

Modified: trunk/apps/olsrs3d/process.c
===================================================================
--- trunk/apps/olsrs3d/process.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/olsrs3d/process.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -50,7 +50,8 @@
  *
  ***/
 
-int add_olsr_con( struct olsr_node *con_from, struct olsr_node *con_to, float etx ) {
+int add_olsr_con( struct olsr_node *con_from, struct olsr_node *con_to, float etx )
+{
 
 	struct olsr_con **olsr_con = &Con_begin;
 	struct olsr_con *prev_olsr_con = NULL;   /* previous olsr connection */
@@ -95,9 +96,9 @@
 		/* add connection color */
 		(*olsr_con)->color = 0;
 		s3d_push_material( (*olsr_con)->obj_id,
-				  1.0,1.0,1.0,
-				  1.0,1.0,1.0,
-				  1.0,1.0,1.0);
+		                   1.0,1.0,1.0,
+		                   1.0,1.0,1.0,
+		                   1.0,1.0,1.0);
 
 		/* add connection endpoints */
 		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->left_olsr_node->pos_vec[0], (*olsr_con)->left_olsr_node->pos_vec[1], (*olsr_con)->left_olsr_node->pos_vec[2] );
@@ -163,7 +164,8 @@
  *
  ***/
 
-void *get_olsr_node( struct olsr_node **olsr_node, char *ip ) {
+void *get_olsr_node( struct olsr_node **olsr_node, char *ip )
+{
 
 	int result;   /* result of strcmp */
 
@@ -247,10 +249,11 @@
  *
  */
 
-void lst_initialize() {
+void lst_initialize()
+{
 	Obj_to_ip_head = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
 	Obj_to_ip_end = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	if(Obj_to_ip_head == NULL || Obj_to_ip_end == NULL)
+	if (Obj_to_ip_head == NULL || Obj_to_ip_end == NULL)
 		out_of_mem();
 	Obj_to_ip_head->id = 0;
 	Obj_to_ip_end->id = 0;
@@ -267,10 +270,11 @@
  *
  */
 
-void lst_add(int id,struct olsr_node **olsr_node) {
+void lst_add(int id,struct olsr_node **olsr_node)
+{
 	struct Obj_to_ip *new;
 	new = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	if(new == NULL)
+	if (new == NULL)
 		out_of_mem();
 	new->id = id;
 	new->olsr_node = *olsr_node;
@@ -289,11 +293,11 @@
  *
  */
 
-void lst_del(int id) {
+void lst_del(int id)
+{
 	struct Obj_to_ip *del;
 	move_lst_ptr(&id);
-	if(id != List_ptr->id)
-	{
+	if (id != List_ptr->id) {
 		printf("obj2ip: remove id %d failed move_lst_ptr return id %d\n",id,List_ptr->next->id);
 	} else {
 		del = List_ptr;
@@ -314,19 +318,19 @@
 struct olsr_node *move_lst_ptr(int *id) {
 	/* printf("obj2ip: move for %d\n",*id); */
 	/* head to point at end or id lass then first element in linked list*/
-	if(Obj_to_ip_head->next == Obj_to_ip_head || *id < Obj_to_ip_head->next->id) {
+	if (Obj_to_ip_head->next == Obj_to_ip_head || *id < Obj_to_ip_head->next->id) {
 		List_ptr = Obj_to_ip_head;
 		return NULL;
- 	/* id is greather then last element in linked list */
-	} else if(*id > Obj_to_ip_end->prev->id) {
+		/* id is greather then last element in linked list */
+	} else if (*id > Obj_to_ip_end->prev->id) {
 		List_ptr = Obj_to_ip_end->prev;
 		return NULL;
 	} else {
 		/* printf("obj2ip: ok i search deeper ;-) for id=%d\n",*id); */
-		if((*id - (int) Obj_to_ip_head->next->id) <= ((int)(Obj_to_ip_end->prev->id)-*id)) {
+		if ((*id - (int) Obj_to_ip_head->next->id) <= ((int)(Obj_to_ip_end->prev->id)-*id)) {
 			List_ptr = Obj_to_ip_head;
 			/* printf("obj2ip: start at head id %d - %d <= %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id); */
-			while(*id >= List_ptr->next->id) {
+			while (*id >= List_ptr->next->id) {
 				/* printf("obj2ip: %d > %d move to ",*id,List_ptr->id); */
 				List_ptr = List_ptr->next;
 				/* printf("%d\n",List_ptr->id); */
@@ -335,7 +339,7 @@
 			List_ptr = Obj_to_ip_end;
 			/* printf("obj2ip: start at end id %d - %d > %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id);  */
 			/*  do List_ptr = List_ptr->prev; while(*id > List_ptr->prev->id); */
-			while(*id < List_ptr->prev->id) {
+			while (*id < List_ptr->prev->id) {
 				/* printf("obj2ip: %d < %d move to ",*id,List_ptr->id); */
 				List_ptr = List_ptr->prev;
 				/* printf("%d\n",List_ptr->id); */
@@ -371,16 +375,18 @@
 
 }
 
-void lst_out() {
+void lst_out()
+{
 	struct Obj_to_ip *ptr;
 	ptr = Obj_to_ip_head;
-	while(ptr != ptr->next) {
+	while (ptr != ptr->next) {
 		printf("id-> %d\n",ptr->id);
 		ptr = ptr->next;
 	}
 }
 
-int process_main() {
+int process_main()
+{
 
 	int dn;
 	float f;
@@ -415,24 +421,24 @@
 
 			switch ( dn ) {
 
-				case 0:
-					con_from = lbuf_ptr + 1;
-					break;
-				case 1:
-					con_from_end = lbuf_ptr;
-					break;
-				case 2:
-					con_to = lbuf_ptr + 1;
-					break;
-				case 3:
-					con_to_end = lbuf_ptr;
-					break;
-				case 4:
-					etx = lbuf_ptr + 1;
-					break;
-				case 5:
-					etx_end = lbuf_ptr;
-					break;
+			case 0:
+				con_from = lbuf_ptr + 1;
+				break;
+			case 1:
+				con_from_end = lbuf_ptr;
+				break;
+			case 2:
+				con_to = lbuf_ptr + 1;
+				break;
+			case 3:
+				con_to_end = lbuf_ptr;
+				break;
+			case 4:
+				etx = lbuf_ptr + 1;
+				break;
+			case 5:
+				etx_end = lbuf_ptr;
+				break;
 
 			}
 
@@ -459,11 +465,10 @@
 
 						}
 
-					/* normal HNA */
+						/* normal HNA */
 					} else {
 						memmove(hna_node,con_to,NAMEMAX);
-						if( (tmpChar = strchr(hna_node, (int)'/')))
-						{
+						if ( (tmpChar = strchr(hna_node, (int)'/'))) {
 							tmpChar++;
 							address = (int)-inet_network(tmpChar);
 							sprintf(hna_name,"%d",(int)(32 - ceil(log(address)/log(2))));
@@ -485,7 +490,7 @@
 
 					}
 
-				/* normal node */
+					/* normal node */
 				} else {
 
 					olsr_node1 = get_olsr_node( &Olsr_root, con_from );

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/olsrs3d/search.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -50,10 +50,10 @@
 void follow_node(float cam_position_t[], float cam_position_r[],float rotate)
 {
 	float real_node_pos[3],
-		  cam_target[3],
-		  tmp_vec[3],
-		  diff_vec[3],
-		  angle;
+	cam_target[3],
+	tmp_vec[3],
+	diff_vec[3],
+	angle;
 
 	real_node_pos[0] =  (*search_node)->pos_vec[0] * cos( rotate * M_PI / 180.0 ) - (*search_node)->pos_vec[2] * -sin ( rotate * M_PI / 180.0 );
 	real_node_pos[1] =  (*search_node)->pos_vec[1];
@@ -147,7 +147,9 @@
 /* public */
 void move_search_widget(float x, float y, float z)
 {
-	_search_widget->x = x; _search_widget->y = y; _search_widget->z = z;
+	_search_widget->x = x;
+	_search_widget->y = y;
+	_search_widget->z = z;
 	s3dw_moveit( _search_widget );
 }
 
@@ -164,27 +166,27 @@
 	target = _search_widget->arx;
 	current = cam_position_r[0];
 
-	if( _search_widget->arx - cam_position_r[0] > 180 )
+	if ( _search_widget->arx - cam_position_r[0] > 180 )
 		target -= 360;
-	if( _search_widget->arx - cam_position_r[0] < -180 )
+	if ( _search_widget->arx - cam_position_r[0] < -180 )
 		current -= 360;
 	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
 
 	target = _search_widget->ary;
 	current = cam_position_r[1];
 
-	if( _search_widget->ary - cam_position_r[1] > 180 )
+	if ( _search_widget->ary - cam_position_r[1] > 180 )
 		target -= 360;
-	if( _search_widget->ary - cam_position_r[1] < -180 )
+	if ( _search_widget->ary - cam_position_r[1] < -180 )
 		current -= 360;
 	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
 
 	target = _search_widget->arz;
 	current = cam_position_r[2];
 
-	if( _search_widget->arz - cam_position_r[2] > 180 )
+	if ( _search_widget->arz - cam_position_r[2] > 180 )
 		target -= 360;
-	if( _search_widget->arz - cam_position_r[2] < -180 )
+	if ( _search_widget->arz - cam_position_r[2] < -180 )
 		current -= 360;
 	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
 
@@ -192,9 +194,8 @@
 	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
 
 	if ( sqrt(  (( cam_position_t[0] - _search_widget->x)*( cam_position_t[0] - _search_widget->x)) +
-				(( cam_position_t[1] - _search_widget->y)*( cam_position_t[1] - _search_widget->y)) +
-				(( cam_position_t[2] - _search_widget->z)*( cam_position_t[2] - _search_widget->z)) ) < 0.2 )
-	{
+	                (( cam_position_t[1] - _search_widget->y)*( cam_position_t[1] - _search_widget->y)) +
+	                (( cam_position_t[2] - _search_widget->z)*( cam_position_t[2] - _search_widget->z)) ) < 0.2 ) {
 		s3d_translate( 0, _search_widget->x, _search_widget->y, ( _search_widget->z - 10 ) );
 		s3d_rotate( 0, _search_widget->arx, _search_widget->ary, _search_widget->arz );
 	}
@@ -212,27 +213,27 @@
 	target = _return_point[1][0];
 	current = cam_position_r[0];
 
-	if( _return_point[1][0] - cam_position_r[0] > 180 )
+	if ( _return_point[1][0] - cam_position_r[0] > 180 )
 		target -= 360;
-	if( _return_point[1][0] - cam_position_r[0] < -180 )
+	if ( _return_point[1][0] - cam_position_r[0] < -180 )
 		current -= 360;
 	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
 
 	target = _return_point[1][1];
 	current = cam_position_r[1];
 
-	if( _return_point[1][1] - cam_position_r[1] > 180 )
+	if ( _return_point[1][1] - cam_position_r[1] > 180 )
 		target -= 360;
-	if( _return_point[1][1] - cam_position_r[1] < -180 )
+	if ( _return_point[1][1] - cam_position_r[1] < -180 )
 		current -= 360;
 	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
 
 	target = _return_point[1][2];
 	current = cam_position_r[2];
 
-	if( _return_point[1][2] - cam_position_r[2] > 180 )
+	if ( _return_point[1][2] - cam_position_r[2] > 180 )
 		target -= 360;
-	if( _return_point[1][2] - cam_position_r[2] < -180 )
+	if ( _return_point[1][2] - cam_position_r[2] < -180 )
 		current -= 360;
 	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
 
@@ -240,9 +241,8 @@
 	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
 
 	if ( sqrt(  (( cam_position_t[0] - _return_point[0][0])*( cam_position_t[0] - _return_point[0][0])) +
-				(( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) +
-				(( cam_position_t[2] - _return_point[0][2])*( cam_position_t[2] - _return_point[0][2])) ) < 0.2 )
-	{
+	                (( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) +
+	                (( cam_position_t[2] - _return_point[0][2])*( cam_position_t[2] - _return_point[0][2])) ) < 0.2 ) {
 		s3d_translate( 0, _return_point[0][0], _return_point[0][1], _return_point[0][2] );
 		s3d_rotate( 0, _return_point[1][0], _return_point[1][1], _return_point[1][2] );
 		set_search_status(NOTHING);
@@ -260,16 +260,14 @@
 	static char s[20];
 	int ln = strlen(s);
 
-	if( key == S3DK_COMMA ) key = S3DK_PERIOD;
+	if ( key == S3DK_COMMA ) key = S3DK_PERIOD;
 
-	if( key != S3DK_RETURN )
-	{
-		if( key == S3DK_BACKSPACE )
-		{
-			if( ln > 0 )
+	if ( key != S3DK_RETURN ) {
+		if ( key == S3DK_BACKSPACE ) {
+			if ( ln > 0 )
 				s[ln-1] = '\0';
 		} else {
-			if( ln < 20 )
+			if ( ln < 20 )
 				s[ln] = key;
 		}
 		s3dw_input_change_text( _search_input, s );
@@ -282,9 +280,9 @@
 void set_return_point(float cam_position_t[], float cam_position_r[])
 {
 	int i;
-	for( i = 0; i < 3; i++ )
+	for ( i = 0; i < 3; i++ )
 		_return_point[0][i] = cam_position_t[i];
-	for( i = 0; i < 3; i++ )
+	for ( i = 0; i < 3; i++ )
 		_return_point[1][i] = cam_position_r[i];
 }
 
@@ -316,8 +314,7 @@
 
 	ip = s3dw_input_gettext( _search_input );
 
-	while ( (*search_node) != NULL )
-	{
+	while ( (*search_node) != NULL ) {
 
 		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
 
@@ -335,18 +332,16 @@
 	_search_widget=NULL;
 
 
-	if( (*search_node) != NULL )
-	{
+	if ( (*search_node) != NULL ) {
 		set_search_status( FOLLOW );
-	}
-	else
-	{
+	} else {
 		window_error("Sorry, could not find...");
 		set_search_status( NOTHING );
 	}
 }
 /* public */
-void follow_node_by_click(struct olsr_node *olsr_node) {
+void follow_node_by_click(struct olsr_node *olsr_node)
+{
 	search_node = &_node_root;
 	(*search_node) = olsr_node;
 	set_search_status( FOLLOW );
@@ -362,8 +357,7 @@
 
 	ip = s3dw_input_gettext( _search_input );
 
-	while ( (*search_node) != NULL )
-	{
+	while ( (*search_node) != NULL ) {
 
 		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
 
@@ -376,7 +370,7 @@
 			(*search_node) = (*search_node)->left;
 	}
 
-	if( (*search_node) != NULL )
+	if ( (*search_node) != NULL )
 		set_search_status( FOLLOW );
 }
 

Modified: trunk/apps/olsrs3d/structs.h
===================================================================
--- trunk/apps/olsrs3d/structs.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/olsrs3d/structs.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -28,8 +28,7 @@
 #define MAXDATASIZE 100			/* max number of bytes we can get at once  */
 
 /* linked list for the all connections */
-struct olsr_con 
-{
+struct olsr_con {
 	struct olsr_con *next_olsr_con;			/* pointer to next connection */
 	struct olsr_con *prev_olsr_con;			/* pointer to previous connection */
 	struct olsr_node *left_olsr_node;		/* pointer to left end point of the connection */
@@ -45,16 +44,14 @@
 
 
 /* linked list for the neighbours of each olsr node */
-struct olsr_neigh_list
-{
+struct olsr_neigh_list {
 	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
 	struct olsr_con *olsr_con;							/* pointer to the connection */
 };
 
 
 /* we contruct a binary tree to handle the nodes */
-struct olsr_node 
-{
+struct olsr_node {
 	struct olsr_node *left;
 	struct olsr_node *right;
 	char ip[NAMEMAX];				/* host ip */
@@ -71,8 +68,7 @@
 };
 
 
-struct Obj_to_ip
-{
+struct Obj_to_ip {
 	int id;
 	struct olsr_node *olsr_node;
 	struct Obj_to_ip *next;

Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * s3d_x11gate.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d_x11gate, a 3d gateway for x11 desktops.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d_x11gate is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d_x11gate is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d_x11gate; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,7 +35,9 @@
 #include <sys/time.h> 	/* gettimeofday */
 #include <sys/ipc.h>
 #include <sys/shm.h>
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+static struct timespec t= {
+	0,100*1000*1000
+}; /* 100 mili seconds */
 
 int oid;
 XImage *image;
@@ -57,8 +59,7 @@
 int get_shift(unsigned long t)
 {
 	int i=0;
-	while (t)
-	{
+	while (t) {
 		t>>=1;
 		i++;
 	}
@@ -77,16 +78,15 @@
 	start.tv_sec	=end.tv_sec;
 	start.tv_usec 	=end.tv_usec;
 
-/*	image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);*/
+	/*	image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);*/
 	XShmGetImage(dpy, window, image, 0,0,0xffffffff);
 	gettimeofday(&end,NULL);
 	count[1]+=(end.tv_sec-start.tv_sec)*10000000 + end.tv_usec-start.tv_usec;
 	start.tv_sec	=end.tv_sec;
 	start.tv_usec 	=end.tv_usec;
-	if (image->format==ZPixmap)
-	{
+	if (image->format==ZPixmap) {
 		printf("Ximage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n",image->width,image->height,image->format,ZPixmap,
-					image->bits_per_pixel,image->depth,image->bitmap_pad);
+		       image->bits_per_pixel,image->depth,image->bitmap_pad);
 		rs=get_shift(image->red_mask)-8;
 		gs=get_shift(image->green_mask)-8;
 		bs=get_shift(image->blue_mask)-8;
@@ -97,50 +97,44 @@
 		gs=gs-8;
 		bs=bs-16;
 		printf("Ximage: rgb: %d|%d|%d\n",	rs,gs,bs);;
-/*		printf("red: size %d, offset %d\n",rs,roff);
-		printf("green: size %d, offset %d\n",gs,goff);
-		printf("blue: size %d, offset %d\n",bs,boff);
-		printf("bits per pixel:%d\n",bpp);*/
+		/*		printf("red: size %d, offset %d\n",rs,roff);
+				printf("green: size %d, offset %d\n",gs,goff);
+				printf("blue: size %d, offset %d\n",bs,boff);
+				printf("bits per pixel:%d\n",bpp);*/
 		last_change=-1;
 		start_change=-1;
-		for (y=0;y<height;y++)
-		{
-			
-			for (x=0;x<width;x++)
-			{
+		for (y=0;y<height;y++) {
+
+			for (x=0;x<width;x++) {
 				d=*((unsigned long *)(image->data+(y*width+x)*bpp));
 				((unsigned long *)tex_image)[(y*width+x)]=
-						(rs>0?((d&image->red_mask)>>rs):	((d&image->red_mask)<<-rs))|
-						(gs>0?((d&image->green_mask)>>gs):	((d&image->green_mask)<<-gs))|
-						(bs>0?((d&image->blue_mask)>>bs):	((d&image->blue_mask)<<-bs))|
-						255<<24;
+				        (rs>0?((d&image->red_mask)>>rs):	((d&image->red_mask)<<-rs))|
+				        (gs>0?((d&image->green_mask)>>gs):	((d&image->green_mask)<<-gs))|
+				        (bs>0?((d&image->blue_mask)>>bs):	((d&image->blue_mask)<<-bs))|
+				        255<<24;
 				if (((unsigned long *)tex_image)[(y*width+x)]!=
-					((unsigned long *)otex_image)[(y*width+x)])
+				                ((unsigned long *)otex_image)[(y*width+x)])
 					last_change=y;
 			}
-			if (last_change!=-1)
-			{
-				if (start_change==-1)
-				{
+			if (last_change!=-1) {
+				if (start_change==-1) {
 					start_change=y;
-/* 					printf("setting start_change to %d\n",start_change); */
+					/* 					printf("setting start_change to %d\n",start_change); */
 				}
-				if (last_change!=y)
-				{	 /*  last change is already over, post it! */
+				if (last_change!=y) {	 /*  last change is already over, post it! */
 					s3d_load_texture(oid,0,0,start_change,width,last_change-start_change+1,(unsigned char *)tex_image+start_change*width*4);
 					start_change=-1;
 					last_change=-1;
 				}
 			}
 		}
-		 /*  posting the last bit, maybe */
-		if (last_change!=-1)
-		{
-/*			printf("last one: [%d-%d]",start_change,last_change);*/
+		/*  posting the last bit, maybe */
+		if (last_change!=-1) {
+			/*			printf("last one: [%d-%d]",start_change,last_change);*/
 			s3d_load_texture(oid,0,0,start_change,width,last_change-start_change,(unsigned char *)tex_image+start_change*width*4);
 		}
-/* 		s3d_load_texture(oid,0,0,0,width,height,tex_image); */
-		 /*  swap images */
+		/* 		s3d_load_texture(oid,0,0,0,width,height,tex_image); */
+		/*  swap images */
 		swap_timg=tex_image;
 		tex_image=otex_image;
 		otex_image=swap_timg;
@@ -150,8 +144,8 @@
 	start.tv_sec	=end.tv_sec;
 	start.tv_usec 	=end.tv_usec;
 	iterations++;
-/*	XDestroyImage(image);*/
-/*	nanosleep(&t,NULL); */
+	/*	XDestroyImage(image);*/
+	/*	nanosleep(&t,NULL); */
 }
 int keypress(struct s3d_evt *event)
 {
@@ -159,23 +153,21 @@
 	int kc;
 	key=*((unsigned short *)event->buf);
 	printf("received key %d ",key);
-    kc = XKeysymToKeycode(dpy, key);
-	if (kc==0) 
-	{
-	    kc = XKeysymToKeycode(dpy, 0xFF00+ key);
+	kc = XKeysymToKeycode(dpy, key);
+	if (kc==0) {
+		kc = XKeysymToKeycode(dpy, 0xFF00+ key);
 		printf(" (%04x) ",0xFF00+key);
 	}
-	if (kc==0)
-	{
-		if (key==8)
-		{
-			kc=22; printf("!backspace!");
+	if (kc==0) {
+		if (key==8) {
+			kc=22;
+			printf("!backspace!");
 		}
 	}
 	printf("using key: %d, keycode %d (%04x)\n",key,kc,kc);
 	if (kc!=0)
-	    XTestFakeKeyEvent(dpy, kc, 1, 1);
-/*	    XTestFakeKeyEvent(dpy, kc, 0, 1);*/
+		XTestFakeKeyEvent(dpy, kc, 1, 1);
+	/*	    XTestFakeKeyEvent(dpy, kc, 0, 1);*/
 	return(0);
 
 }
@@ -185,7 +177,7 @@
 	printf("thats it, collecting:\n");
 	for (i=0;i<3;i++)
 		printf("[%d] %f\n",i,count[i]/iterations);
-	exit(0);	
+	exit(0);
 	return(0);
 }
 int main(int argc, char **argv)
@@ -196,15 +188,13 @@
 	if (disp==NULL) disp=getenv("DISPLAY");
 	if (disp==NULL) disp="";  /*  fallback */
 	dpy = XOpenDisplay(disp);
-	if (!dpy)
-	{
+	if (!dpy) {
 		printf("couldn't open display\n");
 		return(-1);
 	}
 	count[0]=count[1]=count[2]=0;
 	iterations=0;
-	if (!s3d_init(&argc,&argv,"X11-gate"))
-	{
+	if (!s3d_init(&argc,&argv,"X11-gate")) {
 		scr = DefaultScreen(dpy);
 		window = RootWindow(dpy, scr);
 		width = DisplayWidth(dpy, scr);
@@ -214,23 +204,22 @@
 		XLockDisplay(dpy);
 		xt=XTestQueryExtension(dpy,&a,&b,&c,&d);
 		XUnlockDisplay(dpy);
-		if (xt)
-		{
+		if (xt) {
 			printf("having xtest extension ...\n");
 		}
-/* X11 shm - http://www.xfree86.org/current/mit-shm.html */
-		
+		/* X11 shm - http://www.xfree86.org/current/mit-shm.html */
+
 		image= XShmCreateImage(dpy, visual, depth, ZPixmap, NULL, &shminfo, width, height);
 		shminfo.shmid = shmget(IPC_PRIVATE, image->bytes_per_line * image->height, IPC_CREAT|0777);
 		shminfo.shmaddr = image->data = shmat (shminfo.shmid, 0, 0);
 		shmctl(shminfo.shmid, IPC_RMID, 0);
 		shminfo.readOnly= False;
-		if (!XShmAttach(dpy, &shminfo)) 
+		if (!XShmAttach(dpy, &shminfo))
 			printf("cannot use the shared memory segment .. :( \n");
 		else
 			printf("can use share segment :D\n");
 		XSync(dpy, False);
-		
+
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,mouseclick);
 		s3d_set_callback(S3D_EVENT_KEY,keypress);
 		printf("screen: %dx%d\n",width,height);
@@ -244,19 +233,19 @@
 		s3d_push_vertex(oid, 5, 5,0);
 		s3d_push_vertex(oid,-5, 5,0);
 		s3d_push_material_a(oid,
-						0.8,	0.0,	0.0	,1.0,
-						1.0,	1.0,	1.0	,1.0,
-						0.8,	0.0,	0.0	,1.0);
+		                    0.8,	0.0,	0.0	,1.0,
+		                    1.0,	1.0,	1.0	,1.0,
+		                    0.8,	0.0,	0.0	,1.0);
 		s3d_push_polygon(oid,0,2,1,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,1.0, 
-									   1.0,0.0,
-									   1.0,1.0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,1.0,
+		                          1.0,0.0,
+		                          1.0,1.0);
 		s3d_push_polygon(oid,0,3,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,1.0, 
-									   0.0,0.0,
-									   1.0,0.0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,1.0,
+		                          0.0,0.0,
+		                          1.0,0.0);
 		s3d_push_texture(oid,width,height);
-					 /*  push data on texture 0 position (0,0) */
+		/*  push data on texture 0 position (0,0) */
 		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
 		s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 		gettimeofday(&start,NULL);

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/animation.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * animation.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -43,24 +43,21 @@
 /* add an node on the animation stack */
 void ani_add(t_node *f)
 {
-	if (ani_n<MAXANI)
-	{
+	if (ani_n<MAXANI) {
 		if (-1!=ani_onstack(f))
 			return;		/* already in list */
 		ani_s[ani_n]=f;
 		ani_iterate(f);
-	/*	printf("[A]ni ADD %d\n",ani_n); */
+		/*	printf("[A]ni ADD %d\n",ani_n); */
 		ani_n++;
-	}
-	else /* no place, finish now */
+	} else /* no place, finish now */
 		ani_finish(f,-1);
 }
 /* delete an node from the animation stack */
 void ani_del(int i)
 {
-	if ((i>=0) && (i<ani_n))
-	{
-/*		printf("[A]ni DEL %d\n",i);*/
+	if ((i>=0) && (i<ani_n)) {
+		/*		printf("[A]ni DEL %d\n",i);*/
 		ani_n--;
 		ani_s[i]=ani_s[ani_n]; /* that should also work if i is the last one */
 	} else {
@@ -111,17 +108,14 @@
 	int i;
 	t_node *f;
 	s3dw_ani_mate();
-	for (i=0;i<ani_n;i++)
-	{
+	for (i=0;i<ani_n;i++) {
 		f=ani_s[i];
-		if (f->oid==-1)
-		{ /* kick out bad animations */
+		if (f->oid==-1) { /* kick out bad animations */
 			ani_del(i);
 			i--;
 		} else {
 			ani_iterate(f);
-			if (ani_check(f))
-			{
+			if (ani_check(f)) {
 				ani_finish(f,i);
 				i--; /* a new object is here now, take care in the next iteration */
 			} else {

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/box.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * box.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -31,11 +31,11 @@
 	box_buildblock(dir);
 	box_sidelabel(dir);
 	ani_doit(dir);
-    s3d_flags_on(dir->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir->objs.close,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir->objs.title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir->objs.select,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir->objs.titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(dir->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(dir->objs.close,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(dir->objs.title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(dir->objs.select,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(dir->objs.titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	dir->disp=D_DIR;
 	box_draw_icons(dir);
 }
@@ -45,8 +45,7 @@
 {
 	int i;
 	printf("box_draw_icons(%s, %d subs)\n",dir->name, dir->n_sub);
-	for (i=0;i<dir->n_sub;i++)
-	{
+	for (i=0;i<dir->n_sub;i++) {
 		if (dir->sub[i]->disp==D_NONE)	icon_draw(dir->sub[i]);
 	}
 	box_order_icons(dir);
@@ -57,8 +56,7 @@
 void box_sidelabel(t_node *dir)
 {
 	float len;
-	if (dir->objs.str==-1)
-	{
+	if (dir->objs.str==-1) {
 		dir->objs.str=s3d_draw_string(dir->name,&len);
 		if (len<2) len=2;
 		dir->objs.strlen=len;
@@ -73,11 +71,11 @@
 /* gives another color for the focused box */
 void box_focus_color(t_node *dir, int on)
 {
-	
+
 	s3d_pep_material(dir->oid,
-						0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
-						0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
-						0.5+on*0.3,0.5+on*0.3,0.5+on*0.3);
+	                 0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
+	                 0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
+	                 0.5+on*0.3,0.5+on*0.3,0.5+on*0.3);
 
 }
 /* creates a big block which will hold files and subdirs on top */
@@ -86,70 +84,66 @@
 	char fname[30];
 	char *fullname=fname;
 	float len;
-	float vertices[]=
-			{-BHP,0,-BHP,
-			 -BHP,0, BHP,
-			  BHP,0, BHP,
-			  BHP,0,-BHP,
-			 -BHP,BHH,-BHP,
-			 -BHP,BHH, BHP,
-			  BHP,BHH, BHP,
-			  BHP,BHH,-BHP,
-			 -1,0, 0.8,
-			 -1,BOXHEIGHT, 0.8,
-			  1,BOXHEIGHT, 0.8,
-			  1,0, 0.8
-				};
-	float xvertices[]=
-			{
-			  0.8,BHH-0.2, 0.8,
-			  0.8,BHH    , 0.8,
-			  BHP,BHH    , 0.8,
-			  BHP,BHH-0.2, 0.8,
-			  0.8,BHH-0.2, 1.0,
-			  0.8,BHH    , 1.0,
-			  BHP,BHH    , 1.0,
-			  BHP,BHH-0.2, 1.0
-			 };
-	float svertices[]=
-			{
-			  0.6,BHH-0.2, 0.8,
-			  0.6,BHH    , 0.8,
-			  0.8,BHH    , 0.8,
-			  0.8,BHH-0.2, 0.8,
-			  0.6,BHH-0.2, 1.0,
-			  0.6,BHH    , 1.0,
-			  0.8,BHH    , 1.0,
-			  0.8,BHH-0.2, 1.0
-			 };
-	float tvertices[]=
-			{
-			  -BHP,BHH-0.2, 0.8,
-			  -BHP,BHH    , 0.8,
-			  0.6, BHH    , 0.8,
-			  0.6, BHH-0.2, 0.8,
-			  -BHP,BHH-0.2, 1.0,
-			  -BHP,BHH    , 1.0,
-			  0.6, BHH    , 1.0,
-			  0.6, BHH-0.2, 1.0
-			 };
+	float vertices[]= {-BHP,0,-BHP,
+	                   -BHP,0, BHP,
+	                   BHP,0, BHP,
+	                   BHP,0,-BHP,
+	                   -BHP,BHH,-BHP,
+	                   -BHP,BHH, BHP,
+	                   BHP,BHH, BHP,
+	                   BHP,BHH,-BHP,
+	                   -1,0, 0.8,
+	                   -1,BOXHEIGHT, 0.8,
+	                   1,BOXHEIGHT, 0.8,
+	                   1,0, 0.8
+	                  };
+	float xvertices[]= {
+		0.8,BHH-0.2, 0.8,
+		0.8,BHH    , 0.8,
+		BHP,BHH    , 0.8,
+		BHP,BHH-0.2, 0.8,
+		0.8,BHH-0.2, 1.0,
+		0.8,BHH    , 1.0,
+		BHP,BHH    , 1.0,
+		BHP,BHH-0.2, 1.0
+	};
+	float svertices[]= {
+		0.6,BHH-0.2, 0.8,
+		0.6,BHH    , 0.8,
+		0.8,BHH    , 0.8,
+		0.8,BHH-0.2, 0.8,
+		0.6,BHH-0.2, 1.0,
+		0.6,BHH    , 1.0,
+		0.8,BHH    , 1.0,
+		0.8,BHH-0.2, 1.0
+	};
+	float tvertices[]= {
+		-BHP,BHH-0.2, 0.8,
+		-BHP,BHH    , 0.8,
+		0.6, BHH    , 0.8,
+		0.6, BHH-0.2, 0.8,
+		-BHP,BHH-0.2, 1.0,
+		-BHP,BHH    , 1.0,
+		0.6, BHH    , 1.0,
+		0.6, BHH-0.2, 1.0
+	};
 	uint32_t bar_poly[]={
 		4,5,6,0,
 		4,6,7,0,
 		3,7,4,0,
 		3,4,0,0
 	};
-/*	printf("new block for %s\n",dir->name);*/
+	/*	printf("new block for %s\n",dir->name);*/
 
 	dir->oid=s3d_new_object();
-	
+
 	/* draw block outside */
 	s3d_push_vertices(dir->oid,vertices,sizeof(vertices)/(3*sizeof(float)));
 	s3d_push_material(dir->oid,
-						0.5,0.5,0.5,
-						0.5,0.5,0.5,
-						0.5,0.5,0.5
-					);
+	                  0.5,0.5,0.5,
+	                  0.5,0.5,0.5,
+	                  0.5,0.5,0.5
+	                 );
 
 	/* top */
 	s3d_push_polygon(dir->oid,4,6,5,0);
@@ -162,7 +156,7 @@
 	/* left */
 	s3d_push_polygon(dir->oid,0,4,5,0);
 	s3d_push_polygon(dir->oid,0,5,1,0);
-	
+
 	/* back */
 	s3d_push_polygon(dir->oid,3,7,4,0);
 	s3d_push_polygon(dir->oid,3,4,0,0);
@@ -170,7 +164,7 @@
 	/* right */
 	s3d_push_polygon(dir->oid,2,6,7,0);
 	s3d_push_polygon(dir->oid,2,7,3,0);
-	
+
 	/* front */
 	s3d_push_polygon(dir->oid,8,9,10,0);
 	s3d_push_polygon(dir->oid,8,10,11,0);
@@ -192,32 +186,32 @@
 	/* draw the select, close buttons ... */
 	dir->objs.close=s3d_new_object();
 	s3d_push_material(dir->objs.close,
-						0.5,0.3,0.3,
-						0.5,0.3,0.3,
-						0.5,0.3,0.3
-					);
+	                  0.5,0.3,0.3,
+	                  0.5,0.3,0.3,
+	                  0.5,0.3,0.3
+	                 );
 	s3d_push_vertices(dir->objs.close,xvertices,sizeof(xvertices)/(3*sizeof(float)));
 	s3d_push_polygons(dir->objs.close,bar_poly,sizeof(bar_poly)/(sizeof(uint32_t)*4));
 	s3d_link(dir->objs.close,dir->oid);
-	
+
 	dir->objs.select=s3d_new_object();
 	s3d_push_material(dir->objs.select,
-						0.1,0.1,0.3,
-						0.1,0.1,0.3,
-						0.1,0.1,0.3
-					);
+	                  0.1,0.1,0.3,
+	                  0.1,0.1,0.3,
+	                  0.1,0.1,0.3
+	                 );
 	s3d_push_vertices(dir->objs.select,svertices,sizeof(svertices)/(3*sizeof(float)));
 	s3d_push_polygons(dir->objs.select,bar_poly,sizeof(bar_poly)/(sizeof(uint32_t)*4));
 	s3d_link(dir->objs.select,dir->oid);
-	
+
 	/* draw the title string */
-	
+
 	dir->objs.title=s3d_new_object();
 	s3d_push_material(dir->objs.title,
-						0.3,0.3,0.3,
-						0.3,0.3,0.3,
-						0.3,0.3,0.3
-					);
+	                  0.3,0.3,0.3,
+	                  0.3,0.3,0.3,
+	                  0.3,0.3,0.3
+	                 );
 	s3d_push_vertices(dir->objs.title,tvertices,sizeof(tvertices)/(3*sizeof(float)));
 	s3d_push_polygons(dir->objs.title,bar_poly,sizeof(bar_poly)/(sizeof(uint32_t)*4));
 	s3d_link(dir->objs.title,dir->oid);
@@ -227,20 +221,23 @@
 	s3d_translate(dir->objs.titlestr,-1.0,1.05,1.01);
 	s3d_link(dir->objs.titlestr,dir->oid);
 	dir->disp=D_DIR;
-/*	printf("FULLNAME is [%s]\n",fullname);*/
+	/*	printf("FULLNAME is [%s]\n",fullname);*/
 	return(0);
 }
 /* display a directoy on the top of another */
 int box_expand(t_node *dir)
 {
 	printf("box_expand( %s )\n",dir->name);
-	switch (dir->disp)
-	{
-		case D_DIR:			return(0); /* already done */
-		case D_ICON:		icon_undisplay(dir); /* undisplay previously displayed types, like icons etc */
-			break;
-		case D_NONE:		break; /* ignore */
-		default:			return(-1); /* panic */
+	switch (dir->disp) {
+	case D_DIR:
+		return(0); /* already done */
+	case D_ICON:
+		icon_undisplay(dir); /* undisplay previously displayed types, like icons etc */
+		break;
+	case D_NONE:
+		break; /* ignore */
+	default:
+		return(-1); /* panic */
 	}
 	dir->dpx=0.0;
 	dir->dpy=BOXHEIGHT;
@@ -249,8 +246,7 @@
 	box_draw(dir);
 
 	/* initialize position on the parent */
-	if (dir->parent!=NULL)	
-	{
+	if (dir->parent!=NULL) {
 		dir->parent->dirs_opened++;
 		s3d_link(dir->oid,dir->parent->oid);
 		box_order_subdirs(dir->parent);
@@ -261,11 +257,25 @@
 int box_undisplay(t_node *dir)
 {
 	printf("box_undisplay( %s )\n",dir->name);
-	if (dir->objs.close!=-1)		{	s3d_del_object(dir->objs.close);	dir->objs.close=-1; }
-	if (dir->objs.select!=-1)		{	s3d_del_object(dir->objs.select);	dir->objs.select=-1; }
-	if (dir->objs.title!=-1)		{	s3d_del_object(dir->objs.title);	dir->objs.title=-1; }
-	if (dir->objs.titlestr!=-1)		{	s3d_del_object(dir->objs.titlestr);	dir->objs.titlestr=-1; }
-	if (dir->oid!=-1)				{	s3d_del_object(dir->oid);	}
+	if (dir->objs.close!=-1)		{
+		s3d_del_object(dir->objs.close);
+		dir->objs.close=-1;
+	}
+	if (dir->objs.select!=-1)		{
+		s3d_del_object(dir->objs.select);
+		dir->objs.select=-1;
+	}
+	if (dir->objs.title!=-1)		{
+		s3d_del_object(dir->objs.title);
+		dir->objs.title=-1;
+	}
+	if (dir->objs.titlestr!=-1)		{
+		s3d_del_object(dir->objs.titlestr);
+		dir->objs.titlestr=-1;
+	}
+	if (dir->oid!=-1)				{
+		s3d_del_object(dir->oid);
+	}
 	/* keep this. icons also needs the *same* string */
 	/*	if (dir->objs.str!=-1)			{ 	s3d_del_object(dir->objs.str); dir->objs.str=-1;	}*/
 	dir->disp=D_NONE;
@@ -293,14 +303,12 @@
 	int i;
 	int ret;
 	printf("box_close( %s )\n",dir->name);
-	if (&root==dir)
-	{
+	if (&root==dir) {
 		printf("won't close down root box ... \n");
 		return(-1);
 	}
 	if (dir->detached && !force)	return(1);
-	if (dir->disp!=D_DIR) /* that should not be happening ... */
-	{
+	if (dir->disp!=D_DIR) { /* that should not be happening ... */
 		printf("[A]lready undisplayed %s, nothing to do ...\n",dir->name);
 		return(-1);
 	}
@@ -309,16 +317,14 @@
 	for (i=0;i<dir->n_sub;i++)
 		if (dir->sub[i]->disp==D_DIR)
 			ret|=box_close(dir->sub[i],force);
-	if (ret && !force) 
-	{	/* if anything got wrong, return here ... */
+	if (ret && !force) {	/* if anything got wrong, return here ... */
 		box_order_subdirs(dir);
-		return(ret); 
+		return(ret);
 	} else {
 		/* also remove the icons */
 		if (focus==dir)			focus_set(dir->parent);
 		for (i=0;i<dir->n_sub;i++)
-			if (dir->sub[i]->disp==D_ICON)
-			{
+			if (dir->sub[i]->disp==D_ICON) {
 				icon_undisplay(dir->sub[i]);
 				dir->detached=0;
 				if (focus==dir->sub[i])
@@ -344,42 +350,38 @@
 		}
 	return(0);
 }*/
-/* orders the directory objects on top of its parent objects 
+/* orders the directory objects on top of its parent objects
  * to be called after adding or removing things ...*/
 void box_order_subdirs(t_node *dir)
 {
 	int i,j;
 	printf("box_order_subdirs( %s ): %d dirs opened\n",dir->name,dir->dirs_opened);
-	switch (dir->dirs_opened)
-	{
-		case 0: return;
-		case 1:
-			for (i=0;i<dir->n_sub;i++)
-			{
-				if (dir->sub[i]->disp==D_DIR)
-				{
-					dir->sub[i]->px=0.0;
-					dir->sub[i]->py=BOXHEIGHT+dir->sub[i]->detached*DETHEIGHT;
-					dir->sub[i]->pz=0.0;
-					dir->sub[i]->scale=0.2;
-					ani_add(dir->sub[i]);
-				}
+	switch (dir->dirs_opened) {
+	case 0:
+		return;
+	case 1:
+		for (i=0;i<dir->n_sub;i++) {
+			if (dir->sub[i]->disp==D_DIR) {
+				dir->sub[i]->px=0.0;
+				dir->sub[i]->py=BOXHEIGHT+dir->sub[i]->detached*DETHEIGHT;
+				dir->sub[i]->pz=0.0;
+				dir->sub[i]->scale=0.2;
+				ani_add(dir->sub[i]);
 			}
-			break;
-		default:
-			j=0;
-			for (i=0;i<dir->n_sub;i++)
-			{
-				if (dir->sub[i]->disp==D_DIR)
-				{
-					dir->sub[i]->px=0.8 * sin(((float)j*2*M_PI)/((float)dir->dirs_opened));
-					dir->sub[i]->py=BOXHEIGHT+dir->sub[i]->detached*DETHEIGHT;
-					dir->sub[i]->pz=0.8 * cos(((float)j*2*M_PI)/((float)dir->dirs_opened));
-					dir->sub[i]->scale=0.2;
-					ani_add(dir->sub[i]);
-					j++;
-				}
+		}
+		break;
+	default:
+		j=0;
+		for (i=0;i<dir->n_sub;i++) {
+			if (dir->sub[i]->disp==D_DIR) {
+				dir->sub[i]->px=0.8 * sin(((float)j*2*M_PI)/((float)dir->dirs_opened));
+				dir->sub[i]->py=BOXHEIGHT+dir->sub[i]->detached*DETHEIGHT;
+				dir->sub[i]->pz=0.8 * cos(((float)j*2*M_PI)/((float)dir->dirs_opened));
+				dir->sub[i]->scale=0.2;
+				ani_add(dir->sub[i]);
+				j++;
 			}
+		}
 	}
 }
 /* order the icons properly */
@@ -387,10 +389,8 @@
 {
 	int dps,i;
 	dps=ceil(sqrt(dir->n_sub)); /* directories per line */
-	for (i=0;i<dir->n_sub;i++)
-	{
-		if (dir->sub[i]->disp == D_ICON)
-		{
+	for (i=0;i<dir->n_sub;i++) {
+		if (dir->sub[i]->disp == D_ICON) {
 			dir->sub[i]->px = -1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
 			dir->sub[i]->py = 0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
 			dir->sub[i]->pz=dir->sub[i]->detached*0.2+1.0;

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/dialog.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -51,11 +51,9 @@
 {
 	int i;
 	char *s;
-	for (i=0;i<dir->n_sub;i++)
-	{
+	for (i=0;i<dir->n_sub;i++) {
 		if (dir->sub[i]->sub!=NULL)	get_selected(fp,dir->sub[i]); /* scan subdir */
-		if (dir->sub[i]->detached)
-		{
+		if (dir->sub[i]->detached) {
 			fp->n++;
 			fp->p=realloc(fp->p,sizeof(t_file) * fp->n);
 			s=malloc(M_DIR);
@@ -67,7 +65,7 @@
 				fp->p[fp->n - 1].anode=NULL;
 			fp->p[fp->n - 1].size=0; /*TODO: later */
 			fp->p[fp->n - 1].state=STATE_NONE;
-	
+
 		}
 	}
 	return(0);
@@ -114,7 +112,7 @@
 {
 	fs_err.state=ESTATE_NONE;
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
-	
+
 }
 void window_fs_errno(char *errmsg)
 {
@@ -134,8 +132,7 @@
 void window_fs_abort(s3dw_widget *button)
 {
 	/* delete a filelist, if there was any */
-	if (fp!=NULL)
-	{
+	if (fp!=NULL) {
 		fl_del(fp);
 		fp=NULL;
 	}
@@ -145,23 +142,22 @@
 }
 void *thread_start(void *ptr)
 {
-	switch (fs_lock)
-	{
-		case TYPE_COPY: 
-			printf("starting a copy process in the thread ... \n");
-			destnode=node_getbypath(destdir);
-			fs_fl_copy(fp,destdir);
-			printf("done\n");
-			break;
-		case TYPE_UNLINK:
-			printf("unlinking some files ... \n");
-			fs_fl_unlink(fp);
-			printf("done\n");
-			break;
+	switch (fs_lock) {
+	case TYPE_COPY:
+		printf("starting a copy process in the thread ... \n");
+		destnode=node_getbypath(destdir);
+		fs_fl_copy(fp,destdir);
+		printf("done\n");
+		break;
+	case TYPE_UNLINK:
+		printf("unlinking some files ... \n");
+		fs_fl_unlink(fp);
+		printf("done\n");
+		break;
 	}
 	fs_lock=TYPE_FINISHED;
 	return(NULL);
-	
+
 }
 /* start the thread, as filesystem stuff is locked ... */
 void window_fs(s3dw_widget *button)
@@ -177,18 +173,25 @@
 
 	int i,m;
 
-	if (fs_lock) 	{	window_fs_another(); 	return; }
+	if (fs_lock) 	{
+		window_fs_another();
+		return;
+	}
 	fs_lock=TYPE_COPY;
 	fp=malloc(sizeof(filelist));
 	fp->n=0;
 	fp->p=NULL;
 	get_selected(fp,&root);
 	printf("selected %d nodes\n",fp->n);
-	if (fp->n == 0)	{	window_fs_nothing();	free(fp); fp=NULL;return;	}
+	if (fp->n == 0)	{
+		window_fs_nothing();
+		free(fp);
+		fp=NULL;
+		return;
+	}
 	/* get the longest item on the list */
 	m=10;
-	for (i=0;i<fp->n;i++)
-	{
+	for (i=0;i<fp->n;i++) {
 		if (strlen(fp->p[i].name)>m) m=strlen(fp->p[i].name);
 		printf("%d: %s\n",i,fp->p[i].name);
 	}
@@ -220,14 +223,22 @@
 
 	int i,m;
 
-	if (fs_lock) 	{	window_fs_another(); 	return; }
+	if (fs_lock) 	{
+		window_fs_another();
+		return;
+	}
 	fs_lock=TYPE_UNLINK;
 	fp=malloc(sizeof(filelist));
 	fp->n=0;
 	fp->p=NULL;
 	get_selected(fp,&root);
 	printf("selected %d nodes\n",fp->n);
-	if (fp->n == 0)	{	window_fs_nothing();	free(fp); fp=NULL;return;	}
+	if (fp->n == 0)	{
+		window_fs_nothing();
+		free(fp);
+		fp=NULL;
+		return;
+	}
 	/* get the longest item on the list */
 	m=10;
 	for (i=0;i<fp->n;i++)
@@ -258,12 +269,11 @@
 	else {
 		/* success, now refresh it */
 		item=node_getbypath(dir);
-		if (item==NULL)
-		{
+		if (item==NULL) {
 			printf("cannot refresh\n");
 		} else {
 			printf("refreshing %s\n",item->name);
-/*			parse_again(item);*/
+			/*			parse_again(item);*/
 		}
 	}
 	fs_lock=0;
@@ -276,7 +286,10 @@
 	s3dw_button  *okbutton,*abortbutton;
 	char string1[M_DIR];
 	float l;
-	if (fs_lock) {window_fs_another(); return; }
+	if (fs_lock) {
+		window_fs_another();
+		return;
+	}
 	snprintf(string1,M_DIR,"Create Directory in %s",path);
 	l=strlen(string1)*0.7;
 	infwin=s3dw_surface_new("Create Directory",l,8);
@@ -298,7 +311,10 @@
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;
-	if (fs_lock) {window_fs_another(); return; }
+	if (fs_lock) {
+		window_fs_another();
+		return;
+	}
 	infwin=s3dw_surface_new("Info Window",20,8);
 	s3dw_label_new(infwin,"Sorry, moving is not implemented yet.. :(",1,2);
 	button=s3dw_button_new(infwin,"Too bad",7,5);
@@ -320,9 +336,9 @@
 	fs_approx(path, &f, &d, &b);
 	dotted_int(bd,b);
 	snprintf(string2 ,M_DIR,"%s bytes in %d files and %d Directories",bd,f,d);
-	
+
 	l=((strlen(string1)>strlen(string2)) ? strlen(string1) :strlen(string2))*0.7;
-	
+
 	infwin=s3dw_surface_new("Info Window",l,12);
 
 	s3dw_label_new(infwin,string1,1,2);
@@ -341,8 +357,7 @@
 	t_node *node, dummy;
 	if (fs_lock!=TYPE_NONE)	{
 		/* get current position of our destination node */
-		if (destnode!=NULL)
-		{
+		if (destnode!=NULL) {
 			node=destnode;
 			node_init(&dummy);
 			dummy.parent = node->parent;
@@ -360,30 +375,28 @@
 		}
 		if (fp!=NULL) {
 			for (i=0;i<fp->n;i++) {
-				if (fp->p[i].state==STATE_FINISHED)
-				{ /* we can go and clean up now. */
-					if (NULL!=(node=node_getbypath(fp->p[i].name)))
-					{
+				if (fp->p[i].state==STATE_FINISHED) { /* we can go and clean up now. */
+					if (NULL!=(node=node_getbypath(fp->p[i].name))) {
 						printf("[CLEANUP] for node %s (%s)\n",node->name,fp->p[i].name);
 						node->detached=0;
-						if (node->parent!=NULL)
-						{
+						if (node->parent!=NULL) {
 							parse_dir(node->parent);
-							switch (node->disp)
-							{
-								case D_ICON:	box_order_icons(node->parent);					break;
-								case D_DIR:		box_order_subdirs(node->parent);				break;
+							switch (node->disp) {
+							case D_ICON:
+								box_order_icons(node->parent);
+								break;
+							case D_DIR:
+								box_order_subdirs(node->parent);
+								break;
 							}
 						}
-					} else 
+					} else
 						printf("node %s already vanished ...\n",fp->p[i].name);
-							
+
 					fp->p[i].state=STATE_CLEANED;
 				}
-				if (fp->p[i].state>STATE_NONE)
-				{
-					if (destnode!=NULL)
-					{
+				if (fp->p[i].state>STATE_NONE) {
+					if (destnode!=NULL) {
 						fp->p[i].anode->px=dummy.px;
 						fp->p[i].anode->py=dummy.py;
 						fp->p[i].anode->pz=dummy.pz;
@@ -395,23 +408,20 @@
 		}
 		if (fs_lock==TYPE_FINISHED)	{
 			printf("filesystem stuff is finisheed, cleaning up");
-			if (fp!=NULL)
-			{
+			if (fp!=NULL) {
 				fl_del(fp);
 				fp=NULL;
 			}
 			typeinput=0;
 			fs_lock=TYPE_NONE;
 			if (destnode!=NULL)
-				if (destnode->disp==D_DIR) /* it usually is opened */
-				{
+				if (destnode->disp==D_DIR) { /* it usually is opened */
 					printf("reordering icons on destnode ...\n");
-					box_order_icons(destnode);	
+					box_order_icons(destnode);
 				}
 			destnode=NULL;
 		}
-		if (fs_err.state==ESTATE_RISE)
-		{
+		if (fs_err.state==ESTATE_RISE) {
 			s3dw_surface *infwin;
 			s3dw_button  *button;
 			char errmsg[M_DIR];

Modified: trunk/apps/s3dfm/event.c
===================================================================
--- trunk/apps/s3dfm/event.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/event.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * event.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -34,8 +34,7 @@
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz->buf;
-	if ((inf->object==0) && (!ani_onstack(&cam)))
-	{
+	if ((inf->object==0) && (!ani_onstack(&cam))) {
 		cam.dpx=inf->trans_x;
 		cam.dpy=inf->trans_y;
 		cam.dpz=inf->trans_z;
@@ -49,71 +48,68 @@
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)evt->buf;
 	char path[M_DIR];
-	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */	
-			printf("inputting text ...\n");
-			s3dw_handle_key(evt); 
-			return(0); 
+	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */
+		printf("inputting text ...\n");
+		s3dw_handle_key(evt);
+		return(0);
 	}
 	node_path(node_getdir(focus),path);
-	switch (keys->keysym)
-	{
-		case 'i':
-		case 'I':
-				{
-				window_info(path);
-				}
-				break;
-		case 'r':
-		case 'R':
-				{/* refresh this window ... */
-					t_node *node;
-					node=node_getdir(focus);
-					printf("[R]efreshing %s\n",node->name);
-					parse_dir(node);
-					box_draw_icons(node);
-					box_order_icons(node);
-					box_order_subdirs(node);
-					
-				}
-				break;
-		case S3DK_F1:
-				window_help();
-				break;
-		case S3DK_F5:
-				window_copy(path);
-				break;
-		case S3DK_F6:
-				window_move(path);
-				break;
-		case S3DK_F7:
-				window_mkdir(path);
-				break;
-		case S3DK_F8:
-				window_unlink();
-				break;
-		case S3DK_F10:
-				/* some debugging stuff */
-				node_getbypath(path);
-				break;
+	switch (keys->keysym) {
+	case 'i':
+	case 'I': {
+		window_info(path);
+	}
+	break;
+	case 'r':
+	case 'R': {/* refresh this window ... */
+		t_node *node;
+		node=node_getdir(focus);
+		printf("[R]efreshing %s\n",node->name);
+		parse_dir(node);
+		box_draw_icons(node);
+		box_order_icons(node);
+		box_order_subdirs(node);
 
-		case S3DK_UP:
-		case S3DK_LEFT:
-		case S3DK_RIGHT:
-		case S3DK_DOWN:
-				focus_by_key(keys->keysym);
-				break;
-		case S3DK_RETURN:
-		case S3DK_SPACE:
-				node_select(focus);
-				break;
-		case S3DK_BACKSPACE:
-				if (focus->disp==D_DIR)
-					box_close(focus,1);
-				else if (focus->parent!=NULL)
-						box_close(focus->parent,1);
-				break;
-				
 	}
+	break;
+	case S3DK_F1:
+		window_help();
+		break;
+	case S3DK_F5:
+		window_copy(path);
+		break;
+	case S3DK_F6:
+		window_move(path);
+		break;
+	case S3DK_F7:
+		window_mkdir(path);
+		break;
+	case S3DK_F8:
+		window_unlink();
+		break;
+	case S3DK_F10:
+		/* some debugging stuff */
+		node_getbypath(path);
+		break;
+
+	case S3DK_UP:
+	case S3DK_LEFT:
+	case S3DK_RIGHT:
+	case S3DK_DOWN:
+		focus_by_key(keys->keysym);
+		break;
+	case S3DK_RETURN:
+	case S3DK_SPACE:
+		node_select(focus);
+		break;
+	case S3DK_BACKSPACE:
+		if (focus->disp==D_DIR)
+			box_close(focus,1);
+		else if (focus->parent!=NULL)
+			box_close(focus->parent,1);
+		break;
+
+	}
 	s3dw_handle_key(evt);
 	return(0);
 }
@@ -125,22 +121,19 @@
 	t_node *f;
 	s3dw_handle_click(evt);
 	oid=(int)*((u_int32_t *)evt->buf);
-	if (NULL!=(f=node_getbyoid(&root,oid)))
-	{
-		if (f->objs.close==oid)
-		{
+	if (NULL!=(f=node_getbyoid(&root,oid))) {
+		if (f->objs.close==oid) {
 			box_close(f,1);
 			return(0);
 		}
-		if (f->objs.select==oid)
-		{
+		if (f->objs.select==oid) {
 			printf("[S]electing %s\n",f->name);
 			node_select(f);
 			return(0);
 		}
 		node_select(f);
 	} else {
-/*		printf("[C]ould not find :/\n");*/
+		/*		printf("[C]ould not find :/\n");*/
 	}
 	return(0);
 }

Modified: trunk/apps/s3dfm/fly.c
===================================================================
--- trunk/apps/s3dfm/fly.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/fly.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * fly.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -36,7 +36,7 @@
 	*/
 	if (f->parent==NULL)	work->scale = f->scale;
 	else					work->scale = work->scale * f->scale;
-	
+
 }
 
 int fly_set_absolute_position(t_node *node)
@@ -51,7 +51,7 @@
 	node->py=work.py;
 	node->pz=work.pz;
 	node->scale=work.scale;
-/*	printf("node coordinates: %3.3f %3.3f %3.3f %3.3f\n",node->px,node->py,node->pz,node->scale);*/
+	/*	printf("node coordinates: %3.3f %3.3f %3.3f %3.3f\n",node->px,node->py,node->pz,node->scale);*/
 	return(0);
 }
 /* create a copy of *node as an icon (block) which can be moved for animation ... */
@@ -75,8 +75,8 @@
 	work->dpz=work->pz;
 	work->dscale=work->scale;
 	work->py=2*work->scale - work->py; /* invert */
-    s3d_flags_on(work->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(work->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(work->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(work->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	ani_add(work);
 	return(work);
 }

Modified: trunk/apps/s3dfm/focus.c
===================================================================
--- trunk/apps/s3dfm/focus.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/focus.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * focus.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -31,8 +31,7 @@
 float focus_get_scale(t_node *f)
 {
 	float scale,s;
-	if (f->disp==D_DIR)
-	{
+	if (f->disp==D_DIR) {
 		s=0.2;
 		scale=1/s;
 		if (f->parent!=NULL)
@@ -50,7 +49,7 @@
 		if (f->parent!=NULL)		return(focus_get_scale(f->parent));	/* icons etc */
 		else  						return(1.0);						/* that should never happen */
 	}
-	
+
 }
 /* center f for the viewer, therefore moving the root box ... */
 void focus_set(t_node *f)
@@ -59,20 +58,19 @@
 	root.py=0.0;
 	root.pz=0.0;
 	moveon=1;
-/*	printf("[Z]ooming to %s\n",f->name);*/
-/*	box_collapse_grandkids(f);*/
+	/*	printf("[Z]ooming to %s\n",f->name);*/
+	/*	box_collapse_grandkids(f);*/
 	root.scale=focus_get_scale(f);
 	root.py-=1.5;
-/*	printf("[R]escaling to %f\n",root.scale);
-	printf("px: %f py:%f pz: %f\n",root.px,root.py,root.pz);*/
+	/*	printf("[R]escaling to %f\n",root.scale);
+		printf("px: %f py:%f pz: %f\n",root.px,root.py,root.pz);*/
 
 	ani_add(&root);
 	node_focus_color(focus,0);
 	node_focus_color(f,1);
 	focus=f;
-	if (((cam.dpx-cam.px)* (cam.dpx-cam.px) + (cam.dpy-cam.py)* (cam.dpy-cam.py) 
-		  + (cam.dpz-cam.pz)* (cam.dpz-cam.pz))	> ( 10 * 10))
-	{
+	if (((cam.dpx-cam.px)* (cam.dpx-cam.px) + (cam.dpy-cam.py)* (cam.dpy-cam.py)
+	                + (cam.dpz-cam.pz)* (cam.dpz-cam.pz))	> ( 10 * 10)) {
 		cam.px=0;
 		cam.py=0;
 		cam.pz=5;
@@ -84,133 +82,120 @@
 void focus_by_key(int keysym)
 {
 	int i,rowsize;
-	if (focus->pindex!=-1)
-	{
-		switch (focus->disp)
-		{
-			case D_DIR:
-				switch (keysym)
-				{
-					case S3DK_RIGHT:
-						/* cycle to the next directory on the ring */
-						for (i=focus->pindex-1;i>=0;i--)
-							if (focus->parent->sub[i]->disp==D_DIR)
-							{ /* found a directory before, cycle */
-								focus_set(focus->parent->sub[i]);
-								break;
-							}
-						if (i==-1) /* nothing found, wrap to the other side */
-						for (i=focus->parent->n_sub-1;i>=focus->pindex+1;i--)
-							if (focus->parent->sub[i]->disp==D_DIR)
-							{ /* found a directory before, cycle */
-								focus_set(focus->parent->sub[i]);
-								break;
-							}
+	if (focus->pindex!=-1) {
+		switch (focus->disp) {
+		case D_DIR:
+			switch (keysym) {
+			case S3DK_RIGHT:
+				/* cycle to the next directory on the ring */
+				for (i=focus->pindex-1;i>=0;i--)
+					if (focus->parent->sub[i]->disp==D_DIR) { /* found a directory before, cycle */
+						focus_set(focus->parent->sub[i]);
 						break;
-					case S3DK_LEFT:
-						/* cycle to the next directory on the ring */
-						for (i=focus->pindex+1;i<focus->parent->n_sub;i++)
-							if (focus->parent->sub[i]->disp==D_DIR)
-							{ /* found a directory before, cycle */
-								focus_set(focus->parent->sub[i]);
-								break;
-							}
-						if (i==focus->parent->n_sub) /* nothing found, wrap to the other side */
-						for (i=0;i<focus->pindex;i++)
-							if (focus->parent->sub[i]->disp==D_DIR)
-							{ /* found a directory before, cycle */
-								focus_set(focus->parent->sub[i]);
-								break;
-							}
+					}
+				if (i==-1) /* nothing found, wrap to the other side */
+					for (i=focus->parent->n_sub-1;i>=focus->pindex+1;i--)
+						if (focus->parent->sub[i]->disp==D_DIR) { /* found a directory before, cycle */
+							focus_set(focus->parent->sub[i]);
+							break;
+						}
+				break;
+			case S3DK_LEFT:
+				/* cycle to the next directory on the ring */
+				for (i=focus->pindex+1;i<focus->parent->n_sub;i++)
+					if (focus->parent->sub[i]->disp==D_DIR) { /* found a directory before, cycle */
+						focus_set(focus->parent->sub[i]);
 						break;
-					case S3DK_UP:
-						/* go in the first entry of this directory, if possible */
-						if (focus->n_sub>0)
-							focus_set(focus->sub[0]);
+					}
+				if (i==focus->parent->n_sub) /* nothing found, wrap to the other side */
+					for (i=0;i<focus->pindex;i++)
+						if (focus->parent->sub[i]->disp==D_DIR) { /* found a directory before, cycle */
+							focus_set(focus->parent->sub[i]);
+							break;
+						}
+				break;
+			case S3DK_UP:
+				/* go in the first entry of this directory, if possible */
+				if (focus->n_sub>0)
+					focus_set(focus->sub[0]);
+				break;
+			case S3DK_DOWN:
+				/* go to first icon entry of parent,  or parent itself */
+				for (i=focus->parent->n_sub-1;i>=0;i--)
+					if (focus->parent->sub[i]->disp==D_ICON) { /* found a directory before, cycle */
+						focus_set(focus->parent->sub[i]);
 						break;
-					case S3DK_DOWN:
-						/* go to first icon entry of parent,  or parent itself */
-						for (i=focus->parent->n_sub-1;i>=0;i--)
-							if (focus->parent->sub[i]->disp==D_ICON)
-							{ /* found a directory before, cycle */
-								focus_set(focus->parent->sub[i]);
-								break;
-							}
-						if (i==0) /* no icons? go to parent. */
-							focus_set(focus->parent);
-						break;
+					}
+				if (i==0) /* no icons? go to parent. */
+					focus_set(focus->parent);
+				break;
 
 
 
-				}
+			}
+			break;
+		case D_ICON:
+			switch (keysym) {
+			case S3DK_LEFT:
+				/* search for the next icon on the left side */
+				i=focus->pindex;
+				do {
+					i--;
+					if (i<0) i=focus->parent->n_sub-1;
+				} while (focus->parent->sub[i]->disp!=D_ICON);
+				focus_set(focus->parent->sub[i]);
 				break;
-			case D_ICON:
-				switch (keysym)
-				{
-					case S3DK_LEFT:
-						/* search for the next icon on the left side */
-						i=focus->pindex;
-						do {
-							i--;
-							if (i<0) i=focus->parent->n_sub-1;
-						} while (focus->parent->sub[i]->disp!=D_ICON);
-						focus_set(focus->parent->sub[i]);
-						break;
-					case S3DK_RIGHT:
-						/* search for the next icon on the right side */
-						i=focus->pindex;
-						do {
-							i++;
-							if (i>=focus->parent->n_sub) i=0;
-						} while (focus->parent->sub[i]->disp!=D_ICON);
-						focus_set(focus->parent->sub[i]);
-						break;
-					case S3DK_UP:
-						/* search for the next icon on the left side */
-						i=focus->pindex;
-						rowsize=ceil(sqrt(focus->parent->n_sub)); /* items per line */
-						do {
-							i+=rowsize;
-							if (i>=focus->parent->n_sub) break;
-						} while (focus->parent->sub[i]->disp!=D_ICON);
-						if (i>=focus->parent->n_sub) 
-						{
-							/* go to the first activated dir above ... */
-							for (i=0;i<focus->parent->n_sub;i++)
-								if (focus->parent->sub[i]->disp==D_DIR)
-								{ /* found a directory before, cycle */
-									focus_set(focus->parent->sub[i]);
-									break;
-								}
-						}
-						else		focus_set(focus->parent->sub[i]);
-						break;
-					case S3DK_DOWN:
-						/* search for the next icon on the left side */
-						i=focus->pindex;
-						rowsize=ceil(sqrt(focus->parent->n_sub)); /* items per line */
-						do {
-							i-=rowsize;
-							if (i<0) break;
-						} while (focus->parent->sub[i]->disp!=D_ICON);
-						if (i<0) 
-							focus_set(focus->parent);
-						else						
+			case S3DK_RIGHT:
+				/* search for the next icon on the right side */
+				i=focus->pindex;
+				do {
+					i++;
+					if (i>=focus->parent->n_sub) i=0;
+				} while (focus->parent->sub[i]->disp!=D_ICON);
+				focus_set(focus->parent->sub[i]);
+				break;
+			case S3DK_UP:
+				/* search for the next icon on the left side */
+				i=focus->pindex;
+				rowsize=ceil(sqrt(focus->parent->n_sub)); /* items per line */
+				do {
+					i+=rowsize;
+					if (i>=focus->parent->n_sub) break;
+				} while (focus->parent->sub[i]->disp!=D_ICON);
+				if (i>=focus->parent->n_sub) {
+					/* go to the first activated dir above ... */
+					for (i=0;i<focus->parent->n_sub;i++)
+						if (focus->parent->sub[i]->disp==D_DIR) { /* found a directory before, cycle */
 							focus_set(focus->parent->sub[i]);
-						break;
-
-				}
+							break;
+						}
+				} else		focus_set(focus->parent->sub[i]);
 				break;
+			case S3DK_DOWN:
+				/* search for the next icon on the left side */
+				i=focus->pindex;
+				rowsize=ceil(sqrt(focus->parent->n_sub)); /* items per line */
+				do {
+					i-=rowsize;
+					if (i<0) break;
+				} while (focus->parent->sub[i]->disp!=D_ICON);
+				if (i<0)
+					focus_set(focus->parent);
+				else
+					focus_set(focus->parent->sub[i]);
+				break;
+
+			}
+			break;
 		}
 	} else {
 		/* probably root */
-		switch (keysym)
-		{
-			case S3DK_UP:
-				/* go in the first entry of this directory, if possible */
-				if (focus->n_sub>0)
-					focus_set(focus->sub[0]);
-				break;
+		switch (keysym) {
+		case S3DK_UP:
+			/* go in the first entry of this directory, if possible */
+			if (focus->n_sub>0)
+				focus_set(focus->sub[0]);
+			break;
 		}
 	}
 

Modified: trunk/apps/s3dfm/fs.c
===================================================================
--- trunk/apps/s3dfm/fs.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/fs.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,20 +1,20 @@
 /*
- * fs.c 
+ * fs.c
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -26,7 +26,7 @@
 #include <stdlib.h>	/*  malloc() */
 
 /* we want GNU version of basename */
-#define _GNU_SOURCE 
+#define _GNU_SOURCE
 #include <string.h>	/*  strlen(), strncmp(), strrchr() */
 #include <libgen.h> /* basename() */
 
@@ -37,7 +37,9 @@
 #include <errno.h> /* errno */
 #include <time.h>	/* nanosleep() */
 
-struct fs_error fs_err={0,0,NULL,NULL};
+struct fs_error fs_err= {
+	0,0,NULL,NULL
+};
 
 
 /* generates the file list */
@@ -51,20 +53,17 @@
 	fl=malloc(sizeof(filelist));
 	fl->p=NULL;
 	fl->n=0;
-    n = scandir(path, &namelist, 0, alphasort);
-    if (n <= 2) /* . and .. is always included. */
-	{
+	n = scandir(path, &namelist, 0, alphasort);
+	if (n <= 2) { /* . and .. is always included. */
 		if (n<0)
-	        fs_error("fl_new():scandir()",path);
+			fs_error("fl_new():scandir()",path);
 	} else {
 		j=0;
 		fl->n=n-2 ; /* ignore . and .. */
 		fl->p=malloc(sizeof(t_file)*fl->n);
-		for (i=0;i<n;i++)
-		{
+		for (i=0;i<n;i++) {
 			name=namelist[i]->d_name;
-			if (!((strcmp(name,".")==0) || (strcmp(name,"..")==0))) /* ignore */
-			{
+			if (!((strcmp(name,".")==0) || (strcmp(name,"..")==0))) { /* ignore */
 				fl->p[j].name=malloc(strlen(name)+strlen(path)+2);
 				strcpy(fl->p[j].name,path);
 				strcat(fl->p[j].name,"/");
@@ -77,25 +76,22 @@
 			}
 			free(namelist[i]);
 		}
-		if (j!=fl->n)
-		{ /* TODO: GUH! don't exit(-1) */
+		if (j!=fl->n) { /* TODO: GUH! don't exit(-1) */
 			printf("assertion failed\n");
 			exit(-1);
 		}
 		free (namelist);
 	}
-	return(fl);	
+	return(fl);
 }
 /* delete the filelist */
 void fl_del(filelist *fl)
 {
 	int i;
-	for (i=0;i<fl->n;i++)
-	{
+	for (i=0;i<fl->n;i++) {
 		free(fl->p[i].name);
-		if (fl->p[i].anode!=NULL)
-		{
-		/* maybe let node_delete do that? */
+		if (fl->p[i].anode!=NULL) {
+			/* maybe let node_delete do that? */
 			/*node_delete(fl->p[i].anode);*/
 			icon_undisplay(fl->p[i].anode);
 			free(fl->p[i].anode);
@@ -114,27 +110,26 @@
 	*dirs=	sdirs=	0;
 	*bytes=	sbytes=	0;
 
-/*	printf("start: %d files, %d dirs, %d bytes in %s\n",*files,*dirs,*bytes,source);*/
+	/*	printf("start: %d files, %d dirs, %d bytes in %s\n",*files,*dirs,*bytes,source);*/
 	if (-1==stat(source,&s))
 		return;
-/*	printf("%s: %08x (%db)\n",source,s.st_mode,(int)s.st_size);*/
-	if ((s.st_mode&S_IFMT) == S_IFDIR)
-	{
-		
+	/*	printf("%s: %08x (%db)\n",source,s.st_mode,(int)s.st_size);*/
+	if ((s.st_mode&S_IFMT) == S_IFDIR) {
+
 		fl=fl_new(source);
 		if (fl->n>0)
 			fs_fl_approx(fl,&sfiles,&sdirs,&sbytes);
 		fl_del(fl);
-/*		printf("%d files, %d dirs, %d bytes in %s\n",sfiles,sdirs,sbytes,source);*/
+		/*		printf("%d files, %d dirs, %d bytes in %s\n",sfiles,sdirs,sbytes,source);*/
 
 		*files=		sfiles;
 		*bytes+=	sbytes;
 		*dirs=		sdirs;
 		*dirs+=		1;
-	} else 
+	} else
 		*files=		1;
 	*bytes+=s.st_size;
-/*	printf("end: %d files, %d dirs, %d bytes in %s\n",*files,*dirs,*bytes,source);*/
+	/*	printf("end: %d files, %d dirs, %d bytes in %s\n",*files,*dirs,*bytes,source);*/
 }
 /* approximate the heaviness of our source ...*/
 void fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes)
@@ -146,8 +141,7 @@
 	*dirs=0;
 	*bytes=0;
 
-	for (i=0;i<fl->n;i++)
-	{
+	for (i=0;i<fl->n;i++) {
 		fs_approx(fl->p[i].name,&sfiles,&sdirs,&sbytes);
 		*files+=		sfiles;
 		*dirs+=			sdirs;
@@ -164,55 +158,51 @@
 	int n;
 	if (-1==stat(source,&s))
 		return(0);
-	switch (s.st_mode&S_IFMT)
-	{
-		case S_IFDIR:
-			fl=fl_new(source);
-		
-			printf("mkdir %s\n",dest);
-			mkdir(dest,0777);
-		
-			fs_fl_copy(fl, dest);
+	switch (s.st_mode&S_IFMT) {
+	case S_IFDIR:
+		fl=fl_new(source);
 
-			fl_del(fl);
-			break;
-		case S_IFIFO:
-			printf("link the fifo\n");
+		printf("mkdir %s\n",dest);
+		mkdir(dest,0777);
 
-			link(source,dest);
-			break;
-		default:
-			printf("fs_copy -> atomic copy\n");
-			printf("open source...");
-			if (NULL==(fps=fopen(source,"r"))) 
-			{
-				fs_error("fs_copy():fopen(source)",source);
-				return(-1);
-			}
-			printf("ok\n");
-			printf("open dest...");
-			if (NULL==(fpd=fopen(dest,"w"))) 
-			{
-				fs_error("fs_copy():fopen(source)",source);
-				return(-1);
-			}
-			printf("ok\n");
-			/* TODO: overwrite protection etc */
-			printf("copy ...");
-		
-			while (!feof(fps))
-			{
-				printf(".");
-				errno=0;
-				n=fread(buf,1,1024,fps);
-				if (errno)	fs_error("fs_copy():fread(source)",source);
-				fwrite(buf,1,n,fpd);
-				if (errno)	fs_error("fs_copy():fwrite(source)",source);
-			}
-			printf("ok\n");
-			fclose(fps);
-			fclose(fpd);
+		fs_fl_copy(fl, dest);
 
+		fl_del(fl);
+		break;
+	case S_IFIFO:
+		printf("link the fifo\n");
+
+		link(source,dest);
+		break;
+	default:
+		printf("fs_copy -> atomic copy\n");
+		printf("open source...");
+		if (NULL==(fps=fopen(source,"r"))) {
+			fs_error("fs_copy():fopen(source)",source);
+			return(-1);
+		}
+		printf("ok\n");
+		printf("open dest...");
+		if (NULL==(fpd=fopen(dest,"w"))) {
+			fs_error("fs_copy():fopen(source)",source);
+			return(-1);
+		}
+		printf("ok\n");
+		/* TODO: overwrite protection etc */
+		printf("copy ...");
+
+		while (!feof(fps)) {
+			printf(".");
+			errno=0;
+			n=fread(buf,1,1024,fps);
+			if (errno)	fs_error("fs_copy():fread(source)",source);
+			fwrite(buf,1,n,fpd);
+			if (errno)	fs_error("fs_copy():fwrite(source)",source);
+		}
+		printf("ok\n");
+		fclose(fps);
+		fclose(fpd);
+
 	}
 	return(0);
 }
@@ -224,8 +214,7 @@
 	char *sdest;
 	char *bname;
 	r=0;
-	for (i=0;i<fl->n;i++)
-	{
+	for (i=0;i<fl->n;i++) {
 		fl->p[i].state=STATE_INUSE;
 		bname=basename(fl->p[i].name);
 		sdest=malloc(strlen(dest)+strlen(bname)+2);
@@ -246,10 +235,9 @@
 {
 	filelist *fl;
 	struct stat s;
-	
+
 	if (-1==stat(dest,&s))		return(-1);
-	if ((s.st_mode&S_IFMT) == S_IFDIR)
-	{
+	if ((s.st_mode&S_IFMT) == S_IFDIR) {
 		printf("%s is a dir, removing below ...\n",dest);
 		fl=fl_new(dest);
 		if (fs_fl_unlink(fl)) {
@@ -258,15 +246,13 @@
 		} else {
 			fl_del(fl);
 			printf("removing %s\n",dest);
-			if (rmdir(dest)==-1)
-			{
+			if (rmdir(dest)==-1) {
 				fs_error("fs_fl_unlink(): rmdir()",dest);
 				return(-1);
 			}
 		}
 	} else {
-		if (unlink(dest)==-1)
-		{
+		if (unlink(dest)==-1) {
 			fs_error("fs_fl_unlink(): unlink()",dest);
 			return(-1);
 		}
@@ -278,8 +264,7 @@
 {
 	int i,r;
 	r=0;
-	for (i=0;i<fl->n;i++)
-	{
+	for (i=0;i<fl->n;i++) {
 		fl->p[i].state=STATE_INUSE;
 		printf("-> atomic unlink %s\n",fl->p[i].name);
 		r|=fs_unlink(fl->p[i].name);
@@ -290,21 +275,19 @@
 }
 int fs_move(char *source, char *dest)
 {
-	if (!rename(source,dest))
-	{
-		switch (errno)
-		{
-			case EXDEV:
-				fs_copy(source,dest);
-				fs_unlink(source);
-				break;
-			default: 
-				fs_error("fs_move()",dest);
-				return(-1); /* can't help it */
-			
+	if (!rename(source,dest)) {
+		switch (errno) {
+		case EXDEV:
+			fs_copy(source,dest);
+			fs_unlink(source);
+			break;
+		default:
+			fs_error("fs_move()",dest);
+			return(-1); /* can't help it */
+
 		}
 	}
-	return(0);	
+	return(0);
 }
 
 /* moves the source to the destination */
@@ -315,8 +298,7 @@
 	char *sdest;
 	char *bname;
 	r=0;
-	for (i=0;i<fl->n;i++)
-	{
+	for (i=0;i<fl->n;i++) {
 		fl->p[i].state=STATE_INUSE;
 		bname=basename(fl->p[i].name);
 		sdest=malloc(strlen(dest)+strlen(bname)+2);
@@ -338,13 +320,15 @@
 /* write an error and wait for a reaction */
 int fs_error(char *message, char *file)
 {
-	static struct timespec t={0,100*1000*1000}; 
+	static struct timespec t= {
+		0,100*1000*1000
+	};
 	fs_err.err=errno;
 	fs_err.message=message;
 	fs_err.file=file;
 	fs_err.state=ESTATE_RISE;
 	printf("[FS ERROR]: %s %s %s",message,file,strerror(errno));
-	while (fs_err.state!=ESTATE_NONE) 
+	while (fs_err.state!=ESTATE_NONE)
 		nanosleep(&t,NULL);  /* until situation clear, wait (and don't waste cpu-time) */
 	return(0);
 }

Modified: trunk/apps/s3dfm/icon.c
===================================================================
--- trunk/apps/s3dfm/icon.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/icon.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * icon.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,14 +27,15 @@
 #include <string.h>  /* strlen() */
 #include <stdlib.h>  /* memcpy() */
 float icon_colors[T_TYPENUM][12]={
-		/* T_DUNO */
+	/* T_DUNO */
 	{	0,0,0.5,1.0,
 		0,0,0.5,1.0,
 		0,0,0.5,1.0 },
-		/* T_FOLDER */
+	/* T_FOLDER */
 	{	0.4,0.4,0,1.0,
-		0.4,0.4,0,1.0,
-		0.4,0.4,0,1.0}};
+	  0.4,0.4,0,1.0,
+	  0.4,0.4,0,1.0}
+};
 
 /* gives another color for the focused item */
 void icon_focus_color(t_node *dir, int on)
@@ -42,31 +43,32 @@
 	float color[12];
 	int i;
 	memcpy(color,icon_colors[dir->type],sizeof(color));
-	if (on) for(i=0;i<3;i++) {
+	if (on) for (i=0;i<3;i++) {
 			color[i*4 + 0]+=0.3;
 			color[i*4 + 1]+=0.3;
 			color[i*4 + 2]+=0.3;
-	}
+		}
 	s3d_pep_materials_a(dir->oid,color,1);
 }
 /* draws icon dir */
 int icon_draw(t_node *dir)
 {
 	float vertices[]={	-1,-0.5,0,
-						-1, 0.5,0,
-						 1, 0.5,0,
-						 1,-0.5,0,
-						-1,-0.5,-1,
-						-1, 0.5,-1,
-						 1, 0.5,-1,
-						 1,-0.5,-1};
+	                   -1, 0.5,0,
+	                   1, 0.5,0,
+	                   1,-0.5,0,
+	                   -1,-0.5,-1,
+	                   -1, 0.5,-1,
+	                   1, 0.5,-1,
+	                   1,-0.5,-1
+	                 };
 	uint32_t polys[]={
-				1,3,0,0,				2,3,1,0,
-				5,6,2,0,				1,5,2,0,
-				2,6,7,0,				2,7,3,0,
-				0,3,7,0,				0,7,4,0,
-				5,1,0,0,				5,0,4,0	
-				};
+		1,3,0,0,				2,3,1,0,
+		5,6,2,0,				1,5,2,0,
+		2,6,7,0,				2,7,3,0,
+		0,3,7,0,				0,7,4,0,
+		5,1,0,0,				5,0,4,0
+	};
 	float len;
 	/* find position for the new block in our directory box */
 	/* create the block */
@@ -76,8 +78,7 @@
 	s3d_push_polygons(dir->oid,polys,10);
 
 	/* draw and position the string */
-	if (dir->objs.str==-1)
-	{
+	if (dir->objs.str==-1) {
 		dir->objs.str=s3d_draw_string(dir->name,&len);
 		if (len<2) len=2;
 		dir->objs.strlen=len;
@@ -91,13 +92,11 @@
 }
 int icon_undisplay(t_node *dir)
 {
-	if (dir->oid!=-1)
-	{
+	if (dir->oid!=-1) {
 		s3d_del_object(dir->oid);
 		dir->oid=-1;
 	}
-	if (dir->objs.str!=-1)
-	{
+	if (dir->objs.str!=-1) {
 		s3d_del_object(dir->objs.str);
 		dir->objs.str=-1;
 	}

Modified: trunk/apps/s3dfm/main.c
===================================================================
--- trunk/apps/s3dfm/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * main.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -25,7 +25,9 @@
 #include "s3dfm.h"
 #include <string.h>  /*  strlen(), strncmp(), strrchr() */
 #include <time.h>	/* nanosleep() */
-static struct timespec t={0,33*1000*1000}; 
+static struct timespec t= {
+	0,33*1000*1000
+};
 t_node root,cam,*focus;
 
 void mainloop()
@@ -33,7 +35,7 @@
 	ani_mate();
 	s3dw_ani_mate();
 	window_fsani();
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 }
 int main (int argc, char **argv)
 {
@@ -41,8 +43,7 @@
 	s3d_set_callback(S3D_EVENT_OBJ_CLICK,event_click);
 	s3d_set_callback(S3D_EVENT_OBJ_INFO,event_oinfo);
 	s3d_set_callback(S3D_EVENT_KEY,event_key);
-	if (!s3d_init(&argc,&argv,"s3dfm"))	
-	{
+	if (!s3d_init(&argc,&argv,"s3dfm")) {
 		s3d_select_font("vera");
 
 		node_init(&cam); /* a virtual object, just to push the cam throu our animation stack */
@@ -57,9 +58,9 @@
 		box_draw(&root);
 		ani_doit(&root);
 		focus_set(&root);
-		
-		
-		
+
+
+
 		s3d_mainloop(mainloop);
 		s3d_quit();
 	}

Modified: trunk/apps/s3dfm/node.c
===================================================================
--- trunk/apps/s3dfm/node.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/node.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * node.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -32,10 +32,9 @@
 	char *s,*match;
 	t_node *cur;
 	int i;
-	
+
 	if (path==NULL) return NULL;
-	if (path[0]=='/')
-	{
+	if (path[0]=='/') {
 		strncpy(p,path,M_DIR-1);
 		s=p+1;
 		cur=&root;
@@ -44,8 +43,7 @@
 	printf("processing rest of string %s\n",s);
 	match=s;
 	while (*s!=0) { /* while search string is not empty */
-		if ((s=index(s,'/'))!=NULL)
-		{
+		if ((s=index(s,'/'))!=NULL) {
 			s[0]=0; /* mark the slash with space */
 			s++;	/* move to the next */
 		} else {
@@ -54,8 +52,7 @@
 		/* parse ... */
 		printf("looking for a match for %s, rest is %s\n",match,s);
 		for (i=0;i<cur->n_sub;i++)
-			if (0==strcmp(cur->sub[i]->name,match))
-			{ /* found !! */
+			if (0==strcmp(cur->sub[i]->name,match)) { /* found !! */
 				cur=cur->sub[i]; /* forward */
 				match=s; /* select next */
 				break;
@@ -87,8 +84,7 @@
 /* writes the path of dir into *path. path should be of type path[M_DIR] */
 void node_path(t_node *dir, char *path)
 {
-	if (dir->parent!=NULL)
-	{
+	if (dir->parent!=NULL) {
 		node_path(dir->parent,path);
 		if (dir->parent->parent!=NULL)
 			mstrncat(path,"/",M_DIR);
@@ -110,7 +106,7 @@
 	dir->objs.title=-1;
 	dir->objs.titlestr=-1;
 	dir->objs.strlen=0;
-	
+
 	dir->disp=D_NONE;
 	dir->parsed=0;
 
@@ -128,11 +124,15 @@
 /* general undisplay routine. does not handle anything recursively... */
 int node_undisplay(t_node *dir)
 {
-	switch (dir->disp)
-	{
-		case D_DIR: return(box_undisplay(dir));break;
-		case D_ICON:return(icon_undisplay(dir));break;
-		default:	return(-1);
+	switch (dir->disp) {
+	case D_DIR:
+		return(box_undisplay(dir));
+		break;
+	case D_ICON:
+		return(icon_undisplay(dir));
+		break;
+	default:
+		return(-1);
 	}
 	dir->disp=0;
 }
@@ -141,8 +141,7 @@
 int node_delete(t_node *dir)
 {
 	int i;
-	if (dir->parent==NULL) 
-	{
+	if (dir->parent==NULL) {
 		printf("won't delete root window!\n");
 		return(-1);
 	}
@@ -154,10 +153,11 @@
 	}
 	/* move focus upward, this should go up with the recursion */
 	if (focus==dir)	focus_set(dir->parent); /* do this before deleting the contents, its better ... */
-	switch (dir->disp)
-	{
-			case D_DIR:  box_undisplay(dir);
-			case D_ICON: icon_undisplay(dir);
+	switch (dir->disp) {
+	case D_DIR:
+		box_undisplay(dir);
+	case D_ICON:
+		icon_undisplay(dir);
 	}
 
 	if (-1!=(i=ani_onstack(dir))) ani_del(i); /* tell animation stack too */
@@ -167,40 +167,40 @@
 /* node select handles click on the detach button. selected items can be moved, copied etc.*/
 void node_select(t_node *dir)
 {
-		
+
 	dir->detached=dir->detached?0:1; /* swapping, not sure if !dir->detached would do the same .. */
-	switch (dir->disp)
-	{
-		case D_DIR:
-			if (focus!=dir)
-			{
-				dir->detached=dir->detached?0:1; /* swap again, we actually don't want to have it detachedf now. */
-				focus_set(dir);
-			}
-			if (dir->parent!=NULL)
-				box_order_subdirs(dir->parent);
-			break;
-		case D_ICON:
-			if (dir->type==T_FOLDER)
-			{
-				dir->detached=0;
-				if (!parse_dir(dir))
-					box_expand(dir);
-			} else {
-				dir->pz=dir->detached*0.2+1.0;
-				ani_add(dir);
-			}
+	switch (dir->disp) {
+	case D_DIR:
+		if (focus!=dir) {
+			dir->detached=dir->detached?0:1; /* swap again, we actually don't want to have it detachedf now. */
 			focus_set(dir);
-			break;
+		}
+		if (dir->parent!=NULL)
+			box_order_subdirs(dir->parent);
+		break;
+	case D_ICON:
+		if (dir->type==T_FOLDER) {
+			dir->detached=0;
+			if (!parse_dir(dir))
+				box_expand(dir);
+		} else {
+			dir->pz=dir->detached*0.2+1.0;
+			ani_add(dir);
+		}
+		focus_set(dir);
+		break;
 	}
 }
 /* change color etc if a node is focused */
 void node_focus_color(t_node *node, int on)
 {
-	switch (node->disp)
-	{
-		case D_DIR:  box_focus_color(node,on);	break;
-		case D_ICON: icon_focus_color(node,on); break;
+	switch (node->disp) {
+	case D_DIR:
+		box_focus_color(node,on);
+		break;
+	case D_ICON:
+		icon_focus_color(node,on);
+		break;
 	}
 }
 /* get the directory of a node */

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/parse.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * main.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -37,34 +37,30 @@
 	DIR	 *dirhd=NULL;
 	char *ext,*nstr=NULL;
 	char path[M_DIR];
-	char ndir[M_DIR]; 
-	
+	char ndir[M_DIR];
+
 	printf("parse_dir( %s )\n",dir->name);
 	node_path(dir,path);
-	for (i=0;i<dir->n_sub;i++)
-	{
+	for (i=0;i<dir->n_sub;i++) {
 		dir->sub[i]->check=1;
 	}
-    n = i = scandir(path, &namelist, 0, alphasort);
-    if (n < 0)
-	{
+	n = i = scandir(path, &namelist, 0, alphasort);
+	if (n < 0) {
 		window_fs_errno(path);
 		return(-1);
 	} else {
 		oldn=dir->n_sub;
-        while(n--) {
+		while (n--) {
 			nstr = namelist[n]->d_name;
 			/* setup kids in the sub */
 			for (i=0;i<oldn;i++) /* see if it's already there */
 				if (dir->sub[i])
-				if (0==strcmp(namelist[n]->d_name,dir->sub[i]->name))
-					break;
- 		    if ((0!=strcmp(nstr,".")) && (0!=strcmp(nstr,".."))) /* we don't care about those */
-			{
-				if (i==oldn)
-				{	/* it's new, add it, initialize it ... */
+					if (0==strcmp(namelist[n]->d_name,dir->sub[i]->name))
+						break;
+			if ((0!=strcmp(nstr,".")) && (0!=strcmp(nstr,".."))) { /* we don't care about those */
+				if (i==oldn) {	/* it's new, add it, initialize it ... */
 					i=dir->n_sub;
-					/* i now holds the right index in sub, so we use dir->sub[i] 
+					/* i now holds the right index in sub, so we use dir->sub[i]
 					 * to reference the new item now... */
 					dir->n_sub++;
 					dir->sub = realloc( dir->sub , dir->n_sub * sizeof(t_node *) );
@@ -78,10 +74,9 @@
 				dir->sub[i]->pindex=i;
 				ext=strrchr(nstr,'.');
 				strncpy(ndir,path,M_DIR);
-		    	strncat(ndir,namelist[n]->d_name,M_DIR);
-			    if ((namelist[n]->d_type==DT_DIR) || ((namelist[n]->d_type==DT_UNKNOWN)))
-					if ((dirhd=opendir(ndir))!=NULL)
-					{
+				strncat(ndir,namelist[n]->d_name,M_DIR);
+				if ((namelist[n]->d_type==DT_DIR) || ((namelist[n]->d_type==DT_UNKNOWN)))
+					if ((dirhd=opendir(ndir))!=NULL) {
 						dir->sub[i]->type=T_FOLDER;
 						closedir(dirhd);
 					} /*else if (ext!=NULL)
@@ -91,13 +86,12 @@
 						   }	*/
 				dir->sub[i]->check=0; /* check=0 means we've already processed this item */
 			}
-	   	    free(namelist[n]);
+			free(namelist[n]);
 		}
 		free(namelist);
 		dir->check=0;
 		for (i=0;i<dir->n_sub;i++)
-			if (dir->sub[i]->check) 
-			{
+			if (dir->sub[i]->check) {
 				/* not checked yet... that means the item is not in the reparsed directory, ie vanished.
 				 * so we're removing it from our queue */
 				node_delete(dir->sub[i]);
@@ -109,7 +103,7 @@
 		/* if we removed something, then shrink the buffer accordingly .. */
 		if (dir->check)		dir->sub = realloc( dir->sub , dir->n_sub * sizeof(t_node *) );
 		dir->parsed=1;
-   	}
+	}
 	return(0);
 }
 

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/s3dfm.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * s3dfm.h
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -60,13 +60,13 @@
 	int				 parsed,detached;					/* Flags for parsed/detached (selected) nodes ... */
 	int 			 oid;								/* main oid, e.g the block or icons oid */
 	int 			 pindex;							/* the index in parents structure */
-	struct 			 {	
+	struct 			 {
 		/* some objects which might be used ... if not, should be -1 */
 		int 		 close,select,title,titlestr; /* box decorations. */
 		int 		 str;						  /* the name of the nodeas s3d object */
 		float		 strlen;					  /* the length of this string */
-		
-		
+
+
 	} 				 objs;
 	int 			 check;							    /* check marker, for internal things */
 };
@@ -93,8 +93,8 @@
 	ESTATE_NONE,
 	ESTATE_RISE,
 	ESTATE_WAIT_FOR_CONFIRM
-		/* TODO: more states should be added and handed back to the filesystem processor, like 
-		 * skip, abort, retry ... */
+	/* TODO: more states should be added and handed back to the filesystem processor, like
+	 * skip, abort, retry ... */
 };
 typedef struct _filelist filelist;
 typedef struct _t_node   t_node;

Modified: trunk/apps/s3dfm/string.c
===================================================================
--- trunk/apps/s3dfm/string.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dfm/string.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,30 +5,30 @@
  *
  * This file is part of s3dfm, a s3d file manager.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dfm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dfm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-/* just a few helper functions which only operate on strings, so we put them 
+/* just a few helper functions which only operate on strings, so we put them
  * here ... */
 
 #include "s3dfm.h"
 #include <string.h> /* strlen(), strncpy() */
 
-/* writes the path of the item d in string str with bufferlength n, 
- * adds some dots to the beginning if its too long */ 
+/* writes the path of the item d in string str with bufferlength n,
+ * adds some dots to the beginning if its too long */
 char *dots_at_start(char *str, unsigned int n, t_node *d)
 {
 	char *s=str;
@@ -37,18 +37,16 @@
 	s[n-1]=0;
 	do {
 		j=strlen(d->name)-1;
-		if (NULL!=(d->parent))
-		{
+		if (NULL!=(d->parent)) {
 			s[i]='/';
 			i--;
 		}
-		while ((i >= 0) && (j >= 0))
-		{
+		while ((i >= 0) && (j >= 0)) {
 			s[i]=d->name[j];
 			j--;
 			i--;
 		}
-		if (i<0) 
+		if (i<0)
 			break;
 	} while ((d=d->parent)!=NULL);
 	if (i<0)			s[0]=s[1]='.';
@@ -63,8 +61,7 @@
 	int p;
 	p=0;
 	st[0]=0;
-	while (i>0)
-	{
+	while (i>0) {
 		if ((p+1)%4==0) {
 			st[p]='.';
 			p++;
@@ -86,9 +83,8 @@
 	int i,j;
 	dest[n-1]=0;						/* for malformed destinations */
 	j=0;
-	for (i=strlen(dest);i<(n-1);i++)
-	{
-		dest[i]=src[j]; 
+	for (i=strlen(dest);i<(n-1);i++) {
+		dest[i]=src[j];
 		if (dest[i]==0) break;
 		j++;
 	}

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/db.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * db.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -55,13 +55,13 @@
 {
 	char addquery[MAXQ];
 	node->base.tagid= tagid++;
-	
+
 	if (node->base.id==0) /* give own id */
 		snprintf(addquery,MAXQ,"INSERT INTO node (layer_id, latitude, longitude, altitude, visible, tag_id) VALUES (%d, %f, %f, %f, %d, %d);",
-						(int)node->base.layerid,				node->lat,		node->lon,		node->alt,		node->visible, 		(int)node->base.tagid);
+		         (int)node->base.layerid,				node->lat,		node->lon,		node->alt,		node->visible, 		(int)node->base.tagid);
 	else
 		snprintf(addquery,MAXQ,"INSERT INTO node (layer_id, node_id,latitude, longitude, altitude, visible, tag_id) VALUES (%d, %d, %f, %f, %f, %d, %d);",
-					(int)node->base.layerid,(int)node->base.id,	node->lat,		node->lon,		node->alt,		node->visible, 		(int)node->base.tagid);
+		         (int)node->base.layerid,(int)node->base.id,	node->lat,		node->lon,		node->alt,		node->visible, 		(int)node->base.tagid);
 
 	db_exec(addquery, NULL, 0);
 	return(0);
@@ -71,19 +71,18 @@
 {
 	char addquery[MAXQ];
 	seg->base.tagid=tagid++;
-	
 
-	if (seg->base.id==0) /* give own id */
-	{
+
+	if (seg->base.id==0) { /* give own id */
 		printf("ugh, segment id is 0!\n");
 		exit(0);
 	}
-/*	if (seg->base.id==0) / * give own id * /
-		snprintf(addquery,MAXQ,"INSERT INTO segment (layer_id, node_from, node_to, tag_id) VALUES (%d, %d, %d), %d;",
-						(int)seg->base.layerid,				(int)seg->from, (int)seg->to,	tagid );
-	else*/
-		snprintf(addquery,MAXQ,"INSERT INTO segment (layer_id, seg_id, node_from, node_to, tag_id) VALUES (%d, %d, %d, %d, %d);",
-						(int)seg->base.layerid,(int)seg->base.id,(int)seg->from, (int)seg->to,	(int)seg->base.tagid );
+	/*	if (seg->base.id==0) / * give own id * /
+			snprintf(addquery,MAXQ,"INSERT INTO segment (layer_id, node_from, node_to, tag_id) VALUES (%d, %d, %d), %d;",
+							(int)seg->base.layerid,				(int)seg->from, (int)seg->to,	tagid );
+		else*/
+	snprintf(addquery,MAXQ,"INSERT INTO segment (layer_id, seg_id, node_from, node_to, tag_id) VALUES (%d, %d, %d, %d, %d);",
+	         (int)seg->base.layerid,(int)seg->base.id,(int)seg->from, (int)seg->to,	(int)seg->base.tagid );
 	db_exec(addquery, NULL, 0);
 
 	return(0);
@@ -111,21 +110,22 @@
 	char clayer[MAXQ];
 	int layerid=-1;
 	clean_string(clayer,layer_name,MAXQ);
-	
+
 	snprintf(findquery, MAXQ, "SELECT layer_id FROM layer WHERE name='%s';", clayer);
-    db_exec(findquery, db_getint, &layerid);
-	if (layerid==-1) /* need to add */
-	{
+	db_exec(findquery, db_getint, &layerid);
+	if (layerid==-1) { /* need to add */
 		snprintf(addquery, MAXQ, "INSERT INTO layer(name) VALUES ('%s');", clayer);
-    	db_exec(addquery, NULL, 0);db_flush();
-    	db_exec(findquery, db_getint, &layerid);
+		db_exec(addquery, NULL, 0);
+		db_flush();
+		db_exec(findquery, db_getint, &layerid);
 	}
 	return(layerid);
 }
 #define MAGIC	1337 /* just to elevate the nodes a little bit */
 static int found=0;
 /* tries to find node coordinates of ip, returns 1 if has found something */
-int db_olsr_check(char *ip, float *pos) {
+int db_olsr_check(char *ip, float *pos)
+{
 	char findquery[MAXQ];
 	char clean_ip[16];
 	float p[6];
@@ -133,11 +133,11 @@
 	clean_string(clean_ip,ip,16);
 	if (NULL!=(s=strchr(clean_ip,'/')))  /* don't process ip's with subnet information */
 		*s=0; /* TERMINATING ZERO!! */
-	
+
 	snprintf(findquery, MAXQ, "SELECT latitude, longitude, altitude FROM node WHERE tag_id=(SELECT tag_id FROM tag WHERE tagkey='ip' AND tagvalue='%s');", clean_ip);
 	found=MAGIC;
-   	db_exec(findquery, db_getpoint, p);
-	if (found==1) { 
+	db_exec(findquery, db_getpoint, p);
+	if (found==1) {
 		pos[0]=p[0];
 		pos[1]=p[1];
 		pos[2]=p[2];
@@ -145,12 +145,13 @@
 		return(1);
 	}
 	found=0;
-	return(0);	
+	return(0);
 }
 /* initializes the starting point of nodes  by averaging its lon/lat */
-int db_olsr_node_init(float *pos) {
+int db_olsr_node_init(float *pos)
+{
 	found=0;
-   	db_exec("SELECT AVG(latitude) as latitude, AVG(longitude) as longitude, AVG(altitude) as altitude FROM node WHERE tag_id IN (SELECT tag_id FROM tag WHERE tagkey='ip');", db_getpoint, pos);
+	db_exec("SELECT AVG(latitude) as latitude, AVG(longitude) as longitude, AVG(altitude) as altitude FROM node WHERE tag_id IN (SELECT tag_id FROM tag WHERE tagkey='ip');", db_getpoint, pos);
 	printf("pos = %3.3f %3.3f %3.3f\n",pos[0],pos[1],pos[2]);
 	return(0);	/* return 1 if something is found, 0 if pos[0] its still 0 */
 }
@@ -162,15 +163,21 @@
 	float lo=0.0,la=0.0,alt=0.0;
 	float *p=data;
 	int i;
-	for(i=0; i<argc; i++){
+	for (i=0; i<argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],"longitude"))			lo=strtod(argv[i],NULL);
 			else if (0==strcmp(azColName[i],"latitude"))		la=strtod(argv[i],NULL);
 			else if (0==strcmp(azColName[i],"altitude"))		alt=strtod(argv[i],NULL);
 		}
 	}
-	if (lo==0.0)	{	printf("missing lo\n");	exit(0);	}
-	if (la==0.0)	{	printf("missing la\n");	exit(0); 	}
+	if (lo==0.0)	{
+		printf("missing lo\n");
+		exit(0);
+	}
+	if (la==0.0)	{
+		printf("missing la\n");
+		exit(0);
+	}
 	if (found==MAGIC) alt=2;
 	calc_earth_to_eukl(la,lo,alt,p);
 	p[3]=la;
@@ -181,14 +188,16 @@
 }
 
 /* sqlite3-callback to get an integer of the database */
-int db_getint(void *tagid, int argc, char **argv, char **azColName){
-  if (argv[0]!=NULL) 
-	  *((int *)tagid)=atoi(argv[0]);
-  return 0;
+int db_getint(void *tagid, int argc, char **argv, char **azColName)
+{
+	if (argv[0]!=NULL)
+		*((int *)tagid)=atoi(argv[0]);
+	return 0;
 }
 
 /* sqlite3-callback to get a string of the database */
-static int db_getstr(void *string, int argc, char **argv, char **azColName) {
+static int db_getstr(void *string, int argc, char **argv, char **azColName)
+{
 	if (argv[0])
 		strncpy((char *)string,argv[0],MAXQ);
 	return(0);
@@ -204,19 +213,20 @@
 	return(target[0]==0);
 }
 
-int callback(void *NotUsed, int argc, char **argv, char **azColName){
-  int i;
-  for(i=0; i<argc; i++){
-    printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
-  }
-  printf("\n");
-  return 0;
+int callback(void *NotUsed, int argc, char **argv, char **azColName)
+{
+	int i;
+	for (i=0; i<argc; i++) {
+		printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
+	}
+	printf("\n");
+	return 0;
 }
 static int db_really_exec(const char *query, sqlite3_callback callback, void *arg)
 {
 	char *zErrMsg = 0;
 	int rc;
-	if(SQLITE_OK !=(  rc = sqlite3_exec(db, query, callback, arg, &zErrMsg))) {
+	if (SQLITE_OK !=(  rc = sqlite3_exec(db, query, callback, arg, &zErrMsg))) {
 		fprintf(stderr,"query: %s\n",query);
 		fprintf(stderr, "SQL error: %s\n", zErrMsg);
 		exit(-1);
@@ -236,8 +246,7 @@
 {
 	int ret;
 #ifdef DB_STACK
-	if (callback==NULL) /* we can stack it */
-	{
+	if (callback==NULL) { /* we can stack it */
 		int len;
 		len=strlen(query);
 		if (len+qlen>=QBUF)
@@ -245,36 +254,35 @@
 		strncat(qbuf,query,QBUF);
 		qlen+=strlen(query);
 		ret=0;
-	} else 
-#endif
-	{
+	} else
+#endif {
 		ret=db_really_exec(query,callback,arg);		/* pass it to the real function */
-	}
-	return(ret);
 }
+return(ret);
+}
 int db_init(char *dbFile)
 {
-  int rc;
-  tagid=1;
-  qbuf[0]=0;		/* clear querybuffer */
-  qlen=0;
+	int rc;
+	tagid=1;
+	qbuf[0]=0;		/* clear querybuffer */
+	qlen=0;
 
-  unlink(dbFile);	/* remove if already there */
-  rc = sqlite3_open(dbFile, &db);
-  if( rc ){
-    fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
-    sqlite3_close(db);
-    return(-1);
-  }
-  return(0);
+	unlink(dbFile);	/* remove if already there */
+	rc = sqlite3_open(dbFile, &db);
+	if ( rc ) {
+		fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
+		sqlite3_close(db);
+		return(-1);
+	}
+	return(0);
 }
 int db_quit()
 {
-  sqlite3_close(db);
-  if (dbFile!=NULL) 
-	if (unlink(dbFile))
-		perror("db_quit()");
-  return(0);
+	sqlite3_close(db);
+	if (dbFile!=NULL)
+		if (unlink(dbFile))
+			perror("db_quit()");
+	return(0);
 }
 int db_create()
 {
@@ -283,7 +291,7 @@
 	db_exec("CREATE TABLE way (layer_id INTEGER, way_id INTEGER, tag_id INT, s3doid INT, PRIMARY KEY(layer_id,way_id));", NULL, 0);
 	db_exec("CREATE TABLE layer (layer_id INTEGER, name TEXT, PRIMARY KEY(layer_id));", NULL, 0);
 	db_exec("CREATE TABLE tag (tag_id INT, tagkey TEXT, tagvalue TEXT, PRIMARY KEY(tag_id, tagkey));", NULL, 0);
-	
+
 	/*
 	db_exec("CREATE UNIQUE INDEX node_id_index ON node (node_id,layer_id);", NULL, 0);
 	db_exec("CREATE UNIQUE INDEX segment_id_index ON segment (seg_id,layer_id);", NULL, 0);

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/draw.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * draw.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -82,17 +82,17 @@
 	x[1]=(ESIZE+alt)*			sin(la);
 	x[2]=(ESIZE+alt)*cos(lo) *cos(la);
 }
-int draw_icon(void *data, int argc, char **argv, char **azColName) 
+int draw_icon(void *data, int argc, char **argv, char **azColName)
 {
 	int i,tagid=-1,oid;
 	int nodeid=-1, layerid=-1;
-/*	char query[MAXQ];*/
+	/*	char query[MAXQ];*/
 	char s[MAXQ];
 	float la, lo, alt;
 	float x[3];
 	la=lo=alt=0.0;
 	num_done++;
-	for(i=0; i<argc; i++) {
+	for (i=0; i<argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],"longitude"))			lo=strtod(argv[i],NULL);
 			else if (0==strcmp(azColName[i],"latitude"))		la=strtod(argv[i],NULL);
@@ -121,11 +121,11 @@
 			s3d_link(oid,oidy);
 			s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			load_update_status((100.0*num_done)/(float)num_max);
-/*			snprintf(query,MAXQ,"UPDATE node SET s3doid=%d WHERE node_id=%d AND layer_id=%d;",oid,nodeid,layerid);
-			db_exec(query, NULL, 0);*/
+			/*			snprintf(query,MAXQ,"UPDATE node SET s3doid=%d WHERE node_id=%d AND layer_id=%d;",oid,nodeid,layerid);
+						db_exec(query, NULL, 0);*/
 		}
-				
-	} 
+
+	}
 	return(0);
 }
 /* just fetches node information and puts in the nodelist */
@@ -133,7 +133,7 @@
 {
 	struct nodelist *np=data;	/* get the nodepointer */
 	int i;
-	for(i=0; i<argc; i++){
+	for (i=0; i<argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],"longitude"))			np[nodelist_n].lo=strtod(argv[i],NULL);
 			else if (0==strcmp(azColName[i],"latitude"))		np[nodelist_n].la=strtod(argv[i],NULL);
@@ -145,13 +145,13 @@
 int select_waytype(void *data, int argc, char **argv, char **azColName)
 {
 	int i;
-	for(i=0; i<argc; i++){
+	for (i=0; i<argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(argv[i],"motorway"))				*((int *) data)=5;	
-			else if (0==strcmp(argv[i],"motorway_link"))	*((int *) data)=4;	
-			else if (0==strcmp(argv[i],"primary"))			*((int *) data)=3;	
-			else if (0==strcmp(argv[i],"secondary"))		*((int *) data)=2;	
-			else if (0==strcmp(argv[i],"residential"))		*((int *) data)=1;	
+			if (0==strcmp(argv[i],"motorway"))				*((int *) data)=5;
+			else if (0==strcmp(argv[i],"motorway_link"))	*((int *) data)=4;
+			else if (0==strcmp(argv[i],"primary"))			*((int *) data)=3;
+			else if (0==strcmp(argv[i],"secondary"))		*((int *) data)=2;
+			else if (0==strcmp(argv[i],"residential"))		*((int *) data)=1;
 		}
 	}
 	return(0);
@@ -176,20 +176,25 @@
 
 	if (waylist_n==0)	/* no nodes, no fun */
 		return;
-/*	printf("way: %d - %d segments\n",lastid,waylist_n);*/
+	/*	printf("way: %d - %d segments\n",lastid,waylist_n);*/
 	way_obj=s3d_new_object();
 	if (lastid!=-1) {
 		snprintf(query,MAXQ,"SELECT tagvalue FROM tag WHERE tag_id=(SELECT tag_id FROM way WHERE way_id=%d AND %s) AND tagkey='highway';",lastid,filter);
 		db_exec(query, select_waytype, &waytype);
 	}
-	switch (waytype)
-	{
-		case 5:s3d_push_material(way_obj,0.2,0.2,0.6,		1.0,1.0,1.0,	0.3,0.3,1.0);	/* motorway */
-		case 4:s3d_push_material(way_obj,0.3,0.3,0.4,		1.0,1.0,1.0,	0.5,0.5,0.8);	/* motorway_link*/
-		case 3:s3d_push_material(way_obj,0.6,0.3,0.1,		1.0,1.0,1.0, 	1.0,0.6,0.2);	/* primary */
-		case 2:s3d_push_material(way_obj,0.6,0.6,0.0,		1.0,1.0,1.0, 	1.0,1.0,0.0);	/* secondary */
-		case 1:s3d_push_material(way_obj,0.6,0.6,0.6,		1.0,1.0,1.0, 	1.0,1.0,1.0);	/* residential */
-		default:s3d_push_material(way_obj,0.6,0.2,0.6,		1.0,1.0,1.0,	1.0,0.5,1.0); /* default */
+	switch (waytype) {
+	case 5:
+		s3d_push_material(way_obj,0.2,0.2,0.6,		1.0,1.0,1.0,	0.3,0.3,1.0);	/* motorway */
+	case 4:
+		s3d_push_material(way_obj,0.3,0.3,0.4,		1.0,1.0,1.0,	0.5,0.5,0.8);	/* motorway_link*/
+	case 3:
+		s3d_push_material(way_obj,0.6,0.3,0.1,		1.0,1.0,1.0, 	1.0,0.6,0.2);	/* primary */
+	case 2:
+		s3d_push_material(way_obj,0.6,0.6,0.0,		1.0,1.0,1.0, 	1.0,1.0,0.0);	/* secondary */
+	case 1:
+		s3d_push_material(way_obj,0.6,0.6,0.6,		1.0,1.0,1.0, 	1.0,1.0,1.0);	/* residential */
+	default:
+		s3d_push_material(way_obj,0.6,0.2,0.6,		1.0,1.0,1.0,	1.0,0.5,1.0); /* default */
 	}
 	street_width=(0.5+waytype/10)/RESCALE;
 	/* put nodes of the graph into a list */
@@ -200,7 +205,7 @@
 		for (j=0;j<nodelist_n;j++)
 			if (nodelist_p[j].node_id==node_id) break;
 		if (j==nodelist_n) { /* we still need to add this node */
-/*			printf("[way %d] add node %d to nodelist as %d\n",lastid, node_id, nodelist_n);*/
+			/*			printf("[way %d] add node %d to nodelist as %d\n",lastid, node_id, nodelist_n);*/
 			nodelist_p[j].node_id=node_id;
 			snprintf(query,MAXQ,"SELECT longitude, latitude, altitude FROM node WHERE %s AND node_id=%d;",filter, node_id);
 			db_exec(query, insert_node,(void *)(nodelist_p));
@@ -210,14 +215,13 @@
 			nodelist_p[j].normal[1]=nodelist_p[j].x[1]/len;
 			nodelist_p[j].normal[2]=nodelist_p[j].x[2]/len;
 			nodelist_n++;
-		} 
+		}
 		if (i%2)				waylist_p[i/2].node_from_int=j;
 		else					waylist_p[i/2].node_to_int=j;
 	}
 	V_COPY(point_zero, nodelist_p[0].x);
 	/* iterate for all nodes */
-	for (i=0;i<nodelist_n;i++)
-	{
+	for (i=0;i<nodelist_n;i++) {
 		/* find adjacent segments */
 		adjlist_n=0;
 		node_id=nodelist_p[i].node_id;
@@ -233,13 +237,10 @@
 			}
 		}
 
-		if (adjlist_n>1)	/* more than one adjacent, need to order and calculate intersections */
-		{
-			if (adjlist_n>2) /* no ordering needed for 2 incoming segments */
-			{
+		if (adjlist_n>1) {	/* more than one adjacent, need to order and calculate intersections */
+			if (adjlist_n>2) { /* no ordering needed for 2 incoming segments */
 				for (j=0;j<adjlist_n-2;j++)
-					for (k=j+2;k<adjlist_n;k++)
-					{
+					for (k=j+2;k<adjlist_n;k++) {
 						float test[3],normal[3],linevector[3];
 						/* (re)calc test direction */
 						V_SUB(nodelist_p[adjlist_p[j].node_id].x,	nodelist_p[adjlist_p[j+1].node_id].x,	linevector);
@@ -248,7 +249,7 @@
 							/* determine on which side the point is. if its between our testvector, we'll need to swap. */
 							V_SUB(nodelist_p[adjlist_p[j].node_id].x,nodelist_p[adjlist_p[k].node_id].x,test);
 							if (s3d_vector_dot_product(normal,test)>0) { /* same side, means adjacent line k is nearer to our point j
-																			than our point j+1 which is supposed to be the nearest point, 
+																			than our point j+1 which is supposed to be the nearest point,
 																			so we swap them and call a break to get the new test-normal */
 								struct adjlist swap;
 								memcpy(&swap,&(adjlist_p[j+1]),sizeof(struct adjlist));
@@ -266,8 +267,7 @@
 			V_NORM(right);
 
 
-			for (j=0;j<adjlist_n;j++)
-			{
+			for (j=0;j<adjlist_n;j++) {
 				swap=left;
 				left=right;			/* use last right segment as new left segment */
 				right=swap;			/* get space for the next right segment */
@@ -285,8 +285,7 @@
 				V_SCAL(n,1/n_len);	/* normalize n first! */
 				scale=V_DOT(n,an);	/* get cos (alpha/2), alpha is opposite angel of left and right segment */
 
-				if ((n_len<0.1) || (fabs(scale)<0.1))
-				{	/* too low, don't use, just have intersection 90 degree of it. */
+				if ((n_len<0.1) || (fabs(scale)<0.1)) {	/* too low, don't use, just have intersection 90 degree of it. */
 					V_SCAL(an, -street_width);		/* S = P + street_width * an */
 					V_ADD(nodelist_p[i].x, an, s);
 
@@ -294,22 +293,22 @@
 					V_SCAL(n,-street_width/scale);
 					V_ADD(s, n, s);
 				}
-				
-				
-/*				printf("calc intersection: %3.3f %3.3f %3.3f\n",s[0],s[1],s[2]);*/
-			V_SUB(s,point_zero,s);
+
+
+				/*				printf("calc intersection: %3.3f %3.3f %3.3f\n",s[0],s[1],s[2]);*/
+				V_SUB(s,point_zero,s);
 				s3d_push_vertices(way_obj,s,1);
 				adj_seg=adjlist_p[j].seg_id;				/* left segment */
 				if (i==waylist_p[adj_seg].node_from_int)	waylist_p[adj_seg].node_from_r=vert;
-					else									waylist_p[adj_seg].node_to_l=vert;
+				else									waylist_p[adj_seg].node_to_l=vert;
 				adj_seg=adjlist_p[(j+1)%adjlist_n].seg_id;	/* right segment */
 				if (i==waylist_p[adj_seg].node_from_int)	waylist_p[adj_seg].node_from_l=vert;
-					else									waylist_p[adj_seg].node_to_r=vert;
+				else									waylist_p[adj_seg].node_to_r=vert;
 				vert++;
 			}
 			if (adjlist_n>=3) {
 				/* we know that the last adjlist_n vertices set belong to our intersection here .. */
-				for (j=vert-adjlist_n+1;j<(vert-1);j++) 
+				for (j=vert-adjlist_n+1;j<(vert-1);j++)
 					s3d_push_polygon(way_obj, vert-adjlist_n, j, j+1,0 );
 			}
 		} else {
@@ -321,7 +320,7 @@
 
 			V_COPY(s,nodelist_p[i].x);
 			V_ADD(s,an,s);
-			V_SUB(s,point_zero,s); 
+			V_SUB(s,point_zero,s);
 			s3d_push_vertices(way_obj,s,1);
 			j=vert;
 			vert++;
@@ -332,7 +331,7 @@
 			s3d_push_vertices(way_obj,s,1);
 			k=vert;
 			vert++;
-			
+
 			adj_seg=adjlist_p[0].seg_id;
 			if (i==waylist_p[adj_seg].node_from_int)	{
 				waylist_p[adj_seg].node_from_l=j;
@@ -357,7 +356,7 @@
 
 		s3d_push_polygons(way_obj, polys, 2);
 	}
-	s3d_translate(way_obj,point_zero[0], point_zero[1], point_zero[2]); 
+	s3d_translate(way_obj,point_zero[0], point_zero[1], point_zero[2]);
 	s3d_link(way_obj,oidy);
 	s3d_flags_on(way_obj,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	snprintf(query,MAXQ,"UPDATE way SET s3doid=%d WHERE way_id=%d AND %s;",way_obj,lastid,filter);
@@ -390,7 +389,7 @@
 	p.node_from=p.node_to=0;
 	p.node_to=-1;
 	p.seg_id=-1;
-	for(i=0; i<argc; i++){
+	for (i=0; i<argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],"way_id"))				id=atoi(argv[i]);
 			else if (0==strcmp(azColName[i],"node_from"))		p.node_from=atoi(argv[i]);

Modified: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/gps.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * gps.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -54,7 +54,7 @@
 
 void show_gpsdata(struct gps_data_t *dgps)
 {
-	if (!dgps->online) 
+	if (!dgps->online)
 		printf("WARNING: no connection to gps device\n");
 #ifdef GPS_NEW
 	printf("[%d] lat/long: [%f|%f], altitude %f\n",frame,dgps->fix.latitude,dgps->fix.longitude,dgps->fix.altitude);
@@ -67,22 +67,35 @@
 	printf("used %d/%d satellits\n",dgps->satellites_used,dgps->satellites);
 
 #endif
-	switch (dgps->status)
-	{
-		case STATUS_NO_FIX:		printf("status: no fix\n");break;
-		case STATUS_FIX:		printf("status: fix\n");break;
-		case STATUS_DGPS_FIX:	printf("status: dgps fix\n");break;
+	switch (dgps->status) {
+	case STATUS_NO_FIX:
+		printf("status: no fix\n");
+		break;
+	case STATUS_FIX:
+		printf("status: fix\n");
+		break;
+	case STATUS_DGPS_FIX:
+		printf("status: dgps fix\n");
+		break;
 	}
 #ifdef GPS_NEW
 	switch (dgps->fix.mode)
-#else 
+#else
 	switch (dgps->mode)
 #endif
 	{
-		case MODE_NOT_SEEN:	printf("mode: not seen yet\n");break;
-		case MODE_NO_FIX:	printf("mode: no fix\n");break;
-		case MODE_2D:		printf("mode: 2d fix\n");break;
-		case MODE_3D:		printf("mode: 3d fix\n");break;
+	case MODE_NOT_SEEN:
+		printf("mode: not seen yet\n");
+		break;
+	case MODE_NO_FIX:
+		printf("mode: no fix\n");
+		break;
+	case MODE_2D:
+		printf("mode: 2d fix\n");
+		break;
+	case MODE_3D:
+		printf("mode: 3d fix\n");
+		break;
 	}
 }
 #define BUFSIZE		1024
@@ -92,40 +105,53 @@
 	float la,lo,heading,speed,slen;
 	char buf[BUFSIZE+1];
 #ifdef GPS_NEW
-	if (!dgps->online) 
+	if (!dgps->online)
 		fix=0;
-	switch (dgps->fix.mode)
-	{
-		case MODE_NOT_SEEN:	fix=0;break;
-		case MODE_NO_FIX:	fix=0;break;
+	switch (dgps->fix.mode) {
+	case MODE_NOT_SEEN:
+		fix=0;
+		break;
+	case MODE_NO_FIX:
+		fix=0;
+		break;
 	}
-	
+
 	la=dgps->fix.latitude;
 	lo=dgps->fix.longitude;
 	heading=-dgps->fix.track;
 	speed=dgps->fix.speed;
 
 #else
-	if (!dgps->online) 
+	if (!dgps->online)
 		fix=0;
-	switch (dgps->mode)
-	{
-		case MODE_NOT_SEEN:	fix=0;break;
-		case MODE_NO_FIX:	fix=0;break;
+	switch (dgps->mode) {
+	case MODE_NOT_SEEN:
+		fix=0;
+		break;
+	case MODE_NO_FIX:
+		fix=0;
+		break;
 	}
 	la=dgps->latitude;
 	lo=dgps->longitude;
 	heading=-dgps->track;
 	speed=dgps->speed*KNOTS_TO_MPH/METERS_TO_MILES/3600; /* speed in knots -> miles per hour -> meter per hour -> meter per secon */
 #endif
-	tlat=la;tlon=lo;
+	tlat=la;
+	tlon=lo;
 	if (fix) {
 		printf("have a fix\n");
 		nav_center(la,lo);
 		if (!finitef(heading)) {
 			heading=get_heading(lat_old,lon_old,la,lo);
-			if (!lastfix && fix) 		{s3d_scale(user_icon,1.0/RESCALE);}
-			if (lastfix && !fix)		{s3d_scale(user_icon,0.3/RESCALE);lat=tlat;lon=tlon;}
+			if (!lastfix && fix) 		{
+				s3d_scale(user_icon,1.0/RESCALE);
+			}
+			if (lastfix && !fix)		{
+				s3d_scale(user_icon,0.3/RESCALE);
+				lat=tlat;
+				lon=tlon;
+			}
 		}
 		if (finitef(heading))		s3d_rotate(user_icon,0,heading,0); /* wrong rotation? */
 		if (finitef(speed)) {
@@ -134,15 +160,15 @@
 			speed_old=speed;
 		} else
 			snprintf(buf,BUFSIZE,"speed: NA (old: %3.2f km/h)",speed_old*3.6);
-	
+
 		if (gps_info!=-1)	s3d_del_object(gps_info);
 		gps_info=s3d_draw_string(buf,&slen);
 		s3d_translate(gps_info,-slen/2,1,0);
 		s3d_link(gps_info, user_icon);
 		s3d_flags_on(gps_info,S3D_OF_VISIBLE);
 	}
-	
-	
+
+
 	lat_old=la;
 	lon_old=lo;
 	lastfix=fix;
@@ -151,24 +177,38 @@
 {
 	char *err_str;
 	dgps=gps_open(gpshost,"2947");
-    if (dgps==NULL) {
+	if (dgps==NULL) {
 		switch ( errno ) {
-			case NL_NOSERVICE: 	err_str = "can't get service entry"; break;
-			case NL_NOHOST: 	err_str = "can't get host entry"; break;
-			case NL_NOPROTO: 	err_str = "can't get protocol entry"; break;
-			case NL_NOSOCK: 	err_str = "can't create socket"; break;
-			case NL_NOSOCKOPT: 	err_str = "error SETSOCKOPT SO_REUSEADDR"; break;
-			case NL_NOCONNECT: 	err_str = "can't connect to host"; break;
-			default:           	err_str = "Unknown"; break;
+		case NL_NOSERVICE:
+			err_str = "can't get service entry";
+			break;
+		case NL_NOHOST:
+			err_str = "can't get host entry";
+			break;
+		case NL_NOPROTO:
+			err_str = "can't get protocol entry";
+			break;
+		case NL_NOSOCK:
+			err_str = "can't create socket";
+			break;
+		case NL_NOSOCKOPT:
+			err_str = "error SETSOCKOPT SO_REUSEADDR";
+			break;
+		case NL_NOCONNECT:
+			err_str = "can't connect to host";
+			break;
+		default:
+			err_str = "Unknown";
+			break;
 		}
-/*		printf("no connection to gpsd\n");*/
+		/*		printf("no connection to gpsd\n");*/
 		fprintf(stderr, "s3dosm: no gpsd running or network error: %d, %s\n"	,  errno, err_str);
 		return(-1);
 	}
 	user_icon=s3d_clone(icons[ICON_ARROW].oid);
 	user_icon_rotator=s3d_new_object();
 	s3d_link(user_icon,user_icon_rotator);
-	s3d_link(user_icon_rotator,oidy); 
+	s3d_link(user_icon_rotator,oidy);
 	s3d_flags_on(user_icon,S3D_OF_VISIBLE);
 	s3d_scale(user_icon,1.0/RESCALE);
 	tlat=lat=lat_old=0.0;
@@ -179,10 +219,8 @@
 }
 int gps_main()
 {
-	if (gps_active && ((frame%6)==0))
-	{
-		if (gps_poll(dgps) < 0) 
-		{
+	if (gps_active && ((frame%6)==0)) {
+		if (gps_poll(dgps) < 0) {
 			printf("read error on server socket\n");
 			gps_quit();
 		}
@@ -198,15 +236,17 @@
 			lat=(tlat+lat*7)/8;
 			lon=(tlon+lon*7)/8;
 		}
-	} else { tlat=lat;tlon=lon;}
+	} else {
+		tlat=lat;
+		tlon=lon;
+	}
 	draw_translate_icon(user_icon_rotator,lat,lon);
 	frame++;
 	return(0);
 }
 int gps_quit()
 {
-	if (gps_active)
-	{
+	if (gps_active) {
 		printf("deactivating gps-connection ...\n");
 		gps_active=0;
 		gps_close(dgps);

Modified: trunk/apps/s3dosm/http_error_codes.c
===================================================================
--- trunk/apps/s3dosm/http_error_codes.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/http_error_codes.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,6 +1,6 @@
 /* http_error_codes.c - Error code declarations
 
-	HTTP Fetcher 
+	HTTP Fetcher
  	Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
 
 	This library is free software; you can redistribute it and/or
@@ -17,9 +17,8 @@
  */
 
 
-	/* Note that '%d' cannot be escaped at this time */
-const char *http_errlist[] =
-	{
+/* Note that '%d' cannot be escaped at this time */
+const char *http_errlist[] = {
 	"Success",										/* HF_SUCCESS		*/
 	"Internal Error. What the hell?!",				/* HF_METAERROR		*/
 	"Got NULL url",									/* HF_NULLURL		*/
@@ -29,8 +28,8 @@
 	"Couldn't convert return code in HTTP response",/* HF_CRETURNCODE	*/
 	"Request returned a status code of %d",			/* HF_STATUSCODE	*/
 	"Couldn't convert Content-Length to integer"	/* HF_CONTENTLEN	*/
-	};
+};
 
-	/* Used to copy in messages from http_errlist[] and replace %d's with
-	 *	the value of errorInt.  Then we can pass the pointer to THIS */
+/* Used to copy in messages from http_errlist[] and replace %d's with
+ *	the value of errorInt.  Then we can pass the pointer to THIS */
 char convertedError[128];

Modified: trunk/apps/s3dosm/http_fetcher.c
===================================================================
--- trunk/apps/s3dosm/http_fetcher.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/http_fetcher.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -14,10 +14,10 @@
 
 	See included LICENSE file for details
 
-	Changes: 
+	Changes:
 		Simon Wunderlich <dotslash at packetmixer.de>
 		+ added http_setAuth() to support basic http-authentication and some minor fixes
-		
+
  */
 
 #include <stdlib.h>
@@ -48,14 +48,14 @@
 static int freeOldReferer = 0; /* Indicated previous malloc's */
 
 
-	/* 
-	 * Actually downloads the page, registering a hit (donation)
-	 *	If the fileBuf passed in is NULL, the url is downloaded and then
-	 *	freed; otherwise the necessary space is allocated for fileBuf.
-	 *	Returns size of download on success, -1 on error is set, 
-	 */
+/*
+ * Actually downloads the page, registering a hit (donation)
+ *	If the fileBuf passed in is NULL, the url is downloaded and then
+ *	freed; otherwise the necessary space is allocated for fileBuf.
+ *	Returns size of download on success, -1 on error is set,
+ */
 int http_fetch(const char *url_tmp, char **fileBuf)
-	{
+{
 	fd_set rfds;
 	struct timeval tv;
 	char requestBuf[REQUEST_BUF_SIZE];
@@ -65,46 +65,41 @@
 	int ret = -1, i, selectRet;
 
 
-	if(url_tmp == NULL)
-		{
+	if (url_tmp == NULL) {
 		errorSource = FETCHER_ERROR;
 		http_errno = HF_NULLURL;
 		return -1;
-		}
+	}
 
 	/* Copy the url passed in into a buffer we can work with, change, etc. */
 	url = malloc(strlen(url_tmp)+1);
-	if(url == NULL)
-		{
+	if (url == NULL) {
 		errorSource = ERRNO;
 		return -1;
-		}
+	}
 	strncpy(url, url_tmp, strlen(url_tmp) + 1);
-	
+
 	/* Seek to the file path portion of the url */
 	charIndex = strstr(url, "://");
-	if(charIndex != NULL)
-		{
+	if (charIndex != NULL) {
 		/* url contains a protocol field */
 		charIndex += strlen("://");
 		host = charIndex;
 		charIndex = strchr(charIndex, '/');
-		}
-	else
-		{
+	} else {
 		host = (char *)url;
 		charIndex = strchr(url, '/');
-		}
+	}
 
 	/* Compose a request string */
-	if(charIndex == NULL)
+	if (charIndex == NULL)
 		/* The url has no '/' in it, assume the user is making a root-level
-		 *	request */ 
+		 *	request */
 		sprintf(requestBuf, "GET / %s\r\n", HTTP_VERSION);
 	else
 		sprintf(requestBuf, "GET %s %s\r\n", charIndex, HTTP_VERSION);
 	/* Null out the end of the hostname if need be */
-	if(charIndex != NULL)
+	if (charIndex != NULL)
 		*charIndex = 0;
 
 	strcat(requestBuf, "Host: ");
@@ -112,29 +107,24 @@
 	strcat(requestBuf, "\r\n");
 
 
-	if(!hideReferer && referer != NULL)	/* NO default referer */
-		{
+	if (!hideReferer && referer != NULL) {	/* NO default referer */
 		strcat(requestBuf, "Referer: ");
 		strcat(requestBuf, referer);
 		strcat(requestBuf, "\r\n");
-		}
+	}
 
-	if(!hideUserAgent && userAgent == NULL)
-		{
+	if (!hideUserAgent && userAgent == NULL) {
 		strcat(requestBuf, "User-Agent: ");
 		strcat(requestBuf, DEFAULT_USER_AGENT);
 		strcat(requestBuf, "/");
 		strcat(requestBuf, HTTP_FETCHER_VERSION);
 		strcat(requestBuf, "\r\n");
-		}
-	else if(!hideUserAgent)
-		{
+	} else if (!hideUserAgent) {
 		strcat(requestBuf, "User-Agent: ");
 		strcat(requestBuf, userAgent);
 		strcat(requestBuf, "\r\n");
-		}
-	if (auth!=NULL)
-	{
+	}
+	if (auth!=NULL) {
 		strcat(requestBuf, "Authorization: Basic ");
 		strcat(requestBuf, auth);
 		strcat(requestBuf, "\r\n");
@@ -143,104 +133,107 @@
 
 	printf("[HTTP] creating connection ...\n");
 	sock = makeSocket(host);			/* errorSource set within makeSocket */
-	if(sock == -1) { free(url); return -1;}
+	if (sock == -1) {
+		free(url);
+		return -1;
+	}
 	printf("[HTTP] sending request \n");
-	if(write(sock, requestBuf, strlen(requestBuf)) == -1)
-		{ close(sock); free(url); errorSource = ERRNO; return -1; }
+	if (write(sock, requestBuf, strlen(requestBuf)) == -1) {
+		close(sock);
+		free(url);
+		errorSource = ERRNO;
+		return -1;
+	}
 
 	printf("[HTTP] receiving header\n");
 	/* Grab enough of the response to get the metadata */
 	ret = _http_read_header(sock, headerBuf);	/* errorSource set within */
-	if(ret < 0) { close(sock); free(url); return -1; }
+	if (ret < 0) {
+		close(sock);
+		free(url);
+		return -1;
+	}
 	printf("[HTTP] receiving content\n");
 
 	/* Get the return code */
 	charIndex = strstr(headerBuf, "HTTP/");
-	if(charIndex == NULL)
-		{
+	if (charIndex == NULL) {
 		close(sock);
 		free(url);
 		errorSource = FETCHER_ERROR;
 		http_errno = HF_FRETURNCODE;
 		return -1;
-		}
-	while(*charIndex != ' ')
+	}
+	while (*charIndex != ' ')
 		charIndex++;
 	charIndex++;
 
 	ret = sscanf(charIndex, "%i", &i);
-	if(ret != 1)
-		{
+	if (ret != 1) {
 		close(sock);
 		free(url);
 		errorSource = FETCHER_ERROR;
 		http_errno = HF_CRETURNCODE;
 		return -1;
-		}
-	if(i<200 || i>299)
-		{
+	}
+	if (i<200 || i>299) {
 		close(sock);
 		free(url);
 		errorInt = i;	/* Status code, to be inserted in error string */
 		errorSource = FETCHER_ERROR;
 		http_errno = HF_STATUSCODE;
 		return -1;
-		}
-	
+	}
+
 	/*
 	 * Parse out about how big the data segment is.
 	 *	Note that under current HTTP standards (1.1 and prior), the
-	 *	Content-Length field is not guaranteed to be accurate or even present. 
+	 *	Content-Length field is not guaranteed to be accurate or even present.
 	 *	I just use it here so I can allocate a ballpark amount of memory.
 	 *
 	 * Note that some servers use different capitalization
 	 */
 	charIndex = strstr(headerBuf, "Content-Length:");
-	if(charIndex == NULL)
+	if (charIndex == NULL)
 		charIndex = strstr(headerBuf, "Content-length:");
 
-	if(charIndex != NULL)
-		{
+	if (charIndex != NULL) {
 		ret = sscanf(charIndex + strlen("content-length: "), "%i",
-			&contentLength);
-		if(ret < 1)
-			{
+		             &contentLength);
+		if (ret < 1) {
 			close(sock);
 			free(url);
 			errorSource = FETCHER_ERROR;
 			http_errno = HF_CONTENTLEN;
 			return -1;
-			}
 		}
-	
+	}
+
 	/* Allocate enough memory to hold the page */
-	if(contentLength == -1)
+	if (contentLength == -1)
 		contentLength = DEFAULT_PAGE_BUF_SIZE;
 
 	pageBuf = (char *)malloc(contentLength+1);
-	if(pageBuf == NULL)
-		{
+	if (pageBuf == NULL) {
 		close(sock);
 		free(url);
 		errorSource = ERRNO;
 		return -1;
-		}
+	}
 
 	/* Begin reading the body of the file */
-	while(ret > 0)
-		{
+	while (ret > 0) {
 		FD_ZERO(&rfds);
 		FD_SET(sock, &rfds);
-		tv.tv_sec = timeout; 
+		tv.tv_sec = timeout;
 		tv.tv_usec = 0;
 
-		if(timeout >= 0)
+		if (timeout >= 0)
 			selectRet = select(sock+1, &rfds, NULL, NULL, &tv);
 		else		/* No timeout, can block indefinately */
 			selectRet = select(sock+1, &rfds, NULL, NULL, NULL);
 
-		if(selectRet == 0 && timeout < 0)
-			{
+		if (selectRet == 0 && timeout < 0) {
 			errorSource = FETCHER_ERROR;
 			http_errno = HF_DATATIMEOUT;
 			errorInt = timeout;
@@ -248,65 +241,59 @@
 			free(url);
 			free(pageBuf);
 			return -1;
-			}
-		else if(selectRet == -1)
-			{
+		} else if (selectRet == -1) {
 			close(sock);
 			free(url);
 			free(pageBuf);
 			errorSource = ERRNO;
 			return -1;
-			}
+		}
 
 		ret = read(sock, pageBuf + bytesRead, contentLength);
-		if(ret == -1)
-			{
+		if (ret == -1) {
 			close(sock);
 			free(url);
 			free(pageBuf);
 			errorSource = ERRNO;
 			return -1;
-			}
+		}
 
 		bytesRead += ret;
 
-		if(ret > 0)
-			{
+		if (ret > 0) {
 			/* To be tolerant of inaccurate Content-Length fields, we'll
 			 *	allocate another read-sized chunk to make sure we have
 			 *	enough room.
 			 */
 			pageBuf = (char *)realloc(pageBuf, bytesRead + contentLength);
-			if(pageBuf == NULL)
-				{
+			if (pageBuf == NULL) {
 				close(sock);
 				free(url);
 				free(pageBuf);
 				errorSource = ERRNO;
 				return -1;
-				}
 			}
+		}
 		printf("[HTTP] read %d bytes\n",ret);
-		}
-	
+	}
+
 	/*
 	 * The download buffer is too large.  Trim off the safety padding.
 	 */
 	pageBuf = (char *)realloc(pageBuf, bytesRead);
-		/* pageBuf shouldn't be null, since we're _shrinking_ the buffer,
-		 *	and if it DID fail, we could go on with the too-large buffer,
-		 *	but something would DEFINATELY be wrong, so we'll just give
-		 *	an error message */
-	if(pageBuf == NULL)
-		{
+	/* pageBuf shouldn't be null, since we're _shrinking_ the buffer,
+	 *	and if it DID fail, we could go on with the too-large buffer,
+	 *	but something would DEFINATELY be wrong, so we'll just give
+	 *	an error message */
+	if (pageBuf == NULL) {
 		close(sock);
 		free(url);
 		free(pageBuf);
 		errorSource = ERRNO;
 		return -1;
-		}
+	}
 
-	if(fileBuf == NULL)	/* They just wanted us to "hit" the url */
+	if (fileBuf == NULL)	/* They just wanted us to "hit" the url */
 		free(pageBuf);
 	else
 		*fileBuf = pageBuf;
@@ -314,65 +301,65 @@
 	close(sock);
 	free(url);
 	return bytesRead;
-	}
+}
 
 
 
-	/*
-	 * Changes the User Agent.  Returns 0 on success, -1 on error. 
-	 */
+/*
+ * Changes the User Agent.  Returns 0 on success, -1 on error.
+ */
 int http_setUserAgent(const char *newAgent)
-	{
+{
 	char *tmp;
 
-	if(newAgent == NULL)
-		{
-		if(freeOldAgent) free(userAgent);
+	if (newAgent == NULL) {
+		if (freeOldAgent) free(userAgent);
 		userAgent = NULL;
 		hideUserAgent = 1;
+	} else {
+		tmp = (char *)malloc(strlen(newAgent));
+		if (tmp == NULL) {
+			errorSource = ERRNO;
+			return -1;
 		}
-	else
-		{
-		tmp = (char *)malloc(strlen(newAgent));
-		if(tmp == NULL) { errorSource = ERRNO; return -1; }
-		if(freeOldAgent) free(userAgent);
+		if (freeOldAgent) free(userAgent);
 		userAgent = tmp;
 		strcpy(userAgent, newAgent);
 		freeOldAgent = 1;
 		hideUserAgent = 0;
-		}
+	}
 
 	return 0;
-	}
+}
 
 
 
-	/*
-	 * Changes the Referer.  Returns 0 on success, -1 on error
-	 */
+/*
+ * Changes the Referer.  Returns 0 on success, -1 on error
+ */
 int http_setReferer(const char *newReferer)
-	{
+{
 	char *tmp;
 
-	if(newReferer == NULL)
-		{
-		if(freeOldReferer) free(referer);
+	if (newReferer == NULL) {
+		if (freeOldReferer) free(referer);
 		referer = NULL;
 		hideReferer = 1;
+	} else {
+		tmp = (char *)malloc(strlen(newReferer));
+		if (tmp == NULL) {
+			errorSource = ERRNO;
+			return -1;
 		}
-	else
-		{
-		tmp = (char *)malloc(strlen(newReferer));
-		if(tmp == NULL) { errorSource = ERRNO; return -1; }
-		if(freeOldReferer) free(referer);
+		if (freeOldReferer) free(referer);
 		referer = tmp;
 		strcpy(referer, newReferer);
 		freeOldReferer = 1;
 		hideReferer = 0;
-		}
-	
+	}
+
 	return 0;
-	}
+}
 int http_setAuth(const char *user, const char *pass)
 {
 	unsigned char plain[1024];
@@ -380,26 +367,34 @@
 	char *b64;
 	int i,j,c,len,n;
 	char o=0;
-	 /* base64 encode user and pass */
-	if ((user==NULL) || (pass==NULL)) /* bad input or request to clean up */
-	{
+	/* base64 encode user and pass */
+	if ((user==NULL) || (pass==NULL)) { /* bad input or request to clean up */
 		if (auth!=NULL)	free(auth); /* free old auth */
 		auth=NULL;
 		return(-1);
 	}
-	
+
 	snprintf((char *)plain,1024,"%s:%s",user,pass);
 	len=strlen((char *)plain);
 	b64=malloc(len*4+1);
 	i=j=c=0;
-	while (i<len || c!=0)
-	{
-		switch (c)
-		{
-			case 0:	o=ec64[ n=plain[i] >> 2 ]; i++; break;
-			case 1: o=ec64[ n=((plain[i-1]&0x3)<<4) | (plain[i]>>4) ]; i++; break;
-			case 2: o=(i>=len)?'=':ec64[ n=((plain[i-1]&0xf)<<2) | (plain[i]>>6) ]; break;
-			case 3: o=(i>=len)?'=':ec64[ n=(plain[i]&0x3f) ];i++;break;
+	while (i<len || c!=0) {
+		switch (c) {
+		case 0:
+			o=ec64[ n=plain[i] >> 2 ];
+			i++;
+			break;
+		case 1:
+			o=ec64[ n=((plain[i-1]&0x3)<<4) | (plain[i]>>4) ];
+			i++;
+			break;
+		case 2:
+			o=(i>=len)?'=':ec64[ n=((plain[i-1]&0xf)<<2) | (plain[i]>>6) ];
+			break;
+		case 3:
+			o=(i>=len)?'=':ec64[ n=(plain[i]&0x3f) ];
+			i++;
+			break;
 		}
 		b64[j]=o;
 		c=(c+1)%4;
@@ -408,226 +403,233 @@
 	b64[j]=0;
 	if (auth!=NULL)	free(auth); /* free old auth */
 	auth=b64;
-	return(0);	
+	return(0);
 
-	
+
 }
 
 
 
 
-	/*
-	 * Changes the amount of time that HTTP Fetcher will wait for data
-	 *	before timing out on reads
-	 */
-void http_setTimeout(int seconds) { timeout = seconds; }
+/*
+ * Changes the amount of time that HTTP Fetcher will wait for data
+ *	before timing out on reads
+ */
+void http_setTimeout(int seconds)
+{
+	timeout = seconds;
+}
 
 
 
-	/*
-	 * Puts the filename portion of the url into 'filename'.
-	 * Returns:
-	 *	0 on success
-	 *	1 when url contains no end filename (i.e., 'www.foo.com/'),
-	 *		and **filename should not be assumed to be valid
-	 *	-1 on error
-	 */
+/*
+ * Puts the filename portion of the url into 'filename'.
+ * Returns:
+ *	0 on success
+ *	1 when url contains no end filename (i.e., 'www.foo.com/'),
+ *		and **filename should not be assumed to be valid
+ *	-1 on error
+ */
 int http_parseFilename(const char *url, char **filename)
-	{
+{
 	char *ptr;
 
-	if(url == NULL)
-		{
+	if (url == NULL) {
 		errorSource = FETCHER_ERROR;
 		http_errno = HF_NULLURL;
 		return -1;
-		}
+	}
 
 	ptr = (char *)rindex(url, '/');
-	if(ptr == NULL)
+	if (ptr == NULL)
 		/* Root level request, apparently */
 		return 1;
 
 	ptr++;
-	if(*ptr == '\0') return 1;
+	if (*ptr == '\0') return 1;
 
 	*filename = (char *)malloc(strlen(ptr));
-	if(*filename == NULL) { errorSource = ERRNO; return -1; }
+	if (*filename == NULL) {
+		errorSource = ERRNO;
+		return -1;
+	}
 	strcpy(*filename, ptr);
 
 	return 0;
-	}
+}
 
-	
-	
-	/* Depending on the source of error, calls either perror() or prints
-	 *	an HTTP Fetcher error message to stdout */
+
+
+/* Depending on the source of error, calls either perror() or prints
+ *	an HTTP Fetcher error message to stdout */
 void http_perror(const char *string)
-	{
-	if(errorSource == ERRNO)
+{
+	if (errorSource == ERRNO)
 		perror(string);
-	else if(errorSource == H_ERRNO)
+	else if (errorSource == H_ERRNO)
 		herror(string);
-	else if(errorSource == FETCHER_ERROR)
-		{
+	else if (errorSource == FETCHER_ERROR) {
 		char *stringIndex;
 
-		if(strstr(http_errlist[http_errno], "%d") == NULL)
-			{
+		if (strstr(http_errlist[http_errno], "%d") == NULL) {
 			fputs(string, stderr);
 			fputs(": ", stderr);
 			fputs(http_errlist[http_errno], stderr);
 			fputs("\n", stderr);
-			}
-		else
-			{
+		} else {
 			/* The error string has a %d in it, we need to insert errorInt */
 			stringIndex = (char *)http_errlist[http_errno];
-			while(*stringIndex != '%')			/* Print up to the %d */
-				{
+			while (*stringIndex != '%') {		/* Print up to the %d */
 				fputc(*stringIndex, stderr);
 				stringIndex++;
-				}
+			}
 			fprintf(stderr, "%d", errorInt);	/* Print the number */
 			stringIndex += 2;					/* Skip past the %d */
-			while(*stringIndex != 0)			/* Print up to the end NULL */
-				{
+			while (*stringIndex != 0) {		/* Print up to the end NULL */
 				fputc(*stringIndex, stderr);
 				stringIndex++;
-				}
+			}
 			fputs("\n", stderr);
-			}
 		}
 	}
+}
 
 
 
-	/* 
-	 * Returns a pointer to the current error description message. The
-	 *	message pointed to is only good until the next call to http_strerror(),
-	 *	so if you need to hold on to the message for a while you should make
-	 *	a copy of it
-	 */
+/*
+ * Returns a pointer to the current error description message. The
+ *	message pointed to is only good until the next call to http_strerror(),
+ *	so if you need to hold on to the message for a while you should make
+ *	a copy of it
+ */
 const char *http_strerror()
-	{
-	if(errorSource == ERRNO)
+{
+	if (errorSource == ERRNO)
 		return strerror(errno);
-	else if(errorSource == H_ERRNO)
+	else if (errorSource == H_ERRNO)
 		return hstrerror(h_errno);
-	else if(errorSource == FETCHER_ERROR)
-		{
-		if(strstr(http_errlist[http_errno], "%d") == NULL)
+	else if (errorSource == FETCHER_ERROR) {
+		if (strstr(http_errlist[http_errno], "%d") == NULL)
 			return http_errlist[http_errno];
-		else
-			{
+		else {
 			/* The error string has a %d in it, we need to insert errorInt.
 			 *	convertedError[128] has been declared for that purpose */
 			char *stringIndex, *originalError;
-		
+
 			originalError = (char *)http_errlist[http_errno];
 			convertedError[0] = 0;		/* Start off with NULL */
 			stringIndex = strstr(originalError, "%d");
 			strncat(convertedError, originalError,		/* Copy up to %d */
-				abs(stringIndex - originalError));
+			        abs(stringIndex - originalError));
 			sprintf(&convertedError[strlen(convertedError)],"%d",errorInt);
 			stringIndex += 2;		/* Skip past the %d */
 			strcat(convertedError, stringIndex);
 
 			return convertedError;
-			}
 		}
-		
-	return http_errlist[HF_METAERROR];	/* Should NEVER happen */
 	}
 
-	
-	/*
-	 * Reads the metadata of an HTTP response.
-	 * Perhaps a little inefficient, as it reads 1 byte at a time, but
-	 *	I don't think it's that much of a loss (most headers aren't HUGE).
-	 * Returns:
-	 *	# of bytes read on success, or
-	 *	-1 on error
-	 */
+	return http_errlist[HF_METAERROR];	/* Should NEVER happen */
+}
+
+
+/*
+ * Reads the metadata of an HTTP response.
+ * Perhaps a little inefficient, as it reads 1 byte at a time, but
+ *	I don't think it's that much of a loss (most headers aren't HUGE).
+ * Returns:
+ *	# of bytes read on success, or
+ *	-1 on error
+ */
 int _http_read_header(int sock, char *headerPtr)
-	{
+{
 	fd_set rfds;
 	struct timeval tv;
 	int bytesRead = 0, newlines = 0, ret, selectRet;
 
-	while(newlines != 2 && bytesRead != HEADER_BUF_SIZE)
-		{
+	while (newlines != 2 && bytesRead != HEADER_BUF_SIZE) {
 		FD_ZERO(&rfds);
 		FD_SET(sock, &rfds);
-		tv.tv_sec = timeout; 
+		tv.tv_sec = timeout;
 		tv.tv_usec = 0;
 
-		if(timeout >= 0)
+		if (timeout >= 0)
 			selectRet = select(sock+1, &rfds, NULL, NULL, &tv);
 		else		/* No timeout, can block indefinately */
 			selectRet = select(sock+1, &rfds, NULL, NULL, NULL);
-		
-		if(selectRet == 0 && timeout < 0)
-			{
+
+		if (selectRet == 0 && timeout < 0) {
 			errorSource = FETCHER_ERROR;
 			http_errno = HF_HEADTIMEOUT;
 			errorInt = timeout;
 			return -1;
-			}
-		else if(selectRet == -1) { errorSource = ERRNO; return -1; }
+		} else if (selectRet == -1) {
+			errorSource = ERRNO;
+			return -1;
+		}
 
 		ret = read(sock, headerPtr, 1);
-		if(ret == -1) { errorSource = ERRNO; return -1; }
+		if (ret == -1) {
+			errorSource = ERRNO;
+			return -1;
+		}
 		bytesRead++;
 
-		if(*headerPtr == '\r')			/* Ignore CR */
-			{
+		if (*headerPtr == '\r') {		/* Ignore CR */
 			/* Basically do nothing special, just don't set newlines
 			 *	to 0 */
 			headerPtr++;
 			continue;
-			}
-		else if(*headerPtr == '\n')		/* LF is the separator */
+		} else if (*headerPtr == '\n')		/* LF is the separator */
 			newlines++;
 		else
 			newlines = 0;
 
 		headerPtr++;
-		}
+	}
 
 	headerPtr -= 3;		/* Snip the trailing LF's */
 	*headerPtr = '\0';
 	return bytesRead;
-	}
+}
 
-	
-	
-	/*
-	 * Opens a TCP socket and returns the descriptor
-	 * Returns:
-	 *	socket descriptor, or
-	 *	-1 on error
-	 */
+
+
+/*
+ * Opens a TCP socket and returns the descriptor
+ * Returns:
+ *	socket descriptor, or
+ *	-1 on error
+ */
 int makeSocket(const char *host)
-	{
+{
 	int sock;										/* Socket descriptor */
 	struct sockaddr_in sa;							/* Socket address */
 	struct hostent *hp;								/* Host entity */
 	int ret;
-	
+
 	hp = gethostbyname(host);
-	if(hp == NULL) { errorSource = H_ERRNO; return -1; }
-		
+	if (hp == NULL) {
+		errorSource = H_ERRNO;
+		return -1;
+	}
+
 	/* Copy host address from hostent to (server) socket address */
 	memcpy((char *)&sa.sin_addr, (char *)hp->h_addr, hp->h_length);
 	sa.sin_family = hp->h_addrtype;		/* Set service sin_family to PF_INET */
 	sa.sin_port = htons(PORT_NUMBER);	/* Put portnum into sockaddr */
 
 	sock = socket(hp->h_addrtype, SOCK_STREAM, 0);
-	if(sock == -1) { errorSource = ERRNO; return -1; }
+	if (sock == -1) {
+		errorSource = ERRNO;
+		return -1;
+	}
 
 	ret = connect(sock, (struct sockaddr *)&sa, sizeof(sa));
-	if(ret == -1) { errorSource = ERRNO; return -1; }
+	if (ret == -1) {
+		errorSource = ERRNO;
+		return -1;
+	}
 
 	return sock;
-	}
+}

Modified: trunk/apps/s3dosm/http_fetcher.h
===================================================================
--- trunk/apps/s3dosm/http_fetcher.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/http_fetcher.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -15,10 +15,10 @@
 
 	See LICENSE file for details
 
-	Changes: 
+	Changes:
 		Simon Wunderlich <dotslash at packetmixer.de>
 		+ added http_setAuth() to support basic http-authentication and some minor fixes
-									
+
  */
 
 #ifndef HTTP_FETCHER_H
@@ -31,8 +31,8 @@
 #define DEFAULT_USER_AGENT		"HTTP Fetcher"
 #define	HTTP_FETCHER_VERSION	"1.0"
 #define DEFAULT_READ_TIMEOUT	30		/* Seconds to wait before giving up
-										 *	when no data is arriving */
-	 
+*	when no data is arriving */
+
 #define REQUEST_BUF_SIZE 		1024
 #define HEADER_BUF_SIZE 		1024
 #define DEFAULT_PAGE_BUF_SIZE 	1024 * 200	/* 200K should hold most things */
@@ -43,83 +43,83 @@
 /**************** Function declarations and descriptions **********************/
 /******************************************************************************/
 
-/* 
+/*
  * [!!! NOTE !!!]  All HTTP Fetcher functions return -1 on error.  You can
  *	then either call http_perror to print the error message or call
  *	http_strerror to get a pointer to it
  */
 
 
-	/*
-	 * Download the page, registering a hit. If you pass it a NULL for fileBuf,
-	 *	'url' will be requested but will not remain in memory (useful for
-	 *	simply registering a hit).  Otherwise necessary space will be allocated
-	 *	and will be pointed to by fileBuf.
-	 * Returns:
-	 *	# of bytes downloaded, or
-	 *	-1 on error
-	 */
+/*
+ * Download the page, registering a hit. If you pass it a NULL for fileBuf,
+ *	'url' will be requested but will not remain in memory (useful for
+ *	simply registering a hit).  Otherwise necessary space will be allocated
+ *	and will be pointed to by fileBuf.
+ * Returns:
+ *	# of bytes downloaded, or
+ *	-1 on error
+ */
 int http_fetch(const char *url, char **fileBuf);
 
-	/*
-	 * Changes the User Agent (shown to the web server with each request)
-	 *	Send it NULL to avoid telling the server a User Agent
-	 *	By default, the User Agent is sent (The default one unless changed)
-	 * Returns:
-	 *	0 on success, or
-	 *	-1 on error (previous value for agent remains unchanged)
-	 */
+/*
+ * Changes the User Agent (shown to the web server with each request)
+ *	Send it NULL to avoid telling the server a User Agent
+ *	By default, the User Agent is sent (The default one unless changed)
+ * Returns:
+ *	0 on success, or
+ *	-1 on error (previous value for agent remains unchanged)
+ */
 int http_setUserAgent(const char *newAgent);
 
-	/*
-	 * Changes the Referer (shown to the web server with each request)
-	 *	Send it NULL to avoid thelling the server a Referer
-	 *	By default, no Referer is sent
-	 * Returns:
-	 *	0 on success, or
-	 *	-1 on error
-	 */
+/*
+ * Changes the Referer (shown to the web server with each request)
+ *	Send it NULL to avoid thelling the server a Referer
+ *	By default, no Referer is sent
+ * Returns:
+ *	0 on success, or
+ *	-1 on error
+ */
 int http_setReferer(const char *newReferer);
 
-	/*
-	 * Changes the maximum amount of time that HTTP Fetcher will wait on
-	 *	data.  If this many seconds elapses without more data from the
-	 *	server, http_fetch will return with an error.
-	 * If you pass a value less than 0, reads will not time out, potentially
-	 *	waiting forever (or until data shows up, whichever comes first)
-	 */
+/*
+ * Changes the maximum amount of time that HTTP Fetcher will wait on
+ *	data.  If this many seconds elapses without more data from the
+ *	server, http_fetch will return with an error.
+ * If you pass a value less than 0, reads will not time out, potentially
+ *	waiting forever (or until data shows up, whichever comes first)
+ */
 void http_setTimeout(int seconds);
 
-	/*
-	 * Activate authentication for the Request. If user or pass is NULL,
-	 * http_set_Auth assumes a request to cleanup (disable Authentication). 
-	 * Returns 0 on success, and -1 on error or cleanup.
-	 */
+/*
+ * Activate authentication for the Request. If user or pass is NULL,
+ * http_set_Auth assumes a request to cleanup (disable Authentication).
+ * Returns 0 on success, and -1 on error or cleanup.
+ */
 
 int http_setAuth(const char *user, const char *pass);
 
-	/*
-	 * Takes a url and puts the filename portion of it into 'filename'.
-	 * Returns:
-	 *	0 on success, or
-	 *	1 when url contains no end filename (i.e., "www.foo.com/")
-	 *		and **filename should not be assumed to point to anything), or
-	 *	-1 on error
-	 */
+/*
+ * Takes a url and puts the filename portion of it into 'filename'.
+ * Returns:
+ *	0 on success, or
+ *	1 when url contains no end filename (i.e., "www.foo.com/")
+ *		and **filename should not be assumed to point to anything), or
+ *	-1 on error
+ */
 int http_parseFilename(const char *url, char **filename);
 
-	/*
-	 * Works like perror.  If an HTTP Fetcher function ever returns an
-	 *	error (-1), this will print a descriptive message to standard output
-	 */
+/*
+ * Works like perror.  If an HTTP Fetcher function ever returns an
+ *	error (-1), this will print a descriptive message to standard output
+ */
 void http_perror(const char *string);
 
-	/*
-	 * Returns a pointer to the current error description message.  The
-	 *	message pointed to is only good until the next call to http_strerror(),
-	 *	so if you need to hold on to the message for a while you should make
-	 *	a copy of it.
-	 */
+/*
+ * Returns a pointer to the current error description message.  The
+ *	message pointed to is only good until the next call to http_strerror(),
+ *	so if you need to hold on to the message for a while you should make
+ *	a copy of it.
+ */
 const char *http_strerror();
 
 
@@ -128,20 +128,20 @@
 /**** The following functions are used INTERNALLY by http_fetcher *************/
 /******************************************************************************/
 
-	/*
-	 * Reads the metadata of an HTTP response.  On success returns the number
-	 * Returns:
-	 *	# of bytes read on success, or
-	 *	-1 on error
-	 */
+/*
+ * Reads the metadata of an HTTP response.  On success returns the number
+ * Returns:
+ *	# of bytes read on success, or
+ *	-1 on error
+ */
 int _http_read_header(int sock, char *headerPtr);
 
-	/*
-	 * Opens a TCP socket and returns the descriptor
-	 * Returns:
-	 *	socket descriptor, or
-	 *	-1 on error
-	 */
+/*
+ * Opens a TCP socket and returns the descriptor
+ * Returns:
+ *	socket descriptor, or
+ *	-1 on error
+ */
 int makeSocket(const char *host);
 
 #endif

Modified: trunk/apps/s3dosm/io.c
===================================================================
--- trunk/apps/s3dosm/io.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/io.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * io.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -38,10 +38,19 @@
 	int filesize;
 	struct stat bf;
 
-	if ((fp = fopen(fname, "rt")) == NULL)	{ 	fprintf(stderr,"read_file( %s ):fopen(): %s",fname,strerror(errno)); 		return(NULL);	}
-	if (fstat(fileno(fp),&bf))				{ 	fprintf(stderr,"read_file( %s ):fopen(): %s",fname,strerror(errno));		return(NULL);	}
+	if ((fp = fopen(fname, "rt")) == NULL)	{
+		fprintf(stderr,"read_file( %s ):fopen(): %s",fname,strerror(errno));
+		return(NULL);
+	}
+	if (fstat(fileno(fp),&bf))				{
+		fprintf(stderr,"read_file( %s ):fopen(): %s",fname,strerror(errno));
+		return(NULL);
+	}
 	filesize=bf.st_size;
-	if ((buf=malloc(filesize))==NULL)		{	fprintf(stderr,"read_file( %s ):malloc(): %s",fname,strerror(errno));		return(NULL);	}
+	if ((buf=malloc(filesize))==NULL)		{
+		fprintf(stderr,"read_file( %s ):malloc(): %s",fname,strerror(errno));
+		return(NULL);
+	}
 	fread(buf, filesize, 1, fp);
 	fclose(fp);
 	if (fsize!=NULL) *fsize=filesize;
@@ -54,63 +63,55 @@
 	char				 c;
 	float				 minlat, minlon, maxlat, maxlon;
 	char 				 info[1024];
-	struct option long_options[] = 
-	{
-		{"help",0,0,'h'},
-		{"osm",1,0,'o'},
-		{0,0,0,0}
+	struct option long_options[] = {
+		{"help",0,0,'h'
+		}, {"osm",1,0,'o'}, {0,0,0,0}
 	};
 	optind=0;
 	opterr=0;
-	while (-1!=(c=getopt_long(argc,argv,"dH:?ho",long_options,&lopt_idx)))
-	{
-		switch (c)
-		{
-				case 0:break;
-				case 'o':
-					if (4==sscanf(optarg,"%f,%f,%f,%f",&minlat,&minlon,&maxlat,&maxlon))
-					   	layerset_add(load_osm_web(minlat,minlon,maxlat,maxlon));
-					else {
-						printf("%s: bad map bounding box",optarg);
-						return(-1);
-					}
-					break;
-				case 'h':
-				case '?':
-					printf("\nUSAGE: %s [options] [files]\n\n",argv[0]);
-					printf("options:\n");
-					printf("\t--osm, -o MINLAT,MINLON,MAXLAT,MAXLON:\n");
-					printf("\t\tload a map with the given bounding box\n\t\tfrom the openstreetmap server\n");
-					printf("\t--help, -?, -h: this helpful text\n\n");
-					printf("supported file types:\n");
-					printf("\t+ Kismet .xml Logs\n");
-					printf("\t+ Opemstreetmap .osm files\n\n");
-					s3d_usage();	/* add s3d usage */
-					return(-1);
-				default:
-					break;
+	while (-1!=(c=getopt_long(argc,argv,"dH:?ho",long_options,&lopt_idx))) {
+		switch (c) {
+		case 0:
+			break;
+		case 'o':
+			if (4==sscanf(optarg,"%f,%f,%f,%f",&minlat,&minlon,&maxlat,&maxlon))
+				layerset_add(load_osm_web(minlat,minlon,maxlat,maxlon));
+			else {
+				printf("%s: bad map bounding box",optarg);
+				return(-1);
+			}
+			break;
+		case 'h':
+		case '?':
+			printf("\nUSAGE: %s [options] [files]\n\n",argv[0]);
+			printf("options:\n");
+			printf("\t--osm, -o MINLAT,MINLON,MAXLAT,MAXLON:\n");
+			printf("\t\tload a map with the given bounding box\n\t\tfrom the openstreetmap server\n");
+			printf("\t--help, -?, -h: this helpful text\n\n");
+			printf("supported file types:\n");
+			printf("\t+ Kismet .xml Logs\n");
+			printf("\t+ Opemstreetmap .osm files\n\n");
+			s3d_usage();	/* add s3d usage */
+			return(-1);
+		default:
+			break;
 		}
 	}
-	for (i=1;i<argc;i++)
-	{
+	for (i=1;i<argc;i++) {
 		if (strstr(argv[i],".osm")-argv[i]==strlen(argv[i])-4) {
 			snprintf(info,1024,"loading OSM-File: %s",argv[i]);
 			load_window(info);
 			layerset_add(load_osm_file(argv[i]));
-		}
-		else if (strstr(argv[i],".xml")-argv[i]==strlen(argv[i])-4) /* might be osm or kismet xml */
-		{
+		} else if (strstr(argv[i],".xml")-argv[i]==strlen(argv[i])-4) { /* might be osm or kismet xml */
 			char *file;
 			int fsize;
-			if (NULL==(file=read_file(argv[i],&fsize)))				
+			if (NULL==(file=read_file(argv[i],&fsize)))
 				break;
-			if (NULL!=strstr(file,"<!DOCTYPE detection-run SYSTEM \"http://kismetwireless.net"))
-			{
+			if (NULL!=strstr(file,"<!DOCTYPE detection-run SYSTEM \"http://kismetwireless.net")) {
 				snprintf(info,1024,"loading Kismet-File: %s",argv[i]);
 				load_window(info);
 				layerset_add(parse_kismet(file,fsize));
-			}
-			else if (NULL!=strstr(file,"<osm ")) {
+			} else if (NULL!=strstr(file,"<osm ")) {
 				snprintf(info,1024,"loading OSM-File: %s",argv[i]);
 				load_window(info);
 				layerset_add(parse_osm(file,fsize));

Modified: trunk/apps/s3dosm/kismet.c
===================================================================
--- trunk/apps/s3dosm/kismet.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/kismet.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * kismet.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -40,12 +40,9 @@
 	node.base.layerid=layerid;
 	node.base.id=0;				/* let database decide */
 	node.visible=2;	/* something special */
-	for (kids=cur->children;kids;kids=kids->next)
-	{
-		if (0==strcmp((char *)kids->name,"gps-info"))
-		{
-			for (gpskids=kids->children;gpskids;gpskids=gpskids->next)
-			{
+	for (kids=cur->children;kids;kids=kids->next) {
+		if (0==strcmp((char *)kids->name,"gps-info")) {
+			for (gpskids=kids->children;gpskids;gpskids=gpskids->next) {
 				/* get median value */
 				if (0==strcmp((char *)gpskids->name,"min-lat")) 		node.lat=node.lat + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
 				if (0==strcmp((char *)gpskids->name,"max-lat")) 		node.lat=node.lat + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
@@ -61,15 +58,14 @@
 	{
 
 		db_insert_node(&node);
-		for (kids=cur->children;kids;kids=kids->next)
-		{
+		for (kids=cur->children;kids;kids=kids->next) {
 			if (0==strcmp((char *)kids->name,"SSID")) 			db_add_tag(OBJECT_T(&node),"wifi_SSID",(char *)xmlNodeGetContent(kids->children));
 			if (0==strcmp((char *)kids->name,"BSSID")) 			db_add_tag(OBJECT_T(&node),"wifi_BSSID",(char *)xmlNodeGetContent(kids->children));
 		}
-		for (attr=cur->properties;attr;attr=attr->next)
-		{
-	/*		if (0==strcmp((char *)attr->name,"number")) 		node->base.id=		strtol((char *)attr->children->content,NULL,10);
-			else */if (0==strcmp((char *)attr->name,"wep")) 	db_add_tag(OBJECT_T(&node),"wifi_wep",(char *)attr->children->content);
+		for (attr=cur->properties;attr;attr=attr->next) {
+			/*		if (0==strcmp((char *)attr->name,"number")) 		node->base.id=		strtol((char *)attr->children->content,NULL,10);
+					else */
+			if (0==strcmp((char *)attr->name,"wep")) 	db_add_tag(OBJECT_T(&node),"wifi_wep",(char *)attr->children->content);
 			else if (0==strcmp((char *)attr->name,"type")) 		db_add_tag(OBJECT_T(&node),"wifi_type",(char *)attr->children->content);
 		}
 
@@ -85,8 +81,8 @@
 	layer_t *layer=layer_new();
 	int i=0;
 	float n=0;
-	
 
+
 	doc = xmlReadMemory(buf, length, "noname.xml", NULL, 0);
 	if (doc == NULL) {
 		fprintf(stderr,"Document not parsed successfully.\n");
@@ -100,14 +96,11 @@
 	}
 	layerid=db_insert_layer("kismet");
 	for (c=cur->children;  c!=NULL;   c=c->next) 		n++; /* count */
-	for (cur=cur->children;cur!=NULL; cur=cur->next)
-	{
-		if (cur->type==XML_ELEMENT_NODE)
-		{
-			if (0==strcmp((char *)cur->name,"wireless-network"))
-			{
+	for (cur=cur->children;cur!=NULL; cur=cur->next) {
+		if (cur->type==XML_ELEMENT_NODE) {
+			if (0==strcmp((char *)cur->name,"wireless-network")) {
 				parse_kismet_node(cur);
-			} 
+			}
 		}
 		if ((i++)%10==0) load_update_status(100*((float)i)/n);
 

Modified: trunk/apps/s3dosm/main.c
===================================================================
--- trunk/apps/s3dosm/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * main.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -31,17 +31,19 @@
 
 void mainloop()
 {
-	struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+	struct timespec t= {
+		0,100*1000*1000
+	}; /* 100 mili seconds */
 	if (ready) {
-		nanosleep(&t,NULL); 
+		nanosleep(&t,NULL);
 		gps_main();
 		nav_main();
 		s3dw_ani_mate();
 	} /* else {
-		s3d_net_check(); / * we are not yet in the mainloop of 
-							s3d_mainloop(), because ready==0, 
+		s3d_net_check(); / * we are not yet in the mainloop of
+							s3d_mainloop(), because ready==0,
 							so we check protocol things ourselves.
-							This just prevents timing out from the server 
+							This just prevents timing out from the server
 							because map loading takes so long, you shouldn't take
 							this as good example and write proper threaded or
 							timesliced loaders :) * /
@@ -63,7 +65,7 @@
 	ready=1;
 	return(0);
 }
-int quit() 
+int quit()
 {
 	ready=0;
 	gps_quit();
@@ -73,8 +75,7 @@
 }
 int main(int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"s3dosm"))
-	{
+	if (!s3d_init(&argc,&argv,"s3dosm")) {
 		if (!init(argc, argv)) s3d_mainloop(mainloop);
 		quit();
 	} else return(-1);

Modified: trunk/apps/s3dosm/nav.c
===================================================================
--- trunk/apps/s3dosm/nav.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/nav.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -28,16 +28,16 @@
 
 	float tmp1[3],tmp2[3];
 	float alpha;
-	
+
 	tmp1[0]=campos[0];
 	tmp1[1]=campos[1] + ESIZE*RESCALE +VIEWHEIGHT;
 	tmp1[2]=campos[2];
-	
+
 	alpha= (90-lat) *M_PI/180.0;
 	tmp2[0]=  tmp1[0];
 	tmp2[1]=  tmp1[1]*cos(alpha) - tmp1[2] * sin (alpha);
 	tmp2[2]=  tmp1[1]*sin(alpha) + tmp1[2] * cos (alpha);
-	
+
 	alpha= lon *M_PI/180.0;
 	tmp1[0]=  tmp2[0]*cos(alpha) + tmp2[2] * sin (alpha);
 	tmp1[1]=  tmp2[1];
@@ -53,17 +53,18 @@
 void nav_main()
 {
 	float x[3];
-	if ((fabs(tlat-lat)>0.00001) && (fabs(tlon-lon)>0.00001))
-	{
-		if (lat==0.0 && lon==0.0)
-		{
+	if ((fabs(tlat-lat)>0.00001) && (fabs(tlon-lon)>0.00001)) {
+		if (lat==0.0 && lon==0.0) {
 			lat=tlat;
 			lon=tlon;
 		} else {
 			lat=(tlat+lat*15)/16;
 			lon=(tlon+lon*15)/16;
 		}
-	} else { lat=tlat;lon=tlon;}
+	} else {
+		lat=tlat;
+		lon=tlon;
+	}
 	s3d_rotate(oidy,0,-lon,0);
 	s3d_rotate(oidx,-(90-lat),0,0);
 	calc_earth_to_eukl(lon,lat,0,x);
@@ -75,7 +76,7 @@
 	int i;
 	med[0]=0;
 	med[1]=0;
-	for(i=0; i<argc; i++){
+	for (i=0; i<argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],"la"))			med[0]=strtod(argv[i],NULL);
 			else if (0==strcmp(azColName[i],"lo"))		med[1]=strtod(argv[i],NULL);
@@ -84,7 +85,8 @@
 	return(0);
 }
 /* returns the heading in degress of position P1 -> P2 */
-float get_heading(float la1, float lo1, float la2, float lo2) {
+float get_heading(float la1, float lo1, float la2, float lo2)
+{
 	float p1_north[3], p1[3], p2[3];
 	float dir[3],north[3];
 	float angle;

Modified: trunk/apps/s3dosm/object.c
===================================================================
--- trunk/apps/s3dosm/object.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/object.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * object.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -112,7 +112,7 @@
 }
 void way_free(way_t *way)
 {
-	if (way->seg_n>0) 
+	if (way->seg_n>0)
 		free(way->seg_p);
 	free(way);
 }

Modified: trunk/apps/s3dosm/osm.c
===================================================================
--- trunk/apps/s3dosm/osm.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/osm.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * osm.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -34,11 +34,9 @@
 	xmlAttrPtr attr;
 	char *v,*k;
 	v=k=NULL;
-	for (c=cur->children;c!=NULL; c=c->next)
-	{
+	for (c=cur->children;c!=NULL; c=c->next) {
 		if (0==strcmp((char *)c->name,"tag"))	{
-			for (attr=c->properties;attr;attr=attr->next)
-			{
+			for (attr=c->properties;attr;attr=attr->next) {
 				if (0==strcmp((char *)attr->name,"k")) 				k=(char *)attr->children->content;
 				else if (0==strcmp((char *)attr->name,"v")) 		v=(char *)attr->children->content;
 			}
@@ -57,14 +55,13 @@
 	int seg;
 
 	way_init(&way);
-	
+
 	way.base.layerid=layerid;
 	for (attr=cur->properties;attr;attr=attr->next)
 		if (0==strcmp((char *)attr->name,"id")) 			way.base.id=	strtol((char *)attr->children->content,NULL,10);
 	db_insert_way_only(&way);
 	parse_osm_tags(OBJECT_T(&way),cur);
-	for (kids=cur->children;kids!=NULL;kids=kids->next)
-	{
+	for (kids=cur->children;kids!=NULL;kids=kids->next) {
 		if (0==strcmp((char *)kids->name,"seg"))	{
 			seg=-1;
 			for (kattr=kids->properties;kattr;kattr=kattr->next)
@@ -79,11 +76,10 @@
 	xmlAttrPtr attr;
 
 	segment_init(&segment);
-	
+
 	segment.base.layerid=layerid;
-	for (attr=cur->properties;attr;attr=attr->next)
-	{
-		
+	for (attr=cur->properties;attr;attr=attr->next) {
+
 		if (0==strcmp((char *)attr->name,"id")) 			segment.base.id=	strtol((char *)attr->children->content,NULL,10);
 		else if (0==strcmp((char *)attr->name,"from")) 		segment.from=		strtod((char *)attr->children->content,NULL);
 		else if (0==strcmp((char *)attr->name,"to")) 		segment.to=			strtod((char *)attr->children->content,NULL);
@@ -100,10 +96,9 @@
 
 	node_init(&node);
 	attr=cur->properties;
-	
+
 	node.base.layerid=layerid;
-	for (attr=cur->properties;attr;attr=attr->next)
-	{
+	for (attr=cur->properties;attr;attr=attr->next) {
 		if (0==strcmp((char *)attr->name,"id")) 			node.base.id=		strtol((char *)attr->children->content,NULL,10);
 		else if (0==strcmp((char *)attr->name,"lat")) 		node.lat=			strtod((char *)attr->children->content,NULL);
 		else if (0==strcmp((char *)attr->name,"lon")) 		node.lon=			strtod((char *)attr->children->content,NULL);
@@ -124,8 +119,8 @@
 	object_t *obj;
 	float n=0;
 	int i=0;
-	
 
+
 	doc = xmlReadMemory(buf, length, "noname.xml", NULL, 0);
 	if (doc == NULL) {
 		fprintf(stderr,"Document not parsed successfully.\n");
@@ -139,10 +134,8 @@
 	}
 	layerid=db_insert_layer("osm");
 	for (c=cur->children;  c!=NULL;   c=c->next) 		n++; /* count */
-	for (cur=cur->children;cur!=NULL; cur=cur->next)
-	{
-		if (cur->type==XML_ELEMENT_NODE)
-		{
+	for (cur=cur->children;cur!=NULL; cur=cur->next) {
+		if (cur->type==XML_ELEMENT_NODE) {
 			obj=NULL;
 			if (0==strcmp((char *)cur->name,"node"))				parse_osm_node(cur);
 			else if (0==strcmp((char *)cur->name,"segment"))		parse_osm_segment(cur);
@@ -168,9 +161,8 @@
 
 	http_setAuth(user,pass);
 	ret = http_fetch(url, &fileBuf);	/* Downloads page */
-	if(ret == -1)
-	{	
-		http_perror("http_fetch");	
+	if (ret == -1) {
+		http_perror("http_fetch");
 		return(NULL);
 	}
 	layer=parse_osm(fileBuf, ret);

Modified: trunk/apps/s3dosm/s3dosm.h
===================================================================
--- trunk/apps/s3dosm/s3dosm.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/s3dosm.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -4,7 +4,7 @@
 #define	ESIZE	637800		/* earth size */
 #define	RESCALE	1
 #define VIEWHEIGHT 3
-#define MAXQ	4096	
+#define MAXQ	4096
 #define QBUF	1024*128
 
 /* stack it */
@@ -95,7 +95,7 @@
 	float 		 alt;		/* altitude */
 	char 		 visible;	/* node visible? 0 = no, 1 = yes, 2 = some sepcial object */
 	int 		 vid;		/* vertex id */
-/*	time_t time;*/
+	/*	time_t time;*/
 	int 		 adj_n;		/* adjacence list */
 	adj_t 		*adj_p;
 };

Modified: trunk/apps/s3dosm/structs.h
===================================================================
--- trunk/apps/s3dosm/structs.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/structs.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -28,8 +28,7 @@
 #define MAXDATASIZE 100			/* max number of bytes we can get at once  */
 
 /* linked list for the all connections */
-struct olsr_con 
-{
+struct olsr_con {
 	struct olsr_con *next_olsr_con;			/* pointer to next connection */
 	struct olsr_con *prev_olsr_con;			/* pointer to previous connection */
 	struct olsr_node *left_olsr_node;		/* pointer to left end point of the connection */
@@ -45,16 +44,14 @@
 
 
 /* linked list for the neighbours of each olsr node */
-struct olsr_neigh_list
-{
+struct olsr_neigh_list {
 	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
 	struct olsr_con *olsr_con;							/* pointer to the connection */
 };
 
 
 /* we contruct a binary tree to handle the nodes */
-struct olsr_node 
-{
+struct olsr_node {
 	struct olsr_node *left;
 	struct olsr_node *right;
 	char ip[NAMEMAX];				/* host ip */
@@ -72,8 +69,7 @@
 };
 
 
-struct Obj_to_ip
-{
+struct Obj_to_ip {
 	int id;
 	struct olsr_node *olsr_node;
 	struct Obj_to_ip *next;

Modified: trunk/apps/s3dosm/tag.c
===================================================================
--- trunk/apps/s3dosm/tag.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/tag.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * tag.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -29,8 +29,7 @@
 	tag_t *t;
 	obj->tag_n++;
 	obj->tag_p=realloc(obj->tag_p,obj->tag_n*sizeof(tag_t));
-	if (k!=NULL && v!=NULL)
-	{
+	if (k!=NULL && v!=NULL) {
 		t=&(obj->tag_p[obj->tag_n-1]);
 		t->ttype=TAG_UNKNOWN;
 		t->k=strdup(k);
@@ -42,8 +41,7 @@
 tag_t *tag_get(object_t *obj, char *k)
 {
 	int i;
-	for (i=0;i<obj->tag_n;i++)
-	{
+	for (i=0;i<obj->tag_n;i++) {
 		if (0==strcmp(obj->tag_p[i].k,k)) return(&(obj->tag_p[i]));
 	}
 	return(NULL);

Modified: trunk/apps/s3dosm/ui.c
===================================================================
--- trunk/apps/s3dosm/ui.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dosm/ui.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * ui.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dosm, a gps card application for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dosm is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dosm is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dosm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -28,11 +28,11 @@
 #include <string.h> /* strcmp */
 #include <stdlib.h> /* atoi() */
 icon_t icons[ICON_NUM]={
-		{"objs/accesspoint.3ds",0},
-		{"objs/noinetwep.3ds",0},
-		{"objs/noinetwpa.3ds",0},
-		{"objs/arrow2.3ds",0}
-	};
+	{"objs/accesspoint.3ds",0},
+	{"objs/noinetwep.3ds",0},
+	{"objs/noinetwpa.3ds",0},
+	{"objs/arrow2.3ds",0}
+};
 
 /* load icons, we want to clone each of them later */
 void ui_loadicons()
@@ -51,7 +51,8 @@
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 }
 
-int ui_getinfo_node(void *data, int argc, char **argv, char **azColName) {
+int ui_getinfo_node(void *data, int argc, char **argv, char **azColName)
+{
 	int i,tagid=-1;
 	char type[MAXQ];
 	char name[MAXQ];
@@ -59,14 +60,14 @@
 	s3dw_surface *miniwin;
 	s3dw_button  *button;
 
-	for(i=0; i<argc; i++) {
+	for (i=0; i<argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],"tag_id")) 			tagid=atoi(argv[i]);
 		}
 	}
 	if (db_gettag(tagid, "amenity",type)) type[0]=0;
 	if (db_gettag(tagid, "name",name)) name[0]=0;
-	
+
 	miniwin=s3dw_surface_new("About node",30,6);
 	snprintf(string,128,"name: %s",name);
 	s3dw_label_new(miniwin,string,1,2);
@@ -78,14 +79,15 @@
 
 	return(0);
 }
-int ui_getinfo_way(void *data, int argc, char **argv, char **azColName) {
+int ui_getinfo_way(void *data, int argc, char **argv, char **azColName)
+{
 	int i,tagid=-1;
 	char name[MAXQ];
 	char string[128];
 	s3dw_surface *miniwin;
 	s3dw_button  *button;
 
-	for(i=0; i<argc; i++) {
+	for (i=0; i<argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],"tag_id")) 			tagid=atoi(argv[i]);
 		}
@@ -117,13 +119,13 @@
 }
 int ui_key(struct s3d_evt *evt)
 {
-/*	struct s3d_key_event *key=(struct s3d_key_event *)evt->buf;*/
+	/*	struct s3d_key_event *key=(struct s3d_key_event *)evt->buf;*/
 	if (s3dw_handle_key(evt)) return(0);
 	return(0);
 }
 int ui_oinfo(struct s3d_evt *evt)
 {
-	s3dw_object_info(evt);	
+	s3dw_object_info(evt);
 	return(0);
 }
 int ui_init()
@@ -138,8 +140,7 @@
 /* initialize the loadwindow or change its caption text */
 int load_window(char *text)
 {
-	if (loadwindow==NULL) /* create it */
-	{
+	if (loadwindow==NULL) { /* create it */
 		loadwindow=s3dw_surface_new("Now loading ...",20,5);
 		loadlabel=s3dw_label_new(loadwindow,text,1,2);
 		loadstatus=s3dw_label_new(loadwindow,"",1,3);

Modified: trunk/apps/s3dvt/main.c
===================================================================
--- trunk/apps/s3dvt/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dvt/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,22 +1,22 @@
 /*
  * main.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  * Copyright (C) 2002 Alexander Graf <helly at gmx.net>
  *
  * This file is part of s3dvt, a 3d terminal emulator for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dvt is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dvt is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dvt; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,7 +35,9 @@
 #include <s3d.h>		 /*  s3d_* */
 #include <s3d_keysym.h>	 /*  key symbols */
 #include <time.h>	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
 
 
 static int pid;
@@ -67,181 +69,171 @@
 {
 	int iscon=1,ret;
 	char buffer[1024];
-	while(iscon) 
-	{
-		switch (term_mode)
-		{
-			case M_PIPE:
-				ret=read(mpipe_out[0], &buffer, 1000);
-				break;
-			case M_PTY:
-				ret=read(curpty, &buffer, 1000);
-				break;
-			default:
-				ret=-1;
+	while (iscon) {
+		switch (term_mode) {
+		case M_PIPE:
+			ret=read(mpipe_out[0], &buffer, 1000);
+			break;
+		case M_PTY:
+			ret=read(curpty, &buffer, 1000);
+			break;
+		default:
+			ret=-1;
 		}
-		if(ret>0) 
-		{ 
+		if (ret>0) {
 			buffer[ret]='\0';
 			printf("<<<new data(%d bytes)\n", ret);
 			AddChar(buffer);
 		} else {
-			if (ret==-1)
-			{
+			if (ret==-1) {
 				perror("read()");
-				printf("Connection to pty lost (ret=%d)\n",ret); 
+				printf("Connection to pty lost (ret=%d)\n",ret);
 				close(mpipe_in[0]);
 				close(mpipe_out[1]);
-		/* 		close(curpty);  */
-		/* 		close(curtty);  */
+				/* 		close(curpty);  */
+				/* 		close(curtty);  */
 				printf("********CONNECTION TO PTY LOST!*******\n");
 				sleep(1);
 				s3d_quit();
 				exit(0);
 			}
 		}
-    }
+	}
 	return(NULL); /* huh?! */
 }
 int pty_init_terminal()
 {
-    int i;
-    char buf[256];
-    char tmpstr[1024];
-    int curtty;
-    int uid=0,gid=0;
-    char exe[]="/bin/bash";
-    char curchar;
-    char *disp;
-    
-    disp=getenv("DISPLAY");
-    uid=getuid();
-    gid=getgid();
+	int i;
+	char buf[256];
+	char tmpstr[1024];
+	int curtty;
+	int uid=0,gid=0;
+	char exe[]="/bin/bash";
+	char curchar;
+	char *disp;
+
+	disp=getenv("DISPLAY");
+	uid=getuid();
+	gid=getgid();
 	term_mode=M_PTY;
-    for(curchar='p'; curchar<'z';curchar++) 
-	{
-		for(i=0;i < 16;i++) 
-		{
+	for (curchar='p'; curchar<'z';curchar++) {
+		for (i=0;i < 16;i++) {
 			sprintf(buf, "/dev/pty%c%x", curchar, i);
 			curpty=open(buf, O_RDWR);
-			if (curpty >= 0) 
+			if (curpty >= 0)
 				goto endloop;
 		}
-    }
+	}
 endloop:
-    if(curpty < 0) {
-		printf("Error opening pty\n"); 
-		return 0; 
+	if (curpty < 0) {
+		printf("Error opening pty\n");
+		return 0;
 	}
-/* 	fnctl(F_SETFL,O_NONBLOCK); */
+	/* 	fnctl(F_SETFL,O_NONBLOCK); */
 	signal(SIGCHLD, SIG_IGN);
-    pid = fork();
-	if(!pid) 
-	{
-	    buf[5]='t';
-	    curtty=open(buf, O_RDWR);
-	    if (curtty < 0) { 
-			printf("Error opening tty\n"); 
-			return 0; 
+	pid = fork();
+	if (!pid) {
+		buf[5]='t';
+		curtty=open(buf, O_RDWR);
+		if (curtty < 0) {
+			printf("Error opening tty\n");
+			return 0;
 		}
-	    setuid(uid);
-	    setgid(gid);
-	    if(setsid()<0) 
-			printf("ERROR (setsid)\n"); 
-	/*     tcflush(curpty, TCIOFLUSH); */
-	    if(ioctl(curtty, TIOCSCTTY, NULL)) 
+		setuid(uid);
+		setgid(gid);
+		if (setsid()<0)
+			printf("ERROR (setsid)\n");
+		/*     tcflush(curpty, TCIOFLUSH); */
+		if (ioctl(curtty, TIOCSCTTY, NULL))
 			printf("ERROR! (ttyflush)\n");;
-	    dup2(curtty, 0);
-	    dup2(curtty, 1);
-	    dup2(curtty, 2);
-	    sprintf(tmpstr, "%d", MAX_LINES-1);
-	    setenv("LINES", tmpstr, 1);
-	    sprintf(tmpstr, "%d", MAX_CHARS-1);
-	    setenv("COLUMNS", tmpstr, 1);
-	    setenv("TERM", "rxvt", 1);
-	    execl(exe, exe, NULL);
+		dup2(curtty, 0);
+		dup2(curtty, 1);
+		dup2(curtty, 2);
+		sprintf(tmpstr, "%d", MAX_LINES-1);
+		setenv("LINES", tmpstr, 1);
+		sprintf(tmpstr, "%d", MAX_CHARS-1);
+		setenv("COLUMNS", tmpstr, 1);
+		setenv("TERM", "rxvt", 1);
+		execl(exe, exe, NULL);
 		sleep(1);
 		printf("that's it, exiting");
 		close(curtty);
 		exit(0);
-	} else if(pid<0) {
+	} else if (pid<0) {
 		printf("Cant fork()\n");
 		exit(0);
 	} else {
-    	pthread_create(&term_thread, NULL, thread_terminal, NULL);
+		pthread_create(&term_thread, NULL, thread_terminal, NULL);
 	}
-    return 1;
+	return 1;
 }
 /*  terminal.c */
 void term_addchar(char toprint)
 {
-/*    printf("sending: %.3d\n", toprint);*/
-	switch (term_mode)
-	{
-		case M_PIPE:
-			write(mpipe_in[1],&toprint,1);
-			write(mpipe_out[1],&toprint,1);
-			break;
-		case M_PTY:
-			write(curpty, &toprint, 1);
-			break;
+	/*    printf("sending: %.3d\n", toprint);*/
+	switch (term_mode) {
+	case M_PIPE:
+		write(mpipe_in[1],&toprint,1);
+		write(mpipe_out[1],&toprint,1);
+		break;
+	case M_PTY:
+		write(curpty, &toprint, 1);
+		break;
 	}
 }
 
 
 int pipe_init_terminal()
 {
-    char buf[256];
-    int uid=0,gid=0;
-    char *exe="/bin/bash";
-    char *args="-i";
-    char *disp;
+	char buf[256];
+	int uid=0,gid=0;
+	char *exe="/bin/bash";
+	char *args="-i";
+	char *disp;
 
 	term_mode=M_PIPE;
-	if ((pipe(mpipe_in)==-1) || (pipe(mpipe_out)==-1))
-	{
+	if ((pipe(mpipe_in)==-1) || (pipe(mpipe_out)==-1)) {
 		printf("pipe failed\n");
 		return(-1);
 	}
-    disp=getenv("DISPLAY");
-    uid=getuid();
-    gid=getgid();
-    pid = fork();
-	if(pid==0) 
-	{  /*  the child */
-	    char tmpstr[1024];
-	    buf[5]='t';
-	    setuid(uid);
-	    setgid(gid);
-	    if(setsid()<0) 
-			printf("ERROR (setsid)\n"); 
-/*     tcflush(curpty, TCIOFLUSH); */
-/*     if(ioctl(curtty, TIOCSCTTY, NULL)) printf("ERROR! (ttyflush)\n");; */
+	disp=getenv("DISPLAY");
+	uid=getuid();
+	gid=getgid();
+	pid = fork();
+	if (pid==0) { /*  the child */
+		char tmpstr[1024];
+		buf[5]='t';
+		setuid(uid);
+		setgid(gid);
+		if (setsid()<0)
+			printf("ERROR (setsid)\n");
+		/*     tcflush(curpty, TCIOFLUSH); */
+		/*     if(ioctl(curtty, TIOCSCTTY, NULL)) printf("ERROR! (ttyflush)\n");; */
 		setvbuf(stdout,(char*)NULL,_IONBF,0);
-	    dup2(mpipe_in[0], fileno(stdin));
-	    dup2(mpipe_out[1], fileno(stdout));
-	    dup2(mpipe_out[1], fileno(stderr));
-		 /*  close unneded things: */
-		close(mpipe_out[0]); 
-		close(mpipe_in[1]); 
-	    sprintf(tmpstr, "%d", MAX_LINES-1);
-	    setenv("LINES", tmpstr, 1);
-	    sprintf(tmpstr, "%d", MAX_CHARS-1);
-	    setenv("COLUMNS", tmpstr, 1);
-	    setenv("TERM", "rxvt", 1);
-	    execl(exe, exe, args,NULL);
+		dup2(mpipe_in[0], fileno(stdin));
+		dup2(mpipe_out[1], fileno(stdout));
+		dup2(mpipe_out[1], fileno(stderr));
+		/*  close unneded things: */
+		close(mpipe_out[0]);
+		close(mpipe_in[1]);
+		sprintf(tmpstr, "%d", MAX_LINES-1);
+		setenv("LINES", tmpstr, 1);
+		sprintf(tmpstr, "%d", MAX_CHARS-1);
+		setenv("COLUMNS", tmpstr, 1);
+		setenv("TERM", "rxvt", 1);
+		execl(exe, exe, args,NULL);
 		printf("that's it, exiting");
 		close(curtty);
 		exit(0);
-   } else if(pid<0) {
-    printf("Cant fork()\n");
-	exit(0);
-   } else {
-	 /*  close unneded things... */
+	} else if (pid<0) {
+		printf("Cant fork()\n");
+		exit(0);
+	} else {
+		/*  close unneded things... */
 		close(mpipe_in[0]);
-	    pthread_create(&term_thread, NULL, thread_terminal, NULL);
-   }
-    return 1;
+		pthread_create(&term_thread, NULL, thread_terminal, NULL);
+	}
+	return 1;
 }
 int init_terminal()
 {
@@ -254,19 +246,18 @@
 void term_unload()
 {
 	printf("unloading tty!!\n");
-	switch (term_mode)
-	{
-		case M_PTY:
-			write(curpty, '\0', 1);  /*  send an EOF, just in case */
-		    close(curpty);
-		    close(curtty);
-			 /* kill(pid); */
-			break;
-		case M_PIPE:
-			 /*  bash should fade with "broken pipe" */
-			close(mpipe_in[1]);
-			close(mpipe_out[0]);
-			break;
+	switch (term_mode) {
+	case M_PTY:
+		write(curpty, '\0', 1);  /*  send an EOF, just in case */
+		close(curpty);
+		close(curtty);
+		/* kill(pid); */
+		break;
+	case M_PIPE:
+		/*  bash should fade with "broken pipe" */
+		close(mpipe_in[1]);
+		close(mpipe_out[0]);
+		break;
 	}
 }
 #ifdef M_CHAR
@@ -280,39 +271,34 @@
 
 	s3d_translate(	cursor,cx*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cy*CS + CS*MAX_LINES/2,0);
 	s3d_scale(		cursor,CS);
-	for(cline=0;cline<MAX_LINES;cline++)
-	{
+	for (cline=0;cline<MAX_LINES;cline++) {
 		line_end=0;
-		for (c=0;c<MAX_CHARS;c++)
-		{
+		for (c=0;c<MAX_CHARS;c++) {
 			i=cline*MAX_CHARS+c;			 /*  calculate position */
-			if (((ch=line[cline].chars[c].character)!=(och=last_c[i])))
-			{
-				if (screenbuf[i]==-1)
-				{
+			if (((ch=line[cline].chars[c].character)!=(och=last_c[i]))) {
+				if (screenbuf[i]==-1) {
 					screenbuf[i]=s3d_new_object();
 					s3d_translate(screenbuf[i],c*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cline*CS + CS*MAX_LINES/2,0);
 					s3d_scale(screenbuf[i],CS);
 					s3d_flags_on(screenbuf[i],S3D_OF_VISIBLE);
 				}
-				if ((ch==0) || (line_end))
-				{	/*  the new character is zero! delete! */
+				if ((ch==0) || (line_end)) {	/*  the new character is zero! delete! */
 					line[cline].chars[c].character=0;
 					ci=charbuf[' '];
 					s3d_clone_target(screenbuf[i],ci);
 					line_end=1;
-/* 					printf("-%03d",ch); */
+					/* 					printf("-%03d",ch); */
 				} else {
 					ci=charbuf[ch];
-/* 					printf("!%03d",ch); */
+					/* 					printf("!%03d",ch); */
 					s3d_clone_target(screenbuf[i],ci);
 				}
 			} else {
-/* 				printf("=%03d",ch); */
-			} 
-			last_c[i]=ch;			
+				/* 				printf("=%03d",ch); */
+			}
+			last_c[i]=ch;
 		}
-/* 		printf("\n"); */
+		/* 		printf("\n"); */
 	}
 	gotnewdata=0;
 }
@@ -325,47 +311,40 @@
 	int len;
 	int changed;
 	char cl[MAX_CHARS];
-	for(cline=0;cline<MAX_LINES;cline++)
-	{
+	for (cline=0;cline<MAX_LINES;cline++) {
 		len=MAX_CHARS;
 		changed=0;
-		for (c=MAX_CHARS;c>=0;c--)
-		{
+		for (c=MAX_CHARS;c>=0;c--) {
 			cl[c]=line[cline].chars[c].character;
-			if (line[cline].chars[c].character!=line[cline].chars[c].last_c)
-			{
+			if (line[cline].chars[c].character!=line[cline].chars[c].last_c) {
 				changed=c+1;
-/*				printf("changed [%d/%d] from %d to %d\n",cline,c,
-								line[cline].chars[c].last_c,
-								line[cline].chars[c].character
-								);*/
+				/*				printf("changed [%d/%d] from %d to %d\n",cline,c,
+												line[cline].chars[c].last_c,
+												line[cline].chars[c].character
+												);*/
 				line[cline].chars[c].last_c=line[cline].chars[c].character;
 			}
 			if (cl[c]==0) len=c;
 		}
-		if (changed)
-		{
-		if (len>0)
-		{
-			printf("[p: line %d [len: %d/changed: %d]\n",cline,len,changed);
-			oid=s3d_draw_string(cl,NULL);
-			s3d_translate(oid,0,-cline,0);
-			if (lines[cline]!=-1) 
-			{
-				s3d_del_object(lines[cline]);
-				lines[cline]=-1;
+		if (changed) {
+			if (len>0) {
+				printf("[p: line %d [len: %d/changed: %d]\n",cline,len,changed);
+				oid=s3d_draw_string(cl,NULL);
+				s3d_translate(oid,0,-cline,0);
+				if (lines[cline]!=-1) {
+					s3d_del_object(lines[cline]);
+					lines[cline]=-1;
+				}
+				s3d_flags_on(oid,S3D_OF_VISIBLE);
+				lines[cline]=oid;
+			} else {
+				if (lines[cline]!=-1) {
+					s3d_del_object(lines[cline]);
+					lines[cline]=-1;
+				}
 			}
-			s3d_flags_on(oid,S3D_OF_VISIBLE);
-			lines[cline]=oid;
-		} else {
-			if (lines[cline]!=-1)
-			{
-				s3d_del_object(lines[cline]);
-				lines[cline]=-1;
-			}
 		}
-		}
-		
+
 	}
 	gotnewdata=0;
 }
@@ -392,98 +371,97 @@
 				screenbuf[MAX_LINES*MAX_CHARS]=oid;
 			 }
 	    }
-/ * 		printf("\n"); * / 
+/ * 		printf("\n"); * /
 	}
 }*/
 int keypress(struct s3d_evt *event)
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
 	int key;
-/*	printf("received key: %d\n",key);*/
-	switch (key=keys->keysym)
-	{
-		case S3DK_F1:
-		case S3DK_F2:
-		case S3DK_F3:
-		case S3DK_F4:
-		case S3DK_F5:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('1');
-			term_addchar(key-S3DK_F1+'1');
-			break;
-		case S3DK_F6:
-		case S3DK_F7:
-		case S3DK_F8:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('1');
-			term_addchar((key-S3DK_F6)+'7');
-			break;
-		case S3DK_F9:
-		case S3DK_F10:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('2');
-			term_addchar((key-S3DK_F9)+'0');
-			break;
-		case S3DK_F11:
-		case S3DK_F12:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('2');
-			term_addchar((key-S3DK_F11)+'3');
-			break;
-		case S3DK_UP:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('A');
-			break;
-		case S3DK_DOWN:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('B');
-			break;
-		case S3DK_RIGHT:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('C');
-			break;
-		case S3DK_LEFT:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('D');
-			break;
-		case S3DK_PAGEUP:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('5');
-			term_addchar('~');
-			break;
-		case S3DK_PAGEDOWN:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('6');
-			term_addchar('~');
-			break;
-		case S3DK_HOME:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('7');
-			term_addchar('~');
-			break;
-		case S3DK_END:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('8');
-			term_addchar('~');
-			break;
-		case 13:
-			term_addchar(10);
-			break;
-		default:
-			if ((char)keys->unicode)  /*  \0 is no good idea .. */
-				term_addchar((char)keys->unicode);
+	/*	printf("received key: %d\n",key);*/
+	switch (key=keys->keysym) {
+	case S3DK_F1:
+	case S3DK_F2:
+	case S3DK_F3:
+	case S3DK_F4:
+	case S3DK_F5:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('1');
+		term_addchar(key-S3DK_F1+'1');
+		break;
+	case S3DK_F6:
+	case S3DK_F7:
+	case S3DK_F8:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('1');
+		term_addchar((key-S3DK_F6)+'7');
+		break;
+	case S3DK_F9:
+	case S3DK_F10:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('2');
+		term_addchar((key-S3DK_F9)+'0');
+		break;
+	case S3DK_F11:
+	case S3DK_F12:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('2');
+		term_addchar((key-S3DK_F11)+'3');
+		break;
+	case S3DK_UP:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('A');
+		break;
+	case S3DK_DOWN:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('B');
+		break;
+	case S3DK_RIGHT:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('C');
+		break;
+	case S3DK_LEFT:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('D');
+		break;
+	case S3DK_PAGEUP:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('5');
+		term_addchar('~');
+		break;
+	case S3DK_PAGEDOWN:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('6');
+		term_addchar('~');
+		break;
+	case S3DK_HOME:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('7');
+		term_addchar('~');
+		break;
+	case S3DK_END:
+		term_addchar(0x1b);
+		term_addchar('[');
+		term_addchar('8');
+		term_addchar('~');
+		break;
+	case 13:
+		term_addchar(10);
+		break;
+	default:
+		if ((char)keys->unicode)  /*  \0 is no good idea .. */
+			term_addchar((char)keys->unicode);
 	}
 	return(0);
 
@@ -492,23 +470,19 @@
 void mainloop()
 {
 	usleep(10000);
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 
-	if ((i+=2)>100)
-	{
-		if (i%2)
-		{
+	if ((i+=2)>100) {
+		if (i%2) {
 			s3d_flags_on(cursor,S3D_OF_VISIBLE);
 			i=0;
-		}
-		else
-		{
+		} else {
 			s3d_flags_off(cursor,S3D_OF_VISIBLE);
 			i=1;
 		}
 	}
 	if (gotnewdata) {
-/* 		printf("got new data,displaying\n"); */
+		/* 		printf("got new data,displaying\n"); */
 		paintit();
 	}
 }
@@ -526,8 +500,8 @@
 	s3d_push_vertex(b, MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
 	s3d_push_vertex(b,-MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
 	s3d_push_material_a(b,0.5,0.5,0.5,0.7,
-						  1,1,1,0.7,
-						  0,0,0,0.7);
+	                    1,1,1,0.7,
+	                    0,0,0,0.7);
 	s3d_push_polygon(b,1,2,0,0);
 	s3d_push_polygon(b,2,3,0,0);
 	s3d_flags_on(b,S3D_OF_VISIBLE);
@@ -538,13 +512,11 @@
 #ifdef M_CHAR
 	char c[2];
 	c[1]='\0';
-	for (i=0;i<128;i++)
-	{
+	for (i=0;i<128;i++) {
 		c[0]=i;
 		charbuf[i]=s3d_draw_string(c,NULL);
 	}
-	for (i=128;i<256;i++)
-	{
+	for (i=128;i<256;i++) {
 		charbuf[i]=s3d_new_object();
 	}
 	cursor=s3d_new_object();
@@ -556,13 +528,12 @@
 #ifdef M_CHAR
 	int x,y;
 	for (y=0;y<(MAX_LINES);y++)
-	for (x=0;x<(MAX_CHARS);x++)
-	{
-		line[y].chars[x].character=line[y].chars[x].character=0;
-		i=y*MAX_CHARS+x;
-		screenbuf[i]=-1;
-		last_c[i]=0;
-	}
+		for (x=0;x<(MAX_CHARS);x++) {
+			line[y].chars[x].character=line[y].chars[x].character=0;
+			i=y*MAX_CHARS+x;
+			screenbuf[i]=-1;
+			last_c[i]=0;
+		}
 #endif
 #ifdef M_LINE
 	int i;
@@ -574,15 +545,13 @@
 {
 	unsigned int b;
 	chars_init();
-   	init_terminal();
+	init_terminal();
 	s3d_set_callback(S3D_EVENT_QUIT,stop);
 	s3d_set_callback(S3D_EVENT_OBJ_CLICK,stop);
 	s3d_set_callback(S3D_EVENT_KEY,keypress);
 
-	if (!s3d_init(&argc,&argv,"s3dvt"))	
-	{
-		if (s3d_select_font("vera"))
-		{
+	if (!s3d_init(&argc,&argv,"s3dvt")) {
+		if (s3d_select_font("vera")) {
 			printf("font not found\n");
 			exit(-1);
 		}

Modified: trunk/apps/s3dvt/s3dvt.h
===================================================================
--- trunk/apps/s3dvt/s3dvt.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dvt/s3dvt.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,22 +1,22 @@
 /*
  * s3dvt.h
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  * Copyright (C) 2002 Alexander Graf <helly at gmx.net>
  *
  * This file is part of s3dvt, a 3d terminal emulator for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dvt is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dvt is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dvt; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,16 +35,14 @@
 /* #define M_LINE		1 */
 #define M_CHAR		1
 
-typedef struct char_struct
-{
-    char character;
-    char fgcolor;
-    char bgcolor;
+typedef struct char_struct {
+	char character;
+	char fgcolor;
+	char bgcolor;
 }t_char;
 
-typedef struct line_struct
-{
-    t_char chars[MAX_CHARS+1];
+typedef struct line_struct {
+	t_char chars[MAX_CHARS+1];
 } t_line;
 
 extern t_line line[MAX_LINES+1];

Modified: trunk/apps/s3dvt/terminal.c
===================================================================
--- trunk/apps/s3dvt/terminal.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/apps/s3dvt/terminal.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,22 +1,22 @@
 /*
  * terminal.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  * Copyright (C) 2002 Alexander Graf <helly at gmx.net>
  *
  * This file is part of s3dvt, a 3d terminal emulator for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3dvt is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3dvt is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3dvt; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -48,263 +48,259 @@
 
 void move_all_lines_up()
 {
-    t_line *pfirstline=(t_line*)&line;
-    t_line *psecondline=(t_line*)&line+1;
-    t_line tmpline[MAX_LINES];
-    memcpy(&tmpline, psecondline, (MAX_LINES-1)*sizeof(struct line_struct));
-    memcpy(pfirstline, &tmpline, (MAX_LINES-1)*sizeof(struct line_struct));
+	t_line *pfirstline=(t_line*)&line;
+	t_line *psecondline=(t_line*)&line+1;
+	t_line tmpline[MAX_LINES];
+	memcpy(&tmpline, psecondline, (MAX_LINES-1)*sizeof(struct line_struct));
+	memcpy(pfirstline, &tmpline, (MAX_LINES-1)*sizeof(struct line_struct));
 }
 
 void clear_char(int lineid, int charid)
 {
-    line[lineid].chars[charid].character=0;
-    line[lineid].chars[charid].fgcolor=DEFAULT_FGCOLOR;
-    line[lineid].chars[charid].bgcolor=DEFAULT_BGCOLOR;
+	line[lineid].chars[charid].character=0;
+	line[lineid].chars[charid].fgcolor=DEFAULT_FGCOLOR;
+	line[lineid].chars[charid].bgcolor=DEFAULT_BGCOLOR;
 }
 
 void clear_line(int lineid)
 {
-    int i;
-    for(i=0;i<MAX_CHARS;i++)
+	int i;
+	for (i=0;i<MAX_CHARS;i++)
 		clear_char(lineid, i);
 }
 
 void clear_line_after_lastchar()
 {
-    int i;
-    for(i=cx;i<MAX_CHARS;i++) 
+	int i;
+	for (i=cx;i<MAX_CHARS;i++)
 		clear_char(cy, i);
 }
 
 t_line *line_is_full()
 {
-    t_line *pcurline=(t_line*)&line+cy;
-    cy++;
-    if (cy>=MAX_LINES) {       /*  damn it ... our display is filled ... let's move everything upwards */
+	t_line *pcurline=(t_line*)&line+cy;
+	cy++;
+	if (cy>=MAX_LINES) {       /*  damn it ... our display is filled ... let's move everything upwards */
 		cy=MAX_LINES-1;
 		pcurline=(t_line*)&line+cy;
-        move_all_lines_up();
-        clear_line(cy);
+		move_all_lines_up();
+		clear_line(cy);
 		gotnewdata=1;
-    } else {
-        pcurline=(t_line*)&line+cy;
-    }
+	} else {
+		pcurline=(t_line*)&line+cy;
+	}
 	cx=0;
-    return pcurline;
+	return pcurline;
 }
 
 void add_char_append(char toappend)
 {
-    int shouldinc=1;
-    t_line *pcurline=(t_line*)&line+cy;
-    if (cx==MAX_CHARS-1)
-	{ 
-		pcurline=line_is_full(); 
-		shouldinc=0; 
+	int shouldinc=1;
+	t_line *pcurline=(t_line*)&line+cy;
+	if (cx==MAX_CHARS-1) {
+		pcurline=line_is_full();
+		shouldinc=0;
 	}  /*  our line is full */
-    pcurline->chars[cx].character=toappend;
-    pcurline->chars[cx].fgcolor=curfgcolor;
-    pcurline->chars[cx].bgcolor=curbgcolor;
-    if(shouldinc) 
+	pcurline->chars[cx].character=toappend;
+	pcurline->chars[cx].fgcolor=curfgcolor;
+	pcurline->chars[cx].bgcolor=curbgcolor;
+	if (shouldinc)
 		cx++;
 }
 
 void backspace()
 {
-    if(cx>0)
+	if (cx>0)
 		cx--;
-    else 
+	else
 		cx=0;
 }
 
 void endansi()
 {
-    printf(" [/ANSI(%d)]\n", isansi2);
-    isansi=0;
-    isansi2=0;
+	printf(" [/ANSI(%d)]\n", isansi2);
+	isansi=0;
+	isansi2=0;
 }
 
 /*
-              Parameter                              Parameter Meaning                                     
-	      
-	      0                                      Attributes off                                                                                      
-	      1                                      Bold or increased intensity                                                                                       
-	      4                                      Underscore                                                                                            
-	      5                                      Blink                                                                                                     
-	      7                                      Negative (reverse) image                                                                           
-*/	      
+              Parameter                              Parameter Meaning
 
+	      0                                      Attributes off
+	      1                                      Bold or increased intensity
+	      4                                      Underscore
+	      5                                      Blink
+	      7                                      Negative (reverse) image
+*/
+
 void ansi_change_graphic(char **args)
 {
-    int curcol;
-    int i;
-    
-    if (args[0][0]=='\0') 
-	{
+	int curcol;
+	int i;
+
+	if (args[0][0]=='\0') {
 		args[0][0]='0';
 		args[0][1]='\0';
 	}
-    
-    for(i=0;i<5;i++)
-	{
-		if(args[i][0])
-		{
-		    curcol=atoi(args[i]);
-			
-			switch(curcol)
-			{
-			    case 0:
-					curbgcolor=DEFAULT_BGCOLOR;
-					curfgcolor=DEFAULT_FGCOLOR;
-					break;
-			    case 1:	 /*  Bold or increased intensity */
-			    case 4:	 /*  Underscore */
-			    case 5:	 /*  Blink */
-			    case 7:	 /*  Negative (reverse) image */
-			    case 10:	 /*  primary font */
-			    case 11:	 /*  alternate font */
-					break;
-				case 30:
-				case 31:
-				case 32:
-				case 33:
-				case 34:
-				case 35:
-				case 36:
-				case 37:
-					curfgcolor=curcol-30;
-					break;
-			    case 39:
-					curbgcolor=DEFAULT_FGCOLOR;
-					break;
-				case 40:
-				case 41:
-				case 42:
-				case 43:
-				case 44:
-				case 45:
-				case 46:
-				case 47:
-					curbgcolor=curcol-40;
-					break;
-	
-			    case 49:
-					curbgcolor=DEFAULT_BGCOLOR;
-					break;
-	
-			    default:
-					printf("*** don't know color-code %d\n", curcol);
-					break;
-		    }
+
+	for (i=0;i<5;i++) {
+		if (args[i][0]) {
+			curcol=atoi(args[i]);
+
+			switch (curcol) {
+			case 0:
+				curbgcolor=DEFAULT_BGCOLOR;
+				curfgcolor=DEFAULT_FGCOLOR;
+				break;
+			case 1:	 /*  Bold or increased intensity */
+			case 4:	 /*  Underscore */
+			case 5:	 /*  Blink */
+			case 7:	 /*  Negative (reverse) image */
+			case 10:	 /*  primary font */
+			case 11:	 /*  alternate font */
+				break;
+			case 30:
+			case 31:
+			case 32:
+			case 33:
+			case 34:
+			case 35:
+			case 36:
+			case 37:
+				curfgcolor=curcol-30;
+				break;
+			case 39:
+				curbgcolor=DEFAULT_FGCOLOR;
+				break;
+			case 40:
+			case 41:
+			case 42:
+			case 43:
+			case 44:
+			case 45:
+			case 46:
+			case 47:
+				curbgcolor=curcol-40;
+				break;
+
+			case 49:
+				curbgcolor=DEFAULT_BGCOLOR;
+				break;
+
+			default:
+				printf("*** don't know color-code %d\n", curcol);
+				break;
+			}
 		}
-    }
+	}
 }
 void move_up_x_lines(char *arg)
 {
-    t_line *pfirstline;
-    t_line *psecondline;
-    t_line tmpline[MAX_LINES];
-    int amount;
-    int i;
-    
-    if(arg[0]) amount=atoi(arg); else amount=0;
-    
-    printf("moving up %d lines", amount);
-    
-    for(i=0;i<amount;i++)
-	{
-    
+	t_line *pfirstline;
+	t_line *psecondline;
+	t_line tmpline[MAX_LINES];
+	int amount;
+	int i;
+
+	if (arg[0]) amount=atoi(arg);
+	else amount=0;
+
+	printf("moving up %d lines", amount);
+
+	for (i=0;i<amount;i++) {
+
 		pfirstline=(t_line*)&line+cy;
 		psecondline=pfirstline+1;
-    
+
 		memcpy(&tmpline, psecondline, (bottom-top)*sizeof(struct line_struct));
 		memcpy(pfirstline, &tmpline,  (bottom-top)*sizeof(struct line_struct));
-    
-    }
+
+	}
 }
 
 void move_down_x_lines(char *arg)
 {
-    t_line *pfirstline;
-    t_line *psecondline;
-    t_line tmpline[MAX_LINES];
-    int amount;
-    int i;
-    
-    if(arg[0]) amount=atoi(arg); else amount=0;
-    
-    printf("moving down %d lines", amount);
-    
-    for(i=0;i<amount;i++)
-	{
+	t_line *pfirstline;
+	t_line *psecondline;
+	t_line tmpline[MAX_LINES];
+	int amount;
+	int i;
+
+	if (arg[0]) amount=atoi(arg);
+	else amount=0;
+
+	printf("moving down %d lines", amount);
+
+	for (i=0;i<amount;i++) {
 		pfirstline=(t_line*)&line+cy;
 		psecondline=pfirstline+1;
-    
+
 		memcpy(&tmpline, pfirstline, (bottom-top)*sizeof(struct line_struct));
 		memcpy(psecondline, &tmpline,  (bottom-top)*sizeof(struct line_struct));
-    }
+	}
 }
 void delete_x_letters(char *arg1)
 {
-    int tmpint;t_line *pcurline;int i;
-	if(arg1[0]) tmpint=atoi(arg1);
+	int tmpint;
+	t_line *pcurline;
+	int i;
+	if (arg1[0]) tmpint=atoi(arg1);
 	else	    tmpint=1;
 	pcurline=(t_line*)&line+cy;
-	if (tmpint+cx>MAX_CHARS) 
+	if (tmpint+cx>MAX_CHARS)
 		tmpint=MAX_CHARS-cx;
-	for(i=cx;i<cx+tmpint;i++)
-	    clear_char(cy,i);
+	for (i=cx;i<cx+tmpint;i++)
+		clear_char(cy,i);
 }
 void move_x_letters(int mode, char *arg1)
 {
-    int tmpint;t_line *pcurline;int i;
-	if(arg1[0])
-	    tmpint=atoi(arg1);
+	int tmpint;
+	t_line *pcurline;
+	int i;
+	if (arg1[0])
+		tmpint=atoi(arg1);
 	else
-	    tmpint=1;
+		tmpint=1;
 	pcurline=(t_line*)&line+cy;
-	switch(mode) {
-	    case MOVE_RIGHT:
-	        for(i=0;i<tmpint;i++)
-			{
-/*	    	    pcurline->nextchar++; 
-				lastchar++;*/
-				cx++;
-		    	if (cx==MAX_CHARS) 
-					pcurline=line_is_full();  /*  our line is full */
-			}
-			break;
-	    case MOVE_LEFT:
-	        for(i=0;i<tmpint;i++)
-			{
-				cx--;
-			    if(cx==-1) 
-				{ 
-					cy--; 
-					pcurline=(t_line*)&line+cy; 
-					cx=MAX_CHARS-1; 
-				}  /*  need to go up one line */
-			}
-			break;
-	    case MOVE_UP:
-			cy--;
-			break;
-	    case MOVE_DOWN:
-			line_is_full();
-			break;
-	    default:
-			break;
+	switch (mode) {
+	case MOVE_RIGHT:
+		for (i=0;i<tmpint;i++) {
+			/*	    	    pcurline->nextchar++;
+							lastchar++;*/
+			cx++;
+			if (cx==MAX_CHARS)
+				pcurline=line_is_full();  /*  our line is full */
+		}
+		break;
+	case MOVE_LEFT:
+		for (i=0;i<tmpint;i++) {
+			cx--;
+			if (cx==-1) {
+				cy--;
+				pcurline=(t_line*)&line+cy;
+				cx=MAX_CHARS-1;
+			}  /*  need to go up one line */
+		}
+		break;
+	case MOVE_UP:
+		cy--;
+		break;
+	case MOVE_DOWN:
+		line_is_full();
+		break;
+	default:
+		break;
 	}
 }
 void remove_beginning_from_curpos()
 {
-    int i,j=cx;
-    for(i=cy;i<MAX_LINES;i++) {
-	for(;j<MAX_CHARS;j++){
-	    clear_char(i,j);
+	int i,j=cx;
+	for (i=cy;i<MAX_LINES;i++) {
+		for (;j<MAX_CHARS;j++) {
+			clear_char(i,j);
+		}
+		j=0;
 	}
-	j=0;
-    }
 }
 
 int parseansi(char curchar)
@@ -318,98 +314,104 @@
 	static char curarg=0;
 	static char *args[]={arg1,arg2,arg3,arg4,arg5};
 	/* 	static char *args[]={&arg1,&arg2,&arg3,&arg4,&arg5}; */
-	    printf("%c", curchar);
-	switch (isansi2)
-	{
+	printf("%c", curchar);
+	switch (isansi2) {
 	case 1:
-		switch(curchar)
-		{
-		    case '0':
-		    case '1':
-		    case '2':
-		    case '3':
-		    case '4':
-		    case '5':
-		    case '6':
-		    case '7':
-		    case '8':
-		    case '9':  /*  we got an argument */
-				args[(int)curarg][(int)curindex]=curchar;
-				curindex++; 
-				args[(int)curarg][(int)curindex]='\0';
-				break;
-		    case ';':  /*  some arg is finished */
-				curarg++; 
-				curindex=0; 
-				args[(int)curarg][0]='\0';
-				break;
-		    case 'J':  /*  remove beginning from current cursor to end of screen */
-				remove_beginning_from_curpos();
-				gotnewdata=1;
-				break;
-		    case 'K':  /*  remove everything in line beginning from lastchar */
-				clear_line_after_lastchar();
-				break;
-		    case 'H':  /*  move to position x=arg1 y=arg2 */
-				if(arg1[0]) cy=atoi(arg1)-1; 
-					else 	cy=0;
-				if(arg2[0]) cx=atoi(arg2)-1; 
-					else 	cx=0;
-				break;
-		    case 'G':  /*  move to position x=arg1 y=MAX */
-				if(arg1[0]) cx=atoi(arg1)-1; else cx=-1;
-				cy=bottom-1;
-				break;
-		    case 'd':  /*  move to position x=MAX y=arg1 */
-				if(arg1[0]) cy=atoi(arg1)-1; else cy=0;
-				cy=top+cy;
-				cx=MAX_CHARS-1;
-				break;
-		    case 'm':  /*  change graphic */
-				ansi_change_graphic(args);
-				break;
-		    case 'M':  /*  Move memory in range ('r') one uo */
-				move_up_x_lines(arg1);
-				break;
-		    case 'L':  /*  Move memory in range ('r') one down */
-				move_down_x_lines(arg1);
-				break;
-		    case 'l':
-	/*		RM -- Reset Mode
-			
-			ESC [ Ps ; Ps ; . . . ; Ps l                                                                                                          default value: none
-			
-			Resets one or more VT100 modes as specified by each selective parameter in the parameter string. Each mode to be reset is specified by a separate
-			parameter. [See Set Mode (SM) control sequence]. (See Modes following this section).*/
-			
-			 /*  mc only resets the '4' !?! => IRM (Insert/Replacement-Mode) */
-			 /*  perhaps Set Cursor to Block mode ? */
-				break;
-			case 'r':  /*  define scroll-range  */
-				if(arg1[0]) top=atoi(arg1); else top=0;
-				if(arg2[0]) bottom=atoi(arg2); else bottom=0;
-				cy=0; 
-				cx=0;
-				break;
-			case 'a':
-			case 'A':  /*  move x letters up */
-				move_x_letters(MOVE_UP, arg1);	break;
-			case 'B':  /*  move x letters down */
-				move_x_letters(MOVE_DOWN, arg1);	break;
-			case 'C':  /*  move x letters right */
-				move_x_letters(MOVE_RIGHT, arg1);	break;
-			case 'D':  /*  move x letters left */
-				move_x_letters(MOVE_LEFT, arg1);	break;
-			case 'P':  /*  delete x letters */
-				delete_x_letters(arg1);	break;
-			case '?':
-				isansi2=4;
-				return 0;
-			default:
-				printf("***unknown***");
+		switch (curchar) {
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':  /*  we got an argument */
+			args[(int)curarg][(int)curindex]=curchar;
+			curindex++;
+			args[(int)curarg][(int)curindex]='\0';
+			break;
+		case ';':  /*  some arg is finished */
+			curarg++;
+			curindex=0;
+			args[(int)curarg][0]='\0';
+			break;
+		case 'J':  /*  remove beginning from current cursor to end of screen */
+			remove_beginning_from_curpos();
+			gotnewdata=1;
+			break;
+		case 'K':  /*  remove everything in line beginning from lastchar */
+			clear_line_after_lastchar();
+			break;
+		case 'H':  /*  move to position x=arg1 y=arg2 */
+			if (arg1[0]) cy=atoi(arg1)-1;
+			else 	cy=0;
+			if (arg2[0]) cx=atoi(arg2)-1;
+			else 	cx=0;
+			break;
+		case 'G':  /*  move to position x=arg1 y=MAX */
+			if (arg1[0]) cx=atoi(arg1)-1;
+			else cx=-1;
+			cy=bottom-1;
+			break;
+		case 'd':  /*  move to position x=MAX y=arg1 */
+			if (arg1[0]) cy=atoi(arg1)-1;
+			else cy=0;
+			cy=top+cy;
+			cx=MAX_CHARS-1;
+			break;
+		case 'm':  /*  change graphic */
+			ansi_change_graphic(args);
+			break;
+		case 'M':  /*  Move memory in range ('r') one uo */
+			move_up_x_lines(arg1);
+			break;
+		case 'L':  /*  Move memory in range ('r') one down */
+			move_down_x_lines(arg1);
+			break;
+		case 'l':
+			/*		RM -- Reset Mode
+					
+					ESC [ Ps ; Ps ; . . . ; Ps l                                                                                                          default value: none
+					
+					Resets one or more VT100 modes as specified by each selective parameter in the parameter string. Each mode to be reset is specified by a separate
+					parameter. [See Set Mode (SM) control sequence]. (See Modes following this section).*/
+
+			/*  mc only resets the '4' !?! => IRM (Insert/Replacement-Mode) */
+			/*  perhaps Set Cursor to Block mode ? */
+			break;
+		case 'r':  /*  define scroll-range  */
+			if (arg1[0]) top=atoi(arg1);
+			else top=0;
+			if (arg2[0]) bottom=atoi(arg2);
+			else bottom=0;
+			cy=0;
+			cx=0;
+			break;
+		case 'a':
+		case 'A':  /*  move x letters up */
+			move_x_letters(MOVE_UP, arg1);
+			break;
+		case 'B':  /*  move x letters down */
+			move_x_letters(MOVE_DOWN, arg1);
+			break;
+		case 'C':  /*  move x letters right */
+			move_x_letters(MOVE_RIGHT, arg1);
+			break;
+		case 'D':  /*  move x letters left */
+			move_x_letters(MOVE_LEFT, arg1);
+			break;
+		case 'P':  /*  delete x letters */
+			delete_x_letters(arg1);
+			break;
+		case '?':
+			isansi2=4;
+			return 0;
+		default:
+			printf("***unknown***");
 		}
-		if(!((curchar>='0' && curchar<='9') || curchar==';'))
-		{  /*  clean our args */
+		if (!((curchar>='0' && curchar<='9') || curchar==';')) { /*  clean our args */
 			args[0][0]='\0';
 			args[1][0]='\0';
 			args[2][0]='\0';
@@ -418,96 +420,98 @@
 			curindex=0;
 			curarg=0;
 			endansi();
-		} 
+		}
 		break;
 	case 0:
-		switch(curchar)
-		{
-		    case '[': isansi2=1; break;
-		    case '(': isansi2=2; break;
-		    case ')': isansi2=3; break;
-		    case ']': isansi2=5; break;
-		    default:
+		switch (curchar) {
+		case '[':
+			isansi2=1;
+			break;
+		case '(':
+			isansi2=2;
+			break;
+		case ')':
+			isansi2=3;
+			break;
+		case ']':
+			isansi2=5;
+			break;
+		default:
 			endansi();
 			break;
 		}
 		break;
 	case 4:
-		if (curchar>'9' || curchar<'0') 
+		if (curchar>'9' || curchar<'0')
 			endansi();
 		break;
 	case 5:
-		if(curchar==7) endansi(); /* FIXME: Window Title*/
+		if (curchar==7) endansi(); /* FIXME: Window Title*/
 		break;
 	default:
 		endansi();
 		break;
-    }
+	}
 	return(0);
 }
 
 void AddChar(char *_toadd)
 {
-    char *toadd;
-    char curchar;
+	char *toadd;
+	char curchar;
 
-    for(toadd=_toadd;toadd[0];toadd++) 
-	{
+	for (toadd=_toadd;toadd[0];toadd++) {
 		curchar=toadd[0];
-	/*	printf("%.3d (", curchar);*/
-		if(isansi) 
-			parseansi(curchar); 
-		else
-		{
-			switch(curchar) 
-			{
+		/*	printf("%.3d (", curchar);*/
+		if (isansi)
+			parseansi(curchar);
+		else {
+			switch (curchar) {
 			case 7:
-			    printf("<BEEP>\n");
-			    break;
+				printf("<BEEP>\n");
+				break;
 			case 8:
-			    printf("<BS>\n");
-			    backspace();
-			    break;
+				printf("<BS>\n");
+				backspace();
+				break;
 			case 27:
-			     /*  ANSI */
-			    printf("<ESC>[ANSI] ");
-			    isansi=1;
-			    break;
+				/*  ANSI */
+				printf("<ESC>[ANSI] ");
+				isansi=1;
+				break;
 			case 10:
-			    printf("<LF>\n");/* get onto the next line */
-			    line_is_full();
-			    break;
+				printf("<LF>\n");/* get onto the next line */
+				line_is_full();
+				break;
 			case 13:
-			    printf("<CR>\n");/* carriage return, get back */
-				if (cx==MAX_CHARS-1) 
+				printf("<CR>\n");/* carriage return, get back */
+				if (cx==MAX_CHARS-1)
 					line_is_full();
 				cx=0;
-			    break;
+				break;
 			default:
-				if ((curchar>=32) && (curchar<127))
-				{
-			/*	    printf("%c", curchar);*/
-				    add_char_append(curchar);
+				if ((curchar>=32) && (curchar<127)) {
+					/*	    printf("%c", curchar);*/
+					add_char_append(curchar);
 				}
-			    break;
-		    }
-/*	printf(")\n");*/
+				break;
+			}
+			/*	printf(")\n");*/
 		}
-    }
-    gotnewdata=1;
+	}
+	gotnewdata=1;
 }
 void init_line()
 {
-    int i;
-    for(i=0;i<MAX_LINES;i++){
+	int i;
+	for (i=0;i<MAX_LINES;i++) {
 		clear_line(i);
-    }
+	}
 }
 void term_addstring(char *toprint)
 {
-    char *ns;
-    for(ns=toprint;ns[0];ns++)
-	{
+	char *ns;
+	for (ns=toprint;ns[0];ns++) {
 		term_addchar(ns[0]);
-    }  /*  better method */
+	}  /*  better method */
 }

Modified: trunk/example/filebrowser.c
===================================================================
--- trunk/example/filebrowser.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/filebrowser.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * filebrowser.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -32,7 +32,9 @@
 #include <unistd.h>	 /*  chdir() */
 #include <math.h>	 /*  sin(),cos() */
 #include <time.h>	/* nanosleep() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+static struct timespec t= {
+	0,100*1000*1000
+}; /* 100 mili seconds */
 
 #define T_DUNO		0
 #define T_LOCALDIR	1
@@ -61,74 +63,82 @@
 	char *nstr;
 	float alpha,al,radius,f;
 	char ndir[M_DIR+1];
-	if (n_item)
-	{
+	if (n_item) {
 		printf("freeing %d old items\n",n_item);
-		for (i=0;i<n_item;i++)
-		{
+		for (i=0;i<n_item;i++) {
 			printf("deleting %d and %d\n",item[i].icon_oid,	item[i].descr_oid);
 			s3d_del_object(item[i].descr_oid);
 			s3d_del_object(item[i].icon_oid);
 			s3d_del_object(item[i].pie_oid);
 		}
 		free(item);
-		
+
 	}
-    n = i = scandir(dir, &namelist, 0, alphasort);
-    if (n < 0)
-	{
-        perror("scandir");
+	n = i = scandir(dir, &namelist, 0, alphasort);
+	if (n < 0) {
+		perror("scandir");
 		return(-1);
-	}
-    else {
+	} else {
 		item=malloc(sizeof(struct t_item)*i);
 		n_item=i;
-        while(n--) {
+		while (n--) {
 			item[n].type=T_DUNO;
 			nstr=namelist[n]->d_name;
 			strncpy(item[n].name,nstr,M_NAME);
- 		    if ((0==strncmp(nstr,".",1)) && (strlen(nstr)==1))
+			if ((0==strncmp(nstr,".",1)) && (strlen(nstr)==1))
 				item[n].type=T_LOCALDIR;
 			else if (0==strncmp(nstr,"..",strlen(nstr)<2?strlen(nstr):2))
-			   item[n].type=T_BACKDIR;
+				item[n].type=T_BACKDIR;
 			else {
 				ext=strrchr(nstr,'.');
-			    strncpy(ndir,dir,M_DIR);
+				strncpy(ndir,dir,M_DIR);
 				ndir[M_DIR]=0;		/* just in case */
-			    strncat(ndir,"/",M_DIR-strlen(ndir));
-		    	strncat(ndir,namelist[n]->d_name,M_DIR-strlen(ndir));
-/* 				printf("displaying %s\n",ndir); */
-			    if ((namelist[n]->d_type==DT_DIR) ||
-					((namelist[n]->d_type==DT_UNKNOWN) && (opendir(ndir)!=NULL)))
+				strncat(ndir,"/",M_DIR-strlen(ndir));
+				strncat(ndir,namelist[n]->d_name,M_DIR-strlen(ndir));
+				/* 				printf("displaying %s\n",ndir); */
+				if ((namelist[n]->d_type==DT_DIR) ||
+				                ((namelist[n]->d_type==DT_UNKNOWN) && (opendir(ndir)!=NULL)))
 					item[n].type=T_FOLDER;
-				else 
-				{
-				   if (ext!=NULL)
-				   {
-					   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))
-							   item[n].type=T_GEOMETRY;
-					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))
-							   item[n].type=T_MUSIC;
-					   else if (0==strncmp(ext,".mpg",strlen(ext)<4?strlen(ext):4))
-							   item[n].type=T_MOVIE;
+				else {
+					if (ext!=NULL) {
+						if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))
+							item[n].type=T_GEOMETRY;
+						else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))
+							item[n].type=T_MUSIC;
+						else if (0==strncmp(ext,".mpg",strlen(ext)<4?strlen(ext):4))
+							item[n].type=T_MOVIE;
 
-				   }
+					}
 				}
 			}
-			switch (item[n].type)
-			{
-				case T_LOCALDIR:   	item[n].icon_oid=s3d_clone(dot);break;
-				case T_BACKDIR:   	item[n].icon_oid=s3d_clone(dotdot);break;
-				case T_FOLDER:   	item[n].icon_oid=s3d_clone(folder);
-									break;
-				case T_GEOMETRY:   	item[n].icon_oid=s3d_clone(geometry);break;
-				case T_MUSIC:	   	item[n].icon_oid=s3d_clone(mp3);break;
-				case T_MOVIE:		item[n].icon_oid=s3d_clone(movie);break;
-				default:   			printf("don't know type, defaulting to duno %d...\n",duno);
-									item[n].icon_oid=s3d_clone(duno);break;
+			switch (item[n].type) {
+			case T_LOCALDIR:
+				item[n].icon_oid=s3d_clone(dot);
+				break;
+			case T_BACKDIR:
+				item[n].icon_oid=s3d_clone(dotdot);
+				break;
+			case T_FOLDER:
+				item[n].icon_oid=s3d_clone(folder);
+				break;
+			case T_GEOMETRY:
+				item[n].icon_oid=s3d_clone(geometry);
+				break;
+			case T_MUSIC:
+				item[n].icon_oid=s3d_clone(mp3);
+				break;
+			case T_MOVIE:
+				item[n].icon_oid=s3d_clone(movie);
+				break;
+			default:
+				printf("don't know type, defaulting to duno %d...\n",duno);
+				item[n].icon_oid=s3d_clone(duno);
+				break;
 			}
 
-			px=posx;py=posy;pz=posz;
+			px=posx;
+			py=posy;
+			pz=posz;
 			alpha=((360.0*n)/((float)i));
 			radius=((n_item*10)/(M_PI*4));
 			if (n_item<5)
@@ -142,39 +152,46 @@
 			item[n].pie_oid=s3d_new_object();
 			s3d_push_vertex(item[n].pie_oid,0,-2,0);
 			al=((360.0*(n-0.5))/((float)i));
-			s3d_push_vertex(item[n].pie_oid,		
-						posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
+			s3d_push_vertex(item[n].pie_oid,
+			                posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
 			al=((360.0*(n+0.5))/((float)i));
-			s3d_push_vertex(item[n].pie_oid,		
-						posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
-			
+			s3d_push_vertex(item[n].pie_oid,
+			                posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
+
 			f=1.0-0.05*(n%2);
-			switch (item[n].type)
-			{
-				case T_LOCALDIR:s3d_push_material(item[n].pie_oid,		0,f,0,			0.5,0.5,0.5,		f,f,f);		break;
-				case T_BACKDIR:	s3d_push_material(item[n].pie_oid,		0,f/2,0,		0.5,0.5,0.5,		f,f,f);		break;
-				case T_FOLDER:	s3d_push_material(item[n].pie_oid,		f,f,0,			0.5,0.5,0.0,		f,f,1);		break;
-				default:		s3d_push_material(item[n].pie_oid,		f,f,f,			0.5,0.5,0.5,		f,f,f);		break;
+			switch (item[n].type) {
+			case T_LOCALDIR:
+				s3d_push_material(item[n].pie_oid,		0,f,0,			0.5,0.5,0.5,		f,f,f);
+				break;
+			case T_BACKDIR:
+				s3d_push_material(item[n].pie_oid,		0,f/2,0,		0.5,0.5,0.5,		f,f,f);
+				break;
+			case T_FOLDER:
+				s3d_push_material(item[n].pie_oid,		f,f,0,			0.5,0.5,0.0,		f,f,1);
+				break;
+			default:
+				s3d_push_material(item[n].pie_oid,		f,f,f,			0.5,0.5,0.5,		f,f,f);
+				break;
 			}
 			s3d_push_polygon(item[n].pie_oid,	0,2,1,	0);
 
 			s3d_push_vertex(item[n].pie_oid,pz,-2,0);
 			s3d_translate(item[n].icon_oid,px,py,pz);
 			s3d_rotate(item[n].icon_oid,0,alpha,0);
-		    s3d_flags_on(item[n].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		    s3d_flags_on(item[n].pie_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(item[n].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(item[n].pie_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			item[n].descr_oid=s3d_draw_string(nstr,NULL);
 			s3d_link(item[n].descr_oid,item[n].icon_oid);
-			s3d_translate(item[n].descr_oid,-1,-2,0); 
-/* 			r=s3d_get_radius(p); */
-/* 			s3d_scale(p,1.0/r,1.0/r,1.0/r); */
-		    s3d_flags_on(item[n].descr_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-            printf("%s [%d]\n", nstr,namelist[n]->d_type);
+			s3d_translate(item[n].descr_oid,-1,-2,0);
+			/* 			r=s3d_get_radius(p); */
+			/* 			s3d_scale(p,1.0/r,1.0/r,1.0/r); */
+			s3d_flags_on(item[n].descr_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			printf("%s [%d]\n", nstr,namelist[n]->d_type);
 			printf("string %d linked to %d\n",item[n].descr_oid,item[n].icon_oid);
-        	free(namelist[n]);
-        }
+			free(namelist[n]);
+		}
 		free(namelist);
-   	}
+	}
 	return(0);
 }
 
@@ -184,35 +201,32 @@
 	char execstr[256];
 	oid=(int)*((unsigned long *)evt->buf);
 	printf("!!!!!!!!! clicked object %d\n",oid);
-	for (i=0;i<n_item;i++)
-	{
+	for (i=0;i<n_item;i++) {
 		if (((oid==item[i].icon_oid) || (oid==item[i].descr_oid)) ||
-			(oid==item[i].pie_oid) )
-		{
-			switch (item[i].type)
-			{
-				case T_BACKDIR:
-				case T_FOLDER:
-				case T_LOCALDIR:
-						printf("going into %s\n",item[i].name);
-						chdir(item[i].name);
-						display_dir(".",0,0,0,0);
-						return(0);
-						break;
-				case T_GEOMETRY:
-						printf("loading geometry %s\n",item[i].name);
-						snprintf(execstr,256,"modelloader \"%s\"&\n",item[i].name);
-						system(execstr);
-						return(0);
-						break;
-				case T_MOVIE:
-						printf("playing %s\n",item[i].name);
-						snprintf(execstr,256,"mplayer -vo s3d \"%s\"&\n",item[i].name);
-						system(execstr);
-						return(0);
-						break;
+		                (oid==item[i].pie_oid) ) {
+			switch (item[i].type) {
+			case T_BACKDIR:
+			case T_FOLDER:
+			case T_LOCALDIR:
+				printf("going into %s\n",item[i].name);
+				chdir(item[i].name);
+				display_dir(".",0,0,0,0);
+				return(0);
+				break;
+			case T_GEOMETRY:
+				printf("loading geometry %s\n",item[i].name);
+				snprintf(execstr,256,"modelloader \"%s\"&\n",item[i].name);
+				system(execstr);
+				return(0);
+				break;
+			case T_MOVIE:
+				printf("playing %s\n",item[i].name);
+				snprintf(execstr,256,"mplayer -vo s3d \"%s\"&\n",item[i].name);
+				system(execstr);
+				return(0);
+				break;
 
-						
+
 			}
 		}
 	}
@@ -220,15 +234,14 @@
 }
 void mainloop()
 {
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 }
 int main (int argc, char **argv)
 {
 	int i;
-	if (!s3d_init(&argc,&argv,"filebrowser"))	
-	{
+	if (!s3d_init(&argc,&argv,"filebrowser")) {
 		i=0;
-		 /*  load the object files */
+		/*  load the object files */
 		folder=s3d_import_model_file("objs/folder.3ds");
 		geometry=s3d_import_model_file("objs/geometry.3ds");
 		mp3=s3d_import_model_file("objs/notes.3ds");

Modified: trunk/example/hudtest.c
===================================================================
--- trunk/example/hudtest.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/hudtest.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * hudtest.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -33,8 +33,7 @@
 int main(int argc, char **argv)
 {
 	int o,m;
-	if (!s3d_init(&argc,&argv,"hud-test"))
-	{
+	if (!s3d_init(&argc,&argv,"hud-test")) {
 		if (s3d_select_font("vera"))
 			printf("font not found\n");
 		o=s3d_draw_string("hud-test",NULL);

Modified: trunk/example/katze.c
===================================================================
--- trunk/example/katze.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/katze.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * katze.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,7 +27,9 @@
 #include <s3d.h>
 #include <math.h>	/* sin() */
 #include <time.h>	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
 
 int a;
 int rot_point,body,legfr,legbr,legfl,legbl,tail;
@@ -44,13 +46,12 @@
 
 	s3d_rotate(tail,0,30,110+pos);
 	s3d_rotate(rot_point,0,-a,0);
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 }
 int main(int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"running cat"))
-	{
-			
+	if (!s3d_init(&argc,&argv,"running cat")) {
+
 		rot_point=s3d_new_object();
 		body=s3d_import_model_file("objs/katze_body.3ds");
 		legfr=s3d_import_model_file("objs/katze_leg.3ds");
@@ -70,14 +71,14 @@
 		s3d_link(legbl,body);
 		s3d_link(tail,body);
 		s3d_link(body,rot_point);
-/*		s3d_link(oid_foot,oid_head);
- *		s3d_link(oid_middle,oid_head);
- *		s3d_translate(oid_head,0,4,0);
-		
- *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
- *		s3d_translate(oid_foot,0,-3.5,0); */
-		
+		/*		s3d_link(oid_foot,oid_head);
+		 *		s3d_link(oid_middle,oid_head);
+		 *		s3d_translate(oid_head,0,4,0);
 
+		 *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
+		 *		s3d_translate(oid_foot,0,-3.5,0); */
+
+
 		s3d_flags_on(body,S3D_OF_VISIBLE);
 		s3d_flags_on(legfr,S3D_OF_VISIBLE);
 		s3d_flags_on(legfl,S3D_OF_VISIBLE);

Modified: trunk/example/linetest.c
===================================================================
--- trunk/example/linetest.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/linetest.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * linetest.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -36,44 +36,40 @@
 void mainloop()
 {
 	i=(i+1)%2;
-	if (i)
-	{
+	if (i) {
 		s3d_pep_vertex(o,1,-2,0);
 		s3d_pep_line(o,0,2,3);
-	}
-	else
-	{
+	} else {
 		s3d_pep_vertex(o,1,-1,0);
 		s3d_pep_line(o,0,1,0);
 
 	}
-/* 	printf("now it's %s\n",time_str); */
+	/* 	printf("now it's %s\n",time_str); */
 	sleep(1);
 
 }
 int main (int argc, char **argv)
 {
 	i=0;
-	if (!s3d_init(&argc,&argv,"linetest"))	
-	{
+	if (!s3d_init(&argc,&argv,"linetest")) {
 		o=s3d_new_object();
-		
+
 		s3d_push_material(o,
-						1,0,0,
-						1,0,0,
-						1,0,0);
+		                  1,0,0,
+		                  1,0,0,
+		                  1,0,0);
 		s3d_push_material(o,
-						0,1,0,
-						0,1,0,
-						0,1,0);
+		                  0,1,0,
+		                  0,1,0,
+		                  0,1,0);
 		s3d_push_material(o,
-						0,1,0,
-						0,1,0,
-						0,1,0);
+		                  0,1,0,
+		                  0,1,0,
+		                  0,1,0);
 		s3d_push_material(o,
-						1,1,0,
-						1,1,0,
-						1,1,0);
+		                  1,1,0,
+		                  1,1,0,
+		                  1,1,0);
 		s3d_push_vertex(o,-1,-1,0);
 		s3d_push_vertex(o,-1,1,0);
 		s3d_push_vertex(o,1,1,0);
@@ -85,7 +81,7 @@
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
 		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
 		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/example/modelloader.c
===================================================================
--- trunk/example/modelloader.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/modelloader.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * modelloader.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,34 +27,33 @@
 #include <s3d.h>
 #include <stdio.h>  /* NULL */
 #include <time.h>	/* nanosleep() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+static struct timespec t= {
+	0,100*1000*1000
+}; /* 100 mili seconds */
 int i,oid;
 void mainloop()
 {
 	s3d_rotate(oid,0,i,0);
 	i=(i+1)%360;
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 }
 int object_click(struct s3d_evt *evt)
 {
 	s3d_quit();
 	return(0);
 }
-	
+
 int main (int argc, char **argv)
 {
-	if (argc<2)
-	{
+	if (argc<2) {
 		printf("usage: %s [somefile.3ds]\n",argv[0]);
 		return(-1);
 	}
-	if (!s3d_init(&argc,&argv,"modelloader"))	
-	{
+	if (!s3d_init(&argc,&argv,"modelloader")) {
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
 		i=0;
-	    if (-1!=(oid=s3d_import_model_file(argv[1])))
-		{
-		    s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		if (-1!=(oid=s3d_import_model_file(argv[1]))) {
+			s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			s3d_mainloop(mainloop);
 		} else {
 			printf("file not found ... \n");

Modified: trunk/example/nichtsnutz.c
===================================================================
--- trunk/example/nichtsnutz.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/nichtsnutz.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * nichtsnutz.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -28,28 +28,30 @@
 #include <s3d_keysym.h>
 #include <stdio.h>
 #include <math.h>
-#include <time.h>	
+#include <time.h>
 
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
 
 int object,foll;
 float al, r, rc ,alpha=0.0, Asp, Bottom, Left, angle;
 float CamPosition[2][3],
-	  TmpMove[3],
-	  Tmp[3],
-	  TmpCam[2][3],
-	  RotCam[2][3],
-	  CatPos[3];
+TmpMove[3],
+Tmp[3],
+TmpCam[2][3],
+RotCam[2][3],
+CatPos[3];
 
 float length;
 
 void mainloop()
 {
-	
+
 	al=(alpha*M_PI/180);
-    r = 5.0;
+	r = 5.0;
 	rc = 12.0;
-	
+
 	CatPos[0] = sin(al)*r;
 	CatPos[1] = 0;
 	CatPos[2] = cos(al)*r;
@@ -62,18 +64,17 @@
 	s3d_rotate(object, 0, alpha, 0);
 	alpha = alpha+0.1;
 	if (alpha>360.0) alpha=0.0;
-	
+
 	length = s3d_vector_length(CatPos);
 
 
 	RotCam[0][0] = ( CatPos[0] * 12.0 ) / length;
 	RotCam[0][1] = ( CatPos[1] * 12.0 ) / length;
 	RotCam[0][2] = ( CatPos[2] * 12.0 ) / length;
-	
-	
-	if( foll )
-	{
-		
+
+
+	if ( foll ) {
+
 		CamPosition[0][0] = ((CamPosition[0][0]*4 + RotCam[0][0])/5);
 		CamPosition[0][1] = ((CamPosition[0][1]*4 + RotCam[0][1])/5);
 		CamPosition[0][2] = ((CamPosition[0][2]*4 + RotCam[0][2])/5);
@@ -86,27 +87,26 @@
 		Tmp[0] = CamPosition[0][0] - CatPos[0];
 		Tmp[1] = 0.0;
 		Tmp[2] = CamPosition[0][2] - CatPos[2];
-		
+
 		angle = s3d_vector_angle(Tmp,TmpMove);
 		angle = (CatPos[0] > 0)?(180-(180 / M_PI * angle)):(180+(180 / M_PI * angle));
 		printf("%f %f\n",angle,al);
-	
+
 		CamPosition[1][1] = (CamPosition[1][1]*4 + angle)/5;
 		s3d_rotate(0,CamPosition[1][0], CamPosition[1][1], CamPosition[1][2]);
 	}
-	
 
-	
-	nanosleep(&t,NULL); 
+
+
+	nanosleep(&t,NULL);
 }
 
 int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz->buf;
-	
-	if (inf->object==0)
-	{
+
+	if (inf->object==0) {
 		CamPosition[0][0] = inf->trans_x;
 		CamPosition[0][1] = inf->trans_y;
 		CamPosition[0][2] = inf->trans_z;
@@ -115,8 +115,7 @@
 		CamPosition[1][2] = inf->rot_z;
 
 		Asp=inf->scale;
-		if (Asp>1.0) /* wide screen */
-		{
+		if (Asp>1.0) { /* wide screen */
 			Bottom=-1.0;
 			Left=-Asp;
 		} else {  /* high screen */
@@ -133,20 +132,18 @@
 {
 	int key;
 	key=*((unsigned short *)event->buf);
-	switch(key)
-	{
-		case 'f':
-				foll = foll ? 0 : 1;
-				if( foll )
-				{
-					TmpCam[0][0] = CamPosition[0][0];
-					TmpCam[0][1] = CamPosition[0][1];
-					TmpCam[0][2] = CamPosition[0][2];
-					TmpCam[1][0] = CamPosition[1][0];
-					TmpCam[1][1] = CamPosition[1][1];
-					TmpCam[1][2] = CamPosition[1][2];
-				}
-				break;
+	switch (key) {
+	case 'f':
+		foll = foll ? 0 : 1;
+		if ( foll ) {
+			TmpCam[0][0] = CamPosition[0][0];
+			TmpCam[0][1] = CamPosition[0][1];
+			TmpCam[0][2] = CamPosition[0][2];
+			TmpCam[1][0] = CamPosition[1][0];
+			TmpCam[1][1] = CamPosition[1][1];
+			TmpCam[1][2] = CamPosition[1][2];
+		}
+		break;
 	}
 	return(0);
 }
@@ -154,12 +151,11 @@
 
 int main(int argc, char **argv)
 {
-	
-	if (!s3d_init(&argc,&argv,"running cat"))
-	{
+
+	if (!s3d_init(&argc,&argv,"running cat")) {
 		s3d_set_callback(S3D_EVENT_KEY,keypress);
 		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-		
+
 		object = s3d_import_model_file("objs/katze_body.3ds");
 		s3d_flags_on(object, S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);

Modified: trunk/example/ptrtest.c
===================================================================
--- trunk/example/ptrtest.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/ptrtest.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * ptrtest.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -33,7 +33,9 @@
 float asp=1.0;
 float len=1.0;
 int alpha=0;
-static struct timespec t={0,10*1000*1000}; /* 100 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 100 mili seconds */
 int stop(struct s3d_evt *evt)
 {
 	s3d_quit();
@@ -48,20 +50,17 @@
 	a=(((float)alpha)*M_PI/180);
 	s3d_translate(0,sin(a)*30,0,30+cos(a)*30);
 	s3d_rotate(0,sin(a)*30,alpha,0);
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 }
 int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz->buf;
-	if (inf->object==0)
-	{
-		if (asp!=inf->scale)
-		{
+	if (inf->object==0) {
+		if (asp!=inf->scale) {
 			asp=inf->scale;
 			printf("screen aspect: %f\n",asp);
-			if (asp>1.0) /* wide screen */
-			{
+			if (asp>1.0) { /* wide screen */
 				bottom=-1.0;
 				left=-asp;
 			} else {  /* high screen */
@@ -70,8 +69,7 @@
 			}
 		}
 	}
-	if (inf->object==1)
-	{ /* of course, a link s3d_link(o,1 would be much easier ... */
+	if (inf->object==1) { /* of course, a link s3d_link(o,1 would be much easier ... */
 		s3d_translate(o,(inf->trans_x)*2.0,(inf->trans_y)*2.0,-2);
 	}
 	return(0);
@@ -88,15 +86,14 @@
 	s3d_translate(o,0,0,-2);
 	s3d_scale(o,0.2);
 	s3d_link(o,0);			/* link to cam */
-/*	s3d_link(o,1);*/
+	/*	s3d_link(o,1);*/
 	s3d_flags_on(o,S3D_OF_VISIBLE);
 	return(0);
 }
 int main (int argc, char **argv)
 {
 	i=0;
-	if (!s3d_init(&argc,&argv,"ptr and cam test"))	
-	{
+	if (!s3d_init(&argc,&argv,"ptr and cam test")) {
 		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
 		s3d_set_callback(S3D_EVENT_MBUTTON,mbutton_press);
 		s3d_set_callback(S3D_EVENT_QUIT,stop);
@@ -105,11 +102,11 @@
 		o=s3d_draw_string("hello",&len);
 		s3d_translate(o,0,0,-2);
 		s3d_link(o,0);			/* link to cam */
-/*		s3d_link(o,1);*/
+		/*		s3d_link(o,1);*/
 		s3d_scale(o,0.2);
 		s3d_flags_on(o,S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/example/radius_test.c
===================================================================
--- trunk/example/radius_test.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/radius_test.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * radius_test.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -24,7 +24,9 @@
 #include <s3d.h>
 #include <stdio.h>  /*  NULL */
 #include <time.h>	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
 
 #include <math.h>	/* sin(), cos() */
 int item1, item2, item3;
@@ -35,40 +37,39 @@
 	f=sin((M_PI*(i%360))/180.0);
 	g=cos((M_PI*(i%360))/180.0);
 	h=sin((M_PI*((3*i)%360))/180.0);
-	
+
 	s3d_translate(item1,f*10,h*2, g*5);
 	s3d_rotate(item1,0,i%360,0);
-/*	s3d_scale(item1,h+3,h+3,h+3);*/
+	/*	s3d_scale(item1,h+3,h+3,h+3);*/
 
-/*	s3d_translate(item2,f*10,0, g*5);*/
+	/*	s3d_translate(item2,f*10,0, g*5);*/
 	s3d_translate(item2,0,0,10);
-/*	s3d_rotate(item2,i%360,0,-i%360);
-	s3d_scale(item2,2*f+5,2*f+5,2*f+5);*/
+	/*	s3d_rotate(item2,i%360,0,-i%360);
+		s3d_scale(item2,2*f+5,2*f+5,2*f+5);*/
 
 	s3d_translate(item3,0,0,10);
-/*	s3d_rotate(item3,((8*i)%360),0,-((8*i)%360));
-	s3d_scale(item3,2*f+5,2*f+5,2*f+5);*/
+	/*	s3d_rotate(item3,((8*i)%360),0,-((8*i)%360));
+		s3d_scale(item3,2*f+5,2*f+5,2*f+5);*/
 
-	
 
+
 	i++;
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 }
 int main (int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"radius test"))	
-	{
+	if (!s3d_init(&argc,&argv,"radius test")) {
 		item1=s3d_import_model_file("objs/cubeyholes.3ds");
 		item2=s3d_import_model_file("objs/folder.3ds");
 		s3d_select_font("vera");
 		item3=s3d_draw_string("radius test",NULL);
 		s3d_link(item2,item1);
 		s3d_link(item3,item2);
-	    s3d_flags_on(item1,S3D_OF_VISIBLE);
-	    s3d_flags_on(item2,S3D_OF_VISIBLE);
-	    s3d_flags_on(item3,S3D_OF_VISIBLE);
+		s3d_flags_on(item1,S3D_OF_VISIBLE);
+		s3d_flags_on(item2,S3D_OF_VISIBLE);
+		s3d_flags_on(item3,S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
-			 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/example/s3dclock.c
===================================================================
--- trunk/example/s3dclock.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/s3dclock.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * s3dclock.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -26,7 +26,9 @@
 #include <stdio.h>  /*  NULL, sprintf() */
 #include <time.h>	 /*  nanosleep(), struct tm, time_t...  */
 #include <string.h>  /*  strlen() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+static struct timespec t= {
+	0,100*1000*1000
+}; /* 100 mili seconds */
 int big_p,lil_p,bg,sec_p;
 int str_oid=-1, o_str_oid;
 struct tm *mytime;
@@ -42,10 +44,9 @@
 {
 	onow=now;
 	now=time(NULL);
-	if (now!=onow)
-	{
+	if (now!=onow) {
 		o_str_oid=str_oid;
-		mytime=localtime(&now);	
+		mytime=localtime(&now);
 		s3d_rotate(lil_p,0,0,-((mytime->tm_hour%12)/12.0)*360.0);
 		s3d_rotate(big_p,0,0,-(mytime->tm_min/60.0)*360.0);
 		s3d_rotate(sec_p,0,0,-(mytime->tm_sec/60.0)*360.0);
@@ -57,14 +58,13 @@
 		if (str_oid!=-1)
 			s3d_del_object(o_str_oid);
 	}
-/* 	printf("now it's %s\n",time_str); */
-	nanosleep(&t,NULL); 
+	/* 	printf("now it's %s\n",time_str); */
+	nanosleep(&t,NULL);
 
 }
 int main (int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"clock"))	
-	{
+	if (!s3d_init(&argc,&argv,"clock")) {
 		lil_p=s3d_import_model_file("objs/lil_p.3ds");
 		big_p=s3d_import_model_file("objs/big_p.3ds");
 		sec_p=s3d_import_model_file("objs/sec_p.3ds");
@@ -79,7 +79,7 @@
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
 		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
 		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/example/snowman.c
===================================================================
--- trunk/example/snowman.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/snowman.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * snowman.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -24,7 +24,9 @@
 #include <s3d.h>
 #include <math.h>	/* sin() */
 #include <time.h>	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
 
 int a;
 int oid_head;
@@ -43,24 +45,23 @@
 	s3d_translate(oid_head,		0,1.5 +2.00*pos,0);
 	s3d_translate(oid_middle,	0,0   +1.25*pos,0);
 	s3d_translate(oid_foot,		0,-2  +1.00*pos,0);
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 }
 int main(int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"snowman"))
-	{
-			
+	if (!s3d_init(&argc,&argv,"snowman")) {
+
 		oid_head=s3d_import_model_file("objs/snow_head.3ds");
 		oid_middle=s3d_import_model_file("objs/snow_body.3ds");
 		oid_foot=s3d_import_model_file("objs/snow_foot.3ds");
 
-/*		s3d_link(oid_foot,oid_head);
- *		s3d_link(oid_middle,oid_head);
- *		s3d_translate(oid_head,0,4,0);
-		
- *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
- *		s3d_translate(oid_foot,0,-3.5,0); */
-		
+		/*		s3d_link(oid_foot,oid_head);
+		 *		s3d_link(oid_middle,oid_head);
+		 *		s3d_translate(oid_head,0,4,0);
+
+		 *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
+		 *		s3d_translate(oid_foot,0,-3.5,0); */
+
 		s3d_scale(oid_middle,1.25);
 		s3d_scale(oid_foot,1.5);
 

Modified: trunk/example/strtest.c
===================================================================
--- trunk/example/strtest.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/strtest.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * strtest.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -34,7 +34,7 @@
 
 void mainloop()
 {
-/* 	printf("now it's %s\n",time_str); */
+	/* 	printf("now it's %s\n",time_str); */
 	sleep(1);
 
 }
@@ -42,20 +42,19 @@
 {
 	char c[256];
 	int i;
-	if (!s3d_init(&argc,&argv,"strtest"))	
-	{
+	if (!s3d_init(&argc,&argv,"strtest")) {
 		s3d_select_font("vera");
-/*		o=s3d_draw_string("The lazy fox is bored enough to jump over everything it sees. weird, isn't it?!",NULL);  */
+		/*		o=s3d_draw_string("The lazy fox is bored enough to jump over everything it sees. weird, isn't it?!",NULL);  */
 		for (i=0;i<256;i++)
 			c[255-i]=i;
 		o=s3d_draw_string(c,NULL);
-/*		o=s3d_draw_string("A",NULL);*/
+		/*		o=s3d_draw_string("A",NULL);*/
 		s3d_flags_on(o,S3D_OF_VISIBLE);
 
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
 		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
 		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/example/texturetest.c
===================================================================
--- trunk/example/texturetest.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/texturetest.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * texturetest.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -26,14 +26,16 @@
 #include <stdio.h>  /*  NULL */
 #include <stdlib.h>  /* malloc(),free() */
 #include <time.h>	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+static struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
 
 int i,oid;
 void mainloop()
 {
 	i=(i+1)%360;
 	s3d_rotate(oid,0,i,0);
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 }
 #define MAXX	300
 #define MAXY	300
@@ -41,9 +43,8 @@
 {
 	unsigned int x,y;
 	unsigned char *data;
-						
-	if (!s3d_init(&argc,&argv,"texturetest"))	
-	{
+
+	if (!s3d_init(&argc,&argv,"texturetest")) {
 		data=malloc(MAXX*MAXY*4);
 		oid=s3d_new_object();
 		s3d_push_vertex(oid,-1,-1,0);
@@ -51,35 +52,34 @@
 		s3d_push_vertex(oid, 1, 1,0);
 		s3d_push_vertex(oid,-1, 1,0);
 		s3d_push_material_a(oid,
-						0.8,	0.0,	0.0	,1.0,
-						1.0,	1.0,	1.0	,1.0,
-						0.8,	0.0,	0.0	,1.0);
+		                    0.8,	0.0,	0.0	,1.0,
+		                    1.0,	1.0,	1.0	,1.0,
+		                    0.8,	0.0,	0.0	,1.0);
 		s3d_push_polygon(oid,0,1,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
-									   1.0,0.0,
-									   1.0,1.0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,0.0,
+		                          1.0,0.0,
+		                          1.0,1.0);
 		s3d_push_polygon(oid,0,2,3,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
-									   1.0,1.0,
-									   0.0,1.0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,0.0,
+		                          1.0,1.0,
+		                          0.0,1.0);
 		s3d_translate(oid,0,0,5);
 		for (y=0;y<MAXY;y++)
-			for (x=0;x<MAXX;x++)
-			{
+			for (x=0;x<MAXX;x++) {
 				data[(y*MAXX+x)*4+0]=(char)((x*255)/MAXX);
 				data[(y*MAXX+x)*4+1]=((x*y)/(MAXX*MAXY));
 				data[(y*MAXX+x)*4+2]=((y*255)/MAXX);
 				data[(y*MAXX+x)*4+3]=255;
 			}
-		s3d_push_texture(oid,MAXX,MAXY);		
+		s3d_push_texture(oid,MAXX,MAXY);
 		s3d_load_texture(oid,0,0,0,MAXX,MAXY,data);
-					 /*  push data on texture 0 position (0,0) */
+		/*  push data on texture 0 position (0,0) */
 		free(data);
 		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
 		s3d_flags_on(oid,S3D_OF_VISIBLE);
 		i=0;
 		s3d_mainloop(mainloop);
-			 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/example/widgets.c
===================================================================
--- trunk/example/widgets.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/widgets.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * widgets.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -33,12 +33,14 @@
 
 s3dw_surface *surface;
 s3dw_input *input;
-static struct timespec t={0,33*1000*1000}; /* 33 mili seconds */
+static struct timespec t= {
+	0,33*1000*1000
+}; /* 33 mili seconds */
 void mainloop()
 {
 	/* keep this in your mainloop. this will do smooth animations for you ... */
 	s3dw_ani_mate();
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 }
 /* you should always put the s3dw-handler in your own event handler,
  * if you want s3dw to react on clicks or keys ... and i'm sure you
@@ -57,13 +59,12 @@
 	char string[8];
 	s3dw_surface *miniwin;
 	s3dw_button  *button;
-	
+
 	s3dw_handle_key(evt);
-	/* okay, that's a little bit insane ... ;) 
+	/* okay, that's a little bit insane ... ;)
 	 * we create some little windows with the actual key pressed. */
 
-	if (key->unicode!=0)
-	{
+	if (key->unicode!=0) {
 		miniwin=s3dw_surface_new("Key",6,6);
 		sprintf(string,"%c",key->unicode);
 		s3dw_label_new(miniwin,string,1,2);
@@ -93,13 +94,13 @@
 
 	/* delete the old surface with it subwidgets */
 	s3dw_delete(S3DWIDGET(surface));
-	
+
 	/* and create a new one ... */
 	surface=s3dw_surface_new("Ah!",10,7);
-	
+
 	/* just cutting the string if it's too long */
 	if (strlen(age)>8) age[8]=0;
-	
+
 	/* assemble the string ..*/
 	sprintf(string,"I see, %s!!",age);
 
@@ -107,12 +108,12 @@
 	button=s3dw_button_new(surface,"Great",4,4);
 	/* clicking on the button will exit ... */
 	button->onclick=done_button;
-	
+
 	/* of couse, show it */
 	s3dw_show(S3DWIDGET(surface));
 
 	/* we don't need it anymore. always free strings, don't leak around */
-	free(age); 
+	free(age);
 }
 void no_button(s3dw_widget *dummy)
 {
@@ -122,10 +123,10 @@
 	s3dw_label_new(surface,"If you don't want to tell me ...",1,2);
 	button=s3dw_button_new(surface,"Bye",4,4);
 	/* clicking on the button will exit ... */
-	
+
 	button->onclick=done_button;
 	/* of couse, show it */
-	
+
 	s3dw_show(S3DWIDGET(surface));
 }
 char *text="okay\nn2\n3\nfooobarfooobar ...\noh no\n its too loooong\n";
@@ -133,20 +134,19 @@
 {
 	s3dw_button *button;
 	s3dw_textbox *textbox;
-	if (!s3d_init(&argc,&argv,"widgettest"))
-	{
+	if (!s3d_init(&argc,&argv,"widgettest")) {
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,click);
 		s3d_set_callback(S3D_EVENT_KEY,key);
 		s3d_set_callback(S3D_EVENT_OBJ_INFO,s3dw_object_info);
 		/* this creates the "window" */
 		surface=s3dw_surface_new("Hello World",20,20);
-		
+
 		/* put a label (which is simply text) at position x=1, y=2 */
 		s3dw_label_new(surface,"How old are you?",1,2);
 
 		/* put an input box right below. we grab the pointer because we want to focus it (need for reference) */
 		input=s3dw_input_new(surface,8,1,4);
-		
+
 		/* we want the input-field be focused on our widget */
 		s3dw_focus(S3DWIDGET(input));
 

Modified: trunk/example/wiresphere.c
===================================================================
--- trunk/example/wiresphere.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/example/wiresphere.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * wiresphere.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,7 +27,9 @@
 #include <time.h>	/* nanosleep()  */
 #include <math.h>	/* M_PI, cos(), sin() */
 #include <stdlib.h>	/* malloc(), free() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+static struct timespec t= {
+	0,100*1000*1000
+}; /* 100 mili seconds */
 int oid;
 int r;
 int wire_sphere(int slices, int stacks)
@@ -56,8 +58,7 @@
 	i=0;
 	for (x=0;x<slices;x++) {
 		for (y=0;y<stacks;y++) {
-			if ((y!=0) && (y!=stacks)) /* no horizontal lines at the poles */
-			{
+			if ((y!=0) && (y!=stacks)) { /* no horizontal lines at the poles */
 				l[i*3+0]=(x*(stacks+1))+y;
 				l[i*3+1]=(((x+1)%slices)*(stacks+1))+y;
 				l[i*3+2]=0;
@@ -86,9 +87,9 @@
 		}
 	}
 	o=s3d_new_object();
-	s3d_push_material(o,0,0,1, 
-						1,0,0, 
-						0,1,0);
+	s3d_push_material(o,0,0,1,
+	                  1,0,0,
+	                  0,1,0);
 	s3d_push_vertices(o,v,num_v);
 	s3d_push_lines(o,l,num_l);
 	s3d_load_line_normals(o,n,0,num_l);
@@ -106,20 +107,19 @@
 {
 	r=(r+1)%360;
 	s3d_rotate(oid,0,r,0);
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 
 }
 int main (int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"wiresphere"))	
-	{
+	if (!s3d_init(&argc,&argv,"wiresphere")) {
 		oid=wire_sphere(30,30);
 		s3d_scale(oid,10);
 		s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
 		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
 		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
+		/*  wait for some object to be clicked */
 		s3d_quit();
 	}
 	return(0);

Modified: trunk/libs3d/callback.c
===================================================================
--- trunk/libs3d/callback.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/callback.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -29,26 +29,26 @@
 /* i know it's ugly, but it's better to have ugly code somewhere than provoke
  * race conditions in the applications code */
 s3d_cb s3d_cb_list[MAX_CB]={
-			NULL,_s3d_ignore,_s3d_ignore,_s3d_ignore, _s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			_s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			_s3d_ignore,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,_s3d_ignore,_s3d_ignore,_s3d_ignore, _s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	_s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	_s3d_ignore,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
 
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
 
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
 
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL
-			};
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL
+};
 /* the ignore-handler ;) */
 static int _s3d_ignore(struct s3d_evt *S3DUNUSED(evt))
 {

Modified: trunk/libs3d/config.h
===================================================================
--- trunk/libs3d/config.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/config.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

Modified: trunk/libs3d/error.c
===================================================================
--- trunk/libs3d/error.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/error.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -29,41 +29,43 @@
 #include <string.h> 	 /*  sterror */
 /*  s3dprintf is only for internal use. */
 #ifdef DEBUG
-void s3dprintf(int relevance, const char *fmt, ...) {
+void s3dprintf(int relevance, const char *fmt, ...)
+{
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance >= DEBUG )
-	{
+	if (relevance >= DEBUG ) {
 		va_start(args,fmt);
 		vsnprintf((char *)&dbm,DBM_MAX,fmt,args);
 		va_end(args);
-	
+
 		fprintf(stderr,"s3dlib: %s\n",(char *)&dbm);
 	}
 }
-void errdn(int relevance, char *func,int en) {
+void errdn(int relevance, char *func,int en)
+{
 	if (relevance >= DEBUG )
-		 fprintf(stderr,"s3dlib error: %s: (%d) %s\n",func,en, strerror(en));
+		fprintf(stderr,"s3dlib error: %s: (%d) %s\n",func,en, strerror(en));
 }
 
 void errds(int relevance,char *func, const char *fmt, ...)
 {
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance >= DEBUG )
-	{
+	if (relevance >= DEBUG ) {
 		va_start(args,fmt);
 		vsnprintf((char *)&dbm,DBM_MAX,fmt,args);
 		va_end(args);
-	
+
 		fprintf(stderr,"s3dlib error: %s:%s\n",func,(char *)&dbm);
 	}
 }
 #endif
-void errn(char *func,int en) {
+void errn(char *func,int en)
+{
 	fprintf(stderr,"s3dlib error: %s: (%d) %s\n",func,en, strerror(en));
 }
-void errs(char *func, char *msg) {
+void errs(char *func, char *msg)
+{
 	fprintf(stderr,"s3dlib error: %s: %s\n",func,msg);
 }
 

Modified: trunk/libs3d/event.c
===================================================================
--- trunk/libs3d/event.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/event.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,44 +35,37 @@
 	s3d_cb cb;
 
 	s3dprintf(VLOW,"pushed event %d, cb_lock = %d",newevt->event, cb_lock);
-	 /*  this will always be called for S3D_EVENT_NEW_OBJECT!! */
-	if (newevt->event==S3D_EVENT_NEW_OBJECT)
-	{
-		_queue_new_object(*((unsigned int *)newevt->buf));	
+	/*  this will always be called for S3D_EVENT_NEW_OBJECT!! */
+	if (newevt->event==S3D_EVENT_NEW_OBJECT) {
+		_queue_new_object(*((unsigned int *)newevt->buf));
 	}
-	if (cb_lock==0)  /*  no recursive event-callbacks, please! */
-	{	
-		if (NULL!=(cb=s3d_get_callback(newevt->event)))
-		{
+	if (cb_lock==0) { /*  no recursive event-callbacks, please! */
+		if (NULL!=(cb=s3d_get_callback(newevt->event))) {
 			cb_lock++;		 /*  on our way! lock it.. */
 			cb(newevt);		 /*  .. and call it! */
 			cb_lock--;
-							 /* okay, no new callbacks, unlock now. */
+			/* okay, no new callbacks, unlock now. */
 			free(newevt);
 			return;
 		}
 	}
 	newevt->next=NULL;
-	if (s3d_stack!=NULL)
-	{
+	if (s3d_stack!=NULL) {
 		for (p=s3d_stack;p->next!=NULL;p=p->next);  /*  go to the end */
 		p->next=newevt;
 	} else
 		s3d_stack=newevt;
 }
-struct s3d_evt *s3d_pop_event()
-{
+struct s3d_evt *s3d_pop_event() {
 	struct s3d_evt *ret;
 	if ((ret=s3d_stack)!=NULL)
 		s3d_stack=s3d_stack->next;
 	return ret;
 }
-struct s3d_evt *s3d_find_event(uint8_t event)
-{
+struct s3d_evt *s3d_find_event(uint8_t event) {
 	struct s3d_evt *p;
 	p=s3d_stack;
-	while (p!=NULL)
-	{
+	while (p!=NULL) {
 		if (p->event==event)
 			return(p);
 		p=p->next;
@@ -83,20 +76,18 @@
 {
 	struct s3d_evt *previous=NULL;
 	struct s3d_evt *p=s3d_stack;
-	while (p!=NULL)
-	{
-		 /* if ((p->event==devt->event) && (p->length==devt->length)) */
-		 /* 	if (0==memcmp(p->buf,devt->buf)) */
-		if (p==devt)
-			{
-				if (p->length>0) 
-					free(p->buf);
-				if (previous==NULL) 
-					s3d_stack=p->next;  /*  the first element!! */
-				else
-					previous->next=p->next;  /*  unlink */
-				free(p);
-			}
+	while (p!=NULL) {
+		/* if ((p->event==devt->event) && (p->length==devt->length)) */
+		/* 	if (0==memcmp(p->buf,devt->buf)) */
+		if (p==devt) {
+			if (p->length>0)
+				free(p->buf);
+			if (previous==NULL)
+				s3d_stack=p->next;  /*  the first element!! */
+			else
+				previous->next=p->next;  /*  unlink */
+			free(p);
+		}
 		previous=p;
 		p=p->next;
 	}
@@ -107,9 +98,8 @@
 {
 	struct s3d_evt *p;
 	s3d_cb cb;
-	if (cb_lock>0) /* can't do that now. */
-	{
-		
+	if (cb_lock>0) { /* can't do that now. */
+
 		s3dprintf(VLOW,"cb_lock = %d, processing later",cb_lock);
 		return;
 	}
@@ -121,11 +111,11 @@
 			cb_lock--;
 		} else {
 			/* kick out unprocessed event */
-			
+
 		}
-		 /*  free */
-		if (p->length>0) 
+		/*  free */
+		if (p->length>0)
 			free(p->buf);
-		free(p);	
+		free(p);
 	}
 }

Modified: trunk/libs3d/fontselect.c
===================================================================
--- trunk/libs3d/fontselect.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/fontselect.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -41,28 +41,29 @@
 #ifdef WITH_FONTCONFIG
 char *s3d_findfont(char *mask)
 {
-  FcPattern *pattern = 0, *match = 0;
-  FcChar8 *file = 0;
-  FcResult result;
+	FcPattern *pattern = 0, *match = 0;
+	FcChar8 *file = 0;
+	FcResult result;
 
-  pattern = FcNameParse((FcChar8 *)mask);
-  FcConfigSubstitute(0,pattern,FcMatchPattern);
-  FcDefaultSubstitute(pattern);
-  s3dprintf(LOW,"Looking for font %s",mask);
+	pattern = FcNameParse((FcChar8 *)mask);
+	FcConfigSubstitute(0,pattern,FcMatchPattern);
+	FcDefaultSubstitute(pattern);
+	s3dprintf(LOW,"Looking for font %s",mask);
 
-  if (!(match=FcFontMatch(0,pattern,&result))) 
-	return NULL;
-  if (FcPatternGetString(match,FC_FILE,0,&file)!=FcResultMatch)
-	return NULL;
-  return (char *)file;
+	if (!(match=FcFontMatch(0,pattern,&result)))
+		return NULL;
+	if (FcPatternGetString(match,FC_FILE,0,&file)!=FcResultMatch)
+		return NULL;
+	return (char *)file;
 }
-#else 
+#else
 /*  this uses the xserver to get a font-path and scan it for ttf-fonts. */
 /*  if it matches, give it out ... it's not nice, right, and might not */
 /*  work on your place. */
 char *s3d_findfont(char *mask)
 {
-    char **flist = NULL; int fnum = 0;
+	char **flist = NULL;
+	int fnum = 0;
 	char *disp=NULL;
 	int n;
 	char *fname;
@@ -71,44 +72,35 @@
 	Display *dpy;
 
 	dpy = XOpenDisplay(disp);  /*  Open display and check for success */
-	if (dpy == NULL) 
-	  errds(VHIGH, "s3d_findfont()","unable to open display %s", XDisplayName (disp));
-	else 
-	{
-		if (!(flist = XGetFontPath (dpy, &fnum)))
-		{
-		    errds(VHIGH, "s3d_findfont():XGetFontPath()","unable to get font path.");
-		}
-		else 
-		while (fnum--)
-		{
-			 /*  now scan the directories	 */
-    		n =  scandir(flist[fnum], &namelist, 0, alphasort);
-        	while(n-->0) 
-			{
-				fname=namelist[n]->d_name;
-				if (strlen(fname)>(strlen(mask)+3))  /*  there should be enough space for the .ttf ending */
-				{
-					 /*  check for the first n characters */
-					if (0==strncasecmp(fname,mask,strlen(mask)))
-					{
-						 /*  name matches! now check for the end... */
-						if (0==strncasecmp(fname+(strlen(fname)-3),"ttf",3)) /*  check if it has a ttf-ending */
-						{
-							if (good==NULL)
-								good=malloc(256);
-							strncpy(good,flist[fnum],255);
-							good[256]=0; 									/* just in case */
-							strncat(good,fname,255-strlen(good));
-							if ((strlen(mask)+4)==strlen(fname))
-							{
-								return(good);
+	if (dpy == NULL)
+		errds(VHIGH, "s3d_findfont()","unable to open display %s", XDisplayName (disp));
+	else {
+		if (!(flist = XGetFontPath (dpy, &fnum))) {
+			errds(VHIGH, "s3d_findfont():XGetFontPath()","unable to get font path.");
+		} else
+			while (fnum--) {
+				/*  now scan the directories	 */
+				n =  scandir(flist[fnum], &namelist, 0, alphasort);
+				while (n-->0) {
+					fname=namelist[n]->d_name;
+					if (strlen(fname)>(strlen(mask)+3)) { /*  there should be enough space for the .ttf ending */
+						/*  check for the first n characters */
+						if (0==strncasecmp(fname,mask,strlen(mask))) {
+							/*  name matches! now check for the end... */
+							if (0==strncasecmp(fname+(strlen(fname)-3),"ttf",3)) { /*  check if it has a ttf-ending */
+								if (good==NULL)
+									good=malloc(256);
+								strncpy(good,flist[fnum],255);
+								good[256]=0; 									/* just in case */
+								strncat(good,fname,255-strlen(good));
+								if ((strlen(mask)+4)==strlen(fname)) {
+									return(good);
+								}
 							}
 						}
 					}
 				}
 			}
-		}
 		XCloseDisplay (dpy);
 	}
 	return(good);

Modified: trunk/libs3d/freetype.c
===================================================================
--- trunk/libs3d/freetype.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/freetype.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -31,24 +31,23 @@
 #include <string.h>			/*  strncmp(), strncpy() */
 #include "ft2build.h"
 #include FT_FREETYPE_H
-#undef __FTERRORS_H__                
-#define FT_ERRORDEF( e, v, s )  { e, s },                    
-#define FT_ERROR_START_LIST     {                           
-#define FT_ERROR_END_LIST       { 0, 0 } };                
-                                                          
-const struct 
-{                                                       
-    int          err_code;                             
-    const char*  err_msg;
-} ft_errors[] = 
-                                                              
-#include FT_ERRORS_H                                         
+#undef __FTERRORS_H__
+#define FT_ERRORDEF( e, v, s )  { e, s },
+#define FT_ERROR_START_LIST     {
+#define FT_ERROR_END_LIST       { 0, 0 } };
 
-#ifndef CALLBACK 
+const struct {
+	int          err_code;
+	const char*  err_msg;
+} ft_errors[] =
+
+#include FT_ERRORS_H
+
+#ifndef CALLBACK
 #define CALLBACK
 #endif
-/*  bad global vars ... */
-static FT_Library 	library;
+        /*  bad global vars ... */
+        static FT_Library 	library;
 static FT_Face		face;
 static char *memory_font=NULL;		 /*  the font file in memory */
 static char oldfontpath[256];
@@ -70,9 +69,8 @@
 	oldfontpath[0]=0;
 	if (error)
 		return (-1);
-    ft_init=1;
-	for (i=0; i<256;i++)
-	{
+	ft_init=1;
+	for (i=0; i<256;i++) {
 		tess_buf[i].vbuf=NULL;
 		tess_buf[i].pbuf=NULL;
 	}
@@ -83,15 +81,13 @@
 int s3d_ft_load_font()
 {
 	FT_Error error;
-	if ((memory_font==NULL) || (memory_font_size==0))
-	{
+	if ((memory_font==NULL) || (memory_font_size==0)) {
 		errds(HIGH,"s3d_ft_load_font()","there is no font in memory, breaking");
 		return(-1);
 	}
 	face_init=0;
 	error= FT_New_Memory_Face(library,(uint8_t *)memory_font,memory_font_size,0,&face);
-	if (error)
-	{
+	if (error) {
 		errds(VHIGH,"s3d_ft_load_font():FT_New_Memory_Face","can't load font : (%d) %s",ft_errors[error].err_code,ft_errors[error].err_msg);
 		return(-1);
 	}
@@ -104,13 +100,11 @@
 {
 	int i;
 
-	for (i=0; i<256;i++)
-	{
+	for (i=0; i<256;i++) {
 		if (tess_buf[i].vbuf!=NULL) free(tess_buf[i].vbuf);
 		if (tess_buf[i].pbuf!=NULL) free(tess_buf[i].pbuf);
 	}
-	for (i=0; i<256;i++)
-	{
+	for (i=0; i<256;i++) {
 		tess_buf[i].vbuf=NULL;
 		tess_buf[i].pbuf=NULL;
 	}
@@ -136,35 +130,31 @@
 	double vertices[SEI_SS+1][2];
 	double nvertices[SEI_SS+1][2];
 	FT_Error error;
-	
+
 	error= FT_Load_Char(face,a, FT_LOAD_NO_BITMAP|FT_LOAD_NO_SCALE);
-	if (error)
-	{
-		
+	if (error) {
+
 		errds(VHIGH,"_s3d_add_tessbuf():FT_Load_Char()","can't load character %d : (%d) %s",a,ft_errors[error].err_code,ft_errors[error].err_msg);
 		return(-1);
-	} 
+	}
 	s3dprintf(VLOW,"[T]riangulating character %c",a);
 	norm=1.0/face->glyph->metrics.vertAdvance;
 	ch=a;
 	v_off=0;
-	if ((face->glyph->outline.n_points>0) && (face->glyph->outline.n_points<SEI_SS))
-	{
+	if ((face->glyph->outline.n_points>0) && (face->glyph->outline.n_points<SEI_SS)) {
 		tess_buf[a].vn=face->glyph->outline.n_points;
 		tess_buf[a].vbuf=malloc(sizeof(float)*face->glyph->outline.n_points*3);
-		
+
 		j=0;
 		ncontours=face->glyph->outline.n_contours;
-		for (c=0;c<ncontours;c++)
-		{
+		for (c=0;c<ncontours;c++) {
 			start=j; 	/* first point */
 			i=0;
 			ncon=face->glyph->outline.contours[c]; /* position of the end of ths contour */
 			cntr[c]=ncon-j+1;					   /* how many points do we have here? */
 			csta[c]=j+1;
 			ar=0.0f;
-			while (j<(ncon+1))
-			{
+			while (j<(ncon+1)) {
 				/* vertices have reverse order in seidels algorithm, outer contours go anticlockwise, inner contours clockwise */
 				/* calculate the area */
 				k=((j+2-csta[c])%(cntr[c]))+csta[c]-1;
@@ -181,44 +171,38 @@
 			s3dprintf(VLOW,"contour %d has area of %3.3f, cntr is %d, contour starts at %d, ncon %d",c,ar,cntr[c], csta[c], ncon);
 			area[c]=ar; /* save the area */
 		}
-		/* now as we have the areas and sizes of the contours, we need to order our contours so that 
+		/* now as we have the areas and sizes of the contours, we need to order our contours so that
 		 * the outlines and their holes are grouped together */
 		n=ncontours;
 		for (i=0;i<n;i++)
 			perm[i]=i; /* initialise permutation */
-		while (n!=0)
-		{
+		while (n!=0) {
 			outl=-1;
 			/* find an outline */
 			for (i=0;i<n;i++)
-				if (area[perm[i]]>0)
-				{
+				if (area[perm[i]]>0) {
 					outl=i; /* found. that was easy ;) */
 					break;
 				}
-			if (outl==-1)
-			{
+			if (outl==-1) {
 				s3dprintf(HIGH,"hole without outline found, exiting ... %c",a);
 				return(-1);
 			}
-			for (i=0;i<n;i++)
-			{
-				if (area[perm[i]]<0)
-				{
+			for (i=0;i<n;i++) {
+				if (area[perm[i]]<0) {
 					/* test for a hole inside by taking one (the first) point of the hole and doing the test */
 					xa=vertices[csta[perm[i]]][0];
 					ya=vertices[csta[perm[i]]][1];
 					s=csta[perm[outl]];							/* start point of outline */
 					e=(csta[perm[outl]]+cntr[perm[outl]])-1;		/* end point */
 					ar=0;
-					for (j=s;j<e;j++)
-					{ /* for all points of the outline, sum: */
+					for (j=s;j<e;j++) { /* for all points of the outline, sum: */
 						ar+=atan2((vertices[j+1][1]-ya)*(vertices[j][0]-xa)-(vertices[j+1][0]-xa)*(vertices[j][1]-ya),
-								  (vertices[j+1][0]-xa)*(vertices[j][0]-xa)+(vertices[j+1][1]-ya)*(vertices[j][1]-ya));
+						          (vertices[j+1][0]-xa)*(vertices[j][0]-xa)+(vertices[j+1][1]-ya)*(vertices[j][1]-ya));
 					}
 					/* dont forget the start/end-point connection*/
 					ar+=atan2((vertices[s][1]-ya)*(vertices[e][0]-xa)-(vertices[s][0]-xa)*(vertices[e][1]-ya),
-							  (vertices[s][0]-xa)*(vertices[e][0]-xa)+(vertices[s][1]-ya)*(vertices[e][1]-ya));
+					          (vertices[s][0]-xa)*(vertices[e][0]-xa)+(vertices[s][1]-ya)*(vertices[e][1]-ya));
 					if (fabsf(ar)>1)						/* if ar = 0.0, it's outside, elseway it's a multiple of pi. this check should be
 															 * very generous to roundoff errors */
 					{
@@ -242,11 +226,9 @@
 		}
 		/* finished the permutation, now apply the new order .... */
 		n=1;
-		for (c=0;c<ncontours;c++)
-		{
+		for (c=0;c<ncontours;c++) {
 			ncsta[c]=n-1;
-			for (j=csta[perm[c]];j<(csta[perm[c]]+cntr[perm[c]]);j++)
-			{
+			for (j=csta[perm[c]];j<(csta[perm[c]]+cntr[perm[c]]);j++) {
 				nvertices[n][0]=vertices[j][0];
 				nvertices[n][1]=vertices[j][1];
 				tess_buf[a].vbuf[(n-1)*3]	=nvertices[n][0];
@@ -257,17 +239,14 @@
 			ncntr[c]=cntr[perm[c]];
 		}
 		n=0;
-		tess_buf[a].pbuf=malloc(sizeof(uint32_t)*4*(face->glyph->outline.n_points+2*face->glyph->outline.n_contours)); 
+		tess_buf[a].pbuf=malloc(sizeof(uint32_t)*4*(face->glyph->outline.n_points+2*face->glyph->outline.n_contours));
 		k=0;
-		for (c=ncontours-1;c>=0;c--)
-		{
+		for (c=ncontours-1;c>=0;c--) {
 			n++;				 /* count out and inlines ... */
-			if (area[perm[c]]>0) /* outline? start! */
-			{
+			if (area[perm[c]]>0) { /* outline? start! */
 				s3dprintf(VLOW,"[T]riangulation from outline %d (%d contours, area = %f)",perm[c],n,area[perm[c]]);
 				np=sei_triangulate_polygon(n, ncntr+c, nvertices+(ncsta[c]), triangles);
-				for (i=0;i<np;i++)
-				{
+				for (i=0;i<np;i++) {
 					tess_buf[a].pbuf[k*4]=  triangles[i][0]+ncsta[c]-1;
 					tess_buf[a].pbuf[k*4+1]=triangles[i][2]+ncsta[c]-1;
 					tess_buf[a].pbuf[k*4+2]=triangles[i][1]+ncsta[c]-1;
@@ -293,31 +272,29 @@
 		_s3d_add_tessbuf(a);
 	/* only draw if it has some information in it */
 	if ((tess_buf[a].pn != 0) && (tess_buf[a].vn != 0)) {
-	
+
 		vbuf=malloc(sizeof(float)*3*tess_buf[a].vn);
 		pbuf=malloc(sizeof(uint32_t)*4*tess_buf[a].pn);
 		memcpy(vbuf,tess_buf[a].vbuf,sizeof(float)*3*tess_buf[a].vn);
 		memcpy(pbuf,tess_buf[a].pbuf,sizeof(uint32_t)*4*tess_buf[a].pn);
-		 /*  prepare the buffs ... */
-	/* 	s3dprintf(LOW,"drawing [%c] (%d vertices, %d polys",a,tess_buf[a].vn,tess_buf[a].pn); */
-		for (i=0;i<tess_buf[a].vn;i++)
-		{
+		/*  prepare the buffs ... */
+		/* 	s3dprintf(LOW,"drawing [%c] (%d vertices, %d polys",a,tess_buf[a].vn,tess_buf[a].pn); */
+		for (i=0;i<tess_buf[a].vn;i++) {
 			vbuf[i*3]+=*xoff;
-	/*		s3dprintf(LOW,"vertex [%c:%d] %f %f %f",a,i,
-							vbuf[i*3],
-							vbuf[i*3+1],
-							vbuf[i*3+2]);*/
+			/*		s3dprintf(LOW,"vertex [%c:%d] %f %f %f",a,i,
+									vbuf[i*3],
+									vbuf[i*3+1],
+									vbuf[i*3+2]);*/
 		}
-		for (i=0;i<tess_buf[a].pn;i++)
-		{
+		for (i=0;i<tess_buf[a].pn;i++) {
 			pbuf[i*4]+=*voff;
 			pbuf[i*4+1]+=*voff;
 			pbuf[i*4+2]+=*voff;
-	/*		s3dprintf(LOW,"poly [%c:%d] %d %d %d | %d (voff %d)",a,i,
-							pbuf[i*4],
-							pbuf[i*4+1],
-							pbuf[i*4+2],
-							pbuf[i*4+3],*voff);*/
+			/*		s3dprintf(LOW,"poly [%c:%d] %d %d %d | %d (voff %d)",a,i,
+									pbuf[i*4],
+									pbuf[i*4+1],
+									pbuf[i*4+2],
+									pbuf[i*4+3],*voff);*/
 		}
 		s3dprintf(VLOW,"commiting %d vertices, %d polygons",tess_buf[a].vn,tess_buf[a].pn);
 		s3d_push_vertices(oid,vbuf,tess_buf[a].vn);
@@ -336,26 +313,21 @@
 	char *c;
 	char **p;
 	if (!ft_init)
-		if (s3d_ft_init())
-		{
+		if (s3d_ft_init()) {
 			errds(VHIGH,"s3d_select_font()","error in initializtation (ft_init())");
 			return(-1);
 		}
-	if (strncmp(oldfontpath,path,256)==0)
-	{
+	if (strncmp(oldfontpath,path,256)==0) {
 		s3dprintf(VLOW,"font already %s loaded.", path);
 		return(-1);
 	}
-	 /*  yse (system-specific?!) font grabber */
-	if (((c=s3d_findfont(path))!=NULL))
-	{
+	/*  yse (system-specific?!) font grabber */
+	if (((c=s3d_findfont(path))!=NULL)) {
 		s3dprintf(LOW,"Loading Font %s ... ",c);
 		_s3d_clear_tessbuf(); /* free and clear the tessbuf */
 		p=&memory_font;
-		if ((memory_font_size=s3d_open_file(c,p))>0)
-		{
-			if (!s3d_ft_load_font())
-			{	/* success */
+		if ((memory_font_size=s3d_open_file(c,p))>0) {
+			if (!s3d_ft_load_font()) {	/* success */
 				if (oldfont!=NULL)				free(oldfont);
 				strncpy(oldfontpath,path,256);
 				return(0);
@@ -379,59 +351,55 @@
 	int len;
 	uint32_t f_oid;
 	if (!ft_init)
-		if (s3d_ft_init())
-		{
+		if (s3d_ft_init()) {
 			errds(VHIGH,"s3d_draw_string()","error in initializtation (ft_init())");
 			return(-1);
 		}
-	if (!face_init)
-	{
+	if (!face_init) {
 		errds(VHIGH,"s3d_draw_string()","no font to draw with");
 		return(-1);
 	}
-	f_oid=s3d_new_object(); 
-	 /*  standard material */
+	f_oid=s3d_new_object();
+	/*  standard material */
 	s3d_push_material(f_oid,1.0,1.0,1.0,		1.0,1.0,1.0,	1.0,1.0,1.0);
 	xoff=0;
-	voff=0; 
+	voff=0;
 	len=strlen(str);
 	for (i=0;i<len; i++)
 		_s3d_draw_tessbuf(f_oid,(uint8_t )str[i],&voff,&xoff);
-	 /*  s3d_ft_quit(); */
+	/*  s3d_ft_quit(); */
 	if (xlen!=NULL) *xlen=xoff;
 	return(f_oid);
 }
 /* get the string length before actually drawing it. */
-float s3d_strlen( char *str) {
+float s3d_strlen( char *str)
+{
 	int i;
 	float xoff;
 	int voff;
 	int len;
 	uint16_t a;
 	if (!ft_init)
-		if (s3d_ft_init())
-		{
+		if (s3d_ft_init()) {
 			errds(VHIGH,"s3d_draw_string()","error in initializtation (ft_init())");
 			return(0.0);
 		}
-	if (!face_init)
-	{
+	if (!face_init) {
 		errds(VHIGH,"s3d_draw_string()","no font to draw with");
 		return(0.0);
 	}
-	 /*  standard material */
+	/*  standard material */
 	xoff=0;
-	voff=0; 
+	voff=0;
 	len=strlen(str);
-	for (i=0;i<len; i++)
-	{
+	for (i=0;i<len; i++) {
 		a=(uint8_t )str[i];
 		if (!(tess_buf[a].vbuf && tess_buf[a].pbuf))
 			_s3d_add_tessbuf(a);
 		xoff+=tess_buf[a].xoff;  /*  xoffset */
 	}
 	return(xoff);
-	
+
 }
 int s3d_ft_quit()
 {

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/io.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -49,7 +49,7 @@
 #endif
 #include <netinet/in.h>  /*  htons(),htonl() */
 #ifndef WIN32
-	#include <netdb.h>		 /*  gethostbyname()  */
+#include <netdb.h>		 /*  gethostbyname()  */
 #endif
 
 static char				*url=NULL;
@@ -77,25 +77,18 @@
 {
 	char				 c;
 	int					 lopt_idx;
-	struct option long_options[] =
-	{
-		{"s3d-url",1,0,0},
-		{"help",0,0,'h'},
-		{"s3d-help",0,0,'h'},
-		{0,0,0,0}
+	struct option long_options[] = {
+		{"s3d-url",1,0,0
+		}, {"help",0,0,'h'}, {"s3d-help",0,0,'h'}, {0,0,0,0}
 	};
 	if ((argc==NULL) || (argv==NULL)) return(0); /* nothing to parse */
 	optind=0;
 	opterr=0;	/* we don't want to be bothered if there is some error */
-	while (-1!=(c=getopt_long(*argc,*argv,"?h",long_options,&lopt_idx)))
-	{
-		switch (c)
-		{
+	while (-1!=(c=getopt_long(*argc,*argv,"?h",long_options,&lopt_idx))) {
+		switch (c) {
 		case 0:
-			if (0==strcmp(long_options[lopt_idx].name,"s3d-url"))
-			{
-				if (optarg)
-				{
+			if (0==strcmp(long_options[lopt_idx].name,"s3d-url")) {
+				if (optarg) {
 					url=optarg;
 					s3dprintf(HIGH,"connecting to %s",url);
 				}
@@ -112,8 +105,7 @@
 		}
 	}
 	optind=0;
-	if (*argc>0)
-	{
+	if (*argc>0) {
 		*argc-=(optind-1); 				 /*  hide s3d-options */
 		(*argv)[optind-1]=(*argv)[0]; 	 /*  restore program path */
 		*argv+=(optind-1); 				 /*  set the string pointer at the right position */
@@ -127,21 +119,20 @@
 	char 				 urlc[256];		 /*  this should be enough for an url */
 	char 				 buf[258]; 		 /*  server buffer */
 	int					 i;
-	struct timespec		 t={0,10*1000*1000}; /* 10 mili second */
+	struct timespec		 t= {
+		0,10*1000*1000
+	}; /* 10 mili second */
 
 	cb_lock=1;	/* don't bother while initiating ... is set to 0 after INIT packet received. */
-	if (NULL!=(s=getenv("S3D")))
-	{
+	if (NULL!=(s=getenv("S3D"))) {
 		s3dprintf(VLOW,"at least we have the enviroment variable ... %s",s);
 		url=s;
 	}
 	parse_args(argc,argv);
-	if (url==NULL) /* no url specified or obtained through arguments */
-	{
+	if (url==NULL) { /* no url specified or obtained through arguments */
 		/* trying standard ways to connect */
 		strncpy(urlc,"s3d:///tmp/.s3d:shm/",256);
-		if (s3d_net_init(urlc)==CON_NULL)
-		{
+		if (s3d_net_init(urlc)==CON_NULL) {
 			strncpy(urlc,"s3d://127.0.0.1:6066/",256);
 			if (s3d_net_init(urlc)==CON_NULL)
 				return(-1);
@@ -149,12 +140,11 @@
 	} else {
 		strncpy(urlc,url,256);	 /*  this should keep buffer overflows away, maybe */
 		urlc[256]=0;			 /*  just to make sure */
-		if (!strncmp(urlc, "s3d:// ",6))
-		{
+		if (!strncmp(urlc, "s3d:// ",6)) {
 			if (s3d_net_init(urlc)==CON_NULL) return(-1);
 		} else {
 			errs("s3d_init()","invalid url");
-			  return(-1);
+			return(-1);
 		}
 	}
 	strncpy(buf,name,256);  /*  copy the name ... */
@@ -162,14 +152,14 @@
 
 	_queue_init();
 #ifdef SIGS
-    if (signal(SIGINT, (sig_t)sigint_handler) == SIG_ERR)
+	if (signal(SIGINT, (sig_t)sigint_handler) == SIG_ERR)
 		errdn(LOW,"s3d_init():signal()",errno);
-    if (signal(SIGTERM, (sig_t)sigint_handler) == SIG_ERR)
+	if (signal(SIGTERM, (sig_t)sigint_handler) == SIG_ERR)
 		errdn(LOW,"s3d_init():signal()",errno);
 #endif
 	for (i=0;i<100;i++) {
 		s3d_net_check(); /* wait for init packet */
-		nanosleep(&t,NULL); 
+		nanosleep(&t,NULL);
 		if (_s3d_ready) {
 			cb_lock--;
 			return(0);
@@ -183,13 +173,16 @@
 	struct s3d_evt *ret;
 	if (con_type!=CON_NULL && _s3d_ready) {
 		net_send(S3D_P_C_QUIT,NULL,0);
-		switch (con_type)
-		{
+		switch (con_type) {
 #ifdef TCP
-			case CON_TCP:_tcp_quit();break;
+		case CON_TCP:
+			_tcp_quit();
+			break;
 #endif
 #ifdef SHM
-			case CON_SHM:_shm_quit();break;
+		case CON_SHM:
+			_shm_quit();
+			break;
 #endif
 		}
 		con_type=CON_NULL;
@@ -207,13 +200,12 @@
 /*  apps should use that as main loop for their programs. */
 int s3d_mainloop(void (*f)())
 {
-	while (con_type!=CON_NULL)
-	{
+	while (con_type!=CON_NULL) {
 		cb_lock++;			/* no callbacks while we are in mainloop */
 		if (f!=NULL)	f();
 		cb_lock--;
 		s3d_process_stack();
-		s3d_net_check(); 	/* get any other packets we might have missed */	
+		s3d_net_check(); 	/* get any other packets we might have missed */
 	}
 	return(0);
 }
@@ -226,23 +218,26 @@
 	int filesize;
 	struct stat bf;
 	*pointer=NULL;
-/*	if ((fp = fopen(fname, "rt")) == NULL)
-	{ errn("s3d_open_file():fopen()",errno); return(0);}
-	if (fseek(fp, 0, SEEK_END) != 0)
-	{ errn("s3d_open_file():fseek()",errno); return(0);}
-	if ((filesize = (int)ftell(fp)) == (long)-1)
-	{ errn("s3d_open_file():ftell()",errno); return(0);}
-	if (fseek(fp, 0, SEEK_SET) != 0)
-	{ errn("s3d_open_file():fseek()",errno); return(0);}*/
+	/*	if ((fp = fopen(fname, "rt")) == NULL)
+		{ errn("s3d_open_file():fopen()",errno); return(0);}
+		if (fseek(fp, 0, SEEK_END) != 0)
+		{ errn("s3d_open_file():fseek()",errno); return(0);}
+		if ((filesize = (int)ftell(fp)) == (long)-1)
+		{ errn("s3d_open_file():ftell()",errno); return(0);}
+		if (fseek(fp, 0, SEEK_SET) != 0)
+		{ errn("s3d_open_file():fseek()",errno); return(0);}*/
 
-	if ((fp = fopen(fname, "rt")) == NULL)
-	{ errdn(VLOW,"s3d_open_file():fopen()",errno); return(-1);}
-	if (fstat(fileno(fp),&bf))
-	{ errdn(VLOW,"s3d_open_file():fstat()",errno); return(-1);}
+	if ((fp = fopen(fname, "rt")) == NULL) {
+		errdn(VLOW,"s3d_open_file():fopen()",errno);
+		return(-1);
+	}
+	if (fstat(fileno(fp),&bf)) {
+		errdn(VLOW,"s3d_open_file():fstat()",errno);
+		return(-1);
+	}
 	filesize=bf.st_size;
-/*	s3dprintf(LOW, "opening %s, filesize is %d",fname, filesize);*/
-	if ((buf=malloc(filesize))==NULL)
-	{
+	/*	s3dprintf(LOW, "opening %s, filesize is %d",fname, filesize);*/
+	if ((buf=malloc(filesize))==NULL) {
 		errn("s3d_open_3ds_file():malloc()",errno);
 		exit(-1);
 	}

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/modelread.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -57,21 +57,17 @@
 	strncpy(searchpath,OBJSDIR,1023);
 	searchpath[1023]=0;							/* just in case */
 	next=ptr=searchpath;
-	while (next!=NULL)
-	{
+	while (next!=NULL) {
 		next=NULL;
 
-		if (NULL!=(next=strchr(ptr,':')))
-		{
+		if (NULL!=(next=strchr(ptr,':'))) {
 			*next=0; 							/* clear the delimiter */
 			next+=1;							/* move to the beginner of the next dir */
 		}
-		if ((strlen(ptr)+strlen(fname))<1024) 	/* only try if this fits */
-		{
+		if ((strlen(ptr)+strlen(fname))<1024) {	/* only try if this fits */
 			strcpy(path,ptr); 					/* can use "unsafe" functions because size was verified above */
 			strcat(path,fname);
-			if (s3d_open_file(path,&buf)!=-1)  /* found something */
-			{
+			if (s3d_open_file(path,&buf)!=-1) { /* found something */
 				free(buf); /* TODO: badbadbad ... */
 				if (-1!=(oid=model_load(path))) return(oid);
 
@@ -84,7 +80,8 @@
 	return(-1); /* nothing in search path ... */
 }
 
-void *get_mat2tex( struct material2texture **mat2tex, void *mat_ptr ) {
+void *get_mat2tex( struct material2texture **mat2tex, void *mat_ptr )
+{
 
 	while ( (*mat2tex) != NULL ) {
 
@@ -175,8 +172,8 @@
 
 				if ( mat2tex->material_id == -1 ) { /* create a new texture if nothing found */
 					s3d_push_material_a( obj_id, 	face->material->r, face->material->g, face->material->b,face->material->a,
-													face->material->specular[0], face->material->specular[1], face->material->specular[2], face->material->specular[3],
-													face->material->r, face->material->g, face->material->b, face->material->a );
+					                     face->material->specular[0], face->material->specular[1], face->material->specular[2], face->material->specular[3],
+					                     face->material->r, face->material->g, face->material->b, face->material->a );
 
 					mat2tex->material_id = material_count;
 					material_count++;
@@ -211,8 +208,7 @@
 
 					}
 				}
-				if (face->flags != oldflags || npoly>=PMAX)
-				{
+				if (face->flags != oldflags || npoly>=PMAX) {
 					/* push things so far */
 					s3d_push_polygons(obj_id, polybuf, npoly);
 					if (oldflags & G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
@@ -238,8 +234,7 @@
 					normalbuf[ npoly*9 + 7] = -face->normals[ 5 ];
 					normalbuf[ npoly*9 + 8] =  face->normals[ 4 ];
 				}
-				if ( face->flags & G3D_FLAG_FAC_TEXMAP )
-				{
+				if ( face->flags & G3D_FLAG_FAC_TEXMAP ) {
 					texcoordbuf[ npoly*6 + 0] = face->tex_vertex_data[ 0 ];
 					texcoordbuf[ npoly*6 + 1] = face->tex_vertex_data[ 1 ];
 					texcoordbuf[ npoly*6 + 2] = face->tex_vertex_data[ 4 ];
@@ -251,8 +246,7 @@
 				oface = oface->next;
 			}
 			/* push the last packets in buffer */
-			if (npoly > 0)
-			{
+			if (npoly > 0) {
 				s3d_push_polygons(obj_id, polybuf, npoly);
 				if (oldflags & G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
 				if (oldflags & G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);

Modified: trunk/libs3d/network.c
===================================================================
--- trunk/libs3d/network.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/network.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -40,20 +40,23 @@
 int net_send(u_int8_t opcode, char *buf, u_int16_t length)
 {
 	char *ptr;
-/* 	char *buff; */
+	/* 	char *buff; */
 	char buff[65539];  /*  u_int16_t really shouldn't be bigger ;) */
-	*(buff)=opcode; 
+	*(buff)=opcode;
 	ptr=buff+1;
 	*((u_int16_t *) ptr)=htons(length);
 	if (length!=0)
 		memcpy(buff+3,buf,length);
-	switch (con_type)
-	{
+	switch (con_type) {
 #ifdef SHM
-		case CON_SHM:shm_writen(buff,length+3);break;
+	case CON_SHM:
+		shm_writen(buff,length+3);
+		break;
 #endif
-#ifdef TCP		
-		case CON_TCP:tcp_writen(buff,length+3);break;
+#ifdef TCP
+	case CON_TCP:
+		tcp_writen(buff,length+3);
+		break;
 #endif
 	}
 	return(0);
@@ -68,25 +71,23 @@
 #endif
 int s3d_net_check()
 {
-	switch (con_type)
-	{
+	switch (con_type) {
 #ifdef TCP
-		case CON_TCP:
+	case CON_TCP:
 #ifdef SIGS
-		if (_s3d_sigio)
-		{
+		if (_s3d_sigio) {
 #endif
 			while (_s3d_net_receive());
 #ifdef SIGS
 			_s3d_sigio=0;
-		}	
+		}
 #endif
-			break;
+		break;
 #endif
 #ifdef SHM
-		case CON_SHM:
-			while(_shm_net_receive());
-			break;
+	case CON_SHM:
+		while (_shm_net_receive());
+		break;
 #endif
 	}
 	s3d_process_stack();
@@ -101,21 +102,18 @@
 #endif
 	int					 tcp,shm;
 	tcp=shm=1; /* everything is possible, yet */
-	
-	 /*  doing a very bad server/port extraction, but I think it'll work ... */
+
+	/*  doing a very bad server/port extraction, but I think it'll work ... */
 	s=sv=urlc+6;  /*  getting to the "real" thing */
-	 /* while (((*s!='/') && (*s!=0)) && (s<(urlc-6))) */
-	while (*s!=0)
-	{
-		if (*s=='/')
-		{
+	/* while (((*s!='/') && (*s!=0)) && (s<(urlc-6))) */
+	while (*s!=0) {
+		if (*s=='/') {
 			if (first_slash==NULL)
 				first_slash=s;
 			if (port!=NULL)
 				break;
 		}
-		if (*s==':')  /*  there is a port in here */
-		{
+		if (*s==':') { /*  there is a port in here */
 			port=s+1;
 			*s=0;	 /*  NULL the port  */
 		}
@@ -123,42 +121,36 @@
 	}
 
 	*s=0;
-	if (port==NULL)
-	{
+	if (port==NULL) {
 		shm=0;
 		if (first_slash!=NULL)
 			*first_slash=0;
 	} else {
 		if (first_slash<port)
 			tcp=0;
-		else 
+		else
 			if (first_slash!=NULL)
 				*first_slash=0;
-		if (!strncmp(port, "shm",3))
-		{
+		if (!strncmp(port, "shm",3)) {
 			tcp=0; /* null the others */
 		} else {
 			shm=0;
 		}
 	}
 #ifdef SHM
-	if (shm)
-	{
+	if (shm) {
 		if (!strncmp(port, "shm",3))
 			if (!_shm_init(sv)) return(con_type=CON_SHM);
 	}
 #endif
 #ifdef TCP
-	if (tcp)
-	{
+	if (tcp) {
 		pn=6066;
-		if (port!=NULL)
-		{
-			if (!(pn=atoi(port)))  /*  I hope atoi is safe enough. */
-			{
+		if (port!=NULL) {
+			if (!(pn=atoi(port))) { /*  I hope atoi is safe enough. */
 				errn("s3d_init():atoi()",errno);
 				pn=6066;
-			} 
+			}
 		}
 		if (!_tcp_init(sv,pn)) return(con_type=CON_TCP);
 	}

Modified: trunk/libs3d/object_queue.c
===================================================================
--- trunk/libs3d/object_queue.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/object_queue.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -24,7 +24,7 @@
 
 #include "s3d.h"
 #include "s3dlib.h"
-#include "proto.h"	 
+#include "proto.h"
 #include <stdlib.h>	 /*  malloc(),free(), realloc() */
 
 #ifndef _POSIX_C_SOURCE
@@ -44,8 +44,10 @@
 static unsigned int *queue;			 	/*  the object id's */
 static int queue_size=0;			 	/*  the size of the object queue */
 static int requested;				 	/*  counter of how many addtional */
-									 	/*  objects have been requested */
-static struct timespec t={0,10*1000};	/* 10 micro seconds */
+/*  objects have been requested */
+static struct timespec t= {
+	0,10*1000
+};	/* 10 micro seconds */
 /*  initializes the object queue */
 int _queue_init()
 {
@@ -53,8 +55,7 @@
 	queue_size=1;
 	requested=0;
 	queue=malloc(sizeof(unsigned int)*queue_size);
-	for (i=0;i<queue_size;i++)
-	{
+	for (i=0;i<queue_size;i++) {
 		queue[i]=Q_UNUSED;
 	}
 	_queue_fill();
@@ -73,18 +74,17 @@
 int _queue_new_object(unsigned int oid)
 {
 	int i;
-/* 	s3dprintf(LOW,"having a new object (%d) in the queue!!",oid); */
+	/* 	s3dprintf(LOW,"having a new object (%d) in the queue!!",oid); */
 	for (i=0;i<queue_size;i++)
-		if (queue[i]==Q_UNUSED)
-		{
-/* 			s3dprintf(LOW,"placing it at position %d",i); */
+		if (queue[i]==Q_UNUSED) {
+			/* 			s3dprintf(LOW,"placing it at position %d",i); */
 			queue[i]=oid;
 			requested--;
 			return(0);
 		}
 	if (queue_size==0) return(-1);  /*  already quit. */
-	 /*  if we reach here, all slots all taken.  */
-/* 	s3dprintf(LOW,"no place for object, resizing stack.",i); */
+	/*  if we reach here, all slots all taken.  */
+	/* 	s3dprintf(LOW,"no place for object, resizing stack.",i); */
 	queue=realloc(queue,sizeof(unsigned int)*(queue_size+1));
 	queue_size+=1;
 	requested--;
@@ -99,34 +99,31 @@
 	j=0;
 	do {
 		for (i=0;i<queue_size;i++)
-			if (queue[i]!=Q_UNUSED)
-			{
+			if (queue[i]!=Q_UNUSED) {
 				ret=queue[i];
 				queue[i]=Q_UNUSED;
 				net_send(S3D_P_C_NEW_OBJ,NULL,0);  /*  we already can request a new one. */
 				return(ret);
 			}
-		 /*  if we reach this point, our queue is empty. */
-		 /*  as other request should have sent S3D_P_C_NEW_OBJ-requests,  */
-		 /*  we request one more object than needed to satisfy more load in future. */
+		/*  if we reach this point, our queue is empty. */
+		/*  as other request should have sent S3D_P_C_NEW_OBJ-requests,  */
+		/*  we request one more object than needed to satisfy more load in future. */
 		if (queue_size==0) return(-1);  /*  already quit. */
-		if (requested<MAX_REQ)
-		{
+		if (requested<MAX_REQ) {
 			net_send(S3D_P_C_NEW_OBJ,NULL,0);
 			requested++;
 		}
 		s3d_net_check();
-		nanosleep(&t,NULL); 
-	} while(j++<TIMEOUT);
+		nanosleep(&t,NULL);
+	} while (j++<TIMEOUT);
 
-	errds(LOW,"_queue_want_object()","timeout is reached. server is extremly slow/laggy or dead");	
+	errds(LOW,"_queue_want_object()","timeout is reached. server is extremly slow/laggy or dead");
 	return(-1);
 }
 /*  cleans up */
 int _queue_quit()
 {
-	if (queue!=NULL)
-	{
+	if (queue!=NULL) {
 		free(queue);
 		queue=NULL;
 	}

Modified: trunk/libs3d/proto_in.c
===================================================================
--- trunk/libs3d/proto_in.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/proto_in.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,142 +35,127 @@
 	struct s3d_evt *s3devt=NULL;
 	struct mcp_object *mo;
 	struct s3d_obj_info *oi;
-	switch (opcode)
-	{
-		case S3D_P_S_INIT:
-			s3dprintf(MED,"S3D_P_S_INIT: init!!");
-			_s3d_ready=1;
-			break;
-		case S3D_P_S_QUIT:
-			s3dprintf(MED,"S3D_P_S_QUIT: server wants us to go. well ...");
-			s3d_quit();
-			break;	
-		case S3D_P_S_CLICK:
-			if (length==4) 
-			{
-				oid=ntohl(*((uint32_t *)buf));
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-					*((uint32_t *)buf)=oid;  /*  reuse buffer ... */
-					s3devt->event=S3D_EVENT_OBJ_CLICK;
-					s3devt->length=4;
-					s3devt->buf=buf;
-				}
-				s3dprintf(MED,"S3D_P_S_CLICK: %d got clicked ....",oid);
+	switch (opcode) {
+	case S3D_P_S_INIT:
+		s3dprintf(MED,"S3D_P_S_INIT: init!!");
+		_s3d_ready=1;
+		break;
+	case S3D_P_S_QUIT:
+		s3dprintf(MED,"S3D_P_S_QUIT: server wants us to go. well ...");
+		s3d_quit();
+		break;
+	case S3D_P_S_CLICK:
+		if (length==4) {
+			oid=ntohl(*((uint32_t *)buf));
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+				*((uint32_t *)buf)=oid;  /*  reuse buffer ... */
+				s3devt->event=S3D_EVENT_OBJ_CLICK;
+				s3devt->length=4;
+				s3devt->buf=buf;
 			}
-			break;
-		case S3D_P_S_NEWOBJ:
-			if (length==4) 
+			s3dprintf(MED,"S3D_P_S_CLICK: %d got clicked ....",oid);
+		}
+		break;
+	case S3D_P_S_NEWOBJ:
+		if (length==4) {
+			oid=ntohl(*((uint32_t *)buf));
+			_queue_new_object(oid);
+			/*
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
 			{
-				oid=ntohl(*((uint32_t *)buf));
-				_queue_new_object(oid);	
-				/*
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * /
-					s3devt->event=S3D_EVENT_NEW_OBJECT;
-					s3devt->length=4;
-					s3devt->buf=buf;
-					_queue_new_object(*((unsigned int *)newevt->buf));	
-				}*/
-				s3dprintf(VLOW,"S3D_P_S_NEWOBJ: new object %d",oid);
+				*((uint32_t *)buf)=oid;  / *  reuse buffer ... * /
+				s3devt->event=S3D_EVENT_NEW_OBJECT;
+				s3devt->length=4;
+				s3devt->buf=buf;
+				_queue_new_object(*((unsigned int *)newevt->buf));
+			}*/
+			s3dprintf(VLOW,"S3D_P_S_NEWOBJ: new object %d",oid);
+		}
+		break;
+	case S3D_P_S_KEY:
+		if (length==8) {
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+				struct s3d_key_event *keyevent;
+				s3devt->length=2;
+				keyevent=(struct s3d_key_event *)buf;
+				keyevent->keysym=ntohs(keyevent->keysym);
+				keyevent->unicode=ntohs(keyevent->unicode);
+				keyevent->modifier=ntohs(keyevent->modifier);
+				keyevent->state=ntohs(keyevent->state);
+				s3devt->buf=buf;
+				s3devt->event=(keyevent->state==0)?S3D_EVENT_KEYDOWN:S3D_EVENT_KEYUP;
 			}
-			break;
-		case S3D_P_S_KEY:
-			if (length==8)
-			{
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-					struct s3d_key_event *keyevent;
-					s3devt->length=2;
-					keyevent=(struct s3d_key_event *)buf;
-					keyevent->keysym=ntohs(keyevent->keysym);
-					keyevent->unicode=ntohs(keyevent->unicode);
-					keyevent->modifier=ntohs(keyevent->modifier);
-					keyevent->state=ntohs(keyevent->state);
-					s3devt->buf=buf;
-					s3devt->event=(keyevent->state==0)?S3D_EVENT_KEYDOWN:S3D_EVENT_KEYUP;
-				}
-				s3dprintf(VLOW,"S3D_P_S_KEY: key %d hit!!",*((uint16_t *)s3devt->buf));
+			s3dprintf(VLOW,"S3D_P_S_KEY: key %d hit!!",*((uint16_t *)s3devt->buf));
+		}
+		break;
+	case S3D_P_S_MBUTTON:
+		if (length==2) {
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+				s3devt->event=S3D_EVENT_MBUTTON;
+				s3devt->length=2;
+				s3devt->buf=buf;
 			}
-			break;
-		case S3D_P_S_MBUTTON:
-			if (length==2)
-			{
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-					s3devt->event=S3D_EVENT_MBUTTON;
-					s3devt->length=2;
-					s3devt->buf=buf;
-				}
-				s3dprintf(VLOW,"S3D_P_S_MBUTTON: mbutton %d, state %d !!",*((uint8_t *)s3devt->buf), *(1+(uint8_t *)s3devt->buf));
-			}
-			break;
-		case S3D_P_MCP_OBJECT:
-			if (length==sizeof(struct mcp_object))
-			{
-/* 				oid=htonl(*((uint32_t *)buf)); */
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-/* 					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
-					s3devt->event=S3D_MCP_OBJECT;
-					s3devt->length=length;
-					mo=(struct mcp_object *)buf;
-					*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
+			s3dprintf(VLOW,"S3D_P_S_MBUTTON: mbutton %d, state %d !!",*((uint8_t *)s3devt->buf), *(1+(uint8_t *)s3devt->buf));
+		}
+		break;
+	case S3D_P_MCP_OBJECT:
+		if (length==sizeof(struct mcp_object)) {
+			/* 				oid=htonl(*((uint32_t *)buf)); */
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+				/* 					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
+				s3devt->event=S3D_MCP_OBJECT;
+				s3devt->length=length;
+				mo=(struct mcp_object *)buf;
+				*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
 
-					buf[length-1]='\0';  /*  put a null byte at the end  */
-										 /*  for the not so careful users */
-					s3devt->buf=buf;
-					s3dprintf(VLOW,"S3D_P_MCP_OBEJCT: something is happening to object %d, name %s", 	mo->object, mo->name);
+				buf[length-1]='\0';  /*  put a null byte at the end  */
+				/*  for the not so careful users */
+				s3devt->buf=buf;
+				s3dprintf(VLOW,"S3D_P_MCP_OBEJCT: something is happening to object %d, name %s", 	mo->object, mo->name);
 
-				}
-			} else s3dprintf(MED,"wrong length for S3D_P_MCP_OBJECT length %d != %d",length,sizeof(struct mcp_object));
-			break;
-		case S3D_P_S_OINFO:
-			if (length==sizeof(struct s3d_obj_info))
-			{
-/* 				oid=htonl(*((uint32_t *)buf)); */
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-/* 					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
-					s3devt->event=S3D_EVENT_OBJ_INFO;
-					s3devt->length=length;
-					oi=(struct s3d_obj_info *)buf;
-					oi->object	=ntohl(oi->object);
-					oi->flags	=ntohl(oi->flags);
+			}
+		} else s3dprintf(MED,"wrong length for S3D_P_MCP_OBJECT length %d != %d",length,sizeof(struct mcp_object));
+		break;
+	case S3D_P_S_OINFO:
+		if (length==sizeof(struct s3d_obj_info)) {
+			/* 				oid=htonl(*((uint32_t *)buf)); */
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+				/* 					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
+				s3devt->event=S3D_EVENT_OBJ_INFO;
+				s3devt->length=length;
+				oi=(struct s3d_obj_info *)buf;
+				oi->object	=ntohl(oi->object);
+				oi->flags	=ntohl(oi->flags);
 
-					buf[length-1]='\0';  /*  put a null byte at the end  */
-										 /*  for the not so careful users */
-					s3devt->buf=buf;
-					s3dprintf(VLOW,"S3D_P_S_OINFO: something is happening to object %d, name %s", 
-								oi->object,
-								oi->name
-								);
+				buf[length-1]='\0';  /*  put a null byte at the end  */
+				/*  for the not so careful users */
+				s3devt->buf=buf;
+				s3dprintf(VLOW,"S3D_P_S_OINFO: something is happening to object %d, name %s",
+				          oi->object,
+				          oi->name
+				         );
 
-				}
-			} else s3dprintf(MED,"wrong length for S3D_P_S_OINFO length %d != %d",length,sizeof(struct s3d_obj_info));
-			break;
+			}
+		} else s3dprintf(MED,"wrong length for S3D_P_S_OINFO length %d != %d",length,sizeof(struct s3d_obj_info));
+		break;
 
-		case S3D_P_MCP_DEL_OBJECT:
-			if (length==4)
-			{
-				if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
-				{
-					s3devt->event=S3D_MCP_DEL_OBJECT;
-					s3devt->length=length;
-					*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
-					s3dprintf(MED,"S3D_P_MCP_DEL_OBEJCT: deleting object %d",*((uint32_t *)buf));
-					s3devt->buf=buf;
-				}
+	case S3D_P_MCP_DEL_OBJECT:
+		if (length==4) {
+			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+				s3devt->event=S3D_MCP_DEL_OBJECT;
+				s3devt->length=length;
+				*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
+				s3dprintf(MED,"S3D_P_MCP_DEL_OBEJCT: deleting object %d",*((uint32_t *)buf));
+				s3devt->buf=buf;
 			}
-			break;
-		default:
-			s3dprintf(MED,"don't know command %d",opcode);
-			if (buf!=NULL) free(buf);
+		}
+		break;
+	default:
+		s3dprintf(MED,"don't know command %d",opcode);
+		if (buf!=NULL) free(buf);
 	}
-	if (s3devt!=NULL)
-	{
-			
+	if (s3devt!=NULL) {
+
 		s3d_push_event(s3devt);
 	}
 	return(0);

Modified: trunk/libs3d/proto_out.c
===================================================================
--- trunk/libs3d/proto_out.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/proto_out.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -31,9 +31,9 @@
 #include <unistd.h>		 /*  select() */
 #include <stdlib.h>		 /*  getenv(),atoi(), malloc() */
 #ifdef WIN32
-	#define uint32_t uint32_t  /*  sohn */
+#define uint32_t uint32_t  /*  sohn */
 #else
-	#include <netdb.h>		 /*  gethostbyname()  */
+#include <netdb.h>		 /*  gethostbyname()  */
 #endif
 
 #define MF_LEN	65530	 /*  maximum fragmentation length */
@@ -41,7 +41,7 @@
 int s3d_new_object()
 {
 	int oid;
-	
+
 	cb_lock++; /* please, no callbacks now. */
 	oid=_queue_want_object();
 	cb_lock--; /* no new callbacks and nothing happened */
@@ -63,7 +63,7 @@
 	buf[0]=htonl(oid);
 	buf[1]=htonl(toid);
 	net_send(S3D_P_C_CLONE,(char *)&buf,8);
-/* 	s3dprintf(MED,"... changed clone-target of object %d to %d", oid, toid); */
+	/* 	s3dprintf(MED,"... changed clone-target of object %d to %d", oid, toid); */
 	return oid;
 }
 /*  deletes an object */
@@ -100,10 +100,14 @@
 	int					len=4+3*4;
 
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=x;					ptr+=sizeof(float);
-	*((float *)ptr)=y;					ptr+=sizeof(float);
-	*((float *)ptr)=z;					ptr+=sizeof(float);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=x;
+	ptr+=sizeof(float);
+	*((float *)ptr)=y;
+	ptr+=sizeof(float);
+	*((float *)ptr)=z;
+	ptr+=sizeof(float);
 	net_send(S3D_P_C_PUSH_VERTEX, buf, len);
 	return(0);
 }
@@ -118,11 +122,11 @@
 		return(-1);
 	stepl=((int)((MF_LEN-4)/(4*3)))*(4*3);
 	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
-/* 	buf=malloc(f>1?MF_LEN:len+4); */
-	for (i=0;i<f;i++)
-	{
+	/* 	buf=malloc(f>1?MF_LEN:len+4); */
+	for (i=0;i<f;i++) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
 		if (len-i*stepl>stepl)
 			flen=stepl;
 		else
@@ -130,65 +134,91 @@
 		memcpy(ptr,(char *)vbuf+i*stepl,flen);
 		net_send(S3D_P_C_PUSH_VERTEX,buf,flen+4);
 	}
-/* 	free(buf); */
+	/* 	free(buf); */
 	return(0);
 }
 
 /*  pushes a new material onto the stack */
 /*  a vectored version of this would be wise ... */
-int s3d_push_material( int object, 
-						float amb_r, float amb_g, float amb_b,
-						float spec_r, float spec_g, float spec_b,
-						float diff_r, float diff_g, float diff_b
-						)
+int s3d_push_material( int object,
+                       float amb_r, float amb_g, float amb_b,
+                       float spec_r, float spec_g, float spec_b,
+                       float diff_r, float diff_g, float diff_b
+                     )
 {
 	char				buf[4+4*12];
 	char				*ptr;
 	int					len=4+4*12;
-/* 	s3dprintf(LOW, "adding a new material..."); */
+	/* 	s3dprintf(LOW, "adding a new material..."); */
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;				ptr+=sizeof(float);
-	*((float *)ptr)=1.0;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;				ptr+=sizeof(float);
-	*((float *)ptr)=1.0;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;				ptr+=sizeof(float);
-	*((float *)ptr)=1.0;				ptr+=sizeof(float);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=amb_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=1.0;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=1.0;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=1.0;
+	ptr+=sizeof(float);
 
 	net_send(S3D_P_C_PUSH_MAT,buf,len);
 	return(0);  /*  nothing yet */
 }
 /*  same as s3d_push_material, but with values for alpha */
-int s3d_push_material_a( int object, 
-						float amb_r, float amb_g, float amb_b, float amb_a,
-						float spec_r, float spec_g, float spec_b, float spec_a,
-						float diff_r, float diff_g, float diff_b, float diff_a
-						)
+int s3d_push_material_a( int object,
+                         float amb_r, float amb_g, float amb_b, float amb_a,
+                         float spec_r, float spec_g, float spec_b, float spec_a,
+                         float diff_r, float diff_g, float diff_b, float diff_a
+                       )
 {
 	char				buf[4+4*12];
 	char				*ptr;
 	int					len=4+4*12;
-/* 	s3dprintf(LOW, "adding a new material..."); */
+	/* 	s3dprintf(LOW, "adding a new material..."); */
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_a;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_a;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_a;				ptr+=sizeof(float);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=amb_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_a;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_a;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_a;
+	ptr+=sizeof(float);
 
 	net_send(S3D_P_C_PUSH_MAT,buf,len);
 	return(0);  /*  nothing yet */
@@ -203,11 +233,11 @@
 		return(-1);
 	stepl=((int)((MF_LEN-4)/(4*12)))*(4*12);
 	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
-/* 	buf=malloc(f>1?MF_LEN:len+4); */
-	for (i=0;i<f;i++)
-	{
+	/* 	buf=malloc(f>1?MF_LEN:len+4); */
+	for (i=0;i<f;i++) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
 		if (len-i*stepl>stepl)
 			flen=stepl;
 		else
@@ -215,7 +245,7 @@
 		memcpy(ptr,(char *)mbuf+i*stepl,flen);
 		net_send(S3D_P_C_PUSH_MAT,buf,flen+4);
 	}
-/* 	free(buf); */
+	/* 	free(buf); */
 	return(0);
 }
 int s3d_push_polygon(int object, uint32_t v1, uint32_t v2, uint32_t v3, uint32_t material)
@@ -223,11 +253,16 @@
 	char				buf[4+4*4],*ptr;
 	int					len=4+4*4;
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(v1);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v2);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v3);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(material);			ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint32_t *)ptr)=htonl(v1);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(v2);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(v3);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(material);
+	ptr+=sizeof(uint32_t);
 
 	net_send(S3D_P_C_PUSH_POLY,buf,len);
 	return(0);
@@ -237,10 +272,14 @@
 	char				buf[4+3*4],*ptr;
 	int					len=4+3*4;
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(v1);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v2);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(material);			ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint32_t *)ptr)=htonl(v1);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(v2);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(material);
+	ptr+=sizeof(uint32_t);
 
 	net_send(S3D_P_C_PUSH_LINE,buf,len);
 	return(0);
@@ -261,8 +300,7 @@
 
 	buf[0]=htonl(object);
 	d=buf+1;
-	for (i=0;i<f;i++)
-	{
+	for (i=0;i<f;i++) {
 		if (len-i*stepl>stepl)			flen=stepl;
 		else							flen=(len-i*stepl);
 
@@ -287,8 +325,7 @@
 	buf[0]=htonl(object);
 	d=buf+1;
 
-	for (i=0;i<f;i++)
-	{
+	for (i=0;i<f;i++) {
 		if (len-i*stepl>stepl)			flen=stepl;
 		else							flen=(len-i*stepl);
 
@@ -305,9 +342,11 @@
 	char				buf[4+2*2],*ptr;
 	int					len=4+2*2;
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint16_t *)ptr)=htons(w);				ptr+=sizeof(uint16_t);
-	*((uint16_t *)ptr)=htons(h);				
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint16_t *)ptr)=htons(w);
+	ptr+=sizeof(uint16_t);
+	*((uint16_t *)ptr)=htons(h);
 
 	net_send(S3D_P_C_PUSH_TEX,buf,len);
 	return(0);
@@ -327,8 +366,7 @@
 	*((uint32_t *)buf)=htonl(object);
 	d=(uint16_t *)(buf+1);
 
-	for (i=0;i<f;i++)
-	{
+	for (i=0;i<f;i++) {
 		if (len-i*stepl>stepl)			flen=stepl;
 		else							flen=(len-i*stepl);
 
@@ -349,7 +387,7 @@
 	buf[1]=htonl(n);
 	net_send(S3D_P_C_DEL_VERTEX,(char *)buf,4*2);
 	return(0);
-	
+
 }
 /*  delete n materials */
 int s3d_pop_material(int object, uint32_t n)
@@ -359,7 +397,7 @@
 	buf[1]=htonl(n);
 	net_send(S3D_P_C_DEL_MAT,(char *)buf,4*2);
 	return(0);
-	
+
 }
 /*  delete n polygons */
 int s3d_pop_polygon(int object, uint32_t n)
@@ -369,7 +407,7 @@
 	buf[1]=htonl(n);
 	net_send(S3D_P_C_DEL_POLY,(char *)buf,4*2);
 	return(0);
-	
+
 }
 /*  delete n lines */
 int s3d_pop_line(int object, uint32_t n)
@@ -379,7 +417,7 @@
 	buf[1]=htonl(n);
 	net_send(S3D_P_C_DEL_LINE,(char *)buf,4*2);
 	return(0);
-	
+
 }
 /*  delete n polygons */
 int s3d_pop_texture(int object, uint32_t n)
@@ -389,64 +427,90 @@
 	buf[1]=htonl(n);
 	net_send(S3D_P_C_DEL_TEX,(char *)buf,4*2);
 	return(0);
-	
+
 }
 /*  pepping/loading functions */
 
 /*  overwrites the last material with this one */
-int s3d_pep_material( int object, 
-						float amb_r, float amb_g, float amb_b,
-						float spec_r, float spec_g, float spec_b,
-						float diff_r, float diff_g, float diff_b
-						)
+int s3d_pep_material( int object,
+                      float amb_r, float amb_g, float amb_b,
+                      float spec_r, float spec_g, float spec_b,
+                      float diff_r, float diff_g, float diff_b
+                    )
 {
 	char				buf[4+4*12];
 	char				*ptr;
 	int					len=4+4*12;
-/* 	s3dprintf(LOW, "adding a new material..."); */
+	/* 	s3dprintf(LOW, "adding a new material..."); */
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;				ptr+=sizeof(float);
-	*((float *)ptr)=1.0;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;				ptr+=sizeof(float);
-	*((float *)ptr)=1.0;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;				ptr+=sizeof(float);
-	*((float *)ptr)=1.0;				ptr+=sizeof(float);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=amb_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=1.0;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=1.0;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=1.0;
+	ptr+=sizeof(float);
 
 	net_send(S3D_P_C_PEP_MAT,buf,len);
 	return(0);  /*  nothing yet */
 }
 /*  same as above, with alpha */
-int s3d_pep_material_a( int object, 
-						float amb_r, float amb_g, float amb_b, float amb_a,
-						float spec_r, float spec_g, float spec_b, float spec_a,
-						float diff_r, float diff_g, float diff_b, float diff_a
-						)
+int s3d_pep_material_a( int object,
+                        float amb_r, float amb_g, float amb_b, float amb_a,
+                        float spec_r, float spec_g, float spec_b, float spec_a,
+                        float diff_r, float diff_g, float diff_b, float diff_a
+                      )
 {
 	char				buf[4+4*12];
 	char				*ptr;
 	int					len=4+4*12;
-/* 	s3dprintf(LOW, "adding a new material..."); */
+	/* 	s3dprintf(LOW, "adding a new material..."); */
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;				ptr+=sizeof(float);
-	*((float *)ptr)=amb_a;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;				ptr+=sizeof(float);
-	*((float *)ptr)=spec_a;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;				ptr+=sizeof(float);
-	*((float *)ptr)=diff_a;				ptr+=sizeof(float);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=amb_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=amb_a;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=spec_a;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_r;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_g;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_b;
+	ptr+=sizeof(float);
+	*((float *)ptr)=diff_a;
+	ptr+=sizeof(float);
 
 	net_send(S3D_P_C_PEP_MAT,buf,len);
 	return(0);  /*  nothing yet */
@@ -454,8 +518,7 @@
 int s3d_pep_materials_a(int object, float *mbuf, uint16_t n)
 {
 	char				buf[MF_LEN+4];
-	if ((n*12*sizeof(float)+4)>MF_LEN)
-	{
+	if ((n*12*sizeof(float)+4)>MF_LEN) {
 		errds(MED,"s3d_pep_materials_a()","too much data");
 		return(-1);  /*  impossible */
 	}
@@ -469,8 +532,7 @@
 int s3d_pep_polygon_normals(int object, float *nbuf,uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
-	if ((n*9*sizeof(float)+4)>MF_LEN) 
-	{
+	if ((n*9*sizeof(float)+4)>MF_LEN) {
 		errds(MED,"s3d_pep_polygon_normals()","too much data");
 		return(-1);  /*  impossible */
 	}
@@ -478,14 +540,13 @@
 	memcpy(buf+4,nbuf,9*n*sizeof(float));
 	net_send(S3D_P_C_PEP_POLY_NORMAL,(char *)buf,n*9*sizeof(float)+4);
 	return(0);
-	
+
 }
 /*  adds normal information to the last n line. */
 int s3d_pep_line_normals(int object, float *nbuf,uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
-	if ((n*9*sizeof(float)+4)>MF_LEN) 
-	{
+	if ((n*9*sizeof(float)+4)>MF_LEN) {
 		errds(MED,"s3d_pep_line_normals()","too much data");
 		return(-1);  /*  impossible */
 	}
@@ -493,7 +554,7 @@
 	memcpy(buf+4,nbuf,6*n*sizeof(float));
 	net_send(S3D_P_C_PEP_LINE_NORMAL,(char *)buf,n*6*sizeof(float)+4);
 	return(0);
-	
+
 }
 /*  replaces the last vertex. */
 int s3d_pep_vertex(int object, float x, float y, float z)
@@ -502,10 +563,14 @@
 	int					len=4+3*4;
 
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=x;					ptr+=sizeof(float);
-	*((float *)ptr)=y;					ptr+=sizeof(float);
-	*((float *)ptr)=z;					ptr+=sizeof(float);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((float *)ptr)=x;
+	ptr+=sizeof(float);
+	*((float *)ptr)=y;
+	ptr+=sizeof(float);
+	*((float *)ptr)=z;
+	ptr+=sizeof(float);
 	net_send(S3D_P_C_PEP_VERTEX, buf, len);
 	return(0);
 }
@@ -515,10 +580,14 @@
 	char				buf[4+3*4],*ptr;
 	int					len=4+3*4;
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(v1);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v2);				ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(material);			ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint32_t *)ptr)=htonl(v1);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(v2);
+	ptr+=sizeof(uint32_t);
+	*((uint32_t *)ptr)=htonl(material);
+	ptr+=sizeof(uint32_t);
 
 	net_send(S3D_P_C_PEP_LINE,buf,len);
 	return(0);
@@ -530,8 +599,7 @@
 {
 	uint32_t 	buf[MF_LEN+4];
 	int				i;
-	if ((n*3*4+4)>MF_LEN) 
-	{
+	if ((n*3*4+4)>MF_LEN) {
 		errds(MED,"s3d_pep_lines()","too much data");
 		return(-1);  /*  impossible */
 	}
@@ -540,14 +608,13 @@
 		buf[i+1]=htonl(lbuf[0]);
 	net_send(S3D_P_C_PEP_LINE, (char *)buf,n*3*4+4);
 	return(0);
-	
+
 }
 /*  replaces the last n vertices. */
 int s3d_pep_vertices(int object, float *vbuf,uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
-	if ((n*3*sizeof(float)+4)>MF_LEN) 
-	{
+	if ((n*3*sizeof(float)+4)>MF_LEN) {
 		errds(MED,"s3d_pep_vertices()","too much data");
 		return(-1);  /*  impossible */
 	}
@@ -555,20 +622,27 @@
 	memcpy(buf+4,vbuf,3*n*sizeof(float));
 	net_send(S3D_P_C_PEP_VERTEX,(char *)buf,n*3*sizeof(float)+4);
 	return(0);
-	
+
 }
 /*  peps the last polygon with some texture coords */
 int s3d_pep_polygon_tex_coord(int object, float x1, float y1, float x2, float y2, float x3, float y3)
 {
 	char *ptr,buf[4*6+4];
 	ptr=buf;
-	*((uint32_t *)buf)=htonl(object);		ptr+=4;
-	*((float *)ptr)=x1;						ptr+=4;
-	*((float *)ptr)=y1;						ptr+=4;
-	*((float *)ptr)=x2;						ptr+=4;
-	*((float *)ptr)=y2;						ptr+=4;
-	*((float *)ptr)=x3;						ptr+=4;
-	*((float *)ptr)=y3;						ptr+=4;
+	*((uint32_t *)buf)=htonl(object);
+	ptr+=4;
+	*((float *)ptr)=x1;
+	ptr+=4;
+	*((float *)ptr)=y1;
+	ptr+=4;
+	*((float *)ptr)=x2;
+	ptr+=4;
+	*((float *)ptr)=y2;
+	ptr+=4;
+	*((float *)ptr)=x3;
+	ptr+=4;
+	*((float *)ptr)=y3;
+	ptr+=4;
 	net_send(S3D_P_C_PEP_POLY_TEXC,(char *)buf,6*4+4);
 	return(0);
 }
@@ -576,8 +650,7 @@
 int s3d_pep_polygon_tex_coords(int object, float *tbuf,uint16_t n)
 {
 	char buf[MF_LEN+4];
-	if ((n*6*sizeof(float))>MF_LEN) 
-	{
+	if ((n*6*sizeof(float))>MF_LEN) {
 		errds(MED,"s3d_pep_polygon_tex_coords()","too much data");
 		return(-1);  /*  impossible */
 	}
@@ -598,11 +671,12 @@
 	mstart=start;
 	stepl=((int)((MF_LEN-8)/(9*4)))*(9*4);
 	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i<f;i++)
-	{
+	for (i=0;i<f;i++) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);			ptr+=sizeof(uint32_t);		  /*  start */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(mstart);
+		ptr+=sizeof(uint32_t);		  /*  start */
 		if (len-i*stepl>stepl)
 			flen=stepl;
 		else
@@ -625,11 +699,12 @@
 	mstart=start;
 	stepl=((int)((MF_LEN-8)/(6*4)))*(6*4);
 	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i<f;i++)
-	{
+	for (i=0;i<f;i++) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);			ptr+=sizeof(uint32_t);		  /*  start */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(mstart);
+		ptr+=sizeof(uint32_t);		  /*  start */
 		if (len-i*stepl>stepl)
 			flen=stepl;
 		else
@@ -652,11 +727,12 @@
 	mstart=start;
 	stepl=((int)((MF_LEN-8)/(6*4)))*(6*4);
 	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i<f;i++)
-	{
+	for (i=0;i<f;i++) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);			ptr+=sizeof(uint32_t);		  /*  start */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(mstart);
+		ptr+=sizeof(uint32_t);		  /*  start */
 		if (len-i*stepl>stepl)
 			flen=stepl;
 		else
@@ -679,11 +755,12 @@
 	mstart=start;
 	stepl=((int)((MF_LEN-8)/(12*4)))*(12*4);
 	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i<f;i++)
-	{
+	for (i=0;i<f;i++) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);			ptr+=sizeof(uint32_t);		  /*  start */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(mstart);
+		ptr+=sizeof(uint32_t);		  /*  start */
 		if (len-i*stepl>stepl)
 			flen=stepl;
 		else
@@ -698,8 +775,10 @@
 {
 	char				buf[4*2],*ptr;
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(tex);				ptr+=sizeof(uint32_t);		 	 /*  texture index numer */
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=sizeof(uint32_t);		  /*  object id */
+	*((uint32_t *)ptr)=htonl(tex);
+	ptr+=sizeof(uint32_t);		 	 /*  texture index numer */
 	net_send(S3D_P_C_PEP_MAT_TEX,buf,8);
 	return(0);
 }
@@ -711,17 +790,22 @@
 	linestep=(MF_LEN-16)/(w*4);
 	if (linestep==0)
 		return(-1);  /*  won't do that. .. yet */
-	for (i=0;i<h;i+=linestep)
-	{
+	for (i=0;i<h;i+=linestep) {
 		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);			ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(tex);				ptr+=sizeof(uint32_t);		  /*  texture number */
-		*((uint16_t *)ptr)=htons(xpos);				ptr+=sizeof(uint16_t);		  /*  xpos */
-		*((uint16_t *)ptr)=htons(ypos+i);			ptr+=sizeof(uint16_t);		  /*  ypos */
-		*((uint16_t *)ptr)=htons(w);				ptr+=sizeof(uint16_t);		  /*  width */
+		*((uint32_t *)ptr)=htonl(object);
+		ptr+=sizeof(uint32_t);		  /*  object id */
+		*((uint32_t *)ptr)=htonl(tex);
+		ptr+=sizeof(uint32_t);		  /*  texture number */
+		*((uint16_t *)ptr)=htons(xpos);
+		ptr+=sizeof(uint16_t);		  /*  xpos */
+		*((uint16_t *)ptr)=htons(ypos+i);
+		ptr+=sizeof(uint16_t);		  /*  ypos */
+		*((uint16_t *)ptr)=htons(w);
+		ptr+=sizeof(uint16_t);		  /*  width */
 		if ((h-i)>linestep)		lines=linestep;
 		else					lines=h-i;
-		*((uint16_t *)ptr)=htons(lines);			ptr+=sizeof(uint16_t);		  /*  height */
+		*((uint16_t *)ptr)=htons(lines);
+		ptr+=sizeof(uint16_t);		  /*  height */
 		memcpy(ptr,data+(i*w*4),lines*w*4);
 		net_send(S3D_P_C_LOAD_TEX,buf,16+lines*w*4);
 	}
@@ -732,10 +816,13 @@
 	char				buf[4+1+4],*ptr;
 	int					len=4+1+4;
 	ptr=buf;
-/* 	s3dprintf(VLOW, "toggling flags on .. %010x", flags); */
-	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
-	*ptr=OF_TURN_ON;							ptr+=1;
-	*((uint32_t *)ptr)=htonl(flags);			ptr+=4;		
+	/* 	s3dprintf(VLOW, "toggling flags on .. %010x", flags); */
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=4;
+	*ptr=OF_TURN_ON;
+	ptr+=1;
+	*((uint32_t *)ptr)=htonl(flags);
+	ptr+=4;
 	net_send(S3D_P_C_TOGGLE_FLAGS,buf,len);
 	return(0);
 }
@@ -744,10 +831,13 @@
 	char				buf[4+1+4],*ptr;
 	int					len=4+1+4;
 	ptr=buf;
-/* 	s3dprintf(VLOW, "toggling flags off .. %010x", flags); */
-	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
-	*ptr=OF_TURN_OFF;							ptr+=1;
-	*((uint32_t *)ptr)=htonl(flags);			ptr+=4;		 
+	/* 	s3dprintf(VLOW, "toggling flags off .. %010x", flags); */
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=4;
+	*ptr=OF_TURN_OFF;
+	ptr+=1;
+	*((uint32_t *)ptr)=htonl(flags);
+	ptr+=4;
 	net_send(S3D_P_C_TOGGLE_FLAGS,buf,len);
 	return(0);
 }
@@ -756,10 +846,13 @@
 	char				buf[4+4*3],*ptr;
 	int					len=4+4*3;
 	ptr=buf;
-/* 	s3dprintf(VLOW, "translating object to  .. %f, %f, %f", x,y,z); */
-	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
-	*((float *)ptr)=x;							ptr+=4;
-	*((float *)ptr)=y;							ptr+=4;
+	/* 	s3dprintf(VLOW, "translating object to  .. %f, %f, %f", x,y,z); */
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=4;
+	*((float *)ptr)=x;
+	ptr+=4;
+	*((float *)ptr)=y;
+	ptr+=4;
 	*((float *)ptr)=z;
 	net_send(S3D_P_C_TRANSLATE,buf,len);
 	return(0);
@@ -771,10 +864,13 @@
 	char				buf[4+4*3],*ptr;
 	int					len=4+4*3;
 	ptr=buf;
-/* 	s3dprintf(VLOW, "rotating object to  .. %f, %f, %f", x,y,z); */
-	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
-	*((float *)ptr)=x;							ptr+=4;
-	*((float *)ptr)=y;							ptr+=4;
+	/* 	s3dprintf(VLOW, "rotating object to  .. %f, %f, %f", x,y,z); */
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=4;
+	*((float *)ptr)=x;
+	ptr+=4;
+	*((float *)ptr)=y;
+	ptr+=4;
 	*((float *)ptr)=z;
 	net_send(S3D_P_C_ROTATE,buf,len);
 	return(0);
@@ -786,8 +882,9 @@
 	char				buf[4+4],*ptr;
 	int					len=4+4;
 	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);			ptr+=4;
-	*((float *)ptr)=s;						
+	*((uint32_t *)ptr)=htonl(object);
+	ptr+=4;
+	*((float *)ptr)=s;
 	net_send(S3D_P_C_SCALE,buf,len);
 	return(0);
 }

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/s3d.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -53,16 +53,14 @@
 #define	S3D_OF_VISIBLE			0x00000001
 #define	S3D_OF_SELECTABLE		0x00000002
 #define S3D_OF_POINTABLE		0x00000004
-struct mcp_object
-{
+struct mcp_object {
 	uint32_t object;
 	float trans_x,trans_y,trans_z;
 	float r;
 #define MCP_NEW_OBJECT	1
 	char name[256];
 };
-struct s3d_obj_info
-{
+struct s3d_obj_info {
 	uint32_t object;
 	uint32_t flags;
 	float trans_x,trans_y,trans_z;
@@ -71,13 +69,11 @@
 	float r;
 	char name[256];
 };
-struct s3d_but_info
-{
+struct s3d_but_info {
 	uint8_t button; /* 0 = left, 1 = middle, 2 = right */
 	uint8_t state;  /* 0 = down, 1 = up, 2 = moving */
 };
-struct s3d_key_event
-{
+struct s3d_key_event {
 	uint16_t keysym;		/* the symbol, use this with s3d_keysym.h */
 	uint16_t unicode;		/* the unicode or "actually typed" character */
 	uint16_t modifier;	/* any modifiers involved */
@@ -97,22 +93,22 @@
 int s3d_push_vertex(int object, float x, float y, float z);
 int s3d_push_vertices(int object, float *vbuf, uint16_t n);
 int s3d_push_material( int object,
-						float amb_r, float amb_g, float amb_b,
-						float spec_r, float spec_g, float spec_b,
-						float diff_r, float diff_g, float diff_b);
+                       float amb_r, float amb_g, float amb_b,
+                       float spec_r, float spec_g, float spec_b,
+                       float diff_r, float diff_g, float diff_b);
 int s3d_pep_material( int object,
-						float amb_r, float amb_g, float amb_b,
-						float spec_r, float spec_g, float spec_b,
-						float diff_r, float diff_g, float diff_b);
+                      float amb_r, float amb_g, float amb_b,
+                      float spec_r, float spec_g, float spec_b,
+                      float diff_r, float diff_g, float diff_b);
 int s3d_push_material_a( int object,
-						float amb_r, float amb_g, float amb_b, float amb_a,
-						float spec_r, float spec_g, float spec_b, float spec_a,
-						float diff_r, float diff_g, float diff_b, float diff_a);
+                         float amb_r, float amb_g, float amb_b, float amb_a,
+                         float spec_r, float spec_g, float spec_b, float spec_a,
+                         float diff_r, float diff_g, float diff_b, float diff_a);
 int s3d_push_materials_a(int object, float *mbuf, uint16_t n);
 int s3d_pep_material_a( int object,
-						float amb_r, float amb_g, float amb_b, float amb_a,
-						float spec_r, float spec_g, float spec_b, float spec_a,
-						float diff_r, float diff_g, float diff_b, float diff_a);
+                        float amb_r, float amb_g, float amb_b, float amb_a,
+                        float spec_r, float spec_g, float spec_b, float spec_a,
+                        float diff_r, float diff_g, float diff_b, float diff_a);
 
 int s3d_pep_materials_a(int object, float *mbuf, uint16_t n);
 int s3d_load_materials_a(int object, float *mbuf, uint32_t start, uint16_t n);

Modified: trunk/libs3d/s3d_keysym.h
===================================================================
--- trunk/libs3d/s3d_keysym.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/s3d_keysym.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -6,17 +6,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -32,7 +32,7 @@
    as international virtual keycodes.  We'll follow in the footsteps of X11...
    The names of the keys
  */
- 
+
 typedef enum {
 	/* The keyboard syms have been cleverly chosen to map to ASCII */
 	S3DK_UNKNOWN		= 0,
@@ -75,7 +75,7 @@
 	S3DK_GREATER		= 62,
 	S3DK_QUESTION		= 63,
 	S3DK_AT			= 64,
-	/* 
+	/*
 	   Skip uppercase letters
 	 */
 	S3DK_LEFTBRACKET	= 91,

Modified: trunk/libs3d/s3dlib.h
===================================================================
--- trunk/libs3d/s3dlib.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/s3dlib.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -24,21 +24,21 @@
 
 #include <stdint.h>
 #include "config.h"
-#ifdef __APPLE__ 
+#ifdef __APPLE__
 #ifdef SHM
 #undef SHM
 #endif
-#endif 
+#endif
 
 #ifndef S3DUNUSED
-	#if defined(UNUSEDPARAM_ATTRIBUTE)
-		#define S3DUNUSED(x) (x)__attribute__((unused))
-	#elif defined(UNUSEDPARAM_OMIT)
-		#define S3DUNUSED(x) /* x */
-	#else
-		#define S3DUNUSED(x) x
-	#endif
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define S3DUNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define S3DUNUSED(x) /* x */
+#else
+#define S3DUNUSED(x) x
 #endif
+#endif
 
 #define VLOW	1
 #define	LOW		2
@@ -54,7 +54,7 @@
 #define TIMEOUT			100000
 #define MAX_CB			256		 /*  as much as there are callbacks */
 #ifndef NULL
-	#define NULL	0
+#define NULL	0
 #endif
 #define CON_NULL	0
 #define CON_SHM		1
@@ -76,13 +76,13 @@
 #pragma GCC visibility push(default) /* Only export following functions */
 #endif
 void s3dprintf(int relevance, const char *fmt, ...);
-void errdn(int relevance, char *func,int en); 
+void errdn(int relevance, char *func,int en);
 void errds(int relevance,char *func, const char *fmt, ...);
 #ifdef HAVE_GCCVISIBILITY
 #pragma GCC visibility pop
 #endif
 
-#else 
+#else
 static __inline__ void s3dprintf(int S3DUNUSED(relevance),
                                  const char *S3DUNUSED(fmt), ...) {}
 static __inline__ void errdn(int S3DUNUSED(relevance),
@@ -117,8 +117,7 @@
 #endif
 /* shm_ringbuf.c */
 #ifdef SHM
-struct buf_t
-{
+struct buf_t {
 	uint32_t start,end,bufsize;	/* start/end of the data */
 };
 int shm_write(struct buf_t *rb,char *buf, int n);
@@ -131,8 +130,7 @@
 int shm_readn(char *str,int s);
 #endif
 /* freetype.c */
-struct t_buf
-{
+struct t_buf {
 	float *vbuf;
 	uint32_t *pbuf;
 	int pn,vn;
@@ -140,8 +138,7 @@
 };
 
 /* tesselate.c */
-struct tessp_t
-{
+struct tessp_t {
 	int next,prev,done;
 };
 int _s3d_tesselate(struct tessp_t *t,struct t_buf *b);

Modified: trunk/libs3d/sei_construct.c
===================================================================
--- trunk/libs3d/sei_construct.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/sei_construct.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,9 +1,9 @@
 /*
  * sei_construct.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
- * for public domain: 
+ * for public domain:
  * <snip>
  *
  * This code is in the public domain. Specifically, we give to the public
@@ -20,17 +20,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -52,126 +52,118 @@
 /* Return a new node to be added into the query tree */
 static int newnode()
 {
-  if (q_idx < QSIZE)
-    return q_idx++;
-  else
-    {
-      errs("sei:newnode()","Query-table overflow");
-      return -1;
-    }
+	if (q_idx < QSIZE)
+		return q_idx++;
+	else {
+		errs("sei:newnode()","Query-table overflow");
+		return -1;
+	}
 }
 
 /* Return a free trapezoid */
 static int newtrap()
 {
-  if (tr_idx < TRSIZE)
-    {
-      tr[tr_idx].lseg = -1;
-      tr[tr_idx].rseg = -1;
-      tr[tr_idx].state = ST_VALID;
-      return tr_idx++;
-    }
-  else
-    {
-      errs("sei:newtrap()","Trapezoid-table overflow");
-      return -1;
-    }
+	if (tr_idx < TRSIZE) {
+		tr[tr_idx].lseg = -1;
+		tr[tr_idx].rseg = -1;
+		tr[tr_idx].state = ST_VALID;
+		return tr_idx++;
+	} else {
+		errs("sei:newtrap()","Trapezoid-table overflow");
+		return -1;
+	}
 }
 
 
 /* Return the maximum of the two points into the yval structure */
 static int _max(yval, v0, v1)
-     point_t *yval;
-     point_t *v0;
-     point_t *v1;
+point_t *yval;
+point_t *v0;
+point_t *v1;
 {
-  if (v0->y > v1->y + C_EPS)
-    *yval = *v0;
-  else if (FP_EQUAL(v0->y, v1->y))
-    {
-      if (v0->x > v1->x + C_EPS)
-	*yval = *v0;
-      else
-	*yval = *v1;
-    }
-  else
-    *yval = *v1;
-  
-  return 0;
+	if (v0->y > v1->y + C_EPS)
+		*yval = *v0;
+	else if (FP_EQUAL(v0->y, v1->y)) {
+		if (v0->x > v1->x + C_EPS)
+			*yval = *v0;
+		else
+			*yval = *v1;
+	} else
+		*yval = *v1;
+
+	return 0;
 }
 
 
 /* Return the minimum of the two points into the yval structure */
 static int _min(yval, v0, v1)
-     point_t *yval;
-     point_t *v0;
-     point_t *v1;
+point_t *yval;
+point_t *v0;
+point_t *v1;
 {
-  if (v0->y < v1->y - C_EPS)
-    *yval = *v0;
-  else if (FP_EQUAL(v0->y, v1->y))
-    {
-      if (v0->x < v1->x)
-	*yval = *v0;
-      else
-	*yval = *v1;
-    }
-  else
-    *yval = *v1;
-  
-  return 0;
+	if (v0->y < v1->y - C_EPS)
+		*yval = *v0;
+	else if (FP_EQUAL(v0->y, v1->y)) {
+		if (v0->x < v1->x)
+			*yval = *v0;
+		else
+			*yval = *v1;
+	} else
+		*yval = *v1;
+
+	return 0;
 }
 
 
 int _greater_than(v0, v1)
-     point_t *v0;
-     point_t *v1;
+point_t *v0;
+point_t *v1;
 {
-  if (v0->y > v1->y + C_EPS)
-    return TRUE;
-  else if (v0->y < v1->y - C_EPS)
-    return FALSE;
-  else
-    return (v0->x > v1->x);
+	if (v0->y > v1->y + C_EPS)
+		return TRUE;
+	else if (v0->y < v1->y - C_EPS)
+		return FALSE;
+	else
+		return (v0->x > v1->x);
 }
 
 
 int _equal_to(v0, v1)
-     point_t *v0;
-     point_t *v1;
+point_t *v0;
+point_t *v1;
 {
-  return (FP_EQUAL(v0->y, v1->y) && FP_EQUAL(v0->x, v1->x));
+	return (FP_EQUAL(v0->y, v1->y) && FP_EQUAL(v0->x, v1->x));
 }
 
 int _greater_than_equal_to(v0, v1)
-     point_t *v0;
-     point_t *v1;
+point_t *v0;
+point_t *v1;
 {
-  if (v0->y > v1->y + C_EPS)
-    return TRUE;
-  else if (v0->y < v1->y - C_EPS)
-    return FALSE;
-  else
-    return (v0->x >= v1->x);
+	if (v0->y > v1->y + C_EPS)
+		return TRUE;
+	else if (v0->y < v1->y - C_EPS)
+		return FALSE;
+	else
+		return (v0->x >= v1->x);
 }
 
 int _less_than(v0, v1)
-     point_t *v0;
-     point_t *v1;
+point_t *v0;
+point_t *v1;
 {
-  if (v0->y < v1->y - C_EPS)
-    return TRUE;
-  else if (v0->y > v1->y + C_EPS)
-    return FALSE;
-  else
-    return (v0->x < v1->x);
+	if (v0->y < v1->y - C_EPS)
+		return TRUE;
+	else if (v0->y > v1->y + C_EPS)
+		return FALSE;
+	else
+		return (v0->x < v1->x);
 }
 
 
-/* Initilialise the query structure (Q) and the trapezoid table (T) 
+/* Initilialise the query structure (Q) and the trapezoid table (T)
  * when the first segment is added to start the trapezoidation. The
  * query-tree starts out with 4 trapezoids, one S-node and 2 Y-nodes
- *    
+ *
  *                4
  *   -----------------------------------
  *  		  \
@@ -182,79 +174,79 @@
  */
 
 static int init_query_structure(segnum)
-     int segnum;
+int segnum;
 {
-  int i1, i2, i3, i4, i5, i6, i7, root;
-  int t1, t2, t3, t4;
-  segment_t *s = &seg[segnum];
+	int i1, i2, i3, i4, i5, i6, i7, root;
+	int t1, t2, t3, t4;
+	segment_t *s = &seg[segnum];
 
-  q_idx = tr_idx = 1;
-  memset((void *)tr, 0, sizeof(tr));
-  memset((void *)qs, 0, sizeof(qs));
+	q_idx = tr_idx = 1;
+	memset((void *)tr, 0, sizeof(tr));
+	memset((void *)qs, 0, sizeof(qs));
 
-  i1 = newnode();
-  qs[i1].nodetype = T_Y;
-  _max(&qs[i1].yval, &s->v0, &s->v1); /* root */
-  root = i1;
+	i1 = newnode();
+	qs[i1].nodetype = T_Y;
+	_max(&qs[i1].yval, &s->v0, &s->v1); /* root */
+	root = i1;
 
-  qs[i1].right = i2 = newnode();
-  qs[i2].nodetype = T_SINK;
-  qs[i2].parent = i1;
+	qs[i1].right = i2 = newnode();
+	qs[i2].nodetype = T_SINK;
+	qs[i2].parent = i1;
 
-  qs[i1].left = i3 = newnode();
-  qs[i3].nodetype = T_Y;
-  _min(&qs[i3].yval, &s->v0, &s->v1); /* root */
-  qs[i3].parent = i1;
-  
-  qs[i3].left = i4 = newnode();
-  qs[i4].nodetype = T_SINK;
-  qs[i4].parent = i3;
-  
-  qs[i3].right = i5 = newnode();
-  qs[i5].nodetype = T_X;
-  qs[i5].segnum = segnum;
-  qs[i5].parent = i3;
-  
-  qs[i5].left = i6 = newnode();
-  qs[i6].nodetype = T_SINK;
-  qs[i6].parent = i5;
+	qs[i1].left = i3 = newnode();
+	qs[i3].nodetype = T_Y;
+	_min(&qs[i3].yval, &s->v0, &s->v1); /* root */
+	qs[i3].parent = i1;
 
-  qs[i5].right = i7 = newnode();
-  qs[i7].nodetype = T_SINK;
-  qs[i7].parent = i5;
+	qs[i3].left = i4 = newnode();
+	qs[i4].nodetype = T_SINK;
+	qs[i4].parent = i3;
 
-  t1 = newtrap();		/* middle left */
-  t2 = newtrap();		/* middle right */
-  t3 = newtrap();		/* bottom-most */
-  t4 = newtrap();		/* topmost */
+	qs[i3].right = i5 = newnode();
+	qs[i5].nodetype = T_X;
+	qs[i5].segnum = segnum;
+	qs[i5].parent = i3;
 
-  tr[t1].hi = tr[t2].hi = tr[t4].lo = qs[i1].yval;
-  tr[t1].lo = tr[t2].lo = tr[t3].hi = qs[i3].yval;
-  tr[t4].hi.y = (double) (INFINITY);
-  tr[t4].hi.x = (double) (INFINITY);
-  tr[t3].lo.y = (double) -1* (INFINITY);
-  tr[t3].lo.x = (double) -1* (INFINITY);
-  tr[t1].rseg = tr[t2].lseg = segnum;
-  tr[t1].u0 = tr[t2].u0 = t4;
-  tr[t1].d0 = tr[t2].d0 = t3;
-  tr[t4].d0 = tr[t3].u0 = t1;
-  tr[t4].d1 = tr[t3].u1 = t2;
-  
-  tr[t1].sink = i6;
-  tr[t2].sink = i7;
-  tr[t3].sink = i4;
-  tr[t4].sink = i2;
+	qs[i5].left = i6 = newnode();
+	qs[i6].nodetype = T_SINK;
+	qs[i6].parent = i5;
 
-  tr[t1].state = tr[t2].state = ST_VALID;
-  tr[t3].state = tr[t4].state = ST_VALID;
+	qs[i5].right = i7 = newnode();
+	qs[i7].nodetype = T_SINK;
+	qs[i7].parent = i5;
 
-  qs[i2].trnum = t4;
-  qs[i4].trnum = t3;
-  qs[i6].trnum = t1;
-  qs[i7].trnum = t2;
+	t1 = newtrap();		/* middle left */
+	t2 = newtrap();		/* middle right */
+	t3 = newtrap();		/* bottom-most */
+	t4 = newtrap();		/* topmost */
 
-  s->is_inserted = TRUE;
-  return root;
+	tr[t1].hi = tr[t2].hi = tr[t4].lo = qs[i1].yval;
+	tr[t1].lo = tr[t2].lo = tr[t3].hi = qs[i3].yval;
+	tr[t4].hi.y = (double) (INFINITY);
+	tr[t4].hi.x = (double) (INFINITY);
+	tr[t3].lo.y = (double) -1* (INFINITY);
+	tr[t3].lo.x = (double) -1* (INFINITY);
+	tr[t1].rseg = tr[t2].lseg = segnum;
+	tr[t1].u0 = tr[t2].u0 = t4;
+	tr[t1].d0 = tr[t2].d0 = t3;
+	tr[t4].d0 = tr[t3].u0 = t1;
+	tr[t4].d1 = tr[t3].u1 = t2;
+
+	tr[t1].sink = i6;
+	tr[t2].sink = i7;
+	tr[t3].sink = i4;
+	tr[t4].sink = i2;
+
+	tr[t1].state = tr[t2].state = ST_VALID;
+	tr[t3].state = tr[t4].state = ST_VALID;
+
+	qs[i2].trnum = t4;
+	qs[i4].trnum = t3;
+	qs[i6].trnum = t1;
+	qs[i7].trnum = t2;
+
+	s->is_inserted = TRUE;
+	return root;
 }
 
 
@@ -264,55 +256,44 @@
  */
 
 static int is_left_of(segnum, v)
-     int segnum;
-     point_t *v;
+int segnum;
+point_t *v;
 {
-  segment_t *s = &seg[segnum];
-  double area;
-  
-  if (_greater_than(&s->v1, &s->v0)) /* seg. going upwards */
-    {
-      if (FP_EQUAL(s->v1.y, v->y))
-	{
-	  if (v->x < s->v1.x)
-	    area = 1.0;
-	  else
-	    area = -1.0;
+	segment_t *s = &seg[segnum];
+	double area;
+
+	if (_greater_than(&s->v1, &s->v0)) { /* seg. going upwards */
+		if (FP_EQUAL(s->v1.y, v->y)) {
+			if (v->x < s->v1.x)
+				area = 1.0;
+			else
+				area = -1.0;
+		} else if (FP_EQUAL(s->v0.y, v->y)) {
+			if (v->x < s->v0.x)
+				area = 1.0;
+			else
+				area = -1.0;
+		} else
+			area = CROSS(s->v0, s->v1, (*v));
+	} else {			/* v0 > v1 */
+		if (FP_EQUAL(s->v1.y, v->y)) {
+			if (v->x < s->v1.x)
+				area = 1.0;
+			else
+				area = -1.0;
+		} else if (FP_EQUAL(s->v0.y, v->y)) {
+			if (v->x < s->v0.x)
+				area = 1.0;
+			else
+				area = -1.0;
+		} else
+			area = CROSS(s->v1, s->v0, (*v));
 	}
-      else if (FP_EQUAL(s->v0.y, v->y))
-	{
-	  if (v->x < s->v0.x)
-	    area = 1.0;
-	  else
-	    area = -1.0;
-	}
-      else
-	area = CROSS(s->v0, s->v1, (*v));
-    }
-  else				/* v0 > v1 */
-    {
-      if (FP_EQUAL(s->v1.y, v->y))
-	{
-	  if (v->x < s->v1.x)
-	    area = 1.0;
-	  else
-	    area = -1.0;
-	}
-      else if (FP_EQUAL(s->v0.y, v->y))
-	{
-	  if (v->x < s->v0.x)
-	    area = 1.0;
-	  else
-	    area = -1.0;
-	}
-      else
-	area = CROSS(s->v1, s->v0, (*v));
-    }
-  
-  if (area > 0.0)
-    return TRUE;
-  else 
-    return FALSE;
+
+	if (area > 0.0)
+		return TRUE;
+	else
+		return FALSE;
 }
 
 
@@ -322,75 +303,70 @@
 /* whether the segment which shares this endpoint is already inserted */
 
 static int inserted(segnum, whichpt)
-     int segnum;
-     int whichpt;
+int segnum;
+int whichpt;
 {
-  if (whichpt == FIRSTPT)
-    return seg[seg[segnum].prev].is_inserted;
-  else
-    return seg[seg[segnum].next].is_inserted;
+	if (whichpt == FIRSTPT)
+		return seg[seg[segnum].prev].is_inserted;
+	else
+		return seg[seg[segnum].next].is_inserted;
 }
 
-/* This is query routine which determines which trapezoid does the 
- * point v lie in. The return value is the trapezoid number. 
+/* This is query routine which determines which trapezoid does the
+ * point v lie in. The return value is the trapezoid number.
  */
 
 int locate_endpoint(v, vo, r)
-     point_t *v;
-     point_t *vo;
-     int r;
+point_t *v;
+point_t *vo;
+int r;
 {
-  node_t *rptr = &qs[r];
-  
-  switch (rptr->nodetype)
-    {
-    case T_SINK:
-      return rptr->trnum;
-      
-    case T_Y:
-      if (_greater_than(v, &rptr->yval)) /* above */
-	return locate_endpoint(v, vo, rptr->right);
-      else if (_equal_to(v, &rptr->yval)) /* the point is already */
-	{			          /* inserted. */
-	  if (_greater_than(vo, &rptr->yval)) /* above */
-	    return locate_endpoint(v, vo, rptr->right);
-	  else 
-	    return locate_endpoint(v, vo, rptr->left); /* below */	    
-	}
-      else
-	return locate_endpoint(v, vo, rptr->left); /* below */
+	node_t *rptr = &qs[r];
 
-    case T_X:
-      if (_equal_to(v, &seg[rptr->segnum].v0) || 
-	       _equal_to(v, &seg[rptr->segnum].v1))
-	{
-	  if (FP_EQUAL(v->y, vo->y)) /* horizontal segment */
-	    {
-	      if (vo->x < v->x)
-		return locate_endpoint(v, vo, rptr->left); /* left */
-	      else
-		return locate_endpoint(v, vo, rptr->right); /* right */
-	    }
+	switch (rptr->nodetype) {
+	case T_SINK:
+		return rptr->trnum;
 
-	  else if (is_left_of(rptr->segnum, vo))
-	    return locate_endpoint(v, vo, rptr->left); /* left */
-	  else
-	    return locate_endpoint(v, vo, rptr->right); /* right */
-	}
-      else if (is_left_of(rptr->segnum, v))
-	return locate_endpoint(v, vo, rptr->left); /* left */
-      else
-	return locate_endpoint(v, vo, rptr->right); /* right */	
+	case T_Y:
+		if (_greater_than(v, &rptr->yval)) /* above */
+			return locate_endpoint(v, vo, rptr->right);
+		else if (_equal_to(v, &rptr->yval)) /* the point is already */
+		{			          /* inserted. */
+			if (_greater_than(vo, &rptr->yval)) /* above */
+				return locate_endpoint(v, vo, rptr->right);
+			else
+				return locate_endpoint(v, vo, rptr->left); /* below */
+		} else
+			return locate_endpoint(v, vo, rptr->left); /* below */
 
-    default:
-      errs("sei:locate_endpoint()","Haggu!!!! (whatever)");
-      break;
-    }
-  return(-1);
+	case T_X:
+		if (_equal_to(v, &seg[rptr->segnum].v0) ||
+		                _equal_to(v, &seg[rptr->segnum].v1)) {
+			if (FP_EQUAL(v->y, vo->y)) { /* horizontal segment */
+				if (vo->x < v->x)
+					return locate_endpoint(v, vo, rptr->left); /* left */
+				else
+					return locate_endpoint(v, vo, rptr->right); /* right */
+			}
+
+			else if (is_left_of(rptr->segnum, vo))
+				return locate_endpoint(v, vo, rptr->left); /* left */
+			else
+				return locate_endpoint(v, vo, rptr->right); /* right */
+		} else if (is_left_of(rptr->segnum, v))
+			return locate_endpoint(v, vo, rptr->left); /* left */
+		else
+			return locate_endpoint(v, vo, rptr->right); /* right */
+
+	default:
+		errs("sei:locate_endpoint()","Haggu!!!! (whatever)");
+		break;
+	}
+	return(-1);
 }
 
 
-/* Thread in the segment into the existing trapezoidation. The 
+/* Thread in the segment into the existing trapezoidation. The
  * limiting trapezoids are given by tfirst and tlast (which are the
  * trapezoids containing the two endpoints of the segment. Merges all
  * possible trapezoids which flank this segment and have been recently
@@ -398,71 +374,65 @@
  */
 
 static int merge_trapezoids(segnum, tfirst, tlast, side)
-     int segnum;
-     int tfirst;
-     int tlast;
-     int side;
+int segnum;
+int tfirst;
+int tlast;
+int side;
 {
-  int t, tnext, cond;
-  int ptnext;
+	int t, tnext, cond;
+	int ptnext;
 
-  /* First merge polys on the LHS */
-  t = tfirst;
-  while ((t > 0) && _greater_than_equal_to(&tr[t].lo, &tr[tlast].lo))
-    {
-      if (side == S_LEFT)
-	cond = ((((tnext = tr[t].d0) > 0) && (tr[tnext].rseg == segnum)) ||
-		(((tnext = tr[t].d1) > 0) && (tr[tnext].rseg == segnum)));
-      else
-	cond = ((((tnext = tr[t].d0) > 0) && (tr[tnext].lseg == segnum)) ||
-		(((tnext = tr[t].d1) > 0) && (tr[tnext].lseg == segnum)));
-      
-      if (cond)
-	{
-	  if ((tr[t].lseg == tr[tnext].lseg) &&
-	      (tr[t].rseg == tr[tnext].rseg)) /* good neighbours */
-	    {			              /* merge them */
-	      /* Use the upper node as the new node i.e. t */
-	      
-	      ptnext = qs[tr[tnext].sink].parent;
-	      
-	      if (qs[ptnext].left == tr[tnext].sink)
-		qs[ptnext].left = tr[t].sink;
-	      else
-		qs[ptnext].right = tr[t].sink;	/* redirect parent */
-	      
-	      
-	      /* Change the upper neighbours of the lower trapezoids */
-	      
-	      if ((tr[t].d0 = tr[tnext].d0) > 0)
-		  {
-			if (tr[tr[t].d0].u0 == tnext)
-			  tr[tr[t].d0].u0 = t;
-			else if (tr[tr[t].d0].u1 == tnext)
-			  tr[tr[t].d0].u1 = t;
-		  }
-	      
-	      if ((tr[t].d1 = tr[tnext].d1) > 0)
-		  {
-			if (tr[tr[t].d1].u0 == tnext)
-			  tr[tr[t].d1].u0 = t;
-			else if (tr[tr[t].d1].u1 == tnext)
-			  tr[tr[t].d1].u1 = t;
-		  }
-	      
-	      tr[t].lo = tr[tnext].lo;
-	      tr[tnext].state = ST_INVALID; /* invalidate the lower */
-				            /* trapezium */
-	    }
-	  else		    /* not good neighbours */
-	    t = tnext;
-	}
-      else		    /* do not satisfy the outer if */
-	t = tnext;
-      
-    } /* end-while */
-       
-  return 0;
+	/* First merge polys on the LHS */
+	t = tfirst;
+	while ((t > 0) && _greater_than_equal_to(&tr[t].lo, &tr[tlast].lo)) {
+		if (side == S_LEFT)
+			cond = ((((tnext = tr[t].d0) > 0) && (tr[tnext].rseg == segnum)) ||
+			        (((tnext = tr[t].d1) > 0) && (tr[tnext].rseg == segnum)));
+		else
+			cond = ((((tnext = tr[t].d0) > 0) && (tr[tnext].lseg == segnum)) ||
+			        (((tnext = tr[t].d1) > 0) && (tr[tnext].lseg == segnum)));
+
+		if (cond) {
+			if ((tr[t].lseg == tr[tnext].lseg) &&
+			                (tr[t].rseg == tr[tnext].rseg)) /* good neighbours */
+			{			              /* merge them */
+				/* Use the upper node as the new node i.e. t */
+
+				ptnext = qs[tr[tnext].sink].parent;
+
+				if (qs[ptnext].left == tr[tnext].sink)
+					qs[ptnext].left = tr[t].sink;
+				else
+					qs[ptnext].right = tr[t].sink;	/* redirect parent */
+
+
+				/* Change the upper neighbours of the lower trapezoids */
+
+				if ((tr[t].d0 = tr[tnext].d0) > 0) {
+					if (tr[tr[t].d0].u0 == tnext)
+						tr[tr[t].d0].u0 = t;
+					else if (tr[tr[t].d0].u1 == tnext)
+						tr[tr[t].d0].u1 = t;
+				}
+
+				if ((tr[t].d1 = tr[tnext].d1) > 0) {
+					if (tr[tr[t].d1].u0 == tnext)
+						tr[tr[t].d1].u0 = t;
+					else if (tr[tr[t].d1].u1 == tnext)
+						tr[tr[t].d1].u1 = t;
+				}
+
+				tr[t].lo = tr[tnext].lo;
+				tr[tnext].state = ST_INVALID; /* invalidate the lower */
+				/* trapezium */
+			} else		   /* not good neighbours */
+				t = tnext;
+		} else		   /* do not satisfy the outer if */
+			t = tnext;
+
+	} /* end-while */
+
+	return 0;
 }
 
 
@@ -473,574 +443,493 @@
  */
 
 static int add_segment(segnum)
-     int segnum;
+int segnum;
 {
-  segment_t s;
-  int tu, tl, sk, tfirst, tlast;
-  int tfirstr = 0, tlastr = 0, tfirstl, tlastl;
-  int i1, i2, t, tn;
-  point_t tpt;
-  int tritop = 0, tribot = 0, is_swapped = 0;
-  int tmptriseg;
-  int tmpseg = 1;
+	segment_t s;
+	int tu, tl, sk, tfirst, tlast;
+	int tfirstr = 0, tlastr = 0, tfirstl, tlastl;
+	int i1, i2, t, tn;
+	point_t tpt;
+	int tritop = 0, tribot = 0, is_swapped = 0;
+	int tmptriseg;
+	int tmpseg = 1;
 
-  s = seg[segnum];
-  if (_greater_than(&s.v1, &s.v0)) /* Get higher vertex in v0 */
-    {
-      int tmp;
-      tpt = s.v0;
-      s.v0 = s.v1;
-      s.v1 = tpt;
-      tmp = s.root0;
-      s.root0 = s.root1;
-      s.root1 = tmp;
-      is_swapped = TRUE;
-    }
+	s = seg[segnum];
+	if (_greater_than(&s.v1, &s.v0)) { /* Get higher vertex in v0 */
+		int tmp;
+		tpt = s.v0;
+		s.v0 = s.v1;
+		s.v1 = tpt;
+		tmp = s.root0;
+		s.root0 = s.root1;
+		s.root1 = tmp;
+		is_swapped = TRUE;
+	}
 
-  if ((is_swapped) ? !inserted(segnum, LASTPT) :
-       !inserted(segnum, FIRSTPT))     /* insert v0 in the tree */
-    {
-      int tmp_d;
+	if ((is_swapped) ? !inserted(segnum, LASTPT) :
+	                !inserted(segnum, FIRSTPT)) {   /* insert v0 in the tree */
+		int tmp_d;
 
-      tu = locate_endpoint(&s.v0, &s.v1, s.root0);
-      tl = newtrap();		/* tl is the new lower trapezoid */
-      tr[tl].state = ST_VALID;
-      tr[tl] = tr[tu];
-      tr[tu].lo.y = tr[tl].hi.y = s.v0.y;
-      tr[tu].lo.x = tr[tl].hi.x = s.v0.x;
-      tr[tu].d0 = tl;      
-      tr[tu].d1 = 0;
-      tr[tl].u0 = tu;
-      tr[tl].u1 = 0;
+		tu = locate_endpoint(&s.v0, &s.v1, s.root0);
+		tl = newtrap();		/* tl is the new lower trapezoid */
+		tr[tl].state = ST_VALID;
+		tr[tl] = tr[tu];
+		tr[tu].lo.y = tr[tl].hi.y = s.v0.y;
+		tr[tu].lo.x = tr[tl].hi.x = s.v0.x;
+		tr[tu].d0 = tl;
+		tr[tu].d1 = 0;
+		tr[tl].u0 = tu;
+		tr[tl].u1 = 0;
 
-      if (((tmp_d = tr[tl].d0) > 0) && (tr[tmp_d].u0 == tu))
-	tr[tmp_d].u0 = tl;
-      if (((tmp_d = tr[tl].d0) > 0) && (tr[tmp_d].u1 == tu))
-	tr[tmp_d].u1 = tl;
+		if (((tmp_d = tr[tl].d0) > 0) && (tr[tmp_d].u0 == tu))
+			tr[tmp_d].u0 = tl;
+		if (((tmp_d = tr[tl].d0) > 0) && (tr[tmp_d].u1 == tu))
+			tr[tmp_d].u1 = tl;
 
-      if (((tmp_d = tr[tl].d1) > 0) && (tr[tmp_d].u0 == tu))
-	tr[tmp_d].u0 = tl;
-      if (((tmp_d = tr[tl].d1) > 0) && (tr[tmp_d].u1 == tu))
-	tr[tmp_d].u1 = tl;
+		if (((tmp_d = tr[tl].d1) > 0) && (tr[tmp_d].u0 == tu))
+			tr[tmp_d].u0 = tl;
+		if (((tmp_d = tr[tl].d1) > 0) && (tr[tmp_d].u1 == tu))
+			tr[tmp_d].u1 = tl;
 
-      /* Now update the query structure and obtain the sinks for the */
-      /* two trapezoids */ 
-      
-      i1 = newnode();		/* Upper trapezoid sink */
-      i2 = newnode();		/* Lower trapezoid sink */
-      sk = tr[tu].sink;
-      
-      qs[sk].nodetype = T_Y;
-      qs[sk].yval = s.v0;
-      qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
-      qs[sk].left = i2;
-      qs[sk].right = i1;
+		/* Now update the query structure and obtain the sinks for the */
+		/* two trapezoids */
 
-      qs[i1].nodetype = T_SINK;
-      qs[i1].trnum = tu;
-      qs[i1].parent = sk;
+		i1 = newnode();		/* Upper trapezoid sink */
+		i2 = newnode();		/* Lower trapezoid sink */
+		sk = tr[tu].sink;
 
-      qs[i2].nodetype = T_SINK;
-      qs[i2].trnum = tl;
-      qs[i2].parent = sk;
+		qs[sk].nodetype = T_Y;
+		qs[sk].yval = s.v0;
+		qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
+		qs[sk].left = i2;
+		qs[sk].right = i1;
 
-      tr[tu].sink = i1;
-      tr[tl].sink = i2;
-      tfirst = tl;
-    }
-  else				/* v0 already present */
-    {       /* Get the topmost intersecting trapezoid */
-      tfirst = locate_endpoint(&s.v0, &s.v1, s.root0);
-      tritop = 1;
-    }
+		qs[i1].nodetype = T_SINK;
+		qs[i1].trnum = tu;
+		qs[i1].parent = sk;
 
+		qs[i2].nodetype = T_SINK;
+		qs[i2].trnum = tl;
+		qs[i2].parent = sk;
 
-  if ((is_swapped) ? !inserted(segnum, FIRSTPT) :
-       !inserted(segnum, LASTPT))     /* insert v1 in the tree */
-    {
-      int tmp_d;
+		tr[tu].sink = i1;
+		tr[tl].sink = i2;
+		tfirst = tl;
+	} else				/* v0 already present */
+	{       /* Get the topmost intersecting trapezoid */
+		tfirst = locate_endpoint(&s.v0, &s.v1, s.root0);
+		tritop = 1;
+	}
 
-      tu = locate_endpoint(&s.v1, &s.v0, s.root1);
 
-      tl = newtrap();		/* tl is the new lower trapezoid */
-      tr[tl].state = ST_VALID;
-      tr[tl] = tr[tu];
-      tr[tu].lo.y = tr[tl].hi.y = s.v1.y;
-      tr[tu].lo.x = tr[tl].hi.x = s.v1.x;
-      tr[tu].d0 = tl;      
-      tr[tu].d1 = 0;
-      tr[tl].u0 = tu;
-      tr[tl].u1 = 0;
+	if ((is_swapped) ? !inserted(segnum, FIRSTPT) :
+	                !inserted(segnum, LASTPT)) {   /* insert v1 in the tree */
+		int tmp_d;
 
-      if (((tmp_d = tr[tl].d0) > 0) && (tr[tmp_d].u0 == tu))
-	tr[tmp_d].u0 = tl;
-      if (((tmp_d = tr[tl].d0) > 0) && (tr[tmp_d].u1 == tu))
-	tr[tmp_d].u1 = tl;
+		tu = locate_endpoint(&s.v1, &s.v0, s.root1);
 
-      if (((tmp_d = tr[tl].d1) > 0) && (tr[tmp_d].u0 == tu))
-	tr[tmp_d].u0 = tl;
-      if (((tmp_d = tr[tl].d1) > 0) && (tr[tmp_d].u1 == tu))
-	tr[tmp_d].u1 = tl;
-      
-      /* Now update the query structure and obtain the sinks for the */
-      /* two trapezoids */ 
-      
-      i1 = newnode();		/* Upper trapezoid sink */
-      i2 = newnode();		/* Lower trapezoid sink */
-      sk = tr[tu].sink;
-      
-      qs[sk].nodetype = T_Y;
-      qs[sk].yval = s.v1;
-      qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
-      qs[sk].left = i2;
-      qs[sk].right = i1;
+		tl = newtrap();		/* tl is the new lower trapezoid */
+		tr[tl].state = ST_VALID;
+		tr[tl] = tr[tu];
+		tr[tu].lo.y = tr[tl].hi.y = s.v1.y;
+		tr[tu].lo.x = tr[tl].hi.x = s.v1.x;
+		tr[tu].d0 = tl;
+		tr[tu].d1 = 0;
+		tr[tl].u0 = tu;
+		tr[tl].u1 = 0;
 
-      qs[i1].nodetype = T_SINK;
-      qs[i1].trnum = tu;
-      qs[i1].parent = sk;
+		if (((tmp_d = tr[tl].d0) > 0) && (tr[tmp_d].u0 == tu))
+			tr[tmp_d].u0 = tl;
+		if (((tmp_d = tr[tl].d0) > 0) && (tr[tmp_d].u1 == tu))
+			tr[tmp_d].u1 = tl;
 
-      qs[i2].nodetype = T_SINK;
-      qs[i2].trnum = tl;
-      qs[i2].parent = sk;
+		if (((tmp_d = tr[tl].d1) > 0) && (tr[tmp_d].u0 == tu))
+			tr[tmp_d].u0 = tl;
+		if (((tmp_d = tr[tl].d1) > 0) && (tr[tmp_d].u1 == tu))
+			tr[tmp_d].u1 = tl;
 
-      tr[tu].sink = i1;
-      tr[tl].sink = i2;
-      tlast = tu;
-    }
-  else				/* v1 already present */
-    {       /* Get the lowermost intersecting trapezoid */
-      tlast = locate_endpoint(&s.v1, &s.v0, s.root1);
-      tribot = 1;
-    }
-  
-  /* Thread the segment into the query tree creating a new X-node */
-  /* First, split all the trapezoids which are intersected by s into */
-  /* two */
+		/* Now update the query structure and obtain the sinks for the */
+		/* two trapezoids */
 
-  t = tfirst;			/* topmost trapezoid */
-  
-  while ((t > 0) && 
-	 _greater_than_equal_to(&tr[t].lo, &tr[tlast].lo))
-				/* traverse from top to bot */
-    {
-      int t_sav, tn_sav;
-      sk = tr[t].sink;
-      i1 = newnode();		/* left trapezoid sink */
-      i2 = newnode();		/* right trapezoid sink */
-      
-      qs[sk].nodetype = T_X;
-      qs[sk].segnum = segnum;
-      qs[sk].left = i1;
-      qs[sk].right = i2;
+		i1 = newnode();		/* Upper trapezoid sink */
+		i2 = newnode();		/* Lower trapezoid sink */
+		sk = tr[tu].sink;
 
-      qs[i1].nodetype = T_SINK;	/* left trapezoid (use existing one) */
-      qs[i1].trnum = t;
-      qs[i1].parent = sk;
+		qs[sk].nodetype = T_Y;
+		qs[sk].yval = s.v1;
+		qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
+		qs[sk].left = i2;
+		qs[sk].right = i1;
 
-      qs[i2].nodetype = T_SINK;	/* right trapezoid (allocate new) */
-      qs[i2].trnum = tn = newtrap();
-      tr[tn].state = ST_VALID;
-      qs[i2].parent = sk;
+		qs[i1].nodetype = T_SINK;
+		qs[i1].trnum = tu;
+		qs[i1].parent = sk;
 
-      if (t == tfirst)
-	tfirstr = tn;
-      if (_equal_to(&tr[t].lo, &tr[tlast].lo))
-	tlastr = tn;
+		qs[i2].nodetype = T_SINK;
+		qs[i2].trnum = tl;
+		qs[i2].parent = sk;
 
-      tr[tn] = tr[t];
-      tr[t].sink = i1;
-      tr[tn].sink = i2;
-      t_sav = t;
-      tn_sav = tn;
+		tr[tu].sink = i1;
+		tr[tl].sink = i2;
+		tlast = tu;
+	} else				/* v1 already present */
+	{       /* Get the lowermost intersecting trapezoid */
+		tlast = locate_endpoint(&s.v1, &s.v0, s.root1);
+		tribot = 1;
+	}
 
-      /* error */
+	/* Thread the segment into the query tree creating a new X-node */
+	/* First, split all the trapezoids which are intersected by s into */
+	/* two */
 
-      if ((tr[t].d0 <= 0) && (tr[t].d1 <= 0)) /* case cannot arise */
+	t = tfirst;			/* topmost trapezoid */
+
+	while ((t > 0) &&
+	                _greater_than_equal_to(&tr[t].lo, &tr[tlast].lo))
+		/* traverse from top to bot */
 	{
-      errs("sei:add_segment()","error");
-	  break;
-	}
-      
-      /* only one trapezoid below. partition t into two and make the */
-      /* two resulting trapezoids t and tn as the upper neighbours of */
-      /* the sole lower trapezoid */
-      
-      else if ((tr[t].d0 > 0) && (tr[t].d1 <= 0))
-	{			/* Only one trapezoid below */
-	  if ((tr[t].u0 > 0) && (tr[t].u1 > 0))
-	    {			/* continuation of a chain from abv. */
-	      if (tr[t].usave > 0) /* three upper neighbours */
-		{
-		  if (tr[t].uside == S_LEFT)
-		    {
-		      tr[tn].u0 = tr[t].u1;
-		      tr[t].u1 = -1;
-		      tr[tn].u1 = tr[t].usave;
-		      
-		      tr[tr[t].u0].d0 = t;
-		      tr[tr[tn].u0].d0 = tn;
-		      tr[tr[tn].u1].d0 = tn;
-		    }
-		  else		/* intersects in the right */
-		    {
-		      tr[tn].u1 = -1;
-		      tr[tn].u0 = tr[t].u1;
-		      tr[t].u1 = tr[t].u0;
-		      tr[t].u0 = tr[t].usave;
+		int t_sav, tn_sav;
+		sk = tr[t].sink;
+		i1 = newnode();		/* left trapezoid sink */
+		i2 = newnode();		/* right trapezoid sink */
 
-		      tr[tr[t].u0].d0 = t;
-		      tr[tr[t].u1].d0 = t;
-		      tr[tr[tn].u0].d0 = tn;		      
-		    }
-		  
-		  tr[t].usave = tr[tn].usave = 0;
-		}
-	      else		/* No usave.... simple case */
-		{
-		  tr[tn].u0 = tr[t].u1;
-		  tr[t].u1 = tr[tn].u1 = -1;
-		  tr[tr[tn].u0].d0 = tn;
-		}
-	    }
-	  else 
-	    {			/* fresh seg. or upward cusp */
-	      int tmp_u = tr[t].u0;
-	      int td0, td1;
-	      if (((td0 = tr[tmp_u].d0) > 0) && 
-		  ((td1 = tr[tmp_u].d1) > 0))
-		{		/* upward cusp */
-		  if ((tr[td0].rseg > 0) &&
-		      !is_left_of(tr[td0].rseg, &s.v1))
-		    {
-		      tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
-		      tr[tr[tn].u0].d1 = tn;
-		    }
-		  else		/* cusp going leftwards */
-		    { 
-		      tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
-		      tr[tr[t].u0].d0 = t;
-		    }
-		}
-	      else		/* fresh segment */
-		{
-		  tr[tr[t].u0].d0 = t;
-		  tr[tr[t].u0].d1 = tn;
-		}	      
-	    }
-	  
-	  if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) && 
-	      FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) && tribot)
-	    {		/* bottom forms a triangle */
+		qs[sk].nodetype = T_X;
+		qs[sk].segnum = segnum;
+		qs[sk].left = i1;
+		qs[sk].right = i2;
 
-	      if (is_swapped)	
-		tmptriseg = seg[segnum].prev;
-	      else
-		tmptriseg = seg[segnum].next;
-	      
-	      if ((tmptriseg > 0) && is_left_of(tmptriseg, &s.v0))
-		{
-				/* L-R downward cusp */
-		  tr[tr[t].d0].u0 = t;
-		  tr[tn].d0 = tr[tn].d1 = -1;
-		}
-	      else
-		{
-				/* R-L downward cusp */
-		  tr[tr[tn].d0].u1 = tn;
-		  tr[t].d0 = tr[t].d1 = -1;
-		}
-	    }
-	  else
-	    {
-	      if ((tr[tr[t].d0].u0 > 0) && (tr[tr[t].d0].u1 > 0))
-		{
-		  if (tr[tr[t].d0].u0 == t) /* passes thru LHS */
-		    {
-		      tr[tr[t].d0].usave = tr[tr[t].d0].u1;
-		      tr[tr[t].d0].uside = S_LEFT;
-		    }
-		  else
-		    {
-		      tr[tr[t].d0].usave = tr[tr[t].d0].u0;
-		      tr[tr[t].d0].uside = S_RIGHT;
-		    }		    
-		}
-	      tr[tr[t].d0].u0 = t;
-	      tr[tr[t].d0].u1 = tn;
-	    }
-	  
-	  t = tr[t].d0;
-	}
+		qs[i1].nodetype = T_SINK;	/* left trapezoid (use existing one) */
+		qs[i1].trnum = t;
+		qs[i1].parent = sk;
 
+		qs[i2].nodetype = T_SINK;	/* right trapezoid (allocate new) */
+		qs[i2].trnum = tn = newtrap();
+		tr[tn].state = ST_VALID;
+		qs[i2].parent = sk;
 
-      else if ((tr[t].d0 <= 0) && (tr[t].d1 > 0))
-	{			/* Only one trapezoid below */
-	  if ((tr[t].u0 > 0) && (tr[t].u1 > 0))
-	    {			/* continuation of a chain from abv. */
-	      if (tr[t].usave > 0) /* three upper neighbours */
-		{
-		  if (tr[t].uside == S_LEFT)
-		    {
-		      tr[tn].u0 = tr[t].u1;
-		      tr[t].u1 = -1;
-		      tr[tn].u1 = tr[t].usave;
-		      
-		      tr[tr[t].u0].d0 = t;
-		      tr[tr[tn].u0].d0 = tn;
-		      tr[tr[tn].u1].d0 = tn;
-		    }
-		  else		/* intersects in the right */
-		    {
-		      tr[tn].u1 = -1;
-		      tr[tn].u0 = tr[t].u1;
-		      tr[t].u1 = tr[t].u0;
-		      tr[t].u0 = tr[t].usave;
+		if (t == tfirst)
+			tfirstr = tn;
+		if (_equal_to(&tr[t].lo, &tr[tlast].lo))
+			tlastr = tn;
 
-		      tr[tr[t].u0].d0 = t;
-		      tr[tr[t].u1].d0 = t;
-		      tr[tr[tn].u0].d0 = tn;		      
-		    }
-		  
-		  tr[t].usave = tr[tn].usave = 0;
+		tr[tn] = tr[t];
+		tr[t].sink = i1;
+		tr[tn].sink = i2;
+		t_sav = t;
+		tn_sav = tn;
+
+		/* error */
+
+		if ((tr[t].d0 <= 0) && (tr[t].d1 <= 0)) { /* case cannot arise */
+			errs("sei:add_segment()","error");
+			break;
 		}
-	      else		/* No usave.... simple case */
-		{
-		  tr[tn].u0 = tr[t].u1;
-		  tr[t].u1 = tr[tn].u1 = -1;
-		  tr[tr[tn].u0].d0 = tn;
-		}
-	    }
-	  else 
-	    {			/* fresh seg. or upward cusp */
-	      int tmp_u = tr[t].u0;
-	      int td0, td1;
-	      if (((td0 = tr[tmp_u].d0) > 0) && 
-		  ((td1 = tr[tmp_u].d1) > 0))
-		{		/* upward cusp */
-		  if ((tr[td0].rseg > 0) &&
-		      !is_left_of(tr[td0].rseg, &s.v1))
-		    {
-		      tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
-		      tr[tr[tn].u0].d1 = tn;
-		    }
-		  else 
-		    {
-		      tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
-		      tr[tr[t].u0].d0 = t;
-		    }
-		}
-	      else		/* fresh segment */
-		{
-		  tr[tr[t].u0].d0 = t;
-		  tr[tr[t].u0].d1 = tn;
-		}
-	    }
-	  
-	  if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) && 
-	      FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) && tribot)
-	    {		/* bottom forms a triangle */
 
-	      if (is_swapped)	
-			tmptriseg = seg[segnum].prev;
-	      else
-			tmptriseg = seg[segnum].next;
+		/* only one trapezoid below. partition t into two and make the */
+		/* two resulting trapezoids t and tn as the upper neighbours of */
+		/* the sole lower trapezoid */
 
-	      if ((tmpseg > 0) && is_left_of(tmpseg, &s.v0))
-		{
-		  /* L-R downward cusp */
-		  tr[tr[t].d1].u0 = t;
-		  tr[tn].d0 = tr[tn].d1 = -1;
+		else if ((tr[t].d0 > 0) && (tr[t].d1 <= 0)) {			/* Only one trapezoid below */
+			if ((tr[t].u0 > 0) && (tr[t].u1 > 0)) {			/* continuation of a chain from abv. */
+				if (tr[t].usave > 0) { /* three upper neighbours */
+					if (tr[t].uside == S_LEFT) {
+						tr[tn].u0 = tr[t].u1;
+						tr[t].u1 = -1;
+						tr[tn].u1 = tr[t].usave;
+
+						tr[tr[t].u0].d0 = t;
+						tr[tr[tn].u0].d0 = tn;
+						tr[tr[tn].u1].d0 = tn;
+					} else {	/* intersects in the right */
+						tr[tn].u1 = -1;
+						tr[tn].u0 = tr[t].u1;
+						tr[t].u1 = tr[t].u0;
+						tr[t].u0 = tr[t].usave;
+
+						tr[tr[t].u0].d0 = t;
+						tr[tr[t].u1].d0 = t;
+						tr[tr[tn].u0].d0 = tn;
+					}
+
+					tr[t].usave = tr[tn].usave = 0;
+				} else {	/* No usave.... simple case */
+					tr[tn].u0 = tr[t].u1;
+					tr[t].u1 = tr[tn].u1 = -1;
+					tr[tr[tn].u0].d0 = tn;
+				}
+			} else {			/* fresh seg. or upward cusp */
+				int tmp_u = tr[t].u0;
+				int td0, td1;
+				if (((td0 = tr[tmp_u].d0) > 0) &&
+				                ((td1 = tr[tmp_u].d1) > 0)) {		/* upward cusp */
+					if ((tr[td0].rseg > 0) &&
+					                !is_left_of(tr[td0].rseg, &s.v1)) {
+						tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
+						tr[tr[tn].u0].d1 = tn;
+					} else {	/* cusp going leftwards */
+						tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
+						tr[tr[t].u0].d0 = t;
+					}
+				} else {	/* fresh segment */
+					tr[tr[t].u0].d0 = t;
+					tr[tr[t].u0].d1 = tn;
+				}
+			}
+
+			if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &&
+			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) && tribot) {		/* bottom forms a triangle */
+
+				if (is_swapped)
+					tmptriseg = seg[segnum].prev;
+				else
+					tmptriseg = seg[segnum].next;
+
+				if ((tmptriseg > 0) && is_left_of(tmptriseg, &s.v0)) {
+					/* L-R downward cusp */
+					tr[tr[t].d0].u0 = t;
+					tr[tn].d0 = tr[tn].d1 = -1;
+				} else {
+					/* R-L downward cusp */
+					tr[tr[tn].d0].u1 = tn;
+					tr[t].d0 = tr[t].d1 = -1;
+				}
+			} else {
+				if ((tr[tr[t].d0].u0 > 0) && (tr[tr[t].d0].u1 > 0)) {
+					if (tr[tr[t].d0].u0 == t) { /* passes thru LHS */
+						tr[tr[t].d0].usave = tr[tr[t].d0].u1;
+						tr[tr[t].d0].uside = S_LEFT;
+					} else {
+						tr[tr[t].d0].usave = tr[tr[t].d0].u0;
+						tr[tr[t].d0].uside = S_RIGHT;
+					}
+				}
+				tr[tr[t].d0].u0 = t;
+				tr[tr[t].d0].u1 = tn;
+			}
+
+			t = tr[t].d0;
 		}
-	      else
-		{
-		  /* R-L downward cusp */
-		  tr[tr[tn].d1].u1 = tn;
-		  tr[t].d0 = tr[t].d1 = -1;
-		}
-	    }		
-	  else
-	    {
-	      if ((tr[tr[t].d1].u0 > 0) && (tr[tr[t].d1].u1 > 0))
-		{
-		  if (tr[tr[t].d1].u0 == t) /* passes thru LHS */
-		    {
-		      tr[tr[t].d1].usave = tr[tr[t].d1].u1;
-		      tr[tr[t].d1].uside = S_LEFT;
-		    }
-		  else
-		    {
-		      tr[tr[t].d1].usave = tr[tr[t].d1].u0;
-		      tr[tr[t].d1].uside = S_RIGHT;
-		    }		    
-		}
-	      tr[tr[t].d1].u0 = t;
-	      tr[tr[t].d1].u1 = tn;
-	    }
-	  
-	  t = tr[t].d1;
-	}
 
-      /* two trapezoids below. Find out which one is intersected by */
-      /* this segment and proceed down that one */
-      
-      else
-	{
-	  double y0, yt;
-	  point_t tmppt;
-	  int tnext, i_d0, i_d1;
-	  tmpseg = tr[tr[t].d0].rseg;
 
-	  i_d0 = i_d1 = FALSE;
-	  if (FP_EQUAL(tr[t].lo.y, s.v0.y))
-	    {
-	      if (tr[t].lo.x > s.v0.x)
-		i_d0 = TRUE;
-	      else
-		i_d1 = TRUE;
-	    }
-	  else
-	    {
-	      tmppt.y = y0 = tr[t].lo.y;
-	      yt = (y0 - s.v0.y)/(s.v1.y - s.v0.y);
-	      tmppt.x = s.v0.x + yt * (s.v1.x - s.v0.x);
-	      
-	      if (_less_than(&tmppt, &tr[t].lo))
-		i_d0 = TRUE;
-	      else
-		i_d1 = TRUE;
-	    }
-	  
-	  /* check continuity from the top so that the lower-neighbour */
-	  /* values are properly filled for the upper trapezoid */
+		else if ((tr[t].d0 <= 0) && (tr[t].d1 > 0)) {			/* Only one trapezoid below */
+			if ((tr[t].u0 > 0) && (tr[t].u1 > 0)) {			/* continuation of a chain from abv. */
+				if (tr[t].usave > 0) { /* three upper neighbours */
+					if (tr[t].uside == S_LEFT) {
+						tr[tn].u0 = tr[t].u1;
+						tr[t].u1 = -1;
+						tr[tn].u1 = tr[t].usave;
 
-	  if ((tr[t].u0 > 0) && (tr[t].u1 > 0))
-	    {			/* continuation of a chain from abv. */
-	      if (tr[t].usave > 0) /* three upper neighbours */
-		{
-		  if (tr[t].uside == S_LEFT)
-		    {
-		      tr[tn].u0 = tr[t].u1;
-		      tr[t].u1 = -1;
-		      tr[tn].u1 = tr[t].usave;
-		      
-		      tr[tr[t].u0].d0 = t;
-		      tr[tr[tn].u0].d0 = tn;
-		      tr[tr[tn].u1].d0 = tn;
-		    }
-		  else		/* intersects in the right */
-		    {
-		      tr[tn].u1 = -1;
-		      tr[tn].u0 = tr[t].u1;
-		      tr[t].u1 = tr[t].u0;
-		      tr[t].u0 = tr[t].usave;
+						tr[tr[t].u0].d0 = t;
+						tr[tr[tn].u0].d0 = tn;
+						tr[tr[tn].u1].d0 = tn;
+					} else {	/* intersects in the right */
+						tr[tn].u1 = -1;
+						tr[tn].u0 = tr[t].u1;
+						tr[t].u1 = tr[t].u0;
+						tr[t].u0 = tr[t].usave;
 
-		      tr[tr[t].u0].d0 = t;
-		      tr[tr[t].u1].d0 = t;
-		      tr[tr[tn].u0].d0 = tn;		      
-		    }
-		  
-		  tr[t].usave = tr[tn].usave = 0;
+						tr[tr[t].u0].d0 = t;
+						tr[tr[t].u1].d0 = t;
+						tr[tr[tn].u0].d0 = tn;
+					}
+
+					tr[t].usave = tr[tn].usave = 0;
+				} else {	/* No usave.... simple case */
+					tr[tn].u0 = tr[t].u1;
+					tr[t].u1 = tr[tn].u1 = -1;
+					tr[tr[tn].u0].d0 = tn;
+				}
+			} else {			/* fresh seg. or upward cusp */
+				int tmp_u = tr[t].u0;
+				int td0, td1;
+				if (((td0 = tr[tmp_u].d0) > 0) &&
+				                ((td1 = tr[tmp_u].d1) > 0)) {		/* upward cusp */
+					if ((tr[td0].rseg > 0) &&
+					                !is_left_of(tr[td0].rseg, &s.v1)) {
+						tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
+						tr[tr[tn].u0].d1 = tn;
+					} else {
+						tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
+						tr[tr[t].u0].d0 = t;
+					}
+				} else {	/* fresh segment */
+					tr[tr[t].u0].d0 = t;
+					tr[tr[t].u0].d1 = tn;
+				}
+			}
+
+			if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &&
+			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) && tribot) {		/* bottom forms a triangle */
+
+				if (is_swapped)
+					tmptriseg = seg[segnum].prev;
+				else
+					tmptriseg = seg[segnum].next;
+
+				if ((tmpseg > 0) && is_left_of(tmpseg, &s.v0)) {
+					/* L-R downward cusp */
+					tr[tr[t].d1].u0 = t;
+					tr[tn].d0 = tr[tn].d1 = -1;
+				} else {
+					/* R-L downward cusp */
+					tr[tr[tn].d1].u1 = tn;
+					tr[t].d0 = tr[t].d1 = -1;
+				}
+			} else {
+				if ((tr[tr[t].d1].u0 > 0) && (tr[tr[t].d1].u1 > 0)) {
+					if (tr[tr[t].d1].u0 == t) { /* passes thru LHS */
+						tr[tr[t].d1].usave = tr[tr[t].d1].u1;
+						tr[tr[t].d1].uside = S_LEFT;
+					} else {
+						tr[tr[t].d1].usave = tr[tr[t].d1].u0;
+						tr[tr[t].d1].uside = S_RIGHT;
+					}
+				}
+				tr[tr[t].d1].u0 = t;
+				tr[tr[t].d1].u1 = tn;
+			}
+
+			t = tr[t].d1;
 		}
-	      else		/* No usave.... simple case */
-		{
-		  tr[tn].u0 = tr[t].u1;
-		  tr[tn].u1 = -1;
-		  tr[t].u1 = -1;
-		  tr[tr[tn].u0].d0 = tn;
-		}
-	    }
-	  else 
-	    {			/* fresh seg. or upward cusp */
-	      int tmp_u = tr[t].u0;
-	      int td0, td1;
-	      if (((td0 = tr[tmp_u].d0) > 0) && 
-		  ((td1 = tr[tmp_u].d1) > 0))
-		{		/* upward cusp */
-		  if ((tr[td0].rseg > 0) &&
-		      !is_left_of(tr[td0].rseg, &s.v1))
-		    {
-		      tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
-		      tr[tr[tn].u0].d1 = tn;
-		    }
-		  else 
-		    {
-		      tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
-		      tr[tr[t].u0].d0 = t;
-		    }
-		}
-	      else		/* fresh segment */
-		{
-		  tr[tr[t].u0].d0 = t;
-		  tr[tr[t].u0].d1 = tn;
-		}
-	    }
-	  
-	  if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) && 
-	      FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) && tribot)
-	    {
-	      /* this case arises only at the lowest trapezoid.. i.e.
-		 tlast, if the lower endpoint of the segment is
-		 already inserted in the structure */
-	      
-	      tr[tr[t].d0].u0 = t;
-	      tr[tr[t].d0].u1 = -1;
-	      tr[tr[t].d1].u0 = tn;
-	      tr[tr[t].d1].u1 = -1;
 
-	      tr[tn].d0 = tr[t].d1;
-	      tr[t].d1 = tr[tn].d1 = -1;
-	      
-	      tnext = tr[t].d1;	      
-	    }
-	  else if (i_d0)
+		/* two trapezoids below. Find out which one is intersected by */
+		/* this segment and proceed down that one */
+
+		else {
+			double y0, yt;
+			point_t tmppt;
+			int tnext, i_d0, i_d1;
+			tmpseg = tr[tr[t].d0].rseg;
+
+			i_d0 = i_d1 = FALSE;
+			if (FP_EQUAL(tr[t].lo.y, s.v0.y)) {
+				if (tr[t].lo.x > s.v0.x)
+					i_d0 = TRUE;
+				else
+					i_d1 = TRUE;
+			} else {
+				tmppt.y = y0 = tr[t].lo.y;
+				yt = (y0 - s.v0.y)/(s.v1.y - s.v0.y);
+				tmppt.x = s.v0.x + yt * (s.v1.x - s.v0.x);
+
+				if (_less_than(&tmppt, &tr[t].lo))
+					i_d0 = TRUE;
+				else
+					i_d1 = TRUE;
+			}
+
+			/* check continuity from the top so that the lower-neighbour */
+			/* values are properly filled for the upper trapezoid */
+
+			if ((tr[t].u0 > 0) && (tr[t].u1 > 0)) {			/* continuation of a chain from abv. */
+				if (tr[t].usave > 0) { /* three upper neighbours */
+					if (tr[t].uside == S_LEFT) {
+						tr[tn].u0 = tr[t].u1;
+						tr[t].u1 = -1;
+						tr[tn].u1 = tr[t].usave;
+
+						tr[tr[t].u0].d0 = t;
+						tr[tr[tn].u0].d0 = tn;
+						tr[tr[tn].u1].d0 = tn;
+					} else {	/* intersects in the right */
+						tr[tn].u1 = -1;
+						tr[tn].u0 = tr[t].u1;
+						tr[t].u1 = tr[t].u0;
+						tr[t].u0 = tr[t].usave;
+
+						tr[tr[t].u0].d0 = t;
+						tr[tr[t].u1].d0 = t;
+						tr[tr[tn].u0].d0 = tn;
+					}
+
+					tr[t].usave = tr[tn].usave = 0;
+				} else {	/* No usave.... simple case */
+					tr[tn].u0 = tr[t].u1;
+					tr[tn].u1 = -1;
+					tr[t].u1 = -1;
+					tr[tr[tn].u0].d0 = tn;
+				}
+			} else {			/* fresh seg. or upward cusp */
+				int tmp_u = tr[t].u0;
+				int td0, td1;
+				if (((td0 = tr[tmp_u].d0) > 0) &&
+				                ((td1 = tr[tmp_u].d1) > 0)) {		/* upward cusp */
+					if ((tr[td0].rseg > 0) &&
+					                !is_left_of(tr[td0].rseg, &s.v1)) {
+						tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
+						tr[tr[tn].u0].d1 = tn;
+					} else {
+						tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
+						tr[tr[t].u0].d0 = t;
+					}
+				} else {	/* fresh segment */
+					tr[tr[t].u0].d0 = t;
+					tr[tr[t].u0].d1 = tn;
+				}
+			}
+
+			if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &&
+			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) && tribot) {
+				/* this case arises only at the lowest trapezoid.. i.e.
+				   tlast, if the lower endpoint of the segment is
+				   already inserted in the structure */
+
+				tr[tr[t].d0].u0 = t;
+				tr[tr[t].d0].u1 = -1;
+				tr[tr[t].d1].u0 = tn;
+				tr[tr[t].d1].u1 = -1;
+
+				tr[tn].d0 = tr[t].d1;
+				tr[t].d1 = tr[tn].d1 = -1;
+
+				tnext = tr[t].d1;
+			} else if (i_d0)
 				/* intersecting d0 */
-	    {
-	      tr[tr[t].d0].u0 = t;
-	      tr[tr[t].d0].u1 = tn;
-	      tr[tr[t].d1].u0 = tn;
-	      tr[tr[t].d1].u1 = -1;
-	      
-	      /* new code to determine the bottom neighbours of the */
-	      /* newly partitioned trapezoid */
-	      
-	      tr[t].d1 = -1;
+			{
+				tr[tr[t].d0].u0 = t;
+				tr[tr[t].d0].u1 = tn;
+				tr[tr[t].d1].u0 = tn;
+				tr[tr[t].d1].u1 = -1;
 
-	      tnext = tr[t].d0;
-	    }
-	  else			/* intersecting d1 */
-	    {
-	      tr[tr[t].d0].u0 = t;
-	      tr[tr[t].d0].u1 = -1;
-	      tr[tr[t].d1].u0 = t;
-	      tr[tr[t].d1].u1 = tn;
+				/* new code to determine the bottom neighbours of the */
+				/* newly partitioned trapezoid */
 
-	      /* new code to determine the bottom neighbours of the */
-	      /* newly partitioned trapezoid */
-	      
-	      tr[tn].d0 = tr[t].d1;
-	      tr[tn].d1 = -1;
-	      
-	      tnext = tr[t].d1;
-	    }	    
-	  
-	  t = tnext;
-	}
-      
-      tr[t_sav].rseg = tr[tn_sav].lseg  = segnum;
-    } /* end-while */
-  
-  /* Now combine those trapezoids which share common segments. We can */
-  /* use the pointers to the parent to connect these together. This */
-  /* works only because all these new trapezoids have been formed */
-  /* due to splitting by the segment, and hence have only one parent */
+				tr[t].d1 = -1;
 
-  tfirstl = tfirst; 
-  tlastl = tlast;
-  merge_trapezoids(segnum, tfirstl, tlastl, S_LEFT);
-  merge_trapezoids(segnum, tfirstr, tlastr, S_RIGHT);
+				tnext = tr[t].d0;
+			} else {		/* intersecting d1 */
+				tr[tr[t].d0].u0 = t;
+				tr[tr[t].d0].u1 = -1;
+				tr[tr[t].d1].u0 = t;
+				tr[tr[t].d1].u1 = tn;
 
-  seg[segnum].is_inserted = TRUE;
-  return 0;
+				/* new code to determine the bottom neighbours of the */
+				/* newly partitioned trapezoid */
+
+				tr[tn].d0 = tr[t].d1;
+				tr[tn].d1 = -1;
+
+				tnext = tr[t].d1;
+			}
+
+			t = tnext;
+		}
+
+		tr[t_sav].rseg = tr[tn_sav].lseg  = segnum;
+	} /* end-while */
+
+	/* Now combine those trapezoids which share common segments. We can */
+	/* use the pointers to the parent to connect these together. This */
+	/* works only because all these new trapezoids have been formed */
+	/* due to splitting by the segment, and hence have only one parent */
+
+	tfirstl = tfirst;
+	tlastl = tlast;
+	merge_trapezoids(segnum, tfirstl, tlastl, S_LEFT);
+	merge_trapezoids(segnum, tfirstr, tlastr, S_RIGHT);
+
+	seg[segnum].is_inserted = TRUE;
+	return 0;
 }
 
 
@@ -1049,51 +938,50 @@
  * the segment is inserted into the trapezoidation subsequently
  */
 static int find_new_roots(segnum)
-     int segnum;
+int segnum;
 {
-  segment_t *s = &seg[segnum];
-  
-  if (s->is_inserted)
-    return 0;
+	segment_t *s = &seg[segnum];
 
-  s->root0 = locate_endpoint(&s->v0, &s->v1, s->root0);
-  s->root0 = tr[s->root0].sink;
+	if (s->is_inserted)
+		return 0;
 
-  s->root1 = locate_endpoint(&s->v1, &s->v0, s->root1);
-  s->root1 = tr[s->root1].sink;  
-  return 0;
+	s->root0 = locate_endpoint(&s->v0, &s->v1, s->root0);
+	s->root0 = tr[s->root0].sink;
+
+	s->root1 = locate_endpoint(&s->v1, &s->v0, s->root1);
+	s->root1 = tr[s->root1].sink;
+	return 0;
 }
 
 
 /* Main routine to perform trapezoidation */
 int construct_trapezoids(nseg)
-     int nseg;
+int nseg;
 {
-  register int i;
-  int root, h;
-  
-  /* Add the first segment and get the query structure and trapezoid */
-  /* list initialised */
+	register int i;
+	int root, h;
 
-  root = init_query_structure(choose_segment());
+	/* Add the first segment and get the query structure and trapezoid */
+	/* list initialised */
 
-  for (i = 1; i <= nseg; i++)
-    seg[i].root0 = seg[i].root1 = root;
-  
-  for (h = 1; h <= math_logstar_n(nseg); h++)
-    {
-      for (i = math_N(nseg, h -1) + 1; i <= math_N(nseg, h); i++)
-	add_segment(choose_segment());
-      
-      /* Find a new root for each of the segment endpoints */
-      for (i = 1; i <= nseg; i++)
-	find_new_roots(i);
-    }
-  
-  for (i = math_N(nseg, math_logstar_n(nseg)) + 1; i <= nseg; i++)
-    add_segment(choose_segment());
+	root = init_query_structure(choose_segment());
 
-  return 0;
+	for (i = 1; i <= nseg; i++)
+		seg[i].root0 = seg[i].root1 = root;
+
+	for (h = 1; h <= math_logstar_n(nseg); h++) {
+		for (i = math_N(nseg, h -1) + 1; i <= math_N(nseg, h); i++)
+			add_segment(choose_segment());
+
+		/* Find a new root for each of the segment endpoints */
+		for (i = 1; i <= nseg; i++)
+			find_new_roots(i);
+	}
+
+	for (i = math_N(nseg, math_logstar_n(nseg)) + 1; i <= nseg; i++)
+		add_segment(choose_segment());
+
+	return 0;
 }
 
 

Modified: trunk/libs3d/sei_interface.h
===================================================================
--- trunk/libs3d/sei_interface.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/sei_interface.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,9 +1,9 @@
 /*
  * sei_interface.h
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
- * for public domain: 
+ * for public domain:
  * <snip>
  *
  * This code is in the public domain. Specifically, we give to the public
@@ -20,17 +20,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

Modified: trunk/libs3d/sei_misc.c
===================================================================
--- trunk/libs3d/sei_misc.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/sei_misc.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,9 +1,9 @@
 /*
  * sei_misc.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
- * for public domain: 
+ * for public domain:
  * <snip>
  *
  * This code is in the public domain. Specifically, we give to the public
@@ -20,17 +20,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -44,68 +44,68 @@
 
 static int choose_idx;
 static int permute[SEGSIZE];
-double mlog2(double x) {
-  return log(x)/log(2);
+double mlog2(double x)
+{
+	return log(x)/log(2);
 }
 
 /* Generate a random permutation of the segments 1..n */
 int generate_random_ordering(n)
-     int n;
+int n;
 {
-  struct timeval tval;
-  register int i;
-  int m, st[SEGSIZE], *p;
-  
-  choose_idx = 1;
-  gettimeofday(&tval, NULL);
-  srand48(tval.tv_sec);
+	struct timeval tval;
+	register int i;
+	int m, st[SEGSIZE], *p;
 
-  for (i = 0; i <= n; i++)
-    st[i] = i;
+	choose_idx = 1;
+	gettimeofday(&tval, NULL);
+	srand48(tval.tv_sec);
 
-  p = st;
-  for (i = 1; i <= n; i++, p++)
-    {
-      m = lrand48() % (n + 1 - i) + 1;
-      permute[i] = p[m];
-      if (m != 1)
-	p[m] = p[1];
-    }
-  return 0;
+	for (i = 0; i <= n; i++)
+		st[i] = i;
+
+	p = st;
+	for (i = 1; i <= n; i++, p++) {
+		m = lrand48() % (n + 1 - i) + 1;
+		permute[i] = p[m];
+		if (m != 1)
+			p[m] = p[1];
+	}
+	return 0;
 }
 
-  
+
 /* Return the next segment in the generated random ordering of all the */
 /* segments in S */
 int choose_segment()
 {
-  errds(VLOW,"sei:choose_segment()","%d", permute[choose_idx]);
-  return permute[choose_idx++];
+	errds(VLOW,"sei:choose_segment()","%d", permute[choose_idx]);
+	return permute[choose_idx++];
 }
 
 /* Get log*n for given n */
 int math_logstar_n(n)
-     int n;
+int n;
 {
-  register int i;
-  double v;
-  
-  for (i = 0, v = (double) n; v >= 1; i++)
-    v = mlog2(v);
-  
-  return (i - 1);
+	register int i;
+	double v;
+
+	for (i = 0, v = (double) n; v >= 1; i++)
+		v = mlog2(v);
+
+	return (i - 1);
 }
-  
 
+
 int math_N(n, h)
-     int n;
-     int h;
+int n;
+int h;
 {
-  register int i;
-  double v;
+	register int i;
+	double v;
 
-  for (i = 0, v = (int) n; i < h; i++)
-    v = mlog2(v);
-  
-  return (int) ceil((double) 1.0*n/v);
+	for (i = 0, v = (int) n; i < h; i++)
+		v = mlog2(v);
+
+	return (int) ceil((double) 1.0*n/v);
 }

Modified: trunk/libs3d/sei_monotone.c
===================================================================
--- trunk/libs3d/sei_monotone.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/sei_monotone.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,9 +1,9 @@
 /*
  * sei_monotone.c
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
- * for public domain: 
+ * for public domain:
  * <snip>
  *
  * This code is in the public domain. Specifically, we give to the public
@@ -20,17 +20,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -45,18 +45,18 @@
 #define LENGTH(v0) (sqrt((v0).x * (v0).x + (v0).y * (v0).y))
 
 static monchain_t mchain[TRSIZE]; /* Table to hold all the monotone */
-				  /* polygons . Each monotone polygon */
-				  /* is a circularly linked list */
+/* polygons . Each monotone polygon */
+/* is a circularly linked list */
 
 static vertexchain_t vert[SEGSIZE]; /* chain init. information. This */
-				    /* is used to decide which */
-				    /* monotone polygon to split if */
-				    /* there are several other */
-				    /* polygons touching at the same */
-				    /* vertex  */
+/* is used to decide which */
+/* monotone polygon to split if */
+/* there are several other */
+/* polygons touching at the same */
+/* vertex  */
 
 static int mon[SEGSIZE];	/* contains position of any vertex in */
-				/* the monotone chain for the polygon */
+/* the monotone chain for the polygon */
 static int visited[TRSIZE];
 static int chain_idx, op_idx, mon_idx;
 
@@ -66,534 +66,473 @@
 
 /* Function returns TRUE if the trapezoid lies inside the polygon */
 static int inside_polygon(t)
-     trap_t *t;
+trap_t *t;
 {
-  int rseg = t->rseg;
+	int rseg = t->rseg;
 
-  if (t->state == ST_INVALID)
-    return 0;
+	if (t->state == ST_INVALID)
+		return 0;
 
-  if ((t->lseg <= 0) || (t->rseg <= 0))
-    return 0;
-  
-  if (((t->u0 <= 0) && (t->u1 <= 0)) || 
-      ((t->d0 <= 0) && (t->d1 <= 0))) /* triangle */
-    return (_greater_than(&seg[rseg].v1, &seg[rseg].v0));
-  
-  return 0;
+	if ((t->lseg <= 0) || (t->rseg <= 0))
+		return 0;
+
+	if (((t->u0 <= 0) && (t->u1 <= 0)) ||
+	                ((t->d0 <= 0) && (t->d1 <= 0))) /* triangle */
+		return (_greater_than(&seg[rseg].v1, &seg[rseg].v0));
+
+	return 0;
 }
 
 
 /* return a new mon structure from the table */
 static int newmon()
 {
-  return ++mon_idx;
+	return ++mon_idx;
 }
 
 
 /* return a new chain element from the table */
 static int new_chain_element()
 {
-  return ++chain_idx;
+	return ++chain_idx;
 }
 
 
 static double get_angle(vp0, vpnext, vp1)
-     point_t *vp0;
-     point_t *vpnext;
-     point_t *vp1;
+point_t *vp0;
+point_t *vpnext;
+point_t *vp1;
 {
-  point_t v0, v1;
-  
-  v0.x = vpnext->x - vp0->x;
-  v0.y = vpnext->y - vp0->y;
+	point_t v0, v1;
 
-  v1.x = vp1->x - vp0->x;
-  v1.y = vp1->y - vp0->y;
+	v0.x = vpnext->x - vp0->x;
+	v0.y = vpnext->y - vp0->y;
 
-  if (CROSS_SINE(v0, v1) >= 0)	/* sine is positive */
-    return DOT(v0, v1)/LENGTH(v0)/LENGTH(v1);
-  else
-    return (-1.0 * DOT(v0, v1)/LENGTH(v0)/LENGTH(v1) - 2);
+	v1.x = vp1->x - vp0->x;
+	v1.y = vp1->y - vp0->y;
+
+	if (CROSS_SINE(v0, v1) >= 0)	/* sine is positive */
+		return DOT(v0, v1)/LENGTH(v0)/LENGTH(v1);
+	else
+		return (-1.0 * DOT(v0, v1)/LENGTH(v0)/LENGTH(v1) - 2);
 }
 
 
 /* (v0, v1) is the new diagonal to be added to the polygon. Find which */
-/* chain to use and return the positions of v0 and v1 in p and q */ 
+/* chain to use and return the positions of v0 and v1 in p and q */
 static int get_vertex_positions(v0, v1, ip, iq)
-     int v0;
-     int v1;
-     int *ip;
-     int *iq;
+int v0;
+int v1;
+int *ip;
+int *iq;
 {
-  vertexchain_t *vp0, *vp1;
-  register int i;
-  double angle, temp;
-  int tp, tq;
+	vertexchain_t *vp0, *vp1;
+	register int i;
+	double angle, temp;
+	int tp, tq;
 
-  tp = tq = 0;
-  
-  vp0 = &vert[v0];
-  vp1 = &vert[v1];
-  
-  /* p is identified as follows. Scan from (v0, v1) rightwards till */
-  /* you hit the first segment starting from v0. That chain is the */
-  /* chain of our interest */
-  
-  angle = -4.0;
-  for (i = 0; i < 4; i++)
-    {
-      if (vp0->vnext[i] <= 0)
-	continue;
-      if ((temp = get_angle(&vp0->pt, &(vert[vp0->vnext[i]].pt), 
-			    &vp1->pt)) > angle)
-	{
-	  angle = temp;
-	  tp = i;
+	tp = tq = 0;
+
+	vp0 = &vert[v0];
+	vp1 = &vert[v1];
+
+	/* p is identified as follows. Scan from (v0, v1) rightwards till */
+	/* you hit the first segment starting from v0. That chain is the */
+	/* chain of our interest */
+
+	angle = -4.0;
+	for (i = 0; i < 4; i++) {
+		if (vp0->vnext[i] <= 0)
+			continue;
+		if ((temp = get_angle(&vp0->pt, &(vert[vp0->vnext[i]].pt),
+		                      &vp1->pt)) > angle) {
+			angle = temp;
+			tp = i;
+		}
 	}
-    }
 
-  *ip = tp;
+	*ip = tp;
 
-  /* Do similar actions for q */
+	/* Do similar actions for q */
 
-  angle = -4.0;
-  for (i = 0; i < 4; i++)
-    {
-      if (vp1->vnext[i] <= 0)
-	continue;      
-      if ((temp = get_angle(&vp1->pt, &(vert[vp1->vnext[i]].pt), 
-			    &vp0->pt)) > angle)
-	{
-	  angle = temp;
-	  tq = i;
+	angle = -4.0;
+	for (i = 0; i < 4; i++) {
+		if (vp1->vnext[i] <= 0)
+			continue;
+		if ((temp = get_angle(&vp1->pt, &(vert[vp1->vnext[i]].pt),
+		                      &vp0->pt)) > angle) {
+			angle = temp;
+			tq = i;
+		}
 	}
-    }
 
-  *iq = tq;
+	*iq = tq;
 
-  return 0;
+	return 0;
 }
 
-  
-/* v0 and v1 are specified in anti-clockwise order with respect to 
- * the current monotone polygon mcur. Split the current polygon into 
- * two polygons using the diagonal (v0, v1) 
+
+/* v0 and v1 are specified in anti-clockwise order with respect to
+ * the current monotone polygon mcur. Split the current polygon into
+ * two polygons using the diagonal (v0, v1)
  */
 static int make_new_monotone_poly(mcur, v0, v1)
-     int mcur;
-     int v0;
-     int v1;
+int mcur;
+int v0;
+int v1;
 {
-  int p, q, ip, iq;
-  int mnew = newmon();
-  int i, j, nf0, nf1;
-  vertexchain_t *vp0, *vp1;
-  
-  vp0 = &vert[v0];
-  vp1 = &vert[v1];
+	int p, q, ip, iq;
+	int mnew = newmon();
+	int i, j, nf0, nf1;
+	vertexchain_t *vp0, *vp1;
 
-  get_vertex_positions(v0, v1, &ip, &iq);
+	vp0 = &vert[v0];
+	vp1 = &vert[v1];
 
-  p = vp0->vpos[ip];
-  q = vp1->vpos[iq];
+	get_vertex_positions(v0, v1, &ip, &iq);
 
-  /* At this stage, we have got the positions of v0 and v1 in the */
-  /* desired chain. Now modify the linked lists */
+	p = vp0->vpos[ip];
+	q = vp1->vpos[iq];
 
-  i = new_chain_element();	/* for the new list */
-  j = new_chain_element();
+	/* At this stage, we have got the positions of v0 and v1 in the */
+	/* desired chain. Now modify the linked lists */
 
-  mchain[i].vnum = v0;
-  mchain[j].vnum = v1;
+	i = new_chain_element();	/* for the new list */
+	j = new_chain_element();
 
-  mchain[i].next = mchain[p].next;
-  mchain[mchain[p].next].prev = i;
-  mchain[i].prev = j;
-  mchain[j].next = i;
-  mchain[j].prev = mchain[q].prev;
-  mchain[mchain[q].prev].next = j;
+	mchain[i].vnum = v0;
+	mchain[j].vnum = v1;
 
-  mchain[p].next = q;
-  mchain[q].prev = p;
+	mchain[i].next = mchain[p].next;
+	mchain[mchain[p].next].prev = i;
+	mchain[i].prev = j;
+	mchain[j].next = i;
+	mchain[j].prev = mchain[q].prev;
+	mchain[mchain[q].prev].next = j;
 
-  nf0 = vp0->nextfree;
-  nf1 = vp1->nextfree;
+	mchain[p].next = q;
+	mchain[q].prev = p;
 
-  vp0->vnext[ip] = v1;
+	nf0 = vp0->nextfree;
+	nf1 = vp1->nextfree;
 
-  vp0->vpos[nf0] = i;
-  vp0->vnext[nf0] = mchain[mchain[i].next].vnum;
-  vp1->vpos[nf1] = j;
-  vp1->vnext[nf1] = v0;
+	vp0->vnext[ip] = v1;
 
-  vp0->nextfree++;
-  vp1->nextfree++;
+	vp0->vpos[nf0] = i;
+	vp0->vnext[nf0] = mchain[mchain[i].next].vnum;
+	vp1->vpos[nf1] = j;
+	vp1->vnext[nf1] = v0;
 
-  errds(VLOW,"sei:make_poly()",": mcur = %d, (v0, v1) = (%d, %d)", mcur, v0, v1);
-  errds(VLOW,"sei:make_poly()","next posns = (p, q) = (%d, %d)", p, q);
+	vp0->nextfree++;
+	vp1->nextfree++;
 
-  mon[mcur] = p;
-  mon[mnew] = i;
-  return mnew;
+	errds(VLOW,"sei:make_poly()",": mcur = %d, (v0, v1) = (%d, %d)", mcur, v0, v1);
+	errds(VLOW,"sei:make_poly()","next posns = (p, q) = (%d, %d)", p, q);
+
+	mon[mcur] = p;
+	mon[mnew] = i;
+	return mnew;
 }
 
-/* Main routine to get monotone polygons from the trapezoidation of 
+/* Main routine to get monotone polygons from the trapezoidation of
  * the polygon.
  */
 
 int monotonate_trapezoids(n)
-     int n;
+int n;
 {
-  register int i;
-  int tr_start;
+	register int i;
+	int tr_start;
 
-  memset((void *)vert, 0, sizeof(vert));
-  memset((void *)visited, 0, sizeof(visited));
-  memset((void *)mchain, 0, sizeof(mchain));
-  memset((void *)mon, 0, sizeof(mon));
-  
-  /* First locate a trapezoid which lies inside the polygon */
-  /* and which is triangular */
-  for (i = 0; i < TRSIZE; i++)
-    if (inside_polygon(&tr[i]))
-      break;
-  tr_start = i;
-  
-  /* Initialise the mon data-structure and start spanning all the */
-  /* trapezoids within the polygon */
+	memset((void *)vert, 0, sizeof(vert));
+	memset((void *)visited, 0, sizeof(visited));
+	memset((void *)mchain, 0, sizeof(mchain));
+	memset((void *)mon, 0, sizeof(mon));
 
+	/* First locate a trapezoid which lies inside the polygon */
+	/* and which is triangular */
+	for (i = 0; i < TRSIZE; i++)
+		if (inside_polygon(&tr[i]))
+			break;
+	tr_start = i;
+
+	/* Initialise the mon data-structure and start spanning all the */
+	/* trapezoids within the polygon */
+
 #if 0
-  for (i = 1; i <= n; i++)
-    {
-      mchain[i].prev = i - 1;
-      mchain[i].next = i + 1;
-      mchain[i].vnum = i;
-      vert[i].pt = seg[i].v0;
-      vert[i].vnext[0] = i + 1;	/* next vertex */
-      vert[i].vpos[0] = i;	/* locn. of next vertex */
-      vert[i].nextfree = 1;
-    }
-  mchain[1].prev = n;
-  mchain[n].next = 1;
-  vert[n].vnext[0] = 1;
-  vert[n].vpos[0] = n;
-  chain_idx = n;
-  mon_idx = 0;
-  mon[0] = 1;			/* position of any vertex in the first */
-				/* chain  */
+	for (i = 1; i <= n; i++) {
+		mchain[i].prev = i - 1;
+		mchain[i].next = i + 1;
+		mchain[i].vnum = i;
+		vert[i].pt = seg[i].v0;
+		vert[i].vnext[0] = i + 1;	/* next vertex */
+		vert[i].vpos[0] = i;	/* locn. of next vertex */
+		vert[i].nextfree = 1;
+	}
+	mchain[1].prev = n;
+	mchain[n].next = 1;
+	vert[n].vnext[0] = 1;
+	vert[n].vpos[0] = n;
+	chain_idx = n;
+	mon_idx = 0;
+	mon[0] = 1;			/* position of any vertex in the first */
+	/* chain  */
 
 #else
 
-  for (i = 1; i <= n; i++)
-    {
-      mchain[i].prev = seg[i].prev;
-      mchain[i].next = seg[i].next;
-      mchain[i].vnum = i;
-      vert[i].pt = seg[i].v0;
-      vert[i].vnext[0] = seg[i].next; /* next vertex */
-      vert[i].vpos[0] = i;	/* locn. of next vertex */
-      vert[i].nextfree = 1;
-    }
+	for (i = 1; i <= n; i++) {
+		mchain[i].prev = seg[i].prev;
+		mchain[i].next = seg[i].next;
+		mchain[i].vnum = i;
+		vert[i].pt = seg[i].v0;
+		vert[i].vnext[0] = seg[i].next; /* next vertex */
+		vert[i].vpos[0] = i;	/* locn. of next vertex */
+		vert[i].nextfree = 1;
+	}
 
-  chain_idx = n;
-  mon_idx = 0;
-  mon[0] = 1;			/* position of any vertex in the first */
-				/* chain  */
+	chain_idx = n;
+	mon_idx = 0;
+	mon[0] = 1;			/* position of any vertex in the first */
+	/* chain  */
 
 #endif
-  
-  /* traverse the polygon */
-  if (tr[tr_start].u0 > 0)
-    traverse_polygon(0, tr_start, tr[tr_start].u0, TR_FROM_UP);
-  else if (tr[tr_start].d0 > 0)
-    traverse_polygon(0, tr_start, tr[tr_start].d0, TR_FROM_DN);
-  
-  /* return the number of polygons created */
-  return newmon();
+
+	/* traverse the polygon */
+	if (tr[tr_start].u0 > 0)
+		traverse_polygon(0, tr_start, tr[tr_start].u0, TR_FROM_UP);
+	else if (tr[tr_start].d0 > 0)
+		traverse_polygon(0, tr_start, tr[tr_start].d0, TR_FROM_DN);
+
+	/* return the number of polygons created */
+	return newmon();
 }
 
 
 /* recursively visit all the trapezoids */
 static int traverse_polygon(mcur, trnum, from, dir)
-     int mcur;
-     int trnum;
-     int from;
-     int dir;
+int mcur;
+int trnum;
+int from;
+int dir;
 {
-  trap_t *t = &tr[trnum];
-  int mnew;
-  int v0, v1;
-  int retval = -1;
-  int do_switch = FALSE;
+	trap_t *t = &tr[trnum];
+	int mnew;
+	int v0, v1;
+	int retval = -1;
+	int do_switch = FALSE;
 
-  if ((trnum <= 0) || visited[trnum])
-    return 0;
+	if ((trnum <= 0) || visited[trnum])
+		return 0;
 
-  visited[trnum] = TRUE;
-  
-  /* We have much more information available here. */
-  /* rseg: goes upwards   */
-  /* lseg: goes downwards */
+	visited[trnum] = TRUE;
 
-  /* Initially assume that dir = TR_FROM_DN (from the left) */
-  /* Switch v0 and v1 if necessary afterwards */
+	/* We have much more information available here. */
+	/* rseg: goes upwards   */
+	/* lseg: goes downwards */
 
+	/* Initially assume that dir = TR_FROM_DN (from the left) */
+	/* Switch v0 and v1 if necessary afterwards */
 
-  /* special cases for triangles with cusps at the opposite ends. */
-  /* take care of this first */
-  if ((t->u0 <= 0) && (t->u1 <= 0))
-    {
-      if ((t->d0 > 0) && (t->d1 > 0)) /* downward opening triangle */
-	{
-	  v0 = tr[t->d1].lseg;
-	  v1 = t->lseg;
-	  if (from == t->d1)
-	    {
-	      do_switch = TRUE;
-	      mnew = make_new_monotone_poly(mcur, v1, v0);
-	      traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
-	      traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);	    
-	    }
-	  else
-	    {
-	      mnew = make_new_monotone_poly(mcur, v0, v1);
-	      traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
-	      traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
-	    }
-	}
-      else
-	{
-	  retval = SP_NOSPLIT;	/* Just traverse all neighbours */
-	  traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
-	  traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
-	  traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
-	  traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
-	}
-    }
-  
-  else if ((t->d0 <= 0) && (t->d1 <= 0))
-    {
-      if ((t->u0 > 0) && (t->u1 > 0)) /* upward opening triangle */
-	{
-	  v0 = t->rseg;
-	  v1 = tr[t->u0].rseg;
-	  if (from == t->u1)
-	    {
-	      do_switch = TRUE;
-	      mnew = make_new_monotone_poly(mcur, v1, v0);
-	      traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
-	      traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);	    
-	    }
-	  else
-	    {
-	      mnew = make_new_monotone_poly(mcur, v0, v1);
-	      traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
-	      traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
-	    }
-	}
-      else
-	{
-	  retval = SP_NOSPLIT;	/* Just traverse all neighbours */
-	  traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
-	  traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
-	  traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
-	  traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
-	}
-    }
-  
-  else if ((t->u0 > 0) && (t->u1 > 0)) 
-    {
-      if ((t->d0 > 0) && (t->d1 > 0)) /* downward + upward cusps */
-	{
-	  v0 = tr[t->d1].lseg;
-	  v1 = tr[t->u0].rseg;
-	  retval = SP_2UP_2DN;
-	  if (((dir == TR_FROM_DN) && (t->d1 == from)) ||
-	      ((dir == TR_FROM_UP) && (t->u1 == from)))
-	    {
-	      do_switch = TRUE;
-	      mnew = make_new_monotone_poly(mcur, v1, v0);
-	      traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
-	      traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
-	      traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
-	      traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
-	    }
-	  else
-	    {
-	      mnew = make_new_monotone_poly(mcur, v0, v1);
-	      traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
-	      traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
-	      traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
-	      traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);	      
-	    }
-	}
-      else			/* only downward cusp */
-	{
-	  if (_equal_to(&t->lo, &seg[t->lseg].v1))
-	    {
-	      v0 = tr[t->u0].rseg;
-	      v1 = seg[t->lseg].next;
 
-	      retval = SP_2UP_LEFT;
-	      if ((dir == TR_FROM_UP) && (t->u0 == from))
-		{
-		  do_switch = TRUE;
-		  mnew = make_new_monotone_poly(mcur, v1, v0);
-		  traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
+	/* special cases for triangles with cusps at the opposite ends. */
+	/* take care of this first */
+	if ((t->u0 <= 0) && (t->u1 <= 0)) {
+		if ((t->d0 > 0) && (t->d1 > 0)) { /* downward opening triangle */
+			v0 = tr[t->d1].lseg;
+			v1 = t->lseg;
+			if (from == t->d1) {
+				do_switch = TRUE;
+				mnew = make_new_monotone_poly(mcur, v1, v0);
+				traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
+				traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
+			} else {
+				mnew = make_new_monotone_poly(mcur, v0, v1);
+				traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
+				traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
+			}
+		} else {
+			retval = SP_NOSPLIT;	/* Just traverse all neighbours */
+			traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
+			traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
+			traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
+			traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
 		}
-	      else
-		{
-		  mnew = make_new_monotone_poly(mcur, v0, v1);
-		  traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
-		}
-	    }
-	  else
-	    {
-	      v0 = t->rseg;
-	      v1 = tr[t->u0].rseg;	
-	      retval = SP_2UP_RIGHT;
-	      if ((dir == TR_FROM_UP) && (t->u1 == from))
-		{
-		  do_switch = TRUE;
-		  mnew = make_new_monotone_poly(mcur, v1, v0);
-		  traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
-		}
-	      else
-		{
-		  mnew = make_new_monotone_poly(mcur, v0, v1);
-		  traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
-		}
-	    }
 	}
-    }
-  else if ((t->u0 > 0) || (t->u1 > 0)) /* no downward cusp */
-    {
-      if ((t->d0 > 0) && (t->d1 > 0)) /* only upward cusp */
-	{
-	  if (_equal_to(&t->hi, &seg[t->lseg].v0))
-	    {
-	      v0 = tr[t->d1].lseg;
-	      v1 = t->lseg;
-	      retval = SP_2DN_LEFT;
-	      if (!((dir == TR_FROM_DN) && (t->d0 == from)))
-		{
-		  do_switch = TRUE;
-		  mnew = make_new_monotone_poly(mcur, v1, v0);
-		  traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
-		}
-	      else
-		{
-		  mnew = make_new_monotone_poly(mcur, v0, v1);
-		  traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);	      
-		}
-	    }
-	  else
-	    {
-	      v0 = tr[t->d1].lseg;
-	      v1 = seg[t->rseg].next;
 
-	      retval = SP_2DN_RIGHT;	    
-	      if ((dir == TR_FROM_DN) && (t->d1 == from))
-		{
-		  do_switch = TRUE;
-		  mnew = make_new_monotone_poly(mcur, v1, v0);
-		  traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
+	else if ((t->d0 <= 0) && (t->d1 <= 0)) {
+		if ((t->u0 > 0) && (t->u1 > 0)) { /* upward opening triangle */
+			v0 = t->rseg;
+			v1 = tr[t->u0].rseg;
+			if (from == t->u1) {
+				do_switch = TRUE;
+				mnew = make_new_monotone_poly(mcur, v1, v0);
+				traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
+				traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
+			} else {
+				mnew = make_new_monotone_poly(mcur, v0, v1);
+				traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
+				traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
+			}
+		} else {
+			retval = SP_NOSPLIT;	/* Just traverse all neighbours */
+			traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
+			traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
+			traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
+			traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
 		}
-	      else
-		{
-		  mnew = make_new_monotone_poly(mcur, v0, v1);
-		  traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
-		}
-	    }
 	}
-      else			/* no cusp */
-	{
-	  if (_equal_to(&t->hi, &seg[t->lseg].v0) &&
-	      _equal_to(&t->lo, &seg[t->rseg].v0))
-	    {
-	      v0 = t->rseg;
-	      v1 = t->lseg;
-	      retval = SP_SIMPLE_LRDN;
-	      if (dir == TR_FROM_UP)
-		{
-		  do_switch = TRUE;
-		  mnew = make_new_monotone_poly(mcur, v1, v0);
-		  traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
+
+	else if ((t->u0 > 0) && (t->u1 > 0)) {
+		if ((t->d0 > 0) && (t->d1 > 0)) { /* downward + upward cusps */
+			v0 = tr[t->d1].lseg;
+			v1 = tr[t->u0].rseg;
+			retval = SP_2UP_2DN;
+			if (((dir == TR_FROM_DN) && (t->d1 == from)) ||
+			                ((dir == TR_FROM_UP) && (t->u1 == from))) {
+				do_switch = TRUE;
+				mnew = make_new_monotone_poly(mcur, v1, v0);
+				traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
+				traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
+				traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
+				traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
+			} else {
+				mnew = make_new_monotone_poly(mcur, v0, v1);
+				traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
+				traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
+				traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
+				traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
+			}
+		} else {		/* only downward cusp */
+			if (_equal_to(&t->lo, &seg[t->lseg].v1)) {
+				v0 = tr[t->u0].rseg;
+				v1 = seg[t->lseg].next;
+
+				retval = SP_2UP_LEFT;
+				if ((dir == TR_FROM_UP) && (t->u0 == from)) {
+					do_switch = TRUE;
+					mnew = make_new_monotone_poly(mcur, v1, v0);
+					traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
+				} else {
+					mnew = make_new_monotone_poly(mcur, v0, v1);
+					traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
+					traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
+					traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
+				}
+			} else {
+				v0 = t->rseg;
+				v1 = tr[t->u0].rseg;
+				retval = SP_2UP_RIGHT;
+				if ((dir == TR_FROM_UP) && (t->u1 == from)) {
+					do_switch = TRUE;
+					mnew = make_new_monotone_poly(mcur, v1, v0);
+					traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
+				} else {
+					mnew = make_new_monotone_poly(mcur, v0, v1);
+					traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
+					traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
+					traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
+				}
+			}
 		}
-	      else
-		{
-		  mnew = make_new_monotone_poly(mcur, v0, v1);
-		  traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
-		}
-	    }
-	  else if (_equal_to(&t->hi, &seg[t->rseg].v1) &&
-		   _equal_to(&t->lo, &seg[t->lseg].v1))
-	    {
-	      v0 = seg[t->rseg].next;
-	      v1 = seg[t->lseg].next;
+	} else if ((t->u0 > 0) || (t->u1 > 0)) { /* no downward cusp */
+		if ((t->d0 > 0) && (t->d1 > 0)) { /* only upward cusp */
+			if (_equal_to(&t->hi, &seg[t->lseg].v0)) {
+				v0 = tr[t->d1].lseg;
+				v1 = t->lseg;
+				retval = SP_2DN_LEFT;
+				if (!((dir == TR_FROM_DN) && (t->d0 == from))) {
+					do_switch = TRUE;
+					mnew = make_new_monotone_poly(mcur, v1, v0);
+					traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
+					traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
+					traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
+				} else {
+					mnew = make_new_monotone_poly(mcur, v0, v1);
+					traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
+				}
+			} else {
+				v0 = tr[t->d1].lseg;
+				v1 = seg[t->rseg].next;
 
-	      retval = SP_SIMPLE_LRUP;
-	      if (dir == TR_FROM_UP)
-		{
-		  do_switch = TRUE;
-		  mnew = make_new_monotone_poly(mcur, v1, v0);
-		  traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
+				retval = SP_2DN_RIGHT;
+				if ((dir == TR_FROM_DN) && (t->d1 == from)) {
+					do_switch = TRUE;
+					mnew = make_new_monotone_poly(mcur, v1, v0);
+					traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
+				} else {
+					mnew = make_new_monotone_poly(mcur, v0, v1);
+					traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
+					traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
+					traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
+				}
+			}
+		} else {		/* no cusp */
+			if (_equal_to(&t->hi, &seg[t->lseg].v0) &&
+			                _equal_to(&t->lo, &seg[t->rseg].v0)) {
+				v0 = t->rseg;
+				v1 = t->lseg;
+				retval = SP_SIMPLE_LRDN;
+				if (dir == TR_FROM_UP) {
+					do_switch = TRUE;
+					mnew = make_new_monotone_poly(mcur, v1, v0);
+					traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
+					traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
+				} else {
+					mnew = make_new_monotone_poly(mcur, v0, v1);
+					traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
+					traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
+				}
+			} else if (_equal_to(&t->hi, &seg[t->rseg].v1) &&
+			                _equal_to(&t->lo, &seg[t->lseg].v1)) {
+				v0 = seg[t->rseg].next;
+				v1 = seg[t->lseg].next;
+
+				retval = SP_SIMPLE_LRUP;
+				if (dir == TR_FROM_UP) {
+					do_switch = TRUE;
+					mnew = make_new_monotone_poly(mcur, v1, v0);
+					traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
+					traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t->d0, trnum, TR_FROM_UP);
+				} else {
+					mnew = make_new_monotone_poly(mcur, v0, v1);
+					traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
+					traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
+					traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
+					traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
+				}
+			} else {		/* no split possible */
+				retval = SP_NOSPLIT;
+				traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
+				traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
+				traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
+				traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
+			}
 		}
-	      else
-		{
-		  mnew = make_new_monotone_poly(mcur, v0, v1);
-		  traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);
-		  traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
-		  traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
-		  traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
-		}
-	    }
-	  else			/* no split possible */
-	    {
-	      retval = SP_NOSPLIT;
-	      traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
-	      traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
-	      traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
-	      traverse_polygon(mcur, t->d1, trnum, TR_FROM_UP);	      	      
-	    }
 	}
-    }
 
-  return retval;
+	return retval;
 }
 
 
@@ -603,157 +542,138 @@
 /* Take care not to triangulate duplicate monotone polygons */
 
 int triangulate_monotone_polygons(nvert, nmonpoly, op)
-     int nvert;
-     int nmonpoly;
-     int op[][3];
+int nvert;
+int nmonpoly;
+int op[][3];
 {
-  register int i;
-  point_t ymax, ymin;
-  int p, vfirst, posmax, posmin, v;
-  int vcount, processed;
+	register int i;
+	point_t ymax, ymin;
+	int p, vfirst, posmax, posmin, v;
+	int vcount, processed;
 
 
-  op_idx = 0;
-  for (i = 0; i < nmonpoly; i++)
-    {
-      vcount = 1;
-      processed = FALSE;
-      vfirst = mchain[mon[i]].vnum;
-      ymax = ymin = vert[vfirst].pt;
-      posmax = posmin = mon[i];
-      mchain[mon[i]].marked = TRUE;
-      p = mchain[mon[i]].next;
-      while ((v = mchain[p].vnum) != vfirst)
-	{
-	 if (mchain[p].marked)
-	   {
-	     processed = TRUE;
-	     break;		/* break from while */
-	   }
-	 else
-	   mchain[p].marked = TRUE;
+	op_idx = 0;
+	for (i = 0; i < nmonpoly; i++) {
+		vcount = 1;
+		processed = FALSE;
+		vfirst = mchain[mon[i]].vnum;
+		ymax = ymin = vert[vfirst].pt;
+		posmax = posmin = mon[i];
+		mchain[mon[i]].marked = TRUE;
+		p = mchain[mon[i]].next;
+		while ((v = mchain[p].vnum) != vfirst) {
+			if (mchain[p].marked) {
+				processed = TRUE;
+				break;		/* break from while */
+			} else
+				mchain[p].marked = TRUE;
 
-	  if (_greater_than(&vert[v].pt, &ymax))
-	    {
-	      ymax = vert[v].pt;
-	      posmax = p;
-	    }
-	  if (_less_than(&vert[v].pt, &ymin))
-	    {
-	      ymin = vert[v].pt;
-	      posmin = p;
-	    }
-	  p = mchain[p].next;
-	  vcount++;
-       }
+			if (_greater_than(&vert[v].pt, &ymax)) {
+				ymax = vert[v].pt;
+				posmax = p;
+			}
+			if (_less_than(&vert[v].pt, &ymin)) {
+				ymin = vert[v].pt;
+				posmin = p;
+			}
+			p = mchain[p].next;
+			vcount++;
+		}
 
-      if (processed)		/* Go to next polygon */
-	continue;
-      
-      if (vcount == 3)		/* already a triangle */
-	{
-	  op[op_idx][0] = mchain[p].vnum;
-	  op[op_idx][1] = mchain[mchain[p].next].vnum;
-	  op[op_idx][2] = mchain[mchain[p].prev].vnum;
-	  op_idx++;
+		if (processed)		/* Go to next polygon */
+			continue;
+
+		if (vcount == 3) {	/* already a triangle */
+			op[op_idx][0] = mchain[p].vnum;
+			op[op_idx][1] = mchain[mchain[p].next].vnum;
+			op[op_idx][2] = mchain[mchain[p].prev].vnum;
+			op_idx++;
+		} else {		/* triangulate the polygon */
+			v = mchain[mchain[posmax].next].vnum;
+			if (_equal_to(&vert[v].pt, &ymin)) {			/* LHS is a single line */
+				triangulate_single_polygon(nvert, posmax, TRI_LHS, op);
+			} else
+				triangulate_single_polygon(nvert, posmax, TRI_RHS, op);
+		}
 	}
-      else			/* triangulate the polygon */
-	{
-	  v = mchain[mchain[posmax].next].vnum;
-	  if (_equal_to(&vert[v].pt, &ymin))
-	    {			/* LHS is a single line */
-	      triangulate_single_polygon(nvert, posmax, TRI_LHS, op);
-	    }
-	  else
-	    triangulate_single_polygon(nvert, posmax, TRI_RHS, op);
-	}
-    }
-  
-  for (i = 0; i < op_idx; i++)
-    errds(VLOW,"sei:triangulate_monotone_polygons()","tri #%d: (%d, %d, %d)\n", i, op[i][0], op[i][1],
-	   op[i][2]);
-  return op_idx;
+
+	for (i = 0; i < op_idx; i++)
+		errds(VLOW,"sei:triangulate_monotone_polygons()","tri #%d: (%d, %d, %d)\n", i, op[i][0], op[i][1],
+		      op[i][2]);
+	return op_idx;
 }
 
 
-/* A greedy corner-cutting algorithm to triangulate a y-monotone 
+/* A greedy corner-cutting algorithm to triangulate a y-monotone
  * polygon in O(n) time.
  * Joseph O-Rourke, Computational Geometry in C.
  */
 static int triangulate_single_polygon(nvert, posmax, side, op)
-     int nvert;
-     int posmax;
-     int side;
-     int op[][3];
+int nvert;
+int posmax;
+int side;
+int op[][3];
 {
-  register int v;
-  int rc[SEGSIZE], ri = 0;	/* reflex chain */
-  int endv, tmp, vpos;
-  
-  if (side == TRI_RHS)		/* RHS segment is a single segment */
-    {
-      rc[0] = mchain[posmax].vnum;
-      tmp = mchain[posmax].next;
-      rc[1] = mchain[tmp].vnum;
-      ri = 1;
-      
-      vpos = mchain[tmp].next;
-      v = mchain[vpos].vnum;
-      
-      if ((endv = mchain[mchain[posmax].prev].vnum) == 0)
-	endv = nvert;
-    }
-  else				/* LHS is a single segment */
-    {
-      tmp = mchain[posmax].next;
-      rc[0] = mchain[tmp].vnum;
-      tmp = mchain[tmp].next;
-      rc[1] = mchain[tmp].vnum;
-      ri = 1;
+	register int v;
+	int rc[SEGSIZE], ri = 0;	/* reflex chain */
+	int endv, tmp, vpos;
 
-      vpos = mchain[tmp].next;
-      v = mchain[vpos].vnum;
+	if (side == TRI_RHS) {	/* RHS segment is a single segment */
+		rc[0] = mchain[posmax].vnum;
+		tmp = mchain[posmax].next;
+		rc[1] = mchain[tmp].vnum;
+		ri = 1;
 
-      endv = mchain[posmax].vnum;
-    }
-  
-  while ((v != endv) || (ri > 1))
-    {
-      if (ri > 0)		/* reflex chain is non-empty */
-	{
-	  if (CROSS(vert[v].pt, vert[rc[ri - 1]].pt, 
-		    vert[rc[ri]].pt) > 0)
-	    {			/* convex corner: cut if off */
-	      op[op_idx][0] = rc[ri - 1];
-	      op[op_idx][1] = rc[ri];
-	      op[op_idx][2] = v;
-	      op_idx++;	     
-	      ri--;
-	    }
-	  else		/* non-convex */
-	    {		/* add v to the chain */
-	      ri++;
-	      rc[ri] = v;
-	      vpos = mchain[vpos].next;
-	      v = mchain[vpos].vnum;
-	    }
+		vpos = mchain[tmp].next;
+		v = mchain[vpos].vnum;
+
+		if ((endv = mchain[mchain[posmax].prev].vnum) == 0)
+			endv = nvert;
+	} else {			/* LHS is a single segment */
+		tmp = mchain[posmax].next;
+		rc[0] = mchain[tmp].vnum;
+		tmp = mchain[tmp].next;
+		rc[1] = mchain[tmp].vnum;
+		ri = 1;
+
+		vpos = mchain[tmp].next;
+		v = mchain[vpos].vnum;
+
+		endv = mchain[posmax].vnum;
 	}
-      else			/* reflex-chain empty: add v to the */
-	{			/* reflex chain and advance it  */
-	  rc[++ri] = v;
-	  vpos = mchain[vpos].next;
-	  v = mchain[vpos].vnum;
-	}
-    } /* end-while */
-  
-  /* reached the bottom vertex. Add in the triangle formed */
-  op[op_idx][0] = rc[ri - 1];
-  op[op_idx][1] = rc[ri];
-  op[op_idx][2] = v;
-  op_idx++;	     
-  ri--;
-  
-  return 0;
+
+	while ((v != endv) || (ri > 1)) {
+		if (ri > 0) {	/* reflex chain is non-empty */
+			if (CROSS(vert[v].pt, vert[rc[ri - 1]].pt,
+			                vert[rc[ri]].pt) > 0) {			/* convex corner: cut if off */
+				op[op_idx][0] = rc[ri - 1];
+				op[op_idx][1] = rc[ri];
+				op[op_idx][2] = v;
+				op_idx++;
+				ri--;
+			} else		/* non-convex */
+			{		/* add v to the chain */
+				ri++;
+				rc[ri] = v;
+				vpos = mchain[vpos].next;
+				v = mchain[vpos].vnum;
+			}
+		} else			/* reflex-chain empty: add v to the */
+		{			/* reflex chain and advance it  */
+			rc[++ri] = v;
+			vpos = mchain[vpos].next;
+			v = mchain[vpos].vnum;
+		}
+	} /* end-while */
+
+	/* reached the bottom vertex. Add in the triangle formed */
+	op[op_idx][0] = rc[ri - 1];
+	op[op_idx][1] = rc[ri];
+	op[op_idx][2] = v;
+	op_idx++;
+	ri--;
+
+	return 0;
 }
 
 

Modified: trunk/libs3d/sei_tri.c
===================================================================
--- trunk/libs3d/sei_tri.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/sei_tri.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2006 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
- * for public domain: 
+ * for public domain:
  * <snip>
  *
  * This code is in the public domain. Specifically, we give to the public
@@ -20,17 +20,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -43,26 +43,26 @@
 
 
 static int initialise(n)
-     int n;
+int n;
 {
-  register int i;
+	register int i;
 
-  for (i = 1; i <= n; i++)
-    seg[i].is_inserted = FALSE;
+	for (i = 1; i <= n; i++)
+		seg[i].is_inserted = FALSE;
 
-  generate_random_ordering(n);
-  
-  return 0;
+	generate_random_ordering(n);
+
+	return 0;
 }
 
 /* Input specified as contours.
  * Outer contour must be anti-clockwise.
  * All inner contours must be clockwise.
- *  
+ *
  * Every contour is specified by giving all its points in order. No
  * point shoud be repeated. i.e. if the outer contour is a square,
  * only the four distinct endpoints shopudl be specified in order.
- *  
+ *
  * ncontours: #contours
  * cntr: An array describing the number of points in each
  *	 contour. Thus, cntr[i] = #points in the i'th contour.
@@ -72,100 +72,93 @@
  *           vertices[1] instead. The output triangles are
  *	     specified  w.r.t. the indices of these vertices.
  * triangles: Output array to hold triangles.
- *  
+ *
  * Enough space must be allocated for all the arrays before calling
  * this routine
  */
 
 
 int sei_triangulate_polygon(ncontours, cntr, vertices, triangles)
-     int ncontours;
-     int cntr[];
-     double (*vertices)[2];
-     int (*triangles)[3];
+int ncontours;
+int cntr[];
+double (*vertices)[2];
+int (*triangles)[3];
 {
-  register int i;
-  int nmonpoly, ccount, npoints, genus;
-  int n;
+	register int i;
+	int nmonpoly, ccount, npoints, genus;
+	int n;
 
-  memset((void *)seg, 0, sizeof(seg));
-  ccount = 0;
-  i = 1;
-  
-  while (ccount < ncontours)
-    {
-      int j;
-      int first, last;
+	memset((void *)seg, 0, sizeof(seg));
+	ccount = 0;
+	i = 1;
 
-      npoints = cntr[ccount];
-      first = i;
-      last = first + npoints - 1;
-      for (j = 0; j < npoints; j++, i++)
-	{
-	  seg[i].v0.x = vertices[i][0];
-	  seg[i].v0.y = vertices[i][1];
+	while (ccount < ncontours) {
+		int j;
+		int first, last;
 
-	  if (i == last)
-	    {
-	      seg[i].next = first;
-	      seg[i].prev = i-1;
-	      seg[i-1].v1 = seg[i].v0;
-	    }
-	  else if (i == first)
-	    {
-	      seg[i].next = i+1;
-	      seg[i].prev = last;
-	      seg[last].v1 = seg[i].v0;
-	    }
-	  else
-	    {
-	      seg[i].prev = i-1;
-	      seg[i].next = i+1;
-	      seg[i-1].v1 = seg[i].v0;
-	    }
-	  
-	  seg[i].is_inserted = FALSE;
+		npoints = cntr[ccount];
+		first = i;
+		last = first + npoints - 1;
+		for (j = 0; j < npoints; j++, i++) {
+			seg[i].v0.x = vertices[i][0];
+			seg[i].v0.y = vertices[i][1];
+
+			if (i == last) {
+				seg[i].next = first;
+				seg[i].prev = i-1;
+				seg[i-1].v1 = seg[i].v0;
+			} else if (i == first) {
+				seg[i].next = i+1;
+				seg[i].prev = last;
+				seg[last].v1 = seg[i].v0;
+			} else {
+				seg[i].prev = i-1;
+				seg[i].next = i+1;
+				seg[i-1].v1 = seg[i].v0;
+			}
+
+			seg[i].is_inserted = FALSE;
+		}
+
+		ccount++;
 	}
-      
-      ccount++;
-    }
-  
-  genus = ncontours - 1;
-  n = i-1;
 
-  initialise(n);
-  construct_trapezoids(n);
-  nmonpoly = monotonate_trapezoids(n);
-  return(triangulate_monotone_polygons(n, nmonpoly, triangles));
+	genus = ncontours - 1;
+	n = i-1;
+
+	initialise(n);
+	construct_trapezoids(n);
+	nmonpoly = monotonate_trapezoids(n);
+	return(triangulate_monotone_polygons(n, nmonpoly, triangles));
 }
 
 
-/* This function returns TRUE or FALSE depending upon whether the 
+/* This function returns TRUE or FALSE depending upon whether the
  * vertex is inside the polygon or not. The polygon must already have
  * been triangulated before this routine is called.
- * This routine will always detect all the points belonging to the 
- * set (polygon-area - polygon-boundary). The return value for points 
+ * This routine will always detect all the points belonging to the
+ * set (polygon-area - polygon-boundary). The return value for points
  * on the boundary is not consistent!!!
  */
 
 int is_point_inside_polygon(vertex)
-     double vertex[2];
+double vertex[2];
 {
-  point_t v;
-  int trnum, rseg;
-  trap_t *t;
+	point_t v;
+	int trnum, rseg;
+	trap_t *t;
 
-  v.x = vertex[0];
-  v.y = vertex[1];
-  
-  trnum = locate_endpoint(&v, &v, 1);
-  t = &tr[trnum];
-  
-  if (t->state == ST_INVALID)
-    return FALSE;
-  
-  if ((t->lseg <= 0) || (t->rseg <= 0))
-    return FALSE;
-  rseg = t->rseg;
-  return _greater_than_equal_to(&seg[rseg].v1, &seg[rseg].v0);
+	v.x = vertex[0];
+	v.y = vertex[1];
+
+	trnum = locate_endpoint(&v, &v, 1);
+	t = &tr[trnum];
+
+	if (t->state == ST_INVALID)
+		return FALSE;
+
+	if ((t->lseg <= 0) || (t->rseg <= 0))
+		return FALSE;
+	rseg = t->rseg;
+	return _greater_than_equal_to(&seg[rseg].v1, &seg[rseg].v0);
 }

Modified: trunk/libs3d/sei_triangulate.h
===================================================================
--- trunk/libs3d/sei_triangulate.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/sei_triangulate.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,9 +1,9 @@
 /*
  * sei_triangulate.h
- * 
+ *
  * Copyright (C) 2006 Simon Wunderlich
  * Copyright (C) 1994 A. Narkhede and D .Manocha, who released their code
- * for public domain: 
+ * for public domain:
  * <snip>
  *
  * This code is in the public domain. Specifically, we give to the public
@@ -20,17 +20,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -47,59 +47,59 @@
 #include "s3dlib.h"
 
 typedef struct {
-  double x, y;
+	double x, y;
 } point_t, vector_t;
 
 
 /* Segment attributes */
 
-typedef struct {	
-  point_t v0, v1;		/* two endpoints */
-  int is_inserted;		/* inserted in trapezoidation yet ? */
-  int root0, root1;		/* root nodes in Q */
-  int next;			/* Next logical segment */
-  int prev;			/* Previous segment */
+typedef struct {
+	point_t v0, v1;		/* two endpoints */
+	int is_inserted;		/* inserted in trapezoidation yet ? */
+	int root0, root1;		/* root nodes in Q */
+	int next;			/* Next logical segment */
+	int prev;			/* Previous segment */
 } segment_t;
 
 
 /* Trapezoid attributes */
 
 typedef struct {
-  int lseg, rseg;		/* two adjoining segments */
-  point_t hi, lo;		/* max/min y-values */
-  int u0, u1;
-  int d0, d1;
-  int sink;			/* pointer to corresponding in Q */
-  int usave, uside;		/* I forgot what this means */
-  int state;
+	int lseg, rseg;		/* two adjoining segments */
+	point_t hi, lo;		/* max/min y-values */
+	int u0, u1;
+	int d0, d1;
+	int sink;			/* pointer to corresponding in Q */
+	int usave, uside;		/* I forgot what this means */
+	int state;
 } trap_t;
 
 
 /* Node attributes for every node in the query structure */
 
 typedef struct {
-  int nodetype;			/* Y-node or S-node */
-  int segnum;
-  point_t yval;
-  int trnum;
-  int parent;			/* doubly linked DAG */
-  int left, right;		/* children */
+	int nodetype;			/* Y-node or S-node */
+	int segnum;
+	point_t yval;
+	int trnum;
+	int parent;			/* doubly linked DAG */
+	int left, right;		/* children */
 } node_t;
 
 
 typedef struct {
-  int vnum;
-  int next;			/* Circularly linked list  */
-  int prev;			/* describing the monotone */
-  int marked;			/* polygon */
-} monchain_t;			
+	int vnum;
+	int next;			/* Circularly linked list  */
+	int prev;			/* describing the monotone */
+	int marked;			/* polygon */
+} monchain_t;
 
 
 typedef struct {
-  point_t pt;
-  int vnext[4];			/* next vertices for the 4 chains */
-  int vpos[4];			/* position of v in the 4 chains */
-  int nextfree;
+	point_t pt;
+	int vnext[4];			/* next vertices for the 4 chains */
+	int vpos[4];			/* position of v in the 4 chains */
+	int nextfree;
 } vertexchain_t;
 
 #ifdef DEBUG
@@ -113,10 +113,10 @@
 
 
 #define SEGSIZE SEI_SS	/* max# of segments. Determines how */
-						/* many points can be specified as */
-						/* input. If your datasets have large */
-						/* number of points, increase this */
-						/* value accordingly. */
+/* many points can be specified as */
+/* input. If your datasets have large */
+/* number of points, increase this */
+/* value accordingly. */
 
 #define QSIZE   8*SEGSIZE	/* maximum table sizes */
 #define TRSIZE  4*SEGSIZE	/* max# trapezoids */
@@ -126,16 +126,16 @@
 #define FALSE 0
 
 
-#define FIRSTPT 1		/* checking whether pt. is inserted */ 
+#define FIRSTPT 1		/* checking whether pt. is inserted */
 #define LASTPT  2
 
 
 #define INFINITY 1<<30
 #define C_EPS 1.0e-7		/* tolerance value: Used for making */
-							/* all decisions about collinearity or */
-							/* left/right of segment. Decrease */
-							/* this value if the input points are */
-							/* spaced very close together */
+/* all decisions about collinearity or */
+/* left/right of segment. Decrease */
+/* this value if the input points are */
+/* spaced very close together */
 
 
 #define S_LEFT 1		/* for merge-direction */
@@ -153,7 +153,7 @@
 #define SP_2UP_RIGHT   5
 #define SP_2DN_LEFT    6
 #define SP_2DN_RIGHT   7
-#define SP_NOSPLIT    -1	
+#define SP_NOSPLIT    -1
 
 #define TR_FROM_UP 1		/* for traverse-direction */
 #define TR_FROM_DN 2

Modified: trunk/libs3d/shm.c
===================================================================
--- trunk/libs3d/shm.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/shm.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -47,16 +47,18 @@
 static struct buf_t *data_in,*data_out;
 static int shmid_in, shmid_out;
 static int shm_idle=0;
-struct timespec t={0,10*1000*1000}; /* 10 mili second */
+struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili second */
 /* char ftoken[]="/tmp/.s3d_shm";*/
 
 int _shm_init(char *ftoken)
 {
 	int shmid;
 	uint32_t *next_key;
-/*	struct shmid_ds *buf; */
+	/*	struct shmid_ds *buf; */
 	key_t key,key_out,key_in;
-	
+
 	s3dprintf(MED,"connecting to shm token %s",ftoken);
 	/* make the key: */
 	if ((key = ftok(ftoken, 'R')) == -1) {
@@ -64,7 +66,7 @@
 		return(1);
 	}
 	s3dprintf(MED,"init key is 0x%08x",key);
-	
+
 	/* connect to the segment: */
 	if ((shmid = shmget(key, SHM_SIZE, 0644 )) == -1) {
 		errn("shm_init():shmget()",errno);
@@ -82,7 +84,7 @@
 	next_key[0]=next_key[1]=0;
 	s3dprintf(MED,"right now, next_keys are: %08x, %08x",key_in,key_out);
 	/* as we have the new key, we  can detach here now. */
-	if (shmdt(next_key) == -1) { 
+	if (shmdt(next_key) == -1) {
 		errn("shm_init():shmdt()",errno);
 		return(1);
 	}
@@ -108,7 +110,7 @@
 		errn("shm_init():shmat()",errno);
 		return(1);
 	}
-	return(0);	
+	return(0);
 }
 int _shm_quit()
 {
@@ -128,20 +130,18 @@
 {
 	int no_left,no_written,wait=0;
 	no_left = s;
-	while (no_left > 0) 
-    { 
+	while (no_left > 0) {
 		no_written = shm_write(data_out,str,no_left);
- 		if (no_written <0)  
+		if (no_written <0)
 			return(no_written);
 		no_left -= no_written;
 		str += no_written;
-		if (wait++>SHM_MAXLOOP) 
-		{
+		if (wait++>SHM_MAXLOOP) {
 			s3dprintf(HIGH,"shm_writen():waited too long ...");
 			return(-1);
 		}
-/*		if (wait>10)
-			nanosleep(&t,NULL); */
+		/*		if (wait>10)
+					nanosleep(&t,NULL); */
 	}
 	return(s - no_left);
 }
@@ -149,22 +149,20 @@
 {
 	int no_left,no_read,wait=0;
 	no_left = s;
-	while (no_left > 0) 
-	{ 
+	while (no_left > 0) {
 		no_read = shm_read(data_in,str,no_left);
-		if(no_read <0)  
+		if (no_read <0)
 			return(no_read);
-		if (no_read == 0) 
+		if (no_read == 0)
 			break;
 		no_left -= no_read;
 		str += no_read;
-		if (wait++>SHM_MAXLOOP) 
-		{
+		if (wait++>SHM_MAXLOOP) {
 			s3dprintf(HIGH,"shm_readn():waited too long ...");
 			return(-1);
 		}
-/*		if (wait>10)
-			nanosleep(&t,NULL); */
+		/*		if (wait>10)
+					nanosleep(&t,NULL); */
 	}
 	return(s - no_left);
 }
@@ -174,13 +172,11 @@
 	char				 opcode,*buf;
 	u_int16_t		 length;
 	struct shmid_ds		 d;
-	
+
 	if (data_in==NULL)
 		return(found);
-	if (data_in->start!=data_in->end)
-	{
-		if (1==shm_readn(&opcode,1))
-		{
+	if (data_in->start!=data_in->end) {
+		if (1==shm_readn(&opcode,1)) {
 			shm_readn((char *)&length,2);
 			length=ntohs(length);
 			buf=malloc(length);
@@ -192,14 +188,12 @@
 			s3d_quit();
 		}
 	} else {
-		if (shm_idle++>SHM_MAX_IDLE)
-		{
+		if (shm_idle++>SHM_MAX_IDLE) {
 			shmctl(shmid_in,IPC_STAT,&d);
-			if (d.shm_nattch==1) /* we're all alone ... remove it!! */
-			{
+			if (d.shm_nattch==1) { /* we're all alone ... remove it!! */
 				s3dprintf(MED,"server vanished ... ");
 				s3d_quit();
-			} else 
+			} else
 				shm_idle=0;
 		}
 	}

Modified: trunk/libs3d/shm_ringbuf.c
===================================================================
--- trunk/libs3d/shm_ringbuf.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/shm_ringbuf.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -40,31 +40,28 @@
 	data=((char *)rb)+sizeof(struct buf_t);
 	if (e<s) {
 		wrap=1;
-	} 
-	while ((((s+size*(1-wrap))-e)<(n+1))) /* checking free space */
-	{
-		if /*((size*2)>RB_MAX_SIZE)*/ (1)
-		{
-	/*		s3dprintf(MED,"buffer reached maxsize, no resizing possible");*/
+	}
+	while ((((s+size*(1-wrap))-e)<(n+1))) { /* checking free space */
+		if /*((size*2)>RB_MAX_SIZE)*/ (1) {
+			/*		s3dprintf(MED,"buffer reached maxsize, no resizing possible");*/
 			return(0);
 		}
-/*		printf("buffer full!! resizing ... (to size %d)",(int)size*2);
-		if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
-		{
-			printf("realloc failed - fatal!!");
-			return(-1);
-		}
-		if (wrap)
-		{
-			memcpy(data+size,data,e);
-			e+=size;
-			wrap=0;
-		}
-		size=rb->bufsize=size*2;
-		rb->end=e;*/
+		/*		printf("buffer full!! resizing ... (to size %d)",(int)size*2);
+				if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
+				{
+					printf("realloc failed - fatal!!");
+					return(-1);
+				}
+				if (wrap)
+				{
+					memcpy(data+size,data,e);
+					e+=size;
+					wrap=0;
+				}
+				size=rb->bufsize=size*2;
+				rb->end=e;*/
 	}
-	if ((e+n)>size)
-	{
+	if ((e+n)>size) {
 		rs=size-e;
 		memcpy(data+e,buf,rs);			/* copy the first part ... */
 		memcpy(data,buf+rs,n-rs); 		/* .. end the rest */
@@ -90,8 +87,7 @@
 	if (e<s) wrap=1;
 	rs=(e+wrap*size-s);
 	mn=(n>rs)?rs:n;
-	if ((wrap) && (mn>(size-s))) 
-	{
+	if ((wrap) && (mn>(size-s))) {
 		rs=size-s;	/* size of the first part */
 		memcpy(buf,data+s,rs);
 		memcpy(buf+rs,data,mn-rs);

Modified: trunk/libs3d/tcp.c
===================================================================
--- trunk/libs3d/tcp.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/tcp.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -31,8 +31,8 @@
 #include <sys/socket.h>
 #include <netinet/in.h>  /*  htons(),htonl() */
 #ifndef WIN32
-	#include <sys/select.h>
-	#include <netdb.h>		 /*  gethostbyname()  */
+#include <sys/select.h>
+#include <netdb.h>		 /*  gethostbyname()  */
 #endif
 #ifdef SIGS
 #define __USE_BSD	1		/* we want sig_t and F_SETOWN to be defined */
@@ -58,51 +58,49 @@
 {
 	int 	 			 sd;
 	int 				 res;
-/*	char			 	*port=NULL;*/
+	/*	char			 	*port=NULL;*/
 	struct sockaddr_in 	 sock;
 	struct hostent 		*server=0;
 #ifdef SIGS
 	_s3d_sigio=0;
 #endif
-#ifdef WIN32 
-   WSADATA datainfo;
-   if (WSAStartup(257, &datainfo) != 0)
-   {
-     errn("s3d_init():startup()", errno);
-	 return(-1);
-   }
-#endif 
+#ifdef WIN32
+	WSADATA datainfo;
+	if (WSAStartup(257, &datainfo) != 0) {
+		errn("s3d_init():startup()", errno);
+		return(-1);
+	}
+#endif
 	if ((sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
-	  errn("s3d_init():socket()",errno);
-	  return (-1);
+		errn("s3d_init():socket()",errno);
+		return (-1);
 	}
 	sock.sin_family = AF_INET;
 	if (*sv==0)  /*  no server argument */
 		sv="127.0.0.1";
 	if ((server = gethostbyname(sv)))
-      memcpy(&sock.sin_addr.s_addr, server->h_addr_list[0], 4);
-	else 
-	{
+		memcpy(&sock.sin_addr.s_addr, server->h_addr_list[0], 4);
+	else {
 		errn("s3d_init():gethostbyname()",errno);
 		return(-1);
 	}
-	sock.sin_port = htons(pn); 
+	sock.sin_port = htons(pn);
 
 	res = connect(sd, (struct sockaddr *) &sock, sizeof(struct sockaddr_in));
 	if (res < 0 ) {
-	  errn("s3d_init():connect()",errno);
-	  return(-1);
+		errn("s3d_init():connect()",errno);
+		return(-1);
 	}
-/*    if ( fcntl(sd, F_SETFL, O_ASYNC | O_NONBLOCK) < 0 ) */
-/* 		errn("fcntl()",errno); */
-#ifdef SIGS 
-   if ( fcntl(sd, F_SETFL, O_ASYNC ) < 0 )
+	/*    if ( fcntl(sd, F_SETFL, O_ASYNC | O_NONBLOCK) < 0 ) */
+	/* 		errn("fcntl()",errno); */
+#ifdef SIGS
+	if ( fcntl(sd, F_SETFL, O_ASYNC ) < 0 )
 		errn("fcntl()",errno);
-   if ( fcntl(sd, F_SETOWN, getpid()) < 0 )
+	if ( fcntl(sd, F_SETOWN, getpid()) < 0 )
 		errn("fcntl()",errno);
-    if (signal(SIGPIPE, (sig_t)sigpipe_handler) == SIG_ERR) 
+	if (signal(SIGPIPE, (sig_t)sigpipe_handler) == SIG_ERR)
 		errn("_tcp_init():signal()",errno);
-    if (signal(SIGIO, (sig_t)sigio_handler) == SIG_ERR) 
+	if (signal(SIGIO, (sig_t)sigio_handler) == SIG_ERR)
 		errn("_tcp_init():signal()",errno);
 #endif
 	s3d_socket=sd;
@@ -111,8 +109,7 @@
 }
 int _tcp_quit()
 {
-	if (s3d_socket)
-	{
+	if (s3d_socket) {
 		s3dprintf(MED,"closing socket %d",s3d_socket);
 		close(s3d_socket);
 		s3d_socket=0;
@@ -120,27 +117,29 @@
 	return(0);
 }
 int tcp_readn(char *str,int s)
-{         int no_left,no_read;
-          no_left = s;
-          while (no_left > 0) 
-                     { no_read = read(s3d_socket,str,no_left);
-                       if(no_read <0)  return(no_read);
-                       if (no_read == 0) break;
-                       no_left -= no_read;
-                       str += no_read;
-                     }
-          return(s - no_left);
+{
+	int no_left,no_read;
+	no_left = s;
+	while (no_left > 0) {
+		no_read = read(s3d_socket,str,no_left);
+		if (no_read <0)  return(no_read);
+		if (no_read == 0) break;
+		no_left -= no_read;
+		str += no_read;
+	}
+	return(s - no_left);
 }
 int tcp_writen(char *str,int s)
-{         int no_left,no_written;
-          no_left = s;
-          while (no_left > 0) 
-                     { no_written = write(s3d_socket,str,no_left);
-                       if(no_written <=0)  return(no_written);
-                       no_left -= no_written;
-                       str += no_written;
-                     }
-          return(s - no_left);
+{
+	int no_left,no_written;
+	no_left = s;
+	while (no_left > 0) {
+		no_written = write(s3d_socket,str,no_left);
+		if (no_written <=0)  return(no_written);
+		no_left -= no_written;
+		str += no_written;
+	}
+	return(s - no_left);
 }
 int _s3d_tcp_net_receive()
 {
@@ -149,24 +148,20 @@
 	int 				 found=0;
 	char				 opcode,*buf;
 	u_int16_t		 length;
-	
-	
-	if (s3d_socket!=-1)
-	{
+
+
+	if (s3d_socket!=-1) {
 		FD_ZERO(&fs_proc);
 		tv.tv_sec=tv.tv_usec=0;
 		FD_SET(s3d_socket,&fs_proc);
-	
-		 /* s3dprintf(LOW,"Added %d procceses into file descriptor ...", n); */
-		if (select(FD_SETSIZE, &fs_proc, NULL,NULL,&tv) ==-1) 
-		{
-			errn("select()",errno); 
+
+		/* s3dprintf(LOW,"Added %d procceses into file descriptor ...", n); */
+		if (select(FD_SETSIZE, &fs_proc, NULL,NULL,&tv) ==-1) {
+			errn("select()",errno);
 		} else {
-			 /*  data is available */
-			if (FD_ISSET(s3d_socket,&fs_proc))
-			{
-				if (1==tcp_readn(&opcode,1))
-				{
+			/*  data is available */
+			if (FD_ISSET(s3d_socket,&fs_proc)) {
+				if (1==tcp_readn(&opcode,1)) {
 					tcp_readn((char *)&length,2);
 					length=ntohs(length);
 					buf=malloc(length);

Modified: trunk/libs3d/vector.c
===================================================================
--- trunk/libs3d/vector.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3d/vector.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -36,7 +36,8 @@
  *
  ***/
 
-float s3d_vector_length( float vector[] ) {
+float s3d_vector_length( float vector[] )
+{
 
 	return ( sqrt( vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2] ) );
 
@@ -53,7 +54,8 @@
  *
  ***/
 
-void s3d_vector_subtract( float vector1[], float vector2[], float result_vector[] ) {
+void s3d_vector_subtract( float vector1[], float vector2[], float result_vector[] )
+{
 
 	result_vector[0] = vector2[0] - vector1[0];
 	result_vector[1] = vector2[1] - vector1[1];
@@ -72,7 +74,8 @@
  *
  ***/
 
-float s3d_vector_dot_product( float vector1[], float vector2[] ) {
+float s3d_vector_dot_product( float vector1[], float vector2[] )
+{
 	return ( vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2] );
 }
 
@@ -87,7 +90,8 @@
  *
  ***/
 
-void s3d_vector_cross_product( float vector1[], float vector2[], float result_vector[] ) {
+void s3d_vector_cross_product( float vector1[], float vector2[], float result_vector[] )
+{
 	result_vector[0]=vector1[1] * vector2[2] - vector1[2] * vector2[1];
 	result_vector[1]=vector1[2] * vector2[0] - vector1[0] * vector2[2];
 	result_vector[2]=vector1[0] * vector2[1] - vector1[1] * vector2[0];
@@ -105,7 +109,8 @@
  *
  ***/
 
-float s3d_vector_angle( float vector1[], float vector2[] ) {
+float s3d_vector_angle( float vector1[], float vector2[] )
+{
 
 	return ( acos( s3d_vector_dot_product( vector1, vector2 ) / ( s3d_vector_length( vector1 ) * s3d_vector_length( vector2 ) ) ) );
 
@@ -123,7 +128,8 @@
  *
  ***/
 
-float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad ) {
+float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad )
+{
 
 	float angle, tmp_mov_vec[3], desc_norm_vec[3] = { 0.0, 0.0, -1.0 };
 

Modified: trunk/libs3dw/animate.c
===================================================================
--- trunk/libs3dw/animate.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/animate.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -50,23 +50,20 @@
 		s3dprintf(HIGH,"s3dw_ani_add() assert failed: weird, moving cam but its not a cam obeject?");
 		return;
 	}
-	if ((ani_n<MAXANI) && (animation_on))
-	{
+	if ((ani_n<MAXANI) && (animation_on)) {
 		if (s3dw_ani_onstack(f))
 			return;		/* already in list */
 		ani_s[ani_n]=f;
 		s3dw_ani_iterate(f);
 		ani_n++;
-	}
-	else /* no place, finish now */
+	} else /* no place, finish now */
 		s3dw_ani_finish(f,-1);
 }
 /* delete an item from the animation stack */
 void s3dw_ani_del(int i)
 {
-	if ((i>=0) && (i<ani_n))
-	{
-/*		printf("[A]ni DEL %d\n",i);*/
+	if ((i>=0) && (i<ani_n)) {
+		/*		printf("[A]ni DEL %d\n",i);*/
 		ani_n--;
 		ani_s[i]=ani_s[ani_n]; /* that should also work if i is the last one */
 	} else {
@@ -133,11 +130,10 @@
 void s3dw_ani_needarr()
 {
 	ani_need_arr=1;
-	if (!animation_on)	
-	{
+	if (!animation_on) {
 		while (ani_need_arr) s3dw_arrange();
 	}
-		
+
 }
 /* doing the whole animation thing */
 void s3dw_ani_mate()
@@ -146,12 +142,10 @@
 	s3dw_widget *f;
 	animation_on=1;			/* animation is activated */
 	if (ani_need_arr) s3dw_arrange();
-	for (i=0;i<ani_n;i++)
-	{
+	for (i=0;i<ani_n;i++) {
 		f=ani_s[i];
 		s3dw_ani_iterate(f);
-		if (s3dw_ani_check(f))
-		{
+		if (s3dw_ani_check(f)) {
 			s3dw_ani_finish(f,i);
 			i--; /* a new widget is here now, take care in the next iteration */
 		} else {

Modified: trunk/libs3dw/arrange.c
===================================================================
--- trunk/libs3dw/arrange.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/arrange.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -41,12 +41,12 @@
 	xt= cos(widget->ry/R2D)*x + sin(widget->ry/R2D) *z;
 	yt=y;
 	zt=-sin(widget->ry/R2D)*x + cos(widget->ry/R2D) *z;
-	
+
 	/* around the x axis (vertical direction) */
 	x=xt;
 	y= cos(widget->rx/R2D)*yt + sin(widget->rx/R2D) *zt;
 	z=-sin(widget->rx/R2D)*yt + cos(widget->rx/R2D) *zt;
-	
+
 	center[0]=x;
 	center[1]=y;
 	center[2]=z;
@@ -54,8 +54,7 @@
 void s3dw_arr_normdir(float *dir)
 {
 	float dirlen=s3d_vector_length(dir);
-	while ((dirlen=s3d_vector_length(dir))==0)
-	{
+	while ((dirlen=s3d_vector_length(dir))==0) {
 		/* make up some random direction if they're exactly the same position */
 		dir[0]=((float)rand() - RAND_MAX/2.0)/RAND_MAX;
 		dir[1]=((float)rand() - RAND_MAX/2.0)/RAND_MAX;
@@ -74,11 +73,9 @@
 	a[0]=0;
 	a[1]=0;
 	a[2]=1;
-	for (i=0;i<root->nobj;i++)
-	{
+	for (i=0;i<root->nobj;i++) {
 		w=root->pobj[i];
-		if ((w->oid!=0) && (w->flags&S3DW_TURN_CAM))
-		{
+		if ((w->oid!=0) && (w->flags&S3DW_TURN_CAM)) {
 			s3dw_arr_widgetcenter(w,op);
 			/* horizontal movement */
 			b[0]=w->x + op[0]  - _s3dw_cam->x;
@@ -125,19 +122,17 @@
 	float b[3];
 	float op[3];
 	float lsqr,l;
-	for (i=0;i<root->nobj;i++)
-	{
+	for (i=0;i<root->nobj;i++) {
 		w=root->pobj[i];
 		if ((w->oid!=0) && (w->flags&S3DW_FOLLOW_CAM))
-				
+
 		{
 			s3dw_arr_widgetcenter(w,op);
 			/* horizontal movement */
 			b[0]=_s3dw_cam->x - (w->x + op[0]);
 			b[1]=_s3dw_cam->y - (w->y + op[1]);
 			b[2]=_s3dw_cam->z - (w->z + op[2]);
-			if ((lsqr=(b[0]*b[0] + b[1]*b[1] + b[2]*b[2])) > (DIST * DIST))
-			{
+			if ((lsqr=(b[0]*b[0] + b[1]*b[1] + b[2]*b[2])) > (DIST * DIST)) {
 				/* need to adjust ... */
 				l=sqrt(lsqr);
 				w->x+= b[0]-b[0]*DIST/l;
@@ -146,7 +141,7 @@
 				w->flags&=~S3DW_ARRANGED;
 				ani_need_arr=1;
 				s3dw_ani_add(w);
-				
+
 			}
 		}
 	}
@@ -164,23 +159,20 @@
 	for (i=0;i<root->nobj;i++)
 		if (!(root->pobj[i]->flags&S3DW_ARRANGED)) arranged=0;
 	if (arranged && !ani_need_arr) return; /* no arrangement necceasary .... */
-		
+
 	ani_need_arr=0;
-	if (root->nobj==1)
-	{
+	if (root->nobj==1) {
 		w1=root->pobj[0];
 		w1->flags|=S3DW_ARRANGED; /* done */
 		return;
 	}
 	allarr=1;
-	for (i=0;i<root->nobj;i++)
-	{
+	for (i=0;i<root->nobj;i++) {
 		w1=root->pobj[i];
 		arranged=1;
 		for (j=0;j<root->nobj;j++) {
 			w2=root->pobj[j];
-			if ((i!=j) && ((w1->oid!=0) && (w2->oid!=0)))
-			{
+			if ((i!=j) && ((w1->oid!=0) && (w2->oid!=0))) {
 				s3dw_arr_widgetcenter(w1,f1);
 				s3dw_arr_widgetcenter(w2,f2);
 				len1=s3d_vector_length(f1);
@@ -189,8 +181,7 @@
 				dir[1]=(w1->y+f1[1]) - (w2->y+f2[1]);
 				dir[2]=(w1->z+f1[2]) - (w2->z+f2[2]);
 				dirlen=s3d_vector_length(dir);
-				if (dirlen<(len1+len2))
-				{
+				if (dirlen<(len1+len2)) {
 					allarr=0;
 					arranged=0;
 					w1->flags&=~S3DW_ARRANGED;
@@ -200,8 +191,7 @@
 					tomove=((len1+len2+1)-dirlen);
 					move1=len1/(len1+len2);
 					move2=len2/(len1+len2);
-					if (w1->oid!=0)
-					{
+					if (w1->oid!=0) {
 						w1->x += tomove * move1 *  dir[0];
 						w1->y += tomove * move1 *  dir[1];
 						w1->z += tomove * move1 *  dir[2];
@@ -212,8 +202,7 @@
 						w2->z += tomove * move2 * -dir[2];
 
 					}
-					if (w2->oid!=0)
-					{
+					if (w2->oid!=0) {
 						w2->x += tomove * move2 * -dir[0];
 						w2->y += tomove * move2 * -dir[1];
 						w2->z += tomove * move2 * -dir[2];

Modified: trunk/libs3dw/button.c
===================================================================
--- trunk/libs3dw/button.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/button.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -34,30 +34,46 @@
 	float length;
 	float vertices[8*3];
 	u_int32_t polygons[10*4]={
-			0,4,5,0,
-			0,5,1,0,
-			1,5,6,0,
-			1,6,2,0,
-			2,6,7,0,
-			2,7,3,0,
-			3,7,4,0,
-			3,4,0,0,
-			4,7,6,0,
-			4,6,5,0
+		0,4,5,0,
+		0,5,1,0,
+		1,5,6,0,
+		1,6,2,0,
+		2,6,7,0,
+		2,7,3,0,
+		3,7,4,0,
+		3,4,0,0,
+		4,7,6,0,
+		4,6,5,0
 	};
 
 	button->oid_text=s3d_draw_string(button->text,&length);
 	s3d_pep_materials_a(button->oid_text,widget->style->text_mat,1);
 
 	/* width of the button depends on the length of the text */
-	vertices[0*3+0]=0.0;			vertices[0*3+1]=0.0;		vertices[0*3+2]=0.0;	
-	vertices[1*3+0]=0.0;			vertices[1*3+1]=-2.0;		vertices[1*3+2]=0.0;	
-	vertices[2*3+0]=length+1;		vertices[2*3+1]=-2.0;		vertices[2*3+2]=0.0;	
-	vertices[3*3+0]=length+1;		vertices[3*3+1]=0.0;		vertices[3*3+2]=0.0;	
-	vertices[4*3+0]=0.25;			vertices[4*3+1]=-0.25;		vertices[4*3+2]=0.25;	
-	vertices[5*3+0]=0.25;			vertices[5*3+1]=-1.75;		vertices[5*3+2]=0.25;	
-	vertices[6*3+0]=length+0.75;	vertices[6*3+1]=-1.75;		vertices[6*3+2]=0.25;	
-	vertices[7*3+0]=length+0.75;	vertices[7*3+1]=-0.25;		vertices[7*3+2]=0.25;	
+	vertices[0*3+0]=0.0;
+	vertices[0*3+1]=0.0;
+	vertices[0*3+2]=0.0;
+	vertices[1*3+0]=0.0;
+	vertices[1*3+1]=-2.0;
+	vertices[1*3+2]=0.0;
+	vertices[2*3+0]=length+1;
+	vertices[2*3+1]=-2.0;
+	vertices[2*3+2]=0.0;
+	vertices[3*3+0]=length+1;
+	vertices[3*3+1]=0.0;
+	vertices[3*3+2]=0.0;
+	vertices[4*3+0]=0.25;
+	vertices[4*3+1]=-0.25;
+	vertices[4*3+2]=0.25;
+	vertices[5*3+0]=0.25;
+	vertices[5*3+1]=-1.75;
+	vertices[5*3+2]=0.25;
+	vertices[6*3+0]=length+0.75;
+	vertices[6*3+1]=-1.75;
+	vertices[6*3+2]=0.25;
+	vertices[7*3+0]=length+0.75;
+	vertices[7*3+1]=-0.25;
+	vertices[7*3+2]=0.25;
 	widget->oid=s3d_new_object();
 	s3d_push_materials_a(widget->oid,widget->style->input_mat,1);
 	s3d_push_vertices   (widget->oid,vertices,8);
@@ -92,15 +108,15 @@
 void s3dw_button_show(s3dw_widget *widget)
 {
 	s3dw_button *button=(s3dw_button *)widget;
-    s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(button->oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(button->oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* hide */
 void s3dw_button_hide(s3dw_widget *widget)
 {
 	s3dw_button *button=(s3dw_button *)widget;
-    s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(button->oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(button->oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* destroy s3d structures of the button */
 void s3dw_button_erase(s3dw_widget *widget)
@@ -128,8 +144,7 @@
 int s3dw_button_event_click(s3dw_widget *widget, u_int32_t oid)
 {
 	s3dw_button *button=(s3dw_button *)widget;
-	if ((button->oid_text==oid) || (widget->oid==oid))
-	{
+	if ((button->oid_text==oid) || (widget->oid==oid)) {
 		button->onclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/event.c
===================================================================
--- trunk/libs3dw/event.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/event.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -39,8 +39,7 @@
 int s3dw_object_info(struct s3d_evt *evt)
 {
 	struct s3d_obj_info *info=(struct s3d_obj_info *)evt->buf;
-	if (info->object==0) /* the _s3dw_cam */
-	{
+	if (info->object==0) { /* the _s3dw_cam */
 		if (_s3dw_cam==NULL)	s3dw_getroot(); /* init, get _s3dw_cam */
 		_s3dw_cam->ax=_s3dw_cam->x=info->trans_x;
 		_s3dw_cam->ay=_s3dw_cam->y=info->trans_y;

Modified: trunk/libs3dw/input.c
===================================================================
--- trunk/libs3dw/input.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/input.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -51,44 +51,68 @@
 	float length;
 	float vertices[12*3];
 	uint32_t polygons[18*4]={
-			0,4,5,1,
-			0,5,1,1,
-			1,5,6,1,
-			1,6,2,1,
-			2,6,7,1,
-			2,7,3,1,
-			3,7,4,1,
-			3,4,0,1,
+		0,4,5,1,
+		0,5,1,1,
+		1,5,6,1,
+		1,6,2,1,
+		2,6,7,1,
+		2,7,3,1,
+		3,7,4,1,
+		3,4,0,1,
 
-			4,8, 9, 1,
-			4,9, 5, 1,
-			5,9, 10,1,
-			5,10,6, 1,
-			6,10,11,1,
-			6,11,7, 1,
-			7,11,8, 1,
-			7,8, 4, 1,
+		4,8, 9, 1,
+		4,9, 5, 1,
+		5,9, 10,1,
+		5,10,6, 1,
+		6,10,11,1,
+		6,11,7, 1,
+		7,11,8, 1,
+		7,8, 4, 1,
 
 
-			8,11,10,0,
-			8,10,9, 0
+		8,11,10,0,
+		8,10,9, 0
 	};
 	length=widget->width-1;
 	if (widget->width<1) return;
 	widget->height=2;
 	/* width of the input depends on the length of the text */
-	vertices[0*3+0]=0.0;			vertices[0*3+1]=0.0;		vertices[0*3+2]=0.0;	
-	vertices[1*3+0]=0.0;			vertices[1*3+1]=-2.0;		vertices[1*3+2]=0.0;	
-	vertices[2*3+0]=length+1;		vertices[2*3+1]=-2.0;		vertices[2*3+2]=0.0;	
-	vertices[3*3+0]=length+1;		vertices[3*3+1]=0.0;		vertices[3*3+2]=0.0;	
-	vertices[4*3+0]=0.125;			vertices[4*3+1]=-0.125;		vertices[4*3+2]=0.25;	
-	vertices[5*3+0]=0.125;			vertices[5*3+1]=-1.875;		vertices[5*3+2]=0.25;	
-	vertices[6*3+0]=length+0.875;	vertices[6*3+1]=-1.875;		vertices[6*3+2]=0.25;	
-	vertices[7*3+0]=length+0.875;	vertices[7*3+1]=-0.125;		vertices[7*3+2]=0.25;	
-	vertices[8*3+0]=0.25;			vertices[8*3+1]=-0.25;		vertices[8*3+2]=0.125;	
-	vertices[9*3+0]=0.25;			vertices[9*3+1]=-1.75;		vertices[9*3+2]=0.125;	
-	vertices[10*3+0]=length+0.75;	vertices[10*3+1]=-1.75;		vertices[10*3+2]=0.125;	
-	vertices[11*3+0]=length+0.75;	vertices[11*3+1]=-0.25;		vertices[11*3+2]=0.125;	
+	vertices[0*3+0]=0.0;
+	vertices[0*3+1]=0.0;
+	vertices[0*3+2]=0.0;
+	vertices[1*3+0]=0.0;
+	vertices[1*3+1]=-2.0;
+	vertices[1*3+2]=0.0;
+	vertices[2*3+0]=length+1;
+	vertices[2*3+1]=-2.0;
+	vertices[2*3+2]=0.0;
+	vertices[3*3+0]=length+1;
+	vertices[3*3+1]=0.0;
+	vertices[3*3+2]=0.0;
+	vertices[4*3+0]=0.125;
+	vertices[4*3+1]=-0.125;
+	vertices[4*3+2]=0.25;
+	vertices[5*3+0]=0.125;
+	vertices[5*3+1]=-1.875;
+	vertices[5*3+2]=0.25;
+	vertices[6*3+0]=length+0.875;
+	vertices[6*3+1]=-1.875;
+	vertices[6*3+2]=0.25;
+	vertices[7*3+0]=length+0.875;
+	vertices[7*3+1]=-0.125;
+	vertices[7*3+2]=0.25;
+	vertices[8*3+0]=0.25;
+	vertices[8*3+1]=-0.25;
+	vertices[8*3+2]=0.125;
+	vertices[9*3+0]=0.25;
+	vertices[9*3+1]=-1.75;
+	vertices[9*3+2]=0.125;
+	vertices[10*3+0]=length+0.75;
+	vertices[10*3+1]=-1.75;
+	vertices[10*3+2]=0.125;
+	vertices[11*3+0]=length+0.75;
+	vertices[11*3+1]=-0.25;
+	vertices[11*3+2]=0.125;
 	widget->oid=s3d_new_object();
 	s3d_push_materials_a(widget->oid,widget->style->inputback_mat,1);
 	s3d_push_materials_a(widget->oid,widget->style->input_mat,1);
@@ -103,15 +127,15 @@
 void s3dw_input_show(s3dw_widget *widget)
 {
 	s3dw_input *input=(s3dw_input *)widget;
-    s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(input->oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(input->oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* hides the input */
 void s3dw_input_hide(s3dw_widget *widget)
 {
 	s3dw_input *input=(s3dw_input *)widget;
-    s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(input->oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(input->oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* create a new input in the surface */
 s3dw_input *s3dw_input_new(s3dw_surface *surface, float width, float posx, float posy)
@@ -144,7 +168,7 @@
 void s3dw_input_destroy(s3dw_widget *widget)
 {
 	s3dw_input *input=(s3dw_input *)widget;
-    s3dw_input_erase(widget);
+	s3dw_input_erase(widget);
 	free(input->text);
 	free(input);
 }
@@ -170,34 +194,31 @@
 	char key=keys->unicode; /* unicode support so far ... :/ */
 	int len;
 	s3dprintf(MED,"edit field got key %d!!",key);
-	switch (keys->keysym)
-	{
-		case S3DK_BACKSPACE:
+	switch (keys->keysym) {
+	case S3DK_BACKSPACE:
+		len=strlen(input->text);
+		if ((len=strlen(input->text))>0) {
+			newtext=malloc(len + 0); /* +1 for the terminating byte, -1 for the deleted character */
+			strncpy(newtext,input->text,len);
+			newtext[len-1]=0;
+			s3dw_input_change_text(input,newtext);
+			free(newtext);
+			return(1);
+		}
+		break;
+	default:
+		if (isprint(key)) {
 			len=strlen(input->text);
-			if ((len=strlen(input->text))>0)
-			{
-				newtext=malloc(len + 0); /* +1 for the terminating byte, -1 for the deleted character */
-				strncpy(newtext,input->text,len);
-				newtext[len-1]=0;
-				s3dw_input_change_text(input,newtext);
-				free(newtext);
-				return(1);
-			}
-			break;
-		default:
-			if (isprint(key))
-			{
-				len=strlen(input->text);
-				newtext=malloc(len + 2); /* +1 for the terminating byte, +1 for the new character */
-				strcpy(newtext,input->text);
-				newtext[len]=key;
-				newtext[len+1]=0;
-				s3dw_input_change_text(input,newtext);
-				free(newtext);
-				return(1);
-			} 
+			newtext=malloc(len + 2); /* +1 for the terminating byte, +1 for the new character */
+			strcpy(newtext,input->text);
+			newtext[len]=key;
+			newtext[len+1]=0;
+			s3dw_input_change_text(input,newtext);
+			free(newtext);
+			return(1);
+		}
 	}
-	
+
 	return(0);
 }
 
@@ -205,8 +226,7 @@
 int s3dw_input_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	s3dw_input *input=(s3dw_input *)widget;
-	if ((input->oid_text==oid) || (widget->oid==oid))
-	{
+	if ((input->oid_text==oid) || (widget->oid==oid)) {
 		s3dw_focus(widget);
 		input->onclick(widget);
 		return(1);

Modified: trunk/libs3dw/label.c
===================================================================
--- trunk/libs3dw/label.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/label.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -42,12 +42,12 @@
 /* show the label */
 void s3dw_label_show(s3dw_widget *widget)
 {
-    s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* hides the label */
 void s3dw_label_hide(s3dw_widget *widget)
 {
-    s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* change label text */
 void s3dw_label_change_text(s3dw_label *label, char *text)
@@ -102,8 +102,7 @@
 int s3dw_label_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	s3dw_label *label=(s3dw_label *)widget;
-	if (widget->oid==oid)
-	{
+	if (widget->oid==oid) {
 		label->onclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/root.c
===================================================================
--- trunk/libs3dw/root.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/root.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -57,8 +57,7 @@
 /* get the root .... if it's NULL, the lib is not initialized, so do this too ... */
 s3dw_widget *s3dw_getroot()
 {
-	if (root==NULL)
-	{
+	if (root==NULL) {
 		root=(s3dw_widget *)malloc(sizeof(s3dw_widget));
 		root=s3dw_widget_new(root);
 		root->type=S3DW_TROOT;
@@ -93,7 +92,7 @@
 		s3dwcb_hide[S3DW_TINPUT]=		s3dw_input_hide;
 		s3dwcb_hide[S3DW_TTEXTBOX]=		s3dw_textbox_hide;
 		s3dwcb_hide[S3DW_TSCROLLBAR]=	s3dw_scrollbar_hide;
-		
+
 		s3dwcb_destroy[S3DW_TROOT]=		s3dw_root_destroy;
 		s3dwcb_destroy[S3DW_TCAM]=		s3dw_root_destroy;
 		s3dwcb_destroy[S3DW_TSURFACE]=	s3dw_surface_destroy;
@@ -121,7 +120,7 @@
 		s3dwcb_key[S3DW_TTEXTBOX]=		s3dw_key_nothing;
 		s3dwcb_key[S3DW_TSCROLLBAR]=	s3dw_key_nothing;
 
-	} 
+	}
 	return root;
 }
 

Modified: trunk/libs3dw/s3dw.h
===================================================================
--- trunk/libs3dw/s3dw.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/s3dw.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -28,8 +28,8 @@
 #endif
 #include <stdint.h>  /* [u]intXX_t type definitions*/
 
-/* we want this widget visible, as long as the widgets below are also visible. 
- * on for all widgets, except surfaces which have to be switched visible 
+/* we want this widget visible, as long as the widgets below are also visible.
+ * on for all widgets, except surfaces which have to be switched visible
  * with s3dw_show() */
 #define		S3DW_VISIBLE	1
 /* widget should accept input. that's on by default. */
@@ -70,7 +70,7 @@
 struct _s3dw_widget {
 	/* private .. */
 	int   		 type;
-	s3dw_widget *parent; 
+	s3dw_widget *parent;
 	s3dw_style  *style;
 	int 				  nobj; /* number of children objects */
 	s3dw_widget		 	**pobj; /* pointer to list of children objects */
@@ -103,7 +103,7 @@
 	char 			*text;
 	/* public */
 	s3dw_callback 	 onclick;
-	
+
 };
 struct _s3dw_scrollbar {
 	/* private */
@@ -114,20 +114,20 @@
 	/* public */
 	s3dw_callback 	 lonclick;
 	s3dw_callback 	 ronclick;
-	
+
 };
 
 struct _s3dw_textbox {
 	/* private */
 	s3dw_widget 	 widget;
 	s3dw_scrollbar	*scroll_vertical,
-					*scroll_horizontal;
+	*scroll_horizontal;
 	char 			*text;
 	int				n_lineoids,*p_lineoids;
 	int				window_x,window_y;
 	/* public */
 	s3dw_callback 	 onclick;
-	
+
 };
 
 struct _s3dw_input {

Modified: trunk/libs3dw/s3dw_int.h
===================================================================
--- trunk/libs3dw/s3dw_int.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/s3dw_int.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

Modified: trunk/libs3dw/scrollbar.c
===================================================================
--- trunk/libs3dw/scrollbar.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/scrollbar.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -34,135 +34,222 @@
 	float back_vertices[3*32];
 	int i,j;
 	unsigned int back_polygons[44*4]={
-							/* box outside */
-							0,4,5,0,							0,5,1,0,
-							1,5,6,0,							1,6,2,0,
-							3,2,7,0,							7,2,6,0,
-							3,7,4,0,							3,4,0,0,
-							
-							/* sides of big box */
-							12,13,9,0,							12,9,8,0,
-							14,15,11,0,							14,11,10,0,
+		/* box outside */
+		0,4,5,0,							0,5,1,0,
+		1,5,6,0,							1,6,2,0,
+		3,2,7,0,							7,2,6,0,
+		3,7,4,0,							3,4,0,0,
 
-							/* inlay box */
-							9,16,17,0,							9,17,10,0,
-							17,18,14,0,							17,14,10,0,
-							13,14,18,0,							13,18,19,0,
-							13,19,16,0,							13,16,9,0,
+		/* sides of big box */
+		12,13,9,0,							12,9,8,0,
+		14,15,11,0,							14,11,10,0,
 
-							/* inlay box back */
-							19,18,17,0,							19,17,16,0,
+		/* inlay box */
+		9,16,17,0,							9,17,10,0,
+		17,18,14,0,							17,14,10,0,
+		13,14,18,0,							13,18,19,0,
+		13,19,16,0,							13,16,9,0,
 
-							/* up arrow background surface */
-							7,6,15,0,
-							7,15,14,0,
-							7,14,13,0,
-							7,13,12,0,
-							
-							/* up arrow face */
-							20,23,24,0,							20,24,21,0,
-							21,24,25,0,							21,25,22,0,
-							20,22,25,0,							20,25,23,0,
-							23,25,24,0,
+		/* inlay box back */
+		19,18,17,0,							19,17,16,0,
 
-							/* down arrow background surface */
-							4,8,9,0,
-							4,9,10,0,
-							4,10,11,0,
-							4,11,5,0,
-							
-							/* down arrow face */
-							26,27,31,0,							26,31,30,0,
-							31,27,28,0,							31,28,29,0,
-							26,30,29,0,							26,29,28,0,
-							30,31,29,0
+		/* up arrow background surface */
+		7,6,15,0,
+		7,15,14,0,
+		7,14,13,0,
+		7,13,12,0,
 
-					};
+		/* up arrow face */
+		20,23,24,0,							20,24,21,0,
+		21,24,25,0,							21,25,22,0,
+		20,22,25,0,							20,25,23,0,
+		23,25,24,0,
+
+		/* down arrow background surface */
+		4,8,9,0,
+		4,9,10,0,
+		4,10,11,0,
+		4,11,5,0,
+
+		/* down arrow face */
+		26,27,31,0,							26,31,30,0,
+		31,27,28,0,							31,28,29,0,
+		26,30,29,0,							26,29,28,0,
+		30,31,29,0
+
+	};
 	unsigned int bar_polygons[14*4]={
-							/* front */
-							0,4,5,0,							0,5,1,0,
-							1,5,6,0,							1,6,2,0,
-							3,2,6,0,							3,6,7,0,
-							3,7,4,0,							3,4,0,0,
+		/* front */
+		0,4,5,0,							0,5,1,0,
+		1,5,6,0,							1,6,2,0,
+		3,2,6,0,							3,6,7,0,
+		3,7,4,0,							3,4,0,0,
 
-							7,6,4,0,							4,6,5,0,
+		7,6,4,0,							4,6,5,0,
 
-							/* back, only visible sides */
-							2,3,11,0,							2,11,10,0,
-							1,9,8,0,							1,8,0,0
-			};
+		/* back, only visible sides */
+		2,3,11,0,							2,11,10,0,
+		1,9,8,0,							1,8,0,0
+	};
 	float bar_vertices[12*3];
 	float w,h;
 	float temp;
 
-	
+
 	w=(scrollbar->type==S3DW_SBAR_VERT)? widget->width : widget->height;
 	h=(scrollbar->type==S3DW_SBAR_VERT)? widget->height : widget->width;
 	/* outside/big  box */
-	back_vertices[0*3+0]=w*0.0;			back_vertices[0*3+1]=0.0-h;			back_vertices[0*3+2]=0.0;
-	back_vertices[1*3+0]=w*1.0;			back_vertices[1*3+1]=0.0-h;			back_vertices[1*3+2]=0.0;
-	back_vertices[2*3+0]=w*1.0;			back_vertices[2*3+1]=0.0;			back_vertices[2*3+2]=0.0;
-	back_vertices[3*3+0]=w*0.0;			back_vertices[3*3+1]=0.0;			back_vertices[3*3+2]=0.0;
-	back_vertices[4*3+0]=w*0.125;		back_vertices[4*3+1]=w*0.125-h;		back_vertices[4*3+2]=0.25;
-	back_vertices[5*3+0]=w*0.875;		back_vertices[5*3+1]=w*0.125-h;		back_vertices[5*3+2]=0.25;
-	back_vertices[6*3+0]=w*0.875;		back_vertices[6*3+1]=w*-0.125;		back_vertices[6*3+2]=0.25;
-	back_vertices[7*3+0]=w*0.125;		back_vertices[7*3+1]=w*-0.125;		back_vertices[7*3+2]=0.25;
+	back_vertices[0*3+0]=w*0.0;
+	back_vertices[0*3+1]=0.0-h;
+	back_vertices[0*3+2]=0.0;
+	back_vertices[1*3+0]=w*1.0;
+	back_vertices[1*3+1]=0.0-h;
+	back_vertices[1*3+2]=0.0;
+	back_vertices[2*3+0]=w*1.0;
+	back_vertices[2*3+1]=0.0;
+	back_vertices[2*3+2]=0.0;
+	back_vertices[3*3+0]=w*0.0;
+	back_vertices[3*3+1]=0.0;
+	back_vertices[3*3+2]=0.0;
+	back_vertices[4*3+0]=w*0.125;
+	back_vertices[4*3+1]=w*0.125-h;
+	back_vertices[4*3+2]=0.25;
+	back_vertices[5*3+0]=w*0.875;
+	back_vertices[5*3+1]=w*0.125-h;
+	back_vertices[5*3+2]=0.25;
+	back_vertices[6*3+0]=w*0.875;
+	back_vertices[6*3+1]=w*-0.125;
+	back_vertices[6*3+2]=0.25;
+	back_vertices[7*3+0]=w*0.125;
+	back_vertices[7*3+1]=w*-0.125;
+	back_vertices[7*3+2]=0.25;
 
 	/* downside inlay */
-	back_vertices[8*3+0]=w* 0.125;		back_vertices[8*3+1]=w-h;			back_vertices[8*3+2]=0.25;
-	back_vertices[9*3+0]=w* 0.25;		back_vertices[9*3+1]=w-h;			back_vertices[9*3+2]=0.25;
-	back_vertices[10*3+0]=w*0.75;		back_vertices[10*3+1]=w-h;			back_vertices[10*3+2]=0.25;
-	back_vertices[11*3+0]=w*0.875;		back_vertices[11*3+1]=w-h;			back_vertices[11*3+2]=0.25;
+	back_vertices[8*3+0]=w* 0.125;
+	back_vertices[8*3+1]=w-h;
+	back_vertices[8*3+2]=0.25;
+	back_vertices[9*3+0]=w* 0.25;
+	back_vertices[9*3+1]=w-h;
+	back_vertices[9*3+2]=0.25;
+	back_vertices[10*3+0]=w*0.75;
+	back_vertices[10*3+1]=w-h;
+	back_vertices[10*3+2]=0.25;
+	back_vertices[11*3+0]=w*0.875;
+	back_vertices[11*3+1]=w-h;
+	back_vertices[11*3+2]=0.25;
 
 	/* upside inlay */
-	back_vertices[12*3+0]=w*0.125;		back_vertices[12*3+1]=-w;			back_vertices[12*3+2]=0.25;
-	back_vertices[13*3+0]=w*0.25;		back_vertices[13*3+1]=-w;			back_vertices[13*3+2]=0.25;
-	back_vertices[14*3+0]=w*0.75;		back_vertices[14*3+1]=-w;			back_vertices[14*3+2]=0.25;
-	back_vertices[15*3+0]=w*0.875;		back_vertices[15*3+1]=-w;			back_vertices[15*3+2]=0.25;
+	back_vertices[12*3+0]=w*0.125;
+	back_vertices[12*3+1]=-w;
+	back_vertices[12*3+2]=0.25;
+	back_vertices[13*3+0]=w*0.25;
+	back_vertices[13*3+1]=-w;
+	back_vertices[13*3+2]=0.25;
+	back_vertices[14*3+0]=w*0.75;
+	back_vertices[14*3+1]=-w;
+	back_vertices[14*3+2]=0.25;
+	back_vertices[15*3+0]=w*0.875;
+	back_vertices[15*3+1]=-w;
+	back_vertices[15*3+2]=0.25;
 
 	/* inlay box */
-	back_vertices[16*3+0]=w*0.25;		back_vertices[16*3+1]=w*0.125-h+w;	back_vertices[16*3+2]=0.125;
-	back_vertices[17*3+0]=w*0.75;		back_vertices[17*3+1]=w*0.125-h+w;	back_vertices[17*3+2]=0.125;
-	back_vertices[18*3+0]=w*0.75;		back_vertices[18*3+1]=w*-0.125-w;	back_vertices[18*3+2]=0.125;
-	back_vertices[19*3+0]=w*0.25;		back_vertices[19*3+1]=w*-0.125-w;	back_vertices[19*3+2]=0.125;
+	back_vertices[16*3+0]=w*0.25;
+	back_vertices[16*3+1]=w*0.125-h+w;
+	back_vertices[16*3+2]=0.125;
+	back_vertices[17*3+0]=w*0.75;
+	back_vertices[17*3+1]=w*0.125-h+w;
+	back_vertices[17*3+2]=0.125;
+	back_vertices[18*3+0]=w*0.75;
+	back_vertices[18*3+1]=w*-0.125-w;
+	back_vertices[18*3+2]=0.125;
+	back_vertices[19*3+0]=w*0.25;
+	back_vertices[19*3+1]=w*-0.125-w;
+	back_vertices[19*3+2]=0.125;
 
 	/* arrow up */
-	back_vertices[20*3+0]=w*0.25;		back_vertices[20*3+1]=w*-0.875;		back_vertices[20*3+2]=0.25;
-	back_vertices[21*3+0]=w*0.75;		back_vertices[21*3+1]=w*-0.875;		back_vertices[21*3+2]=0.25;
-	back_vertices[22*3+0]=w*0.5;		back_vertices[22*3+1]=w*-0.25;		back_vertices[22*3+2]=0.25;
-	back_vertices[23*3+0]=w*0.375;		back_vertices[23*3+1]=w*-0.75;		back_vertices[23*3+2]=0.375;
-	back_vertices[24*3+0]=w*0.625;		back_vertices[24*3+1]=w*-0.75;		back_vertices[24*3+2]=0.375;
-	back_vertices[25*3+0]=w*0.5;		back_vertices[25*3+1]=w*-0.375;		back_vertices[25*3+2]=0.375;
+	back_vertices[20*3+0]=w*0.25;
+	back_vertices[20*3+1]=w*-0.875;
+	back_vertices[20*3+2]=0.25;
+	back_vertices[21*3+0]=w*0.75;
+	back_vertices[21*3+1]=w*-0.875;
+	back_vertices[21*3+2]=0.25;
+	back_vertices[22*3+0]=w*0.5;
+	back_vertices[22*3+1]=w*-0.25;
+	back_vertices[22*3+2]=0.25;
+	back_vertices[23*3+0]=w*0.375;
+	back_vertices[23*3+1]=w*-0.75;
+	back_vertices[23*3+2]=0.375;
+	back_vertices[24*3+0]=w*0.625;
+	back_vertices[24*3+1]=w*-0.75;
+	back_vertices[24*3+2]=0.375;
+	back_vertices[25*3+0]=w*0.5;
+	back_vertices[25*3+1]=w*-0.375;
+	back_vertices[25*3+2]=0.375;
 
 	/* arrow down */
-	back_vertices[26*3+0]=w*0.25;		back_vertices[26*3+1]=-h+w*0.875;	back_vertices[26*3+2]=0.25;
-	back_vertices[27*3+0]=w*0.75;		back_vertices[27*3+1]=-h+w*0.875;	back_vertices[27*3+2]=0.25;
-	back_vertices[28*3+0]=w*0.5;		back_vertices[28*3+1]=-h+w*0.25;	back_vertices[28*3+2]=0.25;
-	back_vertices[29*3+0]=w*0.375;		back_vertices[29*3+1]=-h+w*0.75;	back_vertices[29*3+2]=0.375;
-	back_vertices[30*3+0]=w*0.625;		back_vertices[30*3+1]=-h+w*0.75;	back_vertices[30*3+2]=0.375;
-	back_vertices[31*3+0]=w*0.5;		back_vertices[31*3+1]=-h+w*0.375;	back_vertices[31*3+2]=0.375;
+	back_vertices[26*3+0]=w*0.25;
+	back_vertices[26*3+1]=-h+w*0.875;
+	back_vertices[26*3+2]=0.25;
+	back_vertices[27*3+0]=w*0.75;
+	back_vertices[27*3+1]=-h+w*0.875;
+	back_vertices[27*3+2]=0.25;
+	back_vertices[28*3+0]=w*0.5;
+	back_vertices[28*3+1]=-h+w*0.25;
+	back_vertices[28*3+2]=0.25;
+	back_vertices[29*3+0]=w*0.375;
+	back_vertices[29*3+1]=-h+w*0.75;
+	back_vertices[29*3+2]=0.375;
+	back_vertices[30*3+0]=w*0.625;
+	back_vertices[30*3+1]=-h+w*0.75;
+	back_vertices[30*3+2]=0.375;
+	back_vertices[31*3+0]=w*0.5;
+	back_vertices[31*3+1]=-h+w*0.375;
+	back_vertices[31*3+2]=0.375;
 
 	/* scrollbar bar poinst */
-	bar_vertices[0*3+0]=w*0.25;			bar_vertices[0*3+1]=-(h-3)+w*0.125;	bar_vertices[0*3+2]=0.25;
-	bar_vertices[1*3+0]=w*0.75;			bar_vertices[1*3+1]=-(h-3)+w*0.125;	bar_vertices[1*3+2]=0.25;
-	bar_vertices[2*3+0]=w*0.75;			bar_vertices[2*3+1]=-w*0.125;		bar_vertices[2*3+2]=0.25;
-	bar_vertices[3*3+0]=w*0.25;			bar_vertices[3*3+1]=-w*0.125;		bar_vertices[3*3+2]=0.25;
+	bar_vertices[0*3+0]=w*0.25;
+	bar_vertices[0*3+1]=-(h-3)+w*0.125;
+	bar_vertices[0*3+2]=0.25;
+	bar_vertices[1*3+0]=w*0.75;
+	bar_vertices[1*3+1]=-(h-3)+w*0.125;
+	bar_vertices[1*3+2]=0.25;
+	bar_vertices[2*3+0]=w*0.75;
+	bar_vertices[2*3+1]=-w*0.125;
+	bar_vertices[2*3+2]=0.25;
+	bar_vertices[3*3+0]=w*0.25;
+	bar_vertices[3*3+1]=-w*0.125;
+	bar_vertices[3*3+2]=0.25;
 
-	bar_vertices[4*3+0]=w*0.125;		bar_vertices[4*3+1]=-(h-3)+w*0.25;	bar_vertices[4*3+2]=0.375;
-	bar_vertices[5*3+0]=w*0.875;		bar_vertices[5*3+1]=-(h-3)+w*0.25;	bar_vertices[5*3+2]=0.375;
-	bar_vertices[6*3+0]=w*0.875;		bar_vertices[6*3+1]=-w*0.25;		bar_vertices[6*3+2]=0.375;
-	bar_vertices[7*3+0]=w*0.125;		bar_vertices[7*3+1]=-w*0.25;		bar_vertices[7*3+2]=0.375;
-	
-	bar_vertices[8*3+0]=w*0.125;		bar_vertices[8*3+1]=-(h-3)+w*0.25;	bar_vertices[8*3+2]=0.175;
-	bar_vertices[9*3+0]=w*0.875;		bar_vertices[9*3+1]=-(h-3)+w*0.25;	bar_vertices[9*3+2]=0.175;
-	bar_vertices[10*3+0]=w*0.875;		bar_vertices[10*3+1]=-w*0.25;		bar_vertices[10*3+2]=0.175;
-	bar_vertices[11*3+0]=w*0.125;		bar_vertices[11*3+1]=-w*0.25;		bar_vertices[11*3+2]=0.175;
+	bar_vertices[4*3+0]=w*0.125;
+	bar_vertices[4*3+1]=-(h-3)+w*0.25;
+	bar_vertices[4*3+2]=0.375;
+	bar_vertices[5*3+0]=w*0.875;
+	bar_vertices[5*3+1]=-(h-3)+w*0.25;
+	bar_vertices[5*3+2]=0.375;
+	bar_vertices[6*3+0]=w*0.875;
+	bar_vertices[6*3+1]=-w*0.25;
+	bar_vertices[6*3+2]=0.375;
+	bar_vertices[7*3+0]=w*0.125;
+	bar_vertices[7*3+1]=-w*0.25;
+	bar_vertices[7*3+2]=0.375;
 
+	bar_vertices[8*3+0]=w*0.125;
+	bar_vertices[8*3+1]=-(h-3)+w*0.25;
+	bar_vertices[8*3+2]=0.175;
+	bar_vertices[9*3+0]=w*0.875;
+	bar_vertices[9*3+1]=-(h-3)+w*0.25;
+	bar_vertices[9*3+2]=0.175;
+	bar_vertices[10*3+0]=w*0.875;
+	bar_vertices[10*3+1]=-w*0.25;
+	bar_vertices[10*3+2]=0.175;
+	bar_vertices[11*3+0]=w*0.125;
+	bar_vertices[11*3+1]=-w*0.25;
+	bar_vertices[11*3+2]=0.175;
 
 
-	
-	if (scrollbar->type==S3DW_SBAR_HORI) /* rotate x and y for horizontal scrollbar */
-	{
+
+
+	if (scrollbar->type==S3DW_SBAR_HORI) { /* rotate x and y for horizontal scrollbar */
 		for (i=0;i<32;i++)	{
 			temp=back_vertices[i*3];
 			back_vertices[i*3]=-back_vertices[i*3+1];
@@ -207,7 +294,7 @@
 	s3d_link(		   scrollbar->roid,widget->oid);
 	s3d_link(		   scrollbar->baroid,widget->oid);
 	s3d_translate(widget->oid,widget->x,-widget->y,0);
-	if (scrollbar->type==S3DW_SBAR_VERT) 
+	if (scrollbar->type==S3DW_SBAR_VERT)
 		s3d_translate(scrollbar->baroid,0,-1.5,0);
 	else
 		s3d_translate(scrollbar->baroid,1.5,0,0);
@@ -217,20 +304,20 @@
 void s3dw_scrollbar_show(s3dw_widget *widget)
 {
 	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
-    s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(scrollbar->loid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(scrollbar->roid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(scrollbar->baroid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(scrollbar->loid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(scrollbar->roid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(scrollbar->baroid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 
 }
 /* hides the scrollbar */
 void s3dw_scrollbar_hide(s3dw_widget *widget)
 {
 	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
-    s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(scrollbar->loid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(scrollbar->roid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(scrollbar->baroid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(scrollbar->loid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(scrollbar->roid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(scrollbar->baroid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 
 /* create a new scrollbar in the surface */
@@ -241,8 +328,7 @@
 	scrollbar=(s3dw_scrollbar *)malloc(sizeof(s3dw_scrollbar));
 	widget=s3dw_widget_new((s3dw_widget *)scrollbar);
 	widget->type=S3DW_TSCROLLBAR;
-	if ((scrollbar->type=type)==S3DW_SBAR_HORI)
-	{
+	if ((scrollbar->type=type)==S3DW_SBAR_HORI) {
 		widget->height=1;
 		widget->width=length;
 	} else {
@@ -286,13 +372,11 @@
 int s3dw_scrollbar_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
-	if (scrollbar->loid==oid)
-	{
+	if (scrollbar->loid==oid) {
 		scrollbar->lonclick(widget);
 		return(1);
 	}
-	if (scrollbar->roid==oid)
-	{
+	if (scrollbar->roid==oid) {
 		scrollbar->ronclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/style.c
===================================================================
--- trunk/libs3dw/style.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/style.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -29,43 +29,43 @@
 
 /* default style */
 s3dw_style def_style={
-/* name */
-"default",
-/* font face */
-"vera",
-/* surface_mat */
-{0.7,0.7,0.7,1.0, 
- 0.7,0.7,0.7,1.0, 
- 0.7,0.7,0.7,1.0
-},
-/* input_mat */
-{0.7,0.7,0.7,1.0,
- 0.7,0.7,0.7,1.0,
- 0.7,0.7,0.7,1.0
-},
-/* inputback_mat */
-{0.9,0.9,0.9,1.0,
- 0.9,0.9,0.9,1.0,
- 0.9,0.9,0.9,1.0
-},
+	/* name */
+	"default",
+	/* font face */
+	"vera",
+	/* surface_mat */
+	{0.7,0.7,0.7,1.0,
+		0.7,0.7,0.7,1.0,
+		0.7,0.7,0.7,1.0
+	},
+	/* input_mat */
+	{0.7,0.7,0.7,1.0,
+	 0.7,0.7,0.7,1.0,
+	 0.7,0.7,0.7,1.0
+	},
+	/* inputback_mat */
+	{0.9,0.9,0.9,1.0,
+	 0.9,0.9,0.9,1.0,
+	 0.9,0.9,0.9,1.0
+	},
 
-/* text_mat */
-{
- 0.0,0.0,0.0,1.0,
- 1.0,1.0,1.0,1.0,
- 0.0,0.0,0.0,1.0
-},
-/* title_mat */
-{
- 0.0,0.4,0.8,1.0,
- 1.0,1.0,1.0,1.0,
- 0.0,0.4,0.8,1.0
-},
-/* title_text_mat */
-{
- 0.0,0.0,0.0,1.0,
- 0.0,0.0,0.0,1.0,
- 0.0,0.0,0.0,1.0
-}
+	/* text_mat */
+	{
+		0.0,0.0,0.0,1.0,
+		1.0,1.0,1.0,1.0,
+		0.0,0.0,0.0,1.0
+	},
+	/* title_mat */
+	{
+		0.0,0.4,0.8,1.0,
+		1.0,1.0,1.0,1.0,
+		0.0,0.4,0.8,1.0
+	},
+	/* title_text_mat */
+	{
+		0.0,0.0,0.0,1.0,
+		0.0,0.0,0.0,1.0,
+		0.0,0.0,0.0,1.0
+	}
 };
 

Modified: trunk/libs3dw/surface.c
===================================================================
--- trunk/libs3dw/surface.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/surface.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -65,14 +65,12 @@
 	surface->oid_tbar=s3d_new_object();
 	s3d_select_font("vera");
 	surface->oid_title=s3d_draw_string(surface->title,&length);
-	while (length > (widget->width+1))
-	{
+	while (length > (widget->width+1)) {
 		s3dprintf(HIGH,"%f > %f",length,widget->width+1);
 		textlen=strlen(surface->title);
 		if (length>((widget->width+1)*1.3))
 			textlen=textlen*((widget->width+1)*1.1/length);
-		if (textlen>4)
-		{
+		if (textlen>4) {
 			surface->title[textlen-2]=0;
 			surface->title[textlen-3]='.';
 			surface->title[textlen-4]='.';
@@ -82,9 +80,8 @@
 			break;
 		}
 	}
- 	/* prepare vertices */
-	for (i=0;i<8;i++)
-	{
+	/* prepare vertices */
+	for (i=0;i<8;i++) {
 		sver[i*3 + 0]=vertices[i*3+0] * widget->width;
 		sver[i*3 + 1]=vertices[i*3+1] * -widget->height;
 		sver[i*3 + 2]=vertices[i*3+2] * -1;
@@ -93,12 +90,11 @@
 		tver[i*3 + 2]=vertices[i*3+2] * -1;
 	}
 	/* swap */
-	for (i=0;i<10;i++)
-	{
-	   tpol[i*4 + 0]=polygon[i*4 + 1];
-	   tpol[i*4 + 1]=polygon[i*4 + 0];
-	   tpol[i*4 + 2]=polygon[i*4 + 2];
-	   tpol[i*4 + 3]=polygon[i*4 + 3];
+	for (i=0;i<10;i++) {
+		tpol[i*4 + 0]=polygon[i*4 + 1];
+		tpol[i*4 + 1]=polygon[i*4 + 0];
+		tpol[i*4 + 2]=polygon[i*4 + 2];
+		tpol[i*4 + 3]=polygon[i*4 + 3];
 	}
 	s3d_push_vertices(widget->oid,sver,8);
 	s3d_push_vertices(surface->oid_tbar,tver,8);
@@ -118,17 +114,17 @@
 void s3dw_surface_show(s3dw_widget *widget)
 {
 	s3dw_surface *surface=(s3dw_surface *)widget;
-    s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(surface->oid_title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(surface->oid_tbar,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(surface->oid_title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(surface->oid_tbar,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* hides the surface */
 void s3dw_surface_hide(s3dw_widget *widget)
 {
 	s3dw_surface *surface=(s3dw_surface *)widget;
-    s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(surface->oid_title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_off(surface->oid_tbar,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(surface->oid_title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(surface->oid_tbar,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* create a new surface */
 s3dw_surface *s3dw_surface_new(char *title, float width, float height)
@@ -136,7 +132,7 @@
 	s3dw_surface *surface;
 	s3dw_widget  *widget;
 	float f1[3];
-			
+
 	surface=(s3dw_surface *)malloc(sizeof(s3dw_surface));
 	surface->title=strdup(title);
 	widget=s3dw_widget_new((s3dw_widget *)surface);
@@ -183,14 +179,12 @@
 int s3dw_surface_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	s3dw_surface *surface=(s3dw_surface *)widget;
-	if (widget->oid==oid)
-	{
+	if (widget->oid==oid) {
 		s3dw_focus(widget);
 		s3dprintf(MED,"body %s clicked",surface->title);
 		return(1);
 	}
-	if ((surface->oid_tbar==oid) || (surface->oid_title==oid))
-	{
+	if ((surface->oid_tbar==oid) || (surface->oid_title==oid)) {
 		s3dw_focus(widget);
 		s3dprintf(MED,"title %s clicked",surface->title);
 		return(1);

Modified: trunk/libs3dw/textbox.c
===================================================================
--- trunk/libs3dw/textbox.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/textbox.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -33,44 +33,68 @@
 	float h,w;
 	float vertices[12*3];
 	uint32_t polygons[18*4]={
-			0,4,5,1,
-			0,5,1,1,
-			1,5,6,1,
-			1,6,2,1,
-			2,6,7,1,
-			2,7,3,1,
-			3,7,4,1,
-			3,4,0,1,
+		0,4,5,1,
+		0,5,1,1,
+		1,5,6,1,
+		1,6,2,1,
+		2,6,7,1,
+		2,7,3,1,
+		3,7,4,1,
+		3,4,0,1,
 
-			4,8, 9, 1,
-			4,9, 5, 1,
-			5,9, 10,1,
-			5,10,6, 1,
-			6,10,11,1,
-			6,11,7, 1,
-			7,11,8, 1,
-			7,8, 4, 1,
+		4,8, 9, 1,
+		4,9, 5, 1,
+		5,9, 10,1,
+		5,10,6, 1,
+		6,10,11,1,
+		6,11,7, 1,
+		7,11,8, 1,
+		7,8, 4, 1,
 
 
-			8,11,10,0,
-			8,10,9, 0
+		8,11,10,0,
+		8,10,9, 0
 	};
 	w=widget->width-2;
 	h=widget->height-3;
 	if (widget->width<1) return;
 	/* width of the input depends on the length of the text */
-	vertices[0*3+0]=0.0;			vertices[0*3+1]=0.0;		vertices[0*3+2]=0.0;	
-	vertices[1*3+0]=0.0;			vertices[1*3+1]=-h-2.0;		vertices[1*3+2]=0.0;	
-	vertices[2*3+0]=w+1;			vertices[2*3+1]=-h-2.0;		vertices[2*3+2]=0.0;	
-	vertices[3*3+0]=w+1;			vertices[3*3+1]=0.0;		vertices[3*3+2]=0.0;	
-	vertices[4*3+0]=0.125;			vertices[4*3+1]=-0.125;		vertices[4*3+2]=0.25;	
-	vertices[5*3+0]=0.125;			vertices[5*3+1]=-h-1.875;	vertices[5*3+2]=0.25;	
-	vertices[6*3+0]=w+0.875;		vertices[6*3+1]=-h-1.875;	vertices[6*3+2]=0.25;	
-	vertices[7*3+0]=w+0.875;		vertices[7*3+1]=-0.125;		vertices[7*3+2]=0.25;	
-	vertices[8*3+0]=0.25;			vertices[8*3+1]=-0.25;		vertices[8*3+2]=0.125;	
-	vertices[9*3+0]=0.25;			vertices[9*3+1]=-h-1.75;	vertices[9*3+2]=0.125;	
-	vertices[10*3+0]=w+0.75;		vertices[10*3+1]=-h-1.75;	vertices[10*3+2]=0.125;	
-	vertices[11*3+0]=w+0.75;		vertices[11*3+1]=-0.25;		vertices[11*3+2]=0.125;	
+	vertices[0*3+0]=0.0;
+	vertices[0*3+1]=0.0;
+	vertices[0*3+2]=0.0;
+	vertices[1*3+0]=0.0;
+	vertices[1*3+1]=-h-2.0;
+	vertices[1*3+2]=0.0;
+	vertices[2*3+0]=w+1;
+	vertices[2*3+1]=-h-2.0;
+	vertices[2*3+2]=0.0;
+	vertices[3*3+0]=w+1;
+	vertices[3*3+1]=0.0;
+	vertices[3*3+2]=0.0;
+	vertices[4*3+0]=0.125;
+	vertices[4*3+1]=-0.125;
+	vertices[4*3+2]=0.25;
+	vertices[5*3+0]=0.125;
+	vertices[5*3+1]=-h-1.875;
+	vertices[5*3+2]=0.25;
+	vertices[6*3+0]=w+0.875;
+	vertices[6*3+1]=-h-1.875;
+	vertices[6*3+2]=0.25;
+	vertices[7*3+0]=w+0.875;
+	vertices[7*3+1]=-0.125;
+	vertices[7*3+2]=0.25;
+	vertices[8*3+0]=0.25;
+	vertices[8*3+1]=-0.25;
+	vertices[8*3+2]=0.125;
+	vertices[9*3+0]=0.25;
+	vertices[9*3+1]=-h-1.75;
+	vertices[9*3+2]=0.125;
+	vertices[10*3+0]=w+0.75;
+	vertices[10*3+1]=-h-1.75;
+	vertices[10*3+2]=0.125;
+	vertices[11*3+0]=w+0.75;
+	vertices[11*3+1]=-0.25;
+	vertices[11*3+2]=0.125;
 	widget->oid=s3d_new_object();
 	s3d_push_materials_a(widget->oid,widget->style->inputback_mat,1);
 	s3d_push_materials_a(widget->oid,widget->style->input_mat,1);
@@ -98,28 +122,25 @@
 	for (i=0;i<textbox->n_lineoids;i++)
 		textbox->p_lineoids[i]=-1;
 	rest=text=strdup(textbox->text);
-	while (NULL!=(linefeedpos=strchr(rest,'\n'))) /* process every line */
-	{
+	while (NULL!=(linefeedpos=strchr(rest,'\n'))) { /* process every line */
 		linefeedpos[0]=0;
-		if ((x<strlen(rest)) && ((y>=0) && y<textbox->n_lineoids)) /* don't bother, if it's not visible anyway */
-		{
+		if ((x<strlen(rest)) && ((y>=0) && y<textbox->n_lineoids)) { /* don't bother, if it's not visible anyway */
 			rest+=x;	/* ignore the first x chars because we've scrolled a bit right */
 			while ((strlen(rest)>0) && (s3d_strlen(rest)>width))
 				rest[strlen(rest)-1]=0; /* remove last character and try again until it fits */
-			if (strlen(rest)>0)
-			{
-				 textbox->p_lineoids[y]=s3d_draw_string(rest,NULL);
-				 s3d_pep_materials_a(textbox->p_lineoids[y],widget->style->text_mat,1);
-				 s3d_translate( textbox->p_lineoids[y],0.5,-y-1,0.30);
-				 s3d_link(	   textbox->p_lineoids[y],widget->oid);
+			if (strlen(rest)>0) {
+				textbox->p_lineoids[y]=s3d_draw_string(rest,NULL);
+				s3d_pep_materials_a(textbox->p_lineoids[y],widget->style->text_mat,1);
+				s3d_translate( textbox->p_lineoids[y],0.5,-y-1,0.30);
+				s3d_link(	   textbox->p_lineoids[y],widget->oid);
 
 			}
-		} 
+		}
 		rest=linefeedpos+1;
 		y+=1;
 	}
 	if (y<0) textbox->window_y-=y;
-	
+
 	free(text);
 }
 void s3dw_textbox_erasetext(s3dw_widget *widget)
@@ -128,8 +149,7 @@
 	int i;
 
 
-	if (textbox->p_lineoids!=NULL)
-	{
+	if (textbox->p_lineoids!=NULL) {
 		for (i=0;i<textbox->n_lineoids;i++)
 			if (textbox->p_lineoids[i]!=-1)
 				s3d_del_object(textbox->p_lineoids[i]);
@@ -144,28 +164,36 @@
 {
 	s3dw_textbox *textbox=(s3dw_textbox *)widget;
 	int i;
-    s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	for (i=0;i<textbox->n_lineoids;i++)
-    	s3d_flags_on(textbox->p_lineoids[i],S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_on(textbox->p_lineoids[i],S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 /* hides the textbox */
 void s3dw_textbox_hide(s3dw_widget *widget)
 {
 	s3dw_textbox *textbox=(s3dw_textbox *)widget;
 	int i;
-    s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	for (i=0;i<textbox->n_lineoids;i++)
-    	s3d_flags_on(textbox->p_lineoids[i],S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_on(textbox->p_lineoids[i],S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 
 }
 static void _s3dw_textbox_scrollbar_up(s3dw_widget *widget)
-{	s3dw_textbox_scrollup((s3dw_textbox *)widget->parent);}
+{
+	s3dw_textbox_scrollup((s3dw_textbox *)widget->parent);
+}
 static void _s3dw_textbox_scrollbar_down(s3dw_widget *widget)
-{	s3dw_textbox_scrolldown((s3dw_textbox *)widget->parent);}
+{
+	s3dw_textbox_scrolldown((s3dw_textbox *)widget->parent);
+}
 static void _s3dw_textbox_scrollbar_left(s3dw_widget *widget)
-{	s3dw_textbox_scrollleft((s3dw_textbox *)widget->parent);}
+{
+	s3dw_textbox_scrollleft((s3dw_textbox *)widget->parent);
+}
 static void _s3dw_textbox_scrollbar_right(s3dw_widget *widget)
-{	s3dw_textbox_scrollright((s3dw_textbox *)widget->parent);}
+{
+	s3dw_textbox_scrollright((s3dw_textbox *)widget->parent);
+}
 
 /* create a new textbox in the surface */
 s3dw_textbox *s3dw_textbox_new(s3dw_surface *surface, char *text, float posx, float posy, float width, float height)
@@ -187,7 +215,7 @@
 	textbox->onclick=s3dw_nothing;
 	s3dw_widget_append((s3dw_widget *)surface, widget);		/* append first so the scrollbars inherit the style */
 	s3dw_textbox_draw(widget);
-	textbox->scroll_horizontal=s3dw_scrollbar_new(widget,S3DW_SBAR_HORI,  0,widget->height-1, widget->width-1); 
+	textbox->scroll_horizontal=s3dw_scrollbar_new(widget,S3DW_SBAR_HORI,  0,widget->height-1, widget->width-1);
 	textbox->scroll_vertical=s3dw_scrollbar_new(widget,S3DW_SBAR_VERT,  widget->width-1,0, widget->height-1);
 	textbox->scroll_horizontal->lonclick=_s3dw_textbox_scrollbar_left;
 	textbox->scroll_horizontal->ronclick=_s3dw_textbox_scrollbar_right;
@@ -203,7 +231,7 @@
 	if (widget->flags&S3DW_ONSCREEN)
 		s3dw_textbox_show(widget);
 }
-		
+
 void s3dw_textbox_scrollup(s3dw_textbox *textbox)
 {
 	if (textbox->window_y>0)
@@ -268,8 +296,7 @@
 int s3dw_textbox_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	s3dw_textbox *textbox=(s3dw_textbox *)widget;
-	if (widget->oid==oid)
-	{
+	if (widget->oid==oid) {
 		textbox->onclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/widget.c
===================================================================
--- trunk/libs3dw/widget.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/libs3dw/widget.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d Widgets, a Widget Library for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d Widgets is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d Widgets is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d Widgets; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -86,8 +86,7 @@
 	if (parent==NULL) return;
 
 	for (i=0;i<parent->nobj;i++) /* search ... */
-		if (parent->pobj[i]==widget) /* ... and destroy */
-		{
+		if (parent->pobj[i]==widget) { /* ... and destroy */
 			if (parent->focus==i)					parent->focus=-1;
 			if (parent->focus==(parent->nobj-1))	parent->focus=i;
 			parent->pobj[i]=parent->pobj[parent->nobj-1]; /* swap last element to the to be deleted one */
@@ -114,8 +113,7 @@
 {
 	int i;
 	for (i=0;i<focus->parent->nobj;i++)
-		if (focus->parent->pobj[i]==focus)
-		{
+		if (focus->parent->pobj[i]==focus) {
 			focus->parent->focus=i;
 			return;
 		}
@@ -126,8 +124,7 @@
 {
 	int i;
 	s3dw_widget *kid;
-	for (i=0;i<widget->nobj;i++)
-	{
+	for (i=0;i<widget->nobj;i++) {
 		kid=widget->pobj[i];
 		if (widget->flags&S3DW_VISIBLE)
 			s3dw_widget_visible(kid);

Modified: trunk/server/allocate.c
===================================================================
--- trunk/server/allocate.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/allocate.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -10,17 +10,17 @@
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -44,16 +44,14 @@
 
 struct chunkHeader *chunkList = NULL;
 
-struct chunkHeader
-{
+struct chunkHeader {
 	struct chunkHeader *next;
 	unsigned int length;
 	int tag;
 	unsigned int magicNumber;
 };
 
-struct chunkTrailer
-{
+struct chunkTrailer {
 	unsigned int magicNumber;
 };
 
@@ -63,10 +61,8 @@
 	struct chunkTrailer *chunkTrailer;
 	unsigned char *memory;
 
-	for (walker = chunkList; walker != NULL; walker = walker->next)
-	{
-		if (walker->magicNumber != MAGIC_NUMBER)
-		{
+	for (walker = chunkList; walker != NULL; walker = walker->next) {
+		if (walker->magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, "Invalid magic number in header: %08x, tag = %d\n", walker->magicNumber, walker->tag);
 			exit(1);
 		}
@@ -75,8 +71,7 @@
 
 		chunkTrailer = (struct chunkTrailer *)(memory + sizeof(struct chunkHeader) + walker->length);
 
-		if (chunkTrailer->magicNumber != MAGIC_NUMBER)
-		{
+		if (chunkTrailer->magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, "Invalid magic number in header: %08x, tag = %d\n", chunkTrailer->magicNumber, walker->tag);
 			exit(1);
 		}
@@ -98,12 +93,11 @@
 	struct chunkTrailer *chunkTrailer;
 	unsigned char *chunk;
 
-/* 	printf("sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\n", sizeof (struct chunkHeader), sizeof (struct chunkTrailer)); */
+	/* 	printf("sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\n", sizeof (struct chunkHeader), sizeof (struct chunkTrailer)); */
 
 	memory = malloc(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer));
 
-	if (memory == NULL)
-	{
+	if (memory == NULL) {
 		fprintf(stderr, "Cannot allocate %u bytes, tag = %d\n", (unsigned int)(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer)), tag);
 		exit(1);
 	}
@@ -135,30 +129,28 @@
 	if (memoryParameter) { /* if memoryParameter==NULL, realloc() should work like malloc() !! */
 		memory = memoryParameter;
 		chunkHeader = (struct chunkHeader *)(memory - sizeof(struct chunkHeader));
-	
-		if (chunkHeader->magicNumber != MAGIC_NUMBER)
-		{
+
+		if (chunkHeader->magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, "Invalid magic number in header: %08x, tag = %d\n", chunkHeader->magicNumber, chunkHeader->tag);
 			exit(1);
 		}
-	
+
 		chunkTrailer = (struct chunkTrailer *)(memory + chunkHeader->length);
-	
-		if (chunkTrailer->magicNumber != MAGIC_NUMBER)
-		{
+
+		if (chunkTrailer->magicNumber != MAGIC_NUMBER) {
 			fprintf(stderr, "Invalid magic number in header: %08x, tag = %d\n", chunkTrailer->magicNumber, chunkHeader->tag);
 			exit(1);
 		}
 	}
-	
 
+
 	result = debugMalloc(length, tag);
 	if (memoryParameter) {
 		copyLength = length;
 
 		if (copyLength > chunkHeader->length)
 			copyLength = chunkHeader->length;
-	
+
 		memcpy(result, memoryParameter, copyLength);
 		debugFree(memoryParameter);
 	}
@@ -178,24 +170,21 @@
 	memory = memoryParameter;
 	chunkHeader = (struct chunkHeader *)(memory - sizeof(struct chunkHeader));
 
-	if (chunkHeader->magicNumber != MAGIC_NUMBER)
-	{
+	if (chunkHeader->magicNumber != MAGIC_NUMBER) {
 		fprintf(stderr, "Invalid magic number in header: %08x, tag = %d\n", chunkHeader->magicNumber, chunkHeader->tag);
 		exit(1);
 	}
 
 	previous = NULL;
 
-	for (walker = chunkList; walker != NULL; walker = walker->next)
-	{
+	for (walker = chunkList; walker != NULL; walker = walker->next) {
 		if (walker == chunkHeader)
 			break;
 
 		previous = walker;
 	}
 
-	if (walker == NULL)
-	{
+	if (walker == NULL) {
 		fprintf(stderr, "Double free detected, tag = %d\n", chunkHeader->tag);
 		exit(1);
 	}
@@ -208,8 +197,7 @@
 
 	chunkTrailer = (struct chunkTrailer *)(memory + chunkHeader->length);
 
-	if (chunkTrailer->magicNumber != MAGIC_NUMBER)
-	{
+	if (chunkTrailer->magicNumber != MAGIC_NUMBER) {
 		fprintf(stderr, "Invalid magic number in header: %08x, tag = %d\n", chunkTrailer->magicNumber, chunkHeader->tag);
 		exit(1);
 	}
@@ -233,8 +221,7 @@
 
 	result = malloc(length);
 
-	if (result == NULL)
-	{
+	if (result == NULL) {
 		fprintf(stderr, "Cannot allocate %u bytes, tag = %d\n", length, tag);
 		exit(1);
 	}
@@ -248,8 +235,7 @@
 
 	result = realloc(memory, length);
 
-	if (result == NULL)
-	{
+	if (result == NULL) {
 		fprintf(stderr, "Cannot re-allocate %u bytes, tag = %d\n", length, tag);
 		exit(1);
 	}

Modified: trunk/server/allocate.h
===================================================================
--- trunk/server/allocate.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/allocate.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -10,17 +10,17 @@
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

Modified: trunk/server/config.h
===================================================================
--- trunk/server/config.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/config.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,24 +5,24 @@
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 /* use the global config.h */
-#include <config-s3d.h> 
+#include <config-s3d.h>
 
 /*  to be filled with configure options ...  */
 /*   */

Modified: trunk/server/cull.c
===================================================================
--- trunk/server/cull.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/cull.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,23 +1,23 @@
 /*
  * cull.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- * code originated from  http://www.racer.nl/reference/vfc.htm 
+ * code originated from  http://www.racer.nl/reference/vfc.htm
  * which is (C) Ruud van Gaal
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -44,8 +44,8 @@
 	struct t_plane *p;
 	int i;
 	float d;
-	
 
+
 	/* get matrices from opengl */
 	glGetFloatv(GL_MODELVIEW_MATRIX,mmodel);
 	glGetFloatv(GL_PROJECTION_MATRIX,mproj);
@@ -91,12 +91,10 @@
 	p->d=m[15]+m[14];
 
 	/* Normalize all plane normals */
-	for(i=0;i<6;i++)
-	{
+	for (i=0;i<6;i++) {
 		p=&frustumPlane[i];
 		d=sqrt(p->n.x*p->n.x + p->n.y*p->n.y + p->n.z*p->n.z);
-		if (d!=0.0)
-		{
+		if (d!=0.0) {
 			p->n.x/=d;
 			p->n.y/=d;
 			p->n.z/=d;
@@ -109,13 +107,11 @@
 {
 	int i;
 	struct t_plane *p;
-	for(i=0;i<6;i++)
-	{
+	for (i=0;i<6;i++) {
 		p=&frustumPlane[i];
-		if (p->n.x*center->x+p->n.y*center->y+p->n.z*center->z+p->d <= -radius)
-		{
-/*			s3dprintf(MED,"out of %d plane (n %f %f %f |d %f)",i,p->n.x,p->n.y,p->n.z,p->d);*/
-			 return 0; /* sorry, no ... */
+		if (p->n.x*center->x+p->n.y*center->y+p->n.z*center->z+p->d <= -radius) {
+			/*			s3dprintf(MED,"out of %d plane (n %f %f %f |d %f)",i,p->n.x,p->n.y,p->n.z,p->d);*/
+			return 0; /* sorry, no ... */
 		}
 	}
 	return 1; /* it's inside */

Modified: trunk/server/error.c
===================================================================
--- trunk/server/error.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/error.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,28 +1,28 @@
 /*
  * error.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 
-#include "global.h"	 
+#include "global.h"
 #include <stdio.h>	 /*  for printf() */
 #include <stdarg.h>	 /*  va_start, va_end */
 #include <string.h>  /*  for strerror() */
@@ -32,21 +32,25 @@
 /*  basicly, this is for upcoming logfiles, or maybe draw error-messages into */
 /*  the 3d-space */
 /*  this is the generic failure routine ... */
-void errn(char *func,int en) {
+void errn(char *func,int en)
+{
 	fprintf(stderr,"error: %s: (%d) %s\n",func,en, strerror(en));
 }
 /*  ... and it's fatal pendant */
-void errnf(char *func,int en) {
+void errnf(char *func,int en)
+{
 	fprintf(stderr,"FATAL: %s: (%d) %s\n",func,en, strerror(en));
 	exit(-1);
 }
 
 /*  prints an error with the function and it's error-message */
-void errs(char *func, char *msg) {
+void errs(char *func, char *msg)
+{
 	fprintf(stderr,"error: %s: %s\n",func,msg);
 }
 
-void errsf(char *func, char *msg) {
+void errsf(char *func, char *msg)
+{
 	fprintf(stderr,"FATAL: %s: %s\n",func,msg);
 	exit(-1);
 }
@@ -56,27 +60,26 @@
 {
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance >= DEBUG )
-	{
+	if (relevance >= DEBUG ) {
 		va_start(args,fmt);
 		vsnprintf((char *)&dbm,DBM_MAX,fmt,args);
 		va_end(args);
-	
+
 		fprintf(stderr,"error: %s:%s\n",func,(char *)&dbm);
 	}
 }
 /*  printing debug message */
 
-void s3dprintf(int relevance, const char *fmt, ...) {
+void s3dprintf(int relevance, const char *fmt, ...)
+{
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance >= DEBUG )
-	{
+	if (relevance >= DEBUG ) {
 		va_start(args,fmt);
 		vsnprintf((char *)&dbm,DBM_MAX,fmt,args);
 		va_end(args);
-	
-/*		fprintf(stderr,"debug: %s\n",(char *)&dbm);*/
+
+		/*		fprintf(stderr,"debug: %s\n",(char *)&dbm);*/
 		fprintf(stdout,"debug: %s\n",(char *)&dbm);
 	}
 }

Modified: trunk/server/event.c
===================================================================
--- trunk/server/event.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/event.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * event.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -25,11 +25,11 @@
 #include "global.h"
 #include "proto.h"
 #include <stdio.h>		/* sprintf() */
-#ifdef WIN32 
+#ifdef WIN32
 #include <winsock2.h>
 #else
 #include <netinet/in.h>  /*  htonl(),htons() */
-#endif 
+#endif
 #include <string.h>  /*  strlen(),strcpy() */
 extern int focus_oid;
 extern int winw,winh; /* to give aspect ratio to the program */
@@ -84,7 +84,7 @@
 int event_quit(struct t_process *p)
 {
 	prot_com_out(p, S3D_P_S_QUIT, NULL,0);
-	s3dprintf(HIGH,"sending pid %d QUIT signal",p->id); 
+	s3dprintf(HIGH,"sending pid %d QUIT signal",p->id);
 	process_del(p->id);
 	return(0);
 }
@@ -106,8 +106,7 @@
 	struct t_obj	 *o;
 	p=get_proc_by_pid(MCP);
 	event_obj_info(p,get_pointer(p));
-	if (OBJ_VALID(p,focus_oid,o))
-	{
+	if (OBJ_VALID(p,focus_oid,o)) {
 		p=get_proc_by_pid(o->n_mat); /* focused program pointer*/
 		event_obj_info(p,get_pointer(p));
 	}
@@ -120,35 +119,33 @@
 	struct t_obj_info mo;
 	struct t_process *ap;
 	struct t_obj *o;
-	if (OBJ_VALID(p,oid,o))
-	{
+	if (OBJ_VALID(p,oid,o)) {
 		mo.object=htonl(oid);
 		mo.trans_x=p->object[oid]->translate.x;
 		mo.trans_y=p->object[oid]->translate.y;
 		mo.trans_z=p->object[oid]->translate.z;
-	
+
 		mo.rot_x=p->object[oid]->rotate.x;
 		mo.rot_y=p->object[oid]->rotate.y;
 		mo.rot_z=p->object[oid]->rotate.z;
-	
+
 		mo.scale=p->object[oid]->scale;
-	
+
 		mo.r=p->object[oid]->r;
 
 		memset(mo.name,0,NAME_MAX);
-		switch (o->oflags&OF_TYPE)
-		{
-			case OF_VIRTUAL:
-				ap=get_proc_by_pid(o->n_mat);
-				strncpy(mo.name,ap->name,NAME_MAX);
-				break;
-			case OF_CAM:
-				mo.scale=(float)((float)winw)/winh; /* give aspect ratio to program */
-				strncpy(mo.name,"sys_camera0",NAME_MAX);
-				break;
-			case OF_POINTER:
-				strncpy(mo.name,"sys_pointer0",NAME_MAX);
-				break;
+		switch (o->oflags&OF_TYPE) {
+		case OF_VIRTUAL:
+			ap=get_proc_by_pid(o->n_mat);
+			strncpy(mo.name,ap->name,NAME_MAX);
+			break;
+		case OF_CAM:
+			mo.scale=(float)((float)winw)/winh; /* give aspect ratio to program */
+			strncpy(mo.name,"sys_camera0",NAME_MAX);
+			break;
+		case OF_POINTER:
+			strncpy(mo.name,"sys_pointer0",NAME_MAX);
+			break;
 
 		}
 		prot_com_out(p,S3D_P_S_OINFO,(uint8_t *)&mo,sizeof(struct t_obj_info));

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/global.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -5,17 +5,17 @@
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -23,28 +23,28 @@
 
 
 #include "config.h"
-#ifdef __APPLE__ 
+#ifdef __APPLE__
 #ifdef SHM
 #undef SHM
 #endif
-#endif 
+#endif
 #include <stdint.h>		 /*  integer types */
 #ifdef SHM
-	#include <sys/shm.h> /* key_t */
+#include <sys/shm.h> /* key_t */
 #endif
 /*  variables and defines */
 extern int frame_mode; 	 /*  GLUT, SDL, ... ? */
 extern int running;		 /*  server running flag */
 /*  relevance macros */
 #ifndef S3DUNUSED
-	#if defined(UNUSEDPARAM_ATTRIBUTE)
-		#define S3DUNUSED(x) (x)__attribute__((unused))
-	#elif defined(UNUSEDPARAM_OMIT)
-		#define S3DUNUSED(x) /* x */
-	#else
-		#define S3DUNUSED(x) x
-	#endif
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define S3DUNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define S3DUNUSED(x) /* x */
+#else
+#define S3DUNUSED(x) x
 #endif
+#endif
 #define NAME_MAX	256		 /*  limit for names [e.g. process names] */
 #define MCP			0		 /*  the mcp's pid	 */
 #define TEXTURE_MAX_W	2048
@@ -66,60 +66,52 @@
 #define OBJ_VALID(p,oid,o)	(oid >= 0) && ((oid < p->n_obj) && ((o=p->object[oid])!=NULL))
 typedef float t_mtrx[16];
 
-struct buf_t
-{
+struct buf_t {
 	uint32_t start,end,bufsize;	/* start/end of the data */
 };
 
 /*  some graphic simple prototypes, they might get into some headerfile later ... */
 /*  our lovely vertex list ... */
-struct t_vertex 
-{
+struct t_vertex {
 	float x,y,z;
 };
-struct t_texc
-{
+struct t_texc {
 	float x,y;
 };
 /*  polygon definition; */
 /*  it's all handled via list types as usually we have only one surface for many polygons, */
 /*  and many vertexes have 2 or more polygons connected. OpenGL will optimize the lists for us */
 /*  anyways, so we shouldn't care ... */
-struct t_poly
-{
+struct t_poly {
 	uint32_t v[3]; 				 /*  we define a poly as set of 3 vertexes, as its usual */
 	struct t_vertex n[3]; 		 /*  normal vectors */
 	uint32_t mat;  				 /*  material index */
 	struct t_texc tc[3];		 /*  texture coords */
 };
-struct t_line
-{
+struct t_line {
 	uint32_t v[2];
 	struct t_vertex n[2];		 /* normal vectors */
 	uint32_t mat;
 };
 /*  material of surfaces, as it's usual in the OpenGL standard */
-struct t_mat
-{
+struct t_mat {
 	float amb_r,amb_g,amb_b,amb_a, 			 /*  ambience */
-		  spec_r,spec_g,spec_b,spec_a,	 	 /*  specualar */
-		  diff_r,diff_g,diff_b,diff_a;		 /*  diffusion */
+	spec_r,spec_g,spec_b,spec_a,	 	 /*  specualar */
+	diff_r,diff_g,diff_b,diff_a;		 /*  diffusion */
 	int32_t tex;							 /*  texture index, -1 if there is no */
 };
 /*  this defines a texture */
-struct t_tex
-{
+struct t_tex {
 	uint16_t w,h;		 /*  width and height */
 	uint16_t tw,th;		 /*  texture width */
 	uint8_t *buf;		 /*  the data */
 	float xs,ys;		 /*  scale data for gl-implementations which require 2^x */
-						 /*  texture sizes. */
+	/*  texture sizes. */
 	int32_t gl_texnum;	 /*  the gl texture number. */
 };
 /*  the object type */
-struct t_obj
-{
-		uint32_t oflags;			 /*  flags, like this object beeing input etc. */
+struct t_obj {
+	uint32_t oflags;			 /*  flags, like this object beeing input etc. */
 #define OF_TURN_ON 		1
 #define OF_TURN_OFF 	2
 #define OF_TURN_SWAP 	3
@@ -138,31 +130,31 @@
 
 #define OF_CLONE		0x10000000
 #define OF_VIRTUAL		0x20000000
-		
+
 #define OF_SYSTEM		0x80000000
 #define OF_CAM			0x90000000
 #define OF_POINTER		0xA0000000
 #define OF_3DPOINTER	0xB0000000
 
 #define OF_MASK			0x00FFFFFF
-		int32_t n_vertex, n_mat, n_poly, n_tex, n_line;
-					 /*  if OF_VIRTUAL is set, n_mat contains the pid */
-					 /*  if OF_CLONE is set, n_vertex contains the original oid */
-					 /*  I know this is dirty, but it would a waste of data if I don't do so ... */
-		int32_t dplist;		 /*  opengl display list number */
-		int32_t linkid;		 /*  linking target, -1 if there is none */
-		int32_t lsub,lnext,lprev;
-		 /*  pointer to our objects; */
-		struct t_vertex *p_vertex;
-		struct t_mat	*p_mat;
-		struct t_poly	*p_poly;
-		struct t_line   *p_line;
-		struct t_tex	*p_tex;
-		struct t_vertex translate,rotate;
-		float 			scale;
-		t_mtrx			m;
-		int				m_uptodate;	 
-		float r,or;					 /*  radius, object radius */
+	int32_t n_vertex, n_mat, n_poly, n_tex, n_line;
+	/*  if OF_VIRTUAL is set, n_mat contains the pid */
+	/*  if OF_CLONE is set, n_vertex contains the original oid */
+	/*  I know this is dirty, but it would a waste of data if I don't do so ... */
+	int32_t dplist;		 /*  opengl display list number */
+	int32_t linkid;		 /*  linking target, -1 if there is none */
+	int32_t lsub,lnext,lprev;
+	/*  pointer to our objects; */
+	struct t_vertex *p_vertex;
+	struct t_mat	*p_mat;
+	struct t_poly	*p_poly;
+	struct t_line   *p_line;
+	struct t_tex	*p_tex;
+	struct t_vertex translate,rotate;
+	float 			scale;
+	t_mtrx			m;
+	int				m_uptodate;
+	float r,or;					 /*  radius, object radius */
 };
 #ifdef SHM
 struct t_shmcb {
@@ -175,8 +167,7 @@
 #endif
 
 /*  l_* is a list-type, t_* is the type itself */
-struct t_process
-{
+struct t_process {
 	char 				  name[NAME_MAX];		 /*  process name */
 	struct t_obj		**object;				 /*  initial pointer to object list */
 	int32_t				  n_obj;				 /*  number of objects */
@@ -195,15 +186,14 @@
 #endif
 };
 
-struct t_obj_info 
-{
+struct t_obj_info {
 	int32_t object;
 	uint32_t flags;
 	float trans_x,trans_y,trans_z;
 	float rot_x,rot_y,rot_z;
 	float scale;
 	float r;
-	char name[NAME_MAX]; 
+	char name[NAME_MAX];
 };
 enum {
 	zero,

Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/graphics.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * graphics.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -50,38 +50,42 @@
 int graphics_init ()
 {
 	GLfloat shin[]={16.0};
-	switch (frame_mode)
-	{
+	switch (frame_mode) {
 #ifdef G_SDL
-		case FRAME_SDL:graphics_init_sdl();break;
+	case FRAME_SDL:
+		graphics_init_sdl();
+		break;
 #endif
 #ifdef G_GLUT
-		case FRAME_GLUT:graphics_init_glut();break;
+	case FRAME_GLUT:
+		graphics_init_glut();
+		break;
 #endif
-		default: return(-1);
+	default:
+		return(-1);
 	}
 	/* light */
 	glEnable(GL_LIGHTING);
 	glEnable(GL_LIGHT0);
-	
+
 	/* depth test */
 	glEnable(GL_DEPTH_TEST);
-/*     glDepthFunc( GL_LEQUAL ); */
-	
+	/*     glDepthFunc( GL_LEQUAL ); */
+
 	/* textures */
-    glEnable(GL_TEXTURE_2D);
-    glShadeModel (GL_SMOOTH);
+	glEnable(GL_TEXTURE_2D);
+	glShadeModel (GL_SMOOTH);
 	glDisable(GL_DITHER);
 
 	/* lines */
-    glHint(GL_LINE_SMOOTH_HINT, GL_FASTEST); 
-    glLineWidth(1.0);
-    glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
-	
+	glHint(GL_LINE_SMOOTH_HINT, GL_FASTEST);
+	glLineWidth(1.0);
+	glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
+
 	/* polygon smoothing */
 	glDisable(GL_POLYGON_SMOOTH);
-/*    glEnable(GL_POLYGON_SMOOTH); 
-    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST); */
+	/*    glEnable(GL_POLYGON_SMOOTH);
+	    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST); */
 
 	/* normalizing */
 	glDisable(GL_AUTO_NORMAL);
@@ -89,12 +93,12 @@
 	glEnable(GL_RESCALE_NORMAL);
 
 	/* blending */
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-/*    glBlendFunc(GL_SRC_ALPHA_SATURATE, GL_ONE);*/
+	glEnable(GL_BLEND);
+	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	/*    glBlendFunc(GL_SRC_ALPHA_SATURATE, GL_ONE);*/
 
 	/* set shininess */
-/* 	glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS,shin); */
+	/* 	glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS,shin); */
 	glMaterialfv(GL_FRONT,GL_SHININESS,shin);
 	graphics_reshape(X_RES,Y_RES);
 
@@ -117,7 +121,7 @@
 		glFrustum(-1.0,1.0,-(1.0*h)/w,(1.0*h)/w,1.0,5000);
 	glMatrixMode(GL_MODELVIEW);
 	if (procs_p!=NULL)
-	event_cam_changed();
+		event_cam_changed();
 }
 void render_virtual_object(struct t_obj *o)
 {
@@ -130,30 +134,26 @@
 	glMultMatrixf(o->m);
 	glGetFloatv(GL_MODELVIEW_MATRIX,m);
 	cull_get_planes();
-	if (NULL==(ap=get_proc_by_pid(o->n_mat)))  /*  the clean way */
-	{
+	if (NULL==(ap=get_proc_by_pid(o->n_mat))) { /*  the clean way */
 		errds(HIGH,"render_by_mcp()","not existing pid (%d) referenced by mcp-object!!", o);
 	} else {
-	 /*  now go throu the objects of our app  */
-		for (j=0;j<ap->n_obj;j++)
-		{
-			if (ap->object[j]!=NULL)
-			{
-				if (((select_mode==0) && ap->object[j]->oflags&OF_VISIBLE) || ((select_mode ==1 ) && (ap->object[j]->oflags&OF_SELECTABLE))) /* either select mode is off or it's selectable */
-				{
+		/*  now go throu the objects of our app  */
+		for (j=0;j<ap->n_obj;j++) {
+			if (ap->object[j]!=NULL) {
+				if (((select_mode==0) && ap->object[j]->oflags&OF_VISIBLE) || ((select_mode ==1 ) && (ap->object[j]->oflags&OF_SELECTABLE))) { /* either select mode is off or it's selectable */
 					x.x=x.y=x.z=0.0f;
 					mySetMatrix(ap->object[j]->m); /* get into position ... */
 					myTransformV(&x);
-					y.x=1.0;y.y=y.z=0.0f;
+					y.x=1.0;
+					y.y=y.z=0.0f;
 					myTransformV(&y);
 					y.x-=x.x;
 					y.y-=x.y;
 					y.z-=x.z;
 
 					k=cull_sphere_in_frustum(&x,ap->object[j]->r * sqrt(y.x*y.x + y.y*y.y + y.z*y.z));
-					if (k)
-					{
-/*						s3dprintf(HIGH,"object %d is in %s frustum",j,k?"":"not");*/
+					if (k) {
+						/*						s3dprintf(HIGH,"object %d is in %s frustum",j,k?"":"not");*/
 						if (select_mode==1)
 							glPushName(j);
 						obj_render(ap,j);
@@ -175,22 +175,18 @@
 	struct t_obj *o;
 	struct t_vertex x,y;
 	int k;
-	for (i=0 ; i < p->n_obj ; i++)
-	{   /* check all mcp objects ... */
+	for (i=0 ; i < p->n_obj ; i++) {  /* check all mcp objects ... */
 		o=p->object[i];
-		if (o!=NULL)
-		{
-			if ((select_mode==0 && o->oflags&OF_VISIBLE) || (select_mode==1 && o->oflags&OF_SELECTABLE))  /*  it's even visible ;) */
-			{
-				if (o->oflags&OF_VIRTUAL)  /*  we have an app here. */
-				{
-					if (o->r!=0.0)
-					{
-						cull_get_planes(); 
+		if (o!=NULL) {
+			if ((select_mode==0 && o->oflags&OF_VISIBLE) || (select_mode==1 && o->oflags&OF_SELECTABLE)) { /*  it's even visible ;) */
+				if (o->oflags&OF_VIRTUAL) { /*  we have an app here. */
+					if (o->r!=0.0) {
+						cull_get_planes();
 						mySetMatrix(o->m);
 						x.x=x.y=x.z=0.0f;
 						myTransformV(&x);
-						y.x=1.0;y.y=y.z=0.0f;
+						y.x=1.0;
+						y.y=y.z=0.0f;
 						myTransformV(&y);
 						y.x-=x.x;
 						y.y-=x.y;
@@ -198,32 +194,27 @@
 
 						k=cull_sphere_in_frustum(&x,o->r * sqrt(y.x*y.x + y.y*y.y + y.z*y.z));
 						s3dprintf(VLOW,"mcp-object %d is in %s frustum",i,k?"":"not");
-						if (k)
-							{
-							if (select_mode==1)
-							{
+						if (k) {
+							if (select_mode==1) {
 								s3dprintf(VLOW,"object %d in culling frustrum!",i);
 								glLoadName(i);
 							}
 							render_virtual_object(o);
 						} else {
-							if (select_mode==1)
-							{
+							if (select_mode==1) {
 								s3dprintf(VLOW,"object %d not in culling frustrum!",i);
 							}
 						}
 					}
-				} else if ((o->oflags&OF_CLONE) && (p->object[o->n_vertex]->oflags&OF_VIRTUAL))  /* it's a clone of an app */
-				{
+				} else if ((o->oflags&OF_CLONE) && (p->object[o->n_vertex]->oflags&OF_VIRTUAL)) { /* it's a clone of an app */
 					if (select_mode==1)
 						glLoadName(o->n_vertex);/*TODO: what to do if a clone is selected?! */
 					glPushMatrix();
 					render_virtual_object(o);
-					render_virtual_object(p->object[o->n_vertex]); 
+					render_virtual_object(p->object[o->n_vertex]);
 					glPopMatrix();
 				} else { /* it's a "regular" mcp object */
-					if (select_mode==1)
-					{
+					if (select_mode==1) {
 						s3dprintf(VLOW,"mcp object no. %d",i);
 						glLoadName(-1);
 						glPushName(i);
@@ -237,9 +228,9 @@
 	}
 	return(0);
 }
- /* this picks objects from their screen-positions and sends
-  * OBK_CLICK-events for the selected object(s).
-  * TODO: how big should the select buffer be? */
+/* this picks objects from their screen-positions and sends
+ * OBK_CLICK-events for the selected object(s).
+ * TODO: how big should the select buffer be? */
 #define SBSIZE	65536
 int graphics_pick_obj(int x, int y)
 {
@@ -257,12 +248,11 @@
 	glSelectBuffer(SBSIZE,select_buf);
 	glRenderMode(GL_SELECT);
 	glMatrixMode(GL_PROJECTION);
-	 /*  count the objects .... */
+	/*  count the objects .... */
 	glPushMatrix();
 	glLoadIdentity();
 	glGetIntegerv(GL_VIEWPORT, viewport);
-	if (winw>winh)
-	{
+	if (winw>winh) {
 		xpos=((x-winw/2.0)/(winw/2.0))*(((double)winw/winh));
 		ypos=(((winh-y)-winh/2.0)/(winh/2.0));
 	} else {
@@ -277,62 +267,61 @@
 	myInvert();
 	myGetMatrix(m);
 	glMultMatrixf(m);
-/*
-	glRotatef(-cam.rotate.x, 1.0,0.0,0.0);
-	glRotatef(-cam.rotate.y, 0.0,1.0,0.0);
-	glTranslatef(-cam.translate.x,-cam.translate.y,-cam.translate.z);*/
+	/*
+		glRotatef(-cam.rotate.x, 1.0,0.0,0.0);
+		glRotatef(-cam.rotate.y, 0.0,1.0,0.0);
+		glTranslatef(-cam.translate.x,-cam.translate.y,-cam.translate.z);*/
 
 	glInitNames();
 	glPushName(0);
 	render_by_mcp();
 	glFlush();
 	hits=glRenderMode(GL_RENDER);
-	if ( hits > 0 )
-	{
+	if ( hits > 0 ) {
 		big=INFINITY;
 		s3dprintf(LOW,"had %d hits",hits);
 		ptr=select_buf;
 		mcp_o= o= names= -1;
 		/* check all the hits, only select the nearest ... */
-		for (i=0 ; i < hits ; i++)
-		{
-			names=*ptr;						ptr++;
-			z1=(float)*ptr/0x7fffffff;		ptr++;
-			z2=(float)*ptr/0x7fffffff;		ptr++;
-			if (z1<big)
-			{
+		for (i=0 ; i < hits ; i++) {
+			names=*ptr;
+			ptr++;
+			z1=(float)*ptr/0x7fffffff;
+			ptr++;
+			z2=(float)*ptr/0x7fffffff;
+			ptr++;
+			if (z1<big) {
 				mcp_o=o=-1;
-				for (j=0;j<names;j++)
-				{
-					switch (j)
-					{
-						case 0:mcp_o=	*ptr;break;
-						case 1:o=		*ptr;break;
+				for (j=0;j<names;j++) {
+					switch (j) {
+					case 0:
+						mcp_o=	*ptr;
+						break;
+					case 1:
+						o=		*ptr;
+						break;
 					}
 					ptr++;
 				}
 				big=z1;
-			} else 
+			} else
 				for (j=0;j<names;j++)
 					ptr++;
-		    s3dprintf(VLOW,"[HIT %d] names %d [z1:%f|z2:%f] mcp_o=%d, o=%d ",i,names, z1, z2, mcp_o, o);
+			s3dprintf(VLOW,"[HIT %d] names %d [z1:%f|z2:%f] mcp_o=%d, o=%d ",i,names, z1, z2, mcp_o, o);
 		}
 		s3dprintf(VLOW,"mcp_o= %d, o= %d",mcp_o,o);
 		ptr=select_buf;
-		if (mcp_o==-1) /* it's an mcp object */
-		{
+		if (mcp_o==-1) { /* it's an mcp object */
 			s3dprintf(LOW,"clicked on mcp-object no. %d",o);
 			event_obj_click(p,o);
-		} else 
-		if ((names>1) && ((mcp_o>=0)&&(mcp_o<p->n_obj)))
-		{ /* it's an usual object */
-			s3dprintf(LOW,"clicked on mcp-object %d, object %d",mcp_o,o);
-			if (p->object[mcp_o]!=NULL)  /*  that shouldn't happen anyways ... */
-			{
-				obj_debug(get_proc_by_pid(p->object[mcp_o]->n_mat),o); 
-				event_obj_click(get_proc_by_pid(p->object[mcp_o]->n_mat),o);
+		} else
+			if ((names>1) && ((mcp_o>=0)&&(mcp_o<p->n_obj))) { /* it's an usual object */
+				s3dprintf(LOW,"clicked on mcp-object %d, object %d",mcp_o,o);
+				if (p->object[mcp_o]!=NULL) { /*  that shouldn't happen anyways ... */
+					obj_debug(get_proc_by_pid(p->object[mcp_o]->n_mat),o);
+					event_obj_click(get_proc_by_pid(p->object[mcp_o]->n_mat),o);
+				}
 			}
- 	}
 	}
 	glMatrixMode(GL_PROJECTION);
 	glPopMatrix();
@@ -351,52 +340,52 @@
 	GLfloat light0_shininess[] ={1.0};
 	GLfloat light0_diff[]={0.5,0.5,0.5,1.0};
 	GLfloat light0_amb[]={1.0,1.0,1.0,1.0};
-	
+
 	select_mode=0;
 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  /*  clear screen */
-	 /*  set up the cam ... */
+	/*  set up the cam ... */
 	glMatrixMode(GL_MODELVIEW);
 
 	glLightfv(GL_LIGHT0,GL_AMBIENT,light0_amb);
 	glLightfv(GL_LIGHT0,GL_DIFFUSE,light0_diff);
 	glLightfv(GL_LIGHT0,GL_SPECULAR,light0_spec);
 	glLightfv(GL_LIGHT0,GL_SHININESS,light0_shininess);
-	
+
 	glLoadIdentity();
-	
+
 	mySetMatrix(p->object[0]->m);
 	myInvert();
 	myGetMatrix(m);
 	glMultMatrixf(m);
 	glLightfv(GL_LIGHT0,GL_POSITION,pos);
-	
+
 	/*glRotatef(-cam.rotate.z, 0.0,0.0,1.0);
 	glRotatef(-cam.rotate.x, 1.0,0.0,0.0);
 	glRotatef(-cam.rotate.y, 0.0,1.0,0.0);
 	glTranslatef(-cam.translate.x,-cam.translate.y,-cam.translate.z);*/
 
- 	glPushMatrix();  /*  save the cam */ 
-		render_by_mcp();
- 	glPopMatrix();  /*  restore the cam */ 
+	glPushMatrix();  /*  save the cam */
+	render_by_mcp();
+	glPopMatrix();  /*  restore the cam */
 	glLoadIdentity();
 	glMultMatrixf(m);
 
-	switch (frame_mode)
-	{
+	switch (frame_mode) {
 #ifdef G_GLUT
-		case FRAME_GLUT:
-				glFlush();
-				glutSwapBuffers();
-				break;
+	case FRAME_GLUT:
+		glFlush();
+		glutSwapBuffers();
+		break;
 #endif
 #ifdef G_SDL
-    	case FRAME_SDL:
-				/* SDL will glFlush itself */
-				SDL_GL_SwapBuffers(); 
-				break;
+	case FRAME_SDL:
+		/* SDL will glFlush itself */
+		SDL_GL_SwapBuffers();
+		break;
 #endif
 #ifdef G_GLX
-		case FRAME_GLX:...
+	case FRAME_GLX:
+		...
 #endif
 	}
 }

Modified: trunk/server/graphics_glut.c
===================================================================
--- trunk/server/graphics_glut.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/graphics_glut.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * graphics_glut.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -37,11 +37,11 @@
 	int argc=1;
 	char *argv[]={"s3d", NULL};
 	s3dprintf(MED,"Using GLUT for GL/windowing ...");
- 	glutInit(&argc, argv); 
+	glutInit(&argc, argv);
 	glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH | GLUT_RGBA);
 	glutInitWindowSize (X_RES, Y_RES);
 	glutCreateWindow("grmbl");
-    glutIdleFunc(one_time);
+	glutIdleFunc(one_time);
 	if (0!=(atexit(quit)))
 		s3dprintf(MED,"Error in setting Exit function ...");
 	glutDisplayFunc(graphics_main);
@@ -51,5 +51,5 @@
 /*  nothing to be done ... */
 int graphics_quit_glut()
 {
-	return(0);	
+	return(0);
 }

Modified: trunk/server/graphics_sdl.c
===================================================================
--- trunk/server/graphics_sdl.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/graphics_sdl.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * graphics_sdl.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -30,40 +30,37 @@
 int SDLFlags = 0;					 /*  some flags for SDL */
 int graphics_init_sdl()
 {
-    SDL_Surface *GLwin = NULL;
-    SDL_VideoInfo *VideoInfo;
-    int rgb_size[3]; 				 /*  for SDL_GL attributes */
-    int buffers, samples;
+	SDL_Surface *GLwin = NULL;
+	SDL_VideoInfo *VideoInfo;
+	int rgb_size[3]; 				 /*  for SDL_GL attributes */
+	int buffers, samples;
 	s3dprintf(MED,"Using SDL driver ...");
-	
-    SDLFlags = SDL_OPENGL | SDL_GL_DOUBLEBUFFER | SDL_HWPALETTE | SDL_RESIZABLE;
-    if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) < 0)  		
-			errsf("SDL_Init()",SDL_GetError());
-    if ((VideoInfo = (SDL_VideoInfo *)SDL_GetVideoInfo())==NULL)
-			errs("SDL_GetVIdeoInfo()",SDL_GetError());
-    if(VideoInfo -> hw_available) 
-	{
+
+	SDLFlags = SDL_OPENGL | SDL_GL_DOUBLEBUFFER | SDL_HWPALETTE | SDL_RESIZABLE;
+	if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) < 0)
+		errsf("SDL_Init()",SDL_GetError());
+	if ((VideoInfo = (SDL_VideoInfo *)SDL_GetVideoInfo())==NULL)
+		errs("SDL_GetVIdeoInfo()",SDL_GetError());
+	if (VideoInfo -> hw_available) {
 		s3dprintf(LOW,"detected HW_SURFACE");
 		SDLFlags |= SDL_HWSURFACE;
-	}
-	else
-	{
+	} else {
 		s3dprintf(LOW,"detected SW_SURFACE");
 		SDLFlags |= SDL_SWSURFACE;
 	}
-    if(VideoInfo -> blit_hw)  	
+	if (VideoInfo -> blit_hw)
 		SDLFlags |= SDL_HWACCEL;
-/*     if(SDL_WM_ToggleFullScreen(GLwin) == 0)        	SDLerror("SDL_WM_ToggleFullScreen"); */
+	/*     if(SDL_WM_ToggleFullScreen(GLwin) == 0)        	SDLerror("SDL_WM_ToggleFullScreen"); */
 
 
-	 /*  set some opengl-attributes */
-/*	SDL_GL_SetAttribute( SDL_GL_RED_SIZE, rgb_size[0] );
-	SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, rgb_size[1] );
-	SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, rgb_size[2] );*/
-/* 	SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5); */
-/* 	SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 5); */
-/* 	SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5); */
-/* 	SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 ); */
+	/*  set some opengl-attributes */
+	/*	SDL_GL_SetAttribute( SDL_GL_RED_SIZE, rgb_size[0] );
+		SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, rgb_size[1] );
+		SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, rgb_size[2] );*/
+	/* 	SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5); */
+	/* 	SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 5); */
+	/* 	SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5); */
+	/* 	SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 ); */
 	SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
 	do {
 		if (aa_level>0) {
@@ -71,9 +68,8 @@
 			if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, aa_level ))	s3dprintf(VHIGH,"no multisampling available");
 		}
 
-		 /*  more opengl-init-stuff */
-		if ((GLwin = SDL_SetVideoMode(X_RES,Y_RES,16,SDLFlags))==NULL) 
-		{
+		/*  more opengl-init-stuff */
+		if ((GLwin = SDL_SetVideoMode(X_RES,Y_RES,16,SDLFlags))==NULL) {
 			if (aa_level>0) {
 				s3dprintf(MED,"retry without multisampling");
 				aa_level=0;
@@ -84,27 +80,36 @@
 		}
 	} while (GLwin==0);
 	switch (SDL_GetVideoInfo()->vfmt->BitsPerPixel) {
-	    case 8:
-				rgb_size[0] = 3;	rgb_size[1] = 3;	rgb_size[2] = 2;	break;
-	    case 15:
-	    case 16:
-				rgb_size[0] = 5;	rgb_size[1] = 5;	rgb_size[2] = 5;	break;
-            default:
-				rgb_size[0] = 8;	rgb_size[1] = 8;	rgb_size[2] = 8;	break;
+	case 8:
+		rgb_size[0] = 3;
+		rgb_size[1] = 3;
+		rgb_size[2] = 2;
+		break;
+	case 15:
+	case 16:
+		rgb_size[0] = 5;
+		rgb_size[1] = 5;
+		rgb_size[2] = 5;
+		break;
+	default:
+		rgb_size[0] = 8;
+		rgb_size[1] = 8;
+		rgb_size[2] = 8;
+		break;
 	}
 	if (aa_level >0) {
-	    SDL_GL_GetAttribute( SDL_GL_MULTISAMPLEBUFFERS, &buffers );
-	    SDL_GL_GetAttribute( SDL_GL_MULTISAMPLESAMPLES, &samples );
-	    s3dprintf(LOW,"Buffers: %d Samples: %d", buffers, samples);
+		SDL_GL_GetAttribute( SDL_GL_MULTISAMPLEBUFFERS, &buffers );
+		SDL_GL_GetAttribute( SDL_GL_MULTISAMPLESAMPLES, &samples );
+		s3dprintf(LOW,"Buffers: %d Samples: %d", buffers, samples);
 	}
 
-	 /*  print some information */
+	/*  print some information */
 	s3dprintf(VLOW,"Screen BPP: %d", SDL_GetVideoSurface()->format->BitsPerPixel);
 	s3dprintf(VLOW,"Vendor     : %s", glGetString( GL_VENDOR ) );
 	s3dprintf(VLOW,"Renderer   : %s", glGetString( GL_RENDERER ) );
 	s3dprintf(VLOW,"Version    : %s", glGetString( GL_VERSION ) );
 	s3dprintf(VLOW,"Extensions : %s", glGetString( GL_EXTENSIONS ) );
-	
+
 	graphics_reshape(X_RES,Y_RES);
 	return(0);
 }

Modified: trunk/server/main.c
===================================================================
--- trunk/server/main.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/main.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * main.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -58,10 +58,9 @@
 }
 void sigchld_handler(int S3DUNUSED(sig))
 {
-	if (kidpid!=0)
-	{
+	if (kidpid!=0) {
 		kidpid=0;
-	    s3dprintf(HIGH,"how cruel, my kid died!!");
+		s3dprintf(HIGH,"how cruel, my kid died!!");
 		quit();
 	}
 }
@@ -76,39 +75,35 @@
 {
 #ifdef SIGS
 	int ret,i;
-	struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+	struct timespec t= {
+		0,10*1000*1000
+	}; /* 10 mili seconds */
 	kidpid=fork();
-	if (kidpid==-1)
-	{
+	if (kidpid==-1) {
 		errsf("rc_init()","*sobsob*, can't fork");
 		exit(1);
 	}
-	if (kidpid==0)
-	{
-	    if (signal(SIGUSR1, sigusr_handler) == SIG_ERR) 
-		        errn("init():signal()",errno);
+	if (kidpid==0) {
+		if (signal(SIGUSR1, sigusr_handler) == SIG_ERR)
+			errn("init():signal()",errno);
 
 		/* giving the father lots of time to set his signal handler
 		 * and all his sockets up */
-		while (!running)  
-			nanosleep(&t,NULL); 	
-		for (i=0 ; i < ((int)(sizeof(s3drc)/sizeof(char **))) ; i++)
-		{
-			if ((*s3drc[i])!=NULL)
-			{
+		while (!running)
+			nanosleep(&t,NULL);
+		for (i=0 ; i < ((int)(sizeof(s3drc)/sizeof(char **))) ; i++) {
+			if ((*s3drc[i])!=NULL) {
 				s3dprintf(LOW,"[RC] launching %s",*s3drc[i]);
 				ret=system(*s3drc[i]);
 				s3dprintf(VLOW,"[RC] system() said %d",ret);
-				if (ret<128) 
-				{
+				if (ret<128) {
 					s3dprintf(LOW,"V[RC] system() did well, I guess. let's die clean now.");
 					exit(0);
 				}
-			} 
+			}
 		}
 		errs("rc_init()", "no usuable rc script found.");
-		if (rc==NULL)
-		{
+		if (rc==NULL) {
 			errs("rc_init()","You don't have an rc-script? Think about creating one (~/.s3drc), its handy :)");
 			errs("rc_init()","Starting anyway ...");
 			while (1) sleep(1);
@@ -121,15 +116,14 @@
 		if (signal(SIGCHLD, sigchld_handler) == SIG_ERR) {
 		}
 		/* father just returns */
-	}	
+	}
 #endif
 	return(0);
 }
 /*  the mainloop, should be handling all signals */
-static void mainloop(void) 
+static void mainloop(void)
 {
-	while (running)
-	{
+	while (running) {
 		one_time();
 	}
 }
@@ -137,16 +131,18 @@
 /*  things which should be done each time in main loop go here! this is */
 /*  just for the case we use a function for the mainloop like we do for glut... */
 
-struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-void one_time() 
+struct timespec t= {
+	0,10*1000*1000
+}; /* 10 mili seconds */
+void one_time()
 {
-	nanosleep(&t,NULL); 
+	nanosleep(&t,NULL);
 	user_main();
-	network_main(); 
+	network_main();
 	graphics_main();
 }
 /*  this initalizes all components.  */
-int init() 
+int init()
 {
 #ifdef	__APPLE__
 	NSApplicationLoad();
@@ -157,8 +153,7 @@
 #else
 	s3dprintf(VHIGH,"rc-files won't work without signals :(");
 #endif
-	if (!frame_mode)  /*  turn default frame_mode on */
-	{
+	if (!frame_mode) { /*  turn default frame_mode on */
 #ifdef G_SDL
 		frame_mode=FRAME_SDL;
 #else
@@ -167,8 +162,7 @@
 #endif
 #endif
 	}
-	if (!frame_mode)
-	{
+	if (!frame_mode) {
 		errsf("init()","no framework mode available");
 		return(-1);
 	}
@@ -178,10 +172,10 @@
 	process_init();
 	running=1;
 #ifdef SIGS
-    if (signal(SIGINT, sigint_handler) == SIG_ERR) 
-	        errn("init():signal()",errno);
-    if (signal(SIGTERM, sigint_handler) == SIG_ERR) 
-	        errn("init():signal()",errno);
+	if (signal(SIGINT, sigint_handler) == SIG_ERR)
+		errn("init():signal()",errno);
+	if (signal(SIGTERM, sigint_handler) == SIG_ERR)
+		errn("init():signal()",errno);
 	if (kidpid!=0)
 		kill(kidpid, SIGUSR1);
 #endif
@@ -191,14 +185,12 @@
 /*  things to be cleaned up  */
 void quit()
 {
-	if (running!=0)
-	{
+	if (running!=0) {
 		user_quit();
 		network_quit();
 		graphics_quit();
 		process_quit();
-		if (kidpid!=0)
-		{ /* our kid is most probably still alive. kill it!! */
+		if (kidpid!=0) { /* our kid is most probably still alive. kill it!! */
 			s3dprintf(HIGH,"kill all the kids!!");
 			kill(kidpid,SIGTERM);
 			kidpid=0;
@@ -213,82 +205,77 @@
 {
 	int					 lopt_idx;
 	char				 c;
-	struct option long_options[] = 
-	{
-		{"multisample",		1,0,'m'},
-		{"rc",				1,0,'r'},
-		{"help",			0,0,'h'},
-		{"use-glut",		0,0,'g'},
-		{"use-sdl",			0,0,'s'},
-		{"no-rc",			0,0,'n'},
-		{0,0,0,0}
+	struct option long_options[] = {
+		{"multisample",		1,0,'m'
+		}, {"rc",				1,0,'r'}, {"help",			0,0,'h'}, {"use-glut",		0,0,'g'}, {"use-sdl",			0,0,'s'}, {"no-rc",			0,0,'n'}, {0,0,0,0}
 	};
-	while (-1!=(c=getopt_long(argc,argv,"?hgsnr:m:",long_options,&lopt_idx)))
-	{
-		switch (c)
-		{
-				case 0:break;
-				case 'g':
+	while (-1!=(c=getopt_long(argc,argv,"?hgsnr:m:",long_options,&lopt_idx))) {
+		switch (c) {
+		case 0:
+			break;
+		case 'g':
 #ifdef G_GLUT
-					frame_mode=FRAME_GLUT;
+			frame_mode=FRAME_GLUT;
 #else
-					errsf("process_args()","sorry, GLUT is not available");
+			errsf("process_args()","sorry, GLUT is not available");
 #endif
-					break;
-				case 's':
+			break;
+		case 's':
 #ifdef G_SDL
-					frame_mode=FRAME_SDL;
+			frame_mode=FRAME_SDL;
 #else
-					errsf("process_args()","sorry, SDL is not available");
-#endif					
-					break;
-				case 'r':
-					s3dprintf(VHIGH,"using rc file: %s",optarg);
-					rc=optarg;
-					break;
-				case 'm':
-					aa_level=atoi(optarg);
-					if (aa_level>=0 || aa_level<=16)
-						s3dprintf(VHIGH,"aa_level: %d",aa_level);
-					else
-						errsf("process_args()","bad multisampling level");
-					break;
-				case 'n':
-					s3dprintf(VHIGH,"Using no rc file!");
-					norc=1;
-					break;
+			errsf("process_args()","sorry, SDL is not available");
+#endif
+			break;
+		case 'r':
+			s3dprintf(VHIGH,"using rc file: %s",optarg);
+			rc=optarg;
+			break;
+		case 'm':
+			aa_level=atoi(optarg);
+			if (aa_level>=0 || aa_level<=16)
+				s3dprintf(VHIGH,"aa_level: %d",aa_level);
+			else
+				errsf("process_args()","bad multisampling level");
+			break;
+		case 'n':
+			s3dprintf(VHIGH,"Using no rc file!");
+			norc=1;
+			break;
 
-				case '?':
-				case 'h':
-					s3dprintf(VHIGH,"usage: %s [options]",argv[0]);
-					s3dprintf(VHIGH,"s3d, the 3d server:");
-					s3dprintf(VHIGH," --multisample, -m:\tSpecify Multisampling level (antialiasing) if available.\n\t\t(value 1-16, default 4, 0 = off),");
-					s3dprintf(VHIGH," --rc, -r:\tspecify a rc (startup script)");
-					s3dprintf(VHIGH," --no-rc, -n:\tdon't use a rc file (useful for debugging mcp's)");
+		case '?':
+		case 'h':
+			s3dprintf(VHIGH,"usage: %s [options]",argv[0]);
+			s3dprintf(VHIGH,"s3d, the 3d server:");
+			s3dprintf(VHIGH," --multisample, -m:\tSpecify Multisampling level (antialiasing) if available.\n\t\t(value 1-16, default 4, 0 = off),");
+			s3dprintf(VHIGH," --rc, -r:\tspecify a rc (startup script)");
+			s3dprintf(VHIGH," --no-rc, -n:\tdon't use a rc file (useful for debugging mcp's)");
 #ifdef G_GLUT
-					s3dprintf(VHIGH," --use-glut, -g:\tuse GLUT as framework-system");
+			s3dprintf(VHIGH," --use-glut, -g:\tuse GLUT as framework-system");
 #endif
 #ifdef G_SDL
-					s3dprintf(VHIGH," --use-sdl, -s:\tuse SDL as framework-system");
+			s3dprintf(VHIGH," --use-sdl, -s:\tuse SDL as framework-system");
 #endif
-					s3dprintf(VHIGH," --help, -?, -h: this helpful text");
-					errsf("process_args()","exiting for users sake");
-					return(-1);
+			s3dprintf(VHIGH," --help, -?, -h: this helpful text");
+			errsf("process_args()","exiting for users sake");
+			return(-1);
 		}
 	}
 	return(0);
 }
 /*  things to be done when program is started */
-int main(int argc, char **argv) {
+int main(int argc, char **argv)
+{
 	process_args(argc,argv);
 	init();
-	switch (frame_mode)
-	{
+	switch (frame_mode) {
 #ifdef G_GLUT
-		case FRAME_GLUT:glutMainLoop();
-				break;
+	case FRAME_GLUT:
+		glutMainLoop();
+		break;
 #endif
-		default:mainloop();
+	default:
+		mainloop();
 	}
 	quit();
 	return(0);

Modified: trunk/server/matrix.c
===================================================================
--- trunk/server/matrix.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/matrix.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
- * matrix.c 
- * 
+ * matrix.c
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -29,10 +29,10 @@
 #define DEG2RAD (M_PI/180.0)
 static t_mtrx MAT;
 t_mtrx Identity = {
-   1.0, 0.0, 0.0, 0.0,
-   0.0, 1.0, 0.0, 0.0,
-   0.0, 0.0, 1.0, 0.0,
-   0.0, 0.0, 0.0, 1.0
+	1.0, 0.0, 0.0, 0.0,
+	0.0, 1.0, 0.0, 0.0,
+	0.0, 0.0, 1.0, 0.0,
+	0.0, 0.0, 0.0, 1.0
 };
 void myLoadIdentity()
 {
@@ -52,8 +52,7 @@
 	int i,j,k;
 	t_mtrx mat_d;  /*  destination matrix */
 	for (i=0;i<4;i++)
-		for (j=0;j<4;j++)
-		{
+		for (j=0;j<4;j++) {
 			mat_d[I(i,j)]=0.0F;
 			for (k=0;k<4;k++)
 				mat_d[I(i,j)]+=M(k,j)*mat2[I(i,k)];
@@ -107,18 +106,17 @@
 	memcpy(Mm,MAT,sizeof(t_mtrx));			/* backup matrix */
 	memcpy(Pm,Identity,sizeof(t_mtrx));		/* target */
 
-/*	s3dprintf(MED,"start:");
-	mat_debug(MAT);*/
+	/*	s3dprintf(MED,"start:");
+		mat_debug(MAT);*/
 
-/*	s3dprintf(LOW,"inverting matrix, we shall begin now ...");*/
+	/*	s3dprintf(LOW,"inverting matrix, we shall begin now ...");*/
 
 	/* step 1 */
-	for (l=0;l<4;l++)
-	{
-check:	if (M(l,l)*M(l,l)>0.00000001F) /* it won't work with real zero */
-		{
-			
-/*			s3dprintf(MED,"normalizing line %d",l);*/
+	for (l=0;l<4;l++) {
+check:
+		if (M(l,l)*M(l,l)>0.00000001F) { /* it won't work with real zero */
+
+			/*			s3dprintf(MED,"normalizing line %d",l);*/
 			/* normalize */
 			f=1/M(l,l);
 			M(l,l)=1.0;
@@ -126,15 +124,13 @@
 				M(i,l)*=f; /* the left side ... */
 			for (i=0;i<4;i++)
 				P(i,l)*=f; /* ... and the right */
-/*			mat_debug(Mm);
-			s3dprintf(MED,"-");
-			mat_debug(Pm);*/
+			/*			mat_debug(Mm);
+						s3dprintf(MED,"-");
+						mat_debug(Pm);*/
 			/* mult/fac */
-			for (lh=l+1;lh<4;lh++)
-			{
-			/*	s3dprintf(MED,"adding line %d for %d",lh,l);*/
-				if (M(l,lh)!=0) /* "first" element of the line */
-				{
+			for (lh=l+1;lh<4;lh++) {
+				/*	s3dprintf(MED,"adding line %d for %d",lh,l);*/
+				if (M(l,lh)!=0) { /* "first" element of the line */
 					f=-M(l,lh);
 					M(l,lh)=0.0; /* yes, this WILL be zero! ... */
 					for (i=l+1;i<4;i++) /* left side */
@@ -145,13 +141,11 @@
 			}
 		} else {
 			M(l,l)=0.0F;
-/*			s3dprintf(MED,"already zero now check and try to swap lines ...");*/
+			/*			s3dprintf(MED,"already zero now check and try to swap lines ...");*/
 			for (lh=l+1;lh<4;lh++)
-				if (M(l,lh)!=0.0)
-				{
-/*					s3dprintf(MED,"swapping lines %d and %d",l,lh);*/
-					for (i=0;i<4;i++)
-					{
+				if (M(l,lh)!=0.0) {
+					/*					s3dprintf(MED,"swapping lines %d and %d",l,lh);*/
+					for (i=0;i<4;i++) {
 						f=M(i,l);
 						M(i,l)=M(i,lh);
 						M(i,lh)=f;
@@ -172,35 +166,31 @@
 	 * (01??|????)
 	 * (001?|????)
 	 * (0001|????)
-	 * 
+	 *
 	 *  (M = left side, P = right side)
 	 * */
 
 	/* step 2 */
-/*	s3dprintf(MED,"S.T.E.P. 2!!");*/
-	for (l=3;l>0;l--)
-	{
+	/*	s3dprintf(MED,"S.T.E.P. 2!!");*/
+	for (l=3;l>0;l--) {
 		/* mult/fac */
-		for (lh=l-1;lh>=0;lh--)
-		{
-/*			s3dprintf(MED,"adding line %d for %d",lh,l);*/
-			if (M(l,lh)!=0) /* "first" element of the line */
-			{
+		for (lh=l-1;lh>=0;lh--) {
+			/*			s3dprintf(MED,"adding line %d for %d",lh,l);*/
+			if (M(l,lh)!=0) { /* "first" element of the line */
 				f=-M(l,lh);
-				M(l,lh)=0; 
-				for (i=0;i<4;i++)	/* ... and the right one! */
-				{
+				M(l,lh)=0;
+				for (i=0;i<4;i++) {	/* ... and the right one! */
 					P(i,lh)+=f*P(i,l);
 				}
 
 			}
-/*			mat_debug(Mm);
-			mat_debug(Pm);*/
+			/*			mat_debug(Mm);
+						mat_debug(Pm);*/
 		}
 	}
 	/* now, Mm,is Identity and Pm is result!*/
-/*	s3dprintf(MED,"result:");
-	mat_debug(Pm);*/
+	/*	s3dprintf(MED,"result:");
+		mat_debug(Pm);*/
 	memcpy(MAT,Pm,sizeof(t_mtrx)); /* copy result */
 	return(0);
 }

Modified: trunk/server/mcp.c
===================================================================
--- trunk/server/mcp.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/mcp.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * mcp.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -25,9 +25,9 @@
 #include "global.h"
 #include "proto.h" 			 /*  for S3D_P_OBJECT, to be integrated in proto.c */
 #ifdef WIN32
-	#include <winsock2.h>
+#include <winsock2.h>
 #else
-	#include <netinet/in.h> 	 /*  htonl() */
+#include <netinet/in.h> 	 /*  htonl() */
 #endif
 #include <string.h>			 /*  strncpy() */
 
@@ -35,13 +35,12 @@
 extern int 		   focus_oid;		 /*  the focused program */
 
 /*  this interacts with the actual mcp client */
-struct mcp_object 
-{
+struct mcp_object {
 	uint32_t object;
 	float trans_x,trans_y,trans_z;
 	float r;
-/* 	char event; */
-	char name[NAME_MAX]; 
+	/* 	char event; */
+	char name[NAME_MAX];
 };
 #define MCP_NEW_OBJECT	1
 /*  call when a new mcp connects */
@@ -51,18 +50,16 @@
 	uint32_t i;
 	p=get_proc_by_pid(MCP);
 	i=p->n_obj;
-	while (i--)
-	{
+	while (i--) {
 		if (p->object[i]!=NULL)
-		switch (p->object[i]->oflags&OF_TYPE)
-		{
+			switch (p->object[i]->oflags&OF_TYPE) {
 			case OF_VIRTUAL:
-					mcp_rep_object(i);
-					break;
+				mcp_rep_object(i);
+				break;
 			case OF_CAM:
-					event_obj_info(p,i);
-					break;
-		}
+				event_obj_info(p,i);
+				break;
+			}
 	}
 	mcp_focus(-1);
 	return(0);
@@ -78,7 +75,7 @@
 	mo.trans_y=p->object[mcp_oid]->translate.y;
 	mo.trans_z=p->object[mcp_oid]->translate.z;
 	mo.r=p->object[mcp_oid]->r;
-/* 	mo.event=MCP_NEW_OBJECT; */
+	/* 	mo.event=MCP_NEW_OBJECT; */
 	ap=get_proc_by_pid(p->object[mcp_oid]->n_mat);
 	strncpy(mo.name,ap->name,NAME_MAX);
 	prot_com_out(p,S3D_P_MCP_OBJECT,(uint8_t *)&mo,sizeof(struct mcp_object));
@@ -88,8 +85,7 @@
 int mcp_del_object(int32_t mcp_oid)
 {
 	int32_t oid=htonl(mcp_oid);
-	if (mcp_oid==focus_oid)
-	{
+	if (mcp_oid==focus_oid) {
 		s3dprintf(MED,"lost the focus of mcp-oid %d",mcp_oid);
 		mcp_focus(-1);
 	}
@@ -105,8 +101,7 @@
 	p=get_proc_by_pid(MCP);
 	s3dprintf(MED,"request to focus %d",oid);
 	if (OBJ_VALID(p,oid,o))
-		if (o->oflags&OF_VIRTUAL)
-		{
+		if (o->oflags&OF_VIRTUAL) {
 			focus_oid=oid;
 			obj_pos_update(p,0,0);
 		}

Modified: trunk/server/navigation.c
===================================================================
--- trunk/server/navigation.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/navigation.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * navigation.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -43,7 +43,7 @@
 {
 	navi_pos(0,-1);
 }
-/* simple movements, not needed currently 
+/* simple movements, not needed currently
 void navi_rot_right()
 {
 	cam.rotate.y=cam.rotate.y+2;
@@ -99,8 +99,7 @@
 	float tv[3],rv[3],xf,yf;
 	struct t_process *p;
 	int ptr;
-	if (winw>winh)
-	{
+	if (winw>winh) {
 		xf=winw/(float)winh;
 		yf=1;
 	} else {
@@ -114,9 +113,8 @@
 	rv[1]=1.5*180/M_PI*-atan(tv[0]/2);
 	rv[2]=0;
 	p=get_proc_by_pid(MCP);
-	if (-1!=(ptr=get_pointer(p)))
-	{
-		obj_translate(p,ptr,tv);	
-		obj_rotate(p,ptr,rv);	
+	if (-1!=(ptr=get_pointer(p))) {
+		obj_translate(p,ptr,tv);
+		obj_rotate(p,ptr,rv);
 	}
 }

Modified: trunk/server/network.c
===================================================================
--- trunk/server/network.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/network.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * network.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -32,7 +32,7 @@
 #include <SDL.h>	/* SDL_SetTimer() */
 #endif
 #ifdef SIGS
-  #include <signal.h>	 /*  sighandler_t SIG_PIPE */
+#include <signal.h>	 /*  sighandler_t SIG_PIPE */
 #endif
 /*  here go all the network functions */
 /*  */
@@ -45,10 +45,10 @@
 uint8_t obuf[MAXPLEN]; /* output buffer */
 #ifdef SIGS
 int sigio=0;
-#endif 
+#endif
 
 #ifdef SIGS
-void sigpipe_handler(int S3DUNUSED(unused))  
+void sigpipe_handler(int S3DUNUSED(unused))
 {
 	errs("sigpip_handler()","there is a broken pipe somewhere");
 }
@@ -62,24 +62,24 @@
 int network_init()
 {
 #ifdef SIGS
-/*	struct sigaction act;*/
+	/*	struct sigaction act;*/
 #endif
 #ifdef TCP
-   tcp_init();
-#endif 
+	tcp_init();
+#endif
 #ifdef SHM
-   shm_init();
+	shm_init();
 #endif
-#ifdef SIGS			
-    if (signal(SIGPIPE, sigpipe_handler) == SIG_ERR) 
+#ifdef SIGS
+	if (signal(SIGPIPE, sigpipe_handler) == SIG_ERR)
 		errn("network_init():signal()",errno);
-/*	act.sa_handler = (sig_t)sigio_handler;
-	if ( sigaction(SIGIO, &act, 0) < 0 )
-		errn("network_init():sigaction()",errno);*/
-     if (signal(SIGIO, sigio_handler) == SIG_ERR)  
- 		errn("s3d_init():signal()",errno); 
+	/*	act.sa_handler = (sig_t)sigio_handler;
+		if ( sigaction(SIGIO, &act, 0) < 0 )
+			errn("network_init():sigaction()",errno);*/
+	if (signal(SIGIO, sigio_handler) == SIG_ERR)
+		errn("s3d_init():signal()",errno);
 #endif
-   return(0);
+	return(0);
 }
 int					 turn;
 int	net_turn_off(int S3DUNUSED(interval))
@@ -94,8 +94,7 @@
 {
 #ifdef TCP
 #ifdef SIGS
-	if (sigio==1)  /*  as long as there is no locking/threadsafety, do like this ... */
-	{
+	if (sigio==1) { /*  as long as there is no locking/threadsafety, do like this ... */
 #endif
 		tcp_pollport();	/*  this polls for new processes */
 #ifdef G_SDL
@@ -118,13 +117,16 @@
 }
 int n_remove(struct t_process *p)
 {
-	switch (p->con_type)
-	{
+	switch (p->con_type) {
 #ifdef SHM
-		case CON_SHM:		shm_remove(p); break;
+	case CON_SHM:
+		shm_remove(p);
+		break;
 #endif
 #ifdef TCP
-		case CON_TCP:		tcp_remove(p->sockid); break;
+	case CON_TCP:
+		tcp_remove(p->sockid);
+		break;
 #endif
 	}
 	p->con_type=CON_NULL;
@@ -133,26 +135,28 @@
 
 int n_readn(struct t_process *p, uint8_t *str, int s)
 {
-	switch (p->con_type)
-	{
+	switch (p->con_type) {
 #ifdef TCP
-		case CON_TCP:return(tcp_readn(p->sockid,str,s));
+	case CON_TCP:
+		return(tcp_readn(p->sockid,str,s));
 #endif
 #ifdef SHM
-		case CON_SHM:return(shm_readn((struct buf_t *)p->shmsock.data_ctos,str,s));
+	case CON_SHM:
+		return(shm_readn((struct buf_t *)p->shmsock.data_ctos,str,s));
 #endif
 	}
 	return(-1);
 }
 int n_writen(struct t_process *p, uint8_t *str, int s)
 {
-	switch (p->con_type)
-	{
+	switch (p->con_type) {
 #ifdef TCP
-		case CON_TCP:return(tcp_writen(p->sockid,str,s));
+	case CON_TCP:
+		return(tcp_writen(p->sockid,str,s));
 #endif
 #ifdef SHM
-		case CON_SHM:return(shm_writen((struct buf_t *)p->shmsock.data_stoc,str,s));
+	case CON_SHM:
+		return(shm_writen((struct buf_t *)p->shmsock.data_stoc,str,s));
 #endif
 	}
 	return(-1);
@@ -166,6 +170,6 @@
 #ifdef SHM
 	shm_quit();
 #endif
-	return(0);	
+	return(0);
 }
 

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/object.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * object.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -32,7 +32,7 @@
 #include <math.h>		 /*  sin(),cos() */
 
 #define MAXLOOP	10
-		 /*  if oid is always unsigned, we don't have to check oid>=0 */
+/*  if oid is always unsigned, we don't have to check oid>=0 */
 
 extern t_mtrx Identity;
 extern int focus_oid;
@@ -46,19 +46,15 @@
 {
 	struct t_obj *o;
 	s3dprintf(HIGH,"about pid %d/obj %d:",p->id,oid);
-	if (OBJ_VALID(p,oid,o))
-	{
+	if (OBJ_VALID(p,oid,o)) {
 		s3dprintf(HIGH,"vertices: %d, polygons: %d, materials: %d, textures: %d, flags: %010x",o->n_vertex,o->n_poly, o->n_mat, o->n_tex,o->oflags);
 		s3dprintf(HIGH,"linkid %d, displaylist %d",o->linkid,o->dplist);
 		s3dprintf(HIGH,"translation: %f %f %f",o->translate.x,o->translate.y,o->translate.z);
 		s3dprintf(HIGH,"rotation: %f %f %f",o->rotate.x,o->rotate.y,o->rotate.z);
 		s3dprintf(HIGH,"scale: %f",o->scale);
-		if (o->oflags&OF_SYSTEM)
-		{
+		if (o->oflags&OF_SYSTEM) {
 			s3dprintf(HIGH,"it's a system object!!");
-		}
-		else if (o->oflags&OF_CLONE)
-		{
+		} else if (o->oflags&OF_CLONE) {
 			s3dprintf(HIGH,"it's a clone linking to %d",o->n_vertex);
 			obj_debug(p,o->n_vertex);
 		}
@@ -77,58 +73,48 @@
 	float *px;
 	float r;
 	int is_clnsrc;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj->oflags&OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_push_vertex()","error: no data on object allowed!");
 			return(-1);
 		}
 
 		m=obj->n_vertex;	 /*  saving the first number of vertices */
 		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_vertex=realloc(obj->p_vertex,sizeof(struct t_vertex) * ( n + (obj->n_vertex)))))
-		{
-			if (obj->dplist)
-			{
+		if (NULL!=(p_vertex=realloc(obj->p_vertex,sizeof(struct t_vertex) * ( n + (obj->n_vertex))))) {
+			if (obj->dplist) {
 				s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 				glDeleteLists(obj->dplist,1);
 				obj->dplist=0;
 			}
 			obj->p_vertex=p_vertex;
-			for (i=0;i<n;i++)
-			{
+			for (i=0;i<n;i++) {
 				obj->p_vertex[m+i].x=*(px++);
 				obj->p_vertex[m+i].y=*(px++);
 				obj->p_vertex[m+i].z=*(px++);
 
 				a=&obj->p_vertex[m+i];
-				r=obj->scale * sqrt(	
-						(a->x * a->x ) + 
-						(a->y * a->y ) +
-						(a->z * a->z ));
+				r=obj->scale * sqrt(
+				          (a->x * a->x ) +
+				          (a->y * a->y ) +
+				          (a->z * a->z ));
 				if (r> obj->r) obj->r=r;
-/*				s3dprintf(VLOW,"added following vertex[%d]: %f, %f, %f",i,
-								obj->p_vertex[m+i].x,
-								obj->p_vertex[m+i].y,
-								obj->p_vertex[m+i].z);*/
+				/*				s3dprintf(VLOW,"added following vertex[%d]: %f, %f, %f",i,
+												obj->p_vertex[m+i].x,
+												obj->p_vertex[m+i].y,
+												obj->p_vertex[m+i].z);*/
 
 			}
-			if (p->id!=MCP)
-			{
-			/* this is doing live update which is quite okay, but we need
-			 * to check for biggest update and clonesources ... */
+			if (p->id!=MCP) {
+				/* this is doing live update which is quite okay, but we need
+				 * to check for biggest update and clonesources ... */
 				obj_check_biggest_object(p,oid);
 			}
-			if (p->object[oid]->oflags&OF_CLONE_SRC)
-			{
+			if (p->object[oid]->oflags&OF_CLONE_SRC) {
 				is_clnsrc=0;
-				for (i=0;i<p->n_obj;i++)
-				{
-					if (p->object[i]!=NULL)
-					{
-						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid))
-						{ /* if it's pointing to our object ... */
+				for (i=0;i<p->n_obj;i++) {
+					if (p->object[i]!=NULL) {
+						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid)) { /* if it's pointing to our object ... */
 							is_clnsrc=1;
 							p->object[i]->r=obj->r*(p->object[i]->r/obj->scale); /* give it the new radius too! */
 							obj_check_biggest_object(p,i);
@@ -141,8 +127,7 @@
 
 			obj->n_vertex+=n;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -155,26 +140,21 @@
 	struct t_mat *p_mat;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj->oflags&OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_push_mat()","error: no data on object allowed!");
 			return(-1);
 		}
 		m=obj->n_mat;	 /*  saving the first number of materials */
 		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_mat=realloc(obj->p_mat,sizeof(struct t_mat) * ( n + (obj->n_mat)))))
-		{
-			if (obj->dplist)
-			{
+		if (NULL!=(p_mat=realloc(obj->p_mat,sizeof(struct t_mat) * ( n + (obj->n_mat))))) {
+			if (obj->dplist) {
 				s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 				glDeleteLists(obj->dplist,1);
 				obj->dplist=0;
 			}
 			obj->p_mat=p_mat;
-			for (i=0;i<n;i++)
-			{
+			for (i=0;i<n;i++) {
 				obj->p_mat[m+i].amb_r=*(px++);
 				obj->p_mat[m+i].amb_g=*(px++);
 				obj->p_mat[m+i].amb_b=*(px++);
@@ -191,8 +171,7 @@
 			}
 			obj->n_mat+=n;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -205,27 +184,22 @@
 	struct t_poly *p_poly;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj->oflags&OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_push_poly()","error: no data on object allowed!");
 			return(-1);
 		}
 
 		m=obj->n_poly;	 /*  saving the first number of polys */
 		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_poly=realloc(obj->p_poly,sizeof(struct t_poly) * ( n + (obj->n_poly)))))
-		{
-			if (obj->dplist)
-			{
+		if (NULL!=(p_poly=realloc(obj->p_poly,sizeof(struct t_poly) * ( n + (obj->n_poly))))) {
+			if (obj->dplist) {
 				s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 				glDeleteLists(obj->dplist,1);
 				obj->dplist=0;
 			}
 			obj->p_poly=p_poly;
-			for (i=0;i<n;i++)
-			{
+			for (i=0;i<n;i++) {
 				obj->p_poly[m+i].v[0]=*(px++);
 				obj->p_poly[m+i].v[1]=*(px++);
 				obj->p_poly[m+i].v[2]=*(px++);
@@ -239,8 +213,7 @@
 			}
 			obj->n_poly+=n;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -252,27 +225,22 @@
 	struct t_line *p_line;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj->oflags&OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_push_line()","error: no data on object allowed!");
 			return(-1);
 		}
 
 		m=obj->n_line;	 /*  saving the first number of lines */
 		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_line=realloc(obj->p_line,sizeof(struct t_line) * ( n + (obj->n_line)))))
-		{
-			if (obj->dplist)
-			{
+		if (NULL!=(p_line=realloc(obj->p_line,sizeof(struct t_line) * ( n + (obj->n_line))))) {
+			if (obj->dplist) {
 				s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 				glDeleteLists(obj->dplist,1);
 				obj->dplist=0;
 			}
 			obj->p_line=p_line;
-			for (i=0;i<n;i++)
-			{
+			for (i=0;i<n;i++) {
 				obj->p_line[m+i].v[0]=*(px++);
 				obj->p_line[m+i].v[1]=*(px++);
 				obj->p_line[m+i].mat=*(px++);
@@ -281,8 +249,7 @@
 			}
 			obj->n_line+=n;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -296,31 +263,26 @@
 	struct t_tex *p_tex;
 	struct t_obj *obj;
 	uint16_t *px,hm;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj->oflags&OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_push_tex()","error: no data on object allowed!");
 			return(-1);
 		}
 		m=obj->n_tex;	     /*  saving the first number of textures */
 		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_tex=realloc(obj->p_tex,sizeof(struct t_tex) * ( n + (obj->n_tex)))))
-		{
-/*			if (obj->dplist)
-			{
-				s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-				glDeleteLists(obj->dplist,1);
-				obj->dplist=0;
-			}*/
+		if (NULL!=(p_tex=realloc(obj->p_tex,sizeof(struct t_tex) * ( n + (obj->n_tex))))) {
+			/*			if (obj->dplist)
+						{
+							s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
+							glDeleteLists(obj->dplist,1);
+							obj->dplist=0;
+						}*/
 			obj->p_tex=p_tex;
-			for (i=0;i<n;i++)
-			{
+			for (i=0;i<n;i++) {
 				obj->p_tex[m+i].gl_texnum=-1;
 				obj->p_tex[m+i].tw=*(px++);
 				obj->p_tex[m+i].th=*(px++);
-				if ((obj->p_tex[m+i].tw<=TEXTURE_MAX_W) && (obj->p_tex[m+i].th<=TEXTURE_MAX_H))
-				{
+				if ((obj->p_tex[m+i].tw<=TEXTURE_MAX_W) && (obj->p_tex[m+i].th<=TEXTURE_MAX_H)) {
 					d=log((double)obj->p_tex[m+i].tw)/log(2.0);
 					hm=pow(2,floor(d));
 					s3dprintf(MED,"hm %d, tw %d",hm,obj->p_tex[m+i].tw);
@@ -334,7 +296,7 @@
 					d=log((double)obj->p_tex[m+i].th)/log(2.0);
 					hm=pow(2,floor(d));
 					s3dprintf(MED,"hm %d, th %d",hm,obj->p_tex[m+i].th);
-					
+
 					if (hm!=obj->p_tex[m+i].th) 	{
 						obj->p_tex[m+i].h=hm*2;
 						obj->p_tex[m+i].ys=(float)((double)obj->p_tex[m+i].th)/((double)obj->p_tex[m+i].h);
@@ -345,21 +307,20 @@
 					obj->p_tex[m+i].buf=malloc(obj->p_tex[m+i].h*obj->p_tex[m+i].w*4);
 					memset(obj->p_tex[m+i].buf,0,obj->p_tex[m+i].h*obj->p_tex[m+i].w*4);
 					errds(LOW,"obj_push_tex()","setting up %d %d (in mem: %d %d) texture",
-									obj->p_tex[m+i].tw,
-									obj->p_tex[m+i].th,
-									obj->p_tex[m+i].w,
-									obj->p_tex[m+i].h);
-									
+					      obj->p_tex[m+i].tw,
+					      obj->p_tex[m+i].th,
+					      obj->p_tex[m+i].w,
+					      obj->p_tex[m+i].h);
+
 				} else	{
 					errds(MED,"obj_push_tex()","bad size for texture %d (requested size: %dx%d, max %dx%d)",m+i,
-									obj->p_tex[m+i].tw,obj->p_tex[m+i].th,TEXTURE_MAX_W,TEXTURE_MAX_H);
+					      obj->p_tex[m+i].tw,obj->p_tex[m+i].th,TEXTURE_MAX_W,TEXTURE_MAX_H);
 					obj->p_tex[m+i].buf=NULL;
 				}
 			}
 			obj->n_tex+=n;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -370,31 +331,26 @@
 	int32_t i,j,m;
 	struct t_obj *obj;
 	float *px;
- 	float len; 
-	if (OBJ_VALID(p,oid,obj))
-	{
+	float len;
+	if (OBJ_VALID(p,oid,obj)) {
 		m=obj->n_poly;
 		if (m<n)	 /*  saving the first number of polys */
 			n=m;  /*  when more polygons than available should be pepped,  */
-				 /*  just pep the first m polygons */
+		/*  just pep the first m polygons */
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj->oflags&OF_NODATA)
-		{
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_pep_poly_normal()","error: no data on object allowed!");
 			return(-1);
 		}
 
-		if (obj->dplist)
-		{
+		if (obj->dplist) {
 			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 			glDeleteLists(obj->dplist,1);
 			obj->dplist=0;
 		}
 		s3dprintf(VLOW,"pepping poly's %d to %d",(m-n),m);
-		for (i=(m-n);i<m;i++)
-		{
-			for (j=0;j<3;j++)
-			{
+		for (i=(m-n);i<m;i++) {
+			for (j=0;j<3;j++) {
 				obj->p_poly[i].n[j].x=*(px++);
 				obj->p_poly[i].n[j].y=*(px++);
 				obj->p_poly[i].n[j].z=*(px++);
@@ -408,8 +364,7 @@
 				}
 			}
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -421,30 +376,25 @@
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		m=obj->n_line;
 		if (m<n)	 /*  saving the first number of lines */
 			n=m;  /*  when more lines than available should be pepped,  */
-				 /*  just pep the first m liness */
+		/*  just pep the first m liness */
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj->oflags&OF_NODATA)
-		{
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_pep_line_normal()","error: no data on object allowed!");
 			return(-1);
 		}
 
-		if (obj->dplist)
-		{
+		if (obj->dplist) {
 			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 			glDeleteLists(obj->dplist,1);
 			obj->dplist=0;
 		}
 		s3dprintf(VLOW,"pepping line's %d to %d",(m-n),m);
-		for (i=(m-n);i<m;i++)
-		{
-			for (j=0;j<2;j++)
-			{
+		for (i=(m-n);i<m;i++) {
+			for (j=0;j<2;j++) {
 				obj->p_line[i].n[j].x=*(px++);
 				obj->p_line[i].n[j].y=*(px++);
 				obj->p_line[i].n[j].z=*(px++);
@@ -459,8 +409,7 @@
 
 			}
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -472,10 +421,8 @@
 	int32_t i,j,m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj->oflags&OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_pep_poly_texc()","error: no data on object allowed!");
 			return(-1);
 		}
@@ -483,26 +430,22 @@
 		m=obj->n_poly;
 		if (m<n)	 /*  saving the first number of polys */
 			n=m;  /*  when more polygons than available should be pepped,  */
-				 /*  just pep the first m polygons */
+		/*  just pep the first m polygons */
 		px=x; 				 /*  movable pointer for x, later */
 
-		if (obj->dplist)
-		{
+		if (obj->dplist) {
 			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 			glDeleteLists(obj->dplist,1);
 			obj->dplist=0;
 		}
 		s3dprintf(VLOW,"pepping poly's %d to %d",(m-n),m);
-		for (i=(m-n);i<m;i++)
-		{
-			for (j=0;j<3;j++)
-			{
+		for (i=(m-n);i<m;i++) {
+			for (j=0;j<3;j++) {
 				obj->p_poly[i].tc[j].x=*(px++);
 				obj->p_poly[i].tc[j].y=*(px++);
 			}
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -513,27 +456,23 @@
 	int32_t i,m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		m=obj->n_mat;	 /*  saving the first number of materials */
-		if (m<n)	
+		if (m<n)
 			n=m;  /*  when more mats than available should be pepped,  */
-				 /*  just pep the first m mats */
+		/*  just pep the first m mats */
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj->oflags&OF_NODATA)
-		{
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_pep_mat()","error: no data on object allowed!");
 			return(-1);
 		}
-		if (obj->dplist)
-		{
+		if (obj->dplist) {
 			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 			glDeleteLists(obj->dplist,1);
 			obj->dplist=0;
 		}
 		s3dprintf(VLOW,"pepping mats %d to %d",(m-n),m);
-		for (i=(m-n);i<m;i++)
-		{
+		for (i=(m-n);i<m;i++) {
 			obj->p_mat[i].amb_r=*(px++);
 			obj->p_mat[i].amb_g=*(px++);
 			obj->p_mat[i].amb_b=*(px++);
@@ -547,8 +486,7 @@
 			obj->p_mat[i].diff_b=*(px++);
 			obj->p_mat[i].diff_a=*(px++);
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -559,35 +497,30 @@
 	int32_t i,m;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		m=obj->n_line;	 /*  saving the first number of lines */
-		if (m<n)	
+		if (m<n)
 			n=m;  /*  when more lines than available should be pepped,  */
-				 /*  just pep the first m lines */
+		/*  just pep the first m lines */
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj->oflags&OF_NODATA)
-		{
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_pep_line()","error: no data on object allowed!");
 			return(-1);
 		}
-		if (obj->dplist)
-		{
+		if (obj->dplist) {
 			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 			glDeleteLists(obj->dplist,1);
 			obj->dplist=0;
 		}
 		s3dprintf(VLOW,"pepping lines %d to %d",(m-n),m);
-		for (i=(m-n);i<m;i++)
-		{
+		for (i=(m-n);i<m;i++) {
 			obj->p_line[i].v[0]=*(px++);
 			obj->p_line[i].v[1]=*(px++);
 			obj->p_line[i].mat=*(px++);
 			obj->p_line[i].n[0].x=obj->p_line[i].n[0].y=obj->p_line[i].n[0].z=0;
 			obj->p_line[i].n[1].x=obj->p_line[i].n[1].y=obj->p_line[i].n[1].z=0;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -603,52 +536,43 @@
 	struct t_obj *obj;
 	float *px;
 	int is_clnsrc;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		m=obj->n_vertex;	 /*  saving the first number of vertices */
-		if (m<n)	 
+		if (m<n)
 			n=m;  /*  when more mats than available should be pepped,  */
-				 /*  just pep the first m mats */
+		/*  just pep the first m mats */
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj->oflags&OF_NODATA)
-		{
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_pep_vertices()","error: no data on object allowed!");
 			return(-1);
 		}
-		if (obj->dplist)
-		{
+		if (obj->dplist) {
 			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 			glDeleteLists(obj->dplist,1);
 			obj->dplist=0;
 		}
 		s3dprintf(VLOW,"pepping vertices %d to %d",(m-n),m-1);
-		for (i=(m-n);i<m;i++)
-		{
+		for (i=(m-n);i<m;i++) {
 			obj->p_vertex[i].x=*(px++);
 			obj->p_vertex[i].y=*(px++);
 			obj->p_vertex[i].z=*(px++);
 			a=&obj->p_vertex[i];
-			r=obj->scale * sqrt(	
-					(a->x * a->x ) + 
-					(a->y * a->y ) +
-					(a->z * a->z ));
+			r=obj->scale * sqrt(
+			          (a->x * a->x ) +
+			          (a->y * a->y ) +
+			          (a->z * a->z ));
 			if (r> obj->r) obj->r=r;
 		}
-		if (p->id!=MCP)
-		{
-		/* this is doing live update which is quite okay, but we need
-		 * to check for biggest update and clonesources ... */
+		if (p->id!=MCP) {
+			/* this is doing live update which is quite okay, but we need
+			 * to check for biggest update and clonesources ... */
 			obj_check_biggest_object(p,oid);
 		}
-		if (p->object[oid]->oflags&OF_CLONE_SRC)
-		{
+		if (p->object[oid]->oflags&OF_CLONE_SRC) {
 			is_clnsrc=0;
-			for (i=0;i<p->n_obj;i++)
-			{
-				if (p->object[i]!=NULL)
-				{
-					if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid))
-					{ /* if it's pointing to our object ... */
+			for (i=0;i<p->n_obj;i++) {
+				if (p->object[i]!=NULL) {
+					if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid)) { /* if it's pointing to our object ... */
 						is_clnsrc=1;
 						p->object[i]->r=obj->r*(p->object[i]->r/obj->scale); /* give it the new radius too! */
 						obj_check_biggest_object(p,i);
@@ -658,8 +582,7 @@
 			if (!is_clnsrc)
 				p->object[oid]->oflags&=~OF_CLONE_SRC;
 		}
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -670,20 +593,17 @@
 	int32_t i,m;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		m=obj->n_mat;	 /*  saving the first number of vertices */
 		if (m<n)	 /*  saving the first number of polys */
 			n=m;  /*  when more mats than available should be pepped,  */
-				 /*  just pep the first m mats */
+		/*  just pep the first m mats */
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj->oflags&OF_NODATA)
-		{
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_pep_mat_tex()","error: no data on object allowed!");
 			return(-1);
 		}
-		if (obj->dplist)
-		{
+		if (obj->dplist) {
 			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 			glDeleteLists(obj->dplist,1);
 			obj->dplist=0;
@@ -691,8 +611,7 @@
 		s3dprintf(MED,"pepping mats %d to %d",(m-n),m);
 		for (i=(m-n);i<m;i++)
 			obj->p_mat[i].tex=*(px++);
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -704,29 +623,24 @@
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if (start < 0) return(-1);
 		m=obj->n_poly;
-		if (m<(start+n))	
-			n=m-start; 
+		if (m<(start+n))
+			n=m-start;
 		px=x;
-		if (obj->oflags&OF_NODATA)
-		{
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_load_poly_normal()","error: no data on object allowed!");
 			return(-1);
 		}
 
-		if (obj->dplist)
-		{
+		if (obj->dplist) {
 			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 			glDeleteLists(obj->dplist,1);
 			obj->dplist=0;
 		}
-		for (i=start;i<(start+n);i++)
-		{
-			for (j=0;j<3;j++)
-			{
+		for (i=start;i<(start+n);i++) {
+			for (j=0;j<3;j++) {
 				obj->p_poly[i].n[j].x=*(px++);
 				obj->p_poly[i].n[j].y=*(px++);
 				obj->p_poly[i].n[j].z=*(px++);
@@ -741,7 +655,7 @@
 
 			}
 		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -752,29 +666,24 @@
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if (start < 0) return(-1);
 		m=obj->n_line;
-		if (m<(start+n))	
-			n=m-start; 
+		if (m<(start+n))
+			n=m-start;
 		px=x;
-		if (obj->oflags&OF_NODATA)
-		{
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_load_line_normal()","error: no data on object allowed!");
 			return(-1);
 		}
 
-		if (obj->dplist)
-		{
+		if (obj->dplist) {
 			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 			glDeleteLists(obj->dplist,1);
 			obj->dplist=0;
 		}
-		for (i=start;i<(start+n);i++)
-		{
-			for (j=0;j<2;j++)
-			{
+		for (i=start;i<(start+n);i++) {
+			for (j=0;j<2;j++) {
 				obj->p_line[i].n[j].x=*(px++);
 				obj->p_line[i].n[j].y=*(px++);
 				obj->p_line[i].n[j].z=*(px++);
@@ -789,7 +698,7 @@
 
 			}
 		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -799,34 +708,29 @@
 	int32_t i,j,m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if (start < 0) return(-1);
 		m=obj->n_poly;
-		if (m<(start+n))	
-			n=m-start; 
+		if (m<(start+n))
+			n=m-start;
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj->oflags&OF_NODATA)
-		{
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_load_poly_texc()","error: no data on object allowed!");
 			return(-1);
 		}
 
-		if (obj->dplist)
-		{
+		if (obj->dplist) {
 			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 			glDeleteLists(obj->dplist,1);
 			obj->dplist=0;
 		}
-		for (i=start;i<(start+n);i++)
-		{
-			for (j=0;j<3;j++)
-			{
+		for (i=start;i<(start+n);i++) {
+			for (j=0;j<3;j++) {
 				obj->p_poly[i].tc[j].x=*(px++);
 				obj->p_poly[i].tc[j].y=*(px++);
 			}
 		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -838,27 +742,23 @@
 	int32_t i,m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if (start < 0) return(-1);
-		m=obj->n_mat;	
-		if (m<(start+n))	
-			n=m-start; 
+		m=obj->n_mat;
+		if (m<(start+n))
+			n=m-start;
 		px=x; 				 /*  movable pointer for x, later */
-		if (obj->oflags&OF_NODATA)
-		{
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_pep_mat()","error: no data on object allowed!");
 			return(-1);
 		}
-		if (obj->dplist)
-		{
+		if (obj->dplist) {
 			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 			glDeleteLists(obj->dplist,1);
 			obj->dplist=0;
 		}
 		s3dprintf(MED,"pepping %d mats, starting at %d",n,start);
-		for (i=start;i<(start+n);i++)
-		{
+		for (i=start;i<(start+n);i++) {
 			obj->p_mat[i].amb_r=*(px++);
 			obj->p_mat[i].amb_g=*(px++);
 			obj->p_mat[i].amb_b=*(px++);
@@ -872,7 +772,7 @@
 			obj->p_mat[i].diff_b=*(px++);
 			obj->p_mat[i].diff_a=*(px++);
 		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -880,11 +780,10 @@
 static void obj_update_tex(struct t_tex *tex,u_int16_t S3DUNUSED(x),u_int16_t S3DUNUSED(y),u_int16_t S3DUNUSED(w),u_int16_t S3DUNUSED(h),u_int8_t *S3DUNUSED(pixbuf))
 {
 	GLuint t;
-	if ((tex->gl_texnum)!=-1)
-	{
+	if ((tex->gl_texnum)!=-1) {
 		t= tex->gl_texnum;
-/* s3dprintf(MED,"updating texture %d at [%d %d] with a [%d %d] pixbuf",t,x,y,w,h); */
-/* 		glTexSubImage2D(t,0,x,y,w,h,GL_RGBA,GL_UNSIGNED_BYTE,pixbuf); */
+		/* s3dprintf(MED,"updating texture %d at [%d %d] with a [%d %d] pixbuf",t,x,y,w,h); */
+		/* 		glTexSubImage2D(t,0,x,y,w,h,GL_RGBA,GL_UNSIGNED_BYTE,pixbuf); */
 
 		glDeleteTextures(1,&t);
 		tex->gl_texnum=-1;
@@ -897,21 +796,16 @@
 	struct t_tex *t;
 	int32_t i,p1,p2,m;
 	int16_t mw;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj->oflags&OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_load_tex()","error: no data on object allowed!");
 			return(-1);
 		}
 		if ( tex < 0 ) return(-1);
-		if ( tex < obj->n_tex)
-		{
+		if ( tex < obj->n_tex) {
 			t=&obj->p_tex[tex];
-			if (t->buf!=NULL)
-			{
-				if (obj->dplist)
-				{
+			if (t->buf!=NULL) {
+				if (obj->dplist) {
 					s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 					glDeleteLists(obj->dplist,1);
 					obj->dplist=0;
@@ -919,11 +813,10 @@
 
 				m=(t->w-1)*t->th+t->tw; 			 /*  maximum: position of the last pixel in the buffer */
 				if ((x+w)>t->tw) mw=(t->tw-x);
-					else mw=w;
+				else mw=w;
 				if (mw<=0)	 /*  nothing to do */
 					return(-1);
-				for (i=0;i<h;i++)
-				{
+				for (i=0;i<h;i++) {
 					p1=(y+i)*t->w+x;  /*  scanline start position */
 					p2=mw;			 /*  and length */
 					if (p1>m)
@@ -931,8 +824,8 @@
 					if ((p1+w)>m)
 						p2=m-p1;	 /*  only draw a part of the scanline */
 					memcpy(	t->buf+	4*p1,			 /*  draw at p1 position ... */
-							pixbuf+	4*i*w,			 /*  scanline number i ... */
-									4*p2);
+					        pixbuf+	4*i*w,			 /*  scanline number i ... */
+					        4*p2);
 				}
 				obj_update_tex(t,x,y,w,h,pixbuf);
 				return(0);
@@ -940,7 +833,7 @@
 				errds(HIGH,"obj_load_tex()","no buffer to draw to in oid %d, texture %d",oid,tex);
 			}
 		}
-	} 
+	}
 	return(-1);
 }
 int obj_toggle_flags(struct t_process *p, int32_t oid, uint8_t type, uint32_t flags)
@@ -949,17 +842,22 @@
 	uint32_t f;
 
 	f=flags&OF_MASK;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		switch (type)
-		{
-			case OF_TURN_ON:	obj->oflags|=f;		break;
-			case OF_TURN_OFF:	obj->oflags&=~f;	break;
-			case OF_TURN_SWAP:	obj->oflags^=f;		break;
-			default:return(-1);
+	if (OBJ_VALID(p,oid,obj)) {
+		switch (type) {
+		case OF_TURN_ON:
+			obj->oflags|=f;
+			break;
+		case OF_TURN_OFF:
+			obj->oflags&=~f;
+			break;
+		case OF_TURN_SWAP:
+			obj->oflags^=f;
+			break;
+		default:
+			return(-1);
 		}
-/* 		s3dprintf(VLOW,"toggled %d->oflags=%010x with %010x [%d]",oid,obj->oflags,flags,type); */
-	} 
+		/* 		s3dprintf(VLOW,"toggled %d->oflags=%010x with %010x [%d]",oid,obj->oflags,flags,type); */
+	}
 	return(0);
 }
 /*  deletes the last n vertices of the stack. if n>=n_vertex, delete all vertices */
@@ -968,29 +866,22 @@
 	int32_t m;
 	struct t_vertex *p_vertex;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj->oflags&OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_del_vertex()","error: can't delete vertices in this object!");
 			return(-1);
 		}
 
 		s3dprintf(VLOW,"deleting %d vertices of pid %d/ oid %d",n,p->id,oid);
 		m=obj->n_vertex;	 /*  saving the first number of vertices */
-		if (n>=m) 
-		{
+		if (n>=m) {
 			if (m>0)
 				free(obj->p_vertex);
 			obj->n_vertex=0;
 			obj->p_vertex=NULL;
-		}
-		else if (n>0)
-		{
-			if (NULL!=(p_vertex=realloc(obj->p_vertex,sizeof(struct t_vertex) * ( m - n))))
-			{
-				if (obj->dplist)
-				{
+		} else if (n>0) {
+			if (NULL!=(p_vertex=realloc(obj->p_vertex,sizeof(struct t_vertex) * ( m - n)))) {
+				if (obj->dplist) {
 					s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
 					glDeleteLists(obj->dplist,1);
 					obj->dplist=0;
@@ -1000,8 +891,7 @@
 			}
 		}
 		obj_size_update(p,oid);
-	} else 
-	{
+	} else {
 		return(-1);
 	}
 	return(0);
@@ -1012,36 +902,30 @@
 	int32_t m;
 	struct t_mat *p_mat;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj->oflags&OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_del_mat()","error: can't delete materials in this object!");
 			return(-1);
 		}
 
 		s3dprintf(VLOW,"deleting %d materials of pid %d/ oid %d",n,p->id,oid);
 		m=obj->n_mat;	 /*  saving the first number of materials */
-		if (n>=m) 
-		{
+		if (n>=m) {
 			if (m>0)
 				free(obj->p_mat);
 			obj->n_mat=0;
 			obj->p_mat=NULL;
-		}
-		else if (n>0)
-		if (NULL!=(p_mat=realloc(obj->p_mat,sizeof(struct t_mat) * ( m - n))))
-		{
-			if (obj->dplist)
-			{
-				s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-				glDeleteLists(obj->dplist,1);
-				obj->dplist=0;
+		} else if (n>0)
+			if (NULL!=(p_mat=realloc(obj->p_mat,sizeof(struct t_mat) * ( m - n)))) {
+				if (obj->dplist) {
+					s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
+					glDeleteLists(obj->dplist,1);
+					obj->dplist=0;
+				}
+				obj->p_mat=p_mat;
+				obj->n_mat-=n;
 			}
-			obj->p_mat=p_mat;
-			obj->n_mat-=n;
-		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -1051,36 +935,30 @@
 	int32_t m;
 	struct t_poly *p_poly;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj->oflags&OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_del_poly()","error: can't delete poly in this object!");
 			return(-1);
 		}
 
 		s3dprintf(VLOW,"deleting %d polys of pid %d/ oid %d",n,p->id,oid);
 		m=obj->n_poly;	 /*  saving the first number of poly  */
-		if (n>=m) 
-		{
+		if (n>=m) {
 			if (m>0)
 				free(obj->p_poly);
 			obj->n_poly=0;
 			obj->p_poly=NULL;
-		}
-		else if (n>0)
-		if (NULL!=(p_poly=realloc(obj->p_poly,sizeof(struct t_poly) * ( m - n))))
-		{
-			if (obj->dplist)
-			{
-				s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-				glDeleteLists(obj->dplist,1);
-				obj->dplist=0;
+		} else if (n>0)
+			if (NULL!=(p_poly=realloc(obj->p_poly,sizeof(struct t_poly) * ( m - n)))) {
+				if (obj->dplist) {
+					s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
+					glDeleteLists(obj->dplist,1);
+					obj->dplist=0;
+				}
+				obj->p_poly=p_poly;
+				obj->n_poly-=n;
 			}
-			obj->p_poly=p_poly;
-			obj->n_poly-=n;
-		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -1090,36 +968,30 @@
 	int32_t m;
 	struct t_line *p_line;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj->oflags&OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_del_line()","error: can't delete line in this object!");
 			return(-1);
 		}
 
 		s3dprintf(VLOW,"deleting %d lines of pid %d/ oid %d",n,p->id,oid);
 		m=obj->n_line;	 /*  saving the first number of line  */
-		if (n>=m) 
-		{
+		if (n>=m) {
 			if (m>0)
 				free(obj->p_line);
 			obj->n_line=0;
 			obj->p_line=NULL;
-		}
-		else if (n>0)
-		if (NULL!=(p_line=realloc(obj->p_line,sizeof(struct t_line) * ( m - n))))
-		{
-			if (obj->dplist)
-			{
-				s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-				glDeleteLists(obj->dplist,1);
-				obj->dplist=0;
+		} else if (n>0)
+			if (NULL!=(p_line=realloc(obj->p_line,sizeof(struct t_line) * ( m - n)))) {
+				if (obj->dplist) {
+					s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
+					glDeleteLists(obj->dplist,1);
+					obj->dplist=0;
+				}
+				obj->p_line=p_line;
+				obj->n_line-=n;
 			}
-			obj->p_line=p_line;
-			obj->n_line-=n;
-		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -1131,24 +1003,19 @@
 	struct t_tex *p_tex;
 	struct t_obj *obj;
 	GLuint t;
-	if (OBJ_VALID(p,oid,obj))
-	{
-		if (obj->oflags&OF_NODATA)
-		{
+	if (OBJ_VALID(p,oid,obj)) {
+		if (obj->oflags&OF_NODATA) {
 			errds(MED,"obj_del_tex()","error: can't delete textures in this object!");
 			return(-1);
 		}
 
 		s3dprintf(VLOW,"deleting %d textures of pid %d/ oid %d",n,p->id,oid);
 		m=obj->n_tex;	 /*  saving the first number of textures  */
-		if (n>=m) 
-		{
-			for (i=0;i<m;i++)
-			{
+		if (n>=m) {
+			for (i=0;i<m;i++) {
 				if ((obj->p_tex[i].buf)!=NULL)
 					free(obj->p_tex[i].buf);
-				if (obj->p_tex[i].gl_texnum)
-				{
+				if (obj->p_tex[i].gl_texnum) {
 					t=obj->p_tex[i].gl_texnum;
 					glDeleteTextures(1,&t);
 				}
@@ -1157,32 +1024,27 @@
 				free(obj->p_tex);
 			obj->n_tex=0;
 			obj->p_tex=NULL;
-		} else if (n>0)
-		{
-			for (i=(m-n);i<m;i++)
-			{
+		} else if (n>0) {
+			for (i=(m-n);i<m;i++) {
 				if (obj->p_tex[i].buf!=NULL)
 					free(obj->p_tex[i].buf);
-				if (obj->p_tex[i].gl_texnum)
-				{
+				if (obj->p_tex[i].gl_texnum) {
 					t=obj->p_tex[i].gl_texnum;
 					glDeleteTextures(1,&t);
 				}
 
 			}
-			if (NULL!=(p_tex=realloc(obj->p_tex,sizeof(struct t_tex) * ( m - n))))
-			{
-				if (obj->dplist)
-				{
+			if (NULL!=(p_tex=realloc(obj->p_tex,sizeof(struct t_tex) * ( m - n)))) {
+				if (obj->dplist) {
 					s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-						glDeleteLists(obj->dplist,1);
+					glDeleteLists(obj->dplist,1);
 					obj->dplist=0;
 				}
 				obj->p_tex=p_tex;
 				obj->n_tex=n;
 			}
 		}
-	} else 
+	} else
 		return(-1);
 	return(0);
 }
@@ -1193,26 +1055,23 @@
 	struct t_obj *obj;
 	struct t_process *mcp_p=get_proc_by_pid(MCP);
 	float v[3];
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if (isnan(transv[0])||isinf(transv[0])) return(-1);
 		if (isnan(transv[1])||isinf(transv[1])) return(-1);
 		if (isnan(transv[2])||isinf(transv[2])) return(-1);
-		if ((p->id!=MCP) && (obj->oflags&OF_SYSTEM))
-		{
-			if (focus_oid==p->mcp_oid)
-			{
+		if ((p->id!=MCP) && (obj->oflags&OF_SYSTEM)) {
+			if (focus_oid==p->mcp_oid) {
 				v[0]=transv[0];
 				v[1]=transv[1];
 				v[2]=transv[2];
 				mySetMatrix(mcp_p->object[p->mcp_oid]->m);
 				myTransform3f(v);
-/*				mySetMatrix(mcp_p->object[oid]->m);
-				myInvert();
-				myTransform3f(v);
-				s3dprintf(LOW,"%3.3f %3.3f %3.3f",v[0],v[1],v[2]);*/
+				/*				mySetMatrix(mcp_p->object[oid]->m);
+								myInvert();
+								myTransform3f(v);
+								s3dprintf(LOW,"%3.3f %3.3f %3.3f",v[0],v[1],v[2]);*/
 				obj_translate(mcp_p,oid,v);
-			} 
+			}
 		} else {
 			obj->translate.x=*transv;
 			obj->translate.y=*(transv+1);
@@ -1230,15 +1089,12 @@
 	struct t_process *mcp_p=get_proc_by_pid(MCP);
 	float v[3];
 	float f;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if (isnan(rotv[0])||isinf(rotv[0])) return(-1);
 		if (isnan(rotv[1])||isinf(rotv[1])) return(-1);
 		if (isnan(rotv[2])||isinf(rotv[2])) return(-1);
-		if ((p->id!=MCP) && (obj->oflags&OF_SYSTEM))
-		{
-			if (focus_oid==p->mcp_oid)
-			{
+		if ((p->id!=MCP) && (obj->oflags&OF_SYSTEM)) {
+			if (focus_oid==p->mcp_oid) {
 				v[0]=obj->rotate.x + (rotv[0] - obj->rotate.x);
 				v[1]=obj->rotate.y + (rotv[1] - obj->rotate.y);
 				v[2]=obj->rotate.z + (rotv[2] - obj->rotate.z);
@@ -1267,19 +1123,17 @@
 int obj_scale(struct t_process *p, int32_t oid, float scav)
 {
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj))
-	{
+	if (OBJ_VALID(p,oid,obj)) {
 		if ((p->id==MCP) || (!(obj->oflags&OF_SYSTEM)))
-		if (!isinf(scav) && !isnan(scav) && !((scav<1.0e-10) && (scav>-1.0e-10))) /* ignore very low values */
-		{
-			s3dprintf(VLOW,"[scale|pid %d] obj %d to %f",p->id,oid,scav);
-			obj->scale=scav;
-	/*		obj->scale.x=*scav;
-			obj->scale.y=*(scav+1);
-			obj->scale.z=*(scav+2);*/
-			obj_size_update(p,oid);
-			obj_pos_update(p,oid,oid);
-		}
+			if (!isinf(scav) && !isnan(scav) && !((scav<1.0e-10) && (scav>-1.0e-10))) { /* ignore very low values */
+				s3dprintf(VLOW,"[scale|pid %d] obj %d to %f",p->id,oid,scav);
+				obj->scale=scav;
+				/*		obj->scale.x=*scav;
+						obj->scale.y=*(scav+1);
+						obj->scale.z=*(scav+2);*/
+				obj_size_update(p,oid);
+				obj_pos_update(p,oid,oid);
+			}
 	}
 	return(0);
 }
@@ -1287,25 +1141,23 @@
 void into_position(struct t_process *p, struct t_obj *obj, int depth)
 {
 	struct t_obj *on;
-	if ((obj->oflags&OF_LINK) && (depth<p->n_obj))
-	{
+	if ((obj->oflags&OF_LINK) && (depth<p->n_obj)) {
 		/* TODO: only MultMatrix if m_uptodate ?! */
-		if (OBJ_VALID(p,obj->linkid,on))
-		{
+		if (OBJ_VALID(p,obj->linkid,on)) {
 			into_position(p,on,depth+1);
 		} else {
 			obj->oflags&=~OF_LINK;
 			s3dprintf(LOW,"link object is broken, removing link");
 		}
 	}
-	 /* if (depth>=MAXLOOP) */
+	/* if (depth>=MAXLOOP) */
 	if (depth>=p->n_obj)
 		s3dprintf(MED,"too much looping ...");
 	glTranslatef(obj->translate.x,obj->translate.y,obj->translate.z);
 	glRotatef(obj->rotate.y,0.0,1.0,0.0);
 	glRotatef(obj->rotate.x,1.0,0.0,0.0);
 	glRotatef(obj->rotate.z,0.0,0.0,1.0);
-/*	glScalef(obj->scale.x,obj->scale.y,obj->scale.z);*/
+	/*	glScalef(obj->scale.x,obj->scale.y,obj->scale.z);*/
 	glScalef(obj->scale,obj->scale,obj->scale);
 }
 
@@ -1317,42 +1169,34 @@
 	int vn,is_clnsrc;
 	int32_t i;
 	if (p->id==MCP) return; /*  mcp does not need that. */
-	if (OBJ_VALID(p,oid,o))
-	{
-		if (o->oflags&OF_SYSTEM)
-		{
+	if (OBJ_VALID(p,oid,o)) {
+		if (o->oflags&OF_SYSTEM) {
 			o->r=o->or=0; /* we don't care about system objects */
-			return; 
+			return;
 		}
 		vp=o->p_vertex;
 		vn=o->n_vertex;
-		if (o->oflags&OF_CLONE)
-		{  
+		if (o->oflags&OF_CLONE) {
 			o2=p->object[o->n_vertex];	 /*  get the target into o2*/
 			o->r= o2->r * (o->scale/o2->scale);
 			obj_check_biggest_object(p,oid);
 			return;
 		} else {
-/* 			printf(MED,"looking through vertices..."); */
-			for (i=0;i<vn;i++)
-			{
+			/* 			printf(MED,"looking through vertices..."); */
+			for (i=0;i<vn;i++) {
 				a=&(vp[i]);
 				r=o->scale * sqrt(
-						(a->x  * a->x ) + 
-						(a->y  * a->y ) +
-						(a->z  * a->z ));
+				          (a->x  * a->x ) +
+				          (a->y  * a->y ) +
+				          (a->z  * a->z ));
 				if (r > o->r) o->r=r;
 			}
 			obj_check_biggest_object(p,oid);
-			if (p->object[oid]->oflags&OF_CLONE_SRC)
-			{
+			if (p->object[oid]->oflags&OF_CLONE_SRC) {
 				is_clnsrc=0;
-				for (i=0;i<p->n_obj;i++)
-				{
-					if (p->object[i]!=NULL)
-					{
-						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex== oid))
-						{ /* if it's pointing to our object ... */
+				for (i=0;i<p->n_obj;i++) {
+					if (p->object[i]!=NULL) {
+						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex== oid)) { /* if it's pointing to our object ... */
 							is_clnsrc=1;
 							p->object[i]->r=o->r*(p->object[i]->r/o->scale); /* give it the new radius too! */
 							obj_check_biggest_object(p,i);
@@ -1380,53 +1224,46 @@
 	if (o->oflags&OF_SYSTEM)
 		return; /* we don't care, system objects don't count. */
 	r=o->r+o->or;
-	if (r>mcp_o->r)
-	{	 /*  this is now the biggest object. */
+	if (r>mcp_o->r) {	 /*  this is now the biggest object. */
 		mcp_o->r=r;
 		p->biggest_obj=oid;
-/*		s3dprintf(MED,"there is a new biggest object in [%d:\"\"]",p->id,p->name);*/
+		/*		s3dprintf(MED,"there is a new biggest object in [%d:\"\"]",p->id,p->name);*/
 		mcp_rep_object(p->mcp_oid);	  /*  and tell the mcp */
 	} else {
-		if (p->biggest_obj==oid)
-		{  /*  oid might now lose the status of the "biggest object". let's check: */
+		if (p->biggest_obj==oid) { /*  oid might now lose the status of the "biggest object". let's check: */
 			found=0;
 			for (i=0;i<p->n_obj;i++)
-				if (p->object[i]!=NULL)
-				{
-					if ((r2=p->object[i]->r+p->object[i]->or)>r)
-					{  /*  this object is bigger than the old biggest one. */
-						if (!(p->object[i]->oflags&OF_SYSTEM))
-						{
+				if (p->object[i]!=NULL) {
+					if ((r2=p->object[i]->r+p->object[i]->or)>r) { /*  this object is bigger than the old biggest one. */
+						if (!(p->object[i]->oflags&OF_SYSTEM)) {
 							p->biggest_obj=oid;
 							r=r2;
 							found=1;
 						}
 					}
 				}
-			if (found)
-			{
+			if (found) {
 				s3dprintf(VLOW,"there is a new biggest object in [%d:\"\"]",p->id,p->name);
 				mcp_o->r=r;  /*  save the new size */
 				mcp_rep_object(p->mcp_oid);	  /*  and tell the mcp */
 			}
 		}   /*  if it wasn't the biggest object, no one cares if it's smaller than process */
-			 /*  radius */
+		/*  radius */
 	}
 }
 /* calculates and saves the transformation matrix, if needed */
 void obj_recalc_tmat(struct t_process *p, int32_t oid)
 {
 	GLint matrixmode;
-	if (!p->object[oid]->m_uptodate)
-	{
+	if (!p->object[oid]->m_uptodate) {
 		glGetIntegerv(GL_MATRIX_MODE,&matrixmode); 		 /*  save matrixmode */
 		glMatrixMode(GL_MODELVIEW); 					 /*  go into modelview */
 		glPushMatrix();
 		glLoadIdentity();
-		into_position(p,p->object[oid],0);	
+		into_position(p,p->object[oid],0);
 		glGetFloatv( GL_MODELVIEW_MATRIX, p->object[oid]->m );
 		glPopMatrix();
-		glMatrixMode(matrixmode);	
+		glMatrixMode(matrixmode);
 		p->object[oid]->m_uptodate=1;
 	}
 }
@@ -1441,8 +1278,7 @@
 	sa=ss=1.0F;
 	/* find the angel of the sys object */
 	o=mcp_p->object[oid];
-	while (o!=NULL)
-	{
+	while (o!=NULL) {
 		fs.x+=o->rotate.x;
 		fs.y+=o->rotate.y;
 		fs.z+=o->rotate.z;
@@ -1457,8 +1293,7 @@
 	myTransform3f(v);
 
 	o=mcp_p->object[p->mcp_oid];
-	while (o!=NULL)
-	{
+	while (o!=NULL) {
 		fa.x+=o->rotate.x;
 		fa.y+=o->rotate.y;
 		fa.z+=o->rotate.z;
@@ -1482,7 +1317,7 @@
 
 	p->object[oid]->scale=ss/sa;
 
-/*	obj_debug(p,oid);*/
+	/*	obj_debug(p,oid);*/
 	obj_pos_update(p,oid,oid); /* now also update the matrix and the objects linking to our sys-object ... */
 }
 /*  recalculate the position of an object. this assumes that oid is valid. */
@@ -1495,24 +1330,20 @@
 	s3dprintf(VLOW,"[obj_pos_upd|pid %d] %d",p->id, oid,first_oid);
 	o->m_uptodate=0;
 	obj_recalc_tmat(p,oid);
-	if (p->id!=MCP) 
-	{/*  mcp does not need that. */
-		 /*  save the matrixmode to reset it later on */
+	if (p->id!=MCP) {/*  mcp does not need that. */
+		/*  save the matrixmode to reset it later on */
 		v[0]=v[1]=v[2]=0.0F;
 		mySetMatrix(o->m);
 		myTransform3f(v);
-			 /*  and get it's destination point. phew */
+		/*  and get it's destination point. phew */
 		o->or=sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
-	} else 
+	} else
 		if (o->oflags&OF_SYSTEM) /* TODO: what will we do if $sys_object is linked to another? */
 		{ /* a system object changed position? let's update the focus'ed sys-objects */
 			if (OBJ_VALID(p,focus_oid,ao))
-				if (NULL!=(ap=get_proc_by_pid(ao->n_mat)))
-				{
-					if (OF_POINTER==(o->oflags&0xF0000000))
-					{ /* we dont have to do that much in this case ... */
-						if (OBJ_VALID(ap,get_pointer(ap),ao)) /* we can redefine ao here -> ao = focused app's pointer*/
-						{
+				if (NULL!=(ap=get_proc_by_pid(ao->n_mat))) {
+					if (OF_POINTER==(o->oflags&0xF0000000)) { /* we dont have to do that much in this case ... */
+						if (OBJ_VALID(ap,get_pointer(ap),ao)) { /* we can redefine ao here -> ao = focused app's pointer*/
 							ao->rotate.x=o->rotate.x;
 							ao->rotate.y=o->rotate.y;
 							ao->rotate.z=o->rotate.z;
@@ -1522,27 +1353,26 @@
 							obj_pos_update(ap,get_pointer(ap),get_pointer(ap));
 						}
 					} else {
-						obj_sys_update(ap,oid);	
+						obj_sys_update(ap,oid);
 					}
 				}
-			switch (o->oflags&0xF0000000)
-			{
-				case OF_CAM:
-					event_cam_changed();
-					break;
-				case OF_POINTER:
-					event_ptr_changed();
-					break;
-				default:
-					s3dprintf(LOW,"[obj_pos_upd|pid %d] %d unknown system event",p->id,oid);
-					
+			switch (o->oflags&0xF0000000) {
+			case OF_CAM:
+				event_cam_changed();
+				break;
+			case OF_POINTER:
+				event_ptr_changed();
+				break;
+			default:
+				s3dprintf(LOW,"[obj_pos_upd|pid %d] %d unknown system event",p->id,oid);
+
 			}
 
 		}
 	/* if it's the root (oid==first_oid), only go down */
-	
+
 	if (o->lsub!=-1)						obj_pos_update(p,o->lsub,first_oid);
-	if ((o->lnext!=-1) && (oid!=first_oid))	obj_pos_update(p,o->lnext,first_oid); 
+	if ((o->lnext!=-1) && (oid!=first_oid))	obj_pos_update(p,o->lnext,first_oid);
 	if (p->id!=MCP)
 		obj_check_biggest_object(p,oid);
 }
@@ -1552,20 +1382,18 @@
 	struct t_vertex a,b,n;
 	struct t_vertex *v[3];
 	int32_t vp,i;
-	
+
 	float len;
-	for (i=0;i<3;i++)  /*  set and check */
-	{
+	for (i=0;i<3;i++) { /*  set and check */
 		vp= obj->p_poly[pn].v[i];  /*  ... get the vertices ... */
 		if ( vp < obj->n_vertex)
 			v[i]=&(obj->p_vertex[vp]);
 		else return(-1);
 	}
-	 /*  check for already set normal */
+	/*  check for already set normal */
 	if ((obj->p_poly[pn].n[0].x*obj->p_poly[pn].n[0].x+
-		 obj->p_poly[pn].n[0].y*obj->p_poly[pn].n[0].y+
-		 obj->p_poly[pn].n[0].z*obj->p_poly[pn].n[0].z)==0)  
-	{/*  normal already defined? */
+	                obj->p_poly[pn].n[0].y*obj->p_poly[pn].n[0].y+
+	                obj->p_poly[pn].n[0].z*obj->p_poly[pn].n[0].z)==0) {/*  normal already defined? */
 		a.x=v[1]->x-v[0]->x;
 		a.y=v[1]->y-v[0]->y;
 		a.z=v[1]->z-v[0]->z;
@@ -1577,15 +1405,13 @@
 		n.z=a.x*b.y - a.y*b.x;
 
 		len=sqrt(n.x*n.x+n.y*n.y+n.z*n.z);
-		if (len==0.0F)
-		{
-		 /* 		errds(VLOW,"bad polygon (can't normalize ...)"); */
+		if (len==0.0F) {
+			/* 		errds(VLOW,"bad polygon (can't normalize ...)"); */
 		} else {
 			n.x=n.x/len;
 			n.y=n.y/len;
 			n.z=n.z/len;
-			for (i=0;i<3;i++) 
-			{
+			for (i=0;i<3;i++) {
 				obj->p_poly[pn].n[i].x=n.x;
 				obj->p_poly[pn].n[i].y=n.y;
 				obj->p_poly[pn].n[i].z=n.z;
@@ -1600,19 +1426,16 @@
 {
 	struct t_vertex *v[2];
 	int i,vp;
-	for (i=0;i<2;i++)  /*  set and check */
-	{
+	for (i=0;i<2;i++) { /*  set and check */
 		vp= obj->p_line[pn].v[i];  /*  ... get the vertices ... */
 		if (vp < (int)obj->n_vertex)
 			v[i]=&(obj->p_vertex[vp]);
 		else return(-1);
 	}
 	if ((obj->p_line[pn].n[0].x*obj->p_line[pn].n[0].x+
-		 obj->p_line[pn].n[0].y*obj->p_line[pn].n[0].y+
-		 obj->p_line[pn].n[0].z*obj->p_line[pn].n[0].z)==0)  
-	{ /* guess we have nothing set yet, so set something */
-		for (i=0;i<2;i++)
-		{
+	                obj->p_line[pn].n[0].y*obj->p_line[pn].n[0].y+
+	                obj->p_line[pn].n[0].z*obj->p_line[pn].n[0].z)==0) { /* guess we have nothing set yet, so set something */
+		for (i=0;i<2;i++) {
 			obj->p_line[pn].n[0].x=0;
 			obj->p_line[pn].n[0].y=0;
 			obj->p_line[pn].n[0].z=1;
@@ -1623,17 +1446,14 @@
 }
 
 /* activate/bind texture for object */
-static struct t_tex *get_texture(struct t_obj *obj,struct t_mat *m)
-{
+static struct t_tex *get_texture(struct t_obj *obj,struct t_mat *m) {
 	GLuint t;
 	struct t_tex *tex=NULL;
 	GLfloat matgl[4];
-/* 	int i,j; */
-	if (m->tex < obj->n_tex)
-	{
+	/* 	int i,j; */
+	if (m->tex < obj->n_tex) {
 		tex=&obj->p_tex[m->tex];
-		if (tex->buf!=NULL)
-		{  /*  texture seems to be okay, select it. */
+		if (tex->buf!=NULL) { /*  texture seems to be okay, select it. */
 			matgl[0]=0.5f;
 			matgl[1]=0.5f;
 			matgl[2]=0.5f;
@@ -1641,37 +1461,35 @@
 			glMaterialfv(GL_FRONT,GL_AMBIENT,matgl);
 			glMaterialfv(GL_FRONT,GL_DIFFUSE,matgl);
 			glMaterialfv(GL_FRONT,GL_SPECULAR,matgl);
-			if (tex->gl_texnum!=-1)
-			{
+			if (tex->gl_texnum!=-1) {
 				glBindTexture( GL_TEXTURE_2D,tex->gl_texnum);
 			} else {
 				glGenTextures(1,&t);
 				glBindTexture( GL_TEXTURE_2D, t);
 				tex->gl_texnum=t;
 				s3dprintf(HIGH,"generated texture %d [%dx%d, in memory %dx%d]",t,tex->tw,tex->th,tex->w,tex->h);
-/*				for (j=0;j<tex->th;j++)
-				for (i=0;i<tex->tw;i++)
-				{
-					s3dprintf(MED,"pixel[%d,%d], %d %d %d %d",i,j,
-									tex->buf[(j*tex->w+i)*4+0],
-									tex->buf[(j*tex->w+i)*4+1],
-									tex->buf[(j*tex->w+i)*4+2],
-									tex->buf[(j*tex->w+i)*4+3]);
-				}*/
-				glTexImage2D(	GL_TEXTURE_2D,0, GL_RGBA,	
-								tex->w,tex->h,0,  /*  no border. */
-								GL_RGBA,GL_UNSIGNED_BYTE,tex->buf);
-								 /*  texture has to be generated yet ... */
-			   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-			   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-			   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, 
-			                   GL_NEAREST);
-			   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, 
-			                   GL_NEAREST);
-			   
-				}
-		}
-		else {  /* . can't use a texture  */
+				/*				for (j=0;j<tex->th;j++)
+								for (i=0;i<tex->tw;i++)
+								{
+									s3dprintf(MED,"pixel[%d,%d], %d %d %d %d",i,j,
+													tex->buf[(j*tex->w+i)*4+0],
+													tex->buf[(j*tex->w+i)*4+1],
+													tex->buf[(j*tex->w+i)*4+2],
+													tex->buf[(j*tex->w+i)*4+3]);
+								}*/
+				glTexImage2D(	GL_TEXTURE_2D,0, GL_RGBA,
+				              tex->w,tex->h,0,  /*  no border. */
+				              GL_RGBA,GL_UNSIGNED_BYTE,tex->buf);
+				/*  texture has to be generated yet ... */
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
+				                GL_NEAREST);
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
+				                GL_NEAREST);
+
+			}
+		} else { /* . can't use a texture  */
 			tex=NULL;
 		}
 	}
@@ -1683,7 +1501,7 @@
 	int32_t pn;
 	int32_t mat,omat=-1;
 	int32_t v;
-/* 	int link_obj; */
+	/* 	int link_obj; */
 	struct t_vertex *on;
 	struct t_obj *obj;
 	struct t_mat *m;
@@ -1694,86 +1512,83 @@
 	obj=p->object[oid];
 	glPushMatrix();
 	glMultMatrixf(obj->m);
-/*	into_position(p,obj,0);*/
+	/*	into_position(p,obj,0);*/
 	if (obj->oflags&OF_SYSTEM)		return(-1); 					/* can't render system objects */
 	if (obj->oflags&OF_CLONE)		obj=p->object[obj->n_vertex]; 	/* it's a clone - draw the clone! */
 	if (!obj->dplist) {
 		obj->dplist=glGenLists(1);
 		if (obj->dplist)	glNewList(obj->dplist,GL_COMPILE); /* only compile and calling later should save time. maybe. */
-		 else 				s3dprintf(LOW,"couldn't get a new list :/");
+		else 				s3dprintf(LOW,"couldn't get a new list :/");
 		omat=-1;
-		for (pn=0; pn<obj->n_poly; pn++)  /*  cycle throu our polygons ... */
-		{
-			if (calc_normal(obj,pn))
-			{
+		for (pn=0; pn<obj->n_poly; pn++) { /*  cycle throu our polygons ... */
+			if (calc_normal(obj,pn)) {
 				s3dprintf(HIGH,"something is wrong with polygon %d!",pn);
-				if (obj->dplist) glEndList();	glPopMatrix(); /* clean up GL-stuff */
+				if (obj->dplist) glEndList();
+				glPopMatrix(); /* clean up GL-stuff */
 				return(-1);
 			}
-	 /* 		glNormal3f(-n.x,-n.y,-n.z); */
+			/* 		glNormal3f(-n.x,-n.y,-n.z); */
 			mat= obj->p_poly[pn].mat;
 			if (mat!=omat) {
 				tex=NULL;
 				if (mat< obj->n_mat) {
 					m=&obj->p_mat[mat];
 					if (m->tex!=-1)		tex=get_texture(obj,m);
-					if (tex==NULL)		/* still NULL? then it couldn't get the texture. */
-					{
-/*						s3dprintf(VLOW,"no texture, using standard material...");*/
+					if (tex==NULL) {	/* still NULL? then it couldn't get the texture. */
+						/*						s3dprintf(VLOW,"no texture, using standard material...");*/
 						glBindTexture( GL_TEXTURE_2D,0);
-						matgl[0]=m->amb_r/2;		
-						matgl[1]=m->amb_g/2;		
+						matgl[0]=m->amb_r/2;
+						matgl[1]=m->amb_g/2;
 						matgl[2]=m->amb_b/2;
 						matgl[3]=m->amb_a;
-		 /* 				glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
+						/* 				glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
 						glMaterialfv(GL_FRONT,GL_AMBIENT,matgl);
 						matgl[0]=m->diff_r/2;
 						matgl[1]=m->diff_g/2;
 						matgl[2]=m->diff_b/2;
 						matgl[3]=m->diff_a;
-		 /* 				glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
+						/* 				glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
 						glMaterialfv(GL_FRONT,GL_DIFFUSE,matgl);
 						matgl[0]=m->spec_r/2;
 						matgl[1]=m->spec_g/2;
 						matgl[2]=m->spec_b/2;
 						matgl[3]=m->spec_a;
-		 /* 				glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
+						/* 				glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
 						glMaterialfv(GL_FRONT,GL_SPECULAR,matgl);
 					}
 				} else {
 					s3dprintf(MED,"something is wrong with polygon %d! material: [%d,%d]",pn, mat,obj->n_mat);
-					if (obj->dplist) glEndList();	glEnd();	glPopMatrix();
+					if (obj->dplist) glEndList();
+					glEnd();
+					glPopMatrix();
 					return(-1);
 				}
 			}
 			omat=mat;		 /*  saving old material */
 			glBegin(GL_TRIANGLES);
-			for (i=0; i<3; i++)
-				{
-					on=&(obj->p_poly[pn].n[i]);
-					glNormal3f(-on->x,-on->y,-on->z);
-					if (tex!=NULL)
-					{
-/*						s3dprintf(MED,"using texture coordinate (%f,%f) for polygon %d point %d",
-										obj->p_poly[pn].tc[i].x *tex->xs,
-										obj->p_poly[pn].tc[i].y *tex->ys,
-										pn,i);*/
+			for (i=0; i<3; i++) {
+				on=&(obj->p_poly[pn].n[i]);
+				glNormal3f(-on->x,-on->y,-on->z);
+				if (tex!=NULL) {
+					/*						s3dprintf(MED,"using texture coordinate (%f,%f) for polygon %d point %d",
+															obj->p_poly[pn].tc[i].x *tex->xs,
+															obj->p_poly[pn].tc[i].y *tex->ys,
+															pn,i);*/
 
-						glTexCoord2f(	obj->p_poly[pn].tc[i].x *tex->xs,
-										(obj->p_poly[pn].tc[i].y *tex->ys));
-					}
-					v= obj->p_poly[pn].v[i];  /*  ... get the vertices ... */
-					glVertex3f(obj->p_vertex[v].x, obj->p_vertex[v].y, obj->p_vertex[v].z);  /*  ...and draw them */
+					glTexCoord2f(	obj->p_poly[pn].tc[i].x *tex->xs,
+					              (obj->p_poly[pn].tc[i].y *tex->ys));
 				}
+				v= obj->p_poly[pn].v[i];  /*  ... get the vertices ... */
+				glVertex3f(obj->p_vertex[v].x, obj->p_vertex[v].y, obj->p_vertex[v].z);  /*  ...and draw them */
+			}
 			glEnd();
 		}
 		if (tex!=NULL)			glBindTexture( GL_TEXTURE_2D, 0);  /*  switch back to standard texture */
-		for (pn=0;pn<obj->n_line; pn++)
-		{
-			if (check_line_normal(obj,pn))
-			{
+		for (pn=0;pn<obj->n_line; pn++) {
+			if (check_line_normal(obj,pn)) {
 				s3dprintf(HIGH,"something is wrong with line %d!",pn);
-				if (obj->dplist) glEndList();	glPopMatrix(); /* clean up GL-stuff */
+				if (obj->dplist) glEndList();
+				glPopMatrix(); /* clean up GL-stuff */
 				return(-1);
 			}
 
@@ -1784,23 +1599,23 @@
 					m=&obj->p_mat[mat];
 					/* dont need to care about textures ...  it's rather impossible
 					 * to get some textures on a line. at least it would look ugly ;)*/
-					matgl[0]=m->amb_r/2;		
-					matgl[1]=m->amb_g/2;		
+					matgl[0]=m->amb_r/2;
+					matgl[1]=m->amb_g/2;
 					matgl[2]=m->amb_b/2;
 					matgl[3]=m->amb_a;
-		 /* 			glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
+					/* 			glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
 					glMaterialfv(GL_FRONT,GL_AMBIENT,matgl);
 					matgl[0]=m->diff_r/2;
 					matgl[1]=m->diff_g/2;
 					matgl[2]=m->diff_b/2;
 					matgl[3]=m->diff_a;
-		 /* 			glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
+					/* 			glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
 					glMaterialfv(GL_FRONT,GL_DIFFUSE,matgl);
 					matgl[0]=m->spec_r/2;
 					matgl[1]=m->spec_g/2;
 					matgl[2]=m->spec_b/2;
 					matgl[3]=m->spec_a;
-		 /* 			glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
+					/* 			glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
 					glMaterialfv(GL_FRONT,GL_SPECULAR,matgl);
 				} else {
 					s3dprintf(MED,"something is wrong with line %d! material: [%d,%d]",pn, mat,obj->n_mat);
@@ -1812,14 +1627,13 @@
 			}
 			omat=mat;		 /*  saving old material */
 			glBegin(GL_LINES);
-			for (i=0; i<2; i++)
-				{
-					on=&(obj->p_line[pn].n[i]);
-					glNormal3f(-on->x,-on->y,-on->z);
+			for (i=0; i<2; i++) {
+				on=&(obj->p_line[pn].n[i]);
+				glNormal3f(-on->x,-on->y,-on->z);
 
-					v= obj->p_line[pn].v[i];  /*  ... get the vertices ... */
-					glVertex3f(obj->p_vertex[v].x, obj->p_vertex[v].y, obj->p_vertex[v].z);  /*  ...and draw them */
-				}
+				v= obj->p_line[pn].v[i];  /*  ... get the vertices ... */
+				glVertex3f(obj->p_vertex[v].x, obj->p_vertex[v].y, obj->p_vertex[v].z);  /*  ...and draw them */
+			}
 			glEnd();
 		}
 		if (obj->dplist) glEndList();
@@ -1834,26 +1648,20 @@
 void link_delete(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o,*o2;
-	if (OBJ_VALID(p,oid,o))
-	{
+	if (OBJ_VALID(p,oid,o)) {
 		s3dprintf(VLOW,"link_delete(): [%d] unlinking %d from %d",p->id, oid, o->linkid);
-		if (o->linkid!=-1) 
-		{
+		if (o->linkid!=-1) {
 			if (o->lprev!=-1)
-				if (OBJ_VALID(p,o->lprev,o2))
-				{ /* we have a previous pointer linking to us */
+				if (OBJ_VALID(p,o->lprev,o2)) { /* we have a previous pointer linking to us */
 					o2->lnext=o->lnext; /* might also be -1 */
 				}
-			if (OBJ_VALID(p,o->linkid,o2))
-			{
-				if (o2->lsub==oid)
-				{/* parent is having oid as it's first link in chain */
-					o2->lsub=o->lnext; 
+			if (OBJ_VALID(p,o->linkid,o2)) {
+				if (o2->lsub==oid) {/* parent is having oid as it's first link in chain */
+					o2->lsub=o->lnext;
 				}
 			}
 			if (o->lnext!=-1)
-				if (OBJ_VALID(p,o->lnext,o2))
-				{ /* fixing next's previous pointer */
+				if (OBJ_VALID(p,o->lnext,o2)) { /* fixing next's previous pointer */
 					o2->lprev=o->lprev;
 				}
 		}
@@ -1867,17 +1675,16 @@
 void link_insert(struct t_process *p, int32_t oid, int32_t target)
 {
 	struct t_obj *o,*ot,*o2;
-	if (OBJ_VALID(p,oid,o) && OBJ_VALID(p,target,ot))
-	{
+	if (OBJ_VALID(p,oid,o) && OBJ_VALID(p,target,ot)) {
 		s3dprintf(VLOW,"link_insert(): [%d] linking %d to %d",p->id, oid, target);
 		o->oflags|=OF_LINK;
 		o->linkid=target;
 		o->lnext=ot->lsub; /* we have a new "first" element */
 		if (o->lnext!=-1) if (OBJ_VALID(p,o->lnext,o2))  /* if we already had an element
 														  in the chain, create the backlink */
-		{
-			o2->lprev=oid;
-		}
+			{
+				o2->lprev=oid;
+			}
 		ot->lsub=oid;
 	}
 }
@@ -1886,36 +1693,29 @@
 int obj_link(struct t_process *p, int32_t oid_from, int32_t oid_to)
 {
 	struct t_obj *o,*o2;
-	if (OBJ_VALID(p,oid_from,o) && OBJ_VALID(p,oid_to,o2))
-	{
-		if (oid_to==oid_from)
-		{
+	if (OBJ_VALID(p,oid_from,o) && OBJ_VALID(p,oid_to,o2)) {
+		if (oid_to==oid_from) {
 			errds(VHIGH,"obj_link()","can't link to itself!!");
 			return(-1);
 		}
-		if (OF_POINTER==(o->oflags&0xF0000000))
-		{
+		if (OF_POINTER==(o->oflags&0xF0000000)) {
 			errds(VHIGH,"obj_link()","may not change the link of a pointer");
 			return(-1);
 		}
 
-		while (o2->oflags&OF_LINK)
-		{
-			if (o2->linkid==oid_from)  /*  circular link!! we can't do that */
-			{
+		while (o2->oflags&OF_LINK) {
+			if (o2->linkid==oid_from) { /*  circular link!! we can't do that */
 				errds(VHIGH,"obj_link()","link from %d to %d would produce a circular link!",oid_from,oid_to);
 				return(-1);
 			}
 			o2=p->object[o2->linkid];  /*   move to the next object in the linkchain */
 		}
-		if ((o->oflags&OF_SYSTEM) && (p->id==MCP))
-		{
+		if ((o->oflags&OF_SYSTEM) && (p->id==MCP)) {
 			errds(VHIGH,"obj_link()","can't link system-objects in non-mcp-apps!");
 			return(-1);
 		}
- 		s3dprintf(VLOW,"[link|pid %d] %d -> %d",p->id, oid_from,oid_to); 
-		if (oid_to!=o->linkid) /* only if something changed ... */
-		{
+		s3dprintf(VLOW,"[link|pid %d] %d -> %d",p->id, oid_from,oid_to);
+		if (oid_to!=o->linkid) { /* only if something changed ... */
 			if (o->linkid!=-1)
 				link_delete(p,oid_from);
 			link_insert(p,oid_from,oid_to);
@@ -1930,10 +1730,8 @@
 int obj_unlink(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o;
-	if (OBJ_VALID(p,oid,o))
-	{
-		if (OF_POINTER==(o->oflags&0xF0000000))
-		{
+	if (OBJ_VALID(p,oid,o)) {
+		if (OF_POINTER==(o->oflags&0xF0000000)) {
 			errds(VHIGH,"obj_link()","may not change the link of a pointer");
 			return(-1);
 		}
@@ -1963,32 +1761,28 @@
 	obj->r=obj->or=0.0F;
 	obj->m_uptodate=0;
 	memcpy(obj->m,Identity,sizeof(t_mtrx));
-	 /*  fresh and clean ... */
-	if (p!=NULL)
-	{
-		 /*  look for an old object for reuse ... */
-		for (pos=0; pos < p->n_obj ; pos++)
-		{
-			if (p->object[pos]==NULL)
-			{
+	/*  fresh and clean ... */
+	if (p!=NULL) {
+		/*  look for an old object for reuse ... */
+		for (pos=0; pos < p->n_obj ; pos++) {
+			if (p->object[pos]==NULL) {
 				reuse=1;
 				break;
-/* 				s3dprintf(HIGH,"reusing position %d",pos); */
+				/* 				s3dprintf(HIGH,"reusing position %d",pos); */
 			}
 		}
-		if (!reuse)
-		{
+		if (!reuse) {
 			if (p->n_obj>0)
 				p->object=realloc(p->object,sizeof(struct t_obj *)*(p->n_obj+1));
 			else p->object=malloc(sizeof(struct t_obj *)*(p->n_obj+1));
 			pos=p->n_obj; 				 /*  add object at the end */
 			p->n_obj++;					 /*  increment counter */
 		}
-		p->object[pos]=obj;						
+		p->object[pos]=obj;
 		s3dprintf(VLOW,"pid %d added new object %d at %010p [pos %d]",p->id,pos,obj,pos);
 		return (pos);
 	} else {
-		s3dprintf(HIGH,"obj_new(): no such process %d",p->id);	
+		s3dprintf(HIGH,"obj_new(): no such process %d",p->id);
 		return(-1);
 	}
 }
@@ -2000,42 +1794,33 @@
 	struct t_obj *o,*no;
 	int already_clone,is_clnsrc;
 	int32_t i;
-	if (OBJ_VALID(p,oid,o) && OBJ_VALID(p,toid,no))
-	{
-		if ((o->oflags&OF_SYSTEM) || (no->oflags&OF_SYSTEM))
-		{
+	if (OBJ_VALID(p,oid,o) && OBJ_VALID(p,toid,no)) {
+		if ((o->oflags&OF_SYSTEM) || (no->oflags&OF_SYSTEM)) {
 			s3dprintf(MED,"can't clone from or to system objects");
 		}
-		 /*  get obj pointer and check for availability of the other object. */
-		if (((already_clone=(o->oflags&OF_CLONE)) || (!(o->n_vertex|o->n_mat|o->n_poly|o->n_tex))) && (!(o->oflags&OF_VIRTUAL)))
-		{
-			if (no->oflags&OF_CLONE)
-			{	 /*  target is clone */
+		/*  get obj pointer and check for availability of the other object. */
+		if (((already_clone=(o->oflags&OF_CLONE)) || (!(o->n_vertex|o->n_mat|o->n_poly|o->n_tex))) && (!(o->oflags&OF_VIRTUAL))) {
+			if (no->oflags&OF_CLONE) {	 /*  target is clone */
 				errds(VHIGH,"obj_clone_change()","couldn't clone %d from %d (on pid %d): clone target is already clone.",oid,toid,p->id,oid);
 				return(-1);
 			}
-			if (!already_clone)  /*  some other object could link to us, so we check the other objects and forward them just in case. */
-			{
-				if (p->object[oid]->oflags&OF_CLONE_SRC)
-				{
+			if (!already_clone) { /*  some other object could link to us, so we check the other objects and forward them just in case. */
+				if (p->object[oid]->oflags&OF_CLONE_SRC) {
 					is_clnsrc=0;
 					for (i=0;i<p->n_obj;i++)
 						if (p->object[i]!=NULL)
-							if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid))  /*  it's linking to our object! */
-							{
+							if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid)) { /*  it's linking to our object! */
 								errds(VHIGH,"obj_clone_change()","couldn't clone %d from %d (on pid %d): object %d is already cloning from object %d.",
-												oid,toid,p->id,oid,i,oid);
+								      oid,toid,p->id,oid,i,oid);
 								return(-1);
 							}
-					if (!is_clnsrc)
-					{
+					if (!is_clnsrc) {
 						s3dprintf(MED,"obj_clone_change(): %d in process %d is no longer a clone-source",oid,p->id);
 						p->object[oid]->oflags&=~OF_CLONE_SRC;
 					}
 				}
 			}
-			if (oid!=toid)
-			{  /*  don't looplink */
+			if (oid!=toid) { /*  don't looplink */
 				o->oflags|=OF_CLONE;
 				no->oflags|=OF_CLONE_SRC;
 				o->n_vertex=toid;  /*  n_vertex is not used for this as it's just cloned, so we can use it ... */
@@ -2066,41 +1851,32 @@
 	int32_t i;
 	int32_t mcp_oid=-1;
 	mcp_p=get_proc_by_pid(MCP);
-	if (OBJ_VALID(p,oid,o))
-	{
-		if (o->oflags&OF_SYSTEM)
-		{
+	if (OBJ_VALID(p,oid,o)) {
+		if (o->oflags&OF_SYSTEM) {
 			s3dprintf(HIGH,"can't delete system object!");
 			return(0);
 		}
 
 
-		if (p->id==MCP) 
-		{
-			if (o->oflags&OF_VIRTUAL)  /*  only delete if virtual */
-			{
+		if (p->id==MCP) {
+			if (o->oflags&OF_VIRTUAL) { /*  only delete if virtual */
 				s3dprintf(HIGH,"the mcp wants %d to be closed",o->n_mat);
 				event_quit(get_proc_by_pid(o->n_mat));
 				return(0);
 			}
-		} else 
+		} else
 			mcp_oid=p->mcp_oid;
 
-		if (OBJ_VALID(p,oid,o))
-		{
+		if (OBJ_VALID(p,oid,o)) {
 			obj_free(p,oid);
-			if ((p->id!=MCP) && (p->biggest_obj==oid))
-			{  /*  if object was the biggest object, find a new one. */
+			if ((p->id!=MCP) && (p->biggest_obj==oid)) { /*  if object was the biggest object, find a new one. */
 				mr=-1;
 				p->biggest_obj=-1;
 				for (i=0;i<p->n_obj;i++)
-					if (p->object[i]!=NULL)
-					{
+					if (p->object[i]!=NULL) {
 						r=p->object[i]->r+p->object[i]->or;
-						if (r>mr)
-						{
-							if (!(p->object[i]->oflags&OF_SYSTEM)) 
-							{
+						if (r>mr) {
+							if (!(p->object[i]->oflags&OF_SYSTEM)) {
 								p->biggest_obj=i;
 								mr=r;
 							}
@@ -2113,8 +1889,7 @@
 			if (o->oflags&OF_CLONE_SRC)
 				for (i=0;i<p->n_obj;i++)
 					if (p->object[i]!=NULL)
-						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid))  /*  it's linking to our object! */
-						{
+						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid)) { /*  it's linking to our object! */
 							p->object[i]->oflags&=~OF_CLONE;  	 /*  disable clone flag */
 							p->object[i]->n_vertex=0; 			 /*  and "clone reference" to 0 */
 							p->object[i]->r=0.0F;				 /*  empty object, so radius is zero! */
@@ -2136,29 +1911,24 @@
 
 	/* clearing links */
 	if (o->linkid!=-1)		link_delete(p,oid);
-	while (o->lsub!=-1)		
-	{
+	while (o->lsub!=-1) {
 		i=o->lsub;
 		link_delete(p,o->lsub);
-		if (i==o->lsub) 
-		{
+		if (i==o->lsub) {
 			s3dprintf(HIGH,"something is wrong!!");
 			o=NULL; /* segfault */
 			o->lsub=-1;
 		}
 	}
 
-	if (!(o->oflags&OF_NODATA))
-	{
+	if (!(o->oflags&OF_NODATA)) {
 		if (o->n_vertex>0) free(o->p_vertex);
 		if (o->n_poly>0) free(o->p_poly);
 		if (o->n_mat>0) free(o->p_mat);
-		for (i=0;i<o->n_tex;i++)
-		{
+		for (i=0;i<o->n_tex;i++) {
 			if (o->p_tex[i].buf!=NULL)
 				free(o->p_tex[i].buf);
-			if (o->p_tex[i].gl_texnum)
-			{
+			if (o->p_tex[i].gl_texnum) {
 				t=o->p_tex[i].gl_texnum;
 				glDeleteTextures(1,&t);
 			}
@@ -2166,18 +1936,15 @@
 		if (o->n_tex>0) free(o->p_tex);
 
 	}
-	if (o->dplist)
-	{
-		if (!(o->oflags&(OF_CLONE|OF_SYSTEM))) 
-		{
+	if (o->dplist) {
+		if (!(o->oflags&(OF_CLONE|OF_SYSTEM))) {
 			s3dprintf(VLOW,"freeing display list %d",o->dplist);
 			glDeleteLists(o->dplist,1);
 		}
 	}
 	free(o);
 	p->object[oid]=NULL;
-	if (oid==(p->n_obj-1))
-	{
+	if (oid==(p->n_obj-1)) {
 		i=oid;
 		while ((i!=-1) && (p->object[i]==NULL)) i--;
 		p->n_obj=i+1;
@@ -2189,11 +1956,9 @@
 int32_t get_pointer(struct t_process *p)
 {
 	int32_t i;
-	for (i=0;i<p->n_obj;i++)
-	{
+	for (i=0;i<p->n_obj;i++) {
 
-		if (OF_POINTER==(p->object[i]->oflags&0xF0000000))
-		{
+		if (OF_POINTER==(p->object[i]->oflags&0xF0000000)) {
 			return(i);
 		}
 	}

Modified: trunk/server/process.c
===================================================================
--- trunk/server/process.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/process.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * process.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,29 +35,25 @@
 int process_sys_init(struct t_process *p);
 
 /* protocol request for process initialization */
-struct t_process *process_protinit(struct t_process *p, char *name)
-{
+struct t_process *process_protinit(struct t_process *p, char *name) {
 	int con_type;
 	int32_t mcp_oid;
-	if ((strncmp(name,"sys_",4)==0))
-	{ /* we don't like "sys_"-apps, kicking this */
+	if ((strncmp(name,"sys_",4)==0)) { /* we don't like "sys_"-apps, kicking this */
 		errds(VHIGH,"process_protinit()","appnames starting with 'sys_' not allowed.");
 		return(NULL);
 	}
-	if ((p->id!=MCP) && (strncmp(name,"mcp",3)==0))
-	{
-		if (procs_p[MCP].con_type==CON_NULL)
-		{
+	if ((p->id!=MCP) && (strncmp(name,"mcp",3)==0)) {
+		if (procs_p[MCP].con_type==CON_NULL) {
 			s3dprintf(MED,"free mcp place, pid %d becoming mcp!",p->id);
 			con_type=p->con_type; /* move connection data */
-#ifdef TCP			
+#ifdef TCP
 			procs_p[MCP].sockid=p->sockid; /* don't save contype yet,
 									or p_del will notify mcp about a deleted
 									mcp-object (which is itselfs, actually) */
 #endif
 #ifdef SHM
 			memcpy(&procs_p[MCP].shmsock,&p->shmsock,sizeof(struct t_shmcb));
-#endif 
+#endif
 			p_del(p); /* deleting data/mcp object */
 			procs_p[MCP].con_type=con_type;
 			mcp_init();
@@ -71,19 +67,17 @@
 		strncpy(p->name, name, NAME_MAX);
 		process_sys_init(p);
 
-	/* register the new process in the mcp */
-		if (-1!=(mcp_oid= obj_new(&procs_p[MCP])))
-		{
+		/* register the new process in the mcp */
+		if (-1!=(mcp_oid= obj_new(&procs_p[MCP]))) {
 			mcp_p->object[mcp_oid]->oflags|=OF_VIRTUAL|OF_VISIBLE|OF_SELECTABLE;
 			mcp_p->object[mcp_oid]->n_mat=p->id;
-			
-	/* 		mcp_p->object[mcp_oid]->p_mat=(struct t_material *)new_p; */
-						/*  dirty, but it's just a pointer after all ... */
+
+			/* 		mcp_p->object[mcp_oid]->p_mat=(struct t_material *)new_p; */
+			/*  dirty, but it's just a pointer after all ... */
 			p->mcp_oid=mcp_oid;
 			s3dprintf(LOW,"process %d now has mcp_oid %d",p->id,mcp_oid);
 			mcp_rep_object(mcp_oid);
-			if (mcp_p->con_type==CON_NULL)
-			{  /*  there is no mcp connected! setting focus to the new program: */
+			if (mcp_p->con_type==CON_NULL) { /*  there is no mcp connected! setting focus to the new program: */
 				mcp_focus(mcp_oid);
 			}
 		} else {
@@ -99,8 +93,7 @@
 	struct t_obj *o;
 	cam=obj_new(p);
 	ptr=obj_new(p);
-	if (p->id==MCP)
-	{   /* this is only called once within process_init, later mcp's are
+	if (p->id==MCP) {   /* this is only called once within process_init, later mcp's are
 		   will be registered as "real" apps first */
 		p->object[cam]->translate.z=5;
 		p->object[cam]->oflags=OF_CAM;
@@ -110,9 +103,8 @@
 	} else {
 		/* TODO: ... get the cam and ptr position of the mcp, somehow */
 		p->object[cam]->oflags=OF_CAM;
-		
-		if (OBJ_VALID(mcp_p,get_pointer(mcp_p),o)) /* get parent pointer, copy parent */
-		{
+
+		if (OBJ_VALID(mcp_p,get_pointer(mcp_p),o)) { /* get parent pointer, copy parent */
 			p->object[ptr]->rotate.x=o->rotate.x;
 			p->object[ptr]->rotate.y=o->rotate.y;
 			p->object[ptr]->rotate.z=o->rotate.z;
@@ -127,26 +119,25 @@
 	s3dprintf(MED,"process_sys_init(): added object ptr0 %d",ptr);
 	obj_pos_update(get_proc_by_pid(MCP),cam,cam);
 	obj_pos_update(get_proc_by_pid(MCP),ptr,ptr);
-/*	obj_recalc_tmat(p,0);*/
+	/*	obj_recalc_tmat(p,0);*/
 	event_obj_info(p,0); /* tell the new program about the thing */
 
 	return(0);
 }
 
 /* this is to be called when a new connection appears. a pointer to the added process will be returned */
-struct t_process *process_add()
-{
+struct t_process *process_add() {
 	struct t_process *new_p;
 	procs_n++;
 	procs_p=realloc(procs_p,sizeof(struct t_process)*procs_n); /* increase the block */
 	new_p=&procs_p[procs_n-1];
 
 	new_p->id	  = procs_n-1;
-/*	if (new_p->id==0)
-		mcp_p=&procs_p[0];*/
+	/*	if (new_p->id==0)
+			mcp_p=&procs_p[0];*/
 	new_p->object = NULL;
 	new_p->n_obj  = 0;
-/*	new_p->netin  = 0;*/
+	/*	new_p->netin  = 0;*/
 	new_p->mcp_oid = -1;
 	new_p->biggest_obj=-1;
 	new_p->con_type=CON_NULL;	/* this is to be changed by the caller */
@@ -156,14 +147,12 @@
 /* deletes the process with pid */
 int process_del(int pid)
 {
-	if (pid==MCP)
-	{
+	if (pid==MCP) {
 		n_remove(&procs_p[pid]);
 		p_del(&procs_p[pid]);
 		return(0);
 	}
-	if ((pid>0) && (pid<procs_n))
-	{
+	if ((pid>0) && (pid<procs_n)) {
 		n_remove(&procs_p[pid]);
 		p_del(&procs_p[pid]);
 		process_list_rm(pid);
@@ -174,22 +163,20 @@
 /* just kick process out of the process list, no network/mcp-oid cleanup */
 int process_list_rm(int pid)
 {
-	if (pid!=(procs_n-1)) 
-	{ /* copy last block, swap pid */
+	if (pid!=(procs_n-1)) { /* copy last block, swap pid */
 		memcpy(&procs_p[pid],&procs_p[procs_n-1],sizeof(struct t_process));
 		procs_p[pid].id=pid; /* change the pid of the new procs_p */
 		if (procs_p[pid].mcp_oid!=-1) /* the last process could just appear without initializing yet ... */
-			procs_p[0].object[procs_p[pid].mcp_oid]->n_mat=pid; 
-			/* change the mcp-objects pid-pointer to the right position! */
-			/* this is kind of pointer madness */
+			procs_p[0].object[procs_p[pid].mcp_oid]->n_mat=pid;
+		/* change the mcp-objects pid-pointer to the right position! */
+		/* this is kind of pointer madness */
 	}
 	procs_n--;
 	procs_p=realloc(procs_p,sizeof(struct t_process)*procs_n); /* decrease the block,
 		wipe the last one */
 	return(0);
 }
-struct t_process *get_proc_by_pid(int pid)
-{
+struct t_process *get_proc_by_pid(int pid) {
 	if ((pid>=0) && (pid<procs_n))
 		return(&procs_p[pid]);
 	return(NULL);
@@ -199,15 +186,11 @@
 static int p_del(struct t_process *p)
 {
 	int j,i=p->n_obj;
-	if (p->id!=MCP)
-	{
-		if (p->mcp_oid!=-1)
-		{
+	if (p->id!=MCP) {
+		if (p->mcp_oid!=-1) {
 			for (j=0;j<mcp_p->n_obj;j++)	 /*  remove clones and links pointing on this app-object ... */
-				if (mcp_p->object[j]!=NULL)
-				{
-					if ((mcp_p->object[j]->oflags&OF_CLONE) && (mcp_p->object[j]->n_vertex == p->mcp_oid))  /*  it's linking to our object! */
-					{
+				if (mcp_p->object[j]!=NULL) {
+					if ((mcp_p->object[j]->oflags&OF_CLONE) && (mcp_p->object[j]->n_vertex == p->mcp_oid)) { /*  it's linking to our object! */
 						mcp_p->object[j]->oflags&=~OF_CLONE;  	 /*  disable clone flag */
 						mcp_p->object[j]->n_vertex=0; 			 /*  and "clone reference" to 0 */
 						mcp_p->object[j]->r=0.0F;				 /*  empty object, so radius is zero! */
@@ -217,20 +200,17 @@
 			mcp_del_object(p->mcp_oid); 	 /*  tell MCP that it's object is beeing deleted. */
 		} else /*
 			errs("p_del()","bad mcp_oid, unable to free mcp object");*/
-		if (i>0)
-		{
-			for (i=0;i<p->n_obj;i++)
-				if (p->object[i]) obj_free(p,i);
-			free(p->object);
-		}
-	}
-	else {
-		 /*  the mcp keeps in our memory ... */
-		 /*  so we just delete the objects added */
-		 /*  by the last mcp */
+			if (i>0) {
+				for (i=0;i<p->n_obj;i++)
+					if (p->object[i]) obj_free(p,i);
+				free(p->object);
+			}
+	} else {
+		/*  the mcp keeps in our memory ... */
+		/*  so we just delete the objects added */
+		/*  by the last mcp */
 		s3dprintf(MED,"clean up mcp's junk ...");
-		for (i=0;i<p->n_obj;i++)
-		{
+		for (i=0;i<p->n_obj;i++) {
 			if (p->object[i]!=NULL)
 				if (!(p->object[i]->oflags&(OF_SYSTEM|OF_VIRTUAL)))
 					obj_free(p,i);
@@ -242,7 +222,7 @@
 {
 	procs_n=0;
 	procs_p=NULL;
-	process_add(); 
+	process_add();
 	/* set up mcp */
 	strncpy(mcp_p->name,"mcp",NAME_MAX);
 	mcp_p->con_type=CON_NULL;
@@ -253,11 +233,10 @@
 {
 	int i;
 	s3dprintf(HIGH,"telling %d processes to go away",procs_n);
-	for (i=(procs_n-1);i>=0;i--)
-	{ 
+	for (i=(procs_n-1);i>=0;i--) {
 		s3dprintf(HIGH,"[QUIT] for %d",i);
 		event_quit(&procs_p[i]);
-/*		process_del(procs_p[i].id);*/
+		/*		process_del(procs_p[i].id);*/
 	}
 	free(procs_p);
 	return(0);

Modified: trunk/server/proto.c
===================================================================
--- trunk/server/proto.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/proto.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * proto.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,11 +27,11 @@
 /* #include <string.h>  / *  memcpy() * / */
 #include <stdlib.h>  /*  malloc() */
 #include <string.h>  /*  strncpy(),memset() */
-#ifdef WIN32 
+#ifdef WIN32
 #include <winsock2.h>
 #else
 #include <netinet/in.h>  /*  htonl(),htons() */
-#endif 
+#endif
 /*  this code should do the protocol work .... */
 /*  */
 extern uint8_t obuf[MAXPLEN];
@@ -53,347 +53,357 @@
 	uint8_t	type;
 	int32_t flags,mcp_oid=-1;
 	command=pbuf[0];
-	if (p->id!=0)
-	{
+	if (p->id!=0) {
 		mcp_oid=p->mcp_oid;		 /*  get mcp-oid if we need to report something to */
-								 /*  the mcp */
-		if ((mcp_oid==-1) && (command!=S3D_P_C_INIT))
-		{
+		/*  the mcp */
+		if ((mcp_oid==-1) && (command!=S3D_P_C_INIT)) {
 			s3dprintf(MED,"prot_com_in(): commands without beeing initialized ?! no way, kicking ...");
 			event_quit(p);
 		}
-	} 
+	}
 	length=ntohs(*((uint16_t *)((uint8_t *)pbuf+1)));
 	cptr=buf=pbuf+3;
-/* 	if (mcp_oid==-1) s3dprintf(HIGH,"couldn't find mcp-oid for pid %d!",p->id); */
-		switch (command) {
-			case S3D_P_C_INIT:
-				memset(name,0,NAME_MAX);
-				if (length>NAME_MAX) i=NAME_MAX; else i=length;
-				strncpy(name,(char *)buf,i);
-				s3dprintf(LOW,"[%d]\"%s\" logged in", p->id,name);
-				if (NULL==(np=process_protinit(p,name)))
-					event_quit(p);  /*  couldn't get process */
-				else
-					event_init(np);
-				break;
-			case S3D_P_C_NEW_OBJ:
-				oid=htonl(obj_new(p));
-/* 				s3dprintf(LOW,"pid %d registering new object %d",p->id,ntohl(oid)); */
-				prot_com_out(p,S3D_P_S_NEWOBJ,(uint8_t *)&oid, 4);
-				break;
-			case S3D_P_C_DEL_OBJ:
-				if (length==4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		
-					obj_del(p,oid);
-				}
-				break;
-			case S3D_P_C_CLONE:
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));
-					obj_clone_change(p,oid,toid);
-				}
-				break;
-			case S3D_P_C_LINK:
-				if (length==4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));
-					obj_unlink(p,oid);
-				}
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));
-					obj_link(p,oid,toid);
-				}
-				break;
-			case S3D_P_C_QUIT:
-				s3dprintf(LOW,"QUIT issued");
-				event_quit(p);
-				break;
-			case S3D_P_C_PUSH_VERTEX:
-				if (length>4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*3);
-/* 					s3dprintf(LOW,"received %d new vertices for object oid...%d", num, oid); */
-					obj_push_vertex(p,oid, (float  *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PUSH_MAT:
-				if (length>4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*12);
-/* 					s3dprintf(LOW,"received %d new materials for object oid...%d", num, oid); */
-					obj_push_mat(p,oid, (float *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PUSH_POLY:
-				if (length>4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*4);
-/* 					s3dprintf(LOW,"received %d new polygons for object oid...%d", num, oid); */
-					for (i=0;i<(num*4);i++)
-						*((uint32_t *)cptr+i)=
-								ntohl(*((uint32_t *)cptr+i));
-					 /*  convert index names */
-					obj_push_poly(p,oid, (uint32_t *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PUSH_LINE:
-				if (length>4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*3);
- 					s3dprintf(VLOW,"received %d new lines for object oid...%d", num, oid); 
-					for (i=0;i<(num*3);i++)
-						*((uint32_t *)cptr+i)=
-								ntohl(*((uint32_t *)cptr+i));
-					 /*  convert index names */
-					obj_push_line(p,oid, (uint32_t *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PUSH_TEX:
-				if (length>4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(2*2);
-					s3dprintf(LOW,"received %d new textures for object oid...%d", num, oid);
-					for (i=0;i<(num*2);i++)
-						*((uint16_t *)cptr+i)=
-								ntohs(*((uint16_t *)cptr+i));
-					 /*  convert index names */
-					obj_push_tex(p,oid, (uint16_t *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PEP_POLY_NORMAL:
-				if (length>4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(9*4);
-					s3dprintf(VLOW,"PEP_POLY_NORMAL[%d]: oid %d, %f polys",length,oid, (length-4)/(9.0*4.0));
-					obj_pep_poly_normal(p,oid, (float *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PEP_LINE_NORMAL:
-				if (length>4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(6*4);
-					s3dprintf(VLOW,"PEP_LINE_NORMAL[%d]: oid %d, %.1f lines",length,oid, (length-4)/(6.0*4.0));
-					obj_pep_line_normal(p,oid, (float *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PEP_POLY_TEXC:
-				if (length>4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(6*4);
-					s3dprintf(VLOW,"PEP_POLY_TEXC[%d]: oid %d, %f polys",length,oid, (length-4)/(6.0*4.0));
-					obj_pep_poly_texc(p,oid, (float *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PEP_MAT:
-				if (length>4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*12);
-					s3dprintf(VLOW,"PEP_MAT[%d]: %d materials for object oid...%d", length, num, oid);
-					obj_pep_mat(p,oid, (float *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PEP_VERTEX:
-				if (length>4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*3);
- 					s3dprintf(VLOW,"pepping %d new vertices for object oid...%d", num, oid); 
-					obj_pep_vertex(p,oid, (float  *)cptr, num);
-				}
-				break;
+	/* 	if (mcp_oid==-1) s3dprintf(HIGH,"couldn't find mcp-oid for pid %d!",p->id); */
+	switch (command) {
+	case S3D_P_C_INIT:
+		memset(name,0,NAME_MAX);
+		if (length>NAME_MAX) i=NAME_MAX;
+		else i=length;
+		strncpy(name,(char *)buf,i);
+		s3dprintf(LOW,"[%d]\"%s\" logged in", p->id,name);
+		if (NULL==(np=process_protinit(p,name)))
+			event_quit(p);  /*  couldn't get process */
+		else
+			event_init(np);
+		break;
+	case S3D_P_C_NEW_OBJ:
+		oid=htonl(obj_new(p));
+		/* 				s3dprintf(LOW,"pid %d registering new object %d",p->id,ntohl(oid)); */
+		prot_com_out(p,S3D_P_S_NEWOBJ,(uint8_t *)&oid, 4);
+		break;
+	case S3D_P_C_DEL_OBJ:
+		if (length==4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			obj_del(p,oid);
+		}
+		break;
+	case S3D_P_C_CLONE:
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			obj_clone_change(p,oid,toid);
+		}
+		break;
+	case S3D_P_C_LINK:
+		if (length==4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			obj_unlink(p,oid);
+		}
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			obj_link(p,oid,toid);
+		}
+		break;
+	case S3D_P_C_QUIT:
+		s3dprintf(LOW,"QUIT issued");
+		event_quit(p);
+		break;
+	case S3D_P_C_PUSH_VERTEX:
+		if (length>4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*3);
+			/* 					s3dprintf(LOW,"received %d new vertices for object oid...%d", num, oid); */
+			obj_push_vertex(p,oid, (float  *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PUSH_MAT:
+		if (length>4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*12);
+			/* 					s3dprintf(LOW,"received %d new materials for object oid...%d", num, oid); */
+			obj_push_mat(p,oid, (float *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PUSH_POLY:
+		if (length>4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*4);
+			/* 					s3dprintf(LOW,"received %d new polygons for object oid...%d", num, oid); */
+			for (i=0;i<(num*4);i++)
+				*((uint32_t *)cptr+i)=
+				        ntohl(*((uint32_t *)cptr+i));
+			/*  convert index names */
+			obj_push_poly(p,oid, (uint32_t *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PUSH_LINE:
+		if (length>4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*3);
+			s3dprintf(VLOW,"received %d new lines for object oid...%d", num, oid);
+			for (i=0;i<(num*3);i++)
+				*((uint32_t *)cptr+i)=
+				        ntohl(*((uint32_t *)cptr+i));
+			/*  convert index names */
+			obj_push_line(p,oid, (uint32_t *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PUSH_TEX:
+		if (length>4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(2*2);
+			s3dprintf(LOW,"received %d new textures for object oid...%d", num, oid);
+			for (i=0;i<(num*2);i++)
+				*((uint16_t *)cptr+i)=
+				        ntohs(*((uint16_t *)cptr+i));
+			/*  convert index names */
+			obj_push_tex(p,oid, (uint16_t *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PEP_POLY_NORMAL:
+		if (length>4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(9*4);
+			s3dprintf(VLOW,"PEP_POLY_NORMAL[%d]: oid %d, %f polys",length,oid, (length-4)/(9.0*4.0));
+			obj_pep_poly_normal(p,oid, (float *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PEP_LINE_NORMAL:
+		if (length>4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(6*4);
+			s3dprintf(VLOW,"PEP_LINE_NORMAL[%d]: oid %d, %.1f lines",length,oid, (length-4)/(6.0*4.0));
+			obj_pep_line_normal(p,oid, (float *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PEP_POLY_TEXC:
+		if (length>4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(6*4);
+			s3dprintf(VLOW,"PEP_POLY_TEXC[%d]: oid %d, %f polys",length,oid, (length-4)/(6.0*4.0));
+			obj_pep_poly_texc(p,oid, (float *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PEP_MAT:
+		if (length>4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*12);
+			s3dprintf(VLOW,"PEP_MAT[%d]: %d materials for object oid...%d", length, num, oid);
+			obj_pep_mat(p,oid, (float *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PEP_VERTEX:
+		if (length>4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*3);
+			s3dprintf(VLOW,"pepping %d new vertices for object oid...%d", num, oid);
+			obj_pep_vertex(p,oid, (float  *)cptr, num);
+		}
+		break;
 
-			case S3D_P_C_PEP_MAT_TEX:
-				if (length>4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4);
-					s3dprintf(VLOW,"PEP_MAT_TEX[%d]: %d materials for object oid...%d", length, num, oid);
-					obj_pep_mat_tex(p,oid, (uint32_t *)cptr, num);
-				}
-				break;
-			case S3D_P_C_PEP_LINE:
-				if (length>4)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-4)/(4*3);
- 					s3dprintf(VLOW,"pepping %d new lines for object oid...%d", num, oid); 
-					for (i=0;i<(num*3);i++)
-						*((uint32_t *)cptr+i)=
-								ntohl(*((uint32_t *)cptr+i));
-					obj_pep_line(p,oid, (uint32_t *)cptr, num);
-				}
-				break;
-			case S3D_P_C_LOAD_LINE_NORMAL:
-				if (length>8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-8)/(6*4);
-					s3dprintf(VLOW,"LOAD_POLY_NORMAL[%d]: oid %d, %.2f lines",length,oid, (length-8)/(6.0*4.0));
-					obj_load_line_normal(p,oid, (float *)cptr, toid, num);
-				}
-				break;
-			case S3D_P_C_LOAD_POLY_NORMAL:
-				if (length>8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-8)/(9*4);
-					s3dprintf(MED,"LOAD_POLY_NORMAL[%d]: oid %d, %f polys",length,oid, (length-8)/(9.0*4.0));
-					obj_load_poly_normal(p,oid, (float *)cptr, toid, num);
-				}
-				break;
-			case S3D_P_C_LOAD_POLY_TEXC:
-				if (length>8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-8)/(6*4);
-					s3dprintf(MED,"LOAD_POLY_TEXC[%d]: oid %d, %f polys",length,oid, (length-8)/(6.0*4.0));
-					obj_load_poly_texc(p,oid, (float *)cptr, toid, num);
-				}
-				break;
-			case S3D_P_C_LOAD_MAT:
-				if (length>8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=(length-8)/(4*12);
-					s3dprintf(LOW,"LOAD_MAT[%d]: %d materials for object oid...%d", length, num, oid);
-					obj_load_mat(p,oid, (float *)cptr, toid, num);
-				}
-				break;
-			case S3D_P_C_LOAD_TEX:
-				if (length>8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					toid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					x=ntohs(*((uint16_t *)cptr));			cptr+=2;
-					y=ntohs(*((uint16_t *)cptr));			cptr+=2;
-					w=ntohs(*((uint16_t *)cptr));			cptr+=2;
-					h=ntohs(*((uint16_t *)cptr));			cptr+=2;
-					num=length-16;
-	 /* 				s3dprintf(MED,"LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)",length, oid,toid,w,h,x,y,num,w*h*4,num); */
-					if ((w*h*4)==num)  /*  check correct size */
-						obj_load_tex(p,oid, toid, x, y, w, h, cptr);
-				}
-				break;
-			case S3D_P_C_DEL_VERTEX:
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=ntohl(*((uint32_t *)cptr));		cptr+=4;
-/* 					s3dprintf(LOW,"deleting %d vertices for object oid...%d", num, oid); */
-					obj_del_vertex(p,oid,num);
-				}
-				break;
-			case S3D_P_C_DEL_POLY:
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=ntohl(*((uint32_t *)cptr));		cptr+=4;
-/* 					s3dprintf(LOW,"deleting %d vertices for object oid...%d", num, oid); */
-					obj_del_poly(p,oid,num);
-				}	
-				break;
-			case S3D_P_C_DEL_LINE:
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=ntohl(*((uint32_t *)cptr));		cptr+=4;
- 					s3dprintf(VLOW,"deleting %d lines for object oid...%d", num, oid); 
-					obj_del_line(p,oid,num);
-				}	
-				break;
+	case S3D_P_C_PEP_MAT_TEX:
+		if (length>4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4);
+			s3dprintf(VLOW,"PEP_MAT_TEX[%d]: %d materials for object oid...%d", length, num, oid);
+			obj_pep_mat_tex(p,oid, (uint32_t *)cptr, num);
+		}
+		break;
+	case S3D_P_C_PEP_LINE:
+		if (length>4) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-4)/(4*3);
+			s3dprintf(VLOW,"pepping %d new lines for object oid...%d", num, oid);
+			for (i=0;i<(num*3);i++)
+				*((uint32_t *)cptr+i)=
+				        ntohl(*((uint32_t *)cptr+i));
+			obj_pep_line(p,oid, (uint32_t *)cptr, num);
+		}
+		break;
+	case S3D_P_C_LOAD_LINE_NORMAL:
+		if (length>8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-8)/(6*4);
+			s3dprintf(VLOW,"LOAD_POLY_NORMAL[%d]: oid %d, %.2f lines",length,oid, (length-8)/(6.0*4.0));
+			obj_load_line_normal(p,oid, (float *)cptr, toid, num);
+		}
+		break;
+	case S3D_P_C_LOAD_POLY_NORMAL:
+		if (length>8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-8)/(9*4);
+			s3dprintf(MED,"LOAD_POLY_NORMAL[%d]: oid %d, %f polys",length,oid, (length-8)/(9.0*4.0));
+			obj_load_poly_normal(p,oid, (float *)cptr, toid, num);
+		}
+		break;
+	case S3D_P_C_LOAD_POLY_TEXC:
+		if (length>8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-8)/(6*4);
+			s3dprintf(MED,"LOAD_POLY_TEXC[%d]: oid %d, %f polys",length,oid, (length-8)/(6.0*4.0));
+			obj_load_poly_texc(p,oid, (float *)cptr, toid, num);
+		}
+		break;
+	case S3D_P_C_LOAD_MAT:
+		if (length>8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=(length-8)/(4*12);
+			s3dprintf(LOW,"LOAD_MAT[%d]: %d materials for object oid...%d", length, num, oid);
+			obj_load_mat(p,oid, (float *)cptr, toid, num);
+		}
+		break;
+	case S3D_P_C_LOAD_TEX:
+		if (length>8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			toid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			x=ntohs(*((uint16_t *)cptr));
+			cptr+=2;
+			y=ntohs(*((uint16_t *)cptr));
+			cptr+=2;
+			w=ntohs(*((uint16_t *)cptr));
+			cptr+=2;
+			h=ntohs(*((uint16_t *)cptr));
+			cptr+=2;
+			num=length-16;
+			/* 				s3dprintf(MED,"LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)",length, oid,toid,w,h,x,y,num,w*h*4,num); */
+			if ((w*h*4)==num)  /*  check correct size */
+				obj_load_tex(p,oid, toid, x, y, w, h, cptr);
+		}
+		break;
+	case S3D_P_C_DEL_VERTEX:
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			/* 					s3dprintf(LOW,"deleting %d vertices for object oid...%d", num, oid); */
+			obj_del_vertex(p,oid,num);
+		}
+		break;
+	case S3D_P_C_DEL_POLY:
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			/* 					s3dprintf(LOW,"deleting %d vertices for object oid...%d", num, oid); */
+			obj_del_poly(p,oid,num);
+		}
+		break;
+	case S3D_P_C_DEL_LINE:
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			s3dprintf(VLOW,"deleting %d lines for object oid...%d", num, oid);
+			obj_del_line(p,oid,num);
+		}
+		break;
 
-			case S3D_P_C_DEL_MAT:
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=ntohl(*((uint32_t *)cptr));		cptr+=4;
-/* 					s3dprintf(LOW,"deleting %d materials for object oid...%d", num, oid); */
-					obj_del_mat(p,oid,num);
-				}
-				break;
-			case S3D_P_C_DEL_TEX:
-				if (length==8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					num=ntohl(*((uint32_t *)cptr));		cptr+=4;
-/* 					s3dprintf(LOW,"deleting %d textures for object oid...%d", num, oid); */
-					obj_del_tex(p,oid,num);
-				}
-				break;
-			case S3D_P_C_TOGGLE_FLAGS:
-				if (length==9)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					type=*cptr;								cptr+=1;
-					flags=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					obj_toggle_flags(p,oid, type, flags);
-				}
-				break;
-			case S3D_P_C_TRANSLATE:
-				if (length>=16)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					obj_translate(p,oid,(float *)cptr);
-				}
-				break;
-			case S3D_P_C_ROTATE:
-				if (length>=16)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					obj_rotate(p,oid,(float *)cptr);
-				}
-				break;
-			case S3D_P_C_SCALE:
-				if (length>=8)
-				{
-					oid=ntohl(*((uint32_t *)cptr));		cptr+=4;
-					obj_scale(p,oid,*((float *)cptr));
-				}
-				break;
-			case S3D_P_MCP_FOCUS:
-				if ((p->id==MCP) && (length==4))
-				{
-					oid=ntohl(*((uint32_t *)cptr));
-					mcp_focus(oid);	
-				}
-				break;
-			default:
-				s3dprintf(LOW,"don't know this command (%d)",command);
+	case S3D_P_C_DEL_MAT:
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			/* 					s3dprintf(LOW,"deleting %d materials for object oid...%d", num, oid); */
+			obj_del_mat(p,oid,num);
 		}
+		break;
+	case S3D_P_C_DEL_TEX:
+		if (length==8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			num=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			/* 					s3dprintf(LOW,"deleting %d textures for object oid...%d", num, oid); */
+			obj_del_tex(p,oid,num);
+		}
+		break;
+	case S3D_P_C_TOGGLE_FLAGS:
+		if (length==9) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			type=*cptr;
+			cptr+=1;
+			flags=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			obj_toggle_flags(p,oid, type, flags);
+		}
+		break;
+	case S3D_P_C_TRANSLATE:
+		if (length>=16) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			obj_translate(p,oid,(float *)cptr);
+		}
+		break;
+	case S3D_P_C_ROTATE:
+		if (length>=16) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			obj_rotate(p,oid,(float *)cptr);
+		}
+		break;
+	case S3D_P_C_SCALE:
+		if (length>=8) {
+			oid=ntohl(*((uint32_t *)cptr));
+			cptr+=4;
+			obj_scale(p,oid,*((float *)cptr));
+		}
+		break;
+	case S3D_P_MCP_FOCUS:
+		if ((p->id==MCP) && (length==4)) {
+			oid=ntohl(*((uint32_t *)cptr));
+			mcp_focus(oid);
+		}
+		break;
+	default:
+		s3dprintf(LOW,"don't know this command (%d)",command);
+	}
 	return(0);
 }
 /*  this pushes some buffer out on the wire... */
 int prot_com_out(struct t_process *p, uint8_t opcode, uint8_t *buf, uint16_t length)
 {
 	uint8_t *ptr;
-	if (p->con_type!=CON_NULL)
-	{
-		*(obuf)=opcode; 
+	if (p->con_type!=CON_NULL) {
+		*(obuf)=opcode;
 		ptr=obuf+1;
 		*((uint16_t *) ptr)=htons(length);
 		if (length)
 			memcpy(obuf+3,buf,length);
-		if (n_writen(p,obuf,length+3)<0)
-		{
+		if (n_writen(p,obuf,length+3)<0) {
 			s3dprintf(LOW,"prot_com_out():n_writen(): connection seems to be dead (pid %d)", p->id);
 			process_del(p->id);
 		}

Modified: trunk/server/proto.h
===================================================================
--- trunk/server/proto.h	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/proto.h	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * proto.h
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -35,150 +35,150 @@
 /*  */
 /*  every command is 1 byte long, arguments differ. */
 #define S3D_P_C_INIT			1
-			/*  max 256b: 	name */
+/*  max 256b: 	name */
 #define S3D_P_C_QUIT			2  /*  no argument */
 
 #define S3D_P_C_NEW_OBJ			3  /*  add a new object */
-			 /*  return: 4b:	object id  */
+/*  return: 4b:	object id  */
 #define S3D_P_C_DEL_OBJ			4
-			 /*  4b:			object id */
+/*  4b:			object id */
 #define S3D_P_C_CLONE			5
-			 /*  4b:			object id */
-			 /*  return: 4b: object id */
-			 /*  if 8b: 		 */
-			 /*  4b:			object id */
-			 /*  4b:			target oid */
+/*  4b:			object id */
+/*  return: 4b: object id */
+/*  if 8b: 		 */
+/*  4b:			object id */
+/*  4b:			target oid */
 #define S3D_P_C_LINK			6
-			 /*  if 4b: */
-			 /*  4b:		oid (for unlink) */
-			 /*  if 8b: */
-			 /*  4b:		oid from */
-			 /*  4b:		oid to */
+/*  if 4b: */
+/*  4b:		oid (for unlink) */
+/*  if 8b: */
+/*  4b:		oid from */
+/*  4b:		oid to */
 #define S3D_P_C_PUSH_LINE		7
-			 /*  4b: 		object id */
-			 /*  n*3d		from vertex, to vertex, color */
+/*  4b: 		object id */
+/*  n*3d		from vertex, to vertex, color */
 #define S3D_P_C_PUSH_VERTEX		8
-			 /*  4b:		object id */
-			 /*  n*3f:	vertexes, each with x,y,z in float */
+/*  4b:		object id */
+/*  n*3f:	vertexes, each with x,y,z in float */
 #define S3D_P_C_PUSH_MAT		9
-			 /*  4b:		object id */
-			 /*  3*4f:	material elements [amb,spec,diff with r,g,b,a] */
+/*  4b:		object id */
+/*  3*4f:	material elements [amb,spec,diff with r,g,b,a] */
 #define S3D_P_C_PUSH_POLY		10
-			 /*  4b:		object id */
+/*  4b:		object id */
 #define S3D_P_C_PUSH_TEX		11
-			 /*  4b: 			object id */
-			 /*  nx(2x2b):	width,height */
+/*  4b: 			object id */
+/*  nx(2x2b):	width,height */
 #define S3D_P_C_DEL_VERTEX		12
-			 /*  4b:		object id */
-			 /*  4b:		number */
+/*  4b:		object id */
+/*  4b:		number */
 #define S3D_P_C_DEL_POLY		13
-			 /*  4b:		object id */
-			 /*  4b:		number */
+/*  4b:		object id */
+/*  4b:		number */
 #define S3D_P_C_DEL_MAT			14
-			 /*  4b:		object id */
-			 /*  4b:		number */
+/*  4b:		object id */
+/*  4b:		number */
 #define S3D_P_C_DEL_TEX			15
-			 /*  4b:		object id */
-			 /*  4b:		number */
+/*  4b:		object id */
+/*  4b:		number */
 #define S3D_P_C_PEP_POLY_NORMAL	16
-			 /*  4b:		object id */
-			 /*  n*9f:		normals (3* x/y/z for each vertex of the poly) */
+/*  4b:		object id */
+/*  n*9f:		normals (3* x/y/z for each vertex of the poly) */
 #define S3D_P_C_PEP_POLY_TEXC	17
-			 /*  4b:		object id */
-			 /*  n*6f		poly texture coordinates (3* u/v for each vertex of the poly) */
+/*  4b:		object id */
+/*  n*6f		poly texture coordinates (3* u/v for each vertex of the poly) */
 #define S3D_P_C_PEP_MAT			18
-			 /*  4b:		object id */
-			 /*  3*4f:		material elements [amb,spec,diff with r,g,b,a] */
+/*  4b:		object id */
+/*  3*4f:		material elements [amb,spec,diff with r,g,b,a] */
 #define S3D_P_C_PEP_MAT_TEX		19
-			 /*  4b:		object id */
-			 /*  4b:		texture index references */
+/*  4b:		object id */
+/*  4b:		texture index references */
 #define S3D_P_C_PEP_VERTEX		20
-			 /*  4b:		object id */
-			 /*  n*3f:	vertexes, each with x,y,z in float */
+/*  4b:		object id */
+/*  n*3f:	vertexes, each with x,y,z in float */
 #define S3D_P_C_PEP_LINE		21
-			 /* 4b:			object id */
-			 /* n*3u:		line information (from,to,color)*/
+/* 4b:			object id */
+/* n*3u:		line information (from,to,color)*/
 #define S3D_P_C_DEL_LINE		22
-			 /*  4b:		object id */
-			 /*  4b:		number */
+/*  4b:		object id */
+/*  4b:		number */
 #define S3D_P_C_PEP_LINE_NORMAL	23
-			 /*  4b:		object id */
-			 /*  n*6f:		normals (2* x/y/z for each vertex of the line) */
+/*  4b:		object id */
+/*  n*6f:		normals (2* x/y/z for each vertex of the line) */
 #define S3D_P_C_LOAD_POLY_NORMAL	24
-			 /*  4b:		object id */
-			 /*  4b:		position */
-			 /*  n*9f:	normals (3* x/y/z for each vertex of the poly) */
+/*  4b:		object id */
+/*  4b:		position */
+/*  n*9f:	normals (3* x/y/z for each vertex of the poly) */
 #define S3D_P_C_LOAD_POLY_TEXC	25
-			 /*  4b:		object id */
-			 /*  4b:		position */
-			 /*  n*6f		poly texture coordinates (3* u/v for each vertex of the poly) */
+/*  4b:		object id */
+/*  4b:		position */
+/*  n*6f		poly texture coordinates (3* u/v for each vertex of the poly) */
 #define S3D_P_C_LOAD_MAT		26
-			 /*  4b:		object id */
-			 /*  4b:		position */
-			 /*  3*4f:	material elements [amb,spec,diff with r,g,b,a] */
+/*  4b:		object id */
+/*  4b:		position */
+/*  3*4f:	material elements [amb,spec,diff with r,g,b,a] */
 #define S3D_P_C_LOAD_TEX		28
-			 /*  4b:		object id */
-			 /*  4b:		texture number */
-			 /*  4*2b:	xpos,ypos,width,height */
-			 /*  n*2b:	pixbuf (16bit) */
+/*  4b:		object id */
+/*  4b:		texture number */
+/*  4*2b:	xpos,ypos,width,height */
+/*  n*2b:	pixbuf (16bit) */
 #define S3D_P_C_LOAD_MAT_TEX	29
-			 /*  4b:		object id */
-			 /*  4b:		texture index references */
+/*  4b:		object id */
+/*  4b:		texture index references */
 #define S3D_P_C_LOAD_LINE_NORMAL 30
-			 /*  4b:		object id */
-			 /*  4b:		position */
-			 /*  n*6f:		normals (2* x/y/z for each vertex of the line) */
+/*  4b:		object id */
+/*  4b:		position */
+/*  n*6f:		normals (2* x/y/z for each vertex of the line) */
 
 
 #define S3D_P_C_TOGGLE_FLAGS 	32
-			 /*  4b:		object id */
-			 /*  1b:		type  */
-			 /*  4b:		flags */
+/*  4b:		object id */
+/*  1b:		type  */
+/*  4b:		flags */
 #define S3D_P_C_TRANSLATE 		33
-			 /*  4b:		object id */
-			 /*  3f:		position */
+/*  4b:		object id */
+/*  3f:		position */
 #define S3D_P_C_ROTATE			34
-			 /*  4b:		object id */
-			 /*  3f:		rotation angle over x,y,z axis */
+/*  4b:		object id */
+/*  3f:		rotation angle over x,y,z axis */
 #define S3D_P_C_SCALE			35
-			 /*  4b: 		object id */
-			 /*  1f:		scale */
+/*  4b: 		object id */
+/*  1f:		scale */
 #define S3D_P_C_GET_SIZE		36
-			   /*  4b: object id */
+/*  4b: object id */
 #define S3D_P_MCP_FOCUS			66		 /*  set the app which should get the keystrokes etc */
-			 /*  4b:		object id/pid */
-			 /*  */
-			 /*  */
-			 /*   */
+/*  4b:		object id/pid */
+/*  */
+/*  */
+/*   */
 #define S3D_P_MCP_OBJECT	67
-			 /*  4b: 		oid */
-			 /*  3*f:		translate */
-			 /*  ... ? */
-			 /*  max 256b:name */
+/*  4b: 		oid */
+/*  3*f:		translate */
+/*  ... ? */
+/*  max 256b:name */
 #define S3D_P_MCP_DEL_OBJECT 68
 
 #define S3D_P_S_INIT	1
-			 /*  1b: acknowledged */
-			 /*  3b: version,major,minor */
-			 /*  description string */
+/*  1b: acknowledged */
+/*  3b: version,major,minor */
+/*  description string */
 #define S3D_P_S_QUIT	2
 #define S3D_P_S_CLICK	3
-			 /*  4b: oid */
+/*  4b: oid */
 #define	S3D_P_S_KEY		4
-			 /*  2b: button */
-			 /*  2b: unicode translation */
-			 /*  2b: modifier information */
-			 /*  2b: state */
+/*  2b: button */
+/*  2b: unicode translation */
+/*  2b: modifier information */
+/*  2b: state */
 #define S3D_P_S_MBUTTON	5
-             /*  1b: button number */
-             /*  2b: butotn state */
+/*  1b: button number */
+/*  2b: butotn state */
 #define S3D_P_S_NEWOBJ	16
-			 /*  4b: oid */
+/*  4b: oid */
 
 #define S3D_P_S_OINFO	32
-			 /*  4b: 		oid */
-			 /*  3*f:		translate */
-			 /*  3*f:		rotate */
-			 /*  1*f:		scale */
-			 /*  1*f:		radius */
-			 /*  max 256b:name */
+/*  4b: 		oid */
+/*  3*f:		translate */
+/*  3*f:		rotate */
+/*  1*f:		scale */
+/*  1*f:		radius */
+/*  max 256b:name */

Modified: trunk/server/shm.c
===================================================================
--- trunk/server/shm.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/shm.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * shm.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -34,9 +34,9 @@
 #include <signal.h>	/* signal() */
 #include <errno.h>	/* errno */
 #ifdef WIN32  /*  sohn wars */
-	#include <winsock2.h>
+#include <winsock2.h>
 #else  /* sohn wars */
-	#include <netinet/in.h>  /* ntohs(),htons(),htonl(),ntohl() */
+#include <netinet/in.h>  /* ntohs(),htons(),htonl(),ntohl() */
 #endif   /*  sohn wars */
 #include <sys/types.h>
 #include <sys/ipc.h>
@@ -63,7 +63,7 @@
 {
 	FILE *fp;
 	key_t key;
-	
+
 	/* create an empty token file */
 	fp=fopen(ftoken,"w");
 	fclose(fp);
@@ -87,7 +87,7 @@
 		return(1);
 	}
 	shm_new_comblock(data);
-	return(0);	
+	return(0);
 }
 void comblock_init(struct t_shmcb *p_cb)
 {
@@ -137,7 +137,7 @@
 	data[1]=mycb->key_stoc;
 	mycb->idle=0;
 	s3dprintf(LOW,"shm_open_comblock():data: %08x, %08x",data[0],data[1]);
-	return(0);	
+	return(0);
 }
 
 int shm_quit()
@@ -145,14 +145,13 @@
 	/* detach from the segment: */
 	s3dprintf(LOW,"shm_quit()...");
 	unlink(ftoken);
-	if (data!=NULL)
-	{
+	if (data!=NULL) {
 		data[0]=data[1]=0;
 		data=0;
 		s3dprintf(MED,"shm_quit():removing init block");
-		if (shmdt(data) == -1) 
+		if (shmdt(data) == -1)
 			errn("shm_quit():shmdt()",errno);
-		if (shmctl(shmid, IPC_RMID, NULL) == -1) 
+		if (shmctl(shmid, IPC_RMID, NULL) == -1)
 			errn("shm_quit():shmctl()",errno);
 	}
 	return(0);
@@ -161,13 +160,13 @@
 {
 	s3dprintf(MED,"shm_remove(): removing pid %d",p->id);
 	s3dprintf(MED,"shm_remove():freeing keys: %08x, %08x",p->shmsock.key_ctos,p->shmsock.key_stoc);
-	if (shmdt(p->shmsock.data_ctos) == -1) 
+	if (shmdt(p->shmsock.data_ctos) == -1)
 		errn("shm_rmove():shmdt()",errno);
-	if (shmctl(p->shmsock.shmid_ctos, IPC_RMID, NULL) == -1) 
+	if (shmctl(p->shmsock.shmid_ctos, IPC_RMID, NULL) == -1)
 		errn("shm_quit():shmctl()",errno);
-	if (shmdt(p->shmsock.data_stoc) == -1) 
+	if (shmdt(p->shmsock.data_stoc) == -1)
 		errn("shm_quit():shmdt()",errno);
-	if (shmctl(p->shmsock.shmid_stoc, IPC_RMID, NULL) == -1) 
+	if (shmctl(p->shmsock.shmid_stoc, IPC_RMID, NULL) == -1)
 		errn("shm_quit():shmctl()",errno);
 	return(0);
 }
@@ -179,20 +178,18 @@
 	struct buf_t 		*dai; /* data in, data out */
 	struct t_process	*new_p;
 	struct shmid_ds		 d;
-/*	do*/ {
-/*		found=0;*/
+	/*	do*/
+	{
+		/*		found=0;*/
 		turn=1;
-		for (i=0;i<procs_n;i++)
-		{
+		for (i=0;i<procs_n;i++) {
 #ifdef G_SDL
 			SDL_SetTimer(100,(SDL_TimerCallback) net_turn_off);
 #endif
-			if (procs_p[i].con_type==CON_SHM)
-			{
+			if (procs_p[i].con_type==CON_SHM) {
 				dai=(struct buf_t *) procs_p[i].shmsock.data_ctos;
-				if (dai->start!=dai->end)
-				{
-/*					found=1;*/
+				if (dai->start!=dai->end) {
+					/*					found=1;*/
 					procs_p[i].shmsock.idle=0;
 					shm_prot_com_in(&procs_p[i]);
 					if (turn)
@@ -202,11 +199,9 @@
 						turn=1; /* don't decrease, it's next connections turn */
 					}
 				} else {
-					if (procs_p[i].shmsock.idle++>MAX_IDLE)
-					{ /* maybe the function timed out somehow ...? let's check ...*/
+					if (procs_p[i].shmsock.idle++>MAX_IDLE) { /* maybe the function timed out somehow ...? let's check ...*/
 						shmctl(procs_p[i].shmsock.shmid_ctos,IPC_STAT,&d);
-						if (d.shm_nattch==1) /* we're all alone ... remove it!! */
-						{
+						if (d.shm_nattch==1) { /* we're all alone ... remove it!! */
 							s3dprintf(MED,"client [%s] detached, removing ... ",procs_p[i].name);
 							process_del(procs_p[i].id);
 						} else {
@@ -220,8 +215,7 @@
 		SDL_SetTimer(0,NULL);
 #endif
 	} /*while (found);*/
-	if ((data[0]==0) && (data[1]==0))
-	{
+	if ((data[0]==0) && (data[1]==0)) {
 		new_p=process_add();
 		new_p->con_type=CON_SHM;
 		memcpy(&new_p->shmsock,&waiting_comblock,sizeof(struct t_shmcb));
@@ -238,38 +232,36 @@
 	struct buf_t *dai;
 	dai=(struct buf_t *)p->shmsock.data_ctos;
 	if (dai!=NULL)
-/*	if ((pid=get_proc_by_dai( */
-	if (3==shm_readn(dai,ibuf,3))
-	{
-		length=ntohs(*((uint16_t *)((uint8_t *)ibuf+1)));
-		s3dprintf(VLOW,"command %d, length %d",ibuf[0], length);
-		if (length>0)
-		{
-			shm_readn(dai,ibuf+3,length);	  
+		/*	if ((pid=get_proc_by_dai( */
+		if (3==shm_readn(dai,ibuf,3)) {
+			length=ntohs(*((uint16_t *)((uint8_t *)ibuf+1)));
+			s3dprintf(VLOW,"command %d, length %d",ibuf[0], length);
+			if (length>0) {
+				shm_readn(dai,ibuf+3,length);
+			}
+			prot_com_in(p,ibuf);
 		}
-		prot_com_in(p,ibuf);
-	}
 	return(0);
 }
 #define SHM_MAXLOOP		20
-static	struct timespec t={0,1000*1000}; /* 1 mili seconds */
+static	struct timespec t= {
+	0,1000*1000
+}; /* 1 mili seconds */
 int shm_writen(struct buf_t *rb,uint8_t *buf, int n)
 {
 	int no_left,no_written,wait=0;
 	no_left = n;
-	while (no_left > 0) 
-    { 
+	while (no_left > 0) {
 		no_written = shm_write(rb,(char *)buf,no_left);
- 		if(no_written <=0)  
+		if (no_written <=0)
 			return(no_written);
 		no_left -= no_written;
 		buf += no_written;
-		if (wait++>SHM_MAXLOOP) 
-		{
+		if (wait++>SHM_MAXLOOP) {
 			s3dprintf(HIGH,"shm_writen():waited too long ...");
 			return(-1);
-		} 
-		if (wait>10)		nanosleep(&t,NULL); 	
+		}
+		if (wait>10)		nanosleep(&t,NULL);
 	}
 	return(n - no_left);
 }
@@ -277,21 +269,19 @@
 {
 	int no_left,no_read,wait=0;
 	no_left = n;
-	while (no_left > 0) 
-	{ 
+	while (no_left > 0) {
 		no_read = shm_read(rb,(char *)buf,no_left);
-		if(no_read <0)  
+		if (no_read <0)
 			return(no_read);
-		if (no_read == 0) 
+		if (no_read == 0)
 			break;
 		no_left -= no_read;
 		buf += no_read;
-		if (wait++>SHM_MAXLOOP) 
-		{
+		if (wait++>SHM_MAXLOOP) {
 			s3dprintf(HIGH,"shm_readn():waited too long ...");
 			return(-1);
 		}
-		if (wait>10)		nanosleep(&t,NULL); 	
+		if (wait>10)		nanosleep(&t,NULL);
 	}
 	return(n - no_left);
 }

Modified: trunk/server/shm_ringbuf.c
===================================================================
--- trunk/server/shm_ringbuf.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/shm_ringbuf.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * shm_ringbuf.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -39,31 +39,28 @@
 	data=((char *)rb)+sizeof(struct buf_t);
 	if (e<s) {
 		wrap=1;
-	} 
-	while ((((s+size*(1-wrap))-e) < (n+1))) /* checking free space */
-	{
-		if /*((size*2)>RB_MAX_SIZE)*/ (1)
-		{
+	}
+	while ((((s+size*(1-wrap))-e) < (n+1))) { /* checking free space */
+		if /*((size*2)>RB_MAX_SIZE)*/ (1) {
 			printf("buffer reached maxsize, no resizing possible");
 			return(-1);
 		}
-/*		printf("buffer full!! resizing ... (to size %d)",(int)size*2);
-		if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
-		{
-			printf("realloc failed - fatal!!");
-			return(-1);
-		}
-		if (wrap)
-		{
-			memcpy(data+size,data,e);
-			e+=size;
-			wrap=0;
-		}
-		size=rb->bufsize=size*2;
-		rb->end=e;*/
+		/*		printf("buffer full!! resizing ... (to size %d)",(int)size*2);
+				if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
+				{
+					printf("realloc failed - fatal!!");
+					return(-1);
+				}
+				if (wrap)
+				{
+					memcpy(data+size,data,e);
+					e+=size;
+					wrap=0;
+				}
+				size=rb->bufsize=size*2;
+				rb->end=e;*/
 	}
-	if ((e+n)>size)
-	{
+	if ((e+n)>size) {
 		rs=size-e;
 		memcpy(data+e,buf,rs);			/* copy the first part ... */
 		memcpy(data,buf+rs,n-rs); 		/* .. end the rest */
@@ -89,8 +86,7 @@
 	if (e<s) wrap=1;
 	rs=(e+wrap*size-s);
 	mn=(n>rs)?rs:n;
-	if ((wrap) && (mn>(size-s))) 
-	{
+	if ((wrap) && (mn>(size-s))) {
 		rs=size-s;	/* size of the first part */
 		memcpy(buf,data+s,rs);
 		memcpy(buf+rs,data,mn-rs);
@@ -104,11 +100,11 @@
 void ringbuf_init(char *data,uint32_t init_size)
 {
 	struct buf_t *ringbuf=(struct buf_t *)data;
-/*	ringbuf=malloc(init_size); */
+	/*	ringbuf=malloc(init_size); */
 	ringbuf->start=0;
 	ringbuf->end=0;
 	ringbuf->bufsize=init_size-RB_OVERHEAD;
-/*	return (ringbuf); */
+	/*	return (ringbuf); */
 }
 
 

Modified: trunk/server/tcp.c
===================================================================
--- trunk/server/tcp.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/tcp.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * tcp.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,19 +27,19 @@
 #include <errno.h>		 /*  errno */
 #include <string.h>		 /*  memset() */
 #ifdef WIN32  /*  sohn wars */
-	#include <winsock2.h>
+#include <winsock2.h>
 #else  /* sohn wars */
-	#include <sys/types.h>   /* fd_set, FD*, socket, accept ... */
-	#include <sys/socket.h>  /* socket, accept ... */
-	#include <sys/select.h>  /* fd_set,FD* */
-	#include <sys/time.h>	 /* fd_set,FD* */
-	#include <netinet/in.h>  /* ntohs(),htons(),htonl(),ntohl() */
-	#include <arpa/inet.h>   /* network */
+#include <sys/types.h>   /* fd_set, FD*, socket, accept ... */
+#include <sys/socket.h>  /* socket, accept ... */
+#include <sys/select.h>  /* fd_set,FD* */
+#include <sys/time.h>	 /* fd_set,FD* */
+#include <netinet/in.h>  /* ntohs(),htons(),htonl(),ntohl() */
+#include <arpa/inet.h>   /* network */
 #endif   /*  sohn wars */
 #include <time.h>		 /*  select() timeval things */
 #include <fcntl.h>		 /*  fcntl(),F_SETOWN */
 #ifndef F_SETOWN /* somehow it is not set with -ansi */
-	#define F_SETOWN	8
+#define F_SETOWN	8
 #endif
 #include <unistd.h>		 /*  read(),write(),getpid(),close() */
 #include <stdlib.h>		 /*  malloc(),free() */
@@ -52,36 +52,36 @@
 int tcp_init()
 {
 	int yes=1;
-	struct sockaddr_in my_addr;   
+	struct sockaddr_in my_addr;
 	s3dprintf(LOW,"server: creating socket");
 #ifdef WIN32  /*  sohn wars */
 	WSADATA datainfo;
 	if (WSAStartup(257, &datainfo) != 0)
 		errnf("startup()", 0);
 #endif  /*  auch sohn */
-   if ((tcp_sockid = socket(AF_INET,SOCK_STREAM,0)) < 0)
-     errnf("socket()", errno);
+	if ((tcp_sockid = socket(AF_INET,SOCK_STREAM,0)) < 0)
+		errnf("socket()", errno);
 
-   s3dprintf(LOW,"server: binding my local socket");
-   /*  allow addresses to be reused */
-   /*  this seems to have something to do with servers using one port */
-   if ( setsockopt(tcp_sockid, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1 )
-        errn("setsockopt(...,SO_REUSEADDR...)",errno );
-   memset((char *) &my_addr,0,sizeof(my_addr));
-   my_addr.sin_family = AF_INET;
-   my_addr.sin_port = htons(S3D_PORT);
-   my_addr.sin_addr.s_addr = htons(INADDR_ANY);
-   if (bind(tcp_sockid ,(struct sockaddr *) &my_addr,sizeof(my_addr)) < 0)
+	s3dprintf(LOW,"server: binding my local socket");
+	/*  allow addresses to be reused */
+	/*  this seems to have something to do with servers using one port */
+	if ( setsockopt(tcp_sockid, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1 )
+		errn("setsockopt(...,SO_REUSEADDR...)",errno );
+	memset((char *) &my_addr,0,sizeof(my_addr));
+	my_addr.sin_family = AF_INET;
+	my_addr.sin_port = htons(S3D_PORT);
+	my_addr.sin_addr.s_addr = htons(INADDR_ANY);
+	if (bind(tcp_sockid ,(struct sockaddr *) &my_addr,sizeof(my_addr)) < 0)
 		errnf("bind()",errno);
-   if (listen(tcp_sockid,5) < 0)	
+	if (listen(tcp_sockid,5) < 0)
 		errnf("listen()",errno);
 #ifdef SIGS
-   if ( fcntl(tcp_sockid, F_SETFL, O_ASYNC | O_NONBLOCK) < 0 )
+	if ( fcntl(tcp_sockid, F_SETFL, O_ASYNC | O_NONBLOCK) < 0 )
 		errnf("fcntl()",errno);
-   if ( fcntl(tcp_sockid, F_SETOWN, getpid()) < 0 )
+	if ( fcntl(tcp_sockid, F_SETOWN, getpid()) < 0 )
 		errnf("fcntl()",errno);
 #endif
-   return(0);
+	return(0);
 
 }
 int tcp_quit()
@@ -98,43 +98,39 @@
 	fd_set				 fs_port; 	 /*  filedescriptor set for listening port(s) */
 	int 				 newsd; 	 /*  new socket descriptor */
 	struct timeval		 tv;		 /*  time structure */
-/*	struct t_con 		*new_con;	*/ /*  pointer to new connection */
+	/*	struct t_con 		*new_con;	*/ /*  pointer to new connection */
 	struct t_process	*new_p;		 /*  pointer to new process */
 	struct sockaddr		 client_addr;  /*  new client's address */
 	socklen_t			 clilen=sizeof(client_addr);		 /*  length of client's address */
-	 /* int i; */
-    FD_ZERO(&fs_port);
-  	FD_SET(tcp_sockid,&fs_port);
+	/* int i; */
+	FD_ZERO(&fs_port);
+	FD_SET(tcp_sockid,&fs_port);
 select_again:
 	tv.tv_sec=tv.tv_usec=0;
-	if (select(FD_SETSIZE, &fs_port, NULL,NULL,&tv)<0)
-	{
-		if (errno==EINTR)  /*  interruption by some evil signal, just do again :) */
-		{
+	if (select(FD_SETSIZE, &fs_port, NULL,NULL,&tv)<0) {
+		if (errno==EINTR) { /*  interruption by some evil signal, just do again :) */
 			errn("tcp_pollport():select()",errno);
 			goto select_again;  /*  oh no, a goto!! that's evil */
 		} else
 			errn("tcp_pollport():select()",errno);
-	}
-	else 
-	if (FD_ISSET(tcp_sockid,&fs_port)) {  /* redundant, I guess */
-		s3dprintf(HIGH,"select(): new connection!!");
-        if ((newsd = accept(tcp_sockid ,(struct sockaddr *) &client_addr,&clilen)) < 0)
-			 errn("accept()",errno);
-		else 
-		{
+	} else
+		if (FD_ISSET(tcp_sockid,&fs_port)) {  /* redundant, I guess */
+			s3dprintf(HIGH,"select(): new connection!!");
+			if ((newsd = accept(tcp_sockid ,(struct sockaddr *) &client_addr,&clilen)) < 0)
+				errn("accept()",errno);
+			else {
 #ifdef SIGS
-		   if ( fcntl(newsd, F_SETFL, O_ASYNC ) < 0 )
-				errnf("fcntl()",errno);
-		   if ( fcntl(newsd, F_SETOWN, getpid()) < 0 )
-				errnf("fcntl()",errno);
+				if ( fcntl(newsd, F_SETFL, O_ASYNC ) < 0 )
+					errnf("fcntl()",errno);
+				if ( fcntl(newsd, F_SETOWN, getpid()) < 0 )
+					errnf("fcntl()",errno);
 #endif
-			new_p=process_add();
-			new_p->con_type=CON_TCP;
-			new_p->sockid=newsd;
-			s3dprintf(HIGH,"registered new connection %d as pid %d",new_p->sockid, new_p->id);
+				new_p=process_add();
+				new_p->con_type=CON_TCP;
+				new_p->sockid=newsd;
+				s3dprintf(HIGH,"registered new connection %d as pid %d",new_p->sockid, new_p->id);
+			}
 		}
-	}
 	return(0);
 }
 extern struct t_process *procs_p;
@@ -153,43 +149,35 @@
 		FD_ZERO(&fs_proc);
 		unfinished=0;
 		n=0;
-		for (i=off;i<procs_n;i++)
-		{
+		for (i=off;i<procs_n;i++) {
 			p=&procs_p[i];
-			if (p->con_type==CON_TCP)
-			{
+			if (p->con_type==CON_TCP) {
 				FD_SET(p->sockid,&fs_proc);
 				n++;
-				if (n>=FD_SETSIZE)	/* don't overflow the setsize! */
-				{
+				if (n>=FD_SETSIZE) {	/* don't overflow the setsize! */
 					off=i;
 					unfinished=1;
 					break;
 				}
 			}
 		}
-		 /*  maybe having a global fd_set for all the processes would have been better */
-		 /*  than generating them new in every poll. to be optimized... */
-select_again_poll:	
+		/*  maybe having a global fd_set for all the processes would have been better */
+		/*  than generating them new in every poll. to be optimized... */
+select_again_poll:
 		tv.tv_sec=tv.tv_usec=0;
-		if (select(FD_SETSIZE, &fs_proc, NULL,NULL,&tv) ==-1) 
-		{
-			if (errno==EINTR)
-			{
-				errn("tcp_pollproc():select()",errno); 
+		if (select(FD_SETSIZE, &fs_proc, NULL,NULL,&tv) ==-1) {
+			if (errno==EINTR) {
+				errn("tcp_pollproc():select()",errno);
 				goto select_again_poll;
 			} else {
-				errn("tcp_pollproc():select()",errno); 
+				errn("tcp_pollproc():select()",errno);
 			}
 		} else {
-			 /*  data is available */
-			for (i=0;i<procs_n;i++)
-			{
+			/*  data is available */
+			for (i=0;i<procs_n;i++) {
 				p=&procs_p[i];
-				if (p->con_type==CON_TCP)
-				{
-					if (FD_ISSET(p->sockid,&fs_proc))
-					{
+				if (p->con_type==CON_TCP) {
+					if (FD_ISSET(p->sockid,&fs_proc)) {
 						FD_CLR(p->sockid,&fs_proc);  /*  clear it from the fd */
 						tcp_prot_com_in(p);
 						found=1;
@@ -204,14 +192,12 @@
 int tcp_prot_com_in(struct t_process *p)
 {
 	uint16_t	length;
-	if (3==tcp_readn(p->sockid, ibuf,3))
-	{
+	if (3==tcp_readn(p->sockid, ibuf,3)) {
 		length=ntohs(*((uint16_t *)((uint8_t *)ibuf+1)));
 		s3dprintf(VLOW,"command %d, length %d",ibuf[0], length);
-		if (length>0)
-		{
+		if (length>0) {
 			tcp_readn(p->sockid,ibuf+3,length);	  /*  uint16_t is limited to 65536, so  */
-										 /*  length can't be bigger than that ... lucky */
+			/*  length can't be bigger than that ... lucky */
 		}
 		prot_com_in(p,ibuf);
 	} else {
@@ -222,33 +208,35 @@
 }
 /*  shamelessly ripped from simple ftp server */
 int tcp_readn(int sock, uint8_t *str,int s)
-{         int no_left,no_read;
-          no_left = s;
-          while (no_left > 0) 
-                     { no_read = read(sock,str,no_left);
-                       if(no_read <0) {
-     						errn("read()", errno); 
-							return(no_read);
-					   }
-                       if (no_read == 0) break;
-                       no_left -= no_read;
-                       str += no_read;
-                     }
-          return(s - no_left);
+{
+	int no_left,no_read;
+	no_left = s;
+	while (no_left > 0) {
+		no_read = read(sock,str,no_left);
+		if (no_read <0) {
+			errn("read()", errno);
+			return(no_read);
+		}
+		if (no_read == 0) break;
+		no_left -= no_read;
+		str += no_read;
+	}
+	return(s - no_left);
 }
 int tcp_writen(int sock, uint8_t *str,int s)
-{         int no_left,no_written;
-          no_left = s;
-          while (no_left > 0) 
-                     { no_written = write(sock,str,no_left);
-                       if(no_written <=0) {
-							errn("write()",errno);
-							return(no_written);
-					   }
-                       no_left -= no_written;
-                       str += no_written;
-                     }
-          return(s - no_left);
+{
+	int no_left,no_written;
+	no_left = s;
+	while (no_left > 0) {
+		no_written = write(sock,str,no_left);
+		if (no_written <=0) {
+			errn("write()",errno);
+			return(no_written);
+		}
+		no_left -= no_written;
+		str += no_written;
+	}
+	return(s - no_left);
 }
 int tcp_remove(int sock)
 {

Modified: trunk/server/user.c
===================================================================
--- trunk/server/user.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/user.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * user.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -27,31 +27,39 @@
 static int ox,oy;
 static int pressed;
 int but=-1;
-int user_init() {
-	switch (frame_mode)
-	{
+int user_init()
+{
+	switch (frame_mode) {
 #ifdef G_GLUT
-		case FRAME_GLUT:user_init_glut();break;
+	case FRAME_GLUT:
+		user_init_glut();
+		break;
 #endif
 #ifdef G_SDL
-    	case FRAME_SDL:user_init_sdl();break;
+	case FRAME_SDL:
+		user_init_sdl();
+		break;
 #endif
-		default:return(-1);
+	default:
+		return(-1);
 	}
 	pressed=0;
 	ox=oy=0xFFFFFF;
 	return(0);
 }
-int user_main() {
-	switch (frame_mode)
-	{
+int user_main()
+{
+	switch (frame_mode) {
 #ifdef G_GLUT
-		case FRAME_GLUT:return(0);  /*  glut uses callback functions */
+	case FRAME_GLUT:
+		return(0);  /*  glut uses callback functions */
 #endif
 #ifdef G_SDL
-    	case FRAME_SDL:user_main_sdl();
+	case FRAME_SDL:
+		user_main_sdl();
 #endif
-		default:return(0);
+	default:
+		return(0);
 	}
 	return(0);
 }
@@ -59,71 +67,69 @@
 {
 	event_key_pressed(key,unicode,mod,state);
 }
-void user_mouse(int button, int state, int x, int y) 
+void user_mouse(int button, int state, int x, int y)
 {
-	switch (state)
-	{
-		case 0: /*  mouse_down ... */
-			switch (button)
-			{
-				case 0:
-					graphics_pick_obj(x,y);	
-					break;
-				case 1:
-					if ((ox!=0xFFFFFF) && (oy!=0xFFFFFF))
-						navi_pos(ox-x,oy-y);
-					break;
-				case 2:
-					if ((ox!=0xFFFFFF) && (oy!=0xFFFFFF))
-						navi_rot(ox-x,oy-y);
-					break;
-				case 3:
-					navi_fwd();
-					break;
-				case 4:
-					navi_back();
-					break;
-				default:
-					s3dprintf(VLOW,"button is ... %d", button);
-			}
-			ox=x;
-			oy=y;
-			event_mbutton_clicked(button,state);
+	switch (state) {
+	case 0: /*  mouse_down ... */
+		switch (button) {
+		case 0:
+			graphics_pick_obj(x,y);
 			break;
-		case 1:  /*  mouse up */
-			ox=oy=0xFFFFFF;
-			event_mbutton_clicked(button,state);
-	/*		s3dprintf(LOW,"state is: %d,button is %d",state,button);*/
+		case 1:
+			if ((ox!=0xFFFFFF) && (oy!=0xFFFFFF))
+				navi_pos(ox-x,oy-y);
 			break;
-		case 2:	 /*  mouse still down */
-			switch (button)
-			{
-				case 1:
-					if ((ox!=0xFFFFFF) && (oy!=0xFFFFFF))
-						navi_pos(ox-x,oy-y);
-					break;
-				case 2:
-					if ((ox!=0xFFFFFF) && (oy!=0xFFFFFF))
-						navi_rot(ox-x,oy-y);
-					break;
-				case 3:
-					navi_fwd();
-					break;
-				case 4:
-					navi_back();
-					break;
-				default:
-					s3dprintf(VLOW,"button is ... %d", button);
-			}
-			ox=x;
-			oy=y;
+		case 2:
+			if ((ox!=0xFFFFFF) && (oy!=0xFFFFFF))
+				navi_rot(ox-x,oy-y);
 			break;
+		case 3:
+			navi_fwd();
+			break;
+		case 4:
+			navi_back();
+			break;
+		default:
+			s3dprintf(VLOW,"button is ... %d", button);
+		}
+		ox=x;
+		oy=y;
+		event_mbutton_clicked(button,state);
+		break;
+	case 1:  /*  mouse up */
+		ox=oy=0xFFFFFF;
+		event_mbutton_clicked(button,state);
+		/*		s3dprintf(LOW,"state is: %d,button is %d",state,button);*/
+		break;
+	case 2:	 /*  mouse still down */
+		switch (button) {
+		case 1:
+			if ((ox!=0xFFFFFF) && (oy!=0xFFFFFF))
+				navi_pos(ox-x,oy-y);
+			break;
+		case 2:
+			if ((ox!=0xFFFFFF) && (oy!=0xFFFFFF))
+				navi_rot(ox-x,oy-y);
+			break;
+		case 3:
+			navi_fwd();
+			break;
+		case 4:
+			navi_back();
+			break;
+		default:
+			s3dprintf(VLOW,"button is ... %d", button);
+		}
+		ox=x;
+		oy=y;
+		break;
 	}
 	but=button;
 	/* mouse changed? */
 	ptr_move(x,y);
 }
-int user_quit() {
+int user_quit()
+{
 	return(0);
 }
 

Modified: trunk/server/user_glut.c
===================================================================
--- trunk/server/user_glut.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/user_glut.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * user_glut.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -38,7 +38,7 @@
 	glutKeyboardFunc (keyboard);
 	glutSpecialFunc (special);
 	glutMouseFunc (user_mouse);
-    glutMotionFunc(mouse_motion);
+	glutMotionFunc(mouse_motion);
 	glutPassiveMotionFunc(passive_mouse_motion);
 	return(0);
 }
@@ -51,30 +51,73 @@
 void special(int skey, int x, int y)
 {
 	uint16_t mkey;
-	switch (skey) /* handle special keys */
-	{
-		case GLUT_KEY_F1:		mkey=S3DK_F1;	break;
-		case GLUT_KEY_F2:		mkey=S3DK_F2;	break;
-		case GLUT_KEY_F3:		mkey=S3DK_F3;	break;
-		case GLUT_KEY_F4:		mkey=S3DK_F4;	break;
-		case GLUT_KEY_F5:		mkey=S3DK_F5;	break;
-		case GLUT_KEY_F6: 		mkey=S3DK_F6;	break;
-		case GLUT_KEY_F7:		mkey=S3DK_F7;	break;
-		case GLUT_KEY_F8:		mkey=S3DK_F8;	break;
-		case GLUT_KEY_F9: 		mkey=S3DK_F9;	break;
-		case GLUT_KEY_F10:		mkey=S3DK_F10;	break;
-		case GLUT_KEY_F11: 		mkey=S3DK_F11;	break;
-		case GLUT_KEY_F12: 		mkey=S3DK_F12;	break;
-		case GLUT_KEY_LEFT: 	mkey=S3DK_LEFT;	break;
-		case GLUT_KEY_RIGHT: 	mkey=S3DK_RIGHT;break;
-		case GLUT_KEY_UP: 		mkey=S3DK_UP;	break;
-		case GLUT_KEY_DOWN: 	mkey=S3DK_DOWN;	break;
-		case GLUT_KEY_PAGE_UP:	mkey=S3DK_PAGEUP;break;
-		case GLUT_KEY_PAGE_DOWN:mkey=S3DK_PAGEDOWN;break;
-		case GLUT_KEY_HOME:		mkey=S3DK_HOME;break;
-		case GLUT_KEY_END: 		mkey=S3DK_END;break;
-		case GLUT_KEY_INSERT: 	mkey=S3DK_INSERT;break;
-		default: 				mkey=skey; break;
+	switch (skey) { /* handle special keys */
+	case GLUT_KEY_F1:
+		mkey=S3DK_F1;
+		break;
+	case GLUT_KEY_F2:
+		mkey=S3DK_F2;
+		break;
+	case GLUT_KEY_F3:
+		mkey=S3DK_F3;
+		break;
+	case GLUT_KEY_F4:
+		mkey=S3DK_F4;
+		break;
+	case GLUT_KEY_F5:
+		mkey=S3DK_F5;
+		break;
+	case GLUT_KEY_F6:
+		mkey=S3DK_F6;
+		break;
+	case GLUT_KEY_F7:
+		mkey=S3DK_F7;
+		break;
+	case GLUT_KEY_F8:
+		mkey=S3DK_F8;
+		break;
+	case GLUT_KEY_F9:
+		mkey=S3DK_F9;
+		break;
+	case GLUT_KEY_F10:
+		mkey=S3DK_F10;
+		break;
+	case GLUT_KEY_F11:
+		mkey=S3DK_F11;
+		break;
+	case GLUT_KEY_F12:
+		mkey=S3DK_F12;
+		break;
+	case GLUT_KEY_LEFT:
+		mkey=S3DK_LEFT;
+		break;
+	case GLUT_KEY_RIGHT:
+		mkey=S3DK_RIGHT;
+		break;
+	case GLUT_KEY_UP:
+		mkey=S3DK_UP;
+		break;
+	case GLUT_KEY_DOWN:
+		mkey=S3DK_DOWN;
+		break;
+	case GLUT_KEY_PAGE_UP:
+		mkey=S3DK_PAGEUP;
+		break;
+	case GLUT_KEY_PAGE_DOWN:
+		mkey=S3DK_PAGEDOWN;
+		break;
+	case GLUT_KEY_HOME:
+		mkey=S3DK_HOME;
+		break;
+	case GLUT_KEY_END:
+		mkey=S3DK_END;
+		break;
+	case GLUT_KEY_INSERT:
+		mkey=S3DK_INSERT;
+		break;
+	default:
+		mkey=skey;
+		break;
 	}
 	s3dprintf(MED,"special(): %d -> %d",skey,mkey);
 	user_key(mkey,0,0,0);

Modified: trunk/server/user_sdl.c
===================================================================
--- trunk/server/user_sdl.c	2007-09-17 10:10:18 UTC (rev 664)
+++ trunk/server/user_sdl.c	2007-09-17 13:33:24 UTC (rev 665)
@@ -1,21 +1,21 @@
 /*
  * user_sdl.c
- * 
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -28,75 +28,85 @@
 /*  this is done right now by SDL-polling */
 
 extern int SDLFlags;
-int user_init_sdl() {
+int user_init_sdl()
+{
 	SDL_EnableUNICODE(1);
 	return(0);
 }
-int user_main_sdl() {
-  SDL_Event 	event;
-  SDL_Surface *GLwin = NULL;
-  while (SDL_PollEvent(&event)) 
-  {
-	switch (event.type)
-	{
-		case SDL_MOUSEMOTION: 
-/* 			s3dprintf(VLOW,"Current mouse position is: (%d, %d),button %d", event.motion.x, event.motion.y,event.button.button); */
-			 switch (event.button.button)
-			 {
-			 	case SDL_BUTTON_LEFT:
-			 		user_mouse(0,2,event.motion.x,event.motion.y);break;
-			 	case SDL_BUTTON_MIDDLE:
-			 		user_mouse(1,2,event.motion.x,event.motion.y);break;
-			 	case SDL_BUTTON_RIGHT:
-				case SDL_BUTTON_RMASK:
-			 		user_mouse(2,2,event.motion.x,event.motion.y);break;
-/*				case SDL_BUTTON_WHEELUP:
-			 		user_mouse(3,2,event.motion.x,event.motion.y);break;
-				case SDL_BUTTON_WHEELDOWN:
-			 		user_mouse(4,2,event.motion.x,event.motion.y);break;*/
-				case 0:
-					user_mouse(-1,-1,event.motion.x,event.motion.y);
-					break;
-					 /*  no button ... */
-				default:
-					s3dprintf(LOW,"don't know button %d", event.button.button);
+int user_main_sdl()
+{
+	SDL_Event 	event;
+	SDL_Surface *GLwin = NULL;
+	while (SDL_PollEvent(&event)) {
+		switch (event.type) {
+		case SDL_MOUSEMOTION:
+			/* 			s3dprintf(VLOW,"Current mouse position is: (%d, %d),button %d", event.motion.x, event.motion.y,event.button.button); */
+			switch (event.button.button) {
+			case SDL_BUTTON_LEFT:
+				user_mouse(0,2,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_MIDDLE:
+				user_mouse(1,2,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_RIGHT:
+			case SDL_BUTTON_RMASK:
+				user_mouse(2,2,event.motion.x,event.motion.y);
+				break;
+				/*				case SDL_BUTTON_WHEELUP:
+							 		user_mouse(3,2,event.motion.x,event.motion.y);break;
+								case SDL_BUTTON_WHEELDOWN:
+							 		user_mouse(4,2,event.motion.x,event.motion.y);break;*/
+			case 0:
+				user_mouse(-1,-1,event.motion.x,event.motion.y);
+				break;
+				/*  no button ... */
+			default:
+				s3dprintf(LOW,"don't know button %d", event.button.button);
 
-			 }
+			}
 			break;
 		case SDL_MOUSEBUTTONDOWN:
-			 switch (event.button.button)
-			 {
-			 	case SDL_BUTTON_LEFT:
-			 		user_mouse(0,0,event.motion.x,event.motion.y);break;
-			 	case SDL_BUTTON_MIDDLE:
-			 		user_mouse(1,0,event.motion.x,event.motion.y);break;
-			 	case SDL_BUTTON_RIGHT:
-			 		user_mouse(2,0,event.motion.x,event.motion.y);break;
-				case SDL_BUTTON_WHEELUP:
-			 		user_mouse(3,0,event.motion.x,event.motion.y);break;
-				case SDL_BUTTON_WHEELDOWN:
-			 		user_mouse(4,0,event.motion.x,event.motion.y);break;
-				default:
-					s3dprintf(LOW,"don't know button %d", event.button.button);
-			 }
-			 break;
+			switch (event.button.button) {
+			case SDL_BUTTON_LEFT:
+				user_mouse(0,0,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_MIDDLE:
+				user_mouse(1,0,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_RIGHT:
+				user_mouse(2,0,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_WHEELUP:
+				user_mouse(3,0,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_WHEELDOWN:
+				user_mouse(4,0,event.motion.x,event.motion.y);
+				break;
+			default:
+				s3dprintf(LOW,"don't know button %d", event.button.button);
+			}
+			break;
 		case SDL_MOUSEBUTTONUP:
-			 switch (event.button.button)
-			 {
-			 	case SDL_BUTTON_LEFT:
-			 		user_mouse(0,1,event.motion.x,event.motion.y);break;
-			 	case SDL_BUTTON_MIDDLE:
-			 		user_mouse(1,1,event.motion.x,event.motion.y);break;
-			 	case SDL_BUTTON_RIGHT:
-			 		user_mouse(2,1,event.motion.x,event.motion.y);break;
-				case SDL_BUTTON_WHEELUP:
-			 		user_mouse(3,1,event.motion.x,event.motion.y);break;
-				case SDL_BUTTON_WHEELDOWN:
-			 		user_mouse(4,1,event.motion.x,event.motion.y);break;
-				default:
-					s3dprintf(LOW,"don't know button %d", event.button.button);
-			 }
-			 break;
+			switch (event.button.button) {
+			case SDL_BUTTON_LEFT:
+				user_mouse(0,1,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_MIDDLE:
+				user_mouse(1,1,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_RIGHT:
+				user_mouse(2,1,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_WHEELUP:
+				user_mouse(3,1,event.motion.x,event.motion.y);
+				break;
+			case SDL_BUTTON_WHEELDOWN:
+				user_mouse(4,1,event.motion.x,event.motion.y);
+				break;
+			default:
+				s3dprintf(LOW,"don't know button %d", event.button.button);
+			}
+			break;
 
 		case SDL_KEYDOWN:
 			user_key(event.key.keysym.sym,event.key.keysym.unicode,event.key.keysym.mod,0);
@@ -108,29 +118,49 @@
 			s3dprintf(HIGH,"SDL_QUIT");
 			quit();
 			break;
-		 /*  these events are not processed right now ... */
-		case SDL_ACTIVEEVENT:		s3dprintf(VLOW,"SDL_ACTIVEEVENT");break;
-		case SDL_SYSWMEVENT:		s3dprintf(VLOW,"SDL_SYSWMEVENT");break;
-		case SDL_VIDEORESIZE:		if ((GLwin = SDL_SetVideoMode(event.resize.w,event.resize.h,16,SDLFlags))==NULL) 
-										errsf("SDL_SetVideoMode()",SDL_GetError());
-									graphics_reshape(event.resize.w,event.resize.h);
-									break;
-		case SDL_VIDEOEXPOSE:		s3dprintf(VLOW,"SDL_VIDEOEXPOSE");break;
-		case SDL_USEREVENT:			s3dprintf(VLOW,"SDL_USEREVENT");break;
-		case SDL_JOYAXISMOTION:		s3dprintf(VLOW,"SDL_JOYAXISMOTION");break;
-		case SDL_JOYBALLMOTION:		s3dprintf(VLOW,"SDL_JOYBALLMOTION");break;
-		case SDL_JOYHATMOTION:		s3dprintf(VLOW,"SDL_JOYHATMOTION");break;
-		case SDL_JOYBUTTONDOWN:		s3dprintf(VLOW,"SDL_JOYBUTTONDOWN");break;
-		case SDL_JOYBUTTONUP:		s3dprintf(VLOW,"SDL_JOYBUTTONUP");break;
+			/*  these events are not processed right now ... */
+		case SDL_ACTIVEEVENT:
+			s3dprintf(VLOW,"SDL_ACTIVEEVENT");
+			break;
+		case SDL_SYSWMEVENT:
+			s3dprintf(VLOW,"SDL_SYSWMEVENT");
+			break;
+		case SDL_VIDEORESIZE:
+			if ((GLwin = SDL_SetVideoMode(event.resize.w,event.resize.h,16,SDLFlags))==NULL)
+				errsf("SDL_SetVideoMode()",SDL_GetError());
+			graphics_reshape(event.resize.w,event.resize.h);
+			break;
+		case SDL_VIDEOEXPOSE:
+			s3dprintf(VLOW,"SDL_VIDEOEXPOSE");
+			break;
+		case SDL_USEREVENT:
+			s3dprintf(VLOW,"SDL_USEREVENT");
+			break;
+		case SDL_JOYAXISMOTION:
+			s3dprintf(VLOW,"SDL_JOYAXISMOTION");
+			break;
+		case SDL_JOYBALLMOTION:
+			s3dprintf(VLOW,"SDL_JOYBALLMOTION");
+			break;
+		case SDL_JOYHATMOTION:
+			s3dprintf(VLOW,"SDL_JOYHATMOTION");
+			break;
+		case SDL_JOYBUTTONDOWN:
+			s3dprintf(VLOW,"SDL_JOYBUTTONDOWN");
+			break;
+		case SDL_JOYBUTTONUP:
+			s3dprintf(VLOW,"SDL_JOYBUTTONUP");
+			break;
 		default:
 			s3dprintf(MED,"SDL_PollEvent(): unhandled event");
-		 	break;
-	  }
-  }
-  return(0);
+			break;
+		}
+	}
+	return(0);
 
 }
-int user_quit_sdl() {
+int user_quit_sdl()
+{
 	return(0);
 }
 



From lazhur at mail.berlios.de  Mon Sep 17 15:43:05 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 17 Sep 2007 15:43:05 +0200
Subject: [S3d-svn] r666 - trunk/apps/s3dosm
Message-ID: <200709171343.l8HDh5fE026450@sheep.berlios.de>

Author: lazhur
Date: 2007-09-17 15:43:05 +0200 (Mon, 17 Sep 2007)
New Revision: 666

Modified:
   trunk/apps/s3dosm/db.c
Log:
Reformatted apps/s3dosm/db.c


Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2007-09-17 13:33:24 UTC (rev 665)
+++ trunk/apps/s3dosm/db.c	2007-09-17 13:43:05 UTC (rev 666)
@@ -41,6 +41,7 @@
 	strncpy(clean, dirty, n);
 	clean[n-1]=0;
 }
+
 int db_add_tag(object_t *obj, char *key, char *val)
 {
 	char tagquery[MAXQ];
@@ -51,6 +52,7 @@
 	db_exec(tagquery, NULL, 0);
 	return(0);
 }
+
 int db_insert_node(node_t *node)
 {
 	char addquery[MAXQ];
@@ -87,6 +89,7 @@
 
 	return(0);
 }
+
 int db_insert_way_only(way_t *way)
 {
 	char addquery[MAXQ];
@@ -103,6 +106,7 @@
 	db_exec(addquery, NULL, 0);
 	return(0);
 }
+
 int db_insert_layer(char *layer_name)
 {
 	char findquery[MAXQ];
@@ -121,6 +125,7 @@
 	}
 	return(layerid);
 }
+
 #define MAGIC	1337 /* just to elevate the nodes a little bit */
 static int found=0;
 /* tries to find node coordinates of ip, returns 1 if has found something */
@@ -147,6 +152,7 @@
 	found=0;
 	return(0);
 }
+
 /* initializes the starting point of nodes  by averaging its lon/lat */
 int db_olsr_node_init(float *pos)
 {
@@ -202,6 +208,7 @@
 		strncpy((char *)string,argv[0],MAXQ);
 	return(0);
 }
+
 /* get the value for a a certain tagid and keyvalue (field). Write into target, which has to be allocated with MAXQ bytes of space.
  * Nothing is written when nothing is found. */
 int db_gettag(int tagid, char *field, char *target)
@@ -222,6 +229,7 @@
 	printf("\n");
 	return 0;
 }
+
 static int db_really_exec(const char *query, sqlite3_callback callback, void *arg)
 {
 	char *zErrMsg = 0;
@@ -242,11 +250,12 @@
 	qbuf[0]=0;
 	qlen=0;
 }
+
 int db_exec(const char *query, sqlite3_callback callback, void *arg)
 {
 	int ret;
 #ifdef DB_STACK
-	if (callback==NULL) { /* we can stack it */
+	if (callback == NULL) { /* we can stack it */
 		int len;
 		len=strlen(query);
 		if (len+qlen>=QBUF)
@@ -255,11 +264,14 @@
 		qlen+=strlen(query);
 		ret=0;
 	} else
-#endif {
+#endif
+
+	{
 		ret=db_really_exec(query,callback,arg);		/* pass it to the real function */
+	}
+	return(ret);
 }
-return(ret);
-}
+
 int db_init(char *dbFile)
 {
 	int rc;
@@ -276,6 +288,7 @@
 	}
 	return(0);
 }
+
 int db_quit()
 {
 	sqlite3_close(db);
@@ -284,6 +297,7 @@
 			perror("db_quit()");
 	return(0);
 }
+
 int db_create()
 {
 	db_exec("CREATE TABLE node (layer_id INT, node_id INTEGER , latitude DOUBLE PRECISION, longitude DOUBLE PRECISION, altitude DOUBLE PRECISION, visible BOOLEAN, tag_id INT, s3doid INT, PRIMARY KEY(layer_id,node_id));",NULL,0);



From lazhur at mail.berlios.de  Mon Sep 17 15:51:33 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 17 Sep 2007 15:51:33 +0200
Subject: [S3d-svn] r667 - in trunk: apps/dot_mcp apps/kism3d apps/meshs3d
	apps/olsrs3d apps/s3d_x11gate apps/s3dfm apps/s3dosm
	apps/s3dvt example libs3d libs3dw server
Message-ID: <200709171351.l8HDpX5G026916@sheep.berlios.de>

Author: lazhur
Date: 2007-09-17 15:51:17 +0200 (Mon, 17 Sep 2007)
New Revision: 667

Modified:
   trunk/apps/dot_mcp/main.c
   trunk/apps/dot_mcp/menu.c
   trunk/apps/kism3d/client.c
   trunk/apps/kism3d/gui.c
   trunk/apps/kism3d/kism3d.c
   trunk/apps/kism3d/kism3d.h
   trunk/apps/kism3d/list.h
   trunk/apps/kism3d/network.c
   trunk/apps/meshs3d/allocate.c
   trunk/apps/meshs3d/hash.c
   trunk/apps/meshs3d/hash.h
   trunk/apps/meshs3d/main.c
   trunk/apps/meshs3d/meshs3d.h
   trunk/apps/meshs3d/net.c
   trunk/apps/meshs3d/process.c
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/net.c
   trunk/apps/olsrs3d/olsrs3d.h
   trunk/apps/olsrs3d/process.c
   trunk/apps/olsrs3d/search.c
   trunk/apps/olsrs3d/search.h
   trunk/apps/olsrs3d/structs.h
   trunk/apps/s3d_x11gate/s3d_x11gate.c
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/event.c
   trunk/apps/s3dfm/fly.c
   trunk/apps/s3dfm/focus.c
   trunk/apps/s3dfm/fs.c
   trunk/apps/s3dfm/icon.c
   trunk/apps/s3dfm/main.c
   trunk/apps/s3dfm/node.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dfm/s3dfm.h
   trunk/apps/s3dfm/string.c
   trunk/apps/s3dosm/db.c
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/gps.c
   trunk/apps/s3dosm/http_error_codes.c
   trunk/apps/s3dosm/http_error_codes.h
   trunk/apps/s3dosm/http_fetcher.c
   trunk/apps/s3dosm/http_fetcher.h
   trunk/apps/s3dosm/io.c
   trunk/apps/s3dosm/kismet.c
   trunk/apps/s3dosm/main.c
   trunk/apps/s3dosm/nav.c
   trunk/apps/s3dosm/object.c
   trunk/apps/s3dosm/olsrs3d.h
   trunk/apps/s3dosm/osm.c
   trunk/apps/s3dosm/s3dosm.h
   trunk/apps/s3dosm/search.h
   trunk/apps/s3dosm/structs.h
   trunk/apps/s3dosm/tag.c
   trunk/apps/s3dosm/ui.c
   trunk/apps/s3dvt/main.c
   trunk/apps/s3dvt/s3dvt.h
   trunk/apps/s3dvt/terminal.c
   trunk/example/filebrowser.c
   trunk/example/hudtest.c
   trunk/example/katze.c
   trunk/example/linetest.c
   trunk/example/modelloader.c
   trunk/example/nichtsnutz.c
   trunk/example/ptrtest.c
   trunk/example/radius_test.c
   trunk/example/s3dclock.c
   trunk/example/snowman.c
   trunk/example/strtest.c
   trunk/example/texturetest.c
   trunk/example/widgets.c
   trunk/example/wiresphere.c
   trunk/libs3d/callback.c
   trunk/libs3d/config.h
   trunk/libs3d/error.c
   trunk/libs3d/event.c
   trunk/libs3d/fontselect.c
   trunk/libs3d/freetype.c
   trunk/libs3d/io.c
   trunk/libs3d/modelread.c
   trunk/libs3d/network.c
   trunk/libs3d/object_queue.c
   trunk/libs3d/proto_in.c
   trunk/libs3d/proto_out.c
   trunk/libs3d/s3d.h
   trunk/libs3d/s3d_keysym.h
   trunk/libs3d/s3dlib.h
   trunk/libs3d/sei_construct.c
   trunk/libs3d/sei_interface.h
   trunk/libs3d/sei_misc.c
   trunk/libs3d/sei_monotone.c
   trunk/libs3d/sei_tri.c
   trunk/libs3d/sei_triangulate.h
   trunk/libs3d/shm.c
   trunk/libs3d/shm_ringbuf.c
   trunk/libs3d/tcp.c
   trunk/libs3d/vector.c
   trunk/libs3dw/animate.c
   trunk/libs3dw/arrange.c
   trunk/libs3dw/button.c
   trunk/libs3dw/event.c
   trunk/libs3dw/input.c
   trunk/libs3dw/label.c
   trunk/libs3dw/root.c
   trunk/libs3dw/s3dw.h
   trunk/libs3dw/s3dw_int.h
   trunk/libs3dw/scrollbar.c
   trunk/libs3dw/style.c
   trunk/libs3dw/surface.c
   trunk/libs3dw/textbox.c
   trunk/libs3dw/widget.c
   trunk/server/allocate.c
   trunk/server/allocate.h
   trunk/server/config.h
   trunk/server/cull.c
   trunk/server/error.c
   trunk/server/event.c
   trunk/server/global.h
   trunk/server/graphics.c
   trunk/server/graphics_glut.c
   trunk/server/graphics_sdl.c
   trunk/server/main.c
   trunk/server/matrix.c
   trunk/server/mcp.c
   trunk/server/navigation.c
   trunk/server/network.c
   trunk/server/object.c
   trunk/server/process.c
   trunk/server/proto.c
   trunk/server/proto.h
   trunk/server/shm.c
   trunk/server/shm_ringbuf.c
   trunk/server/tcp.c
   trunk/server/user.c
   trunk/server/user_glut.c
   trunk/server/user_sdl.c
Log:
Reformatted space paddings


Modified: trunk/apps/dot_mcp/main.c
===================================================================
--- trunk/apps/dot_mcp/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/dot_mcp/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,192 +25,192 @@
 #include <s3d.h>
 #include <s3d_keysym.h>
 #include "dot_mcp.h"
-#include <stdint.h>	 /*  uint32_t */
+#include <stdint.h>  /*  uint32_t */
 #include <unistd.h>  /*  sleep() */
 #include <stdlib.h>  /*  free(), malloc() */
 #include <string.h>  /*  strncpy() */
 #include <stdio.h>  /*  printf() */
-#include <math.h>	/* sin(), cos() */
-#include <time.h>	/* nanosleep() */
-static struct timespec t= {
-	0,33*1000*1000
+#include <math.h> /* sin(), cos() */
+#include <time.h> /* nanosleep() */
+static struct timespec t = {
+	0, 33*1000*1000
 };
 
-#define bsize 	0.2
+#define bsize  0.2
 struct tver {
-	float x,y,z;
+	float x, y, z;
 };
 struct tver campos, camrot;
-float xdif=0,ydif=0;
+float xdif = 0, ydif = 0;
 
 struct app {
-	unsigned int oid,oid_c;
+	unsigned int oid, oid_c;
 	float r;
 	int init;
-	float trans_x,trans_y,trans_z;
+	float trans_x, trans_y, trans_z;
 	float textw;
 	char name[256];
-	int min_but,close_but,title;
+	int min_but, close_but, title;
 	int sphere;
 	struct app *next;
 };
-int ego_mode=0;
-float asp=1.0;
-struct app *apps=NULL;
-float bottom=-1.0;
-float left=-1.0;
-float zoom=5.0;
-int n_app=0;
-int rot_flag=0;
-struct app *focus=NULL;
-float focus_r=0;
-float alpha=0;
-unsigned int min_but,rotate,close_but,sphere,reset,menu=-1;
+int ego_mode = 0;
+float asp = 1.0;
+struct app *apps = NULL;
+float bottom = -1.0;
+float left = -1.0;
+float zoom = 5.0;
+int n_app = 0;
+int rot_flag = 0;
+struct app *focus = NULL;
+float focus_r = 0;
+float alpha = 0;
+unsigned int min_but, rotate, close_but, sphere, reset, menu = -1;
 
 void place_apps();
 
-#define SIDES	60
-#define RINGS	60
+#define SIDES 60
+#define RINGS 60
 int greentorus()
 {
-	int o,i,j;
-	float R,r,a;
-	float ia,ja,iap,jap;
+	int o, i, j;
+	float R, r, a;
+	float ia, ja, iap, jap;
 	float v[SIDES*RINGS*3];
 	float n[SIDES*12]; /* normals */
 	uint32_t l[SIDES*RINGS*6];
-	o=s3d_new_object();
-	R=100; /* outer radius */
-	r=100; /* inner radius */
-	a=M_PI/180;
-	s3d_push_material_a(o, 0.2,0.6,0.2,0.5,
-	                    1  ,1  ,1  ,0.5,
-	                    0.2,0.6,0.2,0.5);
-	for (i=0;i<RINGS;i++) {
-		for (j=0;j<SIDES;j++) {
-			ia=a*((float)i*360.0/RINGS);
-			ja=a*((float)j*360.0/SIDES);
-			iap=a*((float)(i+1)*360.0/RINGS);
-			jap=a*((float)(j+1)*360.0/SIDES);
+	o = s3d_new_object();
+	R = 100; /* outer radius */
+	r = 100; /* inner radius */
+	a = M_PI / 180;
+	s3d_push_material_a(o, 0.2, 0.6, 0.2, 0.5,
+	                    1  , 1  , 1  , 0.5,
+	                    0.2, 0.6, 0.2, 0.5);
+	for (i = 0;i < RINGS;i++) {
+		for (j = 0;j < SIDES;j++) {
+			ia = a * ((float)i * 360.0 / RINGS);
+			ja = a * ((float)j * 360.0 / SIDES);
+			iap = a * ((float)(i + 1) * 360.0 / RINGS);
+			jap = a * ((float)(j + 1) * 360.0 / SIDES);
 
-			v[i*SIDES*3+ j*3 +0]=(R+r*cos(ja))* cos(ia);
-			v[i*SIDES*3+ j*3 +1]=r*sin(ja);
-			v[i*SIDES*3+ j*3 +2]=(R+r*cos(ja))* sin(ia);
+			v[i*SIDES*3+ j*3 +0] = (R + r * cos(ja)) * cos(ia);
+			v[i*SIDES*3+ j*3 +1] = r * sin(ja);
+			v[i*SIDES*3+ j*3 +2] = (R + r * cos(ja)) * sin(ia);
 
-			l[i*SIDES*6+ j*6 +0]=i*SIDES+ j;
-			l[i*SIDES*6+ j*6 +1]=i*SIDES+ (j+1)%SIDES;
-			l[i*SIDES*6+ j*6 +2]=0;
-			l[i*SIDES*6+ j*6 +3]=i*SIDES+ j;
-			l[i*SIDES*6+ j*6 +4]=((i+1)%RINGS)*SIDES+ j;
-			l[i*SIDES*6+ j*6 +5]=0;
+			l[i*SIDES*6+ j*6 +0] = i * SIDES + j;
+			l[i*SIDES*6+ j*6 +1] = i * SIDES + (j + 1) % SIDES;
+			l[i*SIDES*6+ j*6 +2] = 0;
+			l[i*SIDES*6+ j*6 +3] = i * SIDES + j;
+			l[i*SIDES*6+ j*6 +4] = ((i + 1) % RINGS) * SIDES + j;
+			l[i*SIDES*6+ j*6 +5] = 0;
 
-			n[j*12 +0] =R*r*cos(ja)*    cos(ia) + r*r*cos(ja)* cos(ia)*cos(ia);
-			n[j*12 +1] =R*r*sin(ja)*    cos(ia) + r*r*sin(ja)* cos(ia)*cos(ia);
-			n[j*12 +2] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
-			n[j*12 +3] =R*r*cos(jap)*    cos(ia)+ r*r*cos(jap)*cos(ia)*cos(ia);
-			n[j*12 +4] =R*r*sin(jap)*    cos(ia)+ r*r*sin(jap)*cos(ia)*cos(ia);
-			n[j*12 +5] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
+			n[j*12 +0] = R * r * cos(ja) *    cos(ia) + r * r * cos(ja) * cos(ia) * cos(ia);
+			n[j*12 +1] = R * r * sin(ja) *    cos(ia) + r * r * sin(ja) * cos(ia) * cos(ia);
+			n[j*12 +2] = R * r * sin(ia)    + r * r * sin(ia) * cos(ia);
+			n[j*12 +3] = R * r * cos(jap) *    cos(ia) + r * r * cos(jap) * cos(ia) * cos(ia);
+			n[j*12 +4] = R * r * sin(jap) *    cos(ia) + r * r * sin(jap) * cos(ia) * cos(ia);
+			n[j*12 +5] = R * r * sin(ia)    + r * r * sin(ia) * cos(ia);
 
-			n[j*12 +6] =R*r*cos(ja)*    cos(ia) + r*r*cos(ja)* cos(ia)*cos(ia);
-			n[j*12 +7] =R*r*sin(ja)*    cos(ia) + r*r*sin(ja)* cos(ia)*cos(ia);
-			n[j*12 +8] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
-			n[j*12 +9] =R*r*cos(ja)*    cos(iap)+ r*r*cos(ja)* cos(iap)*cos(iap);
-			n[j*12 +10]=R*r*sin(ja)*    cos(iap)+ r*r*sin(ja)* cos(iap)*cos(iap);
-			n[j*12 +11]=R*r*sin(iap) 			+ r*r*sin(iap)*cos(iap);
+			n[j*12 +6] = R * r * cos(ja) *    cos(ia) + r * r * cos(ja) * cos(ia) * cos(ia);
+			n[j*12 +7] = R * r * sin(ja) *    cos(ia) + r * r * sin(ja) * cos(ia) * cos(ia);
+			n[j*12 +8] = R * r * sin(ia)    + r * r * sin(ia) * cos(ia);
+			n[j*12 +9] = R * r * cos(ja) *    cos(iap) + r * r * cos(ja) * cos(iap) * cos(iap);
+			n[j*12 +10] = R * r * sin(ja) *    cos(iap) + r * r * sin(ja) * cos(iap) * cos(iap);
+			n[j*12 +11] = R * r * sin(iap)    + r * r * sin(iap) * cos(iap);
 		}
-		s3d_push_vertices(o,&v[i*SIDES*3],SIDES);
-		s3d_push_lines(o,   &l[i*SIDES*6],SIDES*2);
-		s3d_pep_line_normals(o,n,SIDES*2);
+		s3d_push_vertices(o, &v[i*SIDES*3], SIDES);
+		s3d_push_lines(o,   &l[i*SIDES*6], SIDES*2);
+		s3d_pep_line_normals(o, n, SIDES*2);
 	}
-	/*	s3d_push_vertices(o,v,SIDES*RINGS);
-		s3d_push_lines(o,   l,SIDES*RINGS*2);*/
+	/* s3d_push_vertices(o,v,SIDES*RINGS);
+	 s3d_push_lines(o,   l,SIDES*RINGS*2);*/
 
-	s3d_flags_on(o,S3D_OF_VISIBLE);
+	s3d_flags_on(o, S3D_OF_VISIBLE);
 	return(o);
 }
 void set_focus(struct app *a)
 {
-	if (focus!=a)
+	if (focus != a)
 		/* resetting old focus */
-		if (focus!=NULL) {
-			printf("unfocusing app name %s\n",focus->name);
-			s3d_scale(focus->oid,1/focus->r);
-			s3d_scale(focus->sphere,focus->r);
+		if (focus != NULL) {
+			printf("unfocusing app name %s\n", focus->name);
+			s3d_scale(focus->oid, 1 / focus->r);
+			s3d_scale(focus->sphere, focus->r);
 
-			s3d_flags_on(focus->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_off(focus->min_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_translate(	focus->title,-focus->textw-1.2,0.0,0);
-			s3d_translate(	focus->close_but,bsize*focus->textw/2,1.2,0);
-			s3d_link(		focus->close_but,focus->sphere);
-			s3d_link(		focus->oid,0);
+			s3d_flags_on(focus->sphere, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			s3d_flags_off(focus->min_but, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			s3d_translate(focus->title, -focus->textw - 1.2, 0.0, 0);
+			s3d_translate(focus->close_but, bsize*focus->textw / 2, 1.2, 0);
+			s3d_link(focus->close_but, focus->sphere);
+			s3d_link(focus->oid, 0);
 		}
-	focus=a;
-	if (a==NULL) {
-		focus_r=n_app;
+	focus = a;
+	if (a == NULL) {
+		focus_r = n_app;
 		s3d_mcp_focus(-1);
-		s3d_flags_off(rotate,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_off(reset,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		rot_flag=0;
+		s3d_flags_off(rotate, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		s3d_flags_off(reset, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		rot_flag = 0;
 	} else {
 		/* set the new focus app up */
-		s3d_translate(	a->title,-a->textw-9.6,0.0,0);
-		s3d_translate(	reset,-7.2,0.0,0);
-		s3d_translate(	rotate,-4.8,0.0,0);
-		s3d_translate(	a->min_but,-2.4,0.0,0);
-		s3d_link(		a->close_but,0);
-		s3d_link(		rotate,a->close_but);
-		s3d_link(		reset,a->close_but);
-		s3d_flags_on(	a->min_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(	rotate,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(	reset,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_off(	a->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_translate(a->title, -a->textw - 9.6, 0.0, 0);
+		s3d_translate(reset, -7.2, 0.0, 0);
+		s3d_translate(rotate, -4.8, 0.0, 0);
+		s3d_translate(a->min_but, -2.4, 0.0, 0);
+		s3d_link(a->close_but, 0);
+		s3d_link(rotate, a->close_but);
+		s3d_link(reset, a->close_but);
+		s3d_flags_on(a->min_but, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		s3d_flags_on(rotate, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		s3d_flags_on(reset, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		s3d_flags_off(a->sphere, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 		s3d_unlink(a->oid);
-		s3d_rotate(a->oid,		0,0,0);
-		s3d_translate(a->oid,	0,0,0);
-		focus_r=a->r;
-		s3d_scale(a->oid,1);
-		s3d_mcp_focus(	a->oid);
+		s3d_rotate(a->oid,  0, 0, 0);
+		s3d_translate(a->oid, 0, 0, 0);
+		focus_r = a->r;
+		s3d_scale(a->oid, 1);
+		s3d_mcp_focus(a->oid);
 	}
 	place_apps();
 }
 
 int add_app(struct app *a)
 {
-	struct app *prev=NULL,*a2=apps;
-	while ((a2)!=NULL) {
-		prev=a2;
-		if (a2->oid==a->oid) { /*  already added, so free() and return */
+	struct app *prev = NULL, *a2 = apps;
+	while ((a2) != NULL) {
+		prev = a2;
+		if (a2->oid == a->oid) { /*  already added, so free() and return */
 			free(a);
 			return(1);
 		}
-		a2=a2->next;  /*  go to the end */
+		a2 = a2->next;  /*  go to the end */
 	}
-	a->next=NULL;
-	if (prev==NULL)
-		apps=a;
+	a->next = NULL;
+	if (prev == NULL)
+		apps = a;
 	else
-		prev->next=a;
-	n_app+=1;
+		prev->next = a;
+	n_app += 1;
 	return(0);
 }
 void *find_app(int oid)
 {
-	struct app *a=apps;
-	while (a!=NULL) {
-		if (oid==a->oid)
+	struct app *a = apps;
+	while (a != NULL) {
+		if (oid == a->oid)
 			break;
-		a=a->next;
+		a = a->next;
 	}
 	return(a);
 }
 void *del_app(int oid)
 {
-	struct app *prev=NULL,*a=apps;
-	while ((a!=NULL)  && (a->oid!=oid)) {
-		prev=a;
-		a=a->next;
+	struct app *prev = NULL, *a = apps;
+	while ((a != NULL)  && (a->oid != oid)) {
+		prev = a;
+		a = a->next;
 	}
-	if (a!=NULL) { /*  found ... */
+	if (a != NULL) { /*  found ... */
 		if (a->init) {
 			s3d_del_object(a->close_but);
 			s3d_del_object(a->min_but);
@@ -218,14 +218,14 @@
 			s3d_del_object(a->sphere);
 			s3d_del_object(a->oid);
 		}
-		if (prev==NULL)
-			apps=a->next;  /*  new head */
+		if (prev == NULL)
+			apps = a->next;  /*  new head */
 		else
-			prev->next=a->next;
+			prev->next = a->next;
 		n_app--;
-		if (focus==a) {
+		if (focus == a) {
 			set_focus(NULL);
-			focus=NULL;
+			focus = NULL;
 		}
 		free(a);
 		place_apps();
@@ -239,64 +239,64 @@
 }
 void place_apps()
 {
-	struct app *a=apps;
-	int j=0;
-	float u[3],v[3],ya,xa;
-	while (a!=NULL) {
+	struct app *a = apps;
+	int j = 0;
+	float u[3], v[3], ya, xa;
+	while (a != NULL) {
 		if (a->init) {
-			/*			printf("placing app [%d,'%s'], oid %d, r=%f\n",j,a->name,a->oid,a->r); */
-			if (focus==a) {
-				s3d_translate(a->close_but,(-left)*zoom-0.4,(-bottom)*zoom-0.4,-zoom);
+			/*   printf("placing app [%d,'%s'], oid %d, r=%f\n",j,a->name,a->oid,a->r); */
+			if (focus == a) {
+				s3d_translate(a->close_but, (-left)*zoom - 0.4, (-bottom)*zoom - 0.4, -zoom);
 			} else {
-				s3d_translate(	a->oid,	zoom*(left)+j*2+1.0,zoom*bottom+1.0,-zoom);
-				s3d_rotate(		a->oid,	0,10,0);
+				s3d_translate(a->oid, zoom*(left) + j*2 + 1.0, zoom*bottom + 1.0, -zoom);
+				s3d_rotate(a->oid, 0, 10, 0);
 				j++;
 			}
 		}
-		a=a->next;
+		a = a->next;
 	}
-	s3d_translate(menu,	left*zoom+0.4,(-bottom)*zoom-0.4,-zoom);
+	s3d_translate(menu, left*zoom + 0.4, (-bottom)*zoom - 0.4, -zoom);
 
-	v[0]=0;
-	v[1]=0;
-	v[2]=1;
-	u[0]=left*zoom+0.4;
-	u[1]=0;
-	u[2]=-zoom;
-	ya=s3d_vector_angle(v,u);
-	u[0]=0;
-	u[1]=(-bottom)*zoom;
-	u[2]=-zoom;
-	xa=s3d_vector_angle(v,u);
-	s3d_rotate(menu, 0 ,30,0);
+	v[0] = 0;
+	v[1] = 0;
+	v[2] = 1;
+	u[0] = left * zoom + 0.4;
+	u[1] = 0;
+	u[2] = -zoom;
+	ya = s3d_vector_angle(v, u);
+	u[0] = 0;
+	u[1] = (-bottom) * zoom;
+	u[2] = -zoom;
+	xa = s3d_vector_angle(v, u);
+	s3d_rotate(menu, 0 , 30, 0);
 }
 int mcp_object(struct s3d_evt *hrmz)
 {
 	struct mcp_object *mo;
 	struct app *a;
-	mo=(struct mcp_object *)hrmz->buf;
-	if (NULL==(a=find_app(mo->object))) {
+	mo = (struct mcp_object *)hrmz->buf;
+	if (NULL == (a = find_app(mo->object))) {
 		printf("adding new object ......");
-		a=malloc(sizeof(struct app));
-		a->oid=mo->object;
-		a->r=mo->r;
-		strncpy(a->name,mo->name,256);
-		a->init=0;
+		a = malloc(sizeof(struct app));
+		a->oid = mo->object;
+		a->r = mo->r;
+		strncpy(a->name, mo->name, 256);
+		a->init = 0;
 		add_app(a);
 		place_apps();
-		printf("..%s\n",a->name);
+		printf("..%s\n", a->name);
 	} else {
-		/*		printf("updating app %d\n",a->oid);*/
-		a->trans_x=mo->trans_x;
-		a->trans_y=mo->trans_y;
-		a->trans_z=mo->trans_z;
-		a->r=mo->r;
+		/*  printf("updating app %d\n",a->oid);*/
+		a->trans_x = mo->trans_x;
+		a->trans_y = mo->trans_y;
+		a->trans_z = mo->trans_z;
+		a->r = mo->r;
 		if (a->init) {
-			if (a==focus) {
-				focus_r=a->r;
+			if (a == focus) {
+				focus_r = a->r;
 			} else {
-				s3d_scale(a->sphere,a->r);
-				s3d_scale(a->oid,1/a->r);
+				s3d_scale(a->sphere, a->r);
+				s3d_scale(a->oid, 1 / a->r);
 			}
 		}
 		place_apps();
@@ -305,44 +305,44 @@
 }
 void app_init(struct app *a)
 {
-	printf("building some window decorations on %d ['%s']\n",a->oid,a->name);
-	printf("radius of object %d is %f\n",a->oid,a->r);
-	s3d_scale(a->oid,		1/a->r);
+	printf("building some window decorations on %d ['%s']\n", a->oid, a->name);
+	printf("radius of object %d is %f\n", a->oid, a->r);
+	s3d_scale(a->oid,  1 / a->r);
 
-	a->sphere=s3d_clone(sphere);
-	s3d_scale(		a->sphere,a->r);
-	s3d_link(		a->sphere,a->oid);
-	s3d_flags_on(	a->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	a->sphere = s3d_clone(sphere);
+	s3d_scale(a->sphere, a->r);
+	s3d_link(a->sphere, a->oid);
+	s3d_flags_on(a->sphere, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
-	a->title=s3d_draw_string(a->name,&a->textw);
+	a->title = s3d_draw_string(a->name, &a->textw);
 
-	a->close_but=s3d_clone(close_but);
-	s3d_translate(	a->close_but,bsize*a->textw/2.0,1.2f,0.0f);
-	s3d_link(		a->close_but,a->sphere);
-	s3d_flags_on(	a->close_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	a->close_but = s3d_clone(close_but);
+	s3d_translate(a->close_but, bsize*a->textw / 2.0, 1.2f, 0.0f);
+	s3d_link(a->close_but, a->sphere);
+	s3d_flags_on(a->close_but, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
 
-	s3d_translate(	a->title,-a->textw-1.2f,0.0f,0.0f);
-	s3d_link(		a->title,a->close_but);
-	s3d_flags_on(	a->title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_translate(a->title, -a->textw - 1.2f, 0.0f, 0.0f);
+	s3d_link(a->title, a->close_but);
+	s3d_flags_on(a->title, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
-	a->min_but=s3d_clone(min_but);
-	s3d_link(		a->min_but,a->close_but);
+	a->min_but = s3d_clone(min_but);
+	s3d_link(a->min_but, a->close_but);
 
 
-	s3d_scale(		a->close_but,bsize);
+	s3d_scale(a->close_but, bsize);
 
-	s3d_link(		a->oid,0);
-	a->init=1;
-	/*	if (focus==NULL)
-			set_focus(a);
-		else*/
+	s3d_link(a->oid, 0);
+	a->init = 1;
+	/* if (focus==NULL)
+	  set_focus(a);
+	 else*/
 	place_apps();
 }
 int mcp_del_object(struct s3d_evt *hrmz)
 {
 	struct mcp_object *mo;
-	mo=(struct mcp_object *)hrmz->buf;
+	mo = (struct mcp_object *)hrmz->buf;
 	del_app(mo->object);
 	return(0);
 }
@@ -350,33 +350,33 @@
 {
 	struct app *a;
 	unsigned int i, oid;
-	oid=*((unsigned int *)hrmz->buf);
-	a=apps;
-	i=0;
-	if (oid==rotate) {
-		rot_flag=!rot_flag;
+	oid = *((unsigned int *)hrmz->buf);
+	a = apps;
+	i = 0;
+	if (oid == rotate) {
+		rot_flag = !rot_flag;
 		return(0);
 	}
-	if (oid==reset) {
-		s3d_translate(0,0.0,0.0,5.0);
-		s3d_rotate(0,0,0,0);
+	if (oid == reset) {
+		s3d_translate(0, 0.0, 0.0, 5.0);
+		s3d_rotate(0, 0, 0, 0);
 	}
-	while (a!=NULL) {
-		if (oid==a->close_but) {
+	while (a != NULL) {
+		if (oid == a->close_but) {
 			del_app(a->oid);
 			return(0);
-		} else 	if (oid==a->min_but) {
-			if (a==focus) {
+		} else  if (oid == a->min_but) {
+			if (a == focus) {
 				set_focus(NULL); /* nothing is focused now */
 			}
 			return(0);
-		} else 	if (((oid==a->title) || (oid==a->sphere)) || (oid==a->oid)) {
-			printf("giving focus to [%s], %d\n",a->name,oid);
+		} else  if (((oid == a->title) || (oid == a->sphere)) || (oid == a->oid)) {
+			printf("giving focus to [%s], %d\n", a->name, oid);
 			set_focus(a);
 			return(0);
 		}
 		i++;
-		a=a->next;
+		a = a->next;
 	}
 	menu_click(oid);
 	return(0);
@@ -384,24 +384,24 @@
 int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz->buf;
-	if (inf->object==0) {
-		campos.x=inf->trans_x;
-		campos.y=inf->trans_y;
-		campos.z=inf->trans_z;
-		camrot.x=inf->rot_x;
-		camrot.y=inf->rot_y;
-		camrot.z=inf->rot_z;
+	inf = (struct s3d_obj_info *)hrmz->buf;
+	if (inf->object == 0) {
+		campos.x = inf->trans_x;
+		campos.y = inf->trans_y;
+		campos.z = inf->trans_z;
+		camrot.x = inf->rot_x;
+		camrot.y = inf->rot_y;
+		camrot.z = inf->rot_z;
 
-		if (asp!=inf->scale) {
-			asp=inf->scale;
-			printf("screen aspect: %f\n",asp);
-			if (asp>1.0) { /* wide screen */
-				bottom=-1.0;
-				left=-asp;
+		if (asp != inf->scale) {
+			asp = inf->scale;
+			printf("screen aspect: %f\n", asp);
+			if (asp > 1.0) { /* wide screen */
+				bottom = -1.0;
+				left = -asp;
 			} else {  /* high screen */
-				bottom=(-1.0/asp);
-				left=-1.0;
+				bottom = (-1.0 / asp);
+				left = -1.0;
 			}
 			place_apps(); /* replace apps */
 		}
@@ -411,108 +411,108 @@
 void mainloop()
 {
 	struct app *a;
-	float al,r;
+	float al, r;
 	int i;
-	a=apps;
-	i=0;
-	while (a!=NULL) {
+	a = apps;
+	i = 0;
+	while (a != NULL) {
 		if (!a->init)
 			app_init(a);
 		i++;
-		a=a->next;
+		a = a->next;
 	}
 	if (rot_flag) {
-		al=(alpha*M_PI/180);
-		r=(focus_r>20.0)?20.0:focus_r;
-		s3d_translate(0,sin(al)*(r+5),0,cos(al)*(r+5));
-		s3d_rotate(0,0,alpha,0);
-		alpha=alpha+0.1;
-		if (alpha>360.0) alpha=0.0;
+		al = (alpha * M_PI / 180);
+		r = (focus_r > 20.0) ? 20.0 : focus_r;
+		s3d_translate(0, sin(al)*(r + 5), 0, cos(al)*(r + 5));
+		s3d_rotate(0, 0, alpha, 0);
+		alpha = alpha + 0.1;
+		if (alpha > 360.0) alpha = 0.0;
 	}
 	if (ego_mode) {
-		if ((ydif!=0) || (xdif!=0)) {
-			campos.x+=ydif*sin((camrot.y*M_PI)/180);
-			campos.z+=ydif*cos((camrot.y*M_PI)/180);
-			campos.x+=xdif*cos((-camrot.y*M_PI)/180);
-			campos.z+=xdif*sin((-camrot.y*M_PI)/180);
-			campos.y+=ydif*sin((-camrot.x*M_PI)/180);
-			s3d_translate(	0,campos.x,campos.y,campos.z);
+		if ((ydif != 0) || (xdif != 0)) {
+			campos.x += ydif * sin((camrot.y * M_PI) / 180);
+			campos.z += ydif * cos((camrot.y * M_PI) / 180);
+			campos.x += xdif * cos((-camrot.y * M_PI) / 180);
+			campos.z += xdif * sin((-camrot.y * M_PI) / 180);
+			campos.y += ydif * sin((-camrot.x * M_PI) / 180);
+			s3d_translate(0, campos.x, campos.y, campos.z);
 		}
 	}
-	nanosleep(&t,NULL);
+	nanosleep(&t, NULL);
 }
 
 int keydown(struct s3d_evt *event)
 {
-	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
+	struct s3d_key_event *keys = (struct s3d_key_event *)event->buf;
 	switch (keys->keysym) {
 	case S3DK_F2:
-		ego_mode=(ego_mode+1)%2;
-		xdif=0;
-		ydif=0;
-		printf("ego mode %d\n",ego_mode);
+		ego_mode = (ego_mode + 1) % 2;
+		xdif = 0;
+		ydif = 0;
+		printf("ego mode %d\n", ego_mode);
 		break;
 	case 'w':
-		ydif+=-1.0;
+		ydif += -1.0;
 		break;
 	case 'a':
-		xdif+=-1.0;
+		xdif += -1.0;
 		break;
 	case 's':
-		ydif+= 1.0;
+		ydif += 1.0;
 		break;
 	case 'd':
-		xdif+= 1.0;
+		xdif += 1.0;
 		break;
 	}
 	return(0);
 }
 int keyup(struct s3d_evt *event)
 {
-	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
+	struct s3d_key_event *keys = (struct s3d_key_event *)event->buf;
 	switch (keys->keysym) {
 	case 'w':
-		ydif-=-1.0;
+		ydif -= -1.0;
 		break;
 	case 'a':
-		xdif-=-1.0;
+		xdif -= -1.0;
 		break;
 	case 's':
-		ydif-= 1.0;
+		ydif -= 1.0;
 		break;
 	case 'd':
-		xdif-= 1.0;
+		xdif -= 1.0;
 		break;
 	}
 	return(0);
 
 }
 
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-	s3d_set_callback(S3D_MCP_OBJECT,mcp_object);
-	s3d_set_callback(S3D_EVENT_QUIT,stop);
-	s3d_set_callback(S3D_MCP_DEL_OBJECT,mcp_del_object);
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-	s3d_set_callback(S3D_EVENT_KEYDOWN,keydown);
-	s3d_set_callback(S3D_EVENT_KEYUP,keyup);
+	s3d_set_callback(S3D_EVENT_OBJ_INFO, object_info);
+	s3d_set_callback(S3D_MCP_OBJECT, mcp_object);
+	s3d_set_callback(S3D_EVENT_QUIT, stop);
+	s3d_set_callback(S3D_MCP_DEL_OBJECT, mcp_del_object);
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK, object_click);
+	s3d_set_callback(S3D_EVENT_KEYDOWN, keydown);
+	s3d_set_callback(S3D_EVENT_KEYUP, keyup);
 
-	if (!s3d_init(&argc,&argv,"mcp")) {
-		if (!((argc>1) && (0==strcmp(argv[1],"--notorus"))))
+	if (!s3d_init(&argc, &argv, "mcp")) {
+		if (!((argc > 1) && (0 == strcmp(argv[1], "--notorus"))))
 			greentorus(); /* just call ... */
 
 		if (s3d_select_font("vera")) {
 			printf("font not found\n");
 		}
-		min_but=s3d_import_model_file("objs/btn_minimize.3ds");
-		rotate=s3d_import_model_file("objs/btn_rotate.3ds");
-		reset=s3d_import_model_file("objs/reset.3ds");
-		close_but=s3d_import_model_file("objs/btn_close.3ds");
-		sphere=s3d_import_model_file("objs/ringsystem.3ds");
-		menu=menu_init();
-		s3d_link(menu,0);
-		s3d_scale(menu,bsize);
+		min_but = s3d_import_model_file("objs/btn_minimize.3ds");
+		rotate = s3d_import_model_file("objs/btn_rotate.3ds");
+		reset = s3d_import_model_file("objs/reset.3ds");
+		close_but = s3d_import_model_file("objs/btn_close.3ds");
+		sphere = s3d_import_model_file("objs/ringsystem.3ds");
+		menu = menu_init();
+		s3d_link(menu, 0);
+		s3d_scale(menu, bsize);
 		place_apps();
 		s3d_mainloop(mainloop);
 		s3d_quit();

Modified: trunk/apps/dot_mcp/menu.c
===================================================================
--- trunk/apps/dot_mcp/menu.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/dot_mcp/menu.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -33,66 +33,66 @@
 	char *icon, *name, *path;
 	int icon_oid, str_oid;
 };
-static int go=-1;
+static int go = -1;
 static int act;
-static struct menu_entry menu[]= {
-	{"objs/comp.3ds","terminal","s3dvt",				0,0
-	}, {"objs/comp.3ds","olsrs3d","olsrs3d",				0,0}, {"objs/comp.3ds","s3d_x11gate","s3d_x11gate",		0,0}, {"objs/comp.3ds","filebrowser","filebrowser",		0,0}, {"objs/comp.3ds","logout","LOGOUT",					0,0},
+static struct menu_entry menu[] = {
+	{"objs/comp.3ds", "terminal", "s3dvt",    0, 0
+	}, {"objs/comp.3ds", "olsrs3d", "olsrs3d",    0, 0}, {"objs/comp.3ds", "s3d_x11gate", "s3d_x11gate",  0, 0}, {"objs/comp.3ds", "filebrowser", "filebrowser",  0, 0}, {"objs/comp.3ds", "logout", "LOGOUT",     0, 0},
 };
 void menu_click(int oid)
 {
 	unsigned int i;
 	char exec[256];
-	printf("%d got clicked\n",oid);
-	if (oid==go) {
-		act=!act;
-		for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++) {
+	printf("%d got clicked\n", oid);
+	if (oid == go) {
+		act = !act;
+		for (i = 0;i < (sizeof(menu) / sizeof(struct menu_entry));i++) {
 			if (act) {
-				s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-				s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+				s3d_flags_on(menu[i].icon_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+				s3d_flags_on(menu[i].str_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 			} else {
-				s3d_flags_off(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-				s3d_flags_off(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+				s3d_flags_off(menu[i].icon_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+				s3d_flags_off(menu[i].str_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 			}
 
 		}
 		return;
 	}
 	if (act) {
-		for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++) {
-			if ((oid==menu[i].icon_oid) || (oid==menu[i].str_oid)) {
-				if (0==strncmp(menu[i].path,"LOGOUT",6)) {
+		for (i = 0;i < (sizeof(menu) / sizeof(struct menu_entry));i++) {
+			if ((oid == menu[i].icon_oid) || (oid == menu[i].str_oid)) {
+				if (0 == strncmp(menu[i].path, "LOGOUT", 6)) {
 					s3d_quit();
 					return;
 				}
-				strncpy(exec,menu[i].path,256);
-				strncat(exec,"> /dev/null 2>&1 &",256); /* ignoring output, starting in background */
-				printf("executing [%s]\n",exec);
+				strncpy(exec, menu[i].path, 256);
+				strncat(exec, "> /dev/null 2>&1 &", 256); /* ignoring output, starting in background */
+				printf("executing [%s]\n", exec);
 				system(exec);
 				return;
 			}
 		}
 	}
 }
-int menu_init ()
+int menu_init()
 {
-	int i,menu_o;
-	menu_o=s3d_new_object();
-	act=0; /* menu deactived */
-	go=s3d_import_model_file("objs/s3dstart.3ds");
-	s3d_flags_on(go,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_link(go,menu_o);
-	for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++) {
-		if (-1==(menu[i].icon_oid=s3d_import_model_file(menu[i].icon)))
-			menu[i].icon_oid=s3d_new_object();
-		menu[i].str_oid=s3d_draw_string(menu[i].name,NULL);
-		s3d_link(menu[i].str_oid,menu[i].icon_oid);
-		s3d_link(menu[i].icon_oid,menu_o);
-		s3d_translate(menu[i].icon_oid,0,-3+(-3*i),0);
-		s3d_translate(menu[i].str_oid,2,0,0);
-		/*		s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-				s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);*/
-		printf("menu item menu[%d], icon_oid=%d, icon_str=%d\n",i,menu[i].icon_oid,menu[i].str_oid);
+	int i, menu_o;
+	menu_o = s3d_new_object();
+	act = 0; /* menu deactived */
+	go = s3d_import_model_file("objs/s3dstart.3ds");
+	s3d_flags_on(go, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_link(go, menu_o);
+	for (i = 0;i < (sizeof(menu) / sizeof(struct menu_entry));i++) {
+		if (-1 == (menu[i].icon_oid = s3d_import_model_file(menu[i].icon)))
+			menu[i].icon_oid = s3d_new_object();
+		menu[i].str_oid = s3d_draw_string(menu[i].name, NULL);
+		s3d_link(menu[i].str_oid, menu[i].icon_oid);
+		s3d_link(menu[i].icon_oid, menu_o);
+		s3d_translate(menu[i].icon_oid, 0, -3 + (-3*i), 0);
+		s3d_translate(menu[i].str_oid, 2, 0, 0);
+		/*  s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		  s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);*/
+		printf("menu item menu[%d], icon_oid=%d, icon_str=%d\n", i, menu[i].icon_oid, menu[i].str_oid);
 	}
 	return(menu_o);
 }

Modified: trunk/apps/kism3d/client.c
===================================================================
--- trunk/apps/kism3d/client.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/kism3d/client.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -29,7 +29,7 @@
 
 
 
-struct wlan_client *get_wlan_client( char *mac ) {
+struct wlan_client *get_wlan_client(char *mac) {
 
 	struct list_head *client_pos;
 	struct wlan_client *wlan_client;
@@ -39,27 +39,27 @@
 
 		wlan_client = list_entry(client_pos, struct wlan_client, list);
 
-		if ( strncmp( wlan_client->mac, mac, 18 ) == 0 )
+		if (strncmp(wlan_client->mac, mac, 18) == 0)
 			return wlan_client;
 
 	}
 
 
 	/* we reached the end of the list and must create a new wlan_network */
-	wlan_client = alloc_memory( sizeof( struct wlan_client ) );
+	wlan_client = alloc_memory(sizeof(struct wlan_client));
 
 	INIT_LIST_HEAD(&wlan_client->list);
 
-	strncpy( wlan_client->mac, mac, 18 );
+	strncpy(wlan_client->mac, mac, 18);
 	wlan_client->wlan_network = NULL;
 
 	wlan_client->props_changed = 1;
 
 	wlan_client->visible = 1;
 
-	wlan_client->pos_vec[0] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-	wlan_client->pos_vec[1] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-	wlan_client->pos_vec[2] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+	wlan_client->pos_vec[0] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
+	wlan_client->pos_vec[1] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
+	wlan_client->pos_vec[2] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
 	wlan_client->mov_vec[0] = wlan_client->mov_vec[1] = wlan_client->mov_vec[2] = 0.0;
 
 	wlan_client->obj_id = -1;

Modified: trunk/apps/kism3d/gui.c
===================================================================
--- trunk/apps/kism3d/gui.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/kism3d/gui.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,10 +26,10 @@
 #include "kism3d.h"
 #include <s3d.h>
 #include <s3dw.h>
-#include <math.h>	/* M_PI, cos(), sin() */
-#include <stdlib.h>	/* malloc(), free() */
+#include <math.h> /* M_PI, cos(), sin() */
+#include <stdlib.h> /* malloc(), free() */
 #include <stdio.h>      /* printf() */
-#include <time.h>	/* nanosleep()  */
+#include <time.h> /* nanosleep()  */
 #include <pthread.h>
 
 
@@ -51,65 +51,65 @@
 
 int wire_sphere(int slices, int stacks)
 {
-	int x,y,i,o;
-	int num_v,num_l;
-	float *v,*n;			/* vertices, normals */
+	int x, y, i, o;
+	int num_v, num_l;
+	float *v, *n;  /* vertices, normals */
 	float alpha, beta;
-	unsigned int *l;	/* lines */
-	num_v=(stacks+1) * slices;
-	num_l=stacks * slices+ (stacks-1) * slices; /* vertical + horizontal */
-	v=malloc(sizeof(float) * 3 * num_v);
-	n=malloc(sizeof(float) * 6 * num_l);
-	l=malloc(sizeof(unsigned int) * 3 * num_l);
-	i=0;
-	for (x=0;x<slices;x++) {
-		alpha=(x*360.0/slices)*M_PI/180.0;
-		for (y=0;y<(stacks+1);y++) {
-			beta=((y*180/slices)-90.0)*M_PI/180.0;
-			v[i*3+0]=cos(alpha) * cos(beta);
-			v[i*3+1]=sin(beta);
-			v[i*3+2]=sin(alpha) * cos(beta);
+	unsigned int *l; /* lines */
+	num_v = (stacks + 1) * slices;
+	num_l = stacks * slices + (stacks - 1) * slices; /* vertical + horizontal */
+	v = malloc(sizeof(float) * 3 * num_v);
+	n = malloc(sizeof(float) * 6 * num_l);
+	l = malloc(sizeof(unsigned int) * 3 * num_l);
+	i = 0;
+	for (x = 0;x < slices;x++) {
+		alpha = (x * 360.0 / slices) * M_PI / 180.0;
+		for (y = 0;y < (stacks + 1);y++) {
+			beta = ((y * 180 / slices) - 90.0) * M_PI / 180.0;
+			v[i*3+0] = cos(alpha) * cos(beta);
+			v[i*3+1] = sin(beta);
+			v[i*3+2] = sin(alpha) * cos(beta);
 			i++;
 		}
 	}
-	i=0;
-	for (x=0;x<slices;x++) {
-		for (y=0;y<stacks;y++) {
-			if ((y!=0) && (y!=stacks)) { /* no horizontal lines at the poles */
-				l[i*3+0]=(x*(stacks+1))+y;
-				l[i*3+1]=(((x+1)%slices)*(stacks+1))+y;
-				l[i*3+2]=0;
-				n[i*6+0]=v[ l[i*3+0]*3 + 0];
-				n[i*6+1]=v[ l[i*3+0]*3 + 1];
-				n[i*6+2]=v[ l[i*3+0]*3 + 2];
-				n[i*6+3]=v[ l[i*3+1]*3 + 0];
-				n[i*6+4]=v[ l[i*3+1]*3 + 1];
-				n[i*6+5]=v[ l[i*3+1]*3 + 2];
+	i = 0;
+	for (x = 0;x < slices;x++) {
+		for (y = 0;y < stacks;y++) {
+			if ((y != 0) && (y != stacks)) { /* no horizontal lines at the poles */
+				l[i*3+0] = (x * (stacks + 1)) + y;
+				l[i*3+1] = (((x + 1) % slices) * (stacks + 1)) + y;
+				l[i*3+2] = 0;
+				n[i*6+0] = v[ l[i*3+0] * 3 + 0];
+				n[i*6+1] = v[ l[i*3+0] * 3 + 1];
+				n[i*6+2] = v[ l[i*3+0] * 3 + 2];
+				n[i*6+3] = v[ l[i*3+1] * 3 + 0];
+				n[i*6+4] = v[ l[i*3+1] * 3 + 1];
+				n[i*6+5] = v[ l[i*3+1] * 3 + 2];
 
 				i++;
 
 			}
 			/* vertical lines */
-			l[i*3+0]=(x*(stacks+1))+y;
-			l[i*3+1]=(x*(stacks+1))+y+1;
-			l[i*3+2]=0;
-			n[i*6+0]=v[ l[i*3+0]*3 + 0];
-			n[i*6+1]=v[ l[i*3+0]*3 + 1];
-			n[i*6+2]=v[ l[i*3+0]*3 + 2];
-			n[i*6+3]=v[ l[i*3+1]*3 + 0];
-			n[i*6+4]=v[ l[i*3+1]*3 + 1];
-			n[i*6+5]=v[ l[i*3+1]*3 + 2];
+			l[i*3+0] = (x * (stacks + 1)) + y;
+			l[i*3+1] = (x * (stacks + 1)) + y + 1;
+			l[i*3+2] = 0;
+			n[i*6+0] = v[ l[i*3+0] * 3 + 0];
+			n[i*6+1] = v[ l[i*3+0] * 3 + 1];
+			n[i*6+2] = v[ l[i*3+0] * 3 + 2];
+			n[i*6+3] = v[ l[i*3+1] * 3 + 0];
+			n[i*6+4] = v[ l[i*3+1] * 3 + 1];
+			n[i*6+5] = v[ l[i*3+1] * 3 + 2];
 			i++;
 
 		}
 	}
-	o=s3d_new_object();
-	s3d_push_material(o,0,0,1,
-	                  1,0,0,
-	                  0,1,0);
-	s3d_push_vertices(o,v,num_v);
-	s3d_push_lines(o,l,num_l);
-	s3d_load_line_normals(o,n,0,num_l);
+	o = s3d_new_object();
+	s3d_push_material(o, 0, 0, 1,
+	                  1, 0, 0,
+	                  0, 1, 0);
+	s3d_push_vertices(o, v, num_v);
+	s3d_push_lines(o, l, num_l);
+	s3d_load_line_normals(o, n, 0, num_l);
 	free(v);
 	free(n);
 	free(l);
@@ -125,120 +125,120 @@
 	struct wlan_network *wlan_network;
 	float real_node_pos_x, real_node_pos_z, angle, angle_rad;
 	int network_index = 0;
-	char label_str[101];	/* safe to do as long as we use strn* functions */
-	float maxlen,templen;
+	char label_str[101]; /* safe to do as long as we use strn* functions */
+	float maxlen, templen;
 
 
-	pthread_mutex_lock( &Network_list_mutex );
+	pthread_mutex_lock(&Network_list_mutex);
 
 	list_for_each(network_pos, &Network_list) {
 
 		wlan_network = list_entry(network_pos, struct wlan_network, list);
 
-		if ( wlan_network->visible ) {
+		if (wlan_network->visible) {
 
 			network_index++;
 
-			if ( wlan_network->obj_id == -1 ) {
+			if (wlan_network->obj_id == -1) {
 
 				wlan_network->obj_id = s3d_new_object();
-				wlan_network->wrsphr_id = wire_sphere( 30, 30 );
-				s3d_link( wlan_network->wrsphr_id, wlan_network->obj_id );
-				s3d_flags_on( wlan_network->wrsphr_id, S3D_OF_VISIBLE );
+				wlan_network->wrsphr_id = wire_sphere(30, 30);
+				s3d_link(wlan_network->wrsphr_id, wlan_network->obj_id);
+				s3d_flags_on(wlan_network->wrsphr_id, S3D_OF_VISIBLE);
 
 			}
 
 
 			wlan_network->scale_fac = wlan_network->num_wlan_clients + 2;
-			s3d_translate( wlan_network->wrsphr_id, 0, /*-6 + wlan_network->scale_fac*/ 0, 0);
-			s3d_scale( wlan_network->obj_id, wlan_network->scale_fac );
+			s3d_translate(wlan_network->wrsphr_id, 0, /*-6 + wlan_network->scale_fac*/ 0, 0);
+			s3d_scale(wlan_network->obj_id, wlan_network->scale_fac);
 
-			real_node_pos_x = sin( 2.0 * M_PI * network_index / ((float) Num_networks ) ) * ( ( ( 1 * Num_networks ) / 2 * M_PI ) );
-			real_node_pos_z = cos( 2.0 * M_PI * network_index / ((float) Num_networks ) ) * ( ( ( 1 * Num_networks ) / 2 * M_PI ) );
+			real_node_pos_x = sin(2.0 * M_PI * network_index / ((float) Num_networks)) * (((1 * Num_networks) / 2 * M_PI));
+			real_node_pos_z = cos(2.0 * M_PI * network_index / ((float) Num_networks)) * (((1 * Num_networks) / 2 * M_PI));
 
-			if ( ( fabs( wlan_network->pos_vec[0] - real_node_pos_x ) > 0.5 ) || ( fabs( wlan_network->pos_vec[2] - real_node_pos_z ) > 0.5 ) ) {
+			if ((fabs(wlan_network->pos_vec[0] - real_node_pos_x) > 0.5) || (fabs(wlan_network->pos_vec[2] - real_node_pos_z) > 0.5)) {
 
-				if ( fabs( wlan_network->pos_vec[0] - real_node_pos_x ) > 0.5 )
-					wlan_network->pos_vec[0] = ( ( wlan_network->pos_vec[0] * 9 + real_node_pos_x ) / 10 );
+				if (fabs(wlan_network->pos_vec[0] - real_node_pos_x) > 0.5)
+					wlan_network->pos_vec[0] = ((wlan_network->pos_vec[0] * 9 + real_node_pos_x) / 10);
 
-				if ( fabs( wlan_network->pos_vec[2] - real_node_pos_z ) > 0.5 )
-					wlan_network->pos_vec[2] = ( ( wlan_network->pos_vec[2] * 9 + real_node_pos_z ) / 10 );
+				if (fabs(wlan_network->pos_vec[2] - real_node_pos_z) > 0.5)
+					wlan_network->pos_vec[2] = ((wlan_network->pos_vec[2] * 9 + real_node_pos_z) / 10);
 
-				s3d_translate( wlan_network->obj_id, wlan_network->pos_vec[0], wlan_network->pos_vec[1], wlan_network->pos_vec[2] );
+				s3d_translate(wlan_network->obj_id, wlan_network->pos_vec[0], wlan_network->pos_vec[1], wlan_network->pos_vec[2]);
 
 			}
 
-			if ( wlan_network->props_changed ) {
-				snprintf( label_str, 100, "Type: %s, CH: %i, Clients: %i", ( wlan_network->type == 0 ? "Managed" : ( wlan_network->type == 1 ? "Ad-Hoc" : ( wlan_network->type == 2 ? "Prober" : "unknown" ) ) ), wlan_network->chan, wlan_network->num_wlan_clients );
+			if (wlan_network->props_changed) {
+				snprintf(label_str, 100, "Type: %s, CH: %i, Clients: %i", (wlan_network->type == 0 ? "Managed" : (wlan_network->type == 1 ? "Ad-Hoc" : (wlan_network->type == 2 ? "Prober" : "unknown"))), wlan_network->chan, wlan_network->num_wlan_clients);
 
 				/* determine our longest string which we draw */
-				maxlen = s3d_strlen( label_str );
+				maxlen = s3d_strlen(label_str);
 
-				if ( ( templen = s3d_strlen( wlan_network->ssid ) ) > maxlen )
+				if ((templen = s3d_strlen(wlan_network->ssid)) > maxlen)
 					maxlen = templen;
 
-				if ( ( templen = s3d_strlen( wlan_network->bssid ) ) > maxlen )
+				if ((templen = s3d_strlen(wlan_network->bssid)) > maxlen)
 					maxlen = templen;
 
 				wlan_network->props_changed = 0;
 
-				if ( wlan_network->ssid_id != -1 )
-					s3d_del_object( wlan_network->ssid_id );
+				if (wlan_network->ssid_id != -1)
+					s3d_del_object(wlan_network->ssid_id);
 
-				if ( wlan_network->misc_id != -1 )
-					s3d_del_object( wlan_network->misc_id );
+				if (wlan_network->misc_id != -1)
+					s3d_del_object(wlan_network->misc_id);
 
 
-				if ( wlan_network->bssid_id == -1 ) {
+				if (wlan_network->bssid_id == -1) {
 
-					wlan_network->bssid_id = s3d_draw_string( wlan_network->bssid, NULL );
+					wlan_network->bssid_id = s3d_draw_string(wlan_network->bssid, NULL);
 					wlan_network->text_width = maxlen; /* the other strings might be longer, so we use the longest string for calculating our rotation. */
-					s3d_link( wlan_network->bssid_id, wlan_network->obj_id );
-					s3d_translate( wlan_network->bssid_id, - maxlen / 2, 2 + wlan_network->scale_fac, 0 );
-					s3d_scale( wlan_network->bssid_id, NETWORK_TEXT_SCALE );
-					s3d_flags_on( wlan_network->bssid_id, S3D_OF_VISIBLE );
+					s3d_link(wlan_network->bssid_id, wlan_network->obj_id);
+					s3d_translate(wlan_network->bssid_id, - maxlen / 2, 2 + wlan_network->scale_fac, 0);
+					s3d_scale(wlan_network->bssid_id, NETWORK_TEXT_SCALE);
+					s3d_flags_on(wlan_network->bssid_id, S3D_OF_VISIBLE);
 
 					wlan_network->click_id = s3d_new_object();
-					s3d_link( wlan_network->click_id, wlan_network->bssid_id );
-					s3d_push_material( wlan_network->click_id, 0,0,0,  0,0,0,  0,0,0);
-					s3d_push_vertex( wlan_network->click_id, 0, 1, 0.1 );
-					s3d_push_vertex( wlan_network->click_id, maxlen, 1, 0.1 );
-					s3d_push_vertex( wlan_network->click_id, maxlen, -2.5, 0.1 ); /* 3 lines of text + some mor space for low characters, like g,q,p ... */
-					s3d_push_vertex( wlan_network->click_id, 0, -2.5, 0.1 );
-					s3d_push_polygon( wlan_network->click_id, 0, 1, 2, 0 );
-					s3d_push_polygon( wlan_network->click_id, 0, 2, 3, 0 );
+					s3d_link(wlan_network->click_id, wlan_network->bssid_id);
+					s3d_push_material(wlan_network->click_id, 0, 0, 0,  0, 0, 0,  0, 0, 0);
+					s3d_push_vertex(wlan_network->click_id, 0, 1, 0.1);
+					s3d_push_vertex(wlan_network->click_id, maxlen, 1, 0.1);
+					s3d_push_vertex(wlan_network->click_id, maxlen, -2.5, 0.1);   /* 3 lines of text + some mor space for low characters, like g,q,p ... */
+					s3d_push_vertex(wlan_network->click_id, 0, -2.5, 0.1);
+					s3d_push_polygon(wlan_network->click_id, 0, 1, 2, 0);
+					s3d_push_polygon(wlan_network->click_id, 0, 2, 3, 0);
 
-					s3d_flags_on( wlan_network->click_id, S3D_OF_SELECTABLE );
+					s3d_flags_on(wlan_network->click_id, S3D_OF_SELECTABLE);
 
 				}
 
-				wlan_network->ssid_id = s3d_draw_string( wlan_network->ssid, NULL );
-				s3d_link( wlan_network->ssid_id, wlan_network->bssid_id );
-				s3d_translate( wlan_network->ssid_id, 0, -1, 0 );
-				s3d_flags_on( wlan_network->ssid_id, S3D_OF_VISIBLE );
+				wlan_network->ssid_id = s3d_draw_string(wlan_network->ssid, NULL);
+				s3d_link(wlan_network->ssid_id, wlan_network->bssid_id);
+				s3d_translate(wlan_network->ssid_id, 0, -1, 0);
+				s3d_flags_on(wlan_network->ssid_id, S3D_OF_VISIBLE);
 
 
-				wlan_network->misc_id = s3d_draw_string( label_str, NULL );
-				s3d_link( wlan_network->misc_id, wlan_network->ssid_id );
-				s3d_translate( wlan_network->misc_id, 0, -1, 0 );
-				s3d_flags_on( wlan_network->misc_id, S3D_OF_VISIBLE );
+				wlan_network->misc_id = s3d_draw_string(label_str, NULL);
+				s3d_link(wlan_network->misc_id, wlan_network->ssid_id);
+				s3d_translate(wlan_network->misc_id, 0, -1, 0);
+				s3d_flags_on(wlan_network->misc_id, S3D_OF_VISIBLE);
 
 			}
 
-			angle = s3d_angle_to_cam( wlan_network->pos_vec, CamPosition[0], &angle_rad );
-			s3d_rotate( wlan_network->bssid_id, 0, angle , 0 );
+			angle = s3d_angle_to_cam(wlan_network->pos_vec, CamPosition[0], &angle_rad);
+			s3d_rotate(wlan_network->bssid_id, 0, angle , 0);
 
-			s3d_translate( wlan_network->bssid_id, -cos(angle_rad) * NETWORK_TEXT_SCALE * wlan_network->text_width / 2 ,2 , sin(angle_rad) * NETWORK_TEXT_SCALE * wlan_network->text_width / 2 );
+			s3d_translate(wlan_network->bssid_id, -cos(angle_rad) * NETWORK_TEXT_SCALE * wlan_network->text_width / 2 , 2 , sin(angle_rad) * NETWORK_TEXT_SCALE * wlan_network->text_width / 2);
 
-			wlan_network->rotation = ( wlan_network->rotation + 1 ) % 360;
-			s3d_rotate( wlan_network->wrsphr_id, 0, wlan_network->rotation, 0 );
+			wlan_network->rotation = (wlan_network->rotation + 1) % 360;
+			s3d_rotate(wlan_network->wrsphr_id, 0, wlan_network->rotation, 0);
 
 		}
 
 	}
 
 
-	pthread_mutex_unlock( &Network_list_mutex );
+	pthread_mutex_unlock(&Network_list_mutex);
 
 	return(0);
 
@@ -254,49 +254,49 @@
 	float angle, angle_rad;
 
 
-	pthread_mutex_lock( &Client_list_mutex );
+	pthread_mutex_lock(&Client_list_mutex);
 
 	list_for_each(client_pos, &Client_list) {
 
 		wlan_client = list_entry(client_pos, struct wlan_client, list);
 
-		if ( wlan_client->visible ) {
+		if (wlan_client->visible) {
 
-			if ( wlan_client->obj_id == -1 ) {
+			if (wlan_client->obj_id == -1) {
 
 				wlan_client->obj_id = s3d_new_object();
-				wlan_client->symbol_id = s3d_clone( Client_obj );
-				s3d_link( wlan_client->symbol_id, wlan_client->obj_id );
-				s3d_flags_on( wlan_client->symbol_id, S3D_OF_VISIBLE );
+				wlan_client->symbol_id = s3d_clone(Client_obj);
+				s3d_link(wlan_client->symbol_id, wlan_client->obj_id);
+				s3d_flags_on(wlan_client->symbol_id, S3D_OF_VISIBLE);
 
 			}
 
-			if ( wlan_client->props_changed ) {
+			if (wlan_client->props_changed) {
 
 				wlan_client->props_changed = 0;
 
-				if ( wlan_client->ip_id != -1 )
-					s3d_del_object( wlan_client->ip_id );
+				if (wlan_client->ip_id != -1)
+					s3d_del_object(wlan_client->ip_id);
 
-				wlan_client->ip_id = s3d_draw_string( wlan_client->ip, &wlan_client->ip_len );
-				s3d_link( wlan_client->ip_id, wlan_client->obj_id );
-				s3d_translate( wlan_client->ip_id, - wlan_client->ip_len / 2, 2, 0 );
-				s3d_scale( wlan_client->ip_id, CLIENT_TEXT_SCALE );
-				s3d_flags_on( wlan_client->ip_id, S3D_OF_VISIBLE );
+				wlan_client->ip_id = s3d_draw_string(wlan_client->ip, &wlan_client->ip_len);
+				s3d_link(wlan_client->ip_id, wlan_client->obj_id);
+				s3d_translate(wlan_client->ip_id, - wlan_client->ip_len / 2, 2, 0);
+				s3d_scale(wlan_client->ip_id, CLIENT_TEXT_SCALE);
+				s3d_flags_on(wlan_client->ip_id, S3D_OF_VISIBLE);
 
 			}
 
-			angle = s3d_angle_to_cam( wlan_client->pos_vec, CamPosition[0], &angle_rad );
-			s3d_rotate( wlan_client->ip_id, 0, angle , 0 );
+			angle = s3d_angle_to_cam(wlan_client->pos_vec, CamPosition[0], &angle_rad);
+			s3d_rotate(wlan_client->ip_id, 0, angle , 0);
 
-			s3d_translate( wlan_client->ip_id, -cos(angle_rad) * CLIENT_TEXT_SCALE * wlan_client->ip_len / 2 ,2 , sin(angle_rad) * CLIENT_TEXT_SCALE * wlan_client->ip_len / 2 );
+			s3d_translate(wlan_client->ip_id, -cos(angle_rad) * CLIENT_TEXT_SCALE * wlan_client->ip_len / 2 , 2 , sin(angle_rad) * CLIENT_TEXT_SCALE * wlan_client->ip_len / 2);
 
 		}
 
 	}
 
 
-	pthread_mutex_unlock( &Client_list_mutex );
+	pthread_mutex_unlock(&Client_list_mutex);
 
 	return(0);
 
@@ -315,19 +315,19 @@
 
 	struct list_head *network_pos;
 	struct wlan_network *wlan_network;
-	int clicked_id = (int)*((uint32_t *)evt->buf);
+	int clicked_id = (int) * ((uint32_t *)evt->buf);
 
 
-	s3dw_handle_click( evt );
+	s3dw_handle_click(evt);
 
 	/* emulate double click */
-	if ( ( Last_Click_Oid == clicked_id ) && ( Last_Click_Time + 250 > get_time() ) ) {
+	if ((Last_Click_Oid == clicked_id) && (Last_Click_Time + 250 > get_time())) {
 
-		list_for_each( network_pos, &Network_list ) {
+		list_for_each(network_pos, &Network_list) {
 
 			wlan_network = list_entry(network_pos, struct wlan_network, list);
 
-			if ( wlan_network->click_id == clicked_id ) {
+			if (wlan_network->click_id == clicked_id) {
 
 				Cam_target = wlan_network;
 				break;
@@ -363,7 +363,7 @@
 	inf = (struct s3d_obj_info *)hrmz->buf;
 	s3dw_object_info(hrmz);
 
-	if ( inf->object == 0 ) {
+	if (inf->object == 0) {
 
 		CamPosition[0][0] = inf->trans_x;
 		CamPosition[0][1] = inf->trans_y;
@@ -389,57 +389,57 @@
 	handle_networks();
 	handle_clients();
 
-	if ( Cam_target != NULL ) {
+	if (Cam_target != NULL) {
 
 		/* move to target */
 		/* printf( "Moving to Network: %s, %s\n", ((struct wlan_network *)Cam_target)->bssid, ((struct wlan_network *)Cam_target)->ssid ); */
 
-		CamPosition[0][0] = ( CamPosition[0][0] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[0] + 10 ) / 5;
-		CamPosition[0][1] = ( CamPosition[0][1] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[1] ) / 5;
-		CamPosition[0][2] = ( CamPosition[0][2] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[2] ) / 5;
+		CamPosition[0][0] = (CamPosition[0][0] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[0] + 10) / 5;
+		CamPosition[0][1] = (CamPosition[0][1] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[1]) / 5;
+		CamPosition[0][2] = (CamPosition[0][2] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[2]) / 5;
 
 		diff_vec[0] = CamPosition[0][0] - ((struct wlan_network *)Cam_target)->pos_vec[0];
 		diff_vec[1] = 0.0;
 		diff_vec[2] = CamPosition[0][2] - ((struct wlan_network *)Cam_target)->pos_vec[2];
 
-		angle = s3d_vector_angle( diff_vec, tmp_vec );
-		angle = 180 - ( 180 / M_PI * angle );
-		CamPosition[1][1] = ( CamPosition[1][1] * 4 + angle ) / 5;
+		angle = s3d_vector_angle(diff_vec, tmp_vec);
+		angle = 180 - (180 / M_PI * angle);
+		CamPosition[1][1] = (CamPosition[1][1] * 4 + angle) / 5;
 
-		s3d_translate( 0, CamPosition[0][0], CamPosition[0][1], CamPosition[0][2] );
-		s3d_rotate( 0, CamPosition[1][0], CamPosition[1][1], CamPosition[1][2] );
+		s3d_translate(0, CamPosition[0][0], CamPosition[0][1], CamPosition[0][2]);
+		s3d_rotate(0, CamPosition[1][0], CamPosition[1][1], CamPosition[1][2]);
 
-		if ( ( fabs( diff_vec[0] ) < 11.0 ) && ( fabs( CamPosition[0][1] - ((struct wlan_network *)Cam_target)->pos_vec[1] ) < 1.0 ) && ( fabs( diff_vec[2] ) < 1.0 ) )
+		if ((fabs(diff_vec[0]) < 11.0) && (fabs(CamPosition[0][1] - ((struct wlan_network *)Cam_target)->pos_vec[1]) < 1.0) && (fabs(diff_vec[2]) < 1.0))
 			Cam_target = NULL;
 
 	}
 
-	if ( Kism3d_aborted )
+	if (Kism3d_aborted)
 		s3d_quit();
 
-	nanosleep( &sleeptime, NULL );
+	nanosleep(&sleeptime, NULL);
 
 }
 
 
 
-void* gui_main( void *unused )
+void* gui_main(void *unused)
 {
 
-	if ( !s3d_init( NULL, NULL, "kism3d" ) ) {
+	if (!s3d_init(NULL, NULL, "kism3d")) {
 
-		if ( s3d_select_font( "vera" ) ) {
+		if (s3d_select_font("vera")) {
 
-			printf( "font 'vera' not found\n" );
+			printf("font 'vera' not found\n");
 
 		} else {
 
-			s3d_set_callback( S3D_EVENT_OBJ_INFO, object_info );
-			s3d_set_callback( S3D_EVENT_OBJ_CLICK, object_click );
+			s3d_set_callback(S3D_EVENT_OBJ_INFO, object_info);
+			s3d_set_callback(S3D_EVENT_OBJ_CLICK, object_click);
 
-			Client_obj = s3d_import_model_file( "objs/accesspoint.3ds" );
+			Client_obj = s3d_import_model_file("objs/accesspoint.3ds");
 
-			s3d_mainloop( mainloop );
+			s3d_mainloop(mainloop);
 
 		}
 

Modified: trunk/apps/kism3d/kism3d.c
===================================================================
--- trunk/apps/kism3d/kism3d.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/kism3d/kism3d.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -52,17 +52,17 @@
 
 
 
-void *alloc_memory( int len )
+void *alloc_memory(int len)
 {
 
-	void *res = malloc( len );
+	void *res = malloc(len);
 
-	if ( res == NULL ) {
-		printf( "Error - can't allocate memory: %s\n", strerror(errno) );
+	if (res == NULL) {
+		printf("Error - can't allocate memory: %s\n", strerror(errno));
 		exit(1);
 	}
 
-	memset( res, 0, len );
+	memset(res, 0, len);
 
 	return res;
 
@@ -70,17 +70,17 @@
 
 
 
-void *realloc_memory( void *ptr, int len )
+void *realloc_memory(void *ptr, int len)
 {
 
-	void *res = realloc( ptr, len );
+	void *res = realloc(ptr, len);
 
 	if (res == NULL) {
-		printf( "Error - can't trallocate memory: %s\n", strerror(errno) );
+		printf("Error - can't trallocate memory: %s\n", strerror(errno));
 		exit(1);
 	}
 
-	memset( res, 0, len );
+	memset(res, 0, len);
 
 	return res;
 
@@ -88,7 +88,7 @@
 
 
 
-unsigned int get_time( void )
+unsigned int get_time(void)
 {
 
 	struct timeval tv;
@@ -101,7 +101,7 @@
 
 
 
-void parse_buffer( struct kismet_src *kismet_src )
+void parse_buffer(struct kismet_src *kismet_src)
 {
 
 	struct wlan_network *wlan_network;
@@ -116,9 +116,9 @@
 	line_ptr = kismet_src->recv_buff;
 
 
-	while ( (*read_ptr) != '\0' ) {
+	while ((*read_ptr) != '\0') {
 
-		if ( (*read_ptr) == '\n' ) {
+		if ((*read_ptr) == '\n') {
 
 			last_cr_ptr = read_ptr;
 			*last_cr_ptr = '\0';
@@ -127,25 +127,25 @@
 
 			/* printf( "line: %s\n", line_ptr ); */
 
-			if ( strncmp( line_ptr, "*TIME: ", strlen( "*TIME: " ) ) == 0 ) {
+			if (strncmp(line_ptr, "*TIME: ", strlen("*TIME: ")) == 0) {
 
-				if ( kismet_src->enable_level < 4 ) {
+				if (kismet_src->enable_level < 4) {
 
-					switch ( kismet_src->enable_level ) {
+					switch (kismet_src->enable_level) {
 
 					case 0:
-						if ( write( kismet_src->sock, enable_alert, sizeof( enable_alert ) ) < 0 ) {
+						if (write(kismet_src->sock, enable_alert, sizeof(enable_alert)) < 0) {
 
-							printf( "Warning - can't send ENABLE ALERT message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno) );
+							printf("Warning - can't send ENABLE ALERT message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno));
 
 						}
 
 						break;
 
 					case 1:
-						if ( write( kismet_src->sock, enable_client, sizeof( enable_client ) ) < 0 ) {
+						if (write(kismet_src->sock, enable_client, sizeof(enable_client)) < 0) {
 
-							printf( "Warning - can't send ENABLE CLIENT message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno) );
+							printf("Warning - can't send ENABLE CLIENT message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno));
 
 						}
 
@@ -153,9 +153,9 @@
 
 					case 2:
 
-						if ( write( kismet_src->sock, enable_network, sizeof( enable_network ) ) < 0 ) {
+						if (write(kismet_src->sock, enable_network, sizeof(enable_network)) < 0) {
 
-							printf( "Warning - can't send ENABLE NETWORK message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno) );
+							printf("Warning - can't send ENABLE NETWORK message to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno));
 
 						}
 
@@ -163,10 +163,10 @@
 
 					case 3:
 
-						if ( !thread_running ) {
+						if (!thread_running) {
 
 							thread_running++;
-							pthread_create( &s3d_thread_id, NULL, &gui_main, NULL );
+							pthread_create(&s3d_thread_id, NULL, &gui_main, NULL);
 
 						}
 
@@ -178,19 +178,19 @@
 
 				}
 
-			} else if ( strncmp( line_ptr, "*NETWORK: ", strlen( "*NETWORK: " ) ) == 0 ) {
+			} else if (strncmp(line_ptr, "*NETWORK: ", strlen("*NETWORK: ")) == 0) {
 
 				/* printf( "line: %s\n", line_ptr ); */
 
-				parse_begin_ptr = parse_end_ptr = line_ptr + strlen( "*NETWORK: " );
+				parse_begin_ptr = parse_end_ptr = line_ptr + strlen("*NETWORK: ");
 				end_char = ' ';
 				count = 0;
 
-				while ( (*parse_end_ptr) != '\0' ) {
+				while ((*parse_end_ptr) != '\0') {
 
-					if ( (*parse_end_ptr) == ' ' ) {
+					if ((*parse_end_ptr) == ' ') {
 
-						switch ( count ) {
+						switch (count) {
 
 						case 0:
 							bssid = parse_begin_ptr;
@@ -206,11 +206,11 @@
 
 						case 3:
 							/* ssids with spaces are quoted by kismet */
-							if ( parse_begin_ptr[0] == '\001' ) {
+							if (parse_begin_ptr[0] == '\001') {
 
 								parse_begin_ptr++;
 
-								parse_end_ptr = strchr( parse_begin_ptr, '\001' );
+								parse_end_ptr = strchr(parse_begin_ptr, '\001');
 								*parse_end_ptr = '\0';
 
 								count++;
@@ -222,7 +222,7 @@
 
 						}
 
-						if ( count == 4 )
+						if (count == 4)
 							break;
 
 						*parse_end_ptr = '\0';
@@ -237,39 +237,39 @@
 				}
 
 
-				pthread_mutex_lock( &Network_list_mutex );
+				pthread_mutex_lock(&Network_list_mutex);
 
-				wlan_network = get_wlan_network( bssid );
+				wlan_network = get_wlan_network(bssid);
 
-				if ( ( wlan_network->type != -1 ) && ( wlan_network->chan != -1 ) && ( wlan_network->ssid != NULL ) ) {
+				if ((wlan_network->type != -1) && (wlan_network->chan != -1) && (wlan_network->ssid != NULL)) {
 
 					/* network properties have changed - alert user */
 
 				}
 
-				wlan_network->type = atoi( type );
-				wlan_network->chan = atoi( channel );
+				wlan_network->type = atoi(type);
+				wlan_network->chan = atoi(channel);
 
-				if ( wlan_network->ssid != NULL )
-					free( wlan_network->ssid );
+				if (wlan_network->ssid != NULL)
+					free(wlan_network->ssid);
 
-				wlan_network->ssid = alloc_memory( strlen( ssid ) );
-				strcpy( wlan_network->ssid, ssid );
+				wlan_network->ssid = alloc_memory(strlen(ssid));
+				strcpy(wlan_network->ssid, ssid);
 
-				pthread_mutex_unlock( &Network_list_mutex );
+				pthread_mutex_unlock(&Network_list_mutex);
 
 				/* printf( "network found - bssid %s, type %s, channel %s, ssid '%s' <> '%s'\n", bssid, type, channel, ssid, wlan_network->ssid ); */
 
-			} else if ( strncmp( line_ptr, "*CLIENT: ", strlen( "*CLIENT: " ) ) == 0 ) {
+			} else if (strncmp(line_ptr, "*CLIENT: ", strlen("*CLIENT: ")) == 0) {
 
-				parse_begin_ptr = parse_end_ptr = line_ptr + strlen( "*CLIENT: " );
+				parse_begin_ptr = parse_end_ptr = line_ptr + strlen("*CLIENT: ");
 				count = 0;
 
-				while ( (*parse_end_ptr) != '\0' ) {
+				while ((*parse_end_ptr) != '\0') {
 
-					if ( (*parse_end_ptr) == ' ' ) {
+					if ((*parse_end_ptr) == ' ') {
 
-						switch ( count ) {
+						switch (count) {
 
 						case 0:
 							bssid = parse_begin_ptr;
@@ -285,7 +285,7 @@
 
 						}
 
-						if ( count == 2 )
+						if (count == 2)
 							break;
 
 						*parse_end_ptr = '\0';
@@ -299,29 +299,29 @@
 
 				}
 
-				wlan_client = get_wlan_client( mac );
+				wlan_client = get_wlan_client(mac);
 
 				/*if ( ( wlan_client->type != -1 ) && ( wlan_client->channel != -1 ) && ( wlan_client->ssid != NULL ) ) {
 
-					 client properties have changed - alert user
+				  client properties have changed - alert user
 
 				}*/
 
-				strncpy( wlan_client->bssid, bssid, 18 );
-				strncpy( wlan_client->ip, ip, 16 );
+				strncpy(wlan_client->bssid, bssid, 18);
+				strncpy(wlan_client->ip, ip, 16);
 
-				wlan_network = find_wlan_network( wlan_client->bssid );
+				wlan_network = find_wlan_network(wlan_client->bssid);
 
-				if ( wlan_client->wlan_network != wlan_network ) {
+				if (wlan_client->wlan_network != wlan_network) {
 
-					if ( wlan_client->wlan_network != NULL ) {
+					if (wlan_client->wlan_network != NULL) {
 
 						wlan_client->wlan_network->num_wlan_clients--;
 						wlan_client->wlan_network->props_changed = 1;
 
 					}
 
-					if ( wlan_network != NULL ) {
+					if (wlan_network != NULL) {
 
 						wlan_network->num_wlan_clients++;
 						wlan_network->props_changed = 1;
@@ -335,7 +335,7 @@
 
 				/* printf( "client found - bssid %s, mac %s, ip %s\n", bssid, mac, ip ); */
 
-			} else if ( strncmp( line_ptr, "*ALERT: ", strlen( "*ALERT: " ) ) == 0 ) {
+			} else if (strncmp(line_ptr, "*ALERT: ", strlen("*ALERT: ")) == 0) {
 
 				/* printf( "alert: %s\n", line_ptr + strlen( "*ALERT: " ) ); */
 
@@ -350,14 +350,14 @@
 
 	}
 
-	if ( last_cr_ptr != NULL )
-		memmove( kismet_src->recv_buff, last_cr_ptr + 1, strlen( last_cr_ptr ) );
+	if (last_cr_ptr != NULL)
+		memmove(kismet_src->recv_buff, last_cr_ptr + 1, strlen(last_cr_ptr));
 
 }
 
 
 
-int main( int argc, char *argv[] )
+int main(int argc, char *argv[])
 {
 
 	struct in_addr tmp_ip_holder;
@@ -374,25 +374,25 @@
 	FD_ZERO(&wait_sockets);
 
 
-	while ( argc > found_args ) {
+	while (argc > found_args) {
 
-		kismet_src = alloc_memory( sizeof(struct kismet_src) );
+		kismet_src = alloc_memory(sizeof(struct kismet_src));
 
 		INIT_LIST_HEAD(&kismet_src->list);
 		kismet_src->enable_level = 0;
 
 		/* get ip and port from argument */
-		if ( ( colon_ptr = strchr( argv[found_args], ':' ) ) != NULL ) {
+		if ((colon_ptr = strchr(argv[found_args], ':')) != NULL) {
 
 			*colon_ptr = '\0';
 			colon_ptr++;
 
 		}
 
-		if ( inet_pton(AF_INET, argv[found_args], &tmp_ip_holder) < 1 ) {
+		if (inet_pton(AF_INET, argv[found_args], &tmp_ip_holder) < 1) {
 
-			printf( "Invalid kismet IP specified: %s\n", argv[found_args] );
-			free( kismet_src );
+			printf("Invalid kismet IP specified: %s\n", argv[found_args]);
+			free(kismet_src);
 			found_args++;
 			continue;
 
@@ -402,13 +402,13 @@
 
 		}
 
-		if ( colon_ptr != NULL ) {
+		if (colon_ptr != NULL) {
 
 			kismet_src->port = strtol(colon_ptr, NULL , 10);
 
-			if ( kismet_src->port < 1 || kismet_src->port > 65535 ) {
-				printf( "Invalid kismet PORT specified: %s\n", colon_ptr );
-				free( kismet_src );
+			if (kismet_src->port < 1 || kismet_src->port > 65535) {
+				printf("Invalid kismet PORT specified: %s\n", colon_ptr);
+				free(kismet_src);
 				found_args++;
 				continue;
 			}
@@ -421,40 +421,40 @@
 
 
 		kismet_src->kismet_addr.sin_family = AF_INET;
-		kismet_src->kismet_addr.sin_port = htons( kismet_src->port );
+		kismet_src->kismet_addr.sin_port = htons(kismet_src->port);
 		kismet_src->kismet_addr.sin_addr.s_addr = kismet_src->ip;
 
-		kismet_src->kismet_ip = alloc_memory( 16 );
-		inet_ntop( AF_INET, &kismet_src->ip, kismet_src->kismet_ip, 16 );
+		kismet_src->kismet_ip = alloc_memory(16);
+		inet_ntop(AF_INET, &kismet_src->ip, kismet_src->kismet_ip, 16);
 
 
 		/* connect to kismet server */
-		if ( ( kismet_src->sock = socket( PF_INET, SOCK_STREAM, 0 ) ) < 0 ) {
+		if ((kismet_src->sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
 
-			printf( "Error - can't create tcp socket (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno) );
-			free( kismet_src->kismet_ip );
-			free( kismet_src );
+			printf("Error - can't create tcp socket (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno));
+			free(kismet_src->kismet_ip);
+			free(kismet_src);
 			found_args++;
 			continue;
 
 		}
 
-		if ( connect ( kismet_src->sock, (struct sockaddr *)&kismet_src->kismet_addr, sizeof(struct sockaddr) ) < 0 ) {
+		if (connect(kismet_src->sock, (struct sockaddr *)&kismet_src->kismet_addr, sizeof(struct sockaddr)) < 0) {
 
-			printf( "Error - can't connect to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno) );
-			close( kismet_src->sock );
-			free( kismet_src->kismet_ip );
-			free( kismet_src );
+			printf("Error - can't connect to kismet server (%s:%i): %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno));
+			close(kismet_src->sock);
+			free(kismet_src->kismet_ip);
+			free(kismet_src);
 			found_args++;
 			continue;
 
 		}
 
 
-		kismet_src->recv_buff = alloc_memory( 1500 );
+		kismet_src->recv_buff = alloc_memory(1500);
 
-		FD_SET( kismet_src->sock, &wait_sockets );
-		if ( kismet_src->sock > max_sock )
+		FD_SET(kismet_src->sock, &wait_sockets);
+		if (kismet_src->sock > max_sock)
 			max_sock = kismet_src->sock;
 
 		list_add_tail(&kismet_src->list, &kismet_src_list);
@@ -466,86 +466,86 @@
 	}
 
 
-	if ( num_kismet_sources == 0 ) {
+	if (num_kismet_sources == 0) {
 
-		printf( "Exiting - can't find any valid kismet server\n" );
+		printf("Exiting - can't find any valid kismet server\n");
 		exit(EXIT_FAILURE);
 
 	}
 
 
-	while ( ( num_kismet_sources > 0 ) && !( Kism3d_aborted ) ) {
+	while ((num_kismet_sources > 0) && !(Kism3d_aborted)) {
 
 		tv.tv_sec = 0;
 		tv.tv_usec = 250;
 
 		tmp_wait_sockets = wait_sockets;
 
-		res = select( max_sock + 1, &tmp_wait_sockets, NULL, NULL, &tv );
+		res = select(max_sock + 1, &tmp_wait_sockets, NULL, NULL, &tv);
 
-		if ( res > 0 ) {
+		if (res > 0) {
 
 			max_sock = -1;
 
-			list_for_each_safe( kismet_pos, kismet_pos_tmp, &kismet_src_list ) {
+			list_for_each_safe(kismet_pos, kismet_pos_tmp, &kismet_src_list) {
 
-				kismet_src = list_entry( kismet_pos, struct kismet_src, list );
+				kismet_src = list_entry(kismet_pos, struct kismet_src, list);
 
-				if ( FD_ISSET( kismet_src->sock, &tmp_wait_sockets ) ) {
+				if (FD_ISSET(kismet_src->sock, &tmp_wait_sockets)) {
 
-					status = read( kismet_src->sock, buff, sizeof( buff ) );
+					status = read(kismet_src->sock, buff, sizeof(buff));
 
-					if ( status > 0 ) {
+					if (status > 0) {
 
-						if ( kismet_src->sock > max_sock )
+						if (kismet_src->sock > max_sock)
 							max_sock = kismet_src->sock;
 
 						buff[status] = '\0';
 
 						/* check for potential buffer overflow */
-						if ( ( strlen( kismet_src->recv_buff ) + strlen( buff ) ) < 1500 ) {
+						if ((strlen(kismet_src->recv_buff) + strlen(buff)) < 1500) {
 
-							strncat( kismet_src->recv_buff, buff, 1000 );
+							strncat(kismet_src->recv_buff, buff, 1000);
 
 						} else {
 
 							/* hope that carriage return is now in buffer */
-							if ( strlen( kismet_src->recv_buff ) < 1500 ) {
+							if (strlen(kismet_src->recv_buff) < 1500) {
 
-								printf( "WARNING: receive buffer almost filled without *any* carriage return within that data !\nAppending truncated buffer to receive buffer to prevent buffer overflow.\n" );
-								strncat( kismet_src->recv_buff, buff, 1500 - strlen( kismet_src->recv_buff ) );
+								printf("WARNING: receive buffer almost filled without *any* carriage return within that data !\nAppending truncated buffer to receive buffer to prevent buffer overflow.\n");
+								strncat(kismet_src->recv_buff, buff, 1500 - strlen(kismet_src->recv_buff));
 
 							} else {
 
-								printf( "ERROR: receive buffer filled without *any* carriage return within that data !\nClearing receive buffer to prevent buffer overflow.\n" );
-								strncpy( kismet_src->recv_buff, buff, 1000 );
+								printf("ERROR: receive buffer filled without *any* carriage return within that data !\nClearing receive buffer to prevent buffer overflow.\n");
+								strncpy(kismet_src->recv_buff, buff, 1000);
 
 							}
 
 						}
 
-						parse_buffer( kismet_src );
+						parse_buffer(kismet_src);
 
 						/* printf( "buffer length: %i\n", strlen( kismet_src->recv_buff ) ); */
 
 					} else {
 
-						if ( status < 0 ) {
+						if (status < 0) {
 
-							printf( "Error - can't read message from %s:%i: %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno) );
+							printf("Error - can't read message from %s:%i: %s\n", kismet_src->kismet_ip, kismet_src->port, strerror(errno));
 
 						} else {
 
-							printf( "Kismet server %s:%i closed connection ...\n", kismet_src->kismet_ip, kismet_src->port );
+							printf("Kismet server %s:%i closed connection ...\n", kismet_src->kismet_ip, kismet_src->port);
 
 						}
 
 						FD_CLR(kismet_src->sock, &wait_sockets);
-						close( kismet_src->sock );
+						close(kismet_src->sock);
 
-						list_del( kismet_pos );
-						free( kismet_src->kismet_ip );
-						free( kismet_pos );
+						list_del(kismet_pos);
+						free(kismet_src->kismet_ip);
+						free(kismet_pos);
 
 						num_kismet_sources--;
 
@@ -553,16 +553,16 @@
 
 				} else {
 
-					if ( kismet_src->sock > max_sock )
+					if (kismet_src->sock > max_sock)
 						max_sock = kismet_src->sock;
 
 				}
 
 			}
 
-		} else if ( ( res < 0 ) && (errno != EINTR) ) {
+		} else if ((res < 0) && (errno != EINTR)) {
 
-			printf( "Error - can't select: %s\n", strerror(errno) );
+			printf("Error - can't select: %s\n", strerror(errno));
 			break;
 
 		}
@@ -571,9 +571,9 @@
 
 		list_for_each_safe(kismet_pos, kismet_pos_tmp, &Network_list) {
 
-			wlan_network = list_entry(kismet_pos, struct wlan_network, list);
+		 wlan_network = list_entry(kismet_pos, struct wlan_network, list);
 
-			printf( "   => %s\n", wlan_network->bssid );
+		 printf( "   => %s\n", wlan_network->bssid );
 
 		}
 
@@ -581,30 +581,30 @@
 
 		list_for_each_safe(kismet_pos, kismet_pos_tmp, &Client_list) {
 
-			wlan_client = list_entry(kismet_pos, struct wlan_client, list);
+		 wlan_client = list_entry(kismet_pos, struct wlan_client, list);
 
-			printf( "   => %s belonging to %s\n", wlan_client->mac, ( wlan_client->wlan_network == NULL ? "unknown" : wlan_client->wlan_network->bssid ) );
+		 printf( "   => %s belonging to %s\n", wlan_client->mac, ( wlan_client->wlan_network == NULL ? "unknown" : wlan_client->wlan_network->bssid ) );
 
 		} */
 
 	}
 
 
-	if ( Kism3d_aborted ) {
+	if (Kism3d_aborted) {
 
-		printf( "Closing all sockets ... \n" );
+		printf("Closing all sockets ... \n");
 		list_for_each(kismet_pos, &kismet_src_list) {
 
-			kismet_src = list_entry( kismet_pos, struct kismet_src, list );
+			kismet_src = list_entry(kismet_pos, struct kismet_src, list);
 
-			close( kismet_src->sock );
+			close(kismet_src->sock);
 
 		}
 
 	} else {
 
 		Kism3d_aborted = 1;
-		pthread_join( s3d_thread_id, NULL );
+		pthread_join(s3d_thread_id, NULL);
 
 	}
 

Modified: trunk/apps/kism3d/kism3d.h
===================================================================
--- trunk/apps/kism3d/kism3d.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/kism3d/kism3d.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -92,12 +92,12 @@
 
 
 
-void *alloc_memory( int len );
-unsigned int get_time( void );
-struct wlan_network *get_wlan_network( char *bssid );
-struct wlan_network *find_wlan_network( char *bssid );
-struct wlan_client *get_wlan_client( char *mac );
-void* gui_main( void *unused );
+void *alloc_memory(int len);
+unsigned int get_time(void);
+struct wlan_network *get_wlan_network(char *bssid);
+struct wlan_network *find_wlan_network(char *bssid);
+struct wlan_client *get_wlan_client(char *mac);
+void* gui_main(void *unused);
 
 
 

Modified: trunk/apps/kism3d/list.h
===================================================================
--- trunk/apps/kism3d/list.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/kism3d/list.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -30,42 +30,42 @@
 
 
 #define DEFINE_LIST_HEAD(name) \
-	struct list_head name = { &(name), &(name) }
+ struct list_head name = { &(name), &(name) }
 
 #define INIT_LIST_HEAD(ptr) do { \
-	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
+ (ptr)->next = (ptr); (ptr)->prev = (ptr); \
 } while (0)
 
 
 /**
- * list_for_each	-	iterate over a list
- * @pos:	the &struct list_head to use as a loop counter.
- * @head:	the head for your list.
+ * list_for_each - iterate over a list
+ * @pos: the &struct list_head to use as a loop counter.
+ * @head: the head for your list.
  */
 #define list_for_each(pos, head) \
-	for (pos = (head)->next; pos != (head); \
-        	pos = pos->next)
+ for (pos = (head)->next; pos != (head); \
+         pos = pos->next)
 
 
 /**
  * list_for_each_safe - iterate over a list safe against removal of list entry
- * @pos:	the &struct list_head to use as a loop counter.
- * @n:		another &struct list_head to use as temporary storage
- * @head:	the head for your list.
+ * @pos: the &struct list_head to use as a loop counter.
+ * @n:  another &struct list_head to use as temporary storage
+ * @head: the head for your list.
  */
 #define list_for_each_safe(pos, n, head) \
-	for (pos = (head)->next, n = pos->next; pos != (head); \
-		pos = n, n = pos->next)
+ for (pos = (head)->next, n = pos->next; pos != (head); \
+  pos = n, n = pos->next)
 
 
 /**
  * list_entry - get the struct for this entry
- * @ptr:	the &struct list_head pointer.
- * @type:	the type of the struct this is embedded in.
- * @member:	the name of the list_struct within the struct.
+ * @ptr: the &struct list_head pointer.
+ * @type: the type of the struct this is embedded in.
+ * @member: the name of the list_struct within the struct.
  */
 #define list_entry(ptr, type, member) \
-	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
+ ((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
 
 
 

Modified: trunk/apps/kism3d/network.c
===================================================================
--- trunk/apps/kism3d/network.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/kism3d/network.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -29,23 +29,23 @@
 
 
 
-struct wlan_network *get_wlan_network( char *bssid ) {
+struct wlan_network *get_wlan_network(char *bssid) {
 
 	struct wlan_network *wlan_network;
 
 
-	wlan_network = find_wlan_network( bssid );
+	wlan_network = find_wlan_network(bssid);
 
-	if ( wlan_network != NULL )
+	if (wlan_network != NULL)
 		return wlan_network;
 
 
 	/* we reached the end of the list and must create a new wlan_network */
-	wlan_network = alloc_memory( sizeof( struct wlan_network ) );
+	wlan_network = alloc_memory(sizeof(struct wlan_network));
 
 	INIT_LIST_HEAD(&wlan_network->list);
 
-	strncpy( wlan_network->bssid, bssid, 18 );
+	strncpy(wlan_network->bssid, bssid, 18);
 
 	wlan_network->type = -1;
 	wlan_network->chan = -1;
@@ -78,7 +78,7 @@
 
 
 
-struct wlan_network *find_wlan_network( char *bssid ) {
+struct wlan_network *find_wlan_network(char *bssid) {
 
 	struct list_head *network_pos;
 	struct wlan_network *wlan_network;
@@ -88,7 +88,7 @@
 
 		wlan_network = list_entry(network_pos, struct wlan_network, list);
 
-		if ( strncmp( wlan_network->bssid, bssid, 18 ) == 0 )
+		if (strncmp(wlan_network->bssid, bssid, 18) == 0)
 			return wlan_network;
 
 	}

Modified: trunk/apps/meshs3d/allocate.c
===================================================================
--- trunk/apps/meshs3d/allocate.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/allocate.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -60,15 +60,15 @@
 };
 
 
-void addMemory( uint32_t length, int32_t tag )
+void addMemory(uint32_t length, int32_t tag)
 {
 
 	struct memoryUsage *walker;
 
 
-	for ( walker = memoryList; walker != NULL; walker = walker->next ) {
+	for (walker = memoryList; walker != NULL; walker = walker->next) {
 
-		if ( walker->tag == tag ) {
+		if (walker->tag == tag) {
 
 			walker->counter++;
 			break;
@@ -77,9 +77,9 @@
 
 	}
 
-	if ( walker == NULL ) {
+	if (walker == NULL) {
 
-		walker = malloc( sizeof(struct memoryUsage) );
+		walker = malloc(sizeof(struct memoryUsage));
 
 		walker->length = length;
 		walker->tag = tag;
@@ -93,19 +93,19 @@
 }
 
 
-void removeMemory( int32_t tag, int32_t freetag )
+void removeMemory(int32_t tag, int32_t freetag)
 {
 
 	struct memoryUsage *walker;
 
 
-	for ( walker = memoryList; walker != NULL; walker = walker->next ) {
+	for (walker = memoryList; walker != NULL; walker = walker->next) {
 
-		if ( walker->tag == tag ) {
+		if (walker->tag == tag) {
 
-			if ( walker->counter == 0 ) {
+			if (walker->counter == 0) {
 
-				fprintf( stderr, "Freeing more memory than was allocated: malloc tag = %d, free tag = %d\n", tag, freetag );
+				fprintf(stderr, "Freeing more memory than was allocated: malloc tag = %d, free tag = %d\n", tag, freetag);
 				exit(1);
 
 			}
@@ -117,9 +117,9 @@
 
 	}
 
-	if ( walker == NULL ) {
+	if (walker == NULL) {
 
-		fprintf( stderr, "Freeing memory that was never allocated: malloc tag = %d, free tag = %d\n", tag, freetag );
+		fprintf(stderr, "Freeing memory that was never allocated: malloc tag = %d, free tag = %d\n", tag, freetag);
 		exit(1);
 
 	}
@@ -141,12 +141,12 @@
 
 	struct memoryUsage *memoryWalker;
 
-	fprintf( stderr, " \nMemory usage information:\n" );
+	fprintf(stderr, " \nMemory usage information:\n");
 
-	for ( memoryWalker = memoryList; memoryWalker != NULL; memoryWalker = memoryWalker->next ) {
+	for (memoryWalker = memoryList; memoryWalker != NULL; memoryWalker = memoryWalker->next) {
 
-		if ( memoryWalker->counter != 0 )
-			fprintf( stderr, "   tag: %d, num malloc: %4i, bytes per malloc: %u, total: %6i\n", memoryWalker->tag, memoryWalker->counter, memoryWalker->length, memoryWalker->counter * memoryWalker->length );
+		if (memoryWalker->counter != 0)
+			fprintf(stderr, "   tag: %d, num malloc: %4i, bytes per malloc: %u, total: %6i\n", memoryWalker->tag, memoryWalker->counter, memoryWalker->length, memoryWalker->counter * memoryWalker->length);
 
 	}
 
@@ -209,7 +209,7 @@
 
 #if defined MEMORY_USAGE
 
-	addMemory( length, tag );
+	addMemory(length, tag);
 
 #endif
 
@@ -302,7 +302,7 @@
 
 #if defined MEMORY_USAGE
 
-	removeMemory( chunkHeader->tag, tag );
+	removeMemory(chunkHeader->tag, tag);
 
 #endif
 

Modified: trunk/apps/meshs3d/hash.c
===================================================================
--- trunk/apps/meshs3d/hash.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/hash.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -18,7 +18,7 @@
  */
 
 
-#include <stdio.h>		/* NULL */
+#include <stdio.h>  /* NULL */
 #include "hash.h"
 #include "allocate.h"
 
@@ -27,8 +27,8 @@
 void hash_init(struct hashtable_t *hash)
 {
 	int i;
-	hash->elements=0;
-	for (i=0 ; i<hash->size ; i++) {
+	hash->elements = 0;
+	for (i = 0 ; i < hash->size ; i++) {
 		hash->table[i] = NULL;
 	}
 }
@@ -42,16 +42,16 @@
 	struct element_t *bucket, *last_bucket;
 	int i;
 
-	for (i=0; i<hash->size; i++) {
+	for (i = 0; i < hash->size; i++) {
 
-		bucket= hash->table[i];
+		bucket = hash->table[i];
 		while (bucket != NULL) {
 
-			if (free_cb!=NULL)
-				free_cb( bucket->data );
+			if (free_cb != NULL)
+				free_cb(bucket->data);
 
-			last_bucket= bucket;
-			bucket= bucket->next;
+			last_bucket = bucket;
+			bucket = bucket->next;
 			debugFree(last_bucket, 1301);
 
 		}
@@ -66,8 +66,8 @@
 void hash_destroy(struct hashtable_t *hash)
 {
 
-	debugFree( hash->table, 1302 );
-	debugFree( hash, 1303 );
+	debugFree(hash->table, 1302);
+	debugFree(hash, 1303);
 
 }
 
@@ -80,24 +80,24 @@
 	struct hash_it_t *iter;
 
 	if (iter_in == NULL) {
-		iter= debugMalloc(sizeof(struct hash_it_t), 301);
+		iter = debugMalloc(sizeof(struct hash_it_t), 301);
 		iter->index =  -1;
 		iter->bucket = NULL;
 		iter->prev_bucket = NULL;
 	} else
-		iter= iter_in;
+		iter = iter_in;
 
 	/* sanity checks first (if our bucket got deleted in the last iteration): */
-	if (iter->bucket!=NULL) {
+	if (iter->bucket != NULL) {
 		if (iter->first_bucket != NULL) {
 
 			/* we're on the first element and it got removed after the last iteration. */
 			if ((*iter->first_bucket) != iter->bucket) {
 
 				/* there are still other elements in the list */
-				if ( (*iter->first_bucket) != NULL ) {
+				if ((*iter->first_bucket) != NULL) {
 					iter->prev_bucket = NULL;
-					iter->bucket= (*iter->first_bucket);
+					iter->bucket = (*iter->first_bucket);
 					iter->first_bucket = &hash->table[ iter->index ];
 					return(iter);
 				} else {
@@ -106,23 +106,23 @@
 
 			}
 
-		} else if ( iter->prev_bucket != NULL ) {
+		} else if (iter->prev_bucket != NULL) {
 
 			/* we're not on the first element, and the bucket got removed after the last iteration.
 			* the last bucket's next pointer is not pointing to our actual bucket anymore.
 			* select the next. */
-			if ( iter->prev_bucket->next != iter->bucket )
-				iter->bucket= iter->prev_bucket;
+			if (iter->prev_bucket->next != iter->bucket)
+				iter->bucket = iter->prev_bucket;
 
 		}
 
 	}
 
 	/* now as we are sane, select the next one if there is some */
-	if (iter->bucket!=NULL) {
-		if (iter->bucket->next!=NULL) {
-			iter->prev_bucket= iter->bucket;
-			iter->bucket= iter->bucket->next;
+	if (iter->bucket != NULL) {
+		if (iter->bucket->next != NULL) {
+			iter->prev_bucket = iter->bucket;
+			iter->bucket = iter->bucket->next;
 			iter->first_bucket = NULL;
 			return(iter);
 		}
@@ -130,14 +130,14 @@
 	/* if not returned yet, we've reached the last one on the index and have to search forward */
 
 	iter->index++;
-	while ( iter->index < hash->size ) {		/* go through the entries of the hash table */
+	while (iter->index < hash->size) {    /* go through the entries of the hash table */
 		if ((hash->table[ iter->index ]) != NULL) {
 			iter->prev_bucket = NULL;
 			iter->bucket = hash->table[ iter->index ];
 			iter->first_bucket = &hash->table[ iter->index ];
-			return(iter);						/* if this table entry is not null, return it */
+			return(iter);      /* if this table entry is not null, return it */
 		} else
-			iter->index++;						/* else, go to the next */
+			iter->index++;      /* else, go to the next */
 	}
 	/* nothing to iterate over anymore */
 	debugFree(iter, 1304);
@@ -149,19 +149,19 @@
 struct hashtable_t *hash_new(int size, hashdata_compare_cb compare, hashdata_choose_cb choose) {
 	struct hashtable_t *hash;
 
-	hash= debugMalloc( sizeof(struct hashtable_t) , 302);
-	if ( hash == NULL ) 			/* could not allocate the hash control structure */
+	hash = debugMalloc(sizeof(struct hashtable_t) , 302);
+	if (hash == NULL)      /* could not allocate the hash control structure */
 		return (NULL);
 
-	hash->size= size;
-	hash->table= debugMalloc( sizeof(struct element_t *) * size, 303);
-	if ( hash->table == NULL ) {	/* could not allocate the table */
+	hash->size = size;
+	hash->table = debugMalloc(sizeof(struct element_t *) * size, 303);
+	if (hash->table == NULL) {   /* could not allocate the table */
 		debugFree(hash, 1305);
 		return(NULL);
 	}
 	hash_init(hash);
-	hash->compare= compare;
-	hash->choose= choose;
+	hash->compare = compare;
+	hash->choose = choose;
 	return(hash);
 }
 
@@ -172,26 +172,26 @@
 	int index;
 	struct element_t *bucket, *prev_bucket = NULL;
 
-	index = hash->choose( data, hash->size );
+	index = hash->choose(data, hash->size);
 	bucket = hash->table[index];
 
-	while ( bucket!=NULL ) {
-		if (0 == hash->compare( bucket->data, data ))
+	while (bucket != NULL) {
+		if (0 == hash->compare(bucket->data, data))
 			return(-1);
 
 		prev_bucket = bucket;
-		bucket= bucket->next;
+		bucket = bucket->next;
 	}
 
 	/* found the tail of the list, add new element */
-	if (NULL == (bucket= debugMalloc(sizeof(struct element_t),304)))
+	if (NULL == (bucket = debugMalloc(sizeof(struct element_t), 304)))
 		return(-1); /* debugMalloc failed */
 
-	bucket->data= data;				/* init the new bucket */
-	bucket->next= NULL;
+	bucket->data = data;   /* init the new bucket */
+	bucket->next = NULL;
 
 	/* and link it */
-	if ( prev_bucket == NULL ) {
+	if (prev_bucket == NULL) {
 		hash->table[index] = bucket;
 	} else {
 		prev_bucket->next = bucket;
@@ -207,14 +207,14 @@
 	int index;
 	struct element_t *bucket;
 
-	index = hash->choose( keydata , hash->size );
+	index = hash->choose(keydata , hash->size);
 	bucket = hash->table[index];
 
-	while ( bucket!=NULL ) {
-		if (0 == hash->compare( bucket->data, keydata ))
-			return( bucket->data );
+	while (bucket != NULL) {
+		if (0 == hash->compare(bucket->data, keydata))
+			return(bucket->data);
 
-		bucket= bucket->next;
+		bucket = bucket->next;
 	}
 
 	return(NULL);
@@ -228,18 +228,18 @@
 {
 	void *data_save;
 
-	data_save = hash_it_t->bucket->data;	/* save the pointer to the data */
+	data_save = hash_it_t->bucket->data; /* save the pointer to the data */
 
-	if ( hash_it_t->prev_bucket != NULL ) {
+	if (hash_it_t->prev_bucket != NULL) {
 		hash_it_t->prev_bucket->next = hash_it_t->bucket->next;
-	} else if ( hash_it_t->first_bucket != NULL ) {
+	} else if (hash_it_t->first_bucket != NULL) {
 		(*hash_it_t->first_bucket) = hash_it_t->bucket->next;
 	}
 
 	debugFree(hash_it_t->bucket, 1306);
 
 	hash->elements--;
-	return( data_save );
+	return(data_save);
 
 }
 
@@ -252,18 +252,18 @@
 {
 	struct hash_it_t hash_it_t;
 
-	hash_it_t.index = hash->choose( data, hash->size );
+	hash_it_t.index = hash->choose(data, hash->size);
 	hash_it_t.bucket = hash->table[hash_it_t.index];
 	hash_it_t.prev_bucket = NULL;
 
-	while ( hash_it_t.bucket!=NULL ) {
-		if (0 == hash->compare( hash_it_t.bucket->data, data )) {
+	while (hash_it_t.bucket != NULL) {
+		if (0 == hash->compare(hash_it_t.bucket->data, data)) {
 			hash_it_t.first_bucket = (hash_it_t.bucket == hash->table[hash_it_t.index] ? &hash->table[ hash_it_t.index ] : NULL);
-			return( hash_remove_bucket(hash, &hash_it_t) );
+			return(hash_remove_bucket(hash, &hash_it_t));
 		}
 
 		hash_it_t.prev_bucket = hash_it_t.bucket;
-		hash_it_t.bucket= hash_it_t.bucket->next;
+		hash_it_t.bucket = hash_it_t.bucket->next;
 	}
 
 	return(NULL);
@@ -278,20 +278,20 @@
 	int i;
 
 	/* initialize a new hash with the new size */
-	if (NULL == (new_hash= hash_new(size, hash->compare, hash->choose)))
+	if (NULL == (new_hash = hash_new(size, hash->compare, hash->choose)))
 		return(NULL);
 
 	/* copy the elements */
-	for (i=0; i<hash->size; i++) {
-		bucket= hash->table[i];
+	for (i = 0; i < hash->size; i++) {
+		bucket = hash->table[i];
 		while (bucket != NULL) {
-			hash_add( new_hash, bucket->data );
-			bucket= bucket->next;
+			hash_add(new_hash, bucket->data);
+			bucket = bucket->next;
 		}
 	}
-	hash_delete(hash, NULL);	/* remove hash and eventual overflow buckets but not the content itself. */
+	hash_delete(hash, NULL); /* remove hash and eventual overflow buckets but not the content itself. */
 
-	return( new_hash);
+	return(new_hash);
 
 }
 
@@ -302,13 +302,13 @@
 	int i;
 	struct element_t *bucket;
 
-	for (i=0; i<hash->size;i++) {
-		printf("[%d] ",i);
-		bucket= hash->table[i];
+	for (i = 0; i < hash->size;i++) {
+		printf("[%d] ", i);
+		bucket = hash->table[i];
 
 		while (bucket != NULL) {
 			printf("-> [%10p] ", (void *)bucket);
-			bucket= bucket->next;
+			bucket = bucket->next;
 		}
 
 		printf("\n");

Modified: trunk/apps/meshs3d/hash.h
===================================================================
--- trunk/apps/meshs3d/hash.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/hash.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,8 +23,8 @@
 typedef void (*hashdata_free_cb)(void *);
 
 struct element_t {
-	void *data;						/* pointer to the data */
-	struct element_t *next;			/* overflow bucket pointer */
+	void *data;      /* pointer to the data */
+	struct element_t *next;   /* overflow bucket pointer */
 };
 
 struct hash_it_t {
@@ -35,53 +35,53 @@
 };
 
 struct hashtable_t {
-	struct element_t **table;					/* the hashtable itself, with the buckets */
-	int elements;								/* number of elements registered */
-	int size;									/* size of hashtable */
-	hashdata_compare_cb compare;			    /* callback to a compare function.
-												 * should compare 2 element datas for their keys,
-												 * return 0 if same and not 0 if not same */
-	hashdata_choose_cb choose;					/* the hashfunction, should return an index based
-												 * on the key in the data of the first argument
-												 * and the size the second */
+	struct element_t **table;     /* the hashtable itself, with the buckets */
+	int elements;        /* number of elements registered */
+	int size;         /* size of hashtable */
+	hashdata_compare_cb compare;       /* callback to a compare function.
+             * should compare 2 element datas for their keys,
+             * return 0 if same and not 0 if not same */
+	hashdata_choose_cb choose;     /* the hashfunction, should return an index based
+             * on the key in the data of the first argument
+             * and the size the second */
 };
 
 /* clears the hash */
-void 				 hash_init(struct hashtable_t *hash);
+void      hash_init(struct hashtable_t *hash);
 
 /* allocates and clears the hash */
-struct hashtable_t	*hash_new(int size, hashdata_compare_cb compare, hashdata_choose_cb choose);
+struct hashtable_t *hash_new(int size, hashdata_compare_cb compare, hashdata_choose_cb choose);
 
 /* remove bucket (this might be used in hash_iterate() if you already found the bucket
  * you want to delete and don't need the overhead to find it again with hash_remove().
  * But usually, you don't want to use this function, as it fiddles with hash-internals. */
-void 				*hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t);
+void     *hash_remove_bucket(struct hashtable_t *hash, struct hash_it_t *hash_it_t);
 
 /* remove the hash structure. if hashdata_free_cb != NULL,
  * this function will be called to remove the elements inside of the hash.
  * if you don't remove the elements, memory might be leaked. */
-void 				 hash_delete(struct hashtable_t *hash, hashdata_free_cb free_cb);
+void      hash_delete(struct hashtable_t *hash, hashdata_free_cb free_cb);
 
 /* free only the hashtable and the hash itself. */
-void 				 hash_destroy(struct hashtable_t *hash);
+void      hash_destroy(struct hashtable_t *hash);
 
 /* adds data to the hashtable. returns 0 on success, -1 on error */
-int 				 hash_add(struct hashtable_t *hash, void *data);
+int      hash_add(struct hashtable_t *hash, void *data);
 
 /* removes data from hash, if found. returns pointer do data on success,
  * so you can remove the used structure yourself, or NULL on error .
  * data could be the structure you use with just the key filled,
  * we just need the key for comparing. */
-void 				*hash_remove(struct hashtable_t *hash, void *data);
+void     *hash_remove(struct hashtable_t *hash, void *data);
 
 /* adds data to the hashtable. returns 0 on success, -1 on error */
-void 				*hash_find(struct hashtable_t *hash, void *keydata);
+void     *hash_find(struct hashtable_t *hash, void *keydata);
 
 /* resize the hash, returns the pointer to the new hash or NULL on error. removes the old hash on success */
-struct hashtable_t	*hash_resize(struct hashtable_t *hash, int size);
+struct hashtable_t *hash_resize(struct hashtable_t *hash, int size);
 
 /* print the hash table for debugging */
-void 				 hash_debug( struct hashtable_t *hash);
+void      hash_debug(struct hashtable_t *hash);
 
 /* iterate though the hash. first element is selected with iter_in NULL.
  * use the returned iterator to access the elements until hash_it_t returns NULL. */

Modified: trunk/apps/meshs3d/main.c
===================================================================
--- trunk/apps/meshs3d/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -45,7 +45,7 @@
 };   /* 100 mili seconds */
 
 
-void init_globals( void )
+void init_globals(void)
 {
 	Global.debug = 1;
 	Global.obj_node_hna = 0;
@@ -58,39 +58,39 @@
 }
 
 
-void print_usage( void )
+void print_usage(void)
 {
 
-	printf( "Usage is olsrs3d [options] [-- [s3d options]]\n" );
-	printf( "olsrs3d options:\n" );
-	printf( "   -h\tprint this short help\n" );
-	printf( "   -d\tenable debug mode\n" );
-	printf( "   -H\tconnect to olsr node [default: localhost]\n" );
+	printf("Usage is olsrs3d [options] [-- [s3d options]]\n");
+	printf("olsrs3d options:\n");
+	printf("   -h\tprint this short help\n");
+	printf("   -d\tenable debug mode\n");
+	printf("   -H\tconnect to olsr node [default: localhost]\n");
 	s3d_usage();
 }
 
 float dist(float p1[], float p2[])
 {
 	float p[3];
-	p[0]=p1[0]-p2[0];
-	p[1]=p1[1]-p2[1];
-	p[2]=p1[2]-p2[2];
+	p[0] = p1[0] - p2[0];
+	p[1] = p1[1] - p2[1];
+	p[2] = p1[2] - p2[2];
 	return (sqrt(p[0]*p[0]   +  p[1]*p[1]  +  p[2]*p[2]));
 }
 
 float dirt(float p1[], float p2[], float p3[])
 {
 	float d;
-	d=dist(p1,p2);
-	if (d==0) {
-		p3[0]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		p3[1]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		p3[2]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		d=s3d_vector_length(p3);
+	d = dist(p1, p2);
+	if (d == 0) {
+		p3[0] = ((float) 0.2 * rand()) / RAND_MAX - 0.1;
+		p3[1] = ((float) 0.2 * rand()) / RAND_MAX - 0.1;
+		p3[2] = ((float) 0.2 * rand()) / RAND_MAX - 0.1;
+		d = s3d_vector_length(p3);
 	} else {
-		p3[0]=p2[0]-p1[0];
-		p3[1]=p2[1]-p1[1];
-		p3[2]=p2[2]-p1[2];
+		p3[0] = p2[0] - p1[0];
+		p3[1] = p2[1] - p1[1];
+		p3[2] = p2[2] - p1[2];
 	}
 	return(d);
 }
@@ -100,29 +100,29 @@
 	struct node *node;
 	struct hash_it_t *hashit;
 
-	if ( node_hash->elements == 0 )
+	if (node_hash->elements == 0)
 		return;
 	hashit = NULL;
-	while ( NULL != ( hashit = hash_iterate( node_hash, hashit ) ) ) {
+	while (NULL != (hashit = hash_iterate(node_hash, hashit))) {
 		node = (struct node *) hashit->bucket->data;
-		if ( node->node_type_modified ) {
+		if (node->node_type_modified) {
 
 			node->node_type_modified = 0;
-			if ( node->obj_id != -1 ) {
-				s3d_del_object( node->obj_id );
+			if (node->obj_id != -1) {
+				s3d_del_object(node->obj_id);
 			}
 
-			if ( node->desc_id != -1 ) s3d_del_object( node->desc_id );
+			if (node->desc_id != -1) s3d_del_object(node->desc_id);
 
-			if ( node->node_type == 1 ) {
-				node->obj_id = s3d_clone( Global.obj_node_inet );
-			} else if ( node->node_type == 2 ) {
-				node->obj_id = s3d_clone( Global.obj_node_hna );
+			if (node->node_type == 1) {
+				node->obj_id = s3d_clone(Global.obj_node_inet);
+			} else if (node->node_type == 2) {
+				node->obj_id = s3d_clone(Global.obj_node_hna);
 			} else {
-				node->obj_id = s3d_clone( Global.obj_node_normal );
+				node->obj_id = s3d_clone(Global.obj_node_normal);
 			}
 
-			s3d_flags_on( node->obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(node->obj_id, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
 		}
 	}
@@ -131,65 +131,65 @@
 
 void mov_add(float mov[], float p[], float fac)
 {
-	/*	if (fac>1000)
-			return;
-		fac=1000; */
-	mov[0]+=fac*p[0];
-	mov[1]+=fac*p[1];
-	mov[2]+=fac*p[2];
+	/* if (fac>1000)
+	  return;
+	 fac=1000; */
+	mov[0] += fac * p[0];
+	mov[1] += fac * p[1];
+	mov[2] += fac * p[2];
 }
 
-void move_meshnode( struct node *node )
+void move_meshnode(struct node *node)
 {
-	float null_vec[3] = {0,0,0};
+	float null_vec[3] = {0, 0, 0};
 	float tmp_mov_vec[3];
 	float distance;
 
-	if ( !( ( node->mov_vec[0] == 0 ) && ( node->mov_vec[1] == 0 ) && ( node->mov_vec[2] == 0 ) ) && node->visible ) {
-		distance = dirt( node->pos_vec, null_vec, tmp_mov_vec );
-		mov_add( node->mov_vec, tmp_mov_vec, distance / 100 ); /* move a little bit to point zero */
-		mov_add( node->mov_vec, tmp_mov_vec, 1 ); /* move a little bit to point zero */
+	if (!((node->mov_vec[0] == 0) && (node->mov_vec[1] == 0) && (node->mov_vec[2] == 0)) && node->visible) {
+		distance = dirt(node->pos_vec, null_vec, tmp_mov_vec);
+		mov_add(node->mov_vec, tmp_mov_vec, distance / 100);   /* move a little bit to point zero */
+		mov_add(node->mov_vec, tmp_mov_vec, 1);   /* move a little bit to point zero */
 
-		if ( ( distance = dist( node->mov_vec, null_vec ) ) > 10.0 )
-			mov_add( node->pos_vec, node->mov_vec, 1.0 / ( ( float ) distance ) );
+		if ((distance = dist(node->mov_vec, null_vec)) > 10.0)
+			mov_add(node->pos_vec, node->mov_vec, 1.0 / ((float) distance));
 		else
-			mov_add( node->pos_vec, node->mov_vec, 0.1 );
+			mov_add(node->pos_vec, node->mov_vec, 0.1);
 
-		s3d_translate( node->obj_id, node->pos_vec[0], node->pos_vec[1], node->pos_vec[2] );
+		s3d_translate(node->obj_id, node->pos_vec[0], node->pos_vec[1], node->pos_vec[2]);
 		/* reset movement vector */
 		node->mov_vec[0] = node->mov_vec[1] = node->mov_vec[2] = 0.0;
 	}
 }
 
-void calc_node_mov( void )
+void calc_node_mov(void)
 {
 
 	float distance;
-	float tmp_mov_vec[3],vertex_buf[6];
+	float tmp_mov_vec[3], vertex_buf[6];
 	float f;
 	int ip[2];
 	struct node_con *con;
 	struct node *first_node, *sec_node;
 	struct hash_it_t *hashit1, *hashit2;
 
-	if ( con_hash->elements == 0 )
+	if (con_hash->elements == 0)
 		return;
 	hashit1 = hashit2 = NULL;
-	while ( NULL != ( hashit1 = hash_iterate( node_hash, hashit1 ) ) ) {
+	while (NULL != (hashit1 = hash_iterate(node_hash, hashit1))) {
 		first_node = (struct node *) hashit1->bucket->data;
-		while ( NULL != ( hashit2 = hash_iterate( node_hash, hashit2 ) ) ) {
+		while (NULL != (hashit2 = hash_iterate(node_hash, hashit2))) {
 			sec_node = (struct node *) hashit2->bucket->data;
-			if ( first_node != sec_node ) {
+			if (first_node != sec_node) {
 				ip[0] = max(first_node->ip, sec_node->ip);
 				ip[1] = min(first_node->ip, sec_node->ip);
-				distance = dirt( first_node->pos_vec, sec_node->pos_vec, tmp_mov_vec );
-				if ( NULL != ( con = hash_find(con_hash, ip ) ) ) {
+				distance = dirt(first_node->pos_vec, sec_node->pos_vec, tmp_mov_vec);
+				if (NULL != (con = hash_find(con_hash, ip))) {
 					/* we have a connection */
-					f = ( ( con->etx1_sqrt + con->etx2_sqrt ) / 4.0 ) / distance;
-					mov_add( first_node->mov_vec, tmp_mov_vec,  1 / f - 1 );
-					mov_add( sec_node->mov_vec, tmp_mov_vec, -( 1 / f - 1 ) );
-					printf("------co---------\n%s %.2f %.2f %.2f\n%s %.2f %.2f %.2f\n", first_node->ip_string,first_node->mov_vec[0],first_node->mov_vec[1],first_node->mov_vec[2],
-					       sec_node->ip_string,sec_node->mov_vec[0],sec_node->mov_vec[1],sec_node->mov_vec[2]  );
+					f = ((con->etx1_sqrt + con->etx2_sqrt) / 4.0) / distance;
+					mov_add(first_node->mov_vec, tmp_mov_vec,  1 / f - 1);
+					mov_add(sec_node->mov_vec, tmp_mov_vec, -(1 / f - 1));
+					printf("------co---------\n%s %.2f %.2f %.2f\n%s %.2f %.2f %.2f\n", first_node->ip_string, first_node->mov_vec[0], first_node->mov_vec[1], first_node->mov_vec[2],
+					       sec_node->ip_string, sec_node->mov_vec[0], sec_node->mov_vec[1], sec_node->mov_vec[2]);
 
 					vertex_buf[0] = first_node->pos_vec[0];
 					vertex_buf[1] = first_node->pos_vec[1];
@@ -197,24 +197,24 @@
 					vertex_buf[3] = sec_node->pos_vec[0];
 					vertex_buf[4] = sec_node->pos_vec[1];
 					vertex_buf[5] = sec_node->pos_vec[2];
-					s3d_pep_vertices( con->obj_id, vertex_buf, 2 );
+					s3d_pep_vertices(con->obj_id, vertex_buf, 2);
 
-					s3d_pep_material( con->obj_id,
-					                  1.0,1.0,1.0,
-					                  1.0,1.0,1.0,
-					                  1.0,1.0,1.0
+					s3d_pep_material(con->obj_id,
+					                 1.0, 1.0, 1.0,
+					                 1.0, 1.0, 1.0,
+					                 1.0, 1.0, 1.0
 					                );
 
 				} else {
 					/* we have no connection */
 					if (distance < 0.1) distance = 0.1;
-					mov_add( first_node->mov_vec, tmp_mov_vec, 100 / ( distance * distance ) );
-					mov_add( sec_node->mov_vec, tmp_mov_vec, -100 / ( distance * distance ) );
-					printf("------nco---------\n%s %.2f %.2f %.2f\n%s %.2f %.2f %.2f\n", first_node->ip_string,first_node->mov_vec[0],first_node->mov_vec[1],first_node->mov_vec[2],
-					       sec_node->ip_string,sec_node->mov_vec[0],sec_node->mov_vec[1],sec_node->mov_vec[2]  );
+					mov_add(first_node->mov_vec, tmp_mov_vec, 100 / (distance * distance));
+					mov_add(sec_node->mov_vec, tmp_mov_vec, -100 / (distance * distance));
+					printf("------nco---------\n%s %.2f %.2f %.2f\n%s %.2f %.2f %.2f\n", first_node->ip_string, first_node->mov_vec[0], first_node->mov_vec[1], first_node->mov_vec[2],
+					       sec_node->ip_string, sec_node->mov_vec[0], sec_node->mov_vec[1], sec_node->mov_vec[2]);
 				}
-				move_meshnode( first_node );
-				move_meshnode( sec_node );
+				move_meshnode(first_node);
+				move_meshnode(sec_node);
 			}
 		}
 		/* first_node = hash_find( node_hash, &con->ip[0] );
@@ -241,36 +241,36 @@
 	handle_node();
 	/* move_nodes(); */
 
-	while ( ( net_result = net_main() ) != 0 ) {
-		if ( net_result == -1 ) {
+	while ((net_result = net_main()) != 0) {
+		if (net_result == -1) {
 			s3d_quit();
 			break;
 		}
 	}
-	nanosleep( &sleep_time, NULL );
+	nanosleep(&sleep_time, NULL);
 	return;
 }
 
 
-int main( int argc, char *argv[] )
+int main(int argc, char *argv[])
 {
 	int optchar;
 	char olsr_host[256];
 
 	init_globals();
-	strncpy( olsr_host, "127.0.0.1", 256 );
+	strncpy(olsr_host, "127.0.0.1", 256);
 	lbuf[0] = '\0';
 
-	while ( ( optchar = getopt ( argc, argv, "dhH:" ) ) != -1 ) {
+	while ((optchar = getopt(argc, argv, "dhH:")) != -1) {
 
-		switch ( optchar ) {
+		switch (optchar) {
 
 		case 'd':
 			Global.debug = 1;
 			break;
 
 		case 'H':
-			strncpy( olsr_host, optarg, 256 );
+			strncpy(olsr_host, optarg, 256);
 			break;
 
 		case 'h':
@@ -282,17 +282,17 @@
 
 	}
 
-	if ( Global.debug )
-		printf( "debug mode enabled ...\n" );
+	if (Global.debug)
+		printf("debug mode enabled ...\n");
 
 	/* initialize obj2ip linked list */
 	/* lst_initialize(); */
 
 	/* delete olsrs3d options */
-	while ( ( optind < argc ) && ( argv[optind][0] != '-' ) ) optind++;		/* optind may point to ip addr of '-H' */
+	while ((optind < argc) && (argv[optind][0] != '-')) optind++;        /* optind may point to ip addr of '-H' */
 	optind--;
-	argv[optind] = argv[0];		/* save program path */
-	argc -= optind;				/* jump over olsrs3d options */
+	argv[optind] = argv[0];  /* save program path */
+	argc -= optind;    /* jump over olsrs3d options */
 	argv += optind;
 
 	/* set extern int optind = 0 for parse_args in io.c */
@@ -306,22 +306,22 @@
 		s3d_set_callback(S3D_EVENT_KEY,keypress);
 		s3d_set_callback(S3D_EVENT_QUIT,stop); */
 
-		if (!s3d_init(&argc,&argv,"meshs3d")) {
+		if (!s3d_init(&argc, &argv, "meshs3d")) {
 
 			if (s3d_select_font("vera"))
 				printf("font not found\n");
 
-			Global.obj_node_normal = s3d_import_model_file( "objs/accesspoint.3ds" );
-			Global.obj_node_inet = s3d_import_model_file( "objs/accesspoint_inet.3ds" );
-			Global.obj_node_hna = s3d_import_model_file( "objs/internet.3ds" );
-			Global.obj_btn_close = s3d_import_model_file( "objs/btn_close.3ds" );
+			Global.obj_node_normal = s3d_import_model_file("objs/accesspoint.3ds");
+			Global.obj_node_inet = s3d_import_model_file("objs/accesspoint_inet.3ds");
+			Global.obj_node_hna = s3d_import_model_file("objs/internet.3ds");
+			Global.obj_btn_close = s3d_import_model_file("objs/btn_close.3ds");
 
-			Global.obj_s3d_url = s3d_import_model_file( "objs/s3d_berlios_de.3ds" );
+			Global.obj_s3d_url = s3d_import_model_file("objs/s3d_berlios_de.3ds");
 
-			s3d_translate( Global.obj_s3d_url, 0.75, -0.75, -1 );
-			s3d_scale( Global.obj_s3d_url, 0.07 );
-			s3d_link( Global.obj_s3d_url, 0 );
-			s3d_flags_on( Global.obj_s3d_url, S3D_OF_VISIBLE );
+			s3d_translate(Global.obj_s3d_url, 0.75, -0.75, -1);
+			s3d_scale(Global.obj_s3d_url, 0.07);
+			s3d_link(Global.obj_s3d_url, 0);
+			s3d_flags_on(Global.obj_s3d_url, S3D_OF_VISIBLE);
 
 			/* create_search_widget( 0, 0, 300 ); */
 

Modified: trunk/apps/meshs3d/meshs3d.h
===================================================================
--- trunk/apps/meshs3d/meshs3d.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/meshs3d.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,42 +25,42 @@
 
 #define max(x,y) ((x)>(y)?(x):(y))
 #define min(x,y) ((x)<(y)?(x):(y))
-#define NAMEMAX		128
-#define MAXLINESIZE 1000		/* lines in a digraph just shouldn't get that longer ... */
-#define MAXDATASIZE 100			/* max number of bytes we can get at once  */
+#define NAMEMAX  128
+#define MAXLINESIZE 1000  /* lines in a digraph just shouldn't get that longer ... */
+#define MAXDATASIZE 100   /* max number of bytes we can get at once  */
 
 /* linked list for the all connections */
 struct node_con {
 	unsigned int ip[2];
-	float etx1;							/* etx of left olsr node */
-	float etx2;						/* etx of right olsr node */
-	float etx1_sqrt;					/* sqrt of etx of left olsr node */
-	float etx2_sqrt;					/* sqrt etx of right olsr node */
-	int obj_id;								/* id of connection object in s3d */
+	float etx1;       /* etx of left olsr node */
+	float etx2;      /* etx of right olsr node */
+	float etx1_sqrt;     /* sqrt of etx of left olsr node */
+	float etx2_sqrt;     /* sqrt etx of right olsr node */
+	int obj_id;        /* id of connection object in s3d */
 	int color;
 	float rgb;
 };
 
 /* linked list for the neighbours of each olsr node */
 struct olsr_neigh_list {
-	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
-	struct olsr_con *olsr_con;							/* pointer to the connection */
+	struct olsr_neigh_list *next_olsr_neigh_list;  /* pointer to next neighbour */
+	struct olsr_con *olsr_con;       /* pointer to the connection */
 };
 
 
 /* we contruct a binary tree to handle the nodes */
 struct node {
 	unsigned int ip;
-	char ip_string[NAMEMAX];		/* host ip */
-	int node_type;					/* normal = 0, internet gateway = 1, via hna announced network = 2 */
-	int node_type_modified;			/* node_type modified flag */
-	int last_seen;					/* last seen counter */
-	int visible;					/* is this node visible or vanished */
-	float pos_vec[3];				/* position vector in 3d "space" */
-	float mov_vec[3];				/* move vector */
-	int obj_id;						/* id of node object in s3d */
-	int desc_id;					/* id of node description object in s3d */
-	float desc_length;				/* length of node description object in s3d */
+	char ip_string[NAMEMAX];  /* host ip */
+	int node_type;     /* normal = 0, internet gateway = 1, via hna announced network = 2 */
+	int node_type_modified;   /* node_type modified flag */
+	int last_seen;     /* last seen counter */
+	int visible;     /* is this node visible or vanished */
+	float pos_vec[3];    /* position vector in 3d "space" */
+	float mov_vec[3];    /* move vector */
+	int obj_id;      /* id of node object in s3d */
+	int desc_id;     /* id of node description object in s3d */
+	float desc_length;    /* length of node description object in s3d */
 };
 
 
@@ -73,11 +73,11 @@
 
 struct glob {
 	int debug;
-	int	obj_node_normal;
-	int	obj_node_inet;
-	int	obj_node_hna;
-	int	obj_btn_close;
-	int	obj_s3d_url;
+	int obj_node_normal;
+	int obj_node_inet;
+	int obj_node_hna;
+	int obj_btn_close;
+	int obj_s3d_url;
 	int obj_zero_point;
 };
 

Modified: trunk/apps/meshs3d/net.c
===================================================================
--- trunk/apps/meshs3d/net.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/net.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -46,7 +46,7 @@
 	struct hostent *he;
 	struct sockaddr_in their_addr; /* connector's address information  */
 
-	if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
+	if ((he = gethostbyname(host)) == NULL) {  /* get the host info  */
 		herror("gethostbyname");
 		return(1);
 	}
@@ -66,7 +66,7 @@
 		perror("connect");
 		return(1);
 	}
-	fcntl(sockfd,F_SETFL, O_NONBLOCK);
+	fcntl(sockfd, F_SETFL, O_NONBLOCK);
 	return(0);
 }
 
@@ -74,14 +74,14 @@
 {
 	static int net_read_count = 0;
 
-	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
-		if (errno==EAGAIN)
+	if ((numbytes = recv(sockfd, buf, MAXDATASIZE - 1, 0)) == -1) {
+		if (errno == EAGAIN)
 			return(0); /* well, that's okay ... */
 		perror("recv");
 		return(-1);
 	}
 
-	if (numbytes==0) {
+	if (numbytes == 0) {
 		printf("connection reset\n");
 		return(-1);
 	}
@@ -89,22 +89,22 @@
 	buf[numbytes] = '\0';
 
 	/* check for potential buffer overflow */
-	if ( ( strlen( lbuf ) + strlen( buf ) ) < MAXLINESIZE ) {
+	if ((strlen(lbuf) + strlen(buf)) < MAXLINESIZE) {
 
-		strncat( lbuf, buf, MAXLINESIZE );
+		strncat(lbuf, buf, MAXLINESIZE);
 
 	} else {
 
 		/* hope that carriage return is now in buf */
-		if ( strlen( lbuf ) < MAXLINESIZE ) {
+		if (strlen(lbuf) < MAXLINESIZE) {
 
-			if ( Global.debug ) printf( "WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n" );
-			strncat( lbuf, buf, MAXLINESIZE - strlen( lbuf ) );
+			if (Global.debug) printf("WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n");
+			strncat(lbuf, buf, MAXLINESIZE - strlen(lbuf));
 
 		} else {
 
-			if ( Global.debug ) printf( "ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n" );
-			strncpy( lbuf, buf, MAXLINESIZE );
+			if (Global.debug) printf("ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n");
+			strncpy(lbuf, buf, MAXLINESIZE);
 
 		}
 
@@ -112,7 +112,7 @@
 
 	process_main();
 
-	if ( ++net_read_count > 5 ) {
+	if (++net_read_count > 5) {
 		net_read_count = 0;
 		return(0);   /* continue mainloop */
 	} else {

Modified: trunk/apps/meshs3d/process.c
===================================================================
--- trunk/apps/meshs3d/process.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/meshs3d/process.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,9 +25,9 @@
 
 
 
-#include <stdio.h> 	/* NULL */
-#include <string.h> 	/* strlen(), memmove() */
-#include <stdlib.h> 	/* rand(), malloc(), realloc(), free() */
+#include <stdio.h>  /* NULL */
+#include <string.h>  /* strlen(), memmove() */
+#include <stdlib.h>  /* rand(), malloc(), realloc(), free() */
 #include <s3d.h>
 #include <math.h>       /* sqrt() */
 #include <sys/socket.h>
@@ -53,7 +53,7 @@
 
 int long_choose(void *data, int32_t size)
 {
-	unsigned char *key= data;
+	unsigned char *key = data;
 	uint32_t hash = 0;
 	size_t i;
 
@@ -65,7 +65,7 @@
 	hash += (hash << 3);
 	hash ^= (hash >> 11);
 	hash += (hash << 15);
-	return (hash%size);
+	return (hash % size);
 }
 
 int orig_comp(void *data1, void *data2)
@@ -77,7 +77,7 @@
 /* hash algorithm from http://en.wikipedia.org/wiki/Hash_table */
 int orig_choose(void *data, int32_t size)
 {
-	unsigned char *key= data;
+	unsigned char *key = data;
 	uint32_t hash = 0;
 	size_t i;
 
@@ -89,7 +89,7 @@
 	hash += (hash << 3);
 	hash ^= (hash >> 11);
 	hash += (hash << 15);
-	return (hash%size);
+	return (hash % size);
 }
 
 void exit_error(char *format, ...)
@@ -99,32 +99,32 @@
 	va_start(args, format);
 	vprintf(format, args);
 	va_end(args);
-	exit( EXIT_FAILURE );
+	exit(EXIT_FAILURE);
 }
 
 void process_init()
 {
 	/* initialize hashtable */
-	if ( NULL == ( node_hash = hash_new( 1600, orig_comp, orig_choose ) ) )
-		exit_error( "Can't create hashtable node_hash\n");
-	if ( NULL == ( con_hash = hash_new( 1600, long_comp, long_choose ) ) )
-		exit_error( "Can't create hashtable con_hash\n");
+	if (NULL == (node_hash = hash_new(1600, orig_comp, orig_choose)))
+		exit_error("Can't create hashtable node_hash\n");
+	if (NULL == (con_hash = hash_new(1600, long_comp, long_choose)))
+		exit_error("Can't create hashtable con_hash\n");
 	return;
 }
 
-void handle_con( unsigned int ip1, unsigned int ip2, float etx )
+void handle_con(unsigned int ip1, unsigned int ip2, float etx)
 {
 
 	unsigned int ip[2];
 	struct node_con *con;
 	struct hashtable_t *swaphash;
 
-	ip[0] = max(ip1,ip2);
-	ip[1] = min(ip1,ip2);
+	ip[0] = max(ip1, ip2);
+	ip[1] = min(ip1, ip2);
 
-	con = ( struct node_con* ) hash_find( con_hash, ip);
-	if ( con == NULL ) {
-		con = ( struct node_con * ) debugMalloc( sizeof( struct node_con ), 102 );
+	con = (struct node_con*) hash_find(con_hash, ip);
+	if (con == NULL) {
+		con = (struct node_con *) debugMalloc(sizeof(struct node_con), 102);
 		con->ip[0] = ip[0];
 		con->ip[1] = ip[1];
 		con->color = 0;
@@ -134,58 +134,58 @@
 		con->etx2 = 0.00;
 		con->etx1_sqrt = 0.00;
 		con->etx2_sqrt = 0.00;
-		hash_add( con_hash, con );
+		hash_add(con_hash, con);
 	}
 
-	if ( con->ip[0] == ip1 ) {
+	if (con->ip[0] == ip1) {
 		con->etx1 = etx;
-		con->etx1_sqrt = sqrt( etx );
+		con->etx1_sqrt = sqrt(etx);
 	} else {
 		con->etx2 = etx;
-		con->etx2_sqrt = sqrt( etx );
+		con->etx2_sqrt = sqrt(etx);
 	}
 
 
-	if ( con_hash->elements * 4 > con_hash->size ) {
-		swaphash = hash_resize( con_hash, con_hash->size * 2 );
-		if ( swaphash == NULL )
+	if (con_hash->elements * 4 > con_hash->size) {
+		swaphash = hash_resize(con_hash, con_hash->size * 2);
+		if (swaphash == NULL)
 			exit_error("Couldn't resize hash table \n");
 		con_hash = swaphash;
 	}
 
 }
 
-void handle_mesh_node( unsigned int *ip, char *ip_string )
+void handle_mesh_node(unsigned int *ip, char *ip_string)
 {
 	struct node *orig_node;
 	struct hashtable_t *swaphash;
 
-	if ( node_hash->elements * 4 > node_hash->size ) {
-		swaphash = hash_resize( node_hash, node_hash->size * 2 );
-		if ( swaphash == NULL )
-			exit_error("Couldn't resize hash table \n" );
+	if (node_hash->elements * 4 > node_hash->size) {
+		swaphash = hash_resize(node_hash, node_hash->size * 2);
+		if (swaphash == NULL)
+			exit_error("Couldn't resize hash table \n");
 		node_hash = swaphash;
 	}
-	orig_node = (struct node *) hash_find( node_hash, ip );
+	orig_node = (struct node *) hash_find(node_hash, ip);
 
-	if ( NULL == orig_node ) {
-		orig_node = (struct node *)debugMalloc( sizeof(struct node), 101 );
+	if (NULL == orig_node) {
+		orig_node = (struct node *)debugMalloc(sizeof(struct node), 101);
 		orig_node->ip = *ip;
-		strncpy( orig_node->ip_string, ip_string, NAMEMAX );
+		strncpy(orig_node->ip_string, ip_string, NAMEMAX);
 
 		orig_node->node_type = 0;
 		orig_node->node_type_modified = 1;
 
 		orig_node->visible = 1;
 
-		orig_node->pos_vec[0] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		orig_node->pos_vec[1] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		orig_node->pos_vec[2] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+		orig_node->pos_vec[0] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
+		orig_node->pos_vec[1] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
+		orig_node->pos_vec[2] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
 		orig_node->mov_vec[0] = orig_node->mov_vec[1] = orig_node->mov_vec[2] = 0.0;
 
 		orig_node->obj_id = -1;
 		orig_node->desc_id = -1;
-		hash_add( node_hash, orig_node );
+		hash_add(node_hash, orig_node);
 	}
 	return;
 }
@@ -198,7 +198,7 @@
 	char *lbuf_ptr, *last_cr_ptr, *con_from, *con_from_end, *con_to, *con_to_end, *etx, *etx_end;
 	/* struct node *node_from, *node_to; */
 
-	unsigned int int_con_from=0, int_con_to=0;
+	unsigned int int_con_from = 0, int_con_to = 0;
 
 	lbuf_ptr = lbuf;
 	last_cr_ptr = NULL;
@@ -207,15 +207,15 @@
 	dn = 0;
 
 
-	while ( (*lbuf_ptr) != '\0' ) {
-		if ( (*lbuf_ptr) == '\n' ) {
+	while ((*lbuf_ptr) != '\0') {
+		if ((*lbuf_ptr) == '\n') {
 			last_cr_ptr = lbuf_ptr;
 			con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
 			dn = 0;
 		}
 
-		if ( (*lbuf_ptr) == '"' ) {
-			switch ( dn ) {
+		if ((*lbuf_ptr) == '"') {
+			switch (dn) {
 			case 0:
 				con_from = lbuf_ptr + 1;
 				break;
@@ -236,32 +236,32 @@
 				break;
 			}
 
-			if ( ++dn == 6 ) {
+			if (++dn == 6) {
 
 				(*con_from_end) = (*con_to_end) = (*etx_end) = '\0';
 
 				/* if( Global.debug ) printf( "con_from: %s, con_to: %s, etx: %s\n", con_from, con_to, etx ); */
 
 				/* announced network via HNA */
-				if ( strncmp( etx, "HNA", NAMEMAX ) == 0 ) {
+				if (strncmp(etx, "HNA", NAMEMAX) == 0) {
 
 				} else {
 
-					f = strtod(etx,NULL);
-					if ( f < 1.0 )
+					f = strtod(etx, NULL);
+					if (f < 1.0)
 						f = 999.0;
 
-					if ( inet_pton(AF_INET, con_from, &int_con_from ) < 1 ) {
-						printf("%s is not a valid ip address\n", con_from );
+					if (inet_pton(AF_INET, con_from, &int_con_from) < 1) {
+						printf("%s is not a valid ip address\n", con_from);
 						continue;
 					}
-					if ( inet_pton(AF_INET, con_to, &int_con_to ) < 1 ) {
-						printf("%s is not a valid ip address\n", con_to );
+					if (inet_pton(AF_INET, con_to, &int_con_to) < 1) {
+						printf("%s is not a valid ip address\n", con_to);
 						continue;
 					}
-					handle_mesh_node( &int_con_from, con_from );
-					handle_mesh_node( &int_con_to, con_to );
-					handle_con( int_con_from, int_con_to, f);
+					handle_mesh_node(&int_con_from, con_from);
+					handle_mesh_node(&int_con_to, con_to);
+					handle_con(int_con_from, int_con_to, f);
 					/* node_from = (struct node *) hash_find( node_hash, &int_con_from );
 					node_to = (struct node *) hash_find( node_hash, &int_con_to ); */
 				}
@@ -274,7 +274,7 @@
 				last_cr_ptr = lbuf_ptr;
 			}
 
-		} else if ( ( (*lbuf_ptr) == '}' ) && ( (*(lbuf_ptr + 1)) == '\n' ) ) {
+		} else if (((*lbuf_ptr) == '}') && ((*(lbuf_ptr + 1)) == '\n')) {
 
 		}
 
@@ -282,7 +282,7 @@
 
 	}
 
-	if ( last_cr_ptr != NULL ) memmove( lbuf, last_cr_ptr + 1, strlen( last_cr_ptr ) );
+	if (last_cr_ptr != NULL) memmove(lbuf, last_cr_ptr + 1, strlen(last_cr_ptr));
 	return(0);
 
 }

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -29,17 +29,17 @@
 #include <s3d.h>
 #include <s3d_keysym.h>
 #include <s3dw.h>
-#include <sys/time.h>	 /* gettimeofday() */
-#include <time.h>	     /* nanosleep() */
-#include <string.h>		 /* strncpy() */
-#include <math.h>		 /* sqrt() */
-#include <getopt.h>		 /* getopt() */
-#include <stdlib.h>		 /* exit() */
-#include <stdint.h>		 /* uintXX_t */
+#include <sys/time.h>  /* gettimeofday() */
+#include <time.h>      /* nanosleep() */
+#include <string.h>   /* strncpy() */
+#include <math.h>   /* sqrt() */
+#include <getopt.h>   /* getopt() */
+#include <stdlib.h>   /* exit() */
+#include <stdint.h>   /* uintXX_t */
 #include "olsrs3d.h"
 #include "search.h"
 
-#define SPEED		10.0
+#define SPEED  10.0
 
 static struct timespec sleep_time = {
 	0, 100 * 1000 * 1000
@@ -71,18 +71,18 @@
 float Bottom = -1.0;
 float Left = -1.0;
 
-float CamPosition[2][3];	/* CamPosition[trans|rot][x-z] */
-float CamPosition2[2][3];	/* CamPosition[trans|rot][x-z] */
+float CamPosition[2][3]; /* CamPosition[trans|rot][x-z] */
+float CamPosition2[2][3]; /* CamPosition[trans|rot][x-z] */
 
 /* needed ? */
-/* float ZeroPosition[3] = {0,0,0};	 current position zero position */
+/* float ZeroPosition[3] = {0,0,0};  current position zero position */
 
 int ZeroPoint;   /* object zeropoint */
 float Zp_rotate = 0.0;
 int ColorSwitch = 0;   /* enable/disable colored olsr connections */
 int RotateSwitch = 0;
 float RotateSpeed = 0.5;
-float Factor = 0.6;	/* Factor in calc_olsr_node_mov */
+float Factor = 0.6; /* Factor in calc_olsr_node_mov */
 struct olsr_node *Olsr_node_pEtx;
 
 int Btn_close_id = -1;
@@ -98,14 +98,14 @@
  *
  ***/
 
-void print_usage( void )
+void print_usage(void)
 {
 
-	printf( "Usage is olsrs3d [options] [-- [s3d options]]\n" );
-	printf( "olsrs3d options:\n" );
-	printf( "   -h\tprint this short help\n" );
-	printf( "   -d\tenable debug mode\n" );
-	printf( "   -H\tconnect to olsr node [default: localhost]\n" );
+	printf("Usage is olsrs3d [options] [-- [s3d options]]\n");
+	printf("olsrs3d options:\n");
+	printf("   -h\tprint this short help\n");
+	printf("   -d\tenable debug mode\n");
+	printf("   -H\tconnect to olsr node [default: localhost]\n");
 	s3d_usage();
 
 }
@@ -124,30 +124,30 @@
 	s3dw_surface *infwin;
 	s3dw_button  *button;
 
-	infwin = s3dw_surface_new( "Help Window", 20, 19 );
+	infwin = s3dw_surface_new("Help Window", 20, 19);
 
 	/*s3dw_label_new(infwin,"C        - Colour On/Off",1,2);*/
-	s3dw_label_new(infwin,"c",1,2);
-	s3dw_label_new(infwin,"- Colour On/Off",6,2);
+	s3dw_label_new(infwin, "c", 1, 2);
+	s3dw_label_new(infwin, "- Colour On/Off", 6, 2);
 	/*s3dw_label_new(infwin,"r        - Rotation On/Off",1,4);*/
-	s3dw_label_new(infwin,"r",1,4);
-	s3dw_label_new(infwin,"- Rotation On/Off",6,4);
-	s3dw_label_new(infwin,"+",1,5);
-	s3dw_label_new(infwin,"- Increase Rotation Speed",6,5);
-	s3dw_label_new(infwin,"-",1,6);
-	s3dw_label_new(infwin,"- Decrease Rotation Speed",6,6);
-	s3dw_label_new(infwin,"s",1,8);
-	s3dw_label_new(infwin,"- Search IP",6,8);
-	s3dw_label_new(infwin,"ESC",1,9);
-	s3dw_label_new(infwin,"- Disable FollowMode",6,9);
-	s3dw_label_new(infwin,"PGUP",1,11);
-	s3dw_label_new(infwin,"- Increase Drift Factor",6,11);
-	s3dw_label_new(infwin,"PGDOWN",1,12);
-	s3dw_label_new(infwin,"- Decrease Drift Factor",6,12);
-	s3dw_label_new(infwin,"STRG + p",1,14);
-	s3dw_label_new(infwin,"- Reset Nodes",6,14);
+	s3dw_label_new(infwin, "r", 1, 4);
+	s3dw_label_new(infwin, "- Rotation On/Off", 6, 4);
+	s3dw_label_new(infwin, "+", 1, 5);
+	s3dw_label_new(infwin, "- Increase Rotation Speed", 6, 5);
+	s3dw_label_new(infwin, "-", 1, 6);
+	s3dw_label_new(infwin, "- Decrease Rotation Speed", 6, 6);
+	s3dw_label_new(infwin, "s", 1, 8);
+	s3dw_label_new(infwin, "- Search IP", 6, 8);
+	s3dw_label_new(infwin, "ESC", 1, 9);
+	s3dw_label_new(infwin, "- Disable FollowMode", 6, 9);
+	s3dw_label_new(infwin, "PGUP", 1, 11);
+	s3dw_label_new(infwin, "- Increase Drift Factor", 6, 11);
+	s3dw_label_new(infwin, "PGDOWN", 1, 12);
+	s3dw_label_new(infwin, "- Decrease Drift Factor", 6, 12);
+	s3dw_label_new(infwin, "STRG + p", 1, 14);
+	s3dw_label_new(infwin, "- Reset Nodes", 6, 14);
 
-	button=s3dw_button_new(infwin,"OK",9,16);
+	button = s3dw_button_new(infwin, "OK", 9, 16);
 	button->onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 
@@ -160,10 +160,10 @@
 	s3dw_surface *infwin;
 	s3dw_button  *button;
 
-	infwin = s3dw_surface_new( "Error", 12, 6 );
-	s3dw_label_new(infwin,msg,1,2);
+	infwin = s3dw_surface_new("Error", 12, 6);
+	s3dw_label_new(infwin, msg, 1, 2);
 
-	button=s3dw_button_new(infwin,"OK",4,4);
+	button = s3dw_button_new(infwin, "OK", 4, 4);
 	button->onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 
@@ -176,10 +176,10 @@
  *
  ***/
 
-void out_of_mem( void )
+void out_of_mem(void)
 {
 
-	printf( "Sorry - you ran out of memory !\n" );
+	printf("Sorry - you ran out of memory !\n");
 	exit(8);
 
 }
@@ -213,9 +213,9 @@
 float dist(float p1[], float p2[])
 {
 	float p[3];
-	p[0]=p1[0]-p2[0];
-	p[1]=p1[1]-p2[1];
-	p[2]=p1[2]-p2[2];
+	p[0] = p1[0] - p2[0];
+	p[1] = p1[1] - p2[1];
+	p[2] = p1[2] - p2[2];
 	return (sqrt(p[0]*p[0]   +  p[1]*p[1]  +  p[2]*p[2]));
 
 }
@@ -237,16 +237,16 @@
 float dirt(float p1[], float p2[], float p3[])
 {
 	float d;
-	d=dist(p1,p2);
-	if (d==0) {
-		p3[0]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		p3[1]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		p3[2]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		d=s3d_vector_length(p3);
+	d = dist(p1, p2);
+	if (d == 0) {
+		p3[0] = ((float) 0.2 * rand()) / RAND_MAX - 0.1;
+		p3[1] = ((float) 0.2 * rand()) / RAND_MAX - 0.1;
+		p3[2] = ((float) 0.2 * rand()) / RAND_MAX - 0.1;
+		d = s3d_vector_length(p3);
 	} else {
-		p3[0]=p2[0]-p1[0];
-		p3[1]=p2[1]-p1[1];
-		p3[2]=p2[2]-p1[2];
+		p3[0] = p2[0] - p1[0];
+		p3[1] = p2[1] - p1[1];
+		p3[2] = p2[2] - p1[2];
 	}
 	return(d);
 }
@@ -266,12 +266,12 @@
 
 void mov_add(float mov[], float p[], float fac)
 {
-	/*	if (fac>1000)
-			return;
-		fac=1000; */
-	mov[0]+=fac*p[0];
-	mov[1]+=fac*p[1];
-	mov[2]+=fac*p[2];
+	/* if (fac>1000)
+	  return;
+	 fac=1000; */
+	mov[0] += fac * p[0];
+	mov[1] += fac * p[1];
+	mov[2] += fac * p[2];
 }
 
 
@@ -284,43 +284,43 @@
  *
  ***/
 
-void handle_olsr_node( struct olsr_node *olsr_node )
+void handle_olsr_node(struct olsr_node *olsr_node)
 {
 
 	float distance, angle, angle_rad;
-	float tmp_mov_vec[3], desc_norm_vec[3] = {0,0,-1};
+	float tmp_mov_vec[3], desc_norm_vec[3] = {0, 0, -1};
 	struct olsr_node *other_node;
 	struct Obj_to_ip *Obj_to_ip_curr;
 	struct olsr_neigh_list *olsr_neigh_list, *prev_olsr_neigh_list, *other_node_neigh_list, *tmp_olsr_neigh_list;
 
 	/* no more nodes left */
-	if ( olsr_node == NULL ) return;
+	if (olsr_node == NULL) return;
 
 	/* olsr node vanished */
-	if ( ( olsr_node->last_seen < Output_block_counter - 1 ) && ( olsr_node->visible ) ) {
+	if ((olsr_node->last_seen < Output_block_counter - 1) && (olsr_node->visible)) {
 
-		if ( Debug )
-			printf( "olsr node vanished: %s\n", olsr_node->ip );
+		if (Debug)
+			printf("olsr node vanished: %s\n", olsr_node->ip);
 
 		Olsr_node_count--;
 
 		olsr_node->visible = 0;
 
 		/* delete shape */
-		if ( olsr_node->obj_id != -1 ) {
+		if (olsr_node->obj_id != -1) {
 
 			/* remove element from ob2ip list */
-			lst_del( olsr_node->obj_id );
+			lst_del(olsr_node->obj_id);
 			/* remove object from s3d server */
-			s3d_del_object( olsr_node->obj_id );
+			s3d_del_object(olsr_node->obj_id);
 
 			olsr_node->obj_id = -1;
 
 		}
 
-		if ( olsr_node->desc_id != -1 ) {
+		if (olsr_node->desc_id != -1) {
 
-			s3d_del_object( olsr_node->desc_id );
+			s3d_del_object(olsr_node->desc_id);
 			olsr_node->desc_id = -1;
 
 		}
@@ -328,10 +328,10 @@
 		/* delete olsr connections of this node */
 		olsr_neigh_list = olsr_node->olsr_neigh_list;
 
-		while ( olsr_neigh_list != NULL ) {
+		while (olsr_neigh_list != NULL) {
 
 			/* get connection list of 'other' node */
-			if ( olsr_neigh_list->olsr_con->left_olsr_node == olsr_node ) {
+			if (olsr_neigh_list->olsr_con->left_olsr_node == olsr_node) {
 				other_node = olsr_neigh_list->olsr_con->right_olsr_node;
 			} else {
 				other_node = olsr_neigh_list->olsr_con->left_olsr_node;
@@ -341,12 +341,12 @@
 			prev_olsr_neigh_list = NULL;
 			other_node_neigh_list = other_node->olsr_neigh_list;
 
-			while ( other_node_neigh_list != NULL ) {
+			while (other_node_neigh_list != NULL) {
 
-				if ( other_node_neigh_list->olsr_con == olsr_neigh_list->olsr_con ) {
+				if (other_node_neigh_list->olsr_con == olsr_neigh_list->olsr_con) {
 
 					/* and delete it ! */
-					if ( prev_olsr_neigh_list != NULL ) {
+					if (prev_olsr_neigh_list != NULL) {
 						/* is first, any or last element in the list */
 						prev_olsr_neigh_list->next_olsr_neigh_list = other_node_neigh_list->next_olsr_neigh_list;
 					} else {
@@ -354,7 +354,7 @@
 						other_node->olsr_neigh_list = NULL;
 					}
 
-					free( other_node_neigh_list );
+					free(other_node_neigh_list);
 
 					break;
 
@@ -365,61 +365,61 @@
 
 			}
 
-			s3d_del_object( olsr_neigh_list->olsr_con->obj_id );
+			s3d_del_object(olsr_neigh_list->olsr_con->obj_id);
 
 			/* delete connection */
-			if ( olsr_neigh_list->olsr_con->prev_olsr_con != NULL ) olsr_neigh_list->olsr_con->prev_olsr_con->next_olsr_con = olsr_neigh_list->olsr_con->next_olsr_con;
-			if ( olsr_neigh_list->olsr_con->next_olsr_con != NULL ) olsr_neigh_list->olsr_con->next_olsr_con->prev_olsr_con = olsr_neigh_list->olsr_con->prev_olsr_con;
+			if (olsr_neigh_list->olsr_con->prev_olsr_con != NULL) olsr_neigh_list->olsr_con->prev_olsr_con->next_olsr_con = olsr_neigh_list->olsr_con->next_olsr_con;
+			if (olsr_neigh_list->olsr_con->next_olsr_con != NULL) olsr_neigh_list->olsr_con->next_olsr_con->prev_olsr_con = olsr_neigh_list->olsr_con->prev_olsr_con;
 
 			tmp_olsr_neigh_list = olsr_neigh_list;
 
 			olsr_neigh_list = olsr_neigh_list->next_olsr_neigh_list;
 
-			free( tmp_olsr_neigh_list->olsr_con );
-			free( tmp_olsr_neigh_list );
+			free(tmp_olsr_neigh_list->olsr_con);
+			free(tmp_olsr_neigh_list);
 
 		}
 
 		olsr_node->olsr_neigh_list = NULL;
 
-	} else if ( olsr_node->visible ) {
+	} else if (olsr_node->visible) {
 
 		/* olsr node shape has been modified */
-		if ( olsr_node->node_type_modified ) {
+		if (olsr_node->node_type_modified) {
 
 			/* delete old shape */
-			if ( olsr_node->obj_id != -1 ) {
+			if (olsr_node->obj_id != -1) {
 				/* remove element from ob2ip list */
-				lst_del( olsr_node->obj_id );
-				s3d_del_object( olsr_node->obj_id );
+				lst_del(olsr_node->obj_id);
+				s3d_del_object(olsr_node->obj_id);
 			}
 
-			if ( olsr_node->desc_id != -1 ) s3d_del_object( olsr_node->desc_id );
+			if (olsr_node->desc_id != -1) s3d_del_object(olsr_node->desc_id);
 
 			/* create new shape */
-			if ( olsr_node->node_type == 1 ) {
+			if (olsr_node->node_type == 1) {
 				/* olsr node offers internet access */
-				olsr_node->obj_id = s3d_clone( Olsr_node_inet_obj );
-			} else if ( olsr_node->node_type == 2 ) {
+				olsr_node->obj_id = s3d_clone(Olsr_node_inet_obj);
+			} else if (olsr_node->node_type == 2) {
 				/* via hna announced network */
-				olsr_node->obj_id = s3d_clone( Olsr_node_hna_net );
+				olsr_node->obj_id = s3d_clone(Olsr_node_hna_net);
 			} else {
 				/* normal olsr node */
-				olsr_node->obj_id = s3d_clone( Olsr_node_obj );
+				olsr_node->obj_id = s3d_clone(Olsr_node_obj);
 			}
 
-			s3d_flags_on( olsr_node->obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(olsr_node->obj_id, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
 			/* link newly created object to ZeroPoint */
-			s3d_link( olsr_node->obj_id, ZeroPoint );
+			s3d_link(olsr_node->obj_id, ZeroPoint);
 			/* add object_id and olsr_node to linked list */
-			lst_add(olsr_node->obj_id,&olsr_node);
+			lst_add(olsr_node->obj_id, &olsr_node);
 
 			/* create olsr node text and attach (link) it to the node */
-			olsr_node->desc_id = s3d_draw_string( olsr_node->ip, &olsr_node->desc_length );
-			s3d_link( olsr_node->desc_id, olsr_node->obj_id );
-			s3d_translate( olsr_node->desc_id, - olsr_node->desc_length / 2, -2, 0 );
-			s3d_flags_on( olsr_node->desc_id, S3D_OF_VISIBLE );
+			olsr_node->desc_id = s3d_draw_string(olsr_node->ip, &olsr_node->desc_length);
+			s3d_link(olsr_node->desc_id, olsr_node->obj_id);
+			s3d_translate(olsr_node->desc_id, - olsr_node->desc_length / 2, -2, 0);
+			s3d_flags_on(olsr_node->desc_id, S3D_OF_VISIBLE);
 
 			olsr_node->node_type_modified = 0;
 
@@ -431,35 +431,35 @@
 		tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
 		tmp_mov_vec[2] = CamPosition2[0][2] - olsr_node->pos_vec[2];
 
-		angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
+		angle = s3d_vector_angle(desc_norm_vec, tmp_mov_vec);
 
 		/* take care of inverse cosinus */
-		if ( tmp_mov_vec[0] > 0 ) {
-			angle_rad = 90.0/M_PI - angle;
-			angle = 180 - ( 180.0/M_PI * angle );
+		if (tmp_mov_vec[0] > 0) {
+			angle_rad = 90.0 / M_PI - angle;
+			angle = 180 - (180.0 / M_PI * angle);
 		} else {
-			angle_rad = 90.0/M_PI + angle;
-			angle = 180 + ( 180.0/M_PI * angle );
+			angle_rad = 90.0 / M_PI + angle;
+			angle = 180 + (180.0 / M_PI * angle);
 		}
 
-		s3d_rotate( olsr_node->desc_id, 0, angle , 0 );
-		s3d_translate( olsr_node->desc_id, -cos(angle_rad)*olsr_node->desc_length/2 ,-1.5, sin(angle_rad)*olsr_node->desc_length/2 );
+		s3d_rotate(olsr_node->desc_id, 0, angle , 0);
+		s3d_translate(olsr_node->desc_id, -cos(angle_rad)*olsr_node->desc_length / 2 , -1.5, sin(angle_rad)*olsr_node->desc_length / 2);
 
 
 		/* drift away from unrelated nodes */
 		Obj_to_ip_curr = Obj_to_ip_head->next;
-		while ( Obj_to_ip_curr != Obj_to_ip_end ) {
+		while (Obj_to_ip_curr != Obj_to_ip_end) {
 
 			/* myself ... */
-			if ( olsr_node != Obj_to_ip_curr->olsr_node ) {
+			if (olsr_node != Obj_to_ip_curr->olsr_node) {
 
 				olsr_neigh_list = olsr_node->olsr_neigh_list;
-				while ( olsr_neigh_list != NULL ) {
+				while (olsr_neigh_list != NULL) {
 
 					/* nodes are related */
-					if ( ( olsr_neigh_list->olsr_con->left_olsr_node->visible == 1 ) && ( olsr_neigh_list->olsr_con->right_olsr_node->visible == 1 ) ) {
+					if ((olsr_neigh_list->olsr_con->left_olsr_node->visible == 1) && (olsr_neigh_list->olsr_con->right_olsr_node->visible == 1)) {
 
-						if ( ( olsr_neigh_list->olsr_con->left_olsr_node == Obj_to_ip_curr->olsr_node ) || (  olsr_neigh_list->olsr_con->right_olsr_node == Obj_to_ip_curr->olsr_node ) ) break;
+						if ((olsr_neigh_list->olsr_con->left_olsr_node == Obj_to_ip_curr->olsr_node) || (olsr_neigh_list->olsr_con->right_olsr_node == Obj_to_ip_curr->olsr_node)) break;
 
 					}
 
@@ -468,12 +468,12 @@
 				}
 
 				/* nodes are not related - so drift */
-				if ( olsr_neigh_list == NULL ) {
+				if (olsr_neigh_list == NULL) {
 
-					distance = dirt( olsr_node->pos_vec, Obj_to_ip_curr->olsr_node->pos_vec, tmp_mov_vec );
-					if ( distance < 0.1 ) distance = 0.1;
-					mov_add( olsr_node->mov_vec, tmp_mov_vec,-100 / ( distance * distance ) );
-					mov_add( Obj_to_ip_curr->olsr_node->mov_vec, tmp_mov_vec, 100 / ( distance * distance ) );
+					distance = dirt(olsr_node->pos_vec, Obj_to_ip_curr->olsr_node->pos_vec, tmp_mov_vec);
+					if (distance < 0.1) distance = 0.1;
+					mov_add(olsr_node->mov_vec, tmp_mov_vec, -100 / (distance * distance));
+					mov_add(Obj_to_ip_curr->olsr_node->mov_vec, tmp_mov_vec, 100 / (distance * distance));
 
 				}
 
@@ -485,8 +485,8 @@
 
 	}
 
-	handle_olsr_node( olsr_node->left );
-	handle_olsr_node( olsr_node->right );
+	handle_olsr_node(olsr_node->left);
+	handle_olsr_node(olsr_node->right);
 
 }
 
@@ -498,7 +498,7 @@
  *
  ***/
 
-void calc_olsr_node_mov( void )
+void calc_olsr_node_mov(void)
 {
 
 	float distance;
@@ -506,19 +506,19 @@
 	float f;
 	struct olsr_con *olsr_con = Con_begin;
 
-	while ( olsr_con != NULL ) {
+	while (olsr_con != NULL) {
 
-		distance = dirt( olsr_con->left_olsr_node->pos_vec, olsr_con->right_olsr_node->pos_vec, tmp_mov_vec );
-		f = ( ( olsr_con->left_etx_sqrt + olsr_con->left_etx_sqrt ) / 4.0 ) / distance;
+		distance = dirt(olsr_con->left_olsr_node->pos_vec, olsr_con->right_olsr_node->pos_vec, tmp_mov_vec);
+		f = ((olsr_con->left_etx_sqrt + olsr_con->left_etx_sqrt) / 4.0) / distance;
 
 		/***
 		 * drift factor - 0.0 < factor < 1.0 ( best results: 0.3 < factor < 0.9
 		 * small factor: fast and strong drift to neighbours
 		 ***/
-		if ( f < Factor ) f = Factor;
+		if (f < Factor) f = Factor;
 
-		mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, 1 / f - 1 );
-		mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, - ( 1 / f - 1 ) );
+		mov_add(olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, 1 / f - 1);
+		mov_add(olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, - (1 / f - 1));
 
 		olsr_con = olsr_con->next_olsr_con;
 
@@ -534,30 +534,30 @@
  *
  ***/
 
-void move_olsr_nodes( void )
+void move_olsr_nodes(void)
 {
 
-	float null_vec[3] = {0,0,0}, vertex_buf[6];
+	float null_vec[3] = {0, 0, 0}, vertex_buf[6];
 	float tmp_mov_vec[3];
 	float distance, etx, rgb;
 	struct olsr_con *olsr_con = Con_begin;
 
-	while ( olsr_con != NULL ) {
+	while (olsr_con != NULL) {
 
 		/* move left olsr node if it has not been moved yet */
-		if ( !( ( olsr_con->left_olsr_node->mov_vec[0] == 0 ) && ( olsr_con->left_olsr_node->mov_vec[1] == 0 ) && ( olsr_con->left_olsr_node->mov_vec[2] == 0 ) ) && olsr_con->left_olsr_node->visible ) {
+		if (!((olsr_con->left_olsr_node->mov_vec[0] == 0) && (olsr_con->left_olsr_node->mov_vec[1] == 0) && (olsr_con->left_olsr_node->mov_vec[2] == 0)) && olsr_con->left_olsr_node->visible) {
 
-			distance = dirt( olsr_con->left_olsr_node->pos_vec, null_vec, tmp_mov_vec );
-			mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, distance / 100 ); /* move a little bit to point zero */
-			mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, 1 ); /* move a little bit to point zero */
+			distance = dirt(olsr_con->left_olsr_node->pos_vec, null_vec, tmp_mov_vec);
+			mov_add(olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, distance / 100);   /* move a little bit to point zero */
+			mov_add(olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, 1);   /* move a little bit to point zero */
 
-			if ( ( distance = dist( olsr_con->left_olsr_node->mov_vec, null_vec ) ) > 10.0 ) {
-				mov_add( olsr_con->left_olsr_node->pos_vec, olsr_con->left_olsr_node->mov_vec, 1.0 / ( ( float ) distance ) );
+			if ((distance = dist(olsr_con->left_olsr_node->mov_vec, null_vec)) > 10.0) {
+				mov_add(olsr_con->left_olsr_node->pos_vec, olsr_con->left_olsr_node->mov_vec, 1.0 / ((float) distance));
 			} else {
-				mov_add( olsr_con->left_olsr_node->pos_vec, olsr_con->left_olsr_node->mov_vec, 0.1 );
+				mov_add(olsr_con->left_olsr_node->pos_vec, olsr_con->left_olsr_node->mov_vec, 0.1);
 			}
 
-			s3d_translate( olsr_con->left_olsr_node->obj_id, olsr_con->left_olsr_node->pos_vec[0], olsr_con->left_olsr_node->pos_vec[1], olsr_con->left_olsr_node->pos_vec[2] );
+			s3d_translate(olsr_con->left_olsr_node->obj_id, olsr_con->left_olsr_node->pos_vec[0], olsr_con->left_olsr_node->pos_vec[1], olsr_con->left_olsr_node->pos_vec[2]);
 
 			/* reset movement vector */
 			olsr_con->left_olsr_node->mov_vec[0] = olsr_con->left_olsr_node->mov_vec[1] = olsr_con->left_olsr_node->mov_vec[2] = 0.0;
@@ -565,19 +565,19 @@
 		}
 
 		/* move right olsr node if it has not been moved yet */
-		if ( !( ( olsr_con->right_olsr_node->mov_vec[0] == 0 ) && ( olsr_con->right_olsr_node->mov_vec[1] == 0 ) && ( olsr_con->right_olsr_node->mov_vec[2] == 0 ) ) && olsr_con->right_olsr_node->visible ) {
+		if (!((olsr_con->right_olsr_node->mov_vec[0] == 0) && (olsr_con->right_olsr_node->mov_vec[1] == 0) && (olsr_con->right_olsr_node->mov_vec[2] == 0)) && olsr_con->right_olsr_node->visible) {
 
-			distance = dirt( olsr_con->right_olsr_node->pos_vec, null_vec, tmp_mov_vec );
-			mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, distance / 100 ); /* move a little bit to point zero */
-			mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, 1 ); /* move a little bit to point zero */
+			distance = dirt(olsr_con->right_olsr_node->pos_vec, null_vec, tmp_mov_vec);
+			mov_add(olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, distance / 100);   /* move a little bit to point zero */
+			mov_add(olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, 1);   /* move a little bit to point zero */
 
-			if ( ( distance = dist( olsr_con->right_olsr_node->mov_vec, null_vec ) ) > 10.0 ) {
-				mov_add( olsr_con->right_olsr_node->pos_vec, olsr_con->right_olsr_node->mov_vec, 1.0 / ( ( float ) distance ) );
+			if ((distance = dist(olsr_con->right_olsr_node->mov_vec, null_vec)) > 10.0) {
+				mov_add(olsr_con->right_olsr_node->pos_vec, olsr_con->right_olsr_node->mov_vec, 1.0 / ((float) distance));
 			} else {
-				mov_add( olsr_con->right_olsr_node->pos_vec, olsr_con->right_olsr_node->mov_vec, 0.1 );
+				mov_add(olsr_con->right_olsr_node->pos_vec, olsr_con->right_olsr_node->mov_vec, 0.1);
 			}
 
-			s3d_translate( olsr_con->right_olsr_node->obj_id, olsr_con->right_olsr_node->pos_vec[0], olsr_con->right_olsr_node->pos_vec[1], olsr_con->right_olsr_node->pos_vec[2] );
+			s3d_translate(olsr_con->right_olsr_node->obj_id, olsr_con->right_olsr_node->pos_vec[0], olsr_con->right_olsr_node->pos_vec[1], olsr_con->right_olsr_node->pos_vec[2]);
 
 			/* reset movement vector */
 			olsr_con->right_olsr_node->mov_vec[0] = olsr_con->right_olsr_node->mov_vec[1] = olsr_con->right_olsr_node->mov_vec[2] = 0.0;
@@ -593,92 +593,92 @@
 		vertex_buf[4] = olsr_con->right_olsr_node->pos_vec[1];
 		vertex_buf[5] = olsr_con->right_olsr_node->pos_vec[2];
 
-		s3d_pep_vertices( olsr_con->obj_id, vertex_buf, 2 );
+		s3d_pep_vertices(olsr_con->obj_id, vertex_buf, 2);
 
 
-		if ( ColorSwitch ) {
+		if (ColorSwitch) {
 
 			/* HNA */
-			if ( olsr_con->left_etx == -1000.00 ) {
+			if (olsr_con->left_etx == -1000.00) {
 
 				if (olsr_con->color != 1) {
-					s3d_pep_material( olsr_con->obj_id,
-					                  0.0,0.0,1.0,
-					                  0.0,0.0,1.0,
-					                  0.0,0.0,1.0);
+					s3d_pep_material(olsr_con->obj_id,
+					                 0.0, 0.0, 1.0,
+					                 0.0, 0.0, 1.0,
+					                 0.0, 0.0, 1.0);
 					olsr_con->color = 1;
 				}
 
 			} else {
 
-				etx = ( olsr_con->left_etx + olsr_con->right_etx ) / 2.0;
+				etx = (olsr_con->left_etx + olsr_con->right_etx) / 2.0;
 
 				/* very good link - bright blue */
-				if ( ( etx >= 1.0 ) && ( etx < 1.5 ) ) {
+				if ((etx >= 1.0) && (etx < 1.5)) {
 
 					if (olsr_con->color != 2) {
-						s3d_pep_material( olsr_con->obj_id,
-						                  0.5,1.0,1.0,
-						                  0.5,1.0,1.0,
-						                  0.5,1.0,1.0);
+						s3d_pep_material(olsr_con->obj_id,
+						                 0.5, 1.0, 1.0,
+						                 0.5, 1.0, 1.0,
+						                 0.5, 1.0, 1.0);
 						olsr_con->color = 2;
 					}
 
 					/* good link - bright yellow */
-				} else if ( ( etx >= 1.5 ) && ( etx < 2.0 ) ) {
+				} else if ((etx >= 1.5) && (etx < 2.0)) {
 
 					rgb = 2.0 - etx;
-					if ( olsr_con->color != 3 || (olsr_con->color == 3 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
-						s3d_pep_material( olsr_con->obj_id,
-						                  1.0,1.0,rgb,
-						                  1.0,1.0,rgb,
-						                  1.0,1.0,rgb);
+					if (olsr_con->color != 3 || (olsr_con->color == 3 && (int) rintf(olsr_con->rgb * 10) != (int) rintf(rgb * 10))) {
+						s3d_pep_material(olsr_con->obj_id,
+						                 1.0, 1.0, rgb,
+						                 1.0, 1.0, rgb,
+						                 1.0, 1.0, rgb);
 						olsr_con->color = 3;
 
 						olsr_con->rgb =  rgb;
 					}
 
 					/* not so good link - orange */
-				} else if ( ( etx >= 2.0 ) && ( etx < 3.0 ) ) {
+				} else if ((etx >= 2.0) && (etx < 3.0)) {
 
-					rgb = 1.5 - ( etx / 2.0 );
-					if ( olsr_con->color != 4 || (olsr_con->color == 4 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
-						s3d_pep_material( olsr_con->obj_id,
-						                  1.0,rgb,0.0,
-						                  1.0,rgb,0.0,
-						                  1.0,rgb,0.0);
+					rgb = 1.5 - (etx / 2.0);
+					if (olsr_con->color != 4 || (olsr_con->color == 4 && (int) rintf(olsr_con->rgb * 10) != (int) rintf(rgb * 10))) {
+						s3d_pep_material(olsr_con->obj_id,
+						                 1.0, rgb, 0.0,
+						                 1.0, rgb, 0.0,
+						                 1.0, rgb, 0.0);
 						olsr_con->color = 4;
 
 						olsr_con->rgb = rgb;
 					}
 
 					/* bad link (almost dead) - brown */
-				} else if ( ( etx >= 3.0 ) && ( etx < 5.0 ) ) {
+				} else if ((etx >= 3.0) && (etx < 5.0)) {
 
-					rgb = 1.75 - ( etx / 4.0 );
+					rgb = 1.75 - (etx / 4.0);
 
-					if ( olsr_con->color != 5 || (olsr_con->color == 5 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
+					if (olsr_con->color != 5 || (olsr_con->color == 5 && (int) rintf(olsr_con->rgb * 10) != (int) rintf(rgb * 10))) {
 
-						s3d_pep_material( olsr_con->obj_id,
-						                  rgb,rgb - 0.5,0.0,
-						                  rgb,rgb - 0.5,0.0,
-						                  rgb,rgb - 0.5,0.0);
+						s3d_pep_material(olsr_con->obj_id,
+						                 rgb, rgb - 0.5, 0.0,
+						                 rgb, rgb - 0.5, 0.0,
+						                 rgb, rgb - 0.5, 0.0);
 						olsr_con->color = 5;
 
 						olsr_con->rgb = rgb;
 					}
 
 					/* zombie link - grey */
-				} else if ( ( etx >= 5.0 ) && ( etx < 1000.0 ) ) {
+				} else if ((etx >= 5.0) && (etx < 1000.0)) {
 
-					rgb = 1000.0 / ( 1500.0 + etx );
+					rgb = 1000.0 / (1500.0 + etx);
 
-					if ( olsr_con->color != 6 || (olsr_con->color == 6 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
+					if (olsr_con->color != 6 || (olsr_con->color == 6 && (int) rintf(olsr_con->rgb * 10) != (int) rintf(rgb * 10))) {
 
-						s3d_pep_material( olsr_con->obj_id,
-						                  rgb,rgb,rgb,
-						                  rgb,rgb,rgb,
-						                  rgb,rgb,rgb);
+						s3d_pep_material(olsr_con->obj_id,
+						                 rgb, rgb, rgb,
+						                 rgb, rgb, rgb,
+						                 rgb, rgb, rgb);
 						olsr_con->color = 6;
 
 						olsr_con->rgb = rgb;
@@ -688,10 +688,10 @@
 				} else {
 
 					if (olsr_con->color != 7) {
-						s3d_pep_material( olsr_con->obj_id,
-						                  0.3,0.3,0.3,
-						                  0.3,0.3,0.3,
-						                  0.3,0.3,0.3);
+						s3d_pep_material(olsr_con->obj_id,
+						                 0.3, 0.3, 0.3,
+						                 0.3, 0.3, 0.3,
+						                 0.3, 0.3, 0.3);
 						olsr_con->color = 7;
 					}
 
@@ -702,10 +702,10 @@
 		} else {
 
 			if (olsr_con->color != 0) {
-				s3d_pep_material( olsr_con->obj_id,
-				                  1.0,1.0,1.0,
-				                  1.0,1.0,1.0,
-				                  1.0,1.0,1.0);
+				s3d_pep_material(olsr_con->obj_id,
+				                 1.0, 1.0, 1.0,
+				                 1.0, 1.0, 1.0,
+				                 1.0, 1.0, 1.0);
 				olsr_con->color = 0;
 			}
 
@@ -731,26 +731,26 @@
 	calc_olsr_node_mov();
 
 	/* prepare nodes */
-	handle_olsr_node( Olsr_root );
+	handle_olsr_node(Olsr_root);
 
 	/* move it */
 	move_olsr_nodes();
 
 	/* if we have more or less nodes now - redraw node count */
-	if ( Olsr_node_count != Last_olsr_node_count ) {
+	if (Olsr_node_count != Last_olsr_node_count) {
 
-		if ( Olsr_node_count_obj != -1 ) s3d_del_object( Olsr_node_count_obj );
-		snprintf( nc_str, 20, "node count: %d", Olsr_node_count );
-		Olsr_node_count_obj = s3d_draw_string( nc_str, &strLen );
-		s3d_link( Olsr_node_count_obj, 0 );
-		s3d_flags_on( Olsr_node_count_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_node_count_obj, 0.2 );
-		s3d_translate( Olsr_node_count_obj, -Left*3.0-(strLen * 0.2), -Bottom*3.0-0.5, -3.0 );
+		if (Olsr_node_count_obj != -1) s3d_del_object(Olsr_node_count_obj);
+		snprintf(nc_str, 20, "node count: %d", Olsr_node_count);
+		Olsr_node_count_obj = s3d_draw_string(nc_str, &strLen);
+		s3d_link(Olsr_node_count_obj, 0);
+		s3d_flags_on(Olsr_node_count_obj, S3D_OF_VISIBLE);
+		s3d_scale(Olsr_node_count_obj, 0.2);
+		s3d_translate(Olsr_node_count_obj, -Left*3.0 - (strLen * 0.2), -Bottom*3.0 - 0.5, -3.0);
 		Last_olsr_node_count = Olsr_node_count;
 
 	}
 
-	if ( Output_block_completed ) {
+	if (Output_block_completed) {
 
 		Output_block_counter++;
 		Output_block_completed = 0;
@@ -759,8 +759,8 @@
 
 	/* read data from socket */
 	Net_read_count = 0;
-	while ( ( net_result = net_main() ) != 0 ) {
-		if ( net_result == -1 ) {
+	while ((net_result = net_main()) != 0) {
+		if (net_result == -1) {
 			s3d_quit();
 			break;
 		}
@@ -768,30 +768,30 @@
 
 	/* rotate modus */
 	if (RotateSwitch) {
-		Zp_rotate = ( Zp_rotate + RotateSpeed ) > 360 ? 0.0 : ( Zp_rotate + RotateSpeed );
-		s3d_rotate(ZeroPoint,0,Zp_rotate,0);
+		Zp_rotate = (Zp_rotate + RotateSpeed) > 360 ? 0.0 : (Zp_rotate + RotateSpeed);
+		s3d_rotate(ZeroPoint, 0, Zp_rotate, 0);
 	}
 
 	/* calc for node description */
-	CamPosition2[0][0]=  CamPosition[0][0]*cos(Zp_rotate*M_PI/180.0) - CamPosition[0][2] * sin (Zp_rotate*M_PI/180.0);
-	CamPosition2[0][1]=  CamPosition[0][1];
-	CamPosition2[0][2]=  CamPosition[0][0]*sin(Zp_rotate*M_PI/180.0) + CamPosition[0][2] * cos (Zp_rotate*M_PI/180.0);
+	CamPosition2[0][0] =  CamPosition[0][0] * cos(Zp_rotate * M_PI / 180.0) - CamPosition[0][2] * sin(Zp_rotate * M_PI / 180.0);
+	CamPosition2[0][1] =  CamPosition[0][1];
+	CamPosition2[0][2] =  CamPosition[0][0] * sin(Zp_rotate * M_PI / 180.0) + CamPosition[0][2] * cos(Zp_rotate * M_PI / 180.0);
 
 	/* check search status */
-	/*	if( get_search_status() == WIDGET )
-			move_to_search_widget( CamPosition[0], CamPosition[1] );*/
-	if ( get_search_status() == FOLLOW )
-		follow_node( CamPosition[0], CamPosition[1], Zp_rotate );
-	/*	if( get_search_status() == ABORT )
-			move_to_return_point( CamPosition[0], CamPosition[1] );*/
+	/* if( get_search_status() == WIDGET )
+	  move_to_search_widget( CamPosition[0], CamPosition[1] );*/
+	if (get_search_status() == FOLLOW)
+		follow_node(CamPosition[0], CamPosition[1], Zp_rotate);
+	/* if( get_search_status() == ABORT )
+	  move_to_return_point( CamPosition[0], CamPosition[1] );*/
 
 
-	if ( Olsr_ip_label_obj != -1 ) {
+	if (Olsr_ip_label_obj != -1) {
 		print_etx();
 	}
 	s3dw_ani_mate();
 
-	nanosleep( &sleep_time, NULL );
+	nanosleep(&sleep_time, NULL);
 
 	return;
 
@@ -813,8 +813,8 @@
 int keypress(struct s3d_evt *event)
 {
 
-	struct s3d_key_event *key=(struct s3d_key_event *)event->buf;
-	if ( get_search_status() != WIDGET ) {
+	struct s3d_key_event *key = (struct s3d_key_event *)event->buf;
+	if (get_search_status() != WIDGET) {
 		switch (key->keysym) {
 		case S3DK_F1: /* help */
 
@@ -823,16 +823,16 @@
 
 		case S3DK_ESCAPE: /* abort action */
 
-			set_search_status( get_search_status() == WIDGET ? ABORT : NOTHING );
+			set_search_status(get_search_status() == WIDGET ? ABORT : NOTHING);
 			break;
 
 		case S3DK_s: /* move to search widget, give widget focus */
 
-			set_search_status(WIDGET);							/* set status for mainloop */
-			set_node_root( Olsr_root );
+			set_search_status(WIDGET);       /* set status for mainloop */
+			set_node_root(Olsr_root);
 			show_search_window();
-			/*				set_return_point(CamPosition[0],CamPosition[1]);	/ * save the return position * /
-							set_node_root( Olsr_root );*/
+			/*    set_return_point(CamPosition[0],CamPosition[1]); / * save the return position * /
+			    set_node_root( Olsr_root );*/
 
 			break;
 
@@ -859,7 +859,7 @@
 		case S3DK_MINUS: /* - -> rotate speed decrease */
 
 			if (RotateSwitch) {
-				if ( RotateSpeed >= 2.0 )
+				if (RotateSpeed >= 2.0)
 					RotateSpeed -= 1.0;
 				else {
 					if (RotateSpeed > 0.2)
@@ -869,7 +869,7 @@
 			break;
 
 		case S3DK_p: /* strg + p -> reset nodes ( zeroPoint to 0,0,0 ) */
-			if (key->modifier&(S3D_KMOD_LCTRL|S3D_KMOD_RCTRL)) {
+			if (key->modifier&(S3D_KMOD_LCTRL | S3D_KMOD_RCTRL)) {
 				s3d_rotate(ZeroPoint, 0, 0, 0);
 				Zp_rotate = 0.0;
 			}
@@ -889,8 +889,8 @@
 
 		}
 	} else {
-		if ( (key->keysym >= S3DK_PERIOD && key->keysym <= S3DK_9) || key->keysym == S3DK_COMMA || key->keysym == S3DK_RETURN || key->keysym == S3DK_BACKSPACE )
-			search_widget_write( key->keysym );
+		if ((key->keysym >= S3DK_PERIOD && key->keysym <= S3DK_9) || key->keysym == S3DK_COMMA || key->keysym == S3DK_RETURN || key->keysym == S3DK_BACKSPACE)
+			search_widget_write(key->keysym);
 	}
 	return(0);
 }
@@ -903,28 +903,28 @@
 
 int object_click(struct s3d_evt *evt)
 {
-	/*	int i
-		char ip_str[50];
-		struct timeval tv;*/
+	/* int i
+	 char ip_str[50];
+	 struct timeval tv;*/
 	struct olsr_node *olsr_node;
 	int oid;
 
 	s3dw_handle_click(evt);
-	/*	if( get_search_status() == WIDGET )
-		{
-			s3dw_handle_click(evt);
-			return;
-		}*/
+	/* if( get_search_status() == WIDGET )
+	 {
+	  s3dw_handle_click(evt);
+	  return;
+	 }*/
 
-	oid=(int)*((uint32_t *)evt->buf);
+	oid = (int) * ((uint32_t *)evt->buf);
 
 
-	if ( ( get_search_status() != FOLLOW ) && ( Last_Click_Oid == oid ) && ( Last_Click_Time + 250 > get_time() ) ) {
+	if ((get_search_status() != FOLLOW) && (Last_Click_Oid == oid) && (Last_Click_Time + 250 > get_time())) {
 
 		olsr_node = lst_search(oid);
 
-		if ( olsr_node != NULL )
-			follow_node_by_click( olsr_node );
+		if (olsr_node != NULL)
+			follow_node_by_click(olsr_node);
 
 	}
 
@@ -932,55 +932,55 @@
 	Last_Click_Time = get_time();
 
 
-	/*	if( oid == Btn_close_id )
-		{
-			s3d_del_object(Btn_close_id);
-			s3d_del_object(Olsr_ip_label_obj);
-			Btn_close_id = Olsr_ip_label_obj = -1;
-			for(i=0; i < Size; i++)
-				s3d_del_object( Olsr_neighbour_label_obj[i] );
-			free(Olsr_neighbour_label_obj);
-			Olsr_neighbour_label_obj = NULL;
-			for(i = 0; i < 4; i++)
-			{
-				if(Output_border[i] != -1)
-					s3d_del_object(Output_border[i]);
-				Output_border[i] = -1;
-			}
-			return;
-		}
+	/* if( oid == Btn_close_id )
+	 {
+	  s3d_del_object(Btn_close_id);
+	  s3d_del_object(Olsr_ip_label_obj);
+	  Btn_close_id = Olsr_ip_label_obj = -1;
+	  for(i=0; i < Size; i++)
+	   s3d_del_object( Olsr_neighbour_label_obj[i] );
+	  free(Olsr_neighbour_label_obj);
+	  Olsr_neighbour_label_obj = NULL;
+	  for(i = 0; i < 4; i++)
+	  {
+	   if(Output_border[i] != -1)
+	    s3d_del_object(Output_border[i]);
+	   Output_border[i] = -1;
+	  }
+	  return;
+	 }
 
-		Olsr_node_pEtx = *lst_search(oid);
+	 Olsr_node_pEtx = *lst_search(oid);
 
-		if( Olsr_node_pEtx != NULL )
-		{
-			if( Btn_close_id == -1 )
-			{
-				Btn_close_id = s3d_clone( Btn_close_obj );
-				s3d_link(Btn_close_id,0);
-				s3d_flags_on(Btn_close_id,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-				s3d_scale( Btn_close_id, 0.10 );
-				s3d_translate( Btn_close_id,-Left*3.0-0.150, -Bottom*3.0-0.9, -3.0 );
-			}
+	 if( Olsr_node_pEtx != NULL )
+	 {
+	  if( Btn_close_id == -1 )
+	  {
+	   Btn_close_id = s3d_clone( Btn_close_obj );
+	   s3d_link(Btn_close_id,0);
+	   s3d_flags_on(Btn_close_id,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	   s3d_scale( Btn_close_id, 0.10 );
+	   s3d_translate( Btn_close_id,-Left*3.0-0.150, -Bottom*3.0-0.9, -3.0 );
+	  }
 
-			if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
-			snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
-			Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
-			s3d_link( Olsr_ip_label_obj, 0 );
-			s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
-			s3d_scale( Olsr_ip_label_obj, 0.2 );
-			s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.2, -3.0 );
+	  if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
+	  snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
+	  Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
+	  s3d_link( Olsr_ip_label_obj, 0 );
+	  s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
+	  s3d_scale( Olsr_ip_label_obj, 0.2 );
+	  s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.2, -3.0 );
 
-			cam_go=1;
-			if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
-			snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
-			Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
-			s3d_link( Olsr_ip_label_obj, 0 );
-			s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
-			s3d_scale( Olsr_ip_label_obj, 0.2 );
-			s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
+	  cam_go=1;
+	  if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
+	  snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
+	  Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
+	  s3d_link( Olsr_ip_label_obj, 0 );
+	  s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
+	  s3d_scale( Olsr_ip_label_obj, 0.2 );
+	  s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
 
-		}*/
+	 }*/
 	return(0);
 }
 
@@ -989,12 +989,12 @@
 	struct olsr_neigh_list *tmpNeighbour;
 	float p = 1.4;
 	int i;
-	float len = 0.0, max_len=0.0;
+	float len = 0.0, max_len = 0.0;
 
-	if ( Olsr_neighbour_label_obj != NULL ) {
+	if (Olsr_neighbour_label_obj != NULL) {
 		/* int n = sizeof(Olsr_neighbour_label_obj) / sizeof(int);*/
-		for (i=0; i < Size; i++)
-			s3d_del_object( Olsr_neighbour_label_obj[i] );
+		for (i = 0; i < Size; i++)
+			s3d_del_object(Olsr_neighbour_label_obj[i]);
 		free(Olsr_neighbour_label_obj);
 		Olsr_neighbour_label_obj = NULL;
 	}
@@ -1007,81 +1007,81 @@
 		tmpNeighbour = tmpNeighbour->next_olsr_neigh_list;
 	}
 
-	Olsr_neighbour_label_obj = malloc(Size*sizeof(int));
+	Olsr_neighbour_label_obj = malloc(Size * sizeof(int));
 	tmpNeighbour = Olsr_node_pEtx->olsr_neigh_list;
 
 	for (i = 0; i < Size ;i++) {
 		char nIpStr[60];
-		float mEtx = ( tmpNeighbour->olsr_con->left_etx + tmpNeighbour->olsr_con->right_etx ) / 2;
+		float mEtx = (tmpNeighbour->olsr_con->left_etx + tmpNeighbour->olsr_con->right_etx) / 2;
 
-		if ( mEtx != -1000 )
-			snprintf(nIpStr, 60, "%15s --> %.2f",(strcmp(Olsr_node_pEtx->ip,tmpNeighbour->olsr_con->right_olsr_node->ip)?tmpNeighbour->olsr_con->right_olsr_node->ip:tmpNeighbour->olsr_con->left_olsr_node->ip),mEtx);
+		if (mEtx != -1000)
+			snprintf(nIpStr, 60, "%15s --> %.2f", (strcmp(Olsr_node_pEtx->ip, tmpNeighbour->olsr_con->right_olsr_node->ip) ? tmpNeighbour->olsr_con->right_olsr_node->ip : tmpNeighbour->olsr_con->left_olsr_node->ip), mEtx);
 		else
-			snprintf(nIpStr, 60, "%15s --> HNA",(strcmp(Olsr_node_pEtx->ip,tmpNeighbour->olsr_con->right_olsr_node->ip)?tmpNeighbour->olsr_con->right_olsr_node->ip:tmpNeighbour->olsr_con->left_olsr_node->ip));
+			snprintf(nIpStr, 60, "%15s --> HNA", (strcmp(Olsr_node_pEtx->ip, tmpNeighbour->olsr_con->right_olsr_node->ip) ? tmpNeighbour->olsr_con->right_olsr_node->ip : tmpNeighbour->olsr_con->left_olsr_node->ip));
 
-		Olsr_neighbour_label_obj[i] = s3d_draw_string( nIpStr, &len );
+		Olsr_neighbour_label_obj[i] = s3d_draw_string(nIpStr, &len);
 		s3d_link(Olsr_neighbour_label_obj[i], 0);
-		s3d_flags_on(Olsr_neighbour_label_obj[i], S3D_OF_VISIBLE );
-		s3d_scale(Olsr_neighbour_label_obj[i], 0.2 );
-		s3d_translate(Olsr_neighbour_label_obj[i], -Left*3.0-(len * 0.2)-0.15, -Bottom*3.0-p, -3.0 );
+		s3d_flags_on(Olsr_neighbour_label_obj[i], S3D_OF_VISIBLE);
+		s3d_scale(Olsr_neighbour_label_obj[i], 0.2);
+		s3d_translate(Olsr_neighbour_label_obj[i], -Left*3.0 - (len * 0.2) - 0.15, -Bottom*3.0 - p, -3.0);
 		tmpNeighbour = tmpNeighbour->next_olsr_neigh_list;
 		p += 0.2;
-		max_len = (len > max_len - 0.2)?len+0.2:max_len;
-		max_len = (Title_len > max_len - 0.2)?len+0.2:max_len;
+		max_len = (len > max_len - 0.2) ? len + 0.2 : max_len;
+		max_len = (Title_len > max_len - 0.2) ? len + 0.2 : max_len;
 		/* printf("title: %f len: %f maxlen: %f %s\n",Title_len,len,max_len-0.2,nIpStr);*/
 	}
 
-	if ( Btn_close_id != -1) {
-		if ( Output_border[0] == -1 ) {
+	if (Btn_close_id != -1) {
+		if (Output_border[0] == -1) {
 			for (i = 0; i < 4; i++) {
 				Output_border[i] = s3d_new_object();
-				s3d_push_material( Output_border[i],
-				                   1.0,1.0,1.0,
-				                   1.0,1.0,1.0,
-				                   1.0,1.0,1.0);
+				s3d_push_material(Output_border[i],
+				                  1.0, 1.0, 1.0,
+				                  1.0, 1.0, 1.0,
+				                  1.0, 1.0, 1.0);
 			}
-			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,			-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
+			s3d_push_vertex(Output_border[0], -Left*3.0 - 0.2,   -Bottom*3.0 - 0.9, -3.0);
+			s3d_push_vertex(Output_border[0], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - 0.9, -3.0);
 
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-1.0, -3.0);
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
+			s3d_push_vertex(Output_border[1], -Left*3.0 - 0.1,   -Bottom*3.0 - 1.0, -3.0);
+			s3d_push_vertex(Output_border[1], -Left*3.0 - 0.1,   -Bottom*3.0 - p,  -3.0);
 
-			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
-			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
+			s3d_push_vertex(Output_border[2], -Left*3.0 - 0.1,   -Bottom*3.0 - p,  -3.0);
+			s3d_push_vertex(Output_border[2], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - p,  -3.0);
 
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
+			s3d_push_vertex(Output_border[3], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - 0.9, -3.0);
+			s3d_push_vertex(Output_border[3], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - p,  -3.0);
 
-			s3d_push_line( Output_border[0], 0,1,0);
-			s3d_push_line( Output_border[1], 0,1,0);
-			s3d_push_line( Output_border[2], 0,1,0);
-			s3d_push_line( Output_border[3], 0,1,0);
+			s3d_push_line(Output_border[0], 0, 1, 0);
+			s3d_push_line(Output_border[1], 0, 1, 0);
+			s3d_push_line(Output_border[2], 0, 1, 0);
+			s3d_push_line(Output_border[3], 0, 1, 0);
 
-			s3d_flags_on( Output_border[0], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[1], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[2], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[3], S3D_OF_VISIBLE);
+			s3d_flags_on(Output_border[0], S3D_OF_VISIBLE);
+			s3d_flags_on(Output_border[1], S3D_OF_VISIBLE);
+			s3d_flags_on(Output_border[2], S3D_OF_VISIBLE);
+			s3d_flags_on(Output_border[3], S3D_OF_VISIBLE);
 
-			s3d_link( Output_border[0], 0);
-			s3d_link( Output_border[1], 0);
-			s3d_link( Output_border[2], 0);
-			s3d_link( Output_border[3], 0);
+			s3d_link(Output_border[0], 0);
+			s3d_link(Output_border[1], 0);
+			s3d_link(Output_border[2], 0);
+			s3d_link(Output_border[3], 0);
 		} else {
 			s3d_pop_vertex(Output_border[0], 2);
 			s3d_pop_vertex(Output_border[1], 2);
 			s3d_pop_vertex(Output_border[2], 2);
 			s3d_pop_vertex(Output_border[3], 2);
-			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,				-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
+			s3d_push_vertex(Output_border[0], -Left*3.0 - 0.2,    -Bottom*3.0 - 0.9, -3.0);
+			s3d_push_vertex(Output_border[0], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - 0.9, -3.0);
 
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-1.0, -3.0);
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
+			s3d_push_vertex(Output_border[1], -Left*3.0 - 0.1,    -Bottom*3.0 - 1.0, -3.0);
+			s3d_push_vertex(Output_border[1], -Left*3.0 - 0.1,    -Bottom*3.0 - p,  -3.0);
 
-			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
-			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p,	 -3.0);
+			s3d_push_vertex(Output_border[2], -Left*3.0 - 0.1,    -Bottom*3.0 - p,  -3.0);
+			s3d_push_vertex(Output_border[2], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - p,  -3.0);
 
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	 -3.0);
+			s3d_push_vertex(Output_border[3], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - 0.9, -3.0);
+			s3d_push_vertex(Output_border[3], -Left*3.0 - (max_len*0.2), -Bottom*3.0 - p,   -3.0);
 		}
 	}
 }
@@ -1098,22 +1098,22 @@
 int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz->buf;
+	inf = (struct s3d_obj_info *)hrmz->buf;
 	s3dw_object_info(hrmz);
-	if (inf->object==0) {
+	if (inf->object == 0) {
 		CamPosition[0][0] = inf->trans_x;
 		CamPosition[0][1] = inf->trans_y;
 		CamPosition[0][2] = inf->trans_z;
 		CamPosition[1][0] = inf->rot_x;
 		CamPosition[1][1] = inf->rot_y;
 		CamPosition[1][2] = inf->rot_z;
-		Asp=inf->scale;
-		if (Asp>1.0) { /* wide screen */
-			Bottom=-1.0;
-			Left=-Asp;
+		Asp = inf->scale;
+		if (Asp > 1.0) { /* wide screen */
+			Bottom = -1.0;
+			Left = -Asp;
 		} else {  /* high screen */
-			Bottom=(-1.0/Asp);
-			Left=-1.0;
+			Bottom = (-1.0 / Asp);
+			Left = -1.0;
 
 		}
 
@@ -1125,28 +1125,28 @@
 int mbutton_press(struct s3d_evt *hrmz)
 {
 	struct s3d_but_info *inf;
-	inf=(struct s3d_but_info *)hrmz->buf;
-	printf("button %d, state %d\n", inf->button,inf->state);
+	inf = (struct s3d_but_info *)hrmz->buf;
+	printf("button %d, state %d\n", inf->button, inf->state);
 	return(0);
 }
 
-int main( int argc, char *argv[] )
+int main(int argc, char *argv[])
 {
 
 	int optchar;
-	strncpy( Olsr_host, "127.0.0.1", 256 );
+	strncpy(Olsr_host, "127.0.0.1", 256);
 	lbuf[0] = '\0';   /* init lbuf */
 
-	while ( ( optchar = getopt ( argc, argv, "dhH:" ) ) != -1 ) {
+	while ((optchar = getopt(argc, argv, "dhH:")) != -1) {
 
-		switch ( optchar ) {
+		switch (optchar) {
 
 		case 'd':
 			Debug = 1;
 			break;
 
 		case 'H':
-			strncpy( Olsr_host, optarg, 256 );
+			strncpy(Olsr_host, optarg, 256);
 			break;
 
 		case 'h':
@@ -1158,14 +1158,14 @@
 
 	}
 
-	if ( Debug )
-		printf( "debug mode enabled ...\n" );
+	if (Debug)
+		printf("debug mode enabled ...\n");
 
 	/* initialize obj2ip linked list */
 	lst_initialize();
 
 	/* delete olsrs3d options */
-	while ( ( optind < argc ) && ( argv[optind][0] != '-' ) ) optind++;   /* optind may point to ip addr of '-H' */
+	while ((optind < argc) && (argv[optind][0] != '-')) optind++;         /* optind may point to ip addr of '-H' */
 	optind--;
 	argv[optind] = argv[0];   /* save program path */
 	argc -= optind;   /* jump over olsrs3d options */
@@ -1176,27 +1176,27 @@
 
 
 	if (!net_init(Olsr_host)) {
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-		s3d_set_callback(S3D_EVENT_KEY,keypress);
-		s3d_set_callback(S3D_EVENT_QUIT,stop);
+		s3d_set_callback(S3D_EVENT_OBJ_INFO, object_info);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, object_click);
+		s3d_set_callback(S3D_EVENT_KEY, keypress);
+		s3d_set_callback(S3D_EVENT_QUIT, stop);
 
-		if (!s3d_init(&argc,&argv,"olsrs3d")) {
+		if (!s3d_init(&argc, &argv, "olsrs3d")) {
 
 			if (s3d_select_font("vera"))
 				printf("font not found\n");
 
-			Olsr_node_obj = s3d_import_model_file( "objs/accesspoint.3ds" );
-			Olsr_node_inet_obj = s3d_import_model_file( "objs/accesspoint_inet.3ds" );
-			Olsr_node_hna_net = s3d_import_model_file( "objs/internet.3ds" );
-			Btn_close_obj = s3d_import_model_file( "objs/btn_close.3ds" );
+			Olsr_node_obj = s3d_import_model_file("objs/accesspoint.3ds");
+			Olsr_node_inet_obj = s3d_import_model_file("objs/accesspoint_inet.3ds");
+			Olsr_node_hna_net = s3d_import_model_file("objs/internet.3ds");
+			Btn_close_obj = s3d_import_model_file("objs/btn_close.3ds");
 
-			S3d_obj = s3d_import_model_file( "objs/s3d_berlios_de.3ds" );
+			S3d_obj = s3d_import_model_file("objs/s3d_berlios_de.3ds");
 
-			s3d_translate( S3d_obj, 0.75, -0.75, -1 );
-			s3d_scale( S3d_obj, 0.07 );
-			s3d_link( S3d_obj, 0 );
-			s3d_flags_on( S3d_obj, S3D_OF_VISIBLE );
+			s3d_translate(S3d_obj, 0.75, -0.75, -1);
+			s3d_scale(S3d_obj, 0.07);
+			s3d_link(S3d_obj, 0);
+			s3d_flags_on(S3d_obj, S3D_OF_VISIBLE);
 
 			/* create_search_widget( 0, 0, 300 ); */
 

Modified: trunk/apps/olsrs3d/net.c
===================================================================
--- trunk/apps/olsrs3d/net.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/net.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -27,17 +27,17 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-#include <unistd.h>	/* close() */
+#include <unistd.h> /* close() */
 #include <errno.h>
-#include <string.h> 	/* strlen(), memmove(), strncpy(), strncat() */
+#include <string.h>  /* strlen(), memmove(), strncpy(), strncat() */
 #include <netdb.h>
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <sys/socket.h>
-#include <fcntl.h>		/* fnctl() */
+#include <fcntl.h>  /* fnctl() */
 #include "olsrs3d.h"
 
-#define PORT 2004 		/* the port client will be connecting to  */
+#define PORT 2004   /* the port client will be connecting to  */
 char buf[MAXDATASIZE];
 
 
@@ -47,7 +47,7 @@
 	struct hostent *he;
 	struct sockaddr_in their_addr; /* connector's address information  */
 
-	if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
+	if ((he = gethostbyname(host)) == NULL) {  /* get the host info  */
 		herror("gethostbyname");
 		return(1);
 	}
@@ -67,21 +67,21 @@
 		perror("connect");
 		return(1);
 	}
-	fcntl(sockfd,F_SETFL, O_NONBLOCK);
+	fcntl(sockfd, F_SETFL, O_NONBLOCK);
 	return(0);
 }
 
 int net_main()
 {
 
-	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
-		if (errno==EAGAIN)
+	if ((numbytes = recv(sockfd, buf, MAXDATASIZE - 1, 0)) == -1) {
+		if (errno == EAGAIN)
 			return(0); /* well, that's okay ... */
 		perror("recv");
 		return(-1);
 	}
 
-	if (numbytes==0) {
+	if (numbytes == 0) {
 		printf("connection reset\n");
 		return(-1);
 	}
@@ -89,22 +89,22 @@
 	buf[numbytes] = '\0';
 
 	/* check for potential buffer overflow */
-	if ( ( strlen( lbuf ) + strlen( buf ) ) < MAXLINESIZE ) {
+	if ((strlen(lbuf) + strlen(buf)) < MAXLINESIZE) {
 
-		strncat( lbuf, buf, MAXLINESIZE );
+		strncat(lbuf, buf, MAXLINESIZE);
 
 	} else {
 
 		/* hope that carriage return is now in buf */
-		if ( strlen( lbuf ) < MAXLINESIZE ) {
+		if (strlen(lbuf) < MAXLINESIZE) {
 
-			if ( Debug ) printf( "WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n" );
-			strncat( lbuf, buf, MAXLINESIZE - strlen( lbuf ) );
+			if (Debug) printf("WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n");
+			strncat(lbuf, buf, MAXLINESIZE - strlen(lbuf));
 
 		} else {
 
-			if ( Debug ) printf( "ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n" );
-			strncpy( lbuf, buf, MAXLINESIZE );
+			if (Debug) printf("ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n");
+			strncpy(lbuf, buf, MAXLINESIZE);
 
 		}
 
@@ -112,7 +112,7 @@
 
 	process_main();
 
-	if ( ++Net_read_count > 5 ) {
+	if (++Net_read_count > 5) {
 		return(0);   /* continue mainloop */
 	} else {
 		return(1);   /* continue reading data from socket */

Modified: trunk/apps/olsrs3d/olsrs3d.h
===================================================================
--- trunk/apps/olsrs3d/olsrs3d.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/olsrs3d.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -37,12 +37,12 @@
 extern struct olsr_node *Olsr_root;   /* top of olsr node tree */
 extern struct Obj_to_ip *Obj_to_ip_head, *Obj_to_ip_end, *List_ptr;   /* struct list */
 
-extern int	Olsr_node_obj;
-extern int	Olsr_node_inet_obj;
-extern int	Olsr_node_hna_net;
-extern int	Btn_close_obj;
-extern int	S3d_obj;
-extern int	Btn_close_id;
+extern int Olsr_node_obj;
+extern int Olsr_node_inet_obj;
+extern int Olsr_node_hna_net;
+extern int Btn_close_obj;
+extern int S3d_obj;
+extern int Btn_close_id;
 extern int Olsr_node_count_obj;
 extern int Olsr_node_count;
 extern int Last_olsr_node_count;
@@ -58,7 +58,7 @@
 
 /* process */
 void lst_initialize();
-void lst_add(int id,struct olsr_node **olsr_node);
+void lst_add(int id, struct olsr_node **olsr_node);
 void lst_del(int id);
 struct olsr_node *lst_search(int id);
 void lst_out();
@@ -69,7 +69,7 @@
 int net_main();
 int net_quit();
 /* main */
-void out_of_mem( void );
-void print_etx( void );
+void out_of_mem(void);
+void print_etx(void);
 float dist(float p1[], float p2[]);
 void window_error(char *msg);

Modified: trunk/apps/olsrs3d/process.c
===================================================================
--- trunk/apps/olsrs3d/process.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/process.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,9 +25,9 @@
 
 
 
-#include <stdio.h> 	/* NULL */
-#include <string.h> 	/* strlen(), memmove() */
-#include <stdlib.h> 	/* rand(), malloc(), realloc(), free() */
+#include <stdio.h>  /* NULL */
+#include <string.h>  /* strlen(), memmove() */
+#include <stdlib.h>  /* rand(), malloc(), realloc(), free() */
 #include <s3d.h>
 #include <math.h>       /* sqrt() */
 #include "olsrs3d.h"
@@ -50,25 +50,25 @@
  *
  ***/
 
-int add_olsr_con( struct olsr_node *con_from, struct olsr_node *con_to, float etx )
+int add_olsr_con(struct olsr_node *con_from, struct olsr_node *con_to, float etx)
 {
 
 	struct olsr_con **olsr_con = &Con_begin;
 	struct olsr_con *prev_olsr_con = NULL;   /* previous olsr connection */
 	struct olsr_neigh_list **olsr_neigh_list;
 
-	while ( (*olsr_con) != NULL ) {
+	while ((*olsr_con) != NULL) {
 
 		/* connection already exists */
-		if ( ( strncmp( (*olsr_con)->left_olsr_node->ip, con_from->ip, NAMEMAX ) == 0 ) && ( strncmp( (*olsr_con)->right_olsr_node->ip, con_to->ip, NAMEMAX ) == 0 ) ) {
+		if ((strncmp((*olsr_con)->left_olsr_node->ip, con_from->ip, NAMEMAX) == 0) && (strncmp((*olsr_con)->right_olsr_node->ip, con_to->ip, NAMEMAX) == 0)) {
 			(*olsr_con)->left_etx = etx;
-			(*olsr_con)->left_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
+			(*olsr_con)->left_etx_sqrt = (etx == -1000.00) ? 10.0 : sqrt(etx) ;
 			break;
 
-		} else if ( ( strncmp( (*olsr_con)->right_olsr_node->ip, con_from->ip, NAMEMAX ) == 0 ) && ( strncmp( (*olsr_con)->left_olsr_node->ip, con_to->ip, NAMEMAX ) == 0 ) ) {
+		} else if ((strncmp((*olsr_con)->right_olsr_node->ip, con_from->ip, NAMEMAX) == 0) && (strncmp((*olsr_con)->left_olsr_node->ip, con_to->ip, NAMEMAX) == 0)) {
 
 			(*olsr_con)->right_etx = etx;
-			(*olsr_con)->right_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
+			(*olsr_con)->right_etx_sqrt = (etx == -1000.00) ? 10.0 : sqrt(etx) ;
 			break;
 
 		}
@@ -81,10 +81,10 @@
 	}
 
 	/* new connection */
-	if ( (*olsr_con) == NULL ) {
+	if ((*olsr_con) == NULL) {
 
-		(*olsr_con) = malloc( sizeof( struct olsr_con ) );
-		if ( (*olsr_con) == NULL ) out_of_mem();
+		(*olsr_con) = malloc(sizeof(struct olsr_con));
+		if ((*olsr_con) == NULL) out_of_mem();
 
 		/* create connection object */
 		(*olsr_con)->obj_id = s3d_new_object();
@@ -95,23 +95,23 @@
 
 		/* add connection color */
 		(*olsr_con)->color = 0;
-		s3d_push_material( (*olsr_con)->obj_id,
-		                   1.0,1.0,1.0,
-		                   1.0,1.0,1.0,
-		                   1.0,1.0,1.0);
+		s3d_push_material((*olsr_con)->obj_id,
+		                  1.0, 1.0, 1.0,
+		                  1.0, 1.0, 1.0,
+		                  1.0, 1.0, 1.0);
 
 		/* add connection endpoints */
-		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->left_olsr_node->pos_vec[0], (*olsr_con)->left_olsr_node->pos_vec[1], (*olsr_con)->left_olsr_node->pos_vec[2] );
-		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->right_olsr_node->pos_vec[0], (*olsr_con)->right_olsr_node->pos_vec[1], (*olsr_con)->right_olsr_node->pos_vec[2] );
+		s3d_push_vertex((*olsr_con)->obj_id, (*olsr_con)->left_olsr_node->pos_vec[0], (*olsr_con)->left_olsr_node->pos_vec[1], (*olsr_con)->left_olsr_node->pos_vec[2]);
+		s3d_push_vertex((*olsr_con)->obj_id, (*olsr_con)->right_olsr_node->pos_vec[0], (*olsr_con)->right_olsr_node->pos_vec[1], (*olsr_con)->right_olsr_node->pos_vec[2]);
 
-		s3d_push_line( (*olsr_con)->obj_id, 0,1,0 );
+		s3d_push_line((*olsr_con)->obj_id, 0, 1, 0);
 
-		s3d_flags_on( (*olsr_con)->obj_id, S3D_OF_VISIBLE );
+		s3d_flags_on((*olsr_con)->obj_id, S3D_OF_VISIBLE);
 
-		s3d_link( (*olsr_con)->obj_id,  ZeroPoint );
+		s3d_link((*olsr_con)->obj_id,  ZeroPoint);
 
 		/* HNA */
-		if ( etx == -1000.00 ) {
+		if (etx == -1000.00) {
 
 			(*olsr_con)->left_etx = etx;
 			(*olsr_con)->left_etx_sqrt = 10.0;
@@ -121,9 +121,9 @@
 		} else {
 
 			(*olsr_con)->left_etx = etx;
-			(*olsr_con)->left_etx_sqrt = sqrt( etx );
+			(*olsr_con)->left_etx_sqrt = sqrt(etx);
 			(*olsr_con)->right_etx = 999.0;
-			(*olsr_con)->right_etx_sqrt = sqrt( 999.0 );
+			(*olsr_con)->right_etx_sqrt = sqrt(999.0);
 
 		}
 
@@ -132,16 +132,16 @@
 
 		/* add new olsr connection to olsr nodes in order to access the connection from the olsr node */
 		olsr_neigh_list = &(*olsr_con)->left_olsr_node->olsr_neigh_list;
-		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
-		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
-		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
+		while ((*olsr_neigh_list) != NULL) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
+		(*olsr_neigh_list) = malloc(sizeof(struct olsr_neigh_list));
+		if ((*olsr_neigh_list) == NULL) out_of_mem();
 		(*olsr_neigh_list)->olsr_con = (*olsr_con);
 		(*olsr_neigh_list)->next_olsr_neigh_list = NULL;
 
 		olsr_neigh_list = &(*olsr_con)->right_olsr_node->olsr_neigh_list;
-		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
-		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
-		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
+		while ((*olsr_neigh_list) != NULL) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
+		(*olsr_neigh_list) = malloc(sizeof(struct olsr_neigh_list));
+		if ((*olsr_neigh_list) == NULL) out_of_mem();
 		(*olsr_neigh_list)->olsr_con = (*olsr_con);
 		(*olsr_neigh_list)->next_olsr_neigh_list = NULL;
 
@@ -164,22 +164,22 @@
  *
  ***/
 
-void *get_olsr_node( struct olsr_node **olsr_node, char *ip )
+void *get_olsr_node(struct olsr_node **olsr_node, char *ip)
 {
 
 	int result;   /* result of strcmp */
 
-	while ( (*olsr_node) != NULL ) {
+	while ((*olsr_node) != NULL) {
 
-		result = strncmp( (*olsr_node)->ip, ip, NAMEMAX );
+		result = strncmp((*olsr_node)->ip, ip, NAMEMAX);
 
 		/* we found the node */
-		if ( result == 0 ) {
+		if (result == 0) {
 
 			(*olsr_node)->last_seen = Output_block_counter;
 
 			/* former invisble (deleted) node */
-			if ( (*olsr_node)->visible == 0 ) {
+			if ((*olsr_node)->visible == 0) {
 
 				(*olsr_node)->node_type = 0;
 				(*olsr_node)->node_type_modified = 1;
@@ -188,7 +188,7 @@
 
 				(*olsr_node)->mov_vec[0] = (*olsr_node)->mov_vec[1] = (*olsr_node)->mov_vec[2] = 0.0;
 
-				if ( Debug ) printf( "new olsr node: %s\n", (*olsr_node)->ip );
+				if (Debug) printf("new olsr node: %s\n", (*olsr_node)->ip);
 
 				Olsr_node_count++;
 
@@ -199,7 +199,7 @@
 		}
 
 		/* the searched node must be in the subtree */
-		if ( result < 0 ) {
+		if (result < 0) {
 			olsr_node = &(*olsr_node)->right;
 		} else {
 			olsr_node = &(*olsr_node)->left;
@@ -208,15 +208,15 @@
 	}
 
 	/* if node is NULL we reached the end of the tree and must create a new olsr_node */
-	if ( (*olsr_node) == NULL ) {
+	if ((*olsr_node) == NULL) {
 
-		(*olsr_node) = malloc( sizeof( struct olsr_node ) );
-		if ( (*olsr_node) == NULL ) out_of_mem();
+		(*olsr_node) = malloc(sizeof(struct olsr_node));
+		if ((*olsr_node) == NULL) out_of_mem();
 
 		(*olsr_node)->left = NULL;
 		(*olsr_node)->right = NULL;
 
-		strncpy( (*olsr_node)->ip, ip, NAMEMAX );
+		strncpy((*olsr_node)->ip, ip, NAMEMAX);
 
 		(*olsr_node)->node_type = 0;
 		(*olsr_node)->node_type_modified = 1;
@@ -224,13 +224,13 @@
 		(*olsr_node)->last_seen = Output_block_counter;
 		(*olsr_node)->visible = 1;
 
-		if ( Debug ) printf( "new olsr node: %s\n", (*olsr_node)->ip );
+		if (Debug) printf("new olsr node: %s\n", (*olsr_node)->ip);
 
 		Olsr_node_count++;
 
-		(*olsr_node)->pos_vec[0] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)->pos_vec[1] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)->pos_vec[2] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+		(*olsr_node)->pos_vec[0] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
+		(*olsr_node)->pos_vec[1] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
+		(*olsr_node)->pos_vec[2] = ((float) 2.0 * rand()) / RAND_MAX - 1.0;
 		(*olsr_node)->mov_vec[0] = (*olsr_node)->mov_vec[1] = (*olsr_node)->mov_vec[2] = 0.0;
 
 		(*olsr_node)->obj_id = -1;
@@ -270,7 +270,7 @@
  *
  */
 
-void lst_add(int id,struct olsr_node **olsr_node)
+void lst_add(int id, struct olsr_node **olsr_node)
 {
 	struct Obj_to_ip *new;
 	new = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
@@ -298,7 +298,7 @@
 	struct Obj_to_ip *del;
 	move_lst_ptr(&id);
 	if (id != List_ptr->id) {
-		printf("obj2ip: remove id %d failed move_lst_ptr return id %d\n",id,List_ptr->next->id);
+		printf("obj2ip: remove id %d failed move_lst_ptr return id %d\n", id, List_ptr->next->id);
 	} else {
 		del = List_ptr;
 		List_ptr->next->prev = List_ptr->prev;
@@ -311,7 +311,7 @@
 /*
  *
  * move the List_ptr one positon ahead the searched element
- *	*id => pointer of object_id , returned from s3d_clone or s3d_new_object
+ * *id => pointer of object_id , returned from s3d_clone or s3d_new_object
  *
  */
 
@@ -327,7 +327,7 @@
 		return NULL;
 	} else {
 		/* printf("obj2ip: ok i search deeper ;-) for id=%d\n",*id); */
-		if ((*id - (int) Obj_to_ip_head->next->id) <= ((int)(Obj_to_ip_end->prev->id)-*id)) {
+		if ((*id - (int) Obj_to_ip_head->next->id) <= ((int)(Obj_to_ip_end->prev->id) - *id)) {
 			List_ptr = Obj_to_ip_head;
 			/* printf("obj2ip: start at head id %d - %d <= %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id); */
 			while (*id >= List_ptr->next->id) {
@@ -347,7 +347,7 @@
 			List_ptr = List_ptr->prev;
 		}
 
-		if ( List_ptr->id == *id )
+		if (List_ptr->id == *id)
 			return List_ptr->olsr_node;
 		else
 			return NULL;
@@ -359,7 +359,7 @@
 /*
  *
  * search a object_id in linked list and return pointer on struct olsr_node
- *	id => object_id , returned from s3d_clone or s3d_new_object
+ * id => object_id , returned from s3d_clone or s3d_new_object
  *
  * <example>
  *     struct olsr_node *olsr_node;
@@ -371,7 +371,7 @@
 
 struct olsr_node *lst_search(int id) {
 
-	return( move_lst_ptr(&id) );
+	return(move_lst_ptr(&id));
 
 }
 
@@ -380,7 +380,7 @@
 	struct Obj_to_ip *ptr;
 	ptr = Obj_to_ip_head;
 	while (ptr != ptr->next) {
-		printf("id-> %d\n",ptr->id);
+		printf("id-> %d\n", ptr->id);
 		ptr = ptr->next;
 	}
 }
@@ -405,11 +405,11 @@
 
 	/*printf("---lbuf-start---\n%s\n---lbuf-end---\n",lbuf);*/
 
-	while ( (*lbuf_ptr) != '\0' ) {
+	while ((*lbuf_ptr) != '\0') {
 
 		/* printf( "%c",(*lbuf_ptr) ); */
 
-		if ( (*lbuf_ptr) == '\n' ) {
+		if ((*lbuf_ptr) == '\n') {
 
 			last_cr_ptr = lbuf_ptr;
 			con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
@@ -417,9 +417,9 @@
 
 		}
 
-		if ( (*lbuf_ptr) == '"' ) {
+		if ((*lbuf_ptr) == '"') {
 
-			switch ( dn ) {
+			switch (dn) {
 
 			case 0:
 				con_from = lbuf_ptr + 1;
@@ -442,7 +442,7 @@
 
 			}
 
-			if ( ++dn == 6 ) {
+			if (++dn == 6) {
 
 				/* terminate strings - but not before 6 times '"' */
 				(*con_from_end) = (*con_to_end) = (*etx_end) = '\0';
@@ -450,55 +450,55 @@
 				/* printf( "con_from: %s, con_to: %s, etx: %s\n", con_from, con_to, etx ); */
 
 				/* announced network via HNA */
-				if ( strncmp( etx, "HNA", NAMEMAX ) == 0 ) {
+				if (strncmp(etx, "HNA", NAMEMAX) == 0) {
 
 					/* connection to internet */
-					if ( strncmp( con_to, "0.0.0.0/0.0.0.0", NAMEMAX ) == 0 ) {
+					if (strncmp(con_to, "0.0.0.0/0.0.0.0", NAMEMAX) == 0) {
 
-						olsr_node1 = get_olsr_node( &Olsr_root, con_from );
+						olsr_node1 = get_olsr_node(&Olsr_root, con_from);
 
-						if ( olsr_node1->node_type != 1 ) {
+						if (olsr_node1->node_type != 1) {
 
 							olsr_node1->node_type = 1;
 							olsr_node1->node_type_modified = 1;
-							if ( Debug ) printf( "new internet: %s\n", olsr_node1->ip );
+							if (Debug) printf("new internet: %s\n", olsr_node1->ip);
 
 						}
 
 						/* normal HNA */
 					} else {
-						memmove(hna_node,con_to,NAMEMAX);
-						if ( (tmpChar = strchr(hna_node, (int)'/'))) {
+						memmove(hna_node, con_to, NAMEMAX);
+						if ((tmpChar = strchr(hna_node, (int)'/'))) {
 							tmpChar++;
-							address = (int)-inet_network(tmpChar);
-							sprintf(hna_name,"%d",(int)(32 - ceil(log(address)/log(2))));
-							strcpy(tmpChar,hna_name);
+							address = (int) - inet_network(tmpChar);
+							sprintf(hna_name, "%d", (int)(32 - ceil(log(address) / log(2))));
+							strcpy(tmpChar, hna_name);
 						}
 
-						olsr_node1 = get_olsr_node( &Olsr_root, con_from );
-						olsr_node2 = get_olsr_node( &Olsr_root, hna_node );
+						olsr_node1 = get_olsr_node(&Olsr_root, con_from);
+						olsr_node2 = get_olsr_node(&Olsr_root, hna_node);
 
-						if ( olsr_node2->node_type != 2 ) {
+						if (olsr_node2->node_type != 2) {
 
 							olsr_node2->node_type = 2;
 							olsr_node2->node_type_modified = 1;
-							if ( Debug ) printf( "new hna network: %s\n", olsr_node2->ip );
+							if (Debug) printf("new hna network: %s\n", olsr_node2->ip);
 
 						}
-						if ( olsr_node1->visible && olsr_node2->visible )
-							add_olsr_con( olsr_node1, olsr_node2, -1000.00 );
+						if (olsr_node1->visible && olsr_node2->visible)
+							add_olsr_con(olsr_node1, olsr_node2, -1000.00);
 
 					}
 
 					/* normal node */
 				} else {
 
-					olsr_node1 = get_olsr_node( &Olsr_root, con_from );
-					olsr_node2 = get_olsr_node( &Olsr_root, con_to );
-					f = strtod(etx,NULL);
-					if ( f < 1.0 )
+					olsr_node1 = get_olsr_node(&Olsr_root, con_from);
+					olsr_node2 = get_olsr_node(&Olsr_root, con_to);
+					f = strtod(etx, NULL);
+					if (f < 1.0)
 						f = 999.0;
-					add_olsr_con( olsr_node1, olsr_node2, f );
+					add_olsr_con(olsr_node1, olsr_node2, f);
 				}
 				/* remove zerobyte */
 				(*con_from_end) = (*con_to_end) = (*etx_end) = '"';
@@ -509,7 +509,7 @@
 
 			}
 
-		} else if ( ( (*lbuf_ptr) == '}' ) && ( (*(lbuf_ptr + 1)) == '\n' ) ) {
+		} else if (((*lbuf_ptr) == '}') && ((*(lbuf_ptr + 1)) == '\n')) {
 
 			Output_block_completed = 1;
 
@@ -519,7 +519,7 @@
 
 	}
 
-	if ( last_cr_ptr != NULL ) memmove( lbuf, last_cr_ptr + 1, strlen( last_cr_ptr ) );
+	if (last_cr_ptr != NULL) memmove(lbuf, last_cr_ptr + 1, strlen(last_cr_ptr));
 	/*printf("---memmove-lbuf-start---\n%s\n---memmove-lbuf-end---\n",lbuf);*/
 	return(0);
 

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/search.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,21 +25,21 @@
 #include <s3dw.h>
 #include <s3d_keysym.h>
 #include <math.h>
-#include <stdio.h>	/* TODO can remove then no more printf needed */
+#include <stdio.h> /* TODO can remove then no more printf needed */
 #include <string.h>
-#include "olsrs3d.h"	/* for window_error(), structs */
+#include "olsrs3d.h" /* for window_error(), structs */
 /* #include "structs.h"  already included by olsrs3d.h */
 #include "search.h"
 
-s3dw_surface	*_search_surface;
-s3dw_input		*_search_input;
-s3dw_widget		*_search_widget;
+s3dw_surface *_search_surface;
+s3dw_input  *_search_input;
+s3dw_widget  *_search_widget;
 
 struct olsr_node *_node_root = NULL;
 struct olsr_node **search_node = NULL;
 
-float	_return_point[2][3];				/* cam position before move to the widget */
-int		_search_status = NOTHING;			/* status of search */
+float _return_point[2][3];    /* cam position before move to the widget */
+int  _search_status = NOTHING;   /* status of search */
 
 void _search_node(s3dw_widget *dummy);
 void _new_search_node(s3dw_widget *dummy);
@@ -47,7 +47,7 @@
 
 
 /* public */
-void follow_node(float cam_position_t[], float cam_position_r[],float rotate)
+void follow_node(float cam_position_t[], float cam_position_r[], float rotate)
 {
 	float real_node_pos[3],
 	cam_target[3],
@@ -55,17 +55,17 @@
 	diff_vec[3],
 	angle;
 
-	real_node_pos[0] =  (*search_node)->pos_vec[0] * cos( rotate * M_PI / 180.0 ) - (*search_node)->pos_vec[2] * -sin ( rotate * M_PI / 180.0 );
-	real_node_pos[1] =  (*search_node)->pos_vec[1];
-	real_node_pos[2] =  (*search_node)->pos_vec[0] * -sin( rotate * M_PI / 180.0) + (*search_node)->pos_vec[2] * cos ( rotate * M_PI / 180.0 );
+	real_node_pos[0] = (*search_node)->pos_vec[0] * cos(rotate * M_PI / 180.0) - (*search_node)->pos_vec[2] * -sin(rotate * M_PI / 180.0);
+	real_node_pos[1] = (*search_node)->pos_vec[1];
+	real_node_pos[2] = (*search_node)->pos_vec[0] * -sin(rotate * M_PI / 180.0) + (*search_node)->pos_vec[2] * cos(rotate * M_PI / 180.0);
 
-	cam_target[0] = ( real_node_pos[0] + 7);
+	cam_target[0] = (real_node_pos[0] + 7);
 	cam_target[1] =   real_node_pos[1];
-	cam_target[2] = ( real_node_pos[2] + 7);
+	cam_target[2] = (real_node_pos[2] + 7);
 
-	cam_position_t[0]=( cam_position_t[0] * 4 + cam_target[0] ) / 5;
-	cam_position_t[1]=( cam_position_t[1] * 4 + cam_target[1] ) / 5;
-	cam_position_t[2]=( cam_position_t[2] * 4 + cam_target[2] ) / 5;
+	cam_position_t[0] = (cam_position_t[0] * 4 + cam_target[0]) / 5;
+	cam_position_t[1] = (cam_position_t[1] * 4 + cam_target[1]) / 5;
+	cam_position_t[2] = (cam_position_t[2] * 4 + cam_target[2]) / 5;
 
 	tmp_vec[0] =  0.0;
 	tmp_vec[1] =  0.0;
@@ -74,44 +74,44 @@
 	diff_vec[0] = cam_position_t[0] - real_node_pos[0];
 	diff_vec[1] = 0.0;
 	diff_vec[2] = cam_position_t[2] - real_node_pos[2];
-	angle = s3d_vector_angle( diff_vec, tmp_vec );
+	angle = s3d_vector_angle(diff_vec, tmp_vec);
 	/* angle = ( real_node_pos[0] > 0) ? ( 180 - ( 180 / M_PI * angle ) ) : ( 180 + ( 180 / M_PI * angle ) ); */
-	angle = 180 - ( 180 / M_PI * angle );
-	cam_position_r[1] = ( cam_position_r[1] * 4 + angle ) / 5;
+	angle = 180 - (180 / M_PI * angle);
+	cam_position_r[1] = (cam_position_r[1] * 4 + angle) / 5;
 
-	s3d_translate( 0, cam_position_t[0], cam_position_t[1], cam_position_t[2] );
-	s3d_rotate( 0, cam_position_r[0], cam_position_r[1], cam_position_r[2] );
+	s3d_translate(0, cam_position_t[0], cam_position_t[1], cam_position_t[2]);
+	s3d_rotate(0, cam_position_r[0], cam_position_r[1], cam_position_r[2]);
 }
 void _abort_search_window(s3dw_widget *bwidget)
 {
 	s3dw_delete(bwidget->parent); /* remove the window cointaining the button */
-	_search_surface=NULL;
-	_search_input=NULL;
-	_search_widget=NULL;
+	_search_surface = NULL;
+	_search_input = NULL;
+	_search_widget = NULL;
 	set_search_status(NOTHING);
 }
 void show_search_window()
 {
 	s3dw_button *search_button, *abort_button;
 
-	_search_surface	= s3dw_surface_new( "Node Search", 17, 10 );
-	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
+	_search_surface = s3dw_surface_new("Node Search", 17, 10);
+	_search_input = s3dw_input_new(_search_surface, 15, 1, 4);
 
-	s3dw_label_new( _search_surface, "Enter the IP of the node.", 1, 2);
-	s3dw_focus( S3DWIDGET( _search_input ) );
+	s3dw_label_new(_search_surface, "Enter the IP of the node.", 1, 2);
+	s3dw_focus(S3DWIDGET(_search_input));
 
-	search_button = s3dw_button_new( _search_surface, "Search", 11.5, 7 );
-	abort_button  = s3dw_button_new( _search_surface, "Abort", 1, 7 );
+	search_button = s3dw_button_new(_search_surface, "Search", 11.5, 7);
+	abort_button  = s3dw_button_new(_search_surface, "Abort", 1, 7);
 	search_button->onclick = _new_search_node;
 	abort_button->onclick = _abort_search_window;
 
 	/* TODO calc position for ok button */
 
-	s3dw_focus	( S3DWIDGET( _search_input ) );
-	s3dw_focus	( S3DWIDGET( _search_surface ) );
-	s3dw_show	( S3DWIDGET( _search_surface ) );
+	s3dw_focus(S3DWIDGET(_search_input));
+	s3dw_focus(S3DWIDGET(_search_surface));
+	s3dw_show(S3DWIDGET(_search_surface));
 
-	_search_widget	= S3DWIDGET(search_button);
+	_search_widget = S3DWIDGET(search_button);
 }
 
 /* public */
@@ -119,25 +119,25 @@
 {
 	s3dw_button *search_button, *abort_button;
 
-	_search_surface	= s3dw_surface_new( "Node Search", 17, 10 );
-	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
+	_search_surface = s3dw_surface_new("Node Search", 17, 10);
+	_search_input = s3dw_input_new(_search_surface, 15, 1, 4);
 
-	s3dw_label_new( _search_surface, "Enter the IP of the node.", 1, 2);
-	s3dw_focus( S3DWIDGET( _search_input ) );
+	s3dw_label_new(_search_surface, "Enter the IP of the node.", 1, 2);
+	s3dw_focus(S3DWIDGET(_search_input));
 
-	search_button = s3dw_button_new( _search_surface, "Search", 11.5, 7 );
-	abort_button  = s3dw_button_new( _search_surface, "Abort", 1, 7 );
+	search_button = s3dw_button_new(_search_surface, "Search", 11.5, 7);
+	abort_button  = s3dw_button_new(_search_surface, "Abort", 1, 7);
 	search_button->onclick = _search_node;
 	abort_button->onclick = _abort_search;
 
 	/* TODO calc position for ok button */
 
-	s3dw_focus	( S3DWIDGET( _search_input ) );
-	s3dw_focus	( S3DWIDGET( _search_surface ) );
-	s3dw_show	( S3DWIDGET( _search_surface ) );
+	s3dw_focus(S3DWIDGET(_search_input));
+	s3dw_focus(S3DWIDGET(_search_surface));
+	s3dw_show(S3DWIDGET(_search_surface));
 
 	/* disabled for autofollowing mode */
-	/*_search_widget	= s3dw_getroot();
+	/*_search_widget = s3dw_getroot();
 	move_search_widget( x, y, z );
 
 	_search_widget->ary = 180;
@@ -150,7 +150,7 @@
 	_search_widget->x = x;
 	_search_widget->y = y;
 	_search_widget->z = z;
-	s3dw_moveit( _search_widget );
+	s3dw_moveit(_search_widget);
 }
 
 /* public */
@@ -159,45 +159,45 @@
 	float target, current;
 
 	set_search_status(WIDGET);
-	cam_position_t[0] = ( cam_position_t[0] * 4 + _search_widget->x ) / 5;
-	cam_position_t[1] = ( cam_position_t[1] * 4 + _search_widget->y ) / 5;
-	cam_position_t[2] = ( cam_position_t[2] * 4 + ( _search_widget->z - 10 ) ) / 5;
+	cam_position_t[0] = (cam_position_t[0] * 4 + _search_widget->x) / 5;
+	cam_position_t[1] = (cam_position_t[1] * 4 + _search_widget->y) / 5;
+	cam_position_t[2] = (cam_position_t[2] * 4 + (_search_widget->z - 10)) / 5;
 
 	target = _search_widget->arx;
 	current = cam_position_r[0];
 
-	if ( _search_widget->arx - cam_position_r[0] > 180 )
+	if (_search_widget->arx - cam_position_r[0] > 180)
 		target -= 360;
-	if ( _search_widget->arx - cam_position_r[0] < -180 )
+	if (_search_widget->arx - cam_position_r[0] < -180)
 		current -= 360;
-	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
+	cam_position_r[0] = (cam_position_r[0] * 4 + target) / 5;
 
 	target = _search_widget->ary;
 	current = cam_position_r[1];
 
-	if ( _search_widget->ary - cam_position_r[1] > 180 )
+	if (_search_widget->ary - cam_position_r[1] > 180)
 		target -= 360;
-	if ( _search_widget->ary - cam_position_r[1] < -180 )
+	if (_search_widget->ary - cam_position_r[1] < -180)
 		current -= 360;
-	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
+	cam_position_r[1] = (cam_position_r[1] * 4 + target) / 5;
 
 	target = _search_widget->arz;
 	current = cam_position_r[2];
 
-	if ( _search_widget->arz - cam_position_r[2] > 180 )
+	if (_search_widget->arz - cam_position_r[2] > 180)
 		target -= 360;
-	if ( _search_widget->arz - cam_position_r[2] < -180 )
+	if (_search_widget->arz - cam_position_r[2] < -180)
 		current -= 360;
-	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
+	cam_position_r[2] = (cam_position_r[2] * 4 + target) / 5;
 
-	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
-	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
+	s3d_translate(0, cam_position_t[0], cam_position_t[1], cam_position_t[2]);
+	s3d_rotate(0, cam_position_r[0], cam_position_r[1], cam_position_r[2]);
 
-	if ( sqrt(  (( cam_position_t[0] - _search_widget->x)*( cam_position_t[0] - _search_widget->x)) +
-	                (( cam_position_t[1] - _search_widget->y)*( cam_position_t[1] - _search_widget->y)) +
-	                (( cam_position_t[2] - _search_widget->z)*( cam_position_t[2] - _search_widget->z)) ) < 0.2 ) {
-		s3d_translate( 0, _search_widget->x, _search_widget->y, ( _search_widget->z - 10 ) );
-		s3d_rotate( 0, _search_widget->arx, _search_widget->ary, _search_widget->arz );
+	if (sqrt(((cam_position_t[0] - _search_widget->x)*(cam_position_t[0] - _search_widget->x)) +
+	                ((cam_position_t[1] - _search_widget->y)*(cam_position_t[1] - _search_widget->y)) +
+	                ((cam_position_t[2] - _search_widget->z)*(cam_position_t[2] - _search_widget->z))) < 0.2) {
+		s3d_translate(0, _search_widget->x, _search_widget->y, (_search_widget->z - 10));
+		s3d_rotate(0, _search_widget->arx, _search_widget->ary, _search_widget->arz);
 	}
 }
 
@@ -206,45 +206,45 @@
 {
 	float target, current;
 
-	cam_position_t[0] = ( cam_position_t[0] * 4 + _return_point[0][0] ) / 5;
-	cam_position_t[1] = ( cam_position_t[1] * 4 + _return_point[0][1] ) / 5;
-	cam_position_t[2] = ( cam_position_t[2] * 4 + _return_point[0][2] ) / 5;
+	cam_position_t[0] = (cam_position_t[0] * 4 + _return_point[0][0]) / 5;
+	cam_position_t[1] = (cam_position_t[1] * 4 + _return_point[0][1]) / 5;
+	cam_position_t[2] = (cam_position_t[2] * 4 + _return_point[0][2]) / 5;
 
 	target = _return_point[1][0];
 	current = cam_position_r[0];
 
-	if ( _return_point[1][0] - cam_position_r[0] > 180 )
+	if (_return_point[1][0] - cam_position_r[0] > 180)
 		target -= 360;
-	if ( _return_point[1][0] - cam_position_r[0] < -180 )
+	if (_return_point[1][0] - cam_position_r[0] < -180)
 		current -= 360;
-	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
+	cam_position_r[0] = (cam_position_r[0] * 4 + target) / 5;
 
 	target = _return_point[1][1];
 	current = cam_position_r[1];
 
-	if ( _return_point[1][1] - cam_position_r[1] > 180 )
+	if (_return_point[1][1] - cam_position_r[1] > 180)
 		target -= 360;
-	if ( _return_point[1][1] - cam_position_r[1] < -180 )
+	if (_return_point[1][1] - cam_position_r[1] < -180)
 		current -= 360;
-	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
+	cam_position_r[1] = (cam_position_r[1] * 4 + target) / 5;
 
 	target = _return_point[1][2];
 	current = cam_position_r[2];
 
-	if ( _return_point[1][2] - cam_position_r[2] > 180 )
+	if (_return_point[1][2] - cam_position_r[2] > 180)
 		target -= 360;
-	if ( _return_point[1][2] - cam_position_r[2] < -180 )
+	if (_return_point[1][2] - cam_position_r[2] < -180)
 		current -= 360;
-	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
+	cam_position_r[2] = (cam_position_r[2] * 4 + target) / 5;
 
-	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
-	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
+	s3d_translate(0, cam_position_t[0], cam_position_t[1], cam_position_t[2]);
+	s3d_rotate(0, cam_position_r[0], cam_position_r[1], cam_position_r[2]);
 
-	if ( sqrt(  (( cam_position_t[0] - _return_point[0][0])*( cam_position_t[0] - _return_point[0][0])) +
-	                (( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) +
-	                (( cam_position_t[2] - _return_point[0][2])*( cam_position_t[2] - _return_point[0][2])) ) < 0.2 ) {
-		s3d_translate( 0, _return_point[0][0], _return_point[0][1], _return_point[0][2] );
-		s3d_rotate( 0, _return_point[1][0], _return_point[1][1], _return_point[1][2] );
+	if (sqrt(((cam_position_t[0] - _return_point[0][0])*(cam_position_t[0] - _return_point[0][0])) +
+	                ((cam_position_t[1] - _return_point[0][1])*(cam_position_t[1] - _return_point[0][1])) +
+	                ((cam_position_t[2] - _return_point[0][2])*(cam_position_t[2] - _return_point[0][2]))) < 0.2) {
+		s3d_translate(0, _return_point[0][0], _return_point[0][1], _return_point[0][2]);
+		s3d_rotate(0, _return_point[1][0], _return_point[1][1], _return_point[1][2]);
 		set_search_status(NOTHING);
 	}
 }
@@ -260,19 +260,19 @@
 	static char s[20];
 	int ln = strlen(s);
 
-	if ( key == S3DK_COMMA ) key = S3DK_PERIOD;
+	if (key == S3DK_COMMA) key = S3DK_PERIOD;
 
-	if ( key != S3DK_RETURN ) {
-		if ( key == S3DK_BACKSPACE ) {
-			if ( ln > 0 )
+	if (key != S3DK_RETURN) {
+		if (key == S3DK_BACKSPACE) {
+			if (ln > 0)
 				s[ln-1] = '\0';
 		} else {
-			if ( ln < 20 )
+			if (ln < 20)
 				s[ln] = key;
 		}
-		s3dw_input_change_text( _search_input, s );
+		s3dw_input_change_text(_search_input, s);
 	} else {
-		_new_search_node( _search_widget );
+		_new_search_node(_search_widget);
 	}
 }
 
@@ -280,9 +280,9 @@
 void set_return_point(float cam_position_t[], float cam_position_r[])
 {
 	int i;
-	for ( i = 0; i < 3; i++ )
+	for (i = 0; i < 3; i++)
 		_return_point[0][i] = cam_position_t[i];
-	for ( i = 0; i < 3; i++ )
+	for (i = 0; i < 3; i++)
 		_return_point[1][i] = cam_position_r[i];
 }
 
@@ -312,31 +312,31 @@
 
 	search_node = &_node_root;
 
-	ip = s3dw_input_gettext( _search_input );
+	ip = s3dw_input_gettext(_search_input);
 
-	while ( (*search_node) != NULL ) {
+	while ((*search_node) != NULL) {
 
-		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
+		result = strncmp((*search_node)->ip, ip, NAMEMAX);
 
-		if ( result == 0 )
+		if (result == 0)
 			break;
 
-		if ( result < 0 )
+		if (result < 0)
 			(*search_node) = (*search_node)->right;
 		else
 			(*search_node) = (*search_node)->left;
 	}
 	s3dw_delete(dummy->parent); /* remove the window cointaining the button */
-	_search_surface=NULL;
-	_search_input=NULL;
-	_search_widget=NULL;
+	_search_surface = NULL;
+	_search_input = NULL;
+	_search_widget = NULL;
 
 
-	if ( (*search_node) != NULL ) {
-		set_search_status( FOLLOW );
+	if ((*search_node) != NULL) {
+		set_search_status(FOLLOW);
 	} else {
 		window_error("Sorry, could not find...");
-		set_search_status( NOTHING );
+		set_search_status(NOTHING);
 	}
 }
 /* public */
@@ -344,7 +344,7 @@
 {
 	search_node = &_node_root;
 	(*search_node) = olsr_node;
-	set_search_status( FOLLOW );
+	set_search_status(FOLLOW);
 }
 
 /* private */
@@ -355,23 +355,23 @@
 
 	search_node = &_node_root;
 
-	ip = s3dw_input_gettext( _search_input );
+	ip = s3dw_input_gettext(_search_input);
 
-	while ( (*search_node) != NULL ) {
+	while ((*search_node) != NULL) {
 
-		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
+		result = strncmp((*search_node)->ip, ip, NAMEMAX);
 
-		if ( result == 0 )
+		if (result == 0)
 			break;
 
-		if ( result < 0 )
+		if (result < 0)
 			(*search_node) = (*search_node)->right;
 		else
 			(*search_node) = (*search_node)->left;
 	}
 
-	if ( (*search_node) != NULL )
-		set_search_status( FOLLOW );
+	if ((*search_node) != NULL)
+		set_search_status(FOLLOW);
 }
 
 /* private */

Modified: trunk/apps/olsrs3d/search.h
===================================================================
--- trunk/apps/olsrs3d/search.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/search.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -21,10 +21,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#define NOTHING 0		/* nothing ;) */
-#define ABORT 1			/* widget has no focus */
-#define WIDGET 2		/* focus on widget */
-#define FOLLOW 3		/* follow search result */
+#define NOTHING 0  /* nothing ;) */
+#define ABORT 1   /* widget has no focus */
+#define WIDGET 2  /* focus on widget */
+#define FOLLOW 3  /* follow search result */
 
 void create_search_widget(float x, float y, float z);
 void move_search_widget(float x, float y, float z);
@@ -35,7 +35,7 @@
 void set_search_status(int stat);
 void search_widget_write(int key);
 void set_node_root(struct olsr_node *root);
-void follow_node(float cam_position_t[], float cam_position_r[],float rotate);
+void follow_node(float cam_position_t[], float cam_position_r[], float rotate);
 void follow_node_by_click(struct olsr_node *olsr_node);
 
 void show_search_window();

Modified: trunk/apps/olsrs3d/structs.h
===================================================================
--- trunk/apps/olsrs3d/structs.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/olsrs3d/structs.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,21 +23,21 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#define NAMEMAX		128
-#define MAXLINESIZE 1000		/* lines in a digraph just shouldn't get that longer ... */
-#define MAXDATASIZE 100			/* max number of bytes we can get at once  */
+#define NAMEMAX  128
+#define MAXLINESIZE 1000  /* lines in a digraph just shouldn't get that longer ... */
+#define MAXDATASIZE 100   /* max number of bytes we can get at once  */
 
 /* linked list for the all connections */
 struct olsr_con {
-	struct olsr_con *next_olsr_con;			/* pointer to next connection */
-	struct olsr_con *prev_olsr_con;			/* pointer to previous connection */
-	struct olsr_node *left_olsr_node;		/* pointer to left end point of the connection */
-	struct olsr_node *right_olsr_node;		/* pointer to right end point of the connection */
-	float left_etx;							/* etx of left olsr node */
-	float right_etx;						/* etx of right olsr node */
-	float left_etx_sqrt;					/* sqrt of etx of left olsr node */
-	float right_etx_sqrt;					/* sqrt etx of right olsr node */
-	int obj_id;								/* id of connection object in s3d */
+	struct olsr_con *next_olsr_con;   /* pointer to next connection */
+	struct olsr_con *prev_olsr_con;   /* pointer to previous connection */
+	struct olsr_node *left_olsr_node;  /* pointer to left end point of the connection */
+	struct olsr_node *right_olsr_node;  /* pointer to right end point of the connection */
+	float left_etx;       /* etx of left olsr node */
+	float right_etx;      /* etx of right olsr node */
+	float left_etx_sqrt;     /* sqrt of etx of left olsr node */
+	float right_etx_sqrt;     /* sqrt etx of right olsr node */
+	int obj_id;        /* id of connection object in s3d */
 	int color;
 	float rgb;
 };
@@ -45,8 +45,8 @@
 
 /* linked list for the neighbours of each olsr node */
 struct olsr_neigh_list {
-	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
-	struct olsr_con *olsr_con;							/* pointer to the connection */
+	struct olsr_neigh_list *next_olsr_neigh_list;  /* pointer to next neighbour */
+	struct olsr_con *olsr_con;       /* pointer to the connection */
 };
 
 
@@ -54,17 +54,17 @@
 struct olsr_node {
 	struct olsr_node *left;
 	struct olsr_node *right;
-	char ip[NAMEMAX];				/* host ip */
-	int node_type;					/* normal = 0, internet gateway = 1, via hna announced network = 2 */
-	int node_type_modified;			/* node_type modified flag */
-	int last_seen;					/* last seen counter */
-	int visible;					/* is this node visible or vanished */
-	float pos_vec[3];				/* position vector in 3d "space" */
-	float mov_vec[3];				/* move vector */
-	int obj_id;						/* id of node object in s3d */
-	int desc_id;					/* id of node description object in s3d */
-	float desc_length;				/* length of node description object in s3d */
-	struct olsr_neigh_list *olsr_neigh_list;	/* pointer to first neighbour */
+	char ip[NAMEMAX];    /* host ip */
+	int node_type;     /* normal = 0, internet gateway = 1, via hna announced network = 2 */
+	int node_type_modified;   /* node_type modified flag */
+	int last_seen;     /* last seen counter */
+	int visible;     /* is this node visible or vanished */
+	float pos_vec[3];    /* position vector in 3d "space" */
+	float mov_vec[3];    /* move vector */
+	int obj_id;      /* id of node object in s3d */
+	int desc_id;     /* id of node description object in s3d */
+	float desc_length;    /* length of node description object in s3d */
+	struct olsr_neigh_list *olsr_neigh_list; /* pointer to first neighbour */
 };
 
 

Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,33 +22,33 @@
  */
 
 
-#include <s3d.h>		 /*  s3d_*() */
-#include <stdlib.h> 	 /*  getenv() */
-#include <stdio.h>		 /*  printf() */
-#include <X11/Xlib.h>	 /*  Ximage, Display, X*() */
-#include <X11/Xutil.h>	 /*  XDestroyImage() */
+#include <s3d.h>   /*  s3d_*() */
+#include <stdlib.h>   /*  getenv() */
+#include <stdio.h>   /*  printf() */
+#include <X11/Xlib.h>  /*  Ximage, Display, X*() */
+#include <X11/Xutil.h>  /*  XDestroyImage() */
 #define XK_MISCELLANY
-#include <X11/keysymdef.h>	 /* keysyms */
-#include <X11/extensions/XTest.h>	/* keyboard/mouse input via s3d */
+#include <X11/keysymdef.h>  /* keysyms */
+#include <X11/extensions/XTest.h> /* keyboard/mouse input via s3d */
 #include <X11/extensions/XShm.h> /* */
-#include <time.h>		/* nanosleep() */
-#include <sys/time.h> 	/* gettimeofday */
+#include <time.h>  /* nanosleep() */
+#include <sys/time.h>  /* gettimeofday */
 #include <sys/ipc.h>
 #include <sys/shm.h>
-static struct timespec t= {
-	0,100*1000*1000
+static struct timespec t = {
+	0, 100*1000*1000
 }; /* 100 mili seconds */
 
 int oid;
 XImage *image;
-Display *dpy=0;
-int window,scr;
-unsigned int width,height, height, depth;
+Display *dpy = 0;
+int window, scr;
+unsigned int width, height, height, depth;
 int format;
 char *data;
 Visual *visual;
 XShmSegmentInfo shminfo;
-char *tex_image=NULL,*otex_image=NULL,*img1,*img2;
+char *tex_image = NULL, *otex_image = NULL, *img1, *img2;
 
 
 
@@ -58,116 +58,116 @@
 
 int get_shift(unsigned long t)
 {
-	int i=0;
+	int i = 0;
 	while (t) {
-		t>>=1;
+		t >>= 1;
 		i++;
 	}
 	return(i);
 }
 void mainloop()
 {
-	int x,y;
-	int rs,gs,bs;
+	int x, y;
+	int rs, gs, bs;
 	unsigned long d;
 	int bpp;
 	char *swap_timg;
-	int last_change,start_change;
-	gettimeofday(&end,NULL);
-	count[0]+=(end.tv_sec-start.tv_sec)*10000000 + end.tv_usec-start.tv_usec;
-	start.tv_sec	=end.tv_sec;
-	start.tv_usec 	=end.tv_usec;
+	int last_change, start_change;
+	gettimeofday(&end, NULL);
+	count[0] += (end.tv_sec - start.tv_sec) * 10000000 + end.tv_usec - start.tv_usec;
+	start.tv_sec = end.tv_sec;
+	start.tv_usec  = end.tv_usec;
 
-	/*	image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);*/
-	XShmGetImage(dpy, window, image, 0,0,0xffffffff);
-	gettimeofday(&end,NULL);
-	count[1]+=(end.tv_sec-start.tv_sec)*10000000 + end.tv_usec-start.tv_usec;
-	start.tv_sec	=end.tv_sec;
-	start.tv_usec 	=end.tv_usec;
-	if (image->format==ZPixmap) {
-		printf("Ximage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n",image->width,image->height,image->format,ZPixmap,
-		       image->bits_per_pixel,image->depth,image->bitmap_pad);
-		rs=get_shift(image->red_mask)-8;
-		gs=get_shift(image->green_mask)-8;
-		bs=get_shift(image->blue_mask)-8;
+	/* image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);*/
+	XShmGetImage(dpy, window, image, 0, 0, 0xffffffff);
+	gettimeofday(&end, NULL);
+	count[1] += (end.tv_sec - start.tv_sec) * 10000000 + end.tv_usec - start.tv_usec;
+	start.tv_sec = end.tv_sec;
+	start.tv_usec  = end.tv_usec;
+	if (image->format == ZPixmap) {
+		printf("Ximage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n", image->width, image->height, image->format, ZPixmap,
+		       image->bits_per_pixel, image->depth, image->bitmap_pad);
+		rs = get_shift(image->red_mask) - 8;
+		gs = get_shift(image->green_mask) - 8;
+		bs = get_shift(image->blue_mask) - 8;
 
-		bpp=(image->bits_per_pixel/8);
+		bpp = (image->bits_per_pixel / 8);
 		/* rgb is not bgr */
-		rs=rs;
-		gs=gs-8;
-		bs=bs-16;
-		printf("Ximage: rgb: %d|%d|%d\n",	rs,gs,bs);;
-		/*		printf("red: size %d, offset %d\n",rs,roff);
-				printf("green: size %d, offset %d\n",gs,goff);
-				printf("blue: size %d, offset %d\n",bs,boff);
-				printf("bits per pixel:%d\n",bpp);*/
-		last_change=-1;
-		start_change=-1;
-		for (y=0;y<height;y++) {
+		rs = rs;
+		gs = gs - 8;
+		bs = bs - 16;
+		printf("Ximage: rgb: %d|%d|%d\n", rs, gs, bs);;
+		/*  printf("red: size %d, offset %d\n",rs,roff);
+		  printf("green: size %d, offset %d\n",gs,goff);
+		  printf("blue: size %d, offset %d\n",bs,boff);
+		  printf("bits per pixel:%d\n",bpp);*/
+		last_change = -1;
+		start_change = -1;
+		for (y = 0;y < height;y++) {
 
-			for (x=0;x<width;x++) {
-				d=*((unsigned long *)(image->data+(y*width+x)*bpp));
-				((unsigned long *)tex_image)[(y*width+x)]=
-				        (rs>0?((d&image->red_mask)>>rs):	((d&image->red_mask)<<-rs))|
-				        (gs>0?((d&image->green_mask)>>gs):	((d&image->green_mask)<<-gs))|
-				        (bs>0?((d&image->blue_mask)>>bs):	((d&image->blue_mask)<<-bs))|
-				        255<<24;
-				if (((unsigned long *)tex_image)[(y*width+x)]!=
+			for (x = 0;x < width;x++) {
+				d = *((unsigned long *)(image->data + (y * width + x) * bpp));
+				((unsigned long *)tex_image)[(y*width+x)] =
+				        (rs > 0 ? ((d & image->red_mask) >> rs) : ((d & image->red_mask) << -rs)) |
+				        (gs > 0 ? ((d & image->green_mask) >> gs) : ((d & image->green_mask) << -gs)) |
+				        (bs > 0 ? ((d & image->blue_mask) >> bs) : ((d & image->blue_mask) << -bs)) |
+				        255 << 24;
+				if (((unsigned long *)tex_image)[(y*width+x)] !=
 				                ((unsigned long *)otex_image)[(y*width+x)])
-					last_change=y;
+					last_change = y;
 			}
-			if (last_change!=-1) {
-				if (start_change==-1) {
-					start_change=y;
-					/* 					printf("setting start_change to %d\n",start_change); */
+			if (last_change != -1) {
+				if (start_change == -1) {
+					start_change = y;
+					/*      printf("setting start_change to %d\n",start_change); */
 				}
-				if (last_change!=y) {	 /*  last change is already over, post it! */
-					s3d_load_texture(oid,0,0,start_change,width,last_change-start_change+1,(unsigned char *)tex_image+start_change*width*4);
-					start_change=-1;
-					last_change=-1;
+				if (last_change != y) {  /*  last change is already over, post it! */
+					s3d_load_texture(oid, 0, 0, start_change, width, last_change - start_change + 1, (unsigned char *)tex_image + start_change*width*4);
+					start_change = -1;
+					last_change = -1;
 				}
 			}
 		}
 		/*  posting the last bit, maybe */
-		if (last_change!=-1) {
-			/*			printf("last one: [%d-%d]",start_change,last_change);*/
-			s3d_load_texture(oid,0,0,start_change,width,last_change-start_change,(unsigned char *)tex_image+start_change*width*4);
+		if (last_change != -1) {
+			/*   printf("last one: [%d-%d]",start_change,last_change);*/
+			s3d_load_texture(oid, 0, 0, start_change, width, last_change - start_change, (unsigned char *)tex_image + start_change*width*4);
 		}
-		/* 		s3d_load_texture(oid,0,0,0,width,height,tex_image); */
+		/*   s3d_load_texture(oid,0,0,0,width,height,tex_image); */
 		/*  swap images */
-		swap_timg=tex_image;
-		tex_image=otex_image;
-		otex_image=swap_timg;
+		swap_timg = tex_image;
+		tex_image = otex_image;
+		otex_image = swap_timg;
 	}
-	gettimeofday(&end,NULL);
-	count[2]+=(end.tv_sec-start.tv_sec)*10000000 + end.tv_usec-start.tv_usec;
-	start.tv_sec	=end.tv_sec;
-	start.tv_usec 	=end.tv_usec;
+	gettimeofday(&end, NULL);
+	count[2] += (end.tv_sec - start.tv_sec) * 10000000 + end.tv_usec - start.tv_usec;
+	start.tv_sec = end.tv_sec;
+	start.tv_usec  = end.tv_usec;
 	iterations++;
-	/*	XDestroyImage(image);*/
-	/*	nanosleep(&t,NULL); */
+	/* XDestroyImage(image);*/
+	/* nanosleep(&t,NULL); */
 }
 int keypress(struct s3d_evt *event)
 {
 	int key;
 	int kc;
-	key=*((unsigned short *)event->buf);
-	printf("received key %d ",key);
+	key = *((unsigned short *)event->buf);
+	printf("received key %d ", key);
 	kc = XKeysymToKeycode(dpy, key);
-	if (kc==0) {
-		kc = XKeysymToKeycode(dpy, 0xFF00+ key);
-		printf(" (%04x) ",0xFF00+key);
+	if (kc == 0) {
+		kc = XKeysymToKeycode(dpy, 0xFF00 + key);
+		printf(" (%04x) ", 0xFF00 + key);
 	}
-	if (kc==0) {
-		if (key==8) {
-			kc=22;
+	if (kc == 0) {
+		if (key == 8) {
+			kc = 22;
 			printf("!backspace!");
 		}
 	}
-	printf("using key: %d, keycode %d (%04x)\n",key,kc,kc);
-	if (kc!=0)
+	printf("using key: %d, keycode %d (%04x)\n", key, kc, kc);
+	if (kc != 0)
 		XTestFakeKeyEvent(dpy, kc, 1, 1);
-	/*	    XTestFakeKeyEvent(dpy, kc, 0, 1);*/
+	/*     XTestFakeKeyEvent(dpy, kc, 0, 1);*/
 	return(0);
 
 }
@@ -175,80 +175,80 @@
 {
 	int i;
 	printf("thats it, collecting:\n");
-	for (i=0;i<3;i++)
-		printf("[%d] %f\n",i,count[i]/iterations);
+	for (i = 0;i < 3;i++)
+		printf("[%d] %f\n", i, count[i] / iterations);
 	exit(0);
 	return(0);
 }
 int main(int argc, char **argv)
 {
-	char *disp=NULL;
-	int a,b,c,d;
+	char *disp = NULL;
+	int a, b, c, d;
 	int xt;
-	if (disp==NULL) disp=getenv("DISPLAY");
-	if (disp==NULL) disp="";  /*  fallback */
+	if (disp == NULL) disp = getenv("DISPLAY");
+	if (disp == NULL) disp = "";  /*  fallback */
 	dpy = XOpenDisplay(disp);
 	if (!dpy) {
 		printf("couldn't open display\n");
 		return(-1);
 	}
-	count[0]=count[1]=count[2]=0;
-	iterations=0;
-	if (!s3d_init(&argc,&argv,"X11-gate")) {
+	count[0] = count[1] = count[2] = 0;
+	iterations = 0;
+	if (!s3d_init(&argc, &argv, "X11-gate")) {
 		scr = DefaultScreen(dpy);
 		window = RootWindow(dpy, scr);
 		width = DisplayWidth(dpy, scr);
 		height = DisplayHeight(dpy, scr);
-		visual= DefaultVisual(dpy, scr);
+		visual = DefaultVisual(dpy, scr);
 		depth = DefaultDepth(dpy, scr);
 		XLockDisplay(dpy);
-		xt=XTestQueryExtension(dpy,&a,&b,&c,&d);
+		xt = XTestQueryExtension(dpy, &a, &b, &c, &d);
 		XUnlockDisplay(dpy);
 		if (xt) {
 			printf("having xtest extension ...\n");
 		}
 		/* X11 shm - http://www.xfree86.org/current/mit-shm.html */
 
-		image= XShmCreateImage(dpy, visual, depth, ZPixmap, NULL, &shminfo, width, height);
-		shminfo.shmid = shmget(IPC_PRIVATE, image->bytes_per_line * image->height, IPC_CREAT|0777);
-		shminfo.shmaddr = image->data = shmat (shminfo.shmid, 0, 0);
+		image = XShmCreateImage(dpy, visual, depth, ZPixmap, NULL, &shminfo, width, height);
+		shminfo.shmid = shmget(IPC_PRIVATE, image->bytes_per_line * image->height, IPC_CREAT | 0777);
+		shminfo.shmaddr = image->data = shmat(shminfo.shmid, 0, 0);
 		shmctl(shminfo.shmid, IPC_RMID, 0);
-		shminfo.readOnly= False;
+		shminfo.readOnly = False;
 		if (!XShmAttach(dpy, &shminfo))
 			printf("cannot use the shared memory segment .. :( \n");
 		else
 			printf("can use share segment :D\n");
 		XSync(dpy, False);
 
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,mouseclick);
-		s3d_set_callback(S3D_EVENT_KEY,keypress);
-		printf("screen: %dx%d\n",width,height);
-		img1=malloc(width*height*4);
-		img2=malloc(width*height*4);
-		tex_image=img1;
-		otex_image=img2;
-		oid=s3d_new_object();
-		s3d_push_vertex(oid,-5,-5,0);
-		s3d_push_vertex(oid, 5,-5,0);
-		s3d_push_vertex(oid, 5, 5,0);
-		s3d_push_vertex(oid,-5, 5,0);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, mouseclick);
+		s3d_set_callback(S3D_EVENT_KEY, keypress);
+		printf("screen: %dx%d\n", width, height);
+		img1 = malloc(width * height * 4);
+		img2 = malloc(width * height * 4);
+		tex_image = img1;
+		otex_image = img2;
+		oid = s3d_new_object();
+		s3d_push_vertex(oid, -5, -5, 0);
+		s3d_push_vertex(oid, 5, -5, 0);
+		s3d_push_vertex(oid, 5, 5, 0);
+		s3d_push_vertex(oid, -5, 5, 0);
 		s3d_push_material_a(oid,
-		                    0.8,	0.0,	0.0	,1.0,
-		                    1.0,	1.0,	1.0	,1.0,
-		                    0.8,	0.0,	0.0	,1.0);
-		s3d_push_polygon(oid,0,2,1,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,1.0,
-		                          1.0,0.0,
-		                          1.0,1.0);
-		s3d_push_polygon(oid,0,3,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,1.0,
-		                          0.0,0.0,
-		                          1.0,0.0);
-		s3d_push_texture(oid,width,height);
+		                    0.8, 0.0, 0.0 , 1.0,
+		                    1.0, 1.0, 1.0 , 1.0,
+		                    0.8, 0.0, 0.0 , 1.0);
+		s3d_push_polygon(oid, 0, 2, 1, 0);
+		s3d_pep_polygon_tex_coord(oid, 0.0, 1.0,
+		                          1.0, 0.0,
+		                          1.0, 1.0);
+		s3d_push_polygon(oid, 0, 3, 2, 0);
+		s3d_pep_polygon_tex_coord(oid, 0.0, 1.0,
+		                          0.0, 0.0,
+		                          1.0, 0.0);
+		s3d_push_texture(oid, width, height);
 		/*  push data on texture 0 position (0,0) */
-		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
-		s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		gettimeofday(&start,NULL);
+		s3d_pep_material_texture(oid, 0); /*  assign texture 0 to material 0 */
+		s3d_flags_on(oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		gettimeofday(&start, NULL);
 		s3d_mainloop(mainloop);
 		free(img1);
 		free(img2);

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/animation.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,44 +22,44 @@
  */
 
 #include "s3dfm.h"
-#include <stdio.h> 	 /*  printf(),NULL */
-#include <math.h>	 /*  fabs() */
-#define SCALE 	1
+#include <stdio.h>   /*  printf(),NULL */
+#include <math.h>  /*  fabs() */
+#define SCALE  1
 
 /* the animation stack */
 static t_node *ani_s[MAXANI];
-static int ani_n=0;
+static int ani_n = 0;
 
 /* is node f already on stack? */
 int ani_onstack(t_node *f)
 {
 	int i;
-	for (i=0;i<ani_n;i++)
-		if (ani_s[i]==f)
-			return(i);		/* already in list */
+	for (i = 0;i < ani_n;i++)
+		if (ani_s[i] == f)
+			return(i);  /* already in list */
 	return(-1);
 
 }
 /* add an node on the animation stack */
 void ani_add(t_node *f)
 {
-	if (ani_n<MAXANI) {
-		if (-1!=ani_onstack(f))
-			return;		/* already in list */
-		ani_s[ani_n]=f;
+	if (ani_n < MAXANI) {
+		if (-1 != ani_onstack(f))
+			return;  /* already in list */
+		ani_s[ani_n] = f;
 		ani_iterate(f);
-		/*	printf("[A]ni ADD %d\n",ani_n); */
+		/* printf("[A]ni ADD %d\n",ani_n); */
 		ani_n++;
 	} else /* no place, finish now */
-		ani_finish(f,-1);
+		ani_finish(f, -1);
 }
 /* delete an node from the animation stack */
 void ani_del(int i)
 {
-	if ((i>=0) && (i<ani_n)) {
-		/*		printf("[A]ni DEL %d\n",i);*/
+	if ((i >= 0) && (i < ani_n)) {
+		/*  printf("[A]ni DEL %d\n",i);*/
 		ani_n--;
-		ani_s[i]=ani_s[ani_n]; /* that should also work if i is the last one */
+		ani_s[i] = ani_s[ani_n]; /* that should also work if i is the last one */
 	} else {
 		printf("[F]ATAL: can't delete animation!\n");
 	}
@@ -67,38 +67,38 @@
 /* well ... */
 void ani_doit(t_node *f)
 {
-	s3d_translate(	f->oid, f->dpx,f->dpy,f->dpz);
-	s3d_scale(		f->oid, f->dscale);
+	s3d_translate(f->oid, f->dpx, f->dpy, f->dpz);
+	s3d_scale(f->oid, f->dscale);
 }
 
 /* finish an animation on the stack, stack index i */
 void ani_finish(t_node *f, int i)
 {
-	f->dpx= f->px;
-	f->dpy= f->py;
-	f->dpz= f->pz;
-	f->dscale= f->scale;
+	f->dpx = f->px;
+	f->dpy = f->py;
+	f->dpz = f->pz;
+	f->dscale = f->scale;
 	ani_doit(f);
-	if (i!=-1)
+	if (i != -1)
 		ani_del(i);
 }
 void ani_iterate(t_node *f)
 {
-	f->dpx=(f->px + f->dpx*ZOOMS)/(ZOOMS+1);
-	f->dpy=(f->py + f->dpy*ZOOMS)/(ZOOMS+1);
-	f->dpz=(f->pz + f->dpz*ZOOMS)/(ZOOMS+1);
-	f->dscale=(f->scale + f->dscale*ZOOMS)/(ZOOMS+1);
+	f->dpx = (f->px + f->dpx * ZOOMS) / (ZOOMS + 1);
+	f->dpy = (f->py + f->dpy * ZOOMS) / (ZOOMS + 1);
+	f->dpz = (f->pz + f->dpz * ZOOMS) / (ZOOMS + 1);
+	f->dscale = (f->scale + f->dscale * ZOOMS) / (ZOOMS + 1);
 
 }
 
 /* checks if f is good enough */
 int ani_check(t_node *f)
 {
-	float x,y,z;
-	x=f->dpx - f->px;
-	y=f->dpy - f->py;
-	z=f->dpz - f->pz;
-	if (((fabs(f->dscale - f->scale)/f->scale)>0.01) || (sqrt(x*x+y*y+z*z) > 0.01))
+	float x, y, z;
+	x = f->dpx - f->px;
+	y = f->dpy - f->py;
+	z = f->dpz - f->pz;
+	if (((fabs(f->dscale - f->scale) / f->scale) > 0.01) || (sqrt(x*x + y*y + z*z) > 0.01))
 		return(0);
 	return(1);
 }
@@ -108,15 +108,15 @@
 	int i;
 	t_node *f;
 	s3dw_ani_mate();
-	for (i=0;i<ani_n;i++) {
-		f=ani_s[i];
-		if (f->oid==-1) { /* kick out bad animations */
+	for (i = 0;i < ani_n;i++) {
+		f = ani_s[i];
+		if (f->oid == -1) { /* kick out bad animations */
 			ani_del(i);
 			i--;
 		} else {
 			ani_iterate(f);
 			if (ani_check(f)) {
-				ani_finish(f,i);
+				ani_finish(f, i);
 				i--; /* a new object is here now, take care in the next iteration */
 			} else {
 				ani_doit(f);

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/box.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,8 +22,8 @@
  */
 
 #include "s3dfm.h"
-#include <stdio.h> 	 /*  printf() */
-#include <math.h>	 /*  sin(),cos() */
+#include <stdio.h>   /*  printf() */
+#include <math.h>  /*  sin(),cos() */
 #include <string.h>  /*  strlen() */
 
 void box_draw(t_node *dir)
@@ -31,12 +31,12 @@
 	box_buildblock(dir);
 	box_sidelabel(dir);
 	ani_doit(dir);
-	s3d_flags_on(dir->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(dir->objs.close,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(dir->objs.title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(dir->objs.select,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(dir->objs.titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	dir->disp=D_DIR;
+	s3d_flags_on(dir->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(dir->objs.close, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(dir->objs.title, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(dir->objs.select, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(dir->objs.titlestr, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	dir->disp = D_DIR;
 	box_draw_icons(dir);
 }
 
@@ -44,9 +44,9 @@
 void box_draw_icons(t_node *dir)
 {
 	int i;
-	printf("box_draw_icons(%s, %d subs)\n",dir->name, dir->n_sub);
-	for (i=0;i<dir->n_sub;i++) {
-		if (dir->sub[i]->disp==D_NONE)	icon_draw(dir->sub[i]);
+	printf("box_draw_icons(%s, %d subs)\n", dir->name, dir->n_sub);
+	for (i = 0;i < dir->n_sub;i++) {
+		if (dir->sub[i]->disp == D_NONE) icon_draw(dir->sub[i]);
 	}
 	box_order_icons(dir);
 }
@@ -56,178 +56,178 @@
 void box_sidelabel(t_node *dir)
 {
 	float len;
-	if (dir->objs.str==-1) {
-		dir->objs.str=s3d_draw_string(dir->name,&len);
-		if (len<2) len=2;
-		dir->objs.strlen=len;
+	if (dir->objs.str == -1) {
+		dir->objs.str = s3d_draw_string(dir->name, &len);
+		if (len < 2) len = 2;
+		dir->objs.strlen = len;
 	}
-	s3d_rotate(dir->objs.str,0,90,0);
-	s3d_translate(dir->objs.str,1.1,0.3,1);
-	s3d_scale(dir->objs.str,(float)1.8/(dir->objs.strlen));
-	s3d_scale(dir->objs.str,(float)1.8/(dir->objs.strlen));
-	s3d_link(dir->objs.str,dir->oid);
-	s3d_flags_on(dir->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_rotate(dir->objs.str, 0, 90, 0);
+	s3d_translate(dir->objs.str, 1.1, 0.3, 1);
+	s3d_scale(dir->objs.str, (float)1.8 / (dir->objs.strlen));
+	s3d_scale(dir->objs.str, (float)1.8 / (dir->objs.strlen));
+	s3d_link(dir->objs.str, dir->oid);
+	s3d_flags_on(dir->objs.str, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* gives another color for the focused box */
 void box_focus_color(t_node *dir, int on)
 {
 
 	s3d_pep_material(dir->oid,
-	                 0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
-	                 0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
-	                 0.5+on*0.3,0.5+on*0.3,0.5+on*0.3);
+	                 0.5 + on*0.3, 0.5 + on*0.3, 0.5 + on*0.3,
+	                 0.5 + on*0.3, 0.5 + on*0.3, 0.5 + on*0.3,
+	                 0.5 + on*0.3, 0.5 + on*0.3, 0.5 + on*0.3);
 
 }
 /* creates a big block which will hold files and subdirs on top */
 int box_buildblock(t_node *dir)
 {
 	char fname[30];
-	char *fullname=fname;
+	char *fullname = fname;
 	float len;
-	float vertices[]= {-BHP,0,-BHP,
-	                   -BHP,0, BHP,
-	                   BHP,0, BHP,
-	                   BHP,0,-BHP,
-	                   -BHP,BHH,-BHP,
-	                   -BHP,BHH, BHP,
-	                   BHP,BHH, BHP,
-	                   BHP,BHH,-BHP,
-	                   -1,0, 0.8,
-	                   -1,BOXHEIGHT, 0.8,
-	                   1,BOXHEIGHT, 0.8,
-	                   1,0, 0.8
-	                  };
-	float xvertices[]= {
-		0.8,BHH-0.2, 0.8,
-		0.8,BHH    , 0.8,
-		BHP,BHH    , 0.8,
-		BHP,BHH-0.2, 0.8,
-		0.8,BHH-0.2, 1.0,
-		0.8,BHH    , 1.0,
-		BHP,BHH    , 1.0,
-		BHP,BHH-0.2, 1.0
+	float vertices[] = { -BHP, 0, -BHP,
+	                     -BHP, 0, BHP,
+	                     BHP, 0, BHP,
+	                     BHP, 0, -BHP,
+	                     -BHP, BHH, -BHP,
+	                     -BHP, BHH, BHP,
+	                     BHP, BHH, BHP,
+	                     BHP, BHH, -BHP,
+	                     -1, 0, 0.8,
+	                     -1, BOXHEIGHT, 0.8,
+	                     1, BOXHEIGHT, 0.8,
+	                     1, 0, 0.8
+	                   };
+	float xvertices[] = {
+		0.8, BHH - 0.2, 0.8,
+		0.8, BHH    , 0.8,
+		BHP, BHH    , 0.8,
+		BHP, BHH - 0.2, 0.8,
+		0.8, BHH - 0.2, 1.0,
+		0.8, BHH    , 1.0,
+		BHP, BHH    , 1.0,
+		BHP, BHH - 0.2, 1.0
 	};
-	float svertices[]= {
-		0.6,BHH-0.2, 0.8,
-		0.6,BHH    , 0.8,
-		0.8,BHH    , 0.8,
-		0.8,BHH-0.2, 0.8,
-		0.6,BHH-0.2, 1.0,
-		0.6,BHH    , 1.0,
-		0.8,BHH    , 1.0,
-		0.8,BHH-0.2, 1.0
+	float svertices[] = {
+		0.6, BHH - 0.2, 0.8,
+		0.6, BHH    , 0.8,
+		0.8, BHH    , 0.8,
+		0.8, BHH - 0.2, 0.8,
+		0.6, BHH - 0.2, 1.0,
+		0.6, BHH    , 1.0,
+		0.8, BHH    , 1.0,
+		0.8, BHH - 0.2, 1.0
 	};
-	float tvertices[]= {
-		-BHP,BHH-0.2, 0.8,
-		-BHP,BHH    , 0.8,
+	float tvertices[] = {
+		-BHP, BHH - 0.2, 0.8,
+		-BHP, BHH    , 0.8,
 		0.6, BHH    , 0.8,
-		0.6, BHH-0.2, 0.8,
-		-BHP,BHH-0.2, 1.0,
-		-BHP,BHH    , 1.0,
+		0.6, BHH - 0.2, 0.8,
+		-BHP, BHH - 0.2, 1.0,
+		-BHP, BHH    , 1.0,
 		0.6, BHH    , 1.0,
-		0.6, BHH-0.2, 1.0
+		0.6, BHH - 0.2, 1.0
 	};
-	uint32_t bar_poly[]={
-		4,5,6,0,
-		4,6,7,0,
-		3,7,4,0,
-		3,4,0,0
+	uint32_t bar_poly[] = {
+		4, 5, 6, 0,
+		4, 6, 7, 0,
+		3, 7, 4, 0,
+		3, 4, 0, 0
 	};
-	/*	printf("new block for %s\n",dir->name);*/
+	/* printf("new block for %s\n",dir->name);*/
 
-	dir->oid=s3d_new_object();
+	dir->oid = s3d_new_object();
 
 	/* draw block outside */
-	s3d_push_vertices(dir->oid,vertices,sizeof(vertices)/(3*sizeof(float)));
+	s3d_push_vertices(dir->oid, vertices, sizeof(vertices) / (3*sizeof(float)));
 	s3d_push_material(dir->oid,
-	                  0.5,0.5,0.5,
-	                  0.5,0.5,0.5,
-	                  0.5,0.5,0.5
+	                  0.5, 0.5, 0.5,
+	                  0.5, 0.5, 0.5,
+	                  0.5, 0.5, 0.5
 	                 );
 
 	/* top */
-	s3d_push_polygon(dir->oid,4,6,5,0);
-	s3d_push_polygon(dir->oid,4,7,6,0);
+	s3d_push_polygon(dir->oid, 4, 6, 5, 0);
+	s3d_push_polygon(dir->oid, 4, 7, 6, 0);
 	/* bottom */
-	s3d_push_polygon(dir->oid,8,11,3,0);
-	s3d_push_polygon(dir->oid,8,3,0,0);
+	s3d_push_polygon(dir->oid, 8, 11, 3, 0);
+	s3d_push_polygon(dir->oid, 8, 3, 0, 0);
 
 
 	/* left */
-	s3d_push_polygon(dir->oid,0,4,5,0);
-	s3d_push_polygon(dir->oid,0,5,1,0);
+	s3d_push_polygon(dir->oid, 0, 4, 5, 0);
+	s3d_push_polygon(dir->oid, 0, 5, 1, 0);
 
 	/* back */
-	s3d_push_polygon(dir->oid,3,7,4,0);
-	s3d_push_polygon(dir->oid,3,4,0,0);
+	s3d_push_polygon(dir->oid, 3, 7, 4, 0);
+	s3d_push_polygon(dir->oid, 3, 4, 0, 0);
 
 	/* right */
-	s3d_push_polygon(dir->oid,2,6,7,0);
-	s3d_push_polygon(dir->oid,2,7,3,0);
+	s3d_push_polygon(dir->oid, 2, 6, 7, 0);
+	s3d_push_polygon(dir->oid, 2, 7, 3, 0);
 
 	/* front */
-	s3d_push_polygon(dir->oid,8,9,10,0);
-	s3d_push_polygon(dir->oid,8,10,11,0);
+	s3d_push_polygon(dir->oid, 8, 9, 10, 0);
+	s3d_push_polygon(dir->oid, 8, 10, 11, 0);
 	/* left inner side */
-	s3d_push_polygon(dir->oid,1,5,9,0);
-	s3d_push_polygon(dir->oid,1,9,8,0);
+	s3d_push_polygon(dir->oid, 1, 5, 9, 0);
+	s3d_push_polygon(dir->oid, 1, 9, 8, 0);
 
 	/* right inner side */
-	s3d_push_polygon(dir->oid,2,11,10,0);
-	s3d_push_polygon(dir->oid,2,10,6,0);
+	s3d_push_polygon(dir->oid, 2, 11, 10, 0);
+	s3d_push_polygon(dir->oid, 2, 10, 6, 0);
 
 	/* top inner side */
-	s3d_push_polygon(dir->oid,9,5,6,0);
-	s3d_push_polygon(dir->oid,9,6,10,0);
+	s3d_push_polygon(dir->oid, 9, 5, 6, 0);
+	s3d_push_polygon(dir->oid, 9, 6, 10, 0);
 
 
 
 
 	/* draw the select, close buttons ... */
-	dir->objs.close=s3d_new_object();
+	dir->objs.close = s3d_new_object();
 	s3d_push_material(dir->objs.close,
-	                  0.5,0.3,0.3,
-	                  0.5,0.3,0.3,
-	                  0.5,0.3,0.3
+	                  0.5, 0.3, 0.3,
+	                  0.5, 0.3, 0.3,
+	                  0.5, 0.3, 0.3
 	                 );
-	s3d_push_vertices(dir->objs.close,xvertices,sizeof(xvertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir->objs.close,bar_poly,sizeof(bar_poly)/(sizeof(uint32_t)*4));
-	s3d_link(dir->objs.close,dir->oid);
+	s3d_push_vertices(dir->objs.close, xvertices, sizeof(xvertices) / (3*sizeof(float)));
+	s3d_push_polygons(dir->objs.close, bar_poly, sizeof(bar_poly) / (sizeof(uint32_t)*4));
+	s3d_link(dir->objs.close, dir->oid);
 
-	dir->objs.select=s3d_new_object();
+	dir->objs.select = s3d_new_object();
 	s3d_push_material(dir->objs.select,
-	                  0.1,0.1,0.3,
-	                  0.1,0.1,0.3,
-	                  0.1,0.1,0.3
+	                  0.1, 0.1, 0.3,
+	                  0.1, 0.1, 0.3,
+	                  0.1, 0.1, 0.3
 	                 );
-	s3d_push_vertices(dir->objs.select,svertices,sizeof(svertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir->objs.select,bar_poly,sizeof(bar_poly)/(sizeof(uint32_t)*4));
-	s3d_link(dir->objs.select,dir->oid);
+	s3d_push_vertices(dir->objs.select, svertices, sizeof(svertices) / (3*sizeof(float)));
+	s3d_push_polygons(dir->objs.select, bar_poly, sizeof(bar_poly) / (sizeof(uint32_t)*4));
+	s3d_link(dir->objs.select, dir->oid);
 
 	/* draw the title string */
 
-	dir->objs.title=s3d_new_object();
+	dir->objs.title = s3d_new_object();
 	s3d_push_material(dir->objs.title,
-	                  0.3,0.3,0.3,
-	                  0.3,0.3,0.3,
-	                  0.3,0.3,0.3
+	                  0.3, 0.3, 0.3,
+	                  0.3, 0.3, 0.3,
+	                  0.3, 0.3, 0.3
 	                 );
-	s3d_push_vertices(dir->objs.title,tvertices,sizeof(tvertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir->objs.title,bar_poly,sizeof(bar_poly)/(sizeof(uint32_t)*4));
-	s3d_link(dir->objs.title,dir->oid);
-	dir->objs.titlestr=s3d_draw_string(dots_at_start(fullname,30,dir),&len);
-	if (len>(1.6*5.0))		s3d_scale(dir->objs.titlestr,1.6/len);
-	else					s3d_scale(dir->objs.titlestr,0.2);
-	s3d_translate(dir->objs.titlestr,-1.0,1.05,1.01);
-	s3d_link(dir->objs.titlestr,dir->oid);
-	dir->disp=D_DIR;
-	/*	printf("FULLNAME is [%s]\n",fullname);*/
+	s3d_push_vertices(dir->objs.title, tvertices, sizeof(tvertices) / (3*sizeof(float)));
+	s3d_push_polygons(dir->objs.title, bar_poly, sizeof(bar_poly) / (sizeof(uint32_t)*4));
+	s3d_link(dir->objs.title, dir->oid);
+	dir->objs.titlestr = s3d_draw_string(dots_at_start(fullname, 30, dir), &len);
+	if (len > (1.6*5.0))  s3d_scale(dir->objs.titlestr, 1.6 / len);
+	else     s3d_scale(dir->objs.titlestr, 0.2);
+	s3d_translate(dir->objs.titlestr, -1.0, 1.05, 1.01);
+	s3d_link(dir->objs.titlestr, dir->oid);
+	dir->disp = D_DIR;
+	/* printf("FULLNAME is [%s]\n",fullname);*/
 	return(0);
 }
 /* display a directoy on the top of another */
 int box_expand(t_node *dir)
 {
-	printf("box_expand( %s )\n",dir->name);
+	printf("box_expand( %s )\n", dir->name);
 	switch (dir->disp) {
 	case D_DIR:
 		return(0); /* already done */
@@ -239,16 +239,16 @@
 	default:
 		return(-1); /* panic */
 	}
-	dir->dpx=0.0;
-	dir->dpy=BOXHEIGHT;
-	dir->dpz=0.0;
-	dir->dscale=0.01;
+	dir->dpx = 0.0;
+	dir->dpy = BOXHEIGHT;
+	dir->dpz = 0.0;
+	dir->dscale = 0.01;
 	box_draw(dir);
 
 	/* initialize position on the parent */
-	if (dir->parent!=NULL) {
+	if (dir->parent != NULL) {
 		dir->parent->dirs_opened++;
-		s3d_link(dir->oid,dir->parent->oid);
+		s3d_link(dir->oid, dir->parent->oid);
 		box_order_subdirs(dir->parent);
 	}
 	return(0);
@@ -256,38 +256,38 @@
 /* remove s3d-objects of a directory node */
 int box_undisplay(t_node *dir)
 {
-	printf("box_undisplay( %s )\n",dir->name);
-	if (dir->objs.close!=-1)		{
+	printf("box_undisplay( %s )\n", dir->name);
+	if (dir->objs.close != -1)  {
 		s3d_del_object(dir->objs.close);
-		dir->objs.close=-1;
+		dir->objs.close = -1;
 	}
-	if (dir->objs.select!=-1)		{
+	if (dir->objs.select != -1)  {
 		s3d_del_object(dir->objs.select);
-		dir->objs.select=-1;
+		dir->objs.select = -1;
 	}
-	if (dir->objs.title!=-1)		{
+	if (dir->objs.title != -1)  {
 		s3d_del_object(dir->objs.title);
-		dir->objs.title=-1;
+		dir->objs.title = -1;
 	}
-	if (dir->objs.titlestr!=-1)		{
+	if (dir->objs.titlestr != -1)  {
 		s3d_del_object(dir->objs.titlestr);
-		dir->objs.titlestr=-1;
+		dir->objs.titlestr = -1;
 	}
-	if (dir->oid!=-1)				{
+	if (dir->oid != -1)    {
 		s3d_del_object(dir->oid);
 	}
 	/* keep this. icons also needs the *same* string */
-	/*	if (dir->objs.str!=-1)			{ 	s3d_del_object(dir->objs.str); dir->objs.str=-1;	}*/
-	dir->disp=D_NONE;
+	/* if (dir->objs.str!=-1)   {  s3d_del_object(dir->objs.str); dir->objs.str=-1; }*/
+	dir->disp = D_NONE;
 	return(0);
 }
 /* the opposite effect of box_expand, e.g. transforming the box back to an icon */
 int box_unexpand(t_node *dir)
 {
-	printf("box_unexpand( %s )\n",dir->name);
-	if (dir->parent==NULL) /* we can't do this on root.... */
+	printf("box_unexpand( %s )\n", dir->name);
+	if (dir->parent == NULL) /* we can't do this on root.... */
 		return(-1);
-	dir->detached=0;
+	dir->detached = 0;
 	box_undisplay(dir);
 	icon_draw(dir);
 	dir->parent->dirs_opened--;
@@ -298,36 +298,36 @@
 
 /* undisplay a directory, thus recursively removing the kids.*/
 /* if force is 1, even the directory is removed even if it still have selected kids */
-int box_close(t_node *dir,int force)
+int box_close(t_node *dir, int force)
 {
 	int i;
 	int ret;
-	printf("box_close( %s )\n",dir->name);
-	if (&root==dir) {
+	printf("box_close( %s )\n", dir->name);
+	if (&root == dir) {
 		printf("won't close down root box ... \n");
 		return(-1);
 	}
-	if (dir->detached && !force)	return(1);
-	if (dir->disp!=D_DIR) { /* that should not be happening ... */
-		printf("[A]lready undisplayed %s, nothing to do ...\n",dir->name);
+	if (dir->detached && !force) return(1);
+	if (dir->disp != D_DIR) { /* that should not be happening ... */
+		printf("[A]lready undisplayed %s, nothing to do ...\n", dir->name);
 		return(-1);
 	}
 	/* closing kids. ret will be != 0 if any of the kids did not close correctly */
-	ret=0;
-	for (i=0;i<dir->n_sub;i++)
-		if (dir->sub[i]->disp==D_DIR)
-			ret|=box_close(dir->sub[i],force);
-	if (ret && !force) {	/* if anything got wrong, return here ... */
+	ret = 0;
+	for (i = 0;i < dir->n_sub;i++)
+		if (dir->sub[i]->disp == D_DIR)
+			ret |= box_close(dir->sub[i], force);
+	if (ret && !force) { /* if anything got wrong, return here ... */
 		box_order_subdirs(dir);
 		return(ret);
 	} else {
 		/* also remove the icons */
-		if (focus==dir)			focus_set(dir->parent);
-		for (i=0;i<dir->n_sub;i++)
-			if (dir->sub[i]->disp==D_ICON) {
+		if (focus == dir)   focus_set(dir->parent);
+		for (i = 0;i < dir->n_sub;i++)
+			if (dir->sub[i]->disp == D_ICON) {
 				icon_undisplay(dir->sub[i]);
-				dir->detached=0;
-				if (focus==dir->sub[i])
+				dir->detached = 0;
+				if (focus == dir->sub[i])
 					focus_set(dir->parent);
 			}
 		box_unexpand(dir);
@@ -338,46 +338,46 @@
 / * only display dir and its kids, but nothing below. * /
 int box_collapse_grandkids(t_node *dir)
 {
-	int i,j;
-	t_node *kid;
-	for (i=0;i<dir->n_sub;i++)
-		if (dir->sub[i].disp==D_DIR)
-		{
-			kid=&dir->sub[i];
-			for (j=0;j<kid->n_item;j++)
-			if (kid->list[j].disp==D_DIR)
-				box_collapse(&kid->list[j],0);
-		}
-	return(0);
+ int i,j;
+ t_node *kid;
+ for (i=0;i<dir->n_sub;i++)
+  if (dir->sub[i].disp==D_DIR)
+  {
+   kid=&dir->sub[i];
+   for (j=0;j<kid->n_item;j++)
+   if (kid->list[j].disp==D_DIR)
+    box_collapse(&kid->list[j],0);
+  }
+ return(0);
 }*/
 /* orders the directory objects on top of its parent objects
  * to be called after adding or removing things ...*/
 void box_order_subdirs(t_node *dir)
 {
-	int i,j;
-	printf("box_order_subdirs( %s ): %d dirs opened\n",dir->name,dir->dirs_opened);
+	int i, j;
+	printf("box_order_subdirs( %s ): %d dirs opened\n", dir->name, dir->dirs_opened);
 	switch (dir->dirs_opened) {
 	case 0:
 		return;
 	case 1:
-		for (i=0;i<dir->n_sub;i++) {
-			if (dir->sub[i]->disp==D_DIR) {
-				dir->sub[i]->px=0.0;
-				dir->sub[i]->py=BOXHEIGHT+dir->sub[i]->detached*DETHEIGHT;
-				dir->sub[i]->pz=0.0;
-				dir->sub[i]->scale=0.2;
+		for (i = 0;i < dir->n_sub;i++) {
+			if (dir->sub[i]->disp == D_DIR) {
+				dir->sub[i]->px = 0.0;
+				dir->sub[i]->py = BOXHEIGHT + dir->sub[i]->detached * DETHEIGHT;
+				dir->sub[i]->pz = 0.0;
+				dir->sub[i]->scale = 0.2;
 				ani_add(dir->sub[i]);
 			}
 		}
 		break;
 	default:
-		j=0;
-		for (i=0;i<dir->n_sub;i++) {
-			if (dir->sub[i]->disp==D_DIR) {
-				dir->sub[i]->px=0.8 * sin(((float)j*2*M_PI)/((float)dir->dirs_opened));
-				dir->sub[i]->py=BOXHEIGHT+dir->sub[i]->detached*DETHEIGHT;
-				dir->sub[i]->pz=0.8 * cos(((float)j*2*M_PI)/((float)dir->dirs_opened));
-				dir->sub[i]->scale=0.2;
+		j = 0;
+		for (i = 0;i < dir->n_sub;i++) {
+			if (dir->sub[i]->disp == D_DIR) {
+				dir->sub[i]->px = 0.8 * sin(((float)j * 2 * M_PI) / ((float)dir->dirs_opened));
+				dir->sub[i]->py = BOXHEIGHT + dir->sub[i]->detached * DETHEIGHT;
+				dir->sub[i]->pz = 0.8 * cos(((float)j * 2 * M_PI) / ((float)dir->dirs_opened));
+				dir->sub[i]->scale = 0.2;
 				ani_add(dir->sub[i]);
 				j++;
 			}
@@ -387,18 +387,18 @@
 /* order the icons properly */
 void box_order_icons(t_node *dir)
 {
-	int dps,i;
-	dps=ceil(sqrt(dir->n_sub)); /* directories per line */
-	for (i=0;i<dir->n_sub;i++) {
+	int dps, i;
+	dps = ceil(sqrt(dir->n_sub)); /* directories per line */
+	for (i = 0;i < dir->n_sub;i++) {
 		if (dir->sub[i]->disp == D_ICON) {
-			dir->sub[i]->px = -1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
-			dir->sub[i]->py = 0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
-			dir->sub[i]->pz=dir->sub[i]->detached*0.2+1.0;
-			dir->sub[i]->scale = (float)1.0/((float)dps);
-			s3d_link(dir->sub[i]->oid,dir->oid);	 /* if it's already displayed, make sure it linked properly ... */
-			ani_finish(dir->sub[i], -1);			 /* copy to the current animation state */
-			s3d_flags_on(dir->sub[i]->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_on(dir->sub[i]->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			dir->sub[i]->px = -1 + 2 * ((float)((int)i % dps) + 0.5) / ((float)dps);
+			dir->sub[i]->py = 0.5 + ((float)((int)i / dps) + 0.5) / ((float)dps) - 0.5;
+			dir->sub[i]->pz = dir->sub[i]->detached * 0.2 + 1.0;
+			dir->sub[i]->scale = (float)1.0 / ((float)dps);
+			s3d_link(dir->sub[i]->oid, dir->oid); /* if it's already displayed, make sure it linked properly ... */
+			ani_finish(dir->sub[i], -1);    /* copy to the current animation state */
+			s3d_flags_on(dir->sub[i]->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			s3d_flags_on(dir->sub[i]->objs.str, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 		}
 	}
 }

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/dialog.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,7 +24,7 @@
 
 #include "s3dfm.h"
 #include <s3d_keysym.h>
-#include <stdio.h> 	/* NULL, printf() */
+#include <stdio.h>  /* NULL, printf() */
 #include <string.h> /* strlen() */
 #include <stdlib.h> /* realloc(),malloc() */
 #include <errno.h>  /* errno */
@@ -32,13 +32,13 @@
 #include <sys/stat.h> /* mkdir() */
 #include <sys/types.h> /* mkdir() */
 
-static s3dw_input	 *input;
+static s3dw_input  *input;
 static filelist *fp;
 static char destdir[M_DIR];
-static t_node *destnode=NULL;
+static t_node *destnode = NULL;
 
 extern int typeinput;
-int fs_lock=0;
+int fs_lock = 0;
 pthread_t filethread;
 
 
@@ -51,20 +51,20 @@
 {
 	int i;
 	char *s;
-	for (i=0;i<dir->n_sub;i++) {
-		if (dir->sub[i]->sub!=NULL)	get_selected(fp,dir->sub[i]); /* scan subdir */
+	for (i = 0;i < dir->n_sub;i++) {
+		if (dir->sub[i]->sub != NULL) get_selected(fp, dir->sub[i]); /* scan subdir */
 		if (dir->sub[i]->detached) {
 			fp->n++;
-			fp->p=realloc(fp->p,sizeof(t_file) * fp->n);
-			s=malloc(M_DIR);
-			node_path(dir->sub[i],s);
-			fp->p[fp->n - 1].name=s;
-			if ((fs_lock==TYPE_COPY)||(fs_lock==TYPE_MOVE))
-				fp->p[fp->n - 1].anode=fly_create_anode(dir->sub[i]);
+			fp->p = realloc(fp->p, sizeof(t_file) * fp->n);
+			s = malloc(M_DIR);
+			node_path(dir->sub[i], s);
+			fp->p[fp->n - 1].name = s;
+			if ((fs_lock == TYPE_COPY) || (fs_lock == TYPE_MOVE))
+				fp->p[fp->n - 1].anode = fly_create_anode(dir->sub[i]);
 			else
-				fp->p[fp->n - 1].anode=NULL;
-			fp->p[fp->n - 1].size=0; /*TODO: later */
-			fp->p[fp->n - 1].state=STATE_NONE;
+				fp->p[fp->n - 1].anode = NULL;
+			fp->p[fp->n - 1].size = 0; /*TODO: later */
+			fp->p[fp->n - 1].state = STATE_NONE;
 
 		}
 	}
@@ -74,17 +74,17 @@
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;
-	infwin=s3dw_surface_new("Help Window",12,12);
-	s3dw_label_new(infwin,"F1 - This Help Window",1,2);
-	s3dw_label_new(infwin,"F5 - Copy",1,3);
-	s3dw_label_new(infwin,"F6 - Move",1,4);
-	s3dw_label_new(infwin,"F7 - Create Directory",1,5);
-	s3dw_label_new(infwin,"F8 - Unlink",1,5);
-	s3dw_label_new(infwin,"R - Refresh",1,6);
-	s3dw_label_new(infwin,"I - Info",1,7);
+	infwin = s3dw_surface_new("Help Window", 12, 12);
+	s3dw_label_new(infwin, "F1 - This Help Window", 1, 2);
+	s3dw_label_new(infwin, "F5 - Copy", 1, 3);
+	s3dw_label_new(infwin, "F6 - Move", 1, 4);
+	s3dw_label_new(infwin, "F7 - Create Directory", 1, 5);
+	s3dw_label_new(infwin, "F8 - Unlink", 1, 5);
+	s3dw_label_new(infwin, "R - Refresh", 1, 6);
+	s3dw_label_new(infwin, "I - Info", 1, 7);
 
-	button=s3dw_button_new(infwin,"OK",4,10);
-	button->onclick=close_win;
+	button = s3dw_button_new(infwin, "OK", 4, 10);
+	button->onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 
 }
@@ -92,25 +92,25 @@
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;
-	infwin=s3dw_surface_new("Error",20,8);
-	s3dw_label_new(infwin,"Sorry, another FS Action is in Progress",1,2);
-	button=s3dw_button_new(infwin,"OK",5,5);
-	button->onclick=close_win;
+	infwin = s3dw_surface_new("Error", 20, 8);
+	s3dw_label_new(infwin, "Sorry, another FS Action is in Progress", 1, 2);
+	button = s3dw_button_new(infwin, "OK", 5, 5);
+	button->onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 }
 void window_fs_nothing()
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;
-	infwin=s3dw_surface_new("Error",12,8);
-	s3dw_label_new(infwin,"Nothing selected :(",1,2);
-	button=s3dw_button_new(infwin,"OK",5,5);
-	button->onclick=close_win;
+	infwin = s3dw_surface_new("Error", 12, 8);
+	s3dw_label_new(infwin, "Nothing selected :(", 1, 2);
+	button = s3dw_button_new(infwin, "OK", 5, 5);
+	button->onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 }
 void window_fs_confirm_error(s3dw_widget *button)
 {
-	fs_err.state=ESTATE_NONE;
+	fs_err.state = ESTATE_NONE;
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 
 }
@@ -120,24 +120,24 @@
 	s3dw_button  *button;
 	char string[M_DIR];
 	float l;
-	snprintf(string,M_DIR,"%s: %s",errmsg,strerror(errno));
-	l=strlen(string)*0.7;
-	infwin=s3dw_surface_new("Error",l,8);
-	s3dw_label_new(infwin,string,1,2);
-	button=s3dw_button_new(infwin,"OK",l/2-1,5);
-	button->onclick=close_win;
+	snprintf(string, M_DIR, "%s: %s", errmsg, strerror(errno));
+	l = strlen(string) * 0.7;
+	infwin = s3dw_surface_new("Error", l, 8);
+	s3dw_label_new(infwin, string, 1, 2);
+	button = s3dw_button_new(infwin, "OK", l / 2 - 1, 5);
+	button->onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 }
 
 void window_fs_abort(s3dw_widget *button)
 {
 	/* delete a filelist, if there was any */
-	if (fp!=NULL) {
+	if (fp != NULL) {
 		fl_del(fp);
-		fp=NULL;
+		fp = NULL;
 	}
-	typeinput=0;
-	fs_lock=TYPE_NONE;
+	typeinput = 0;
+	fs_lock = TYPE_NONE;
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 }
 void *thread_start(void *ptr)
@@ -145,8 +145,8 @@
 	switch (fs_lock) {
 	case TYPE_COPY:
 		printf("starting a copy process in the thread ... \n");
-		destnode=node_getbypath(destdir);
-		fs_fl_copy(fp,destdir);
+		destnode = node_getbypath(destdir);
+		fs_fl_copy(fp, destdir);
 		printf("done\n");
 		break;
 	case TYPE_UNLINK:
@@ -155,60 +155,60 @@
 		printf("done\n");
 		break;
 	}
-	fs_lock=TYPE_FINISHED;
+	fs_lock = TYPE_FINISHED;
 	return(NULL);
 
 }
 /* start the thread, as filesystem stuff is locked ... */
 void window_fs(s3dw_widget *button)
 {
-	pthread_create( &filethread, NULL, thread_start, NULL);
+	pthread_create(&filethread, NULL, thread_start, NULL);
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 }
 void window_copy(char *path)
 {
 	s3dw_surface *infwin;
-	s3dw_button  *okbutton,*abortbutton;
+	s3dw_button  *okbutton, *abortbutton;
 	float l;
 
-	int i,m;
+	int i, m;
 
-	if (fs_lock) 	{
+	if (fs_lock)  {
 		window_fs_another();
 		return;
 	}
-	fs_lock=TYPE_COPY;
-	fp=malloc(sizeof(filelist));
-	fp->n=0;
-	fp->p=NULL;
-	get_selected(fp,&root);
-	printf("selected %d nodes\n",fp->n);
-	if (fp->n == 0)	{
+	fs_lock = TYPE_COPY;
+	fp = malloc(sizeof(filelist));
+	fp->n = 0;
+	fp->p = NULL;
+	get_selected(fp, &root);
+	printf("selected %d nodes\n", fp->n);
+	if (fp->n == 0) {
 		window_fs_nothing();
 		free(fp);
-		fp=NULL;
+		fp = NULL;
 		return;
 	}
 	/* get the longest item on the list */
-	m=10;
-	for (i=0;i<fp->n;i++) {
-		if (strlen(fp->p[i].name)>m) m=strlen(fp->p[i].name);
-		printf("%d: %s\n",i,fp->p[i].name);
+	m = 10;
+	for (i = 0;i < fp->n;i++) {
+		if (strlen(fp->p[i].name) > m) m = strlen(fp->p[i].name);
+		printf("%d: %s\n", i, fp->p[i].name);
 	}
 
-	l=(m+3)*0.7;
-	infwin=s3dw_surface_new("Copy Window",l,fp->n+8);
-	s3dw_label_new(infwin,"Copy: ",1,1);
-	for (i=0;i<fp->n;i++)
-		s3dw_label_new(infwin,fp->p[i].name,3,2+i);
-	s3dw_label_new(infwin,"to:",1,fp->n+3);
-	node_path(node_getdir(focus),destdir);
-	s3dw_label_new(infwin,destdir,3,fp->n+4);
+	l = (m + 3) * 0.7;
+	infwin = s3dw_surface_new("Copy Window", l, fp->n + 8);
+	s3dw_label_new(infwin, "Copy: ", 1, 1);
+	for (i = 0;i < fp->n;i++)
+		s3dw_label_new(infwin, fp->p[i].name, 3, 2 + i);
+	s3dw_label_new(infwin, "to:", 1, fp->n + 3);
+	node_path(node_getdir(focus), destdir);
+	s3dw_label_new(infwin, destdir, 3, fp->n + 4);
 
-	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp->n+5);
-	okbutton->onclick=window_fs;
-	abortbutton=s3dw_button_new(infwin,"abort",l/2,fp->n+5);
-	abortbutton->onclick=window_fs_abort;
+	okbutton = s3dw_button_new(infwin, "OK", l / 2 - 3, fp->n + 5);
+	okbutton->onclick = window_fs;
+	abortbutton = s3dw_button_new(infwin, "abort", l / 2, fp->n + 5);
+	abortbutton->onclick = window_fs_abort;
 
 	s3dw_show(S3DWIDGET(infwin));
 
@@ -218,42 +218,42 @@
 void window_unlink()
 {
 	s3dw_surface *infwin;
-	s3dw_button  *okbutton,*abortbutton;
+	s3dw_button  *okbutton, *abortbutton;
 	float l;
 
-	int i,m;
+	int i, m;
 
-	if (fs_lock) 	{
+	if (fs_lock)  {
 		window_fs_another();
 		return;
 	}
-	fs_lock=TYPE_UNLINK;
-	fp=malloc(sizeof(filelist));
-	fp->n=0;
-	fp->p=NULL;
-	get_selected(fp,&root);
-	printf("selected %d nodes\n",fp->n);
-	if (fp->n == 0)	{
+	fs_lock = TYPE_UNLINK;
+	fp = malloc(sizeof(filelist));
+	fp->n = 0;
+	fp->p = NULL;
+	get_selected(fp, &root);
+	printf("selected %d nodes\n", fp->n);
+	if (fp->n == 0) {
 		window_fs_nothing();
 		free(fp);
-		fp=NULL;
+		fp = NULL;
 		return;
 	}
 	/* get the longest item on the list */
-	m=10;
-	for (i=0;i<fp->n;i++)
-		if (strlen(fp->p[i].name)>m) m=strlen(fp->p[i].name);
+	m = 10;
+	for (i = 0;i < fp->n;i++)
+		if (strlen(fp->p[i].name) > m) m = strlen(fp->p[i].name);
 
-	l=(m+3)*0.7;
-	infwin=s3dw_surface_new("Unlink Window",l,fp->n+8);
-	s3dw_label_new(infwin,"Unlink: ",1,1);
-	for (i=0;i<fp->n;i++)
-		s3dw_label_new(infwin,fp->p[i].name,3,2+i);
+	l = (m + 3) * 0.7;
+	infwin = s3dw_surface_new("Unlink Window", l, fp->n + 8);
+	s3dw_label_new(infwin, "Unlink: ", 1, 1);
+	for (i = 0;i < fp->n;i++)
+		s3dw_label_new(infwin, fp->p[i].name, 3, 2 + i);
 
-	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp->n+3);
-	okbutton->onclick=window_fs;
-	abortbutton=s3dw_button_new(infwin,"Abort",l/2,fp->n+3);
-	abortbutton->onclick=window_fs_abort;
+	okbutton = s3dw_button_new(infwin, "OK", l / 2 - 3, fp->n + 3);
+	okbutton->onclick = window_fs;
+	abortbutton = s3dw_button_new(infwin, "Abort", l / 2, fp->n + 3);
+	abortbutton->onclick = window_fs_abort;
 
 	s3dw_show(S3DWIDGET(infwin));
 
@@ -262,48 +262,48 @@
 {
 	char *dir;
 	t_node *item;
-	dir=s3dw_input_gettext(input);
-	printf("creating Directory ...%s\n",dir);
-	if (-1==mkdir(dir,0777)) /* umask ?! */
+	dir = s3dw_input_gettext(input);
+	printf("creating Directory ...%s\n", dir);
+	if (-1 == mkdir(dir, 0777)) /* umask ?! */
 		window_fs_errno("could not create directory");
 	else {
 		/* success, now refresh it */
-		item=node_getbypath(dir);
-		if (item==NULL) {
+		item = node_getbypath(dir);
+		if (item == NULL) {
 			printf("cannot refresh\n");
 		} else {
-			printf("refreshing %s\n",item->name);
-			/*			parse_again(item);*/
+			printf("refreshing %s\n", item->name);
+			/*   parse_again(item);*/
 		}
 	}
-	fs_lock=0;
+	fs_lock = 0;
 	window_fs_abort(button); /* finish */
 
 }
 void window_mkdir(char *path)
 {
 	s3dw_surface *infwin;
-	s3dw_button  *okbutton,*abortbutton;
+	s3dw_button  *okbutton, *abortbutton;
 	char string1[M_DIR];
 	float l;
 	if (fs_lock) {
 		window_fs_another();
 		return;
 	}
-	snprintf(string1,M_DIR,"Create Directory in %s",path);
-	l=strlen(string1)*0.7;
-	infwin=s3dw_surface_new("Create Directory",l,8);
-	s3dw_label_new(infwin,string1,1,2);
-	input=s3dw_input_new(infwin,10,1,3);
+	snprintf(string1, M_DIR, "Create Directory in %s", path);
+	l = strlen(string1) * 0.7;
+	infwin = s3dw_surface_new("Create Directory", l, 8);
+	s3dw_label_new(infwin, string1, 1, 2);
+	input = s3dw_input_new(infwin, 10, 1, 3);
 	s3dw_input_change_text(input, path);
 	s3dw_focus(S3DWIDGET(input));
 	s3dw_focus(S3DWIDGET(infwin));
-	typeinput=1;
-	fs_lock=1;
-	okbutton=s3dw_button_new(infwin,"OK",l/2-3,5);
-	okbutton->onclick=window_fs_mkdir;
-	abortbutton=s3dw_button_new(infwin,"abort",l/2,5);
-	abortbutton->onclick=window_fs_abort;
+	typeinput = 1;
+	fs_lock = 1;
+	okbutton = s3dw_button_new(infwin, "OK", l / 2 - 3, 5);
+	okbutton->onclick = window_fs_mkdir;
+	abortbutton = s3dw_button_new(infwin, "abort", l / 2, 5);
+	abortbutton->onclick = window_fs_abort;
 	s3dw_show(S3DWIDGET(infwin));
 }
 
@@ -315,10 +315,10 @@
 		window_fs_another();
 		return;
 	}
-	infwin=s3dw_surface_new("Info Window",20,8);
-	s3dw_label_new(infwin,"Sorry, moving is not implemented yet.. :(",1,2);
-	button=s3dw_button_new(infwin,"Too bad",7,5);
-	button->onclick=close_win;
+	infwin = s3dw_surface_new("Info Window", 20, 8);
+	s3dw_label_new(infwin, "Sorry, moving is not implemented yet.. :(", 1, 2);
+	button = s3dw_button_new(infwin, "Too bad", 7, 5);
+	button->onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 
 }
@@ -329,24 +329,24 @@
 	s3dw_button  *button;
 	char string1[M_DIR];
 	char string2[M_DIR];
-	int b,d,f;
+	int b, d, f;
 	char bd[M_DIR];
 	float l;
-	snprintf(string1,M_DIR,"Info for %s",path);
+	snprintf(string1, M_DIR, "Info for %s", path);
 	fs_approx(path, &f, &d, &b);
-	dotted_int(bd,b);
-	snprintf(string2 ,M_DIR,"%s bytes in %d files and %d Directories",bd,f,d);
+	dotted_int(bd, b);
+	snprintf(string2 , M_DIR, "%s bytes in %d files and %d Directories", bd, f, d);
 
-	l=((strlen(string1)>strlen(string2)) ? strlen(string1) :strlen(string2))*0.7;
+	l = ((strlen(string1) > strlen(string2)) ? strlen(string1) : strlen(string2)) * 0.7;
 
-	infwin=s3dw_surface_new("Info Window",l,12);
+	infwin = s3dw_surface_new("Info Window", l, 12);
 
-	s3dw_label_new(infwin,string1,1,2);
-	s3dw_label_new(infwin,string2,1,4);
+	s3dw_label_new(infwin, string1, 1, 2);
+	s3dw_label_new(infwin, string2, 1, 4);
 
-	button=s3dw_button_new(infwin,"OK",l/2-1,6);
+	button = s3dw_button_new(infwin, "OK", l / 2 - 1, 6);
 	/* clicking on the button will exit ... */
-	button->onclick=close_win;
+	button->onclick = close_win;
 	/* of couse, show it */
 	s3dw_show(S3DWIDGET(infwin));
 }
@@ -355,10 +355,10 @@
 {
 	int i;
 	t_node *node, dummy;
-	if (fs_lock!=TYPE_NONE)	{
+	if (fs_lock != TYPE_NONE) {
 		/* get current position of our destination node */
-		if (destnode!=NULL) {
-			node=destnode;
+		if (destnode != NULL) {
+			node = destnode;
 			node_init(&dummy);
 			dummy.parent = node->parent;
 			dummy.scale = node->scale;
@@ -368,18 +368,18 @@
 			dummy.type = node->type;
 			fly_set_absolute_position(&dummy);
 		} else {
-			dummy.px=0;
-			dummy.py=0;
-			dummy.pz=0;
-			dummy.scale=0.01;
+			dummy.px = 0;
+			dummy.py = 0;
+			dummy.pz = 0;
+			dummy.scale = 0.01;
 		}
-		if (fp!=NULL) {
-			for (i=0;i<fp->n;i++) {
-				if (fp->p[i].state==STATE_FINISHED) { /* we can go and clean up now. */
-					if (NULL!=(node=node_getbypath(fp->p[i].name))) {
-						printf("[CLEANUP] for node %s (%s)\n",node->name,fp->p[i].name);
-						node->detached=0;
-						if (node->parent!=NULL) {
+		if (fp != NULL) {
+			for (i = 0;i < fp->n;i++) {
+				if (fp->p[i].state == STATE_FINISHED) { /* we can go and clean up now. */
+					if (NULL != (node = node_getbypath(fp->p[i].name))) {
+						printf("[CLEANUP] for node %s (%s)\n", node->name, fp->p[i].name);
+						node->detached = 0;
+						if (node->parent != NULL) {
 							parse_dir(node->parent);
 							switch (node->disp) {
 							case D_ICON:
@@ -391,50 +391,50 @@
 							}
 						}
 					} else
-						printf("node %s already vanished ...\n",fp->p[i].name);
+						printf("node %s already vanished ...\n", fp->p[i].name);
 
-					fp->p[i].state=STATE_CLEANED;
+					fp->p[i].state = STATE_CLEANED;
 				}
-				if (fp->p[i].state>STATE_NONE) {
-					if (destnode!=NULL) {
-						fp->p[i].anode->px=dummy.px;
-						fp->p[i].anode->py=dummy.py;
-						fp->p[i].anode->pz=dummy.pz;
+				if (fp->p[i].state > STATE_NONE) {
+					if (destnode != NULL) {
+						fp->p[i].anode->px = dummy.px;
+						fp->p[i].anode->py = dummy.py;
+						fp->p[i].anode->pz = dummy.pz;
 						ani_add(fp->p[i].anode);
 					}
 
 				}
 			}
 		}
-		if (fs_lock==TYPE_FINISHED)	{
+		if (fs_lock == TYPE_FINISHED) {
 			printf("filesystem stuff is finisheed, cleaning up");
-			if (fp!=NULL) {
+			if (fp != NULL) {
 				fl_del(fp);
-				fp=NULL;
+				fp = NULL;
 			}
-			typeinput=0;
-			fs_lock=TYPE_NONE;
-			if (destnode!=NULL)
-				if (destnode->disp==D_DIR) { /* it usually is opened */
+			typeinput = 0;
+			fs_lock = TYPE_NONE;
+			if (destnode != NULL)
+				if (destnode->disp == D_DIR) { /* it usually is opened */
 					printf("reordering icons on destnode ...\n");
 					box_order_icons(destnode);
 				}
-			destnode=NULL;
+			destnode = NULL;
 		}
-		if (fs_err.state==ESTATE_RISE) {
+		if (fs_err.state == ESTATE_RISE) {
 			s3dw_surface *infwin;
 			s3dw_button  *button;
 			char errmsg[M_DIR];
 			float l;
-			fs_err.state=ESTATE_WAIT_FOR_CONFIRM;
-			snprintf(errmsg,M_DIR,"Error \"%s\" on %s",fs_err.message,fs_err.file);
-			l=s3d_strlen(errmsg)+2;
-			infwin=s3dw_surface_new("Error",l,8);
-			s3dw_label_new(infwin,errmsg,1,2);
-			button=s3dw_button_new(infwin,"OK",l/2-1,5);
-			button->onclick=window_fs_confirm_error;
+			fs_err.state = ESTATE_WAIT_FOR_CONFIRM;
+			snprintf(errmsg, M_DIR, "Error \"%s\" on %s", fs_err.message, fs_err.file);
+			l = s3d_strlen(errmsg) + 2;
+			infwin = s3dw_surface_new("Error", l, 8);
+			s3dw_label_new(infwin, errmsg, 1, 2);
+			button = s3dw_button_new(infwin, "OK", l / 2 - 1, 5);
+			button->onclick = window_fs_confirm_error;
 			s3dw_show(S3DWIDGET(infwin));
-			printf("fs_err is active ... message: %s\n",errmsg);
+			printf("fs_err is active ... message: %s\n", errmsg);
 		}
 	}
 }

Modified: trunk/apps/s3dfm/event.c
===================================================================
--- trunk/apps/s3dfm/event.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/event.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -27,17 +27,17 @@
 
 
 
-int typeinput=0;
+int typeinput = 0;
 
 /* info packets handler, we're just interested in the cam */
 int event_oinfo(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz->buf;
-	if ((inf->object==0) && (!ani_onstack(&cam))) {
-		cam.dpx=inf->trans_x;
-		cam.dpy=inf->trans_y;
-		cam.dpz=inf->trans_z;
+	inf = (struct s3d_obj_info *)hrmz->buf;
+	if ((inf->object == 0) && (!ani_onstack(&cam))) {
+		cam.dpx = inf->trans_x;
+		cam.dpy = inf->trans_y;
+		cam.dpz = inf->trans_z;
 	}
 	s3dw_object_info(hrmz);
 	return(0);
@@ -46,14 +46,14 @@
 /* keyevent handler */
 int event_key(struct s3d_evt *evt)
 {
-	struct s3d_key_event *keys=(struct s3d_key_event *)evt->buf;
+	struct s3d_key_event *keys = (struct s3d_key_event *)evt->buf;
 	char path[M_DIR];
-	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */
+	if (typeinput) { /* we have some inputfield now and want the s3dw to handle our input */
 		printf("inputting text ...\n");
 		s3dw_handle_key(evt);
 		return(0);
 	}
-	node_path(node_getdir(focus),path);
+	node_path(node_getdir(focus), path);
 	switch (keys->keysym) {
 	case 'i':
 	case 'I': {
@@ -63,8 +63,8 @@
 	case 'r':
 	case 'R': {/* refresh this window ... */
 		t_node *node;
-		node=node_getdir(focus);
-		printf("[R]efreshing %s\n",node->name);
+		node = node_getdir(focus);
+		printf("[R]efreshing %s\n", node->name);
 		parse_dir(node);
 		box_draw_icons(node);
 		box_order_icons(node);
@@ -103,10 +103,10 @@
 		node_select(focus);
 		break;
 	case S3DK_BACKSPACE:
-		if (focus->disp==D_DIR)
-			box_close(focus,1);
-		else if (focus->parent!=NULL)
-			box_close(focus->parent,1);
+		if (focus->disp == D_DIR)
+			box_close(focus, 1);
+		else if (focus->parent != NULL)
+			box_close(focus->parent, 1);
 		break;
 
 	}
@@ -120,20 +120,20 @@
 	int oid;
 	t_node *f;
 	s3dw_handle_click(evt);
-	oid=(int)*((u_int32_t *)evt->buf);
-	if (NULL!=(f=node_getbyoid(&root,oid))) {
-		if (f->objs.close==oid) {
-			box_close(f,1);
+	oid = (int) * ((u_int32_t *)evt->buf);
+	if (NULL != (f = node_getbyoid(&root, oid))) {
+		if (f->objs.close == oid) {
+			box_close(f, 1);
 			return(0);
 		}
-		if (f->objs.select==oid) {
-			printf("[S]electing %s\n",f->name);
+		if (f->objs.select == oid) {
+			printf("[S]electing %s\n", f->name);
 			node_select(f);
 			return(0);
 		}
 		node_select(f);
 	} else {
-		/*		printf("[C]ould not find :/\n");*/
+		/*  printf("[C]ould not find :/\n");*/
 	}
 	return(0);
 }

Modified: trunk/apps/s3dfm/fly.c
===================================================================
--- trunk/apps/s3dfm/fly.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/fly.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,43 +22,43 @@
  */
 
 #include "s3dfm.h"
-#include <stdio.h>	/* NULL */
+#include <stdio.h> /* NULL */
 #include <string.h> /* strncpy() */
 static void _get_pos(t_node *work, t_node *f)
 {
-	if (f->parent!=NULL) _get_pos(work,f->parent);
-	work->px+=f->px										* work->scale;
-	work->pz+=f->pz										* work->scale;
-	work->py+=f->py										* work->scale;
+	if (f->parent != NULL) _get_pos(work, f->parent);
+	work->px += f->px          * work->scale;
+	work->pz += f->pz          * work->scale;
+	work->py += f->py          * work->scale;
 	/*
 	printf("%s: %3.3f %3.3f %3.3f - %3.3f\n",f->name, f->px, f->py, f->pz, f->scale );
 	printf("### %3.3f %3.3f %3.3f - %3.3f)\n", work->px, work->py, work->pz, work->scale);
 	*/
-	if (f->parent==NULL)	work->scale = f->scale;
-	else					work->scale = work->scale * f->scale;
+	if (f->parent == NULL) work->scale = f->scale;
+	else     work->scale = work->scale * f->scale;
 
 }
 
 int fly_set_absolute_position(t_node *node)
 {
 	t_node work;
-	work.px=0;
-	work.py=0;
-	work.pz=0;
-	work.scale=1.0;
+	work.px = 0;
+	work.py = 0;
+	work.pz = 0;
+	work.scale = 1.0;
 	_get_pos(&work, node);
-	node->px=work.px;
-	node->py=work.py;
-	node->pz=work.pz;
-	node->scale=work.scale;
-	/*	printf("node coordinates: %3.3f %3.3f %3.3f %3.3f\n",node->px,node->py,node->pz,node->scale);*/
+	node->px = work.px;
+	node->py = work.py;
+	node->pz = work.pz;
+	node->scale = work.scale;
+	/* printf("node coordinates: %3.3f %3.3f %3.3f %3.3f\n",node->px,node->py,node->pz,node->scale);*/
 	return(0);
 }
 /* create a copy of *node as an icon (block) which can be moved for animation ... */
 t_node *fly_create_anode(t_node *node)
 {
 	t_node *work;
-	work=malloc(sizeof(t_node));
+	work = malloc(sizeof(t_node));
 	node_init(work);
 	work->parent = node->parent;
 	work->scale = node->scale;
@@ -66,17 +66,17 @@
 	work->py = node->py;
 	work->pz = node->pz;
 	work->type = node->type;
-	strncpy(work->name,node->name,M_NAME);
+	strncpy(work->name, node->name, M_NAME);
 	fly_set_absolute_position(work);
 	icon_draw(work);
 
-	work->dpx=work->px;
-	work->dpy=work->py;
-	work->dpz=work->pz;
-	work->dscale=work->scale;
-	work->py=2*work->scale - work->py; /* invert */
-	s3d_flags_on(work->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(work->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	work->dpx = work->px;
+	work->dpy = work->py;
+	work->dpz = work->pz;
+	work->dscale = work->scale;
+	work->py = 2 * work->scale - work->py; /* invert */
+	s3d_flags_on(work->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(work->objs.str, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 	ani_add(work);
 	return(work);
 }

Modified: trunk/apps/s3dfm/focus.c
===================================================================
--- trunk/apps/s3dfm/focus.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/focus.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,55 +25,55 @@
 #include <s3d_keysym.h>
 #include <stdio.h> /* printf() */
 #include <math.h>  /* ceil(), sqrt() */
-int moveon=1;
+int moveon = 1;
 
 /* get the scale for the rootbox zoom */
 float focus_get_scale(t_node *f)
 {
-	float scale,s;
-	if (f->disp==D_DIR) {
-		s=0.2;
-		scale=1/s;
-		if (f->parent!=NULL)
-			scale=1/s*focus_get_scale(f->parent);
+	float scale, s;
+	if (f->disp == D_DIR) {
+		s = 0.2;
+		scale = 1 / s;
+		if (f->parent != NULL)
+			scale = 1 / s * focus_get_scale(f->parent);
 		else
 			return(1.0);
-		root.px-=f->px;
-		root.pz-=f->pz;
-		root.py-=BOXHEIGHT+f->detached*DETHEIGHT;
-		root.px*=1/s;
-		root.py*=1/s;
-		root.pz*=1/s;
+		root.px -= f->px;
+		root.pz -= f->pz;
+		root.py -= BOXHEIGHT + f->detached * DETHEIGHT;
+		root.px *= 1 / s;
+		root.py *= 1 / s;
+		root.pz *= 1 / s;
 		return(scale);
 	} else {
-		if (f->parent!=NULL)		return(focus_get_scale(f->parent));	/* icons etc */
-		else  						return(1.0);						/* that should never happen */
+		if (f->parent != NULL)  return(focus_get_scale(f->parent)); /* icons etc */
+		else        return(1.0);      /* that should never happen */
 	}
 
 }
 /* center f for the viewer, therefore moving the root box ... */
 void focus_set(t_node *f)
 {
-	root.px=0.0;
-	root.py=0.0;
-	root.pz=0.0;
-	moveon=1;
-	/*	printf("[Z]ooming to %s\n",f->name);*/
-	/*	box_collapse_grandkids(f);*/
-	root.scale=focus_get_scale(f);
-	root.py-=1.5;
-	/*	printf("[R]escaling to %f\n",root.scale);
-		printf("px: %f py:%f pz: %f\n",root.px,root.py,root.pz);*/
+	root.px = 0.0;
+	root.py = 0.0;
+	root.pz = 0.0;
+	moveon = 1;
+	/* printf("[Z]ooming to %s\n",f->name);*/
+	/* box_collapse_grandkids(f);*/
+	root.scale = focus_get_scale(f);
+	root.py -= 1.5;
+	/* printf("[R]escaling to %f\n",root.scale);
+	 printf("px: %f py:%f pz: %f\n",root.px,root.py,root.pz);*/
 
 	ani_add(&root);
-	node_focus_color(focus,0);
-	node_focus_color(f,1);
-	focus=f;
-	if (((cam.dpx-cam.px)* (cam.dpx-cam.px) + (cam.dpy-cam.py)* (cam.dpy-cam.py)
-	                + (cam.dpz-cam.pz)* (cam.dpz-cam.pz))	> ( 10 * 10)) {
-		cam.px=0;
-		cam.py=0;
-		cam.pz=5;
+	node_focus_color(focus, 0);
+	node_focus_color(f, 1);
+	focus = f;
+	if (((cam.dpx - cam.px)* (cam.dpx - cam.px) + (cam.dpy - cam.py)* (cam.dpy - cam.py)
+	                + (cam.dpz - cam.pz)* (cam.dpz - cam.pz)) > (10 * 10)) {
+		cam.px = 0;
+		cam.py = 0;
+		cam.pz = 5;
 		ani_add(&cam);
 	}
 }
@@ -81,52 +81,52 @@
 /* uses a keysym to set the focus new */
 void focus_by_key(int keysym)
 {
-	int i,rowsize;
-	if (focus->pindex!=-1) {
+	int i, rowsize;
+	if (focus->pindex != -1) {
 		switch (focus->disp) {
 		case D_DIR:
 			switch (keysym) {
 			case S3DK_RIGHT:
 				/* cycle to the next directory on the ring */
-				for (i=focus->pindex-1;i>=0;i--)
-					if (focus->parent->sub[i]->disp==D_DIR) { /* found a directory before, cycle */
+				for (i = focus->pindex - 1;i >= 0;i--)
+					if (focus->parent->sub[i]->disp == D_DIR) { /* found a directory before, cycle */
 						focus_set(focus->parent->sub[i]);
 						break;
 					}
-				if (i==-1) /* nothing found, wrap to the other side */
-					for (i=focus->parent->n_sub-1;i>=focus->pindex+1;i--)
-						if (focus->parent->sub[i]->disp==D_DIR) { /* found a directory before, cycle */
+				if (i == -1) /* nothing found, wrap to the other side */
+					for (i = focus->parent->n_sub - 1;i >= focus->pindex + 1;i--)
+						if (focus->parent->sub[i]->disp == D_DIR) { /* found a directory before, cycle */
 							focus_set(focus->parent->sub[i]);
 							break;
 						}
 				break;
 			case S3DK_LEFT:
 				/* cycle to the next directory on the ring */
-				for (i=focus->pindex+1;i<focus->parent->n_sub;i++)
-					if (focus->parent->sub[i]->disp==D_DIR) { /* found a directory before, cycle */
+				for (i = focus->pindex + 1;i < focus->parent->n_sub;i++)
+					if (focus->parent->sub[i]->disp == D_DIR) { /* found a directory before, cycle */
 						focus_set(focus->parent->sub[i]);
 						break;
 					}
-				if (i==focus->parent->n_sub) /* nothing found, wrap to the other side */
-					for (i=0;i<focus->pindex;i++)
-						if (focus->parent->sub[i]->disp==D_DIR) { /* found a directory before, cycle */
+				if (i == focus->parent->n_sub) /* nothing found, wrap to the other side */
+					for (i = 0;i < focus->pindex;i++)
+						if (focus->parent->sub[i]->disp == D_DIR) { /* found a directory before, cycle */
 							focus_set(focus->parent->sub[i]);
 							break;
 						}
 				break;
 			case S3DK_UP:
 				/* go in the first entry of this directory, if possible */
-				if (focus->n_sub>0)
+				if (focus->n_sub > 0)
 					focus_set(focus->sub[0]);
 				break;
 			case S3DK_DOWN:
 				/* go to first icon entry of parent,  or parent itself */
-				for (i=focus->parent->n_sub-1;i>=0;i--)
-					if (focus->parent->sub[i]->disp==D_ICON) { /* found a directory before, cycle */
+				for (i = focus->parent->n_sub - 1;i >= 0;i--)
+					if (focus->parent->sub[i]->disp == D_ICON) { /* found a directory before, cycle */
 						focus_set(focus->parent->sub[i]);
 						break;
 					}
-				if (i==0) /* no icons? go to parent. */
+				if (i == 0) /* no icons? go to parent. */
 					focus_set(focus->parent);
 				break;
 
@@ -138,48 +138,48 @@
 			switch (keysym) {
 			case S3DK_LEFT:
 				/* search for the next icon on the left side */
-				i=focus->pindex;
+				i = focus->pindex;
 				do {
 					i--;
-					if (i<0) i=focus->parent->n_sub-1;
-				} while (focus->parent->sub[i]->disp!=D_ICON);
+					if (i < 0) i = focus->parent->n_sub - 1;
+				} while (focus->parent->sub[i]->disp != D_ICON);
 				focus_set(focus->parent->sub[i]);
 				break;
 			case S3DK_RIGHT:
 				/* search for the next icon on the right side */
-				i=focus->pindex;
+				i = focus->pindex;
 				do {
 					i++;
-					if (i>=focus->parent->n_sub) i=0;
-				} while (focus->parent->sub[i]->disp!=D_ICON);
+					if (i >= focus->parent->n_sub) i = 0;
+				} while (focus->parent->sub[i]->disp != D_ICON);
 				focus_set(focus->parent->sub[i]);
 				break;
 			case S3DK_UP:
 				/* search for the next icon on the left side */
-				i=focus->pindex;
-				rowsize=ceil(sqrt(focus->parent->n_sub)); /* items per line */
+				i = focus->pindex;
+				rowsize = ceil(sqrt(focus->parent->n_sub)); /* items per line */
 				do {
-					i+=rowsize;
-					if (i>=focus->parent->n_sub) break;
-				} while (focus->parent->sub[i]->disp!=D_ICON);
-				if (i>=focus->parent->n_sub) {
+					i += rowsize;
+					if (i >= focus->parent->n_sub) break;
+				} while (focus->parent->sub[i]->disp != D_ICON);
+				if (i >= focus->parent->n_sub) {
 					/* go to the first activated dir above ... */
-					for (i=0;i<focus->parent->n_sub;i++)
-						if (focus->parent->sub[i]->disp==D_DIR) { /* found a directory before, cycle */
+					for (i = 0;i < focus->parent->n_sub;i++)
+						if (focus->parent->sub[i]->disp == D_DIR) { /* found a directory before, cycle */
 							focus_set(focus->parent->sub[i]);
 							break;
 						}
-				} else		focus_set(focus->parent->sub[i]);
+				} else  focus_set(focus->parent->sub[i]);
 				break;
 			case S3DK_DOWN:
 				/* search for the next icon on the left side */
-				i=focus->pindex;
-				rowsize=ceil(sqrt(focus->parent->n_sub)); /* items per line */
+				i = focus->pindex;
+				rowsize = ceil(sqrt(focus->parent->n_sub)); /* items per line */
 				do {
-					i-=rowsize;
-					if (i<0) break;
-				} while (focus->parent->sub[i]->disp!=D_ICON);
-				if (i<0)
+					i -= rowsize;
+					if (i < 0) break;
+				} while (focus->parent->sub[i]->disp != D_ICON);
+				if (i < 0)
 					focus_set(focus->parent);
 				else
 					focus_set(focus->parent->sub[i]);
@@ -193,7 +193,7 @@
 		switch (keysym) {
 		case S3DK_UP:
 			/* go in the first entry of this directory, if possible */
-			if (focus->n_sub>0)
+			if (focus->n_sub > 0)
 				focus_set(focus->sub[0]);
 			break;
 		}

Modified: trunk/apps/s3dfm/fs.c
===================================================================
--- trunk/apps/s3dfm/fs.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/fs.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -21,13 +21,13 @@
  */
 
 #include "s3dfm.h"
-#include <stdio.h>	/*  printf() */
-#include <dirent.h>	/* scandir() */
-#include <stdlib.h>	/*  malloc() */
+#include <stdio.h> /*  printf() */
+#include <dirent.h> /* scandir() */
+#include <stdlib.h> /*  malloc() */
 
 /* we want GNU version of basename */
 #define _GNU_SOURCE
-#include <string.h>	/*  strlen(), strncmp(), strrchr() */
+#include <string.h> /*  strlen(), strncmp(), strrchr() */
 #include <libgen.h> /* basename() */
 
 #include <sys/types.h>
@@ -35,10 +35,10 @@
 #include <unistd.h>
 
 #include <errno.h> /* errno */
-#include <time.h>	/* nanosleep() */
+#include <time.h> /* nanosleep() */
 
-struct fs_error fs_err= {
-	0,0,NULL,NULL
+struct fs_error fs_err = {
+	0, 0, NULL, NULL
 };
 
 
@@ -47,40 +47,40 @@
 {
 	struct dirent **namelist;
 	filelist *fl;
-	int n,i,j;
+	int n, i, j;
 	char *name;
 
-	fl=malloc(sizeof(filelist));
-	fl->p=NULL;
-	fl->n=0;
+	fl = malloc(sizeof(filelist));
+	fl->p = NULL;
+	fl->n = 0;
 	n = scandir(path, &namelist, 0, alphasort);
 	if (n <= 2) { /* . and .. is always included. */
-		if (n<0)
-			fs_error("fl_new():scandir()",path);
+		if (n < 0)
+			fs_error("fl_new():scandir()", path);
 	} else {
-		j=0;
-		fl->n=n-2 ; /* ignore . and .. */
-		fl->p=malloc(sizeof(t_file)*fl->n);
-		for (i=0;i<n;i++) {
-			name=namelist[i]->d_name;
-			if (!((strcmp(name,".")==0) || (strcmp(name,"..")==0))) { /* ignore */
-				fl->p[j].name=malloc(strlen(name)+strlen(path)+2);
-				strcpy(fl->p[j].name,path);
-				strcat(fl->p[j].name,"/");
-				strcat(fl->p[j].name,name);
-				fl->p[j].anode=NULL;
-				fl->p[j].size=0; /*TODO: later */
-				fl->p[j].state=STATE_NONE;
+		j = 0;
+		fl->n = n - 2 ; /* ignore . and .. */
+		fl->p = malloc(sizeof(t_file) * fl->n);
+		for (i = 0;i < n;i++) {
+			name = namelist[i]->d_name;
+			if (!((strcmp(name, ".") == 0) || (strcmp(name, "..") == 0))) { /* ignore */
+				fl->p[j].name = malloc(strlen(name) + strlen(path) + 2);
+				strcpy(fl->p[j].name, path);
+				strcat(fl->p[j].name, "/");
+				strcat(fl->p[j].name, name);
+				fl->p[j].anode = NULL;
+				fl->p[j].size = 0; /*TODO: later */
+				fl->p[j].state = STATE_NONE;
 
 				j++;
 			}
 			free(namelist[i]);
 		}
-		if (j!=fl->n) { /* TODO: GUH! don't exit(-1) */
+		if (j != fl->n) { /* TODO: GUH! don't exit(-1) */
 			printf("assertion failed\n");
 			exit(-1);
 		}
-		free (namelist);
+		free(namelist);
 	}
 	return(fl);
 }
@@ -88,9 +88,9 @@
 void fl_del(filelist *fl)
 {
 	int i;
-	for (i=0;i<fl->n;i++) {
+	for (i = 0;i < fl->n;i++) {
 		free(fl->p[i].name);
-		if (fl->p[i].anode!=NULL) {
+		if (fl->p[i].anode != NULL) {
 			/* maybe let node_delete do that? */
 			/*node_delete(fl->p[i].anode);*/
 			icon_undisplay(fl->p[i].anode);
@@ -102,50 +102,50 @@
 /* approximate the heaviness of a single */
 void fs_approx(char *source, int *files, int *dirs, int *bytes)
 {
-	int sfiles,sdirs,sbytes; 	/* for subdirs */
+	int sfiles, sdirs, sbytes;  /* for subdirs */
 	filelist *fl;
 	struct stat s;
 
-	*files=	sfiles=	0;
-	*dirs=	sdirs=	0;
-	*bytes=	sbytes=	0;
+	*files = sfiles = 0;
+	*dirs = sdirs = 0;
+	*bytes = sbytes = 0;
 
-	/*	printf("start: %d files, %d dirs, %d bytes in %s\n",*files,*dirs,*bytes,source);*/
-	if (-1==stat(source,&s))
+	/* printf("start: %d files, %d dirs, %d bytes in %s\n",*files,*dirs,*bytes,source);*/
+	if (-1 == stat(source, &s))
 		return;
-	/*	printf("%s: %08x (%db)\n",source,s.st_mode,(int)s.st_size);*/
+	/* printf("%s: %08x (%db)\n",source,s.st_mode,(int)s.st_size);*/
 	if ((s.st_mode&S_IFMT) == S_IFDIR) {
 
-		fl=fl_new(source);
-		if (fl->n>0)
-			fs_fl_approx(fl,&sfiles,&sdirs,&sbytes);
+		fl = fl_new(source);
+		if (fl->n > 0)
+			fs_fl_approx(fl, &sfiles, &sdirs, &sbytes);
 		fl_del(fl);
-		/*		printf("%d files, %d dirs, %d bytes in %s\n",sfiles,sdirs,sbytes,source);*/
+		/*  printf("%d files, %d dirs, %d bytes in %s\n",sfiles,sdirs,sbytes,source);*/
 
-		*files=		sfiles;
-		*bytes+=	sbytes;
-		*dirs=		sdirs;
-		*dirs+=		1;
+		*files =  sfiles;
+		*bytes += sbytes;
+		*dirs =  sdirs;
+		*dirs +=  1;
 	} else
-		*files=		1;
-	*bytes+=s.st_size;
-	/*	printf("end: %d files, %d dirs, %d bytes in %s\n",*files,*dirs,*bytes,source);*/
+		*files =  1;
+	*bytes += s.st_size;
+	/* printf("end: %d files, %d dirs, %d bytes in %s\n",*files,*dirs,*bytes,source);*/
 }
 /* approximate the heaviness of our source ...*/
 void fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes)
 {
 	int i;
-	int sfiles,sdirs,sbytes; 	/* for subdirs */
+	int sfiles, sdirs, sbytes;  /* for subdirs */
 
-	*files=0;
-	*dirs=0;
-	*bytes=0;
+	*files = 0;
+	*dirs = 0;
+	*bytes = 0;
 
-	for (i=0;i<fl->n;i++) {
-		fs_approx(fl->p[i].name,&sfiles,&sdirs,&sbytes);
-		*files+=		sfiles;
-		*dirs+=			sdirs;
-		*bytes+=		sbytes;
+	for (i = 0;i < fl->n;i++) {
+		fs_approx(fl->p[i].name, &sfiles, &sdirs, &sbytes);
+		*files +=  sfiles;
+		*dirs +=   sdirs;
+		*bytes +=  sbytes;
 	}
 }
 /* copy a certain file */
@@ -156,14 +156,14 @@
 	struct stat s;
 	char buf[1024];
 	int n;
-	if (-1==stat(source,&s))
+	if (-1 == stat(source, &s))
 		return(0);
 	switch (s.st_mode&S_IFMT) {
 	case S_IFDIR:
-		fl=fl_new(source);
+		fl = fl_new(source);
 
-		printf("mkdir %s\n",dest);
-		mkdir(dest,0777);
+		printf("mkdir %s\n", dest);
+		mkdir(dest, 0777);
 
 		fs_fl_copy(fl, dest);
 
@@ -172,19 +172,19 @@
 	case S_IFIFO:
 		printf("link the fifo\n");
 
-		link(source,dest);
+		link(source, dest);
 		break;
 	default:
 		printf("fs_copy -> atomic copy\n");
 		printf("open source...");
-		if (NULL==(fps=fopen(source,"r"))) {
-			fs_error("fs_copy():fopen(source)",source);
+		if (NULL == (fps = fopen(source, "r"))) {
+			fs_error("fs_copy():fopen(source)", source);
 			return(-1);
 		}
 		printf("ok\n");
 		printf("open dest...");
-		if (NULL==(fpd=fopen(dest,"w"))) {
-			fs_error("fs_copy():fopen(source)",source);
+		if (NULL == (fpd = fopen(dest, "w"))) {
+			fs_error("fs_copy():fopen(source)", source);
 			return(-1);
 		}
 		printf("ok\n");
@@ -193,11 +193,11 @@
 
 		while (!feof(fps)) {
 			printf(".");
-			errno=0;
-			n=fread(buf,1,1024,fps);
-			if (errno)	fs_error("fs_copy():fread(source)",source);
-			fwrite(buf,1,n,fpd);
-			if (errno)	fs_error("fs_copy():fwrite(source)",source);
+			errno = 0;
+			n = fread(buf, 1, 1024, fps);
+			if (errno) fs_error("fs_copy():fread(source)", source);
+			fwrite(buf, 1, n, fpd);
+			if (errno) fs_error("fs_copy():fwrite(source)", source);
 		}
 		printf("ok\n");
 		fclose(fps);
@@ -213,19 +213,19 @@
 	int r;
 	char *sdest;
 	char *bname;
-	r=0;
-	for (i=0;i<fl->n;i++) {
-		fl->p[i].state=STATE_INUSE;
-		bname=basename(fl->p[i].name);
-		sdest=malloc(strlen(dest)+strlen(bname)+2);
+	r = 0;
+	for (i = 0;i < fl->n;i++) {
+		fl->p[i].state = STATE_INUSE;
+		bname = basename(fl->p[i].name);
+		sdest = malloc(strlen(dest) + strlen(bname) + 2);
 
-		strcpy(sdest,dest);
-		strcat(sdest,"/");
-		strcat(sdest,bname);
-		r|=fs_copy(fl->p[i].name,sdest);
+		strcpy(sdest, dest);
+		strcat(sdest, "/");
+		strcat(sdest, bname);
+		r |= fs_copy(fl->p[i].name, sdest);
 
 		free(sdest);
-		fl->p[i].state=STATE_FINISHED;
+		fl->p[i].state = STATE_FINISHED;
 	}
 
 	return(r);
@@ -236,24 +236,24 @@
 	filelist *fl;
 	struct stat s;
 
-	if (-1==stat(dest,&s))		return(-1);
+	if (-1 == stat(dest, &s))  return(-1);
 	if ((s.st_mode&S_IFMT) == S_IFDIR) {
-		printf("%s is a dir, removing below ...\n",dest);
-		fl=fl_new(dest);
+		printf("%s is a dir, removing below ...\n", dest);
+		fl = fl_new(dest);
 		if (fs_fl_unlink(fl)) {
 			fl_del(fl);
 			return(-1);
 		} else {
 			fl_del(fl);
-			printf("removing %s\n",dest);
-			if (rmdir(dest)==-1) {
-				fs_error("fs_fl_unlink(): rmdir()",dest);
+			printf("removing %s\n", dest);
+			if (rmdir(dest) == -1) {
+				fs_error("fs_fl_unlink(): rmdir()", dest);
 				return(-1);
 			}
 		}
 	} else {
-		if (unlink(dest)==-1) {
-			fs_error("fs_fl_unlink(): unlink()",dest);
+		if (unlink(dest) == -1) {
+			fs_error("fs_fl_unlink(): unlink()", dest);
 			return(-1);
 		}
 	}
@@ -262,27 +262,27 @@
 /* remove a lot of files */
 int fs_fl_unlink(filelist *fl)
 {
-	int i,r;
-	r=0;
-	for (i=0;i<fl->n;i++) {
-		fl->p[i].state=STATE_INUSE;
-		printf("-> atomic unlink %s\n",fl->p[i].name);
-		r|=fs_unlink(fl->p[i].name);
-		fl->p[i].state=STATE_FINISHED;
+	int i, r;
+	r = 0;
+	for (i = 0;i < fl->n;i++) {
+		fl->p[i].state = STATE_INUSE;
+		printf("-> atomic unlink %s\n", fl->p[i].name);
+		r |= fs_unlink(fl->p[i].name);
+		fl->p[i].state = STATE_FINISHED;
 	}
 	return(r);
 
 }
 int fs_move(char *source, char *dest)
 {
-	if (!rename(source,dest)) {
+	if (!rename(source, dest)) {
 		switch (errno) {
 		case EXDEV:
-			fs_copy(source,dest);
+			fs_copy(source, dest);
 			fs_unlink(source);
 			break;
 		default:
-			fs_error("fs_move()",dest);
+			fs_error("fs_move()", dest);
 			return(-1); /* can't help it */
 
 		}
@@ -297,19 +297,19 @@
 	int r;
 	char *sdest;
 	char *bname;
-	r=0;
-	for (i=0;i<fl->n;i++) {
-		fl->p[i].state=STATE_INUSE;
-		bname=basename(fl->p[i].name);
-		sdest=malloc(strlen(dest)+strlen(bname)+2);
+	r = 0;
+	for (i = 0;i < fl->n;i++) {
+		fl->p[i].state = STATE_INUSE;
+		bname = basename(fl->p[i].name);
+		sdest = malloc(strlen(dest) + strlen(bname) + 2);
 
-		strcpy(sdest,dest);
-		strcat(sdest,"/");
-		strcat(sdest,bname);
-		r|=fs_move(fl->p[i].name,sdest);
+		strcpy(sdest, dest);
+		strcat(sdest, "/");
+		strcat(sdest, bname);
+		r |= fs_move(fl->p[i].name, sdest);
 
 		free(sdest);
-		fl->p[i].state=STATE_FINISHED;
+		fl->p[i].state = STATE_FINISHED;
 	}
 
 	return(r);
@@ -320,15 +320,15 @@
 /* write an error and wait for a reaction */
 int fs_error(char *message, char *file)
 {
-	static struct timespec t= {
-		0,100*1000*1000
+	static struct timespec t = {
+		0, 100*1000*1000
 	};
-	fs_err.err=errno;
-	fs_err.message=message;
-	fs_err.file=file;
-	fs_err.state=ESTATE_RISE;
-	printf("[FS ERROR]: %s %s %s",message,file,strerror(errno));
-	while (fs_err.state!=ESTATE_NONE)
-		nanosleep(&t,NULL);  /* until situation clear, wait (and don't waste cpu-time) */
+	fs_err.err = errno;
+	fs_err.message = message;
+	fs_err.file = file;
+	fs_err.state = ESTATE_RISE;
+	printf("[FS ERROR]: %s %s %s", message, file, strerror(errno));
+	while (fs_err.state != ESTATE_NONE)
+		nanosleep(&t, NULL); /* until situation clear, wait (and don't waste cpu-time) */
 	return(0);
 }

Modified: trunk/apps/s3dfm/icon.c
===================================================================
--- trunk/apps/s3dfm/icon.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/icon.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,19 +22,19 @@
  */
 
 #include "s3dfm.h"
-#include <stdio.h> 	 /* printf() */
-#include <math.h>	 /* sin(),cos() */
+#include <stdio.h>   /* printf() */
+#include <math.h>  /* sin(),cos() */
 #include <string.h>  /* strlen() */
 #include <stdlib.h>  /* memcpy() */
-float icon_colors[T_TYPENUM][12]={
+float icon_colors[T_TYPENUM][12] = {
 	/* T_DUNO */
-	{	0,0,0.5,1.0,
-		0,0,0.5,1.0,
-		0,0,0.5,1.0 },
+	{ 0, 0, 0.5, 1.0,
+		0, 0, 0.5, 1.0,
+		0, 0, 0.5, 1.0 },
 	/* T_FOLDER */
-	{	0.4,0.4,0,1.0,
-	  0.4,0.4,0,1.0,
-	  0.4,0.4,0,1.0}
+	{ 0.4, 0.4, 0, 1.0,
+	  0.4, 0.4, 0, 1.0,
+	  0.4, 0.4, 0, 1.0}
 };
 
 /* gives another color for the focused item */
@@ -42,64 +42,64 @@
 {
 	float color[12];
 	int i;
-	memcpy(color,icon_colors[dir->type],sizeof(color));
-	if (on) for (i=0;i<3;i++) {
-			color[i*4 + 0]+=0.3;
-			color[i*4 + 1]+=0.3;
-			color[i*4 + 2]+=0.3;
+	memcpy(color, icon_colors[dir->type], sizeof(color));
+	if (on) for (i = 0;i < 3;i++) {
+			color[i*4 + 0] += 0.3;
+			color[i*4 + 1] += 0.3;
+			color[i*4 + 2] += 0.3;
 		}
-	s3d_pep_materials_a(dir->oid,color,1);
+	s3d_pep_materials_a(dir->oid, color, 1);
 }
 /* draws icon dir */
 int icon_draw(t_node *dir)
 {
-	float vertices[]={	-1,-0.5,0,
-	                   -1, 0.5,0,
-	                   1, 0.5,0,
-	                   1,-0.5,0,
-	                   -1,-0.5,-1,
-	                   -1, 0.5,-1,
-	                   1, 0.5,-1,
-	                   1,-0.5,-1
-	                 };
-	uint32_t polys[]={
-		1,3,0,0,				2,3,1,0,
-		5,6,2,0,				1,5,2,0,
-		2,6,7,0,				2,7,3,0,
-		0,3,7,0,				0,7,4,0,
-		5,1,0,0,				5,0,4,0
+	float vertices[] = { -1, -0.5, 0,
+	                     -1, 0.5, 0,
+	                     1, 0.5, 0,
+	                     1, -0.5, 0,
+	                     -1, -0.5, -1,
+	                     -1, 0.5, -1,
+	                     1, 0.5, -1,
+	                     1, -0.5, -1
+	                   };
+	uint32_t polys[] = {
+		1, 3, 0, 0,    2, 3, 1, 0,
+		5, 6, 2, 0,    1, 5, 2, 0,
+		2, 6, 7, 0,    2, 7, 3, 0,
+		0, 3, 7, 0,    0, 7, 4, 0,
+		5, 1, 0, 0,    5, 0, 4, 0
 	};
 	float len;
 	/* find position for the new block in our directory box */
 	/* create the block */
-	dir->oid=s3d_new_object();
-	s3d_push_vertices(dir->oid,vertices,8);
-	s3d_push_materials_a(dir->oid,icon_colors[dir->type],1);
-	s3d_push_polygons(dir->oid,polys,10);
+	dir->oid = s3d_new_object();
+	s3d_push_vertices(dir->oid, vertices, 8);
+	s3d_push_materials_a(dir->oid, icon_colors[dir->type], 1);
+	s3d_push_polygons(dir->oid, polys, 10);
 
 	/* draw and position the string */
-	if (dir->objs.str==-1) {
-		dir->objs.str=s3d_draw_string(dir->name,&len);
-		if (len<2) len=2;
-		dir->objs.strlen=len;
-	} else len=dir->objs.strlen;
-	s3d_scale(dir->objs.str,(float)1.8/len);
-	s3d_translate(dir->objs.str,-0.9,-0.3,0.1);
-	s3d_rotate(dir->objs.str,0,0,0);
-	s3d_link(dir->objs.str,dir->oid);
-	dir->disp=D_ICON;
+	if (dir->objs.str == -1) {
+		dir->objs.str = s3d_draw_string(dir->name, &len);
+		if (len < 2) len = 2;
+		dir->objs.strlen = len;
+	} else len = dir->objs.strlen;
+	s3d_scale(dir->objs.str, (float)1.8 / len);
+	s3d_translate(dir->objs.str, -0.9, -0.3, 0.1);
+	s3d_rotate(dir->objs.str, 0, 0, 0);
+	s3d_link(dir->objs.str, dir->oid);
+	dir->disp = D_ICON;
 	return(0);
 }
 int icon_undisplay(t_node *dir)
 {
-	if (dir->oid!=-1) {
+	if (dir->oid != -1) {
 		s3d_del_object(dir->oid);
-		dir->oid=-1;
+		dir->oid = -1;
 	}
-	if (dir->objs.str!=-1) {
+	if (dir->objs.str != -1) {
 		s3d_del_object(dir->objs.str);
-		dir->objs.str=-1;
+		dir->objs.str = -1;
 	}
-	dir->disp=0;
+	dir->disp = 0;
 	return(0);
 }

Modified: trunk/apps/s3dfm/main.c
===================================================================
--- trunk/apps/s3dfm/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,36 +24,36 @@
 
 #include "s3dfm.h"
 #include <string.h>  /*  strlen(), strncmp(), strrchr() */
-#include <time.h>	/* nanosleep() */
-static struct timespec t= {
-	0,33*1000*1000
+#include <time.h> /* nanosleep() */
+static struct timespec t = {
+	0, 33*1000*1000
 };
-t_node root,cam,*focus;
+t_node root, cam, *focus;
 
 void mainloop()
 {
 	ani_mate();
 	s3dw_ani_mate();
 	window_fsani();
-	nanosleep(&t,NULL);
+	nanosleep(&t, NULL);
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
 
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,event_click);
-	s3d_set_callback(S3D_EVENT_OBJ_INFO,event_oinfo);
-	s3d_set_callback(S3D_EVENT_KEY,event_key);
-	if (!s3d_init(&argc,&argv,"s3dfm")) {
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK, event_click);
+	s3d_set_callback(S3D_EVENT_OBJ_INFO, event_oinfo);
+	s3d_set_callback(S3D_EVENT_KEY, event_key);
+	if (!s3d_init(&argc, &argv, "s3dfm")) {
 		s3d_select_font("vera");
 
 		node_init(&cam); /* a virtual object, just to push the cam throu our animation stack */
-		cam.oid=0;
+		cam.oid = 0;
 		/* set up file system representation */
 		node_init(&root);
-		strncpy(root.name,"/",M_NAME);
-		focus=&root;
-		root.dscale=0.1;
-		root.type=T_FOLDER;
+		strncpy(root.name, "/", M_NAME);
+		focus = &root;
+		root.dscale = 0.1;
+		root.type = T_FOLDER;
 		parse_dir(&root);
 		box_draw(&root);
 		ani_doit(&root);

Modified: trunk/apps/s3dfm/node.c
===================================================================
--- trunk/apps/s3dfm/node.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/node.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,43 +22,43 @@
  */
 
 #include "s3dfm.h"
-#include <string.h>	/* strncpy(), index() */
-#include <stdio.h>	/* printf() */
+#include <string.h> /* strncpy(), index() */
+#include <stdio.h> /* printf() */
 #include <stdlib.h> /* free() */
 /* find the node to a path, return NULL if not parsed yet */
 t_node *node_getbypath(char *path)
 {
 	char p[M_DIR];
-	char *s,*match;
+	char *s, *match;
 	t_node *cur;
 	int i;
 
-	if (path==NULL) return NULL;
-	if (path[0]=='/') {
-		strncpy(p,path,M_DIR-1);
-		s=p+1;
-		cur=&root;
+	if (path == NULL) return NULL;
+	if (path[0] == '/') {
+		strncpy(p, path, M_DIR - 1);
+		s = p + 1;
+		cur = &root;
 	} else return NULL; /* TODO: also process local paths. right now, we are to lazy */
-	p[strlen(p)+1]=0; /* extra terminating 0, to be sure */
-	printf("processing rest of string %s\n",s);
-	match=s;
-	while (*s!=0) { /* while search string is not empty */
-		if ((s=index(s,'/'))!=NULL) {
-			s[0]=0; /* mark the slash with space */
-			s++;	/* move to the next */
+	p[strlen(p)+1] = 0; /* extra terminating 0, to be sure */
+	printf("processing rest of string %s\n", s);
+	match = s;
+	while (*s != 0) { /* while search string is not empty */
+		if ((s = index(s, '/')) != NULL) {
+			s[0] = 0; /* mark the slash with space */
+			s++; /* move to the next */
 		} else {
-			s=match+strlen(match); /* select terminating 0 */
+			s = match + strlen(match); /* select terminating 0 */
 		}
 		/* parse ... */
-		printf("looking for a match for %s, rest is %s\n",match,s);
-		for (i=0;i<cur->n_sub;i++)
-			if (0==strcmp(cur->sub[i]->name,match)) { /* found !! */
-				cur=cur->sub[i]; /* forward */
-				match=s; /* select next */
+		printf("looking for a match for %s, rest is %s\n", match, s);
+		for (i = 0;i < cur->n_sub;i++)
+			if (0 == strcmp(cur->sub[i]->name, match)) { /* found !! */
+				cur = cur->sub[i]; /* forward */
+				match = s; /* select next */
 				break;
 			}
-		if (i==cur->n_sub) {
-			printf("found no match for %s :(\n",match);
+		if (i == cur->n_sub) {
+			printf("found no match for %s :(\n", match);
 			return NULL; /* not found */
 		}
 	}
@@ -69,55 +69,55 @@
 {
 	int i;
 	t_node *f;
-	if (t->oid==oid)			return(t);
-	if (t->objs.str==oid)		return(t);
-	if (t->objs.close==oid)		return(t);
-	if (t->objs.select==oid)	return(t);
-	if (t->objs.title==oid)		return(t);
-	if (t->objs.titlestr==oid)	return(t);
-	if (t->type==T_FOLDER)
-		for (i=0;i<t->n_sub;i++)
-			if ((f=node_getbyoid(t->sub[i],oid))!=NULL)
+	if (t->oid == oid)   return(t);
+	if (t->objs.str == oid)  return(t);
+	if (t->objs.close == oid)  return(t);
+	if (t->objs.select == oid) return(t);
+	if (t->objs.title == oid)  return(t);
+	if (t->objs.titlestr == oid) return(t);
+	if (t->type == T_FOLDER)
+		for (i = 0;i < t->n_sub;i++)
+			if ((f = node_getbyoid(t->sub[i], oid)) != NULL)
 				return(f);
 	return(NULL);
 }
 /* writes the path of dir into *path. path should be of type path[M_DIR] */
 void node_path(t_node *dir, char *path)
 {
-	if (dir->parent!=NULL) {
-		node_path(dir->parent,path);
-		if (dir->parent->parent!=NULL)
-			mstrncat(path,"/",M_DIR);
-		mstrncat(path,dir->name,M_DIR);
+	if (dir->parent != NULL) {
+		node_path(dir->parent, path);
+		if (dir->parent->parent != NULL)
+			mstrncat(path, "/", M_DIR);
+		mstrncat(path, dir->name, M_DIR);
 	} else
-		mstrncpy(path,dir->name,M_DIR);
+		mstrncpy(path, dir->name, M_DIR);
 }
 /* clear the node */
 int node_init(t_node *dir)
 {
-	dir->parent=NULL;
-	dir->sub=NULL;
-	dir->n_sub=0;
+	dir->parent = NULL;
+	dir->sub = NULL;
+	dir->n_sub = 0;
 
-	dir->oid=-1;
-	dir->objs.str=-1;
-	dir->objs.close=-1;
-	dir->objs.select=-1;
-	dir->objs.title=-1;
-	dir->objs.titlestr=-1;
-	dir->objs.strlen=0;
+	dir->oid = -1;
+	dir->objs.str = -1;
+	dir->objs.close = -1;
+	dir->objs.select = -1;
+	dir->objs.title = -1;
+	dir->objs.titlestr = -1;
+	dir->objs.strlen = 0;
 
-	dir->disp=D_NONE;
-	dir->parsed=0;
+	dir->disp = D_NONE;
+	dir->parsed = 0;
 
-	dir->pindex=-1;
-	dir->check=0;
-	dir->dirs_opened=0;
-	dir->type=T_DUNO;
-	dir->px=dir->py=dir->pz=0.0;
-	dir->dpx=dir->dpy=dir->dpz=0.0;
-	dir->scale=dir->dscale=1.0;
-	dir->detached=0;
+	dir->pindex = -1;
+	dir->check = 0;
+	dir->dirs_opened = 0;
+	dir->type = T_DUNO;
+	dir->px = dir->py = dir->pz = 0.0;
+	dir->dpx = dir->dpy = dir->dpz = 0.0;
+	dir->scale = dir->dscale = 1.0;
+	dir->detached = 0;
 
 	return(0);
 }
@@ -134,25 +134,25 @@
 	default:
 		return(-1);
 	}
-	dir->disp=0;
+	dir->disp = 0;
 }
 
 /* delete a node and all its kids internally, remove the graphics, reorder the parents etc ... */
 int node_delete(t_node *dir)
 {
 	int i;
-	if (dir->parent==NULL) {
+	if (dir->parent == NULL) {
 		printf("won't delete root window!\n");
 		return(-1);
 	}
 	/* delete all the kids */
-	if (dir->n_sub>0) {
-		for (i=0;i<dir->n_sub;i++)
+	if (dir->n_sub > 0) {
+		for (i = 0;i < dir->n_sub;i++)
 			node_delete(dir->sub[i]);
 		free(dir->sub);
 	}
 	/* move focus upward, this should go up with the recursion */
-	if (focus==dir)	focus_set(dir->parent); /* do this before deleting the contents, its better ... */
+	if (focus == dir) focus_set(dir->parent); /* do this before deleting the contents, its better ... */
 	switch (dir->disp) {
 	case D_DIR:
 		box_undisplay(dir);
@@ -160,7 +160,7 @@
 		icon_undisplay(dir);
 	}
 
-	if (-1!=(i=ani_onstack(dir))) ani_del(i); /* tell animation stack too */
+	if (-1 != (i = ani_onstack(dir))) ani_del(i); /* tell animation stack too */
 	free(dir);
 	return(0);
 }
@@ -168,23 +168,23 @@
 void node_select(t_node *dir)
 {
 
-	dir->detached=dir->detached?0:1; /* swapping, not sure if !dir->detached would do the same .. */
+	dir->detached = dir->detached ? 0 : 1; /* swapping, not sure if !dir->detached would do the same .. */
 	switch (dir->disp) {
 	case D_DIR:
-		if (focus!=dir) {
-			dir->detached=dir->detached?0:1; /* swap again, we actually don't want to have it detachedf now. */
+		if (focus != dir) {
+			dir->detached = dir->detached ? 0 : 1; /* swap again, we actually don't want to have it detachedf now. */
 			focus_set(dir);
 		}
-		if (dir->parent!=NULL)
+		if (dir->parent != NULL)
 			box_order_subdirs(dir->parent);
 		break;
 	case D_ICON:
-		if (dir->type==T_FOLDER) {
-			dir->detached=0;
+		if (dir->type == T_FOLDER) {
+			dir->detached = 0;
 			if (!parse_dir(dir))
 				box_expand(dir);
 		} else {
-			dir->pz=dir->detached*0.2+1.0;
+			dir->pz = dir->detached * 0.2 + 1.0;
 			ani_add(dir);
 		}
 		focus_set(dir);
@@ -196,16 +196,16 @@
 {
 	switch (node->disp) {
 	case D_DIR:
-		box_focus_color(node,on);
+		box_focus_color(node, on);
 		break;
 	case D_ICON:
-		icon_focus_color(node,on);
+		icon_focus_color(node, on);
 		break;
 	}
 }
 /* get the directory of a node */
 t_node *node_getdir(t_node *node)
 {
-	if (node->type==T_FOLDER) return(node);
+	if (node->type == T_FOLDER) return(node);
 	else return(node->parent);
 }

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/parse.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,83 +26,83 @@
 #include <stdio.h>   /*  printf() */
 #include <dirent.h>  /*  dirent */
 #include <string.h>  /*  strlen(), strncmp(), strrchr() */
-#include <stdlib.h>	 /*  realloc () */
+#include <stdlib.h>  /*  realloc () */
 
 
 int parse_dir(t_node *dir)
 {
 	struct dirent **namelist;
-	int n,i;
+	int n, i;
 	int oldn;
-	DIR	 *dirhd=NULL;
-	char *ext,*nstr=NULL;
+	DIR  *dirhd = NULL;
+	char *ext, *nstr = NULL;
 	char path[M_DIR];
 	char ndir[M_DIR];
 
-	printf("parse_dir( %s )\n",dir->name);
-	node_path(dir,path);
-	for (i=0;i<dir->n_sub;i++) {
-		dir->sub[i]->check=1;
+	printf("parse_dir( %s )\n", dir->name);
+	node_path(dir, path);
+	for (i = 0;i < dir->n_sub;i++) {
+		dir->sub[i]->check = 1;
 	}
 	n = i = scandir(path, &namelist, 0, alphasort);
 	if (n < 0) {
 		window_fs_errno(path);
 		return(-1);
 	} else {
-		oldn=dir->n_sub;
+		oldn = dir->n_sub;
 		while (n--) {
 			nstr = namelist[n]->d_name;
 			/* setup kids in the sub */
-			for (i=0;i<oldn;i++) /* see if it's already there */
+			for (i = 0;i < oldn;i++) /* see if it's already there */
 				if (dir->sub[i])
-					if (0==strcmp(namelist[n]->d_name,dir->sub[i]->name))
+					if (0 == strcmp(namelist[n]->d_name, dir->sub[i]->name))
 						break;
-			if ((0!=strcmp(nstr,".")) && (0!=strcmp(nstr,".."))) { /* we don't care about those */
-				if (i==oldn) {	/* it's new, add it, initialize it ... */
-					i=dir->n_sub;
+			if ((0 != strcmp(nstr, ".")) && (0 != strcmp(nstr, ".."))) { /* we don't care about those */
+				if (i == oldn) { /* it's new, add it, initialize it ... */
+					i = dir->n_sub;
 					/* i now holds the right index in sub, so we use dir->sub[i]
 					 * to reference the new item now... */
 					dir->n_sub++;
-					dir->sub = realloc( dir->sub , dir->n_sub * sizeof(t_node *) );
+					dir->sub = realloc(dir->sub , dir->n_sub * sizeof(t_node *));
 					dir->sub[i] = malloc(sizeof(t_node));
 					node_init(dir->sub[i]);
-					strncpy(dir->sub[i]->name,nstr,M_NAME);
+					strncpy(dir->sub[i]->name, nstr, M_NAME);
 					dir->sub[i]->parent = dir;
 				}
 				/* find out the filetype ... very simple */
-				dir->sub[i]->type=T_DUNO;
-				dir->sub[i]->pindex=i;
-				ext=strrchr(nstr,'.');
-				strncpy(ndir,path,M_DIR);
-				strncat(ndir,namelist[n]->d_name,M_DIR);
-				if ((namelist[n]->d_type==DT_DIR) || ((namelist[n]->d_type==DT_UNKNOWN)))
-					if ((dirhd=opendir(ndir))!=NULL) {
-						dir->sub[i]->type=T_FOLDER;
+				dir->sub[i]->type = T_DUNO;
+				dir->sub[i]->pindex = i;
+				ext = strrchr(nstr, '.');
+				strncpy(ndir, path, M_DIR);
+				strncat(ndir, namelist[n]->d_name, M_DIR);
+				if ((namelist[n]->d_type == DT_DIR) || ((namelist[n]->d_type == DT_UNKNOWN)))
+					if ((dirhd = opendir(ndir)) != NULL) {
+						dir->sub[i]->type = T_FOLDER;
 						closedir(dirhd);
 					} /*else if (ext!=NULL)
-					   {
-						   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))		   dir->sub[i]->type=T_GEOMETRY;
-						   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))	   dir->sub[i]->type=T_MUSIC;
-						   }	*/
-				dir->sub[i]->check=0; /* check=0 means we've already processed this item */
+        {
+         if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))     dir->sub[i]->type=T_GEOMETRY;
+         else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))    dir->sub[i]->type=T_MUSIC;
+         } */
+				dir->sub[i]->check = 0; /* check=0 means we've already processed this item */
 			}
 			free(namelist[n]);
 		}
 		free(namelist);
-		dir->check=0;
-		for (i=0;i<dir->n_sub;i++)
+		dir->check = 0;
+		for (i = 0;i < dir->n_sub;i++)
 			if (dir->sub[i]->check) {
 				/* not checked yet... that means the item is not in the reparsed directory, ie vanished.
 				 * so we're removing it from our queue */
 				node_delete(dir->sub[i]);
 				dir->n_sub--;
-				dir->sub[i]=dir->sub[dir->n_sub]; /* exchange with the last one */
-				dir->sub[i]->pindex=i;
-				dir->check=1;
+				dir->sub[i] = dir->sub[dir->n_sub]; /* exchange with the last one */
+				dir->sub[i]->pindex = i;
+				dir->check = 1;
 			}
 		/* if we removed something, then shrink the buffer accordingly .. */
-		if (dir->check)		dir->sub = realloc( dir->sub , dir->n_sub * sizeof(t_node *) );
-		dir->parsed=1;
+		if (dir->check)  dir->sub = realloc(dir->sub , dir->n_sub * sizeof(t_node *));
+		dir->parsed = 1;
 	}
 	return(0);
 }

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/s3dfm.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,69 +24,69 @@
 
 #include <s3d.h>
 #include <s3dw.h>
-#include <stdlib.h>		/* uintXX_t */
-#define T_DUNO		0
-#define T_FOLDER	1
-#define T_TYPENUM	2
+#include <stdlib.h>  /* uintXX_t */
+#define T_DUNO  0
+#define T_FOLDER 1
+#define T_TYPENUM 2
 
-#define M_DIR		512
-#define M_NAME		256
+#define M_DIR  512
+#define M_NAME  256
 
 /* total height of the block */
-#define BOXHEIGHT	1.2
-#define BHP			1.001
-#define BHH			BOXHEIGHT+0.001
+#define BOXHEIGHT 1.2
+#define BHP   1.001
+#define BHH   BOXHEIGHT+0.001
 /* how much should detached dirs move away from parent block */
-#define DETHEIGHT	0.3
+#define DETHEIGHT 0.3
 
 /* maximum size of the animation stack */
-#define MAXANI		1024
-#define ZOOMS 		10
+#define MAXANI  1024
+#define ZOOMS   10
 /* zoomspeed */
 
 struct _t_node {
-	char 			 name[M_NAME];						/* name (e.g. file name) */
-	struct _t_node 	*parent;							/* parent node */
-	struct _t_node 	**sub;								/* list of nodes  (if it's a subdir)*/
-	int 			 n_sub;								/* number of nodes in list ( = -1 for normal or not-expanded files) */
-	int 			 dirs_opened;						/* how many dirs are opened/displayed */
-	float 			 px ,py ,pz ,scale;					/* state after animation */
-	float 			 dpx,dpy,dpz,dscale;				/* current state in animation */
-	int 			 type;								/* type, determined by extension or file type like dir, pipe, link etc */
-	int 			 disp;								/* the type of how the node is displayed currently */
-#define D_NONE		0
-#define D_ICON		1
-#define D_DIR		2
-	int				 parsed,detached;					/* Flags for parsed/detached (selected) nodes ... */
-	int 			 oid;								/* main oid, e.g the block or icons oid */
-	int 			 pindex;							/* the index in parents structure */
-	struct 			 {
+	char     name[M_NAME];      /* name (e.g. file name) */
+	struct _t_node  *parent;       /* parent node */
+	struct _t_node  **sub;        /* list of nodes  (if it's a subdir)*/
+	int     n_sub;        /* number of nodes in list ( = -1 for normal or not-expanded files) */
+	int     dirs_opened;      /* how many dirs are opened/displayed */
+	float     px , py , pz , scale;  /* state after animation */
+	float     dpx, dpy, dpz, dscale; /* current state in animation */
+	int     type;        /* type, determined by extension or file type like dir, pipe, link etc */
+	int     disp;        /* the type of how the node is displayed currently */
+#define D_NONE  0
+#define D_ICON  1
+#define D_DIR  2
+	int     parsed, detached;    /* Flags for parsed/detached (selected) nodes ... */
+	int     oid;        /* main oid, e.g the block or icons oid */
+	int     pindex;       /* the index in parents structure */
+	struct     {
 		/* some objects which might be used ... if not, should be -1 */
-		int 		 close,select,title,titlestr; /* box decorations. */
-		int 		 str;						  /* the name of the nodeas s3d object */
-		float		 strlen;					  /* the length of this string */
+		int    close, select, title, titlestr; /* box decorations. */
+		int    str;        /* the name of the nodeas s3d object */
+		float   strlen;       /* the length of this string */
 
 
-	} 				 objs;
-	int 			 check;							    /* check marker, for internal things */
+	}      objs;
+	int     check;           /* check marker, for internal things */
 };
 struct _t_file {
 	char *name;
-	int size,state;
+	int size, state;
 	struct _t_node *anode;
 };
 enum {
-	STATE_NONE, 		/* nothing happned */
-	STATE_INUSE, 		/* currently processing */
-	STATE_FINISHED, 	/* file operation finished */
-	STATE_CLEANED		/* cleaned (e.g. reordered the item */
+	STATE_NONE,   /* nothing happned */
+	STATE_INUSE,   /* currently processing */
+	STATE_FINISHED,  /* file operation finished */
+	STATE_CLEANED  /* cleaned (e.g. reordered the item */
 };
 struct _filelist {
 	struct _t_file *p;
 	int n;
 };
 struct fs_error {
-	int err,state;
+	int err, state;
 	char *message, *file;
 };
 enum {
@@ -98,11 +98,11 @@
 };
 typedef struct _filelist filelist;
 typedef struct _t_node   t_node;
-typedef struct _t_file	 t_file;
+typedef struct _t_file  t_file;
 
 
-extern t_node root,cam; /* some global objects */
-extern t_node *focus;	/* the focused object */
+extern t_node root, cam; /* some global objects */
+extern t_node *focus; /* the focused object */
 extern struct fs_error fs_err;
 
 enum {
@@ -116,82 +116,82 @@
 extern int fs_lock;
 
 /* animation.c */
-int 		 ani_onstack(t_node *f);
-void 		 ani_add(t_node *f);
-void 		 ani_del(int i);
-void 		 ani_doit(t_node *f);
-void 		 ani_finish(t_node *f, int i);
-void 		 ani_iterate(t_node *f);
-int 		 ani_check(t_node *f);
-void 		 ani_mate();
+int    ani_onstack(t_node *f);
+void    ani_add(t_node *f);
+void    ani_del(int i);
+void    ani_doit(t_node *f);
+void    ani_finish(t_node *f, int i);
+void    ani_iterate(t_node *f);
+int    ani_check(t_node *f);
+void    ani_mate();
 /* box.c */
-void	 	 box_draw(t_node *dir);
-void 	 	 box_draw_icons(t_node *dir);
-int 		 box_undisplay(t_node *dir);
-void  		 box_order_icons(t_node *dir);
-void	 	 box_sidelabel(t_node *dir);
-int 		 box_buildblock(t_node *dir);
-void 		 box_order_subdirs(t_node *dir);
-int 		 box_expand(t_node *dir);
-int 		 box_unexpand(t_node *dir);
-int 		 box_close(t_node *dir,int force);
-void 		 box_focus_color(t_node *dir, int on);
+void    box_draw(t_node *dir);
+void     box_draw_icons(t_node *dir);
+int    box_undisplay(t_node *dir);
+void     box_order_icons(t_node *dir);
+void    box_sidelabel(t_node *dir);
+int    box_buildblock(t_node *dir);
+void    box_order_subdirs(t_node *dir);
+int    box_expand(t_node *dir);
+int    box_unexpand(t_node *dir);
+int    box_close(t_node *dir, int force);
+void    box_focus_color(t_node *dir, int on);
 /* dialog.c */
-void		 close_win(s3dw_widget *button);
-void		 window_help();
-void 		 window_fs(s3dw_widget *button);
-void		 window_fs_another();
-void		 window_fs_nothing();
-void		 window_fs_errno(char *errmsg);
-void		 window_fs_abort(s3dw_widget *button);
-void		 window_copy(char *path);
-void		 window_fs_mkdir(s3dw_widget *button);
-void		 window_mkdir(char *path);
-void		 window_move(char *path);
-void		 window_info(char *path);
-void		 window_fsani();
-void 		 window_unlink();
+void   close_win(s3dw_widget *button);
+void   window_help();
+void    window_fs(s3dw_widget *button);
+void   window_fs_another();
+void   window_fs_nothing();
+void   window_fs_errno(char *errmsg);
+void   window_fs_abort(s3dw_widget *button);
+void   window_copy(char *path);
+void   window_fs_mkdir(s3dw_widget *button);
+void   window_mkdir(char *path);
+void   window_move(char *path);
+void   window_info(char *path);
+void   window_fsani();
+void    window_unlink();
 /* event.c */
-int 		 event_click(struct s3d_evt *evt);
-int			 event_key(struct s3d_evt *evt);
-int			 event_oinfo(struct s3d_evt *hrmz);
+int    event_click(struct s3d_evt *evt);
+int    event_key(struct s3d_evt *evt);
+int    event_oinfo(struct s3d_evt *hrmz);
 /* focus.c */
-void 		 focus_by_key(int keysym);
-float		 focus_get_scale(t_node *f);
-void 		 focus_set(t_node *f);
+void    focus_by_key(int keysym);
+float   focus_get_scale(t_node *f);
+void    focus_set(t_node *f);
 /* fs.c */
-filelist	 *fl_new(char *path);
-void		 fl_del(filelist *fl);
-void	 	 fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes);
-int			 fs_fl_copy(filelist *fl, char *dest);
-int			 fs_fl_move(filelist *fl, char *dest);
-int			 fs_fl_unlink(filelist *fl);
-void	 	 fs_approx(char *source, int *files, int *dirs, int *bytes);
-int			 fs_copy(char *source, char *dest);
-int			 fs_move(char *source, char *dest);
-int			 fs_unlink(char *dest);
-int 		 fs_error(char *message, char *file);
+filelist  *fl_new(char *path);
+void   fl_del(filelist *fl);
+void    fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes);
+int    fs_fl_copy(filelist *fl, char *dest);
+int    fs_fl_move(filelist *fl, char *dest);
+int    fs_fl_unlink(filelist *fl);
+void    fs_approx(char *source, int *files, int *dirs, int *bytes);
+int    fs_copy(char *source, char *dest);
+int    fs_move(char *source, char *dest);
+int    fs_unlink(char *dest);
+int    fs_error(char *message, char *file);
 /* icon.c */
-int 		 icon_draw(t_node *dir);
-int 		 icon_undisplay(t_node *dir);
-void 		 icon_focus_color(t_node *dir, int on);
+int    icon_draw(t_node *dir);
+int    icon_undisplay(t_node *dir);
+void    icon_focus_color(t_node *dir, int on);
 /* node.c */
-t_node 		*node_getbypath(char *path);
-void 		 node_path(t_node *dir, char *path);
-t_node 		*node_getbyoid(t_node *t, int oid);
-int 		 node_init(t_node *dir);
-int 		 node_delete(t_node *dir);
-int 		 node_undisplay(t_node *dir);
-void		 node_select(t_node *dir);
-void 		 node_focus_color(t_node *node, int on);
-t_node		*node_getdir(t_node *node);
+t_node   *node_getbypath(char *path);
+void    node_path(t_node *dir, char *path);
+t_node   *node_getbyoid(t_node *t, int oid);
+int    node_init(t_node *dir);
+int    node_delete(t_node *dir);
+int    node_undisplay(t_node *dir);
+void   node_select(t_node *dir);
+void    node_focus_color(t_node *node, int on);
+t_node  *node_getdir(t_node *node);
 /* parse.c */
-int 		 parse_dir(t_node *dir);
+int    parse_dir(t_node *dir);
 /* string.c */
-void		 dotted_int(char *s,unsigned int i);
-char 		*dots_at_start(char *str, unsigned int n, t_node *d);
-char		*mstrncat(char *dest, const char *src, int n);
-char		*mstrncpy(char *dest, const char *src, int n);
+void   dotted_int(char *s, unsigned int i);
+char   *dots_at_start(char *str, unsigned int n, t_node *d);
+char  *mstrncat(char *dest, const char *src, int n);
+char  *mstrncpy(char *dest, const char *src, int n);
 /* fly.c */
-int 		 fly_set_absolute_position(t_node *node);
-t_node 		*fly_create_anode(t_node *node);
+int    fly_set_absolute_position(t_node *node);
+t_node   *fly_create_anode(t_node *node);

Modified: trunk/apps/s3dfm/string.c
===================================================================
--- trunk/apps/s3dfm/string.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dfm/string.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -31,73 +31,73 @@
  * adds some dots to the beginning if its too long */
 char *dots_at_start(char *str, unsigned int n, t_node *d)
 {
-	char *s=str;
-	int i,j;
-	i=n-2;
-	s[n-1]=0;
+	char *s = str;
+	int i, j;
+	i = n - 2;
+	s[n-1] = 0;
 	do {
-		j=strlen(d->name)-1;
-		if (NULL!=(d->parent)) {
-			s[i]='/';
+		j = strlen(d->name) - 1;
+		if (NULL != (d->parent)) {
+			s[i] = '/';
 			i--;
 		}
 		while ((i >= 0) && (j >= 0)) {
-			s[i]=d->name[j];
+			s[i] = d->name[j];
 			j--;
 			i--;
 		}
-		if (i<0)
+		if (i < 0)
 			break;
-	} while ((d=d->parent)!=NULL);
-	if (i<0)			s[0]=s[1]='.';
-	else 				s=(char *)s+i+1; /* jump to start of the string */
+	} while ((d = d->parent) != NULL);
+	if (i < 0)   s[0] = s[1] = '.';
+	else     s = (char *)s + i + 1; /* jump to start of the string */
 	return(s);
 
 }
 /* add some dots to an integer value for better readability */
-void dotted_int(char *s,unsigned int i)
+void dotted_int(char *s, unsigned int i)
 {
 	char st[M_DIR];
 	int p;
-	p=0;
-	st[0]=0;
-	while (i>0) {
-		if ((p+1)%4==0) {
-			st[p]='.';
+	p = 0;
+	st[0] = 0;
+	while (i > 0) {
+		if ((p + 1) % 4 == 0) {
+			st[p] = '.';
 			p++;
 		}
-		st[p]=(i%10)+'0';
-		i=i/10;
+		st[p] = (i % 10) + '0';
+		i = i / 10;
 		p++;
 	}
-	if (p>0) p--;
-	st[p+1]=0;
-	for (i=0;i<p+1;i++)
-		s[i]=st[p-i];
-	s[p+1]=0;
+	if (p > 0) p--;
+	st[p+1] = 0;
+	for (i = 0;i < p + 1;i++)
+		s[i] = st[p-i];
+	s[p+1] = 0;
 }
 /* save concatting 2 strings, this version takes argument n
  * as the size of the buffer of dest. */
 char *mstrncat(char *dest, const char *src, int n)
 {
-	int i,j;
-	dest[n-1]=0;						/* for malformed destinations */
-	j=0;
-	for (i=strlen(dest);i<(n-1);i++) {
-		dest[i]=src[j];
-		if (dest[i]==0) break;
+	int i, j;
+	dest[n-1] = 0;    /* for malformed destinations */
+	j = 0;
+	for (i = strlen(dest);i < (n - 1);i++) {
+		dest[i] = src[j];
+		if (dest[i] == 0) break;
 		j++;
 	}
-	for (;i<n;i++)
-		dest[i]=0; /* pad the rest with zero */
+	for (;i < n;i++)
+		dest[i] = 0; /* pad the rest with zero */
 	return(dest);
 }
 /* same as strncpy, but have a terminating zero even if
  * source is too big */
 char *mstrncpy(char *dest, const char *src, int n)
 {
-	strncpy(dest,src,n);
-	dest[n-1]=0;
+	strncpy(dest, src, n);
+	dest[n-1] = 0;
 	return(dest);
 }
 

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/db.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,30 +25,30 @@
 #include "s3dosm.h"
 #include <stdio.h>
 #include <string.h> /* stdup() */
-#include <unistd.h>	/* unlink() */
-#include <stdlib.h>	/* atoi() */
+#include <unistd.h> /* unlink() */
+#include <stdlib.h> /* atoi() */
 static char qbuf[QBUF];
-static int qlen=0;
-static int tagid=1;		/* tagid, incremented with each new object */
+static int qlen = 0;
+static int tagid = 1;  /* tagid, incremented with each new object */
 
 static sqlite3 *db;
-static char *dbFile=NULL;
+static char *dbFile = NULL;
 int db_exec(const char *query, sqlite3_callback callback, void *arg);
 
 /* TODO: remove '' for security reasons */
 void clean_string(char *clean, char *dirty, int n)
 {
 	strncpy(clean, dirty, n);
-	clean[n-1]=0;
+	clean[n-1] = 0;
 }
 
 int db_add_tag(object_t *obj, char *key, char *val)
 {
 	char tagquery[MAXQ];
 	char mkey[MAXQ], mval[MAXQ];
-	clean_string(mkey,key,MAXQ);
-	clean_string(mval,val,MAXQ);
-	snprintf(tagquery,MAXQ,"INSERT INTO tag VALUES (%d, '%s','%s' );",(int)obj->tagid, mkey, mval);
+	clean_string(mkey, key, MAXQ);
+	clean_string(mval, val, MAXQ);
+	snprintf(tagquery, MAXQ, "INSERT INTO tag VALUES (%d, '%s','%s' );", (int)obj->tagid, mkey, mval);
 	db_exec(tagquery, NULL, 0);
 	return(0);
 }
@@ -56,14 +56,14 @@
 int db_insert_node(node_t *node)
 {
 	char addquery[MAXQ];
-	node->base.tagid= tagid++;
+	node->base.tagid = tagid++;
 
-	if (node->base.id==0) /* give own id */
-		snprintf(addquery,MAXQ,"INSERT INTO node (layer_id, latitude, longitude, altitude, visible, tag_id) VALUES (%d, %f, %f, %f, %d, %d);",
-		         (int)node->base.layerid,				node->lat,		node->lon,		node->alt,		node->visible, 		(int)node->base.tagid);
+	if (node->base.id == 0) /* give own id */
+		snprintf(addquery, MAXQ, "INSERT INTO node (layer_id, latitude, longitude, altitude, visible, tag_id) VALUES (%d, %f, %f, %f, %d, %d);",
+		         (int)node->base.layerid,    node->lat,  node->lon,  node->alt,  node->visible, (int)node->base.tagid);
 	else
-		snprintf(addquery,MAXQ,"INSERT INTO node (layer_id, node_id,latitude, longitude, altitude, visible, tag_id) VALUES (%d, %d, %f, %f, %f, %d, %d);",
-		         (int)node->base.layerid,(int)node->base.id,	node->lat,		node->lon,		node->alt,		node->visible, 		(int)node->base.tagid);
+		snprintf(addquery, MAXQ, "INSERT INTO node (layer_id, node_id,latitude, longitude, altitude, visible, tag_id) VALUES (%d, %d, %f, %f, %f, %d, %d);",
+		         (int)node->base.layerid, (int)node->base.id, node->lat,  node->lon,  node->alt,  node->visible, (int)node->base.tagid);
 
 	db_exec(addquery, NULL, 0);
 	return(0);
@@ -72,19 +72,19 @@
 int db_insert_segment(segment_t *seg)
 {
 	char addquery[MAXQ];
-	seg->base.tagid=tagid++;
+	seg->base.tagid = tagid++;
 
 
-	if (seg->base.id==0) { /* give own id */
+	if (seg->base.id == 0) { /* give own id */
 		printf("ugh, segment id is 0!\n");
 		exit(0);
 	}
-	/*	if (seg->base.id==0) / * give own id * /
-			snprintf(addquery,MAXQ,"INSERT INTO segment (layer_id, node_from, node_to, tag_id) VALUES (%d, %d, %d), %d;",
-							(int)seg->base.layerid,				(int)seg->from, (int)seg->to,	tagid );
-		else*/
-	snprintf(addquery,MAXQ,"INSERT INTO segment (layer_id, seg_id, node_from, node_to, tag_id) VALUES (%d, %d, %d, %d, %d);",
-	         (int)seg->base.layerid,(int)seg->base.id,(int)seg->from, (int)seg->to,	(int)seg->base.tagid );
+	/* if (seg->base.id==0) / * give own id * /
+	  snprintf(addquery,MAXQ,"INSERT INTO segment (layer_id, node_from, node_to, tag_id) VALUES (%d, %d, %d), %d;",
+	      (int)seg->base.layerid,    (int)seg->from, (int)seg->to, tagid );
+	 else*/
+	snprintf(addquery, MAXQ, "INSERT INTO segment (layer_id, seg_id, node_from, node_to, tag_id) VALUES (%d, %d, %d, %d, %d);",
+	         (int)seg->base.layerid, (int)seg->base.id, (int)seg->from, (int)seg->to, (int)seg->base.tagid);
 	db_exec(addquery, NULL, 0);
 
 	return(0);
@@ -93,8 +93,8 @@
 int db_insert_way_only(way_t *way)
 {
 	char addquery[MAXQ];
-	way->base.tagid= tagid++;
-	snprintf(addquery,MAXQ,"INSERT INTO way (layer_id, way_id, tag_id) VALUES (%d, %d, %d);",(int)way->base.layerid, (int)way->base.id, (int)way->base.tagid );
+	way->base.tagid = tagid++;
+	snprintf(addquery, MAXQ, "INSERT INTO way (layer_id, way_id, tag_id) VALUES (%d, %d, %d);", (int)way->base.layerid, (int)way->base.id, (int)way->base.tagid);
 	db_exec(addquery, NULL, 0);
 	return(0);
 }
@@ -102,7 +102,7 @@
 int db_insert_way_seg(way_t *way, int seg_n)
 {
 	char addquery[MAXQ];
-	snprintf(addquery,MAXQ,"UPDATE segment SET way_id=%d WHERE seg_id=%d AND layer_id=%d;",(int)way->base.id,seg_n,(int)way->base.layerid );
+	snprintf(addquery, MAXQ, "UPDATE segment SET way_id=%d WHERE seg_id=%d AND layer_id=%d;", (int)way->base.id, seg_n, (int)way->base.layerid);
 	db_exec(addquery, NULL, 0);
 	return(0);
 }
@@ -112,12 +112,12 @@
 	char findquery[MAXQ];
 	char addquery[MAXQ];
 	char clayer[MAXQ];
-	int layerid=-1;
-	clean_string(clayer,layer_name,MAXQ);
+	int layerid = -1;
+	clean_string(clayer, layer_name, MAXQ);
 
 	snprintf(findquery, MAXQ, "SELECT layer_id FROM layer WHERE name='%s';", clayer);
 	db_exec(findquery, db_getint, &layerid);
-	if (layerid==-1) { /* need to add */
+	if (layerid == -1) { /* need to add */
 		snprintf(addquery, MAXQ, "INSERT INTO layer(name) VALUES ('%s');", clayer);
 		db_exec(addquery, NULL, 0);
 		db_flush();
@@ -126,78 +126,78 @@
 	return(layerid);
 }
 
-#define MAGIC	1337 /* just to elevate the nodes a little bit */
-static int found=0;
+#define MAGIC 1337 /* just to elevate the nodes a little bit */
+static int found = 0;
 /* tries to find node coordinates of ip, returns 1 if has found something */
 int db_olsr_check(char *ip, float *pos)
 {
 	char findquery[MAXQ];
 	char clean_ip[16];
 	float p[6];
-	char *s=NULL;
-	clean_string(clean_ip,ip,16);
-	if (NULL!=(s=strchr(clean_ip,'/')))  /* don't process ip's with subnet information */
-		*s=0; /* TERMINATING ZERO!! */
+	char *s = NULL;
+	clean_string(clean_ip, ip, 16);
+	if (NULL != (s = strchr(clean_ip, '/')))  /* don't process ip's with subnet information */
+		*s = 0; /* TERMINATING ZERO!! */
 
 	snprintf(findquery, MAXQ, "SELECT latitude, longitude, altitude FROM node WHERE tag_id=(SELECT tag_id FROM tag WHERE tagkey='ip' AND tagvalue='%s');", clean_ip);
-	found=MAGIC;
+	found = MAGIC;
 	db_exec(findquery, db_getpoint, p);
-	if (found==1) {
-		pos[0]=p[0];
-		pos[1]=p[1];
-		pos[2]=p[2];
-		found=0;
+	if (found == 1) {
+		pos[0] = p[0];
+		pos[1] = p[1];
+		pos[2] = p[2];
+		found = 0;
 		return(1);
 	}
-	found=0;
+	found = 0;
 	return(0);
 }
 
 /* initializes the starting point of nodes  by averaging its lon/lat */
 int db_olsr_node_init(float *pos)
 {
-	found=0;
+	found = 0;
 	db_exec("SELECT AVG(latitude) as latitude, AVG(longitude) as longitude, AVG(altitude) as altitude FROM node WHERE tag_id IN (SELECT tag_id FROM tag WHERE tagkey='ip');", db_getpoint, pos);
-	printf("pos = %3.3f %3.3f %3.3f\n",pos[0],pos[1],pos[2]);
-	return(0);	/* return 1 if something is found, 0 if pos[0] its still 0 */
+	printf("pos = %3.3f %3.3f %3.3f\n", pos[0], pos[1], pos[2]);
+	return(0); /* return 1 if something is found, 0 if pos[0] its still 0 */
 }
 
 
 /* expecting a 3x float vector, returns the points coordinates */
 int db_getpoint(void *data, int argc, char **argv, char **azColName)
 {
-	float lo=0.0,la=0.0,alt=0.0;
-	float *p=data;
+	float lo = 0.0, la = 0.0, alt = 0.0;
+	float *p = data;
 	int i;
-	for (i=0; i<argc; i++) {
+	for (i = 0; i < argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],"longitude"))			lo=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],"latitude"))		la=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],"altitude"))		alt=strtod(argv[i],NULL);
+			if (0 == strcmp(azColName[i], "longitude"))   lo = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], "latitude"))  la = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], "altitude"))  alt = strtod(argv[i], NULL);
 		}
 	}
-	if (lo==0.0)	{
+	if (lo == 0.0) {
 		printf("missing lo\n");
 		exit(0);
 	}
-	if (la==0.0)	{
+	if (la == 0.0) {
 		printf("missing la\n");
 		exit(0);
 	}
-	if (found==MAGIC) alt=2;
-	calc_earth_to_eukl(la,lo,alt,p);
-	p[3]=la;
-	p[4]=lo;
-	p[5]=alt;
-	found=1;
+	if (found == MAGIC) alt = 2;
+	calc_earth_to_eukl(la, lo, alt, p);
+	p[3] = la;
+	p[4] = lo;
+	p[5] = alt;
+	found = 1;
 	return(0);
 }
 
 /* sqlite3-callback to get an integer of the database */
 int db_getint(void *tagid, int argc, char **argv, char **azColName)
 {
-	if (argv[0]!=NULL)
-		*((int *)tagid)=atoi(argv[0]);
+	if (argv[0] != NULL)
+		*((int *)tagid) = atoi(argv[0]);
 	return 0;
 }
 
@@ -205,7 +205,7 @@
 static int db_getstr(void *string, int argc, char **argv, char **azColName)
 {
 	if (argv[0])
-		strncpy((char *)string,argv[0],MAXQ);
+		strncpy((char *)string, argv[0], MAXQ);
 	return(0);
 }
 
@@ -214,16 +214,16 @@
 int db_gettag(int tagid, char *field, char *target)
 {
 	char query[MAXQ];
-	target[0]=0;
-	snprintf(query,MAXQ,"SELECT tagvalue FROM tag WHERE tagkey='%s' AND tag_id=%d;",field,tagid);
-	db_exec(query, db_getstr,target);
-	return(target[0]==0);
+	target[0] = 0;
+	snprintf(query, MAXQ, "SELECT tagvalue FROM tag WHERE tagkey='%s' AND tag_id=%d;", field, tagid);
+	db_exec(query, db_getstr, target);
+	return(target[0] == 0);
 }
 
 int callback(void *NotUsed, int argc, char **argv, char **azColName)
 {
 	int i;
-	for (i=0; i<argc; i++) {
+	for (i = 0; i < argc; i++) {
 		printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
 	}
 	printf("\n");
@@ -234,21 +234,21 @@
 {
 	char *zErrMsg = 0;
 	int rc;
-	if (SQLITE_OK !=(  rc = sqlite3_exec(db, query, callback, arg, &zErrMsg))) {
-		fprintf(stderr,"query: %s\n",query);
+	if (SQLITE_OK != (rc = sqlite3_exec(db, query, callback, arg, &zErrMsg))) {
+		fprintf(stderr, "query: %s\n", query);
 		fprintf(stderr, "SQL error: %s\n", zErrMsg);
 		exit(-1);
 	}
-	return(SQLITE_OK!=rc); /* 0 = okay */
+	return(SQLITE_OK != rc); /* 0 = okay */
 }
 
 /* call this if you're finished with a few stackable operations */
 void db_flush()
 {
-	if (qlen>0)
-		db_really_exec(qbuf,NULL,0);
-	qbuf[0]=0;
-	qlen=0;
+	if (qlen > 0)
+		db_really_exec(qbuf, NULL, 0);
+	qbuf[0] = 0;
+	qlen = 0;
 }
 
 int db_exec(const char *query, sqlite3_callback callback, void *arg)
@@ -257,17 +257,17 @@
 #ifdef DB_STACK
 	if (callback == NULL) { /* we can stack it */
 		int len;
-		len=strlen(query);
-		if (len+qlen>=QBUF)
+		len = strlen(query);
+		if (len + qlen >= QBUF)
 			db_flush();
-		strncat(qbuf,query,QBUF);
-		qlen+=strlen(query);
-		ret=0;
+		strncat(qbuf, query, QBUF);
+		qlen += strlen(query);
+		ret = 0;
 	} else
 #endif
 
 	{
-		ret=db_really_exec(query,callback,arg);		/* pass it to the real function */
+		ret = db_really_exec(query, callback, arg);  /* pass it to the real function */
 	}
 	return(ret);
 }
@@ -275,13 +275,13 @@
 int db_init(char *dbFile)
 {
 	int rc;
-	tagid=1;
-	qbuf[0]=0;		/* clear querybuffer */
-	qlen=0;
+	tagid = 1;
+	qbuf[0] = 0;  /* clear querybuffer */
+	qlen = 0;
 
-	unlink(dbFile);	/* remove if already there */
+	unlink(dbFile); /* remove if already there */
 	rc = sqlite3_open(dbFile, &db);
-	if ( rc ) {
+	if (rc) {
 		fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
 		sqlite3_close(db);
 		return(-1);
@@ -292,7 +292,7 @@
 int db_quit()
 {
 	sqlite3_close(db);
-	if (dbFile!=NULL)
+	if (dbFile != NULL)
 		if (unlink(dbFile))
 			perror("db_quit()");
 	return(0);
@@ -300,7 +300,7 @@
 
 int db_create()
 {
-	db_exec("CREATE TABLE node (layer_id INT, node_id INTEGER , latitude DOUBLE PRECISION, longitude DOUBLE PRECISION, altitude DOUBLE PRECISION, visible BOOLEAN, tag_id INT, s3doid INT, PRIMARY KEY(layer_id,node_id));",NULL,0);
+	db_exec("CREATE TABLE node (layer_id INT, node_id INTEGER , latitude DOUBLE PRECISION, longitude DOUBLE PRECISION, altitude DOUBLE PRECISION, visible BOOLEAN, tag_id INT, s3doid INT, PRIMARY KEY(layer_id,node_id));", NULL, 0);
 	db_exec("CREATE TABLE segment (layer_id INT, seg_id INTEGER, node_from INT, node_to INT, tag_id INT, way_id INT,PRIMARY KEY(layer_id,seg_id));", NULL, 0);
 	db_exec("CREATE TABLE way (layer_id INTEGER, way_id INTEGER, tag_id INT, s3doid INT, PRIMARY KEY(layer_id,way_id));", NULL, 0);
 	db_exec("CREATE TABLE layer (layer_id INTEGER, name TEXT, PRIMARY KEY(layer_id));", NULL, 0);

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/draw.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,107 +22,107 @@
  */
 #include "s3dosm.h"
 #include <s3d.h>
-#include <math.h>	/* sin(), cos() */
-#include <stdio.h>	/* printf() */
-#include <string.h>	/* strcmp() */
+#include <math.h> /* sin(), cos() */
+#include <stdio.h> /* printf() */
+#include <string.h> /* strcmp() */
 #include <stdlib.h> /* atoi(),malloc(), calloc(), free() */
 
 static float temp;
-#define		V_COPY(a,b)		a[0]=b[0];	a[1]=b[1];	a[2]=b[2];
-#define 	V_ADD(a,b,c)	c[0]=a[0]+b[0];	c[1]=a[1]+b[1];	c[2]=a[2]+b[2];
-#define 	V_SUB(a,b,c)	c[0]=a[0]-b[0];	c[1]=a[1]-b[1];	c[2]=a[2]-b[2];
-#define		V_DOT(a,b)		a[0]*b[0] + a[1]*b[1] + a[2] * b[2]
-#define		V_CROSS(a,b,c)	c[0]=a[1]*b[2] - a[2]*b[1];		c[1]=a[2]*b[0] - a[0]*b[2]; 	c[2]=a[0]*b[1] - a[1]*b[0];
-#define		V_LEN(a)		sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2])
-#define		V_SCAL(a,s)		a[0]=s*a[0];	a[1]=s*a[1];	a[2]=s*a[2];
-#define		V_NORM(a)		temp=V_LEN(a); V_SCAL(a,1/temp);
+#define  V_COPY(a,b)  a[0]=b[0]; a[1]=b[1]; a[2]=b[2];
+#define  V_ADD(a,b,c) c[0]=a[0]+b[0]; c[1]=a[1]+b[1]; c[2]=a[2]+b[2];
+#define  V_SUB(a,b,c) c[0]=a[0]-b[0]; c[1]=a[1]-b[1]; c[2]=a[2]-b[2];
+#define  V_DOT(a,b)  a[0]*b[0] + a[1]*b[1] + a[2] * b[2]
+#define  V_CROSS(a,b,c) c[0]=a[1]*b[2] - a[2]*b[1];  c[1]=a[2]*b[0] - a[0]*b[2];  c[2]=a[0]*b[1] - a[1]*b[0];
+#define  V_LEN(a)  sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2])
+#define  V_SCAL(a,s)  a[0]=s*a[0]; a[1]=s*a[1]; a[2]=s*a[2];
+#define  V_NORM(a)  temp=V_LEN(a); V_SCAL(a,1/temp);
 
 
-static int num_max;		/* how many results in our query? to calculate pecent done ... */
-static int num_done;	/* how many already done */
+static int num_max;  /* how many results in our query? to calculate pecent done ... */
+static int num_done; /* how many already done */
 
-static int lastid=-1;
+static int lastid = -1;
 /* list element of a segment which is on our way */
 struct waylist {
-	int node_from,node_to;
-	int node_from_int,node_to_int;
+	int node_from, node_to;
+	int node_from_int, node_to_int;
 	int seg_id;
-	int node_from_l,node_from_r;	/* vertex id's for corners */
-	int node_to_l,node_to_r;
+	int node_from_l, node_from_r; /* vertex id's for corners */
+	int node_to_l, node_to_r;
 };
 /* list element of a node which is to be drawn */
 struct nodelist {
-	int node_id;			/* (external counting) */
-	float la,lo,alt;		/* earth coords */
-	float x[3];				/* euclid coords */
+	int node_id;   /* (external counting) */
+	float la, lo, alt;  /* earth coords */
+	float x[3];    /* euclid coords */
 	float normal[3];
 	float len;
 };
 /* list element for adjacent nodes */
 struct adjlist {
-	int node_id;			/* node to which the segment leads to */
-	int seg_id;				/* segment which is involved to the node (both internal counting) */
+	int node_id;   /* node to which the segment leads to */
+	int seg_id;    /* segment which is involved to the node (both internal counting) */
 };
 
-struct waylist 	*waylist_p=NULL;
-struct nodelist	*nodelist_p=NULL;
-struct adjlist	*adjlist_p=NULL;
-int				nodelist_n=0;
-int				adjlist_n=0;
-int 			waylist_n=0;
-int 			waylist_bufn=0;
+struct waylist  *waylist_p = NULL;
+struct nodelist *nodelist_p = NULL;
+struct adjlist *adjlist_p = NULL;
+int    nodelist_n = 0;
+int    adjlist_n = 0;
+int    waylist_n = 0;
+int    waylist_bufn = 0;
 
 
 void calc_earth_to_eukl(float lat, float lon, float alt, float *x)
 {
-	float la,lo;
-	la=lat*M_PI/180.0;
-	lo=lon*M_PI/180.0;
-	x[0]=(ESIZE+alt)*sin(lo) *cos(la);
-	x[1]=(ESIZE+alt)*			sin(la);
-	x[2]=(ESIZE+alt)*cos(lo) *cos(la);
+	float la, lo;
+	la = lat * M_PI / 180.0;
+	lo = lon * M_PI / 180.0;
+	x[0] = (ESIZE + alt) * sin(lo) * cos(la);
+	x[1] = (ESIZE + alt) *   sin(la);
+	x[2] = (ESIZE + alt) * cos(lo) * cos(la);
 }
 int draw_icon(void *data, int argc, char **argv, char **azColName)
 {
-	int i,tagid=-1,oid;
-	int nodeid=-1, layerid=-1;
-	/*	char query[MAXQ];*/
+	int i, tagid = -1, oid;
+	int nodeid = -1, layerid = -1;
+	/* char query[MAXQ];*/
 	char s[MAXQ];
 	float la, lo, alt;
 	float x[3];
-	la=lo=alt=0.0;
+	la = lo = alt = 0.0;
 	num_done++;
-	for (i=0; i<argc; i++) {
+	for (i = 0; i < argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],"longitude"))			lo=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],"latitude"))		la=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],"altitude"))		alt=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],"tag_id")) 			tagid=atoi(argv[i]);
-			else if (0==strcmp(azColName[i],"node_id")) 		nodeid=atoi(argv[i]);
-			else if (0==strcmp(azColName[i],"layer_id")) 		layerid=atoi(argv[i]);
+			if (0 == strcmp(azColName[i], "longitude"))   lo = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], "latitude"))  la = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], "altitude"))  alt = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], "tag_id"))    tagid = atoi(argv[i]);
+			else if (0 == strcmp(azColName[i], "node_id"))   nodeid = atoi(argv[i]);
+			else if (0 == strcmp(azColName[i], "layer_id"))   layerid = atoi(argv[i]);
 		}
 	}
-	if (0==db_gettag(tagid, "amenity",s)) {
-		oid=-1;
-		if (0==strcmp(s,"wifi")) {					/* some wifi icon */
-			if (0==db_gettag(tagid, "wifi_type",s)) {
-				if (0==strcmp(s,"infrastructure")) {	/* access point */
-					if (0==db_gettag(tagid, "wifi_wep",s)) {
-						if (0==strcmp(s,"true"))	oid=s3d_clone(icons[ICON_AP_WPA].oid);
-						else						oid=s3d_clone(icons[ICON_AP_OPEN].oid);
-					} else oid=s3d_clone(icons[ICON_AP_OPEN].oid);	/* assuming open ap */
+	if (0 == db_gettag(tagid, "amenity", s)) {
+		oid = -1;
+		if (0 == strcmp(s, "wifi")) {  /* some wifi icon */
+			if (0 == db_gettag(tagid, "wifi_type", s)) {
+				if (0 == strcmp(s, "infrastructure")) { /* access point */
+					if (0 == db_gettag(tagid, "wifi_wep", s)) {
+						if (0 == strcmp(s, "true")) oid = s3d_clone(icons[ICON_AP_WPA].oid);
+						else      oid = s3d_clone(icons[ICON_AP_OPEN].oid);
+					} else oid = s3d_clone(icons[ICON_AP_OPEN].oid); /* assuming open ap */
 				}
 			}
 		}
-		if (oid!=-1) {
-			calc_earth_to_eukl(la,lo,0,x);
-			s3d_translate(oid,x[0],x[1],x[2]);
-			s3d_rotate(oid,(90-la),lo,0);
-			s3d_link(oid,oidy);
-			s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			load_update_status((100.0*num_done)/(float)num_max);
-			/*			snprintf(query,MAXQ,"UPDATE node SET s3doid=%d WHERE node_id=%d AND layer_id=%d;",oid,nodeid,layerid);
-						db_exec(query, NULL, 0);*/
+		if (oid != -1) {
+			calc_earth_to_eukl(la, lo, 0, x);
+			s3d_translate(oid, x[0], x[1], x[2]);
+			s3d_rotate(oid, (90 - la), lo, 0);
+			s3d_link(oid, oidy);
+			s3d_flags_on(oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			load_update_status((100.0*num_done) / (float)num_max);
+			/*   snprintf(query,MAXQ,"UPDATE node SET s3doid=%d WHERE node_id=%d AND layer_id=%d;",oid,nodeid,layerid);
+			   db_exec(query, NULL, 0);*/
 		}
 
 	}
@@ -131,13 +131,13 @@
 /* just fetches node information and puts in the nodelist */
 int insert_node(void *data, int argc, char **argv, char **azColName)
 {
-	struct nodelist *np=data;	/* get the nodepointer */
+	struct nodelist *np = data; /* get the nodepointer */
 	int i;
-	for (i=0; i<argc; i++) {
+	for (i = 0; i < argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],"longitude"))			np[nodelist_n].lo=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],"latitude"))		np[nodelist_n].la=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],"altitude"))		np[nodelist_n].alt=strtod(argv[i],NULL);
+			if (0 == strcmp(azColName[i], "longitude"))   np[nodelist_n].lo = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], "latitude"))  np[nodelist_n].la = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], "altitude"))  np[nodelist_n].alt = strtod(argv[i], NULL);
 		}
 	}
 	return(0);
@@ -145,13 +145,13 @@
 int select_waytype(void *data, int argc, char **argv, char **azColName)
 {
 	int i;
-	for (i=0; i<argc; i++) {
+	for (i = 0; i < argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(argv[i],"motorway"))				*((int *) data)=5;
-			else if (0==strcmp(argv[i],"motorway_link"))	*((int *) data)=4;
-			else if (0==strcmp(argv[i],"primary"))			*((int *) data)=3;
-			else if (0==strcmp(argv[i],"secondary"))		*((int *) data)=2;
-			else if (0==strcmp(argv[i],"residential"))		*((int *) data)=1;
+			if (0 == strcmp(argv[i], "motorway"))    *((int *) data) = 5;
+			else if (0 == strcmp(argv[i], "motorway_link")) *((int *) data) = 4;
+			else if (0 == strcmp(argv[i], "primary"))   *((int *) data) = 3;
+			else if (0 == strcmp(argv[i], "secondary"))  *((int *) data) = 2;
+			else if (0 == strcmp(argv[i], "residential"))  *((int *) data) = 1;
 		}
 	}
 	return(0);
@@ -161,245 +161,245 @@
 {
 	float len;
 	char query[MAXQ];
-	int i,j,k,vert=0;
+	int i, j, k, vert = 0;
 	int node_id;
 	int way_obj;
-	int waytype=0;
+	int waytype = 0;
 	int adj_seg;
-	float a[3],b[3],*left,*right,*swap;
+	float a[3], b[3], *left, *right, *swap;
 	float street_width; /* dynamically adjust? */
-	float an[3];		/* normal on the plane, orthogonal on the right side of the left segment */
-	float n[3];			/* the direction vector in which the intersecion should be placed */
-	float s[3];			/* intersection point */
+	float an[3];  /* normal on the plane, orthogonal on the right side of the left segment */
+	float n[3];   /* the direction vector in which the intersecion should be placed */
+	float s[3];   /* intersection point */
 	float point_zero[3]; /* we use point_zero so we don't have very big bounding spheres in s3d and speed up picking */
-	float n_len,scale;
+	float n_len, scale;
 
-	if (waylist_n==0)	/* no nodes, no fun */
+	if (waylist_n == 0) /* no nodes, no fun */
 		return;
-	/*	printf("way: %d - %d segments\n",lastid,waylist_n);*/
-	way_obj=s3d_new_object();
-	if (lastid!=-1) {
-		snprintf(query,MAXQ,"SELECT tagvalue FROM tag WHERE tag_id=(SELECT tag_id FROM way WHERE way_id=%d AND %s) AND tagkey='highway';",lastid,filter);
+	/* printf("way: %d - %d segments\n",lastid,waylist_n);*/
+	way_obj = s3d_new_object();
+	if (lastid != -1) {
+		snprintf(query, MAXQ, "SELECT tagvalue FROM tag WHERE tag_id=(SELECT tag_id FROM way WHERE way_id=%d AND %s) AND tagkey='highway';", lastid, filter);
 		db_exec(query, select_waytype, &waytype);
 	}
 	switch (waytype) {
 	case 5:
-		s3d_push_material(way_obj,0.2,0.2,0.6,		1.0,1.0,1.0,	0.3,0.3,1.0);	/* motorway */
+		s3d_push_material(way_obj, 0.2, 0.2, 0.6,  1.0, 1.0, 1.0, 0.3, 0.3, 1.0); /* motorway */
 	case 4:
-		s3d_push_material(way_obj,0.3,0.3,0.4,		1.0,1.0,1.0,	0.5,0.5,0.8);	/* motorway_link*/
+		s3d_push_material(way_obj, 0.3, 0.3, 0.4,  1.0, 1.0, 1.0, 0.5, 0.5, 0.8); /* motorway_link*/
 	case 3:
-		s3d_push_material(way_obj,0.6,0.3,0.1,		1.0,1.0,1.0, 	1.0,0.6,0.2);	/* primary */
+		s3d_push_material(way_obj, 0.6, 0.3, 0.1,  1.0, 1.0, 1.0,  1.0, 0.6, 0.2); /* primary */
 	case 2:
-		s3d_push_material(way_obj,0.6,0.6,0.0,		1.0,1.0,1.0, 	1.0,1.0,0.0);	/* secondary */
+		s3d_push_material(way_obj, 0.6, 0.6, 0.0,  1.0, 1.0, 1.0,  1.0, 1.0, 0.0); /* secondary */
 	case 1:
-		s3d_push_material(way_obj,0.6,0.6,0.6,		1.0,1.0,1.0, 	1.0,1.0,1.0);	/* residential */
+		s3d_push_material(way_obj, 0.6, 0.6, 0.6,  1.0, 1.0, 1.0,  1.0, 1.0, 1.0); /* residential */
 	default:
-		s3d_push_material(way_obj,0.6,0.2,0.6,		1.0,1.0,1.0,	1.0,0.5,1.0); /* default */
+		s3d_push_material(way_obj, 0.6, 0.2, 0.6,  1.0, 1.0, 1.0, 1.0, 0.5, 1.0); /* default */
 	}
-	street_width=(0.5+waytype/10)/RESCALE;
+	street_width = (0.5 + waytype / 10) / RESCALE;
 	/* put nodes of the graph into a list */
-	nodelist_n=0;
-	for (i=0;i<waylist_n*2;i++) {
-		if (i%2)				node_id=waylist_p[i/2].node_from;
-		else					node_id=waylist_p[i/2].node_to;
-		for (j=0;j<nodelist_n;j++)
-			if (nodelist_p[j].node_id==node_id) break;
-		if (j==nodelist_n) { /* we still need to add this node */
-			/*			printf("[way %d] add node %d to nodelist as %d\n",lastid, node_id, nodelist_n);*/
-			nodelist_p[j].node_id=node_id;
-			snprintf(query,MAXQ,"SELECT longitude, latitude, altitude FROM node WHERE %s AND node_id=%d;",filter, node_id);
-			db_exec(query, insert_node,(void *)(nodelist_p));
-			calc_earth_to_eukl(nodelist_p[j].la,nodelist_p[j].lo,0,nodelist_p[j].x); /* elevate higher priority streets a little bit ... */
-			len=sqrt(nodelist_p[j].x[0]*nodelist_p[j].x[0] + nodelist_p[j].x[1]*nodelist_p[j].x[1] + nodelist_p[j].x[2]*nodelist_p[j].x[2]);
-			nodelist_p[j].normal[0]=nodelist_p[j].x[0]/len;
-			nodelist_p[j].normal[1]=nodelist_p[j].x[1]/len;
-			nodelist_p[j].normal[2]=nodelist_p[j].x[2]/len;
+	nodelist_n = 0;
+	for (i = 0;i < waylist_n*2;i++) {
+		if (i % 2)    node_id = waylist_p[i/2].node_from;
+		else     node_id = waylist_p[i/2].node_to;
+		for (j = 0;j < nodelist_n;j++)
+			if (nodelist_p[j].node_id == node_id) break;
+		if (j == nodelist_n) { /* we still need to add this node */
+			/*   printf("[way %d] add node %d to nodelist as %d\n",lastid, node_id, nodelist_n);*/
+			nodelist_p[j].node_id = node_id;
+			snprintf(query, MAXQ, "SELECT longitude, latitude, altitude FROM node WHERE %s AND node_id=%d;", filter, node_id);
+			db_exec(query, insert_node, (void *)(nodelist_p));
+			calc_earth_to_eukl(nodelist_p[j].la, nodelist_p[j].lo, 0, nodelist_p[j].x); /* elevate higher priority streets a little bit ... */
+			len = sqrt(nodelist_p[j].x[0] * nodelist_p[j].x[0] + nodelist_p[j].x[1] * nodelist_p[j].x[1] + nodelist_p[j].x[2] * nodelist_p[j].x[2]);
+			nodelist_p[j].normal[0] = nodelist_p[j].x[0] / len;
+			nodelist_p[j].normal[1] = nodelist_p[j].x[1] / len;
+			nodelist_p[j].normal[2] = nodelist_p[j].x[2] / len;
 			nodelist_n++;
 		}
-		if (i%2)				waylist_p[i/2].node_from_int=j;
-		else					waylist_p[i/2].node_to_int=j;
+		if (i % 2)    waylist_p[i/2].node_from_int = j;
+		else     waylist_p[i/2].node_to_int = j;
 	}
 	V_COPY(point_zero, nodelist_p[0].x);
 	/* iterate for all nodes */
-	for (i=0;i<nodelist_n;i++) {
+	for (i = 0;i < nodelist_n;i++) {
 		/* find adjacent segments */
-		adjlist_n=0;
-		node_id=nodelist_p[i].node_id;
-		for (j=0;j<=waylist_n;j++)	{
-			if (waylist_p[j].node_from==node_id) {
-				adjlist_p[adjlist_n].node_id=waylist_p[j].node_to_int;
-				adjlist_p[adjlist_n].seg_id=j;
+		adjlist_n = 0;
+		node_id = nodelist_p[i].node_id;
+		for (j = 0;j <= waylist_n;j++) {
+			if (waylist_p[j].node_from == node_id) {
+				adjlist_p[adjlist_n].node_id = waylist_p[j].node_to_int;
+				adjlist_p[adjlist_n].seg_id = j;
 				adjlist_n++;
-			} else  if (waylist_p[j].node_to==node_id) {
-				adjlist_p[adjlist_n].node_id=waylist_p[j].node_from_int;
-				adjlist_p[adjlist_n].seg_id=j;
+			} else  if (waylist_p[j].node_to == node_id) {
+				adjlist_p[adjlist_n].node_id = waylist_p[j].node_from_int;
+				adjlist_p[adjlist_n].seg_id = j;
 				adjlist_n++;
 			}
 		}
 
-		if (adjlist_n>1) {	/* more than one adjacent, need to order and calculate intersections */
-			if (adjlist_n>2) { /* no ordering needed for 2 incoming segments */
-				for (j=0;j<adjlist_n-2;j++)
-					for (k=j+2;k<adjlist_n;k++) {
-						float test[3],normal[3],linevector[3];
+		if (adjlist_n > 1) { /* more than one adjacent, need to order and calculate intersections */
+			if (adjlist_n > 2) { /* no ordering needed for 2 incoming segments */
+				for (j = 0;j < adjlist_n - 2;j++)
+					for (k = j + 2;k < adjlist_n;k++) {
+						float test[3], normal[3], linevector[3];
 						/* (re)calc test direction */
-						V_SUB(nodelist_p[adjlist_p[j].node_id].x,	nodelist_p[adjlist_p[j+1].node_id].x,	linevector);
-						V_CROSS(nodelist_p[adjlist_p[j].node_id].normal,	linevector,		normal); /* normal should look outside of our circle now. */
-						while (k<adjlist_n) {
+						V_SUB(nodelist_p[adjlist_p[j].node_id].x, nodelist_p[adjlist_p[j+1].node_id].x, linevector);
+						V_CROSS(nodelist_p[adjlist_p[j].node_id].normal, linevector,  normal); /* normal should look outside of our circle now. */
+						while (k < adjlist_n) {
 							/* determine on which side the point is. if its between our testvector, we'll need to swap. */
-							V_SUB(nodelist_p[adjlist_p[j].node_id].x,nodelist_p[adjlist_p[k].node_id].x,test);
-							if (s3d_vector_dot_product(normal,test)>0) { /* same side, means adjacent line k is nearer to our point j
-																			than our point j+1 which is supposed to be the nearest point,
-																			so we swap them and call a break to get the new test-normal */
+							V_SUB(nodelist_p[adjlist_p[j].node_id].x, nodelist_p[adjlist_p[k].node_id].x, test);
+							if (s3d_vector_dot_product(normal, test) > 0) { /* same side, means adjacent line k is nearer to our point j
+                   than our point j+1 which is supposed to be the nearest point,
+                   so we swap them and call a break to get the new test-normal */
 								struct adjlist swap;
-								memcpy(&swap,&(adjlist_p[j+1]),sizeof(struct adjlist));
-								memcpy(&(adjlist_p[j+1]),&(adjlist_p[k]),sizeof(struct adjlist));
-								memcpy(&(adjlist_p[k]),&swap,sizeof(struct adjlist));
+								memcpy(&swap, &(adjlist_p[j+1]), sizeof(struct adjlist));
+								memcpy(&(adjlist_p[j+1]), &(adjlist_p[k]), sizeof(struct adjlist));
+								memcpy(&(adjlist_p[k]), &swap, sizeof(struct adjlist));
 								break;
 							}
 							k++;
 						}
 					}
 			}
-			left=a;
-			right=b;
+			left = a;
+			right = b;
 			V_SUB(nodelist_p[adjlist_p[0].node_id].x, nodelist_p[i].x, right);
 			V_NORM(right);
 
 
-			for (j=0;j<adjlist_n;j++) {
-				swap=left;
-				left=right;			/* use last right segment as new left segment */
-				right=swap;			/* get space for the next right segment */
+			for (j = 0;j < adjlist_n;j++) {
+				swap = left;
+				left = right; /* use last right segment as new left segment */
+				right = swap; /* get space for the next right segment */
 				V_SUB(nodelist_p[adjlist_p[(j+1)%adjlist_n].node_id].x, nodelist_p[i].x, right);
 				V_NORM(right);
-				V_CROSS(nodelist_p[i].normal, left ,an);	/* an is also normalized, as first and second argument are already length 1 */
-				V_ADD(left, right, n);						/* direction which our intersection is */
+				V_CROSS(nodelist_p[i].normal, left , an); /* an is also normalized, as first and second argument are already length 1 */
+				V_ADD(left, right, n);      /* direction which our intersection is */
 
 				V_CROSS(nodelist_p[i].normal, n, s);
 				V_CROSS(s, nodelist_p[i].normal, n); /* get n on the plane which is spanned by the points normal */
 
-				n_len=V_LEN(n);
+				n_len = V_LEN(n);
 
-				V_COPY(s, nodelist_p[i].x);	/* s = P + (street_width/ ( n * an)) * n */
-				V_SCAL(n,1/n_len);	/* normalize n first! */
-				scale=V_DOT(n,an);	/* get cos (alpha/2), alpha is opposite angel of left and right segment */
+				V_COPY(s, nodelist_p[i].x); /* s = P + (street_width/ ( n * an)) * n */
+				V_SCAL(n, 1 / n_len); /* normalize n first! */
+				scale = V_DOT(n, an); /* get cos (alpha/2), alpha is opposite angel of left and right segment */
 
-				if ((n_len<0.1) || (fabs(scale)<0.1)) {	/* too low, don't use, just have intersection 90 degree of it. */
-					V_SCAL(an, -street_width);		/* S = P + street_width * an */
+				if ((n_len < 0.1) || (fabs(scale) < 0.1)) { /* too low, don't use, just have intersection 90 degree of it. */
+					V_SCAL(an, -street_width);  /* S = P + street_width * an */
 					V_ADD(nodelist_p[i].x, an, s);
 
 				} else {
-					V_SCAL(n,-street_width/scale);
+					V_SCAL(n, -street_width / scale);
 					V_ADD(s, n, s);
 				}
 
 
-				/*				printf("calc intersection: %3.3f %3.3f %3.3f\n",s[0],s[1],s[2]);*/
-				V_SUB(s,point_zero,s);
-				s3d_push_vertices(way_obj,s,1);
-				adj_seg=adjlist_p[j].seg_id;				/* left segment */
-				if (i==waylist_p[adj_seg].node_from_int)	waylist_p[adj_seg].node_from_r=vert;
-				else									waylist_p[adj_seg].node_to_l=vert;
-				adj_seg=adjlist_p[(j+1)%adjlist_n].seg_id;	/* right segment */
-				if (i==waylist_p[adj_seg].node_from_int)	waylist_p[adj_seg].node_from_l=vert;
-				else									waylist_p[adj_seg].node_to_r=vert;
+				/*    printf("calc intersection: %3.3f %3.3f %3.3f\n",s[0],s[1],s[2]);*/
+				V_SUB(s, point_zero, s);
+				s3d_push_vertices(way_obj, s, 1);
+				adj_seg = adjlist_p[j].seg_id;  /* left segment */
+				if (i == waylist_p[adj_seg].node_from_int) waylist_p[adj_seg].node_from_r = vert;
+				else         waylist_p[adj_seg].node_to_l = vert;
+				adj_seg = adjlist_p[(j+1)%adjlist_n].seg_id; /* right segment */
+				if (i == waylist_p[adj_seg].node_from_int) waylist_p[adj_seg].node_from_l = vert;
+				else         waylist_p[adj_seg].node_to_r = vert;
 				vert++;
 			}
-			if (adjlist_n>=3) {
+			if (adjlist_n >= 3) {
 				/* we know that the last adjlist_n vertices set belong to our intersection here .. */
-				for (j=vert-adjlist_n+1;j<(vert-1);j++)
-					s3d_push_polygon(way_obj, vert-adjlist_n, j, j+1,0 );
+				for (j = vert - adjlist_n + 1;j < (vert - 1);j++)
+					s3d_push_polygon(way_obj, vert - adjlist_n, j, j + 1, 0);
 			}
 		} else {
 			/* endpoint */
 			V_SUB(nodelist_p[adjlist_p[0].node_id].x, nodelist_p[i].x, a);
 			V_NORM(a);
-			V_CROSS(nodelist_p[i].normal, a ,an);	/* an is also normalized, as first and second argument are already length 1 */
+			V_CROSS(nodelist_p[i].normal, a , an); /* an is also normalized, as first and second argument are already length 1 */
 			V_SCAL(an, street_width);
 
-			V_COPY(s,nodelist_p[i].x);
-			V_ADD(s,an,s);
-			V_SUB(s,point_zero,s);
-			s3d_push_vertices(way_obj,s,1);
-			j=vert;
+			V_COPY(s, nodelist_p[i].x);
+			V_ADD(s, an, s);
+			V_SUB(s, point_zero, s);
+			s3d_push_vertices(way_obj, s, 1);
+			j = vert;
 			vert++;
-			V_SCAL(an,-1);
-			V_COPY(s,nodelist_p[i].x);
-			V_ADD(s,an,s);
-			V_SUB(s,point_zero,s);
-			s3d_push_vertices(way_obj,s,1);
-			k=vert;
+			V_SCAL(an, -1);
+			V_COPY(s, nodelist_p[i].x);
+			V_ADD(s, an, s);
+			V_SUB(s, point_zero, s);
+			s3d_push_vertices(way_obj, s, 1);
+			k = vert;
 			vert++;
 
-			adj_seg=adjlist_p[0].seg_id;
-			if (i==waylist_p[adj_seg].node_from_int)	{
-				waylist_p[adj_seg].node_from_l=j;
-				waylist_p[adj_seg].node_from_r=k;
+			adj_seg = adjlist_p[0].seg_id;
+			if (i == waylist_p[adj_seg].node_from_int) {
+				waylist_p[adj_seg].node_from_l = j;
+				waylist_p[adj_seg].node_from_r = k;
 			} else {
-				waylist_p[adj_seg].node_to_l=k;
-				waylist_p[adj_seg].node_to_r=j;
+				waylist_p[adj_seg].node_to_l = k;
+				waylist_p[adj_seg].node_to_r = j;
 			}
 		}
 	}
-	for (i=0;i<waylist_n;i++) {
-		uint32_t	polys[8];
+	for (i = 0;i < waylist_n;i++) {
+		uint32_t polys[8];
 		/* printf("drawing way from points %d %d %d %d\n",waylist_p[i].node_from_l, waylist_p[i].node_to_l, waylist_p[i].node_to_r,waylist_p[i].node_from_r);*/
-		polys[0]=waylist_p[i].node_from_l;
-		polys[1]=waylist_p[i].node_to_l;
-		polys[2]=waylist_p[i].node_to_r;
-		polys[3]=0;
-		polys[4]=waylist_p[i].node_from_l;
-		polys[5]=waylist_p[i].node_to_r;
-		polys[6]=waylist_p[i].node_from_r;
-		polys[7]=0;
+		polys[0] = waylist_p[i].node_from_l;
+		polys[1] = waylist_p[i].node_to_l;
+		polys[2] = waylist_p[i].node_to_r;
+		polys[3] = 0;
+		polys[4] = waylist_p[i].node_from_l;
+		polys[5] = waylist_p[i].node_to_r;
+		polys[6] = waylist_p[i].node_from_r;
+		polys[7] = 0;
 
 		s3d_push_polygons(way_obj, polys, 2);
 	}
-	s3d_translate(way_obj,point_zero[0], point_zero[1], point_zero[2]);
-	s3d_link(way_obj,oidy);
-	s3d_flags_on(way_obj,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	snprintf(query,MAXQ,"UPDATE way SET s3doid=%d WHERE way_id=%d AND %s;",way_obj,lastid,filter);
+	s3d_translate(way_obj, point_zero[0], point_zero[1], point_zero[2]);
+	s3d_link(way_obj, oidy);
+	s3d_flags_on(way_obj, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	snprintf(query, MAXQ, "UPDATE way SET s3doid=%d WHERE way_id=%d AND %s;", way_obj, lastid, filter);
 	db_exec(query, NULL, 0);
 
-	waylist_n=0;
+	waylist_n = 0;
 
-	load_update_status((100.0*num_done)/(float)num_max);
+	load_update_status((100.0*num_done) / (float)num_max);
 }
 void waylist_add(struct waylist *p)
 {
-	if (waylist_n>=waylist_bufn) {
-		waylist_bufn+=64;
-		waylist_p=realloc(waylist_p,sizeof(struct waylist)*waylist_bufn);
-		nodelist_p=realloc(nodelist_p,sizeof(struct nodelist)*waylist_bufn*2); /* we can have twice as many nodes as there are segments in a graph. */
-		adjlist_p=realloc(adjlist_p,sizeof(struct nodelist)*waylist_bufn*2);
+	if (waylist_n >= waylist_bufn) {
+		waylist_bufn += 64;
+		waylist_p = realloc(waylist_p, sizeof(struct waylist) * waylist_bufn);
+		nodelist_p = realloc(nodelist_p, sizeof(struct nodelist) * waylist_bufn * 2); /* we can have twice as many nodes as there are segments in a graph. */
+		adjlist_p = realloc(adjlist_p, sizeof(struct nodelist) * waylist_bufn * 2);
 	}
-	waylist_p[waylist_n].node_to= p->node_to;
-	waylist_p[waylist_n].node_from= p->node_from;
+	waylist_p[waylist_n].node_to = p->node_to;
+	waylist_p[waylist_n].node_from = p->node_from;
 	waylist_n++;
 }
 
 int way_group(void *data, int argc, char **argv, char **azColName)
 {
 	int i;
-	int id=-1;
+	int id = -1;
 	struct waylist p;
-	char *filter=(char *)data;
+	char *filter = (char *)data;
 	num_done++;
-	p.node_from=p.node_to=0;
-	p.node_to=-1;
-	p.seg_id=-1;
-	for (i=0; i<argc; i++) {
+	p.node_from = p.node_to = 0;
+	p.node_to = -1;
+	p.seg_id = -1;
+	for (i = 0; i < argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],"way_id"))				id=atoi(argv[i]);
-			else if (0==strcmp(azColName[i],"node_from"))		p.node_from=atoi(argv[i]);
-			else if (0==strcmp(azColName[i],"node_to"))			p.node_to=atoi(argv[i]);
-			else if (0==strcmp(azColName[i],"seg_id"))			p.seg_id=atoi(argv[i]);
+			if (0 == strcmp(azColName[i], "way_id"))    id = atoi(argv[i]);
+			else if (0 == strcmp(azColName[i], "node_from"))  p.node_from = atoi(argv[i]);
+			else if (0 == strcmp(azColName[i], "node_to"))   p.node_to = atoi(argv[i]);
+			else if (0 == strcmp(azColName[i], "seg_id"))   p.seg_id = atoi(argv[i]);
 		}
 	}
-	if (p.node_from==p.node_to)	/* skip */
+	if (p.node_from == p.node_to) /* skip */
 		return(0);
-	if ((lastid!=id) && (id!=0)) {
+	if ((lastid != id) && (id != 0)) {
 		waylist_draw(filter);
 		/* flush/draw the list, add new  */
 		waylist_add(&p);
@@ -407,25 +407,25 @@
 		/* add id to the list */
 		waylist_add(&p);
 	}
-	lastid=id;
+	lastid = id;
 	return 0;
 }
 void draw_translate_icon(int user_icon, float la, float lo)
 {
 	float x[3];
-	calc_earth_to_eukl(la,lo,1/RESCALE,x);
-	s3d_translate(user_icon,x[0],x[1],x[2]);
-	s3d_rotate(user_icon,(90-la),lo,0);
+	calc_earth_to_eukl(la, lo, 1 / RESCALE, x);
+	s3d_translate(user_icon, x[0], x[1], x[2]);
+	s3d_rotate(user_icon, (90 - la), lo, 0);
 }
 
 void draw_ways(char *filter)
 {
 	char query[MAXQ];
-	num_done=0;
-	snprintf(query,MAXQ,"SELECT count(seg_id) FROM segment WHERE %s;",filter);
-	db_exec(query, db_getint,&num_max);
-	snprintf(query,MAXQ,"SELECT * FROM segment WHERE %s ORDER BY way_id;",filter);
-	db_exec(query, way_group,filter);
+	num_done = 0;
+	snprintf(query, MAXQ, "SELECT count(seg_id) FROM segment WHERE %s;", filter);
+	db_exec(query, db_getint, &num_max);
+	snprintf(query, MAXQ, "SELECT * FROM segment WHERE %s ORDER BY way_id;", filter);
+	db_exec(query, way_group, filter);
 	waylist_draw(filter); /* last way */
 }
 void draw_osm()
@@ -436,13 +436,13 @@
 void draw_kismet()
 {
 	char query[MAXQ];
-	char filter[]="layer_id=(SELECT layer_id FROM layer WHERE name='kismet')";
+	char filter[] = "layer_id=(SELECT layer_id FROM layer WHERE name='kismet')";
 	load_window("Drawing Access Points ...");
-	num_done=0;
-	snprintf(query,MAXQ,"SELECT count(node_id) FROM node WHERE %s;",filter);
-	db_exec(query, db_getint,&num_max);
-	snprintf(query,MAXQ,"SELECT * FROM node WHERE %s;",filter);
-	db_exec(query, draw_icon,filter);
+	num_done = 0;
+	snprintf(query, MAXQ, "SELECT count(node_id) FROM node WHERE %s;", filter);
+	db_exec(query, db_getint, &num_max);
+	snprintf(query, MAXQ, "SELECT * FROM node WHERE %s;", filter);
+	db_exec(query, draw_icon, filter);
 }
 void draw_all_layers()
 {

Modified: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/gps.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,10 +24,10 @@
 
 #include <s3d.h>
 #include "s3dosm.h"
-#include <stdio.h> 	/* printf() */
-int user_icon=-1,user_icon_rotator=-1;
+#include <stdio.h>  /* printf() */
+int user_icon = -1, user_icon_rotator = -1;
 #ifdef HAVE_GPS
-#include <gps.h> 	/* gps_*() */
+#include <gps.h>  /* gps_*() */
 #ifdef NMEA_CHANNELS
 #define GPS_NEW
 #endif
@@ -36,35 +36,35 @@
 #endif
 
 #include <errno.h>  /* errno */
-#include <stdlib.h>	/* malloc(), free() */
+#include <stdlib.h> /* malloc(), free() */
 #include <string.h> /* strlen() */
-#include <stdio.h>		 /*  snprintf(), printf(), NULL */
-#include <time.h>	 /*  nanosleep(), struct tm, time_t...  */
-#include <math.h>	/* fabs(), finite () */
-static struct gps_data_t 	*dgps;
-static int 					 frame=0;
-static int 					 lastfix=0;
-static int 					 gps_active=0;
-static int					 gps_info=-1;
-static float 				 lat,lon,tlat,tlon;	/* we have the same in nav.c, this one is for the user icon ... */
-static float				 lat_old,lon_old;
-static float				 speed_old=0.0;
-void 				 show_gpsdata(struct gps_data_t *dgps);
-void				 show_position(struct gps_data_t *dgps);
+#include <stdio.h>   /*  snprintf(), printf(), NULL */
+#include <time.h>  /*  nanosleep(), struct tm, time_t...  */
+#include <math.h> /* fabs(), finite () */
+static struct gps_data_t  *dgps;
+static int       frame = 0;
+static int       lastfix = 0;
+static int       gps_active = 0;
+static int      gps_info = -1;
+static float      lat, lon, tlat, tlon; /* we have the same in nav.c, this one is for the user icon ... */
+static float     lat_old, lon_old;
+static float     speed_old = 0.0;
+void      show_gpsdata(struct gps_data_t *dgps);
+void     show_position(struct gps_data_t *dgps);
 
 void show_gpsdata(struct gps_data_t *dgps)
 {
 	if (!dgps->online)
 		printf("WARNING: no connection to gps device\n");
 #ifdef GPS_NEW
-	printf("[%d] lat/long: [%f|%f], altitude %f\n",frame,dgps->fix.latitude,dgps->fix.longitude,dgps->fix.altitude);
-	printf("speed [kph]: %f\n",dgps->fix.speed/KNOTS_TO_KPH);
-	printf("used %d/%d satellits\n",dgps->satellites_used,dgps->satellites);
-	printf("################## = %f %f %f\n",dgps->fix.pitch, dgps->fix.roll, dgps->fix.dip);
+	printf("[%d] lat/long: [%f|%f], altitude %f\n", frame, dgps->fix.latitude, dgps->fix.longitude, dgps->fix.altitude);
+	printf("speed [kph]: %f\n", dgps->fix.speed / KNOTS_TO_KPH);
+	printf("used %d/%d satellits\n", dgps->satellites_used, dgps->satellites);
+	printf("################## = %f %f %f\n", dgps->fix.pitch, dgps->fix.roll, dgps->fix.dip);
 #else
-	printf("[%d] lat/long: [%f|%f], altitude %f\n",frame,dgps->latitude,dgps->longitude,dgps->altitude);
-	printf("speed [kph]: %f\n",dgps->speed/KNOTS_TO_KPH);
-	printf("used %d/%d satellits\n",dgps->satellites_used,dgps->satellites);
+	printf("[%d] lat/long: [%f|%f], altitude %f\n", frame, dgps->latitude, dgps->longitude, dgps->altitude);
+	printf("speed [kph]: %f\n", dgps->speed / KNOTS_TO_KPH);
+	printf("used %d/%d satellits\n", dgps->satellites_used, dgps->satellites);
 
 #endif
 	switch (dgps->status) {
@@ -98,87 +98,87 @@
 		break;
 	}
 }
-#define BUFSIZE		1024
+#define BUFSIZE  1024
 void show_position(struct gps_data_t *dgps)
 {
-	int fix=1;
-	float la,lo,heading,speed,slen;
+	int fix = 1;
+	float la, lo, heading, speed, slen;
 	char buf[BUFSIZE+1];
 #ifdef GPS_NEW
 	if (!dgps->online)
-		fix=0;
+		fix = 0;
 	switch (dgps->fix.mode) {
 	case MODE_NOT_SEEN:
-		fix=0;
+		fix = 0;
 		break;
 	case MODE_NO_FIX:
-		fix=0;
+		fix = 0;
 		break;
 	}
 
-	la=dgps->fix.latitude;
-	lo=dgps->fix.longitude;
-	heading=-dgps->fix.track;
-	speed=dgps->fix.speed;
+	la = dgps->fix.latitude;
+	lo = dgps->fix.longitude;
+	heading = -dgps->fix.track;
+	speed = dgps->fix.speed;
 
 #else
 	if (!dgps->online)
-		fix=0;
+		fix = 0;
 	switch (dgps->mode) {
 	case MODE_NOT_SEEN:
-		fix=0;
+		fix = 0;
 		break;
 	case MODE_NO_FIX:
-		fix=0;
+		fix = 0;
 		break;
 	}
-	la=dgps->latitude;
-	lo=dgps->longitude;
-	heading=-dgps->track;
-	speed=dgps->speed*KNOTS_TO_MPH/METERS_TO_MILES/3600; /* speed in knots -> miles per hour -> meter per hour -> meter per secon */
+	la = dgps->latitude;
+	lo = dgps->longitude;
+	heading = -dgps->track;
+	speed = dgps->speed * KNOTS_TO_MPH / METERS_TO_MILES / 3600; /* speed in knots -> miles per hour -> meter per hour -> meter per secon */
 #endif
-	tlat=la;
-	tlon=lo;
+	tlat = la;
+	tlon = lo;
 	if (fix) {
 		printf("have a fix\n");
-		nav_center(la,lo);
+		nav_center(la, lo);
 		if (!finitef(heading)) {
-			heading=get_heading(lat_old,lon_old,la,lo);
-			if (!lastfix && fix) 		{
-				s3d_scale(user_icon,1.0/RESCALE);
+			heading = get_heading(lat_old, lon_old, la, lo);
+			if (!lastfix && fix)   {
+				s3d_scale(user_icon, 1.0 / RESCALE);
 			}
-			if (lastfix && !fix)		{
-				s3d_scale(user_icon,0.3/RESCALE);
-				lat=tlat;
-				lon=tlon;
+			if (lastfix && !fix)  {
+				s3d_scale(user_icon, 0.3 / RESCALE);
+				lat = tlat;
+				lon = tlon;
 			}
 		}
-		if (finitef(heading))		s3d_rotate(user_icon,0,heading,0); /* wrong rotation? */
+		if (finitef(heading))  s3d_rotate(user_icon, 0, heading, 0); /* wrong rotation? */
 		if (finitef(speed)) {
 			/* print some information */
-			snprintf(buf,BUFSIZE,"speed: %3.2f km/h",speed*3.6);
-			speed_old=speed;
+			snprintf(buf, BUFSIZE, "speed: %3.2f km/h", speed*3.6);
+			speed_old = speed;
 		} else
-			snprintf(buf,BUFSIZE,"speed: NA (old: %3.2f km/h)",speed_old*3.6);
+			snprintf(buf, BUFSIZE, "speed: NA (old: %3.2f km/h)", speed_old*3.6);
 
-		if (gps_info!=-1)	s3d_del_object(gps_info);
-		gps_info=s3d_draw_string(buf,&slen);
-		s3d_translate(gps_info,-slen/2,1,0);
+		if (gps_info != -1) s3d_del_object(gps_info);
+		gps_info = s3d_draw_string(buf, &slen);
+		s3d_translate(gps_info, -slen / 2, 1, 0);
 		s3d_link(gps_info, user_icon);
-		s3d_flags_on(gps_info,S3D_OF_VISIBLE);
+		s3d_flags_on(gps_info, S3D_OF_VISIBLE);
 	}
 
 
-	lat_old=la;
-	lon_old=lo;
-	lastfix=fix;
+	lat_old = la;
+	lon_old = lo;
+	lastfix = fix;
 }
 int gps_init(char *gpshost)
 {
 	char *err_str;
-	dgps=gps_open(gpshost,"2947");
-	if (dgps==NULL) {
-		switch ( errno ) {
+	dgps = gps_open(gpshost, "2947");
+	if (dgps == NULL) {
+		switch (errno) {
 		case NL_NOSERVICE:
 			err_str = "can't get service entry";
 			break;
@@ -201,25 +201,25 @@
 			err_str = "Unknown";
 			break;
 		}
-		/*		printf("no connection to gpsd\n");*/
-		fprintf(stderr, "s3dosm: no gpsd running or network error: %d, %s\n"	,  errno, err_str);
+		/*  printf("no connection to gpsd\n");*/
+		fprintf(stderr, "s3dosm: no gpsd running or network error: %d, %s\n" ,  errno, err_str);
 		return(-1);
 	}
-	user_icon=s3d_clone(icons[ICON_ARROW].oid);
-	user_icon_rotator=s3d_new_object();
-	s3d_link(user_icon,user_icon_rotator);
-	s3d_link(user_icon_rotator,oidy);
-	s3d_flags_on(user_icon,S3D_OF_VISIBLE);
-	s3d_scale(user_icon,1.0/RESCALE);
-	tlat=lat=lat_old=0.0;
-	tlon=lon=lon_old=0.0;
-	gps_active=1;
+	user_icon = s3d_clone(icons[ICON_ARROW].oid);
+	user_icon_rotator = s3d_new_object();
+	s3d_link(user_icon, user_icon_rotator);
+	s3d_link(user_icon_rotator, oidy);
+	s3d_flags_on(user_icon, S3D_OF_VISIBLE);
+	s3d_scale(user_icon, 1.0 / RESCALE);
+	tlat = lat = lat_old = 0.0;
+	tlon = lon = lon_old = 0.0;
+	gps_active = 1;
 	gps_query(dgps, "w+x\n");
 	return(0);
 }
 int gps_main()
 {
-	if (gps_active && ((frame%6)==0)) {
+	if (gps_active && ((frame % 6) == 0)) {
 		if (gps_poll(dgps) < 0) {
 			printf("read error on server socket\n");
 			gps_quit();
@@ -228,19 +228,19 @@
 		/*show_gpsdata(dgps);*/
 		show_position(dgps);
 	}
-	if ((fabs(tlat-lat)>0.00001) && (fabs(tlon-lon)>0.00001)) {
-		if (lat==0.0 && lon==0.0) {
-			lat=tlat;
-			lon=tlon;
+	if ((fabs(tlat - lat) > 0.00001) && (fabs(tlon - lon) > 0.00001)) {
+		if (lat == 0.0 && lon == 0.0) {
+			lat = tlat;
+			lon = tlon;
 		} else {
-			lat=(tlat+lat*7)/8;
-			lon=(tlon+lon*7)/8;
+			lat = (tlat + lat * 7) / 8;
+			lon = (tlon + lon * 7) / 8;
 		}
 	} else {
-		tlat=lat;
-		tlon=lon;
+		tlat = lat;
+		tlon = lon;
 	}
-	draw_translate_icon(user_icon_rotator,lat,lon);
+	draw_translate_icon(user_icon_rotator, lat, lon);
 	frame++;
 	return(0);
 }
@@ -248,7 +248,7 @@
 {
 	if (gps_active) {
 		printf("deactivating gps-connection ...\n");
-		gps_active=0;
+		gps_active = 0;
 		gps_close(dgps);
 	}
 	return(0);

Modified: trunk/apps/s3dosm/http_error_codes.c
===================================================================
--- trunk/apps/s3dosm/http_error_codes.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/http_error_codes.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,35 +1,35 @@
 /* http_error_codes.c - Error code declarations
 
-	HTTP Fetcher
- 	Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
+ HTTP Fetcher
+  Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
 
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Library General Public
-	License as published by the Free Software Foundation; either
-	version 2 of the License, or (at your option) any later version.
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Library General Public
+ License as published by the Free Software Foundation; either
+ version 2 of the License, or (at your option) any later version.
 
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Library General Public License for more details.
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Library General Public License for more details.
 
-	See LICENSE file for details
+ See LICENSE file for details
  */
 
 
 /* Note that '%d' cannot be escaped at this time */
 const char *http_errlist[] = {
-	"Success",										/* HF_SUCCESS		*/
-	"Internal Error. What the hell?!",				/* HF_METAERROR		*/
-	"Got NULL url",									/* HF_NULLURL		*/
-	"Timed out, no metadata for %d seconds",		/* HF_HEADTIMEOUT 	*/
-	"Timed out, no data for %d seconds",			/* HF_DATATIMEOUT	*/
-	"Couldn't find return code in HTTP response",	/* HF_FRETURNCODE	*/
-	"Couldn't convert return code in HTTP response",/* HF_CRETURNCODE	*/
-	"Request returned a status code of %d",			/* HF_STATUSCODE	*/
-	"Couldn't convert Content-Length to integer"	/* HF_CONTENTLEN	*/
+	"Success",          /* HF_SUCCESS  */
+	"Internal Error. What the hell?!",    /* HF_METAERROR  */
+	"Got NULL url",         /* HF_NULLURL  */
+	"Timed out, no metadata for %d seconds",  /* HF_HEADTIMEOUT  */
+	"Timed out, no data for %d seconds",   /* HF_DATATIMEOUT */
+	"Couldn't find return code in HTTP response", /* HF_FRETURNCODE */
+	"Couldn't convert return code in HTTP response",/* HF_CRETURNCODE */
+	"Request returned a status code of %d",   /* HF_STATUSCODE */
+	"Couldn't convert Content-Length to integer" /* HF_CONTENTLEN */
 };
 
 /* Used to copy in messages from http_errlist[] and replace %d's with
- *	the value of errorInt.  Then we can pass the pointer to THIS */
+ * the value of errorInt.  Then we can pass the pointer to THIS */
 char convertedError[128];

Modified: trunk/apps/s3dosm/http_error_codes.h
===================================================================
--- trunk/apps/s3dosm/http_error_codes.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/http_error_codes.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,18 +1,18 @@
 /* http_error_codes.h - Error code definitions
 
-	Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
+ Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
 
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Library General Public
-	License as published by the Free Software Foundation; either
-	version 2 of the License, or (at your option) any later version.
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Library General Public
+ License as published by the Free Software Foundation; either
+ version 2 of the License, or (at your option) any later version.
 
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Library General Public License for more details.
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Library General Public License for more details.
 
-	See LICENSE file for details
+ See LICENSE file for details
 
  */
 
@@ -20,19 +20,19 @@
 #define HTTP_ERROR_CODES_H
 
 /* Error sources */
-#define FETCHER_ERROR	0
-#define ERRNO			1
-#define H_ERRNO			2
+#define FETCHER_ERROR 0
+#define ERRNO   1
+#define H_ERRNO   2
 
 /* HTTP Fetcher error codes */
-#define HF_SUCCESS		0
-#define HF_METAERROR	1
-#define HF_NULLURL		2
-#define HF_HEADTIMEOUT	3
-#define HF_DATATIMEOUT	4
-#define HF_FRETURNCODE	5
-#define HF_CRETURNCODE	6
-#define HF_STATUSCODE	7
-#define HF_CONTENTLEN	8
+#define HF_SUCCESS  0
+#define HF_METAERROR 1
+#define HF_NULLURL  2
+#define HF_HEADTIMEOUT 3
+#define HF_DATATIMEOUT 4
+#define HF_FRETURNCODE 5
+#define HF_CRETURNCODE 6
+#define HF_STATUSCODE 7
+#define HF_CONTENTLEN 8
 
 #endif

Modified: trunk/apps/s3dosm/http_fetcher.c
===================================================================
--- trunk/apps/s3dosm/http_fetcher.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/http_fetcher.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,22 +1,22 @@
 /* http_fetcher.c - HTTP handling functions
 
-	Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
+ Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
 
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Library General Public
-	License as published by the Free Software Foundation; either
-	version 2 of the License, or (at your option) any later version.
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Library General Public
+ License as published by the Free Software Foundation; either
+ version 2 of the License, or (at your option) any later version.
 
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Library General Public License for more details.
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Library General Public License for more details.
 
-	See included LICENSE file for details
+ See included LICENSE file for details
 
-	Changes:
-		Simon Wunderlich <dotslash at packetmixer.de>
-		+ added http_setAuth() to support basic http-authentication and some minor fixes
+ Changes:
+  Simon Wunderlich <dotslash at packetmixer.de>
+  + added http_setAuth() to support basic http-authentication and some minor fixes
 
  */
 
@@ -38,21 +38,21 @@
 char *auth = NULL;
 int hideUserAgent = 0;
 int hideReferer = 1;
-extern const char *http_errlist[];	/* Array of HTTP Fetcher error messages */
-extern char convertedError[128];	/* Buffer to used when errors contain %d */
+extern const char *http_errlist[]; /* Array of HTTP Fetcher error messages */
+extern char convertedError[128]; /* Buffer to used when errors contain %d */
 static int errorSource = 0;
 static int http_errno = 0;
-static int errorInt = 0;			/* When the error message has a %d in it,
-									 *	this variable is inserted */
+static int errorInt = 0;   /* When the error message has a %d in it,
+          * this variable is inserted */
 static int freeOldAgent = 0; /* Indicates previous malloc's */
 static int freeOldReferer = 0; /* Indicated previous malloc's */
 
 
 /*
  * Actually downloads the page, registering a hit (donation)
- *	If the fileBuf passed in is NULL, the url is downloaded and then
- *	freed; otherwise the necessary space is allocated for fileBuf.
- *	Returns size of download on success, -1 on error is set,
+ * If the fileBuf passed in is NULL, the url is downloaded and then
+ * freed; otherwise the necessary space is allocated for fileBuf.
+ * Returns size of download on success, -1 on error is set,
  */
 int http_fetch(const char *url_tmp, char **fileBuf)
 {
@@ -72,7 +72,7 @@
 	}
 
 	/* Copy the url passed in into a buffer we can work with, change, etc. */
-	url = malloc(strlen(url_tmp)+1);
+	url = malloc(strlen(url_tmp) + 1);
 	if (url == NULL) {
 		errorSource = ERRNO;
 		return -1;
@@ -94,7 +94,7 @@
 	/* Compose a request string */
 	if (charIndex == NULL)
 		/* The url has no '/' in it, assume the user is making a root-level
-		 *	request */
+		 * request */
 		sprintf(requestBuf, "GET / %s\r\n", HTTP_VERSION);
 	else
 		sprintf(requestBuf, "GET %s %s\r\n", charIndex, HTTP_VERSION);
@@ -107,7 +107,7 @@
 	strcat(requestBuf, "\r\n");
 
 
-	if (!hideReferer && referer != NULL) {	/* NO default referer */
+	if (!hideReferer && referer != NULL) { /* NO default referer */
 		strcat(requestBuf, "Referer: ");
 		strcat(requestBuf, referer);
 		strcat(requestBuf, "\r\n");
@@ -124,7 +124,7 @@
 		strcat(requestBuf, userAgent);
 		strcat(requestBuf, "\r\n");
 	}
-	if (auth!=NULL) {
+	if (auth != NULL) {
 		strcat(requestBuf, "Authorization: Basic ");
 		strcat(requestBuf, auth);
 		strcat(requestBuf, "\r\n");
@@ -132,7 +132,7 @@
 	strcat(requestBuf, "\r\n");
 
 	printf("[HTTP] creating connection ...\n");
-	sock = makeSocket(host);			/* errorSource set within makeSocket */
+	sock = makeSocket(host);   /* errorSource set within makeSocket */
 	if (sock == -1) {
 		free(url);
 		return -1;
@@ -147,7 +147,7 @@
 
 	printf("[HTTP] receiving header\n");
 	/* Grab enough of the response to get the metadata */
-	ret = _http_read_header(sock, headerBuf);	/* errorSource set within */
+	ret = _http_read_header(sock, headerBuf); /* errorSource set within */
 	if (ret < 0) {
 		close(sock);
 		free(url);
@@ -176,10 +176,10 @@
 		http_errno = HF_CRETURNCODE;
 		return -1;
 	}
-	if (i<200 || i>299) {
+	if (i < 200 || i > 299) {
 		close(sock);
 		free(url);
-		errorInt = i;	/* Status code, to be inserted in error string */
+		errorInt = i; /* Status code, to be inserted in error string */
 		errorSource = FETCHER_ERROR;
 		http_errno = HF_STATUSCODE;
 		return -1;
@@ -187,9 +187,9 @@
 
 	/*
 	 * Parse out about how big the data segment is.
-	 *	Note that under current HTTP standards (1.1 and prior), the
-	 *	Content-Length field is not guaranteed to be accurate or even present.
-	 *	I just use it here so I can allocate a ballpark amount of memory.
+	 * Note that under current HTTP standards (1.1 and prior), the
+	 * Content-Length field is not guaranteed to be accurate or even present.
+	 * I just use it here so I can allocate a ballpark amount of memory.
 	 *
 	 * Note that some servers use different capitalization
 	 */
@@ -213,7 +213,7 @@
 	if (contentLength == -1)
 		contentLength = DEFAULT_PAGE_BUF_SIZE;
 
-	pageBuf = (char *)malloc(contentLength+1);
+	pageBuf = (char *)malloc(contentLength + 1);
 	if (pageBuf == NULL) {
 		close(sock);
 		free(url);
@@ -229,9 +229,9 @@
 		tv.tv_usec = 0;
 
 		if (timeout >= 0)
-			selectRet = select(sock+1, &rfds, NULL, NULL, &tv);
-		else		/* No timeout, can block indefinately */
-			selectRet = select(sock+1, &rfds, NULL, NULL, NULL);
+			selectRet = select(sock + 1, &rfds, NULL, NULL, &tv);
+		else  /* No timeout, can block indefinately */
+			selectRet = select(sock + 1, &rfds, NULL, NULL, NULL);
 
 		if (selectRet == 0 && timeout < 0) {
 			errorSource = FETCHER_ERROR;
@@ -262,8 +262,8 @@
 
 		if (ret > 0) {
 			/* To be tolerant of inaccurate Content-Length fields, we'll
-			 *	allocate another read-sized chunk to make sure we have
-			 *	enough room.
+			 * allocate another read-sized chunk to make sure we have
+			 * enough room.
 			 */
 			pageBuf = (char *)realloc(pageBuf, bytesRead + contentLength);
 			if (pageBuf == NULL) {
@@ -274,7 +274,7 @@
 				return -1;
 			}
 		}
-		printf("[HTTP] read %d bytes\n",ret);
+		printf("[HTTP] read %d bytes\n", ret);
 	}
 
 	/*
@@ -282,9 +282,9 @@
 	 */
 	pageBuf = (char *)realloc(pageBuf, bytesRead);
 	/* pageBuf shouldn't be null, since we're _shrinking_ the buffer,
-	 *	and if it DID fail, we could go on with the too-large buffer,
-	 *	but something would DEFINATELY be wrong, so we'll just give
-	 *	an error message */
+	 * and if it DID fail, we could go on with the too-large buffer,
+	 * but something would DEFINATELY be wrong, so we'll just give
+	 * an error message */
 	if (pageBuf == NULL) {
 		close(sock);
 		free(url);
@@ -293,7 +293,7 @@
 		return -1;
 	}
 
-	if (fileBuf == NULL)	/* They just wanted us to "hit" the url */
+	if (fileBuf == NULL) /* They just wanted us to "hit" the url */
 		free(pageBuf);
 	else
 		*fileBuf = pageBuf;
@@ -363,46 +363,46 @@
 int http_setAuth(const char *user, const char *pass)
 {
 	unsigned char plain[1024];
-	char ec64[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+	char ec64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 	char *b64;
-	int i,j,c,len,n;
-	char o=0;
+	int i, j, c, len, n;
+	char o = 0;
 	/* base64 encode user and pass */
-	if ((user==NULL) || (pass==NULL)) { /* bad input or request to clean up */
-		if (auth!=NULL)	free(auth); /* free old auth */
-		auth=NULL;
+	if ((user == NULL) || (pass == NULL)) { /* bad input or request to clean up */
+		if (auth != NULL) free(auth); /* free old auth */
+		auth = NULL;
 		return(-1);
 	}
 
-	snprintf((char *)plain,1024,"%s:%s",user,pass);
-	len=strlen((char *)plain);
-	b64=malloc(len*4+1);
-	i=j=c=0;
-	while (i<len || c!=0) {
+	snprintf((char *)plain, 1024, "%s:%s", user, pass);
+	len = strlen((char *)plain);
+	b64 = malloc(len * 4 + 1);
+	i = j = c = 0;
+	while (i < len || c != 0) {
 		switch (c) {
 		case 0:
-			o=ec64[ n=plain[i] >> 2 ];
+			o = ec64[ n=plain[i] >> 2 ];
 			i++;
 			break;
 		case 1:
-			o=ec64[ n=((plain[i-1]&0x3)<<4) | (plain[i]>>4) ];
+			o = ec64[ n=((plain[i-1] & 0x3) << 4) | (plain[i] >> 4)];
 			i++;
 			break;
 		case 2:
-			o=(i>=len)?'=':ec64[ n=((plain[i-1]&0xf)<<2) | (plain[i]>>6) ];
+			o = (i >= len) ? '=' : ec64[ n=((plain[i-1] & 0xf) << 2) | (plain[i] >> 6)];
 			break;
 		case 3:
-			o=(i>=len)?'=':ec64[ n=(plain[i]&0x3f) ];
+			o = (i >= len) ? '=' : ec64[ n=(plain[i] & 0x3f)];
 			i++;
 			break;
 		}
-		b64[j]=o;
-		c=(c+1)%4;
+		b64[j] = o;
+		c = (c + 1) % 4;
 		j++;
 	}
-	b64[j]=0;
-	if (auth!=NULL)	free(auth); /* free old auth */
-	auth=b64;
+	b64[j] = 0;
+	if (auth != NULL) free(auth); /* free old auth */
+	auth = b64;
 	return(0);
 
 
@@ -413,7 +413,7 @@
 
 /*
  * Changes the amount of time that HTTP Fetcher will wait for data
- *	before timing out on reads
+ * before timing out on reads
  */
 void http_setTimeout(int seconds)
 {
@@ -425,10 +425,10 @@
 /*
  * Puts the filename portion of the url into 'filename'.
  * Returns:
- *	0 on success
- *	1 when url contains no end filename (i.e., 'www.foo.com/'),
- *		and **filename should not be assumed to be valid
- *	-1 on error
+ * 0 on success
+ * 1 when url contains no end filename (i.e., 'www.foo.com/'),
+ *  and **filename should not be assumed to be valid
+ * -1 on error
  */
 int http_parseFilename(const char *url, char **filename)
 {
@@ -461,7 +461,7 @@
 
 
 /* Depending on the source of error, calls either perror() or prints
- *	an HTTP Fetcher error message to stdout */
+ * an HTTP Fetcher error message to stdout */
 void http_perror(const char *string)
 {
 	if (errorSource == ERRNO)
@@ -479,13 +479,13 @@
 		} else {
 			/* The error string has a %d in it, we need to insert errorInt */
 			stringIndex = (char *)http_errlist[http_errno];
-			while (*stringIndex != '%') {		/* Print up to the %d */
+			while (*stringIndex != '%') {  /* Print up to the %d */
 				fputc(*stringIndex, stderr);
 				stringIndex++;
 			}
-			fprintf(stderr, "%d", errorInt);	/* Print the number */
-			stringIndex += 2;					/* Skip past the %d */
-			while (*stringIndex != 0) {		/* Print up to the end NULL */
+			fprintf(stderr, "%d", errorInt); /* Print the number */
+			stringIndex += 2;     /* Skip past the %d */
+			while (*stringIndex != 0) {  /* Print up to the end NULL */
 				fputc(*stringIndex, stderr);
 				stringIndex++;
 			}
@@ -498,9 +498,9 @@
 
 /*
  * Returns a pointer to the current error description message. The
- *	message pointed to is only good until the next call to http_strerror(),
- *	so if you need to hold on to the message for a while you should make
- *	a copy of it
+ * message pointed to is only good until the next call to http_strerror(),
+ * so if you need to hold on to the message for a while you should make
+ * a copy of it
  */
 const char *http_strerror()
 {
@@ -513,33 +513,33 @@
 			return http_errlist[http_errno];
 		else {
 			/* The error string has a %d in it, we need to insert errorInt.
-			 *	convertedError[128] has been declared for that purpose */
+			 * convertedError[128] has been declared for that purpose */
 			char *stringIndex, *originalError;
 
 			originalError = (char *)http_errlist[http_errno];
-			convertedError[0] = 0;		/* Start off with NULL */
+			convertedError[0] = 0;  /* Start off with NULL */
 			stringIndex = strstr(originalError, "%d");
-			strncat(convertedError, originalError,		/* Copy up to %d */
+			strncat(convertedError, originalError,  /* Copy up to %d */
 			        abs(stringIndex - originalError));
-			sprintf(&convertedError[strlen(convertedError)],"%d",errorInt);
-			stringIndex += 2;		/* Skip past the %d */
+			sprintf(&convertedError[strlen(convertedError)], "%d", errorInt);
+			stringIndex += 2;  /* Skip past the %d */
 			strcat(convertedError, stringIndex);
 
 			return convertedError;
 		}
 	}
 
-	return http_errlist[HF_METAERROR];	/* Should NEVER happen */
+	return http_errlist[HF_METAERROR]; /* Should NEVER happen */
 }
 
 
 /*
  * Reads the metadata of an HTTP response.
  * Perhaps a little inefficient, as it reads 1 byte at a time, but
- *	I don't think it's that much of a loss (most headers aren't HUGE).
+ * I don't think it's that much of a loss (most headers aren't HUGE).
  * Returns:
- *	# of bytes read on success, or
- *	-1 on error
+ * # of bytes read on success, or
+ * -1 on error
  */
 int _http_read_header(int sock, char *headerPtr)
 {
@@ -554,9 +554,9 @@
 		tv.tv_usec = 0;
 
 		if (timeout >= 0)
-			selectRet = select(sock+1, &rfds, NULL, NULL, &tv);
-		else		/* No timeout, can block indefinately */
-			selectRet = select(sock+1, &rfds, NULL, NULL, NULL);
+			selectRet = select(sock + 1, &rfds, NULL, NULL, &tv);
+		else  /* No timeout, can block indefinately */
+			selectRet = select(sock + 1, &rfds, NULL, NULL, NULL);
 
 		if (selectRet == 0 && timeout < 0) {
 			errorSource = FETCHER_ERROR;
@@ -575,12 +575,12 @@
 		}
 		bytesRead++;
 
-		if (*headerPtr == '\r') {		/* Ignore CR */
+		if (*headerPtr == '\r') {  /* Ignore CR */
 			/* Basically do nothing special, just don't set newlines
-			 *	to 0 */
+			 * to 0 */
 			headerPtr++;
 			continue;
-		} else if (*headerPtr == '\n')		/* LF is the separator */
+		} else if (*headerPtr == '\n')  /* LF is the separator */
 			newlines++;
 		else
 			newlines = 0;
@@ -588,7 +588,7 @@
 		headerPtr++;
 	}
 
-	headerPtr -= 3;		/* Snip the trailing LF's */
+	headerPtr -= 3;  /* Snip the trailing LF's */
 	*headerPtr = '\0';
 	return bytesRead;
 }
@@ -598,14 +598,14 @@
 /*
  * Opens a TCP socket and returns the descriptor
  * Returns:
- *	socket descriptor, or
- *	-1 on error
+ * socket descriptor, or
+ * -1 on error
  */
 int makeSocket(const char *host)
 {
-	int sock;										/* Socket descriptor */
-	struct sockaddr_in sa;							/* Socket address */
-	struct hostent *hp;								/* Host entity */
+	int sock;          /* Socket descriptor */
+	struct sockaddr_in sa;       /* Socket address */
+	struct hostent *hp;        /* Host entity */
 	int ret;
 
 	hp = gethostbyname(host);
@@ -616,8 +616,8 @@
 
 	/* Copy host address from hostent to (server) socket address */
 	memcpy((char *)&sa.sin_addr, (char *)hp->h_addr, hp->h_length);
-	sa.sin_family = hp->h_addrtype;		/* Set service sin_family to PF_INET */
-	sa.sin_port = htons(PORT_NUMBER);	/* Put portnum into sockaddr */
+	sa.sin_family = hp->h_addrtype;  /* Set service sin_family to PF_INET */
+	sa.sin_port = htons(PORT_NUMBER); /* Put portnum into sockaddr */
 
 	sock = socket(hp->h_addrtype, SOCK_STREAM, 0);
 	if (sock == -1) {
@@ -625,7 +625,7 @@
 		return -1;
 	}
 
-	ret = connect(sock, (struct sockaddr *)&sa, sizeof(sa));
+	ret = connect(sock, (struct sockaddr *) & sa, sizeof(sa));
 	if (ret == -1) {
 		errorSource = ERRNO;
 		return -1;

Modified: trunk/apps/s3dosm/http_fetcher.h
===================================================================
--- trunk/apps/s3dosm/http_fetcher.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/http_fetcher.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,23 +1,23 @@
 /* http_fetcher.h - HTTP handling functions
 
-	HTTP Fetcher
-	Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
+ HTTP Fetcher
+ Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
 
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Library General Public
-	License as published by the Free Software Foundation; either
-	version 2 of the License, or (at your option) any later version.
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Library General Public
+ License as published by the Free Software Foundation; either
+ version 2 of the License, or (at your option) any later version.
 
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Library General Public License for more details.
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Library General Public License for more details.
 
-	See LICENSE file for details
+ See LICENSE file for details
 
-	Changes:
-		Simon Wunderlich <dotslash at packetmixer.de>
-		+ added http_setAuth() to support basic http-authentication and some minor fixes
+ Changes:
+  Simon Wunderlich <dotslash at packetmixer.de>
+  + added http_setAuth() to support basic http-authentication and some minor fixes
 
  */
 
@@ -26,16 +26,15 @@
 
 #include "http_error_codes.h"
 
-#define PORT_NUMBER 			80
-#define HTTP_VERSION 			"HTTP/1.1"
-#define DEFAULT_USER_AGENT		"HTTP Fetcher"
-#define	HTTP_FETCHER_VERSION	"1.0"
-#define DEFAULT_READ_TIMEOUT	30		/* Seconds to wait before giving up
-*	when no data is arriving */
+#define PORT_NUMBER    80
+#define HTTP_VERSION    "HTTP/1.1"
+#define DEFAULT_USER_AGENT  "HTTP Fetcher"
+#define HTTP_FETCHER_VERSION "1.0"
+#define DEFAULT_READ_TIMEOUT 30  /* Seconds to wait before giving up when no data is arriving */
 
-#define REQUEST_BUF_SIZE 		1024
-#define HEADER_BUF_SIZE 		1024
-#define DEFAULT_PAGE_BUF_SIZE 	1024 * 200	/* 200K should hold most things */
+#define REQUEST_BUF_SIZE   1024
+#define HEADER_BUF_SIZE   1024
+#define DEFAULT_PAGE_BUF_SIZE  1024 * 200 /* 200K should hold most things */
 
 
 
@@ -45,48 +44,48 @@
 
 /*
  * [!!! NOTE !!!]  All HTTP Fetcher functions return -1 on error.  You can
- *	then either call http_perror to print the error message or call
- *	http_strerror to get a pointer to it
+ * then either call http_perror to print the error message or call
+ * http_strerror to get a pointer to it
  */
 
 
 /*
  * Download the page, registering a hit. If you pass it a NULL for fileBuf,
- *	'url' will be requested but will not remain in memory (useful for
- *	simply registering a hit).  Otherwise necessary space will be allocated
- *	and will be pointed to by fileBuf.
+ * 'url' will be requested but will not remain in memory (useful for
+ * simply registering a hit).  Otherwise necessary space will be allocated
+ * and will be pointed to by fileBuf.
  * Returns:
- *	# of bytes downloaded, or
- *	-1 on error
+ * # of bytes downloaded, or
+ * -1 on error
  */
 int http_fetch(const char *url, char **fileBuf);
 
 /*
  * Changes the User Agent (shown to the web server with each request)
- *	Send it NULL to avoid telling the server a User Agent
- *	By default, the User Agent is sent (The default one unless changed)
+ * Send it NULL to avoid telling the server a User Agent
+ * By default, the User Agent is sent (The default one unless changed)
  * Returns:
- *	0 on success, or
- *	-1 on error (previous value for agent remains unchanged)
+ * 0 on success, or
+ * -1 on error (previous value for agent remains unchanged)
  */
 int http_setUserAgent(const char *newAgent);
 
 /*
  * Changes the Referer (shown to the web server with each request)
- *	Send it NULL to avoid thelling the server a Referer
- *	By default, no Referer is sent
+ * Send it NULL to avoid thelling the server a Referer
+ * By default, no Referer is sent
  * Returns:
- *	0 on success, or
- *	-1 on error
+ * 0 on success, or
+ * -1 on error
  */
 int http_setReferer(const char *newReferer);
 
 /*
  * Changes the maximum amount of time that HTTP Fetcher will wait on
- *	data.  If this many seconds elapses without more data from the
- *	server, http_fetch will return with an error.
+ * data.  If this many seconds elapses without more data from the
+ * server, http_fetch will return with an error.
  * If you pass a value less than 0, reads will not time out, potentially
- *	waiting forever (or until data shows up, whichever comes first)
+ * waiting forever (or until data shows up, whichever comes first)
  */
 void http_setTimeout(int seconds);
 
@@ -101,24 +100,24 @@
 /*
  * Takes a url and puts the filename portion of it into 'filename'.
  * Returns:
- *	0 on success, or
- *	1 when url contains no end filename (i.e., "www.foo.com/")
- *		and **filename should not be assumed to point to anything), or
- *	-1 on error
+ * 0 on success, or
+ * 1 when url contains no end filename (i.e., "www.foo.com/")
+ *  and **filename should not be assumed to point to anything), or
+ * -1 on error
  */
 int http_parseFilename(const char *url, char **filename);
 
 /*
  * Works like perror.  If an HTTP Fetcher function ever returns an
- *	error (-1), this will print a descriptive message to standard output
+ * error (-1), this will print a descriptive message to standard output
  */
 void http_perror(const char *string);
 
 /*
  * Returns a pointer to the current error description message.  The
- *	message pointed to is only good until the next call to http_strerror(),
- *	so if you need to hold on to the message for a while you should make
- *	a copy of it.
+ * message pointed to is only good until the next call to http_strerror(),
+ * so if you need to hold on to the message for a while you should make
+ * a copy of it.
  */
 const char *http_strerror();
 
@@ -131,16 +130,16 @@
 /*
  * Reads the metadata of an HTTP response.  On success returns the number
  * Returns:
- *	# of bytes read on success, or
- *	-1 on error
+ * # of bytes read on success, or
+ * -1 on error
  */
 int _http_read_header(int sock, char *headerPtr);
 
 /*
  * Opens a TCP socket and returns the descriptor
  * Returns:
- *	socket descriptor, or
- *	-1 on error
+ * socket descriptor, or
+ * -1 on error
  */
 int makeSocket(const char *host);
 

Modified: trunk/apps/s3dosm/io.c
===================================================================
--- trunk/apps/s3dosm/io.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/io.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,67 +23,67 @@
 
 
 #include "s3dosm.h"
-#include <stdio.h>		 /* fopen(), fread(), fclose() */
-#include <stdlib.h>		 /* malloc(), free() */
-#include <string.h>		 /* strstr() */
-#include <sys/stat.h>	 /* fstat() */
-#include <getopt.h>		 /* getopt() */
-#include <errno.h>		 /* errno */
-#include <s3d.h>		 /* s3d_usage() */
+#include <stdio.h>   /* fopen(), fread(), fclose() */
+#include <stdlib.h>   /* malloc(), free() */
+#include <string.h>   /* strstr() */
+#include <sys/stat.h>  /* fstat() */
+#include <getopt.h>   /* getopt() */
+#include <errno.h>   /* errno */
+#include <s3d.h>   /* s3d_usage() */
 
 char *read_file(char *fname, int *fsize)
 {
 	FILE *fp;
-	char *buf=NULL;
+	char *buf = NULL;
 	int filesize;
 	struct stat bf;
 
-	if ((fp = fopen(fname, "rt")) == NULL)	{
-		fprintf(stderr,"read_file( %s ):fopen(): %s",fname,strerror(errno));
+	if ((fp = fopen(fname, "rt")) == NULL) {
+		fprintf(stderr, "read_file( %s ):fopen(): %s", fname, strerror(errno));
 		return(NULL);
 	}
-	if (fstat(fileno(fp),&bf))				{
-		fprintf(stderr,"read_file( %s ):fopen(): %s",fname,strerror(errno));
+	if (fstat(fileno(fp), &bf))    {
+		fprintf(stderr, "read_file( %s ):fopen(): %s", fname, strerror(errno));
 		return(NULL);
 	}
-	filesize=bf.st_size;
-	if ((buf=malloc(filesize))==NULL)		{
-		fprintf(stderr,"read_file( %s ):malloc(): %s",fname,strerror(errno));
+	filesize = bf.st_size;
+	if ((buf = malloc(filesize)) == NULL)  {
+		fprintf(stderr, "read_file( %s ):malloc(): %s", fname, strerror(errno));
 		return(NULL);
 	}
 	fread(buf, filesize, 1, fp);
 	fclose(fp);
-	if (fsize!=NULL) *fsize=filesize;
+	if (fsize != NULL) *fsize = filesize;
 	return(buf);
 }
 
 int process_args(int argc, char **argv)
 {
-	int					 lopt_idx=0,i;
-	char				 c;
-	float				 minlat, minlon, maxlat, maxlon;
-	char 				 info[1024];
+	int      lopt_idx = 0, i;
+	char     c;
+	float     minlat, minlon, maxlat, maxlon;
+	char      info[1024];
 	struct option long_options[] = {
-		{"help",0,0,'h'
-		}, {"osm",1,0,'o'}, {0,0,0,0}
+		{"help", 0, 0, 'h'
+		}, {"osm", 1, 0, 'o'}, {0, 0, 0, 0}
 	};
-	optind=0;
-	opterr=0;
-	while (-1!=(c=getopt_long(argc,argv,"dH:?ho",long_options,&lopt_idx))) {
+	optind = 0;
+	opterr = 0;
+	while (-1 != (c = getopt_long(argc, argv, "dH:?ho", long_options, &lopt_idx))) {
 		switch (c) {
 		case 0:
 			break;
 		case 'o':
-			if (4==sscanf(optarg,"%f,%f,%f,%f",&minlat,&minlon,&maxlat,&maxlon))
-				layerset_add(load_osm_web(minlat,minlon,maxlat,maxlon));
+			if (4 == sscanf(optarg, "%f,%f,%f,%f", &minlat, &minlon, &maxlat, &maxlon))
+				layerset_add(load_osm_web(minlat, minlon, maxlat, maxlon));
 			else {
-				printf("%s: bad map bounding box",optarg);
+				printf("%s: bad map bounding box", optarg);
 				return(-1);
 			}
 			break;
 		case 'h':
 		case '?':
-			printf("\nUSAGE: %s [options] [files]\n\n",argv[0]);
+			printf("\nUSAGE: %s [options] [files]\n\n", argv[0]);
 			printf("options:\n");
 			printf("\t--osm, -o MINLAT,MINLON,MAXLAT,MAXLON:\n");
 			printf("\t\tload a map with the given bounding box\n\t\tfrom the openstreetmap server\n");
@@ -91,30 +91,30 @@
 			printf("supported file types:\n");
 			printf("\t+ Kismet .xml Logs\n");
 			printf("\t+ Opemstreetmap .osm files\n\n");
-			s3d_usage();	/* add s3d usage */
+			s3d_usage(); /* add s3d usage */
 			return(-1);
 		default:
 			break;
 		}
 	}
-	for (i=1;i<argc;i++) {
-		if (strstr(argv[i],".osm")-argv[i]==strlen(argv[i])-4) {
-			snprintf(info,1024,"loading OSM-File: %s",argv[i]);
+	for (i = 1;i < argc;i++) {
+		if (strstr(argv[i], ".osm") - argv[i] == strlen(argv[i]) - 4) {
+			snprintf(info, 1024, "loading OSM-File: %s", argv[i]);
 			load_window(info);
 			layerset_add(load_osm_file(argv[i]));
-		} else if (strstr(argv[i],".xml")-argv[i]==strlen(argv[i])-4) { /* might be osm or kismet xml */
+		} else if (strstr(argv[i], ".xml") - argv[i] == strlen(argv[i]) - 4) { /* might be osm or kismet xml */
 			char *file;
 			int fsize;
-			if (NULL==(file=read_file(argv[i],&fsize)))
+			if (NULL == (file = read_file(argv[i], &fsize)))
 				break;
-			if (NULL!=strstr(file,"<!DOCTYPE detection-run SYSTEM \"http://kismetwireless.net")) {
-				snprintf(info,1024,"loading Kismet-File: %s",argv[i]);
+			if (NULL != strstr(file, "<!DOCTYPE detection-run SYSTEM \"http://kismetwireless.net")) {
+				snprintf(info, 1024, "loading Kismet-File: %s", argv[i]);
 				load_window(info);
-				layerset_add(parse_kismet(file,fsize));
-			} else if (NULL!=strstr(file,"<osm ")) {
-				snprintf(info,1024,"loading OSM-File: %s",argv[i]);
+				layerset_add(parse_kismet(file, fsize));
+			} else if (NULL != strstr(file, "<osm ")) {
+				snprintf(info, 1024, "loading OSM-File: %s", argv[i]);
 				load_window(info);
-				layerset_add(parse_osm(file,fsize));
+				layerset_add(parse_osm(file, fsize));
 			}
 			free(file);
 		}

Modified: trunk/apps/s3dosm/kismet.c
===================================================================
--- trunk/apps/s3dosm/kismet.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/kismet.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,9 +22,9 @@
  */
 
 #include "s3dosm.h"
-#include <math.h>			/* fabs() */
-#include <string.h>			/* strcmp() */
-#include <stdlib.h>			/* strtof(),strtod(),strtol() */
+#include <math.h>   /* fabs() */
+#include <string.h>   /* strcmp() */
+#include <stdlib.h>   /* strtof(),strtod(),strtol() */
 #include <libxml/parser.h>
 #include <libxml/tree.h>
 static int layerid;
@@ -32,41 +32,41 @@
 {
 	node_t node;
 	xmlAttrPtr attr;
-	xmlNodePtr kids,gpskids;
+	xmlNodePtr kids, gpskids;
 
 	node_init(&node);
-	attr=cur->properties;
+	attr = cur->properties;
 
-	node.base.layerid=layerid;
-	node.base.id=0;				/* let database decide */
-	node.visible=2;	/* something special */
-	for (kids=cur->children;kids;kids=kids->next) {
-		if (0==strcmp((char *)kids->name,"gps-info")) {
-			for (gpskids=kids->children;gpskids;gpskids=gpskids->next) {
+	node.base.layerid = layerid;
+	node.base.id = 0;  /* let database decide */
+	node.visible = 2; /* something special */
+	for (kids = cur->children;kids;kids = kids->next) {
+		if (0 == strcmp((char *)kids->name, "gps-info")) {
+			for (gpskids = kids->children;gpskids;gpskids = gpskids->next) {
 				/* get median value */
-				if (0==strcmp((char *)gpskids->name,"min-lat")) 		node.lat=node.lat + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
-				if (0==strcmp((char *)gpskids->name,"max-lat")) 		node.lat=node.lat + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
-				if (0==strcmp((char *)gpskids->name,"min-lon")) 		node.lon=node.lon + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
-				if (0==strcmp((char *)gpskids->name,"max-lon")) 		node.lon=node.lon + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
-				if (0==strcmp((char *)gpskids->name,"min-alt")) 		node.alt=node.alt + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
-				if (0==strcmp((char *)gpskids->name,"max-alt")) 		node.alt=node.alt + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
+				if (0 == strcmp((char *)gpskids->name, "min-lat"))   node.lat = node.lat + strtod((char *)xmlNodeGetContent(gpskids->children), NULL) / 2;
+				if (0 == strcmp((char *)gpskids->name, "max-lat"))   node.lat = node.lat + strtod((char *)xmlNodeGetContent(gpskids->children), NULL) / 2;
+				if (0 == strcmp((char *)gpskids->name, "min-lon"))   node.lon = node.lon + strtod((char *)xmlNodeGetContent(gpskids->children), NULL) / 2;
+				if (0 == strcmp((char *)gpskids->name, "max-lon"))   node.lon = node.lon + strtod((char *)xmlNodeGetContent(gpskids->children), NULL) / 2;
+				if (0 == strcmp((char *)gpskids->name, "min-alt"))   node.alt = node.alt + strtod((char *)xmlNodeGetContent(gpskids->children), NULL) / 2;
+				if (0 == strcmp((char *)gpskids->name, "max-alt"))   node.alt = node.alt + strtod((char *)xmlNodeGetContent(gpskids->children), NULL) / 2;
 			}
 		}
 	}
-	if ((fabs(node.lon)>0.01) || (fabs(node.lat)>0.01)) /* really, i don't want to discriminate anyone at 0 lat 0 lon running a wifi hotspot, even
-																	if it's in the middle of the ocean. i'm very sorry. */
+	if ((fabs(node.lon) > 0.01) || (fabs(node.lat) > 0.01)) /* really, i don't want to discriminate anyone at 0 lat 0 lon running a wifi hotspot, even
+                 if it's in the middle of the ocean. i'm very sorry. */
 	{
 
 		db_insert_node(&node);
-		for (kids=cur->children;kids;kids=kids->next) {
-			if (0==strcmp((char *)kids->name,"SSID")) 			db_add_tag(OBJECT_T(&node),"wifi_SSID",(char *)xmlNodeGetContent(kids->children));
-			if (0==strcmp((char *)kids->name,"BSSID")) 			db_add_tag(OBJECT_T(&node),"wifi_BSSID",(char *)xmlNodeGetContent(kids->children));
+		for (kids = cur->children;kids;kids = kids->next) {
+			if (0 == strcmp((char *)kids->name, "SSID"))    db_add_tag(OBJECT_T(&node), "wifi_SSID", (char *)xmlNodeGetContent(kids->children));
+			if (0 == strcmp((char *)kids->name, "BSSID"))    db_add_tag(OBJECT_T(&node), "wifi_BSSID", (char *)xmlNodeGetContent(kids->children));
 		}
-		for (attr=cur->properties;attr;attr=attr->next) {
-			/*		if (0==strcmp((char *)attr->name,"number")) 		node->base.id=		strtol((char *)attr->children->content,NULL,10);
-					else */
-			if (0==strcmp((char *)attr->name,"wep")) 	db_add_tag(OBJECT_T(&node),"wifi_wep",(char *)attr->children->content);
-			else if (0==strcmp((char *)attr->name,"type")) 		db_add_tag(OBJECT_T(&node),"wifi_type",(char *)attr->children->content);
+		for (attr = cur->properties;attr;attr = attr->next) {
+			/*  if (0==strcmp((char *)attr->name,"number"))   node->base.id=  strtol((char *)attr->children->content,NULL,10);
+			  else */
+			if (0 == strcmp((char *)attr->name, "wep"))  db_add_tag(OBJECT_T(&node), "wifi_wep", (char *)attr->children->content);
+			else if (0 == strcmp((char *)attr->name, "type"))   db_add_tag(OBJECT_T(&node), "wifi_type", (char *)attr->children->content);
 		}
 
 		db_add_tag(OBJECT_T(&node), "amenity", "wifi");
@@ -77,32 +77,32 @@
 layer_t *parse_kismet(char *buf, int length)
 {
 	xmlDocPtr doc;
-	xmlNodePtr cur,c;
-	layer_t *layer=layer_new();
-	int i=0;
-	float n=0;
+	xmlNodePtr cur, c;
+	layer_t *layer = layer_new();
+	int i = 0;
+	float n = 0;
 
 
 	doc = xmlReadMemory(buf, length, "noname.xml", NULL, 0);
 	if (doc == NULL) {
-		fprintf(stderr,"Document not parsed successfully.\n");
+		fprintf(stderr, "Document not parsed successfully.\n");
 		return(NULL);
 	}
 	cur = xmlDocGetRootElement(doc);
 	if (cur == NULL) {
-		fprintf(stderr,"empty document\n");
+		fprintf(stderr, "empty document\n");
 		xmlFreeDoc(doc);
 		return(NULL);
 	}
-	layerid=db_insert_layer("kismet");
-	for (c=cur->children;  c!=NULL;   c=c->next) 		n++; /* count */
-	for (cur=cur->children;cur!=NULL; cur=cur->next) {
-		if (cur->type==XML_ELEMENT_NODE) {
-			if (0==strcmp((char *)cur->name,"wireless-network")) {
+	layerid = db_insert_layer("kismet");
+	for (c = cur->children;  c != NULL;   c = c->next)   n++; /* count */
+	for (cur = cur->children;cur != NULL; cur = cur->next) {
+		if (cur->type == XML_ELEMENT_NODE) {
+			if (0 == strcmp((char *)cur->name, "wireless-network")) {
 				parse_kismet_node(cur);
 			}
 		}
-		if ((i++)%10==0) load_update_status(100*((float)i)/n);
+		if ((i++) % 10 == 0) load_update_status(100*((float)i) / n);
 
 	}
 	db_flush();
@@ -114,8 +114,8 @@
 	int length;
 	char *file;
 	layer_t *ret;
-	if (NULL==(file=read_file(filename,&length))) return(NULL);
-	ret=parse_kismet(file,length);
+	if (NULL == (file = read_file(filename, &length))) return(NULL);
+	ret = parse_kismet(file, length);
 	free(file);
 	return ret;
 }

Modified: trunk/apps/s3dosm/main.c
===================================================================
--- trunk/apps/s3dosm/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,34 +22,34 @@
  */
 
 
-#include <stdio.h>		 /*  snprintf(), printf(), NULL */
+#include <stdio.h>   /*  snprintf(), printf(), NULL */
 #include <s3d.h>
 #include <s3dw.h>
 #include "s3dosm.h"
-#include <time.h>	 /*  nanosleep(), struct tm, time_t...  */
-static int ready=0;
+#include <time.h>  /*  nanosleep(), struct tm, time_t...  */
+static int ready = 0;
 
 void mainloop()
 {
-	struct timespec t= {
-		0,100*1000*1000
+	struct timespec t = {
+		0, 100*1000*1000
 	}; /* 100 mili seconds */
 	if (ready) {
-		nanosleep(&t,NULL);
+		nanosleep(&t, NULL);
 		gps_main();
 		nav_main();
 		s3dw_ani_mate();
 	} /* else {
-		s3d_net_check(); / * we are not yet in the mainloop of
-							s3d_mainloop(), because ready==0,
-							so we check protocol things ourselves.
-							This just prevents timing out from the server
-							because map loading takes so long, you shouldn't take
-							this as good example and write proper threaded or
-							timesliced loaders :) * /
-		s3d_process_stack();
-	}
-	s3dw_ani_mate();*/
+  s3d_net_check(); / * we are not yet in the mainloop of
+       s3d_mainloop(), because ready==0,
+       so we check protocol things ourselves.
+       This just prevents timing out from the server
+       because map loading takes so long, you shouldn't take
+       this as good example and write proper threaded or
+       timesliced loaders :) * /
+  s3d_process_stack();
+ }
+ s3dw_ani_mate();*/
 }
 int init(int argc, char **argv)
 {
@@ -57,17 +57,17 @@
 	ui_init();
 	if (db_init(":memory:")) return(-1);
 	if (db_create()) return(-1);
-	if (process_args(argc,argv)) return(-1);
+	if (process_args(argc, argv)) return(-1);
 	nav_init();
 	nav_autocenter();
 	draw_all_layers();
 	gps_init("localhost");
-	ready=1;
+	ready = 1;
 	return(0);
 }
 int quit()
 {
-	ready=0;
+	ready = 0;
 	gps_quit();
 	s3d_quit();
 	db_quit();
@@ -75,7 +75,7 @@
 }
 int main(int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"s3dosm")) {
+	if (!s3d_init(&argc, &argv, "s3dosm")) {
 		if (!init(argc, argv)) s3d_mainloop(mainloop);
 		quit();
 	} else return(-1);

Modified: trunk/apps/s3dosm/nav.c
===================================================================
--- trunk/apps/s3dosm/nav.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/nav.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,85 +1,85 @@
 #include "s3dosm.h"
 #include <s3d.h>
-#include <string.h>	/* strcmp() */
-#include <stdlib.h>	/* strtod() */
-#include <stdio.h>	/* printf() */
-#include <math.h>	/* fabs() */
+#include <string.h> /* strcmp() */
+#include <stdlib.h> /* strtod() */
+#include <stdio.h> /* printf() */
+#include <math.h> /* fabs() */
 
 int oidx, oidy;
-static float lat,lon,tlat,tlon;
+static float lat, lon, tlat, tlon;
 /* load rotation centers */
 void nav_init()
 {
-	lat=lon=tlat=tlon=0.0;
-	oidx=s3d_new_object();
-	oidy=s3d_new_object();
-	s3d_link(oidy,oidx);
-	s3d_translate(oidx,0,-ESIZE*RESCALE- VIEWHEIGHT,0);
-	s3d_scale(oidx,RESCALE);
+	lat = lon = tlat = tlon = 0.0;
+	oidx = s3d_new_object();
+	oidy = s3d_new_object();
+	s3d_link(oidy, oidx);
+	s3d_translate(oidx, 0, -ESIZE*RESCALE - VIEWHEIGHT, 0);
+	s3d_scale(oidx, RESCALE);
 }
 /* center to given latitude longitude */
 void nav_center(float la, float lo)
 {
-	tlat=la;
-	tlon=lo;
+	tlat = la;
+	tlon = lo;
 }
 void nav_campos(float campos[3], float earthpos[3])
 {
 
-	float tmp1[3],tmp2[3];
+	float tmp1[3], tmp2[3];
 	float alpha;
 
-	tmp1[0]=campos[0];
-	tmp1[1]=campos[1] + ESIZE*RESCALE +VIEWHEIGHT;
-	tmp1[2]=campos[2];
+	tmp1[0] = campos[0];
+	tmp1[1] = campos[1] + ESIZE * RESCALE + VIEWHEIGHT;
+	tmp1[2] = campos[2];
 
-	alpha= (90-lat) *M_PI/180.0;
-	tmp2[0]=  tmp1[0];
-	tmp2[1]=  tmp1[1]*cos(alpha) - tmp1[2] * sin (alpha);
-	tmp2[2]=  tmp1[1]*sin(alpha) + tmp1[2] * cos (alpha);
+	alpha = (90 - lat) * M_PI / 180.0;
+	tmp2[0] =  tmp1[0];
+	tmp2[1] =  tmp1[1] * cos(alpha) - tmp1[2] * sin(alpha);
+	tmp2[2] =  tmp1[1] * sin(alpha) + tmp1[2] * cos(alpha);
 
-	alpha= lon *M_PI/180.0;
-	tmp1[0]=  tmp2[0]*cos(alpha) + tmp2[2] * sin (alpha);
-	tmp1[1]=  tmp2[1];
-	tmp1[2]=  - tmp2[0]*sin(alpha) + tmp2[2] * cos (alpha);
+	alpha = lon * M_PI / 180.0;
+	tmp1[0] =  tmp2[0] * cos(alpha) + tmp2[2] * sin(alpha);
+	tmp1[1] =  tmp2[1];
+	tmp1[2] =  - tmp2[0] * sin(alpha) + tmp2[2] * cos(alpha);
 
 
 
-	earthpos[0]=tmp1[0];
-	earthpos[1]=tmp1[1];
-	earthpos[2]=tmp1[2];
+	earthpos[0] = tmp1[0];
+	earthpos[1] = tmp1[1];
+	earthpos[2] = tmp1[2];
 
 }
 void nav_main()
 {
 	float x[3];
-	if ((fabs(tlat-lat)>0.00001) && (fabs(tlon-lon)>0.00001)) {
-		if (lat==0.0 && lon==0.0) {
-			lat=tlat;
-			lon=tlon;
+	if ((fabs(tlat - lat) > 0.00001) && (fabs(tlon - lon) > 0.00001)) {
+		if (lat == 0.0 && lon == 0.0) {
+			lat = tlat;
+			lon = tlon;
 		} else {
-			lat=(tlat+lat*15)/16;
-			lon=(tlon+lon*15)/16;
+			lat = (tlat + lat * 15) / 16;
+			lon = (tlon + lon * 15) / 16;
 		}
 	} else {
-		lat=tlat;
-		lon=tlon;
+		lat = tlat;
+		lon = tlon;
 	}
-	s3d_rotate(oidy,0,-lon,0);
-	s3d_rotate(oidx,-(90-lat),0,0);
-	calc_earth_to_eukl(lon,lat,0,x);
+	s3d_rotate(oidy, 0, -lon, 0);
+	s3d_rotate(oidx, -(90 - lat), 0, 0);
+	calc_earth_to_eukl(lon, lat, 0, x);
 }
 
 int get_center(void *data, int argc, char **argv, char **azColName)
 {
-	float *med=(float *)data;
+	float *med = (float *)data;
 	int i;
-	med[0]=0;
-	med[1]=0;
-	for (i=0; i<argc; i++) {
+	med[0] = 0;
+	med[1] = 0;
+	for (i = 0; i < argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],"la"))			med[0]=strtod(argv[i],NULL);
-			else if (0==strcmp(azColName[i],"lo"))		med[1]=strtod(argv[i],NULL);
+			if (0 == strcmp(azColName[i], "la"))   med[0] = strtod(argv[i], NULL);
+			else if (0 == strcmp(azColName[i], "lo"))  med[1] = strtod(argv[i], NULL);
 		}
 	}
 	return(0);
@@ -88,25 +88,25 @@
 float get_heading(float la1, float lo1, float la2, float lo2)
 {
 	float p1_north[3], p1[3], p2[3];
-	float dir[3],north[3];
+	float dir[3], north[3];
 	float angle;
 	int i;
-	calc_earth_to_eukl(la1,lo1,0,p1);
-	calc_earth_to_eukl(la2,lo2,0,p2);
-	calc_earth_to_eukl(la1+1,lo1,0,p1_north);
-	for (i=0;i<3;i++)		north[i]=p1_north[i]-p1[i];
-	for (i=0;i<3;i++)		dir[i]=p2[i]-p1[i];
-	angle=s3d_vector_angle(dir,north);
-	angle=angle*180.0/M_PI;
-	if ((lo2>lo1) || (lo1-lo2>180.0))		angle=360-angle;
+	calc_earth_to_eukl(la1, lo1, 0, p1);
+	calc_earth_to_eukl(la2, lo2, 0, p2);
+	calc_earth_to_eukl(la1 + 1, lo1, 0, p1_north);
+	for (i = 0;i < 3;i++)  north[i] = p1_north[i] - p1[i];
+	for (i = 0;i < 3;i++)  dir[i] = p2[i] - p1[i];
+	angle = s3d_vector_angle(dir, north);
+	angle = angle * 180.0 / M_PI;
+	if ((lo2 > lo1) || (lo1 - lo2 > 180.0))  angle = 360 - angle;
 	return(angle);
 }
 /* find some good center on our own */
 void nav_autocenter()
 {
 	float med[2];
-	char query[]="SELECT avg(longitude) as lo, avg(latitude) as la FROM node; ";
-	db_exec(query,get_center,med);
-	nav_center(med[0],med[1]);
-	printf("center to %f,%f\n",med[0],med[1]);
+	char query[] = "SELECT avg(longitude) as lo, avg(latitude) as la FROM node; ";
+	db_exec(query, get_center, med);
+	nav_center(med[0], med[1]);
+	printf("center to %f,%f\n", med[0], med[1]);
 }

Modified: trunk/apps/s3dosm/object.c
===================================================================
--- trunk/apps/s3dosm/object.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/object.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -29,46 +29,46 @@
 void object_free(object_t *obj)
 {
 	int i;
-	for (i=0;i<obj->tag_n;i++)
+	for (i = 0;i < obj->tag_n;i++)
 		tag_free(&(obj->tag_p[i]));
 }
 void object_init(object_t *nobj)
 {
-	nobj->bal=0;
-	nobj->left=NULL;
-	nobj->right=NULL;
-	nobj->id=0;
-	nobj->oid=-1;
-	nobj->layerid=-1;
-	nobj->tagid=-1;
-	nobj->tag_n=0;
-	nobj->tag_p=NULL;
-	nobj->type=T_OBJECT;
+	nobj->bal = 0;
+	nobj->left = NULL;
+	nobj->right = NULL;
+	nobj->id = 0;
+	nobj->oid = -1;
+	nobj->layerid = -1;
+	nobj->tagid = -1;
+	nobj->tag_n = 0;
+	nobj->tag_p = NULL;
+	nobj->type = T_OBJECT;
 }
 
 object_t *object_new(int key)
 {
-	object_t *nobj=malloc(sizeof(object_t));
+	object_t *nobj = malloc(sizeof(object_t));
 	object_init(nobj);
-	nobj->id=key;
+	nobj->id = key;
 	return (nobj);
 }
 /* ########### node ############### */
 void node_init(node_t *nnode)
 {
 	object_init((object_t *)nnode);
-	OBJECT_T(nnode)->type=T_NODE;
-	nnode->lat=0;
-	nnode->lon=0;
-	nnode->alt=0;
-	nnode->visible=1;
-	nnode->vid=-1;
-	nnode->adj_n=0;
-	nnode->adj_p=NULL;
+	OBJECT_T(nnode)->type = T_NODE;
+	nnode->lat = 0;
+	nnode->lon = 0;
+	nnode->alt = 0;
+	nnode->visible = 1;
+	nnode->vid = -1;
+	nnode->adj_n = 0;
+	nnode->adj_p = NULL;
 }
 node_t *node_new()
 {
-	node_t *nnode=malloc(sizeof(node_t));
+	node_t *nnode = malloc(sizeof(node_t));
 	node_init(nnode);
 	return(nnode);
 }
@@ -81,13 +81,13 @@
 void segment_init(segment_t *nsegment)
 {
 	object_init((object_t *)nsegment);
-	OBJECT_T(nsegment)->type=T_SEGMENT;
-	nsegment->from=0;
-	nsegment->to=0;
+	OBJECT_T(nsegment)->type = T_SEGMENT;
+	nsegment->from = 0;
+	nsegment->to = 0;
 }
 segment_t *segment_new()
 {
-	segment_t *nsegment=malloc(sizeof(segment_t));
+	segment_t *nsegment = malloc(sizeof(segment_t));
 	segment_init(nsegment);
 	return(nsegment);
 }
@@ -100,37 +100,37 @@
 void way_init(way_t *nway)
 {
 	object_init((object_t *)nway);
-	OBJECT_T(nway)->type=T_WAY;
-	nway->seg_n=0;
-	nway->seg_p=NULL;
+	OBJECT_T(nway)->type = T_WAY;
+	nway->seg_n = 0;
+	nway->seg_p = NULL;
 }
 way_t *way_new()
 {
-	way_t *nway=malloc(sizeof(way_t));
+	way_t *nway = malloc(sizeof(way_t));
 	way_init(nway);
 	return(nway);
 }
 void way_free(way_t *way)
 {
-	if (way->seg_n>0)
+	if (way->seg_n > 0)
 		free(way->seg_p);
 	free(way);
 }
 /* ########### layer  ############### */
 layer_t *layer_new()
 {
-	layer_t *nlayer=malloc(sizeof(layer_t));
-	nlayer->tree=NULL;
-	nlayer->visible=0;
+	layer_t *nlayer = malloc(sizeof(layer_t));
+	nlayer->tree = NULL;
+	nlayer->visible = 0;
 	return(nlayer);
 }
 /* ########### layerset ############### */
-layerset_t layerset={0,NULL};
+layerset_t layerset = {0, NULL};
 
 void layerset_add(layer_t *layer)
 {
-	if (layer==NULL) return;
+	if (layer == NULL) return;
 	layerset.n++;
-	layerset.p=realloc(layerset.p, sizeof(layer_t *)*layerset.n);
-	layerset.p[layerset.n-1]=layer;
+	layerset.p = realloc(layerset.p, sizeof(layer_t *) * layerset.n);
+	layerset.p[layerset.n-1] = layer;
 }

Modified: trunk/apps/s3dosm/olsrs3d.h
===================================================================
--- trunk/apps/s3dosm/olsrs3d.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/olsrs3d.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -37,12 +37,12 @@
 extern struct olsr_node *Olsr_root;   /* top of olsr node tree */
 extern struct Obj_to_ip *Obj_to_ip_head, *Obj_to_ip_end, *List_ptr;   /* struct list */
 
-extern int	Olsr_node_obj;
-extern int	Olsr_node_inet_obj;
-extern int	Olsr_node_hna_net;
-extern int	Btn_close_obj;
-extern int	S3d_obj;
-extern int	Btn_close_id;
+extern int Olsr_node_obj;
+extern int Olsr_node_inet_obj;
+extern int Olsr_node_hna_net;
+extern int Btn_close_obj;
+extern int S3d_obj;
+extern int Btn_close_id;
 extern int Olsr_node_count_obj;
 extern int Olsr_node_count;
 extern int Last_olsr_node_count;
@@ -58,7 +58,7 @@
 
 /* process */
 void lst_initialize();
-void lst_add(int id,struct olsr_node **olsr_node);
+void lst_add(int id, struct olsr_node **olsr_node);
 void lst_del(int id);
 struct olsr_node *lst_search(int id);
 void lst_out();
@@ -69,7 +69,7 @@
 int net_main();
 int net_quit();
 /* main */
-void out_of_mem( void );
-void print_etx( void );
+void out_of_mem(void);
+void print_etx(void);
 float dist(float p1[], float p2[]);
 void window_error(char *msg);

Modified: trunk/apps/s3dosm/osm.c
===================================================================
--- trunk/apps/s3dosm/osm.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/osm.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,8 +22,8 @@
  */
 
 #include "s3dosm.h"
-#include <string.h>			/* strcmp() */
-#include <stdlib.h>			/* strtof(),strtod(),strtol() */
+#include <string.h>   /* strcmp() */
+#include <stdlib.h>   /* strtof(),strtod(),strtol() */
 #include <libxml/parser.h>
 #include <libxml/tree.h>
 #include "http_fetcher.h"
@@ -32,15 +32,15 @@
 {
 	xmlNodePtr c;
 	xmlAttrPtr attr;
-	char *v,*k;
-	v=k=NULL;
-	for (c=cur->children;c!=NULL; c=c->next) {
-		if (0==strcmp((char *)c->name,"tag"))	{
-			for (attr=c->properties;attr;attr=attr->next) {
-				if (0==strcmp((char *)attr->name,"k")) 				k=(char *)attr->children->content;
-				else if (0==strcmp((char *)attr->name,"v")) 		v=(char *)attr->children->content;
+	char *v, *k;
+	v = k = NULL;
+	for (c = cur->children;c != NULL; c = c->next) {
+		if (0 == strcmp((char *)c->name, "tag")) {
+			for (attr = c->properties;attr;attr = attr->next) {
+				if (0 == strcmp((char *)attr->name, "k"))     k = (char *)attr->children->content;
+				else if (0 == strcmp((char *)attr->name, "v"))   v = (char *)attr->children->content;
 			}
-			if (k!=NULL && v!=NULL)
+			if (k != NULL && v != NULL)
 				db_add_tag(obj, k, v);
 		}
 	}
@@ -51,22 +51,22 @@
 {
 	way_t way;
 	xmlNodePtr kids;
-	xmlAttrPtr attr,kattr;
+	xmlAttrPtr attr, kattr;
 	int seg;
 
 	way_init(&way);
 
-	way.base.layerid=layerid;
-	for (attr=cur->properties;attr;attr=attr->next)
-		if (0==strcmp((char *)attr->name,"id")) 			way.base.id=	strtol((char *)attr->children->content,NULL,10);
+	way.base.layerid = layerid;
+	for (attr = cur->properties;attr;attr = attr->next)
+		if (0 == strcmp((char *)attr->name, "id"))    way.base.id = strtol((char *)attr->children->content, NULL, 10);
 	db_insert_way_only(&way);
-	parse_osm_tags(OBJECT_T(&way),cur);
-	for (kids=cur->children;kids!=NULL;kids=kids->next) {
-		if (0==strcmp((char *)kids->name,"seg"))	{
-			seg=-1;
-			for (kattr=kids->properties;kattr;kattr=kattr->next)
-				if (0==strcmp((char *)kattr->name,"id")) 			seg=	strtol((char *)kattr->children->content,NULL,10);
-			db_insert_way_seg(&way,seg);
+	parse_osm_tags(OBJECT_T(&way), cur);
+	for (kids = cur->children;kids != NULL;kids = kids->next) {
+		if (0 == strcmp((char *)kids->name, "seg")) {
+			seg = -1;
+			for (kattr = kids->properties;kattr;kattr = kattr->next)
+				if (0 == strcmp((char *)kattr->name, "id"))    seg = strtol((char *)kattr->children->content, NULL, 10);
+			db_insert_way_seg(&way, seg);
 		}
 	}
 }
@@ -77,16 +77,16 @@
 
 	segment_init(&segment);
 
-	segment.base.layerid=layerid;
-	for (attr=cur->properties;attr;attr=attr->next) {
+	segment.base.layerid = layerid;
+	for (attr = cur->properties;attr;attr = attr->next) {
 
-		if (0==strcmp((char *)attr->name,"id")) 			segment.base.id=	strtol((char *)attr->children->content,NULL,10);
-		else if (0==strcmp((char *)attr->name,"from")) 		segment.from=		strtod((char *)attr->children->content,NULL);
-		else if (0==strcmp((char *)attr->name,"to")) 		segment.to=			strtod((char *)attr->children->content,NULL);
+		if (0 == strcmp((char *)attr->name, "id"))    segment.base.id = strtol((char *)attr->children->content, NULL, 10);
+		else if (0 == strcmp((char *)attr->name, "from"))   segment.from =  strtod((char *)attr->children->content, NULL);
+		else if (0 == strcmp((char *)attr->name, "to"))   segment.to =   strtod((char *)attr->children->content, NULL);
 	}
-	if ((segment.base.id>0) && (segment.from>0) && (segment.to>0)) {
+	if ((segment.base.id > 0) && (segment.from > 0) && (segment.to > 0)) {
 		db_insert_segment(&segment);
-		parse_osm_tags(OBJECT_T(&segment),cur);
+		parse_osm_tags(OBJECT_T(&segment), cur);
 	}
 }
 void parse_osm_node(xmlNodePtr cur)
@@ -95,53 +95,53 @@
 	xmlAttrPtr attr;
 
 	node_init(&node);
-	attr=cur->properties;
+	attr = cur->properties;
 
-	node.base.layerid=layerid;
-	for (attr=cur->properties;attr;attr=attr->next) {
-		if (0==strcmp((char *)attr->name,"id")) 			node.base.id=		strtol((char *)attr->children->content,NULL,10);
-		else if (0==strcmp((char *)attr->name,"lat")) 		node.lat=			strtod((char *)attr->children->content,NULL);
-		else if (0==strcmp((char *)attr->name,"lon")) 		node.lon=			strtod((char *)attr->children->content,NULL);
-		else if (0==strcmp((char *)attr->name,"visible")) 	node.visible=		(0==strcmp((char *)attr->children->content,"true"))?1:0;
-		else if (0==strcmp((char *)attr->name,"time")) {}	/* TODO */
+	node.base.layerid = layerid;
+	for (attr = cur->properties;attr;attr = attr->next) {
+		if (0 == strcmp((char *)attr->name, "id"))    node.base.id =  strtol((char *)attr->children->content, NULL, 10);
+		else if (0 == strcmp((char *)attr->name, "lat"))   node.lat =   strtod((char *)attr->children->content, NULL);
+		else if (0 == strcmp((char *)attr->name, "lon"))   node.lon =   strtod((char *)attr->children->content, NULL);
+		else if (0 == strcmp((char *)attr->name, "visible"))  node.visible = (0 == strcmp((char *)attr->children->content, "true")) ? 1 : 0;
+		else if (0 == strcmp((char *)attr->name, "time")) {} /* TODO */
 	}
-	if (node.base.id>0) {
+	if (node.base.id > 0) {
 		db_insert_node(&node);
-		parse_osm_tags(OBJECT_T(&node),cur);
+		parse_osm_tags(OBJECT_T(&node), cur);
 	}
 }
 /* parse the osm input file */
 layer_t *parse_osm(char *buf, int length)
 {
 	xmlDocPtr doc;
-	xmlNodePtr cur,c;
-	layer_t *layer=layer_new();
+	xmlNodePtr cur, c;
+	layer_t *layer = layer_new();
 	object_t *obj;
-	float n=0;
-	int i=0;
+	float n = 0;
+	int i = 0;
 
 
 	doc = xmlReadMemory(buf, length, "noname.xml", NULL, 0);
 	if (doc == NULL) {
-		fprintf(stderr,"Document not parsed successfully.\n");
+		fprintf(stderr, "Document not parsed successfully.\n");
 		return(NULL);
 	}
 	cur = xmlDocGetRootElement(doc);
 	if (cur == NULL) {
-		fprintf(stderr,"empty document\n");
+		fprintf(stderr, "empty document\n");
 		xmlFreeDoc(doc);
 		return(NULL);
 	}
-	layerid=db_insert_layer("osm");
-	for (c=cur->children;  c!=NULL;   c=c->next) 		n++; /* count */
-	for (cur=cur->children;cur!=NULL; cur=cur->next) {
-		if (cur->type==XML_ELEMENT_NODE) {
-			obj=NULL;
-			if (0==strcmp((char *)cur->name,"node"))				parse_osm_node(cur);
-			else if (0==strcmp((char *)cur->name,"segment"))		parse_osm_segment(cur);
-			else if (0==strcmp((char *)cur->name,"way"))			parse_osm_way(cur);
+	layerid = db_insert_layer("osm");
+	for (c = cur->children;  c != NULL;   c = c->next)   n++; /* count */
+	for (cur = cur->children;cur != NULL; cur = cur->next) {
+		if (cur->type == XML_ELEMENT_NODE) {
+			obj = NULL;
+			if (0 == strcmp((char *)cur->name, "node"))    parse_osm_node(cur);
+			else if (0 == strcmp((char *)cur->name, "segment"))  parse_osm_segment(cur);
+			else if (0 == strcmp((char *)cur->name, "way"))   parse_osm_way(cur);
 		}
-		if ((i++)%200==0) 	load_update_status(100*((float)i)/n); /* report status */
+		if ((i++) % 200 == 0)  load_update_status(100*((float)i) / n); /* report status */
 	}
 	xmlFreeDoc(doc);
 	db_flush();
@@ -154,18 +154,18 @@
 	char *user = "foo at packetmixer.de";
 	char *pass = "foobar";
 	char url[1024];
-	char *fileBuf;						/* Pointer to downloaded data */
+	char *fileBuf;      /* Pointer to downloaded data */
 	layer_t *layer;
-	snprintf(url,1024,"www.openstreetmap.org/api/0.3/map?bbox=%f,%f,%f,%f",minlon,minlat,maxlon,maxlat);
-	printf("downloading url [ %s ]\n",url);
+	snprintf(url, 1024, "www.openstreetmap.org/api/0.3/map?bbox=%f,%f,%f,%f", minlon, minlat, maxlon, maxlat);
+	printf("downloading url [ %s ]\n", url);
 
-	http_setAuth(user,pass);
-	ret = http_fetch(url, &fileBuf);	/* Downloads page */
+	http_setAuth(user, pass);
+	ret = http_fetch(url, &fileBuf); /* Downloads page */
 	if (ret == -1) {
 		http_perror("http_fetch");
 		return(NULL);
 	}
-	layer=parse_osm(fileBuf, ret);
+	layer = parse_osm(fileBuf, ret);
 	/* TODO: cleanup http-lib */
 	free(fileBuf);
 	return layer;
@@ -175,8 +175,8 @@
 	int length;
 	char *file;
 	layer_t *ret;
-	if (NULL==(file=read_file(filename,&length))) return(NULL);
-	ret=parse_osm(file,length);
+	if (NULL == (file = read_file(filename, &length))) return(NULL);
+	ret = parse_osm(file, length);
 	free(file);
 	return ret;
 }

Modified: trunk/apps/s3dosm/s3dosm.h
===================================================================
--- trunk/apps/s3dosm/s3dosm.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/s3dosm.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,14 +1,14 @@
 #include <sqlite3.h>
-#include <s3d.h>	/* s3devt structure */
+#include <s3d.h> /* s3devt structure */
 #include <config-s3d.h>
-#define	ESIZE	637800		/* earth size */
-#define	RESCALE	1
+#define ESIZE 637800  /* earth size */
+#define RESCALE 1
 #define VIEWHEIGHT 3
-#define MAXQ	4096
-#define QBUF	1024*128
+#define MAXQ 4096
+#define QBUF 1024*128
 
 /* stack it */
-/* #define DB_STACK	1*/
+/* #define DB_STACK 1*/
 
 typedef struct _layer_t layer_t;
 typedef struct _adj_t adj_t;
@@ -20,10 +20,10 @@
 typedef struct _tag_t tag_t;
 typedef struct _icon_t icon_t;
 typedef unsigned long ID_T;
-#define OBJECT_T(x)		((object_t *)x)
-#define NODE_T(x)		((node_t *)x)
-#define SEGMENT_T(x)	((segment_t *)x)
-#define WAY_T(x)		((way_t *)x)
+#define OBJECT_T(x)  ((object_t *)x)
+#define NODE_T(x)  ((node_t *)x)
+#define SEGMENT_T(x) ((segment_t *)x)
+#define WAY_T(x)  ((way_t *)x)
 struct _layerset_t {
 	int n;
 	layer_t **p;
@@ -72,60 +72,60 @@
 };
 
 struct _object_t {
-	ID_T 		 id;		/* id of this object */
-	ID_T		 layerid;
-	ID_T		 tagid;
-	int 		 oid;		/* s3d oid */
-	int 		 type;		/* type of this object */
+	ID_T    id;  /* id of this object */
+	ID_T   layerid;
+	ID_T   tagid;
+	int    oid;  /* s3d oid */
+	int    type;  /* type of this object */
 	/* avl stuff */
-	char 		 bal;
-	int			 tag_n;
-	tag_t		*tag_p;
-	object_t 	*left,*right;
+	char    bal;
+	int    tag_n;
+	tag_t  *tag_p;
+	object_t  *left, *right;
 };
 
 struct _adj_t {
-	ID_T 		 to,seg;	/* destination and segment to use */
+	ID_T    to, seg; /* destination and segment to use */
 };
 
 struct _node_t {
-	object_t	 base;
-	float 		 lon;		/* longitude */
-	float 		 lat;		/* latitude */
-	float 		 alt;		/* altitude */
-	char 		 visible;	/* node visible? 0 = no, 1 = yes, 2 = some sepcial object */
-	int 		 vid;		/* vertex id */
-	/*	time_t time;*/
-	int 		 adj_n;		/* adjacence list */
-	adj_t 		*adj_p;
+	object_t  base;
+	float    lon;  /* longitude */
+	float    lat;  /* latitude */
+	float    alt;  /* altitude */
+	char    visible; /* node visible? 0 = no, 1 = yes, 2 = some sepcial object */
+	int    vid;  /* vertex id */
+	/* time_t time;*/
+	int    adj_n;  /* adjacence list */
+	adj_t   *adj_p;
 };
 struct _segment_t {
-	object_t	 base;
-	ID_T		 from;
-	ID_T		 to;
+	object_t  base;
+	ID_T   from;
+	ID_T   to;
 };
 struct _way_t {
-	object_t	 base;
-	int 		 seg_n;
-	ID_T		*seg_p;
+	object_t  base;
+	int    seg_n;
+	ID_T  *seg_p;
 };
 
 /* public functions */
 
 /* object.c */
-void 		 object_init(object_t *nobj);
-void 		 node_init(node_t *nnode);
-void 		 segment_init(segment_t *nsegment);
-void 		 way_init(way_t *nway);
-object_t 	*object_new(int key);
-node_t 		*node_new();
-segment_t 	*segment_new();
-layer_t 	*layer_new();
-way_t 		*way_new();
-void 		 node_free(node_t *node);
-void 		 segment_free(segment_t *segment);
-void 		 way_free(way_t *way);
-void 		 layerset_add(layer_t *layer);
+void    object_init(object_t *nobj);
+void    node_init(node_t *nnode);
+void    segment_init(segment_t *nsegment);
+void    way_init(way_t *nway);
+object_t  *object_new(int key);
+node_t   *node_new();
+segment_t  *segment_new();
+layer_t  *layer_new();
+way_t   *way_new();
+void    node_free(node_t *node);
+void    segment_free(segment_t *segment);
+void    way_free(way_t *way);
+void    layerset_add(layer_t *layer);
 /* main.c */
 void mainloop();
 /* osm.c */
@@ -150,7 +150,7 @@
 float get_heading(float la1, float lo1, float la2, float lo2);
 extern int oidy;
 /* tag.c */
-void tag_add(object_t *obj,char *k, char *v);
+void tag_add(object_t *obj, char *k, char *v);
 tag_t *tag_get(object_t *obj, char *k);
 void tag_free(tag_t *tag);
 /* io.c */
@@ -185,7 +185,7 @@
 int load_window_remove();
 int load_update_status(float percent);
 /* olsrs3d.c */
-#define NODEHEIGHT	10
+#define NODEHEIGHT 10
 int olsr_object_click(struct s3d_evt *evt);
 int olsr_object_info(struct s3d_evt *hrmz);
 int olsr_parse_args(int argc, char **argv);

Modified: trunk/apps/s3dosm/search.h
===================================================================
--- trunk/apps/s3dosm/search.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/search.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -21,10 +21,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#define NOTHING 0		/* nothing ;) */
-#define ABORT 1			/* widget has no focus */
-#define WIDGET 2		/* focus on widget */
-#define FOLLOW 3		/* follow search result */
+#define NOTHING 0  /* nothing ;) */
+#define ABORT 1   /* widget has no focus */
+#define WIDGET 2  /* focus on widget */
+#define FOLLOW 3  /* follow search result */
 
 void create_search_widget(float x, float y, float z);
 void move_search_widget(float x, float y, float z);
@@ -35,7 +35,7 @@
 void set_search_status(int stat);
 void search_widget_write(int key);
 void set_node_root(struct olsr_node *root);
-void follow_node(float cam_position_t[], float cam_position_r[],float rotate);
+void follow_node(float cam_position_t[], float cam_position_r[], float rotate);
 void follow_node_by_click(struct olsr_node *olsr_node);
 
 void show_search_window();

Modified: trunk/apps/s3dosm/structs.h
===================================================================
--- trunk/apps/s3dosm/structs.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/structs.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,21 +23,21 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#define NAMEMAX		128
-#define MAXLINESIZE 1000		/* lines in a digraph just shouldn't get that longer ... */
-#define MAXDATASIZE 100			/* max number of bytes we can get at once  */
+#define NAMEMAX  128
+#define MAXLINESIZE 1000  /* lines in a digraph just shouldn't get that longer ... */
+#define MAXDATASIZE 100   /* max number of bytes we can get at once  */
 
 /* linked list for the all connections */
 struct olsr_con {
-	struct olsr_con *next_olsr_con;			/* pointer to next connection */
-	struct olsr_con *prev_olsr_con;			/* pointer to previous connection */
-	struct olsr_node *left_olsr_node;		/* pointer to left end point of the connection */
-	struct olsr_node *right_olsr_node;		/* pointer to right end point of the connection */
-	float left_etx;							/* etx of left olsr node */
-	float right_etx;						/* etx of right olsr node */
-	float left_etx_sqrt;					/* sqrt of etx of left olsr node */
-	float right_etx_sqrt;					/* sqrt etx of right olsr node */
-	int obj_id;								/* id of connection object in s3d */
+	struct olsr_con *next_olsr_con;   /* pointer to next connection */
+	struct olsr_con *prev_olsr_con;   /* pointer to previous connection */
+	struct olsr_node *left_olsr_node;  /* pointer to left end point of the connection */
+	struct olsr_node *right_olsr_node;  /* pointer to right end point of the connection */
+	float left_etx;       /* etx of left olsr node */
+	float right_etx;      /* etx of right olsr node */
+	float left_etx_sqrt;     /* sqrt of etx of left olsr node */
+	float right_etx_sqrt;     /* sqrt etx of right olsr node */
+	int obj_id;        /* id of connection object in s3d */
 	int color;
 	float rgb;
 };
@@ -45,8 +45,8 @@
 
 /* linked list for the neighbours of each olsr node */
 struct olsr_neigh_list {
-	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
-	struct olsr_con *olsr_con;							/* pointer to the connection */
+	struct olsr_neigh_list *next_olsr_neigh_list;  /* pointer to next neighbour */
+	struct olsr_con *olsr_con;       /* pointer to the connection */
 };
 
 
@@ -54,18 +54,18 @@
 struct olsr_node {
 	struct olsr_node *left;
 	struct olsr_node *right;
-	char ip[NAMEMAX];				/* host ip */
-	int static_node;				/* static nodes have some known geolocation and won't move */
-	int node_type;					/* normal = 0, internet gateway = 1, via hna announced network = 2 */
-	int node_type_modified;			/* node_type modified flag */
-	int last_seen;					/* last seen counter */
-	int visible;					/* is this node visible or vanished */
-	float pos_vec[3];				/* position vector in 3d "space" */
-	float mov_vec[3];				/* move vector */
-	int obj_id;						/* id of node object in s3d */
-	int desc_id;					/* id of node description object in s3d */
-	float desc_length;				/* length of node description object in s3d */
-	struct olsr_neigh_list *olsr_neigh_list;	/* pointer to first neighbour */
+	char ip[NAMEMAX];    /* host ip */
+	int static_node;    /* static nodes have some known geolocation and won't move */
+	int node_type;     /* normal = 0, internet gateway = 1, via hna announced network = 2 */
+	int node_type_modified;   /* node_type modified flag */
+	int last_seen;     /* last seen counter */
+	int visible;     /* is this node visible or vanished */
+	float pos_vec[3];    /* position vector in 3d "space" */
+	float mov_vec[3];    /* move vector */
+	int obj_id;      /* id of node object in s3d */
+	int desc_id;     /* id of node description object in s3d */
+	float desc_length;    /* length of node description object in s3d */
+	struct olsr_neigh_list *olsr_neigh_list; /* pointer to first neighbour */
 };
 
 

Modified: trunk/apps/s3dosm/tag.c
===================================================================
--- trunk/apps/s3dosm/tag.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/tag.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -21,38 +21,38 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 #include "s3dosm.h"
-#include <stdio.h>	/* printf() */
-#include <string.h>	/* strcmp() */
-#include <stdlib.h>	/* realloc() */
-void tag_add(object_t *obj,char *k, char *v)
+#include <stdio.h> /* printf() */
+#include <string.h> /* strcmp() */
+#include <stdlib.h> /* realloc() */
+void tag_add(object_t *obj, char *k, char *v)
 {
 	tag_t *t;
 	obj->tag_n++;
-	obj->tag_p=realloc(obj->tag_p,obj->tag_n*sizeof(tag_t));
-	if (k!=NULL && v!=NULL) {
-		t=&(obj->tag_p[obj->tag_n-1]);
-		t->ttype=TAG_UNKNOWN;
-		t->k=strdup(k);
-		t->v=strdup(v);
-		t->d.s=v;
-		if (0==strcmp(k,"name"))	t->ttype=TAG_NAME;
+	obj->tag_p = realloc(obj->tag_p, obj->tag_n * sizeof(tag_t));
+	if (k != NULL && v != NULL) {
+		t = &(obj->tag_p[obj->tag_n-1]);
+		t->ttype = TAG_UNKNOWN;
+		t->k = strdup(k);
+		t->v = strdup(v);
+		t->d.s = v;
+		if (0 == strcmp(k, "name")) t->ttype = TAG_NAME;
 	}
 }
 tag_t *tag_get(object_t *obj, char *k)
 {
 	int i;
-	for (i=0;i<obj->tag_n;i++) {
-		if (0==strcmp(obj->tag_p[i].k,k)) return(&(obj->tag_p[i]));
+	for (i = 0;i < obj->tag_n;i++) {
+		if (0 == strcmp(obj->tag_p[i].k, k)) return(&(obj->tag_p[i]));
 	}
 	return(NULL);
 }
 void tag_free(tag_t *tag)
 {
-	if (tag->d.s!=tag->v)
+	if (tag->d.s != tag->v)
 		free(tag->d.s);
 	free(tag->v);
 	free(tag->k);
-	tag->k=NULL;
-	tag->d.s=NULL;
-	tag->v=NULL;
+	tag->k = NULL;
+	tag->d.s = NULL;
+	tag->v = NULL;
 }

Modified: trunk/apps/s3dosm/ui.c
===================================================================
--- trunk/apps/s3dosm/ui.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dosm/ui.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,27 +24,27 @@
 #include <s3d.h>
 #include <s3dw.h>
 #include "s3dosm.h"
-#include <stdio.h>	/* NULL */
+#include <stdio.h> /* NULL */
 #include <string.h> /* strcmp */
 #include <stdlib.h> /* atoi() */
-icon_t icons[ICON_NUM]={
-	{"objs/accesspoint.3ds",0},
-	{"objs/noinetwep.3ds",0},
-	{"objs/noinetwpa.3ds",0},
-	{"objs/arrow2.3ds",0}
+icon_t icons[ICON_NUM] = {
+	{"objs/accesspoint.3ds", 0},
+	{"objs/noinetwep.3ds", 0},
+	{"objs/noinetwpa.3ds", 0},
+	{"objs/arrow2.3ds", 0}
 };
 
 /* load icons, we want to clone each of them later */
 void ui_loadicons()
 {
 	int i;
-	for (i=0;i<ICON_NUM;i++)
-		icons[i].oid=s3d_import_model_file(icons[i].path);
+	for (i = 0;i < ICON_NUM;i++)
+		icons[i].oid = s3d_import_model_file(icons[i].path);
 }
 
-static s3dw_surface *loadwindow=NULL;
-static s3dw_label   *loadlabel=NULL;
-static s3dw_label   *loadstatus=NULL;
+static s3dw_surface *loadwindow = NULL;
+static s3dw_label   *loadlabel = NULL;
+static s3dw_label   *loadstatus = NULL;
 
 void key_button(s3dw_widget *button)
 {
@@ -53,53 +53,53 @@
 
 int ui_getinfo_node(void *data, int argc, char **argv, char **azColName)
 {
-	int i,tagid=-1;
+	int i, tagid = -1;
 	char type[MAXQ];
 	char name[MAXQ];
 	char string[128];
 	s3dw_surface *miniwin;
 	s3dw_button  *button;
 
-	for (i=0; i<argc; i++) {
+	for (i = 0; i < argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],"tag_id")) 			tagid=atoi(argv[i]);
+			if (0 == strcmp(azColName[i], "tag_id"))    tagid = atoi(argv[i]);
 		}
 	}
-	if (db_gettag(tagid, "amenity",type)) type[0]=0;
-	if (db_gettag(tagid, "name",name)) name[0]=0;
+	if (db_gettag(tagid, "amenity", type)) type[0] = 0;
+	if (db_gettag(tagid, "name", name)) name[0] = 0;
 
-	miniwin=s3dw_surface_new("About node",30,6);
-	snprintf(string,128,"name: %s",name);
-	s3dw_label_new(miniwin,string,1,2);
-	snprintf(string,128,"type: %s",type);
-	s3dw_label_new(miniwin,string,1,4);
-	button=s3dw_button_new(miniwin,"OK",2,6);
-	button->onclick=key_button;
+	miniwin = s3dw_surface_new("About node", 30, 6);
+	snprintf(string, 128, "name: %s", name);
+	s3dw_label_new(miniwin, string, 1, 2);
+	snprintf(string, 128, "type: %s", type);
+	s3dw_label_new(miniwin, string, 1, 4);
+	button = s3dw_button_new(miniwin, "OK", 2, 6);
+	button->onclick = key_button;
 	s3dw_show(S3DWIDGET(miniwin));
 
 	return(0);
 }
 int ui_getinfo_way(void *data, int argc, char **argv, char **azColName)
 {
-	int i,tagid=-1;
+	int i, tagid = -1;
 	char name[MAXQ];
 	char string[128];
 	s3dw_surface *miniwin;
 	s3dw_button  *button;
 
-	for (i=0; i<argc; i++) {
+	for (i = 0; i < argc; i++) {
 		if (argv[i]) {
-			if (0==strcmp(azColName[i],"tag_id")) 			tagid=atoi(argv[i]);
+			if (0 == strcmp(azColName[i], "tag_id"))    tagid = atoi(argv[i]);
 		}
 	}
-	if (db_gettag(tagid, "name",name)) name[0]=0;
-	printf("reporting street %s\n",name);
+	if (db_gettag(tagid, "name", name)) name[0] = 0;
+	printf("reporting street %s\n", name);
 
-	miniwin=s3dw_surface_new("About street",30,6);
-	snprintf(string,128,"name: %s",name);
-	s3dw_label_new(miniwin,string,1,2);
-	button=s3dw_button_new(miniwin,"OK",2,4);
-	button->onclick=key_button;
+	miniwin = s3dw_surface_new("About street", 30, 6);
+	snprintf(string, 128, "name: %s", name);
+	s3dw_label_new(miniwin, string, 1, 2);
+	button = s3dw_button_new(miniwin, "OK", 2, 4);
+	button->onclick = key_button;
 	s3dw_show(S3DWIDGET(miniwin));
 
 	return(0);
@@ -107,19 +107,19 @@
 
 int ui_click(struct s3d_evt *evt)
 {
-	int oid=(int)*((uint32_t *)evt->buf);
+	int oid = (int) * ((uint32_t *)evt->buf);
 	char query[MAXQ];
 	if (s3dw_handle_click(evt)) return(0);
-	snprintf(query,MAXQ,"SELECT * FROM node WHERE s3doid=%d;",oid);
+	snprintf(query, MAXQ, "SELECT * FROM node WHERE s3doid=%d;", oid);
 	db_exec(query, ui_getinfo_node, 0);
-	snprintf(query,MAXQ,"SELECT * FROM way WHERE s3doid=%d;",oid);
+	snprintf(query, MAXQ, "SELECT * FROM way WHERE s3doid=%d;", oid);
 	db_exec(query, ui_getinfo_way, 0);
 
 	return(0);
 }
 int ui_key(struct s3d_evt *evt)
 {
-	/*	struct s3d_key_event *key=(struct s3d_key_event *)evt->buf;*/
+	/* struct s3d_key_event *key=(struct s3d_key_event *)evt->buf;*/
 	if (s3dw_handle_key(evt)) return(0);
 	return(0);
 }
@@ -131,33 +131,33 @@
 int ui_init()
 {
 	ui_loadicons();
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,ui_click);
-	s3d_set_callback(S3D_EVENT_KEY,ui_key);
-	s3d_set_callback(S3D_EVENT_OBJ_INFO,ui_oinfo);
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK, ui_click);
+	s3d_set_callback(S3D_EVENT_KEY, ui_key);
+	s3d_set_callback(S3D_EVENT_OBJ_INFO, ui_oinfo);
 	return(0);
 }
 
 /* initialize the loadwindow or change its caption text */
 int load_window(char *text)
 {
-	if (loadwindow==NULL) { /* create it */
-		loadwindow=s3dw_surface_new("Now loading ...",20,5);
-		loadlabel=s3dw_label_new(loadwindow,text,1,2);
-		loadstatus=s3dw_label_new(loadwindow,"",1,3);
+	if (loadwindow == NULL) { /* create it */
+		loadwindow = s3dw_surface_new("Now loading ...", 20, 5);
+		loadlabel = s3dw_label_new(loadwindow, text, 1, 2);
+		loadstatus = s3dw_label_new(loadwindow, "", 1, 3);
 		s3dw_show(S3DWIDGET(loadwindow));
 	} else {
-		s3dw_label_change_text(loadlabel,text);
-		s3dw_label_change_text(loadstatus,"");
+		s3dw_label_change_text(loadlabel, text);
+		s3dw_label_change_text(loadstatus, "");
 	}
 	return(0);
 }
 /* remove it if still here */
 int load_window_remove()
 {
-	if (loadwindow!=NULL) {
+	if (loadwindow != NULL) {
 		s3dw_delete(S3DWIDGET(loadwindow));
-		loadwindow=NULL;
-		loadlabel=NULL;
+		loadwindow = NULL;
+		loadlabel = NULL;
 	}
 	return(0);
 }
@@ -165,9 +165,9 @@
 int load_update_status(float percent)
 {
 	char text[128];
-	if (loadwindow!=NULL) {
-		snprintf(text,128,"%3.1f",percent);
-		s3dw_label_change_text(loadstatus,text);
+	if (loadwindow != NULL) {
+		snprintf(text, 128, "%3.1f", percent);
+		s3dw_label_change_text(loadstatus, text);
 	}
 	mainloop();
 	return(0);

Modified: trunk/apps/s3dvt/main.c
===================================================================
--- trunk/apps/s3dvt/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dvt/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,26 +24,26 @@
 
 
 #include "s3dvt.h"
-#include <stdio.h> 		 /*  FILE,NULL */
-#include <unistd.h> 	 /*  read(),write(), sleep(),close() ... */
-#include <errno.h>		 /*  errno() */
-#include <fcntl.h> 		 /*  open() */
-#include <signal.h>		 /*  signal() */
-#include <stdlib.h>		 /*  exit(),getenv(),setenv() */
-#include <sys/ioctl.h> 	 /*  ioctl() */
-#include <pthread.h>	 /*  pthread_create() */
-#include <s3d.h>		 /*  s3d_* */
-#include <s3d_keysym.h>	 /*  key symbols */
-#include <time.h>	/* nanosleep() */
-static struct timespec t= {
-	0,10*1000*1000
+#include <stdio.h>    /*  FILE,NULL */
+#include <unistd.h>   /*  read(),write(), sleep(),close() ... */
+#include <errno.h>   /*  errno() */
+#include <fcntl.h>    /*  open() */
+#include <signal.h>   /*  signal() */
+#include <stdlib.h>   /*  exit(),getenv(),setenv() */
+#include <sys/ioctl.h>   /*  ioctl() */
+#include <pthread.h>  /*  pthread_create() */
+#include <s3d.h>   /*  s3d_* */
+#include <s3d_keysym.h>  /*  key symbols */
+#include <time.h> /* nanosleep() */
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 
 
 static int pid;
-static int term_mode=0;
+static int term_mode = 0;
 
-static int cursor;		/* the object id of the cursor */
+static int cursor;  /* the object id of the cursor */
 
 static pthread_t term_thread;
 
@@ -52,46 +52,46 @@
 static int mpipe_out[2];
 #endif
 #ifdef M_PTY
-static int curtty,curpty;
+static int curtty, curpty;
 #endif
 
 #ifdef M_CHAR
 static unsigned int charbuf[256];
 static unsigned int screenbuf[MAX_LINES*MAX_CHARS];
-static char 		last_c[MAX_LINES*MAX_CHARS];
+static char   last_c[MAX_LINES*MAX_CHARS];
 #endif
 
 #ifdef M_LINE
-static int 			lines[MAX_LINES];
+static int    lines[MAX_LINES];
 #endif
 
 void *thread_terminal(void *a)
 {
-	int iscon=1,ret;
+	int iscon = 1, ret;
 	char buffer[1024];
 	while (iscon) {
 		switch (term_mode) {
 		case M_PIPE:
-			ret=read(mpipe_out[0], &buffer, 1000);
+			ret = read(mpipe_out[0], &buffer, 1000);
 			break;
 		case M_PTY:
-			ret=read(curpty, &buffer, 1000);
+			ret = read(curpty, &buffer, 1000);
 			break;
 		default:
-			ret=-1;
+			ret = -1;
 		}
-		if (ret>0) {
-			buffer[ret]='\0';
+		if (ret > 0) {
+			buffer[ret] = '\0';
 			printf("<<<new data(%d bytes)\n", ret);
 			AddChar(buffer);
 		} else {
-			if (ret==-1) {
+			if (ret == -1) {
 				perror("read()");
-				printf("Connection to pty lost (ret=%d)\n",ret);
+				printf("Connection to pty lost (ret=%d)\n", ret);
 				close(mpipe_in[0]);
 				close(mpipe_out[1]);
-				/* 		close(curpty);  */
-				/* 		close(curtty);  */
+				/*   close(curpty);  */
+				/*   close(curtty);  */
 				printf("********CONNECTION TO PTY LOST!*******\n");
 				sleep(1);
 				s3d_quit();
@@ -107,19 +107,19 @@
 	char buf[256];
 	char tmpstr[1024];
 	int curtty;
-	int uid=0,gid=0;
-	char exe[]="/bin/bash";
+	int uid = 0, gid = 0;
+	char exe[] = "/bin/bash";
 	char curchar;
 	char *disp;
 
-	disp=getenv("DISPLAY");
-	uid=getuid();
-	gid=getgid();
-	term_mode=M_PTY;
-	for (curchar='p'; curchar<'z';curchar++) {
-		for (i=0;i < 16;i++) {
+	disp = getenv("DISPLAY");
+	uid = getuid();
+	gid = getgid();
+	term_mode = M_PTY;
+	for (curchar = 'p'; curchar < 'z';curchar++) {
+		for (i = 0;i < 16;i++) {
 			sprintf(buf, "/dev/pty%c%x", curchar, i);
-			curpty=open(buf, O_RDWR);
+			curpty = open(buf, O_RDWR);
 			if (curpty >= 0)
 				goto endloop;
 		}
@@ -129,19 +129,19 @@
 		printf("Error opening pty\n");
 		return 0;
 	}
-	/* 	fnctl(F_SETFL,O_NONBLOCK); */
+	/*  fnctl(F_SETFL,O_NONBLOCK); */
 	signal(SIGCHLD, SIG_IGN);
 	pid = fork();
 	if (!pid) {
-		buf[5]='t';
-		curtty=open(buf, O_RDWR);
+		buf[5] = 't';
+		curtty = open(buf, O_RDWR);
 		if (curtty < 0) {
 			printf("Error opening tty\n");
 			return 0;
 		}
 		setuid(uid);
 		setgid(gid);
-		if (setsid()<0)
+		if (setsid() < 0)
 			printf("ERROR (setsid)\n");
 		/*     tcflush(curpty, TCIOFLUSH); */
 		if (ioctl(curtty, TIOCSCTTY, NULL))
@@ -149,9 +149,9 @@
 		dup2(curtty, 0);
 		dup2(curtty, 1);
 		dup2(curtty, 2);
-		sprintf(tmpstr, "%d", MAX_LINES-1);
+		sprintf(tmpstr, "%d", MAX_LINES - 1);
 		setenv("LINES", tmpstr, 1);
-		sprintf(tmpstr, "%d", MAX_CHARS-1);
+		sprintf(tmpstr, "%d", MAX_CHARS - 1);
 		setenv("COLUMNS", tmpstr, 1);
 		setenv("TERM", "rxvt", 1);
 		execl(exe, exe, NULL);
@@ -159,7 +159,7 @@
 		printf("that's it, exiting");
 		close(curtty);
 		exit(0);
-	} else if (pid<0) {
+	} else if (pid < 0) {
 		printf("Cant fork()\n");
 		exit(0);
 	} else {
@@ -173,8 +173,8 @@
 	/*    printf("sending: %.3d\n", toprint);*/
 	switch (term_mode) {
 	case M_PIPE:
-		write(mpipe_in[1],&toprint,1);
-		write(mpipe_out[1],&toprint,1);
+		write(mpipe_in[1], &toprint, 1);
+		write(mpipe_out[1], &toprint, 1);
 		break;
 	case M_PTY:
 		write(curpty, &toprint, 1);
@@ -186,46 +186,46 @@
 int pipe_init_terminal()
 {
 	char buf[256];
-	int uid=0,gid=0;
-	char *exe="/bin/bash";
-	char *args="-i";
+	int uid = 0, gid = 0;
+	char *exe = "/bin/bash";
+	char *args = "-i";
 	char *disp;
 
-	term_mode=M_PIPE;
-	if ((pipe(mpipe_in)==-1) || (pipe(mpipe_out)==-1)) {
+	term_mode = M_PIPE;
+	if ((pipe(mpipe_in) == -1) || (pipe(mpipe_out) == -1)) {
 		printf("pipe failed\n");
 		return(-1);
 	}
-	disp=getenv("DISPLAY");
-	uid=getuid();
-	gid=getgid();
+	disp = getenv("DISPLAY");
+	uid = getuid();
+	gid = getgid();
 	pid = fork();
-	if (pid==0) { /*  the child */
+	if (pid == 0) { /*  the child */
 		char tmpstr[1024];
-		buf[5]='t';
+		buf[5] = 't';
 		setuid(uid);
 		setgid(gid);
-		if (setsid()<0)
+		if (setsid() < 0)
 			printf("ERROR (setsid)\n");
 		/*     tcflush(curpty, TCIOFLUSH); */
 		/*     if(ioctl(curtty, TIOCSCTTY, NULL)) printf("ERROR! (ttyflush)\n");; */
-		setvbuf(stdout,(char*)NULL,_IONBF,0);
+		setvbuf(stdout, (char*)NULL, _IONBF, 0);
 		dup2(mpipe_in[0], fileno(stdin));
 		dup2(mpipe_out[1], fileno(stdout));
 		dup2(mpipe_out[1], fileno(stderr));
 		/*  close unneded things: */
 		close(mpipe_out[0]);
 		close(mpipe_in[1]);
-		sprintf(tmpstr, "%d", MAX_LINES-1);
+		sprintf(tmpstr, "%d", MAX_LINES - 1);
 		setenv("LINES", tmpstr, 1);
-		sprintf(tmpstr, "%d", MAX_CHARS-1);
+		sprintf(tmpstr, "%d", MAX_CHARS - 1);
 		setenv("COLUMNS", tmpstr, 1);
 		setenv("TERM", "rxvt", 1);
-		execl(exe, exe, args,NULL);
+		execl(exe, exe, args, NULL);
 		printf("that's it, exiting");
 		close(curtty);
 		exit(0);
-	} else if (pid<0) {
+	} else if (pid < 0) {
 		printf("Cant fork()\n");
 		exit(0);
 	} else {
@@ -238,7 +238,7 @@
 int init_terminal()
 {
 	int i;
-	for (i=0;i<5;i++)
+	for (i = 0;i < 5;i++)
 		if (pty_init_terminal())  /*  find an open pty. */
 			return(0);
 	return(pipe_init_terminal());  /*  if not, fallback to pipe mode */
@@ -265,121 +265,121 @@
 {
 	int cline;
 	int c;
-	unsigned char ch,och;
+	unsigned char ch, och;
 	unsigned int ci;
-	int i,line_end;
+	int i, line_end;
 
-	s3d_translate(	cursor,cx*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cy*CS + CS*MAX_LINES/2,0);
-	s3d_scale(		cursor,CS);
-	for (cline=0;cline<MAX_LINES;cline++) {
-		line_end=0;
-		for (c=0;c<MAX_CHARS;c++) {
-			i=cline*MAX_CHARS+c;			 /*  calculate position */
-			if (((ch=line[cline].chars[c].character)!=(och=last_c[i]))) {
-				if (screenbuf[i]==-1) {
-					screenbuf[i]=s3d_new_object();
-					s3d_translate(screenbuf[i],c*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cline*CS + CS*MAX_LINES/2,0);
-					s3d_scale(screenbuf[i],CS);
-					s3d_flags_on(screenbuf[i],S3D_OF_VISIBLE);
+	s3d_translate(cursor, cx*X_RATIO*CS - CS*X_RATIO*MAX_CHARS / 2, -cy*CS + CS*MAX_LINES / 2, 0);
+	s3d_scale(cursor, CS);
+	for (cline = 0;cline < MAX_LINES;cline++) {
+		line_end = 0;
+		for (c = 0;c < MAX_CHARS;c++) {
+			i = cline * MAX_CHARS + c;    /*  calculate position */
+			if (((ch = line[cline].chars[c].character) != (och = last_c[i]))) {
+				if (screenbuf[i] == -1) {
+					screenbuf[i] = s3d_new_object();
+					s3d_translate(screenbuf[i], c*X_RATIO*CS - CS*X_RATIO*MAX_CHARS / 2, -cline*CS + CS*MAX_LINES / 2, 0);
+					s3d_scale(screenbuf[i], CS);
+					s3d_flags_on(screenbuf[i], S3D_OF_VISIBLE);
 				}
-				if ((ch==0) || (line_end)) {	/*  the new character is zero! delete! */
-					line[cline].chars[c].character=0;
-					ci=charbuf[' '];
-					s3d_clone_target(screenbuf[i],ci);
-					line_end=1;
-					/* 					printf("-%03d",ch); */
+				if ((ch == 0) || (line_end)) { /*  the new character is zero! delete! */
+					line[cline].chars[c].character = 0;
+					ci = charbuf[' '];
+					s3d_clone_target(screenbuf[i], ci);
+					line_end = 1;
+					/*      printf("-%03d",ch); */
 				} else {
-					ci=charbuf[ch];
-					/* 					printf("!%03d",ch); */
-					s3d_clone_target(screenbuf[i],ci);
+					ci = charbuf[ch];
+					/*      printf("!%03d",ch); */
+					s3d_clone_target(screenbuf[i], ci);
 				}
 			} else {
-				/* 				printf("=%03d",ch); */
+				/*     printf("=%03d",ch); */
 			}
-			last_c[i]=ch;
+			last_c[i] = ch;
 		}
-		/* 		printf("\n"); */
+		/*   printf("\n"); */
 	}
-	gotnewdata=0;
+	gotnewdata = 0;
 }
 #endif
 #ifdef M_LINE
 void paintit()
 {
 	int cline;
-	int oid,c;
+	int oid, c;
 	int len;
 	int changed;
 	char cl[MAX_CHARS];
-	for (cline=0;cline<MAX_LINES;cline++) {
-		len=MAX_CHARS;
-		changed=0;
-		for (c=MAX_CHARS;c>=0;c--) {
-			cl[c]=line[cline].chars[c].character;
-			if (line[cline].chars[c].character!=line[cline].chars[c].last_c) {
-				changed=c+1;
-				/*				printf("changed [%d/%d] from %d to %d\n",cline,c,
-												line[cline].chars[c].last_c,
-												line[cline].chars[c].character
-												);*/
-				line[cline].chars[c].last_c=line[cline].chars[c].character;
+	for (cline = 0;cline < MAX_LINES;cline++) {
+		len = MAX_CHARS;
+		changed = 0;
+		for (c = MAX_CHARS;c >= 0;c--) {
+			cl[c] = line[cline].chars[c].character;
+			if (line[cline].chars[c].character != line[cline].chars[c].last_c) {
+				changed = c + 1;
+				/*    printf("changed [%d/%d] from %d to %d\n",cline,c,
+				        line[cline].chars[c].last_c,
+				        line[cline].chars[c].character
+				        );*/
+				line[cline].chars[c].last_c = line[cline].chars[c].character;
 			}
-			if (cl[c]==0) len=c;
+			if (cl[c] == 0) len = c;
 		}
 		if (changed) {
-			if (len>0) {
-				printf("[p: line %d [len: %d/changed: %d]\n",cline,len,changed);
-				oid=s3d_draw_string(cl,NULL);
-				s3d_translate(oid,0,-cline,0);
-				if (lines[cline]!=-1) {
+			if (len > 0) {
+				printf("[p: line %d [len: %d/changed: %d]\n", cline, len, changed);
+				oid = s3d_draw_string(cl, NULL);
+				s3d_translate(oid, 0, -cline, 0);
+				if (lines[cline] != -1) {
 					s3d_del_object(lines[cline]);
-					lines[cline]=-1;
+					lines[cline] = -1;
 				}
-				s3d_flags_on(oid,S3D_OF_VISIBLE);
-				lines[cline]=oid;
+				s3d_flags_on(oid, S3D_OF_VISIBLE);
+				lines[cline] = oid;
 			} else {
-				if (lines[cline]!=-1) {
+				if (lines[cline] != -1) {
 					s3d_del_object(lines[cline]);
-					lines[cline]=-1;
+					lines[cline] = -1;
 				}
 			}
 		}
 
 	}
-	gotnewdata=0;
+	gotnewdata = 0;
 }
 #endif
 /*
 void paint_chars()
 {
-	char c;
-	int oid;
-	int cline,cchar;
-	for(cline=0;cline<MAX_LINES;cline++)
-	{
-	    for(cchar=0;cchar<MAX_CHARS;cchar++)
-		{
-			c=line[cline].chars[cchar].character;
-/ * 			printf("%02x|",c); * /
-	        if(!islastchar(cline,cchar))
-	         if(line[cline].chars[cchar].character && line[cline].chars[cchar].character != ' ')
-			 {
-/ * 				if (screenbuf[MAX_LINES*MAX_CHARS]!=-1) s3d_del_object(screenbuf[MAX_LINES*MAX_CHARS]); * /
-				oid=s3d_clone(cobjs[c]);
-				s3d_translate(oid,10*cchar,10*cline,0);
-				s3d_flags_on(oid,S3D_OF_VISIBLE);
-				screenbuf[MAX_LINES*MAX_CHARS]=oid;
-			 }
-	    }
-/ * 		printf("\n"); * /
-	}
+ char c;
+ int oid;
+ int cline,cchar;
+ for(cline=0;cline<MAX_LINES;cline++)
+ {
+     for(cchar=0;cchar<MAX_CHARS;cchar++)
+  {
+   c=line[cline].chars[cchar].character;
+/ *    printf("%02x|",c); * /
+         if(!islastchar(cline,cchar))
+          if(line[cline].chars[cchar].character && line[cline].chars[cchar].character != ' ')
+    {
+/ *     if (screenbuf[MAX_LINES*MAX_CHARS]!=-1) s3d_del_object(screenbuf[MAX_LINES*MAX_CHARS]); * /
+    oid=s3d_clone(cobjs[c]);
+    s3d_translate(oid,10*cchar,10*cline,0);
+    s3d_flags_on(oid,S3D_OF_VISIBLE);
+    screenbuf[MAX_LINES*MAX_CHARS]=oid;
+    }
+     }
+/ *   printf("\n"); * /
+ }
 }*/
 int keypress(struct s3d_evt *event)
 {
-	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
+	struct s3d_key_event *keys = (struct s3d_key_event *)event->buf;
 	int key;
-	/*	printf("received key: %d\n",key);*/
-	switch (key=keys->keysym) {
+	/* printf("received key: %d\n",key);*/
+	switch (key = keys->keysym) {
 	case S3DK_F1:
 	case S3DK_F2:
 	case S3DK_F3:
@@ -388,7 +388,7 @@
 		term_addchar(0x1b);
 		term_addchar('[');
 		term_addchar('1');
-		term_addchar(key-S3DK_F1+'1');
+		term_addchar(key - S3DK_F1 + '1');
 		break;
 	case S3DK_F6:
 	case S3DK_F7:
@@ -396,21 +396,21 @@
 		term_addchar(0x1b);
 		term_addchar('[');
 		term_addchar('1');
-		term_addchar((key-S3DK_F6)+'7');
+		term_addchar((key - S3DK_F6) + '7');
 		break;
 	case S3DK_F9:
 	case S3DK_F10:
 		term_addchar(0x1b);
 		term_addchar('[');
 		term_addchar('2');
-		term_addchar((key-S3DK_F9)+'0');
+		term_addchar((key - S3DK_F9) + '0');
 		break;
 	case S3DK_F11:
 	case S3DK_F12:
 		term_addchar(0x1b);
 		term_addchar('[');
 		term_addchar('2');
-		term_addchar((key-S3DK_F11)+'3');
+		term_addchar((key - S3DK_F11) + '3');
 		break;
 	case S3DK_UP:
 		term_addchar(0x1b);
@@ -466,23 +466,23 @@
 	return(0);
 
 }
-int i=0;
+int i = 0;
 void mainloop()
 {
 	usleep(10000);
-	nanosleep(&t,NULL);
+	nanosleep(&t, NULL);
 
-	if ((i+=2)>100) {
-		if (i%2) {
-			s3d_flags_on(cursor,S3D_OF_VISIBLE);
-			i=0;
+	if ((i += 2) > 100) {
+		if (i % 2) {
+			s3d_flags_on(cursor, S3D_OF_VISIBLE);
+			i = 0;
 		} else {
-			s3d_flags_off(cursor,S3D_OF_VISIBLE);
-			i=1;
+			s3d_flags_off(cursor, S3D_OF_VISIBLE);
+			i = 1;
 		}
 	}
 	if (gotnewdata) {
-		/* 		printf("got new data,displaying\n"); */
+		/*   printf("got new data,displaying\n"); */
 		paintit();
 	}
 }
@@ -494,68 +494,68 @@
 unsigned int draw_background()
 {
 	unsigned int b;
-	b=s3d_new_object();
-	s3d_push_vertex(b,-MAX_CHARS/2*X_RATIO*CS	,CS	+CS*MAX_LINES/2		,-0.01);
-	s3d_push_vertex(b, MAX_CHARS/2*X_RATIO*CS	,CS	+CS*MAX_LINES/2		,-0.01);
-	s3d_push_vertex(b, MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
-	s3d_push_vertex(b,-MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
-	s3d_push_material_a(b,0.5,0.5,0.5,0.7,
-	                    1,1,1,0.7,
-	                    0,0,0,0.7);
-	s3d_push_polygon(b,1,2,0,0);
-	s3d_push_polygon(b,2,3,0,0);
-	s3d_flags_on(b,S3D_OF_VISIBLE);
+	b = s3d_new_object();
+	s3d_push_vertex(b, -MAX_CHARS / 2*X_RATIO*CS , CS + CS*MAX_LINES / 2  , -0.01);
+	s3d_push_vertex(b, MAX_CHARS / 2*X_RATIO*CS , CS + CS*MAX_LINES / 2  , -0.01);
+	s3d_push_vertex(b, MAX_CHARS / 2*X_RATIO*CS , -CS*MAX_LINES / 2  , -0.01);
+	s3d_push_vertex(b, -MAX_CHARS / 2*X_RATIO*CS , -CS*MAX_LINES / 2  , -0.01);
+	s3d_push_material_a(b, 0.5, 0.5, 0.5, 0.7,
+	                    1, 1, 1, 0.7,
+	                    0, 0, 0, 0.7);
+	s3d_push_polygon(b, 1, 2, 0, 0);
+	s3d_push_polygon(b, 2, 3, 0, 0);
+	s3d_flags_on(b, S3D_OF_VISIBLE);
 	return(b);
 }
 void chars_s3d_init()
 {
 #ifdef M_CHAR
 	char c[2];
-	c[1]='\0';
-	for (i=0;i<128;i++) {
-		c[0]=i;
-		charbuf[i]=s3d_draw_string(c,NULL);
+	c[1] = '\0';
+	for (i = 0;i < 128;i++) {
+		c[0] = i;
+		charbuf[i] = s3d_draw_string(c, NULL);
 	}
-	for (i=128;i<256;i++) {
-		charbuf[i]=s3d_new_object();
+	for (i = 128;i < 256;i++) {
+		charbuf[i] = s3d_new_object();
 	}
-	cursor=s3d_new_object();
-	s3d_clone_target(cursor,charbuf['_']);
+	cursor = s3d_new_object();
+	s3d_clone_target(cursor, charbuf['_']);
 #endif
 }
 void chars_init()
 {
 #ifdef M_CHAR
-	int x,y;
-	for (y=0;y<(MAX_LINES);y++)
-		for (x=0;x<(MAX_CHARS);x++) {
-			line[y].chars[x].character=line[y].chars[x].character=0;
-			i=y*MAX_CHARS+x;
-			screenbuf[i]=-1;
-			last_c[i]=0;
+	int x, y;
+	for (y = 0;y < (MAX_LINES);y++)
+		for (x = 0;x < (MAX_CHARS);x++) {
+			line[y].chars[x].character = line[y].chars[x].character = 0;
+			i = y * MAX_CHARS + x;
+			screenbuf[i] = -1;
+			last_c[i] = 0;
 		}
 #endif
 #ifdef M_LINE
 	int i;
-	for (i=0;i<MAX_LINES;i++)
-		lines[i]=-1;
+	for (i = 0;i < MAX_LINES;i++)
+		lines[i] = -1;
 #endif
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
 	unsigned int b;
 	chars_init();
 	init_terminal();
-	s3d_set_callback(S3D_EVENT_QUIT,stop);
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,stop);
-	s3d_set_callback(S3D_EVENT_KEY,keypress);
+	s3d_set_callback(S3D_EVENT_QUIT, stop);
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK, stop);
+	s3d_set_callback(S3D_EVENT_KEY, keypress);
 
-	if (!s3d_init(&argc,&argv,"s3dvt")) {
+	if (!s3d_init(&argc, &argv, "s3dvt")) {
 		if (s3d_select_font("vera")) {
 			printf("font not found\n");
 			exit(-1);
 		}
-		b=draw_background();
+		b = draw_background();
 		chars_s3d_init();
 		s3d_mainloop(mainloop);
 		s3d_quit();

Modified: trunk/apps/s3dvt/s3dvt.h
===================================================================
--- trunk/apps/s3dvt/s3dvt.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dvt/s3dvt.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,18 +22,18 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#define MAX_LINES	50
-#define MAX_CHARS	80
+#define MAX_LINES 50
+#define MAX_CHARS 80
 #define DEFAULT_FGCOLOR 2
 #define DEFAULT_BGCOLOR 0
-#define X_RATIO		0.75
-#define CS			0.1
+#define X_RATIO  0.75
+#define CS   0.1
 
-#define M_PIPE		1
-#define M_PTY		2
+#define M_PIPE  1
+#define M_PTY  2
 
-/* #define M_LINE		1 */
-#define M_CHAR		1
+/* #define M_LINE  1 */
+#define M_CHAR  1
 
 typedef struct char_struct {
 	char character;
@@ -53,4 +53,4 @@
 void AddChar(char *_toadd);
 
 extern int gotnewdata;
-extern int cx,cy;
+extern int cx, cy;

Modified: trunk/apps/s3dvt/terminal.c
===================================================================
--- trunk/apps/s3dvt/terminal.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/apps/s3dvt/terminal.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,113 +24,113 @@
 
 
 #include "s3dvt.h"
-#include <stdio.h> 		 /*  NULL,perror() */
-#include <string.h>		 /*  memcpy() */
-#include <stdlib.h>		 /*  atoi() */
-#define MOVE_RIGHT 	1
-#define MOVE_LEFT 	2
-#define MOVE_UP	 	3
-#define MOVE_DOWN 	4
+#include <stdio.h>    /*  NULL,perror() */
+#include <string.h>   /*  memcpy() */
+#include <stdlib.h>   /*  atoi() */
+#define MOVE_RIGHT  1
+#define MOVE_LEFT  2
+#define MOVE_UP   3
+#define MOVE_DOWN  4
 
 
-int cx=0,cy=0;
+int cx = 0, cy = 0;
 
-int gotnewdata=1;
+int gotnewdata = 1;
 t_line line[MAX_LINES+1];
-static int isansi=0;
-static int isansi2=0;
+static int isansi = 0;
+static int isansi2 = 0;
 
-static int bottom=MAX_LINES-1;
-static int top=0;
+static int bottom = MAX_LINES - 1;
+static int top = 0;
 
-static int curfgcolor=DEFAULT_FGCOLOR;
-static int curbgcolor=DEFAULT_BGCOLOR;
+static int curfgcolor = DEFAULT_FGCOLOR;
+static int curbgcolor = DEFAULT_BGCOLOR;
 
 void move_all_lines_up()
 {
-	t_line *pfirstline=(t_line*)&line;
-	t_line *psecondline=(t_line*)&line+1;
+	t_line *pfirstline = (t_line*) & line;
+	t_line *psecondline = (t_line*) & line + 1;
 	t_line tmpline[MAX_LINES];
-	memcpy(&tmpline, psecondline, (MAX_LINES-1)*sizeof(struct line_struct));
-	memcpy(pfirstline, &tmpline, (MAX_LINES-1)*sizeof(struct line_struct));
+	memcpy(&tmpline, psecondline, (MAX_LINES - 1)*sizeof(struct line_struct));
+	memcpy(pfirstline, &tmpline, (MAX_LINES - 1)*sizeof(struct line_struct));
 }
 
 void clear_char(int lineid, int charid)
 {
-	line[lineid].chars[charid].character=0;
-	line[lineid].chars[charid].fgcolor=DEFAULT_FGCOLOR;
-	line[lineid].chars[charid].bgcolor=DEFAULT_BGCOLOR;
+	line[lineid].chars[charid].character = 0;
+	line[lineid].chars[charid].fgcolor = DEFAULT_FGCOLOR;
+	line[lineid].chars[charid].bgcolor = DEFAULT_BGCOLOR;
 }
 
 void clear_line(int lineid)
 {
 	int i;
-	for (i=0;i<MAX_CHARS;i++)
+	for (i = 0;i < MAX_CHARS;i++)
 		clear_char(lineid, i);
 }
 
 void clear_line_after_lastchar()
 {
 	int i;
-	for (i=cx;i<MAX_CHARS;i++)
+	for (i = cx;i < MAX_CHARS;i++)
 		clear_char(cy, i);
 }
 
 t_line *line_is_full()
 {
-	t_line *pcurline=(t_line*)&line+cy;
+	t_line *pcurline = (t_line*) & line + cy;
 	cy++;
-	if (cy>=MAX_LINES) {       /*  damn it ... our display is filled ... let's move everything upwards */
-		cy=MAX_LINES-1;
-		pcurline=(t_line*)&line+cy;
+	if (cy >= MAX_LINES) {     /*  damn it ... our display is filled ... let's move everything upwards */
+		cy = MAX_LINES - 1;
+		pcurline = (t_line*) & line + cy;
 		move_all_lines_up();
 		clear_line(cy);
-		gotnewdata=1;
+		gotnewdata = 1;
 	} else {
-		pcurline=(t_line*)&line+cy;
+		pcurline = (t_line*) & line + cy;
 	}
-	cx=0;
+	cx = 0;
 	return pcurline;
 }
 
 void add_char_append(char toappend)
 {
-	int shouldinc=1;
-	t_line *pcurline=(t_line*)&line+cy;
-	if (cx==MAX_CHARS-1) {
-		pcurline=line_is_full();
-		shouldinc=0;
+	int shouldinc = 1;
+	t_line *pcurline = (t_line*) & line + cy;
+	if (cx == MAX_CHARS - 1) {
+		pcurline = line_is_full();
+		shouldinc = 0;
 	}  /*  our line is full */
-	pcurline->chars[cx].character=toappend;
-	pcurline->chars[cx].fgcolor=curfgcolor;
-	pcurline->chars[cx].bgcolor=curbgcolor;
+	pcurline->chars[cx].character = toappend;
+	pcurline->chars[cx].fgcolor = curfgcolor;
+	pcurline->chars[cx].bgcolor = curbgcolor;
 	if (shouldinc)
 		cx++;
 }
 
 void backspace()
 {
-	if (cx>0)
+	if (cx > 0)
 		cx--;
 	else
-		cx=0;
+		cx = 0;
 }
 
 void endansi()
 {
 	printf(" [/ANSI(%d)]\n", isansi2);
-	isansi=0;
-	isansi2=0;
+	isansi = 0;
+	isansi2 = 0;
 }
 
 /*
               Parameter                              Parameter Meaning
 
-	      0                                      Attributes off
-	      1                                      Bold or increased intensity
-	      4                                      Underscore
-	      5                                      Blink
-	      7                                      Negative (reverse) image
+       0                                      Attributes off
+       1                                      Bold or increased intensity
+       4                                      Underscore
+       5                                      Blink
+       7                                      Negative (reverse) image
 */
 
 void ansi_change_graphic(char **args)
@@ -138,26 +138,26 @@
 	int curcol;
 	int i;
 
-	if (args[0][0]=='\0') {
-		args[0][0]='0';
-		args[0][1]='\0';
+	if (args[0][0] == '\0') {
+		args[0][0] = '0';
+		args[0][1] = '\0';
 	}
 
-	for (i=0;i<5;i++) {
+	for (i = 0;i < 5;i++) {
 		if (args[i][0]) {
-			curcol=atoi(args[i]);
+			curcol = atoi(args[i]);
 
 			switch (curcol) {
 			case 0:
-				curbgcolor=DEFAULT_BGCOLOR;
-				curfgcolor=DEFAULT_FGCOLOR;
+				curbgcolor = DEFAULT_BGCOLOR;
+				curfgcolor = DEFAULT_FGCOLOR;
 				break;
-			case 1:	 /*  Bold or increased intensity */
-			case 4:	 /*  Underscore */
-			case 5:	 /*  Blink */
-			case 7:	 /*  Negative (reverse) image */
-			case 10:	 /*  primary font */
-			case 11:	 /*  alternate font */
+			case 1:  /*  Bold or increased intensity */
+			case 4:  /*  Underscore */
+			case 5:  /*  Blink */
+			case 7:  /*  Negative (reverse) image */
+			case 10:  /*  primary font */
+			case 11:  /*  alternate font */
 				break;
 			case 30:
 			case 31:
@@ -167,10 +167,10 @@
 			case 35:
 			case 36:
 			case 37:
-				curfgcolor=curcol-30;
+				curfgcolor = curcol - 30;
 				break;
 			case 39:
-				curbgcolor=DEFAULT_FGCOLOR;
+				curbgcolor = DEFAULT_FGCOLOR;
 				break;
 			case 40:
 			case 41:
@@ -180,11 +180,11 @@
 			case 45:
 			case 46:
 			case 47:
-				curbgcolor=curcol-40;
+				curbgcolor = curcol - 40;
 				break;
 
 			case 49:
-				curbgcolor=DEFAULT_BGCOLOR;
+				curbgcolor = DEFAULT_BGCOLOR;
 				break;
 
 			default:
@@ -202,18 +202,18 @@
 	int amount;
 	int i;
 
-	if (arg[0]) amount=atoi(arg);
-	else amount=0;
+	if (arg[0]) amount = atoi(arg);
+	else amount = 0;
 
 	printf("moving up %d lines", amount);
 
-	for (i=0;i<amount;i++) {
+	for (i = 0;i < amount;i++) {
 
-		pfirstline=(t_line*)&line+cy;
-		psecondline=pfirstline+1;
+		pfirstline = (t_line*) & line + cy;
+		psecondline = pfirstline + 1;
 
-		memcpy(&tmpline, psecondline, (bottom-top)*sizeof(struct line_struct));
-		memcpy(pfirstline, &tmpline,  (bottom-top)*sizeof(struct line_struct));
+		memcpy(&tmpline, psecondline, (bottom - top)*sizeof(struct line_struct));
+		memcpy(pfirstline, &tmpline, (bottom - top)*sizeof(struct line_struct));
 
 	}
 }
@@ -226,17 +226,17 @@
 	int amount;
 	int i;
 
-	if (arg[0]) amount=atoi(arg);
-	else amount=0;
+	if (arg[0]) amount = atoi(arg);
+	else amount = 0;
 
 	printf("moving down %d lines", amount);
 
-	for (i=0;i<amount;i++) {
-		pfirstline=(t_line*)&line+cy;
-		psecondline=pfirstline+1;
+	for (i = 0;i < amount;i++) {
+		pfirstline = (t_line*) & line + cy;
+		psecondline = pfirstline + 1;
 
-		memcpy(&tmpline, pfirstline, (bottom-top)*sizeof(struct line_struct));
-		memcpy(psecondline, &tmpline,  (bottom-top)*sizeof(struct line_struct));
+		memcpy(&tmpline, pfirstline, (bottom - top)*sizeof(struct line_struct));
+		memcpy(psecondline, &tmpline, (bottom - top)*sizeof(struct line_struct));
 	}
 }
 void delete_x_letters(char *arg1)
@@ -244,13 +244,13 @@
 	int tmpint;
 	t_line *pcurline;
 	int i;
-	if (arg1[0]) tmpint=atoi(arg1);
-	else	    tmpint=1;
-	pcurline=(t_line*)&line+cy;
-	if (tmpint+cx>MAX_CHARS)
-		tmpint=MAX_CHARS-cx;
-	for (i=cx;i<cx+tmpint;i++)
-		clear_char(cy,i);
+	if (arg1[0]) tmpint = atoi(arg1);
+	else     tmpint = 1;
+	pcurline = (t_line*) & line + cy;
+	if (tmpint + cx > MAX_CHARS)
+		tmpint = MAX_CHARS - cx;
+	for (i = cx;i < cx + tmpint;i++)
+		clear_char(cy, i);
 }
 void move_x_letters(int mode, char *arg1)
 {
@@ -258,27 +258,27 @@
 	t_line *pcurline;
 	int i;
 	if (arg1[0])
-		tmpint=atoi(arg1);
+		tmpint = atoi(arg1);
 	else
-		tmpint=1;
-	pcurline=(t_line*)&line+cy;
+		tmpint = 1;
+	pcurline = (t_line*) & line + cy;
 	switch (mode) {
 	case MOVE_RIGHT:
-		for (i=0;i<tmpint;i++) {
-			/*	    	    pcurline->nextchar++;
-							lastchar++;*/
+		for (i = 0;i < tmpint;i++) {
+			/*          pcurline->nextchar++;
+			    lastchar++;*/
 			cx++;
-			if (cx==MAX_CHARS)
-				pcurline=line_is_full();  /*  our line is full */
+			if (cx == MAX_CHARS)
+				pcurline = line_is_full();  /*  our line is full */
 		}
 		break;
 	case MOVE_LEFT:
-		for (i=0;i<tmpint;i++) {
+		for (i = 0;i < tmpint;i++) {
 			cx--;
-			if (cx==-1) {
+			if (cx == -1) {
 				cy--;
-				pcurline=(t_line*)&line+cy;
-				cx=MAX_CHARS-1;
+				pcurline = (t_line*) & line + cy;
+				cx = MAX_CHARS - 1;
 			}  /*  need to go up one line */
 		}
 		break;
@@ -294,26 +294,26 @@
 }
 void remove_beginning_from_curpos()
 {
-	int i,j=cx;
-	for (i=cy;i<MAX_LINES;i++) {
-		for (;j<MAX_CHARS;j++) {
-			clear_char(i,j);
+	int i, j = cx;
+	for (i = cy;i < MAX_LINES;i++) {
+		for (;j < MAX_CHARS;j++) {
+			clear_char(i, j);
 		}
-		j=0;
+		j = 0;
 	}
 }
 
 int parseansi(char curchar)
 {
-	static char arg1[16]="";
-	static char arg2[16]="";
-	static char arg3[16]="";
-	static char arg4[16]="";
-	static char arg5[16]="";
-	static char curindex=0;
-	static char curarg=0;
-	static char *args[]={arg1,arg2,arg3,arg4,arg5};
-	/* 	static char *args[]={&arg1,&arg2,&arg3,&arg4,&arg5}; */
+	static char arg1[16] = "";
+	static char arg2[16] = "";
+	static char arg3[16] = "";
+	static char arg4[16] = "";
+	static char arg5[16] = "";
+	static char curindex = 0;
+	static char curarg = 0;
+	static char *args[] = {arg1, arg2, arg3, arg4, arg5};
+	/*  static char *args[]={&arg1,&arg2,&arg3,&arg4,&arg5}; */
 	printf("%c", curchar);
 	switch (isansi2) {
 	case 1:
@@ -328,38 +328,38 @@
 		case '7':
 		case '8':
 		case '9':  /*  we got an argument */
-			args[(int)curarg][(int)curindex]=curchar;
+			args[(int)curarg][(int)curindex] = curchar;
 			curindex++;
-			args[(int)curarg][(int)curindex]='\0';
+			args[(int)curarg][(int)curindex] = '\0';
 			break;
 		case ';':  /*  some arg is finished */
 			curarg++;
-			curindex=0;
-			args[(int)curarg][0]='\0';
+			curindex = 0;
+			args[(int)curarg][0] = '\0';
 			break;
 		case 'J':  /*  remove beginning from current cursor to end of screen */
 			remove_beginning_from_curpos();
-			gotnewdata=1;
+			gotnewdata = 1;
 			break;
 		case 'K':  /*  remove everything in line beginning from lastchar */
 			clear_line_after_lastchar();
 			break;
 		case 'H':  /*  move to position x=arg1 y=arg2 */
-			if (arg1[0]) cy=atoi(arg1)-1;
-			else 	cy=0;
-			if (arg2[0]) cx=atoi(arg2)-1;
-			else 	cx=0;
+			if (arg1[0]) cy = atoi(arg1) - 1;
+			else  cy = 0;
+			if (arg2[0]) cx = atoi(arg2) - 1;
+			else  cx = 0;
 			break;
 		case 'G':  /*  move to position x=arg1 y=MAX */
-			if (arg1[0]) cx=atoi(arg1)-1;
-			else cx=-1;
-			cy=bottom-1;
+			if (arg1[0]) cx = atoi(arg1) - 1;
+			else cx = -1;
+			cy = bottom - 1;
 			break;
 		case 'd':  /*  move to position x=MAX y=arg1 */
-			if (arg1[0]) cy=atoi(arg1)-1;
-			else cy=0;
-			cy=top+cy;
-			cx=MAX_CHARS-1;
+			if (arg1[0]) cy = atoi(arg1) - 1;
+			else cy = 0;
+			cy = top + cy;
+			cx = MAX_CHARS - 1;
 			break;
 		case 'm':  /*  change graphic */
 			ansi_change_graphic(args);
@@ -371,23 +371,23 @@
 			move_down_x_lines(arg1);
 			break;
 		case 'l':
-			/*		RM -- Reset Mode
-					
-					ESC [ Ps ; Ps ; . . . ; Ps l                                                                                                          default value: none
-					
-					Resets one or more VT100 modes as specified by each selective parameter in the parameter string. Each mode to be reset is specified by a separate
-					parameter. [See Set Mode (SM) control sequence]. (See Modes following this section).*/
+			/*  RM -- Reset Mode
+			  
+			  ESC [ Ps ; Ps ; . . . ; Ps l                                                                                                          default value: none
+			  
+			  Resets one or more VT100 modes as specified by each selective parameter in the parameter string. Each mode to be reset is specified by a separate
+			  parameter. [See Set Mode (SM) control sequence]. (See Modes following this section).*/
 
 			/*  mc only resets the '4' !?! => IRM (Insert/Replacement-Mode) */
 			/*  perhaps Set Cursor to Block mode ? */
 			break;
 		case 'r':  /*  define scroll-range  */
-			if (arg1[0]) top=atoi(arg1);
-			else top=0;
-			if (arg2[0]) bottom=atoi(arg2);
-			else bottom=0;
-			cy=0;
-			cx=0;
+			if (arg1[0]) top = atoi(arg1);
+			else top = 0;
+			if (arg2[0]) bottom = atoi(arg2);
+			else bottom = 0;
+			cy = 0;
+			cx = 0;
 			break;
 		case 'a':
 		case 'A':  /*  move x letters up */
@@ -406,35 +406,35 @@
 			delete_x_letters(arg1);
 			break;
 		case '?':
-			isansi2=4;
+			isansi2 = 4;
 			return 0;
 		default:
 			printf("***unknown***");
 		}
-		if (!((curchar>='0' && curchar<='9') || curchar==';')) { /*  clean our args */
-			args[0][0]='\0';
-			args[1][0]='\0';
-			args[2][0]='\0';
-			args[3][0]='\0';
-			args[4][0]='\0';
-			curindex=0;
-			curarg=0;
+		if (!((curchar >= '0' && curchar <= '9') || curchar == ';')) { /*  clean our args */
+			args[0][0] = '\0';
+			args[1][0] = '\0';
+			args[2][0] = '\0';
+			args[3][0] = '\0';
+			args[4][0] = '\0';
+			curindex = 0;
+			curarg = 0;
 			endansi();
 		}
 		break;
 	case 0:
 		switch (curchar) {
 		case '[':
-			isansi2=1;
+			isansi2 = 1;
 			break;
 		case '(':
-			isansi2=2;
+			isansi2 = 2;
 			break;
 		case ')':
-			isansi2=3;
+			isansi2 = 3;
 			break;
 		case ']':
-			isansi2=5;
+			isansi2 = 5;
 			break;
 		default:
 			endansi();
@@ -442,11 +442,11 @@
 		}
 		break;
 	case 4:
-		if (curchar>'9' || curchar<'0')
+		if (curchar > '9' || curchar < '0')
 			endansi();
 		break;
 	case 5:
-		if (curchar==7) endansi(); /* FIXME: Window Title*/
+		if (curchar == 7) endansi(); /* FIXME: Window Title*/
 		break;
 	default:
 		endansi();
@@ -460,9 +460,9 @@
 	char *toadd;
 	char curchar;
 
-	for (toadd=_toadd;toadd[0];toadd++) {
-		curchar=toadd[0];
-		/*	printf("%.3d (", curchar);*/
+	for (toadd = _toadd;toadd[0];toadd++) {
+		curchar = toadd[0];
+		/* printf("%.3d (", curchar);*/
 		if (isansi)
 			parseansi(curchar);
 		else {
@@ -477,7 +477,7 @@
 			case 27:
 				/*  ANSI */
 				printf("<ESC>[ANSI] ");
-				isansi=1;
+				isansi = 1;
 				break;
 			case 10:
 				printf("<LF>\n");/* get onto the next line */
@@ -485,33 +485,33 @@
 				break;
 			case 13:
 				printf("<CR>\n");/* carriage return, get back */
-				if (cx==MAX_CHARS-1)
+				if (cx == MAX_CHARS - 1)
 					line_is_full();
-				cx=0;
+				cx = 0;
 				break;
 			default:
-				if ((curchar>=32) && (curchar<127)) {
-					/*	    printf("%c", curchar);*/
+				if ((curchar >= 32) && (curchar < 127)) {
+					/*     printf("%c", curchar);*/
 					add_char_append(curchar);
 				}
 				break;
 			}
-			/*	printf(")\n");*/
+			/* printf(")\n");*/
 		}
 	}
-	gotnewdata=1;
+	gotnewdata = 1;
 }
 void init_line()
 {
 	int i;
-	for (i=0;i<MAX_LINES;i++) {
+	for (i = 0;i < MAX_LINES;i++) {
 		clear_line(i);
 	}
 }
 void term_addstring(char *toprint)
 {
 	char *ns;
-	for (ns=toprint;ns[0];ns++) {
+	for (ns = toprint;ns[0];ns++) {
 		term_addchar(ns[0]);
 	}  /*  better method */
 }

Modified: trunk/example/filebrowser.c
===================================================================
--- trunk/example/filebrowser.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/filebrowser.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,48 +25,48 @@
 
 
 #include <s3d.h>
-#include <stdio.h> 	 /*  printf() */
+#include <stdio.h>   /*  printf() */
 #include <dirent.h>  /*  dirent */
-#include <stdlib.h>	 /*  malloc() */
+#include <stdlib.h>  /*  malloc() */
 #include <string.h>  /*  strlen(), strncmp(), strrchr() */
-#include <unistd.h>	 /*  chdir() */
-#include <math.h>	 /*  sin(),cos() */
-#include <time.h>	/* nanosleep() */
-static struct timespec t= {
-	0,100*1000*1000
+#include <unistd.h>  /*  chdir() */
+#include <math.h>  /*  sin(),cos() */
+#include <time.h> /* nanosleep() */
+static struct timespec t = {
+	0, 100*1000*1000
 }; /* 100 mili seconds */
 
-#define T_DUNO		0
-#define T_LOCALDIR	1
-#define T_BACKDIR	2
-#define T_FOLDER	3
-#define T_GEOMETRY	4
-#define T_MUSIC		5
-#define	T_MOVIE		6
+#define T_DUNO  0
+#define T_LOCALDIR 1
+#define T_BACKDIR 2
+#define T_FOLDER 3
+#define T_GEOMETRY 4
+#define T_MUSIC  5
+#define T_MOVIE  6
 
-#define M_DIR		512
-#define M_NAME		256
-int folder,geometry,mp3,movie,duno,dot,dotdot;
+#define M_DIR  512
+#define M_NAME  256
+int folder, geometry, mp3, movie, duno, dot, dotdot;
 struct t_item {
 	int icon_oid, descr_oid, pie_oid;
 	char name[M_NAME];
 	int type;
 };
 struct t_item *item;
-int n_item=0;
+int n_item = 0;
 int display_dir(char *dir, int depth, int  posx, int posy, int posz)
 {
 	struct dirent **namelist;
-	int n,i;
-	int  px,py,pz;
+	int n, i;
+	int  px, py, pz;
 	char *ext;
 	char *nstr;
-	float alpha,al,radius,f;
+	float alpha, al, radius, f;
 	char ndir[M_DIR+1];
 	if (n_item) {
-		printf("freeing %d old items\n",n_item);
-		for (i=0;i<n_item;i++) {
-			printf("deleting %d and %d\n",item[i].icon_oid,	item[i].descr_oid);
+		printf("freeing %d old items\n", n_item);
+		for (i = 0;i < n_item;i++) {
+			printf("deleting %d and %d\n", item[i].icon_oid, item[i].descr_oid);
 			s3d_del_object(item[i].descr_oid);
 			s3d_del_object(item[i].icon_oid);
 			s3d_del_object(item[i].pie_oid);
@@ -79,115 +79,115 @@
 		perror("scandir");
 		return(-1);
 	} else {
-		item=malloc(sizeof(struct t_item)*i);
-		n_item=i;
+		item = malloc(sizeof(struct t_item) * i);
+		n_item = i;
 		while (n--) {
-			item[n].type=T_DUNO;
-			nstr=namelist[n]->d_name;
-			strncpy(item[n].name,nstr,M_NAME);
-			if ((0==strncmp(nstr,".",1)) && (strlen(nstr)==1))
-				item[n].type=T_LOCALDIR;
-			else if (0==strncmp(nstr,"..",strlen(nstr)<2?strlen(nstr):2))
-				item[n].type=T_BACKDIR;
+			item[n].type = T_DUNO;
+			nstr = namelist[n]->d_name;
+			strncpy(item[n].name, nstr, M_NAME);
+			if ((0 == strncmp(nstr, ".", 1)) && (strlen(nstr) == 1))
+				item[n].type = T_LOCALDIR;
+			else if (0 == strncmp(nstr, "..", strlen(nstr) < 2 ? strlen(nstr) : 2))
+				item[n].type = T_BACKDIR;
 			else {
-				ext=strrchr(nstr,'.');
-				strncpy(ndir,dir,M_DIR);
-				ndir[M_DIR]=0;		/* just in case */
-				strncat(ndir,"/",M_DIR-strlen(ndir));
-				strncat(ndir,namelist[n]->d_name,M_DIR-strlen(ndir));
-				/* 				printf("displaying %s\n",ndir); */
-				if ((namelist[n]->d_type==DT_DIR) ||
-				                ((namelist[n]->d_type==DT_UNKNOWN) && (opendir(ndir)!=NULL)))
-					item[n].type=T_FOLDER;
+				ext = strrchr(nstr, '.');
+				strncpy(ndir, dir, M_DIR);
+				ndir[M_DIR] = 0;  /* just in case */
+				strncat(ndir, "/", M_DIR - strlen(ndir));
+				strncat(ndir, namelist[n]->d_name, M_DIR - strlen(ndir));
+				/*     printf("displaying %s\n",ndir); */
+				if ((namelist[n]->d_type == DT_DIR) ||
+				                ((namelist[n]->d_type == DT_UNKNOWN) && (opendir(ndir) != NULL)))
+					item[n].type = T_FOLDER;
 				else {
-					if (ext!=NULL) {
-						if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))
-							item[n].type=T_GEOMETRY;
-						else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))
-							item[n].type=T_MUSIC;
-						else if (0==strncmp(ext,".mpg",strlen(ext)<4?strlen(ext):4))
-							item[n].type=T_MOVIE;
+					if (ext != NULL) {
+						if (0 == strncmp(ext, ".3ds", strlen(ext) < 4 ? strlen(ext) : 4))
+							item[n].type = T_GEOMETRY;
+						else if (0 == strncmp(ext, ".mp3", strlen(ext) < 4 ? strlen(ext) : 4))
+							item[n].type = T_MUSIC;
+						else if (0 == strncmp(ext, ".mpg", strlen(ext) < 4 ? strlen(ext) : 4))
+							item[n].type = T_MOVIE;
 
 					}
 				}
 			}
 			switch (item[n].type) {
 			case T_LOCALDIR:
-				item[n].icon_oid=s3d_clone(dot);
+				item[n].icon_oid = s3d_clone(dot);
 				break;
 			case T_BACKDIR:
-				item[n].icon_oid=s3d_clone(dotdot);
+				item[n].icon_oid = s3d_clone(dotdot);
 				break;
 			case T_FOLDER:
-				item[n].icon_oid=s3d_clone(folder);
+				item[n].icon_oid = s3d_clone(folder);
 				break;
 			case T_GEOMETRY:
-				item[n].icon_oid=s3d_clone(geometry);
+				item[n].icon_oid = s3d_clone(geometry);
 				break;
 			case T_MUSIC:
-				item[n].icon_oid=s3d_clone(mp3);
+				item[n].icon_oid = s3d_clone(mp3);
 				break;
 			case T_MOVIE:
-				item[n].icon_oid=s3d_clone(movie);
+				item[n].icon_oid = s3d_clone(movie);
 				break;
 			default:
-				printf("don't know type, defaulting to duno %d...\n",duno);
-				item[n].icon_oid=s3d_clone(duno);
+				printf("don't know type, defaulting to duno %d...\n", duno);
+				item[n].icon_oid = s3d_clone(duno);
 				break;
 			}
 
-			px=posx;
-			py=posy;
-			pz=posz;
-			alpha=((360.0*n)/((float)i));
-			radius=((n_item*10)/(M_PI*4));
-			if (n_item<5)
-				radius=((50)/(M_PI*4));
+			px = posx;
+			py = posy;
+			pz = posz;
+			alpha = ((360.0 * n) / ((float)i));
+			radius = ((n_item * 10) / (M_PI * 4));
+			if (n_item < 5)
+				radius = ((50) / (M_PI * 4));
 			else
-				radius=((n_item*10)/(M_PI*4));
-			px=posx-sin(alpha*M_PI/180.0)*radius;
-			pz=posy;
-			pz=posz-cos(alpha*M_PI/180.0)*radius;
+				radius = ((n_item * 10) / (M_PI * 4));
+			px = posx - sin(alpha * M_PI / 180.0) * radius;
+			pz = posy;
+			pz = posz - cos(alpha * M_PI / 180.0) * radius;
 
-			item[n].pie_oid=s3d_new_object();
-			s3d_push_vertex(item[n].pie_oid,0,-2,0);
-			al=((360.0*(n-0.5))/((float)i));
+			item[n].pie_oid = s3d_new_object();
+			s3d_push_vertex(item[n].pie_oid, 0, -2, 0);
+			al = ((360.0 * (n - 0.5)) / ((float)i));
 			s3d_push_vertex(item[n].pie_oid,
-			                posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
-			al=((360.0*(n+0.5))/((float)i));
+			                posx - sin(al*M_PI / 180.0)*radius, -2, posz - cos(al*M_PI / 180.0)*radius);
+			al = ((360.0 * (n + 0.5)) / ((float)i));
 			s3d_push_vertex(item[n].pie_oid,
-			                posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
+			                posx - sin(al*M_PI / 180.0)*radius, -2, posz - cos(al*M_PI / 180.0)*radius);
 
-			f=1.0-0.05*(n%2);
+			f = 1.0 - 0.05 * (n % 2);
 			switch (item[n].type) {
 			case T_LOCALDIR:
-				s3d_push_material(item[n].pie_oid,		0,f,0,			0.5,0.5,0.5,		f,f,f);
+				s3d_push_material(item[n].pie_oid,  0, f, 0,   0.5, 0.5, 0.5,  f, f, f);
 				break;
 			case T_BACKDIR:
-				s3d_push_material(item[n].pie_oid,		0,f/2,0,		0.5,0.5,0.5,		f,f,f);
+				s3d_push_material(item[n].pie_oid,  0, f / 2, 0,  0.5, 0.5, 0.5,  f, f, f);
 				break;
 			case T_FOLDER:
-				s3d_push_material(item[n].pie_oid,		f,f,0,			0.5,0.5,0.0,		f,f,1);
+				s3d_push_material(item[n].pie_oid,  f, f, 0,   0.5, 0.5, 0.0,  f, f, 1);
 				break;
 			default:
-				s3d_push_material(item[n].pie_oid,		f,f,f,			0.5,0.5,0.5,		f,f,f);
+				s3d_push_material(item[n].pie_oid,  f, f, f,   0.5, 0.5, 0.5,  f, f, f);
 				break;
 			}
-			s3d_push_polygon(item[n].pie_oid,	0,2,1,	0);
+			s3d_push_polygon(item[n].pie_oid, 0, 2, 1, 0);
 
-			s3d_push_vertex(item[n].pie_oid,pz,-2,0);
-			s3d_translate(item[n].icon_oid,px,py,pz);
-			s3d_rotate(item[n].icon_oid,0,alpha,0);
-			s3d_flags_on(item[n].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_on(item[n].pie_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			item[n].descr_oid=s3d_draw_string(nstr,NULL);
-			s3d_link(item[n].descr_oid,item[n].icon_oid);
-			s3d_translate(item[n].descr_oid,-1,-2,0);
-			/* 			r=s3d_get_radius(p); */
-			/* 			s3d_scale(p,1.0/r,1.0/r,1.0/r); */
-			s3d_flags_on(item[n].descr_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			printf("%s [%d]\n", nstr,namelist[n]->d_type);
-			printf("string %d linked to %d\n",item[n].descr_oid,item[n].icon_oid);
+			s3d_push_vertex(item[n].pie_oid, pz, -2, 0);
+			s3d_translate(item[n].icon_oid, px, py, pz);
+			s3d_rotate(item[n].icon_oid, 0, alpha, 0);
+			s3d_flags_on(item[n].icon_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			s3d_flags_on(item[n].pie_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			item[n].descr_oid = s3d_draw_string(nstr, NULL);
+			s3d_link(item[n].descr_oid, item[n].icon_oid);
+			s3d_translate(item[n].descr_oid, -1, -2, 0);
+			/*    r=s3d_get_radius(p); */
+			/*    s3d_scale(p,1.0/r,1.0/r,1.0/r); */
+			s3d_flags_on(item[n].descr_oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+			printf("%s [%d]\n", nstr, namelist[n]->d_type);
+			printf("string %d linked to %d\n", item[n].descr_oid, item[n].icon_oid);
 			free(namelist[n]);
 		}
 		free(namelist);
@@ -197,31 +197,31 @@
 
 int object_click(struct s3d_evt *evt)
 {
-	int i,oid;
+	int i, oid;
 	char execstr[256];
-	oid=(int)*((unsigned long *)evt->buf);
-	printf("!!!!!!!!! clicked object %d\n",oid);
-	for (i=0;i<n_item;i++) {
-		if (((oid==item[i].icon_oid) || (oid==item[i].descr_oid)) ||
-		                (oid==item[i].pie_oid) ) {
+	oid = (int) * ((unsigned long *)evt->buf);
+	printf("!!!!!!!!! clicked object %d\n", oid);
+	for (i = 0;i < n_item;i++) {
+		if (((oid == item[i].icon_oid) || (oid == item[i].descr_oid)) ||
+		                (oid == item[i].pie_oid)) {
 			switch (item[i].type) {
 			case T_BACKDIR:
 			case T_FOLDER:
 			case T_LOCALDIR:
-				printf("going into %s\n",item[i].name);
+				printf("going into %s\n", item[i].name);
 				chdir(item[i].name);
-				display_dir(".",0,0,0,0);
+				display_dir(".", 0, 0, 0, 0);
 				return(0);
 				break;
 			case T_GEOMETRY:
-				printf("loading geometry %s\n",item[i].name);
-				snprintf(execstr,256,"modelloader \"%s\"&\n",item[i].name);
+				printf("loading geometry %s\n", item[i].name);
+				snprintf(execstr, 256, "modelloader \"%s\"&\n", item[i].name);
 				system(execstr);
 				return(0);
 				break;
 			case T_MOVIE:
-				printf("playing %s\n",item[i].name);
-				snprintf(execstr,256,"mplayer -vo s3d \"%s\"&\n",item[i].name);
+				printf("playing %s\n", item[i].name);
+				snprintf(execstr, 256, "mplayer -vo s3d \"%s\"&\n", item[i].name);
 				system(execstr);
 				return(0);
 				break;
@@ -234,24 +234,24 @@
 }
 void mainloop()
 {
-	nanosleep(&t,NULL);
+	nanosleep(&t, NULL);
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
 	int i;
-	if (!s3d_init(&argc,&argv,"filebrowser")) {
-		i=0;
+	if (!s3d_init(&argc, &argv, "filebrowser")) {
+		i = 0;
 		/*  load the object files */
-		folder=s3d_import_model_file("objs/folder.3ds");
-		geometry=s3d_import_model_file("objs/geometry.3ds");
-		mp3=s3d_import_model_file("objs/notes.3ds");
-		movie=s3d_import_model_file("objs/film.3ds");
-		duno=s3d_import_model_file("objs/duno.3ds");
-		dot=s3d_import_model_file("objs/dot.3ds");
-		dotdot=s3d_import_model_file("objs/dotdot.3ds");
+		folder = s3d_import_model_file("objs/folder.3ds");
+		geometry = s3d_import_model_file("objs/geometry.3ds");
+		mp3 = s3d_import_model_file("objs/notes.3ds");
+		movie = s3d_import_model_file("objs/film.3ds");
+		duno = s3d_import_model_file("objs/duno.3ds");
+		dot = s3d_import_model_file("objs/dot.3ds");
+		dotdot = s3d_import_model_file("objs/dotdot.3ds");
 		s3d_select_font("vera");
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-		display_dir(".",0,0,0,0);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, object_click);
+		display_dir(".", 0, 0, 0, 0);
 		s3d_mainloop(mainloop);
 		s3d_quit();
 	}

Modified: trunk/example/hudtest.c
===================================================================
--- trunk/example/hudtest.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/hudtest.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -32,16 +32,16 @@
 }
 int main(int argc, char **argv)
 {
-	int o,m;
-	if (!s3d_init(&argc,&argv,"hud-test")) {
+	int o, m;
+	if (!s3d_init(&argc, &argv, "hud-test")) {
 		if (s3d_select_font("vera"))
 			printf("font not found\n");
-		o=s3d_draw_string("hud-test",NULL);
-		m=s3d_import_model_file("objs/star.3ds");
-		s3d_translate(o,0,0,-5);
-		s3d_link(o,0);
-		s3d_flags_on(o,S3D_OF_VISIBLE);
-		s3d_flags_on(m,S3D_OF_VISIBLE);
+		o = s3d_draw_string("hud-test", NULL);
+		m = s3d_import_model_file("objs/star.3ds");
+		s3d_translate(o, 0, 0, -5);
+		s3d_link(o, 0);
+		s3d_flags_on(o, S3D_OF_VISIBLE);
+		s3d_flags_on(m, S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
 		s3d_quit();
 	}

Modified: trunk/example/katze.c
===================================================================
--- trunk/example/katze.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/katze.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,66 +25,66 @@
 
 
 #include <s3d.h>
-#include <math.h>	/* sin() */
-#include <time.h>	/* nanosleep() */
-static struct timespec t= {
-	0,10*1000*1000
+#include <math.h> /* sin() */
+#include <time.h> /* nanosleep() */
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 
 int a;
-int rot_point,body,legfr,legbr,legfl,legbl,tail;
+int rot_point, body, legfr, legbr, legfl, legbl, tail;
 
 void mainloop()
 {
 	float pos;
-	a=(a+2)%360;
-	pos=sin((5*a*M_PI)/180)*20;
-	s3d_rotate(legfr,0,90,180+pos);
-	s3d_rotate(legfl,0,90,180-pos);
-	s3d_rotate(legbr,0,0,180+pos);
-	s3d_rotate(legbl,0,0,180-pos);
+	a = (a + 2) % 360;
+	pos = sin((5 * a * M_PI) / 180) * 20;
+	s3d_rotate(legfr, 0, 90, 180 + pos);
+	s3d_rotate(legfl, 0, 90, 180 - pos);
+	s3d_rotate(legbr, 0, 0, 180 + pos);
+	s3d_rotate(legbl, 0, 0, 180 - pos);
 
-	s3d_rotate(tail,0,30,110+pos);
-	s3d_rotate(rot_point,0,-a,0);
-	nanosleep(&t,NULL);
+	s3d_rotate(tail, 0, 30, 110 + pos);
+	s3d_rotate(rot_point, 0, -a, 0);
+	nanosleep(&t, NULL);
 }
 int main(int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"running cat")) {
+	if (!s3d_init(&argc, &argv, "running cat")) {
 
-		rot_point=s3d_new_object();
-		body=s3d_import_model_file("objs/katze_body.3ds");
-		legfr=s3d_import_model_file("objs/katze_leg.3ds");
-		tail=s3d_import_model_file("objs/katze_tail.3ds");
-		legfl=s3d_clone(legfr);
-		legbl=s3d_clone(legfr);
-		legbr=s3d_clone(legfr);
-		s3d_translate(legfl,2.3,1.0,0.5);
-		s3d_translate(legfr,0,1.0,0.2);
-		s3d_translate(legbl,-1.2,1.0,-1.8);
-		s3d_translate(legbr,-1.2,1.0,0.0);
-		s3d_translate(tail,-1.6,1.6,-0.8);
-		s3d_translate(body,1.3,0.0,-1.3);
-		s3d_link(legfr,body);
-		s3d_link(legfl,body);
-		s3d_link(legbr,body);
-		s3d_link(legbl,body);
-		s3d_link(tail,body);
-		s3d_link(body,rot_point);
-		/*		s3d_link(oid_foot,oid_head);
-		 *		s3d_link(oid_middle,oid_head);
-		 *		s3d_translate(oid_head,0,4,0);
+		rot_point = s3d_new_object();
+		body = s3d_import_model_file("objs/katze_body.3ds");
+		legfr = s3d_import_model_file("objs/katze_leg.3ds");
+		tail = s3d_import_model_file("objs/katze_tail.3ds");
+		legfl = s3d_clone(legfr);
+		legbl = s3d_clone(legfr);
+		legbr = s3d_clone(legfr);
+		s3d_translate(legfl, 2.3, 1.0, 0.5);
+		s3d_translate(legfr, 0, 1.0, 0.2);
+		s3d_translate(legbl, -1.2, 1.0, -1.8);
+		s3d_translate(legbr, -1.2, 1.0, 0.0);
+		s3d_translate(tail, -1.6, 1.6, -0.8);
+		s3d_translate(body, 1.3, 0.0, -1.3);
+		s3d_link(legfr, body);
+		s3d_link(legfl, body);
+		s3d_link(legbr, body);
+		s3d_link(legbl, body);
+		s3d_link(tail, body);
+		s3d_link(body, rot_point);
+		/*  s3d_link(oid_foot,oid_head);
+		 *  s3d_link(oid_middle,oid_head);
+		 *  s3d_translate(oid_head,0,4,0);
 
-		 *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
-		 *		s3d_translate(oid_foot,0,-3.5,0); */
+		 *  s3d_translate(oid_middle,0,-1.5,0);  * relative to head: *
+		 *  s3d_translate(oid_foot,0,-3.5,0); */
 
 
-		s3d_flags_on(body,S3D_OF_VISIBLE);
-		s3d_flags_on(legfr,S3D_OF_VISIBLE);
-		s3d_flags_on(legfl,S3D_OF_VISIBLE);
-		s3d_flags_on(legbr,S3D_OF_VISIBLE);
-		s3d_flags_on(legbl,S3D_OF_VISIBLE);
-		s3d_flags_on(tail,S3D_OF_VISIBLE);
+		s3d_flags_on(body, S3D_OF_VISIBLE);
+		s3d_flags_on(legfr, S3D_OF_VISIBLE);
+		s3d_flags_on(legfl, S3D_OF_VISIBLE);
+		s3d_flags_on(legbr, S3D_OF_VISIBLE);
+		s3d_flags_on(legbl, S3D_OF_VISIBLE);
+		s3d_flags_on(tail, S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
 		s3d_quit();
 	}

Modified: trunk/example/linetest.c
===================================================================
--- trunk/example/linetest.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/linetest.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -35,51 +35,51 @@
 
 void mainloop()
 {
-	i=(i+1)%2;
+	i = (i + 1) % 2;
 	if (i) {
-		s3d_pep_vertex(o,1,-2,0);
-		s3d_pep_line(o,0,2,3);
+		s3d_pep_vertex(o, 1, -2, 0);
+		s3d_pep_line(o, 0, 2, 3);
 	} else {
-		s3d_pep_vertex(o,1,-1,0);
-		s3d_pep_line(o,0,1,0);
+		s3d_pep_vertex(o, 1, -1, 0);
+		s3d_pep_line(o, 0, 1, 0);
 
 	}
-	/* 	printf("now it's %s\n",time_str); */
+	/*  printf("now it's %s\n",time_str); */
 	sleep(1);
 
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	i=0;
-	if (!s3d_init(&argc,&argv,"linetest")) {
-		o=s3d_new_object();
+	i = 0;
+	if (!s3d_init(&argc, &argv, "linetest")) {
+		o = s3d_new_object();
 
 		s3d_push_material(o,
-		                  1,0,0,
-		                  1,0,0,
-		                  1,0,0);
+		                  1, 0, 0,
+		                  1, 0, 0,
+		                  1, 0, 0);
 		s3d_push_material(o,
-		                  0,1,0,
-		                  0,1,0,
-		                  0,1,0);
+		                  0, 1, 0,
+		                  0, 1, 0,
+		                  0, 1, 0);
 		s3d_push_material(o,
-		                  0,1,0,
-		                  0,1,0,
-		                  0,1,0);
+		                  0, 1, 0,
+		                  0, 1, 0,
+		                  0, 1, 0);
 		s3d_push_material(o,
-		                  1,1,0,
-		                  1,1,0,
-		                  1,1,0);
-		s3d_push_vertex(o,-1,-1,0);
-		s3d_push_vertex(o,-1,1,0);
-		s3d_push_vertex(o,1,1,0);
-		s3d_push_vertex(o,1,-1,0);
-		s3d_push_line(o,2,3,1);
-		s3d_push_line(o,0,1,0);
+		                  1, 1, 0,
+		                  1, 1, 0,
+		                  1, 1, 0);
+		s3d_push_vertex(o, -1, -1, 0);
+		s3d_push_vertex(o, -1, 1, 0);
+		s3d_push_vertex(o, 1, 1, 0);
+		s3d_push_vertex(o, 1, -1, 0);
+		s3d_push_line(o, 2, 3, 1);
+		s3d_push_line(o, 0, 1, 0);
 
-		s3d_flags_on(o,S3D_OF_VISIBLE);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
+		s3d_flags_on(o, S3D_OF_VISIBLE);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, (s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_QUIT, (s3d_cb)stop);
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/example/modelloader.c
===================================================================
--- trunk/example/modelloader.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/modelloader.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,16 +26,16 @@
 
 #include <s3d.h>
 #include <stdio.h>  /* NULL */
-#include <time.h>	/* nanosleep() */
-static struct timespec t= {
-	0,100*1000*1000
+#include <time.h> /* nanosleep() */
+static struct timespec t = {
+	0, 100*1000*1000
 }; /* 100 mili seconds */
-int i,oid;
+int i, oid;
 void mainloop()
 {
-	s3d_rotate(oid,0,i,0);
-	i=(i+1)%360;
-	nanosleep(&t,NULL);
+	s3d_rotate(oid, 0, i, 0);
+	i = (i + 1) % 360;
+	nanosleep(&t, NULL);
 }
 int object_click(struct s3d_evt *evt)
 {
@@ -43,17 +43,17 @@
 	return(0);
 }
 
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	if (argc<2) {
-		printf("usage: %s [somefile.3ds]\n",argv[0]);
+	if (argc < 2) {
+		printf("usage: %s [somefile.3ds]\n", argv[0]);
 		return(-1);
 	}
-	if (!s3d_init(&argc,&argv,"modelloader")) {
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-		i=0;
-		if (-1!=(oid=s3d_import_model_file(argv[1]))) {
-			s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	if (!s3d_init(&argc, &argv, "modelloader")) {
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, object_click);
+		i = 0;
+		if (-1 != (oid = s3d_import_model_file(argv[1]))) {
+			s3d_flags_on(oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 			s3d_mainloop(mainloop);
 		} else {
 			printf("file not found ... \n");

Modified: trunk/example/nichtsnutz.c
===================================================================
--- trunk/example/nichtsnutz.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/nichtsnutz.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -30,12 +30,12 @@
 #include <math.h>
 #include <time.h>
 
-static struct timespec t= {
-	0,10*1000*1000
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 
-int object,foll;
-float al, r, rc ,alpha=0.0, Asp, Bottom, Left, angle;
+int object, foll;
+float al, r, rc , alpha = 0.0, Asp, Bottom, Left, angle;
 float CamPosition[2][3],
 TmpMove[3],
 Tmp[3],
@@ -48,37 +48,37 @@
 void mainloop()
 {
 
-	al=(alpha*M_PI/180);
+	al = (alpha * M_PI / 180);
 	r = 5.0;
 	rc = 12.0;
 
-	CatPos[0] = sin(al)*r;
+	CatPos[0] = sin(al) * r;
 	CatPos[1] = 0;
-	CatPos[2] = cos(al)*r;
+	CatPos[2] = cos(al) * r;
 	/*
 	RotCam[0][0] = sin(al) * rc;
 	RotCam[0][1] = 0.0;
 	RotCam[0][2] = cos(al) * rc;
 	*/
-	s3d_translate(object,CatPos[0] ,CatPos[1], CatPos[2]);
+	s3d_translate(object, CatPos[0] , CatPos[1], CatPos[2]);
 	s3d_rotate(object, 0, alpha, 0);
-	alpha = alpha+0.1;
-	if (alpha>360.0) alpha=0.0;
+	alpha = alpha + 0.1;
+	if (alpha > 360.0) alpha = 0.0;
 
 	length = s3d_vector_length(CatPos);
 
 
-	RotCam[0][0] = ( CatPos[0] * 12.0 ) / length;
-	RotCam[0][1] = ( CatPos[1] * 12.0 ) / length;
-	RotCam[0][2] = ( CatPos[2] * 12.0 ) / length;
+	RotCam[0][0] = (CatPos[0] * 12.0) / length;
+	RotCam[0][1] = (CatPos[1] * 12.0) / length;
+	RotCam[0][2] = (CatPos[2] * 12.0) / length;
 
 
-	if ( foll ) {
+	if (foll) {
 
-		CamPosition[0][0] = ((CamPosition[0][0]*4 + RotCam[0][0])/5);
-		CamPosition[0][1] = ((CamPosition[0][1]*4 + RotCam[0][1])/5);
-		CamPosition[0][2] = ((CamPosition[0][2]*4 + RotCam[0][2])/5);
-		s3d_translate(0,CamPosition[0][0],CamPosition[0][1],CamPosition[0][2]);
+		CamPosition[0][0] = ((CamPosition[0][0] * 4 + RotCam[0][0]) / 5);
+		CamPosition[0][1] = ((CamPosition[0][1] * 4 + RotCam[0][1]) / 5);
+		CamPosition[0][2] = ((CamPosition[0][2] * 4 + RotCam[0][2]) / 5);
+		s3d_translate(0, CamPosition[0][0], CamPosition[0][1], CamPosition[0][2]);
 
 		TmpMove[0] = 0.0;
 		TmpMove[1] = 0.0;
@@ -88,25 +88,25 @@
 		Tmp[1] = 0.0;
 		Tmp[2] = CamPosition[0][2] - CatPos[2];
 
-		angle = s3d_vector_angle(Tmp,TmpMove);
-		angle = (CatPos[0] > 0)?(180-(180 / M_PI * angle)):(180+(180 / M_PI * angle));
-		printf("%f %f\n",angle,al);
+		angle = s3d_vector_angle(Tmp, TmpMove);
+		angle = (CatPos[0] > 0) ? (180 - (180 / M_PI * angle)) : (180 + (180 / M_PI * angle));
+		printf("%f %f\n", angle, al);
 
-		CamPosition[1][1] = (CamPosition[1][1]*4 + angle)/5;
-		s3d_rotate(0,CamPosition[1][0], CamPosition[1][1], CamPosition[1][2]);
+		CamPosition[1][1] = (CamPosition[1][1] * 4 + angle) / 5;
+		s3d_rotate(0, CamPosition[1][0], CamPosition[1][1], CamPosition[1][2]);
 	}
 
 
 
-	nanosleep(&t,NULL);
+	nanosleep(&t, NULL);
 }
 
 int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz->buf;
+	inf = (struct s3d_obj_info *)hrmz->buf;
 
-	if (inf->object==0) {
+	if (inf->object == 0) {
 		CamPosition[0][0] = inf->trans_x;
 		CamPosition[0][1] = inf->trans_y;
 		CamPosition[0][2] = inf->trans_z;
@@ -114,13 +114,13 @@
 		CamPosition[1][1] = inf->rot_y;
 		CamPosition[1][2] = inf->rot_z;
 
-		Asp=inf->scale;
-		if (Asp>1.0) { /* wide screen */
-			Bottom=-1.0;
-			Left=-Asp;
+		Asp = inf->scale;
+		if (Asp > 1.0) { /* wide screen */
+			Bottom = -1.0;
+			Left = -Asp;
 		} else {  /* high screen */
-			Bottom=(-1.0/Asp);
-			Left=-1.0;
+			Bottom = (-1.0 / Asp);
+			Left = -1.0;
 		}
 	}
 	return(0);
@@ -131,11 +131,11 @@
 int keypress(struct s3d_evt *event)
 {
 	int key;
-	key=*((unsigned short *)event->buf);
+	key = *((unsigned short *)event->buf);
 	switch (key) {
 	case 'f':
 		foll = foll ? 0 : 1;
-		if ( foll ) {
+		if (foll) {
 			TmpCam[0][0] = CamPosition[0][0];
 			TmpCam[0][1] = CamPosition[0][1];
 			TmpCam[0][2] = CamPosition[0][2];
@@ -152,9 +152,9 @@
 int main(int argc, char **argv)
 {
 
-	if (!s3d_init(&argc,&argv,"running cat")) {
-		s3d_set_callback(S3D_EVENT_KEY,keypress);
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
+	if (!s3d_init(&argc, &argv, "running cat")) {
+		s3d_set_callback(S3D_EVENT_KEY, keypress);
+		s3d_set_callback(S3D_EVENT_OBJ_INFO, object_info);
 
 		object = s3d_import_model_file("objs/katze_body.3ds");
 		s3d_flags_on(object, S3D_OF_VISIBLE);

Modified: trunk/example/ptrtest.c
===================================================================
--- trunk/example/ptrtest.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/ptrtest.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,17 +24,17 @@
 
 #include <s3d.h>
 #include <stdio.h>  /*  NULL*/
-#include <time.h>	/* nanosleep() */
-#include <math.h>	/* sin(), cos() */
+#include <time.h> /* nanosleep() */
+#include <math.h> /* sin(), cos() */
 int i;
 int o;
-float bottom=-1.0;
-float left=-1.0;
-float asp=1.0;
-float len=1.0;
-int alpha=0;
-static struct timespec t= {
-	0,10*1000*1000
+float bottom = -1.0;
+float left = -1.0;
+float asp = 1.0;
+float len = 1.0;
+int alpha = 0;
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 100 mili seconds */
 int stop(struct s3d_evt *evt)
 {
@@ -45,32 +45,32 @@
 void mainloop()
 {
 	float a;
-	alpha=(alpha+1)%360;
-	s3d_rotate(o,alpha,0,0);
-	a=(((float)alpha)*M_PI/180);
-	s3d_translate(0,sin(a)*30,0,30+cos(a)*30);
-	s3d_rotate(0,sin(a)*30,alpha,0);
-	nanosleep(&t,NULL);
+	alpha = (alpha + 1) % 360;
+	s3d_rotate(o, alpha, 0, 0);
+	a = (((float)alpha) * M_PI / 180);
+	s3d_translate(0, sin(a)*30, 0, 30 + cos(a)*30);
+	s3d_rotate(0, sin(a)*30, alpha, 0);
+	nanosleep(&t, NULL);
 }
 int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz->buf;
-	if (inf->object==0) {
-		if (asp!=inf->scale) {
-			asp=inf->scale;
-			printf("screen aspect: %f\n",asp);
-			if (asp>1.0) { /* wide screen */
-				bottom=-1.0;
-				left=-asp;
+	inf = (struct s3d_obj_info *)hrmz->buf;
+	if (inf->object == 0) {
+		if (asp != inf->scale) {
+			asp = inf->scale;
+			printf("screen aspect: %f\n", asp);
+			if (asp > 1.0) { /* wide screen */
+				bottom = -1.0;
+				left = -asp;
 			} else {  /* high screen */
-				bottom=(-1.0/asp);
-				left=-1.0;
+				bottom = (-1.0 / asp);
+				left = -1.0;
 			}
 		}
 	}
-	if (inf->object==1) { /* of course, a link s3d_link(o,1 would be much easier ... */
-		s3d_translate(o,(inf->trans_x)*2.0,(inf->trans_y)*2.0,-2);
+	if (inf->object == 1) { /* of course, a link s3d_link(o,1 would be much easier ... */
+		s3d_translate(o, (inf->trans_x)*2.0, (inf->trans_y)*2.0, -2);
 	}
 	return(0);
 }
@@ -78,33 +78,33 @@
 {
 	struct s3d_but_info *inf;
 	char s[256];
-	inf=(struct s3d_but_info *)hrmz->buf;
-	snprintf(s,256,"please, watch your stomach! button %d, state %d", inf->button,inf->state);
-	printf("button %d, state %d\n", inf->button,inf->state);
+	inf = (struct s3d_but_info *)hrmz->buf;
+	snprintf(s, 256, "please, watch your stomach! button %d, state %d", inf->button, inf->state);
+	printf("button %d, state %d\n", inf->button, inf->state);
 	s3d_del_object(o);
-	o=s3d_draw_string(s,&len);
-	s3d_translate(o,0,0,-2);
-	s3d_scale(o,0.2);
-	s3d_link(o,0);			/* link to cam */
-	/*	s3d_link(o,1);*/
-	s3d_flags_on(o,S3D_OF_VISIBLE);
+	o = s3d_draw_string(s, &len);
+	s3d_translate(o, 0, 0, -2);
+	s3d_scale(o, 0.2);
+	s3d_link(o, 0);  /* link to cam */
+	/* s3d_link(o,1);*/
+	s3d_flags_on(o, S3D_OF_VISIBLE);
 	return(0);
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	i=0;
-	if (!s3d_init(&argc,&argv,"ptr and cam test")) {
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-		s3d_set_callback(S3D_EVENT_MBUTTON,mbutton_press);
-		s3d_set_callback(S3D_EVENT_QUIT,stop);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,stop);
+	i = 0;
+	if (!s3d_init(&argc, &argv, "ptr and cam test")) {
+		s3d_set_callback(S3D_EVENT_OBJ_INFO, object_info);
+		s3d_set_callback(S3D_EVENT_MBUTTON, mbutton_press);
+		s3d_set_callback(S3D_EVENT_QUIT, stop);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, stop);
 		s3d_select_font("vera");
-		o=s3d_draw_string("hello",&len);
-		s3d_translate(o,0,0,-2);
-		s3d_link(o,0);			/* link to cam */
-		/*		s3d_link(o,1);*/
-		s3d_scale(o,0.2);
-		s3d_flags_on(o,S3D_OF_VISIBLE);
+		o = s3d_draw_string("hello", &len);
+		s3d_translate(o, 0, 0, -2);
+		s3d_link(o, 0);  /* link to cam */
+		/*  s3d_link(o,1);*/
+		s3d_scale(o, 0.2);
+		s3d_flags_on(o, S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/example/radius_test.c
===================================================================
--- trunk/example/radius_test.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/radius_test.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,51 +23,51 @@
 
 #include <s3d.h>
 #include <stdio.h>  /*  NULL */
-#include <time.h>	/* nanosleep() */
-static struct timespec t= {
-	0,10*1000*1000
+#include <time.h> /* nanosleep() */
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 
-#include <math.h>	/* sin(), cos() */
+#include <math.h> /* sin(), cos() */
 int item1, item2, item3;
-int i=0;
+int i = 0;
 void mainloop()
 {
-	float f,g,h;
-	f=sin((M_PI*(i%360))/180.0);
-	g=cos((M_PI*(i%360))/180.0);
-	h=sin((M_PI*((3*i)%360))/180.0);
+	float f, g, h;
+	f = sin((M_PI * (i % 360)) / 180.0);
+	g = cos((M_PI * (i % 360)) / 180.0);
+	h = sin((M_PI * ((3 * i) % 360)) / 180.0);
 
-	s3d_translate(item1,f*10,h*2, g*5);
-	s3d_rotate(item1,0,i%360,0);
-	/*	s3d_scale(item1,h+3,h+3,h+3);*/
+	s3d_translate(item1, f*10, h*2, g*5);
+	s3d_rotate(item1, 0, i % 360, 0);
+	/* s3d_scale(item1,h+3,h+3,h+3);*/
 
-	/*	s3d_translate(item2,f*10,0, g*5);*/
-	s3d_translate(item2,0,0,10);
-	/*	s3d_rotate(item2,i%360,0,-i%360);
-		s3d_scale(item2,2*f+5,2*f+5,2*f+5);*/
+	/* s3d_translate(item2,f*10,0, g*5);*/
+	s3d_translate(item2, 0, 0, 10);
+	/* s3d_rotate(item2,i%360,0,-i%360);
+	 s3d_scale(item2,2*f+5,2*f+5,2*f+5);*/
 
-	s3d_translate(item3,0,0,10);
-	/*	s3d_rotate(item3,((8*i)%360),0,-((8*i)%360));
-		s3d_scale(item3,2*f+5,2*f+5,2*f+5);*/
+	s3d_translate(item3, 0, 0, 10);
+	/* s3d_rotate(item3,((8*i)%360),0,-((8*i)%360));
+	 s3d_scale(item3,2*f+5,2*f+5,2*f+5);*/
 
 
 
 	i++;
-	nanosleep(&t,NULL);
+	nanosleep(&t, NULL);
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"radius test")) {
-		item1=s3d_import_model_file("objs/cubeyholes.3ds");
-		item2=s3d_import_model_file("objs/folder.3ds");
+	if (!s3d_init(&argc, &argv, "radius test")) {
+		item1 = s3d_import_model_file("objs/cubeyholes.3ds");
+		item2 = s3d_import_model_file("objs/folder.3ds");
 		s3d_select_font("vera");
-		item3=s3d_draw_string("radius test",NULL);
-		s3d_link(item2,item1);
-		s3d_link(item3,item2);
-		s3d_flags_on(item1,S3D_OF_VISIBLE);
-		s3d_flags_on(item2,S3D_OF_VISIBLE);
-		s3d_flags_on(item3,S3D_OF_VISIBLE);
+		item3 = s3d_draw_string("radius test", NULL);
+		s3d_link(item2, item1);
+		s3d_link(item3, item2);
+		s3d_flags_on(item1, S3D_OF_VISIBLE);
+		s3d_flags_on(item2, S3D_OF_VISIBLE);
+		s3d_flags_on(item3, S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/example/s3dclock.c
===================================================================
--- trunk/example/s3dclock.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/s3dclock.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,15 +24,15 @@
 
 #include <s3d.h>
 #include <stdio.h>  /*  NULL, sprintf() */
-#include <time.h>	 /*  nanosleep(), struct tm, time_t...  */
+#include <time.h>  /*  nanosleep(), struct tm, time_t...  */
 #include <string.h>  /*  strlen() */
-static struct timespec t= {
-	0,100*1000*1000
+static struct timespec t = {
+	0, 100*1000*1000
 }; /* 100 mili seconds */
-int big_p,lil_p,bg,sec_p;
-int str_oid=-1, o_str_oid;
+int big_p, lil_p, bg, sec_p;
+int str_oid = -1, o_str_oid;
 struct tm *mytime;
-time_t now,onow;
+time_t now, onow;
 char time_str[256];
 
 void stop(struct s3d_evt *evt)
@@ -42,42 +42,42 @@
 
 void mainloop()
 {
-	onow=now;
-	now=time(NULL);
-	if (now!=onow) {
-		o_str_oid=str_oid;
-		mytime=localtime(&now);
-		s3d_rotate(lil_p,0,0,-((mytime->tm_hour%12)/12.0)*360.0);
-		s3d_rotate(big_p,0,0,-(mytime->tm_min/60.0)*360.0);
-		s3d_rotate(sec_p,0,0,-(mytime->tm_sec/60.0)*360.0);
-		sprintf(time_str,"%02d:%02d:%02d",mytime->tm_hour,mytime->tm_min,mytime->tm_sec);
-		str_oid=s3d_draw_string(time_str,NULL);
-		s3d_translate(str_oid,-1,-1.3,0);
-		s3d_scale(str_oid,0.5);
-		s3d_flags_on(str_oid,S3D_OF_VISIBLE);
-		if (str_oid!=-1)
+	onow = now;
+	now = time(NULL);
+	if (now != onow) {
+		o_str_oid = str_oid;
+		mytime = localtime(&now);
+		s3d_rotate(lil_p, 0, 0, -((mytime->tm_hour % 12) / 12.0)*360.0);
+		s3d_rotate(big_p, 0, 0, -(mytime->tm_min / 60.0)*360.0);
+		s3d_rotate(sec_p, 0, 0, -(mytime->tm_sec / 60.0)*360.0);
+		sprintf(time_str, "%02d:%02d:%02d", mytime->tm_hour, mytime->tm_min, mytime->tm_sec);
+		str_oid = s3d_draw_string(time_str, NULL);
+		s3d_translate(str_oid, -1, -1.3, 0);
+		s3d_scale(str_oid, 0.5);
+		s3d_flags_on(str_oid, S3D_OF_VISIBLE);
+		if (str_oid != -1)
 			s3d_del_object(o_str_oid);
 	}
-	/* 	printf("now it's %s\n",time_str); */
-	nanosleep(&t,NULL);
+	/*  printf("now it's %s\n",time_str); */
+	nanosleep(&t, NULL);
 
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"clock")) {
-		lil_p=s3d_import_model_file("objs/lil_p.3ds");
-		big_p=s3d_import_model_file("objs/big_p.3ds");
-		sec_p=s3d_import_model_file("objs/sec_p.3ds");
-		bg=s3d_import_model_file("objs/clock_bg.3ds");
+	if (!s3d_init(&argc, &argv, "clock")) {
+		lil_p = s3d_import_model_file("objs/lil_p.3ds");
+		big_p = s3d_import_model_file("objs/big_p.3ds");
+		sec_p = s3d_import_model_file("objs/sec_p.3ds");
+		bg = s3d_import_model_file("objs/clock_bg.3ds");
 
-		s3d_flags_on(big_p,S3D_OF_VISIBLE);
-		s3d_flags_on(lil_p,S3D_OF_VISIBLE);
-		s3d_flags_on(sec_p,S3D_OF_VISIBLE);
-		s3d_flags_on(bg,S3D_OF_VISIBLE);
+		s3d_flags_on(big_p, S3D_OF_VISIBLE);
+		s3d_flags_on(lil_p, S3D_OF_VISIBLE);
+		s3d_flags_on(sec_p, S3D_OF_VISIBLE);
+		s3d_flags_on(bg, S3D_OF_VISIBLE);
 		s3d_select_font("vera");
 
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, (s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_QUIT, (s3d_cb)stop);
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/example/snowman.c
===================================================================
--- trunk/example/snowman.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/snowman.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,10 +22,10 @@
  */
 
 #include <s3d.h>
-#include <math.h>	/* sin() */
-#include <time.h>	/* nanosleep() */
-static struct timespec t= {
-	0,10*1000*1000
+#include <math.h> /* sin() */
+#include <time.h> /* nanosleep() */
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 
 int a;
@@ -36,38 +36,38 @@
 void mainloop()
 {
 	float pos;
-	a=(a+3)%360;
-	pos=sin((a*M_PI)/180)*5;
-	if (pos<0) pos*=-1;
-	s3d_rotate(oid_head,0,a,0);
-	s3d_rotate(oid_middle,0,a,0);
-	s3d_rotate(oid_foot,0,a,0);
-	s3d_translate(oid_head,		0,1.5 +2.00*pos,0);
-	s3d_translate(oid_middle,	0,0   +1.25*pos,0);
-	s3d_translate(oid_foot,		0,-2  +1.00*pos,0);
-	nanosleep(&t,NULL);
+	a = (a + 3) % 360;
+	pos = sin((a * M_PI) / 180) * 5;
+	if (pos < 0) pos *= -1;
+	s3d_rotate(oid_head, 0, a, 0);
+	s3d_rotate(oid_middle, 0, a, 0);
+	s3d_rotate(oid_foot, 0, a, 0);
+	s3d_translate(oid_head,  0, 1.5 + 2.00*pos, 0);
+	s3d_translate(oid_middle, 0, 0   + 1.25*pos, 0);
+	s3d_translate(oid_foot,  0, -2  + 1.00*pos, 0);
+	nanosleep(&t, NULL);
 }
 int main(int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"snowman")) {
+	if (!s3d_init(&argc, &argv, "snowman")) {
 
-		oid_head=s3d_import_model_file("objs/snow_head.3ds");
-		oid_middle=s3d_import_model_file("objs/snow_body.3ds");
-		oid_foot=s3d_import_model_file("objs/snow_foot.3ds");
+		oid_head = s3d_import_model_file("objs/snow_head.3ds");
+		oid_middle = s3d_import_model_file("objs/snow_body.3ds");
+		oid_foot = s3d_import_model_file("objs/snow_foot.3ds");
 
-		/*		s3d_link(oid_foot,oid_head);
-		 *		s3d_link(oid_middle,oid_head);
-		 *		s3d_translate(oid_head,0,4,0);
+		/*  s3d_link(oid_foot,oid_head);
+		 *  s3d_link(oid_middle,oid_head);
+		 *  s3d_translate(oid_head,0,4,0);
 
-		 *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
-		 *		s3d_translate(oid_foot,0,-3.5,0); */
+		 *  s3d_translate(oid_middle,0,-1.5,0);  * relative to head: *
+		 *  s3d_translate(oid_foot,0,-3.5,0); */
 
-		s3d_scale(oid_middle,1.25);
-		s3d_scale(oid_foot,1.5);
+		s3d_scale(oid_middle, 1.25);
+		s3d_scale(oid_foot, 1.5);
 
-		s3d_flags_on(oid_head,S3D_OF_VISIBLE);
-		s3d_flags_on(oid_middle,S3D_OF_VISIBLE);
-		s3d_flags_on(oid_foot,S3D_OF_VISIBLE);
+		s3d_flags_on(oid_head, S3D_OF_VISIBLE);
+		s3d_flags_on(oid_middle, S3D_OF_VISIBLE);
+		s3d_flags_on(oid_foot, S3D_OF_VISIBLE);
 		s3d_mainloop(mainloop);
 		s3d_quit();
 	}

Modified: trunk/example/strtest.c
===================================================================
--- trunk/example/strtest.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/strtest.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -34,25 +34,25 @@
 
 void mainloop()
 {
-	/* 	printf("now it's %s\n",time_str); */
+	/*  printf("now it's %s\n",time_str); */
 	sleep(1);
 
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
 	char c[256];
 	int i;
-	if (!s3d_init(&argc,&argv,"strtest")) {
+	if (!s3d_init(&argc, &argv, "strtest")) {
 		s3d_select_font("vera");
-		/*		o=s3d_draw_string("The lazy fox is bored enough to jump over everything it sees. weird, isn't it?!",NULL);  */
-		for (i=0;i<256;i++)
-			c[255-i]=i;
-		o=s3d_draw_string(c,NULL);
-		/*		o=s3d_draw_string("A",NULL);*/
-		s3d_flags_on(o,S3D_OF_VISIBLE);
+		/*  o=s3d_draw_string("The lazy fox is bored enough to jump over everything it sees. weird, isn't it?!",NULL);  */
+		for (i = 0;i < 256;i++)
+			c[255-i] = i;
+		o = s3d_draw_string(c, NULL);
+		/*  o=s3d_draw_string("A",NULL);*/
+		s3d_flags_on(o, S3D_OF_VISIBLE);
 
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, (s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_QUIT, (s3d_cb)stop);
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/example/texturetest.c
===================================================================
--- trunk/example/texturetest.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/texturetest.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,59 +25,59 @@
 #include <s3d.h>
 #include <stdio.h>  /*  NULL */
 #include <stdlib.h>  /* malloc(),free() */
-#include <time.h>	/* nanosleep() */
-static struct timespec t= {
-	0,10*1000*1000
+#include <time.h> /* nanosleep() */
+static struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 
-int i,oid;
+int i, oid;
 void mainloop()
 {
-	i=(i+1)%360;
-	s3d_rotate(oid,0,i,0);
-	nanosleep(&t,NULL);
+	i = (i + 1) % 360;
+	s3d_rotate(oid, 0, i, 0);
+	nanosleep(&t, NULL);
 }
-#define MAXX	300
-#define MAXY	300
-int main (int argc, char **argv)
+#define MAXX 300
+#define MAXY 300
+int main(int argc, char **argv)
 {
-	unsigned int x,y;
+	unsigned int x, y;
 	unsigned char *data;
 
-	if (!s3d_init(&argc,&argv,"texturetest")) {
-		data=malloc(MAXX*MAXY*4);
-		oid=s3d_new_object();
-		s3d_push_vertex(oid,-1,-1,0);
-		s3d_push_vertex(oid, 1,-1,0);
-		s3d_push_vertex(oid, 1, 1,0);
-		s3d_push_vertex(oid,-1, 1,0);
+	if (!s3d_init(&argc, &argv, "texturetest")) {
+		data = malloc(MAXX * MAXY * 4);
+		oid = s3d_new_object();
+		s3d_push_vertex(oid, -1, -1, 0);
+		s3d_push_vertex(oid, 1, -1, 0);
+		s3d_push_vertex(oid, 1, 1, 0);
+		s3d_push_vertex(oid, -1, 1, 0);
 		s3d_push_material_a(oid,
-		                    0.8,	0.0,	0.0	,1.0,
-		                    1.0,	1.0,	1.0	,1.0,
-		                    0.8,	0.0,	0.0	,1.0);
-		s3d_push_polygon(oid,0,1,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0,
-		                          1.0,0.0,
-		                          1.0,1.0);
-		s3d_push_polygon(oid,0,2,3,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0,
-		                          1.0,1.0,
-		                          0.0,1.0);
-		s3d_translate(oid,0,0,5);
-		for (y=0;y<MAXY;y++)
-			for (x=0;x<MAXX;x++) {
-				data[(y*MAXX+x)*4+0]=(char)((x*255)/MAXX);
-				data[(y*MAXX+x)*4+1]=((x*y)/(MAXX*MAXY));
-				data[(y*MAXX+x)*4+2]=((y*255)/MAXX);
-				data[(y*MAXX+x)*4+3]=255;
+		                    0.8, 0.0, 0.0 , 1.0,
+		                    1.0, 1.0, 1.0 , 1.0,
+		                    0.8, 0.0, 0.0 , 1.0);
+		s3d_push_polygon(oid, 0, 1, 2, 0);
+		s3d_pep_polygon_tex_coord(oid, 0.0, 0.0,
+		                          1.0, 0.0,
+		                          1.0, 1.0);
+		s3d_push_polygon(oid, 0, 2, 3, 0);
+		s3d_pep_polygon_tex_coord(oid, 0.0, 0.0,
+		                          1.0, 1.0,
+		                          0.0, 1.0);
+		s3d_translate(oid, 0, 0, 5);
+		for (y = 0;y < MAXY;y++)
+			for (x = 0;x < MAXX;x++) {
+				data[(y*MAXX+x)*4+0] = (char)((x * 255) / MAXX);
+				data[(y*MAXX+x)*4+1] = ((x * y) / (MAXX * MAXY));
+				data[(y*MAXX+x)*4+2] = ((y * 255) / MAXX);
+				data[(y*MAXX+x)*4+3] = 255;
 			}
-		s3d_push_texture(oid,MAXX,MAXY);
-		s3d_load_texture(oid,0,0,0,MAXX,MAXY,data);
+		s3d_push_texture(oid, MAXX, MAXY);
+		s3d_load_texture(oid, 0, 0, 0, MAXX, MAXY, data);
 		/*  push data on texture 0 position (0,0) */
 		free(data);
-		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
-		s3d_flags_on(oid,S3D_OF_VISIBLE);
-		i=0;
+		s3d_pep_material_texture(oid, 0); /*  assign texture 0 to material 0 */
+		s3d_flags_on(oid, S3D_OF_VISIBLE);
+		i = 0;
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/example/widgets.c
===================================================================
--- trunk/example/widgets.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/widgets.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -27,20 +27,20 @@
 #include <s3d.h>
 #include <s3dw.h>
 #include <stdio.h>  /* NULL */
-#include <time.h>	/* nanosleep() */
-#include <stdlib.h>	/* free() */
+#include <time.h> /* nanosleep() */
+#include <stdlib.h> /* free() */
 #include <string.h> /* strlen() */
 
 s3dw_surface *surface;
 s3dw_input *input;
-static struct timespec t= {
-	0,33*1000*1000
+static struct timespec t = {
+	0, 33*1000*1000
 }; /* 33 mili seconds */
 void mainloop()
 {
 	/* keep this in your mainloop. this will do smooth animations for you ... */
 	s3dw_ani_mate();
-	nanosleep(&t,NULL);
+	nanosleep(&t, NULL);
 }
 /* you should always put the s3dw-handler in your own event handler,
  * if you want s3dw to react on clicks or keys ... and i'm sure you
@@ -55,7 +55,7 @@
 }
 int key(struct s3d_evt *evt)
 {
-	struct s3d_key_event *key=(struct s3d_key_event *)evt->buf;
+	struct s3d_key_event *key = (struct s3d_key_event *)evt->buf;
 	char string[8];
 	s3dw_surface *miniwin;
 	s3dw_button  *button;
@@ -64,13 +64,13 @@
 	/* okay, that's a little bit insane ... ;)
 	 * we create some little windows with the actual key pressed. */
 
-	if (key->unicode!=0) {
-		miniwin=s3dw_surface_new("Key",6,6);
-		sprintf(string,"%c",key->unicode);
-		s3dw_label_new(miniwin,string,1,2);
-		button=s3dw_button_new(miniwin,"OK",2,4);
+	if (key->unicode != 0) {
+		miniwin = s3dw_surface_new("Key", 6, 6);
+		sprintf(string, "%c", key->unicode);
+		s3dw_label_new(miniwin, string, 1, 2);
+		button = s3dw_button_new(miniwin, "OK", 2, 4);
 		/* clicking on the button will exit ... */
-		button->onclick=key_button;
+		button->onclick = key_button;
 		/* of couse, show it */
 		s3dw_show(S3DWIDGET(miniwin));
 	}
@@ -90,24 +90,24 @@
 	char *age;
 
 	/* get the input of the text ... before its destroyed, of course*/
-	age=s3dw_input_gettext(input);
+	age = s3dw_input_gettext(input);
 
 	/* delete the old surface with it subwidgets */
 	s3dw_delete(S3DWIDGET(surface));
 
 	/* and create a new one ... */
-	surface=s3dw_surface_new("Ah!",10,7);
+	surface = s3dw_surface_new("Ah!", 10, 7);
 
 	/* just cutting the string if it's too long */
-	if (strlen(age)>8) age[8]=0;
+	if (strlen(age) > 8) age[8] = 0;
 
 	/* assemble the string ..*/
-	sprintf(string,"I see, %s!!",age);
+	sprintf(string, "I see, %s!!", age);
 
-	s3dw_label_new(surface,string,1,2);
-	button=s3dw_button_new(surface,"Great",4,4);
+	s3dw_label_new(surface, string, 1, 2);
+	button = s3dw_button_new(surface, "Great", 4, 4);
 	/* clicking on the button will exit ... */
-	button->onclick=done_button;
+	button->onclick = done_button;
 
 	/* of couse, show it */
 	s3dw_show(S3DWIDGET(surface));
@@ -119,50 +119,50 @@
 {
 	s3dw_button *button;
 	s3dw_delete(S3DWIDGET(surface));
-	surface=s3dw_surface_new("Well ...",10,7);
-	s3dw_label_new(surface,"If you don't want to tell me ...",1,2);
-	button=s3dw_button_new(surface,"Bye",4,4);
+	surface = s3dw_surface_new("Well ...", 10, 7);
+	s3dw_label_new(surface, "If you don't want to tell me ...", 1, 2);
+	button = s3dw_button_new(surface, "Bye", 4, 4);
 	/* clicking on the button will exit ... */
 
-	button->onclick=done_button;
+	button->onclick = done_button;
 	/* of couse, show it */
 
 	s3dw_show(S3DWIDGET(surface));
 }
-char *text="okay\nn2\n3\nfooobarfooobar ...\noh no\n its too loooong\n";
-int main (int argc, char **argv)
+char *text = "okay\nn2\n3\nfooobarfooobar ...\noh no\n its too loooong\n";
+int main(int argc, char **argv)
 {
 	s3dw_button *button;
 	s3dw_textbox *textbox;
-	if (!s3d_init(&argc,&argv,"widgettest")) {
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,click);
-		s3d_set_callback(S3D_EVENT_KEY,key);
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,s3dw_object_info);
+	if (!s3d_init(&argc, &argv, "widgettest")) {
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, click);
+		s3d_set_callback(S3D_EVENT_KEY, key);
+		s3d_set_callback(S3D_EVENT_OBJ_INFO, s3dw_object_info);
 		/* this creates the "window" */
-		surface=s3dw_surface_new("Hello World",20,20);
+		surface = s3dw_surface_new("Hello World", 20, 20);
 
 		/* put a label (which is simply text) at position x=1, y=2 */
-		s3dw_label_new(surface,"How old are you?",1,2);
+		s3dw_label_new(surface, "How old are you?", 1, 2);
 
 		/* put an input box right below. we grab the pointer because we want to focus it (need for reference) */
-		input=s3dw_input_new(surface,8,1,4);
+		input = s3dw_input_new(surface, 8, 1, 4);
 
 		/* we want the input-field be focused on our widget */
 		s3dw_focus(S3DWIDGET(input));
 
 		/* create the okay button */
-		button=s3dw_button_new(surface,"OK",1,7);
+		button = s3dw_button_new(surface, "OK", 1, 7);
 
 		/* define the callback when the button is clicked. in our case, okay_button() will handle the event */
-		button->onclick=okay_button;
+		button->onclick = okay_button;
 
 		/* another button  */
-		button=s3dw_button_new(surface,"Won't tell you",10,7);
+		button = s3dw_button_new(surface, "Won't tell you", 10, 7);
 
 		/* we will tell him how sad we are ... */
-		button->onclick=no_button;
+		button->onclick = no_button;
 		/* create some textbox at (1,10) widh width 18 and height 8 */
-		textbox=s3dw_textbox_new(surface,text,1,10,18,8);
+		textbox = s3dw_textbox_new(surface, text, 1, 10, 18, 8);
 
 		/* this widget is focused (of course, it's our only one ... */
 		s3dw_focus(S3DWIDGET(surface));

Modified: trunk/example/wiresphere.c
===================================================================
--- trunk/example/wiresphere.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/example/wiresphere.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,75 +24,75 @@
 
 #include <s3d.h>
 #include <stdio.h>  /* NULL, sprintf() */
-#include <time.h>	/* nanosleep()  */
-#include <math.h>	/* M_PI, cos(), sin() */
-#include <stdlib.h>	/* malloc(), free() */
-static struct timespec t= {
-	0,100*1000*1000
+#include <time.h> /* nanosleep()  */
+#include <math.h> /* M_PI, cos(), sin() */
+#include <stdlib.h> /* malloc(), free() */
+static struct timespec t = {
+	0, 100*1000*1000
 }; /* 100 mili seconds */
 int oid;
 int r;
 int wire_sphere(int slices, int stacks)
 {
-	int x,y,i,o;
-	int num_v,num_l;
-	float *v,*n;			/* vertices, normals */
+	int x, y, i, o;
+	int num_v, num_l;
+	float *v, *n;  /* vertices, normals */
 	float alpha, beta;
-	unsigned int *l;	/* lines */
-	num_v=(stacks+1) * slices;
-	num_l=stacks * slices+ (stacks-1) * slices; /* vertical + horizontal */
-	v=malloc(sizeof(float) * 3 * num_v);
-	n=malloc(sizeof(float) * 6 * num_l);
-	l=malloc(sizeof(unsigned int) * 3 * num_l);
-	i=0;
-	for (x=0;x<slices;x++) {
-		alpha=(x*360.0/slices)*M_PI/180.0;
-		for (y=0;y<(stacks+1);y++) {
-			beta=((y*180/slices)-90.0)*M_PI/180.0;
-			v[i*3+0]=cos(alpha) * cos(beta);
-			v[i*3+1]=sin(beta);
-			v[i*3+2]=sin(alpha) * cos(beta);
+	unsigned int *l; /* lines */
+	num_v = (stacks + 1) * slices;
+	num_l = stacks * slices + (stacks - 1) * slices; /* vertical + horizontal */
+	v = malloc(sizeof(float) * 3 * num_v);
+	n = malloc(sizeof(float) * 6 * num_l);
+	l = malloc(sizeof(unsigned int) * 3 * num_l);
+	i = 0;
+	for (x = 0;x < slices;x++) {
+		alpha = (x * 360.0 / slices) * M_PI / 180.0;
+		for (y = 0;y < (stacks + 1);y++) {
+			beta = ((y * 180 / slices) - 90.0) * M_PI / 180.0;
+			v[i*3+0] = cos(alpha) * cos(beta);
+			v[i*3+1] = sin(beta);
+			v[i*3+2] = sin(alpha) * cos(beta);
 			i++;
 		}
 	}
-	i=0;
-	for (x=0;x<slices;x++) {
-		for (y=0;y<stacks;y++) {
-			if ((y!=0) && (y!=stacks)) { /* no horizontal lines at the poles */
-				l[i*3+0]=(x*(stacks+1))+y;
-				l[i*3+1]=(((x+1)%slices)*(stacks+1))+y;
-				l[i*3+2]=0;
-				n[i*6+0]=v[ l[i*3+0]*3 + 0];
-				n[i*6+1]=v[ l[i*3+0]*3 + 1];
-				n[i*6+2]=v[ l[i*3+0]*3 + 2];
-				n[i*6+3]=v[ l[i*3+1]*3 + 0];
-				n[i*6+4]=v[ l[i*3+1]*3 + 1];
-				n[i*6+5]=v[ l[i*3+1]*3 + 2];
+	i = 0;
+	for (x = 0;x < slices;x++) {
+		for (y = 0;y < stacks;y++) {
+			if ((y != 0) && (y != stacks)) { /* no horizontal lines at the poles */
+				l[i*3+0] = (x * (stacks + 1)) + y;
+				l[i*3+1] = (((x + 1) % slices) * (stacks + 1)) + y;
+				l[i*3+2] = 0;
+				n[i*6+0] = v[ l[i*3+0] * 3 + 0];
+				n[i*6+1] = v[ l[i*3+0] * 3 + 1];
+				n[i*6+2] = v[ l[i*3+0] * 3 + 2];
+				n[i*6+3] = v[ l[i*3+1] * 3 + 0];
+				n[i*6+4] = v[ l[i*3+1] * 3 + 1];
+				n[i*6+5] = v[ l[i*3+1] * 3 + 2];
 
 				i++;
 
 			}
 			/* vertical lines */
-			l[i*3+0]=(x*(stacks+1))+y;
-			l[i*3+1]=(x*(stacks+1))+y+1;
-			l[i*3+2]=0;
-			n[i*6+0]=v[ l[i*3+0]*3 + 0];
-			n[i*6+1]=v[ l[i*3+0]*3 + 1];
-			n[i*6+2]=v[ l[i*3+0]*3 + 2];
-			n[i*6+3]=v[ l[i*3+1]*3 + 0];
-			n[i*6+4]=v[ l[i*3+1]*3 + 1];
-			n[i*6+5]=v[ l[i*3+1]*3 + 2];
+			l[i*3+0] = (x * (stacks + 1)) + y;
+			l[i*3+1] = (x * (stacks + 1)) + y + 1;
+			l[i*3+2] = 0;
+			n[i*6+0] = v[ l[i*3+0] * 3 + 0];
+			n[i*6+1] = v[ l[i*3+0] * 3 + 1];
+			n[i*6+2] = v[ l[i*3+0] * 3 + 2];
+			n[i*6+3] = v[ l[i*3+1] * 3 + 0];
+			n[i*6+4] = v[ l[i*3+1] * 3 + 1];
+			n[i*6+5] = v[ l[i*3+1] * 3 + 2];
 			i++;
 
 		}
 	}
-	o=s3d_new_object();
-	s3d_push_material(o,0,0,1,
-	                  1,0,0,
-	                  0,1,0);
-	s3d_push_vertices(o,v,num_v);
-	s3d_push_lines(o,l,num_l);
-	s3d_load_line_normals(o,n,0,num_l);
+	o = s3d_new_object();
+	s3d_push_material(o, 0, 0, 1,
+	                  1, 0, 0,
+	                  0, 1, 0);
+	s3d_push_vertices(o, v, num_v);
+	s3d_push_lines(o, l, num_l);
+	s3d_load_line_normals(o, n, 0, num_l);
 	free(v);
 	free(n);
 	free(l);
@@ -105,19 +105,19 @@
 
 void mainloop()
 {
-	r=(r+1)%360;
-	s3d_rotate(oid,0,r,0);
-	nanosleep(&t,NULL);
+	r = (r + 1) % 360;
+	s3d_rotate(oid, 0, r, 0);
+	nanosleep(&t, NULL);
 
 }
-int main (int argc, char **argv)
+int main(int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"wiresphere")) {
-		oid=wire_sphere(30,30);
-		s3d_scale(oid,10);
-		s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
+	if (!s3d_init(&argc, &argv, "wiresphere")) {
+		oid = wire_sphere(30, 30);
+		s3d_scale(oid, 10);
+		s3d_flags_on(oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK, (s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_QUIT, (s3d_cb)stop);
 		s3d_mainloop(mainloop);
 		/*  wait for some object to be clicked */
 		s3d_quit();

Modified: trunk/libs3d/callback.c
===================================================================
--- trunk/libs3d/callback.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/callback.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -28,26 +28,26 @@
 /*  the s3d callback list */
 /* i know it's ugly, but it's better to have ugly code somewhere than provoke
  * race conditions in the applications code */
-s3d_cb s3d_cb_list[MAX_CB]={
-	NULL,_s3d_ignore,_s3d_ignore,_s3d_ignore, _s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	_s3d_ignore,_s3d_ignore,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	_s3d_ignore,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+s3d_cb s3d_cb_list[MAX_CB] = {
+	NULL, _s3d_ignore, _s3d_ignore, _s3d_ignore, _s3d_ignore, _s3d_ignore, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	_s3d_ignore, _s3d_ignore, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	_s3d_ignore, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,
-	NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
 };
 /* the ignore-handler ;) */
 static int _s3d_ignore(struct s3d_evt *S3DUNUSED(evt))
@@ -58,18 +58,18 @@
 /*  sets a callback */
 void s3d_set_callback(uint8_t event, s3d_cb func)
 {
-	s3d_cb_list[(int)event]=func;
+	s3d_cb_list[(int)event] = func;
 	s3d_process_stack();
 }
 /*  clears a callback, same as s3d_set_callback(event, (s3d_cb) NULL); */
 void s3d_clear_callback(uint8_t event)
 {
-	s3d_cb_list[(int)event]=NULL;
+	s3d_cb_list[(int)event] = NULL;
 }
 /* ignores an event ... */
 void s3d_ignore_callback(uint8_t event)
 {
-	s3d_set_callback(event,_s3d_ignore);
+	s3d_set_callback(event, _s3d_ignore);
 }
 s3d_cb s3d_get_callback(uint8_t event)
 {

Modified: trunk/libs3d/config.h
===================================================================
--- trunk/libs3d/config.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/config.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -29,6 +29,6 @@
 
 #define WITH_FONTCONFIG
 /*  our level of debug messages */
-/* #define DEBUG			LOW */ 	/*  standard debug level, should be set with compiler, e.g. -DDEBUG=LOW */
-#define SHM_MAX_IDLE	200	/* maximum wait for server timeout */
-#define	SEI_SS			200	/* seidel algorithm maximum point number */
+/* #define DEBUG   LOW */  /*  standard debug level, should be set with compiler, e.g. -DDEBUG=LOW */
+#define SHM_MAX_IDLE 200 /* maximum wait for server timeout */
+#define SEI_SS   200 /* seidel algorithm maximum point number */

Modified: trunk/libs3d/error.c
===================================================================
--- trunk/libs3d/error.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/error.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,49 +24,49 @@
 
 #include "s3d.h"
 #include "s3dlib.h"
-#include <stdarg.h>		 /*  va_list */
-#include <stdio.h> 		 /*  perror(),fprintf() */
-#include <string.h> 	 /*  sterror */
+#include <stdarg.h>   /*  va_list */
+#include <stdio.h>    /*  perror(),fprintf() */
+#include <string.h>   /*  sterror */
 /*  s3dprintf is only for internal use. */
 #ifdef DEBUG
 void s3dprintf(int relevance, const char *fmt, ...)
 {
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance >= DEBUG ) {
-		va_start(args,fmt);
-		vsnprintf((char *)&dbm,DBM_MAX,fmt,args);
+	if (relevance >= DEBUG) {
+		va_start(args, fmt);
+		vsnprintf((char *)&dbm, DBM_MAX, fmt, args);
 		va_end(args);
 
-		fprintf(stderr,"s3dlib: %s\n",(char *)&dbm);
+		fprintf(stderr, "s3dlib: %s\n", (char *)&dbm);
 	}
 }
-void errdn(int relevance, char *func,int en)
+void errdn(int relevance, char *func, int en)
 {
-	if (relevance >= DEBUG )
-		fprintf(stderr,"s3dlib error: %s: (%d) %s\n",func,en, strerror(en));
+	if (relevance >= DEBUG)
+		fprintf(stderr, "s3dlib error: %s: (%d) %s\n", func, en, strerror(en));
 }
 
-void errds(int relevance,char *func, const char *fmt, ...)
+void errds(int relevance, char *func, const char *fmt, ...)
 {
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance >= DEBUG ) {
-		va_start(args,fmt);
-		vsnprintf((char *)&dbm,DBM_MAX,fmt,args);
+	if (relevance >= DEBUG) {
+		va_start(args, fmt);
+		vsnprintf((char *)&dbm, DBM_MAX, fmt, args);
 		va_end(args);
 
-		fprintf(stderr,"s3dlib error: %s:%s\n",func,(char *)&dbm);
+		fprintf(stderr, "s3dlib error: %s:%s\n", func, (char *)&dbm);
 	}
 }
 #endif
-void errn(char *func,int en)
+void errn(char *func, int en)
 {
-	fprintf(stderr,"s3dlib error: %s: (%d) %s\n",func,en, strerror(en));
+	fprintf(stderr, "s3dlib error: %s: (%d) %s\n", func, en, strerror(en));
 }
 void errs(char *func, char *msg)
 {
-	fprintf(stderr,"s3dlib error: %s: %s\n",func,msg);
+	fprintf(stderr, "s3dlib error: %s: %s\n", func, msg);
 }
 
 

Modified: trunk/libs3d/event.c
===================================================================
--- trunk/libs3d/event.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/event.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,71 +25,71 @@
 #include "s3d.h"
 #include "s3dlib.h"
 #include "proto.h"
-#include <stdlib.h>		 /*  malloc(), free() */
+#include <stdlib.h>   /*  malloc(), free() */
 
 struct s3d_evt *s3d_stack;
-int cb_lock=2;	 /*  callback lock */
+int cb_lock = 2;  /*  callback lock */
 void s3d_push_event(struct s3d_evt *newevt)
 {
 	struct s3d_evt *p;
 	s3d_cb cb;
 
-	s3dprintf(VLOW,"pushed event %d, cb_lock = %d",newevt->event, cb_lock);
+	s3dprintf(VLOW, "pushed event %d, cb_lock = %d", newevt->event, cb_lock);
 	/*  this will always be called for S3D_EVENT_NEW_OBJECT!! */
-	if (newevt->event==S3D_EVENT_NEW_OBJECT) {
+	if (newevt->event == S3D_EVENT_NEW_OBJECT) {
 		_queue_new_object(*((unsigned int *)newevt->buf));
 	}
-	if (cb_lock==0) { /*  no recursive event-callbacks, please! */
-		if (NULL!=(cb=s3d_get_callback(newevt->event))) {
-			cb_lock++;		 /*  on our way! lock it.. */
-			cb(newevt);		 /*  .. and call it! */
+	if (cb_lock == 0) { /*  no recursive event-callbacks, please! */
+		if (NULL != (cb = s3d_get_callback(newevt->event))) {
+			cb_lock++;   /*  on our way! lock it.. */
+			cb(newevt);   /*  .. and call it! */
 			cb_lock--;
 			/* okay, no new callbacks, unlock now. */
 			free(newevt);
 			return;
 		}
 	}
-	newevt->next=NULL;
-	if (s3d_stack!=NULL) {
-		for (p=s3d_stack;p->next!=NULL;p=p->next);  /*  go to the end */
-		p->next=newevt;
+	newevt->next = NULL;
+	if (s3d_stack != NULL) {
+		for (p = s3d_stack;p->next != NULL;p = p->next);  /*  go to the end */
+		p->next = newevt;
 	} else
-		s3d_stack=newevt;
+		s3d_stack = newevt;
 }
 struct s3d_evt *s3d_pop_event() {
 	struct s3d_evt *ret;
-	if ((ret=s3d_stack)!=NULL)
-		s3d_stack=s3d_stack->next;
+	if ((ret = s3d_stack) != NULL)
+		s3d_stack = s3d_stack->next;
 	return ret;
 }
 struct s3d_evt *s3d_find_event(uint8_t event) {
 	struct s3d_evt *p;
-	p=s3d_stack;
-	while (p!=NULL) {
-		if (p->event==event)
+	p = s3d_stack;
+	while (p != NULL) {
+		if (p->event == event)
 			return(p);
-		p=p->next;
+		p = p->next;
 	}
 	return(NULL);
 }
 int s3d_delete_event(struct s3d_evt *devt)
 {
-	struct s3d_evt *previous=NULL;
-	struct s3d_evt *p=s3d_stack;
-	while (p!=NULL) {
+	struct s3d_evt *previous = NULL;
+	struct s3d_evt *p = s3d_stack;
+	while (p != NULL) {
 		/* if ((p->event==devt->event) && (p->length==devt->length)) */
-		/* 	if (0==memcmp(p->buf,devt->buf)) */
-		if (p==devt) {
-			if (p->length>0)
+		/*  if (0==memcmp(p->buf,devt->buf)) */
+		if (p == devt) {
+			if (p->length > 0)
 				free(p->buf);
-			if (previous==NULL)
-				s3d_stack=p->next;  /*  the first element!! */
+			if (previous == NULL)
+				s3d_stack = p->next;  /*  the first element!! */
 			else
-				previous->next=p->next;  /*  unlink */
+				previous->next = p->next;  /*  unlink */
 			free(p);
 		}
-		previous=p;
-		p=p->next;
+		previous = p;
+		p = p->next;
 	}
 	return(-1);
 }
@@ -98,14 +98,14 @@
 {
 	struct s3d_evt *p;
 	s3d_cb cb;
-	if (cb_lock>0) { /* can't do that now. */
+	if (cb_lock > 0) { /* can't do that now. */
 
-		s3dprintf(VLOW,"cb_lock = %d, processing later",cb_lock);
+		s3dprintf(VLOW, "cb_lock = %d, processing later", cb_lock);
 		return;
 	}
-	s3dprintf(VLOW,"processing stack ...");
-	while (NULL!=(p=s3d_pop_event())) {
-		if ((cb=s3d_get_callback(p->event))!=NULL) {
+	s3dprintf(VLOW, "processing stack ...");
+	while (NULL != (p = s3d_pop_event())) {
+		if ((cb = s3d_get_callback(p->event)) != NULL) {
 			cb_lock++;
 			cb(p);
 			cb_lock--;
@@ -114,7 +114,7 @@
 
 		}
 		/*  free */
-		if (p->length>0)
+		if (p->length > 0)
 			free(p->buf);
 		free(p);
 	}

Modified: trunk/libs3d/fontselect.c
===================================================================
--- trunk/libs3d/fontselect.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/fontselect.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -27,7 +27,7 @@
 /*  version would be nice too, to be implemented :) */
 #include "s3d.h"
 #include "s3dlib.h"
-#include <dirent.h> 	 /*  dirent */
+#include <dirent.h>   /*  dirent */
 #include <X11/Xlib.h>  /*  Display type, XOpenDisplay(), XCloseDIsplay etc. */
 #ifdef WITH_FONTCONFIG
 #include "ft2build.h"
@@ -46,13 +46,13 @@
 	FcResult result;
 
 	pattern = FcNameParse((FcChar8 *)mask);
-	FcConfigSubstitute(0,pattern,FcMatchPattern);
+	FcConfigSubstitute(0, pattern, FcMatchPattern);
 	FcDefaultSubstitute(pattern);
-	s3dprintf(LOW,"Looking for font %s",mask);
+	s3dprintf(LOW, "Looking for font %s", mask);
 
-	if (!(match=FcFontMatch(0,pattern,&result)))
+	if (!(match = FcFontMatch(0, pattern, &result)))
 		return NULL;
-	if (FcPatternGetString(match,FC_FILE,0,&file)!=FcResultMatch)
+	if (FcPatternGetString(match, FC_FILE, 0, &file) != FcResultMatch)
 		return NULL;
 	return (char *)file;
 }
@@ -64,36 +64,36 @@
 {
 	char **flist = NULL;
 	int fnum = 0;
-	char *disp=NULL;
+	char *disp = NULL;
 	int n;
 	char *fname;
-	char *good=NULL;
+	char *good = NULL;
 	struct dirent **namelist;
 	Display *dpy;
 
 	dpy = XOpenDisplay(disp);  /*  Open display and check for success */
 	if (dpy == NULL)
-		errds(VHIGH, "s3d_findfont()","unable to open display %s", XDisplayName (disp));
+		errds(VHIGH, "s3d_findfont()", "unable to open display %s", XDisplayName(disp));
 	else {
-		if (!(flist = XGetFontPath (dpy, &fnum))) {
-			errds(VHIGH, "s3d_findfont():XGetFontPath()","unable to get font path.");
+		if (!(flist = XGetFontPath(dpy, &fnum))) {
+			errds(VHIGH, "s3d_findfont():XGetFontPath()", "unable to get font path.");
 		} else
 			while (fnum--) {
-				/*  now scan the directories	 */
+				/*  now scan the directories  */
 				n =  scandir(flist[fnum], &namelist, 0, alphasort);
-				while (n-->0) {
-					fname=namelist[n]->d_name;
-					if (strlen(fname)>(strlen(mask)+3)) { /*  there should be enough space for the .ttf ending */
+				while (n-- > 0) {
+					fname = namelist[n]->d_name;
+					if (strlen(fname) > (strlen(mask) + 3)) { /*  there should be enough space for the .ttf ending */
 						/*  check for the first n characters */
-						if (0==strncasecmp(fname,mask,strlen(mask))) {
+						if (0 == strncasecmp(fname, mask, strlen(mask))) {
 							/*  name matches! now check for the end... */
-							if (0==strncasecmp(fname+(strlen(fname)-3),"ttf",3)) { /*  check if it has a ttf-ending */
-								if (good==NULL)
-									good=malloc(256);
-								strncpy(good,flist[fnum],255);
-								good[256]=0; 									/* just in case */
-								strncat(good,fname,255-strlen(good));
-								if ((strlen(mask)+4)==strlen(fname)) {
+							if (0 == strncasecmp(fname + (strlen(fname) - 3), "ttf", 3)) { /*  check if it has a ttf-ending */
+								if (good == NULL)
+									good = malloc(256);
+								strncpy(good, flist[fnum], 255);
+								good[256] = 0;        /* just in case */
+								strncat(good, fname, 255 - strlen(good));
+								if ((strlen(mask) + 4) == strlen(fname)) {
 									return(good);
 								}
 							}
@@ -101,7 +101,7 @@
 					}
 				}
 			}
-		XCloseDisplay (dpy);
+		XCloseDisplay(dpy);
 	}
 	return(good);
 }

Modified: trunk/libs3d/freetype.c
===================================================================
--- trunk/libs3d/freetype.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/freetype.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,10 +25,10 @@
 /*  this file should render truetype fonts as objects */
 #include "s3d.h"
 #include "s3dlib.h"
-#include "sei_interface.h"	/* sei_triangulate_polygon() */
-#include <stdlib.h>    		/*  malloc(), free() */
-#include <math.h>			/*  atan2() */
-#include <string.h>			/*  strncmp(), strncpy() */
+#include "sei_interface.h" /* sei_triangulate_polygon() */
+#include <stdlib.h>      /*  malloc(), free() */
+#include <math.h>   /*  atan2() */
+#include <string.h>   /*  strncmp(), strncpy() */
 #include "ft2build.h"
 #include FT_FREETYPE_H
 #undef __FTERRORS_H__
@@ -47,15 +47,15 @@
 #define CALLBACK
 #endif
         /*  bad global vars ... */
-        static FT_Library 	library;
-static FT_Face		face;
-static char *memory_font=NULL;		 /*  the font file in memory */
+        static FT_Library  library;
+static FT_Face  face;
+static char *memory_font = NULL; /*  the font file in memory */
 static char oldfontpath[256];
-static int memory_font_size=0;	 /*  and it's size, to reduce load times. */
-static int ft_init=0;
-static int face_init=0;
+static int memory_font_size = 0;  /*  and it's size, to reduce load times. */
+static int ft_init = 0;
+static int face_init = 0;
 
-static int v_off; 	 /*  the vertex number offset, to have the right vertex numbers for each character */
+static int v_off;   /*  the vertex number offset, to have the right vertex numbers for each character */
 static int ch;
 struct t_buf tess_buf[256];
 
@@ -64,15 +64,15 @@
 /*  initialize truetype and tess_buf ... */
 int s3d_ft_init()
 {
-	int error= FT_Init_FreeType( &library);
+	int error = FT_Init_FreeType(&library);
 	int i;
-	oldfontpath[0]=0;
+	oldfontpath[0] = 0;
 	if (error)
 		return (-1);
-	ft_init=1;
-	for (i=0; i<256;i++) {
-		tess_buf[i].vbuf=NULL;
-		tess_buf[i].pbuf=NULL;
+	ft_init = 1;
+	for (i = 0; i < 256;i++) {
+		tess_buf[i].vbuf = NULL;
+		tess_buf[i].pbuf = NULL;
 	}
 
 	return(0);
@@ -81,18 +81,18 @@
 int s3d_ft_load_font()
 {
 	FT_Error error;
-	if ((memory_font==NULL) || (memory_font_size==0)) {
-		errds(HIGH,"s3d_ft_load_font()","there is no font in memory, breaking");
+	if ((memory_font == NULL) || (memory_font_size == 0)) {
+		errds(HIGH, "s3d_ft_load_font()", "there is no font in memory, breaking");
 		return(-1);
 	}
-	face_init=0;
-	error= FT_New_Memory_Face(library,(uint8_t *)memory_font,memory_font_size,0,&face);
+	face_init = 0;
+	error = FT_New_Memory_Face(library, (uint8_t *)memory_font, memory_font_size, 0, &face);
 	if (error) {
-		errds(VHIGH,"s3d_ft_load_font():FT_New_Memory_Face","can't load font : (%d) %s",ft_errors[error].err_code,ft_errors[error].err_msg);
+		errds(VHIGH, "s3d_ft_load_font():FT_New_Memory_Face", "can't load font : (%d) %s", ft_errors[error].err_code, ft_errors[error].err_msg);
 		return(-1);
 	}
-	s3dprintf(LOW,"Load Font successful ...");
-	face_init=1;
+	s3dprintf(LOW, "Load Font successful ...");
+	face_init = 1;
 	return(0);
 }
 
@@ -100,13 +100,13 @@
 {
 	int i;
 
-	for (i=0; i<256;i++) {
-		if (tess_buf[i].vbuf!=NULL) free(tess_buf[i].vbuf);
-		if (tess_buf[i].pbuf!=NULL) free(tess_buf[i].pbuf);
+	for (i = 0; i < 256;i++) {
+		if (tess_buf[i].vbuf != NULL) free(tess_buf[i].vbuf);
+		if (tess_buf[i].pbuf != NULL) free(tess_buf[i].pbuf);
 	}
-	for (i=0; i<256;i++) {
-		tess_buf[i].vbuf=NULL;
-		tess_buf[i].pbuf=NULL;
+	for (i = 0; i < 256;i++) {
+		tess_buf[i].vbuf = NULL;
+		tess_buf[i].pbuf = NULL;
 	}
 	return(0);
 }
@@ -117,153 +117,153 @@
  * usage */
 int _s3d_add_tessbuf(uint16_t a)
 {
-	float norm,ar,xa,ya;
-	int i,j,k,c,n,start,outl,s,e;
-	int np,pos;
+	float norm, ar, xa, ya;
+	int i, j, k, c, n, start, outl, s, e;
+	int np, pos;
 	int triangles[SEI_SS*2][3]; /* more than enough ... */
-	int ncontours,ncon;
+	int ncontours, ncon;
 	int cntr[SEI_SS];
 	int ncntr[SEI_SS];
-	int csta[SEI_SS],ncsta[SEI_SS];
+	int csta[SEI_SS], ncsta[SEI_SS];
 	int perm[SEI_SS];
 	float area[SEI_SS];
 	double vertices[SEI_SS+1][2];
 	double nvertices[SEI_SS+1][2];
 	FT_Error error;
 
-	error= FT_Load_Char(face,a, FT_LOAD_NO_BITMAP|FT_LOAD_NO_SCALE);
+	error = FT_Load_Char(face, a, FT_LOAD_NO_BITMAP | FT_LOAD_NO_SCALE);
 	if (error) {
 
-		errds(VHIGH,"_s3d_add_tessbuf():FT_Load_Char()","can't load character %d : (%d) %s",a,ft_errors[error].err_code,ft_errors[error].err_msg);
+		errds(VHIGH, "_s3d_add_tessbuf():FT_Load_Char()", "can't load character %d : (%d) %s", a, ft_errors[error].err_code, ft_errors[error].err_msg);
 		return(-1);
 	}
-	s3dprintf(VLOW,"[T]riangulating character %c",a);
-	norm=1.0/face->glyph->metrics.vertAdvance;
-	ch=a;
-	v_off=0;
-	if ((face->glyph->outline.n_points>0) && (face->glyph->outline.n_points<SEI_SS)) {
-		tess_buf[a].vn=face->glyph->outline.n_points;
-		tess_buf[a].vbuf=malloc(sizeof(float)*face->glyph->outline.n_points*3);
+	s3dprintf(VLOW, "[T]riangulating character %c", a);
+	norm = 1.0 / face->glyph->metrics.vertAdvance;
+	ch = a;
+	v_off = 0;
+	if ((face->glyph->outline.n_points > 0) && (face->glyph->outline.n_points < SEI_SS)) {
+		tess_buf[a].vn = face->glyph->outline.n_points;
+		tess_buf[a].vbuf = malloc(sizeof(float) * face->glyph->outline.n_points * 3);
 
-		j=0;
-		ncontours=face->glyph->outline.n_contours;
-		for (c=0;c<ncontours;c++) {
-			start=j; 	/* first point */
-			i=0;
-			ncon=face->glyph->outline.contours[c]; /* position of the end of ths contour */
-			cntr[c]=ncon-j+1;					   /* how many points do we have here? */
-			csta[c]=j+1;
-			ar=0.0f;
-			while (j<(ncon+1)) {
+		j = 0;
+		ncontours = face->glyph->outline.n_contours;
+		for (c = 0;c < ncontours;c++) {
+			start = j;  /* first point */
+			i = 0;
+			ncon = face->glyph->outline.contours[c]; /* position of the end of ths contour */
+			cntr[c] = ncon - j + 1;  /* how many points do we have here? */
+			csta[c] = j + 1;
+			ar = 0.0f;
+			while (j < (ncon + 1)) {
 				/* vertices have reverse order in seidels algorithm, outer contours go anticlockwise, inner contours clockwise */
 				/* calculate the area */
-				k=((j+2-csta[c])%(cntr[c]))+csta[c]-1;
-				ar-=face->glyph->outline.points[j].x * face->glyph->outline.points[k].y;
-				ar+=face->glyph->outline.points[k].x * face->glyph->outline.points[j].y;
+				k = ((j + 2 - csta[c]) % (cntr[c])) + csta[c] - 1;
+				ar -= face->glyph->outline.points[j].x * face->glyph->outline.points[k].y;
+				ar += face->glyph->outline.points[k].x * face->glyph->outline.points[j].y;
 
-				pos=ncon-i;
-				vertices[pos+1][0]=face->glyph->outline.points[j].x*norm;
-				vertices[pos+1][1]=face->glyph->outline.points[j].y*norm;
+				pos = ncon - i;
+				vertices[pos+1][0] = face->glyph->outline.points[j].x * norm;
+				vertices[pos+1][1] = face->glyph->outline.points[j].y * norm;
 				j++;
 				i++;
 			}
-			ar=0.5f*norm*norm*ar;
-			s3dprintf(VLOW,"contour %d has area of %3.3f, cntr is %d, contour starts at %d, ncon %d",c,ar,cntr[c], csta[c], ncon);
-			area[c]=ar; /* save the area */
+			ar = 0.5f * norm * norm * ar;
+			s3dprintf(VLOW, "contour %d has area of %3.3f, cntr is %d, contour starts at %d, ncon %d", c, ar, cntr[c], csta[c], ncon);
+			area[c] = ar; /* save the area */
 		}
 		/* now as we have the areas and sizes of the contours, we need to order our contours so that
 		 * the outlines and their holes are grouped together */
-		n=ncontours;
-		for (i=0;i<n;i++)
-			perm[i]=i; /* initialise permutation */
-		while (n!=0) {
-			outl=-1;
+		n = ncontours;
+		for (i = 0;i < n;i++)
+			perm[i] = i; /* initialise permutation */
+		while (n != 0) {
+			outl = -1;
 			/* find an outline */
-			for (i=0;i<n;i++)
-				if (area[perm[i]]>0) {
-					outl=i; /* found. that was easy ;) */
+			for (i = 0;i < n;i++)
+				if (area[perm[i]] > 0) {
+					outl = i; /* found. that was easy ;) */
 					break;
 				}
-			if (outl==-1) {
-				s3dprintf(HIGH,"hole without outline found, exiting ... %c",a);
+			if (outl == -1) {
+				s3dprintf(HIGH, "hole without outline found, exiting ... %c", a);
 				return(-1);
 			}
-			for (i=0;i<n;i++) {
-				if (area[perm[i]]<0) {
+			for (i = 0;i < n;i++) {
+				if (area[perm[i]] < 0) {
 					/* test for a hole inside by taking one (the first) point of the hole and doing the test */
-					xa=vertices[csta[perm[i]]][0];
-					ya=vertices[csta[perm[i]]][1];
-					s=csta[perm[outl]];							/* start point of outline */
-					e=(csta[perm[outl]]+cntr[perm[outl]])-1;		/* end point */
-					ar=0;
-					for (j=s;j<e;j++) { /* for all points of the outline, sum: */
-						ar+=atan2((vertices[j+1][1]-ya)*(vertices[j][0]-xa)-(vertices[j+1][0]-xa)*(vertices[j][1]-ya),
-						          (vertices[j+1][0]-xa)*(vertices[j][0]-xa)+(vertices[j+1][1]-ya)*(vertices[j][1]-ya));
+					xa = vertices[csta[perm[i]]][0];
+					ya = vertices[csta[perm[i]]][1];
+					s = csta[perm[outl]];     /* start point of outline */
+					e = (csta[perm[outl]] + cntr[perm[outl]]) - 1;  /* end point */
+					ar = 0;
+					for (j = s;j < e;j++) { /* for all points of the outline, sum: */
+						ar += atan2((vertices[j+1][1] - ya) * (vertices[j][0] - xa) - (vertices[j+1][0] - xa) * (vertices[j][1] - ya),
+						            (vertices[j+1][0] - xa) * (vertices[j][0] - xa) + (vertices[j+1][1] - ya) * (vertices[j][1] - ya));
 					}
 					/* dont forget the start/end-point connection*/
-					ar+=atan2((vertices[s][1]-ya)*(vertices[e][0]-xa)-(vertices[s][0]-xa)*(vertices[e][1]-ya),
-					          (vertices[s][0]-xa)*(vertices[e][0]-xa)+(vertices[s][1]-ya)*(vertices[e][1]-ya));
-					if (fabsf(ar)>1)						/* if ar = 0.0, it's outside, elseway it's a multiple of pi. this check should be
-															 * very generous to roundoff errors */
+					ar += atan2((vertices[s][1] - ya) * (vertices[e][0] - xa) - (vertices[s][0] - xa) * (vertices[e][1] - ya),
+					            (vertices[s][0] - xa) * (vertices[e][0] - xa) + (vertices[s][1] - ya) * (vertices[e][1] - ya));
+					if (fabsf(ar) > 1)      /* if ar = 0.0, it's outside, elseway it's a multiple of pi. this check should be
+                * very generous to roundoff errors */
 					{
-						s3dprintf(VLOW,"hole %d (%d) in %d (%d): interior angle sum %f (n=%d)",i,perm[i],outl, perm[outl],ar,n);
-						j=perm[n-1];	/* swap our hole to the end */
-						perm[n-1]=perm[i];
-						perm[i]=j;
-						if (outl==n-1)
-							outl=i;		/* outline got swapped */
-						n--;			/* we don't care for the hole at the end anymore as it's found */
-						i--;			/* check again for the just-swapped value in the next
-										 * loop iteration */
+						s3dprintf(VLOW, "hole %d (%d) in %d (%d): interior angle sum %f (n=%d)", i, perm[i], outl, perm[outl], ar, n);
+						j = perm[n-1]; /* swap our hole to the end */
+						perm[n-1] = perm[i];
+						perm[i] = j;
+						if (outl == n - 1)
+							outl = i;  /* outline got swapped */
+						n--;   /* we don't care for the hole at the end anymore as it's found */
+						i--;   /* check again for the just-swapped value in the next
+           * loop iteration */
 					}
 				}
 			}
 			/* all the holes should be behind n-i, if so, so we swap our outline to the end now */
-			j=perm[n-1];	/* swap our hole to the end */
-			perm[n-1]=perm[outl];
-			perm[outl]=j;
-			n--;			/* we don't care for the hole at the end anymore as it's found */
+			j = perm[n-1]; /* swap our hole to the end */
+			perm[n-1] = perm[outl];
+			perm[outl] = j;
+			n--;   /* we don't care for the hole at the end anymore as it's found */
 		}
 		/* finished the permutation, now apply the new order .... */
-		n=1;
-		for (c=0;c<ncontours;c++) {
-			ncsta[c]=n-1;
-			for (j=csta[perm[c]];j<(csta[perm[c]]+cntr[perm[c]]);j++) {
-				nvertices[n][0]=vertices[j][0];
-				nvertices[n][1]=vertices[j][1];
-				tess_buf[a].vbuf[(n-1)*3]	=nvertices[n][0];
-				tess_buf[a].vbuf[(n-1)*3+1]	=nvertices[n][1];
-				tess_buf[a].vbuf[(n-1)*3+2]	=0;
+		n = 1;
+		for (c = 0;c < ncontours;c++) {
+			ncsta[c] = n - 1;
+			for (j = csta[perm[c]];j < (csta[perm[c]] + cntr[perm[c]]);j++) {
+				nvertices[n][0] = vertices[j][0];
+				nvertices[n][1] = vertices[j][1];
+				tess_buf[a].vbuf[(n-1)*3] = nvertices[n][0];
+				tess_buf[a].vbuf[(n-1)*3+1] = nvertices[n][1];
+				tess_buf[a].vbuf[(n-1)*3+2] = 0;
 				n++;
 			}
-			ncntr[c]=cntr[perm[c]];
+			ncntr[c] = cntr[perm[c]];
 		}
-		n=0;
-		tess_buf[a].pbuf=malloc(sizeof(uint32_t)*4*(face->glyph->outline.n_points+2*face->glyph->outline.n_contours));
-		k=0;
-		for (c=ncontours-1;c>=0;c--) {
-			n++;				 /* count out and inlines ... */
-			if (area[perm[c]]>0) { /* outline? start! */
-				s3dprintf(VLOW,"[T]riangulation from outline %d (%d contours, area = %f)",perm[c],n,area[perm[c]]);
-				np=sei_triangulate_polygon(n, ncntr+c, nvertices+(ncsta[c]), triangles);
-				for (i=0;i<np;i++) {
-					tess_buf[a].pbuf[k*4]=  triangles[i][0]+ncsta[c]-1;
-					tess_buf[a].pbuf[k*4+1]=triangles[i][2]+ncsta[c]-1;
-					tess_buf[a].pbuf[k*4+2]=triangles[i][1]+ncsta[c]-1;
-					tess_buf[a].pbuf[k*4+3]=0;
+		n = 0;
+		tess_buf[a].pbuf = malloc(sizeof(uint32_t) * 4 * (face->glyph->outline.n_points + 2 * face->glyph->outline.n_contours));
+		k = 0;
+		for (c = ncontours - 1;c >= 0;c--) {
+			n++;     /* count out and inlines ... */
+			if (area[perm[c]] > 0) { /* outline? start! */
+				s3dprintf(VLOW, "[T]riangulation from outline %d (%d contours, area = %f)", perm[c], n, area[perm[c]]);
+				np = sei_triangulate_polygon(n, ncntr + c, nvertices + (ncsta[c]), triangles);
+				for (i = 0;i < np;i++) {
+					tess_buf[a].pbuf[k*4] =  triangles[i][0] + ncsta[c] - 1;
+					tess_buf[a].pbuf[k*4+1] = triangles[i][2] + ncsta[c] - 1;
+					tess_buf[a].pbuf[k*4+2] = triangles[i][1] + ncsta[c] - 1;
+					tess_buf[a].pbuf[k*4+3] = 0;
 					k++;
 				}
-				n=0;
+				n = 0;
 			}
 		}
-		tess_buf[a].pn=k;
+		tess_buf[a].pn = k;
 	}
-	tess_buf[a].xoff=1.0*face->glyph->metrics.horiAdvance*norm;
+	tess_buf[a].xoff = 1.0 * face->glyph->metrics.horiAdvance * norm;
 	return(0);
 }
 
 /* draws one charachter a */
-int _s3d_draw_tessbuf(int oid,uint16_t a,int *voff, float *xoff)
+int _s3d_draw_tessbuf(int oid, uint16_t a, int *voff, float *xoff)
 {
 	float *vbuf;
 	uint32_t *pbuf;
@@ -273,77 +273,77 @@
 	/* only draw if it has some information in it */
 	if ((tess_buf[a].pn != 0) && (tess_buf[a].vn != 0)) {
 
-		vbuf=malloc(sizeof(float)*3*tess_buf[a].vn);
-		pbuf=malloc(sizeof(uint32_t)*4*tess_buf[a].pn);
-		memcpy(vbuf,tess_buf[a].vbuf,sizeof(float)*3*tess_buf[a].vn);
-		memcpy(pbuf,tess_buf[a].pbuf,sizeof(uint32_t)*4*tess_buf[a].pn);
+		vbuf = malloc(sizeof(float) * 3 * tess_buf[a].vn);
+		pbuf = malloc(sizeof(uint32_t) * 4 * tess_buf[a].pn);
+		memcpy(vbuf, tess_buf[a].vbuf, sizeof(float)*3*tess_buf[a].vn);
+		memcpy(pbuf, tess_buf[a].pbuf, sizeof(uint32_t)*4*tess_buf[a].pn);
 		/*  prepare the buffs ... */
-		/* 	s3dprintf(LOW,"drawing [%c] (%d vertices, %d polys",a,tess_buf[a].vn,tess_buf[a].pn); */
-		for (i=0;i<tess_buf[a].vn;i++) {
-			vbuf[i*3]+=*xoff;
-			/*		s3dprintf(LOW,"vertex [%c:%d] %f %f %f",a,i,
-									vbuf[i*3],
-									vbuf[i*3+1],
-									vbuf[i*3+2]);*/
+		/*  s3dprintf(LOW,"drawing [%c] (%d vertices, %d polys",a,tess_buf[a].vn,tess_buf[a].pn); */
+		for (i = 0;i < tess_buf[a].vn;i++) {
+			vbuf[i*3] += *xoff;
+			/*  s3dprintf(LOW,"vertex [%c:%d] %f %f %f",a,i,
+			      vbuf[i*3],
+			      vbuf[i*3+1],
+			      vbuf[i*3+2]);*/
 		}
-		for (i=0;i<tess_buf[a].pn;i++) {
-			pbuf[i*4]+=*voff;
-			pbuf[i*4+1]+=*voff;
-			pbuf[i*4+2]+=*voff;
-			/*		s3dprintf(LOW,"poly [%c:%d] %d %d %d | %d (voff %d)",a,i,
-									pbuf[i*4],
-									pbuf[i*4+1],
-									pbuf[i*4+2],
-									pbuf[i*4+3],*voff);*/
+		for (i = 0;i < tess_buf[a].pn;i++) {
+			pbuf[i*4] += *voff;
+			pbuf[i*4+1] += *voff;
+			pbuf[i*4+2] += *voff;
+			/*  s3dprintf(LOW,"poly [%c:%d] %d %d %d | %d (voff %d)",a,i,
+			      pbuf[i*4],
+			      pbuf[i*4+1],
+			      pbuf[i*4+2],
+			      pbuf[i*4+3],*voff);*/
 		}
-		s3dprintf(VLOW,"commiting %d vertices, %d polygons",tess_buf[a].vn,tess_buf[a].pn);
-		s3d_push_vertices(oid,vbuf,tess_buf[a].vn);
-		s3d_push_polygons(oid,pbuf,tess_buf[a].pn);
-		*voff+=tess_buf[a].vn;
+		s3dprintf(VLOW, "commiting %d vertices, %d polygons", tess_buf[a].vn, tess_buf[a].pn);
+		s3d_push_vertices(oid, vbuf, tess_buf[a].vn);
+		s3d_push_polygons(oid, pbuf, tess_buf[a].pn);
+		*voff += tess_buf[a].vn;
 		free(vbuf);
 		free(pbuf);
 	}
-	*xoff+=tess_buf[a].xoff;  /*  xoffset */
+	*xoff += tess_buf[a].xoff;  /*  xoffset */
 	return(0);
 }
 int s3d_select_font(char *path)
 {
-	char		 	*oldfont=memory_font;
-	int 			 oldsize=memory_font_size;
+	char    *oldfont = memory_font;
+	int     oldsize = memory_font_size;
 	char *c;
 	char **p;
 	if (!ft_init)
 		if (s3d_ft_init()) {
-			errds(VHIGH,"s3d_select_font()","error in initializtation (ft_init())");
+			errds(VHIGH, "s3d_select_font()", "error in initializtation (ft_init())");
 			return(-1);
 		}
-	if (strncmp(oldfontpath,path,256)==0) {
-		s3dprintf(VLOW,"font already %s loaded.", path);
+	if (strncmp(oldfontpath, path, 256) == 0) {
+		s3dprintf(VLOW, "font already %s loaded.", path);
 		return(-1);
 	}
 	/*  yse (system-specific?!) font grabber */
-	if (((c=s3d_findfont(path))!=NULL)) {
-		s3dprintf(LOW,"Loading Font %s ... ",c);
+	if (((c = s3d_findfont(path)) != NULL)) {
+		s3dprintf(LOW, "Loading Font %s ... ", c);
 		_s3d_clear_tessbuf(); /* free and clear the tessbuf */
-		p=&memory_font;
-		if ((memory_font_size=s3d_open_file(c,p))>0) {
-			if (!s3d_ft_load_font()) {	/* success */
-				if (oldfont!=NULL)				free(oldfont);
-				strncpy(oldfontpath,path,256);
+		p = &memory_font;
+		if ((memory_font_size = s3d_open_file(c, p)) > 0) {
+			if (!s3d_ft_load_font()) { /* success */
+				if (oldfont != NULL)    free(oldfont);
+				strncpy(oldfontpath, path, 256);
 				return(0);
 			} else {
-				memory_font=oldfont;
-				memory_font_size=oldsize;
+				memory_font = oldfont;
+				memory_font_size = oldsize;
 			}
 		} else {
-			errds(VHIGH,"s3d_select_font()","Could not open fontfile %s",c);
+			errds(VHIGH, "s3d_select_font()", "Could not open fontfile %s", c);
 		}
 	}
 	return(-1);
 }
 
 /*  draws a simple string. */
-int s3d_draw_string( char *str,float *xlen)
+int s3d_draw_string(char *str, float *xlen)
 {
 	int i;
 	float xoff;
@@ -352,27 +352,27 @@
 	uint32_t f_oid;
 	if (!ft_init)
 		if (s3d_ft_init()) {
-			errds(VHIGH,"s3d_draw_string()","error in initializtation (ft_init())");
+			errds(VHIGH, "s3d_draw_string()", "error in initializtation (ft_init())");
 			return(-1);
 		}
 	if (!face_init) {
-		errds(VHIGH,"s3d_draw_string()","no font to draw with");
+		errds(VHIGH, "s3d_draw_string()", "no font to draw with");
 		return(-1);
 	}
-	f_oid=s3d_new_object();
+	f_oid = s3d_new_object();
 	/*  standard material */
-	s3d_push_material(f_oid,1.0,1.0,1.0,		1.0,1.0,1.0,	1.0,1.0,1.0);
-	xoff=0;
-	voff=0;
-	len=strlen(str);
-	for (i=0;i<len; i++)
-		_s3d_draw_tessbuf(f_oid,(uint8_t )str[i],&voff,&xoff);
+	s3d_push_material(f_oid, 1.0, 1.0, 1.0,  1.0, 1.0, 1.0, 1.0, 1.0, 1.0);
+	xoff = 0;
+	voff = 0;
+	len = strlen(str);
+	for (i = 0;i < len; i++)
+		_s3d_draw_tessbuf(f_oid, (uint8_t)str[i], &voff, &xoff);
 	/*  s3d_ft_quit(); */
-	if (xlen!=NULL) *xlen=xoff;
+	if (xlen != NULL) *xlen = xoff;
 	return(f_oid);
 }
 /* get the string length before actually drawing it. */
-float s3d_strlen( char *str)
+float s3d_strlen(char *str)
 {
 	int i;
 	float xoff;
@@ -381,22 +381,22 @@
 	uint16_t a;
 	if (!ft_init)
 		if (s3d_ft_init()) {
-			errds(VHIGH,"s3d_draw_string()","error in initializtation (ft_init())");
+			errds(VHIGH, "s3d_draw_string()", "error in initializtation (ft_init())");
 			return(0.0);
 		}
 	if (!face_init) {
-		errds(VHIGH,"s3d_draw_string()","no font to draw with");
+		errds(VHIGH, "s3d_draw_string()", "no font to draw with");
 		return(0.0);
 	}
 	/*  standard material */
-	xoff=0;
-	voff=0;
-	len=strlen(str);
-	for (i=0;i<len; i++) {
-		a=(uint8_t )str[i];
+	xoff = 0;
+	voff = 0;
+	len = strlen(str);
+	for (i = 0;i < len; i++) {
+		a = (uint8_t)str[i];
 		if (!(tess_buf[a].vbuf && tess_buf[a].pbuf))
 			_s3d_add_tessbuf(a);
-		xoff+=tess_buf[a].xoff;  /*  xoffset */
+		xoff += tess_buf[a].xoff;  /*  xoffset */
 	}
 	return(xoff);
 
@@ -405,7 +405,7 @@
 {
 	_s3d_clear_tessbuf();
 	FT_Done_FreeType(library);
-	ft_init=0;
+	ft_init = 0;
 	return(0);
 }
 

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/io.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,40 +25,40 @@
 #include "s3d.h"
 #include "s3dlib.h"
 #include "proto.h"
-#include <stdio.h>  	 /*  fopen(),fclose(),fileno() */
-#include <string.h> 	 /*  strncpy(),strncmp(),memcpy() */
-#include <stdlib.h>		 /*  atoi(),malloc(),free() */
-#include <sys/stat.h>	 /*  fstat() */
-#include <unistd.h>		 /*  getpid(), fstat() */
-#include <errno.h>		 /*  errno */
+#include <stdio.h>    /*  fopen(),fclose(),fileno() */
+#include <string.h>   /*  strncpy(),strncmp(),memcpy() */
+#include <stdlib.h>   /*  atoi(),malloc(),free() */
+#include <sys/stat.h>  /*  fstat() */
+#include <unistd.h>   /*  getpid(), fstat() */
+#include <errno.h>   /*  errno */
 #include <sys/socket.h>  /*  socket() */
-#include <getopt.h>		 /*  getopt() */
+#include <getopt.h>   /*  getopt() */
 
 #ifndef _POSIX_C_SOURCE
-#define _POSIX_C_SOURCE 199309		/* we want struct timespec to be defined */
+#define _POSIX_C_SOURCE 199309  /* we want struct timespec to be defined */
 #endif
 #ifndef __USE_POSIX199309
 #define __USE_POSIX199309 1
 #endif
-#include <time.h>		 /*  nanosleep() */
+#include <time.h>   /*  nanosleep() */
 
 #ifdef SIGS
-#include <fcntl.h>		 /*  fcntl() */
-#define __USE_BSD	1		/* we want sig_t to be defined */
-#include <signal.h>		 /*  signal.h, SIG_PIPE */
+#include <fcntl.h>   /*  fcntl() */
+#define __USE_BSD 1  /* we want sig_t to be defined */
+#include <signal.h>   /*  signal.h, SIG_PIPE */
 #endif
 #include <netinet/in.h>  /*  htons(),htonl() */
 #ifndef WIN32
-#include <netdb.h>		 /*  gethostbyname()  */
+#include <netdb.h>   /*  gethostbyname()  */
 #endif
 
-static char				*url=NULL;
-extern int 				con_type;
-extern int 				cb_lock;
+static char    *url = NULL;
+extern int     con_type;
+extern int     cb_lock;
 /*  this file is the client-lib-implementation which holds the function to connect and control the server. */
 #ifdef SIGS
-int _s3d_sigio=0;
-int _s3d_ready=0;
+int _s3d_sigio = 0;
+int _s3d_ready = 0;
 void sigint_handler(int S3DUNUSED(sig), int S3DUNUSED(code))  /*  ... ? */
 {
 	/*s3d_quit();*/ /* TODO: sometimes no clean quit ?!*/
@@ -75,27 +75,27 @@
 
 static int parse_args(int *argc, char ***argv)
 {
-	char				 c;
-	int					 lopt_idx;
+	char     c;
+	int      lopt_idx;
 	struct option long_options[] = {
-		{"s3d-url",1,0,0
-		}, {"help",0,0,'h'}, {"s3d-help",0,0,'h'}, {0,0,0,0}
+		{"s3d-url", 1, 0, 0
+		}, {"help", 0, 0, 'h'}, {"s3d-help", 0, 0, 'h'}, {0, 0, 0, 0}
 	};
-	if ((argc==NULL) || (argv==NULL)) return(0); /* nothing to parse */
-	optind=0;
-	opterr=0;	/* we don't want to be bothered if there is some error */
-	while (-1!=(c=getopt_long(*argc,*argv,"?h",long_options,&lopt_idx))) {
+	if ((argc == NULL) || (argv == NULL)) return(0); /* nothing to parse */
+	optind = 0;
+	opterr = 0; /* we don't want to be bothered if there is some error */
+	while (-1 != (c = getopt_long(*argc, *argv, "?h", long_options, &lopt_idx))) {
 		switch (c) {
 		case 0:
-			if (0==strcmp(long_options[lopt_idx].name,"s3d-url")) {
+			if (0 == strcmp(long_options[lopt_idx].name, "s3d-url")) {
 				if (optarg) {
-					url=optarg;
-					s3dprintf(HIGH,"connecting to %s",url);
+					url = optarg;
+					s3dprintf(HIGH, "connecting to %s", url);
 				}
 			}
 			break;
 		case 'h':
-			printf("usage: %s [options]",(*argv)[0]);
+			printf("usage: %s [options]", (*argv)[0]);
 			s3d_usage();
 			return(-1);
 		case '?':
@@ -104,62 +104,62 @@
 			break;
 		}
 	}
-	optind=0;
-	if (*argc>0) {
-		*argc-=(optind-1); 				 /*  hide s3d-options */
-		(*argv)[optind-1]=(*argv)[0]; 	 /*  restore program path */
-		*argv+=(optind-1); 				 /*  set the string pointer at the right position */
+	optind = 0;
+	if (*argc > 0) {
+		*argc -= (optind - 1);  /*  hide s3d-options */
+		(*argv)[optind-1] = (*argv)[0]; /*  restore program path */
+		*argv += (optind - 1);  /*  set the string pointer at the right position */
 	}
 	return(0);
 }
 /*  external functions go here ... */
 int s3d_init(int *argc, char ***argv, char *name)
 {
-	char 				*s;
-	char 				 urlc[256];		 /*  this should be enough for an url */
-	char 				 buf[258]; 		 /*  server buffer */
-	int					 i;
-	struct timespec		 t= {
-		0,10*1000*1000
+	char     *s;
+	char      urlc[256];   /*  this should be enough for an url */
+	char      buf[258];    /*  server buffer */
+	int      i;
+	struct timespec   t = {
+		0, 10*1000*1000
 	}; /* 10 mili second */
 
-	cb_lock=1;	/* don't bother while initiating ... is set to 0 after INIT packet received. */
-	if (NULL!=(s=getenv("S3D"))) {
-		s3dprintf(VLOW,"at least we have the enviroment variable ... %s",s);
-		url=s;
+	cb_lock = 1; /* don't bother while initiating ... is set to 0 after INIT packet received. */
+	if (NULL != (s = getenv("S3D"))) {
+		s3dprintf(VLOW, "at least we have the enviroment variable ... %s", s);
+		url = s;
 	}
-	parse_args(argc,argv);
-	if (url==NULL) { /* no url specified or obtained through arguments */
+	parse_args(argc, argv);
+	if (url == NULL) { /* no url specified or obtained through arguments */
 		/* trying standard ways to connect */
-		strncpy(urlc,"s3d:///tmp/.s3d:shm/",256);
-		if (s3d_net_init(urlc)==CON_NULL) {
-			strncpy(urlc,"s3d://127.0.0.1:6066/",256);
-			if (s3d_net_init(urlc)==CON_NULL)
+		strncpy(urlc, "s3d:///tmp/.s3d:shm/", 256);
+		if (s3d_net_init(urlc) == CON_NULL) {
+			strncpy(urlc, "s3d://127.0.0.1:6066/", 256);
+			if (s3d_net_init(urlc) == CON_NULL)
 				return(-1);
 		}
 	} else {
-		strncpy(urlc,url,256);	 /*  this should keep buffer overflows away, maybe */
-		urlc[256]=0;			 /*  just to make sure */
-		if (!strncmp(urlc, "s3d:// ",6)) {
-			if (s3d_net_init(urlc)==CON_NULL) return(-1);
+		strncpy(urlc, url, 256);  /*  this should keep buffer overflows away, maybe */
+		urlc[256] = 0;  /*  just to make sure */
+		if (!strncmp(urlc, "s3d:// ", 6)) {
+			if (s3d_net_init(urlc) == CON_NULL) return(-1);
 		} else {
-			errs("s3d_init()","invalid url");
+			errs("s3d_init()", "invalid url");
 			return(-1);
 		}
 	}
-	strncpy(buf,name,256);  /*  copy the name ... */
-	net_send(S3D_P_C_INIT,buf,strlen(buf));
+	strncpy(buf, name, 256);  /*  copy the name ... */
+	net_send(S3D_P_C_INIT, buf, strlen(buf));
 
 	_queue_init();
 #ifdef SIGS
 	if (signal(SIGINT, (sig_t)sigint_handler) == SIG_ERR)
-		errdn(LOW,"s3d_init():signal()",errno);
+		errdn(LOW, "s3d_init():signal()", errno);
 	if (signal(SIGTERM, (sig_t)sigint_handler) == SIG_ERR)
-		errdn(LOW,"s3d_init():signal()",errno);
+		errdn(LOW, "s3d_init():signal()", errno);
 #endif
-	for (i=0;i<100;i++) {
+	for (i = 0;i < 100;i++) {
 		s3d_net_check(); /* wait for init packet */
-		nanosleep(&t,NULL);
+		nanosleep(&t, NULL);
 		if (_s3d_ready) {
 			cb_lock--;
 			return(0);
@@ -171,8 +171,8 @@
 int s3d_quit()
 {
 	struct s3d_evt *ret;
-	if (con_type!=CON_NULL && _s3d_ready) {
-		net_send(S3D_P_C_QUIT,NULL,0);
+	if (con_type != CON_NULL && _s3d_ready) {
+		net_send(S3D_P_C_QUIT, NULL, 0);
 		switch (con_type) {
 #ifdef TCP
 		case CON_TCP:
@@ -185,14 +185,14 @@
 			break;
 #endif
 		}
-		con_type=CON_NULL;
-		_s3d_ready=0;
+		con_type = CON_NULL;
+		_s3d_ready = 0;
 		_queue_quit();
-		while (NULL!=(ret=s3d_pop_event())) s3d_delete_event(ret);  /*  clear the stack ... */
-		cb_lock=0; /* we don't care about old callbacks, now we just quit! */
-		ret=malloc(sizeof(struct s3d_evt));
-		ret->event=S3D_EVENT_QUIT;
-		ret->length=0;
+		while (NULL != (ret = s3d_pop_event())) s3d_delete_event(ret);  /*  clear the stack ... */
+		cb_lock = 0; /* we don't care about old callbacks, now we just quit! */
+		ret = malloc(sizeof(struct s3d_evt));
+		ret->event = S3D_EVENT_QUIT;
+		ret->length = 0;
 		s3d_push_event(ret);
 	}
 	return(0);
@@ -200,12 +200,12 @@
 /*  apps should use that as main loop for their programs. */
 int s3d_mainloop(void (*f)())
 {
-	while (con_type!=CON_NULL) {
-		cb_lock++;			/* no callbacks while we are in mainloop */
-		if (f!=NULL)	f();
+	while (con_type != CON_NULL) {
+		cb_lock++;   /* no callbacks while we are in mainloop */
+		if (f != NULL) f();
 		cb_lock--;
 		s3d_process_stack();
-		s3d_net_check(); 	/* get any other packets we might have missed */
+		s3d_net_check();  /* get any other packets we might have missed */
 	}
 	return(0);
 }
@@ -214,35 +214,35 @@
 int s3d_open_file(char *fname, char **pointer)
 {
 	FILE *fp;
-	char *buf=NULL;
+	char *buf = NULL;
 	int filesize;
 	struct stat bf;
-	*pointer=NULL;
-	/*	if ((fp = fopen(fname, "rt")) == NULL)
-		{ errn("s3d_open_file():fopen()",errno); return(0);}
-		if (fseek(fp, 0, SEEK_END) != 0)
-		{ errn("s3d_open_file():fseek()",errno); return(0);}
-		if ((filesize = (int)ftell(fp)) == (long)-1)
-		{ errn("s3d_open_file():ftell()",errno); return(0);}
-		if (fseek(fp, 0, SEEK_SET) != 0)
-		{ errn("s3d_open_file():fseek()",errno); return(0);}*/
+	*pointer = NULL;
+	/* if ((fp = fopen(fname, "rt")) == NULL)
+	 { errn("s3d_open_file():fopen()",errno); return(0);}
+	 if (fseek(fp, 0, SEEK_END) != 0)
+	 { errn("s3d_open_file():fseek()",errno); return(0);}
+	 if ((filesize = (int)ftell(fp)) == (long)-1)
+	 { errn("s3d_open_file():ftell()",errno); return(0);}
+	 if (fseek(fp, 0, SEEK_SET) != 0)
+	 { errn("s3d_open_file():fseek()",errno); return(0);}*/
 
 	if ((fp = fopen(fname, "rt")) == NULL) {
-		errdn(VLOW,"s3d_open_file():fopen()",errno);
+		errdn(VLOW, "s3d_open_file():fopen()", errno);
 		return(-1);
 	}
-	if (fstat(fileno(fp),&bf)) {
-		errdn(VLOW,"s3d_open_file():fstat()",errno);
+	if (fstat(fileno(fp), &bf)) {
+		errdn(VLOW, "s3d_open_file():fstat()", errno);
 		return(-1);
 	}
-	filesize=bf.st_size;
-	/*	s3dprintf(LOW, "opening %s, filesize is %d",fname, filesize);*/
-	if ((buf=malloc(filesize))==NULL) {
-		errn("s3d_open_3ds_file():malloc()",errno);
+	filesize = bf.st_size;
+	/* s3dprintf(LOW, "opening %s, filesize is %d",fname, filesize);*/
+	if ((buf = malloc(filesize)) == NULL) {
+		errn("s3d_open_3ds_file():malloc()", errno);
 		exit(-1);
 	}
 	fread(buf, 1, filesize, fp);
 	fclose(fp);
-	*pointer=buf;
+	*pointer = buf;
 	return(filesize);
 }

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/modelread.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,10 +25,10 @@
 #include "s3d.h"
 #include "s3dlib.h"
 #include <g3d/g3d.h>
-#include <stdlib.h> 	 /*  exit(), malloc() */
-#include <math.h>		 /*  sqrt() */
-#include <string.h> 	 /*  strncpy() */
-#include <errno.h> 		 /*  errno */
+#include <stdlib.h>   /*  exit(), malloc() */
+#include <math.h>   /*  sqrt() */
+#include <string.h>   /*  strncpy() */
+#include <errno.h>    /*  errno */
 
 
 struct material2texture {
@@ -40,63 +40,63 @@
 };
 struct material2texture *mat2tex_root = NULL;
 
-#define MAXSTRN		20
+#define MAXSTRN  20
 static int model_load(char *file);
 /*  just a helper function for reading from file instead of memory. */
 int s3d_import_model_file(char *fname)
 {
-	char *buf,*ptr,*next;
+	char *buf, *ptr, *next;
 	char searchpath[1024];
 	char path[1024];
 	int oid;
-	if (fname==NULL) return(-1);
+	if (fname == NULL) return(-1);
 #ifndef OBJSDIR
-#define OBJSDIR 	":./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/"
+#define OBJSDIR  ":./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/"
 #endif
 
-	strncpy(searchpath,OBJSDIR,1023);
-	searchpath[1023]=0;							/* just in case */
-	next=ptr=searchpath;
-	while (next!=NULL) {
-		next=NULL;
+	strncpy(searchpath, OBJSDIR, 1023);
+	searchpath[1023] = 0;     /* just in case */
+	next = ptr = searchpath;
+	while (next != NULL) {
+		next = NULL;
 
-		if (NULL!=(next=strchr(ptr,':'))) {
-			*next=0; 							/* clear the delimiter */
-			next+=1;							/* move to the beginner of the next dir */
+		if (NULL != (next = strchr(ptr, ':'))) {
+			*next = 0;      /* clear the delimiter */
+			next += 1;     /* move to the beginner of the next dir */
 		}
-		if ((strlen(ptr)+strlen(fname))<1024) {	/* only try if this fits */
-			strcpy(path,ptr); 					/* can use "unsafe" functions because size was verified above */
-			strcat(path,fname);
-			if (s3d_open_file(path,&buf)!=-1) { /* found something */
+		if ((strlen(ptr) + strlen(fname)) < 1024) { /* only try if this fits */
+			strcpy(path, ptr);     /* can use "unsafe" functions because size was verified above */
+			strcat(path, fname);
+			if (s3d_open_file(path, &buf) != -1) { /* found something */
 				free(buf); /* TODO: badbadbad ... */
-				if (-1!=(oid=model_load(path))) return(oid);
+				if (-1 != (oid = model_load(path))) return(oid);
 
 			}
 		}
-		if (next!=NULL)
-			ptr=next;							/* move pointer to the next position */
+		if (next != NULL)
+			ptr = next;     /* move pointer to the next position */
 	}
-	errds(LOW,"s3d_import_model_file()","Could not open %s", fname);
+	errds(LOW, "s3d_import_model_file()", "Could not open %s", fname);
 	return(-1); /* nothing in search path ... */
 }
 
-void *get_mat2tex( struct material2texture **mat2tex, void *mat_ptr )
+void *get_mat2tex(struct material2texture **mat2tex, void *mat_ptr)
 {
 
-	while ( (*mat2tex) != NULL ) {
+	while ((*mat2tex) != NULL) {
 
-		if ( (*mat2tex)->material_ptr == mat_ptr ) return (*mat2tex);
+		if ((*mat2tex)->material_ptr == mat_ptr) return (*mat2tex);
 
 		mat2tex = &(*mat2tex)->next_ptr;
 
 	}
 
-	if ( (*mat2tex) == NULL ) {
+	if ((*mat2tex) == NULL) {
 
-		(*mat2tex) = malloc( sizeof( struct material2texture ) );
+		(*mat2tex) = malloc(sizeof(struct material2texture));
 
-		if ( (*mat2tex) == NULL ) {
-			errs( "model_import()", "Sorry - you ran out of memory !\n" );
+		if ((*mat2tex) == NULL) {
+			errs("model_import()", "Sorry - you ran out of memory !\n");
 			exit(8);
 		}
 
@@ -118,112 +118,112 @@
 
 int model_load(char *file)
 {
-	G3DContext			 	*context;
-	G3DModel				*model;
-	G3DObject 				*object;
-	G3DFace 				*face;
-	GSList 					*oitem, *oface;
+	G3DContext     *context;
+	G3DModel    *model;
+	G3DObject     *object;
+	G3DFace     *face;
+	GSList      *oitem, *oface;
 	struct material2texture *mat2tex;
-	int						 j, k, material_count, texture_count, voff,obj_id;
-#define 					PMAX	100
-	uint32_t 			 polybuf[PMAX * 4],npoly,oldflags;
-	float					 normalbuf[PMAX * 9],texcoordbuf[PMAX * 6];
-	float 					 swaph;				/* swap helper */
-	uint8_t 			*s3d_pixeldata = NULL;
+	int       j, k, material_count, texture_count, voff, obj_id;
+#define      PMAX 100
+	uint32_t     polybuf[PMAX * 4], npoly, oldflags;
+	float      normalbuf[PMAX * 9], texcoordbuf[PMAX * 6];
+	float       swaph;    /* swap helper */
+	uint8_t    *s3d_pixeldata = NULL;
 
 	context = g3d_context_new();
-	obj_id=-1;
+	obj_id = -1;
 	model = g3d_model_load_full(context, file, 0);
 
-	if ( model ) {
+	if (model) {
 
 		oitem = model->objects;
 		obj_id = s3d_new_object();
 		material_count = texture_count = voff = 0;
 
-		while ( oitem ) {
+		while (oitem) {
 
 			object = (G3DObject *)oitem->data;
 
 			/* push vertices */
-			for ( j = 0; j < object->vertex_count; j++ ) {
+			for (j = 0; j < object->vertex_count; j++) {
 				/* 2. and 3. coord have to change places otherwise the object will be turned */
 				object->vertex_data[j * 3 + 0] =  object->vertex_data[j * 3 + 0];
-				swaph=							  object->vertex_data[j * 3 + 2];
+				swaph =         object->vertex_data[j * 3 + 2];
 				object->vertex_data[j * 3 + 2] = -object->vertex_data[j * 3 + 1];
 				object->vertex_data[j * 3 + 1] = swaph;
 			}
-			s3d_push_vertices( obj_id, object->vertex_data, object->vertex_count);
+			s3d_push_vertices(obj_id, object->vertex_data, object->vertex_count);
 
 
 
-			if (NULL==(oface = object->faces)) {
+			if (NULL == (oface = object->faces)) {
 				voff += object->vertex_count; /* increase vertex offset */
 				oitem = oitem->next;
 				continue;
 			}
-			npoly=0;
-			oldflags = ((G3DFace *) (oface->data))->flags;
+			npoly = 0;
+			oldflags = ((G3DFace *)(oface->data))->flags;
 
-			while ( oface ) {
+			while (oface) {
 
 				face = (G3DFace *)oface->data;
-				mat2tex = get_mat2tex( &mat2tex_root, face->material );
+				mat2tex = get_mat2tex(&mat2tex_root, face->material);
 
-				if ( mat2tex->material_id == -1 ) { /* create a new texture if nothing found */
-					s3d_push_material_a( obj_id, 	face->material->r, face->material->g, face->material->b,face->material->a,
-					                     face->material->specular[0], face->material->specular[1], face->material->specular[2], face->material->specular[3],
-					                     face->material->r, face->material->g, face->material->b, face->material->a );
+				if (mat2tex->material_id == -1) {   /* create a new texture if nothing found */
+					s3d_push_material_a(obj_id,  face->material->r, face->material->g, face->material->b, face->material->a,
+					                    face->material->specular[0], face->material->specular[1], face->material->specular[2], face->material->specular[3],
+					                    face->material->r, face->material->g, face->material->b, face->material->a);
 
 					mat2tex->material_id = material_count;
 					material_count++;
 
-					if ( face->tex_image != NULL ) {
+					if (face->tex_image != NULL) {
 
 						/* reorder pixeldata - s3d wants rgba */
-						if ( s3d_pixeldata != NULL ) free( s3d_pixeldata );
+						if (s3d_pixeldata != NULL) free(s3d_pixeldata);
 
-						s3d_pixeldata = malloc( sizeof( uint8_t ) * face->tex_image->width * face->tex_image->height * 32 );
+						s3d_pixeldata = malloc(sizeof(uint8_t) * face->tex_image->width * face->tex_image->height * 32);
 
-						if ( s3d_pixeldata == NULL ) {
-							errs("model_load()", "Sorry - you ran out of memory !\n" );
+						if (s3d_pixeldata == NULL) {
+							errs("model_load()", "Sorry - you ran out of memory !\n");
 							exit(8);
 						}
 
-						for ( j = ( face->tex_image->height - 1 ); j >= 0; j-- ) {
-							for ( k = 0; k < face->tex_image->width; k++ ) {
-								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ];
-								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ];
-								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ];
-								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ];
+						for (j = (face->tex_image->height - 1); j >= 0; j--) {
+							for (k = 0; k < face->tex_image->width; k++) {
+								s3d_pixeldata[(j * face->tex_image->width + k) * 4 + 0 ] = face->tex_image->pixeldata[(j * face->tex_image->width + k) * 4 + 2 ];
+								s3d_pixeldata[(j * face->tex_image->width + k) * 4 + 1 ] = face->tex_image->pixeldata[(j * face->tex_image->width + k) * 4 + 1 ];
+								s3d_pixeldata[(j * face->tex_image->width + k) * 4 + 2 ] = face->tex_image->pixeldata[(j * face->tex_image->width + k) * 4 + 0 ];
+								s3d_pixeldata[(j * face->tex_image->width + k) * 4 + 3 ] = face->tex_image->pixeldata[(j * face->tex_image->width + k) * 4 + 3 ];
 							}
 						}
 
-						s3d_push_texture( obj_id, face->tex_image->width, face->tex_image->height );
-						s3d_pep_material_texture( obj_id, texture_count );
-						s3d_load_texture( obj_id, texture_count, 0, 0, face->tex_image->width, face->tex_image->height, s3d_pixeldata );
+						s3d_push_texture(obj_id, face->tex_image->width, face->tex_image->height);
+						s3d_pep_material_texture(obj_id, texture_count);
+						s3d_load_texture(obj_id, texture_count, 0, 0, face->tex_image->width, face->tex_image->height, s3d_pixeldata);
 
 						mat2tex->texture_id = texture_count;
 						texture_count++;
 
 					}
 				}
-				if (face->flags != oldflags || npoly>=PMAX) {
+				if (face->flags != oldflags || npoly >= PMAX) {
 					/* push things so far */
 					s3d_push_polygons(obj_id, polybuf, npoly);
-					if (oldflags & G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
-					if (oldflags & G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);
-					npoly=0;
+					if (oldflags & G3D_FLAG_FAC_NORMALS)  s3d_pep_polygon_normals(obj_id, normalbuf,   npoly);
+					if (oldflags & G3D_FLAG_FAC_TEXMAP)   s3d_pep_polygon_tex_coords(obj_id, texcoordbuf, npoly);
+					npoly = 0;
 				}
-				oldflags=face->flags;
+				oldflags = face->flags;
 
 				/* add polygon to the polygon buffer */
-				polybuf[npoly*4+0]=face->vertex_indices[0] + voff;
-				polybuf[npoly*4+1]=face->vertex_indices[2] + voff;
-				polybuf[npoly*4+2]=face->vertex_indices[1] + voff;
-				polybuf[npoly*4+3]=mat2tex->material_id;
+				polybuf[npoly*4+0] = face->vertex_indices[0] + voff;
+				polybuf[npoly*4+1] = face->vertex_indices[2] + voff;
+				polybuf[npoly*4+2] = face->vertex_indices[1] + voff;
+				polybuf[npoly*4+3] = mat2tex->material_id;
 
-				if ( face->flags & G3D_FLAG_FAC_NORMALS ) {
+				if (face->flags & G3D_FLAG_FAC_NORMALS) {
 					normalbuf[ npoly*9 + 0] = -face->normals[ 0 ];
 					normalbuf[ npoly*9 + 1] = -face->normals[ 2 ];
 					normalbuf[ npoly*9 + 2] =  face->normals[ 1 ];
@@ -234,7 +234,7 @@
 					normalbuf[ npoly*9 + 7] = -face->normals[ 5 ];
 					normalbuf[ npoly*9 + 8] =  face->normals[ 4 ];
 				}
-				if ( face->flags & G3D_FLAG_FAC_TEXMAP ) {
+				if (face->flags & G3D_FLAG_FAC_TEXMAP) {
 					texcoordbuf[ npoly*6 + 0] = face->tex_vertex_data[ 0 ];
 					texcoordbuf[ npoly*6 + 1] = face->tex_vertex_data[ 1 ];
 					texcoordbuf[ npoly*6 + 2] = face->tex_vertex_data[ 4 ];
@@ -248,9 +248,9 @@
 			/* push the last packets in buffer */
 			if (npoly > 0) {
 				s3d_push_polygons(obj_id, polybuf, npoly);
-				if (oldflags & G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
-				if (oldflags & G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);
-				npoly=0;
+				if (oldflags & G3D_FLAG_FAC_NORMALS)  s3d_pep_polygon_normals(obj_id, normalbuf,   npoly);
+				if (oldflags & G3D_FLAG_FAC_TEXMAP)   s3d_pep_polygon_tex_coords(obj_id, texcoordbuf, npoly);
+				npoly = 0;
 			}
 
 			voff += object->vertex_count; /* increase vertex offset */

Modified: trunk/libs3d/network.c
===================================================================
--- trunk/libs3d/network.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/network.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,15 +24,15 @@
 
 #include "s3d.h"
 #include "s3dlib.h"
-#include <string.h> 	 /*  memcpy() */
-#include <stdlib.h>		 /*  malloc(), free() */
-#include <unistd.h>		 /*  read(), write() */
-#include <errno.h>		 /*  errno */
+#include <string.h>   /*  memcpy() */
+#include <stdlib.h>   /*  malloc(), free() */
+#include <unistd.h>   /*  read(), write() */
+#include <errno.h>   /*  errno */
 #include <netinet/in.h>  /*  htons(),htonl() */
 #ifdef SIGS
 extern int _s3d_sigio;
 #endif
-int con_type=CON_NULL;
+int con_type = CON_NULL;
 #ifdef TCP
 static int _s3d_net_receive();
 #endif
@@ -40,22 +40,22 @@
 int net_send(u_int8_t opcode, char *buf, u_int16_t length)
 {
 	char *ptr;
-	/* 	char *buff; */
+	/*  char *buff; */
 	char buff[65539];  /*  u_int16_t really shouldn't be bigger ;) */
-	*(buff)=opcode;
-	ptr=buff+1;
-	*((u_int16_t *) ptr)=htons(length);
-	if (length!=0)
-		memcpy(buff+3,buf,length);
+	*(buff) = opcode;
+	ptr = buff + 1;
+	*((u_int16_t *) ptr) = htons(length);
+	if (length != 0)
+		memcpy(buff + 3, buf, length);
 	switch (con_type) {
 #ifdef SHM
 	case CON_SHM:
-		shm_writen(buff,length+3);
+		shm_writen(buff, length + 3);
 		break;
 #endif
 #ifdef TCP
 	case CON_TCP:
-		tcp_writen(buff,length+3);
+		tcp_writen(buff, length + 3);
 		break;
 #endif
 	}
@@ -79,7 +79,7 @@
 #endif
 			while (_s3d_net_receive());
 #ifdef SIGS
-			_s3d_sigio=0;
+			_s3d_sigio = 0;
 		}
 #endif
 		break;
@@ -95,64 +95,64 @@
 }
 int s3d_net_init(char *urlc)
 {
-	char				*s,*sv,*port=NULL;
-	char				*first_slash=NULL;
+	char    *s, *sv, *port = NULL;
+	char    *first_slash = NULL;
 #ifdef TCP
-	int					 pn=0;
+	int      pn = 0;
 #endif
-	int					 tcp,shm;
-	tcp=shm=1; /* everything is possible, yet */
+	int      tcp, shm;
+	tcp = shm = 1; /* everything is possible, yet */
 
 	/*  doing a very bad server/port extraction, but I think it'll work ... */
-	s=sv=urlc+6;  /*  getting to the "real" thing */
+	s = sv = urlc + 6;  /*  getting to the "real" thing */
 	/* while (((*s!='/') && (*s!=0)) && (s<(urlc-6))) */
-	while (*s!=0) {
-		if (*s=='/') {
-			if (first_slash==NULL)
-				first_slash=s;
-			if (port!=NULL)
+	while (*s != 0) {
+		if (*s == '/') {
+			if (first_slash == NULL)
+				first_slash = s;
+			if (port != NULL)
 				break;
 		}
-		if (*s==':') { /*  there is a port in here */
-			port=s+1;
-			*s=0;	 /*  NULL the port  */
+		if (*s == ':') { /*  there is a port in here */
+			port = s + 1;
+			*s = 0;  /*  NULL the port  */
 		}
 		s++;
 	}
 
-	*s=0;
-	if (port==NULL) {
-		shm=0;
-		if (first_slash!=NULL)
-			*first_slash=0;
+	*s = 0;
+	if (port == NULL) {
+		shm = 0;
+		if (first_slash != NULL)
+			*first_slash = 0;
 	} else {
-		if (first_slash<port)
-			tcp=0;
+		if (first_slash < port)
+			tcp = 0;
 		else
-			if (first_slash!=NULL)
-				*first_slash=0;
-		if (!strncmp(port, "shm",3)) {
-			tcp=0; /* null the others */
+			if (first_slash != NULL)
+				*first_slash = 0;
+		if (!strncmp(port, "shm", 3)) {
+			tcp = 0; /* null the others */
 		} else {
-			shm=0;
+			shm = 0;
 		}
 	}
 #ifdef SHM
 	if (shm) {
-		if (!strncmp(port, "shm",3))
-			if (!_shm_init(sv)) return(con_type=CON_SHM);
+		if (!strncmp(port, "shm", 3))
+			if (!_shm_init(sv)) return(con_type = CON_SHM);
 	}
 #endif
 #ifdef TCP
 	if (tcp) {
-		pn=6066;
-		if (port!=NULL) {
-			if (!(pn=atoi(port))) { /*  I hope atoi is safe enough. */
-				errn("s3d_init():atoi()",errno);
-				pn=6066;
+		pn = 6066;
+		if (port != NULL) {
+			if (!(pn = atoi(port))) { /*  I hope atoi is safe enough. */
+				errn("s3d_init():atoi()", errno);
+				pn = 6066;
 			}
 		}
-		if (!_tcp_init(sv,pn)) return(con_type=CON_TCP);
+		if (!_tcp_init(sv, pn)) return(con_type = CON_TCP);
 	}
 #endif
 	return(CON_NULL);

Modified: trunk/libs3d/object_queue.c
===================================================================
--- trunk/libs3d/object_queue.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/object_queue.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,38 +25,38 @@
 #include "s3d.h"
 #include "s3dlib.h"
 #include "proto.h"
-#include <stdlib.h>	 /*  malloc(),free(), realloc() */
+#include <stdlib.h>  /*  malloc(),free(), realloc() */
 
 #ifndef _POSIX_C_SOURCE
-#define _POSIX_C_SOURCE 199309		/* we want struct timespec to be defined */
+#define _POSIX_C_SOURCE 199309  /* we want struct timespec to be defined */
 #endif
 #ifndef __USE_POSIX199309
 #define __USE_POSIX199309 1
 #endif
-#include <time.h>		 /*  nanosleep() */
+#include <time.h>   /*  nanosleep() */
 
 /*  objects are requested before beeing used for having fast  */
 /*  access when needed. this also makes things more asynchronous, */
 /*  therefore faster (I hope). */
 
-#define Q_UNUSED	-1				 	/*  unused slot magic number */
-#define MAX_REQ		100				 	/*  don't request more than that. */
-static unsigned int *queue;			 	/*  the object id's */
-static int queue_size=0;			 	/*  the size of the object queue */
-static int requested;				 	/*  counter of how many addtional */
+#define Q_UNUSED -1      /*  unused slot magic number */
+#define MAX_REQ  100      /*  don't request more than that. */
+static unsigned int *queue;     /*  the object id's */
+static int queue_size = 0;   /*  the size of the object queue */
+static int requested;      /*  counter of how many addtional */
 /*  objects have been requested */
-static struct timespec t= {
-	0,10*1000
-};	/* 10 micro seconds */
+static struct timespec t = {
+	0, 10*1000
+}; /* 10 micro seconds */
 /*  initializes the object queue */
 int _queue_init()
 {
 	int i;
-	queue_size=1;
-	requested=0;
-	queue=malloc(sizeof(unsigned int)*queue_size);
-	for (i=0;i<queue_size;i++) {
-		queue[i]=Q_UNUSED;
+	queue_size = 1;
+	requested = 0;
+	queue = malloc(sizeof(unsigned int) * queue_size);
+	for (i = 0;i < queue_size;i++) {
+		queue[i] = Q_UNUSED;
 	}
 	_queue_fill();
 	return(0);
@@ -65,68 +65,68 @@
 int _queue_fill()
 {
 	int i;
-	for (i=0;i<queue_size;i++)
-		if (queue[i]==Q_UNUSED)
-			net_send(S3D_P_C_NEW_OBJ,NULL,0);
+	for (i = 0;i < queue_size;i++)
+		if (queue[i] == Q_UNUSED)
+			net_send(S3D_P_C_NEW_OBJ, NULL, 0);
 	return(0);
 }
 /*  we have a new object from the server, trying to find a place for it */
 int _queue_new_object(unsigned int oid)
 {
 	int i;
-	/* 	s3dprintf(LOW,"having a new object (%d) in the queue!!",oid); */
-	for (i=0;i<queue_size;i++)
-		if (queue[i]==Q_UNUSED) {
-			/* 			s3dprintf(LOW,"placing it at position %d",i); */
-			queue[i]=oid;
+	/*  s3dprintf(LOW,"having a new object (%d) in the queue!!",oid); */
+	for (i = 0;i < queue_size;i++)
+		if (queue[i] == Q_UNUSED) {
+			/*    s3dprintf(LOW,"placing it at position %d",i); */
+			queue[i] = oid;
 			requested--;
 			return(0);
 		}
-	if (queue_size==0) return(-1);  /*  already quit. */
+	if (queue_size == 0) return(-1);  /*  already quit. */
 	/*  if we reach here, all slots all taken.  */
-	/* 	s3dprintf(LOW,"no place for object, resizing stack.",i); */
-	queue=realloc(queue,sizeof(unsigned int)*(queue_size+1));
-	queue_size+=1;
+	/*  s3dprintf(LOW,"no place for object, resizing stack.",i); */
+	queue = realloc(queue, sizeof(unsigned int) * (queue_size + 1));
+	queue_size += 1;
 	requested--;
-	queue[queue_size-1]=oid;
+	queue[queue_size-1] = oid;
 	return(0);
 }
 /*  an object is requested!! give one out: */
 unsigned int _queue_want_object()
 {
 	unsigned int ret;
-	int i,j;
-	j=0;
+	int i, j;
+	j = 0;
 	do {
-		for (i=0;i<queue_size;i++)
-			if (queue[i]!=Q_UNUSED) {
-				ret=queue[i];
-				queue[i]=Q_UNUSED;
-				net_send(S3D_P_C_NEW_OBJ,NULL,0);  /*  we already can request a new one. */
+		for (i = 0;i < queue_size;i++)
+			if (queue[i] != Q_UNUSED) {
+				ret = queue[i];
+				queue[i] = Q_UNUSED;
+				net_send(S3D_P_C_NEW_OBJ, NULL, 0);  /*  we already can request a new one. */
 				return(ret);
 			}
 		/*  if we reach this point, our queue is empty. */
 		/*  as other request should have sent S3D_P_C_NEW_OBJ-requests,  */
 		/*  we request one more object than needed to satisfy more load in future. */
-		if (queue_size==0) return(-1);  /*  already quit. */
-		if (requested<MAX_REQ) {
-			net_send(S3D_P_C_NEW_OBJ,NULL,0);
+		if (queue_size == 0) return(-1);  /*  already quit. */
+		if (requested < MAX_REQ) {
+			net_send(S3D_P_C_NEW_OBJ, NULL, 0);
 			requested++;
 		}
 		s3d_net_check();
-		nanosleep(&t,NULL);
-	} while (j++<TIMEOUT);
+		nanosleep(&t, NULL);
+	} while (j++ < TIMEOUT);
 
-	errds(LOW,"_queue_want_object()","timeout is reached. server is extremly slow/laggy or dead");
+	errds(LOW, "_queue_want_object()", "timeout is reached. server is extremly slow/laggy or dead");
 	return(-1);
 }
 /*  cleans up */
 int _queue_quit()
 {
-	if (queue!=NULL) {
+	if (queue != NULL) {
 		free(queue);
-		queue=NULL;
+		queue = NULL;
 	}
-	queue_size=0;
+	queue_size = 0;
 	return(0);
 }

Modified: trunk/libs3d/proto_in.c
===================================================================
--- trunk/libs3d/proto_in.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/proto_in.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,135 +26,135 @@
 #include "s3dlib.h"
 #include <proto.h>
 #include <netinet/in.h>  /*  htons(),htonl() */
-#include <errno.h>		 /*  errno */
-#include <stdlib.h>		 /*  malloc(), free() */
+#include <errno.h>   /*  errno */
+#include <stdlib.h>   /*  malloc(), free() */
 /*  this proccesses the commands and pushes s3d-events, or does other things ;) */
 int net_prot_in(uint8_t opcode, uint16_t length, char *buf)
 {
-	uint32_t oid=-1;
-	struct s3d_evt *s3devt=NULL;
+	uint32_t oid = -1;
+	struct s3d_evt *s3devt = NULL;
 	struct mcp_object *mo;
 	struct s3d_obj_info *oi;
 	switch (opcode) {
 	case S3D_P_S_INIT:
-		s3dprintf(MED,"S3D_P_S_INIT: init!!");
-		_s3d_ready=1;
+		s3dprintf(MED, "S3D_P_S_INIT: init!!");
+		_s3d_ready = 1;
 		break;
 	case S3D_P_S_QUIT:
-		s3dprintf(MED,"S3D_P_S_QUIT: server wants us to go. well ...");
+		s3dprintf(MED, "S3D_P_S_QUIT: server wants us to go. well ...");
 		s3d_quit();
 		break;
 	case S3D_P_S_CLICK:
-		if (length==4) {
-			oid=ntohl(*((uint32_t *)buf));
-			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
-				*((uint32_t *)buf)=oid;  /*  reuse buffer ... */
-				s3devt->event=S3D_EVENT_OBJ_CLICK;
-				s3devt->length=4;
-				s3devt->buf=buf;
+		if (length == 4) {
+			oid = ntohl(*((uint32_t *)buf));
+			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {
+				*((uint32_t *)buf) = oid;  /*  reuse buffer ... */
+				s3devt->event = S3D_EVENT_OBJ_CLICK;
+				s3devt->length = 4;
+				s3devt->buf = buf;
 			}
-			s3dprintf(MED,"S3D_P_S_CLICK: %d got clicked ....",oid);
+			s3dprintf(MED, "S3D_P_S_CLICK: %d got clicked ....", oid);
 		}
 		break;
 	case S3D_P_S_NEWOBJ:
-		if (length==4) {
-			oid=ntohl(*((uint32_t *)buf));
+		if (length == 4) {
+			oid = ntohl(*((uint32_t *)buf));
 			_queue_new_object(oid);
 			/*
 			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt))))
 			{
-				*((uint32_t *)buf)=oid;  / *  reuse buffer ... * /
-				s3devt->event=S3D_EVENT_NEW_OBJECT;
-				s3devt->length=4;
-				s3devt->buf=buf;
-				_queue_new_object(*((unsigned int *)newevt->buf));
+			 *((uint32_t *)buf)=oid;  / *  reuse buffer ... * /
+			 s3devt->event=S3D_EVENT_NEW_OBJECT;
+			 s3devt->length=4;
+			 s3devt->buf=buf;
+			 _queue_new_object(*((unsigned int *)newevt->buf));
 			}*/
-			s3dprintf(VLOW,"S3D_P_S_NEWOBJ: new object %d",oid);
+			s3dprintf(VLOW, "S3D_P_S_NEWOBJ: new object %d", oid);
 		}
 		break;
 	case S3D_P_S_KEY:
-		if (length==8) {
-			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
+		if (length == 8) {
+			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {
 				struct s3d_key_event *keyevent;
-				s3devt->length=2;
-				keyevent=(struct s3d_key_event *)buf;
-				keyevent->keysym=ntohs(keyevent->keysym);
-				keyevent->unicode=ntohs(keyevent->unicode);
-				keyevent->modifier=ntohs(keyevent->modifier);
-				keyevent->state=ntohs(keyevent->state);
-				s3devt->buf=buf;
-				s3devt->event=(keyevent->state==0)?S3D_EVENT_KEYDOWN:S3D_EVENT_KEYUP;
+				s3devt->length = 2;
+				keyevent = (struct s3d_key_event *)buf;
+				keyevent->keysym = ntohs(keyevent->keysym);
+				keyevent->unicode = ntohs(keyevent->unicode);
+				keyevent->modifier = ntohs(keyevent->modifier);
+				keyevent->state = ntohs(keyevent->state);
+				s3devt->buf = buf;
+				s3devt->event = (keyevent->state == 0) ? S3D_EVENT_KEYDOWN : S3D_EVENT_KEYUP;
 			}
-			s3dprintf(VLOW,"S3D_P_S_KEY: key %d hit!!",*((uint16_t *)s3devt->buf));
+			s3dprintf(VLOW, "S3D_P_S_KEY: key %d hit!!", *((uint16_t *)s3devt->buf));
 		}
 		break;
 	case S3D_P_S_MBUTTON:
-		if (length==2) {
-			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
-				s3devt->event=S3D_EVENT_MBUTTON;
-				s3devt->length=2;
-				s3devt->buf=buf;
+		if (length == 2) {
+			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {
+				s3devt->event = S3D_EVENT_MBUTTON;
+				s3devt->length = 2;
+				s3devt->buf = buf;
 			}
-			s3dprintf(VLOW,"S3D_P_S_MBUTTON: mbutton %d, state %d !!",*((uint8_t *)s3devt->buf), *(1+(uint8_t *)s3devt->buf));
+			s3dprintf(VLOW, "S3D_P_S_MBUTTON: mbutton %d, state %d !!", *((uint8_t *)s3devt->buf), *(1 + (uint8_t *)s3devt->buf));
 		}
 		break;
 	case S3D_P_MCP_OBJECT:
-		if (length==sizeof(struct mcp_object)) {
-			/* 				oid=htonl(*((uint32_t *)buf)); */
-			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
-				/* 					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
-				s3devt->event=S3D_MCP_OBJECT;
-				s3devt->length=length;
-				mo=(struct mcp_object *)buf;
-				*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
+		if (length == sizeof(struct mcp_object)) {
+			/*     oid=htonl(*((uint32_t *)buf)); */
+			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {
+				/*      *((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
+				s3devt->event = S3D_MCP_OBJECT;
+				s3devt->length = length;
+				mo = (struct mcp_object *)buf;
+				*((uint32_t *)buf) = ntohl(*((uint32_t *)buf));  /*  revert oid */
 
-				buf[length-1]='\0';  /*  put a null byte at the end  */
+				buf[length-1] = '\0';  /*  put a null byte at the end  */
 				/*  for the not so careful users */
-				s3devt->buf=buf;
-				s3dprintf(VLOW,"S3D_P_MCP_OBEJCT: something is happening to object %d, name %s", 	mo->object, mo->name);
+				s3devt->buf = buf;
+				s3dprintf(VLOW, "S3D_P_MCP_OBEJCT: something is happening to object %d, name %s",  mo->object, mo->name);
 
 			}
-		} else s3dprintf(MED,"wrong length for S3D_P_MCP_OBJECT length %d != %d",length,sizeof(struct mcp_object));
+		} else s3dprintf(MED, "wrong length for S3D_P_MCP_OBJECT length %d != %d", length, sizeof(struct mcp_object));
 		break;
 	case S3D_P_S_OINFO:
-		if (length==sizeof(struct s3d_obj_info)) {
-			/* 				oid=htonl(*((uint32_t *)buf)); */
-			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
-				/* 					*((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
-				s3devt->event=S3D_EVENT_OBJ_INFO;
-				s3devt->length=length;
-				oi=(struct s3d_obj_info *)buf;
-				oi->object	=ntohl(oi->object);
-				oi->flags	=ntohl(oi->flags);
+		if (length == sizeof(struct s3d_obj_info)) {
+			/*     oid=htonl(*((uint32_t *)buf)); */
+			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {
+				/*      *((uint32_t *)buf)=oid;  / *  reuse buffer ... * / */
+				s3devt->event = S3D_EVENT_OBJ_INFO;
+				s3devt->length = length;
+				oi = (struct s3d_obj_info *)buf;
+				oi->object = ntohl(oi->object);
+				oi->flags = ntohl(oi->flags);
 
-				buf[length-1]='\0';  /*  put a null byte at the end  */
+				buf[length-1] = '\0';  /*  put a null byte at the end  */
 				/*  for the not so careful users */
-				s3devt->buf=buf;
-				s3dprintf(VLOW,"S3D_P_S_OINFO: something is happening to object %d, name %s",
+				s3devt->buf = buf;
+				s3dprintf(VLOW, "S3D_P_S_OINFO: something is happening to object %d, name %s",
 				          oi->object,
 				          oi->name
 				         );
 
 			}
-		} else s3dprintf(MED,"wrong length for S3D_P_S_OINFO length %d != %d",length,sizeof(struct s3d_obj_info));
+		} else s3dprintf(MED, "wrong length for S3D_P_S_OINFO length %d != %d", length, sizeof(struct s3d_obj_info));
 		break;
 
 	case S3D_P_MCP_DEL_OBJECT:
-		if (length==4) {
-			if (NULL!=(s3devt=malloc(sizeof(struct s3d_evt)))) {
-				s3devt->event=S3D_MCP_DEL_OBJECT;
-				s3devt->length=length;
-				*((uint32_t *)buf)=ntohl(*((uint32_t *)buf));  /*  revert oid */
-				s3dprintf(MED,"S3D_P_MCP_DEL_OBEJCT: deleting object %d",*((uint32_t *)buf));
-				s3devt->buf=buf;
+		if (length == 4) {
+			if (NULL != (s3devt = malloc(sizeof(struct s3d_evt)))) {
+				s3devt->event = S3D_MCP_DEL_OBJECT;
+				s3devt->length = length;
+				*((uint32_t *)buf) = ntohl(*((uint32_t *)buf));  /*  revert oid */
+				s3dprintf(MED, "S3D_P_MCP_DEL_OBEJCT: deleting object %d", *((uint32_t *)buf));
+				s3devt->buf = buf;
 			}
 		}
 		break;
 	default:
-		s3dprintf(MED,"don't know command %d",opcode);
-		if (buf!=NULL) free(buf);
+		s3dprintf(MED, "don't know command %d", opcode);
+		if (buf != NULL) free(buf);
 	}
-	if (s3devt!=NULL) {
+	if (s3devt != NULL) {
 
 		s3d_push_event(s3devt);
 	}

Modified: trunk/libs3d/proto_out.c
===================================================================
--- trunk/libs3d/proto_out.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/proto_out.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,25 +25,25 @@
 #include "s3d.h"
 #include "s3dlib.h"
 #include <proto.h>
-#include <string.h> 	 /*  memset(),strncpy(),strncmp(),memcpy() */
-#include <errno.h>		 /*  errno */
+#include <string.h>   /*  memset(),strncpy(),strncmp(),memcpy() */
+#include <errno.h>   /*  errno */
 #include <netinet/in.h>  /*  htons(),htonl() */
-#include <unistd.h>		 /*  select() */
-#include <stdlib.h>		 /*  getenv(),atoi(), malloc() */
+#include <unistd.h>   /*  select() */
+#include <stdlib.h>   /*  getenv(),atoi(), malloc() */
 #ifdef WIN32
 #define uint32_t uint32_t  /*  sohn */
 #else
-#include <netdb.h>		 /*  gethostbyname()  */
+#include <netdb.h>   /*  gethostbyname()  */
 #endif
 
-#define MF_LEN	65530	 /*  maximum fragmentation length */
+#define MF_LEN 65530  /*  maximum fragmentation length */
 /*  creates a new object */
 int s3d_new_object()
 {
 	int oid;
 
 	cb_lock++; /* please, no callbacks now. */
-	oid=_queue_want_object();
+	oid = _queue_want_object();
 	cb_lock--; /* no new callbacks and nothing happened */
 	return(oid);
 }
@@ -51,8 +51,8 @@
 int s3d_clone(int oid)
 {
 	uint32_t res;
-	res=s3d_new_object();
-	s3d_clone_target(res,oid);
+	res = s3d_new_object();
+	s3d_clone_target(res, oid);
 	return(res);
 }
 
@@ -60,17 +60,17 @@
 int s3d_clone_target(int oid, int toid)
 {
 	uint32_t buf[2];
-	buf[0]=htonl(oid);
-	buf[1]=htonl(toid);
-	net_send(S3D_P_C_CLONE,(char *)&buf,8);
-	/* 	s3dprintf(MED,"... changed clone-target of object %d to %d", oid, toid); */
+	buf[0] = htonl(oid);
+	buf[1] = htonl(toid);
+	net_send(S3D_P_C_CLONE, (char *)&buf, 8);
+	/*  s3dprintf(MED,"... changed clone-target of object %d to %d", oid, toid); */
 	return oid;
 }
 /*  deletes an object */
 int s3d_del_object(int oid)
 {
-	uint32_t res=htonl(oid);
-	net_send(S3D_P_C_DEL_OBJ,(char *)&res,4);
+	uint32_t res = htonl(oid);
+	net_send(S3D_P_C_DEL_OBJ, (char *)&res, 4);
 	return oid;
 }
 /*  creates a link from object oid_from to object oid_to in order to copy */
@@ -78,17 +78,17 @@
 int s3d_link(int oid_from, int oid_to)
 {
 	uint32_t buf[2];
-	buf[0]=htonl(oid_from);
-	buf[1]=htonl(oid_to);
-	net_send(S3D_P_C_LINK,(char *)buf,8);
+	buf[0] = htonl(oid_from);
+	buf[1] = htonl(oid_to);
+	net_send(S3D_P_C_LINK, (char *)buf, 8);
 	return(0);
 }
 /*  remove the link to another object */
 int s3d_unlink(int oid)
 {
 	uint32_t buf;
-	buf=htonl(oid);
-	net_send(S3D_P_C_LINK,(char *)&buf,4);
+	buf = htonl(oid);
+	net_send(S3D_P_C_LINK, (char *)&buf, 4);
 	return(0);
 }
 /*  pushing functions */
@@ -96,18 +96,18 @@
 /*  has float always the same size? i'm not quite sure ... */
 int s3d_push_vertex(int object, float x, float y, float z)
 {
-	char				buf[4+3*4],*ptr;
-	int					len=4+3*4;
+	char    buf[4+3*4], *ptr;
+	int     len = 4 + 3 * 4;
 
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=x;
-	ptr+=sizeof(float);
-	*((float *)ptr)=y;
-	ptr+=sizeof(float);
-	*((float *)ptr)=z;
-	ptr+=sizeof(float);
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((float *)ptr) = x;
+	ptr += sizeof(float);
+	*((float *)ptr) = y;
+	ptr += sizeof(float);
+	*((float *)ptr) = z;
+	ptr += sizeof(float);
 	net_send(S3D_P_C_PUSH_VERTEX, buf, len);
 	return(0);
 }
@@ -115,173 +115,173 @@
 /*  it's to be used for file readers or fast coders :) */
 int s3d_push_vertices(int object, float *vbuf, uint16_t n)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int					f,i,len=n*4*3;
-	int					flen,stepl;
-	if (n<1)
+	char    buf[MF_LEN+4], *ptr;
+	int     f, i, len = n * 4 * 3;
+	int     flen, stepl;
+	if (n < 1)
 		return(-1);
-	stepl=((int)((MF_LEN-4)/(4*3)))*(4*3);
-	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
-	/* 	buf=malloc(f>1?MF_LEN:len+4); */
-	for (i=0;i<f;i++) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		if (len-i*stepl>stepl)
-			flen=stepl;
+	stepl = ((int)((MF_LEN - 4) / (4 * 3))) * (4 * 3);
+	f = len / (MF_LEN - 4) + 1;  /*  how many fragments? */
+	/*  buf=malloc(f>1?MF_LEN:len+4); */
+	for (i = 0;i < f;i++) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		if (len - i*stepl > stepl)
+			flen = stepl;
 		else
-			flen=(len-i*stepl);
-		memcpy(ptr,(char *)vbuf+i*stepl,flen);
-		net_send(S3D_P_C_PUSH_VERTEX,buf,flen+4);
+			flen = (len - i * stepl);
+		memcpy(ptr, (char *)vbuf + i*stepl, flen);
+		net_send(S3D_P_C_PUSH_VERTEX, buf, flen + 4);
 	}
-	/* 	free(buf); */
+	/*  free(buf); */
 	return(0);
 }
 
 /*  pushes a new material onto the stack */
 /*  a vectored version of this would be wise ... */
-int s3d_push_material( int object,
-                       float amb_r, float amb_g, float amb_b,
-                       float spec_r, float spec_g, float spec_b,
-                       float diff_r, float diff_g, float diff_b
+int s3d_push_material(int object,
+                      float amb_r, float amb_g, float amb_b,
+                      float spec_r, float spec_g, float spec_b,
+                      float diff_r, float diff_g, float diff_b
                      )
 {
-	char				buf[4+4*12];
-	char				*ptr;
-	int					len=4+4*12;
-	/* 	s3dprintf(LOW, "adding a new material..."); */
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=1.0;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=1.0;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=1.0;
-	ptr+=sizeof(float);
+	char    buf[4+4*12];
+	char    *ptr;
+	int     len = 4 + 4 * 12;
+	/*  s3dprintf(LOW, "adding a new material..."); */
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((float *)ptr) = amb_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = 1.0;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = 1.0;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = 1.0;
+	ptr += sizeof(float);
 
-	net_send(S3D_P_C_PUSH_MAT,buf,len);
+	net_send(S3D_P_C_PUSH_MAT, buf, len);
 	return(0);  /*  nothing yet */
 }
 /*  same as s3d_push_material, but with values for alpha */
-int s3d_push_material_a( int object,
-                         float amb_r, float amb_g, float amb_b, float amb_a,
-                         float spec_r, float spec_g, float spec_b, float spec_a,
-                         float diff_r, float diff_g, float diff_b, float diff_a
+int s3d_push_material_a(int object,
+                        float amb_r, float amb_g, float amb_b, float amb_a,
+                        float spec_r, float spec_g, float spec_b, float spec_a,
+                        float diff_r, float diff_g, float diff_b, float diff_a
                        )
 {
-	char				buf[4+4*12];
-	char				*ptr;
-	int					len=4+4*12;
-	/* 	s3dprintf(LOW, "adding a new material..."); */
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_a;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_a;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_a;
-	ptr+=sizeof(float);
+	char    buf[4+4*12];
+	char    *ptr;
+	int     len = 4 + 4 * 12;
+	/*  s3dprintf(LOW, "adding a new material..."); */
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((float *)ptr) = amb_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_a;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_a;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_a;
+	ptr += sizeof(float);
 
-	net_send(S3D_P_C_PUSH_MAT,buf,len);
+	net_send(S3D_P_C_PUSH_MAT, buf, len);
 	return(0);  /*  nothing yet */
 }
 /*  push a material array (with alpha information!) */
 int s3d_push_materials_a(int object, float *mbuf, uint16_t n)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int					f,i,len=n*4*12;
-	int					flen,stepl;
-	if (n<1)
+	char    buf[MF_LEN+4], *ptr;
+	int     f, i, len = n * 4 * 12;
+	int     flen, stepl;
+	if (n < 1)
 		return(-1);
-	stepl=((int)((MF_LEN-4)/(4*12)))*(4*12);
-	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
-	/* 	buf=malloc(f>1?MF_LEN:len+4); */
-	for (i=0;i<f;i++) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		if (len-i*stepl>stepl)
-			flen=stepl;
+	stepl = ((int)((MF_LEN - 4) / (4 * 12))) * (4 * 12);
+	f = len / (MF_LEN - 4) + 1;  /*  how many fragments? */
+	/*  buf=malloc(f>1?MF_LEN:len+4); */
+	for (i = 0;i < f;i++) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		if (len - i*stepl > stepl)
+			flen = stepl;
 		else
-			flen=(len-i*stepl);
-		memcpy(ptr,(char *)mbuf+i*stepl,flen);
-		net_send(S3D_P_C_PUSH_MAT,buf,flen+4);
+			flen = (len - i * stepl);
+		memcpy(ptr, (char *)mbuf + i*stepl, flen);
+		net_send(S3D_P_C_PUSH_MAT, buf, flen + 4);
 	}
-	/* 	free(buf); */
+	/*  free(buf); */
 	return(0);
 }
 int s3d_push_polygon(int object, uint32_t v1, uint32_t v2, uint32_t v3, uint32_t material)
 {
-	char				buf[4+4*4],*ptr;
-	int					len=4+4*4;
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(v1);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v2);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v3);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(material);
-	ptr+=sizeof(uint32_t);
+	char    buf[4+4*4], *ptr;
+	int     len = 4 + 4 * 4;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((uint32_t *)ptr) = htonl(v1);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(v2);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(v3);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(material);
+	ptr += sizeof(uint32_t);
 
-	net_send(S3D_P_C_PUSH_POLY,buf,len);
+	net_send(S3D_P_C_PUSH_POLY, buf, len);
 	return(0);
 }
 int s3d_push_line(int object, uint32_t v1, uint32_t v2, uint32_t material)
 {
-	char				buf[4+3*4],*ptr;
-	int					len=4+3*4;
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(v1);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v2);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(material);
-	ptr+=sizeof(uint32_t);
+	char    buf[4+3*4], *ptr;
+	int     len = 4 + 3 * 4;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((uint32_t *)ptr) = htonl(v1);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(v2);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(material);
+	ptr += sizeof(uint32_t);
 
-	net_send(S3D_P_C_PUSH_LINE,buf,len);
+	net_send(S3D_P_C_PUSH_LINE, buf, len);
 	return(0);
 }
 
@@ -289,91 +289,91 @@
 /*  assumes to have a list of polys which consists of v1,v2,v3,material */
 int s3d_push_polygons(int object, uint32_t *pbuf, uint16_t n)
 {
-	uint32_t		buf[(MF_LEN+4)/4];
-	uint32_t		*s,*d;
-	int					f,i,j,len=n*4*4;
-	int					flen,stepl;
-	if (n<1)
+	uint32_t  buf[(MF_LEN+4)/4];
+	uint32_t  *s, *d;
+	int     f, i, j, len = n * 4 * 4;
+	int     flen, stepl;
+	if (n < 1)
 		return(-1);
-	stepl=((int)((MF_LEN-4)/(4*4)))*(4*4);
-	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
+	stepl = ((int)((MF_LEN - 4) / (4 * 4))) * (4 * 4);
+	f = len / (MF_LEN - 4) + 1;  /*  how many fragments? */
 
-	buf[0]=htonl(object);
-	d=buf+1;
-	for (i=0;i<f;i++) {
-		if (len-i*stepl>stepl)			flen=stepl;
-		else							flen=(len-i*stepl);
+	buf[0] = htonl(object);
+	d = buf + 1;
+	for (i = 0;i < f;i++) {
+		if (len - i*stepl > stepl)   flen = stepl;
+		else       flen = (len - i * stepl);
 
-		s=pbuf+i*stepl/4;
-		for (j=0;j<flen/4;j++)
-			d[j]=htonl(s[j]);
-		net_send(S3D_P_C_PUSH_POLY,(char *)buf,flen+4);
+		s = pbuf + i * stepl / 4;
+		for (j = 0;j < flen / 4;j++)
+			d[j] = htonl(s[j]);
+		net_send(S3D_P_C_PUSH_POLY, (char *)buf, flen + 4);
 	}
 	return(0);
 }
 int s3d_push_lines(int object, uint32_t *lbuf, uint16_t n)
 {
-	uint32_t		buf[(MF_LEN+4)/4];
-	uint32_t		*s,*d;
-	int					f,i,j,len=n*4*3;
-	int					flen,stepl;
-	if (n<1)
+	uint32_t  buf[(MF_LEN+4)/4];
+	uint32_t  *s, *d;
+	int     f, i, j, len = n * 4 * 3;
+	int     flen, stepl;
+	if (n < 1)
 		return(-1);
-	stepl=((int)((MF_LEN-4)/(4*3)))*(4*3);
-	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
+	stepl = ((int)((MF_LEN - 4) / (4 * 3))) * (4 * 3);
+	f = len / (MF_LEN - 4) + 1;  /*  how many fragments? */
 
-	buf[0]=htonl(object);
-	d=buf+1;
+	buf[0] = htonl(object);
+	d = buf + 1;
 
-	for (i=0;i<f;i++) {
-		if (len-i*stepl>stepl)			flen=stepl;
-		else							flen=(len-i*stepl);
+	for (i = 0;i < f;i++) {
+		if (len - i*stepl > stepl)   flen = stepl;
+		else       flen = (len - i * stepl);
 
-		s=lbuf+i*stepl/4;
-		for (j=0;j<flen/4;j++)
-			d[j]=htonl(s[j]);
+		s = lbuf + i * stepl / 4;
+		for (j = 0;j < flen / 4;j++)
+			d[j] = htonl(s[j]);
 
-		net_send(S3D_P_C_PUSH_LINE,(char *)buf,flen+4);
+		net_send(S3D_P_C_PUSH_LINE, (char *)buf, flen + 4);
 	}
 	return(0);
 }
 int s3d_push_texture(int object, uint16_t w, uint16_t h)
 {
-	char				buf[4+2*2],*ptr;
-	int					len=4+2*2;
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint16_t *)ptr)=htons(w);
-	ptr+=sizeof(uint16_t);
-	*((uint16_t *)ptr)=htons(h);
+	char    buf[4+2*2], *ptr;
+	int     len = 4 + 2 * 2;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((uint16_t *)ptr) = htons(w);
+	ptr += sizeof(uint16_t);
+	*((uint16_t *)ptr) = htons(h);
 
-	net_send(S3D_P_C_PUSH_TEX,buf,len);
+	net_send(S3D_P_C_PUSH_TEX, buf, len);
 	return(0);
 }
 int s3d_push_textures(int object, uint16_t *tbuf, uint16_t n)
 {
-	uint32_t		buf[(MF_LEN+4)/4];
-	uint16_t		*s,*d;
+	uint32_t  buf[(MF_LEN+4)/4];
+	uint16_t  *s, *d;
 
-	int					f,i,j,len=n*2*2;
-	int					flen,stepl;
-	if (n<1)
+	int     f, i, j, len = n * 2 * 2;
+	int     flen, stepl;
+	if (n < 1)
 		return(-1);
-	stepl=((int)((MF_LEN-4)/(2*2)))*(2*2);
-	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
+	stepl = ((int)((MF_LEN - 4) / (2 * 2))) * (2 * 2);
+	f = len / (MF_LEN - 4) + 1;  /*  how many fragments? */
 
-	*((uint32_t *)buf)=htonl(object);
-	d=(uint16_t *)(buf+1);
+	*((uint32_t *)buf) = htonl(object);
+	d = (uint16_t *)(buf + 1);
 
-	for (i=0;i<f;i++) {
-		if (len-i*stepl>stepl)			flen=stepl;
-		else							flen=(len-i*stepl);
+	for (i = 0;i < f;i++) {
+		if (len - i*stepl > stepl)   flen = stepl;
+		else       flen = (len - i * stepl);
 
-		s=tbuf+i*stepl/2;
-		for (j=0;j<flen/2;j++)
-			d[j]=htons(s[j]);
-		net_send(S3D_P_C_PUSH_POLY,(char *)buf,flen+4);
+		s = tbuf + i * stepl / 2;
+		for (j = 0;j < flen / 2;j++)
+			d[j] = htons(s[j]);
+		net_send(S3D_P_C_PUSH_POLY, (char *)buf, flen + 4);
 	}
 	return(0);
 }
@@ -382,516 +382,516 @@
 /*  delete n vertices */
 int s3d_pop_vertex(int object, uint32_t n)
 {
-	uint32_t		buf[2];
-	buf[0]=htonl(object);
-	buf[1]=htonl(n);
-	net_send(S3D_P_C_DEL_VERTEX,(char *)buf,4*2);
+	uint32_t  buf[2];
+	buf[0] = htonl(object);
+	buf[1] = htonl(n);
+	net_send(S3D_P_C_DEL_VERTEX, (char *)buf, 4*2);
 	return(0);
 
 }
 /*  delete n materials */
 int s3d_pop_material(int object, uint32_t n)
 {
-	uint32_t		buf[2];
-	buf[0]=htonl(object);
-	buf[1]=htonl(n);
-	net_send(S3D_P_C_DEL_MAT,(char *)buf,4*2);
+	uint32_t  buf[2];
+	buf[0] = htonl(object);
+	buf[1] = htonl(n);
+	net_send(S3D_P_C_DEL_MAT, (char *)buf, 4*2);
 	return(0);
 
 }
 /*  delete n polygons */
 int s3d_pop_polygon(int object, uint32_t n)
 {
-	uint32_t		buf[2];
-	buf[0]=htonl(object);
-	buf[1]=htonl(n);
-	net_send(S3D_P_C_DEL_POLY,(char *)buf,4*2);
+	uint32_t  buf[2];
+	buf[0] = htonl(object);
+	buf[1] = htonl(n);
+	net_send(S3D_P_C_DEL_POLY, (char *)buf, 4*2);
 	return(0);
 
 }
 /*  delete n lines */
 int s3d_pop_line(int object, uint32_t n)
 {
-	uint32_t		buf[2];
-	buf[0]=htonl(object);
-	buf[1]=htonl(n);
-	net_send(S3D_P_C_DEL_LINE,(char *)buf,4*2);
+	uint32_t  buf[2];
+	buf[0] = htonl(object);
+	buf[1] = htonl(n);
+	net_send(S3D_P_C_DEL_LINE, (char *)buf, 4*2);
 	return(0);
 
 }
 /*  delete n polygons */
 int s3d_pop_texture(int object, uint32_t n)
 {
-	uint32_t		buf[2];
-	buf[0]=htonl(object);
-	buf[1]=htonl(n);
-	net_send(S3D_P_C_DEL_TEX,(char *)buf,4*2);
+	uint32_t  buf[2];
+	buf[0] = htonl(object);
+	buf[1] = htonl(n);
+	net_send(S3D_P_C_DEL_TEX, (char *)buf, 4*2);
 	return(0);
 
 }
 /*  pepping/loading functions */
 
 /*  overwrites the last material with this one */
-int s3d_pep_material( int object,
-                      float amb_r, float amb_g, float amb_b,
-                      float spec_r, float spec_g, float spec_b,
-                      float diff_r, float diff_g, float diff_b
+int s3d_pep_material(int object,
+                     float amb_r, float amb_g, float amb_b,
+                     float spec_r, float spec_g, float spec_b,
+                     float diff_r, float diff_g, float diff_b
                     )
 {
-	char				buf[4+4*12];
-	char				*ptr;
-	int					len=4+4*12;
-	/* 	s3dprintf(LOW, "adding a new material..."); */
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=1.0;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=1.0;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=1.0;
-	ptr+=sizeof(float);
+	char    buf[4+4*12];
+	char    *ptr;
+	int     len = 4 + 4 * 12;
+	/*  s3dprintf(LOW, "adding a new material..."); */
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((float *)ptr) = amb_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = 1.0;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = 1.0;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = 1.0;
+	ptr += sizeof(float);
 
-	net_send(S3D_P_C_PEP_MAT,buf,len);
+	net_send(S3D_P_C_PEP_MAT, buf, len);
 	return(0);  /*  nothing yet */
 }
 /*  same as above, with alpha */
-int s3d_pep_material_a( int object,
-                        float amb_r, float amb_g, float amb_b, float amb_a,
-                        float spec_r, float spec_g, float spec_b, float spec_a,
-                        float diff_r, float diff_g, float diff_b, float diff_a
+int s3d_pep_material_a(int object,
+                       float amb_r, float amb_g, float amb_b, float amb_a,
+                       float spec_r, float spec_g, float spec_b, float spec_a,
+                       float diff_r, float diff_g, float diff_b, float diff_a
                       )
 {
-	char				buf[4+4*12];
-	char				*ptr;
-	int					len=4+4*12;
-	/* 	s3dprintf(LOW, "adding a new material..."); */
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=amb_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=amb_a;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=spec_a;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_r;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_g;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_b;
-	ptr+=sizeof(float);
-	*((float *)ptr)=diff_a;
-	ptr+=sizeof(float);
+	char    buf[4+4*12];
+	char    *ptr;
+	int     len = 4 + 4 * 12;
+	/*  s3dprintf(LOW, "adding a new material..."); */
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((float *)ptr) = amb_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = amb_a;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = spec_a;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_r;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_g;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_b;
+	ptr += sizeof(float);
+	*((float *)ptr) = diff_a;
+	ptr += sizeof(float);
 
-	net_send(S3D_P_C_PEP_MAT,buf,len);
+	net_send(S3D_P_C_PEP_MAT, buf, len);
 	return(0);  /*  nothing yet */
 }
 int s3d_pep_materials_a(int object, float *mbuf, uint16_t n)
 {
-	char				buf[MF_LEN+4];
-	if ((n*12*sizeof(float)+4)>MF_LEN) {
-		errds(MED,"s3d_pep_materials_a()","too much data");
+	char    buf[MF_LEN+4];
+	if ((n*12*sizeof(float) + 4) > MF_LEN) {
+		errds(MED, "s3d_pep_materials_a()", "too much data");
 		return(-1);  /*  impossible */
 	}
-	*((uint32_t *)buf)=htonl(object);			 /*  object id */
-	memcpy(buf+4,mbuf,12*n*sizeof(float));
-	net_send(S3D_P_C_PEP_MAT,buf,n*12*sizeof(float)+4);
+	*((uint32_t *)buf) = htonl(object);  /*  object id */
+	memcpy(buf + 4, mbuf, 12*n*sizeof(float));
+	net_send(S3D_P_C_PEP_MAT, buf, n*12*sizeof(float) + 4);
 	return(0);
 }
 
 /*  adds normal information to the last n polygons. */
-int s3d_pep_polygon_normals(int object, float *nbuf,uint16_t n)
+int s3d_pep_polygon_normals(int object, float *nbuf, uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
-	if ((n*9*sizeof(float)+4)>MF_LEN) {
-		errds(MED,"s3d_pep_polygon_normals()","too much data");
+	if ((n*9*sizeof(float) + 4) > MF_LEN) {
+		errds(MED, "s3d_pep_polygon_normals()", "too much data");
 		return(-1);  /*  impossible */
 	}
-	*((uint32_t *)buf)=htonl(object);
-	memcpy(buf+4,nbuf,9*n*sizeof(float));
-	net_send(S3D_P_C_PEP_POLY_NORMAL,(char *)buf,n*9*sizeof(float)+4);
+	*((uint32_t *)buf) = htonl(object);
+	memcpy(buf + 4, nbuf, 9*n*sizeof(float));
+	net_send(S3D_P_C_PEP_POLY_NORMAL, (char *)buf, n*9*sizeof(float) + 4);
 	return(0);
 
 }
 /*  adds normal information to the last n line. */
-int s3d_pep_line_normals(int object, float *nbuf,uint16_t n)
+int s3d_pep_line_normals(int object, float *nbuf, uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
-	if ((n*9*sizeof(float)+4)>MF_LEN) {
-		errds(MED,"s3d_pep_line_normals()","too much data");
+	if ((n*9*sizeof(float) + 4) > MF_LEN) {
+		errds(MED, "s3d_pep_line_normals()", "too much data");
 		return(-1);  /*  impossible */
 	}
-	*((uint32_t *)buf)=htonl(object);
-	memcpy(buf+4,nbuf,6*n*sizeof(float));
-	net_send(S3D_P_C_PEP_LINE_NORMAL,(char *)buf,n*6*sizeof(float)+4);
+	*((uint32_t *)buf) = htonl(object);
+	memcpy(buf + 4, nbuf, 6*n*sizeof(float));
+	net_send(S3D_P_C_PEP_LINE_NORMAL, (char *)buf, n*6*sizeof(float) + 4);
 	return(0);
 
 }
 /*  replaces the last vertex. */
 int s3d_pep_vertex(int object, float x, float y, float z)
 {
-	char				buf[4+3*4],*ptr;
-	int					len=4+3*4;
+	char    buf[4+3*4], *ptr;
+	int     len = 4 + 3 * 4;
 
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((float *)ptr)=x;
-	ptr+=sizeof(float);
-	*((float *)ptr)=y;
-	ptr+=sizeof(float);
-	*((float *)ptr)=z;
-	ptr+=sizeof(float);
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((float *)ptr) = x;
+	ptr += sizeof(float);
+	*((float *)ptr) = y;
+	ptr += sizeof(float);
+	*((float *)ptr) = z;
+	ptr += sizeof(float);
 	net_send(S3D_P_C_PEP_VERTEX, buf, len);
 	return(0);
 }
 /* replaces the last line */
 int s3d_pep_line(int object, int v1, int v2, int material)
 {
-	char				buf[4+3*4],*ptr;
-	int					len=4+3*4;
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(v1);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(v2);
-	ptr+=sizeof(uint32_t);
-	*((uint32_t *)ptr)=htonl(material);
-	ptr+=sizeof(uint32_t);
+	char    buf[4+3*4], *ptr;
+	int     len = 4 + 3 * 4;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((uint32_t *)ptr) = htonl(v1);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(v2);
+	ptr += sizeof(uint32_t);
+	*((uint32_t *)ptr) = htonl(material);
+	ptr += sizeof(uint32_t);
 
-	net_send(S3D_P_C_PEP_LINE,buf,len);
+	net_send(S3D_P_C_PEP_LINE, buf, len);
 	return(0);
 }
 
 
 /*  replaces the last n lines. */
-int s3d_pep_lines(int object, uint32_t *lbuf,uint16_t n)
+int s3d_pep_lines(int object, uint32_t *lbuf, uint16_t n)
 {
-	uint32_t 	buf[MF_LEN+4];
-	int				i;
-	if ((n*3*4+4)>MF_LEN) {
-		errds(MED,"s3d_pep_lines()","too much data");
+	uint32_t  buf[MF_LEN+4];
+	int    i;
+	if ((n*3*4 + 4) > MF_LEN) {
+		errds(MED, "s3d_pep_lines()", "too much data");
 		return(-1);  /*  impossible */
 	}
-	buf[0]=htonl(object);
-	for (i=0;i<3*n;i++)
-		buf[i+1]=htonl(lbuf[0]);
-	net_send(S3D_P_C_PEP_LINE, (char *)buf,n*3*4+4);
+	buf[0] = htonl(object);
+	for (i = 0;i < 3*n;i++)
+		buf[i+1] = htonl(lbuf[0]);
+	net_send(S3D_P_C_PEP_LINE, (char *)buf, n*3*4 + 4);
 	return(0);
 
 }
 /*  replaces the last n vertices. */
-int s3d_pep_vertices(int object, float *vbuf,uint16_t n)
+int s3d_pep_vertices(int object, float *vbuf, uint16_t n)
 {
 	uint8_t buf[MF_LEN+4];
-	if ((n*3*sizeof(float)+4)>MF_LEN) {
-		errds(MED,"s3d_pep_vertices()","too much data");
+	if ((n*3*sizeof(float) + 4) > MF_LEN) {
+		errds(MED, "s3d_pep_vertices()", "too much data");
 		return(-1);  /*  impossible */
 	}
-	*((uint32_t *)buf)=htonl(object);
-	memcpy(buf+4,vbuf,3*n*sizeof(float));
-	net_send(S3D_P_C_PEP_VERTEX,(char *)buf,n*3*sizeof(float)+4);
+	*((uint32_t *)buf) = htonl(object);
+	memcpy(buf + 4, vbuf, 3*n*sizeof(float));
+	net_send(S3D_P_C_PEP_VERTEX, (char *)buf, n*3*sizeof(float) + 4);
 	return(0);
 
 }
 /*  peps the last polygon with some texture coords */
 int s3d_pep_polygon_tex_coord(int object, float x1, float y1, float x2, float y2, float x3, float y3)
 {
-	char *ptr,buf[4*6+4];
-	ptr=buf;
-	*((uint32_t *)buf)=htonl(object);
-	ptr+=4;
-	*((float *)ptr)=x1;
-	ptr+=4;
-	*((float *)ptr)=y1;
-	ptr+=4;
-	*((float *)ptr)=x2;
-	ptr+=4;
-	*((float *)ptr)=y2;
-	ptr+=4;
-	*((float *)ptr)=x3;
-	ptr+=4;
-	*((float *)ptr)=y3;
-	ptr+=4;
-	net_send(S3D_P_C_PEP_POLY_TEXC,(char *)buf,6*4+4);
+	char *ptr, buf[4*6+4];
+	ptr = buf;
+	*((uint32_t *)buf) = htonl(object);
+	ptr += 4;
+	*((float *)ptr) = x1;
+	ptr += 4;
+	*((float *)ptr) = y1;
+	ptr += 4;
+	*((float *)ptr) = x2;
+	ptr += 4;
+	*((float *)ptr) = y2;
+	ptr += 4;
+	*((float *)ptr) = x3;
+	ptr += 4;
+	*((float *)ptr) = y3;
+	ptr += 4;
+	net_send(S3D_P_C_PEP_POLY_TEXC, (char *)buf, 6*4 + 4);
 	return(0);
 }
 /*  adds texture coordinates to the last n polygons. */
-int s3d_pep_polygon_tex_coords(int object, float *tbuf,uint16_t n)
+int s3d_pep_polygon_tex_coords(int object, float *tbuf, uint16_t n)
 {
 	char buf[MF_LEN+4];
-	if ((n*6*sizeof(float))>MF_LEN) {
-		errds(MED,"s3d_pep_polygon_tex_coords()","too much data");
+	if ((n*6*sizeof(float)) > MF_LEN) {
+		errds(MED, "s3d_pep_polygon_tex_coords()", "too much data");
 		return(-1);  /*  impossible */
 	}
-	*((uint32_t *)buf)=htonl(object);
-	memcpy(buf+4,tbuf,6*n*sizeof(float));
-	net_send(S3D_P_C_PEP_POLY_TEXC,(char *)buf,n*6*sizeof(float)+4);
+	*((uint32_t *)buf) = htonl(object);
+	memcpy(buf + 4, tbuf, 6*n*sizeof(float));
+	net_send(S3D_P_C_PEP_POLY_TEXC, (char *)buf, n*6*sizeof(float) + 4);
 	return(0);
 }
 /*  adds normal information to the last n polygons. */
-int s3d_load_polygon_normals(int object, float *nbuf,uint32_t start, uint16_t n)
+int s3d_load_polygon_normals(int object, float *nbuf, uint32_t start, uint16_t n)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int					f,i,len=n*9*4;
-	int					flen,stepl;
-	uint32_t			mstart;
-	if (n<1)
+	char    buf[MF_LEN+4], *ptr;
+	int     f, i, len = n * 9 * 4;
+	int     flen, stepl;
+	uint32_t   mstart;
+	if (n < 1)
 		return(-1);
-	mstart=start;
-	stepl=((int)((MF_LEN-8)/(9*4)))*(9*4);
-	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i<f;i++) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);
-		ptr+=sizeof(uint32_t);		  /*  start */
-		if (len-i*stepl>stepl)
-			flen=stepl;
+	mstart = start;
+	stepl = ((int)((MF_LEN - 8) / (9 * 4))) * (9 * 4);
+	f = len / (MF_LEN - 8) + 1;  /*  how many fragments? */
+	for (i = 0;i < f;i++) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		*((uint32_t *)ptr) = htonl(mstart);
+		ptr += sizeof(uint32_t);  /*  start */
+		if (len - i*stepl > stepl)
+			flen = stepl;
 		else
-			flen=(len-i*stepl);
-		memcpy(ptr,(char *)nbuf+i*stepl,flen);
-		net_send(S3D_P_C_PEP_POLY_NORMAL,buf,flen+8);
-		mstart+=stepl;
+			flen = (len - i * stepl);
+		memcpy(ptr, (char *)nbuf + i*stepl, flen);
+		net_send(S3D_P_C_PEP_POLY_NORMAL, buf, flen + 8);
+		mstart += stepl;
 	}
 	return(0);
 }
 /*  adds normal information to the last n polygons. */
-int s3d_load_line_normals(int object, float *nbuf,uint32_t start, uint16_t n)
+int s3d_load_line_normals(int object, float *nbuf, uint32_t start, uint16_t n)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int					f,i,len=n*6*4;
-	int					flen,stepl;
-	uint32_t			mstart;
-	if (n<1)
+	char    buf[MF_LEN+4], *ptr;
+	int     f, i, len = n * 6 * 4;
+	int     flen, stepl;
+	uint32_t   mstart;
+	if (n < 1)
 		return(-1);
-	mstart=start;
-	stepl=((int)((MF_LEN-8)/(6*4)))*(6*4);
-	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i<f;i++) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);
-		ptr+=sizeof(uint32_t);		  /*  start */
-		if (len-i*stepl>stepl)
-			flen=stepl;
+	mstart = start;
+	stepl = ((int)((MF_LEN - 8) / (6 * 4))) * (6 * 4);
+	f = len / (MF_LEN - 8) + 1;  /*  how many fragments? */
+	for (i = 0;i < f;i++) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		*((uint32_t *)ptr) = htonl(mstart);
+		ptr += sizeof(uint32_t);  /*  start */
+		if (len - i*stepl > stepl)
+			flen = stepl;
 		else
-			flen=(len-i*stepl);
-		memcpy(ptr,(char *)nbuf+i*stepl,flen);
-		net_send(S3D_P_C_PEP_LINE_NORMAL,buf,flen+8);
-		mstart+=stepl;
+			flen = (len - i * stepl);
+		memcpy(ptr, (char *)nbuf + i*stepl, flen);
+		net_send(S3D_P_C_PEP_LINE_NORMAL, buf, flen + 8);
+		mstart += stepl;
 	}
 	return(0);
 }
 /*  adds texture coordinates to the last n polygons. */
 int s3d_load_polygon_tex_coords(int object, float *tbuf, uint32_t start, uint16_t n)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int					f,i,len=n*6*4;
-	int					flen,stepl;
-	uint32_t			mstart;
-	if (n<1)
+	char    buf[MF_LEN+4], *ptr;
+	int     f, i, len = n * 6 * 4;
+	int     flen, stepl;
+	uint32_t   mstart;
+	if (n < 1)
 		return(-1);
-	mstart=start;
-	stepl=((int)((MF_LEN-8)/(6*4)))*(6*4);
-	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i<f;i++) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);
-		ptr+=sizeof(uint32_t);		  /*  start */
-		if (len-i*stepl>stepl)
-			flen=stepl;
+	mstart = start;
+	stepl = ((int)((MF_LEN - 8) / (6 * 4))) * (6 * 4);
+	f = len / (MF_LEN - 8) + 1;  /*  how many fragments? */
+	for (i = 0;i < f;i++) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		*((uint32_t *)ptr) = htonl(mstart);
+		ptr += sizeof(uint32_t);  /*  start */
+		if (len - i*stepl > stepl)
+			flen = stepl;
 		else
-			flen=(len-i*stepl);
-		memcpy(ptr,(char *)tbuf+i*stepl,flen);
-		net_send(S3D_P_C_PEP_POLY_TEXC,buf,flen+8);
-		mstart+=stepl;
+			flen = (len - i * stepl);
+		memcpy(ptr, (char *)tbuf + i*stepl, flen);
+		net_send(S3D_P_C_PEP_POLY_TEXC, buf, flen + 8);
+		mstart += stepl;
 	}
 	return(0);
 }
 /*  load n materials at position start, overwriting old ones */
 int s3d_load_materials_a(int object, float *mbuf, uint32_t start, uint16_t n)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int					f,i,len=n*12*4;
-	int					flen,stepl;
-	uint32_t			mstart;
-	if (n<1)
+	char    buf[MF_LEN+4], *ptr;
+	int     f, i, len = n * 12 * 4;
+	int     flen, stepl;
+	uint32_t   mstart;
+	if (n < 1)
 		return(-1);
-	mstart=start;
-	stepl=((int)((MF_LEN-8)/(12*4)))*(12*4);
-	f=len/(MF_LEN-8)+1;  /*  how many fragments? */
-	for (i=0;i<f;i++) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(mstart);
-		ptr+=sizeof(uint32_t);		  /*  start */
-		if (len-i*stepl>stepl)
-			flen=stepl;
+	mstart = start;
+	stepl = ((int)((MF_LEN - 8) / (12 * 4))) * (12 * 4);
+	f = len / (MF_LEN - 8) + 1;  /*  how many fragments? */
+	for (i = 0;i < f;i++) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		*((uint32_t *)ptr) = htonl(mstart);
+		ptr += sizeof(uint32_t);  /*  start */
+		if (len - i*stepl > stepl)
+			flen = stepl;
 		else
-			flen=(len-i*stepl);
-		memcpy(ptr,(char *)mbuf+i*stepl,flen);
-		net_send(S3D_P_C_PEP_MAT,buf,flen+8);
-		mstart+=stepl;
+			flen = (len - i * stepl);
+		memcpy(ptr, (char *)mbuf + i*stepl, flen);
+		net_send(S3D_P_C_PEP_MAT, buf, flen + 8);
+		mstart += stepl;
 	}
 	return(0);
 }
 int s3d_pep_material_texture(int object, uint32_t tex)
 {
-	char				buf[4*2],*ptr;
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=sizeof(uint32_t);		  /*  object id */
-	*((uint32_t *)ptr)=htonl(tex);
-	ptr+=sizeof(uint32_t);		 	 /*  texture index numer */
-	net_send(S3D_P_C_PEP_MAT_TEX,buf,8);
+	char    buf[4*2], *ptr;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += sizeof(uint32_t);  /*  object id */
+	*((uint32_t *)ptr) = htonl(tex);
+	ptr += sizeof(uint32_t);   /*  texture index numer */
+	net_send(S3D_P_C_PEP_MAT_TEX, buf, 8);
 	return(0);
 }
 /*  load data (which has width w and height h) into object, texture tex at position (xpos,ypos) */
 int s3d_load_texture(int object, uint32_t tex, uint16_t xpos, uint16_t ypos, uint16_t w, uint16_t h, uint8_t *data)
 {
-	char				buf[MF_LEN+4],*ptr;
-	int 				linestep,lines,i;
-	linestep=(MF_LEN-16)/(w*4);
-	if (linestep==0)
+	char    buf[MF_LEN+4], *ptr;
+	int     linestep, lines, i;
+	linestep = (MF_LEN - 16) / (w * 4);
+	if (linestep == 0)
 		return(-1);  /*  won't do that. .. yet */
-	for (i=0;i<h;i+=linestep) {
-		ptr=buf;
-		*((uint32_t *)ptr)=htonl(object);
-		ptr+=sizeof(uint32_t);		  /*  object id */
-		*((uint32_t *)ptr)=htonl(tex);
-		ptr+=sizeof(uint32_t);		  /*  texture number */
-		*((uint16_t *)ptr)=htons(xpos);
-		ptr+=sizeof(uint16_t);		  /*  xpos */
-		*((uint16_t *)ptr)=htons(ypos+i);
-		ptr+=sizeof(uint16_t);		  /*  ypos */
-		*((uint16_t *)ptr)=htons(w);
-		ptr+=sizeof(uint16_t);		  /*  width */
-		if ((h-i)>linestep)		lines=linestep;
-		else					lines=h-i;
-		*((uint16_t *)ptr)=htons(lines);
-		ptr+=sizeof(uint16_t);		  /*  height */
-		memcpy(ptr,data+(i*w*4),lines*w*4);
-		net_send(S3D_P_C_LOAD_TEX,buf,16+lines*w*4);
+	for (i = 0;i < h;i += linestep) {
+		ptr = buf;
+		*((uint32_t *)ptr) = htonl(object);
+		ptr += sizeof(uint32_t);  /*  object id */
+		*((uint32_t *)ptr) = htonl(tex);
+		ptr += sizeof(uint32_t);  /*  texture number */
+		*((uint16_t *)ptr) = htons(xpos);
+		ptr += sizeof(uint16_t);  /*  xpos */
+		*((uint16_t *)ptr) = htons(ypos + i);
+		ptr += sizeof(uint16_t);  /*  ypos */
+		*((uint16_t *)ptr) = htons(w);
+		ptr += sizeof(uint16_t);  /*  width */
+		if ((h - i) > linestep)  lines = linestep;
+		else     lines = h - i;
+		*((uint16_t *)ptr) = htons(lines);
+		ptr += sizeof(uint16_t);  /*  height */
+		memcpy(ptr, data + (i*w*4), lines*w*4);
+		net_send(S3D_P_C_LOAD_TEX, buf, 16 + lines*w*4);
 	}
 	return(0);
 }
 int s3d_flags_on(int object, uint32_t flags)
 {
-	char				buf[4+1+4],*ptr;
-	int					len=4+1+4;
-	ptr=buf;
-	/* 	s3dprintf(VLOW, "toggling flags on .. %010x", flags); */
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=4;
-	*ptr=OF_TURN_ON;
-	ptr+=1;
-	*((uint32_t *)ptr)=htonl(flags);
-	ptr+=4;
-	net_send(S3D_P_C_TOGGLE_FLAGS,buf,len);
+	char    buf[4+1+4], *ptr;
+	int     len = 4 + 1 + 4;
+	ptr = buf;
+	/*  s3dprintf(VLOW, "toggling flags on .. %010x", flags); */
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += 4;
+	*ptr = OF_TURN_ON;
+	ptr += 1;
+	*((uint32_t *)ptr) = htonl(flags);
+	ptr += 4;
+	net_send(S3D_P_C_TOGGLE_FLAGS, buf, len);
 	return(0);
 }
 int s3d_flags_off(int object, uint32_t flags)
 {
-	char				buf[4+1+4],*ptr;
-	int					len=4+1+4;
-	ptr=buf;
-	/* 	s3dprintf(VLOW, "toggling flags off .. %010x", flags); */
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=4;
-	*ptr=OF_TURN_OFF;
-	ptr+=1;
-	*((uint32_t *)ptr)=htonl(flags);
-	ptr+=4;
-	net_send(S3D_P_C_TOGGLE_FLAGS,buf,len);
+	char    buf[4+1+4], *ptr;
+	int     len = 4 + 1 + 4;
+	ptr = buf;
+	/*  s3dprintf(VLOW, "toggling flags off .. %010x", flags); */
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += 4;
+	*ptr = OF_TURN_OFF;
+	ptr += 1;
+	*((uint32_t *)ptr) = htonl(flags);
+	ptr += 4;
+	net_send(S3D_P_C_TOGGLE_FLAGS, buf, len);
 	return(0);
 }
 int s3d_translate(int object, float x, float y, float z)
 {
-	char				buf[4+4*3],*ptr;
-	int					len=4+4*3;
-	ptr=buf;
-	/* 	s3dprintf(VLOW, "translating object to  .. %f, %f, %f", x,y,z); */
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=4;
-	*((float *)ptr)=x;
-	ptr+=4;
-	*((float *)ptr)=y;
-	ptr+=4;
-	*((float *)ptr)=z;
-	net_send(S3D_P_C_TRANSLATE,buf,len);
+	char    buf[4+4*3], *ptr;
+	int     len = 4 + 4 * 3;
+	ptr = buf;
+	/*  s3dprintf(VLOW, "translating object to  .. %f, %f, %f", x,y,z); */
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += 4;
+	*((float *)ptr) = x;
+	ptr += 4;
+	*((float *)ptr) = y;
+	ptr += 4;
+	*((float *)ptr) = z;
+	net_send(S3D_P_C_TRANSLATE, buf, len);
 	return(0);
 
 }
 /*  rotation about the x-axis, y-axis and z-axis */
 int s3d_rotate(int object, float x, float y, float z)
 {
-	char				buf[4+4*3],*ptr;
-	int					len=4+4*3;
-	ptr=buf;
-	/* 	s3dprintf(VLOW, "rotating object to  .. %f, %f, %f", x,y,z); */
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=4;
-	*((float *)ptr)=x;
-	ptr+=4;
-	*((float *)ptr)=y;
-	ptr+=4;
-	*((float *)ptr)=z;
-	net_send(S3D_P_C_ROTATE,buf,len);
+	char    buf[4+4*3], *ptr;
+	int     len = 4 + 4 * 3;
+	ptr = buf;
+	/*  s3dprintf(VLOW, "rotating object to  .. %f, %f, %f", x,y,z); */
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += 4;
+	*((float *)ptr) = x;
+	ptr += 4;
+	*((float *)ptr) = y;
+	ptr += 4;
+	*((float *)ptr) = z;
+	net_send(S3D_P_C_ROTATE, buf, len);
 	return(0);
 }
 /*  scale the object .. */
 
 int s3d_scale(int object, float s)
 {
-	char				buf[4+4],*ptr;
-	int					len=4+4;
-	ptr=buf;
-	*((uint32_t *)ptr)=htonl(object);
-	ptr+=4;
-	*((float *)ptr)=s;
-	net_send(S3D_P_C_SCALE,buf,len);
+	char    buf[4+4], *ptr;
+	int     len = 4 + 4;
+	ptr = buf;
+	*((uint32_t *)ptr) = htonl(object);
+	ptr += 4;
+	*((float *)ptr) = s;
+	net_send(S3D_P_C_SCALE, buf, len);
 	return(0);
 }
 /*  sets the focused app through it's mcp object number */
 int s3d_mcp_focus(int object)
 {
-	uint32_t buf=htonl(object);
-	net_send(S3D_P_MCP_FOCUS,(char *)&buf,4);
+	uint32_t buf = htonl(object);
+	net_send(S3D_P_MCP_FOCUS, (char *)&buf, 4);
 	return(0);
 }

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/s3d.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -34,37 +34,37 @@
 
 typedef int (*s3d_cb)(struct s3d_evt *);
 
-#define S3D_EVENT_OBJ_CLICK		1
-#define S3D_EVENT_KEY			2
-#define S3D_EVENT_KEYDOWN		2
-#define S3D_EVENT_MBUTTON		3
-#define S3D_EVENT_KEYUP			4
-#define S3D_EVENT_NEW_OBJECT	16
-#define S3D_EVENT_OBJ_INFO		17
+#define S3D_EVENT_OBJ_CLICK  1
+#define S3D_EVENT_KEY   2
+#define S3D_EVENT_KEYDOWN  2
+#define S3D_EVENT_MBUTTON  3
+#define S3D_EVENT_KEYUP   4
+#define S3D_EVENT_NEW_OBJECT 16
+#define S3D_EVENT_OBJ_INFO  17
 
-#define S3D_EVENT_QUIT			255
+#define S3D_EVENT_QUIT   255
 
 /* TODO: don't keep _MCP_ events .. they're ugly */
-#define S3D_MCP_OBJECT			32
-#define S3D_MCP_DEL_OBJECT		33
+#define S3D_MCP_OBJECT   32
+#define S3D_MCP_DEL_OBJECT  33
 
-#define S3D_PORT				6066
+#define S3D_PORT    6066
 
-#define	S3D_OF_VISIBLE			0x00000001
-#define	S3D_OF_SELECTABLE		0x00000002
-#define S3D_OF_POINTABLE		0x00000004
+#define S3D_OF_VISIBLE   0x00000001
+#define S3D_OF_SELECTABLE  0x00000002
+#define S3D_OF_POINTABLE  0x00000004
 struct mcp_object {
 	uint32_t object;
-	float trans_x,trans_y,trans_z;
+	float trans_x, trans_y, trans_z;
 	float r;
-#define MCP_NEW_OBJECT	1
+#define MCP_NEW_OBJECT 1
 	char name[256];
 };
 struct s3d_obj_info {
 	uint32_t object;
 	uint32_t flags;
-	float trans_x,trans_y,trans_z;
-	float rot_x,rot_y,rot_z;
+	float trans_x, trans_y, trans_z;
+	float rot_x, rot_y, rot_z;
 	float scale;
 	float r;
 	char name[256];
@@ -74,10 +74,10 @@
 	uint8_t state;  /* 0 = down, 1 = up, 2 = moving */
 };
 struct s3d_key_event {
-	uint16_t keysym;		/* the symbol, use this with s3d_keysym.h */
-	uint16_t unicode;		/* the unicode or "actually typed" character */
-	uint16_t modifier;	/* any modifiers involved */
-	uint16_t state;		/* 0 = pressed, 1 = released */
+	uint16_t keysym;  /* the symbol, use this with s3d_keysym.h */
+	uint16_t unicode;  /* the unicode or "actually typed" character */
+	uint16_t modifier; /* any modifiers involved */
+	uint16_t state;  /* 0 = pressed, 1 = released */
 };
 
 /* framework functions */
@@ -92,23 +92,23 @@
 /* object manipulations */
 int s3d_push_vertex(int object, float x, float y, float z);
 int s3d_push_vertices(int object, float *vbuf, uint16_t n);
-int s3d_push_material( int object,
-                       float amb_r, float amb_g, float amb_b,
-                       float spec_r, float spec_g, float spec_b,
-                       float diff_r, float diff_g, float diff_b);
-int s3d_pep_material( int object,
+int s3d_push_material(int object,
                       float amb_r, float amb_g, float amb_b,
                       float spec_r, float spec_g, float spec_b,
                       float diff_r, float diff_g, float diff_b);
-int s3d_push_material_a( int object,
-                         float amb_r, float amb_g, float amb_b, float amb_a,
-                         float spec_r, float spec_g, float spec_b, float spec_a,
-                         float diff_r, float diff_g, float diff_b, float diff_a);
-int s3d_push_materials_a(int object, float *mbuf, uint16_t n);
-int s3d_pep_material_a( int object,
+int s3d_pep_material(int object,
+                     float amb_r, float amb_g, float amb_b,
+                     float spec_r, float spec_g, float spec_b,
+                     float diff_r, float diff_g, float diff_b);
+int s3d_push_material_a(int object,
                         float amb_r, float amb_g, float amb_b, float amb_a,
                         float spec_r, float spec_g, float spec_b, float spec_a,
                         float diff_r, float diff_g, float diff_b, float diff_a);
+int s3d_push_materials_a(int object, float *mbuf, uint16_t n);
+int s3d_pep_material_a(int object,
+                       float amb_r, float amb_g, float amb_b, float amb_a,
+                       float spec_r, float spec_g, float spec_b, float spec_a,
+                       float diff_r, float diff_g, float diff_b, float diff_a);
 
 int s3d_pep_materials_a(int object, float *mbuf, uint16_t n);
 int s3d_load_materials_a(int object, float *mbuf, uint32_t start, uint16_t n);
@@ -124,17 +124,17 @@
 int s3d_pop_texture(int object, uint32_t n);
 int s3d_pop_polygon(int object, uint32_t n);
 int s3d_pop_line(int object, uint32_t n);
-int s3d_pep_line_normals(int object, float *nbuf,uint16_t n);
-int s3d_pep_polygon_normals(int object, float *nbuf,uint16_t n);
+int s3d_pep_line_normals(int object, float *nbuf, uint16_t n);
+int s3d_pep_polygon_normals(int object, float *nbuf, uint16_t n);
 int s3d_pep_polygon_tex_coord(int object, float x1, float y1, float x2, float y2, float x3, float y3);
-int s3d_pep_polygon_tex_coords(int object, float *tbuf,uint16_t n);
+int s3d_pep_polygon_tex_coords(int object, float *tbuf, uint16_t n);
 int s3d_pep_material_texture(int object, uint32_t tex);
 int s3d_pep_vertex(int object, float x, float y, float z);
-int s3d_pep_vertices(int object, float *vbuf,uint16_t n);
+int s3d_pep_vertices(int object, float *vbuf, uint16_t n);
 int s3d_pep_line(int object, int v1, int v2, int material);
-int s3d_pep_lines(int object, uint32_t *lbuf,uint16_t n);
-int s3d_load_line_normals(int object, float *nbuf,uint32_t start, uint16_t n);
-int s3d_load_polygon_normals(int object, float *nbuf,uint32_t start, uint16_t n);
+int s3d_pep_lines(int object, uint32_t *lbuf, uint16_t n);
+int s3d_load_line_normals(int object, float *nbuf, uint32_t start, uint16_t n);
+int s3d_load_polygon_normals(int object, float *nbuf, uint32_t start, uint16_t n);
 int s3d_load_polygon_tex_coords(int object, float *tbuf, uint32_t start, uint16_t n);
 int s3d_load_texture(int object, uint32_t tex, uint16_t xpos, uint16_t ypos, uint16_t w, uint16_t h, uint8_t *data);
 
@@ -157,17 +157,17 @@
 int s3d_import_model_file(char *fname);
 int s3d_open_file(char *fname, char **pointer);
 int s3d_select_font(char *mask);
-int s3d_draw_string( char *str, float *xlen);
-float s3d_strlen( char *str);
+int s3d_draw_string(char *str, float *xlen);
+float s3d_strlen(char *str);
 
 /* some vector calculation helpers */
 
-float s3d_vector_length( float vector[] );
-float s3d_vector_dot_product( float vector1[], float vector2[] );
-void s3d_vector_subtract( float vector1[], float vector2[], float result_vector[] );
-float s3d_vector_angle( float vector1[], float vector2[] );
-float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad );
-void s3d_vector_cross_product( float vector1[], float vector2[], float result_vector[] );
+float s3d_vector_length(float vector[]);
+float s3d_vector_dot_product(float vector1[], float vector2[]);
+void s3d_vector_subtract(float vector1[], float vector2[], float result_vector[]);
+float s3d_vector_angle(float vector1[], float vector2[]);
+float s3d_angle_to_cam(float obj_pos[], float cam_pos[], float *angle_rad);
+void s3d_vector_cross_product(float vector1[], float vector2[], float result_vector[]);
 
 /* event handlers */
 void s3d_push_event(struct s3d_evt *newevt);

Modified: trunk/libs3d/s3d_keysym.h
===================================================================
--- trunk/libs3d/s3d_keysym.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/s3d_keysym.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -35,255 +35,255 @@
 
 typedef enum {
 	/* The keyboard syms have been cleverly chosen to map to ASCII */
-	S3DK_UNKNOWN		= 0,
-	S3DK_FIRST		= 0,
-	S3DK_BACKSPACE		= 8,
-	S3DK_TAB		= 9,
-	S3DK_CLEAR		= 12,
-	S3DK_RETURN		= 13,
-	S3DK_PAUSE		= 19,
-	S3DK_ESCAPE		= 27,
-	S3DK_SPACE		= 32,
-	S3DK_EXCLAIM		= 33,
-	S3DK_QUOTEDBL		= 34,
-	S3DK_HASH		= 35,
-	S3DK_DOLLAR		= 36,
-	S3DK_AMPERSAND		= 38,
-	S3DK_QUOTE		= 39,
-	S3DK_LEFTPAREN		= 40,
-	S3DK_RIGHTPAREN		= 41,
-	S3DK_ASTERISK		= 42,
-	S3DK_PLUS		= 43,
-	S3DK_COMMA		= 44,
-	S3DK_MINUS		= 45,
-	S3DK_PERIOD		= 46,
-	S3DK_SLASH		= 47,
-	S3DK_0			= 48,
-	S3DK_1			= 49,
-	S3DK_2			= 50,
-	S3DK_3			= 51,
-	S3DK_4			= 52,
-	S3DK_5			= 53,
-	S3DK_6			= 54,
-	S3DK_7			= 55,
-	S3DK_8			= 56,
-	S3DK_9			= 57,
-	S3DK_COLON		= 58,
-	S3DK_SEMICOLON		= 59,
-	S3DK_LESS		= 60,
-	S3DK_EQUALS		= 61,
-	S3DK_GREATER		= 62,
-	S3DK_QUESTION		= 63,
-	S3DK_AT			= 64,
+	S3DK_UNKNOWN  = 0,
+	S3DK_FIRST  = 0,
+	S3DK_BACKSPACE  = 8,
+	S3DK_TAB  = 9,
+	S3DK_CLEAR  = 12,
+	S3DK_RETURN  = 13,
+	S3DK_PAUSE  = 19,
+	S3DK_ESCAPE  = 27,
+	S3DK_SPACE  = 32,
+	S3DK_EXCLAIM  = 33,
+	S3DK_QUOTEDBL  = 34,
+	S3DK_HASH  = 35,
+	S3DK_DOLLAR  = 36,
+	S3DK_AMPERSAND  = 38,
+	S3DK_QUOTE  = 39,
+	S3DK_LEFTPAREN  = 40,
+	S3DK_RIGHTPAREN  = 41,
+	S3DK_ASTERISK  = 42,
+	S3DK_PLUS  = 43,
+	S3DK_COMMA  = 44,
+	S3DK_MINUS  = 45,
+	S3DK_PERIOD  = 46,
+	S3DK_SLASH  = 47,
+	S3DK_0   = 48,
+	S3DK_1   = 49,
+	S3DK_2   = 50,
+	S3DK_3   = 51,
+	S3DK_4   = 52,
+	S3DK_5   = 53,
+	S3DK_6   = 54,
+	S3DK_7   = 55,
+	S3DK_8   = 56,
+	S3DK_9   = 57,
+	S3DK_COLON  = 58,
+	S3DK_SEMICOLON  = 59,
+	S3DK_LESS  = 60,
+	S3DK_EQUALS  = 61,
+	S3DK_GREATER  = 62,
+	S3DK_QUESTION  = 63,
+	S3DK_AT   = 64,
 	/*
 	   Skip uppercase letters
 	 */
-	S3DK_LEFTBRACKET	= 91,
-	S3DK_BACKSLASH		= 92,
-	S3DK_RIGHTBRACKET	= 93,
-	S3DK_CARET		= 94,
-	S3DK_UNDERSCORE		= 95,
-	S3DK_BACKQUOTE		= 96,
-	S3DK_a			= 97,
-	S3DK_b			= 98,
-	S3DK_c			= 99,
-	S3DK_d			= 100,
-	S3DK_e			= 101,
-	S3DK_f			= 102,
-	S3DK_g			= 103,
-	S3DK_h			= 104,
-	S3DK_i			= 105,
-	S3DK_j			= 106,
-	S3DK_k			= 107,
-	S3DK_l			= 108,
-	S3DK_m			= 109,
-	S3DK_n			= 110,
-	S3DK_o			= 111,
-	S3DK_p			= 112,
-	S3DK_q			= 113,
-	S3DK_r			= 114,
-	S3DK_s			= 115,
-	S3DK_t			= 116,
-	S3DK_u			= 117,
-	S3DK_v			= 118,
-	S3DK_w			= 119,
-	S3DK_x			= 120,
-	S3DK_y			= 121,
-	S3DK_z			= 122,
-	S3DK_DELETE		= 127,
+	S3DK_LEFTBRACKET = 91,
+	S3DK_BACKSLASH  = 92,
+	S3DK_RIGHTBRACKET = 93,
+	S3DK_CARET  = 94,
+	S3DK_UNDERSCORE  = 95,
+	S3DK_BACKQUOTE  = 96,
+	S3DK_a   = 97,
+	S3DK_b   = 98,
+	S3DK_c   = 99,
+	S3DK_d   = 100,
+	S3DK_e   = 101,
+	S3DK_f   = 102,
+	S3DK_g   = 103,
+	S3DK_h   = 104,
+	S3DK_i   = 105,
+	S3DK_j   = 106,
+	S3DK_k   = 107,
+	S3DK_l   = 108,
+	S3DK_m   = 109,
+	S3DK_n   = 110,
+	S3DK_o   = 111,
+	S3DK_p   = 112,
+	S3DK_q   = 113,
+	S3DK_r   = 114,
+	S3DK_s   = 115,
+	S3DK_t   = 116,
+	S3DK_u   = 117,
+	S3DK_v   = 118,
+	S3DK_w   = 119,
+	S3DK_x   = 120,
+	S3DK_y   = 121,
+	S3DK_z   = 122,
+	S3DK_DELETE  = 127,
 	/* End of ASCII mapped keysyms */
 
 	/* International keyboard syms */
-	S3DK_WORLD_0		= 160,		/* 0xA0 */
-	S3DK_WORLD_1		= 161,
-	S3DK_WORLD_2		= 162,
-	S3DK_WORLD_3		= 163,
-	S3DK_WORLD_4		= 164,
-	S3DK_WORLD_5		= 165,
-	S3DK_WORLD_6		= 166,
-	S3DK_WORLD_7		= 167,
-	S3DK_WORLD_8		= 168,
-	S3DK_WORLD_9		= 169,
-	S3DK_WORLD_10		= 170,
-	S3DK_WORLD_11		= 171,
-	S3DK_WORLD_12		= 172,
-	S3DK_WORLD_13		= 173,
-	S3DK_WORLD_14		= 174,
-	S3DK_WORLD_15		= 175,
-	S3DK_WORLD_16		= 176,
-	S3DK_WORLD_17		= 177,
-	S3DK_WORLD_18		= 178,
-	S3DK_WORLD_19		= 179,
-	S3DK_WORLD_20		= 180,
-	S3DK_WORLD_21		= 181,
-	S3DK_WORLD_22		= 182,
-	S3DK_WORLD_23		= 183,
-	S3DK_WORLD_24		= 184,
-	S3DK_WORLD_25		= 185,
-	S3DK_WORLD_26		= 186,
-	S3DK_WORLD_27		= 187,
-	S3DK_WORLD_28		= 188,
-	S3DK_WORLD_29		= 189,
-	S3DK_WORLD_30		= 190,
-	S3DK_WORLD_31		= 191,
-	S3DK_WORLD_32		= 192,
-	S3DK_WORLD_33		= 193,
-	S3DK_WORLD_34		= 194,
-	S3DK_WORLD_35		= 195,
-	S3DK_WORLD_36		= 196,
-	S3DK_WORLD_37		= 197,
-	S3DK_WORLD_38		= 198,
-	S3DK_WORLD_39		= 199,
-	S3DK_WORLD_40		= 200,
-	S3DK_WORLD_41		= 201,
-	S3DK_WORLD_42		= 202,
-	S3DK_WORLD_43		= 203,
-	S3DK_WORLD_44		= 204,
-	S3DK_WORLD_45		= 205,
-	S3DK_WORLD_46		= 206,
-	S3DK_WORLD_47		= 207,
-	S3DK_WORLD_48		= 208,
-	S3DK_WORLD_49		= 209,
-	S3DK_WORLD_50		= 210,
-	S3DK_WORLD_51		= 211,
-	S3DK_WORLD_52		= 212,
-	S3DK_WORLD_53		= 213,
-	S3DK_WORLD_54		= 214,
-	S3DK_WORLD_55		= 215,
-	S3DK_WORLD_56		= 216,
-	S3DK_WORLD_57		= 217,
-	S3DK_WORLD_58		= 218,
-	S3DK_WORLD_59		= 219,
-	S3DK_WORLD_60		= 220,
-	S3DK_WORLD_61		= 221,
-	S3DK_WORLD_62		= 222,
-	S3DK_WORLD_63		= 223,
-	S3DK_WORLD_64		= 224,
-	S3DK_WORLD_65		= 225,
-	S3DK_WORLD_66		= 226,
-	S3DK_WORLD_67		= 227,
-	S3DK_WORLD_68		= 228,
-	S3DK_WORLD_69		= 229,
-	S3DK_WORLD_70		= 230,
-	S3DK_WORLD_71		= 231,
-	S3DK_WORLD_72		= 232,
-	S3DK_WORLD_73		= 233,
-	S3DK_WORLD_74		= 234,
-	S3DK_WORLD_75		= 235,
-	S3DK_WORLD_76		= 236,
-	S3DK_WORLD_77		= 237,
-	S3DK_WORLD_78		= 238,
-	S3DK_WORLD_79		= 239,
-	S3DK_WORLD_80		= 240,
-	S3DK_WORLD_81		= 241,
-	S3DK_WORLD_82		= 242,
-	S3DK_WORLD_83		= 243,
-	S3DK_WORLD_84		= 244,
-	S3DK_WORLD_85		= 245,
-	S3DK_WORLD_86		= 246,
-	S3DK_WORLD_87		= 247,
-	S3DK_WORLD_88		= 248,
-	S3DK_WORLD_89		= 249,
-	S3DK_WORLD_90		= 250,
-	S3DK_WORLD_91		= 251,
-	S3DK_WORLD_92		= 252,
-	S3DK_WORLD_93		= 253,
-	S3DK_WORLD_94		= 254,
-	S3DK_WORLD_95		= 255,		/* 0xFF */
+	S3DK_WORLD_0  = 160,  /* 0xA0 */
+	S3DK_WORLD_1  = 161,
+	S3DK_WORLD_2  = 162,
+	S3DK_WORLD_3  = 163,
+	S3DK_WORLD_4  = 164,
+	S3DK_WORLD_5  = 165,
+	S3DK_WORLD_6  = 166,
+	S3DK_WORLD_7  = 167,
+	S3DK_WORLD_8  = 168,
+	S3DK_WORLD_9  = 169,
+	S3DK_WORLD_10  = 170,
+	S3DK_WORLD_11  = 171,
+	S3DK_WORLD_12  = 172,
+	S3DK_WORLD_13  = 173,
+	S3DK_WORLD_14  = 174,
+	S3DK_WORLD_15  = 175,
+	S3DK_WORLD_16  = 176,
+	S3DK_WORLD_17  = 177,
+	S3DK_WORLD_18  = 178,
+	S3DK_WORLD_19  = 179,
+	S3DK_WORLD_20  = 180,
+	S3DK_WORLD_21  = 181,
+	S3DK_WORLD_22  = 182,
+	S3DK_WORLD_23  = 183,
+	S3DK_WORLD_24  = 184,
+	S3DK_WORLD_25  = 185,
+	S3DK_WORLD_26  = 186,
+	S3DK_WORLD_27  = 187,
+	S3DK_WORLD_28  = 188,
+	S3DK_WORLD_29  = 189,
+	S3DK_WORLD_30  = 190,
+	S3DK_WORLD_31  = 191,
+	S3DK_WORLD_32  = 192,
+	S3DK_WORLD_33  = 193,
+	S3DK_WORLD_34  = 194,
+	S3DK_WORLD_35  = 195,
+	S3DK_WORLD_36  = 196,
+	S3DK_WORLD_37  = 197,
+	S3DK_WORLD_38  = 198,
+	S3DK_WORLD_39  = 199,
+	S3DK_WORLD_40  = 200,
+	S3DK_WORLD_41  = 201,
+	S3DK_WORLD_42  = 202,
+	S3DK_WORLD_43  = 203,
+	S3DK_WORLD_44  = 204,
+	S3DK_WORLD_45  = 205,
+	S3DK_WORLD_46  = 206,
+	S3DK_WORLD_47  = 207,
+	S3DK_WORLD_48  = 208,
+	S3DK_WORLD_49  = 209,
+	S3DK_WORLD_50  = 210,
+	S3DK_WORLD_51  = 211,
+	S3DK_WORLD_52  = 212,
+	S3DK_WORLD_53  = 213,
+	S3DK_WORLD_54  = 214,
+	S3DK_WORLD_55  = 215,
+	S3DK_WORLD_56  = 216,
+	S3DK_WORLD_57  = 217,
+	S3DK_WORLD_58  = 218,
+	S3DK_WORLD_59  = 219,
+	S3DK_WORLD_60  = 220,
+	S3DK_WORLD_61  = 221,
+	S3DK_WORLD_62  = 222,
+	S3DK_WORLD_63  = 223,
+	S3DK_WORLD_64  = 224,
+	S3DK_WORLD_65  = 225,
+	S3DK_WORLD_66  = 226,
+	S3DK_WORLD_67  = 227,
+	S3DK_WORLD_68  = 228,
+	S3DK_WORLD_69  = 229,
+	S3DK_WORLD_70  = 230,
+	S3DK_WORLD_71  = 231,
+	S3DK_WORLD_72  = 232,
+	S3DK_WORLD_73  = 233,
+	S3DK_WORLD_74  = 234,
+	S3DK_WORLD_75  = 235,
+	S3DK_WORLD_76  = 236,
+	S3DK_WORLD_77  = 237,
+	S3DK_WORLD_78  = 238,
+	S3DK_WORLD_79  = 239,
+	S3DK_WORLD_80  = 240,
+	S3DK_WORLD_81  = 241,
+	S3DK_WORLD_82  = 242,
+	S3DK_WORLD_83  = 243,
+	S3DK_WORLD_84  = 244,
+	S3DK_WORLD_85  = 245,
+	S3DK_WORLD_86  = 246,
+	S3DK_WORLD_87  = 247,
+	S3DK_WORLD_88  = 248,
+	S3DK_WORLD_89  = 249,
+	S3DK_WORLD_90  = 250,
+	S3DK_WORLD_91  = 251,
+	S3DK_WORLD_92  = 252,
+	S3DK_WORLD_93  = 253,
+	S3DK_WORLD_94  = 254,
+	S3DK_WORLD_95  = 255,  /* 0xFF */
 
 	/* Numeric keypad */
-	S3DK_KP0		= 256,
-	S3DK_KP1		= 257,
-	S3DK_KP2		= 258,
-	S3DK_KP3		= 259,
-	S3DK_KP4		= 260,
-	S3DK_KP5		= 261,
-	S3DK_KP6		= 262,
-	S3DK_KP7		= 263,
-	S3DK_KP8		= 264,
-	S3DK_KP9		= 265,
-	S3DK_KP_PERIOD		= 266,
-	S3DK_KP_DIVIDE		= 267,
-	S3DK_KP_MULTIPLY	= 268,
-	S3DK_KP_MINUS		= 269,
-	S3DK_KP_PLUS		= 270,
-	S3DK_KP_ENTER		= 271,
-	S3DK_KP_EQUALS		= 272,
+	S3DK_KP0  = 256,
+	S3DK_KP1  = 257,
+	S3DK_KP2  = 258,
+	S3DK_KP3  = 259,
+	S3DK_KP4  = 260,
+	S3DK_KP5  = 261,
+	S3DK_KP6  = 262,
+	S3DK_KP7  = 263,
+	S3DK_KP8  = 264,
+	S3DK_KP9  = 265,
+	S3DK_KP_PERIOD  = 266,
+	S3DK_KP_DIVIDE  = 267,
+	S3DK_KP_MULTIPLY = 268,
+	S3DK_KP_MINUS  = 269,
+	S3DK_KP_PLUS  = 270,
+	S3DK_KP_ENTER  = 271,
+	S3DK_KP_EQUALS  = 272,
 
 	/* Arrows + Home/End pad */
-	S3DK_UP			= 273,
-	S3DK_DOWN		= 274,
-	S3DK_RIGHT		= 275,
-	S3DK_LEFT		= 276,
-	S3DK_INSERT		= 277,
-	S3DK_HOME		= 278,
-	S3DK_END		= 279,
-	S3DK_PAGEUP		= 280,
-	S3DK_PAGEDOWN		= 281,
+	S3DK_UP   = 273,
+	S3DK_DOWN  = 274,
+	S3DK_RIGHT  = 275,
+	S3DK_LEFT  = 276,
+	S3DK_INSERT  = 277,
+	S3DK_HOME  = 278,
+	S3DK_END  = 279,
+	S3DK_PAGEUP  = 280,
+	S3DK_PAGEDOWN  = 281,
 
 	/* Function keys */
-	S3DK_F1			= 282,
-	S3DK_F2			= 283,
-	S3DK_F3			= 284,
-	S3DK_F4			= 285,
-	S3DK_F5			= 286,
-	S3DK_F6			= 287,
-	S3DK_F7			= 288,
-	S3DK_F8			= 289,
-	S3DK_F9			= 290,
-	S3DK_F10		= 291,
-	S3DK_F11		= 292,
-	S3DK_F12		= 293,
-	S3DK_F13		= 294,
-	S3DK_F14		= 295,
-	S3DK_F15		= 296,
+	S3DK_F1   = 282,
+	S3DK_F2   = 283,
+	S3DK_F3   = 284,
+	S3DK_F4   = 285,
+	S3DK_F5   = 286,
+	S3DK_F6   = 287,
+	S3DK_F7   = 288,
+	S3DK_F8   = 289,
+	S3DK_F9   = 290,
+	S3DK_F10  = 291,
+	S3DK_F11  = 292,
+	S3DK_F12  = 293,
+	S3DK_F13  = 294,
+	S3DK_F14  = 295,
+	S3DK_F15  = 296,
 
 	/* Key state modifier keys */
-	S3DK_NUMLOCK		= 300,
-	S3DK_CAPSLOCK		= 301,
-	S3DK_SCROLLOCK		= 302,
-	S3DK_RSHIFT		= 303,
-	S3DK_LSHIFT		= 304,
-	S3DK_RCTRL		= 305,
-	S3DK_LCTRL		= 306,
-	S3DK_RALT		= 307,
-	S3DK_LALT		= 308,
-	S3DK_RMETA		= 309,
-	S3DK_LMETA		= 310,
-	S3DK_LSUPER		= 311,		/* Left "Windows" key */
-	S3DK_RSUPER		= 312,		/* Right "Windows" key */
-	S3DK_MODE		= 313,		/* "Alt Gr" key */
-	S3DK_COMPOSE		= 314,		/* Multi-key compose key */
+	S3DK_NUMLOCK  = 300,
+	S3DK_CAPSLOCK  = 301,
+	S3DK_SCROLLOCK  = 302,
+	S3DK_RSHIFT  = 303,
+	S3DK_LSHIFT  = 304,
+	S3DK_RCTRL  = 305,
+	S3DK_LCTRL  = 306,
+	S3DK_RALT  = 307,
+	S3DK_LALT  = 308,
+	S3DK_RMETA  = 309,
+	S3DK_LMETA  = 310,
+	S3DK_LSUPER  = 311,  /* Left "Windows" key */
+	S3DK_RSUPER  = 312,  /* Right "Windows" key */
+	S3DK_MODE  = 313,  /* "Alt Gr" key */
+	S3DK_COMPOSE  = 314,  /* Multi-key compose key */
 
 	/* Miscellaneous function keys */
-	S3DK_HELP		= 315,
-	S3DK_PRINT		= 316,
-	S3DK_SYSREQ		= 317,
-	S3DK_BREAK		= 318,
-	S3DK_MENU		= 319,
-	S3DK_POWER		= 320,		/* Power Macintosh power key */
-	S3DK_EURO		= 321,		/* Some european keyboards */
-	S3DK_UNDO		= 322,		/* Atari keyboard has Undo */
+	S3DK_HELP  = 315,
+	S3DK_PRINT  = 316,
+	S3DK_SYSREQ  = 317,
+	S3DK_BREAK  = 318,
+	S3DK_MENU  = 319,
+	S3DK_POWER  = 320,  /* Power Macintosh power key */
+	S3DK_EURO  = 321,  /* Some european keyboards */
+	S3DK_UNDO  = 322,  /* Atari keyboard has Undo */
 
 	/* Add any other keys here */
 
@@ -293,8 +293,8 @@
 /* Enumeration of valid key mods (possibly OR'd together) */
 typedef enum {
 	S3D_KMOD_NONE  = 0x0000,
-	S3D_KMOD_LSHIFT= 0x0001,
-	S3D_KMOD_RSHIFT= 0x0002,
+	S3D_KMOD_LSHIFT = 0x0001,
+	S3D_KMOD_RSHIFT = 0x0002,
 	S3D_KMOD_LCTRL = 0x0040,
 	S3D_KMOD_RCTRL = 0x0080,
 	S3D_KMOD_LALT  = 0x0100,
@@ -307,8 +307,8 @@
 	S3D_KMOD_RESERVED = 0x8000
 } S3DMod;
 
-#define S3D_KMOD_CTRL	(KMOD_LCTRL|KMOD_RCTRL)
-#define S3D_KMOD_SHIFT	(KMOD_LSHIFT|KMOD_RSHIFT)
-#define S3D_KMOD_ALT	(KMOD_LALT|KMOD_RALT)
-#define S3D_KMOD_META	(KMOD_LMETA|KMOD_RMETA)
+#define S3D_KMOD_CTRL (KMOD_LCTRL|KMOD_RCTRL)
+#define S3D_KMOD_SHIFT (KMOD_LSHIFT|KMOD_RSHIFT)
+#define S3D_KMOD_ALT (KMOD_LALT|KMOD_RALT)
+#define S3D_KMOD_META (KMOD_LMETA|KMOD_RMETA)
 

Modified: trunk/libs3d/s3dlib.h
===================================================================
--- trunk/libs3d/s3dlib.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/s3dlib.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -40,30 +40,30 @@
 #endif
 #endif
 
-#define VLOW	1
-#define	LOW		2
-#define MED		3
-#define HIGH	4
-#define	VHIGH	5
+#define VLOW 1
+#define LOW  2
+#define MED  3
+#define HIGH 4
+#define VHIGH 5
 
-#define DBM_MAX			1024	 /*  maximum size of a debug message string */
-#define S3D_NAME_MAX	256		 /*  limit for names [e.g. process names] */
-#define OF_TURN_ON 		1		 /*  logical or */
-#define OF_TURN_OFF 	2		 /*  logical ?! */
-#define OF_TURN_SWAP 	3		 /*  logical ?! */
-#define TIMEOUT			100000
-#define MAX_CB			256		 /*  as much as there are callbacks */
+#define DBM_MAX   1024  /*  maximum size of a debug message string */
+#define S3D_NAME_MAX 256   /*  limit for names [e.g. process names] */
+#define OF_TURN_ON   1   /*  logical or */
+#define OF_TURN_OFF  2   /*  logical ?! */
+#define OF_TURN_SWAP  3   /*  logical ?! */
+#define TIMEOUT   100000
+#define MAX_CB   256   /*  as much as there are callbacks */
 #ifndef NULL
-#define NULL	0
+#define NULL 0
 #endif
-#define CON_NULL	0
-#define CON_SHM		1
-#define CON_TCP		2
-#define SHM_SIZE 	sizeof(key_t)*2  		/* space for the keys */
-#define RB_STD_SIZE		1024*512
-#define RB_OVERHEAD		sizeof(struct buf_t)
+#define CON_NULL 0
+#define CON_SHM  1
+#define CON_TCP  2
+#define SHM_SIZE  sizeof(key_t)*2    /* space for the keys */
+#define RB_STD_SIZE  1024*512
+#define RB_OVERHEAD  sizeof(struct buf_t)
 /*  the callback buiffer: */
-extern int cb_lock;	/* holds the recursion depth */
+extern int cb_lock; /* holds the recursion depth */
 
 extern int _s3d_ready; /* is 1 after s3d_init() was sucessful */
 extern s3d_cb s3d_cb_list[MAX_CB];
@@ -76,8 +76,8 @@
 #pragma GCC visibility push(default) /* Only export following functions */
 #endif
 void s3dprintf(int relevance, const char *fmt, ...);
-void errdn(int relevance, char *func,int en);
-void errds(int relevance,char *func, const char *fmt, ...);
+void errdn(int relevance, char *func, int en);
+void errds(int relevance, char *func, const char *fmt, ...);
 #ifdef HAVE_GCCVISIBILITY
 #pragma GCC visibility pop
 #endif
@@ -93,7 +93,7 @@
                              const char *S3DUNUSED(fmt), ...) {}
 #endif
 
-void errn(char *func,int en);
+void errn(char *func, int en);
 void errs(char *func, char *msg);
 
 /*  fontselect.c */
@@ -112,33 +112,33 @@
 int _tcp_init();
 int _tcp_quit();
 int _s3d_tcp_net_receive();
-int tcp_writen(char *str,int s);
-int tcp_readn(char *str,int s);
+int tcp_writen(char *str, int s);
+int tcp_readn(char *str, int s);
 #endif
 /* shm_ringbuf.c */
 #ifdef SHM
 struct buf_t {
-	uint32_t start,end,bufsize;	/* start/end of the data */
+	uint32_t start, end, bufsize; /* start/end of the data */
 };
-int shm_write(struct buf_t *rb,char *buf, int n);
-int shm_read(struct buf_t *rb,char *buf, int n);
+int shm_write(struct buf_t *rb, char *buf, int n);
+int shm_read(struct buf_t *rb, char *buf, int n);
 /* shm.c */
 int _shm_init(char *ftoken);
 int _shm_quit();
 int _shm_net_receive();
-int shm_writen(char *str,int s);
-int shm_readn(char *str,int s);
+int shm_writen(char *str, int s);
+int shm_readn(char *str, int s);
 #endif
 /* freetype.c */
 struct t_buf {
 	float *vbuf;
 	uint32_t *pbuf;
-	int pn,vn;
+	int pn, vn;
 	float xoff;
 };
 
 /* tesselate.c */
 struct tessp_t {
-	int next,prev,done;
+	int next, prev, done;
 };
-int _s3d_tesselate(struct tessp_t *t,struct t_buf *b);
+int _s3d_tesselate(struct tessp_t *t, struct t_buf *b);

Modified: trunk/libs3d/sei_construct.c
===================================================================
--- trunk/libs3d/sei_construct.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/sei_construct.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -42,9 +42,9 @@
 #include <string.h> /* memset() */
 
 
-node_t qs[QSIZE];		/* Query structure */
-trap_t tr[TRSIZE];		/* Trapezoid structure */
-segment_t seg[SEGSIZE];		/* Segment table */
+node_t qs[QSIZE];  /* Query structure */
+trap_t tr[TRSIZE];  /* Trapezoid structure */
+segment_t seg[SEGSIZE];  /* Segment table */
 
 static int q_idx;
 static int tr_idx;
@@ -55,7 +55,7 @@
 	if (q_idx < QSIZE)
 		return q_idx++;
 	else {
-		errs("sei:newnode()","Query-table overflow");
+		errs("sei:newnode()", "Query-table overflow");
 		return -1;
 	}
 }
@@ -69,7 +69,7 @@
 		tr[tr_idx].state = ST_VALID;
 		return tr_idx++;
 	} else {
-		errs("sei:newtrap()","Trapezoid-table overflow");
+		errs("sei:newtrap()", "Trapezoid-table overflow");
 		return -1;
 	}
 }
@@ -166,9 +166,9 @@
  *
  *                4
  *   -----------------------------------
- *  		  \
- *  	1	   \        2
- *  		    \
+ *      \
+ *   1    \        2
+ *        \
  *   -----------------------------------
  *                3
  */
@@ -215,17 +215,17 @@
 	qs[i7].nodetype = T_SINK;
 	qs[i7].parent = i5;
 
-	t1 = newtrap();		/* middle left */
-	t2 = newtrap();		/* middle right */
-	t3 = newtrap();		/* bottom-most */
-	t4 = newtrap();		/* topmost */
+	t1 = newtrap();  /* middle left */
+	t2 = newtrap();  /* middle right */
+	t3 = newtrap();  /* bottom-most */
+	t4 = newtrap();  /* topmost */
 
 	tr[t1].hi = tr[t2].hi = tr[t4].lo = qs[i1].yval;
 	tr[t1].lo = tr[t2].lo = tr[t3].hi = qs[i3].yval;
-	tr[t4].hi.y = (double) (INFINITY);
-	tr[t4].hi.x = (double) (INFINITY);
-	tr[t3].lo.y = (double) -1* (INFINITY);
-	tr[t3].lo.x = (double) -1* (INFINITY);
+	tr[t4].hi.y = (double)(INFINITY);
+	tr[t4].hi.x = (double)(INFINITY);
+	tr[t3].lo.y = (double) - 1 * (INFINITY);
+	tr[t3].lo.x = (double) - 1 * (INFINITY);
 	tr[t1].rseg = tr[t2].lseg = segnum;
 	tr[t1].u0 = tr[t2].u0 = t4;
 	tr[t1].d0 = tr[t2].d0 = t3;
@@ -275,7 +275,7 @@
 				area = -1.0;
 		} else
 			area = CROSS(s->v0, s->v1, (*v));
-	} else {			/* v0 > v1 */
+	} else {   /* v0 > v1 */
 		if (FP_EQUAL(s->v1.y, v->y)) {
 			if (v->x < s->v1.x)
 				area = 1.0;
@@ -331,7 +331,7 @@
 		if (_greater_than(v, &rptr->yval)) /* above */
 			return locate_endpoint(v, vo, rptr->right);
 		else if (_equal_to(v, &rptr->yval)) /* the point is already */
-		{			          /* inserted. */
+		{             /* inserted. */
 			if (_greater_than(vo, &rptr->yval)) /* above */
 				return locate_endpoint(v, vo, rptr->right);
 			else
@@ -359,7 +359,7 @@
 			return locate_endpoint(v, vo, rptr->right); /* right */
 
 	default:
-		errs("sei:locate_endpoint()","Haggu!!!! (whatever)");
+		errs("sei:locate_endpoint()", "Haggu!!!! (whatever)");
 		break;
 	}
 	return(-1);
@@ -395,7 +395,7 @@
 		if (cond) {
 			if ((tr[t].lseg == tr[tnext].lseg) &&
 			                (tr[t].rseg == tr[tnext].rseg)) /* good neighbours */
-			{			              /* merge them */
+			{                 /* merge them */
 				/* Use the upper node as the new node i.e. t */
 
 				ptnext = qs[tr[tnext].sink].parent;
@@ -403,7 +403,7 @@
 				if (qs[ptnext].left == tr[tnext].sink)
 					qs[ptnext].left = tr[t].sink;
 				else
-					qs[ptnext].right = tr[t].sink;	/* redirect parent */
+					qs[ptnext].right = tr[t].sink; /* redirect parent */
 
 
 				/* Change the upper neighbours of the lower trapezoids */
@@ -425,9 +425,9 @@
 				tr[t].lo = tr[tnext].lo;
 				tr[tnext].state = ST_INVALID; /* invalidate the lower */
 				/* trapezium */
-			} else		   /* not good neighbours */
+			} else     /* not good neighbours */
 				t = tnext;
-		} else		   /* do not satisfy the outer if */
+		} else     /* do not satisfy the outer if */
 			t = tnext;
 
 	} /* end-while */
@@ -471,7 +471,7 @@
 		int tmp_d;
 
 		tu = locate_endpoint(&s.v0, &s.v1, s.root0);
-		tl = newtrap();		/* tl is the new lower trapezoid */
+		tl = newtrap();  /* tl is the new lower trapezoid */
 		tr[tl].state = ST_VALID;
 		tr[tl] = tr[tu];
 		tr[tu].lo.y = tr[tl].hi.y = s.v0.y;
@@ -494,13 +494,13 @@
 		/* Now update the query structure and obtain the sinks for the */
 		/* two trapezoids */
 
-		i1 = newnode();		/* Upper trapezoid sink */
-		i2 = newnode();		/* Lower trapezoid sink */
+		i1 = newnode();  /* Upper trapezoid sink */
+		i2 = newnode();  /* Lower trapezoid sink */
 		sk = tr[tu].sink;
 
 		qs[sk].nodetype = T_Y;
 		qs[sk].yval = s.v0;
-		qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
+		qs[sk].segnum = segnum; /* not really reqd ... maybe later */
 		qs[sk].left = i2;
 		qs[sk].right = i1;
 
@@ -515,7 +515,7 @@
 		tr[tu].sink = i1;
 		tr[tl].sink = i2;
 		tfirst = tl;
-	} else				/* v0 already present */
+	} else    /* v0 already present */
 	{       /* Get the topmost intersecting trapezoid */
 		tfirst = locate_endpoint(&s.v0, &s.v1, s.root0);
 		tritop = 1;
@@ -528,7 +528,7 @@
 
 		tu = locate_endpoint(&s.v1, &s.v0, s.root1);
 
-		tl = newtrap();		/* tl is the new lower trapezoid */
+		tl = newtrap();  /* tl is the new lower trapezoid */
 		tr[tl].state = ST_VALID;
 		tr[tl] = tr[tu];
 		tr[tu].lo.y = tr[tl].hi.y = s.v1.y;
@@ -551,13 +551,13 @@
 		/* Now update the query structure and obtain the sinks for the */
 		/* two trapezoids */
 
-		i1 = newnode();		/* Upper trapezoid sink */
-		i2 = newnode();		/* Lower trapezoid sink */
+		i1 = newnode();  /* Upper trapezoid sink */
+		i2 = newnode();  /* Lower trapezoid sink */
 		sk = tr[tu].sink;
 
 		qs[sk].nodetype = T_Y;
 		qs[sk].yval = s.v1;
-		qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
+		qs[sk].segnum = segnum; /* not really reqd ... maybe later */
 		qs[sk].left = i2;
 		qs[sk].right = i1;
 
@@ -572,7 +572,7 @@
 		tr[tu].sink = i1;
 		tr[tl].sink = i2;
 		tlast = tu;
-	} else				/* v1 already present */
+	} else    /* v1 already present */
 	{       /* Get the lowermost intersecting trapezoid */
 		tlast = locate_endpoint(&s.v1, &s.v0, s.root1);
 		tribot = 1;
@@ -582,7 +582,7 @@
 	/* First, split all the trapezoids which are intersected by s into */
 	/* two */
 
-	t = tfirst;			/* topmost trapezoid */
+	t = tfirst;   /* topmost trapezoid */
 
 	while ((t > 0) &&
 	                _greater_than_equal_to(&tr[t].lo, &tr[tlast].lo))
@@ -590,19 +590,19 @@
 	{
 		int t_sav, tn_sav;
 		sk = tr[t].sink;
-		i1 = newnode();		/* left trapezoid sink */
-		i2 = newnode();		/* right trapezoid sink */
+		i1 = newnode();  /* left trapezoid sink */
+		i2 = newnode();  /* right trapezoid sink */
 
 		qs[sk].nodetype = T_X;
 		qs[sk].segnum = segnum;
 		qs[sk].left = i1;
 		qs[sk].right = i2;
 
-		qs[i1].nodetype = T_SINK;	/* left trapezoid (use existing one) */
+		qs[i1].nodetype = T_SINK; /* left trapezoid (use existing one) */
 		qs[i1].trnum = t;
 		qs[i1].parent = sk;
 
-		qs[i2].nodetype = T_SINK;	/* right trapezoid (allocate new) */
+		qs[i2].nodetype = T_SINK; /* right trapezoid (allocate new) */
 		qs[i2].trnum = tn = newtrap();
 		tr[tn].state = ST_VALID;
 		qs[i2].parent = sk;
@@ -621,7 +621,7 @@
 		/* error */
 
 		if ((tr[t].d0 <= 0) && (tr[t].d1 <= 0)) { /* case cannot arise */
-			errs("sei:add_segment()","error");
+			errs("sei:add_segment()", "error");
 			break;
 		}
 
@@ -629,8 +629,8 @@
 		/* two resulting trapezoids t and tn as the upper neighbours of */
 		/* the sole lower trapezoid */
 
-		else if ((tr[t].d0 > 0) && (tr[t].d1 <= 0)) {			/* Only one trapezoid below */
-			if ((tr[t].u0 > 0) && (tr[t].u1 > 0)) {			/* continuation of a chain from abv. */
+		else if ((tr[t].d0 > 0) && (tr[t].d1 <= 0)) {   /* Only one trapezoid below */
+			if ((tr[t].u0 > 0) && (tr[t].u1 > 0)) {   /* continuation of a chain from abv. */
 				if (tr[t].usave > 0) { /* three upper neighbours */
 					if (tr[t].uside == S_LEFT) {
 						tr[tn].u0 = tr[t].u1;
@@ -640,7 +640,7 @@
 						tr[tr[t].u0].d0 = t;
 						tr[tr[tn].u0].d0 = tn;
 						tr[tr[tn].u1].d0 = tn;
-					} else {	/* intersects in the right */
+					} else { /* intersects in the right */
 						tr[tn].u1 = -1;
 						tr[tn].u0 = tr[t].u1;
 						tr[t].u1 = tr[t].u0;
@@ -652,32 +652,32 @@
 					}
 
 					tr[t].usave = tr[tn].usave = 0;
-				} else {	/* No usave.... simple case */
+				} else { /* No usave.... simple case */
 					tr[tn].u0 = tr[t].u1;
 					tr[t].u1 = tr[tn].u1 = -1;
 					tr[tr[tn].u0].d0 = tn;
 				}
-			} else {			/* fresh seg. or upward cusp */
+			} else {   /* fresh seg. or upward cusp */
 				int tmp_u = tr[t].u0;
 				int td0, td1;
 				if (((td0 = tr[tmp_u].d0) > 0) &&
-				                ((td1 = tr[tmp_u].d1) > 0)) {		/* upward cusp */
+				                ((td1 = tr[tmp_u].d1) > 0)) {  /* upward cusp */
 					if ((tr[td0].rseg > 0) &&
 					                !is_left_of(tr[td0].rseg, &s.v1)) {
 						tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
 						tr[tr[tn].u0].d1 = tn;
-					} else {	/* cusp going leftwards */
+					} else { /* cusp going leftwards */
 						tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
 						tr[tr[t].u0].d0 = t;
 					}
-				} else {	/* fresh segment */
+				} else { /* fresh segment */
 					tr[tr[t].u0].d0 = t;
 					tr[tr[t].u0].d1 = tn;
 				}
 			}
 
 			if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &&
-			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) && tribot) {		/* bottom forms a triangle */
+			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) && tribot) {  /* bottom forms a triangle */
 
 				if (is_swapped)
 					tmptriseg = seg[segnum].prev;
@@ -711,8 +711,8 @@
 		}
 
 
-		else if ((tr[t].d0 <= 0) && (tr[t].d1 > 0)) {			/* Only one trapezoid below */
-			if ((tr[t].u0 > 0) && (tr[t].u1 > 0)) {			/* continuation of a chain from abv. */
+		else if ((tr[t].d0 <= 0) && (tr[t].d1 > 0)) {   /* Only one trapezoid below */
+			if ((tr[t].u0 > 0) && (tr[t].u1 > 0)) {   /* continuation of a chain from abv. */
 				if (tr[t].usave > 0) { /* three upper neighbours */
 					if (tr[t].uside == S_LEFT) {
 						tr[tn].u0 = tr[t].u1;
@@ -722,7 +722,7 @@
 						tr[tr[t].u0].d0 = t;
 						tr[tr[tn].u0].d0 = tn;
 						tr[tr[tn].u1].d0 = tn;
-					} else {	/* intersects in the right */
+					} else { /* intersects in the right */
 						tr[tn].u1 = -1;
 						tr[tn].u0 = tr[t].u1;
 						tr[t].u1 = tr[t].u0;
@@ -734,16 +734,16 @@
 					}
 
 					tr[t].usave = tr[tn].usave = 0;
-				} else {	/* No usave.... simple case */
+				} else { /* No usave.... simple case */
 					tr[tn].u0 = tr[t].u1;
 					tr[t].u1 = tr[tn].u1 = -1;
 					tr[tr[tn].u0].d0 = tn;
 				}
-			} else {			/* fresh seg. or upward cusp */
+			} else {   /* fresh seg. or upward cusp */
 				int tmp_u = tr[t].u0;
 				int td0, td1;
 				if (((td0 = tr[tmp_u].d0) > 0) &&
-				                ((td1 = tr[tmp_u].d1) > 0)) {		/* upward cusp */
+				                ((td1 = tr[tmp_u].d1) > 0)) {  /* upward cusp */
 					if ((tr[td0].rseg > 0) &&
 					                !is_left_of(tr[td0].rseg, &s.v1)) {
 						tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
@@ -752,14 +752,14 @@
 						tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
 						tr[tr[t].u0].d0 = t;
 					}
-				} else {	/* fresh segment */
+				} else { /* fresh segment */
 					tr[tr[t].u0].d0 = t;
 					tr[tr[t].u0].d1 = tn;
 				}
 			}
 
 			if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &&
-			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) && tribot) {		/* bottom forms a triangle */
+			                FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) && tribot) {  /* bottom forms a triangle */
 
 				if (is_swapped)
 					tmptriseg = seg[segnum].prev;
@@ -809,7 +809,7 @@
 					i_d1 = TRUE;
 			} else {
 				tmppt.y = y0 = tr[t].lo.y;
-				yt = (y0 - s.v0.y)/(s.v1.y - s.v0.y);
+				yt = (y0 - s.v0.y) / (s.v1.y - s.v0.y);
 				tmppt.x = s.v0.x + yt * (s.v1.x - s.v0.x);
 
 				if (_less_than(&tmppt, &tr[t].lo))
@@ -821,7 +821,7 @@
 			/* check continuity from the top so that the lower-neighbour */
 			/* values are properly filled for the upper trapezoid */
 
-			if ((tr[t].u0 > 0) && (tr[t].u1 > 0)) {			/* continuation of a chain from abv. */
+			if ((tr[t].u0 > 0) && (tr[t].u1 > 0)) {   /* continuation of a chain from abv. */
 				if (tr[t].usave > 0) { /* three upper neighbours */
 					if (tr[t].uside == S_LEFT) {
 						tr[tn].u0 = tr[t].u1;
@@ -831,7 +831,7 @@
 						tr[tr[t].u0].d0 = t;
 						tr[tr[tn].u0].d0 = tn;
 						tr[tr[tn].u1].d0 = tn;
-					} else {	/* intersects in the right */
+					} else { /* intersects in the right */
 						tr[tn].u1 = -1;
 						tr[tn].u0 = tr[t].u1;
 						tr[t].u1 = tr[t].u0;
@@ -843,17 +843,17 @@
 					}
 
 					tr[t].usave = tr[tn].usave = 0;
-				} else {	/* No usave.... simple case */
+				} else { /* No usave.... simple case */
 					tr[tn].u0 = tr[t].u1;
 					tr[tn].u1 = -1;
 					tr[t].u1 = -1;
 					tr[tr[tn].u0].d0 = tn;
 				}
-			} else {			/* fresh seg. or upward cusp */
+			} else {   /* fresh seg. or upward cusp */
 				int tmp_u = tr[t].u0;
 				int td0, td1;
 				if (((td0 = tr[tmp_u].d0) > 0) &&
-				                ((td1 = tr[tmp_u].d1) > 0)) {		/* upward cusp */
+				                ((td1 = tr[tmp_u].d1) > 0)) {  /* upward cusp */
 					if ((tr[td0].rseg > 0) &&
 					                !is_left_of(tr[td0].rseg, &s.v1)) {
 						tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
@@ -862,7 +862,7 @@
 						tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
 						tr[tr[t].u0].d0 = t;
 					}
-				} else {	/* fresh segment */
+				} else { /* fresh segment */
 					tr[tr[t].u0].d0 = t;
 					tr[tr[t].u0].d1 = tn;
 				}
@@ -897,7 +897,7 @@
 				tr[t].d1 = -1;
 
 				tnext = tr[t].d0;
-			} else {		/* intersecting d1 */
+			} else {  /* intersecting d1 */
 				tr[tr[t].d0].u0 = t;
 				tr[tr[t].d0].u1 = -1;
 				tr[tr[t].d1].u0 = t;
@@ -970,7 +970,7 @@
 		seg[i].root0 = seg[i].root1 = root;
 
 	for (h = 1; h <= math_logstar_n(nseg); h++) {
-		for (i = math_N(nseg, h -1) + 1; i <= math_N(nseg, h); i++)
+		for (i = math_N(nseg, h - 1) + 1; i <= math_N(nseg, h); i++)
 			add_segment(choose_segment());
 
 		/* Find a new root for each of the segment endpoints */

Modified: trunk/libs3d/sei_interface.h
===================================================================
--- trunk/libs3d/sei_interface.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/sei_interface.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -43,7 +43,7 @@
 #define TRUE 1
 #define FALSE 0
 
-extern int sei_triangulate_polygon(int, int *, double (*)[2], int (*)[3]);
+extern int sei_triangulate_polygon(int, int *, double(*)[2], int (*)[3]);
 extern int is_point_inside_polygon(double *);
 
 #endif /* __interface_h */

Modified: trunk/libs3d/sei_misc.c
===================================================================
--- trunk/libs3d/sei_misc.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/sei_misc.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -46,7 +46,7 @@
 static int permute[SEGSIZE];
 double mlog2(double x)
 {
-	return log(x)/log(2);
+	return log(x) / log(2);
 }
 
 /* Generate a random permutation of the segments 1..n */
@@ -79,7 +79,7 @@
 /* segments in S */
 int choose_segment()
 {
-	errds(VLOW,"sei:choose_segment()","%d", permute[choose_idx]);
+	errds(VLOW, "sei:choose_segment()", "%d", permute[choose_idx]);
 	return permute[choose_idx++];
 }
 
@@ -107,5 +107,5 @@
 	for (i = 0, v = (int) n; i < h; i++)
 		v = mlog2(v);
 
-	return (int) ceil((double) 1.0*n/v);
+	return (int) ceil((double) 1.0*n / v);
 }

Modified: trunk/libs3d/sei_monotone.c
===================================================================
--- trunk/libs3d/sei_monotone.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/sei_monotone.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -55,7 +55,7 @@
 /* polygons touching at the same */
 /* vertex  */
 
-static int mon[SEGSIZE];	/* contains position of any vertex in */
+static int mon[SEGSIZE]; /* contains position of any vertex in */
 /* the monotone chain for the polygon */
 static int visited[TRSIZE];
 static int chain_idx, op_idx, mon_idx;
@@ -111,10 +111,10 @@
 	v1.x = vp1->x - vp0->x;
 	v1.y = vp1->y - vp0->y;
 
-	if (CROSS_SINE(v0, v1) >= 0)	/* sine is positive */
-		return DOT(v0, v1)/LENGTH(v0)/LENGTH(v1);
+	if (CROSS_SINE(v0, v1) >= 0) /* sine is positive */
+		return DOT(v0, v1) / LENGTH(v0) / LENGTH(v1);
 	else
-		return (-1.0 * DOT(v0, v1)/LENGTH(v0)/LENGTH(v1) - 2);
+		return (-1.0 * DOT(v0, v1) / LENGTH(v0) / LENGTH(v1) - 2);
 }
 
 
@@ -197,7 +197,7 @@
 	/* At this stage, we have got the positions of v0 and v1 in the */
 	/* desired chain. Now modify the linked lists */
 
-	i = new_chain_element();	/* for the new list */
+	i = new_chain_element(); /* for the new list */
 	j = new_chain_element();
 
 	mchain[i].vnum = v0;
@@ -226,8 +226,8 @@
 	vp0->nextfree++;
 	vp1->nextfree++;
 
-	errds(VLOW,"sei:make_poly()",": mcur = %d, (v0, v1) = (%d, %d)", mcur, v0, v1);
-	errds(VLOW,"sei:make_poly()","next posns = (p, q) = (%d, %d)", p, q);
+	errds(VLOW, "sei:make_poly()", ": mcur = %d, (v0, v1) = (%d, %d)", mcur, v0, v1);
+	errds(VLOW, "sei:make_poly()", "next posns = (p, q) = (%d, %d)", p, q);
 
 	mon[mcur] = p;
 	mon[mnew] = i;
@@ -265,8 +265,8 @@
 		mchain[i].next = i + 1;
 		mchain[i].vnum = i;
 		vert[i].pt = seg[i].v0;
-		vert[i].vnext[0] = i + 1;	/* next vertex */
-		vert[i].vpos[0] = i;	/* locn. of next vertex */
+		vert[i].vnext[0] = i + 1; /* next vertex */
+		vert[i].vpos[0] = i; /* locn. of next vertex */
 		vert[i].nextfree = 1;
 	}
 	mchain[1].prev = n;
@@ -275,7 +275,7 @@
 	vert[n].vpos[0] = n;
 	chain_idx = n;
 	mon_idx = 0;
-	mon[0] = 1;			/* position of any vertex in the first */
+	mon[0] = 1;   /* position of any vertex in the first */
 	/* chain  */
 
 #else
@@ -286,13 +286,13 @@
 		mchain[i].vnum = i;
 		vert[i].pt = seg[i].v0;
 		vert[i].vnext[0] = seg[i].next; /* next vertex */
-		vert[i].vpos[0] = i;	/* locn. of next vertex */
+		vert[i].vpos[0] = i; /* locn. of next vertex */
 		vert[i].nextfree = 1;
 	}
 
 	chain_idx = n;
 	mon_idx = 0;
-	mon[0] = 1;			/* position of any vertex in the first */
+	mon[0] = 1;   /* position of any vertex in the first */
 	/* chain  */
 
 #endif
@@ -351,7 +351,7 @@
 				traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
 			}
 		} else {
-			retval = SP_NOSPLIT;	/* Just traverse all neighbours */
+			retval = SP_NOSPLIT; /* Just traverse all neighbours */
 			traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
 			traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
 			traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
@@ -374,7 +374,7 @@
 				traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
 			}
 		} else {
-			retval = SP_NOSPLIT;	/* Just traverse all neighbours */
+			retval = SP_NOSPLIT; /* Just traverse all neighbours */
 			traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
 			traverse_polygon(mcur, t->u1, trnum, TR_FROM_DN);
 			traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
@@ -402,7 +402,7 @@
 				traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
 				traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
 			}
-		} else {		/* only downward cusp */
+		} else {  /* only downward cusp */
 			if (_equal_to(&t->lo, &seg[t->lseg].v1)) {
 				v0 = tr[t->u0].rseg;
 				v1 = seg[t->lseg].next;
@@ -482,7 +482,7 @@
 					traverse_polygon(mnew, t->d1, trnum, TR_FROM_UP);
 				}
 			}
-		} else {		/* no cusp */
+		} else {  /* no cusp */
 			if (_equal_to(&t->hi, &seg[t->lseg].v0) &&
 			                _equal_to(&t->lo, &seg[t->rseg].v0)) {
 				v0 = t->rseg;
@@ -522,7 +522,7 @@
 					traverse_polygon(mnew, t->u0, trnum, TR_FROM_DN);
 					traverse_polygon(mnew, t->u1, trnum, TR_FROM_DN);
 				}
-			} else {		/* no split possible */
+			} else {  /* no split possible */
 				retval = SP_NOSPLIT;
 				traverse_polygon(mcur, t->u0, trnum, TR_FROM_DN);
 				traverse_polygon(mcur, t->d0, trnum, TR_FROM_UP);
@@ -564,7 +564,7 @@
 		while ((v = mchain[p].vnum) != vfirst) {
 			if (mchain[p].marked) {
 				processed = TRUE;
-				break;		/* break from while */
+				break;  /* break from while */
 			} else
 				mchain[p].marked = TRUE;
 
@@ -580,17 +580,17 @@
 			vcount++;
 		}
 
-		if (processed)		/* Go to next polygon */
+		if (processed)  /* Go to next polygon */
 			continue;
 
-		if (vcount == 3) {	/* already a triangle */
+		if (vcount == 3) { /* already a triangle */
 			op[op_idx][0] = mchain[p].vnum;
 			op[op_idx][1] = mchain[mchain[p].next].vnum;
 			op[op_idx][2] = mchain[mchain[p].prev].vnum;
 			op_idx++;
-		} else {		/* triangulate the polygon */
+		} else {  /* triangulate the polygon */
 			v = mchain[mchain[posmax].next].vnum;
-			if (_equal_to(&vert[v].pt, &ymin)) {			/* LHS is a single line */
+			if (_equal_to(&vert[v].pt, &ymin)) {   /* LHS is a single line */
 				triangulate_single_polygon(nvert, posmax, TRI_LHS, op);
 			} else
 				triangulate_single_polygon(nvert, posmax, TRI_RHS, op);
@@ -598,7 +598,7 @@
 	}
 
 	for (i = 0; i < op_idx; i++)
-		errds(VLOW,"sei:triangulate_monotone_polygons()","tri #%d: (%d, %d, %d)\n", i, op[i][0], op[i][1],
+		errds(VLOW, "sei:triangulate_monotone_polygons()", "tri #%d: (%d, %d, %d)\n", i, op[i][0], op[i][1],
 		      op[i][2]);
 	return op_idx;
 }
@@ -615,10 +615,10 @@
 int op[][3];
 {
 	register int v;
-	int rc[SEGSIZE], ri = 0;	/* reflex chain */
+	int rc[SEGSIZE], ri = 0; /* reflex chain */
 	int endv, tmp, vpos;
 
-	if (side == TRI_RHS) {	/* RHS segment is a single segment */
+	if (side == TRI_RHS) { /* RHS segment is a single segment */
 		rc[0] = mchain[posmax].vnum;
 		tmp = mchain[posmax].next;
 		rc[1] = mchain[tmp].vnum;
@@ -629,7 +629,7 @@
 
 		if ((endv = mchain[mchain[posmax].prev].vnum) == 0)
 			endv = nvert;
-	} else {			/* LHS is a single segment */
+	} else {   /* LHS is a single segment */
 		tmp = mchain[posmax].next;
 		rc[0] = mchain[tmp].vnum;
 		tmp = mchain[tmp].next;
@@ -643,23 +643,23 @@
 	}
 
 	while ((v != endv) || (ri > 1)) {
-		if (ri > 0) {	/* reflex chain is non-empty */
+		if (ri > 0) { /* reflex chain is non-empty */
 			if (CROSS(vert[v].pt, vert[rc[ri - 1]].pt,
-			                vert[rc[ri]].pt) > 0) {			/* convex corner: cut if off */
+			                vert[rc[ri]].pt) > 0) {   /* convex corner: cut if off */
 				op[op_idx][0] = rc[ri - 1];
 				op[op_idx][1] = rc[ri];
 				op[op_idx][2] = v;
 				op_idx++;
 				ri--;
-			} else		/* non-convex */
-			{		/* add v to the chain */
+			} else  /* non-convex */
+			{  /* add v to the chain */
 				ri++;
 				rc[ri] = v;
 				vpos = mchain[vpos].next;
 				v = mchain[vpos].vnum;
 			}
-		} else			/* reflex-chain empty: add v to the */
-		{			/* reflex chain and advance it  */
+		} else   /* reflex-chain empty: add v to the */
+		{   /* reflex chain and advance it  */
 			rc[++ri] = v;
 			vpos = mchain[vpos].next;
 			v = mchain[vpos].vnum;

Modified: trunk/libs3d/sei_tri.c
===================================================================
--- trunk/libs3d/sei_tri.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/sei_tri.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -65,12 +65,12 @@
  *
  * ncontours: #contours
  * cntr: An array describing the number of points in each
- *	 contour. Thus, cntr[i] = #points in the i'th contour.
+ *  contour. Thus, cntr[i] = #points in the i'th contour.
  * vertices: Input array of vertices. Vertices for each contour
  *           immediately follow those for previous one. Array location
  *           vertices[0] must NOT be used (i.e. i/p starts from
  *           vertices[1] instead. The output triangles are
- *	     specified  w.r.t. the indices of these vertices.
+ *      specified  w.r.t. the indices of these vertices.
  * triangles: Output array to hold triangles.
  *
  * Enough space must be allocated for all the arrays before calling
@@ -81,7 +81,7 @@
 int sei_triangulate_polygon(ncontours, cntr, vertices, triangles)
 int ncontours;
 int cntr[];
-double (*vertices)[2];
+double(*vertices)[2];
 int (*triangles)[3];
 {
 	register int i;
@@ -105,15 +105,15 @@
 
 			if (i == last) {
 				seg[i].next = first;
-				seg[i].prev = i-1;
+				seg[i].prev = i - 1;
 				seg[i-1].v1 = seg[i].v0;
 			} else if (i == first) {
-				seg[i].next = i+1;
+				seg[i].next = i + 1;
 				seg[i].prev = last;
 				seg[last].v1 = seg[i].v0;
 			} else {
-				seg[i].prev = i-1;
-				seg[i].next = i+1;
+				seg[i].prev = i - 1;
+				seg[i].next = i + 1;
 				seg[i-1].v1 = seg[i].v0;
 			}
 
@@ -124,7 +124,7 @@
 	}
 
 	genus = ncontours - 1;
-	n = i-1;
+	n = i - 1;
 
 	initialise(n);
 	construct_trapezoids(n);

Modified: trunk/libs3d/sei_triangulate.h
===================================================================
--- trunk/libs3d/sei_triangulate.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/sei_triangulate.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -54,23 +54,23 @@
 /* Segment attributes */
 
 typedef struct {
-	point_t v0, v1;		/* two endpoints */
-	int is_inserted;		/* inserted in trapezoidation yet ? */
-	int root0, root1;		/* root nodes in Q */
-	int next;			/* Next logical segment */
-	int prev;			/* Previous segment */
+	point_t v0, v1;  /* two endpoints */
+	int is_inserted;  /* inserted in trapezoidation yet ? */
+	int root0, root1;  /* root nodes in Q */
+	int next;   /* Next logical segment */
+	int prev;   /* Previous segment */
 } segment_t;
 
 
 /* Trapezoid attributes */
 
 typedef struct {
-	int lseg, rseg;		/* two adjoining segments */
-	point_t hi, lo;		/* max/min y-values */
+	int lseg, rseg;  /* two adjoining segments */
+	point_t hi, lo;  /* max/min y-values */
 	int u0, u1;
 	int d0, d1;
-	int sink;			/* pointer to corresponding in Q */
-	int usave, uside;		/* I forgot what this means */
+	int sink;   /* pointer to corresponding in Q */
+	int usave, uside;  /* I forgot what this means */
 	int state;
 } trap_t;
 
@@ -78,27 +78,27 @@
 /* Node attributes for every node in the query structure */
 
 typedef struct {
-	int nodetype;			/* Y-node or S-node */
+	int nodetype;   /* Y-node or S-node */
 	int segnum;
 	point_t yval;
 	int trnum;
-	int parent;			/* doubly linked DAG */
-	int left, right;		/* children */
+	int parent;   /* doubly linked DAG */
+	int left, right;  /* children */
 } node_t;
 
 
 typedef struct {
 	int vnum;
-	int next;			/* Circularly linked list  */
-	int prev;			/* describing the monotone */
-	int marked;			/* polygon */
+	int next;   /* Circularly linked list  */
+	int prev;   /* describing the monotone */
+	int marked;   /* polygon */
 } monchain_t;
 
 
 typedef struct {
 	point_t pt;
-	int vnext[4];			/* next vertices for the 4 chains */
-	int vpos[4];			/* position of v in the 4 chains */
+	int vnext[4];   /* next vertices for the 4 chains */
+	int vpos[4];   /* position of v in the 4 chains */
 	int nextfree;
 } vertexchain_t;
 
@@ -112,41 +112,41 @@
 #define T_SINK  3
 
 
-#define SEGSIZE SEI_SS	/* max# of segments. Determines how */
+#define SEGSIZE SEI_SS /* max# of segments. Determines how */
 /* many points can be specified as */
 /* input. If your datasets have large */
 /* number of points, increase this */
 /* value accordingly. */
 
-#define QSIZE   8*SEGSIZE	/* maximum table sizes */
-#define TRSIZE  4*SEGSIZE	/* max# trapezoids */
+#define QSIZE   8*SEGSIZE /* maximum table sizes */
+#define TRSIZE  4*SEGSIZE /* max# trapezoids */
 
 
 #define TRUE  1
 #define FALSE 0
 
 
-#define FIRSTPT 1		/* checking whether pt. is inserted */
+#define FIRSTPT 1  /* checking whether pt. is inserted */
 #define LASTPT  2
 
 
 #define INFINITY 1<<30
-#define C_EPS 1.0e-7		/* tolerance value: Used for making */
+#define C_EPS 1.0e-7  /* tolerance value: Used for making */
 /* all decisions about collinearity or */
 /* left/right of segment. Decrease */
 /* this value if the input points are */
 /* spaced very close together */
 
 
-#define S_LEFT 1		/* for merge-direction */
+#define S_LEFT 1  /* for merge-direction */
 #define S_RIGHT 2
 
 
-#define ST_VALID 1		/* for trapezium state */
+#define ST_VALID 1  /* for trapezium state */
 #define ST_INVALID 2
 
 
-#define SP_SIMPLE_LRUP 1	/* for splitting trapezoids */
+#define SP_SIMPLE_LRUP 1 /* for splitting trapezoids */
 #define SP_SIMPLE_LRDN 2
 #define SP_2UP_2DN     3
 #define SP_2UP_LEFT    4
@@ -155,7 +155,7 @@
 #define SP_2DN_RIGHT   7
 #define SP_NOSPLIT    -1
 
-#define TR_FROM_UP 1		/* for traverse-direction */
+#define TR_FROM_UP 1  /* for traverse-direction */
 #define TR_FROM_DN 2
 
 #define TRI_LHS 1
@@ -166,7 +166,7 @@
 #define MIN(a, b) (((a) < (b)) ? (a) : (b))
 
 #define CROSS(v0, v1, v2) (((v1).x - (v0).x)*((v2).y - (v0).y) - \
-			   ((v1).y - (v0).y)*((v2).x - (v0).x))
+      ((v1).y - (v0).y)*((v2).x - (v0).x))
 
 #define DOT(v0, v1) ((v0).x * (v1).x + (v0).y * (v1).y)
 
@@ -176,9 +176,9 @@
 
 /* Global variables */
 
-extern node_t qs[QSIZE];		/* Query structure */
-extern trap_t tr[TRSIZE];		/* Trapezoid structure */
-extern segment_t seg[SEGSIZE];		/* Segment table */
+extern node_t qs[QSIZE];  /* Query structure */
+extern trap_t tr[TRSIZE];  /* Trapezoid structure */
+extern segment_t seg[SEGSIZE];  /* Segment table */
 
 
 /* Functions */

Modified: trunk/libs3d/shm.c
===================================================================
--- trunk/libs3d/shm.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/shm.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,31 +24,31 @@
 
 #include "s3d.h"
 #include "s3dlib.h"
-#include <stdlib.h> 	/* malloc() */
+#include <stdlib.h>  /* malloc() */
 #include <sys/types.h>
 #include <sys/ipc.h>
 #include <sys/shm.h>
-#include <netinet/in.h>	/* ntohs() */
-#include <errno.h> 		/* errno */
+#include <netinet/in.h> /* ntohs() */
+#include <errno.h>   /* errno */
 
 #ifndef _POSIX_C_SOURCE
-#define _POSIX_C_SOURCE 199309		/* we want struct timespec to be defined */
+#define _POSIX_C_SOURCE 199309  /* we want struct timespec to be defined */
 #endif
 #ifndef __USE_POSIX199309
 #define __USE_POSIX199309 1
 #endif
-#include <time.h>		 /*  nanosleep() */
+#include <time.h>   /*  nanosleep() */
 
 #ifdef SHM
 
-#define SHM_SIZE 		sizeof(key_t)*2  		/* space for the keys */
-#define SHM_MAXLOOP		100
-#define RB_STD_SIZE		1024*512
-static struct buf_t *data_in,*data_out;
+#define SHM_SIZE   sizeof(key_t)*2    /* space for the keys */
+#define SHM_MAXLOOP  100
+#define RB_STD_SIZE  1024*512
+static struct buf_t *data_in, *data_out;
 static int shmid_in, shmid_out;
-static int shm_idle=0;
-struct timespec t= {
-	0,10*1000*1000
+static int shm_idle = 0;
+struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili second */
 /* char ftoken[]="/tmp/.s3d_shm";*/
 
@@ -56,58 +56,58 @@
 {
 	int shmid;
 	uint32_t *next_key;
-	/*	struct shmid_ds *buf; */
-	key_t key,key_out,key_in;
+	/* struct shmid_ds *buf; */
+	key_t key, key_out, key_in;
 
-	s3dprintf(MED,"connecting to shm token %s",ftoken);
+	s3dprintf(MED, "connecting to shm token %s", ftoken);
 	/* make the key: */
 	if ((key = ftok(ftoken, 'R')) == -1) {
-		errn("shm_init():ftok()",errno);
+		errn("shm_init():ftok()", errno);
 		return(1);
 	}
-	s3dprintf(MED,"init key is 0x%08x",key);
+	s3dprintf(MED, "init key is 0x%08x", key);
 
 	/* connect to the segment: */
-	if ((shmid = shmget(key, SHM_SIZE, 0644 )) == -1) {
-		errn("shm_init():shmget()",errno);
+	if ((shmid = shmget(key, SHM_SIZE, 0644)) == -1) {
+		errn("shm_init():shmget()", errno);
 		return(1);
 	}
 
 	/* attach to the segment to get a pointer to it: */
 	next_key = shmat(shmid, (void *)0, 0);
 	if (next_key == (uint32_t *)(-1)) {
-		errn("shm_init():shmat()",errno);
+		errn("shm_init():shmat()", errno);
 		return(1);
 	}
-	s3dprintf(MED,"right now, next_keys are: %08x, %08x",next_key[0],next_key[1]);
-	while ((0==(key_in=next_key[1])) || (0==(key_out=next_key[0])));
-	next_key[0]=next_key[1]=0;
-	s3dprintf(MED,"right now, next_keys are: %08x, %08x",key_in,key_out);
+	s3dprintf(MED, "right now, next_keys are: %08x, %08x", next_key[0], next_key[1]);
+	while ((0 == (key_in = next_key[1])) || (0 == (key_out = next_key[0])));
+	next_key[0] = next_key[1] = 0;
+	s3dprintf(MED, "right now, next_keys are: %08x, %08x", key_in, key_out);
 	/* as we have the new key, we  can detach here now. */
 	if (shmdt(next_key) == -1) {
-		errn("shm_init():shmdt()",errno);
+		errn("shm_init():shmdt()", errno);
 		return(1);
 	}
 	/* get input buffer */
-	if ((shmid_in = shmget(key_in, RB_STD_SIZE, 0644 )) == -1) {
-		errn("shm_init():shmget()",errno);
+	if ((shmid_in = shmget(key_in, RB_STD_SIZE, 0644)) == -1) {
+		errn("shm_init():shmget()", errno);
 		return(1);
 	}
 	/* attach to the  in segment to get a pointer to it: */
 	data_in = (struct buf_t *) shmat(shmid_in, (void *)0, 0);
 	if (data_in == (struct buf_t *)(-1)) {
-		errn("shm_init():shmat()",errno);
+		errn("shm_init():shmat()", errno);
 		return(1);
 	}
 	/* get output buffer */
-	if ((shmid_out = shmget(key_out, RB_STD_SIZE, 0644 )) == -1) {
-		errn("shm_init():shmget()",errno);
+	if ((shmid_out = shmget(key_out, RB_STD_SIZE, 0644)) == -1) {
+		errn("shm_init():shmget()", errno);
 		return(1);
 	}
 	/* attach to the out segment to get a pointer to it: */
 	data_out = (struct buf_t *) shmat(shmid_out, (void *)0, 0);
 	if (data_out == (struct buf_t *)(-1)) {
-		errn("shm_init():shmat()",errno);
+		errn("shm_init():shmat()", errno);
 		return(1);
 	}
 	return(0);
@@ -116,85 +116,85 @@
 {
 	/* detach from the segment: */
 	if (shmdt(data_in) == -1) {
-		errn("shm_init():shmdt()",errno);
+		errn("shm_init():shmdt()", errno);
 		return(1);
 	}
 	if (shmdt(data_out) == -1) {
-		errn("shm_init():shmdt()",errno);
+		errn("shm_init():shmdt()", errno);
 		return(1);
 	}
-	data_in=data_out=NULL;
+	data_in = data_out = NULL;
 	return(0);
 }
 int shm_writen(char *str, int s)
 {
-	int no_left,no_written,wait=0;
+	int no_left, no_written, wait = 0;
 	no_left = s;
 	while (no_left > 0) {
-		no_written = shm_write(data_out,str,no_left);
-		if (no_written <0)
+		no_written = shm_write(data_out, str, no_left);
+		if (no_written < 0)
 			return(no_written);
 		no_left -= no_written;
 		str += no_written;
-		if (wait++>SHM_MAXLOOP) {
-			s3dprintf(HIGH,"shm_writen():waited too long ...");
+		if (wait++ > SHM_MAXLOOP) {
+			s3dprintf(HIGH, "shm_writen():waited too long ...");
 			return(-1);
 		}
-		/*		if (wait>10)
-					nanosleep(&t,NULL); */
+		/*  if (wait>10)
+		   nanosleep(&t,NULL); */
 	}
 	return(s - no_left);
 }
-int shm_readn(char *str,int s)
+int shm_readn(char *str, int s)
 {
-	int no_left,no_read,wait=0;
+	int no_left, no_read, wait = 0;
 	no_left = s;
 	while (no_left > 0) {
-		no_read = shm_read(data_in,str,no_left);
-		if (no_read <0)
+		no_read = shm_read(data_in, str, no_left);
+		if (no_read < 0)
 			return(no_read);
 		if (no_read == 0)
 			break;
 		no_left -= no_read;
 		str += no_read;
-		if (wait++>SHM_MAXLOOP) {
-			s3dprintf(HIGH,"shm_readn():waited too long ...");
+		if (wait++ > SHM_MAXLOOP) {
+			s3dprintf(HIGH, "shm_readn():waited too long ...");
 			return(-1);
 		}
-		/*		if (wait>10)
-					nanosleep(&t,NULL); */
+		/*  if (wait>10)
+		   nanosleep(&t,NULL); */
 	}
 	return(s - no_left);
 }
 int _shm_net_receive()
 {
-	int 				 found=0;
-	char				 opcode,*buf;
-	u_int16_t		 length;
-	struct shmid_ds		 d;
+	int      found = 0;
+	char     opcode, *buf;
+	u_int16_t   length;
+	struct shmid_ds   d;
 
-	if (data_in==NULL)
+	if (data_in == NULL)
 		return(found);
-	if (data_in->start!=data_in->end) {
-		if (1==shm_readn(&opcode,1)) {
-			shm_readn((char *)&length,2);
-			length=ntohs(length);
-			buf=malloc(length);
-			shm_readn(buf,length);
-			net_prot_in(opcode,length,buf);
-			found=1;
+	if (data_in->start != data_in->end) {
+		if (1 == shm_readn(&opcode, 1)) {
+			shm_readn((char *)&length, 2);
+			length = ntohs(length);
+			buf = malloc(length);
+			shm_readn(buf, length);
+			net_prot_in(opcode, length, buf);
+			found = 1;
 		} else {
-			s3dprintf(HIGH,"socket seems to be dead ...");
+			s3dprintf(HIGH, "socket seems to be dead ...");
 			s3d_quit();
 		}
 	} else {
-		if (shm_idle++>SHM_MAX_IDLE) {
-			shmctl(shmid_in,IPC_STAT,&d);
-			if (d.shm_nattch==1) { /* we're all alone ... remove it!! */
-				s3dprintf(MED,"server vanished ... ");
+		if (shm_idle++ > SHM_MAX_IDLE) {
+			shmctl(shmid_in, IPC_STAT, &d);
+			if (d.shm_nattch == 1) { /* we're all alone ... remove it!! */
+				s3dprintf(MED, "server vanished ... ");
 				s3d_quit();
 			} else
-				shm_idle=0;
+				shm_idle = 0;
 		}
 	}
 	return(found);

Modified: trunk/libs3d/shm_ringbuf.c
===================================================================
--- trunk/libs3d/shm_ringbuf.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/shm_ringbuf.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,77 +25,77 @@
 #include "s3d.h"
 #include "s3dlib.h"
 #include <stdint.h> /* uint32_t */
-#include <string.h>	/* memcpy() */
+#include <string.h> /* memcpy() */
 #ifdef SHM
-int shm_write(struct buf_t *rb,char *buf, int n)
+int shm_write(struct buf_t *rb, char *buf, int n)
 {
-	int wrap=0;
+	int wrap = 0;
 	int rs;
-	uint32_t e,s,size;
+	uint32_t e, s, size;
 	char *data;
 
-	e=rb->end;
-	s=rb->start;
-	size=rb->bufsize;
-	data=((char *)rb)+sizeof(struct buf_t);
-	if (e<s) {
-		wrap=1;
+	e = rb->end;
+	s = rb->start;
+	size = rb->bufsize;
+	data = ((char *)rb) + sizeof(struct buf_t);
+	if (e < s) {
+		wrap = 1;
 	}
-	while ((((s+size*(1-wrap))-e)<(n+1))) { /* checking free space */
+	while ((((s + size*(1 - wrap)) - e) < (n + 1))) { /* checking free space */
 		if /*((size*2)>RB_MAX_SIZE)*/ (1) {
-			/*		s3dprintf(MED,"buffer reached maxsize, no resizing possible");*/
+			/*  s3dprintf(MED,"buffer reached maxsize, no resizing possible");*/
 			return(0);
 		}
-		/*		printf("buffer full!! resizing ... (to size %d)",(int)size*2);
-				if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
-				{
-					printf("realloc failed - fatal!!");
-					return(-1);
-				}
-				if (wrap)
-				{
-					memcpy(data+size,data,e);
-					e+=size;
-					wrap=0;
-				}
-				size=rb->bufsize=size*2;
-				rb->end=e;*/
+		/*  printf("buffer full!! resizing ... (to size %d)",(int)size*2);
+		  if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
+		  {
+		   printf("realloc failed - fatal!!");
+		   return(-1);
+		  }
+		  if (wrap)
+		  {
+		   memcpy(data+size,data,e);
+		   e+=size;
+		   wrap=0;
+		  }
+		  size=rb->bufsize=size*2;
+		  rb->end=e;*/
 	}
-	if ((e+n)>size) {
-		rs=size-e;
-		memcpy(data+e,buf,rs);			/* copy the first part ... */
-		memcpy(data,buf+rs,n-rs); 		/* .. end the rest */
+	if ((e + n) > size) {
+		rs = size - e;
+		memcpy(data + e, buf, rs);   /* copy the first part ... */
+		memcpy(data, buf + rs, n - rs);   /* .. end the rest */
 	} else {
-		memcpy(data+e,buf,n);			/* plain copy */
+		memcpy(data + e, buf, n);   /* plain copy */
 	}
-	rb->end=e+n;	/* update end of the buffer */
-	if (rb->end>=rb->bufsize) rb->end-=rb->bufsize;
+	rb->end = e + n; /* update end of the buffer */
+	if (rb->end >= rb->bufsize) rb->end -= rb->bufsize;
 	return(n);
 }
-int shm_read(struct buf_t *rb,char *buf, int n)
+int shm_read(struct buf_t *rb, char *buf, int n)
 {
-	int wrap=0;
-	int mn=n;
+	int wrap = 0;
+	int mn = n;
 	int rs;
-	uint32_t e,s,size;
+	uint32_t e, s, size;
 	char *data;
 
-	e=rb->end;
-	s=rb->start;
-	size=rb->bufsize;
-	data=((char *)rb)+sizeof(struct buf_t);
-	if (e<s) wrap=1;
-	rs=(e+wrap*size-s);
-	mn=(n>rs)?rs:n;
-	if ((wrap) && (mn>(size-s))) {
-		rs=size-s;	/* size of the first part */
-		memcpy(buf,data+s,rs);
-		memcpy(buf+rs,data,mn-rs);
+	e = rb->end;
+	s = rb->start;
+	size = rb->bufsize;
+	data = ((char *)rb) + sizeof(struct buf_t);
+	if (e < s) wrap = 1;
+	rs = (e + wrap * size - s);
+	mn = (n > rs) ? rs : n;
+	if ((wrap) && (mn > (size - s))) {
+		rs = size - s; /* size of the first part */
+		memcpy(buf, data + s, rs);
+		memcpy(buf + rs, data, mn - rs);
 	} else { /* no wrap (needed)*/
-		memcpy(buf,data+s,mn);
+		memcpy(buf, data + s, mn);
 	}
-	rb->start=s+mn;
-	if (rb->start>=rb->bufsize) rb->start-=rb->bufsize;
+	rb->start = s + mn;
+	if (rb->start >= rb->bufsize) rb->start -= rb->bufsize;
 	return(mn);
 }
 #endif

Modified: trunk/libs3d/tcp.c
===================================================================
--- trunk/libs3d/tcp.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/tcp.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,45 +24,45 @@
 #include "s3d.h"
 #include "s3dlib.h"
 #include <sys/types.h>
-#include <stdlib.h>		 /*  malloc(), free() */
-#include <unistd.h>		 /*  read(), write() */
-#include <errno.h>		 /*  errno */
-#include <string.h> 	 /*  memcpy() */
+#include <stdlib.h>   /*  malloc(), free() */
+#include <unistd.h>   /*  read(), write() */
+#include <errno.h>   /*  errno */
+#include <string.h>   /*  memcpy() */
 #include <sys/socket.h>
 #include <netinet/in.h>  /*  htons(),htonl() */
 #ifndef WIN32
 #include <sys/select.h>
-#include <netdb.h>		 /*  gethostbyname()  */
+#include <netdb.h>   /*  gethostbyname()  */
 #endif
 #ifdef SIGS
-#define __USE_BSD	1		/* we want sig_t and F_SETOWN to be defined */
-#include <fcntl.h>		 /*  fcntl */
-#include <signal.h>		 /*  signal(), SIGPIPE, SIGIO */
+#define __USE_BSD 1  /* we want sig_t and F_SETOWN to be defined */
+#include <fcntl.h>   /*  fcntl */
+#include <signal.h>   /*  signal(), SIGPIPE, SIGIO */
 extern int _s3d_sigio;
 #endif
 
-int s3d_socket;		 /*  this is the socket which holds the tcp-socket .... */
+int s3d_socket;   /*  this is the socket which holds the tcp-socket .... */
 
 #ifdef SIGS
 void sigpipe_handler(int S3DUNUSED(sig), int S3DUNUSED(code))  /*  ... ? */
 {
-	errs("sigpipe_handler()","there is a broken pipe somewhere");
+	errs("sigpipe_handler()", "there is a broken pipe somewhere");
 }
 void sigio_handler(int S3DUNUSED(sig), int S3DUNUSED(code))  /*  ... ? */
 {
-	_s3d_sigio=1;
+	_s3d_sigio = 1;
 }
 #endif
 
 int _tcp_init(char *sv, int pn)
 {
-	int 	 			 sd;
-	int 				 res;
-	/*	char			 	*port=NULL;*/
-	struct sockaddr_in 	 sock;
-	struct hostent 		*server=0;
+	int       sd;
+	int      res;
+	/* char     *port=NULL;*/
+	struct sockaddr_in   sock;
+	struct hostent   *server = 0;
 #ifdef SIGS
-	_s3d_sigio=0;
+	_s3d_sigio = 0;
 #endif
 #ifdef WIN32
 	WSADATA datainfo;
@@ -72,70 +72,70 @@
 	}
 #endif
 	if ((sd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
-		errn("s3d_init():socket()",errno);
+		errn("s3d_init():socket()", errno);
 		return (-1);
 	}
 	sock.sin_family = AF_INET;
-	if (*sv==0)  /*  no server argument */
-		sv="127.0.0.1";
+	if (*sv == 0)  /*  no server argument */
+		sv = "127.0.0.1";
 	if ((server = gethostbyname(sv)))
 		memcpy(&sock.sin_addr.s_addr, server->h_addr_list[0], 4);
 	else {
-		errn("s3d_init():gethostbyname()",errno);
+		errn("s3d_init():gethostbyname()", errno);
 		return(-1);
 	}
 	sock.sin_port = htons(pn);
 
-	res = connect(sd, (struct sockaddr *) &sock, sizeof(struct sockaddr_in));
-	if (res < 0 ) {
-		errn("s3d_init():connect()",errno);
+	res = connect(sd, (struct sockaddr *) & sock, sizeof(struct sockaddr_in));
+	if (res < 0) {
+		errn("s3d_init():connect()", errno);
 		return(-1);
 	}
 	/*    if ( fcntl(sd, F_SETFL, O_ASYNC | O_NONBLOCK) < 0 ) */
-	/* 		errn("fcntl()",errno); */
+	/*   errn("fcntl()",errno); */
 #ifdef SIGS
-	if ( fcntl(sd, F_SETFL, O_ASYNC ) < 0 )
-		errn("fcntl()",errno);
-	if ( fcntl(sd, F_SETOWN, getpid()) < 0 )
-		errn("fcntl()",errno);
+	if (fcntl(sd, F_SETFL, O_ASYNC) < 0)
+		errn("fcntl()", errno);
+	if (fcntl(sd, F_SETOWN, getpid()) < 0)
+		errn("fcntl()", errno);
 	if (signal(SIGPIPE, (sig_t)sigpipe_handler) == SIG_ERR)
-		errn("_tcp_init():signal()",errno);
+		errn("_tcp_init():signal()", errno);
 	if (signal(SIGIO, (sig_t)sigio_handler) == SIG_ERR)
-		errn("_tcp_init():signal()",errno);
+		errn("_tcp_init():signal()", errno);
 #endif
-	s3d_socket=sd;
-	s3dprintf(MED,"connection to %s:%d established", sv, pn);
+	s3d_socket = sd;
+	s3dprintf(MED, "connection to %s:%d established", sv, pn);
 	return(0);
 }
 int _tcp_quit()
 {
 	if (s3d_socket) {
-		s3dprintf(MED,"closing socket %d",s3d_socket);
+		s3dprintf(MED, "closing socket %d", s3d_socket);
 		close(s3d_socket);
-		s3d_socket=0;
+		s3d_socket = 0;
 	}
 	return(0);
 }
-int tcp_readn(char *str,int s)
+int tcp_readn(char *str, int s)
 {
-	int no_left,no_read;
+	int no_left, no_read;
 	no_left = s;
 	while (no_left > 0) {
-		no_read = read(s3d_socket,str,no_left);
-		if (no_read <0)  return(no_read);
+		no_read = read(s3d_socket, str, no_left);
+		if (no_read < 0)  return(no_read);
 		if (no_read == 0) break;
 		no_left -= no_read;
 		str += no_read;
 	}
 	return(s - no_left);
 }
-int tcp_writen(char *str,int s)
+int tcp_writen(char *str, int s)
 {
-	int no_left,no_written;
+	int no_left, no_written;
 	no_left = s;
 	while (no_left > 0) {
-		no_written = write(s3d_socket,str,no_left);
-		if (no_written <=0)  return(no_written);
+		no_written = write(s3d_socket, str, no_left);
+		if (no_written <= 0)  return(no_written);
 		no_left -= no_written;
 		str += no_written;
 	}
@@ -143,33 +143,33 @@
 }
 int _s3d_tcp_net_receive()
 {
-	fd_set				 fs_proc; 	 /*  filedescriptor set for listening port(s) */
-	struct timeval		 tv;		 /*  time structure */
-	int 				 found=0;
-	char				 opcode,*buf;
-	u_int16_t		 length;
+	fd_set     fs_proc;   /*  filedescriptor set for listening port(s) */
+	struct timeval   tv;   /*  time structure */
+	int      found = 0;
+	char     opcode, *buf;
+	u_int16_t   length;
 
 
-	if (s3d_socket!=-1) {
+	if (s3d_socket != -1) {
 		FD_ZERO(&fs_proc);
-		tv.tv_sec=tv.tv_usec=0;
-		FD_SET(s3d_socket,&fs_proc);
+		tv.tv_sec = tv.tv_usec = 0;
+		FD_SET(s3d_socket, &fs_proc);
 
 		/* s3dprintf(LOW,"Added %d procceses into file descriptor ...", n); */
-		if (select(FD_SETSIZE, &fs_proc, NULL,NULL,&tv) ==-1) {
-			errn("select()",errno);
+		if (select(FD_SETSIZE, &fs_proc, NULL, NULL, &tv) == -1) {
+			errn("select()", errno);
 		} else {
 			/*  data is available */
-			if (FD_ISSET(s3d_socket,&fs_proc)) {
-				if (1==tcp_readn(&opcode,1)) {
-					tcp_readn((char *)&length,2);
-					length=ntohs(length);
-					buf=malloc(length);
-					tcp_readn(buf,length);
-					net_prot_in(opcode,length,buf);
-					found=1;
+			if (FD_ISSET(s3d_socket, &fs_proc)) {
+				if (1 == tcp_readn(&opcode, 1)) {
+					tcp_readn((char *)&length, 2);
+					length = ntohs(length);
+					buf = malloc(length);
+					tcp_readn(buf, length);
+					net_prot_in(opcode, length, buf);
+					found = 1;
 				} else {
-					s3dprintf(HIGH,"socket seems to be dead ...");
+					s3dprintf(HIGH, "socket seems to be dead ...");
 					s3d_quit();
 				}
 			}

Modified: trunk/libs3d/vector.c
===================================================================
--- trunk/libs3d/vector.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3d/vector.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,7 +23,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#include <math.h>		/* sqrt() */
+#include <math.h>  /* sqrt() */
 #include "s3d.h"
 
 /***
@@ -36,10 +36,10 @@
  *
  ***/
 
-float s3d_vector_length( float vector[] )
+float s3d_vector_length(float vector[])
 {
 
-	return ( sqrt( vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2] ) );
+	return (sqrt(vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2]));
 
 }
 
@@ -54,7 +54,7 @@
  *
  ***/
 
-void s3d_vector_subtract( float vector1[], float vector2[], float result_vector[] )
+void s3d_vector_subtract(float vector1[], float vector2[], float result_vector[])
 {
 
 	result_vector[0] = vector2[0] - vector1[0];
@@ -74,9 +74,9 @@
  *
  ***/
 
-float s3d_vector_dot_product( float vector1[], float vector2[] )
+float s3d_vector_dot_product(float vector1[], float vector2[])
 {
-	return ( vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2] );
+	return (vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2]);
 }
 
 /***
@@ -85,16 +85,16 @@
  *
  *   vector1         =>   given vector1
  *   vector2         =>   given vector2
- *	 result_vector   =>   save resulting vector here
+ *  result_vector   =>   save resulting vector here
  *   return dot product
  *
  ***/
 
-void s3d_vector_cross_product( float vector1[], float vector2[], float result_vector[] )
+void s3d_vector_cross_product(float vector1[], float vector2[], float result_vector[])
 {
-	result_vector[0]=vector1[1] * vector2[2] - vector1[2] * vector2[1];
-	result_vector[1]=vector1[2] * vector2[0] - vector1[0] * vector2[2];
-	result_vector[2]=vector1[0] * vector2[1] - vector1[1] * vector2[0];
+	result_vector[0] = vector1[1] * vector2[2] - vector1[2] * vector2[1];
+	result_vector[1] = vector1[2] * vector2[0] - vector1[0] * vector2[2];
+	result_vector[2] = vector1[0] * vector2[1] - vector1[1] * vector2[0];
 }
 /***
  *
@@ -109,10 +109,10 @@
  *
  ***/
 
-float s3d_vector_angle( float vector1[], float vector2[] )
+float s3d_vector_angle(float vector1[], float vector2[])
 {
 
-	return ( acos( s3d_vector_dot_product( vector1, vector2 ) / ( s3d_vector_length( vector1 ) * s3d_vector_length( vector2 ) ) ) );
+	return (acos(s3d_vector_dot_product(vector1, vector2) / (s3d_vector_length(vector1) * s3d_vector_length(vector2))));
 
 }
 
@@ -128,7 +128,7 @@
  *
  ***/
 
-float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad )
+float s3d_angle_to_cam(float obj_pos[], float cam_pos[], float *angle_rad)
 {
 
 	float angle, tmp_mov_vec[3], desc_norm_vec[3] = { 0.0, 0.0, -1.0 };
@@ -138,15 +138,15 @@
 	tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
 	tmp_mov_vec[2] = cam_pos[2] - obj_pos[2];
 
-	angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
+	angle = s3d_vector_angle(desc_norm_vec, tmp_mov_vec);
 
 	/* take care of inverse cosinus */
-	if ( tmp_mov_vec[0] > 0 ) {
-		*angle_rad = 90.0/M_PI - angle;
-		angle = 180 - ( 180.0/M_PI * angle );
+	if (tmp_mov_vec[0] > 0) {
+		*angle_rad = 90.0 / M_PI - angle;
+		angle = 180 - (180.0 / M_PI * angle);
 	} else {
-		*angle_rad = 90.0/M_PI + angle;
-		angle = 180 + ( 180.0/M_PI * angle );
+		*angle_rad = 90.0 / M_PI + angle;
+		angle = 180 + (180.0 / M_PI * angle);
 	}
 
 	return angle;

Modified: trunk/libs3dw/animate.c
===================================================================
--- trunk/libs3dw/animate.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/animate.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -28,17 +28,17 @@
 
 /* the animation stack */
 static s3dw_widget *ani_s[MAXANI];
-static int ani_n=0;
-static int animation_on=0;
-int ani_need_arr=0;
+static int ani_n = 0;
+static int animation_on = 0;
+int ani_need_arr = 0;
 
 /* is item f already on stack? */
 int s3dw_ani_onstack(s3dw_widget *f)
 {
 	int i;
-	for (i=0;i<ani_n;i++)
-		if (ani_s[i]==f)
-			return(1);		/* already in list */
+	for (i = 0;i < ani_n;i++)
+		if (ani_s[i] == f)
+			return(1);  /* already in list */
 	return(0);
 
 }
@@ -46,90 +46,90 @@
 void s3dw_ani_add(s3dw_widget *f)
 {
 
-	if ((f->oid == 0) && (f->type!=S3DW_TCAM)) {
-		s3dprintf(HIGH,"s3dw_ani_add() assert failed: weird, moving cam but its not a cam obeject?");
+	if ((f->oid == 0) && (f->type != S3DW_TCAM)) {
+		s3dprintf(HIGH, "s3dw_ani_add() assert failed: weird, moving cam but its not a cam obeject?");
 		return;
 	}
-	if ((ani_n<MAXANI) && (animation_on)) {
+	if ((ani_n < MAXANI) && (animation_on)) {
 		if (s3dw_ani_onstack(f))
-			return;		/* already in list */
-		ani_s[ani_n]=f;
+			return;  /* already in list */
+		ani_s[ani_n] = f;
 		s3dw_ani_iterate(f);
 		ani_n++;
 	} else /* no place, finish now */
-		s3dw_ani_finish(f,-1);
+		s3dw_ani_finish(f, -1);
 }
 /* delete an item from the animation stack */
 void s3dw_ani_del(int i)
 {
-	if ((i>=0) && (i<ani_n)) {
-		/*		printf("[A]ni DEL %d\n",i);*/
+	if ((i >= 0) && (i < ani_n)) {
+		/*  printf("[A]ni DEL %d\n",i);*/
 		ani_n--;
-		ani_s[i]=ani_s[ani_n]; /* that should also work if i is the last one */
+		ani_s[i] = ani_s[ani_n]; /* that should also work if i is the last one */
 	} else {
-		s3dprintf(MED,"[F]ATAL: can't delete animation!\n");
+		s3dprintf(MED, "[F]ATAL: can't delete animation!\n");
 	}
 }
 /* well ... */
 void s3dw_ani_doit(s3dw_widget *f)
 {
-	if ((f->oid == 0) && (f->type!=S3DW_TCAM)) {
-		s3dprintf(HIGH,"s3dw_ani_doit() assert failed: weird, moving cam but its not a cam obeject?");
+	if ((f->oid == 0) && (f->type != S3DW_TCAM)) {
+		s3dprintf(HIGH, "s3dw_ani_doit() assert failed: weird, moving cam but its not a cam obeject?");
 	} else {
-		if (f->oid==0) {
-			s3dprintf(HIGH,"moving cam");
+		if (f->oid == 0) {
+			s3dprintf(HIGH, "moving cam");
 		}
-		s3d_translate(	f->oid, f->ax,f->ay,f->az);
-		s3d_rotate(		f->oid, f->arx,f->ary,f->arz);
-		s3d_scale(		f->oid, f->as);
+		s3d_translate(f->oid, f->ax, f->ay, f->az);
+		s3d_rotate(f->oid, f->arx, f->ary, f->arz);
+		s3d_scale(f->oid, f->as);
 	}
 }
 
 /* finish an animation on the stack, stack index i */
 void s3dw_ani_finish(s3dw_widget *f, int i)
 {
-	f->ax= f->x;
-	f->ay= f->y;
-	f->az= f->z;
-	f->arx= f->rx;
-	f->ary= f->ry;
-	f->arz= f->rz;
-	f->as= f->s;
+	f->ax = f->x;
+	f->ay = f->y;
+	f->az = f->z;
+	f->arx = f->rx;
+	f->ary = f->ry;
+	f->arz = f->rz;
+	f->as = f->s;
 	s3dw_ani_doit(f);
-	if (i!=-1)
+	if (i != -1)
 		s3dw_ani_del(i);
 }
 void s3dw_ani_iterate(s3dw_widget *f)
 {
-	f->ax=(f->x + f->ax*ZOOMS)/(ZOOMS+1);
-	f->ay=(f->y + f->ay*ZOOMS)/(ZOOMS+1);
-	f->az=(f->z + f->az*ZOOMS)/(ZOOMS+1);
-	f->arx=(f->rx + f->arx*ZOOMS)/(ZOOMS+1);
-	f->ary=(f->ry + f->ary*ZOOMS)/(ZOOMS+1);
-	f->arz=(f->rz + f->arz*ZOOMS)/(ZOOMS+1);
-	f->as=(f->s + f->as*ZOOMS)/(ZOOMS+1);
+	f->ax = (f->x + f->ax * ZOOMS) / (ZOOMS + 1);
+	f->ay = (f->y + f->ay * ZOOMS) / (ZOOMS + 1);
+	f->az = (f->z + f->az * ZOOMS) / (ZOOMS + 1);
+	f->arx = (f->rx + f->arx * ZOOMS) / (ZOOMS + 1);
+	f->ary = (f->ry + f->ary * ZOOMS) / (ZOOMS + 1);
+	f->arz = (f->rz + f->arz * ZOOMS) / (ZOOMS + 1);
+	f->as = (f->s + f->as * ZOOMS) / (ZOOMS + 1);
 
 }
 
 /* checks if f is good enough */
 int s3dw_ani_check(s3dw_widget *f)
 {
-	float x,y,z,rx,ry,rz;
-	x=f->ax - f->x;
-	y=f->ay - f->y;
-	z=f->az - f->z;
-	rx=f->arx - f->rx;
-	ry=f->ary - f->ry;
-	rz=f->arz - f->rz;
+	float x, y, z, rx, ry, rz;
+	x = f->ax - f->x;
+	y = f->ay - f->y;
+	z = f->az - f->z;
+	rx = f->arx - f->rx;
+	ry = f->ary - f->ry;
+	rz = f->arz - f->rz;
 
-	if (((fabs(f->as - f->s)/f->s)>0.01) || (sqrt(x*x+y*y+z*z) > 0.01) || (sqrt(rx*rx+ry*ry+rz*rz) > 0.01))
+	if (((fabs(f->as - f->s) / f->s) > 0.01) || (sqrt(x*x + y*y + z*z) > 0.01) || (sqrt(rx*rx + ry*ry + rz*rz) > 0.01))
 		return(0);
 	return(1);
 }
 /* need an arrangement ... */
 void s3dw_ani_needarr()
 {
-	ani_need_arr=1;
+	ani_need_arr = 1;
 	if (!animation_on) {
 		while (ani_need_arr) s3dw_arrange();
 	}
@@ -140,13 +140,13 @@
 {
 	int i;
 	s3dw_widget *f;
-	animation_on=1;			/* animation is activated */
+	animation_on = 1; /* animation is activated */
 	if (ani_need_arr) s3dw_arrange();
-	for (i=0;i<ani_n;i++) {
-		f=ani_s[i];
+	for (i = 0;i < ani_n;i++) {
+		f = ani_s[i];
 		s3dw_ani_iterate(f);
 		if (s3dw_ani_check(f)) {
-			s3dw_ani_finish(f,i);
+			s3dw_ani_finish(f, i);
 			i--; /* a new widget is here now, take care in the next iteration */
 		} else {
 			s3dw_ani_doit(f);

Modified: trunk/libs3dw/arrange.c
===================================================================
--- trunk/libs3dw/arrange.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/arrange.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,121 +25,121 @@
 #include <s3dw.h>
 #include <s3dw_int.h>
 #include <stdlib.h> /* rand(), RAND_MAX */
-#include <math.h>	/* M_PI */
-#define R2D		(180/M_PI)
-s3dw_widget *_s3dw_cam=NULL;
+#include <math.h> /* M_PI */
+#define R2D  (180/M_PI)
+s3dw_widget *_s3dw_cam = NULL;
 extern int ani_need_arr;
 
 void s3dw_arr_widgetcenter(s3dw_widget *widget, float *center)
 {
-	float x,y,z,xt,yt,zt;
-	x=widget->s*widget->width/2;
-	y=widget->s*-widget->height/2+0.5;
-	z=widget->s*0.5;
+	float x, y, z, xt, yt, zt;
+	x = widget->s * widget->width / 2;
+	y = widget->s * -widget->height / 2 + 0.5;
+	z = widget->s * 0.5;
 	/* calc back rotation */
 	/* around the y axis (horizontal direction) */
-	xt= cos(widget->ry/R2D)*x + sin(widget->ry/R2D) *z;
-	yt=y;
-	zt=-sin(widget->ry/R2D)*x + cos(widget->ry/R2D) *z;
+	xt = cos(widget->ry / R2D) * x + sin(widget->ry / R2D) * z;
+	yt = y;
+	zt = -sin(widget->ry / R2D) * x + cos(widget->ry / R2D) * z;
 
 	/* around the x axis (vertical direction) */
-	x=xt;
-	y= cos(widget->rx/R2D)*yt + sin(widget->rx/R2D) *zt;
-	z=-sin(widget->rx/R2D)*yt + cos(widget->rx/R2D) *zt;
+	x = xt;
+	y = cos(widget->rx / R2D) * yt + sin(widget->rx / R2D) * zt;
+	z = -sin(widget->rx / R2D) * yt + cos(widget->rx / R2D) * zt;
 
-	center[0]=x;
-	center[1]=y;
-	center[2]=z;
+	center[0] = x;
+	center[1] = y;
+	center[2] = z;
 }
 void s3dw_arr_normdir(float *dir)
 {
-	float dirlen=s3d_vector_length(dir);
-	while ((dirlen=s3d_vector_length(dir))==0) {
+	float dirlen = s3d_vector_length(dir);
+	while ((dirlen = s3d_vector_length(dir)) == 0) {
 		/* make up some random direction if they're exactly the same position */
-		dir[0]=((float)rand() - RAND_MAX/2.0)/RAND_MAX;
-		dir[1]=((float)rand() - RAND_MAX/2.0)/RAND_MAX;
-		dir[2]=((float)rand() - RAND_MAX/2.0)/RAND_MAX;
+		dir[0] = ((float)rand() - RAND_MAX / 2.0) / RAND_MAX;
+		dir[1] = ((float)rand() - RAND_MAX / 2.0) / RAND_MAX;
+		dir[2] = ((float)rand() - RAND_MAX / 2.0) / RAND_MAX;
 	}
-	dir[0]/=dirlen;
-	dir[1]/=dirlen;
-	dir[2]/=dirlen;
+	dir[0] /= dirlen;
+	dir[1] /= dirlen;
+	dir[2] /= dirlen;
 }
 void s3dw_turn()
 {
-	s3dw_widget *w,*root=s3dw_getroot();
+	s3dw_widget *w, *root = s3dw_getroot();
 	int i;
-	float a[3],b[3],rx,ry;
-	float op[3],np[3];
-	a[0]=0;
-	a[1]=0;
-	a[2]=1;
-	for (i=0;i<root->nobj;i++) {
-		w=root->pobj[i];
-		if ((w->oid!=0) && (w->flags&S3DW_TURN_CAM)) {
-			s3dw_arr_widgetcenter(w,op);
+	float a[3], b[3], rx, ry;
+	float op[3], np[3];
+	a[0] = 0;
+	a[1] = 0;
+	a[2] = 1;
+	for (i = 0;i < root->nobj;i++) {
+		w = root->pobj[i];
+		if ((w->oid != 0) && (w->flags&S3DW_TURN_CAM)) {
+			s3dw_arr_widgetcenter(w, op);
 			/* horizontal movement */
-			b[0]=w->x + op[0]  - _s3dw_cam->x;
-			b[1]=0;
-			b[2]=w->z + op[2]  - _s3dw_cam->z;
-			ry=180*s3d_vector_angle(a,b)/M_PI;
-			if ((b[0]==0) && (b[1]==0) && (b[2]==0)) ry=0;
+			b[0] = w->x + op[0]  - _s3dw_cam->x;
+			b[1] = 0;
+			b[2] = w->z + op[2]  - _s3dw_cam->z;
+			ry = 180 * s3d_vector_angle(a, b) / M_PI;
+			if ((b[0] == 0) && (b[1] == 0) && (b[2] == 0)) ry = 0;
 			/* correct acos incompletness */
-			if (b[0]<0) ry=180-ry;
-			else 		ry=180+ry;
+			if (b[0] < 0) ry = 180 - ry;
+			else   ry = 180 + ry;
 
-			b[2]=sqrt(b[0]*b[0] + b[2]*b[2]);
-			b[1]=w->y + op[1]   - _s3dw_cam->y;
-			b[0]=0;
-			rx=180*s3d_vector_angle(a,b)/M_PI;
-			if ((b[0]==0) && (b[1]==0) && (b[2]==0)) rx=0;
-			if (b[1]>0) rx=180-rx;
-			else 		rx=180+rx;
-			if 		((rx>90) && (rx<=180)) 	 rx=180 - rx;
-			else if ((rx>=180) && (rx<270))  rx=540 - rx ;
+			b[2] = sqrt(b[0] * b[0] + b[2] * b[2]);
+			b[1] = w->y + op[1]   - _s3dw_cam->y;
+			b[0] = 0;
+			rx = 180 * s3d_vector_angle(a, b) / M_PI;
+			if ((b[0] == 0) && (b[1] == 0) && (b[2] == 0)) rx = 0;
+			if (b[1] > 0) rx = 180 - rx;
+			else   rx = 180 + rx;
+			if ((rx > 90) && (rx <= 180))   rx = 180 - rx;
+			else if ((rx >= 180) && (rx < 270))  rx = 540 - rx ;
 
-			w->rx=rx;
-			w->ry=ry;
-			if ((w->arx - w->rx)>180)  w->arx-=360;
-			if ((w->arx - w->rx)<-180) w->arx+=360;
-			if ((w->ary - w->ry)>180)  w->ary-=360;
-			if ((w->ary - w->ry)<-180) w->ary+=360;
+			w->rx = rx;
+			w->ry = ry;
+			if ((w->arx - w->rx) > 180)  w->arx -= 360;
+			if ((w->arx - w->rx) < -180) w->arx += 360;
+			if ((w->ary - w->ry) > 180)  w->ary -= 360;
+			if ((w->ary - w->ry) < -180) w->ary += 360;
 
 
-			s3dw_arr_widgetcenter(w,np);
-			w->x-=np[0] - op[0];
-			w->y-=np[1] - op[1];
-			w->z-=np[2] - op[2];
+			s3dw_arr_widgetcenter(w, np);
+			w->x -= np[0] - op[0];
+			w->y -= np[1] - op[1];
+			w->z -= np[2] - op[2];
 
 			s3dw_ani_add(w);
 		}
 	}
 }
-#define DIST	40.0
+#define DIST 40.0
 void s3dw_follow()
 {
-	s3dw_widget *w,*root=s3dw_getroot();
+	s3dw_widget *w, *root = s3dw_getroot();
 	int i;
 	float b[3];
 	float op[3];
-	float lsqr,l;
-	for (i=0;i<root->nobj;i++) {
-		w=root->pobj[i];
-		if ((w->oid!=0) && (w->flags&S3DW_FOLLOW_CAM))
+	float lsqr, l;
+	for (i = 0;i < root->nobj;i++) {
+		w = root->pobj[i];
+		if ((w->oid != 0) && (w->flags&S3DW_FOLLOW_CAM))
 
 		{
-			s3dw_arr_widgetcenter(w,op);
+			s3dw_arr_widgetcenter(w, op);
 			/* horizontal movement */
-			b[0]=_s3dw_cam->x - (w->x + op[0]);
-			b[1]=_s3dw_cam->y - (w->y + op[1]);
-			b[2]=_s3dw_cam->z - (w->z + op[2]);
-			if ((lsqr=(b[0]*b[0] + b[1]*b[1] + b[2]*b[2])) > (DIST * DIST)) {
+			b[0] = _s3dw_cam->x - (w->x + op[0]);
+			b[1] = _s3dw_cam->y - (w->y + op[1]);
+			b[2] = _s3dw_cam->z - (w->z + op[2]);
+			if ((lsqr = (b[0] * b[0] + b[1] * b[1] + b[2] * b[2])) > (DIST * DIST)) {
 				/* need to adjust ... */
-				l=sqrt(lsqr);
-				w->x+= b[0]-b[0]*DIST/l;
-				w->y+= b[1]-b[1]*DIST/l;
-				w->z+= b[2]-b[2]*DIST/l;
-				w->flags&=~S3DW_ARRANGED;
-				ani_need_arr=1;
+				l = sqrt(lsqr);
+				w->x += b[0] - b[0] * DIST / l;
+				w->y += b[1] - b[1] * DIST / l;
+				w->z += b[2] - b[2] * DIST / l;
+				w->flags &= ~S3DW_ARRANGED;
+				ani_need_arr = 1;
 				s3dw_ani_add(w);
 
 			}
@@ -148,50 +148,50 @@
 }
 void s3dw_arrange()
 {
-	s3dw_widget *w1,*w2,*root=s3dw_getroot();
-	int i,j,arranged,allarr;
-	float len1,len2, dirlen;
+	s3dw_widget *w1, *w2, *root = s3dw_getroot();
+	int i, j, arranged, allarr;
+	float len1, len2, dirlen;
 	float tomove, move1, move2;
-	float f1[3],f2[3],dir[3];
+	float f1[3], f2[3], dir[3];
 
 	/* test if there is anything to arrange ... */
-	arranged=1;
-	for (i=0;i<root->nobj;i++)
-		if (!(root->pobj[i]->flags&S3DW_ARRANGED)) arranged=0;
+	arranged = 1;
+	for (i = 0;i < root->nobj;i++)
+		if (!(root->pobj[i]->flags&S3DW_ARRANGED)) arranged = 0;
 	if (arranged && !ani_need_arr) return; /* no arrangement necceasary .... */
 
-	ani_need_arr=0;
-	if (root->nobj==1) {
-		w1=root->pobj[0];
-		w1->flags|=S3DW_ARRANGED; /* done */
+	ani_need_arr = 0;
+	if (root->nobj == 1) {
+		w1 = root->pobj[0];
+		w1->flags |= S3DW_ARRANGED; /* done */
 		return;
 	}
-	allarr=1;
-	for (i=0;i<root->nobj;i++) {
-		w1=root->pobj[i];
-		arranged=1;
-		for (j=0;j<root->nobj;j++) {
-			w2=root->pobj[j];
-			if ((i!=j) && ((w1->oid!=0) && (w2->oid!=0))) {
-				s3dw_arr_widgetcenter(w1,f1);
-				s3dw_arr_widgetcenter(w2,f2);
-				len1=s3d_vector_length(f1);
-				len2=s3d_vector_length(f2);
-				dir[0]=(w1->x+f1[0]) - (w2->x+f2[0]);
-				dir[1]=(w1->y+f1[1]) - (w2->y+f2[1]);
-				dir[2]=(w1->z+f1[2]) - (w2->z+f2[2]);
-				dirlen=s3d_vector_length(dir);
-				if (dirlen<(len1+len2)) {
-					allarr=0;
-					arranged=0;
-					w1->flags&=~S3DW_ARRANGED;
-					w2->flags&=~S3DW_ARRANGED;
+	allarr = 1;
+	for (i = 0;i < root->nobj;i++) {
+		w1 = root->pobj[i];
+		arranged = 1;
+		for (j = 0;j < root->nobj;j++) {
+			w2 = root->pobj[j];
+			if ((i != j) && ((w1->oid != 0) && (w2->oid != 0))) {
+				s3dw_arr_widgetcenter(w1, f1);
+				s3dw_arr_widgetcenter(w2, f2);
+				len1 = s3d_vector_length(f1);
+				len2 = s3d_vector_length(f2);
+				dir[0] = (w1->x + f1[0]) - (w2->x + f2[0]);
+				dir[1] = (w1->y + f1[1]) - (w2->y + f2[1]);
+				dir[2] = (w1->z + f1[2]) - (w2->z + f2[2]);
+				dirlen = s3d_vector_length(dir);
+				if (dirlen < (len1 + len2)) {
+					allarr = 0;
+					arranged = 0;
+					w1->flags &= ~S3DW_ARRANGED;
+					w2->flags &= ~S3DW_ARRANGED;
 					/* it's not arranged, turn the flags off! */
 					s3dw_arr_normdir(dir);
-					tomove=((len1+len2+1)-dirlen);
-					move1=len1/(len1+len2);
-					move2=len2/(len1+len2);
-					if (w1->oid!=0) {
+					tomove = ((len1 + len2 + 1) - dirlen);
+					move1 = len1 / (len1 + len2);
+					move2 = len2 / (len1 + len2);
+					if (w1->oid != 0) {
 						w1->x += tomove * move1 *  dir[0];
 						w1->y += tomove * move1 *  dir[1];
 						w1->z += tomove * move1 *  dir[2];
@@ -202,7 +202,7 @@
 						w2->z += tomove * move2 * -dir[2];
 
 					}
-					if (w2->oid!=0) {
+					if (w2->oid != 0) {
 						w2->x += tomove * move2 * -dir[0];
 						w2->y += tomove * move2 * -dir[1];
 						w2->z += tomove * move2 * -dir[2];
@@ -216,9 +216,9 @@
 			}
 		}
 		if (arranged)
-			w1->flags|=S3DW_ARRANGED;
+			w1->flags |= S3DW_ARRANGED;
 	}
-	if (allarr)	ani_need_arr=0;
+	if (allarr) ani_need_arr = 0;
 	s3dw_turn();
 	s3dw_follow();
 }

Modified: trunk/libs3dw/button.c
===================================================================
--- trunk/libs3dw/button.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/button.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -30,60 +30,60 @@
 /* draw and setup the button */
 void s3dw_button_draw(s3dw_widget *widget)
 {
-	s3dw_button *button=(s3dw_button *)widget;
+	s3dw_button *button = (s3dw_button *)widget;
 	float length;
 	float vertices[8*3];
-	u_int32_t polygons[10*4]={
-		0,4,5,0,
-		0,5,1,0,
-		1,5,6,0,
-		1,6,2,0,
-		2,6,7,0,
-		2,7,3,0,
-		3,7,4,0,
-		3,4,0,0,
-		4,7,6,0,
-		4,6,5,0
+	u_int32_t polygons[10*4] = {
+		0, 4, 5, 0,
+		0, 5, 1, 0,
+		1, 5, 6, 0,
+		1, 6, 2, 0,
+		2, 6, 7, 0,
+		2, 7, 3, 0,
+		3, 7, 4, 0,
+		3, 4, 0, 0,
+		4, 7, 6, 0,
+		4, 6, 5, 0
 	};
 
-	button->oid_text=s3d_draw_string(button->text,&length);
-	s3d_pep_materials_a(button->oid_text,widget->style->text_mat,1);
+	button->oid_text = s3d_draw_string(button->text, &length);
+	s3d_pep_materials_a(button->oid_text, widget->style->text_mat, 1);
 
 	/* width of the button depends on the length of the text */
-	vertices[0*3+0]=0.0;
-	vertices[0*3+1]=0.0;
-	vertices[0*3+2]=0.0;
-	vertices[1*3+0]=0.0;
-	vertices[1*3+1]=-2.0;
-	vertices[1*3+2]=0.0;
-	vertices[2*3+0]=length+1;
-	vertices[2*3+1]=-2.0;
-	vertices[2*3+2]=0.0;
-	vertices[3*3+0]=length+1;
-	vertices[3*3+1]=0.0;
-	vertices[3*3+2]=0.0;
-	vertices[4*3+0]=0.25;
-	vertices[4*3+1]=-0.25;
-	vertices[4*3+2]=0.25;
-	vertices[5*3+0]=0.25;
-	vertices[5*3+1]=-1.75;
-	vertices[5*3+2]=0.25;
-	vertices[6*3+0]=length+0.75;
-	vertices[6*3+1]=-1.75;
-	vertices[6*3+2]=0.25;
-	vertices[7*3+0]=length+0.75;
-	vertices[7*3+1]=-0.25;
-	vertices[7*3+2]=0.25;
-	widget->oid=s3d_new_object();
-	s3d_push_materials_a(widget->oid,widget->style->input_mat,1);
-	s3d_push_vertices   (widget->oid,vertices,8);
-	s3d_push_polygons   (widget->oid,polygons,10);
-	s3d_link(		   widget->oid,widget->parent->oid);
-	s3d_link(		   button->oid_text,widget->oid);
-	s3d_translate(button->oid_text,0.5,-1.5,0.30);
-	s3d_translate(widget->oid,widget->x,-widget->y,0);
-	widget->width=length+1;
-	widget->height=2;
+	vertices[0*3+0] = 0.0;
+	vertices[0*3+1] = 0.0;
+	vertices[0*3+2] = 0.0;
+	vertices[1*3+0] = 0.0;
+	vertices[1*3+1] = -2.0;
+	vertices[1*3+2] = 0.0;
+	vertices[2*3+0] = length + 1;
+	vertices[2*3+1] = -2.0;
+	vertices[2*3+2] = 0.0;
+	vertices[3*3+0] = length + 1;
+	vertices[3*3+1] = 0.0;
+	vertices[3*3+2] = 0.0;
+	vertices[4*3+0] = 0.25;
+	vertices[4*3+1] = -0.25;
+	vertices[4*3+2] = 0.25;
+	vertices[5*3+0] = 0.25;
+	vertices[5*3+1] = -1.75;
+	vertices[5*3+2] = 0.25;
+	vertices[6*3+0] = length + 0.75;
+	vertices[6*3+1] = -1.75;
+	vertices[6*3+2] = 0.25;
+	vertices[7*3+0] = length + 0.75;
+	vertices[7*3+1] = -0.25;
+	vertices[7*3+2] = 0.25;
+	widget->oid = s3d_new_object();
+	s3d_push_materials_a(widget->oid, widget->style->input_mat, 1);
+	s3d_push_vertices(widget->oid, vertices, 8);
+	s3d_push_polygons(widget->oid, polygons, 10);
+	s3d_link(widget->oid, widget->parent->oid);
+	s3d_link(button->oid_text, widget->oid);
+	s3d_translate(button->oid_text, 0.5, -1.5, 0.30);
+	s3d_translate(widget->oid, widget->x, -widget->y, 0);
+	widget->width = length + 1;
+	widget->height = 2;
 }
 
 /* create a new button in the surface */
@@ -91,14 +91,14 @@
 {
 	s3dw_button *button;
 	s3dw_widget *widget;
-	button=(s3dw_button *)malloc(sizeof(s3dw_button));
-	button->text=strdup(text);
-	button->onclick=s3dw_nothing;
-	widget=s3dw_widget_new((s3dw_widget *)button);
-	widget->type=S3DW_TBUTTON;
-	widget->x=posx;
-	widget->y=posy;
-	widget->style=((s3dw_widget *)surface)->style;
+	button = (s3dw_button *)malloc(sizeof(s3dw_button));
+	button->text = strdup(text);
+	button->onclick = s3dw_nothing;
+	widget = s3dw_widget_new((s3dw_widget *)button);
+	widget->type = S3DW_TBUTTON;
+	widget->x = posx;
+	widget->y = posy;
+	widget->style = ((s3dw_widget *)surface)->style;
 
 	s3dw_widget_append((s3dw_widget *)surface, widget);
 	s3dw_button_draw(widget);
@@ -107,21 +107,21 @@
 /* show, make visible */
 void s3dw_button_show(s3dw_widget *widget)
 {
-	s3dw_button *button=(s3dw_button *)widget;
-	s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(button->oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_button *button = (s3dw_button *)widget;
+	s3d_flags_on(widget->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(button->oid_text, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* hide */
 void s3dw_button_hide(s3dw_widget *widget)
 {
-	s3dw_button *button=(s3dw_button *)widget;
-	s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(button->oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_button *button = (s3dw_button *)widget;
+	s3d_flags_off(widget->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(button->oid_text, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* destroy s3d structures of the button */
 void s3dw_button_erase(s3dw_widget *widget)
 {
-	s3dw_button *button=(s3dw_button *)widget;
+	s3dw_button *button = (s3dw_button *)widget;
 	s3d_del_object(button->oid_text);
 	s3d_del_object(widget->oid);
 }
@@ -129,7 +129,7 @@
 /* destroy the button */
 void s3dw_button_destroy(s3dw_widget *widget)
 {
-	s3dw_button *button=(s3dw_button *)widget;
+	s3dw_button *button = (s3dw_button *)widget;
 	s3dw_button_erase(widget);
 	free(button->text);
 	free(button);
@@ -143,8 +143,8 @@
 /* handle click on a button */
 int s3dw_button_event_click(s3dw_widget *widget, u_int32_t oid)
 {
-	s3dw_button *button=(s3dw_button *)widget;
-	if ((button->oid_text==oid) || (widget->oid==oid)) {
+	s3dw_button *button = (s3dw_button *)widget;
+	if ((button->oid_text == oid) || (widget->oid == oid)) {
 		button->onclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/event.c
===================================================================
--- trunk/libs3dw/event.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/event.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -27,28 +27,28 @@
 extern s3dw_widget *_s3dw_cam;
 int s3dw_handle_click(struct s3d_evt *evt)
 {
-	uint32_t oid=*((uint32_t *)evt->buf);
-	return(s3dw_widget_event_click(s3dw_getroot(),oid));
+	uint32_t oid = *((uint32_t *)evt->buf);
+	return(s3dw_widget_event_click(s3dw_getroot(), oid));
 }
 int s3dw_handle_key(struct s3d_evt *evt)
 {
-	struct s3d_key_event *keys=(struct s3d_key_event *)evt->buf;
-	return(s3dw_widget_event_key(s3dw_getroot(),keys));
+	struct s3d_key_event *keys = (struct s3d_key_event *)evt->buf;
+	return(s3dw_widget_event_key(s3dw_getroot(), keys));
 }
 
 int s3dw_object_info(struct s3d_evt *evt)
 {
-	struct s3d_obj_info *info=(struct s3d_obj_info *)evt->buf;
-	if (info->object==0) { /* the _s3dw_cam */
-		if (_s3dw_cam==NULL)	s3dw_getroot(); /* init, get _s3dw_cam */
-		_s3dw_cam->ax=_s3dw_cam->x=info->trans_x;
-		_s3dw_cam->ay=_s3dw_cam->y=info->trans_y;
-		_s3dw_cam->az=_s3dw_cam->z=info->trans_z;
-		_s3dw_cam->arx=_s3dw_cam->rx=info->rot_x;
-		_s3dw_cam->ary=_s3dw_cam->ry=info->rot_y;
-		_s3dw_cam->arz=_s3dw_cam->rz=info->rot_z;
+	struct s3d_obj_info *info = (struct s3d_obj_info *)evt->buf;
+	if (info->object == 0) { /* the _s3dw_cam */
+		if (_s3dw_cam == NULL) s3dw_getroot(); /* init, get _s3dw_cam */
+		_s3dw_cam->ax = _s3dw_cam->x = info->trans_x;
+		_s3dw_cam->ay = _s3dw_cam->y = info->trans_y;
+		_s3dw_cam->az = _s3dw_cam->z = info->trans_z;
+		_s3dw_cam->arx = _s3dw_cam->rx = info->rot_x;
+		_s3dw_cam->ary = _s3dw_cam->ry = info->rot_y;
+		_s3dw_cam->arz = _s3dw_cam->rz = info->rot_z;
 
-		_s3dw_cam->flags&=~S3DW_ARRANGED;
+		_s3dw_cam->flags &= ~S3DW_ARRANGED;
 		s3dw_ani_needarr();
 	}
 	return(0);

Modified: trunk/libs3dw/input.c
===================================================================
--- trunk/libs3dw/input.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/input.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -28,130 +28,130 @@
 #include <s3dw_int.h>
 #include <stdlib.h> /* malloc() */
 #include <string.h> /* strdup(),strlen() */
-#include <ctype.h>	/* isprint */
+#include <ctype.h> /* isprint */
 
 uint32_t s3dw_input_draw_string(s3dw_widget *widget)
 {
-	s3dw_input *input=(s3dw_input *)widget;
+	s3dw_input *input = (s3dw_input *)widget;
 	uint32_t oid_text;
 	int i;
 	float tlen;
-	if (widget->width<1) return(-1);
-	i=0;
-	while (s3d_strlen(input->text+i) > (widget->width-1)) i++;
-	oid_text=s3d_draw_string(input->text+i,&tlen);
-	s3d_pep_materials_a(oid_text,widget->style->text_mat,1);
-	s3d_translate( oid_text,0.5,-1.5,0.30);
-	s3d_link(	   oid_text,widget->oid);
+	if (widget->width < 1) return(-1);
+	i = 0;
+	while (s3d_strlen(input->text + i) > (widget->width - 1)) i++;
+	oid_text = s3d_draw_string(input->text + i, &tlen);
+	s3d_pep_materials_a(oid_text, widget->style->text_mat, 1);
+	s3d_translate(oid_text, 0.5, -1.5, 0.30);
+	s3d_link(oid_text, widget->oid);
 	return (oid_text);
 }
 void s3dw_input_draw(s3dw_widget *widget)
 {
-	s3dw_input *input=(s3dw_input *)widget;
+	s3dw_input *input = (s3dw_input *)widget;
 	float length;
 	float vertices[12*3];
-	uint32_t polygons[18*4]={
-		0,4,5,1,
-		0,5,1,1,
-		1,5,6,1,
-		1,6,2,1,
-		2,6,7,1,
-		2,7,3,1,
-		3,7,4,1,
-		3,4,0,1,
+	uint32_t polygons[18*4] = {
+		0, 4, 5, 1,
+		0, 5, 1, 1,
+		1, 5, 6, 1,
+		1, 6, 2, 1,
+		2, 6, 7, 1,
+		2, 7, 3, 1,
+		3, 7, 4, 1,
+		3, 4, 0, 1,
 
-		4,8, 9, 1,
-		4,9, 5, 1,
-		5,9, 10,1,
-		5,10,6, 1,
-		6,10,11,1,
-		6,11,7, 1,
-		7,11,8, 1,
-		7,8, 4, 1,
+		4, 8, 9, 1,
+		4, 9, 5, 1,
+		5, 9, 10, 1,
+		5, 10, 6, 1,
+		6, 10, 11, 1,
+		6, 11, 7, 1,
+		7, 11, 8, 1,
+		7, 8, 4, 1,
 
 
-		8,11,10,0,
-		8,10,9, 0
+		8, 11, 10, 0,
+		8, 10, 9, 0
 	};
-	length=widget->width-1;
-	if (widget->width<1) return;
-	widget->height=2;
+	length = widget->width - 1;
+	if (widget->width < 1) return;
+	widget->height = 2;
 	/* width of the input depends on the length of the text */
-	vertices[0*3+0]=0.0;
-	vertices[0*3+1]=0.0;
-	vertices[0*3+2]=0.0;
-	vertices[1*3+0]=0.0;
-	vertices[1*3+1]=-2.0;
-	vertices[1*3+2]=0.0;
-	vertices[2*3+0]=length+1;
-	vertices[2*3+1]=-2.0;
-	vertices[2*3+2]=0.0;
-	vertices[3*3+0]=length+1;
-	vertices[3*3+1]=0.0;
-	vertices[3*3+2]=0.0;
-	vertices[4*3+0]=0.125;
-	vertices[4*3+1]=-0.125;
-	vertices[4*3+2]=0.25;
-	vertices[5*3+0]=0.125;
-	vertices[5*3+1]=-1.875;
-	vertices[5*3+2]=0.25;
-	vertices[6*3+0]=length+0.875;
-	vertices[6*3+1]=-1.875;
-	vertices[6*3+2]=0.25;
-	vertices[7*3+0]=length+0.875;
-	vertices[7*3+1]=-0.125;
-	vertices[7*3+2]=0.25;
-	vertices[8*3+0]=0.25;
-	vertices[8*3+1]=-0.25;
-	vertices[8*3+2]=0.125;
-	vertices[9*3+0]=0.25;
-	vertices[9*3+1]=-1.75;
-	vertices[9*3+2]=0.125;
-	vertices[10*3+0]=length+0.75;
-	vertices[10*3+1]=-1.75;
-	vertices[10*3+2]=0.125;
-	vertices[11*3+0]=length+0.75;
-	vertices[11*3+1]=-0.25;
-	vertices[11*3+2]=0.125;
-	widget->oid=s3d_new_object();
-	s3d_push_materials_a(widget->oid,widget->style->inputback_mat,1);
-	s3d_push_materials_a(widget->oid,widget->style->input_mat,1);
-	s3d_push_vertices   (widget->oid,vertices,12);
-	s3d_push_polygons   (widget->oid,polygons,18);
-	s3d_link(		   widget->oid,widget->parent->oid);
-	s3d_translate(widget->oid,widget->x,-widget->y,0);
+	vertices[0*3+0] = 0.0;
+	vertices[0*3+1] = 0.0;
+	vertices[0*3+2] = 0.0;
+	vertices[1*3+0] = 0.0;
+	vertices[1*3+1] = -2.0;
+	vertices[1*3+2] = 0.0;
+	vertices[2*3+0] = length + 1;
+	vertices[2*3+1] = -2.0;
+	vertices[2*3+2] = 0.0;
+	vertices[3*3+0] = length + 1;
+	vertices[3*3+1] = 0.0;
+	vertices[3*3+2] = 0.0;
+	vertices[4*3+0] = 0.125;
+	vertices[4*3+1] = -0.125;
+	vertices[4*3+2] = 0.25;
+	vertices[5*3+0] = 0.125;
+	vertices[5*3+1] = -1.875;
+	vertices[5*3+2] = 0.25;
+	vertices[6*3+0] = length + 0.875;
+	vertices[6*3+1] = -1.875;
+	vertices[6*3+2] = 0.25;
+	vertices[7*3+0] = length + 0.875;
+	vertices[7*3+1] = -0.125;
+	vertices[7*3+2] = 0.25;
+	vertices[8*3+0] = 0.25;
+	vertices[8*3+1] = -0.25;
+	vertices[8*3+2] = 0.125;
+	vertices[9*3+0] = 0.25;
+	vertices[9*3+1] = -1.75;
+	vertices[9*3+2] = 0.125;
+	vertices[10*3+0] = length + 0.75;
+	vertices[10*3+1] = -1.75;
+	vertices[10*3+2] = 0.125;
+	vertices[11*3+0] = length + 0.75;
+	vertices[11*3+1] = -0.25;
+	vertices[11*3+2] = 0.125;
+	widget->oid = s3d_new_object();
+	s3d_push_materials_a(widget->oid, widget->style->inputback_mat, 1);
+	s3d_push_materials_a(widget->oid, widget->style->input_mat, 1);
+	s3d_push_vertices(widget->oid, vertices, 12);
+	s3d_push_polygons(widget->oid, polygons, 18);
+	s3d_link(widget->oid, widget->parent->oid);
+	s3d_translate(widget->oid, widget->x, -widget->y, 0);
 
-	input->oid_text=s3dw_input_draw_string(widget);
+	input->oid_text = s3dw_input_draw_string(widget);
 }
 /* show the input */
 void s3dw_input_show(s3dw_widget *widget)
 {
-	s3dw_input *input=(s3dw_input *)widget;
-	s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(input->oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_input *input = (s3dw_input *)widget;
+	s3d_flags_on(widget->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(input->oid_text, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* hides the input */
 void s3dw_input_hide(s3dw_widget *widget)
 {
-	s3dw_input *input=(s3dw_input *)widget;
-	s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(input->oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_input *input = (s3dw_input *)widget;
+	s3d_flags_off(widget->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(input->oid_text, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* create a new input in the surface */
 s3dw_input *s3dw_input_new(s3dw_surface *surface, float width, float posx, float posy)
 {
 	s3dw_input *input;
 	s3dw_widget *widget;
-	input=(s3dw_input *)malloc(sizeof(s3dw_input));
-	input->text=strdup("");
-	input->onclick=s3dw_nothing;
-	input->onedit=s3dw_nothing;
-	widget=s3dw_widget_new((s3dw_widget *)input);
-	widget->type=S3DW_TINPUT;
-	widget->x=posx;
-	widget->y=posy;
-	widget->width=width;
-	widget->height=2;
+	input = (s3dw_input *)malloc(sizeof(s3dw_input));
+	input->text = strdup("");
+	input->onclick = s3dw_nothing;
+	input->onedit = s3dw_nothing;
+	widget = s3dw_widget_new((s3dw_widget *)input);
+	widget->type = S3DW_TINPUT;
+	widget->x = posx;
+	widget->y = posy;
+	widget->width = width;
+	widget->height = 2;
 
 	s3dw_widget_append((s3dw_widget *)surface, widget);
 	s3dw_input_draw(widget);
@@ -159,7 +159,7 @@
 }
 void s3dw_input_erase(s3dw_widget *widget)
 {
-	s3dw_input *input=(s3dw_input *)widget;
+	s3dw_input *input = (s3dw_input *)widget;
 	s3d_del_object(input->oid_text);
 	s3d_del_object(widget->oid);
 
@@ -167,7 +167,7 @@
 /* destroy the input */
 void s3dw_input_destroy(s3dw_widget *widget)
 {
-	s3dw_input *input=(s3dw_input *)widget;
+	s3dw_input *input = (s3dw_input *)widget;
 	s3dw_input_erase(widget);
 	free(input->text);
 	free(input);
@@ -175,45 +175,45 @@
 /* changes the text of the input */
 void s3dw_input_change_text(s3dw_input *input, char *text)
 {
-	s3dw_widget *widget=(s3dw_widget *)input;
+	s3dw_widget *widget = (s3dw_widget *)input;
 	uint32_t oid_text;
 	/* redraw the text ... */
 	free(input->text);
-	input->text=strdup(text);
-	oid_text=s3dw_input_draw_string(widget);
+	input->text = strdup(text);
+	oid_text = s3dw_input_draw_string(widget);
 	if (widget->flags&S3DW_ONSCREEN)
-		s3d_flags_on(oid_text,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_on(oid_text, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 	s3d_del_object(input->oid_text);
-	input->oid_text=oid_text;
+	input->oid_text = oid_text;
 }
 /* handle key events */
 int s3dw_input_event_key(s3dw_widget *widget, struct s3d_key_event *keys)
 {
-	s3dw_input *input=(s3dw_input *)widget;
+	s3dw_input *input = (s3dw_input *)widget;
 	char *newtext;
-	char key=keys->unicode; /* unicode support so far ... :/ */
+	char key = keys->unicode; /* unicode support so far ... :/ */
 	int len;
-	s3dprintf(MED,"edit field got key %d!!",key);
+	s3dprintf(MED, "edit field got key %d!!", key);
 	switch (keys->keysym) {
 	case S3DK_BACKSPACE:
-		len=strlen(input->text);
-		if ((len=strlen(input->text))>0) {
-			newtext=malloc(len + 0); /* +1 for the terminating byte, -1 for the deleted character */
-			strncpy(newtext,input->text,len);
-			newtext[len-1]=0;
-			s3dw_input_change_text(input,newtext);
+		len = strlen(input->text);
+		if ((len = strlen(input->text)) > 0) {
+			newtext = malloc(len + 0); /* +1 for the terminating byte, -1 for the deleted character */
+			strncpy(newtext, input->text, len);
+			newtext[len-1] = 0;
+			s3dw_input_change_text(input, newtext);
 			free(newtext);
 			return(1);
 		}
 		break;
 	default:
 		if (isprint(key)) {
-			len=strlen(input->text);
-			newtext=malloc(len + 2); /* +1 for the terminating byte, +1 for the new character */
-			strcpy(newtext,input->text);
-			newtext[len]=key;
-			newtext[len+1]=0;
-			s3dw_input_change_text(input,newtext);
+			len = strlen(input->text);
+			newtext = malloc(len + 2); /* +1 for the terminating byte, +1 for the new character */
+			strcpy(newtext, input->text);
+			newtext[len] = key;
+			newtext[len+1] = 0;
+			s3dw_input_change_text(input, newtext);
 			free(newtext);
 			return(1);
 		}
@@ -225,8 +225,8 @@
 
 int s3dw_input_event_click(s3dw_widget *widget, uint32_t oid)
 {
-	s3dw_input *input=(s3dw_input *)widget;
-	if ((input->oid_text==oid) || (widget->oid==oid)) {
+	s3dw_input *input = (s3dw_input *)widget;
+	if ((input->oid_text == oid) || (widget->oid == oid)) {
 		s3dw_focus(widget);
 		input->onclick(widget);
 		return(1);

Modified: trunk/libs3dw/label.c
===================================================================
--- trunk/libs3dw/label.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/label.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -30,33 +30,33 @@
 
 void s3dw_label_draw(s3dw_widget *widget)
 {
-	s3dw_label *label=(s3dw_label *)widget;
+	s3dw_label *label = (s3dw_label *)widget;
 	float length;
-	widget->oid=s3d_draw_string(label->text,&length);
-	s3d_pep_materials_a(widget->oid,widget->style->text_mat,1);
-	s3d_link(widget->oid,widget->parent->oid);
-	s3d_translate(widget->oid,widget->x,-widget->y,0.1);
-	widget->width=length+1;
-	widget->height=2;
+	widget->oid = s3d_draw_string(label->text, &length);
+	s3d_pep_materials_a(widget->oid, widget->style->text_mat, 1);
+	s3d_link(widget->oid, widget->parent->oid);
+	s3d_translate(widget->oid, widget->x, -widget->y, 0.1);
+	widget->width = length + 1;
+	widget->height = 2;
 }
 /* show the label */
 void s3dw_label_show(s3dw_widget *widget)
 {
-	s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* hides the label */
 void s3dw_label_hide(s3dw_widget *widget)
 {
-	s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* change label text */
 void s3dw_label_change_text(s3dw_label *label, char *text)
 {
-	s3dw_widget *widget=(s3dw_widget *)label;
+	s3dw_widget *widget = (s3dw_widget *)label;
 
 	/* redraw the text ... */
 	free(label->text);
-	label->text=strdup(text);
+	label->text = strdup(text);
 	s3dw_label_erase(widget);
 	s3dw_label_draw(widget);
 	if (widget->flags&S3DW_ONSCREEN)
@@ -69,13 +69,13 @@
 {
 	s3dw_label *label;
 	s3dw_widget *widget;
-	label=(s3dw_label *)malloc(sizeof(s3dw_label));
-	widget=s3dw_widget_new((s3dw_widget *)label);
-	widget->type=S3DW_TLABEL;
-	widget->x=posx;
-	widget->y=posy;
-	label->text=strdup(text);
-	label->onclick=s3dw_nothing;
+	label = (s3dw_label *)malloc(sizeof(s3dw_label));
+	widget = s3dw_widget_new((s3dw_widget *)label);
+	widget->type = S3DW_TLABEL;
+	widget->x = posx;
+	widget->y = posy;
+	label->text = strdup(text);
+	label->onclick = s3dw_nothing;
 	s3dw_widget_append((s3dw_widget *)surface, widget);
 	s3dw_label_draw(widget);
 	return(label);
@@ -88,7 +88,7 @@
 /* destroy the label */
 void s3dw_label_destroy(s3dw_widget *widget)
 {
-	s3dw_label *label=(s3dw_label *)widget;
+	s3dw_label *label = (s3dw_label *)widget;
 	s3dw_label_erase(widget);
 	free(label->text);
 	free(label);
@@ -101,8 +101,8 @@
 /* handle click events */
 int s3dw_label_event_click(s3dw_widget *widget, uint32_t oid)
 {
-	s3dw_label *label=(s3dw_label *)widget;
-	if (widget->oid==oid) {
+	s3dw_label *label = (s3dw_label *)widget;
+	if (widget->oid == oid) {
 		label->onclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/root.c
===================================================================
--- trunk/libs3dw/root.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/root.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,14 +26,14 @@
 #include <s3dw_int.h>
 #include <stdlib.h> /* malloc() */
 #include <stdio.h>   /* printf() */
-s3dw_callback 		s3dwcb_show[S3DW_NTYPES];
-s3dw_callback 		s3dwcb_hide[S3DW_NTYPES];
-s3dw_callback 		s3dwcb_destroy[S3DW_NTYPES];
+s3dw_callback   s3dwcb_show[S3DW_NTYPES];
+s3dw_callback   s3dwcb_hide[S3DW_NTYPES];
+s3dw_callback   s3dwcb_destroy[S3DW_NTYPES];
 s3dw_click_callback s3dwcb_click[S3DW_NTYPES];
-s3dw_key_callback	s3dwcb_key[S3DW_NTYPES];
+s3dw_key_callback s3dwcb_key[S3DW_NTYPES];
 
 
-static s3dw_widget *root=NULL;
+static s3dw_widget *root = NULL;
 extern s3dw_widget *_s3dw_cam;
 
 /* just destroy the widget */
@@ -57,68 +57,68 @@
 /* get the root .... if it's NULL, the lib is not initialized, so do this too ... */
 s3dw_widget *s3dw_getroot()
 {
-	if (root==NULL) {
-		root=(s3dw_widget *)malloc(sizeof(s3dw_widget));
-		root=s3dw_widget_new(root);
-		root->type=S3DW_TROOT;
-		root->oid=s3d_new_object();
-		root->style=&def_style;
-		root->flags=S3DW_VISIBLE|S3DW_ACTIVE;
-		_s3dw_cam=(s3dw_widget *)malloc(sizeof(s3dw_widget));
+	if (root == NULL) {
+		root = (s3dw_widget *)malloc(sizeof(s3dw_widget));
+		root = s3dw_widget_new(root);
+		root->type = S3DW_TROOT;
+		root->oid = s3d_new_object();
+		root->style = &def_style;
+		root->flags = S3DW_VISIBLE | S3DW_ACTIVE;
+		_s3dw_cam = (s3dw_widget *)malloc(sizeof(s3dw_widget));
 		s3dw_widget_new(_s3dw_cam);
-		_s3dw_cam->type=S3DW_TCAM;
-		_s3dw_cam->oid=0;
-		_s3dw_cam->style=&def_style;
-		_s3dw_cam->s=10;
-		_s3dw_cam->width=1;
-		_s3dw_cam->height=0;
-		_s3dw_cam->flags=S3DW_VISIBLE|S3DW_ACTIVE;
+		_s3dw_cam->type = S3DW_TCAM;
+		_s3dw_cam->oid = 0;
+		_s3dw_cam->style = &def_style;
+		_s3dw_cam->s = 10;
+		_s3dw_cam->width = 1;
+		_s3dw_cam->height = 0;
+		_s3dw_cam->flags = S3DW_VISIBLE | S3DW_ACTIVE;
 
 		s3dw_widget_append(root, _s3dw_cam);
 		/* setup callback tables */
-		s3dwcb_show[S3DW_TROOT]=		s3dw_nothing;
-		s3dwcb_show[S3DW_TCAM]=			s3dw_nothing;
-		s3dwcb_show[S3DW_TSURFACE]=		s3dw_surface_show;
-		s3dwcb_show[S3DW_TBUTTON]=		s3dw_button_show;
-		s3dwcb_show[S3DW_TLABEL]=		s3dw_label_show;
-		s3dwcb_show[S3DW_TINPUT]=		s3dw_input_show;
-		s3dwcb_show[S3DW_TTEXTBOX]=		s3dw_textbox_show;
-		s3dwcb_show[S3DW_TSCROLLBAR]=	s3dw_scrollbar_show;
+		s3dwcb_show[S3DW_TROOT] =  s3dw_nothing;
+		s3dwcb_show[S3DW_TCAM] =   s3dw_nothing;
+		s3dwcb_show[S3DW_TSURFACE] =  s3dw_surface_show;
+		s3dwcb_show[S3DW_TBUTTON] =  s3dw_button_show;
+		s3dwcb_show[S3DW_TLABEL] =  s3dw_label_show;
+		s3dwcb_show[S3DW_TINPUT] =  s3dw_input_show;
+		s3dwcb_show[S3DW_TTEXTBOX] =  s3dw_textbox_show;
+		s3dwcb_show[S3DW_TSCROLLBAR] = s3dw_scrollbar_show;
 
-		s3dwcb_hide[S3DW_TROOT]=		s3dw_nothing;
-		s3dwcb_hide[S3DW_TSURFACE]=		s3dw_surface_hide;
-		s3dwcb_hide[S3DW_TBUTTON]=		s3dw_button_hide;
-		s3dwcb_hide[S3DW_TLABEL]=		s3dw_label_hide;
-		s3dwcb_hide[S3DW_TINPUT]=		s3dw_input_hide;
-		s3dwcb_hide[S3DW_TTEXTBOX]=		s3dw_textbox_hide;
-		s3dwcb_hide[S3DW_TSCROLLBAR]=	s3dw_scrollbar_hide;
+		s3dwcb_hide[S3DW_TROOT] =  s3dw_nothing;
+		s3dwcb_hide[S3DW_TSURFACE] =  s3dw_surface_hide;
+		s3dwcb_hide[S3DW_TBUTTON] =  s3dw_button_hide;
+		s3dwcb_hide[S3DW_TLABEL] =  s3dw_label_hide;
+		s3dwcb_hide[S3DW_TINPUT] =  s3dw_input_hide;
+		s3dwcb_hide[S3DW_TTEXTBOX] =  s3dw_textbox_hide;
+		s3dwcb_hide[S3DW_TSCROLLBAR] = s3dw_scrollbar_hide;
 
-		s3dwcb_destroy[S3DW_TROOT]=		s3dw_root_destroy;
-		s3dwcb_destroy[S3DW_TCAM]=		s3dw_root_destroy;
-		s3dwcb_destroy[S3DW_TSURFACE]=	s3dw_surface_destroy;
-		s3dwcb_destroy[S3DW_TBUTTON]=	s3dw_button_destroy;
-		s3dwcb_destroy[S3DW_TLABEL]=	s3dw_label_destroy;
-		s3dwcb_destroy[S3DW_TINPUT]=	s3dw_input_destroy;
-		s3dwcb_destroy[S3DW_TTEXTBOX]=	s3dw_textbox_destroy;
-		s3dwcb_destroy[S3DW_TSCROLLBAR]=s3dw_scrollbar_destroy;
+		s3dwcb_destroy[S3DW_TROOT] =  s3dw_root_destroy;
+		s3dwcb_destroy[S3DW_TCAM] =  s3dw_root_destroy;
+		s3dwcb_destroy[S3DW_TSURFACE] = s3dw_surface_destroy;
+		s3dwcb_destroy[S3DW_TBUTTON] = s3dw_button_destroy;
+		s3dwcb_destroy[S3DW_TLABEL] = s3dw_label_destroy;
+		s3dwcb_destroy[S3DW_TINPUT] = s3dw_input_destroy;
+		s3dwcb_destroy[S3DW_TTEXTBOX] = s3dw_textbox_destroy;
+		s3dwcb_destroy[S3DW_TSCROLLBAR] = s3dw_scrollbar_destroy;
 
-		s3dwcb_click[S3DW_TROOT]=		s3dw_click_nothing;
-		s3dwcb_click[S3DW_TCAM]=		s3dw_click_nothing;
-		s3dwcb_click[S3DW_TSURFACE]=	s3dw_surface_event_click;
-		s3dwcb_click[S3DW_TBUTTON]=		s3dw_button_event_click;
-		s3dwcb_click[S3DW_TLABEL]=		s3dw_label_event_click;
-		s3dwcb_click[S3DW_TINPUT]=		s3dw_input_event_click;
-		s3dwcb_click[S3DW_TTEXTBOX]=	s3dw_textbox_event_click;
-		s3dwcb_click[S3DW_TSCROLLBAR]=	s3dw_scrollbar_event_click;
+		s3dwcb_click[S3DW_TROOT] =  s3dw_click_nothing;
+		s3dwcb_click[S3DW_TCAM] =  s3dw_click_nothing;
+		s3dwcb_click[S3DW_TSURFACE] = s3dw_surface_event_click;
+		s3dwcb_click[S3DW_TBUTTON] =  s3dw_button_event_click;
+		s3dwcb_click[S3DW_TLABEL] =  s3dw_label_event_click;
+		s3dwcb_click[S3DW_TINPUT] =  s3dw_input_event_click;
+		s3dwcb_click[S3DW_TTEXTBOX] = s3dw_textbox_event_click;
+		s3dwcb_click[S3DW_TSCROLLBAR] = s3dw_scrollbar_event_click;
 
-		s3dwcb_key[S3DW_TROOT]=			s3dw_key_nothing;
-		s3dwcb_key[S3DW_TCAM]=			s3dw_key_nothing;
-		s3dwcb_key[S3DW_TSURFACE]=		s3dw_surface_event_key;
-		s3dwcb_key[S3DW_TBUTTON]=		s3dw_button_event_key;
-		s3dwcb_key[S3DW_TLABEL]=		s3dw_label_event_key;
-		s3dwcb_key[S3DW_TINPUT]=		s3dw_input_event_key;
-		s3dwcb_key[S3DW_TTEXTBOX]=		s3dw_key_nothing;
-		s3dwcb_key[S3DW_TSCROLLBAR]=	s3dw_key_nothing;
+		s3dwcb_key[S3DW_TROOT] =   s3dw_key_nothing;
+		s3dwcb_key[S3DW_TCAM] =   s3dw_key_nothing;
+		s3dwcb_key[S3DW_TSURFACE] =  s3dw_surface_event_key;
+		s3dwcb_key[S3DW_TBUTTON] =  s3dw_button_event_key;
+		s3dwcb_key[S3DW_TLABEL] =  s3dw_label_event_key;
+		s3dwcb_key[S3DW_TINPUT] =  s3dw_input_event_key;
+		s3dwcb_key[S3DW_TTEXTBOX] =  s3dw_key_nothing;
+		s3dwcb_key[S3DW_TSCROLLBAR] = s3dw_key_nothing;
 
 	}
 	return root;

Modified: trunk/libs3dw/s3dw.h
===================================================================
--- trunk/libs3dw/s3dw.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/s3dw.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -31,19 +31,19 @@
 /* we want this widget visible, as long as the widgets below are also visible.
  * on for all widgets, except surfaces which have to be switched visible
  * with s3dw_show() */
-#define		S3DW_VISIBLE	1
+#define  S3DW_VISIBLE 1
 /* widget should accept input. that's on by default. */
-#define 	S3DW_ACTIVE		2
+#define  S3DW_ACTIVE  2
 /* tells us if the widget is currently displayed */
-#define		S3DW_ONSCREEN	256
+#define  S3DW_ONSCREEN 256
 /* if the surface (or widget) is already properly arranged */
-#define 	S3DW_ARRANGED	512
+#define  S3DW_ARRANGED 512
 /* follow the camera */
-#define 	S3DW_FOLLOW_CAM	1024
+#define  S3DW_FOLLOW_CAM 1024
 /* turn to the camera */
-#define 	S3DW_TURN_CAM	2048
+#define  S3DW_TURN_CAM 2048
 /* just a typecaster to beatify code. use it if you like */
-#define 	S3DWIDGET(x)	((s3dw_widget *)x)
+#define  S3DWIDGET(x) ((s3dw_widget *)x)
 
 enum {
 	S3DW_TROOT,
@@ -56,140 +56,140 @@
 	S3DW_TSCROLLBAR,
 	S3DW_NTYPES
 };
-typedef struct _s3dw_widget 	s3dw_widget;
-typedef struct _s3dw_button 	s3dw_button;
-typedef struct _s3dw_label  	s3dw_label;
-typedef struct _s3dw_textbox  	s3dw_textbox;
-typedef struct _s3dw_scrollbar 	s3dw_scrollbar;
-typedef struct _s3dw_input  	s3dw_input;
-typedef struct _s3dw_surface  	s3dw_surface;
-typedef struct _s3dw_style  	s3dw_style;
+typedef struct _s3dw_widget  s3dw_widget;
+typedef struct _s3dw_button  s3dw_button;
+typedef struct _s3dw_label   s3dw_label;
+typedef struct _s3dw_textbox   s3dw_textbox;
+typedef struct _s3dw_scrollbar  s3dw_scrollbar;
+typedef struct _s3dw_input   s3dw_input;
+typedef struct _s3dw_surface   s3dw_surface;
+typedef struct _s3dw_style   s3dw_style;
 typedef void (*s3dw_callback)(s3dw_widget *);
 
 
 struct _s3dw_widget {
 	/* private .. */
-	int   		 type;
+	int      type;
 	s3dw_widget *parent;
 	s3dw_style  *style;
-	int 				  nobj; /* number of children objects */
-	s3dw_widget		 	**pobj; /* pointer to list of children objects */
-	int 		 focus;			/* index of the widget focused in pobj */
-	int   		 flags;			/* flags like visibility */
-	float 		 ax,ay,az;		/* current position for animation */
-	float 		 as;			/* current scale factor */
-	float 		 arx,ary,arz;   /* current rotation */
-	float 		 width,height;	/* width and height of the widget, outer size */
-	uint32_t	 oid;			/* the main object which is used for transformations etc ...*/
+	int       nobj; /* number of children objects */
+	s3dw_widget    **pobj; /* pointer to list of children objects */
+	int    focus;   /* index of the widget focused in pobj */
+	int      flags;   /* flags like visibility */
+	float    ax, ay, az;  /* current position for animation */
+	float    as;   /* current scale factor */
+	float    arx, ary, arz; /* current rotation */
+	float    width, height; /* width and height of the widget, outer size */
+	uint32_t  oid;   /* the main object which is used for transformations etc ...*/
 	/* public */
-	void		*ptr;			/* a pointer to a user structure, to use in callbacks etc */
-	float 		 x,y,z;			/* position, relative to the surface usually */
-	float 		 s;				/* scale factor */
-	float 		 rx,ry,rz;		/* rotation around the axis */
+	void  *ptr;   /* a pointer to a user structure, to use in callbacks etc */
+	float    x, y, z; /* position, relative to the surface usually */
+	float    s;    /* scale factor */
+	float    rx, ry, rz;  /* rotation around the axis */
 };
 
 
 struct _s3dw_button {
 	/* private */
-	s3dw_widget 	 widget;
-	char 			*text;
-	uint32_t  		  oid_text;
+	s3dw_widget   widget;
+	char    *text;
+	uint32_t      oid_text;
 	/* public */
-	s3dw_callback 	 onclick;
+	s3dw_callback   onclick;
 };
 struct _s3dw_label {
 	/* private */
-	s3dw_widget 	 widget;
-	char 			*text;
+	s3dw_widget   widget;
+	char    *text;
 	/* public */
-	s3dw_callback 	 onclick;
+	s3dw_callback   onclick;
 
 };
 struct _s3dw_scrollbar {
 	/* private */
-	s3dw_widget 	 widget;
-	float			 pos,max;
-	int				 type; /* 0 = horizontal, 1 = vertical */
-	int				 loid,roid,baroid;
+	s3dw_widget   widget;
+	float    pos, max;
+	int     type; /* 0 = horizontal, 1 = vertical */
+	int     loid, roid, baroid;
 	/* public */
-	s3dw_callback 	 lonclick;
-	s3dw_callback 	 ronclick;
+	s3dw_callback   lonclick;
+	s3dw_callback   ronclick;
 
 };
 
 struct _s3dw_textbox {
 	/* private */
-	s3dw_widget 	 widget;
-	s3dw_scrollbar	*scroll_vertical,
+	s3dw_widget   widget;
+	s3dw_scrollbar *scroll_vertical,
 	*scroll_horizontal;
-	char 			*text;
-	int				n_lineoids,*p_lineoids;
-	int				window_x,window_y;
+	char    *text;
+	int    n_lineoids, *p_lineoids;
+	int    window_x, window_y;
 	/* public */
-	s3dw_callback 	 onclick;
+	s3dw_callback   onclick;
 
 };
 
 struct _s3dw_input {
 	/* private */
-	s3dw_widget 	 widget;
-	char 			*text;
-	uint32_t   	 oid_text;
+	s3dw_widget   widget;
+	char    *text;
+	uint32_t     oid_text;
 	/* public */
-	s3dw_callback 	 onclick;
-	s3dw_callback 	 onedit;
+	s3dw_callback   onclick;
+	s3dw_callback   onedit;
 };
 
 struct _s3dw_surface {
 	/* private */
-	s3dw_widget 		  widget;
-	uint32_t			  oid_title;
-	uint32_t			  oid_tbar;
-	char				 *title;
+	s3dw_widget     widget;
+	uint32_t     oid_title;
+	uint32_t     oid_tbar;
+	char     *title;
 };
 
 /* style */
 struct _s3dw_style {
-	char *name;					/* name of the style ... kind of redundant */
-	char *fontface;				/* font face for all used fonts */
-	float surface_mat[12];		/* material for the surface background */
-	float input_mat[12];		/* material for buttonboxes and other widgets */
-	float inputback_mat[12];	/* material for inputfield background */
-	float text_mat[12];			/* material for the text on buttons and inputs */
-	float title_mat[12];		/* material for the title bar */
-	float title_text_mat[12];	/* material for the text on the title bar */
+	char *name;     /* name of the style ... kind of redundant */
+	char *fontface;    /* font face for all used fonts */
+	float surface_mat[12];  /* material for the surface background */
+	float input_mat[12];  /* material for buttonboxes and other widgets */
+	float inputback_mat[12]; /* material for inputfield background */
+	float text_mat[12];   /* material for the text on buttons and inputs */
+	float title_mat[12];  /* material for the title bar */
+	float title_text_mat[12]; /* material for the text on the title bar */
 };
 /* button.c */
 #ifdef HAVE_GCCVISIBILITY
 #pragma GCC visibility push(default) /* Only export following functions */
 #endif
-s3dw_button 		*s3dw_button_new(s3dw_surface *surface, char *text, float posx, float posy);
-s3dw_label	 		*s3dw_label_new(s3dw_surface *surface, char *text, float posx, float posy);
-s3dw_input 			*s3dw_input_new(s3dw_surface *surface, float width, float posx, float posy);
-s3dw_textbox 		*s3dw_textbox_new(s3dw_surface *surface, char *text, float posx, float posy, float width, float height);
-char 				*s3dw_input_gettext(s3dw_input *input);
-void 				 s3dw_input_change_text(s3dw_input *input, char *text);
-void 				 s3dw_label_change_text(s3dw_label *label, char *text);
-s3dw_surface 		*s3dw_surface_new(char *title, float width, float height);
+s3dw_button   *s3dw_button_new(s3dw_surface *surface, char *text, float posx, float posy);
+s3dw_label    *s3dw_label_new(s3dw_surface *surface, char *text, float posx, float posy);
+s3dw_input    *s3dw_input_new(s3dw_surface *surface, float width, float posx, float posy);
+s3dw_textbox   *s3dw_textbox_new(s3dw_surface *surface, char *text, float posx, float posy, float width, float height);
+char     *s3dw_input_gettext(s3dw_input *input);
+void      s3dw_input_change_text(s3dw_input *input, char *text);
+void      s3dw_label_change_text(s3dw_label *label, char *text);
+s3dw_surface   *s3dw_surface_new(char *title, float width, float height);
 
-s3dw_widget 		*s3dw_getroot();
-void				 s3dw_moveit(s3dw_widget *widget);
-void 				 s3dw_delete(s3dw_widget *widget);
-void 				 s3dw_show(s3dw_widget *widget);
-void 				 s3dw_focus(s3dw_widget *focus);
+s3dw_widget   *s3dw_getroot();
+void     s3dw_moveit(s3dw_widget *widget);
+void      s3dw_delete(s3dw_widget *widget);
+void      s3dw_show(s3dw_widget *widget);
+void      s3dw_focus(s3dw_widget *focus);
 
-void 				 s3dw_textbox_scrollup(s3dw_textbox *textbox);
-void 				 s3dw_textbox_scrolldown(s3dw_textbox *textbox);
-void 				 s3dw_textbox_scrollleft(s3dw_textbox *textbox);
-void 				 s3dw_textbox_scrollright(s3dw_textbox *textbox);
-void 				 s3dw_textbox_scrollto(s3dw_textbox *textbox, int x, int y);
-void 				 s3dw_textbox_change_text(s3dw_textbox *textbox, char *text);
+void      s3dw_textbox_scrollup(s3dw_textbox *textbox);
+void      s3dw_textbox_scrolldown(s3dw_textbox *textbox);
+void      s3dw_textbox_scrollleft(s3dw_textbox *textbox);
+void      s3dw_textbox_scrollright(s3dw_textbox *textbox);
+void      s3dw_textbox_scrollto(s3dw_textbox *textbox, int x, int y);
+void      s3dw_textbox_change_text(s3dw_textbox *textbox, char *text);
 
-int 				 s3dw_handle_click(struct s3d_evt *evt);
-int 				 s3dw_handle_key(struct s3d_evt *evt);
-int 				 s3dw_object_info(struct s3d_evt *evt);
+int      s3dw_handle_click(struct s3d_evt *evt);
+int      s3dw_handle_key(struct s3d_evt *evt);
+int      s3dw_object_info(struct s3d_evt *evt);
 
-void 				 s3dw_ani_mate();
+void      s3dw_ani_mate();
 #ifdef HAVE_GCCVISIBILITY
 #pragma GCC visibility pop
 #endif

Modified: trunk/libs3dw/s3dw_int.h
===================================================================
--- trunk/libs3dw/s3dw_int.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/s3dw_int.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,16 +22,16 @@
  */
 
 #include <s3dlib.h> /* s3dprintf() */
-#define MAXANI		128
-#define ZOOMS		5
+#define MAXANI  128
+#define ZOOMS  5
 /* constructor and handler callbacks */
 typedef int (*s3dw_click_callback)(s3dw_widget *, uint32_t);
-typedef int (*s3dw_key_callback)(  s3dw_widget *, struct s3d_key_event *);
-extern s3dw_callback 		s3dwcb_show[S3DW_NTYPES];
-extern s3dw_callback 		s3dwcb_hide[S3DW_NTYPES];
-extern s3dw_callback 		s3dwcb_destroy[S3DW_NTYPES];
+typedef int (*s3dw_key_callback)(s3dw_widget *, struct s3d_key_event *);
+extern s3dw_callback   s3dwcb_show[S3DW_NTYPES];
+extern s3dw_callback   s3dwcb_hide[S3DW_NTYPES];
+extern s3dw_callback   s3dwcb_destroy[S3DW_NTYPES];
 extern s3dw_click_callback s3dwcb_click[S3DW_NTYPES];
-extern s3dw_key_callback	s3dwcb_key[S3DW_NTYPES];
+extern s3dw_key_callback s3dwcb_key[S3DW_NTYPES];
 
 /* root.c */
 s3dw_widget *s3dw_getroot();
@@ -93,8 +93,8 @@
 int s3dw_textbox_event_click(s3dw_widget *widget, uint32_t oid);
 
 /* scrollbar.c */
-#define S3DW_SBAR_HORI		0
-#define S3DW_SBAR_VERT		1
+#define S3DW_SBAR_HORI  0
+#define S3DW_SBAR_VERT  1
 s3dw_scrollbar *s3dw_scrollbar_new(s3dw_widget *parent, int type, float posx, float posy, float length);
 void s3dw_scrollbar_show(s3dw_widget *widget);
 void s3dw_scrollbar_hide(s3dw_widget *widget);

Modified: trunk/libs3dw/scrollbar.c
===================================================================
--- trunk/libs3dw/scrollbar.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/scrollbar.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -30,294 +30,294 @@
 
 void s3dw_scrollbar_draw(s3dw_widget *widget)
 {
-	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
+	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
 	float back_vertices[3*32];
-	int i,j;
-	unsigned int back_polygons[44*4]={
+	int i, j;
+	unsigned int back_polygons[44*4] = {
 		/* box outside */
-		0,4,5,0,							0,5,1,0,
-		1,5,6,0,							1,6,2,0,
-		3,2,7,0,							7,2,6,0,
-		3,7,4,0,							3,4,0,0,
+		0, 4, 5, 0,       0, 5, 1, 0,
+		1, 5, 6, 0,       1, 6, 2, 0,
+		3, 2, 7, 0,       7, 2, 6, 0,
+		3, 7, 4, 0,       3, 4, 0, 0,
 
 		/* sides of big box */
-		12,13,9,0,							12,9,8,0,
-		14,15,11,0,							14,11,10,0,
+		12, 13, 9, 0,       12, 9, 8, 0,
+		14, 15, 11, 0,       14, 11, 10, 0,
 
 		/* inlay box */
-		9,16,17,0,							9,17,10,0,
-		17,18,14,0,							17,14,10,0,
-		13,14,18,0,							13,18,19,0,
-		13,19,16,0,							13,16,9,0,
+		9, 16, 17, 0,       9, 17, 10, 0,
+		17, 18, 14, 0,       17, 14, 10, 0,
+		13, 14, 18, 0,       13, 18, 19, 0,
+		13, 19, 16, 0,       13, 16, 9, 0,
 
 		/* inlay box back */
-		19,18,17,0,							19,17,16,0,
+		19, 18, 17, 0,       19, 17, 16, 0,
 
 		/* up arrow background surface */
-		7,6,15,0,
-		7,15,14,0,
-		7,14,13,0,
-		7,13,12,0,
+		7, 6, 15, 0,
+		7, 15, 14, 0,
+		7, 14, 13, 0,
+		7, 13, 12, 0,
 
 		/* up arrow face */
-		20,23,24,0,							20,24,21,0,
-		21,24,25,0,							21,25,22,0,
-		20,22,25,0,							20,25,23,0,
-		23,25,24,0,
+		20, 23, 24, 0,       20, 24, 21, 0,
+		21, 24, 25, 0,       21, 25, 22, 0,
+		20, 22, 25, 0,       20, 25, 23, 0,
+		23, 25, 24, 0,
 
 		/* down arrow background surface */
-		4,8,9,0,
-		4,9,10,0,
-		4,10,11,0,
-		4,11,5,0,
+		4, 8, 9, 0,
+		4, 9, 10, 0,
+		4, 10, 11, 0,
+		4, 11, 5, 0,
 
 		/* down arrow face */
-		26,27,31,0,							26,31,30,0,
-		31,27,28,0,							31,28,29,0,
-		26,30,29,0,							26,29,28,0,
-		30,31,29,0
+		26, 27, 31, 0,       26, 31, 30, 0,
+		31, 27, 28, 0,       31, 28, 29, 0,
+		26, 30, 29, 0,       26, 29, 28, 0,
+		30, 31, 29, 0
 
 	};
-	unsigned int bar_polygons[14*4]={
+	unsigned int bar_polygons[14*4] = {
 		/* front */
-		0,4,5,0,							0,5,1,0,
-		1,5,6,0,							1,6,2,0,
-		3,2,6,0,							3,6,7,0,
-		3,7,4,0,							3,4,0,0,
+		0, 4, 5, 0,       0, 5, 1, 0,
+		1, 5, 6, 0,       1, 6, 2, 0,
+		3, 2, 6, 0,       3, 6, 7, 0,
+		3, 7, 4, 0,       3, 4, 0, 0,
 
-		7,6,4,0,							4,6,5,0,
+		7, 6, 4, 0,       4, 6, 5, 0,
 
 		/* back, only visible sides */
-		2,3,11,0,							2,11,10,0,
-		1,9,8,0,							1,8,0,0
+		2, 3, 11, 0,       2, 11, 10, 0,
+		1, 9, 8, 0,       1, 8, 0, 0
 	};
 	float bar_vertices[12*3];
-	float w,h;
+	float w, h;
 	float temp;
 
 
-	w=(scrollbar->type==S3DW_SBAR_VERT)? widget->width : widget->height;
-	h=(scrollbar->type==S3DW_SBAR_VERT)? widget->height : widget->width;
+	w = (scrollbar->type == S3DW_SBAR_VERT) ? widget->width : widget->height;
+	h = (scrollbar->type == S3DW_SBAR_VERT) ? widget->height : widget->width;
 	/* outside/big  box */
-	back_vertices[0*3+0]=w*0.0;
-	back_vertices[0*3+1]=0.0-h;
-	back_vertices[0*3+2]=0.0;
-	back_vertices[1*3+0]=w*1.0;
-	back_vertices[1*3+1]=0.0-h;
-	back_vertices[1*3+2]=0.0;
-	back_vertices[2*3+0]=w*1.0;
-	back_vertices[2*3+1]=0.0;
-	back_vertices[2*3+2]=0.0;
-	back_vertices[3*3+0]=w*0.0;
-	back_vertices[3*3+1]=0.0;
-	back_vertices[3*3+2]=0.0;
-	back_vertices[4*3+0]=w*0.125;
-	back_vertices[4*3+1]=w*0.125-h;
-	back_vertices[4*3+2]=0.25;
-	back_vertices[5*3+0]=w*0.875;
-	back_vertices[5*3+1]=w*0.125-h;
-	back_vertices[5*3+2]=0.25;
-	back_vertices[6*3+0]=w*0.875;
-	back_vertices[6*3+1]=w*-0.125;
-	back_vertices[6*3+2]=0.25;
-	back_vertices[7*3+0]=w*0.125;
-	back_vertices[7*3+1]=w*-0.125;
-	back_vertices[7*3+2]=0.25;
+	back_vertices[0*3+0] = w * 0.0;
+	back_vertices[0*3+1] = 0.0 - h;
+	back_vertices[0*3+2] = 0.0;
+	back_vertices[1*3+0] = w * 1.0;
+	back_vertices[1*3+1] = 0.0 - h;
+	back_vertices[1*3+2] = 0.0;
+	back_vertices[2*3+0] = w * 1.0;
+	back_vertices[2*3+1] = 0.0;
+	back_vertices[2*3+2] = 0.0;
+	back_vertices[3*3+0] = w * 0.0;
+	back_vertices[3*3+1] = 0.0;
+	back_vertices[3*3+2] = 0.0;
+	back_vertices[4*3+0] = w * 0.125;
+	back_vertices[4*3+1] = w * 0.125 - h;
+	back_vertices[4*3+2] = 0.25;
+	back_vertices[5*3+0] = w * 0.875;
+	back_vertices[5*3+1] = w * 0.125 - h;
+	back_vertices[5*3+2] = 0.25;
+	back_vertices[6*3+0] = w * 0.875;
+	back_vertices[6*3+1] = w * -0.125;
+	back_vertices[6*3+2] = 0.25;
+	back_vertices[7*3+0] = w * 0.125;
+	back_vertices[7*3+1] = w * -0.125;
+	back_vertices[7*3+2] = 0.25;
 
 	/* downside inlay */
-	back_vertices[8*3+0]=w* 0.125;
-	back_vertices[8*3+1]=w-h;
-	back_vertices[8*3+2]=0.25;
-	back_vertices[9*3+0]=w* 0.25;
-	back_vertices[9*3+1]=w-h;
-	back_vertices[9*3+2]=0.25;
-	back_vertices[10*3+0]=w*0.75;
-	back_vertices[10*3+1]=w-h;
-	back_vertices[10*3+2]=0.25;
-	back_vertices[11*3+0]=w*0.875;
-	back_vertices[11*3+1]=w-h;
-	back_vertices[11*3+2]=0.25;
+	back_vertices[8*3+0] = w * 0.125;
+	back_vertices[8*3+1] = w - h;
+	back_vertices[8*3+2] = 0.25;
+	back_vertices[9*3+0] = w * 0.25;
+	back_vertices[9*3+1] = w - h;
+	back_vertices[9*3+2] = 0.25;
+	back_vertices[10*3+0] = w * 0.75;
+	back_vertices[10*3+1] = w - h;
+	back_vertices[10*3+2] = 0.25;
+	back_vertices[11*3+0] = w * 0.875;
+	back_vertices[11*3+1] = w - h;
+	back_vertices[11*3+2] = 0.25;
 
 	/* upside inlay */
-	back_vertices[12*3+0]=w*0.125;
-	back_vertices[12*3+1]=-w;
-	back_vertices[12*3+2]=0.25;
-	back_vertices[13*3+0]=w*0.25;
-	back_vertices[13*3+1]=-w;
-	back_vertices[13*3+2]=0.25;
-	back_vertices[14*3+0]=w*0.75;
-	back_vertices[14*3+1]=-w;
-	back_vertices[14*3+2]=0.25;
-	back_vertices[15*3+0]=w*0.875;
-	back_vertices[15*3+1]=-w;
-	back_vertices[15*3+2]=0.25;
+	back_vertices[12*3+0] = w * 0.125;
+	back_vertices[12*3+1] = -w;
+	back_vertices[12*3+2] = 0.25;
+	back_vertices[13*3+0] = w * 0.25;
+	back_vertices[13*3+1] = -w;
+	back_vertices[13*3+2] = 0.25;
+	back_vertices[14*3+0] = w * 0.75;
+	back_vertices[14*3+1] = -w;
+	back_vertices[14*3+2] = 0.25;
+	back_vertices[15*3+0] = w * 0.875;
+	back_vertices[15*3+1] = -w;
+	back_vertices[15*3+2] = 0.25;
 
 	/* inlay box */
-	back_vertices[16*3+0]=w*0.25;
-	back_vertices[16*3+1]=w*0.125-h+w;
-	back_vertices[16*3+2]=0.125;
-	back_vertices[17*3+0]=w*0.75;
-	back_vertices[17*3+1]=w*0.125-h+w;
-	back_vertices[17*3+2]=0.125;
-	back_vertices[18*3+0]=w*0.75;
-	back_vertices[18*3+1]=w*-0.125-w;
-	back_vertices[18*3+2]=0.125;
-	back_vertices[19*3+0]=w*0.25;
-	back_vertices[19*3+1]=w*-0.125-w;
-	back_vertices[19*3+2]=0.125;
+	back_vertices[16*3+0] = w * 0.25;
+	back_vertices[16*3+1] = w * 0.125 - h + w;
+	back_vertices[16*3+2] = 0.125;
+	back_vertices[17*3+0] = w * 0.75;
+	back_vertices[17*3+1] = w * 0.125 - h + w;
+	back_vertices[17*3+2] = 0.125;
+	back_vertices[18*3+0] = w * 0.75;
+	back_vertices[18*3+1] = w * -0.125 - w;
+	back_vertices[18*3+2] = 0.125;
+	back_vertices[19*3+0] = w * 0.25;
+	back_vertices[19*3+1] = w * -0.125 - w;
+	back_vertices[19*3+2] = 0.125;
 
 	/* arrow up */
-	back_vertices[20*3+0]=w*0.25;
-	back_vertices[20*3+1]=w*-0.875;
-	back_vertices[20*3+2]=0.25;
-	back_vertices[21*3+0]=w*0.75;
-	back_vertices[21*3+1]=w*-0.875;
-	back_vertices[21*3+2]=0.25;
-	back_vertices[22*3+0]=w*0.5;
-	back_vertices[22*3+1]=w*-0.25;
-	back_vertices[22*3+2]=0.25;
-	back_vertices[23*3+0]=w*0.375;
-	back_vertices[23*3+1]=w*-0.75;
-	back_vertices[23*3+2]=0.375;
-	back_vertices[24*3+0]=w*0.625;
-	back_vertices[24*3+1]=w*-0.75;
-	back_vertices[24*3+2]=0.375;
-	back_vertices[25*3+0]=w*0.5;
-	back_vertices[25*3+1]=w*-0.375;
-	back_vertices[25*3+2]=0.375;
+	back_vertices[20*3+0] = w * 0.25;
+	back_vertices[20*3+1] = w * -0.875;
+	back_vertices[20*3+2] = 0.25;
+	back_vertices[21*3+0] = w * 0.75;
+	back_vertices[21*3+1] = w * -0.875;
+	back_vertices[21*3+2] = 0.25;
+	back_vertices[22*3+0] = w * 0.5;
+	back_vertices[22*3+1] = w * -0.25;
+	back_vertices[22*3+2] = 0.25;
+	back_vertices[23*3+0] = w * 0.375;
+	back_vertices[23*3+1] = w * -0.75;
+	back_vertices[23*3+2] = 0.375;
+	back_vertices[24*3+0] = w * 0.625;
+	back_vertices[24*3+1] = w * -0.75;
+	back_vertices[24*3+2] = 0.375;
+	back_vertices[25*3+0] = w * 0.5;
+	back_vertices[25*3+1] = w * -0.375;
+	back_vertices[25*3+2] = 0.375;
 
 	/* arrow down */
-	back_vertices[26*3+0]=w*0.25;
-	back_vertices[26*3+1]=-h+w*0.875;
-	back_vertices[26*3+2]=0.25;
-	back_vertices[27*3+0]=w*0.75;
-	back_vertices[27*3+1]=-h+w*0.875;
-	back_vertices[27*3+2]=0.25;
-	back_vertices[28*3+0]=w*0.5;
-	back_vertices[28*3+1]=-h+w*0.25;
-	back_vertices[28*3+2]=0.25;
-	back_vertices[29*3+0]=w*0.375;
-	back_vertices[29*3+1]=-h+w*0.75;
-	back_vertices[29*3+2]=0.375;
-	back_vertices[30*3+0]=w*0.625;
-	back_vertices[30*3+1]=-h+w*0.75;
-	back_vertices[30*3+2]=0.375;
-	back_vertices[31*3+0]=w*0.5;
-	back_vertices[31*3+1]=-h+w*0.375;
-	back_vertices[31*3+2]=0.375;
+	back_vertices[26*3+0] = w * 0.25;
+	back_vertices[26*3+1] = -h + w * 0.875;
+	back_vertices[26*3+2] = 0.25;
+	back_vertices[27*3+0] = w * 0.75;
+	back_vertices[27*3+1] = -h + w * 0.875;
+	back_vertices[27*3+2] = 0.25;
+	back_vertices[28*3+0] = w * 0.5;
+	back_vertices[28*3+1] = -h + w * 0.25;
+	back_vertices[28*3+2] = 0.25;
+	back_vertices[29*3+0] = w * 0.375;
+	back_vertices[29*3+1] = -h + w * 0.75;
+	back_vertices[29*3+2] = 0.375;
+	back_vertices[30*3+0] = w * 0.625;
+	back_vertices[30*3+1] = -h + w * 0.75;
+	back_vertices[30*3+2] = 0.375;
+	back_vertices[31*3+0] = w * 0.5;
+	back_vertices[31*3+1] = -h + w * 0.375;
+	back_vertices[31*3+2] = 0.375;
 
 	/* scrollbar bar poinst */
-	bar_vertices[0*3+0]=w*0.25;
-	bar_vertices[0*3+1]=-(h-3)+w*0.125;
-	bar_vertices[0*3+2]=0.25;
-	bar_vertices[1*3+0]=w*0.75;
-	bar_vertices[1*3+1]=-(h-3)+w*0.125;
-	bar_vertices[1*3+2]=0.25;
-	bar_vertices[2*3+0]=w*0.75;
-	bar_vertices[2*3+1]=-w*0.125;
-	bar_vertices[2*3+2]=0.25;
-	bar_vertices[3*3+0]=w*0.25;
-	bar_vertices[3*3+1]=-w*0.125;
-	bar_vertices[3*3+2]=0.25;
+	bar_vertices[0*3+0] = w * 0.25;
+	bar_vertices[0*3+1] = -(h - 3) + w * 0.125;
+	bar_vertices[0*3+2] = 0.25;
+	bar_vertices[1*3+0] = w * 0.75;
+	bar_vertices[1*3+1] = -(h - 3) + w * 0.125;
+	bar_vertices[1*3+2] = 0.25;
+	bar_vertices[2*3+0] = w * 0.75;
+	bar_vertices[2*3+1] = -w * 0.125;
+	bar_vertices[2*3+2] = 0.25;
+	bar_vertices[3*3+0] = w * 0.25;
+	bar_vertices[3*3+1] = -w * 0.125;
+	bar_vertices[3*3+2] = 0.25;
 
-	bar_vertices[4*3+0]=w*0.125;
-	bar_vertices[4*3+1]=-(h-3)+w*0.25;
-	bar_vertices[4*3+2]=0.375;
-	bar_vertices[5*3+0]=w*0.875;
-	bar_vertices[5*3+1]=-(h-3)+w*0.25;
-	bar_vertices[5*3+2]=0.375;
-	bar_vertices[6*3+0]=w*0.875;
-	bar_vertices[6*3+1]=-w*0.25;
-	bar_vertices[6*3+2]=0.375;
-	bar_vertices[7*3+0]=w*0.125;
-	bar_vertices[7*3+1]=-w*0.25;
-	bar_vertices[7*3+2]=0.375;
+	bar_vertices[4*3+0] = w * 0.125;
+	bar_vertices[4*3+1] = -(h - 3) + w * 0.25;
+	bar_vertices[4*3+2] = 0.375;
+	bar_vertices[5*3+0] = w * 0.875;
+	bar_vertices[5*3+1] = -(h - 3) + w * 0.25;
+	bar_vertices[5*3+2] = 0.375;
+	bar_vertices[6*3+0] = w * 0.875;
+	bar_vertices[6*3+1] = -w * 0.25;
+	bar_vertices[6*3+2] = 0.375;
+	bar_vertices[7*3+0] = w * 0.125;
+	bar_vertices[7*3+1] = -w * 0.25;
+	bar_vertices[7*3+2] = 0.375;
 
-	bar_vertices[8*3+0]=w*0.125;
-	bar_vertices[8*3+1]=-(h-3)+w*0.25;
-	bar_vertices[8*3+2]=0.175;
-	bar_vertices[9*3+0]=w*0.875;
-	bar_vertices[9*3+1]=-(h-3)+w*0.25;
-	bar_vertices[9*3+2]=0.175;
-	bar_vertices[10*3+0]=w*0.875;
-	bar_vertices[10*3+1]=-w*0.25;
-	bar_vertices[10*3+2]=0.175;
-	bar_vertices[11*3+0]=w*0.125;
-	bar_vertices[11*3+1]=-w*0.25;
-	bar_vertices[11*3+2]=0.175;
+	bar_vertices[8*3+0] = w * 0.125;
+	bar_vertices[8*3+1] = -(h - 3) + w * 0.25;
+	bar_vertices[8*3+2] = 0.175;
+	bar_vertices[9*3+0] = w * 0.875;
+	bar_vertices[9*3+1] = -(h - 3) + w * 0.25;
+	bar_vertices[9*3+2] = 0.175;
+	bar_vertices[10*3+0] = w * 0.875;
+	bar_vertices[10*3+1] = -w * 0.25;
+	bar_vertices[10*3+2] = 0.175;
+	bar_vertices[11*3+0] = w * 0.125;
+	bar_vertices[11*3+1] = -w * 0.25;
+	bar_vertices[11*3+2] = 0.175;
 
 
 
 
-	if (scrollbar->type==S3DW_SBAR_HORI) { /* rotate x and y for horizontal scrollbar */
-		for (i=0;i<32;i++)	{
-			temp=back_vertices[i*3];
-			back_vertices[i*3]=-back_vertices[i*3+1];
-			back_vertices[i*3+1]=-temp;
+	if (scrollbar->type == S3DW_SBAR_HORI) { /* rotate x and y for horizontal scrollbar */
+		for (i = 0;i < 32;i++) {
+			temp = back_vertices[i*3];
+			back_vertices[i*3] = -back_vertices[i*3+1];
+			back_vertices[i*3+1] = -temp;
 		}
-		for (i=0;i<44;i++) { /* change clockwiseness */
-			j=back_polygons[i*4];
-			back_polygons[i*4]=back_polygons[i*4+1];
-			back_polygons[i*4+1]=j;
+		for (i = 0;i < 44;i++) { /* change clockwiseness */
+			j = back_polygons[i*4];
+			back_polygons[i*4] = back_polygons[i*4+1];
+			back_polygons[i*4+1] = j;
 		}
-		for (i=0;i<12;i++)	{
-			temp=bar_vertices[i*3];
-			bar_vertices[i*3]=-bar_vertices[i*3+1];
-			bar_vertices[i*3+1]=-temp;
+		for (i = 0;i < 12;i++) {
+			temp = bar_vertices[i*3];
+			bar_vertices[i*3] = -bar_vertices[i*3+1];
+			bar_vertices[i*3+1] = -temp;
 		}
-		for (i=0;i<14;i++) { /* change clockwiseness */
-			j=bar_polygons[i*4];
-			bar_polygons[i*4]=bar_polygons[i*4+1];
-			bar_polygons[i*4+1]=j;
+		for (i = 0;i < 14;i++) { /* change clockwiseness */
+			j = bar_polygons[i*4];
+			bar_polygons[i*4] = bar_polygons[i*4+1];
+			bar_polygons[i*4+1] = j;
 		}
 	}
 
-	widget->oid=s3d_new_object();
-	scrollbar->loid=s3d_new_object();
-	scrollbar->roid=s3d_new_object();
-	scrollbar->baroid=s3d_new_object();
-	s3d_push_materials_a(widget->oid,widget->style->input_mat,1);
-	s3d_push_materials_a(scrollbar->loid,widget->style->input_mat,1);
-	s3d_push_materials_a(scrollbar->roid,widget->style->input_mat,1);
-	s3d_push_materials_a(scrollbar->baroid,widget->style->input_mat,1);
-	s3d_push_vertices   (widget->oid,back_vertices,20);
-	s3d_push_vertices   (scrollbar->loid,back_vertices,32);
-	s3d_push_vertices   (scrollbar->roid,back_vertices,32);
-	s3d_push_vertices   (scrollbar->baroid,bar_vertices,12);
+	widget->oid = s3d_new_object();
+	scrollbar->loid = s3d_new_object();
+	scrollbar->roid = s3d_new_object();
+	scrollbar->baroid = s3d_new_object();
+	s3d_push_materials_a(widget->oid, widget->style->input_mat, 1);
+	s3d_push_materials_a(scrollbar->loid, widget->style->input_mat, 1);
+	s3d_push_materials_a(scrollbar->roid, widget->style->input_mat, 1);
+	s3d_push_materials_a(scrollbar->baroid, widget->style->input_mat, 1);
+	s3d_push_vertices(widget->oid, back_vertices, 20);
+	s3d_push_vertices(scrollbar->loid, back_vertices, 32);
+	s3d_push_vertices(scrollbar->roid, back_vertices, 32);
+	s3d_push_vertices(scrollbar->baroid, bar_vertices, 12);
 
-	s3d_push_polygons   (widget->oid,back_polygons ,22);
-	s3d_push_polygons   (scrollbar->loid,back_polygons +4*22,11);
-	s3d_push_polygons   (scrollbar->roid,back_polygons +4*33,11);
-	s3d_push_polygons   (scrollbar->baroid,bar_polygons ,14);
-	s3d_link(		   widget->oid,widget->parent->oid);
-	s3d_link(		   scrollbar->loid,widget->oid);
-	s3d_link(		   scrollbar->roid,widget->oid);
-	s3d_link(		   scrollbar->baroid,widget->oid);
-	s3d_translate(widget->oid,widget->x,-widget->y,0);
-	if (scrollbar->type==S3DW_SBAR_VERT)
-		s3d_translate(scrollbar->baroid,0,-1.5,0);
+	s3d_push_polygons(widget->oid, back_polygons , 22);
+	s3d_push_polygons(scrollbar->loid, back_polygons + 4*22, 11);
+	s3d_push_polygons(scrollbar->roid, back_polygons + 4*33, 11);
+	s3d_push_polygons(scrollbar->baroid, bar_polygons , 14);
+	s3d_link(widget->oid, widget->parent->oid);
+	s3d_link(scrollbar->loid, widget->oid);
+	s3d_link(scrollbar->roid, widget->oid);
+	s3d_link(scrollbar->baroid, widget->oid);
+	s3d_translate(widget->oid, widget->x, -widget->y, 0);
+	if (scrollbar->type == S3DW_SBAR_VERT)
+		s3d_translate(scrollbar->baroid, 0, -1.5, 0);
 	else
-		s3d_translate(scrollbar->baroid,1.5,0,0);
+		s3d_translate(scrollbar->baroid, 1.5, 0, 0);
 
 }
 /* show the scrollbar */
 void s3dw_scrollbar_show(s3dw_widget *widget)
 {
-	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
-	s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(scrollbar->loid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(scrollbar->roid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(scrollbar->baroid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
+	s3d_flags_on(widget->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(scrollbar->loid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(scrollbar->roid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(scrollbar->baroid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
 }
 /* hides the scrollbar */
 void s3dw_scrollbar_hide(s3dw_widget *widget)
 {
-	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
-	s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(scrollbar->loid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(scrollbar->roid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(scrollbar->baroid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
+	s3d_flags_off(widget->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(scrollbar->loid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(scrollbar->roid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(scrollbar->baroid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 
 /* create a new scrollbar in the surface */
@@ -325,24 +325,24 @@
 {
 	s3dw_scrollbar *scrollbar;
 	s3dw_widget *widget;
-	scrollbar=(s3dw_scrollbar *)malloc(sizeof(s3dw_scrollbar));
-	widget=s3dw_widget_new((s3dw_widget *)scrollbar);
-	widget->type=S3DW_TSCROLLBAR;
-	if ((scrollbar->type=type)==S3DW_SBAR_HORI) {
-		widget->height=1;
-		widget->width=length;
+	scrollbar = (s3dw_scrollbar *)malloc(sizeof(s3dw_scrollbar));
+	widget = s3dw_widget_new((s3dw_widget *)scrollbar);
+	widget->type = S3DW_TSCROLLBAR;
+	if ((scrollbar->type = type) == S3DW_SBAR_HORI) {
+		widget->height = 1;
+		widget->width = length;
 	} else {
-		widget->width=1;
-		widget->height=length;
+		widget->width = 1;
+		widget->height = length;
 	}
-	widget->x=posx;
-	widget->y=posy;
-	widget->oid=-1;
-	scrollbar->loid=-1;
-	scrollbar->roid=-1;
-	scrollbar->baroid=-1;
-	scrollbar->lonclick=s3dw_nothing;
-	scrollbar->ronclick=s3dw_nothing;
+	widget->x = posx;
+	widget->y = posy;
+	widget->oid = -1;
+	scrollbar->loid = -1;
+	scrollbar->roid = -1;
+	scrollbar->baroid = -1;
+	scrollbar->lonclick = s3dw_nothing;
+	scrollbar->ronclick = s3dw_nothing;
 	s3dw_widget_append(parent, widget);
 	s3dw_scrollbar_draw(widget);
 	return(scrollbar);
@@ -350,7 +350,7 @@
 
 void s3dw_scrollbar_erase(s3dw_widget *widget)
 {
-	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
+	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
 	s3d_del_object(widget->oid);
 	s3d_del_object(scrollbar->loid);
 	s3d_del_object(scrollbar->roid);
@@ -359,7 +359,7 @@
 /* destroy the scrollbar */
 void s3dw_scrollbar_destroy(s3dw_widget *widget)
 {
-	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
+	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
 	s3dw_scrollbar_erase(widget);
 	free(scrollbar);
 }
@@ -371,12 +371,12 @@
 /* handle click events */
 int s3dw_scrollbar_event_click(s3dw_widget *widget, uint32_t oid)
 {
-	s3dw_scrollbar *scrollbar=(s3dw_scrollbar *)widget;
-	if (scrollbar->loid==oid) {
+	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
+	if (scrollbar->loid == oid) {
 		scrollbar->lonclick(widget);
 		return(1);
 	}
-	if (scrollbar->roid==oid) {
+	if (scrollbar->roid == oid) {
 		scrollbar->ronclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/style.c
===================================================================
--- trunk/libs3dw/style.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/style.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -28,44 +28,44 @@
 
 
 /* default style */
-s3dw_style def_style={
+s3dw_style def_style = {
 	/* name */
 	"default",
 	/* font face */
 	"vera",
 	/* surface_mat */
-	{0.7,0.7,0.7,1.0,
-		0.7,0.7,0.7,1.0,
-		0.7,0.7,0.7,1.0
+	{0.7, 0.7, 0.7, 1.0,
+		0.7, 0.7, 0.7, 1.0,
+		0.7, 0.7, 0.7, 1.0
 	},
 	/* input_mat */
-	{0.7,0.7,0.7,1.0,
-	 0.7,0.7,0.7,1.0,
-	 0.7,0.7,0.7,1.0
+	{0.7, 0.7, 0.7, 1.0,
+	 0.7, 0.7, 0.7, 1.0,
+	 0.7, 0.7, 0.7, 1.0
 	},
 	/* inputback_mat */
-	{0.9,0.9,0.9,1.0,
-	 0.9,0.9,0.9,1.0,
-	 0.9,0.9,0.9,1.0
+	{0.9, 0.9, 0.9, 1.0,
+	 0.9, 0.9, 0.9, 1.0,
+	 0.9, 0.9, 0.9, 1.0
 	},
 
 	/* text_mat */
 	{
-		0.0,0.0,0.0,1.0,
-		1.0,1.0,1.0,1.0,
-		0.0,0.0,0.0,1.0
+		0.0, 0.0, 0.0, 1.0,
+		1.0, 1.0, 1.0, 1.0,
+		0.0, 0.0, 0.0, 1.0
 	},
 	/* title_mat */
 	{
-		0.0,0.4,0.8,1.0,
-		1.0,1.0,1.0,1.0,
-		0.0,0.4,0.8,1.0
+		0.0, 0.4, 0.8, 1.0,
+		1.0, 1.0, 1.0, 1.0,
+		0.0, 0.4, 0.8, 1.0
 	},
 	/* title_text_mat */
 	{
-		0.0,0.0,0.0,1.0,
-		0.0,0.0,0.0,1.0,
-		0.0,0.0,0.0,1.0
+		0.0, 0.0, 0.0, 1.0,
+		0.0, 0.0, 0.0, 1.0,
+		0.0, 0.0, 0.0, 1.0
 	}
 };
 

Modified: trunk/libs3dw/surface.c
===================================================================
--- trunk/libs3dw/surface.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/surface.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,105 +26,105 @@
 #include <s3dw_int.h>
 #include <stdlib.h> /* malloc() */
 #include <string.h> /* strdup() */
-#include <math.h>	/* cos(), sin() */
-#define POPUPDIST	20
+#include <math.h> /* cos(), sin() */
+#define POPUPDIST 20
 extern s3dw_widget *_s3dw_cam; /* for correct popup position */
 
 void s3dw_surface_draw(s3dw_widget *widget)
 {
-	s3dw_surface *surface=(s3dw_surface *)widget;
+	s3dw_surface *surface = (s3dw_surface *)widget;
 	int textlen;
 	float length;
-	float vertices[8*3]={
-		0,0,0,
-		1,0,0,
-		1,1,0,
-		0,1,0,
-		0,0,1,
-		1,0,1,
-		1,1,1,
-		0,1,1
+	float vertices[8*3] = {
+		0, 0, 0,
+		1, 0, 0,
+		1, 1, 0,
+		0, 1, 0,
+		0, 0, 1,
+		1, 0, 1,
+		1, 1, 1,
+		0, 1, 1
 	};
 	float sver[8*3], tver[8*3];
-	uint32_t polygon[10*4]={
-		0,1,2,0,
-		0,2,3,0,
-		1,5,6,0,
-		1,6,2,0,
-		2,6,7,0,
-		2,7,3,0,
-		4,0,3,0,
-		4,3,7,0,
-		5,4,7,0,
-		5,7,6,0
+	uint32_t polygon[10*4] = {
+		0, 1, 2, 0,
+		0, 2, 3, 0,
+		1, 5, 6, 0,
+		1, 6, 2, 0,
+		2, 6, 7, 0,
+		2, 7, 3, 0,
+		4, 0, 3, 0,
+		4, 3, 7, 0,
+		5, 4, 7, 0,
+		5, 7, 6, 0
 	};
 	uint32_t tpol[10*4];
 	int i;
 
-	widget->oid=s3d_new_object();
-	surface->oid_tbar=s3d_new_object();
+	widget->oid = s3d_new_object();
+	surface->oid_tbar = s3d_new_object();
 	s3d_select_font("vera");
-	surface->oid_title=s3d_draw_string(surface->title,&length);
-	while (length > (widget->width+1)) {
-		s3dprintf(HIGH,"%f > %f",length,widget->width+1);
-		textlen=strlen(surface->title);
-		if (length>((widget->width+1)*1.3))
-			textlen=textlen*((widget->width+1)*1.1/length);
-		if (textlen>4) {
-			surface->title[textlen-2]=0;
-			surface->title[textlen-3]='.';
-			surface->title[textlen-4]='.';
+	surface->oid_title = s3d_draw_string(surface->title, &length);
+	while (length > (widget->width + 1)) {
+		s3dprintf(HIGH, "%f > %f", length, widget->width + 1);
+		textlen = strlen(surface->title);
+		if (length > ((widget->width + 1)*1.3))
+			textlen = textlen * ((widget->width + 1) * 1.1 / length);
+		if (textlen > 4) {
+			surface->title[textlen-2] = 0;
+			surface->title[textlen-3] = '.';
+			surface->title[textlen-4] = '.';
 			s3d_del_object(surface->oid_title);
-			surface->oid_title=s3d_draw_string(surface->title,&length);
+			surface->oid_title = s3d_draw_string(surface->title, &length);
 		} else {
 			break;
 		}
 	}
 	/* prepare vertices */
-	for (i=0;i<8;i++) {
-		sver[i*3 + 0]=vertices[i*3+0] * widget->width;
-		sver[i*3 + 1]=vertices[i*3+1] * -widget->height;
-		sver[i*3 + 2]=vertices[i*3+2] * -1;
-		tver[i*3 + 0]=vertices[i*3+0] * widget->width;
-		tver[i*3 + 1]=vertices[i*3+1];
-		tver[i*3 + 2]=vertices[i*3+2] * -1;
+	for (i = 0;i < 8;i++) {
+		sver[i*3 + 0] = vertices[i*3+0] * widget->width;
+		sver[i*3 + 1] = vertices[i*3+1] * -widget->height;
+		sver[i*3 + 2] = vertices[i*3+2] * -1;
+		tver[i*3 + 0] = vertices[i*3+0] * widget->width;
+		tver[i*3 + 1] = vertices[i*3+1];
+		tver[i*3 + 2] = vertices[i*3+2] * -1;
 	}
 	/* swap */
-	for (i=0;i<10;i++) {
-		tpol[i*4 + 0]=polygon[i*4 + 1];
-		tpol[i*4 + 1]=polygon[i*4 + 0];
-		tpol[i*4 + 2]=polygon[i*4 + 2];
-		tpol[i*4 + 3]=polygon[i*4 + 3];
+	for (i = 0;i < 10;i++) {
+		tpol[i*4 + 0] = polygon[i*4 + 1];
+		tpol[i*4 + 1] = polygon[i*4 + 0];
+		tpol[i*4 + 2] = polygon[i*4 + 2];
+		tpol[i*4 + 3] = polygon[i*4 + 3];
 	}
-	s3d_push_vertices(widget->oid,sver,8);
-	s3d_push_vertices(surface->oid_tbar,tver,8);
-	s3d_push_materials_a(widget->oid      ,widget->style->surface_mat,1);
-	s3d_push_materials_a(surface->oid_tbar,widget->style->title_mat,1);
-	s3d_pep_materials_a(surface->oid_title,widget->style->title_text_mat,1);
-	s3d_push_polygons(widget->oid,polygon,10);
-	s3d_push_polygons(surface->oid_tbar,tpol,10);
-	s3d_link(surface->oid_tbar,widget->oid);
-	s3d_link(surface->oid_title,surface->oid_tbar);
-	s3d_link(widget->oid,widget->parent->oid);
-	s3d_translate(surface->oid_title,0.5,0.2,0.1);
-	s3d_scale(widget->oid,	widget->as);
-	s3d_translate(widget->oid,	widget->ax, widget->ay, widget->az);
+	s3d_push_vertices(widget->oid, sver, 8);
+	s3d_push_vertices(surface->oid_tbar, tver, 8);
+	s3d_push_materials_a(widget->oid      , widget->style->surface_mat, 1);
+	s3d_push_materials_a(surface->oid_tbar, widget->style->title_mat, 1);
+	s3d_pep_materials_a(surface->oid_title, widget->style->title_text_mat, 1);
+	s3d_push_polygons(widget->oid, polygon, 10);
+	s3d_push_polygons(surface->oid_tbar, tpol, 10);
+	s3d_link(surface->oid_tbar, widget->oid);
+	s3d_link(surface->oid_title, surface->oid_tbar);
+	s3d_link(widget->oid, widget->parent->oid);
+	s3d_translate(surface->oid_title, 0.5, 0.2, 0.1);
+	s3d_scale(widget->oid, widget->as);
+	s3d_translate(widget->oid, widget->ax, widget->ay, widget->az);
 }
 /* show the surface */
 void s3dw_surface_show(s3dw_widget *widget)
 {
-	s3dw_surface *surface=(s3dw_surface *)widget;
-	s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(surface->oid_title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_on(surface->oid_tbar,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_surface *surface = (s3dw_surface *)widget;
+	s3d_flags_on(widget->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(surface->oid_title, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_on(surface->oid_tbar, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* hides the surface */
 void s3dw_surface_hide(s3dw_widget *widget)
 {
-	s3dw_surface *surface=(s3dw_surface *)widget;
-	s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(surface->oid_title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_flags_off(surface->oid_tbar,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3dw_surface *surface = (s3dw_surface *)widget;
+	s3d_flags_off(widget->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(surface->oid_title, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	s3d_flags_off(surface->oid_tbar, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* create a new surface */
 s3dw_surface *s3dw_surface_new(char *title, float width, float height)
@@ -133,22 +133,22 @@
 	s3dw_widget  *widget;
 	float f1[3];
 
-	surface=(s3dw_surface *)malloc(sizeof(s3dw_surface));
-	surface->title=strdup(title);
-	widget=s3dw_widget_new((s3dw_widget *)surface);
-	widget->type=S3DW_TSURFACE;
-	widget->width=width;
-	widget->height=height;
-	widget->as=0.01;
-	s3dw_arr_widgetcenter(widget,f1);
-	s3dw_widget_append(s3dw_getroot(),widget);
-	widget->x=-f1[0] + _s3dw_cam->x - sin( _s3dw_cam->ry * M_PI/180) * 	cos ( _s3dw_cam->rx *M_PI/180) * POPUPDIST;
-	widget->y=-f1[1] + _s3dw_cam->y + 								   	sin( _s3dw_cam->rx * M_PI/180 ) *POPUPDIST;
-	widget->z=-f1[2] + _s3dw_cam->z - cos( _s3dw_cam->ry * M_PI/180) * 	cos ( _s3dw_cam->rx *M_PI/180) * POPUPDIST;
-	widget->ax=widget->x;
-	widget->ay=widget->y;
-	widget->az=widget->z;
-	widget->flags|=S3DW_FOLLOW_CAM|S3DW_TURN_CAM;
+	surface = (s3dw_surface *)malloc(sizeof(s3dw_surface));
+	surface->title = strdup(title);
+	widget = s3dw_widget_new((s3dw_widget *)surface);
+	widget->type = S3DW_TSURFACE;
+	widget->width = width;
+	widget->height = height;
+	widget->as = 0.01;
+	s3dw_arr_widgetcenter(widget, f1);
+	s3dw_widget_append(s3dw_getroot(), widget);
+	widget->x = -f1[0] + _s3dw_cam->x - sin(_s3dw_cam->ry * M_PI / 180) *  cos(_s3dw_cam->rx * M_PI / 180) * POPUPDIST;
+	widget->y = -f1[1] + _s3dw_cam->y +             sin(_s3dw_cam->rx * M_PI / 180) * POPUPDIST;
+	widget->z = -f1[2] + _s3dw_cam->z - cos(_s3dw_cam->ry * M_PI / 180) *  cos(_s3dw_cam->rx * M_PI / 180) * POPUPDIST;
+	widget->ax = widget->x;
+	widget->ay = widget->y;
+	widget->az = widget->z;
+	widget->flags |= S3DW_FOLLOW_CAM | S3DW_TURN_CAM;
 	s3dw_surface_draw(widget);
 	s3dw_ani_needarr();
 	s3dw_ani_add(widget);
@@ -157,7 +157,7 @@
 /* delete objects in the s3d context */
 void s3dw_surface_erase(s3dw_widget *widget)
 {
-	s3dw_surface *surface=(s3dw_surface *)widget;
+	s3dw_surface *surface = (s3dw_surface *)widget;
 	s3d_del_object(widget->oid);
 	s3d_del_object(surface->oid_tbar);
 	s3d_del_object(surface->oid_title);
@@ -165,7 +165,7 @@
 /* destroy the surface */
 void s3dw_surface_destroy(s3dw_widget *widget)
 {
-	s3dw_surface *surface=(s3dw_surface *)widget;
+	s3dw_surface *surface = (s3dw_surface *)widget;
 	s3dw_surface_erase(widget);
 	free(surface->title);
 	free(surface);
@@ -178,15 +178,15 @@
 /* test widgets of the surface for clicks */
 int s3dw_surface_event_click(s3dw_widget *widget, uint32_t oid)
 {
-	s3dw_surface *surface=(s3dw_surface *)widget;
-	if (widget->oid==oid) {
+	s3dw_surface *surface = (s3dw_surface *)widget;
+	if (widget->oid == oid) {
 		s3dw_focus(widget);
-		s3dprintf(MED,"body %s clicked",surface->title);
+		s3dprintf(MED, "body %s clicked", surface->title);
 		return(1);
 	}
-	if ((surface->oid_tbar==oid) || (surface->oid_title==oid)) {
+	if ((surface->oid_tbar == oid) || (surface->oid_title == oid)) {
 		s3dw_focus(widget);
-		s3dprintf(MED,"title %s clicked",surface->title);
+		s3dprintf(MED, "title %s clicked", surface->title);
 		return(1);
 	}
 	return(0);

Modified: trunk/libs3dw/textbox.c
===================================================================
--- trunk/libs3dw/textbox.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/textbox.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -30,152 +30,152 @@
 
 void s3dw_textbox_draw(s3dw_widget *widget)
 {
-	float h,w;
+	float h, w;
 	float vertices[12*3];
-	uint32_t polygons[18*4]={
-		0,4,5,1,
-		0,5,1,1,
-		1,5,6,1,
-		1,6,2,1,
-		2,6,7,1,
-		2,7,3,1,
-		3,7,4,1,
-		3,4,0,1,
+	uint32_t polygons[18*4] = {
+		0, 4, 5, 1,
+		0, 5, 1, 1,
+		1, 5, 6, 1,
+		1, 6, 2, 1,
+		2, 6, 7, 1,
+		2, 7, 3, 1,
+		3, 7, 4, 1,
+		3, 4, 0, 1,
 
-		4,8, 9, 1,
-		4,9, 5, 1,
-		5,9, 10,1,
-		5,10,6, 1,
-		6,10,11,1,
-		6,11,7, 1,
-		7,11,8, 1,
-		7,8, 4, 1,
+		4, 8, 9, 1,
+		4, 9, 5, 1,
+		5, 9, 10, 1,
+		5, 10, 6, 1,
+		6, 10, 11, 1,
+		6, 11, 7, 1,
+		7, 11, 8, 1,
+		7, 8, 4, 1,
 
 
-		8,11,10,0,
-		8,10,9, 0
+		8, 11, 10, 0,
+		8, 10, 9, 0
 	};
-	w=widget->width-2;
-	h=widget->height-3;
-	if (widget->width<1) return;
+	w = widget->width - 2;
+	h = widget->height - 3;
+	if (widget->width < 1) return;
 	/* width of the input depends on the length of the text */
-	vertices[0*3+0]=0.0;
-	vertices[0*3+1]=0.0;
-	vertices[0*3+2]=0.0;
-	vertices[1*3+0]=0.0;
-	vertices[1*3+1]=-h-2.0;
-	vertices[1*3+2]=0.0;
-	vertices[2*3+0]=w+1;
-	vertices[2*3+1]=-h-2.0;
-	vertices[2*3+2]=0.0;
-	vertices[3*3+0]=w+1;
-	vertices[3*3+1]=0.0;
-	vertices[3*3+2]=0.0;
-	vertices[4*3+0]=0.125;
-	vertices[4*3+1]=-0.125;
-	vertices[4*3+2]=0.25;
-	vertices[5*3+0]=0.125;
-	vertices[5*3+1]=-h-1.875;
-	vertices[5*3+2]=0.25;
-	vertices[6*3+0]=w+0.875;
-	vertices[6*3+1]=-h-1.875;
-	vertices[6*3+2]=0.25;
-	vertices[7*3+0]=w+0.875;
-	vertices[7*3+1]=-0.125;
-	vertices[7*3+2]=0.25;
-	vertices[8*3+0]=0.25;
-	vertices[8*3+1]=-0.25;
-	vertices[8*3+2]=0.125;
-	vertices[9*3+0]=0.25;
-	vertices[9*3+1]=-h-1.75;
-	vertices[9*3+2]=0.125;
-	vertices[10*3+0]=w+0.75;
-	vertices[10*3+1]=-h-1.75;
-	vertices[10*3+2]=0.125;
-	vertices[11*3+0]=w+0.75;
-	vertices[11*3+1]=-0.25;
-	vertices[11*3+2]=0.125;
-	widget->oid=s3d_new_object();
-	s3d_push_materials_a(widget->oid,widget->style->inputback_mat,1);
-	s3d_push_materials_a(widget->oid,widget->style->input_mat,1);
-	s3d_push_vertices   (widget->oid,vertices,12);
-	s3d_push_polygons   (widget->oid,polygons,18);
-	s3d_link(		   widget->oid,widget->parent->oid);
-	s3d_translate(widget->oid,widget->x,-widget->y,0);
+	vertices[0*3+0] = 0.0;
+	vertices[0*3+1] = 0.0;
+	vertices[0*3+2] = 0.0;
+	vertices[1*3+0] = 0.0;
+	vertices[1*3+1] = -h - 2.0;
+	vertices[1*3+2] = 0.0;
+	vertices[2*3+0] = w + 1;
+	vertices[2*3+1] = -h - 2.0;
+	vertices[2*3+2] = 0.0;
+	vertices[3*3+0] = w + 1;
+	vertices[3*3+1] = 0.0;
+	vertices[3*3+2] = 0.0;
+	vertices[4*3+0] = 0.125;
+	vertices[4*3+1] = -0.125;
+	vertices[4*3+2] = 0.25;
+	vertices[5*3+0] = 0.125;
+	vertices[5*3+1] = -h - 1.875;
+	vertices[5*3+2] = 0.25;
+	vertices[6*3+0] = w + 0.875;
+	vertices[6*3+1] = -h - 1.875;
+	vertices[6*3+2] = 0.25;
+	vertices[7*3+0] = w + 0.875;
+	vertices[7*3+1] = -0.125;
+	vertices[7*3+2] = 0.25;
+	vertices[8*3+0] = 0.25;
+	vertices[8*3+1] = -0.25;
+	vertices[8*3+2] = 0.125;
+	vertices[9*3+0] = 0.25;
+	vertices[9*3+1] = -h - 1.75;
+	vertices[9*3+2] = 0.125;
+	vertices[10*3+0] = w + 0.75;
+	vertices[10*3+1] = -h - 1.75;
+	vertices[10*3+2] = 0.125;
+	vertices[11*3+0] = w + 0.75;
+	vertices[11*3+1] = -0.25;
+	vertices[11*3+2] = 0.125;
+	widget->oid = s3d_new_object();
+	s3d_push_materials_a(widget->oid, widget->style->inputback_mat, 1);
+	s3d_push_materials_a(widget->oid, widget->style->input_mat, 1);
+	s3d_push_vertices(widget->oid, vertices, 12);
+	s3d_push_polygons(widget->oid, polygons, 18);
+	s3d_link(widget->oid, widget->parent->oid);
+	s3d_translate(widget->oid, widget->x, -widget->y, 0);
 
 	s3dw_textbox_drawtext(widget);
 
 }
 void s3dw_textbox_drawtext(s3dw_widget *widget)
 {
-	s3dw_textbox *textbox=(s3dw_textbox *)widget;
-	char *text,*rest;
+	s3dw_textbox *textbox = (s3dw_textbox *)widget;
+	char *text, *rest;
 	char *linefeedpos;
 	int i;
-	int x,y;
+	int x, y;
 	float width;
-	textbox->n_lineoids=widget->height-2;
-	textbox->p_lineoids=malloc(textbox->n_lineoids*sizeof(int));
-	width=widget->width-1.5;
-	y=-textbox->window_y;
-	x=textbox->window_x;
-	for (i=0;i<textbox->n_lineoids;i++)
-		textbox->p_lineoids[i]=-1;
-	rest=text=strdup(textbox->text);
-	while (NULL!=(linefeedpos=strchr(rest,'\n'))) { /* process every line */
-		linefeedpos[0]=0;
-		if ((x<strlen(rest)) && ((y>=0) && y<textbox->n_lineoids)) { /* don't bother, if it's not visible anyway */
-			rest+=x;	/* ignore the first x chars because we've scrolled a bit right */
-			while ((strlen(rest)>0) && (s3d_strlen(rest)>width))
-				rest[strlen(rest)-1]=0; /* remove last character and try again until it fits */
-			if (strlen(rest)>0) {
-				textbox->p_lineoids[y]=s3d_draw_string(rest,NULL);
-				s3d_pep_materials_a(textbox->p_lineoids[y],widget->style->text_mat,1);
-				s3d_translate( textbox->p_lineoids[y],0.5,-y-1,0.30);
-				s3d_link(	   textbox->p_lineoids[y],widget->oid);
+	textbox->n_lineoids = widget->height - 2;
+	textbox->p_lineoids = malloc(textbox->n_lineoids * sizeof(int));
+	width = widget->width - 1.5;
+	y = -textbox->window_y;
+	x = textbox->window_x;
+	for (i = 0;i < textbox->n_lineoids;i++)
+		textbox->p_lineoids[i] = -1;
+	rest = text = strdup(textbox->text);
+	while (NULL != (linefeedpos = strchr(rest, '\n'))) { /* process every line */
+		linefeedpos[0] = 0;
+		if ((x < strlen(rest)) && ((y >= 0) && y < textbox->n_lineoids)) { /* don't bother, if it's not visible anyway */
+			rest += x; /* ignore the first x chars because we've scrolled a bit right */
+			while ((strlen(rest) > 0) && (s3d_strlen(rest) > width))
+				rest[strlen(rest)-1] = 0; /* remove last character and try again until it fits */
+			if (strlen(rest) > 0) {
+				textbox->p_lineoids[y] = s3d_draw_string(rest, NULL);
+				s3d_pep_materials_a(textbox->p_lineoids[y], widget->style->text_mat, 1);
+				s3d_translate(textbox->p_lineoids[y], 0.5, -y - 1, 0.30);
+				s3d_link(textbox->p_lineoids[y], widget->oid);
 
 			}
 		}
-		rest=linefeedpos+1;
-		y+=1;
+		rest = linefeedpos + 1;
+		y += 1;
 	}
-	if (y<0) textbox->window_y-=y;
+	if (y < 0) textbox->window_y -= y;
 
 	free(text);
 }
 void s3dw_textbox_erasetext(s3dw_widget *widget)
 {
-	s3dw_textbox *textbox=(s3dw_textbox *)widget;
+	s3dw_textbox *textbox = (s3dw_textbox *)widget;
 	int i;
 
 
-	if (textbox->p_lineoids!=NULL) {
-		for (i=0;i<textbox->n_lineoids;i++)
-			if (textbox->p_lineoids[i]!=-1)
+	if (textbox->p_lineoids != NULL) {
+		for (i = 0;i < textbox->n_lineoids;i++)
+			if (textbox->p_lineoids[i] != -1)
 				s3d_del_object(textbox->p_lineoids[i]);
 		free(textbox->p_lineoids);
-		textbox->p_lineoids=NULL;
-		textbox->n_lineoids=0;
+		textbox->p_lineoids = NULL;
+		textbox->n_lineoids = 0;
 
 	}
 }
 /* show the textbox */
 void s3dw_textbox_show(s3dw_widget *widget)
 {
-	s3dw_textbox *textbox=(s3dw_textbox *)widget;
+	s3dw_textbox *textbox = (s3dw_textbox *)widget;
 	int i;
-	s3d_flags_on(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	for (i=0;i<textbox->n_lineoids;i++)
-		s3d_flags_on(textbox->p_lineoids[i],S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_on(widget->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	for (i = 0;i < textbox->n_lineoids;i++)
+		s3d_flags_on(textbox->p_lineoids[i], S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 }
 /* hides the textbox */
 void s3dw_textbox_hide(s3dw_widget *widget)
 {
-	s3dw_textbox *textbox=(s3dw_textbox *)widget;
+	s3dw_textbox *textbox = (s3dw_textbox *)widget;
 	int i;
-	s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	for (i=0;i<textbox->n_lineoids;i++)
-		s3d_flags_on(textbox->p_lineoids[i],S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_flags_off(widget->oid, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
+	for (i = 0;i < textbox->n_lineoids;i++)
+		s3d_flags_on(textbox->p_lineoids[i], S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 
 }
 static void _s3dw_textbox_scrollbar_up(s3dw_widget *widget)
@@ -200,27 +200,27 @@
 {
 	s3dw_textbox *textbox;
 	s3dw_widget *widget;
-	textbox=(s3dw_textbox *)malloc(sizeof(s3dw_textbox));
-	widget=s3dw_widget_new((s3dw_widget *)textbox);
-	widget->type=S3DW_TTEXTBOX;
-	widget->x=posx;
-	widget->y=posy;
-	widget->width=width;
-	widget->height=height;
-	textbox->window_x=0;
-	textbox->window_y=0;
-	textbox->p_lineoids=NULL;
-	textbox->n_lineoids=0;
-	textbox->text=strdup(text);
-	textbox->onclick=s3dw_nothing;
-	s3dw_widget_append((s3dw_widget *)surface, widget);		/* append first so the scrollbars inherit the style */
+	textbox = (s3dw_textbox *)malloc(sizeof(s3dw_textbox));
+	widget = s3dw_widget_new((s3dw_widget *)textbox);
+	widget->type = S3DW_TTEXTBOX;
+	widget->x = posx;
+	widget->y = posy;
+	widget->width = width;
+	widget->height = height;
+	textbox->window_x = 0;
+	textbox->window_y = 0;
+	textbox->p_lineoids = NULL;
+	textbox->n_lineoids = 0;
+	textbox->text = strdup(text);
+	textbox->onclick = s3dw_nothing;
+	s3dw_widget_append((s3dw_widget *)surface, widget);  /* append first so the scrollbars inherit the style */
 	s3dw_textbox_draw(widget);
-	textbox->scroll_horizontal=s3dw_scrollbar_new(widget,S3DW_SBAR_HORI,  0,widget->height-1, widget->width-1);
-	textbox->scroll_vertical=s3dw_scrollbar_new(widget,S3DW_SBAR_VERT,  widget->width-1,0, widget->height-1);
-	textbox->scroll_horizontal->lonclick=_s3dw_textbox_scrollbar_left;
-	textbox->scroll_horizontal->ronclick=_s3dw_textbox_scrollbar_right;
-	textbox->scroll_vertical->lonclick=_s3dw_textbox_scrollbar_up;
-	textbox->scroll_vertical->ronclick=_s3dw_textbox_scrollbar_down;
+	textbox->scroll_horizontal = s3dw_scrollbar_new(widget, S3DW_SBAR_HORI,  0, widget->height - 1, widget->width - 1);
+	textbox->scroll_vertical = s3dw_scrollbar_new(widget, S3DW_SBAR_VERT,  widget->width - 1, 0, widget->height - 1);
+	textbox->scroll_horizontal->lonclick = _s3dw_textbox_scrollbar_left;
+	textbox->scroll_horizontal->ronclick = _s3dw_textbox_scrollbar_right;
+	textbox->scroll_vertical->lonclick = _s3dw_textbox_scrollbar_up;
+	textbox->scroll_vertical->ronclick = _s3dw_textbox_scrollbar_down;
 
 	return(textbox);
 }
@@ -234,7 +234,7 @@
 
 void s3dw_textbox_scrollup(s3dw_textbox *textbox)
 {
-	if (textbox->window_y>0)
+	if (textbox->window_y > 0)
 		textbox->window_y--;
 	s3dw_textbox_redraw(S3DWIDGET(textbox));
 }
@@ -246,7 +246,7 @@
 }
 void s3dw_textbox_scrollleft(s3dw_textbox *textbox)
 {
-	if (textbox->window_x>0)
+	if (textbox->window_x > 0)
 		textbox->window_x--;
 	s3dw_textbox_redraw(S3DWIDGET(textbox));
 }
@@ -257,20 +257,20 @@
 }
 void s3dw_textbox_scrollto(s3dw_textbox *textbox, int x, int y)
 {
-	s3dw_widget *widget=(s3dw_widget *)textbox;
-	if (x<0) x=0;
-	if (y<0) y=0;
-	textbox->window_x=x;
-	textbox->window_y=y;
+	s3dw_widget *widget = (s3dw_widget *)textbox;
+	if (x < 0) x = 0;
+	if (y < 0) y = 0;
+	textbox->window_x = x;
+	textbox->window_y = y;
 	s3dw_textbox_redraw(widget);
 }
 
 void s3dw_textbox_change_text(s3dw_textbox *textbox, char *text)
 {
-	s3dw_widget *widget=(s3dw_widget *)textbox;
+	s3dw_widget *widget = (s3dw_widget *)textbox;
 	/* redraw the text ... */
 	free(textbox->text);
-	textbox->text=strdup(text);
+	textbox->text = strdup(text);
 	s3dw_textbox_redraw(widget);
 }
 void s3dw_textbox_erase(s3dw_widget *widget)
@@ -282,7 +282,7 @@
 /* destroy the textbox */
 void s3dw_textbox_destroy(s3dw_widget *widget)
 {
-	s3dw_textbox *textbox=(s3dw_textbox *)widget;
+	s3dw_textbox *textbox = (s3dw_textbox *)widget;
 	s3dw_textbox_erase(widget);
 	free(textbox->text);
 	free(textbox);
@@ -295,8 +295,8 @@
 /* handle click events */
 int s3dw_textbox_event_click(s3dw_widget *widget, uint32_t oid)
 {
-	s3dw_textbox *textbox=(s3dw_textbox *)widget;
-	if (widget->oid==oid) {
+	s3dw_textbox *textbox = (s3dw_textbox *)widget;
+	if (widget->oid == oid) {
 		textbox->onclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/widget.c
===================================================================
--- trunk/libs3dw/widget.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/libs3dw/widget.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -28,41 +28,41 @@
 #include <string.h> /* strdup() */
 s3dw_widget *s3dw_widget_new(s3dw_widget *widget)
 {
-	widget->type=-1;
-	widget->x=widget->ax=0;
-	widget->y=widget->ay=0;
-	widget->z=widget->az=0;
-	widget->rx=widget->arx=0;
-	widget->ry=widget->ary=0;
-	widget->rz=widget->arz=0;
-	widget->s=widget->as=1;
-	widget->width=0;
-	widget->height=0;
-	widget->nobj=0;
-	widget->pobj=NULL;
-	widget->parent=NULL;
-	widget->ptr=NULL;
-	widget->focus=-1;
-	widget->flags=S3DW_ACTIVE;
-	widget->oid=-1;
+	widget->type = -1;
+	widget->x = widget->ax = 0;
+	widget->y = widget->ay = 0;
+	widget->z = widget->az = 0;
+	widget->rx = widget->arx = 0;
+	widget->ry = widget->ary = 0;
+	widget->rz = widget->arz = 0;
+	widget->s = widget->as = 1;
+	widget->width = 0;
+	widget->height = 0;
+	widget->nobj = 0;
+	widget->pobj = NULL;
+	widget->parent = NULL;
+	widget->ptr = NULL;
+	widget->focus = -1;
+	widget->flags = S3DW_ACTIVE;
+	widget->oid = -1;
 	return(widget);
 }
 /* widget clicked, call specific function and check kids */
 int s3dw_widget_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	int i;
-	s3dprintf(VLOW,"processing click event for widget %010p of type %d, oid %d (%d), subobjects: %d",widget,widget->type, widget->oid, oid, widget->nobj);
-	if (s3dwcb_click[widget->type](widget,oid)) return(1);
-	for (i=0;i<widget->nobj;i++)
-		if (s3dw_widget_event_click(widget->pobj[i],oid)) return(1);
+	s3dprintf(VLOW, "processing click event for widget %010p of type %d, oid %d (%d), subobjects: %d", widget, widget->type, widget->oid, oid, widget->nobj);
+	if (s3dwcb_click[widget->type](widget, oid)) return(1);
+	for (i = 0;i < widget->nobj;i++)
+		if (s3dw_widget_event_click(widget->pobj[i], oid)) return(1);
 	return(0);
 }
 /* widget received key,,call specific function and check (focused) kids */
 int s3dw_widget_event_key(s3dw_widget *widget, struct s3d_key_event *keys)
 {
-	if (s3dwcb_key[widget->type](widget,keys)) return(1);
-	if (widget->focus!=-1)
-		if (s3dw_widget_event_key(widget->pobj[widget->focus],keys)) return(1);
+	if (s3dwcb_key[widget->type](widget, keys)) return(1);
+	if (widget->focus != -1)
+		if (s3dw_widget_event_key(widget->pobj[widget->focus], keys)) return(1);
 	return(0);
 }
 
@@ -71,25 +71,25 @@
 void s3dw_widget_append(s3dw_widget *parent, s3dw_widget *widget)
 {
 	parent->nobj++;
-	parent->pobj=realloc(parent->pobj,sizeof(s3dw_widget **) * (parent->nobj));
-	parent->pobj[parent->nobj-1]=widget;
-	widget->parent=parent;
-	widget->style=parent->style;
+	parent->pobj = realloc(parent->pobj, sizeof(s3dw_widget **) * (parent->nobj));
+	parent->pobj[parent->nobj-1] = widget;
+	widget->parent = parent;
+	widget->style = parent->style;
 	if (!(parent->flags&S3DW_VISIBLE))
-		widget->flags|=S3DW_VISIBLE;
+		widget->flags |= S3DW_VISIBLE;
 }
 /* removes an widget from it's parent, should have been appended before */
 void s3dw_widget_remove(s3dw_widget *widget)
 {
-	s3dw_widget *parent=widget->parent;
+	s3dw_widget *parent = widget->parent;
 	int i;
-	if (parent==NULL) return;
+	if (parent == NULL) return;
 
-	for (i=0;i<parent->nobj;i++) /* search ... */
-		if (parent->pobj[i]==widget) { /* ... and destroy */
-			if (parent->focus==i)					parent->focus=-1;
-			if (parent->focus==(parent->nobj-1))	parent->focus=i;
-			parent->pobj[i]=parent->pobj[parent->nobj-1]; /* swap last element to the to be deleted one */
+	for (i = 0;i < parent->nobj;i++) /* search ... */
+		if (parent->pobj[i] == widget) { /* ... and destroy */
+			if (parent->focus == i)     parent->focus = -1;
+			if (parent->focus == (parent->nobj - 1)) parent->focus = i;
+			parent->pobj[i] = parent->pobj[parent->nobj-1]; /* swap last element to the to be deleted one */
 			parent->nobj--;
 		}
 }
@@ -98,23 +98,23 @@
 {
 	s3dw_widget_remove(widget);
 	/* remove kids */
-	while (widget->nobj>0) /* will decrease as child-delete will call s3dw_widget_remove() */
+	while (widget->nobj > 0) /* will decrease as child-delete will call s3dw_widget_remove() */
 		s3dw_delete(widget->pobj[0]);
 	free(widget->pobj);
-	s3dwcb_destroy[widget->type](widget);	/* type-specific destroy */
+	s3dwcb_destroy[widget->type](widget); /* type-specific destroy */
 }
 /* toggle a widget visible and show it */
 void s3dw_show(s3dw_widget *widget)
 {
-	widget->flags|=S3DW_VISIBLE;
+	widget->flags |= S3DW_VISIBLE;
 	s3dw_widget_visible(widget);
 }
 void s3dw_focus(s3dw_widget *focus)
 {
 	int i;
-	for (i=0;i<focus->parent->nobj;i++)
-		if (focus->parent->pobj[i]==focus) {
-			focus->parent->focus=i;
+	for (i = 0;i < focus->parent->nobj;i++)
+		if (focus->parent->pobj[i] == focus) {
+			focus->parent->focus = i;
 			return;
 		}
 }
@@ -124,16 +124,16 @@
 {
 	int i;
 	s3dw_widget *kid;
-	for (i=0;i<widget->nobj;i++) {
-		kid=widget->pobj[i];
+	for (i = 0;i < widget->nobj;i++) {
+		kid = widget->pobj[i];
 		if (widget->flags&S3DW_VISIBLE)
 			s3dw_widget_visible(kid);
 	}
-	widget->flags|=S3DW_ONSCREEN;
+	widget->flags |= S3DW_ONSCREEN;
 	s3dwcb_show[widget->type](widget);
 }
 /* apply the moves ... */
-void				 s3dw_moveit(s3dw_widget *widget)
+void     s3dw_moveit(s3dw_widget *widget)
 {
 	s3dw_ani_add(widget);
 }

Modified: trunk/server/allocate.c
===================================================================
--- trunk/server/allocate.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/allocate.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,12 +1,12 @@
 /*
  * allocate.c
  *
- * Copyright (C) 2006 	Marek Lindner <lindner_marek at yahoo.de>
- * 						Thomas Lopatic
- * 						Corinna 'Elektra' Aichele
- * 						Axel Neumann
- * 						Felix Fietkau
- * 						Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2006  Marek Lindner <lindner_marek at yahoo.de>
+ *       Thomas Lopatic
+ *       Corinna 'Elektra' Aichele
+ *       Axel Neumann
+ *       Felix Fietkau
+ *       Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.
@@ -93,7 +93,7 @@
 	struct chunkTrailer *chunkTrailer;
 	unsigned char *chunk;
 
-	/* 	printf("sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\n", sizeof (struct chunkHeader), sizeof (struct chunkTrailer)); */
+	/*  printf("sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\n", sizeof (struct chunkHeader), sizeof (struct chunkTrailer)); */
 
 	memory = malloc(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer));
 

Modified: trunk/server/allocate.h
===================================================================
--- trunk/server/allocate.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/allocate.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -1,12 +1,12 @@
 /*
  * allocate.h
  *
- * Copyright (C) 2006 	Marek Lindner <lindner_marek at yahoo.de>
- *						Thomas Lopatic
- * 						Corinna 'Elektra' Aichele
- * 						Axel Neumann
- * 						Felix Fietkau
- * 						Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2006  Marek Lindner <lindner_marek at yahoo.de>
+ *      Thomas Lopatic
+ *       Corinna 'Elektra' Aichele
+ *       Axel Neumann
+ *       Felix Fietkau
+ *       Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3d, a 3d network display server.
  * See http://s3d.berlios.de/ for more updates.

Modified: trunk/server/config.h
===================================================================
--- trunk/server/config.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/config.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -27,18 +27,18 @@
 /*  to be filled with configure options ...  */
 /*   */
 /*  on which port do we listen? */
-#define S3D_PORT	6066
+#define S3D_PORT 6066
 /*  resolution on startup */
-#define X_RES	800
-#define Y_RES	600
+#define X_RES 800
+#define Y_RES 600
 /* how many frames to wait until test the connection if it's still here */
-#define MAX_IDLE	50
+#define MAX_IDLE 50
 /*  this is to be set dynamicly later on */
-#define VLOW	1
-#define	LOW		2
-#define MED		3
-#define HIGH	4
-#define	VHIGH	5
+#define VLOW 1
+#define LOW  2
+#define MED  3
+#define HIGH 4
+#define VHIGH 5
 /*  which is the minimum level of debugmessage we want to see? */
-/* #define DEBUG	LOW */ 		/* should be set with compile, e.g. -DDEBUG=LOW */
+/* #define DEBUG LOW */   /* should be set with compile, e.g. -DDEBUG=LOW */
 

Modified: trunk/server/cull.c
===================================================================
--- trunk/server/cull.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/cull.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -25,80 +25,80 @@
 
 
 #include "global.h"
-#include <math.h>	/* sqrt() */
-#include <GL/gl.h>	/* glGetFloatv() */
+#include <math.h> /* sqrt() */
+#include <GL/gl.h> /* glGetFloatv() */
 struct t_plane {
 	struct t_vertex n;
 	float d;
 };
-#define LEFT	0
-#define RIGHT	1
-#define TOP		2
-#define BOTTOM	3
-#define PNEAR	4
-#define PFAR	5
+#define LEFT 0
+#define RIGHT 1
+#define TOP  2
+#define BOTTOM 3
+#define PNEAR 4
+#define PFAR 5
 static struct t_plane frustumPlane[6];
 void cull_get_planes()
 {
-	t_mtrx m,mproj,mmodel;
+	t_mtrx m, mproj, mmodel;
 	struct t_plane *p;
 	int i;
 	float d;
 
 
 	/* get matrices from opengl */
-	glGetFloatv(GL_MODELVIEW_MATRIX,mmodel);
-	glGetFloatv(GL_PROJECTION_MATRIX,mproj);
+	glGetFloatv(GL_MODELVIEW_MATRIX, mmodel);
+	glGetFloatv(GL_PROJECTION_MATRIX, mproj);
 
 	mySetMatrix(mproj);
 	myMultMatrix(mmodel);
 	myGetMatrix(m); /* multiply and have the result in m */
 
-	p=&frustumPlane[RIGHT];
-	p->n.x=m[3]-m[0];
-	p->n.y=m[7]-m[4];
-	p->n.z=m[11]-m[8];
-	p->d=m[15]-m[12];
+	p = &frustumPlane[RIGHT];
+	p->n.x = m[3] - m[0];
+	p->n.y = m[7] - m[4];
+	p->n.z = m[11] - m[8];
+	p->d = m[15] - m[12];
 
-	p=&frustumPlane[LEFT];
-	p->n.x=m[3]+m[0];
-	p->n.y=m[7]+m[4];
-	p->n.z=m[11]+m[8];
-	p->d=m[15]+m[12];
+	p = &frustumPlane[LEFT];
+	p->n.x = m[3] + m[0];
+	p->n.y = m[7] + m[4];
+	p->n.z = m[11] + m[8];
+	p->d = m[15] + m[12];
 
-	p=&frustumPlane[BOTTOM];
-	p->n.x=m[3]+m[1];
-	p->n.y=m[7]+m[5];
-	p->n.z=m[11]+m[9];
-	p->d=m[15]+m[13];
+	p = &frustumPlane[BOTTOM];
+	p->n.x = m[3] + m[1];
+	p->n.y = m[7] + m[5];
+	p->n.z = m[11] + m[9];
+	p->d = m[15] + m[13];
 
-	p=&frustumPlane[TOP];
-	p->n.x=m[3]-m[1];
-	p->n.y=m[7]-m[5];
-	p->n.z=m[11]-m[9];
-	p->d=m[15]-m[13];
+	p = &frustumPlane[TOP];
+	p->n.x = m[3] - m[1];
+	p->n.y = m[7] - m[5];
+	p->n.z = m[11] - m[9];
+	p->d = m[15] - m[13];
 
-	p=&frustumPlane[PFAR];
-	p->n.x=m[3]-m[2];
-	p->n.y=m[7]-m[6];
-	p->n.z=m[11]-m[10];
-	p->d=m[15]-m[14];
+	p = &frustumPlane[PFAR];
+	p->n.x = m[3] - m[2];
+	p->n.y = m[7] - m[6];
+	p->n.z = m[11] - m[10];
+	p->d = m[15] - m[14];
 
-	p=&frustumPlane[PNEAR];
-	p->n.x=m[3]+m[2];
-	p->n.y=m[7]+m[6];
-	p->n.z=m[11]+m[10];
-	p->d=m[15]+m[14];
+	p = &frustumPlane[PNEAR];
+	p->n.x = m[3] + m[2];
+	p->n.y = m[7] + m[6];
+	p->n.z = m[11] + m[10];
+	p->d = m[15] + m[14];
 
 	/* Normalize all plane normals */
-	for (i=0;i<6;i++) {
-		p=&frustumPlane[i];
-		d=sqrt(p->n.x*p->n.x + p->n.y*p->n.y + p->n.z*p->n.z);
-		if (d!=0.0) {
-			p->n.x/=d;
-			p->n.y/=d;
-			p->n.z/=d;
-			p->d/=d;
+	for (i = 0;i < 6;i++) {
+		p = &frustumPlane[i];
+		d = sqrt(p->n.x * p->n.x + p->n.y * p->n.y + p->n.z * p->n.z);
+		if (d != 0.0) {
+			p->n.x /= d;
+			p->n.y /= d;
+			p->n.z /= d;
+			p->d /= d;
 		}
 	}
 }
@@ -107,10 +107,10 @@
 {
 	int i;
 	struct t_plane *p;
-	for (i=0;i<6;i++) {
-		p=&frustumPlane[i];
-		if (p->n.x*center->x+p->n.y*center->y+p->n.z*center->z+p->d <= -radius) {
-			/*			s3dprintf(MED,"out of %d plane (n %f %f %f |d %f)",i,p->n.x,p->n.y,p->n.z,p->d);*/
+	for (i = 0;i < 6;i++) {
+		p = &frustumPlane[i];
+		if (p->n.x*center->x + p->n.y*center->y + p->n.z*center->z + p->d <= -radius) {
+			/*   s3dprintf(MED,"out of %d plane (n %f %f %f |d %f)",i,p->n.x,p->n.y,p->n.z,p->d);*/
 			return 0; /* sorry, no ... */
 		}
 	}

Modified: trunk/server/error.c
===================================================================
--- trunk/server/error.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/error.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,49 +23,49 @@
 
 
 #include "global.h"
-#include <stdio.h>	 /*  for printf() */
-#include <stdarg.h>	 /*  va_start, va_end */
+#include <stdio.h>  /*  for printf() */
+#include <stdarg.h>  /*  va_start, va_end */
 #include <string.h>  /*  for strerror() */
 #include <stdlib.h>  /*  for exit() */
-#define 	DBM_MAX		1024  /*  debug message buffer size */
+#define  DBM_MAX  1024  /*  debug message buffer size */
 /*  this function writes an error somewhere */
 /*  basicly, this is for upcoming logfiles, or maybe draw error-messages into */
 /*  the 3d-space */
 /*  this is the generic failure routine ... */
-void errn(char *func,int en)
+void errn(char *func, int en)
 {
-	fprintf(stderr,"error: %s: (%d) %s\n",func,en, strerror(en));
+	fprintf(stderr, "error: %s: (%d) %s\n", func, en, strerror(en));
 }
 /*  ... and it's fatal pendant */
-void errnf(char *func,int en)
+void errnf(char *func, int en)
 {
-	fprintf(stderr,"FATAL: %s: (%d) %s\n",func,en, strerror(en));
+	fprintf(stderr, "FATAL: %s: (%d) %s\n", func, en, strerror(en));
 	exit(-1);
 }
 
 /*  prints an error with the function and it's error-message */
 void errs(char *func, char *msg)
 {
-	fprintf(stderr,"error: %s: %s\n",func,msg);
+	fprintf(stderr, "error: %s: %s\n", func, msg);
 }
 
 void errsf(char *func, char *msg)
 {
-	fprintf(stderr,"FATAL: %s: %s\n",func,msg);
+	fprintf(stderr, "FATAL: %s: %s\n", func, msg);
 	exit(-1);
 }
 #ifdef DEBUG
 /*  printing error message */
-void errds(int relevance,char *func, const char *fmt, ...)
+void errds(int relevance, char *func, const char *fmt, ...)
 {
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance >= DEBUG ) {
-		va_start(args,fmt);
-		vsnprintf((char *)&dbm,DBM_MAX,fmt,args);
+	if (relevance >= DEBUG) {
+		va_start(args, fmt);
+		vsnprintf((char *)&dbm, DBM_MAX, fmt, args);
 		va_end(args);
 
-		fprintf(stderr,"error: %s:%s\n",func,(char *)&dbm);
+		fprintf(stderr, "error: %s:%s\n", func, (char *)&dbm);
 	}
 }
 /*  printing debug message */
@@ -74,13 +74,13 @@
 {
 	char dbm[DBM_MAX];
 	va_list args;
-	if (relevance >= DEBUG ) {
-		va_start(args,fmt);
-		vsnprintf((char *)&dbm,DBM_MAX,fmt,args);
+	if (relevance >= DEBUG) {
+		va_start(args, fmt);
+		vsnprintf((char *)&dbm, DBM_MAX, fmt, args);
 		va_end(args);
 
-		/*		fprintf(stderr,"debug: %s\n",(char *)&dbm);*/
-		fprintf(stdout,"debug: %s\n",(char *)&dbm);
+		/*  fprintf(stderr,"debug: %s\n",(char *)&dbm);*/
+		fprintf(stdout, "debug: %s\n", (char *)&dbm);
 	}
 }
 

Modified: trunk/server/event.c
===================================================================
--- trunk/server/event.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/event.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,7 +24,7 @@
 
 #include "global.h"
 #include "proto.h"
-#include <stdio.h>		/* sprintf() */
+#include <stdio.h>  /* sprintf() */
 #ifdef WIN32
 #include <winsock2.h>
 #else
@@ -32,30 +32,30 @@
 #endif
 #include <string.h>  /*  strlen(),strcpy() */
 extern int focus_oid;
-extern int winw,winh; /* to give aspect ratio to the program */
+extern int winw, winh; /* to give aspect ratio to the program */
 /*  I don't plan to keep this until the end, but it can show us how */
 /*  to interact ... */
 int event_obj_click(struct t_process *p, int32_t oid)
 {
-	uint32_t moid=htonl(oid);
-	s3dprintf(MED,"telling client that oid %d got clicked",oid);
-	prot_com_out(p,S3D_P_S_CLICK,(uint8_t *)&moid, 4);
+	uint32_t moid = htonl(oid);
+	s3dprintf(MED, "telling client that oid %d got clicked", oid);
+	prot_com_out(p, S3D_P_S_CLICK, (uint8_t *)&moid, 4);
 	return(0);
 }
 /*  this functions sends keystroke events to the focused program. */
 /*  maybe mcp-keystrokes should be catched here. */
 /*  state = 0 -> pressed, 1 -> released */
-int event_key_pressed(uint16_t key, uint16_t uni, uint16_t mod,int state)
+int event_key_pressed(uint16_t key, uint16_t uni, uint16_t mod, int state)
 {
 	uint16_t k[4];
 	struct t_obj *o;
-	k[0]=htons(key);
-	k[1]=htons(uni);
-	k[2]=htons(mod);
-	k[3]=htons(state);
-	if (OBJ_VALID(get_proc_by_pid(MCP),focus_oid,o))
+	k[0] = htons(key);
+	k[1] = htons(uni);
+	k[2] = htons(mod);
+	k[3] = htons(state);
+	if (OBJ_VALID(get_proc_by_pid(MCP), focus_oid, o))
 		prot_com_out(get_proc_by_pid(o->n_mat), S3D_P_S_KEY, (uint8_t *)k, 8);
-	prot_com_out(get_proc_by_pid(MCP),S3D_P_S_KEY,(uint8_t *)k, 8); /* mcp always gets a copy */
+	prot_com_out(get_proc_by_pid(MCP), S3D_P_S_KEY, (uint8_t *)k, 8); /* mcp always gets a copy */
 	return(0);
 }
 
@@ -65,26 +65,26 @@
 {
 	struct t_obj *o;
 	uint8_t b[2];
-	b[0]=button;
-	b[1]=state;
-	if (OBJ_VALID(get_proc_by_pid(MCP),focus_oid,o))
+	b[0] = button;
+	b[1] = state;
+	if (OBJ_VALID(get_proc_by_pid(MCP), focus_oid, o))
 		prot_com_out(get_proc_by_pid(o->n_mat), S3D_P_S_MBUTTON, (uint8_t *)&b, 2);
-	prot_com_out(get_proc_by_pid(MCP),S3D_P_S_MBUTTON,(uint8_t *)&b, 2); /* mcp always gets a copy */
+	prot_com_out(get_proc_by_pid(MCP), S3D_P_S_MBUTTON, (uint8_t *)&b, 2); /* mcp always gets a copy */
 	return(0);
 }
 /*  tell the client something about us */
 int event_init(struct t_process *p)
 {
 	char s[NAME_MAX+3];
-	sprintf(s,"%c%c%c%s", S3D_SERVER_MAJOR, S3D_SERVER_MINOR, S3D_SERVER_PATCH, S3D_SERVER_NAME); /* thanks award */
-	prot_com_out(p,S3D_P_S_INIT, (uint8_t *)s, strlen(S3D_SERVER_NAME)+4);
+	sprintf(s, "%c%c%c%s", S3D_SERVER_MAJOR, S3D_SERVER_MINOR, S3D_SERVER_PATCH, S3D_SERVER_NAME); /* thanks award */
+	prot_com_out(p, S3D_P_S_INIT, (uint8_t *)s, strlen(S3D_SERVER_NAME) + 4);
 	return(0);
 }
 /*  this lets a process quit gracefully ... */
 int event_quit(struct t_process *p)
 {
-	prot_com_out(p, S3D_P_S_QUIT, NULL,0);
-	s3dprintf(HIGH,"sending pid %d QUIT signal",p->id);
+	prot_com_out(p, S3D_P_S_QUIT, NULL, 0);
+	s3dprintf(HIGH, "sending pid %d QUIT signal", p->id);
 	process_del(p->id);
 	return(0);
 }
@@ -92,23 +92,23 @@
 int event_cam_changed()
 {
 	struct t_process *p;
-	struct t_obj	 *o;
-	p=get_proc_by_pid(MCP);
-	event_obj_info(p,0);
-	if (OBJ_VALID(p,focus_oid,o))
-		event_obj_info(get_proc_by_pid(o->n_mat),0);
+	struct t_obj  *o;
+	p = get_proc_by_pid(MCP);
+	event_obj_info(p, 0);
+	if (OBJ_VALID(p, focus_oid, o))
+		event_obj_info(get_proc_by_pid(o->n_mat), 0);
 	return(0);
 }
 /* same for the mouse movement! */
 int event_ptr_changed()
 {
 	struct t_process *p;
-	struct t_obj	 *o;
-	p=get_proc_by_pid(MCP);
-	event_obj_info(p,get_pointer(p));
-	if (OBJ_VALID(p,focus_oid,o)) {
-		p=get_proc_by_pid(o->n_mat); /* focused program pointer*/
-		event_obj_info(p,get_pointer(p));
+	struct t_obj  *o;
+	p = get_proc_by_pid(MCP);
+	event_obj_info(p, get_pointer(p));
+	if (OBJ_VALID(p, focus_oid, o)) {
+		p = get_proc_by_pid(o->n_mat); /* focused program pointer*/
+		event_obj_info(p, get_pointer(p));
 	}
 	return(0);
 }
@@ -119,36 +119,36 @@
 	struct t_obj_info mo;
 	struct t_process *ap;
 	struct t_obj *o;
-	if (OBJ_VALID(p,oid,o)) {
-		mo.object=htonl(oid);
-		mo.trans_x=p->object[oid]->translate.x;
-		mo.trans_y=p->object[oid]->translate.y;
-		mo.trans_z=p->object[oid]->translate.z;
+	if (OBJ_VALID(p, oid, o)) {
+		mo.object = htonl(oid);
+		mo.trans_x = p->object[oid]->translate.x;
+		mo.trans_y = p->object[oid]->translate.y;
+		mo.trans_z = p->object[oid]->translate.z;
 
-		mo.rot_x=p->object[oid]->rotate.x;
-		mo.rot_y=p->object[oid]->rotate.y;
-		mo.rot_z=p->object[oid]->rotate.z;
+		mo.rot_x = p->object[oid]->rotate.x;
+		mo.rot_y = p->object[oid]->rotate.y;
+		mo.rot_z = p->object[oid]->rotate.z;
 
-		mo.scale=p->object[oid]->scale;
+		mo.scale = p->object[oid]->scale;
 
-		mo.r=p->object[oid]->r;
+		mo.r = p->object[oid]->r;
 
-		memset(mo.name,0,NAME_MAX);
+		memset(mo.name, 0, NAME_MAX);
 		switch (o->oflags&OF_TYPE) {
 		case OF_VIRTUAL:
-			ap=get_proc_by_pid(o->n_mat);
-			strncpy(mo.name,ap->name,NAME_MAX);
+			ap = get_proc_by_pid(o->n_mat);
+			strncpy(mo.name, ap->name, NAME_MAX);
 			break;
 		case OF_CAM:
-			mo.scale=(float)((float)winw)/winh; /* give aspect ratio to program */
-			strncpy(mo.name,"sys_camera0",NAME_MAX);
+			mo.scale = (float)((float)winw) / winh; /* give aspect ratio to program */
+			strncpy(mo.name, "sys_camera0", NAME_MAX);
 			break;
 		case OF_POINTER:
-			strncpy(mo.name,"sys_pointer0",NAME_MAX);
+			strncpy(mo.name, "sys_pointer0", NAME_MAX);
 			break;
 
 		}
-		prot_com_out(p,S3D_P_S_OINFO,(uint8_t *)&mo,sizeof(struct t_obj_info));
+		prot_com_out(p, S3D_P_S_OINFO, (uint8_t *)&mo, sizeof(struct t_obj_info));
 	}
 	return(0);
 }

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/global.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -28,13 +28,13 @@
 #undef SHM
 #endif
 #endif
-#include <stdint.h>		 /*  integer types */
+#include <stdint.h>   /*  integer types */
 #ifdef SHM
 #include <sys/shm.h> /* key_t */
 #endif
 /*  variables and defines */
-extern int frame_mode; 	 /*  GLUT, SDL, ... ? */
-extern int running;		 /*  server running flag */
+extern int frame_mode;   /*  GLUT, SDL, ... ? */
+extern int running;   /*  server running flag */
 /*  relevance macros */
 #ifndef S3DUNUSED
 #if defined(UNUSEDPARAM_ATTRIBUTE)
@@ -45,152 +45,152 @@
 #define S3DUNUSED(x) x
 #endif
 #endif
-#define NAME_MAX	256		 /*  limit for names [e.g. process names] */
-#define MCP			0		 /*  the mcp's pid	 */
-#define TEXTURE_MAX_W	2048
-#define TEXTURE_MAX_H	2048
+#define NAME_MAX 256   /*  limit for names [e.g. process names] */
+#define MCP   0   /*  the mcp's pid  */
+#define TEXTURE_MAX_W 2048
+#define TEXTURE_MAX_H 2048
 /*  server version */
-#define S3D_SERVER_MAJOR	0
-#define S3D_SERVER_MINOR	1
-#define S3D_SERVER_PATCH	1
-#define S3D_SERVER_NAME 	"dotslash s3d server"
+#define S3D_SERVER_MAJOR 0
+#define S3D_SERVER_MINOR 1
+#define S3D_SERVER_PATCH 1
+#define S3D_SERVER_NAME  "dotslash s3d server"
 
-#define MAXPLEN	65536
+#define MAXPLEN 65536
 
-#define RB_STD_SIZE		1024*512
-#define RB_MAX_SIZE		1048*4096
-#define SHM_SIZE 	sizeof(key_t)*2  		/* space for the keys */
+#define RB_STD_SIZE  1024*512
+#define RB_MAX_SIZE  1048*4096
+#define SHM_SIZE  sizeof(key_t)*2    /* space for the keys */
 
-#define RB_OVERHEAD		sizeof(struct buf_t)
+#define RB_OVERHEAD  sizeof(struct buf_t)
 
-#define OBJ_VALID(p,oid,o)	(oid >= 0) && ((oid < p->n_obj) && ((o=p->object[oid])!=NULL))
+#define OBJ_VALID(p,oid,o) (oid >= 0) && ((oid < p->n_obj) && ((o=p->object[oid])!=NULL))
 typedef float t_mtrx[16];
 
 struct buf_t {
-	uint32_t start,end,bufsize;	/* start/end of the data */
+	uint32_t start, end, bufsize; /* start/end of the data */
 };
 
 /*  some graphic simple prototypes, they might get into some headerfile later ... */
 /*  our lovely vertex list ... */
 struct t_vertex {
-	float x,y,z;
+	float x, y, z;
 };
 struct t_texc {
-	float x,y;
+	float x, y;
 };
 /*  polygon definition; */
 /*  it's all handled via list types as usually we have only one surface for many polygons, */
 /*  and many vertexes have 2 or more polygons connected. OpenGL will optimize the lists for us */
 /*  anyways, so we shouldn't care ... */
 struct t_poly {
-	uint32_t v[3]; 				 /*  we define a poly as set of 3 vertexes, as its usual */
-	struct t_vertex n[3]; 		 /*  normal vectors */
-	uint32_t mat;  				 /*  material index */
-	struct t_texc tc[3];		 /*  texture coords */
+	uint32_t v[3];      /*  we define a poly as set of 3 vertexes, as its usual */
+	struct t_vertex n[3];    /*  normal vectors */
+	uint32_t mat;       /*  material index */
+	struct t_texc tc[3];   /*  texture coords */
 };
 struct t_line {
 	uint32_t v[2];
-	struct t_vertex n[2];		 /* normal vectors */
+	struct t_vertex n[2];   /* normal vectors */
 	uint32_t mat;
 };
 /*  material of surfaces, as it's usual in the OpenGL standard */
 struct t_mat {
-	float amb_r,amb_g,amb_b,amb_a, 			 /*  ambience */
-	spec_r,spec_g,spec_b,spec_a,	 	 /*  specualar */
-	diff_r,diff_g,diff_b,diff_a;		 /*  diffusion */
-	int32_t tex;							 /*  texture index, -1 if there is no */
+	float amb_r, amb_g, amb_b, amb_a,  /*  ambience */
+	spec_r, spec_g, spec_b, spec_a, /*  specualar */
+	diff_r, diff_g, diff_b, diff_a;   /*  diffusion */
+	int32_t tex;        /*  texture index, -1 if there is no */
 };
 /*  this defines a texture */
 struct t_tex {
-	uint16_t w,h;		 /*  width and height */
-	uint16_t tw,th;		 /*  texture width */
-	uint8_t *buf;		 /*  the data */
-	float xs,ys;		 /*  scale data for gl-implementations which require 2^x */
+	uint16_t w, h;  /*  width and height */
+	uint16_t tw, th;  /*  texture width */
+	uint8_t *buf;   /*  the data */
+	float xs, ys;  /*  scale data for gl-implementations which require 2^x */
 	/*  texture sizes. */
-	int32_t gl_texnum;	 /*  the gl texture number. */
+	int32_t gl_texnum;  /*  the gl texture number. */
 };
 /*  the object type */
 struct t_obj {
-	uint32_t oflags;			 /*  flags, like this object beeing input etc. */
-#define OF_TURN_ON 		1
-#define OF_TURN_OFF 	2
-#define OF_TURN_SWAP 	3
+	uint32_t oflags;    /*  flags, like this object beeing input etc. */
+#define OF_TURN_ON   1
+#define OF_TURN_OFF  2
+#define OF_TURN_SWAP  3
 
-#define	OF_VISIBLE		0x00000001
-#define	OF_SELECTABLE	0x00000002
-#define	OF_POINTABLE	0x00000004
+#define OF_VISIBLE  0x00000001
+#define OF_SELECTABLE 0x00000002
+#define OF_POINTABLE 0x00000004
 
-#define OF_CLONE_SRC	0x01000000
-#define OF_LINK_SRC		0x02000000
-#define OF_LINK			0x04000000
+#define OF_CLONE_SRC 0x01000000
+#define OF_LINK_SRC  0x02000000
+#define OF_LINK   0x04000000
 
 
-#define OF_TYPE			0xF0000000
-#define OF_NODATA		0xF0000000 /* no data allowed! */
+#define OF_TYPE   0xF0000000
+#define OF_NODATA  0xF0000000 /* no data allowed! */
 
-#define OF_CLONE		0x10000000
-#define OF_VIRTUAL		0x20000000
+#define OF_CLONE  0x10000000
+#define OF_VIRTUAL  0x20000000
 
-#define OF_SYSTEM		0x80000000
-#define OF_CAM			0x90000000
-#define OF_POINTER		0xA0000000
-#define OF_3DPOINTER	0xB0000000
+#define OF_SYSTEM  0x80000000
+#define OF_CAM   0x90000000
+#define OF_POINTER  0xA0000000
+#define OF_3DPOINTER 0xB0000000
 
-#define OF_MASK			0x00FFFFFF
+#define OF_MASK   0x00FFFFFF
 	int32_t n_vertex, n_mat, n_poly, n_tex, n_line;
 	/*  if OF_VIRTUAL is set, n_mat contains the pid */
 	/*  if OF_CLONE is set, n_vertex contains the original oid */
 	/*  I know this is dirty, but it would a waste of data if I don't do so ... */
-	int32_t dplist;		 /*  opengl display list number */
-	int32_t linkid;		 /*  linking target, -1 if there is none */
-	int32_t lsub,lnext,lprev;
+	int32_t dplist;   /*  opengl display list number */
+	int32_t linkid;   /*  linking target, -1 if there is none */
+	int32_t lsub, lnext, lprev;
 	/*  pointer to our objects; */
 	struct t_vertex *p_vertex;
-	struct t_mat	*p_mat;
-	struct t_poly	*p_poly;
+	struct t_mat *p_mat;
+	struct t_poly *p_poly;
 	struct t_line   *p_line;
-	struct t_tex	*p_tex;
-	struct t_vertex translate,rotate;
-	float 			scale;
-	t_mtrx			m;
-	int				m_uptodate;
-	float r,or;					 /*  radius, object radius */
+	struct t_tex *p_tex;
+	struct t_vertex translate, rotate;
+	float    scale;
+	t_mtrx   m;
+	int    m_uptodate;
+	float r, or;     /*  radius, object radius */
 };
 #ifdef SHM
 struct t_shmcb {
-	int shmid_ctos,shmid_stoc;
-	key_t key_ctos,key_stoc;
-	char *data_ctos,*data_stoc;
-	int size_ctos,size_stoc;
+	int shmid_ctos, shmid_stoc;
+	key_t key_ctos, key_stoc;
+	char *data_ctos, *data_stoc;
+	int size_ctos, size_stoc;
 	int idle;
 };
 #endif
 
 /*  l_* is a list-type, t_* is the type itself */
 struct t_process {
-	char 				  name[NAME_MAX];		 /*  process name */
-	struct t_obj		**object;				 /*  initial pointer to object list */
-	int32_t				  n_obj;				 /*  number of objects */
-	int32_t				  biggest_obj;			 /*  the biggest object */
-	int32_t				  mcp_oid;				 /*  oid in mcp */
-	int 				  id;					 /*  pid */
-	int					  con_type;				 /*  type of connection, one of following: */
-#define CON_NULL	0
-#define CON_TCP		1
-#define CON_SHM		2
+	char       name[NAME_MAX];   /*  process name */
+	struct t_obj  **object;     /*  initial pointer to object list */
+	int32_t      n_obj;     /*  number of objects */
+	int32_t      biggest_obj;    /*  the biggest object */
+	int32_t      mcp_oid;     /*  oid in mcp */
+	int       id;      /*  pid */
+	int       con_type;     /*  type of connection, one of following: */
+#define CON_NULL 0
+#define CON_TCP  1
+#define CON_SHM  2
 #ifdef TCP
-	int					  sockid;
+	int       sockid;
 #endif
 #ifdef SHM
-	struct t_shmcb		  shmsock;
+	struct t_shmcb    shmsock;
 #endif
 };
 
 struct t_obj_info {
 	int32_t object;
 	uint32_t flags;
-	float trans_x,trans_y,trans_z;
-	float rot_x,rot_y,rot_z;
+	float trans_x, trans_y, trans_z;
+	float rot_x, rot_y, rot_z;
 	float scale;
 	float r;
 	char name[NAME_MAX];
@@ -211,11 +211,11 @@
 int network_init(void);
 int network_quit(void);
 int network_main(void);
-int n_readn(struct t_process *p, uint8_t *str,int s);
-int n_writen(struct t_process *p, uint8_t *str,int s);
+int n_readn(struct t_process *p, uint8_t *str, int s);
+int n_writen(struct t_process *p, uint8_t *str, int s);
 int n_remove(struct t_process *p);
 #ifdef G_SDL
-int	net_turn_off(int interval);
+int net_turn_off(int interval);
 #endif
 /* tcp.c */
 int tcp_init(void);
@@ -223,21 +223,21 @@
 int tcp_pollport(void);
 int tcp_pollproc(void);
 int tcp_prot_com_in(struct t_process *p);
-int tcp_writen(int sock, uint8_t *str,int s);
-int tcp_readn(int sock, uint8_t *str,int s);
+int tcp_writen(int sock, uint8_t *str, int s);
+int tcp_readn(int sock, uint8_t *str, int s);
 int tcp_remove(int sock);
 /* shm.c/shm_ringbuf.c */
 int shm_init(void);
 int shm_quit(void);
 int shm_main(void);
 int shm_remove(struct t_process *p);
-int shm_writen(struct buf_t *rb,uint8_t *buf, int n);
-int shm_readn(struct buf_t *rb,uint8_t *buf, int n);
+int shm_writen(struct buf_t *rb, uint8_t *buf, int n);
+int shm_readn(struct buf_t *rb, uint8_t *buf, int n);
 int shm_prot_com_in(struct t_process *p);
 /* shm_ringbuf.c */
-void ringbuf_init(char *data,uint32_t init_size);
-int shm_write(struct buf_t *rb,char *buf, int n);
-int shm_read(struct buf_t *rb,char *buf, int n);
+void ringbuf_init(char *data, uint32_t init_size);
+int shm_write(struct buf_t *rb, char *buf, int n);
+int shm_read(struct buf_t *rb, char *buf, int n);
 /*  proto.c */
 int prot_com_in(struct t_process *p, uint8_t *pbuf);
 int prot_com_out(struct t_process *p, uint8_t opcode, uint8_t *buf, uint16_t length);
@@ -273,7 +273,7 @@
 void errs(char *func, char *msg);
 void errsf(char *func, char *msg);
 #ifdef DEBUG
-void errds(int relevance,char *func, const char *fmt, ...);
+void errds(int relevance, char *func, const char *fmt, ...);
 void s3dprintf(int relevance, const char *msg, ...);
 #else
 static __inline__ void errds(int relevance __attribute__((unused)),
@@ -297,7 +297,7 @@
 int graphics_quit_sdl(void);
 #endif
 
-void graphics_reshape( int w, int h);
+void graphics_reshape(int w, int h);
 /*  navigation.c */
 void navi_left(void);
 void navi_right(void);
@@ -318,45 +318,45 @@
 struct t_process *process_protinit(struct t_process *p, char *name);
 struct t_process *get_proc_by_pid(int pid);
 /*  object.c */
-int obj_debug			(struct t_process *p, int32_t oid);
-int obj_new				(struct t_process *p);
-int obj_clone			(struct t_process *p, int32_t oid);
-int obj_clone_change	(struct t_process *p, int32_t oid, int32_t toid);
-int obj_link			(struct t_process *p, int32_t oid_from, int32_t oid_to);
-int obj_unlink			(struct t_process *p, int32_t oid);
-int obj_del				(struct t_process *p, int32_t oid);
-int obj_push_vertex		(struct t_process *p, int32_t oid, float *x, int32_t n);
-int obj_push_mat		(struct t_process *p, int32_t oid, float *x, int32_t n);
-int obj_push_poly		(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
-int obj_push_line		(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
-int obj_push_tex		(struct t_process *p, int32_t oid, uint16_t *x, int32_t n);
-int obj_pep_poly_normal	(struct t_process *p, int32_t oid, float *x, int32_t n);
-int obj_pep_line_normal (struct t_process *p, int32_t oid, float *x, int32_t n);
-int obj_pep_poly_texc	(struct t_process *p, int32_t oid, float *x, int32_t  n);
-int obj_pep_mat			(struct t_process *p, int32_t oid, float *x, int32_t n);
-int obj_pep_mat_tex		(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
-int obj_pep_vertex		(struct t_process *p, int32_t oid, float *x, int32_t n);
-int obj_pep_line		(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
+int obj_debug(struct t_process *p, int32_t oid);
+int obj_new(struct t_process *p);
+int obj_clone(struct t_process *p, int32_t oid);
+int obj_clone_change(struct t_process *p, int32_t oid, int32_t toid);
+int obj_link(struct t_process *p, int32_t oid_from, int32_t oid_to);
+int obj_unlink(struct t_process *p, int32_t oid);
+int obj_del(struct t_process *p, int32_t oid);
+int obj_push_vertex(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_push_mat(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_push_poly(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
+int obj_push_line(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
+int obj_push_tex(struct t_process *p, int32_t oid, uint16_t *x, int32_t n);
+int obj_pep_poly_normal(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_pep_line_normal(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_pep_poly_texc(struct t_process *p, int32_t oid, float *x, int32_t  n);
+int obj_pep_mat(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_pep_mat_tex(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
+int obj_pep_vertex(struct t_process *p, int32_t oid, float *x, int32_t n);
+int obj_pep_line(struct t_process *p, int32_t oid, uint32_t *x, int32_t n);
 int obj_load_poly_normal(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
 int obj_load_line_normal(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
-int obj_load_poly_texc	(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
-int obj_load_mat		(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
-int obj_load_tex		(struct t_process *p, int32_t oid, int32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf);
-int obj_del_vertex		(struct t_process *p, int32_t oid, int32_t n);
-int obj_del_mat			(struct t_process *p, int32_t oid, int32_t n);
-int obj_del_poly		(struct t_process *p, int32_t oid, int32_t n);
-int obj_del_line		(struct t_process *p, int32_t oid, int32_t n);
-int obj_del_tex			(struct t_process *p, int32_t oid, int32_t n);
-int obj_toggle_flags	(struct t_process *p, int32_t oid, uint8_t type, uint32_t flags);
-int obj_translate		(struct t_process *p, int32_t oid, float *transv);
-int obj_rotate			(struct t_process *p, int32_t oid, float *rotv);
-int obj_scale			(struct t_process *p, int32_t oid, float scav);
-int obj_render			(struct t_process *p, int32_t oid);
-int obj_free			(struct t_process *p, int32_t oid);
-void obj_get_maximum	(struct t_process *p, struct t_obj *obj);
-void into_position		(struct t_process *p, struct t_obj *obj, int depth);
-void obj_recalc_tmat	(struct t_process *p, int32_t oid);
-void obj_size_update	(struct t_process *p, int32_t oid);
+int obj_load_poly_texc(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
+int obj_load_mat(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n);
+int obj_load_tex(struct t_process *p, int32_t oid, int32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf);
+int obj_del_vertex(struct t_process *p, int32_t oid, int32_t n);
+int obj_del_mat(struct t_process *p, int32_t oid, int32_t n);
+int obj_del_poly(struct t_process *p, int32_t oid, int32_t n);
+int obj_del_line(struct t_process *p, int32_t oid, int32_t n);
+int obj_del_tex(struct t_process *p, int32_t oid, int32_t n);
+int obj_toggle_flags(struct t_process *p, int32_t oid, uint8_t type, uint32_t flags);
+int obj_translate(struct t_process *p, int32_t oid, float *transv);
+int obj_rotate(struct t_process *p, int32_t oid, float *rotv);
+int obj_scale(struct t_process *p, int32_t oid, float scav);
+int obj_render(struct t_process *p, int32_t oid);
+int obj_free(struct t_process *p, int32_t oid);
+void obj_get_maximum(struct t_process *p, struct t_obj *obj);
+void into_position(struct t_process *p, struct t_obj *obj, int depth);
+void obj_recalc_tmat(struct t_process *p, int32_t oid);
+void obj_size_update(struct t_process *p, int32_t oid);
 void obj_pos_update(struct t_process *p, int32_t oid, int32_t first_oid);
 void obj_check_biggest_object(struct t_process *p, int32_t oid);
 int32_t get_pointer(struct t_process *p);
@@ -392,7 +392,7 @@
 void *debugMalloc(unsigned int length, int tag);
 void *debugRealloc(void *memory, unsigned int length, int tag);
 void debugFree(void *memoryParameter);
-#define malloc(x)		debugMalloc(x,42)
-#define free(x)			debugFree(x);
-#define realloc(x,y)	debugRealloc(x,y,42)
+#define malloc(x)  debugMalloc(x,42)
+#define free(x)   debugFree(x);
+#define realloc(x,y) debugRealloc(x,y,42)
 #endif

Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/graphics.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,18 +22,18 @@
  */
 
 #include "global.h"
-#include <stdlib.h>		 /*  malloc() */
-#include <string.h>		 /*  memcpy() */
+#include <stdlib.h>   /*  malloc() */
+#include <string.h>   /*  memcpy() */
 /*
 #ifdef G_GLUT
-#include <GL/glut.h> 	 *  glutWireTorus() -  to be removed later *
+#include <GL/glut.h>   *  glutWireTorus() -  to be removed later *
 #endif
 */
-#include <GL/gl.h>		 /*  GLint */
+#include <GL/gl.h>   /*  GLint */
 #ifdef G_SDL
-#include <SDL.h>	 /*  SDL_GL_SwapBuffers */
+#include <SDL.h>  /*  SDL_GL_SwapBuffers */
 #endif
-#include <math.h>		 /*  sin(),cos() */
+#include <math.h>   /*  sin(),cos() */
 #ifndef INFINITY
 #define INFINITY 1<<30
 #endif
@@ -41,15 +41,15 @@
 /*  local prototypes ... */
 void render_virtual_object(struct t_obj *o);
 /*  ... and types/variables */
-int select_mode=0;
-int winw,winh;
+int select_mode = 0;
+int winw, winh;
 extern struct t_process *procs_p;
 extern int frame_mode;  /*  GLUT, SDL, ... ? */
 /*  this detects and opens the SDL things */
 
-int graphics_init ()
+int graphics_init()
 {
-	GLfloat shin[]={16.0};
+	GLfloat shin[] = {16.0};
 	switch (frame_mode) {
 #ifdef G_SDL
 	case FRAME_SDL:
@@ -74,13 +74,13 @@
 
 	/* textures */
 	glEnable(GL_TEXTURE_2D);
-	glShadeModel (GL_SMOOTH);
+	glShadeModel(GL_SMOOTH);
 	glDisable(GL_DITHER);
 
 	/* lines */
 	glHint(GL_LINE_SMOOTH_HINT, GL_FASTEST);
 	glLineWidth(1.0);
-	glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
+	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
 
 	/* polygon smoothing */
 	glDisable(GL_POLYGON_SMOOTH);
@@ -89,7 +89,7 @@
 
 	/* normalizing */
 	glDisable(GL_AUTO_NORMAL);
-	glDisable(GL_NORMALIZE); 		/* don't use the expensive GL_NORMALIZE, we use uniform scaling so GL_RESCALE_NORMAL is sufficent */
+	glDisable(GL_NORMALIZE);   /* don't use the expensive GL_NORMALIZE, we use uniform scaling so GL_RESCALE_NORMAL is sufficent */
 	glEnable(GL_RESCALE_NORMAL);
 
 	/* blending */
@@ -98,9 +98,9 @@
 	/*    glBlendFunc(GL_SRC_ALPHA_SATURATE, GL_ONE);*/
 
 	/* set shininess */
-	/* 	glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS,shin); */
-	glMaterialfv(GL_FRONT,GL_SHININESS,shin);
-	graphics_reshape(X_RES,Y_RES);
+	/*  glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS,shin); */
+	glMaterialfv(GL_FRONT, GL_SHININESS, shin);
+	graphics_reshape(X_RES, Y_RES);
 
 	/* face culling */
 	glCullFace(GL_FRONT);
@@ -108,56 +108,56 @@
 	return(0);
 }
 /*  this is to be called when the window is resized or created ... */
-void graphics_reshape( int w, int h)
+void graphics_reshape(int w, int h)
 {
-	glViewport (0, 0, (GLsizei) w, (GLsizei) h);
-	winw=w;
-	winh=h;
-	glMatrixMode (GL_PROJECTION);
-	glLoadIdentity ();
-	if (w>h)
-		glFrustum(-((1.0*w)/h),(1.0*w)/h,-1.0,1.0,1.0,5000);
+	glViewport(0, 0, (GLsizei) w, (GLsizei) h);
+	winw = w;
+	winh = h;
+	glMatrixMode(GL_PROJECTION);
+	glLoadIdentity();
+	if (w > h)
+		glFrustum(-((1.0*w) / h), (1.0*w) / h, -1.0, 1.0, 1.0, 5000);
 	else
-		glFrustum(-1.0,1.0,-(1.0*h)/w,(1.0*h)/w,1.0,5000);
+		glFrustum(-1.0, 1.0, -(1.0*h) / w, (1.0*h) / w, 1.0, 5000);
 	glMatrixMode(GL_MODELVIEW);
-	if (procs_p!=NULL)
+	if (procs_p != NULL)
 		event_cam_changed();
 }
 void render_virtual_object(struct t_obj *o)
 {
 	struct t_process *ap;
-	struct t_vertex x,y;
-	int32_t j,k;
+	struct t_vertex x, y;
+	int32_t j, k;
 	t_mtrx m;
 
 	glPushMatrix();
 	glMultMatrixf(o->m);
-	glGetFloatv(GL_MODELVIEW_MATRIX,m);
+	glGetFloatv(GL_MODELVIEW_MATRIX, m);
 	cull_get_planes();
-	if (NULL==(ap=get_proc_by_pid(o->n_mat))) { /*  the clean way */
-		errds(HIGH,"render_by_mcp()","not existing pid (%d) referenced by mcp-object!!", o);
+	if (NULL == (ap = get_proc_by_pid(o->n_mat))) { /*  the clean way */
+		errds(HIGH, "render_by_mcp()", "not existing pid (%d) referenced by mcp-object!!", o);
 	} else {
 		/*  now go throu the objects of our app  */
-		for (j=0;j<ap->n_obj;j++) {
-			if (ap->object[j]!=NULL) {
-				if (((select_mode==0) && ap->object[j]->oflags&OF_VISIBLE) || ((select_mode ==1 ) && (ap->object[j]->oflags&OF_SELECTABLE))) { /* either select mode is off or it's selectable */
-					x.x=x.y=x.z=0.0f;
+		for (j = 0;j < ap->n_obj;j++) {
+			if (ap->object[j] != NULL) {
+				if (((select_mode == 0) && ap->object[j]->oflags&OF_VISIBLE) || ((select_mode == 1) && (ap->object[j]->oflags&OF_SELECTABLE))) { /* either select mode is off or it's selectable */
+					x.x = x.y = x.z = 0.0f;
 					mySetMatrix(ap->object[j]->m); /* get into position ... */
 					myTransformV(&x);
-					y.x=1.0;
-					y.y=y.z=0.0f;
+					y.x = 1.0;
+					y.y = y.z = 0.0f;
 					myTransformV(&y);
-					y.x-=x.x;
-					y.y-=x.y;
-					y.z-=x.z;
+					y.x -= x.x;
+					y.y -= x.y;
+					y.z -= x.z;
 
-					k=cull_sphere_in_frustum(&x,ap->object[j]->r * sqrt(y.x*y.x + y.y*y.y + y.z*y.z));
+					k = cull_sphere_in_frustum(&x, ap->object[j]->r * sqrt(y.x * y.x + y.y * y.y + y.z * y.z));
 					if (k) {
-						/*						s3dprintf(HIGH,"object %d is in %s frustum",j,k?"":"not");*/
-						if (select_mode==1)
+						/*      s3dprintf(HIGH,"object %d is in %s frustum",j,k?"":"not");*/
+						if (select_mode == 1)
 							glPushName(j);
-						obj_render(ap,j);
-						if (select_mode==1)
+						obj_render(ap, j);
+						if (select_mode == 1)
 							glPopName();
 					}
 				}
@@ -170,57 +170,57 @@
 /*  recursively positiniong the objects into the space. */
 int render_by_mcp()
 {
-	struct t_process *p=get_proc_by_pid(MCP);
+	struct t_process *p = get_proc_by_pid(MCP);
 	int32_t i;
 	struct t_obj *o;
-	struct t_vertex x,y;
+	struct t_vertex x, y;
 	int k;
-	for (i=0 ; i < p->n_obj ; i++) {  /* check all mcp objects ... */
-		o=p->object[i];
-		if (o!=NULL) {
-			if ((select_mode==0 && o->oflags&OF_VISIBLE) || (select_mode==1 && o->oflags&OF_SELECTABLE)) { /*  it's even visible ;) */
+	for (i = 0 ; i < p->n_obj ; i++) {  /* check all mcp objects ... */
+		o = p->object[i];
+		if (o != NULL) {
+			if ((select_mode == 0 && o->oflags&OF_VISIBLE) || (select_mode == 1 && o->oflags&OF_SELECTABLE)) { /*  it's even visible ;) */
 				if (o->oflags&OF_VIRTUAL) { /*  we have an app here. */
-					if (o->r!=0.0) {
+					if (o->r != 0.0) {
 						cull_get_planes();
 						mySetMatrix(o->m);
-						x.x=x.y=x.z=0.0f;
+						x.x = x.y = x.z = 0.0f;
 						myTransformV(&x);
-						y.x=1.0;
-						y.y=y.z=0.0f;
+						y.x = 1.0;
+						y.y = y.z = 0.0f;
 						myTransformV(&y);
-						y.x-=x.x;
-						y.y-=x.y;
-						y.z-=x.z;
+						y.x -= x.x;
+						y.y -= x.y;
+						y.z -= x.z;
 
-						k=cull_sphere_in_frustum(&x,o->r * sqrt(y.x*y.x + y.y*y.y + y.z*y.z));
-						s3dprintf(VLOW,"mcp-object %d is in %s frustum",i,k?"":"not");
+						k = cull_sphere_in_frustum(&x, o->r * sqrt(y.x * y.x + y.y * y.y + y.z * y.z));
+						s3dprintf(VLOW, "mcp-object %d is in %s frustum", i, k ? "" : "not");
 						if (k) {
-							if (select_mode==1) {
-								s3dprintf(VLOW,"object %d in culling frustrum!",i);
+							if (select_mode == 1) {
+								s3dprintf(VLOW, "object %d in culling frustrum!", i);
 								glLoadName(i);
 							}
 							render_virtual_object(o);
 						} else {
-							if (select_mode==1) {
-								s3dprintf(VLOW,"object %d not in culling frustrum!",i);
+							if (select_mode == 1) {
+								s3dprintf(VLOW, "object %d not in culling frustrum!", i);
 							}
 						}
 					}
 				} else if ((o->oflags&OF_CLONE) && (p->object[o->n_vertex]->oflags&OF_VIRTUAL)) { /* it's a clone of an app */
-					if (select_mode==1)
+					if (select_mode == 1)
 						glLoadName(o->n_vertex);/*TODO: what to do if a clone is selected?! */
 					glPushMatrix();
 					render_virtual_object(o);
 					render_virtual_object(p->object[o->n_vertex]);
 					glPopMatrix();
 				} else { /* it's a "regular" mcp object */
-					if (select_mode==1) {
-						s3dprintf(VLOW,"mcp object no. %d",i);
+					if (select_mode == 1) {
+						s3dprintf(VLOW, "mcp object no. %d", i);
 						glLoadName(-1);
 						glPushName(i);
 					}
-					obj_render(p,i);
-					if (select_mode==1)
+					obj_render(p, i);
+					if (select_mode == 1)
 						glPopName();
 				}
 			}
@@ -231,36 +231,36 @@
 /* this picks objects from their screen-positions and sends
  * OBK_CLICK-events for the selected object(s).
  * TODO: how big should the select buffer be? */
-#define SBSIZE	65536
+#define SBSIZE 65536
 int graphics_pick_obj(int x, int y)
 {
-	int i,j;
+	int i, j;
 	GLint viewport[4];
-	GLfloat xpos,ypos;
-	float big,z1,z2;
-	int32_t mcp_o,o;
-	struct t_process *p=get_proc_by_pid(MCP);
-	GLuint select_buf[SBSIZE],*ptr;
+	GLfloat xpos, ypos;
+	float big, z1, z2;
+	int32_t mcp_o, o;
+	struct t_process *p = get_proc_by_pid(MCP);
+	GLuint select_buf[SBSIZE], *ptr;
 	int hits, names;
 	t_mtrx m;
 
-	select_mode=1;
-	glSelectBuffer(SBSIZE,select_buf);
+	select_mode = 1;
+	glSelectBuffer(SBSIZE, select_buf);
 	glRenderMode(GL_SELECT);
 	glMatrixMode(GL_PROJECTION);
 	/*  count the objects .... */
 	glPushMatrix();
 	glLoadIdentity();
 	glGetIntegerv(GL_VIEWPORT, viewport);
-	if (winw>winh) {
-		xpos=((x-winw/2.0)/(winw/2.0))*(((double)winw/winh));
-		ypos=(((winh-y)-winh/2.0)/(winh/2.0));
+	if (winw > winh) {
+		xpos = ((x - winw / 2.0) / (winw / 2.0)) * (((double)winw / winh));
+		ypos = (((winh - y) - winh / 2.0) / (winh / 2.0));
 	} else {
-		xpos=((x-winw/2.0)/(winw/2.0));
-		ypos=(((winh-y)-winh/2.0)/(winh/2.0))*(((double)winh/winw));
+		xpos = ((x - winw / 2.0) / (winw / 2.0));
+		ypos = (((winh - y) - winh / 2.0) / (winh / 2.0)) * (((double)winh / winw));
 	}
 #define mnear 0.001  /*  omg this is so dirty ... but works after all */
-	glFrustum(xpos-mnear,xpos+mnear,ypos-mnear,ypos+mnear,1,5000);
+	glFrustum(xpos - mnear, xpos + mnear, ypos - mnear, ypos + mnear, 1, 5000);
 	glMatrixMode(GL_MODELVIEW);
 	glLoadIdentity();  /*  get into position ... */
 	mySetMatrix(p->object[0]->m);
@@ -268,88 +268,88 @@
 	myGetMatrix(m);
 	glMultMatrixf(m);
 	/*
-		glRotatef(-cam.rotate.x, 1.0,0.0,0.0);
-		glRotatef(-cam.rotate.y, 0.0,1.0,0.0);
-		glTranslatef(-cam.translate.x,-cam.translate.y,-cam.translate.z);*/
+	 glRotatef(-cam.rotate.x, 1.0,0.0,0.0);
+	 glRotatef(-cam.rotate.y, 0.0,1.0,0.0);
+	 glTranslatef(-cam.translate.x,-cam.translate.y,-cam.translate.z);*/
 
 	glInitNames();
 	glPushName(0);
 	render_by_mcp();
 	glFlush();
-	hits=glRenderMode(GL_RENDER);
-	if ( hits > 0 ) {
-		big=INFINITY;
-		s3dprintf(LOW,"had %d hits",hits);
-		ptr=select_buf;
-		mcp_o= o= names= -1;
+	hits = glRenderMode(GL_RENDER);
+	if (hits > 0) {
+		big = INFINITY;
+		s3dprintf(LOW, "had %d hits", hits);
+		ptr = select_buf;
+		mcp_o = o = names = -1;
 		/* check all the hits, only select the nearest ... */
-		for (i=0 ; i < hits ; i++) {
-			names=*ptr;
+		for (i = 0 ; i < hits ; i++) {
+			names = *ptr;
 			ptr++;
-			z1=(float)*ptr/0x7fffffff;
+			z1 = (float) * ptr / 0x7fffffff;
 			ptr++;
-			z2=(float)*ptr/0x7fffffff;
+			z2 = (float) * ptr / 0x7fffffff;
 			ptr++;
-			if (z1<big) {
-				mcp_o=o=-1;
-				for (j=0;j<names;j++) {
+			if (z1 < big) {
+				mcp_o = o = -1;
+				for (j = 0;j < names;j++) {
 					switch (j) {
 					case 0:
-						mcp_o=	*ptr;
+						mcp_o = *ptr;
 						break;
 					case 1:
-						o=		*ptr;
+						o =  *ptr;
 						break;
 					}
 					ptr++;
 				}
-				big=z1;
+				big = z1;
 			} else
-				for (j=0;j<names;j++)
+				for (j = 0;j < names;j++)
 					ptr++;
-			s3dprintf(VLOW,"[HIT %d] names %d [z1:%f|z2:%f] mcp_o=%d, o=%d ",i,names, z1, z2, mcp_o, o);
+			s3dprintf(VLOW, "[HIT %d] names %d [z1:%f|z2:%f] mcp_o=%d, o=%d ", i, names, z1, z2, mcp_o, o);
 		}
-		s3dprintf(VLOW,"mcp_o= %d, o= %d",mcp_o,o);
-		ptr=select_buf;
-		if (mcp_o==-1) { /* it's an mcp object */
-			s3dprintf(LOW,"clicked on mcp-object no. %d",o);
-			event_obj_click(p,o);
+		s3dprintf(VLOW, "mcp_o= %d, o= %d", mcp_o, o);
+		ptr = select_buf;
+		if (mcp_o == -1) { /* it's an mcp object */
+			s3dprintf(LOW, "clicked on mcp-object no. %d", o);
+			event_obj_click(p, o);
 		} else
-			if ((names>1) && ((mcp_o>=0)&&(mcp_o<p->n_obj))) { /* it's an usual object */
-				s3dprintf(LOW,"clicked on mcp-object %d, object %d",mcp_o,o);
-				if (p->object[mcp_o]!=NULL) { /*  that shouldn't happen anyways ... */
-					obj_debug(get_proc_by_pid(p->object[mcp_o]->n_mat),o);
-					event_obj_click(get_proc_by_pid(p->object[mcp_o]->n_mat),o);
+			if ((names > 1) && ((mcp_o >= 0) && (mcp_o < p->n_obj))) { /* it's an usual object */
+				s3dprintf(LOW, "clicked on mcp-object %d, object %d", mcp_o, o);
+				if (p->object[mcp_o] != NULL) { /*  that shouldn't happen anyways ... */
+					obj_debug(get_proc_by_pid(p->object[mcp_o]->n_mat), o);
+					event_obj_click(get_proc_by_pid(p->object[mcp_o]->n_mat), o);
 				}
 			}
 	}
 	glMatrixMode(GL_PROJECTION);
 	glPopMatrix();
 	glMatrixMode(GL_MODELVIEW);
-	select_mode=0;
+	select_mode = 0;
 	return(0);
 }
 
 
 void graphics_main()
 {
-	struct t_process *p=get_proc_by_pid(MCP);
+	struct t_process *p = get_proc_by_pid(MCP);
 	t_mtrx m;
-	GLfloat pos[]={0,50,50,1.0};
-	GLfloat light0_spec[]={0.7,0.7,0.7,0.0};
-	GLfloat light0_shininess[] ={1.0};
-	GLfloat light0_diff[]={0.5,0.5,0.5,1.0};
-	GLfloat light0_amb[]={1.0,1.0,1.0,1.0};
+	GLfloat pos[] = {0, 50, 50, 1.0};
+	GLfloat light0_spec[] = {0.7, 0.7, 0.7, 0.0};
+	GLfloat light0_shininess[] = {1.0};
+	GLfloat light0_diff[] = {0.5, 0.5, 0.5, 1.0};
+	GLfloat light0_amb[] = {1.0, 1.0, 1.0, 1.0};
 
-	select_mode=0;
+	select_mode = 0;
 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  /*  clear screen */
 	/*  set up the cam ... */
 	glMatrixMode(GL_MODELVIEW);
 
-	glLightfv(GL_LIGHT0,GL_AMBIENT,light0_amb);
-	glLightfv(GL_LIGHT0,GL_DIFFUSE,light0_diff);
-	glLightfv(GL_LIGHT0,GL_SPECULAR,light0_spec);
-	glLightfv(GL_LIGHT0,GL_SHININESS,light0_shininess);
+	glLightfv(GL_LIGHT0, GL_AMBIENT, light0_amb);
+	glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diff);
+	glLightfv(GL_LIGHT0, GL_SPECULAR, light0_spec);
+	glLightfv(GL_LIGHT0, GL_SHININESS, light0_shininess);
 
 	glLoadIdentity();
 
@@ -357,7 +357,7 @@
 	myInvert();
 	myGetMatrix(m);
 	glMultMatrixf(m);
-	glLightfv(GL_LIGHT0,GL_POSITION,pos);
+	glLightfv(GL_LIGHT0, GL_POSITION, pos);
 
 	/*glRotatef(-cam.rotate.z, 0.0,0.0,1.0);
 	glRotatef(-cam.rotate.x, 1.0,0.0,0.0);

Modified: trunk/server/graphics_glut.c
===================================================================
--- trunk/server/graphics_glut.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/graphics_glut.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -26,24 +26,24 @@
 /*  maybe we are able to choose if we want to use glut or sdl or any other lib later ... */
 
 #include "global.h"
-#include <stdio.h>		/* NULL */
-#include <GL/glut.h> 	 /*  all the glut functions */
-#include <GL/gl.h>		 /*  of course, the gl header */
-#include <stdlib.h>		/* atexit() */
+#include <stdio.h>  /* NULL */
+#include <GL/glut.h>   /*  all the glut functions */
+#include <GL/gl.h>   /*  of course, the gl header */
+#include <stdlib.h>  /* atexit() */
 /*  glut version of graphics init ... */
 int graphics_init_glut()
 {
 	/* XXX: Faking argc and argv is probably not a good idea. */
-	int argc=1;
-	char *argv[]={"s3d", NULL};
-	s3dprintf(MED,"Using GLUT for GL/windowing ...");
+	int argc = 1;
+	char *argv[] = {"s3d", NULL};
+	s3dprintf(MED, "Using GLUT for GL/windowing ...");
 	glutInit(&argc, argv);
 	glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH | GLUT_RGBA);
-	glutInitWindowSize (X_RES, Y_RES);
+	glutInitWindowSize(X_RES, Y_RES);
 	glutCreateWindow("grmbl");
 	glutIdleFunc(one_time);
-	if (0!=(atexit(quit)))
-		s3dprintf(MED,"Error in setting Exit function ...");
+	if (0 != (atexit(quit)))
+		s3dprintf(MED, "Error in setting Exit function ...");
 	glutDisplayFunc(graphics_main);
 	glutReshapeFunc(graphics_reshape);
 	return(0);

Modified: trunk/server/graphics_sdl.c
===================================================================
--- trunk/server/graphics_sdl.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/graphics_sdl.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,63 +22,63 @@
  */
 
 #include "global.h"
-int aa_level=4;
+int aa_level = 4;
 
 #include <SDL_opengl.h>
 #include <SDL.h>
 
-int SDLFlags = 0;					 /*  some flags for SDL */
+int SDLFlags = 0;      /*  some flags for SDL */
 int graphics_init_sdl()
 {
 	SDL_Surface *GLwin = NULL;
 	SDL_VideoInfo *VideoInfo;
-	int rgb_size[3]; 				 /*  for SDL_GL attributes */
+	int rgb_size[3];      /*  for SDL_GL attributes */
 	int buffers, samples;
-	s3dprintf(MED,"Using SDL driver ...");
+	s3dprintf(MED, "Using SDL driver ...");
 
 	SDLFlags = SDL_OPENGL | SDL_GL_DOUBLEBUFFER | SDL_HWPALETTE | SDL_RESIZABLE;
-	if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) < 0)
-		errsf("SDL_Init()",SDL_GetError());
-	if ((VideoInfo = (SDL_VideoInfo *)SDL_GetVideoInfo())==NULL)
-		errs("SDL_GetVIdeoInfo()",SDL_GetError());
+	if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) < 0)
+		errsf("SDL_Init()", SDL_GetError());
+	if ((VideoInfo = (SDL_VideoInfo *)SDL_GetVideoInfo()) == NULL)
+		errs("SDL_GetVIdeoInfo()", SDL_GetError());
 	if (VideoInfo -> hw_available) {
-		s3dprintf(LOW,"detected HW_SURFACE");
+		s3dprintf(LOW, "detected HW_SURFACE");
 		SDLFlags |= SDL_HWSURFACE;
 	} else {
-		s3dprintf(LOW,"detected SW_SURFACE");
+		s3dprintf(LOW, "detected SW_SURFACE");
 		SDLFlags |= SDL_SWSURFACE;
 	}
 	if (VideoInfo -> blit_hw)
 		SDLFlags |= SDL_HWACCEL;
-	/*     if(SDL_WM_ToggleFullScreen(GLwin) == 0)        	SDLerror("SDL_WM_ToggleFullScreen"); */
+	/*     if(SDL_WM_ToggleFullScreen(GLwin) == 0)         SDLerror("SDL_WM_ToggleFullScreen"); */
 
 
 	/*  set some opengl-attributes */
-	/*	SDL_GL_SetAttribute( SDL_GL_RED_SIZE, rgb_size[0] );
-		SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, rgb_size[1] );
-		SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, rgb_size[2] );*/
-	/* 	SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5); */
-	/* 	SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 5); */
-	/* 	SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5); */
-	/* 	SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 ); */
-	SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
+	/* SDL_GL_SetAttribute( SDL_GL_RED_SIZE, rgb_size[0] );
+	 SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, rgb_size[1] );
+	 SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, rgb_size[2] );*/
+	/*  SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5); */
+	/*  SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 5); */
+	/*  SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5); */
+	/*  SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 ); */
+	SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
 	do {
-		if (aa_level>0) {
-			if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1 ))			s3dprintf(VHIGH,"error initializing multisampling");
-			if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, aa_level ))	s3dprintf(VHIGH,"no multisampling available");
+		if (aa_level > 0) {
+			if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1))   s3dprintf(VHIGH, "error initializing multisampling");
+			if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, aa_level)) s3dprintf(VHIGH, "no multisampling available");
 		}
 
 		/*  more opengl-init-stuff */
-		if ((GLwin = SDL_SetVideoMode(X_RES,Y_RES,16,SDLFlags))==NULL) {
-			if (aa_level>0) {
-				s3dprintf(MED,"retry without multisampling");
-				aa_level=0;
-				SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 0 );
-				SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 0 );
+		if ((GLwin = SDL_SetVideoMode(X_RES, Y_RES, 16, SDLFlags)) == NULL) {
+			if (aa_level > 0) {
+				s3dprintf(MED, "retry without multisampling");
+				aa_level = 0;
+				SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 0);
+				SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 0);
 			} else
-				errsf("SDL_SetVideoMode()",SDL_GetError());
+				errsf("SDL_SetVideoMode()", SDL_GetError());
 		}
-	} while (GLwin==0);
+	} while (GLwin == 0);
 	switch (SDL_GetVideoInfo()->vfmt->BitsPerPixel) {
 	case 8:
 		rgb_size[0] = 3;
@@ -97,20 +97,20 @@
 		rgb_size[2] = 8;
 		break;
 	}
-	if (aa_level >0) {
-		SDL_GL_GetAttribute( SDL_GL_MULTISAMPLEBUFFERS, &buffers );
-		SDL_GL_GetAttribute( SDL_GL_MULTISAMPLESAMPLES, &samples );
-		s3dprintf(LOW,"Buffers: %d Samples: %d", buffers, samples);
+	if (aa_level > 0) {
+		SDL_GL_GetAttribute(SDL_GL_MULTISAMPLEBUFFERS, &buffers);
+		SDL_GL_GetAttribute(SDL_GL_MULTISAMPLESAMPLES, &samples);
+		s3dprintf(LOW, "Buffers: %d Samples: %d", buffers, samples);
 	}
 
 	/*  print some information */
-	s3dprintf(VLOW,"Screen BPP: %d", SDL_GetVideoSurface()->format->BitsPerPixel);
-	s3dprintf(VLOW,"Vendor     : %s", glGetString( GL_VENDOR ) );
-	s3dprintf(VLOW,"Renderer   : %s", glGetString( GL_RENDERER ) );
-	s3dprintf(VLOW,"Version    : %s", glGetString( GL_VERSION ) );
-	s3dprintf(VLOW,"Extensions : %s", glGetString( GL_EXTENSIONS ) );
+	s3dprintf(VLOW, "Screen BPP: %d", SDL_GetVideoSurface()->format->BitsPerPixel);
+	s3dprintf(VLOW, "Vendor     : %s", glGetString(GL_VENDOR));
+	s3dprintf(VLOW, "Renderer   : %s", glGetString(GL_RENDERER));
+	s3dprintf(VLOW, "Version    : %s", glGetString(GL_VERSION));
+	s3dprintf(VLOW, "Extensions : %s", glGetString(GL_EXTENSIONS));
 
-	graphics_reshape(X_RES,Y_RES);
+	graphics_reshape(X_RES, Y_RES);
 	return(0);
 }
 int graphics_quit_sdl()

Modified: trunk/server/main.c
===================================================================
--- trunk/server/main.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/main.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -22,94 +22,94 @@
  */
 
 
-#include "global.h" 		 /*  contains the prototypes of all modules */
-#include <time.h>		 /* nanosleep() */
-#include <stdlib.h>		 /* exit() */
-#include <unistd.h>		 /* sleep(), fork() */
+#include "global.h"    /*  contains the prototypes of all modules */
+#include <time.h>   /* nanosleep() */
+#include <stdlib.h>   /* exit() */
+#include <unistd.h>   /* sleep(), fork() */
 #ifdef G_GLUT
-#include <GL/glut.h> 	 /*  glutMainLoop() */
+#include <GL/glut.h>   /*  glutMainLoop() */
 #endif
-#define		X_RES	800
-#define		Y_RES	600
-#include <getopt.h>		 /*  getopt() */
-#include <string.h>		 /*  strcmp() */
+#define  X_RES 800
+#define  Y_RES 600
+#include <getopt.h>   /*  getopt() */
+#include <string.h>   /*  strcmp() */
 #ifdef SIGS
-#include <signal.h>		 /*  signal() */
+#include <signal.h>   /*  signal() */
 #endif
-#include <errno.h>		 /*  errno() */
-int frame_mode=0;
-int kidpid=0;
-int norc=0;
+#include <errno.h>   /*  errno() */
+int frame_mode = 0;
+int kidpid = 0;
+int norc = 0;
 int running;
-static char *rc=NULL;
-static char *homerc="~/.s3drc";
-static char *etcrc ="/etc/s3drc";
+static char *rc = NULL;
+static char *homerc = "~/.s3drc";
+static char *etcrc = "/etc/s3drc";
 /*static int father_done=0;*/
 extern int aa_level;
-char **s3drc[]={&rc,&homerc,&etcrc};
+char **s3drc[] = {&rc, &homerc, &etcrc};
 
 static void mainloop(void);
 #ifdef SIGS
 /*  handles the SIGINT command. maybe put signals in a special file? */
 void sigint_handler(int S3DUNUSED(sig))
 {
-	s3dprintf(HIGH,"oh my gosh there is a sigint/term signal! running away ...");
+	s3dprintf(HIGH, "oh my gosh there is a sigint/term signal! running away ...");
 	quit();
 }
 void sigchld_handler(int S3DUNUSED(sig))
 {
-	if (kidpid!=0) {
-		kidpid=0;
-		s3dprintf(HIGH,"how cruel, my kid died!!");
+	if (kidpid != 0) {
+		kidpid = 0;
+		s3dprintf(HIGH, "how cruel, my kid died!!");
 		quit();
 	}
 }
 #endif
 void sigusr_handler(int S3DUNUSED(sig))
 {
-	s3dprintf(HIGH,"father told use he's done, so lets start to think about the rc file ...");
-	running=1;
+	s3dprintf(HIGH, "father told use he's done, so lets start to think about the rc file ...");
+	running = 1;
 }
 
 int rc_init(void)
 {
 #ifdef SIGS
-	int ret,i;
-	struct timespec t= {
-		0,10*1000*1000
+	int ret, i;
+	struct timespec t = {
+		0, 10*1000*1000
 	}; /* 10 mili seconds */
-	kidpid=fork();
-	if (kidpid==-1) {
-		errsf("rc_init()","*sobsob*, can't fork");
+	kidpid = fork();
+	if (kidpid == -1) {
+		errsf("rc_init()", "*sobsob*, can't fork");
 		exit(1);
 	}
-	if (kidpid==0) {
+	if (kidpid == 0) {
 		if (signal(SIGUSR1, sigusr_handler) == SIG_ERR)
-			errn("init():signal()",errno);
+			errn("init():signal()", errno);
 
 		/* giving the father lots of time to set his signal handler
 		 * and all his sockets up */
 		while (!running)
-			nanosleep(&t,NULL);
-		for (i=0 ; i < ((int)(sizeof(s3drc)/sizeof(char **))) ; i++) {
-			if ((*s3drc[i])!=NULL) {
-				s3dprintf(LOW,"[RC] launching %s",*s3drc[i]);
-				ret=system(*s3drc[i]);
-				s3dprintf(VLOW,"[RC] system() said %d",ret);
-				if (ret<128) {
-					s3dprintf(LOW,"V[RC] system() did well, I guess. let's die clean now.");
+			nanosleep(&t, NULL);
+		for (i = 0 ; i < ((int)(sizeof(s3drc) / sizeof(char **))) ; i++) {
+			if ((*s3drc[i]) != NULL) {
+				s3dprintf(LOW, "[RC] launching %s", *s3drc[i]);
+				ret = system(*s3drc[i]);
+				s3dprintf(VLOW, "[RC] system() said %d", ret);
+				if (ret < 128) {
+					s3dprintf(LOW, "V[RC] system() did well, I guess. let's die clean now.");
 					exit(0);
 				}
 			}
 		}
 		errs("rc_init()", "no usuable rc script found.");
-		if (rc==NULL) {
-			errs("rc_init()","You don't have an rc-script? Think about creating one (~/.s3drc), its handy :)");
-			errs("rc_init()","Starting anyway ...");
+		if (rc == NULL) {
+			errs("rc_init()", "You don't have an rc-script? Think about creating one (~/.s3drc), its handy :)");
+			errs("rc_init()", "Starting anyway ...");
 			while (1) sleep(1);
 		} else {
-			errs("rc_init()","no usuable rc script found.");
-			errs("rc_init()","Check your rc-script!");
+			errs("rc_init()", "no usuable rc script found.");
+			errs("rc_init()", "Check your rc-script!");
 		}
 		exit(1);
 	} else {
@@ -131,12 +131,12 @@
 /*  things which should be done each time in main loop go here! this is */
 /*  just for the case we use a function for the mainloop like we do for glut... */
 
-struct timespec t= {
-	0,10*1000*1000
+struct timespec t = {
+	0, 10*1000*1000
 }; /* 10 mili seconds */
 void one_time()
 {
-	nanosleep(&t,NULL);
+	nanosleep(&t, NULL);
 	user_main();
 	network_main();
 	graphics_main();
@@ -144,39 +144,39 @@
 /*  this initalizes all components.  */
 int init()
 {
-#ifdef	__APPLE__
+#ifdef __APPLE__
 	NSApplicationLoad();
 #endif
 #ifdef SIGS
 	if (!norc)
 		rc_init();
 #else
-	s3dprintf(VHIGH,"rc-files won't work without signals :(");
+	s3dprintf(VHIGH, "rc-files won't work without signals :(");
 #endif
 	if (!frame_mode) { /*  turn default frame_mode on */
 #ifdef G_SDL
-		frame_mode=FRAME_SDL;
+		frame_mode = FRAME_SDL;
 #else
 #ifdef G_GLUT
-		frame_mode=FRAME_GLUT;
+		frame_mode = FRAME_GLUT;
 #endif
 #endif
 	}
 	if (!frame_mode) {
-		errsf("init()","no framework mode available");
+		errsf("init()", "no framework mode available");
 		return(-1);
 	}
 	graphics_init();
 	network_init();
 	user_init();
 	process_init();
-	running=1;
+	running = 1;
 #ifdef SIGS
 	if (signal(SIGINT, sigint_handler) == SIG_ERR)
-		errn("init():signal()",errno);
+		errn("init():signal()", errno);
 	if (signal(SIGTERM, sigint_handler) == SIG_ERR)
-		errn("init():signal()",errno);
-	if (kidpid!=0)
+		errn("init():signal()", errno);
+	if (kidpid != 0)
 		kill(kidpid, SIGUSR1);
 #endif
 	return(0);
@@ -185,79 +185,79 @@
 /*  things to be cleaned up  */
 void quit()
 {
-	if (running!=0) {
+	if (running != 0) {
 		user_quit();
 		network_quit();
 		graphics_quit();
 		process_quit();
-		if (kidpid!=0) { /* our kid is most probably still alive. kill it!! */
-			s3dprintf(HIGH,"kill all the kids!!");
-			kill(kidpid,SIGTERM);
-			kidpid=0;
+		if (kidpid != 0) { /* our kid is most probably still alive. kill it!! */
+			s3dprintf(HIGH, "kill all the kids!!");
+			kill(kidpid, SIGTERM);
+			kidpid = 0;
 		}
 	}
-	running=0;
-	s3dprintf(VHIGH,"byebye, s3d quitting ...");
+	running = 0;
+	s3dprintf(VHIGH, "byebye, s3d quitting ...");
 	exit(0);
 }
 /*  processing arguments from the commandline */
 int process_args(int argc, char **argv)
 {
-	int					 lopt_idx;
-	char				 c;
+	int      lopt_idx;
+	char     c;
 	struct option long_options[] = {
-		{"multisample",		1,0,'m'
-		}, {"rc",				1,0,'r'}, {"help",			0,0,'h'}, {"use-glut",		0,0,'g'}, {"use-sdl",			0,0,'s'}, {"no-rc",			0,0,'n'}, {0,0,0,0}
+		{"multisample",  1, 0, 'm'
+		}, {"rc",    1, 0, 'r'}, {"help",   0, 0, 'h'}, {"use-glut",  0, 0, 'g'}, {"use-sdl",   0, 0, 's'}, {"no-rc",   0, 0, 'n'}, {0, 0, 0, 0}
 	};
-	while (-1!=(c=getopt_long(argc,argv,"?hgsnr:m:",long_options,&lopt_idx))) {
+	while (-1 != (c = getopt_long(argc, argv, "?hgsnr:m:", long_options, &lopt_idx))) {
 		switch (c) {
 		case 0:
 			break;
 		case 'g':
 #ifdef G_GLUT
-			frame_mode=FRAME_GLUT;
+			frame_mode = FRAME_GLUT;
 #else
-			errsf("process_args()","sorry, GLUT is not available");
+			errsf("process_args()", "sorry, GLUT is not available");
 #endif
 			break;
 		case 's':
 #ifdef G_SDL
-			frame_mode=FRAME_SDL;
+			frame_mode = FRAME_SDL;
 #else
-			errsf("process_args()","sorry, SDL is not available");
+			errsf("process_args()", "sorry, SDL is not available");
 #endif
 			break;
 		case 'r':
-			s3dprintf(VHIGH,"using rc file: %s",optarg);
-			rc=optarg;
+			s3dprintf(VHIGH, "using rc file: %s", optarg);
+			rc = optarg;
 			break;
 		case 'm':
-			aa_level=atoi(optarg);
-			if (aa_level>=0 || aa_level<=16)
-				s3dprintf(VHIGH,"aa_level: %d",aa_level);
+			aa_level = atoi(optarg);
+			if (aa_level >= 0 || aa_level <= 16)
+				s3dprintf(VHIGH, "aa_level: %d", aa_level);
 			else
-				errsf("process_args()","bad multisampling level");
+				errsf("process_args()", "bad multisampling level");
 			break;
 		case 'n':
-			s3dprintf(VHIGH,"Using no rc file!");
-			norc=1;
+			s3dprintf(VHIGH, "Using no rc file!");
+			norc = 1;
 			break;
 
 		case '?':
 		case 'h':
-			s3dprintf(VHIGH,"usage: %s [options]",argv[0]);
-			s3dprintf(VHIGH,"s3d, the 3d server:");
-			s3dprintf(VHIGH," --multisample, -m:\tSpecify Multisampling level (antialiasing) if available.\n\t\t(value 1-16, default 4, 0 = off),");
-			s3dprintf(VHIGH," --rc, -r:\tspecify a rc (startup script)");
-			s3dprintf(VHIGH," --no-rc, -n:\tdon't use a rc file (useful for debugging mcp's)");
+			s3dprintf(VHIGH, "usage: %s [options]", argv[0]);
+			s3dprintf(VHIGH, "s3d, the 3d server:");
+			s3dprintf(VHIGH, " --multisample, -m:\tSpecify Multisampling level (antialiasing) if available.\n\t\t(value 1-16, default 4, 0 = off),");
+			s3dprintf(VHIGH, " --rc, -r:\tspecify a rc (startup script)");
+			s3dprintf(VHIGH, " --no-rc, -n:\tdon't use a rc file (useful for debugging mcp's)");
 #ifdef G_GLUT
-			s3dprintf(VHIGH," --use-glut, -g:\tuse GLUT as framework-system");
+			s3dprintf(VHIGH, " --use-glut, -g:\tuse GLUT as framework-system");
 #endif
 #ifdef G_SDL
-			s3dprintf(VHIGH," --use-sdl, -s:\tuse SDL as framework-system");
+			s3dprintf(VHIGH, " --use-sdl, -s:\tuse SDL as framework-system");
 #endif
-			s3dprintf(VHIGH," --help, -?, -h: this helpful text");
-			errsf("process_args()","exiting for users sake");
+			s3dprintf(VHIGH, " --help, -?, -h: this helpful text");
+			errsf("process_args()", "exiting for users sake");
 			return(-1);
 		}
 	}
@@ -266,7 +266,7 @@
 /*  things to be done when program is started */
 int main(int argc, char **argv)
 {
-	process_args(argc,argv);
+	process_args(argc, argv);
 	init();
 	switch (frame_mode) {
 #ifdef G_GLUT

Modified: trunk/server/matrix.c
===================================================================
--- trunk/server/matrix.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/matrix.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,7 +24,7 @@
 /*  this file gives some simple matrix functionality for things I was unable */
 /*  to do with OpenGL */
 #include "global.h"
-#include <string.h>	 /*  memcpy() */
+#include <string.h>  /*  memcpy() */
 
 #define DEG2RAD (M_PI/180.0)
 static t_mtrx MAT;
@@ -36,127 +36,127 @@
 };
 void myLoadIdentity()
 {
-	memcpy(MAT,Identity,sizeof(t_mtrx));
+	memcpy(MAT, Identity, sizeof(t_mtrx));
 }
-#define I(x, y)		x*4+y
-#define M(x, y)		MAT[I(x, y)]
+#define I(x, y)  x*4+y
+#define M(x, y)  MAT[I(x, y)]
 void mat_debug(t_mtrx S)
 {
-	s3dprintf(MED,"MAT_0: %.2f %.2f %.2f %.2f",S[I(0,0)],S[I(1,0)],S[I(2,0)],S[I(3,0)]);
-	s3dprintf(MED,"MAT_1: %.2f %.2f %.2f %.2f",S[I(0,1)],S[I(1,1)],S[I(2,1)],S[I(3,1)]);
-	s3dprintf(MED,"MAT_2: %.2f %.2f %.2f %.2f",S[I(0,2)],S[I(1,2)],S[I(2,2)],S[I(3,2)]);
-	s3dprintf(MED,"MAT_3: %.2f %.2f %.2f %.2f",S[I(0,3)],S[I(1,3)],S[I(2,3)],S[I(3,3)]);
+	s3dprintf(MED, "MAT_0: %.2f %.2f %.2f %.2f", S[I(0,0)], S[I(1,0)], S[I(2,0)], S[I(3,0)]);
+	s3dprintf(MED, "MAT_1: %.2f %.2f %.2f %.2f", S[I(0,1)], S[I(1,1)], S[I(2,1)], S[I(3,1)]);
+	s3dprintf(MED, "MAT_2: %.2f %.2f %.2f %.2f", S[I(0,2)], S[I(1,2)], S[I(2,2)], S[I(3,2)]);
+	s3dprintf(MED, "MAT_3: %.2f %.2f %.2f %.2f", S[I(0,3)], S[I(1,3)], S[I(2,3)], S[I(3,3)]);
 }
 void myMultMatrix(t_mtrx mat2)
 {
-	int i,j,k;
+	int i, j, k;
 	t_mtrx mat_d;  /*  destination matrix */
-	for (i=0;i<4;i++)
-		for (j=0;j<4;j++) {
-			mat_d[I(i,j)]=0.0F;
-			for (k=0;k<4;k++)
-				mat_d[I(i,j)]+=M(k,j)*mat2[I(i,k)];
+	for (i = 0;i < 4;i++)
+		for (j = 0;j < 4;j++) {
+			mat_d[I(i,j)] = 0.0F;
+			for (k = 0;k < 4;k++)
+				mat_d[I(i,j)] += M(k, j) * mat2[I(i,k)];
 		}
-	memcpy(MAT,mat_d,sizeof(t_mtrx));
+	memcpy(MAT, mat_d, sizeof(t_mtrx));
 }
 void myGetMatrix(t_mtrx mat)
 {
-	memcpy(mat,MAT,sizeof(t_mtrx));
+	memcpy(mat, MAT, sizeof(t_mtrx));
 }
 void mySetMatrix(t_mtrx mat)
 {
-	memcpy(MAT,mat,sizeof(t_mtrx));
+	memcpy(MAT, mat, sizeof(t_mtrx));
 }
 void myTransform4f(float *v)
 {
 	float w[4];
-	w[0]= v[0]*M(0,0) + v[1]*M(1,0) + v[2]*M(2,0) + v[3]*M(3,0);
-	w[1]= v[0]*M(0,1) + v[1]*M(1,1) + v[2]*M(2,1) + v[3]*M(3,1);
-	w[2]= v[0]*M(0,2) + v[1]*M(1,2) + v[2]*M(2,2) + v[3]*M(3,2);
-	w[3]= v[0]*M(0,3) + v[1]*M(1,3) + v[2]*M(2,3) + v[3]*M(3,3);
-	memcpy(v,w,sizeof(w));
+	w[0] = v[0] * M(0, 0) + v[1] * M(1, 0) + v[2] * M(2, 0) + v[3] * M(3, 0);
+	w[1] = v[0] * M(0, 1) + v[1] * M(1, 1) + v[2] * M(2, 1) + v[3] * M(3, 1);
+	w[2] = v[0] * M(0, 2) + v[1] * M(1, 2) + v[2] * M(2, 2) + v[3] * M(3, 2);
+	w[3] = v[0] * M(0, 3) + v[1] * M(1, 3) + v[2] * M(2, 3) + v[3] * M(3, 3);
+	memcpy(v, w, sizeof(w));
 }
 void myTransform3f(float *v)
 {
 	float w[3];
-	w[0]= v[0]*M(0,0) + v[1]*M(1,0) + v[2]*M(2,0) + 1.0F*M(3,0);
-	w[1]= v[0]*M(0,1) + v[1]*M(1,1) + v[2]*M(2,1) + 1.0F*M(3,1);
-	w[2]= v[0]*M(0,2) + v[1]*M(1,2) + v[2]*M(2,2) + 1.0F*M(3,2);
-	memcpy(v,w,sizeof(w));
+	w[0] = v[0] * M(0, 0) + v[1] * M(1, 0) + v[2] * M(2, 0) + 1.0F * M(3, 0);
+	w[1] = v[0] * M(0, 1) + v[1] * M(1, 1) + v[2] * M(2, 1) + 1.0F * M(3, 1);
+	w[2] = v[0] * M(0, 2) + v[1] * M(1, 2) + v[2] * M(2, 2) + 1.0F * M(3, 2);
+	memcpy(v, w, sizeof(w));
 }
 void myTransformV(struct t_vertex *v)
 {
 	struct t_vertex w;
-	w.x= v->x*M(0,0) + v->y*M(1,0) + v->z*M(2,0) + 1.0F*M(3,0);
-	w.y= v->x*M(0,1) + v->y*M(1,1) + v->z*M(2,1) + 1.0F*M(3,1);
-	w.z= v->x*M(0,2) + v->y*M(1,2) + v->z*M(2,2) + 1.0F*M(3,2);
-	memcpy(v,&w,sizeof(struct t_vertex));
+	w.x = v->x * M(0, 0) + v->y * M(1, 0) + v->z * M(2, 0) + 1.0F * M(3, 0);
+	w.y = v->x * M(0, 1) + v->y * M(1, 1) + v->z * M(2, 1) + 1.0F * M(3, 1);
+	w.z = v->x * M(0, 2) + v->y * M(1, 2) + v->z * M(2, 2) + 1.0F * M(3, 2);
+	memcpy(v, &w, sizeof(struct t_vertex));
 }
 
 #undef M
-#define M(x, y)		Mm[I(x, y)]
-#define P(x, y)		Pm[I(x, y)]
+#define M(x, y)  Mm[I(x, y)]
+#define P(x, y)  Pm[I(x, y)]
 /* this inverts the matrix M into P in the gauss way */
 int myInvert()
 {
-	t_mtrx Mm,Pm;
-	int l,lh; /* line*/
+	t_mtrx Mm, Pm;
+	int l, lh; /* line*/
 	float f; /* factor */
 	int i; /* number */
-	memcpy(Mm,MAT,sizeof(t_mtrx));			/* backup matrix */
-	memcpy(Pm,Identity,sizeof(t_mtrx));		/* target */
+	memcpy(Mm, MAT, sizeof(t_mtrx)); /* backup matrix */
+	memcpy(Pm, Identity, sizeof(t_mtrx));  /* target */
 
-	/*	s3dprintf(MED,"start:");
-		mat_debug(MAT);*/
+	/* s3dprintf(MED,"start:");
+	 mat_debug(MAT);*/
 
-	/*	s3dprintf(LOW,"inverting matrix, we shall begin now ...");*/
+	/* s3dprintf(LOW,"inverting matrix, we shall begin now ...");*/
 
 	/* step 1 */
-	for (l=0;l<4;l++) {
+	for (l = 0;l < 4;l++) {
 check:
-		if (M(l,l)*M(l,l)>0.00000001F) { /* it won't work with real zero */
+		if (M(l, l)*M(l, l) > 0.00000001F) { /* it won't work with real zero */
 
-			/*			s3dprintf(MED,"normalizing line %d",l);*/
+			/*   s3dprintf(MED,"normalizing line %d",l);*/
 			/* normalize */
-			f=1/M(l,l);
-			M(l,l)=1.0;
-			for (i=l+1;i<4;i++)
-				M(i,l)*=f; /* the left side ... */
-			for (i=0;i<4;i++)
-				P(i,l)*=f; /* ... and the right */
-			/*			mat_debug(Mm);
-						s3dprintf(MED,"-");
-						mat_debug(Pm);*/
+			f = 1 / M(l, l);
+			M(l, l) = 1.0;
+			for (i = l + 1;i < 4;i++)
+				M(i, l) *= f; /* the left side ... */
+			for (i = 0;i < 4;i++)
+				P(i, l) *= f; /* ... and the right */
+			/*   mat_debug(Mm);
+			   s3dprintf(MED,"-");
+			   mat_debug(Pm);*/
 			/* mult/fac */
-			for (lh=l+1;lh<4;lh++) {
-				/*	s3dprintf(MED,"adding line %d for %d",lh,l);*/
-				if (M(l,lh)!=0) { /* "first" element of the line */
-					f=-M(l,lh);
-					M(l,lh)=0.0; /* yes, this WILL be zero! ... */
-					for (i=l+1;i<4;i++) /* left side */
-						M(i,lh)+=f*M(i,l);
-					for (i=0;i<4;i++)	/* ... and the right one! */
-						P(i,lh)+=f*P(i,l);
+			for (lh = l + 1;lh < 4;lh++) {
+				/* s3dprintf(MED,"adding line %d for %d",lh,l);*/
+				if (M(l, lh) != 0) { /* "first" element of the line */
+					f = -M(l, lh);
+					M(l, lh) = 0.0; /* yes, this WILL be zero! ... */
+					for (i = l + 1;i < 4;i++) /* left side */
+						M(i, lh) += f * M(i, l);
+					for (i = 0;i < 4;i++) /* ... and the right one! */
+						P(i, lh) += f * P(i, l);
 				} /*else s3dprintf(MED,"element already zero!");*/
 			}
 		} else {
-			M(l,l)=0.0F;
-			/*			s3dprintf(MED,"already zero now check and try to swap lines ...");*/
-			for (lh=l+1;lh<4;lh++)
-				if (M(l,lh)!=0.0) {
-					/*					s3dprintf(MED,"swapping lines %d and %d",l,lh);*/
-					for (i=0;i<4;i++) {
-						f=M(i,l);
-						M(i,l)=M(i,lh);
-						M(i,lh)=f;
-						f=P(i,l);
-						P(i,l)=P(i,lh);
-						P(i,lh)=f;
+			M(l, l) = 0.0F;
+			/*   s3dprintf(MED,"already zero now check and try to swap lines ...");*/
+			for (lh = l + 1;lh < 4;lh++)
+				if (M(l, lh) != 0.0) {
+					/*     s3dprintf(MED,"swapping lines %d and %d",l,lh);*/
+					for (i = 0;i < 4;i++) {
+						f = M(i, l);
+						M(i, l) = M(i, lh);
+						M(i, lh) = f;
+						f = P(i, l);
+						P(i, l) = P(i, lh);
+						P(i, lh) = f;
 
 					}
 					goto check;
 				}
-			s3dprintf(MED,"nothing to swap, can't reverse this matrix! returning ... ");
+			s3dprintf(MED, "nothing to swap, can't reverse this matrix! returning ... ");
 			mat_debug(Mm);
 			return(-1); /* the dead end!! */
 		}
@@ -171,27 +171,27 @@
 	 * */
 
 	/* step 2 */
-	/*	s3dprintf(MED,"S.T.E.P. 2!!");*/
-	for (l=3;l>0;l--) {
+	/* s3dprintf(MED,"S.T.E.P. 2!!");*/
+	for (l = 3;l > 0;l--) {
 		/* mult/fac */
-		for (lh=l-1;lh>=0;lh--) {
-			/*			s3dprintf(MED,"adding line %d for %d",lh,l);*/
-			if (M(l,lh)!=0) { /* "first" element of the line */
-				f=-M(l,lh);
-				M(l,lh)=0;
-				for (i=0;i<4;i++) {	/* ... and the right one! */
-					P(i,lh)+=f*P(i,l);
+		for (lh = l - 1;lh >= 0;lh--) {
+			/*   s3dprintf(MED,"adding line %d for %d",lh,l);*/
+			if (M(l, lh) != 0) { /* "first" element of the line */
+				f = -M(l, lh);
+				M(l, lh) = 0;
+				for (i = 0;i < 4;i++) { /* ... and the right one! */
+					P(i, lh) += f * P(i, l);
 				}
 
 			}
-			/*			mat_debug(Mm);
-						mat_debug(Pm);*/
+			/*   mat_debug(Mm);
+			   mat_debug(Pm);*/
 		}
 	}
 	/* now, Mm,is Identity and Pm is result!*/
-	/*	s3dprintf(MED,"result:");
-		mat_debug(Pm);*/
-	memcpy(MAT,Pm,sizeof(t_mtrx)); /* copy result */
+	/* s3dprintf(MED,"result:");
+	 mat_debug(Pm);*/
+	memcpy(MAT, Pm, sizeof(t_mtrx)); /* copy result */
 	return(0);
 }
 

Modified: trunk/server/mcp.c
===================================================================
--- trunk/server/mcp.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/mcp.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,41 +23,41 @@
 
 
 #include "global.h"
-#include "proto.h" 			 /*  for S3D_P_OBJECT, to be integrated in proto.c */
+#include "proto.h"     /*  for S3D_P_OBJECT, to be integrated in proto.c */
 #ifdef WIN32
 #include <winsock2.h>
 #else
-#include <netinet/in.h> 	 /*  htonl() */
+#include <netinet/in.h>   /*  htonl() */
 #endif
-#include <string.h>			 /*  strncpy() */
+#include <string.h>    /*  strncpy() */
 
 
-extern int 		   focus_oid;		 /*  the focused program */
+extern int      focus_oid;   /*  the focused program */
 
 /*  this interacts with the actual mcp client */
 struct mcp_object {
 	uint32_t object;
-	float trans_x,trans_y,trans_z;
+	float trans_x, trans_y, trans_z;
 	float r;
-	/* 	char event; */
+	/*  char event; */
 	char name[NAME_MAX];
 };
-#define MCP_NEW_OBJECT	1
+#define MCP_NEW_OBJECT 1
 /*  call when a new mcp connects */
 int mcp_init()
 {
 	struct t_process *p;
 	uint32_t i;
-	p=get_proc_by_pid(MCP);
-	i=p->n_obj;
+	p = get_proc_by_pid(MCP);
+	i = p->n_obj;
 	while (i--) {
-		if (p->object[i]!=NULL)
+		if (p->object[i] != NULL)
 			switch (p->object[i]->oflags&OF_TYPE) {
 			case OF_VIRTUAL:
 				mcp_rep_object(i);
 				break;
 			case OF_CAM:
-				event_obj_info(p,i);
+				event_obj_info(p, i);
 				break;
 			}
 	}
@@ -68,28 +68,28 @@
 int mcp_rep_object(int32_t mcp_oid)
 {
 	struct mcp_object mo;
-	struct t_process *p,*ap;
-	p=get_proc_by_pid(MCP);
-	mo.object=htonl(mcp_oid);
-	mo.trans_x=p->object[mcp_oid]->translate.x;
-	mo.trans_y=p->object[mcp_oid]->translate.y;
-	mo.trans_z=p->object[mcp_oid]->translate.z;
-	mo.r=p->object[mcp_oid]->r;
-	/* 	mo.event=MCP_NEW_OBJECT; */
-	ap=get_proc_by_pid(p->object[mcp_oid]->n_mat);
-	strncpy(mo.name,ap->name,NAME_MAX);
-	prot_com_out(p,S3D_P_MCP_OBJECT,(uint8_t *)&mo,sizeof(struct mcp_object));
+	struct t_process *p, *ap;
+	p = get_proc_by_pid(MCP);
+	mo.object = htonl(mcp_oid);
+	mo.trans_x = p->object[mcp_oid]->translate.x;
+	mo.trans_y = p->object[mcp_oid]->translate.y;
+	mo.trans_z = p->object[mcp_oid]->translate.z;
+	mo.r = p->object[mcp_oid]->r;
+	/*  mo.event=MCP_NEW_OBJECT; */
+	ap = get_proc_by_pid(p->object[mcp_oid]->n_mat);
+	strncpy(mo.name, ap->name, NAME_MAX);
+	prot_com_out(p, S3D_P_MCP_OBJECT, (uint8_t *)&mo, sizeof(struct mcp_object));
 	return(0);
 }
 /* tells the mcp that some program vanished ... */
 int mcp_del_object(int32_t mcp_oid)
 {
-	int32_t oid=htonl(mcp_oid);
-	if (mcp_oid==focus_oid) {
-		s3dprintf(MED,"lost the focus of mcp-oid %d",mcp_oid);
+	int32_t oid = htonl(mcp_oid);
+	if (mcp_oid == focus_oid) {
+		s3dprintf(MED, "lost the focus of mcp-oid %d", mcp_oid);
 		mcp_focus(-1);
 	}
-	prot_com_out(get_proc_by_pid(MCP),S3D_P_MCP_DEL_OBJECT,(uint8_t *)&oid,4);
+	prot_com_out(get_proc_by_pid(MCP), S3D_P_MCP_DEL_OBJECT, (uint8_t *)&oid, 4);
 	return(0);
 }
 /* sets a new focus */
@@ -97,13 +97,13 @@
 {
 	struct t_process *p;
 	struct t_obj *o;
-	focus_oid=-1;
-	p=get_proc_by_pid(MCP);
-	s3dprintf(MED,"request to focus %d",oid);
-	if (OBJ_VALID(p,oid,o))
+	focus_oid = -1;
+	p = get_proc_by_pid(MCP);
+	s3dprintf(MED, "request to focus %d", oid);
+	if (OBJ_VALID(p, oid, o))
 		if (o->oflags&OF_VIRTUAL) {
-			focus_oid=oid;
-			obj_pos_update(p,0,0);
+			focus_oid = oid;
+			obj_pos_update(p, 0, 0);
 		}
 	return(0);
 }
@@ -113,6 +113,6 @@
 /* TODO: move things from object.c to this place!
 int mcp_quit(void)
 {
-	return(0);
+ return(0);
 }
 */

Modified: trunk/server/navigation.c
===================================================================
--- trunk/server/navigation.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/navigation.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,97 +24,97 @@
 
 #include "global.h"
 #include <math.h> /* atan() */
-int alphax,alphay;
-float view_x,view_y,view_z;
-extern int winw,winh;
+int alphax, alphay;
+float view_x, view_y, view_z;
+extern int winw, winh;
 void navi_right()
 {
-	navi_pos(1,0);
+	navi_pos(1, 0);
 }
 void navi_left()
 {
-	navi_pos(-1,0);
+	navi_pos(-1, 0);
 }
 void navi_fwd()
 {
-	navi_pos(0,1);
+	navi_pos(0, 1);
 }
 void navi_back()
 {
-	navi_pos(0,-1);
+	navi_pos(0, -1);
 }
 /* simple movements, not needed currently
 void navi_rot_right()
 {
-	cam.rotate.y=cam.rotate.y+2;
-	if (cam.rotate.y>360) cam.rotate.y-=360;
+ cam.rotate.y=cam.rotate.y+2;
+ if (cam.rotate.y>360) cam.rotate.y-=360;
 }
 void navi_rot_left()
 {
-	cam.rotate.y=cam.rotate.y-2;
-	cam.rotate.y=(cam.rotate.y<0)?cam.rotate.y+360:cam.rotate.y;
+ cam.rotate.y=cam.rotate.y-2;
+ cam.rotate.y=(cam.rotate.y<0)?cam.rotate.y+360:cam.rotate.y;
 }
 void navi_rot_up()
 {
-	cam.rotate.x=(cam.rotate.x+2);
-	if (cam.rotate.x>90) cam.rotate.x=90;
+ cam.rotate.x=(cam.rotate.x+2);
+ if (cam.rotate.x>90) cam.rotate.x=90;
 }
 void navi_rot_down()
 {
-	cam.rotate.x=cam.rotate.x-2;
-	if (cam.rotate.x<-90) cam.rotate.x=-90;
+ cam.rotate.x=cam.rotate.x-2;
+ if (cam.rotate.x<-90) cam.rotate.x=-90;
 }*/
 void navi_pos(int xdif, int ydif)
 {
 	float tv[3];
 	struct t_obj *cam;
-	cam=get_proc_by_pid(MCP)->object[0];
-	tv[0]=cam->translate.x;
-	tv[1]=cam->translate.y;
-	tv[2]=cam->translate.z;
+	cam = get_proc_by_pid(MCP)->object[0];
+	tv[0] = cam->translate.x;
+	tv[1] = cam->translate.y;
+	tv[2] = cam->translate.z;
 
-	tv[0]+=ydif*sin((-cam->rotate.y*M_PI)/180);
-	tv[2]-=ydif*cos((-cam->rotate.y*M_PI)/180);
+	tv[0] += ydif * sin((-cam->rotate.y * M_PI) / 180);
+	tv[2] -= ydif * cos((-cam->rotate.y * M_PI) / 180);
 
-	tv[0]-=xdif*cos((-cam->rotate.y*M_PI)/180);
-	tv[2]-=xdif*sin((-cam->rotate.y*M_PI)/180);
-	obj_translate(get_proc_by_pid(MCP),0,tv);
+	tv[0] -= xdif * cos((-cam->rotate.y * M_PI) / 180);
+	tv[2] -= xdif * sin((-cam->rotate.y * M_PI) / 180);
+	obj_translate(get_proc_by_pid(MCP), 0, tv);
 }
 void navi_rot(int xdif, int ydif)
 {
 	float rv[3];
 	struct t_obj *cam;
-	cam=get_proc_by_pid(MCP)->object[0];
-	rv[0]=(cam->rotate.x+ydif);
-	rv[1]=(cam->rotate.y+xdif);
-	rv[2]=0.0F;
-	if (rv[0]>90) 	rv[0]=90;
-	if (rv[0]<-90) 	rv[0]=-90;
-	if (rv[1]>360) 	rv[1]-=360;
-	if (rv[1]<0) 	rv[1]+=360;
-	obj_rotate(get_proc_by_pid(MCP),0,rv);
+	cam = get_proc_by_pid(MCP)->object[0];
+	rv[0] = (cam->rotate.x + ydif);
+	rv[1] = (cam->rotate.y + xdif);
+	rv[2] = 0.0F;
+	if (rv[0] > 90)  rv[0] = 90;
+	if (rv[0] < -90)  rv[0] = -90;
+	if (rv[1] > 360)  rv[1] -= 360;
+	if (rv[1] < 0)  rv[1] += 360;
+	obj_rotate(get_proc_by_pid(MCP), 0, rv);
 }
 void ptr_move(int x, int y)
 {
-	float tv[3],rv[3],xf,yf;
+	float tv[3], rv[3], xf, yf;
 	struct t_process *p;
 	int ptr;
-	if (winw>winh) {
-		xf=winw/(float)winh;
-		yf=1;
+	if (winw > winh) {
+		xf = winw / (float)winh;
+		yf = 1;
 	} else {
-		xf=1;
-		yf=winh/(float)winw;
+		xf = 1;
+		yf = winh / (float)winw;
 	}
-	tv[0]=(2.0*x/((float)winw)-1.0)*xf;
-	tv[1]=-(2.0*y/((float)winh)-1.0)*yf;
-	tv[2]=-1;
-	rv[0]=1.5*180/M_PI*atan(tv[1]/2); /* TODO: Hm, this is not really correct ... */
-	rv[1]=1.5*180/M_PI*-atan(tv[0]/2);
-	rv[2]=0;
-	p=get_proc_by_pid(MCP);
-	if (-1!=(ptr=get_pointer(p))) {
-		obj_translate(p,ptr,tv);
-		obj_rotate(p,ptr,rv);
+	tv[0] = (2.0 * x / ((float)winw) - 1.0) * xf;
+	tv[1] = -(2.0 * y / ((float)winh) - 1.0) * yf;
+	tv[2] = -1;
+	rv[0] = 1.5 * 180 / M_PI * atan(tv[1] / 2); /* TODO: Hm, this is not really correct ... */
+	rv[1] = 1.5 * 180 / M_PI * -atan(tv[0] / 2);
+	rv[2] = 0;
+	p = get_proc_by_pid(MCP);
+	if (-1 != (ptr = get_pointer(p))) {
+		obj_translate(p, ptr, tv);
+		obj_rotate(p, ptr, rv);
 	}
 }

Modified: trunk/server/network.c
===================================================================
--- trunk/server/network.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/network.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,15 +24,15 @@
 
 #include "global.h"
 #include <stdio.h>
-#include <stdlib.h>		 /*  free() */
-#include <errno.h>		 /*  errno() */
-#include <unistd.h>		/* close(), read(),write() */
-#include <signal.h>		/* SIGPIPE,SIG_ERR,SIGIO */
+#include <stdlib.h>   /*  free() */
+#include <errno.h>   /*  errno() */
+#include <unistd.h>  /* close(), read(),write() */
+#include <signal.h>  /* SIGPIPE,SIG_ERR,SIGIO */
 #ifdef G_SDL
-#include <SDL.h>	/* SDL_SetTimer() */
+#include <SDL.h> /* SDL_SetTimer() */
 #endif
 #ifdef SIGS
-#include <signal.h>	 /*  sighandler_t SIG_PIPE */
+#include <signal.h>  /*  sighandler_t SIG_PIPE */
 #endif
 /*  here go all the network functions */
 /*  */
@@ -44,25 +44,25 @@
 uint8_t ibuf[MAXPLEN]; /* input buffer for a packet */
 uint8_t obuf[MAXPLEN]; /* output buffer */
 #ifdef SIGS
-int sigio=0;
+int sigio = 0;
 #endif
 
 #ifdef SIGS
 void sigpipe_handler(int S3DUNUSED(unused))
 {
-	errs("sigpip_handler()","there is a broken pipe somewhere");
+	errs("sigpip_handler()", "there is a broken pipe somewhere");
 }
 
 void sigio_handler(int S3DUNUSED(unused))
 {
-	sigio=1;
+	sigio = 1;
 }
 #endif
 /*  maybe change the errors to fatal errors ... */
 int network_init()
 {
 #ifdef SIGS
-	/*	struct sigaction act;*/
+	/* struct sigaction act;*/
 #endif
 #ifdef TCP
 	tcp_init();
@@ -72,20 +72,20 @@
 #endif
 #ifdef SIGS
 	if (signal(SIGPIPE, sigpipe_handler) == SIG_ERR)
-		errn("network_init():signal()",errno);
-	/*	act.sa_handler = (sig_t)sigio_handler;
-		if ( sigaction(SIGIO, &act, 0) < 0 )
-			errn("network_init():sigaction()",errno);*/
+		errn("network_init():signal()", errno);
+	/* act.sa_handler = (sig_t)sigio_handler;
+	 if ( sigaction(SIGIO, &act, 0) < 0 )
+	  errn("network_init():sigaction()",errno);*/
 	if (signal(SIGIO, sigio_handler) == SIG_ERR)
-		errn("s3d_init():signal()",errno);
+		errn("s3d_init():signal()", errno);
 #endif
 	return(0);
 }
-int					 turn;
-int	net_turn_off(int S3DUNUSED(interval))
+int      turn;
+int net_turn_off(int S3DUNUSED(interval))
 {
-	s3dprintf(VLOW,"Warning: High traffic on Network, interrupting read.");
-	turn=0;
+	s3dprintf(VLOW, "Warning: High traffic on Network, interrupting read.");
+	turn = 0;
 	return(0);
 }
 
@@ -94,19 +94,19 @@
 {
 #ifdef TCP
 #ifdef SIGS
-	if (sigio==1) { /*  as long as there is no locking/threadsafety, do like this ... */
+	if (sigio == 1) { /*  as long as there is no locking/threadsafety, do like this ... */
 #endif
-		tcp_pollport();	/*  this polls for new processes */
+		tcp_pollport(); /*  this polls for new processes */
 #ifdef G_SDL
-		SDL_SetTimer(50,(SDL_TimerCallback) net_turn_off);
+		SDL_SetTimer(50, (SDL_TimerCallback) net_turn_off);
 #endif
 		while (turn && tcp_pollproc());  /*  if there is new data, loop please. this is for testing now, and should be combined with timing later .. */
 #ifdef G_SDL
-		SDL_SetTimer(0,NULL);
+		SDL_SetTimer(0, NULL);
 #endif
 
 #ifdef SIGS
-		sigio=0;
+		sigio = 0;
 	}
 #endif
 #endif
@@ -129,7 +129,7 @@
 		break;
 #endif
 	}
-	p->con_type=CON_NULL;
+	p->con_type = CON_NULL;
 	return(-1);
 }
 
@@ -138,11 +138,11 @@
 	switch (p->con_type) {
 #ifdef TCP
 	case CON_TCP:
-		return(tcp_readn(p->sockid,str,s));
+		return(tcp_readn(p->sockid, str, s));
 #endif
 #ifdef SHM
 	case CON_SHM:
-		return(shm_readn((struct buf_t *)p->shmsock.data_ctos,str,s));
+		return(shm_readn((struct buf_t *)p->shmsock.data_ctos, str, s));
 #endif
 	}
 	return(-1);
@@ -152,11 +152,11 @@
 	switch (p->con_type) {
 #ifdef TCP
 	case CON_TCP:
-		return(tcp_writen(p->sockid,str,s));
+		return(tcp_writen(p->sockid, str, s));
 #endif
 #ifdef SHM
 	case CON_SHM:
-		return(shm_writen((struct buf_t *)p->shmsock.data_stoc,str,s));
+		return(shm_writen((struct buf_t *)p->shmsock.data_stoc, str, s));
 #endif
 	}
 	return(-1);

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/object.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,109 +23,109 @@
 
 
 #include "global.h"
-#include <stdlib.h>		 /*  malloc(),realloc(),free() */
-#include <string.h>		 /*  memcpy() */
-#include <GL/gl.h>		 /*  gl*, GL* */
-#ifndef _ISOC99_SOURCE	/* we want isnan() */
+#include <stdlib.h>   /*  malloc(),realloc(),free() */
+#include <string.h>   /*  memcpy() */
+#include <GL/gl.h>   /*  gl*, GL* */
+#ifndef _ISOC99_SOURCE /* we want isnan() */
 #define _ISOC99_SOURCE
 #endif
-#include <math.h>		 /*  sin(),cos() */
+#include <math.h>   /*  sin(),cos() */
 
-#define MAXLOOP	10
+#define MAXLOOP 10
 /*  if oid is always unsigned, we don't have to check oid>=0 */
 
 extern t_mtrx Identity;
 extern int focus_oid;
 
 
-static void obj_update_tex(struct t_tex *tex,u_int16_t x,u_int16_t y,u_int16_t w,u_int16_t h,u_int8_t *pixbuf);
+static void obj_update_tex(struct t_tex *tex, u_int16_t x, u_int16_t y, u_int16_t w, u_int16_t h, u_int8_t *pixbuf);
 void obj_sys_update(struct t_process *p, int32_t oid);
 
 /*  debugging function for objects, prints out some stuff known about it... */
-int obj_debug			(struct t_process *p, int32_t oid)
+int obj_debug(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o;
-	s3dprintf(HIGH,"about pid %d/obj %d:",p->id,oid);
-	if (OBJ_VALID(p,oid,o)) {
-		s3dprintf(HIGH,"vertices: %d, polygons: %d, materials: %d, textures: %d, flags: %010x",o->n_vertex,o->n_poly, o->n_mat, o->n_tex,o->oflags);
-		s3dprintf(HIGH,"linkid %d, displaylist %d",o->linkid,o->dplist);
-		s3dprintf(HIGH,"translation: %f %f %f",o->translate.x,o->translate.y,o->translate.z);
-		s3dprintf(HIGH,"rotation: %f %f %f",o->rotate.x,o->rotate.y,o->rotate.z);
-		s3dprintf(HIGH,"scale: %f",o->scale);
+	s3dprintf(HIGH, "about pid %d/obj %d:", p->id, oid);
+	if (OBJ_VALID(p, oid, o)) {
+		s3dprintf(HIGH, "vertices: %d, polygons: %d, materials: %d, textures: %d, flags: %010x", o->n_vertex, o->n_poly, o->n_mat, o->n_tex, o->oflags);
+		s3dprintf(HIGH, "linkid %d, displaylist %d", o->linkid, o->dplist);
+		s3dprintf(HIGH, "translation: %f %f %f", o->translate.x, o->translate.y, o->translate.z);
+		s3dprintf(HIGH, "rotation: %f %f %f", o->rotate.x, o->rotate.y, o->rotate.z);
+		s3dprintf(HIGH, "scale: %f", o->scale);
 		if (o->oflags&OF_SYSTEM) {
-			s3dprintf(HIGH,"it's a system object!!");
+			s3dprintf(HIGH, "it's a system object!!");
 		} else if (o->oflags&OF_CLONE) {
-			s3dprintf(HIGH,"it's a clone linking to %d",o->n_vertex);
-			obj_debug(p,o->n_vertex);
+			s3dprintf(HIGH, "it's a clone linking to %d", o->n_vertex);
+			obj_debug(p, o->n_vertex);
 		}
 	} else {
-		s3dprintf(HIGH,"can't get oid %d pid %d",oid,p->id);
+		s3dprintf(HIGH, "can't get oid %d pid %d", oid, p->id);
 	}
 	return(0);
 }
 /*  push a few new vertices onto the stack. */
-int obj_push_vertex		(struct t_process *p, int32_t oid, float *x, int32_t n)
+int obj_push_vertex(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_vertex *p_vertex;
 	struct t_vertex *a;
 	struct t_obj *obj;
 	float *px;
 	float r;
 	int is_clnsrc;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_push_vertex()","error: no data on object allowed!");
+			errds(MED, "obj_push_vertex()", "error: no data on object allowed!");
 			return(-1);
 		}
 
-		m=obj->n_vertex;	 /*  saving the first number of vertices */
-		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_vertex=realloc(obj->p_vertex,sizeof(struct t_vertex) * ( n + (obj->n_vertex))))) {
+		m = obj->n_vertex;  /*  saving the first number of vertices */
+		px = x;    /*  movable pointer for x, later */
+		if (NULL != (p_vertex = realloc(obj->p_vertex, sizeof(struct t_vertex) * (n + (obj->n_vertex))))) {
 			if (obj->dplist) {
-				s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-				glDeleteLists(obj->dplist,1);
-				obj->dplist=0;
+				s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+				glDeleteLists(obj->dplist, 1);
+				obj->dplist = 0;
 			}
-			obj->p_vertex=p_vertex;
-			for (i=0;i<n;i++) {
-				obj->p_vertex[m+i].x=*(px++);
-				obj->p_vertex[m+i].y=*(px++);
-				obj->p_vertex[m+i].z=*(px++);
+			obj->p_vertex = p_vertex;
+			for (i = 0;i < n;i++) {
+				obj->p_vertex[m+i].x = *(px++);
+				obj->p_vertex[m+i].y = *(px++);
+				obj->p_vertex[m+i].z = *(px++);
 
-				a=&obj->p_vertex[m+i];
-				r=obj->scale * sqrt(
-				          (a->x * a->x ) +
-				          (a->y * a->y ) +
-				          (a->z * a->z ));
-				if (r> obj->r) obj->r=r;
-				/*				s3dprintf(VLOW,"added following vertex[%d]: %f, %f, %f",i,
-												obj->p_vertex[m+i].x,
-												obj->p_vertex[m+i].y,
-												obj->p_vertex[m+i].z);*/
+				a = &obj->p_vertex[m+i];
+				r = obj->scale * sqrt(
+				            (a->x * a->x) +
+				            (a->y * a->y) +
+				            (a->z * a->z));
+				if (r > obj->r) obj->r = r;
+				/*    s3dprintf(VLOW,"added following vertex[%d]: %f, %f, %f",i,
+				        obj->p_vertex[m+i].x,
+				        obj->p_vertex[m+i].y,
+				        obj->p_vertex[m+i].z);*/
 
 			}
-			if (p->id!=MCP) {
+			if (p->id != MCP) {
 				/* this is doing live update which is quite okay, but we need
 				 * to check for biggest update and clonesources ... */
-				obj_check_biggest_object(p,oid);
+				obj_check_biggest_object(p, oid);
 			}
 			if (p->object[oid]->oflags&OF_CLONE_SRC) {
-				is_clnsrc=0;
-				for (i=0;i<p->n_obj;i++) {
-					if (p->object[i]!=NULL) {
-						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid)) { /* if it's pointing to our object ... */
-							is_clnsrc=1;
-							p->object[i]->r=obj->r*(p->object[i]->r/obj->scale); /* give it the new radius too! */
-							obj_check_biggest_object(p,i);
+				is_clnsrc = 0;
+				for (i = 0;i < p->n_obj;i++) {
+					if (p->object[i] != NULL) {
+						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex == oid)) { /* if it's pointing to our object ... */
+							is_clnsrc = 1;
+							p->object[i]->r = obj->r * (p->object[i]->r / obj->scale); /* give it the new radius too! */
+							obj_check_biggest_object(p, i);
 						}
 					}
 				}
 				if (!is_clnsrc)
-					p->object[oid]->oflags&=~OF_CLONE_SRC;
+					p->object[oid]->oflags &= ~OF_CLONE_SRC;
 			}
 
-			obj->n_vertex+=n;
+			obj->n_vertex += n;
 		}
 	} else {
 		return(-1);
@@ -134,42 +134,42 @@
 }
 
 
-int obj_push_mat		(struct t_process *p, int32_t oid, float *x, int32_t n)
+int obj_push_mat(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_mat *p_mat;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_push_mat()","error: no data on object allowed!");
+			errds(MED, "obj_push_mat()", "error: no data on object allowed!");
 			return(-1);
 		}
-		m=obj->n_mat;	 /*  saving the first number of materials */
-		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_mat=realloc(obj->p_mat,sizeof(struct t_mat) * ( n + (obj->n_mat))))) {
+		m = obj->n_mat;  /*  saving the first number of materials */
+		px = x;    /*  movable pointer for x, later */
+		if (NULL != (p_mat = realloc(obj->p_mat, sizeof(struct t_mat) * (n + (obj->n_mat))))) {
 			if (obj->dplist) {
-				s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-				glDeleteLists(obj->dplist,1);
-				obj->dplist=0;
+				s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+				glDeleteLists(obj->dplist, 1);
+				obj->dplist = 0;
 			}
-			obj->p_mat=p_mat;
-			for (i=0;i<n;i++) {
-				obj->p_mat[m+i].amb_r=*(px++);
-				obj->p_mat[m+i].amb_g=*(px++);
-				obj->p_mat[m+i].amb_b=*(px++);
-				obj->p_mat[m+i].amb_a=*(px++);
-				obj->p_mat[m+i].spec_r=*(px++);
-				obj->p_mat[m+i].spec_g=*(px++);
-				obj->p_mat[m+i].spec_b=*(px++);
-				obj->p_mat[m+i].spec_a=*(px++);
-				obj->p_mat[m+i].diff_r=*(px++);
-				obj->p_mat[m+i].diff_g=*(px++);
-				obj->p_mat[m+i].diff_b=*(px++);
-				obj->p_mat[m+i].diff_a=*(px++);
-				obj->p_mat[m+i].tex=-1;
+			obj->p_mat = p_mat;
+			for (i = 0;i < n;i++) {
+				obj->p_mat[m+i].amb_r = *(px++);
+				obj->p_mat[m+i].amb_g = *(px++);
+				obj->p_mat[m+i].amb_b = *(px++);
+				obj->p_mat[m+i].amb_a = *(px++);
+				obj->p_mat[m+i].spec_r = *(px++);
+				obj->p_mat[m+i].spec_g = *(px++);
+				obj->p_mat[m+i].spec_b = *(px++);
+				obj->p_mat[m+i].spec_a = *(px++);
+				obj->p_mat[m+i].diff_r = *(px++);
+				obj->p_mat[m+i].diff_g = *(px++);
+				obj->p_mat[m+i].diff_b = *(px++);
+				obj->p_mat[m+i].diff_a = *(px++);
+				obj->p_mat[m+i].tex = -1;
 			}
-			obj->n_mat+=n;
+			obj->n_mat += n;
 		}
 	} else {
 		return(-1);
@@ -180,38 +180,38 @@
 /*  its always the same ... this time we push some polys on the stack */
 int obj_push_poly(struct t_process *p, int32_t oid, uint32_t *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_poly *p_poly;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_push_poly()","error: no data on object allowed!");
+			errds(MED, "obj_push_poly()", "error: no data on object allowed!");
 			return(-1);
 		}
 
-		m=obj->n_poly;	 /*  saving the first number of polys */
-		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_poly=realloc(obj->p_poly,sizeof(struct t_poly) * ( n + (obj->n_poly))))) {
+		m = obj->n_poly;  /*  saving the first number of polys */
+		px = x;    /*  movable pointer for x, later */
+		if (NULL != (p_poly = realloc(obj->p_poly, sizeof(struct t_poly) * (n + (obj->n_poly))))) {
 			if (obj->dplist) {
-				s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-				glDeleteLists(obj->dplist,1);
-				obj->dplist=0;
+				s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+				glDeleteLists(obj->dplist, 1);
+				obj->dplist = 0;
 			}
-			obj->p_poly=p_poly;
-			for (i=0;i<n;i++) {
-				obj->p_poly[m+i].v[0]=*(px++);
-				obj->p_poly[m+i].v[1]=*(px++);
-				obj->p_poly[m+i].v[2]=*(px++);
-				obj->p_poly[m+i].mat=*(px++);
-				obj->p_poly[m+i].n[0].x=obj->p_poly[m+i].n[0].y=obj->p_poly[m+i].n[0].z=0;
-				obj->p_poly[m+i].n[1].x=obj->p_poly[m+i].n[1].y=obj->p_poly[m+i].n[1].z=0;
-				obj->p_poly[m+i].n[2].x=obj->p_poly[m+i].n[2].y=obj->p_poly[m+i].n[2].z=0;
-				obj->p_poly[m+i].tc[0].x=obj->p_poly[m+i].n[0].y=obj->p_poly[m+i].n[0].z=0;
-				obj->p_poly[m+i].tc[1].x=obj->p_poly[m+i].n[1].y=obj->p_poly[m+i].n[1].z=0;
-				obj->p_poly[m+i].tc[2].x=obj->p_poly[m+i].n[2].y=obj->p_poly[m+i].n[2].z=0;
+			obj->p_poly = p_poly;
+			for (i = 0;i < n;i++) {
+				obj->p_poly[m+i].v[0] = *(px++);
+				obj->p_poly[m+i].v[1] = *(px++);
+				obj->p_poly[m+i].v[2] = *(px++);
+				obj->p_poly[m+i].mat = *(px++);
+				obj->p_poly[m+i].n[0].x = obj->p_poly[m+i].n[0].y = obj->p_poly[m+i].n[0].z = 0;
+				obj->p_poly[m+i].n[1].x = obj->p_poly[m+i].n[1].y = obj->p_poly[m+i].n[1].z = 0;
+				obj->p_poly[m+i].n[2].x = obj->p_poly[m+i].n[2].y = obj->p_poly[m+i].n[2].z = 0;
+				obj->p_poly[m+i].tc[0].x = obj->p_poly[m+i].n[0].y = obj->p_poly[m+i].n[0].z = 0;
+				obj->p_poly[m+i].tc[1].x = obj->p_poly[m+i].n[1].y = obj->p_poly[m+i].n[1].z = 0;
+				obj->p_poly[m+i].tc[2].x = obj->p_poly[m+i].n[2].y = obj->p_poly[m+i].n[2].z = 0;
 			}
-			obj->n_poly+=n;
+			obj->n_poly += n;
 		}
 	} else {
 		return(-1);
@@ -221,33 +221,33 @@
 /*  its always the same ... this time we push some lines on the stack */
 int obj_push_line(struct t_process *p, int32_t oid, uint32_t *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_line *p_line;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_push_line()","error: no data on object allowed!");
+			errds(MED, "obj_push_line()", "error: no data on object allowed!");
 			return(-1);
 		}
 
-		m=obj->n_line;	 /*  saving the first number of lines */
-		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_line=realloc(obj->p_line,sizeof(struct t_line) * ( n + (obj->n_line))))) {
+		m = obj->n_line;  /*  saving the first number of lines */
+		px = x;    /*  movable pointer for x, later */
+		if (NULL != (p_line = realloc(obj->p_line, sizeof(struct t_line) * (n + (obj->n_line))))) {
 			if (obj->dplist) {
-				s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-				glDeleteLists(obj->dplist,1);
-				obj->dplist=0;
+				s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+				glDeleteLists(obj->dplist, 1);
+				obj->dplist = 0;
 			}
-			obj->p_line=p_line;
-			for (i=0;i<n;i++) {
-				obj->p_line[m+i].v[0]=*(px++);
-				obj->p_line[m+i].v[1]=*(px++);
-				obj->p_line[m+i].mat=*(px++);
-				obj->p_line[m+i].n[0].x=obj->p_line[m+i].n[0].y=obj->p_line[m+i].n[0].z=0;
-				obj->p_line[m+i].n[1].x=obj->p_line[m+i].n[1].y=obj->p_line[m+i].n[1].z=0;
+			obj->p_line = p_line;
+			for (i = 0;i < n;i++) {
+				obj->p_line[m+i].v[0] = *(px++);
+				obj->p_line[m+i].v[1] = *(px++);
+				obj->p_line[m+i].mat = *(px++);
+				obj->p_line[m+i].n[0].x = obj->p_line[m+i].n[0].y = obj->p_line[m+i].n[0].z = 0;
+				obj->p_line[m+i].n[1].x = obj->p_line[m+i].n[1].y = obj->p_line[m+i].n[1].z = 0;
 			}
-			obj->n_line+=n;
+			obj->n_line += n;
 		}
 	} else {
 		return(-1);
@@ -258,67 +258,67 @@
  * given through *x */
 int obj_push_tex(struct t_process *p, int32_t oid, uint16_t *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	double d;
 	struct t_tex *p_tex;
 	struct t_obj *obj;
-	uint16_t *px,hm;
-	if (OBJ_VALID(p,oid,obj)) {
+	uint16_t *px, hm;
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_push_tex()","error: no data on object allowed!");
+			errds(MED, "obj_push_tex()", "error: no data on object allowed!");
 			return(-1);
 		}
-		m=obj->n_tex;	     /*  saving the first number of textures */
-		px=x; 				 /*  movable pointer for x, later */
-		if (NULL!=(p_tex=realloc(obj->p_tex,sizeof(struct t_tex) * ( n + (obj->n_tex))))) {
-			/*			if (obj->dplist)
-						{
-							s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-							glDeleteLists(obj->dplist,1);
-							obj->dplist=0;
-						}*/
-			obj->p_tex=p_tex;
-			for (i=0;i<n;i++) {
-				obj->p_tex[m+i].gl_texnum=-1;
-				obj->p_tex[m+i].tw=*(px++);
-				obj->p_tex[m+i].th=*(px++);
-				if ((obj->p_tex[m+i].tw<=TEXTURE_MAX_W) && (obj->p_tex[m+i].th<=TEXTURE_MAX_H)) {
-					d=log((double)obj->p_tex[m+i].tw)/log(2.0);
-					hm=pow(2,floor(d));
-					s3dprintf(MED,"hm %d, tw %d",hm,obj->p_tex[m+i].tw);
-					if (hm!=obj->p_tex[m+i].tw) 	{
-						obj->p_tex[m+i].w=hm*2;
-						obj->p_tex[m+i].xs=(float)((double)obj->p_tex[m+i].tw)/((double)obj->p_tex[m+i].w);
-					} else	{
-						obj->p_tex[m+i].xs=1.0;
-						obj->p_tex[m+i].w=obj->p_tex[m+i].tw;
+		m = obj->n_tex;    /*  saving the first number of textures */
+		px = x;    /*  movable pointer for x, later */
+		if (NULL != (p_tex = realloc(obj->p_tex, sizeof(struct t_tex) * (n + (obj->n_tex))))) {
+			/*   if (obj->dplist)
+			   {
+			    s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
+			    glDeleteLists(obj->dplist,1);
+			    obj->dplist=0;
+			   }*/
+			obj->p_tex = p_tex;
+			for (i = 0;i < n;i++) {
+				obj->p_tex[m+i].gl_texnum = -1;
+				obj->p_tex[m+i].tw = *(px++);
+				obj->p_tex[m+i].th = *(px++);
+				if ((obj->p_tex[m+i].tw <= TEXTURE_MAX_W) && (obj->p_tex[m+i].th <= TEXTURE_MAX_H)) {
+					d = log((double)obj->p_tex[m+i].tw) / log(2.0);
+					hm = pow(2, floor(d));
+					s3dprintf(MED, "hm %d, tw %d", hm, obj->p_tex[m+i].tw);
+					if (hm != obj->p_tex[m+i].tw)  {
+						obj->p_tex[m+i].w = hm * 2;
+						obj->p_tex[m+i].xs = (float)((double)obj->p_tex[m+i].tw) / ((double)obj->p_tex[m+i].w);
+					} else {
+						obj->p_tex[m+i].xs = 1.0;
+						obj->p_tex[m+i].w = obj->p_tex[m+i].tw;
 					}
-					d=log((double)obj->p_tex[m+i].th)/log(2.0);
-					hm=pow(2,floor(d));
-					s3dprintf(MED,"hm %d, th %d",hm,obj->p_tex[m+i].th);
+					d = log((double)obj->p_tex[m+i].th) / log(2.0);
+					hm = pow(2, floor(d));
+					s3dprintf(MED, "hm %d, th %d", hm, obj->p_tex[m+i].th);
 
-					if (hm!=obj->p_tex[m+i].th) 	{
-						obj->p_tex[m+i].h=hm*2;
-						obj->p_tex[m+i].ys=(float)((double)obj->p_tex[m+i].th)/((double)obj->p_tex[m+i].h);
-					} else 	{
-						obj->p_tex[m+i].ys=1.0;
-						obj->p_tex[m+i].h=obj->p_tex[m+i].th;
+					if (hm != obj->p_tex[m+i].th)  {
+						obj->p_tex[m+i].h = hm * 2;
+						obj->p_tex[m+i].ys = (float)((double)obj->p_tex[m+i].th) / ((double)obj->p_tex[m+i].h);
+					} else  {
+						obj->p_tex[m+i].ys = 1.0;
+						obj->p_tex[m+i].h = obj->p_tex[m+i].th;
 					}
-					obj->p_tex[m+i].buf=malloc(obj->p_tex[m+i].h*obj->p_tex[m+i].w*4);
-					memset(obj->p_tex[m+i].buf,0,obj->p_tex[m+i].h*obj->p_tex[m+i].w*4);
-					errds(LOW,"obj_push_tex()","setting up %d %d (in mem: %d %d) texture",
+					obj->p_tex[m+i].buf = malloc(obj->p_tex[m+i].h * obj->p_tex[m+i].w * 4);
+					memset(obj->p_tex[m+i].buf, 0, obj->p_tex[m+i].h*obj->p_tex[m+i].w*4);
+					errds(LOW, "obj_push_tex()", "setting up %d %d (in mem: %d %d) texture",
 					      obj->p_tex[m+i].tw,
 					      obj->p_tex[m+i].th,
 					      obj->p_tex[m+i].w,
 					      obj->p_tex[m+i].h);
 
-				} else	{
-					errds(MED,"obj_push_tex()","bad size for texture %d (requested size: %dx%d, max %dx%d)",m+i,
-					      obj->p_tex[m+i].tw,obj->p_tex[m+i].th,TEXTURE_MAX_W,TEXTURE_MAX_H);
-					obj->p_tex[m+i].buf=NULL;
+				} else {
+					errds(MED, "obj_push_tex()", "bad size for texture %d (requested size: %dx%d, max %dx%d)", m + i,
+					      obj->p_tex[m+i].tw, obj->p_tex[m+i].th, TEXTURE_MAX_W, TEXTURE_MAX_H);
+					obj->p_tex[m+i].buf = NULL;
 				}
 			}
-			obj->n_tex+=n;
+			obj->n_tex += n;
 		}
 	} else {
 		return(-1);
@@ -328,39 +328,39 @@
 /*  add some normal information to the polygon buffer */
 int obj_pep_poly_normal(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,j,m;
+	int32_t i, j, m;
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj)) {
-		m=obj->n_poly;
-		if (m<n)	 /*  saving the first number of polys */
-			n=m;  /*  when more polygons than available should be pepped,  */
+	if (OBJ_VALID(p, oid, obj)) {
+		m = obj->n_poly;
+		if (m < n)  /*  saving the first number of polys */
+			n = m;  /*  when more polygons than available should be pepped,  */
 		/*  just pep the first m polygons */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_pep_poly_normal()","error: no data on object allowed!");
+			errds(MED, "obj_pep_poly_normal()", "error: no data on object allowed!");
 			return(-1);
 		}
 
 		if (obj->dplist) {
-			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-			glDeleteLists(obj->dplist,1);
-			obj->dplist=0;
+			s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+			glDeleteLists(obj->dplist, 1);
+			obj->dplist = 0;
 		}
-		s3dprintf(VLOW,"pepping poly's %d to %d",(m-n),m);
-		for (i=(m-n);i<m;i++) {
-			for (j=0;j<3;j++) {
-				obj->p_poly[i].n[j].x=*(px++);
-				obj->p_poly[i].n[j].y=*(px++);
-				obj->p_poly[i].n[j].z=*(px++);
-				len=sqrt(obj->p_poly[i].n[j].x*obj->p_poly[i].n[j].x + obj->p_poly[i].n[j].y*obj->p_poly[i].n[j].y +obj->p_poly[i].n[j].z*obj->p_poly[i].n[j].z);
-				if (len==0)
-					obj->p_poly[i].n[j].x=obj->p_poly[i].n[j].y=obj->p_poly[i].n[j].z=0;
+		s3dprintf(VLOW, "pepping poly's %d to %d", (m - n), m);
+		for (i = (m - n);i < m;i++) {
+			for (j = 0;j < 3;j++) {
+				obj->p_poly[i].n[j].x = *(px++);
+				obj->p_poly[i].n[j].y = *(px++);
+				obj->p_poly[i].n[j].z = *(px++);
+				len = sqrt(obj->p_poly[i].n[j].x * obj->p_poly[i].n[j].x + obj->p_poly[i].n[j].y * obj->p_poly[i].n[j].y + obj->p_poly[i].n[j].z * obj->p_poly[i].n[j].z);
+				if (len == 0)
+					obj->p_poly[i].n[j].x = obj->p_poly[i].n[j].y = obj->p_poly[i].n[j].z = 0;
 				else {
-					obj->p_poly[i].n[j].x/=len;
-					obj->p_poly[i].n[j].y/=len;
-					obj->p_poly[i].n[j].z/=len;
+					obj->p_poly[i].n[j].x /= len;
+					obj->p_poly[i].n[j].y /= len;
+					obj->p_poly[i].n[j].z /= len;
 				}
 			}
 		}
@@ -372,39 +372,39 @@
 /*  add some normal information to the line buffer */
 int obj_pep_line_normal(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,j,m;
+	int32_t i, j, m;
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj)) {
-		m=obj->n_line;
-		if (m<n)	 /*  saving the first number of lines */
-			n=m;  /*  when more lines than available should be pepped,  */
+	if (OBJ_VALID(p, oid, obj)) {
+		m = obj->n_line;
+		if (m < n)  /*  saving the first number of lines */
+			n = m;  /*  when more lines than available should be pepped,  */
 		/*  just pep the first m liness */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_pep_line_normal()","error: no data on object allowed!");
+			errds(MED, "obj_pep_line_normal()", "error: no data on object allowed!");
 			return(-1);
 		}
 
 		if (obj->dplist) {
-			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-			glDeleteLists(obj->dplist,1);
-			obj->dplist=0;
+			s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+			glDeleteLists(obj->dplist, 1);
+			obj->dplist = 0;
 		}
-		s3dprintf(VLOW,"pepping line's %d to %d",(m-n),m);
-		for (i=(m-n);i<m;i++) {
-			for (j=0;j<2;j++) {
-				obj->p_line[i].n[j].x=*(px++);
-				obj->p_line[i].n[j].y=*(px++);
-				obj->p_line[i].n[j].z=*(px++);
-				len=sqrt(obj->p_line[i].n[j].x*obj->p_line[i].n[j].x + obj->p_line[i].n[j].y*obj->p_line[i].n[j].y +obj->p_line[i].n[j].z*obj->p_line[i].n[j].z);
-				if (len==0)
-					obj->p_line[i].n[j].x=obj->p_line[i].n[j].y=obj->p_line[i].n[j].z=0;
+		s3dprintf(VLOW, "pepping line's %d to %d", (m - n), m);
+		for (i = (m - n);i < m;i++) {
+			for (j = 0;j < 2;j++) {
+				obj->p_line[i].n[j].x = *(px++);
+				obj->p_line[i].n[j].y = *(px++);
+				obj->p_line[i].n[j].z = *(px++);
+				len = sqrt(obj->p_line[i].n[j].x * obj->p_line[i].n[j].x + obj->p_line[i].n[j].y * obj->p_line[i].n[j].y + obj->p_line[i].n[j].z * obj->p_line[i].n[j].z);
+				if (len == 0)
+					obj->p_line[i].n[j].x = obj->p_line[i].n[j].y = obj->p_line[i].n[j].z = 0;
 				else {
-					obj->p_line[i].n[j].x/=len;
-					obj->p_line[i].n[j].y/=len;
-					obj->p_line[i].n[j].z/=len;
+					obj->p_line[i].n[j].x /= len;
+					obj->p_line[i].n[j].y /= len;
+					obj->p_line[i].n[j].z /= len;
 				}
 
 			}
@@ -418,31 +418,31 @@
 /*  add textures coordinates to each vertex of the polygon(s) */
 int obj_pep_poly_texc(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,j,m;
+	int32_t i, j, m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_pep_poly_texc()","error: no data on object allowed!");
+			errds(MED, "obj_pep_poly_texc()", "error: no data on object allowed!");
 			return(-1);
 		}
 
-		m=obj->n_poly;
-		if (m<n)	 /*  saving the first number of polys */
-			n=m;  /*  when more polygons than available should be pepped,  */
+		m = obj->n_poly;
+		if (m < n)  /*  saving the first number of polys */
+			n = m;  /*  when more polygons than available should be pepped,  */
 		/*  just pep the first m polygons */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 
 		if (obj->dplist) {
-			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-			glDeleteLists(obj->dplist,1);
-			obj->dplist=0;
+			s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+			glDeleteLists(obj->dplist, 1);
+			obj->dplist = 0;
 		}
-		s3dprintf(VLOW,"pepping poly's %d to %d",(m-n),m);
-		for (i=(m-n);i<m;i++) {
-			for (j=0;j<3;j++) {
-				obj->p_poly[i].tc[j].x=*(px++);
-				obj->p_poly[i].tc[j].y=*(px++);
+		s3dprintf(VLOW, "pepping poly's %d to %d", (m - n), m);
+		for (i = (m - n);i < m;i++) {
+			for (j = 0;j < 3;j++) {
+				obj->p_poly[i].tc[j].x = *(px++);
+				obj->p_poly[i].tc[j].y = *(px++);
 			}
 		}
 	} else {
@@ -453,38 +453,38 @@
 /*  overwrite n latest materials with some other materials */
 int obj_pep_mat(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj)) {
-		m=obj->n_mat;	 /*  saving the first number of materials */
-		if (m<n)
-			n=m;  /*  when more mats than available should be pepped,  */
+	if (OBJ_VALID(p, oid, obj)) {
+		m = obj->n_mat;  /*  saving the first number of materials */
+		if (m < n)
+			n = m;  /*  when more mats than available should be pepped,  */
 		/*  just pep the first m mats */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_pep_mat()","error: no data on object allowed!");
+			errds(MED, "obj_pep_mat()", "error: no data on object allowed!");
 			return(-1);
 		}
 		if (obj->dplist) {
-			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-			glDeleteLists(obj->dplist,1);
-			obj->dplist=0;
+			s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+			glDeleteLists(obj->dplist, 1);
+			obj->dplist = 0;
 		}
-		s3dprintf(VLOW,"pepping mats %d to %d",(m-n),m);
-		for (i=(m-n);i<m;i++) {
-			obj->p_mat[i].amb_r=*(px++);
-			obj->p_mat[i].amb_g=*(px++);
-			obj->p_mat[i].amb_b=*(px++);
-			obj->p_mat[i].amb_a=*(px++);
-			obj->p_mat[i].spec_r=*(px++);
-			obj->p_mat[i].spec_g=*(px++);
-			obj->p_mat[i].spec_b=*(px++);
-			obj->p_mat[i].spec_a=*(px++);
-			obj->p_mat[i].diff_r=*(px++);
-			obj->p_mat[i].diff_g=*(px++);
-			obj->p_mat[i].diff_b=*(px++);
-			obj->p_mat[i].diff_a=*(px++);
+		s3dprintf(VLOW, "pepping mats %d to %d", (m - n), m);
+		for (i = (m - n);i < m;i++) {
+			obj->p_mat[i].amb_r = *(px++);
+			obj->p_mat[i].amb_g = *(px++);
+			obj->p_mat[i].amb_b = *(px++);
+			obj->p_mat[i].amb_a = *(px++);
+			obj->p_mat[i].spec_r = *(px++);
+			obj->p_mat[i].spec_g = *(px++);
+			obj->p_mat[i].spec_b = *(px++);
+			obj->p_mat[i].spec_a = *(px++);
+			obj->p_mat[i].diff_r = *(px++);
+			obj->p_mat[i].diff_g = *(px++);
+			obj->p_mat[i].diff_b = *(px++);
+			obj->p_mat[i].diff_a = *(px++);
 		}
 	} else {
 		return(-1);
@@ -494,31 +494,31 @@
 /*  overwrite n latest lines with some other lines */
 int obj_pep_line(struct t_process *p, int32_t oid, uint32_t *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj)) {
-		m=obj->n_line;	 /*  saving the first number of lines */
-		if (m<n)
-			n=m;  /*  when more lines than available should be pepped,  */
+	if (OBJ_VALID(p, oid, obj)) {
+		m = obj->n_line;  /*  saving the first number of lines */
+		if (m < n)
+			n = m;  /*  when more lines than available should be pepped,  */
 		/*  just pep the first m lines */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_pep_line()","error: no data on object allowed!");
+			errds(MED, "obj_pep_line()", "error: no data on object allowed!");
 			return(-1);
 		}
 		if (obj->dplist) {
-			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-			glDeleteLists(obj->dplist,1);
-			obj->dplist=0;
+			s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+			glDeleteLists(obj->dplist, 1);
+			obj->dplist = 0;
 		}
-		s3dprintf(VLOW,"pepping lines %d to %d",(m-n),m);
-		for (i=(m-n);i<m;i++) {
-			obj->p_line[i].v[0]=*(px++);
-			obj->p_line[i].v[1]=*(px++);
-			obj->p_line[i].mat=*(px++);
-			obj->p_line[i].n[0].x=obj->p_line[i].n[0].y=obj->p_line[i].n[0].z=0;
-			obj->p_line[i].n[1].x=obj->p_line[i].n[1].y=obj->p_line[i].n[1].z=0;
+		s3dprintf(VLOW, "pepping lines %d to %d", (m - n), m);
+		for (i = (m - n);i < m;i++) {
+			obj->p_line[i].v[0] = *(px++);
+			obj->p_line[i].v[1] = *(px++);
+			obj->p_line[i].mat = *(px++);
+			obj->p_line[i].n[0].x = obj->p_line[i].n[0].y = obj->p_line[i].n[0].z = 0;
+			obj->p_line[i].n[1].x = obj->p_line[i].n[1].y = obj->p_line[i].n[1].z = 0;
 		}
 	} else {
 		return(-1);
@@ -530,57 +530,57 @@
 /*  overwrite n latest vertices with some other vertices */
 int obj_pep_vertex(struct t_process *p, int32_t oid, float *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	float r;
 	struct t_vertex *a;
 	struct t_obj *obj;
 	float *px;
 	int is_clnsrc;
-	if (OBJ_VALID(p,oid,obj)) {
-		m=obj->n_vertex;	 /*  saving the first number of vertices */
-		if (m<n)
-			n=m;  /*  when more mats than available should be pepped,  */
+	if (OBJ_VALID(p, oid, obj)) {
+		m = obj->n_vertex;  /*  saving the first number of vertices */
+		if (m < n)
+			n = m;  /*  when more mats than available should be pepped,  */
 		/*  just pep the first m mats */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_pep_vertices()","error: no data on object allowed!");
+			errds(MED, "obj_pep_vertices()", "error: no data on object allowed!");
 			return(-1);
 		}
 		if (obj->dplist) {
-			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-			glDeleteLists(obj->dplist,1);
-			obj->dplist=0;
+			s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+			glDeleteLists(obj->dplist, 1);
+			obj->dplist = 0;
 		}
-		s3dprintf(VLOW,"pepping vertices %d to %d",(m-n),m-1);
-		for (i=(m-n);i<m;i++) {
-			obj->p_vertex[i].x=*(px++);
-			obj->p_vertex[i].y=*(px++);
-			obj->p_vertex[i].z=*(px++);
-			a=&obj->p_vertex[i];
-			r=obj->scale * sqrt(
-			          (a->x * a->x ) +
-			          (a->y * a->y ) +
-			          (a->z * a->z ));
-			if (r> obj->r) obj->r=r;
+		s3dprintf(VLOW, "pepping vertices %d to %d", (m - n), m - 1);
+		for (i = (m - n);i < m;i++) {
+			obj->p_vertex[i].x = *(px++);
+			obj->p_vertex[i].y = *(px++);
+			obj->p_vertex[i].z = *(px++);
+			a = &obj->p_vertex[i];
+			r = obj->scale * sqrt(
+			            (a->x * a->x) +
+			            (a->y * a->y) +
+			            (a->z * a->z));
+			if (r > obj->r) obj->r = r;
 		}
-		if (p->id!=MCP) {
+		if (p->id != MCP) {
 			/* this is doing live update which is quite okay, but we need
 			 * to check for biggest update and clonesources ... */
-			obj_check_biggest_object(p,oid);
+			obj_check_biggest_object(p, oid);
 		}
 		if (p->object[oid]->oflags&OF_CLONE_SRC) {
-			is_clnsrc=0;
-			for (i=0;i<p->n_obj;i++) {
-				if (p->object[i]!=NULL) {
-					if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid)) { /* if it's pointing to our object ... */
-						is_clnsrc=1;
-						p->object[i]->r=obj->r*(p->object[i]->r/obj->scale); /* give it the new radius too! */
-						obj_check_biggest_object(p,i);
+			is_clnsrc = 0;
+			for (i = 0;i < p->n_obj;i++) {
+				if (p->object[i] != NULL) {
+					if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex == oid)) { /* if it's pointing to our object ... */
+						is_clnsrc = 1;
+						p->object[i]->r = obj->r * (p->object[i]->r / obj->scale); /* give it the new radius too! */
+						obj_check_biggest_object(p, i);
 					}
 				}
 			}
 			if (!is_clnsrc)
-				p->object[oid]->oflags&=~OF_CLONE_SRC;
+				p->object[oid]->oflags &= ~OF_CLONE_SRC;
 		}
 	} else {
 		return(-1);
@@ -590,27 +590,27 @@
 /*  assign textures to the last n materials */
 int obj_pep_mat_tex(struct t_process *p, int32_t oid, uint32_t *x, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_obj *obj;
 	uint32_t *px;
-	if (OBJ_VALID(p,oid,obj)) {
-		m=obj->n_mat;	 /*  saving the first number of vertices */
-		if (m<n)	 /*  saving the first number of polys */
-			n=m;  /*  when more mats than available should be pepped,  */
+	if (OBJ_VALID(p, oid, obj)) {
+		m = obj->n_mat;  /*  saving the first number of vertices */
+		if (m < n)  /*  saving the first number of polys */
+			n = m;  /*  when more mats than available should be pepped,  */
 		/*  just pep the first m mats */
-		px=x; 				 /*  movable pointer for x, later */
+		px = x;    /*  movable pointer for x, later */
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_pep_mat_tex()","error: no data on object allowed!");
+			errds(MED, "obj_pep_mat_tex()", "error: no data on object allowed!");
 			return(-1);
 		}
 		if (obj->dplist) {
-			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-			glDeleteLists(obj->dplist,1);
-			obj->dplist=0;
+			s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+			glDeleteLists(obj->dplist, 1);
+			obj->dplist = 0;
 		}
-		s3dprintf(MED,"pepping mats %d to %d",(m-n),m);
-		for (i=(m-n);i<m;i++)
-			obj->p_mat[i].tex=*(px++);
+		s3dprintf(MED, "pepping mats %d to %d", (m - n), m);
+		for (i = (m - n);i < m;i++)
+			obj->p_mat[i].tex = *(px++);
 	} else {
 		return(-1);
 	}
@@ -619,38 +619,38 @@
 /*  add some normal information to the polygon buffer */
 int obj_load_poly_normal(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n)
 {
-	int32_t i,j,m;
+	int32_t i, j, m;
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (start < 0) return(-1);
-		m=obj->n_poly;
-		if (m<(start+n))
-			n=m-start;
-		px=x;
+		m = obj->n_poly;
+		if (m < (start + n))
+			n = m - start;
+		px = x;
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_load_poly_normal()","error: no data on object allowed!");
+			errds(MED, "obj_load_poly_normal()", "error: no data on object allowed!");
 			return(-1);
 		}
 
 		if (obj->dplist) {
-			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-			glDeleteLists(obj->dplist,1);
-			obj->dplist=0;
+			s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+			glDeleteLists(obj->dplist, 1);
+			obj->dplist = 0;
 		}
-		for (i=start;i<(start+n);i++) {
-			for (j=0;j<3;j++) {
-				obj->p_poly[i].n[j].x=*(px++);
-				obj->p_poly[i].n[j].y=*(px++);
-				obj->p_poly[i].n[j].z=*(px++);
-				len=sqrt(obj->p_poly[i].n[j].x*obj->p_poly[i].n[j].x + obj->p_poly[i].n[j].y*obj->p_poly[i].n[j].y +obj->p_poly[i].n[j].z*obj->p_poly[i].n[j].z);
-				if (len==0)
-					obj->p_poly[i].n[j].x=obj->p_poly[i].n[j].y=obj->p_poly[i].n[j].z=0;
+		for (i = start;i < (start + n);i++) {
+			for (j = 0;j < 3;j++) {
+				obj->p_poly[i].n[j].x = *(px++);
+				obj->p_poly[i].n[j].y = *(px++);
+				obj->p_poly[i].n[j].z = *(px++);
+				len = sqrt(obj->p_poly[i].n[j].x * obj->p_poly[i].n[j].x + obj->p_poly[i].n[j].y * obj->p_poly[i].n[j].y + obj->p_poly[i].n[j].z * obj->p_poly[i].n[j].z);
+				if (len == 0)
+					obj->p_poly[i].n[j].x = obj->p_poly[i].n[j].y = obj->p_poly[i].n[j].z = 0;
 				else {
-					obj->p_poly[i].n[j].x/=len;
-					obj->p_poly[i].n[j].y/=len;
-					obj->p_poly[i].n[j].z/=len;
+					obj->p_poly[i].n[j].x /= len;
+					obj->p_poly[i].n[j].y /= len;
+					obj->p_poly[i].n[j].z /= len;
 				}
 
 			}
@@ -662,38 +662,38 @@
 /*  add some normal information to the line  buffer */
 int obj_load_line_normal(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n)
 {
-	int32_t i,j,m;
+	int32_t i, j, m;
 	struct t_obj *obj;
 	float *px;
 	float len;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (start < 0) return(-1);
-		m=obj->n_line;
-		if (m<(start+n))
-			n=m-start;
-		px=x;
+		m = obj->n_line;
+		if (m < (start + n))
+			n = m - start;
+		px = x;
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_load_line_normal()","error: no data on object allowed!");
+			errds(MED, "obj_load_line_normal()", "error: no data on object allowed!");
 			return(-1);
 		}
 
 		if (obj->dplist) {
-			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-			glDeleteLists(obj->dplist,1);
-			obj->dplist=0;
+			s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+			glDeleteLists(obj->dplist, 1);
+			obj->dplist = 0;
 		}
-		for (i=start;i<(start+n);i++) {
-			for (j=0;j<2;j++) {
-				obj->p_line[i].n[j].x=*(px++);
-				obj->p_line[i].n[j].y=*(px++);
-				obj->p_line[i].n[j].z=*(px++);
-				len=sqrt(obj->p_line[i].n[j].x*obj->p_line[i].n[j].x + obj->p_line[i].n[j].y*obj->p_line[i].n[j].y +obj->p_line[i].n[j].z*obj->p_line[i].n[j].z);
-				if (len==0)
-					obj->p_line[i].n[j].x=obj->p_line[i].n[j].y=obj->p_line[i].n[j].z=0;
+		for (i = start;i < (start + n);i++) {
+			for (j = 0;j < 2;j++) {
+				obj->p_line[i].n[j].x = *(px++);
+				obj->p_line[i].n[j].y = *(px++);
+				obj->p_line[i].n[j].z = *(px++);
+				len = sqrt(obj->p_line[i].n[j].x * obj->p_line[i].n[j].x + obj->p_line[i].n[j].y * obj->p_line[i].n[j].y + obj->p_line[i].n[j].z * obj->p_line[i].n[j].z);
+				if (len == 0)
+					obj->p_line[i].n[j].x = obj->p_line[i].n[j].y = obj->p_line[i].n[j].z = 0;
 				else {
-					obj->p_line[i].n[j].x/=len;
-					obj->p_line[i].n[j].y/=len;
-					obj->p_line[i].n[j].z/=len;
+					obj->p_line[i].n[j].x /= len;
+					obj->p_line[i].n[j].y /= len;
+					obj->p_line[i].n[j].z /= len;
 				}
 
 			}
@@ -705,29 +705,29 @@
 /*  add textures coordinates to each vertex of the polygon(s) */
 int obj_load_poly_texc(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n)
 {
-	int32_t i,j,m;
+	int32_t i, j, m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (start < 0) return(-1);
-		m=obj->n_poly;
-		if (m<(start+n))
-			n=m-start;
-		px=x; 				 /*  movable pointer for x, later */
+		m = obj->n_poly;
+		if (m < (start + n))
+			n = m - start;
+		px = x;    /*  movable pointer for x, later */
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_load_poly_texc()","error: no data on object allowed!");
+			errds(MED, "obj_load_poly_texc()", "error: no data on object allowed!");
 			return(-1);
 		}
 
 		if (obj->dplist) {
-			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-			glDeleteLists(obj->dplist,1);
-			obj->dplist=0;
+			s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+			glDeleteLists(obj->dplist, 1);
+			obj->dplist = 0;
 		}
-		for (i=start;i<(start+n);i++) {
-			for (j=0;j<3;j++) {
-				obj->p_poly[i].tc[j].x=*(px++);
-				obj->p_poly[i].tc[j].y=*(px++);
+		for (i = start;i < (start + n);i++) {
+			for (j = 0;j < 3;j++) {
+				obj->p_poly[i].tc[j].x = *(px++);
+				obj->p_poly[i].tc[j].y = *(px++);
 			}
 		}
 	} else
@@ -739,98 +739,98 @@
 /*  load at position start n materials, overwriting old ones */
 int obj_load_mat(struct t_process *p, int32_t oid, float *x, int32_t start, int32_t n)
 {
-	int32_t i,m;
+	int32_t i, m;
 	struct t_obj *obj;
 	float *px;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (start < 0) return(-1);
-		m=obj->n_mat;
-		if (m<(start+n))
-			n=m-start;
-		px=x; 				 /*  movable pointer for x, later */
+		m = obj->n_mat;
+		if (m < (start + n))
+			n = m - start;
+		px = x;    /*  movable pointer for x, later */
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_pep_mat()","error: no data on object allowed!");
+			errds(MED, "obj_pep_mat()", "error: no data on object allowed!");
 			return(-1);
 		}
 		if (obj->dplist) {
-			s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-			glDeleteLists(obj->dplist,1);
-			obj->dplist=0;
+			s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+			glDeleteLists(obj->dplist, 1);
+			obj->dplist = 0;
 		}
-		s3dprintf(MED,"pepping %d mats, starting at %d",n,start);
-		for (i=start;i<(start+n);i++) {
-			obj->p_mat[i].amb_r=*(px++);
-			obj->p_mat[i].amb_g=*(px++);
-			obj->p_mat[i].amb_b=*(px++);
-			obj->p_mat[i].amb_a=*(px++);
-			obj->p_mat[i].spec_r=*(px++);
-			obj->p_mat[i].spec_g=*(px++);
-			obj->p_mat[i].spec_b=*(px++);
-			obj->p_mat[i].spec_a=*(px++);
-			obj->p_mat[i].diff_r=*(px++);
-			obj->p_mat[i].diff_g=*(px++);
-			obj->p_mat[i].diff_b=*(px++);
-			obj->p_mat[i].diff_a=*(px++);
+		s3dprintf(MED, "pepping %d mats, starting at %d", n, start);
+		for (i = start;i < (start + n);i++) {
+			obj->p_mat[i].amb_r = *(px++);
+			obj->p_mat[i].amb_g = *(px++);
+			obj->p_mat[i].amb_b = *(px++);
+			obj->p_mat[i].amb_a = *(px++);
+			obj->p_mat[i].spec_r = *(px++);
+			obj->p_mat[i].spec_g = *(px++);
+			obj->p_mat[i].spec_b = *(px++);
+			obj->p_mat[i].spec_a = *(px++);
+			obj->p_mat[i].diff_r = *(px++);
+			obj->p_mat[i].diff_g = *(px++);
+			obj->p_mat[i].diff_b = *(px++);
+			obj->p_mat[i].diff_a = *(px++);
 		}
 	} else
 		return(-1);
 	return(0);
 }
 /* the interal texture updating function ... this is for opengl*/
-static void obj_update_tex(struct t_tex *tex,u_int16_t S3DUNUSED(x),u_int16_t S3DUNUSED(y),u_int16_t S3DUNUSED(w),u_int16_t S3DUNUSED(h),u_int8_t *S3DUNUSED(pixbuf))
+static void obj_update_tex(struct t_tex *tex, u_int16_t S3DUNUSED(x), u_int16_t S3DUNUSED(y), u_int16_t S3DUNUSED(w), u_int16_t S3DUNUSED(h), u_int8_t *S3DUNUSED(pixbuf))
 {
 	GLuint t;
-	if ((tex->gl_texnum)!=-1) {
-		t= tex->gl_texnum;
+	if ((tex->gl_texnum) != -1) {
+		t = tex->gl_texnum;
 		/* s3dprintf(MED,"updating texture %d at [%d %d] with a [%d %d] pixbuf",t,x,y,w,h); */
-		/* 		glTexSubImage2D(t,0,x,y,w,h,GL_RGBA,GL_UNSIGNED_BYTE,pixbuf); */
+		/*   glTexSubImage2D(t,0,x,y,w,h,GL_RGBA,GL_UNSIGNED_BYTE,pixbuf); */
 
-		glDeleteTextures(1,&t);
-		tex->gl_texnum=-1;
+		glDeleteTextures(1, &t);
+		tex->gl_texnum = -1;
 	}
 }
 /*  loads some data into the pixbuf */
-int obj_load_tex		(struct t_process *p, int32_t oid, int32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf)
+int obj_load_tex(struct t_process *p, int32_t oid, int32_t tex, uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t *pixbuf)
 {
 	struct t_obj *obj;
 	struct t_tex *t;
-	int32_t i,p1,p2,m;
+	int32_t i, p1, p2, m;
 	int16_t mw;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_load_tex()","error: no data on object allowed!");
+			errds(MED, "obj_load_tex()", "error: no data on object allowed!");
 			return(-1);
 		}
-		if ( tex < 0 ) return(-1);
-		if ( tex < obj->n_tex) {
-			t=&obj->p_tex[tex];
-			if (t->buf!=NULL) {
+		if (tex < 0) return(-1);
+		if (tex < obj->n_tex) {
+			t = &obj->p_tex[tex];
+			if (t->buf != NULL) {
 				if (obj->dplist) {
-					s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-					glDeleteLists(obj->dplist,1);
-					obj->dplist=0;
+					s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+					glDeleteLists(obj->dplist, 1);
+					obj->dplist = 0;
 				}
 
-				m=(t->w-1)*t->th+t->tw; 			 /*  maximum: position of the last pixel in the buffer */
-				if ((x+w)>t->tw) mw=(t->tw-x);
-				else mw=w;
-				if (mw<=0)	 /*  nothing to do */
+				m = (t->w - 1) * t->th + t->tw;     /*  maximum: position of the last pixel in the buffer */
+				if ((x + w) > t->tw) mw = (t->tw - x);
+				else mw = w;
+				if (mw <= 0)  /*  nothing to do */
 					return(-1);
-				for (i=0;i<h;i++) {
-					p1=(y+i)*t->w+x;  /*  scanline start position */
-					p2=mw;			 /*  and length */
-					if (p1>m)
+				for (i = 0;i < h;i++) {
+					p1 = (y + i) * t->w + x;  /*  scanline start position */
+					p2 = mw;  /*  and length */
+					if (p1 > m)
 						return(0);   /*  need to break here. */
-					if ((p1+w)>m)
-						p2=m-p1;	 /*  only draw a part of the scanline */
-					memcpy(	t->buf+	4*p1,			 /*  draw at p1 position ... */
-					        pixbuf+	4*i*w,			 /*  scanline number i ... */
-					        4*p2);
+					if ((p1 + w) > m)
+						p2 = m - p1;  /*  only draw a part of the scanline */
+					memcpy(t->buf + 4*p1,    /*  draw at p1 position ... */
+					       pixbuf + 4*i*w,   /*  scanline number i ... */
+					       4*p2);
 				}
-				obj_update_tex(t,x,y,w,h,pixbuf);
+				obj_update_tex(t, x, y, w, h, pixbuf);
 				return(0);
 			} else {
-				errds(HIGH,"obj_load_tex()","no buffer to draw to in oid %d, texture %d",oid,tex);
+				errds(HIGH, "obj_load_tex()", "no buffer to draw to in oid %d, texture %d", oid, tex);
 			}
 		}
 	}
@@ -841,22 +841,22 @@
 	struct t_obj *obj;
 	uint32_t f;
 
-	f=flags&OF_MASK;
-	if (OBJ_VALID(p,oid,obj)) {
+	f = flags & OF_MASK;
+	if (OBJ_VALID(p, oid, obj)) {
 		switch (type) {
 		case OF_TURN_ON:
-			obj->oflags|=f;
+			obj->oflags |= f;
 			break;
 		case OF_TURN_OFF:
-			obj->oflags&=~f;
+			obj->oflags &= ~f;
 			break;
 		case OF_TURN_SWAP:
-			obj->oflags^=f;
+			obj->oflags ^= f;
 			break;
 		default:
 			return(-1);
 		}
-		/* 		s3dprintf(VLOW,"toggled %d->oflags=%010x with %010x [%d]",oid,obj->oflags,flags,type); */
+		/*   s3dprintf(VLOW,"toggled %d->oflags=%010x with %010x [%d]",oid,obj->oflags,flags,type); */
 	}
 	return(0);
 }
@@ -866,31 +866,31 @@
 	int32_t m;
 	struct t_vertex *p_vertex;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_del_vertex()","error: can't delete vertices in this object!");
+			errds(MED, "obj_del_vertex()", "error: can't delete vertices in this object!");
 			return(-1);
 		}
 
-		s3dprintf(VLOW,"deleting %d vertices of pid %d/ oid %d",n,p->id,oid);
-		m=obj->n_vertex;	 /*  saving the first number of vertices */
-		if (n>=m) {
-			if (m>0)
+		s3dprintf(VLOW, "deleting %d vertices of pid %d/ oid %d", n, p->id, oid);
+		m = obj->n_vertex;  /*  saving the first number of vertices */
+		if (n >= m) {
+			if (m > 0)
 				free(obj->p_vertex);
-			obj->n_vertex=0;
-			obj->p_vertex=NULL;
-		} else if (n>0) {
-			if (NULL!=(p_vertex=realloc(obj->p_vertex,sizeof(struct t_vertex) * ( m - n)))) {
+			obj->n_vertex = 0;
+			obj->p_vertex = NULL;
+		} else if (n > 0) {
+			if (NULL != (p_vertex = realloc(obj->p_vertex, sizeof(struct t_vertex) * (m - n)))) {
 				if (obj->dplist) {
-					s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-					glDeleteLists(obj->dplist,1);
-					obj->dplist=0;
+					s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+					glDeleteLists(obj->dplist, 1);
+					obj->dplist = 0;
 				}
-				obj->p_vertex=p_vertex;
-				obj->n_vertex-=n;
+				obj->p_vertex = p_vertex;
+				obj->n_vertex -= n;
 			}
 		}
-		obj_size_update(p,oid);
+		obj_size_update(p, oid);
 	} else {
 		return(-1);
 	}
@@ -902,28 +902,28 @@
 	int32_t m;
 	struct t_mat *p_mat;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_del_mat()","error: can't delete materials in this object!");
+			errds(MED, "obj_del_mat()", "error: can't delete materials in this object!");
 			return(-1);
 		}
 
-		s3dprintf(VLOW,"deleting %d materials of pid %d/ oid %d",n,p->id,oid);
-		m=obj->n_mat;	 /*  saving the first number of materials */
-		if (n>=m) {
-			if (m>0)
+		s3dprintf(VLOW, "deleting %d materials of pid %d/ oid %d", n, p->id, oid);
+		m = obj->n_mat;  /*  saving the first number of materials */
+		if (n >= m) {
+			if (m > 0)
 				free(obj->p_mat);
-			obj->n_mat=0;
-			obj->p_mat=NULL;
-		} else if (n>0)
-			if (NULL!=(p_mat=realloc(obj->p_mat,sizeof(struct t_mat) * ( m - n)))) {
+			obj->n_mat = 0;
+			obj->p_mat = NULL;
+		} else if (n > 0)
+			if (NULL != (p_mat = realloc(obj->p_mat, sizeof(struct t_mat) * (m - n)))) {
 				if (obj->dplist) {
-					s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-					glDeleteLists(obj->dplist,1);
-					obj->dplist=0;
+					s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+					glDeleteLists(obj->dplist, 1);
+					obj->dplist = 0;
 				}
-				obj->p_mat=p_mat;
-				obj->n_mat-=n;
+				obj->p_mat = p_mat;
+				obj->n_mat -= n;
 			}
 	} else
 		return(-1);
@@ -935,28 +935,28 @@
 	int32_t m;
 	struct t_poly *p_poly;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_del_poly()","error: can't delete poly in this object!");
+			errds(MED, "obj_del_poly()", "error: can't delete poly in this object!");
 			return(-1);
 		}
 
-		s3dprintf(VLOW,"deleting %d polys of pid %d/ oid %d",n,p->id,oid);
-		m=obj->n_poly;	 /*  saving the first number of poly  */
-		if (n>=m) {
-			if (m>0)
+		s3dprintf(VLOW, "deleting %d polys of pid %d/ oid %d", n, p->id, oid);
+		m = obj->n_poly;  /*  saving the first number of poly  */
+		if (n >= m) {
+			if (m > 0)
 				free(obj->p_poly);
-			obj->n_poly=0;
-			obj->p_poly=NULL;
-		} else if (n>0)
-			if (NULL!=(p_poly=realloc(obj->p_poly,sizeof(struct t_poly) * ( m - n)))) {
+			obj->n_poly = 0;
+			obj->p_poly = NULL;
+		} else if (n > 0)
+			if (NULL != (p_poly = realloc(obj->p_poly, sizeof(struct t_poly) * (m - n)))) {
 				if (obj->dplist) {
-					s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-					glDeleteLists(obj->dplist,1);
-					obj->dplist=0;
+					s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+					glDeleteLists(obj->dplist, 1);
+					obj->dplist = 0;
 				}
-				obj->p_poly=p_poly;
-				obj->n_poly-=n;
+				obj->p_poly = p_poly;
+				obj->n_poly -= n;
 			}
 	} else
 		return(-1);
@@ -968,28 +968,28 @@
 	int32_t m;
 	struct t_line *p_line;
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_del_line()","error: can't delete line in this object!");
+			errds(MED, "obj_del_line()", "error: can't delete line in this object!");
 			return(-1);
 		}
 
-		s3dprintf(VLOW,"deleting %d lines of pid %d/ oid %d",n,p->id,oid);
-		m=obj->n_line;	 /*  saving the first number of line  */
-		if (n>=m) {
-			if (m>0)
+		s3dprintf(VLOW, "deleting %d lines of pid %d/ oid %d", n, p->id, oid);
+		m = obj->n_line;  /*  saving the first number of line  */
+		if (n >= m) {
+			if (m > 0)
 				free(obj->p_line);
-			obj->n_line=0;
-			obj->p_line=NULL;
-		} else if (n>0)
-			if (NULL!=(p_line=realloc(obj->p_line,sizeof(struct t_line) * ( m - n)))) {
+			obj->n_line = 0;
+			obj->p_line = NULL;
+		} else if (n > 0)
+			if (NULL != (p_line = realloc(obj->p_line, sizeof(struct t_line) * (m - n)))) {
 				if (obj->dplist) {
-					s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-					glDeleteLists(obj->dplist,1);
-					obj->dplist=0;
+					s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+					glDeleteLists(obj->dplist, 1);
+					obj->dplist = 0;
 				}
-				obj->p_line=p_line;
-				obj->n_line-=n;
+				obj->p_line = p_line;
+				obj->n_line -= n;
 			}
 	} else
 		return(-1);
@@ -1003,45 +1003,45 @@
 	struct t_tex *p_tex;
 	struct t_obj *obj;
 	GLuint t;
-	if (OBJ_VALID(p,oid,obj)) {
+	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
-			errds(MED,"obj_del_tex()","error: can't delete textures in this object!");
+			errds(MED, "obj_del_tex()", "error: can't delete textures in this object!");
 			return(-1);
 		}
 
-		s3dprintf(VLOW,"deleting %d textures of pid %d/ oid %d",n,p->id,oid);
-		m=obj->n_tex;	 /*  saving the first number of textures  */
-		if (n>=m) {
-			for (i=0;i<m;i++) {
-				if ((obj->p_tex[i].buf)!=NULL)
+		s3dprintf(VLOW, "deleting %d textures of pid %d/ oid %d", n, p->id, oid);
+		m = obj->n_tex;  /*  saving the first number of textures  */
+		if (n >= m) {
+			for (i = 0;i < m;i++) {
+				if ((obj->p_tex[i].buf) != NULL)
 					free(obj->p_tex[i].buf);
 				if (obj->p_tex[i].gl_texnum) {
-					t=obj->p_tex[i].gl_texnum;
-					glDeleteTextures(1,&t);
+					t = obj->p_tex[i].gl_texnum;
+					glDeleteTextures(1, &t);
 				}
 			}
-			if (m>0)
+			if (m > 0)
 				free(obj->p_tex);
-			obj->n_tex=0;
-			obj->p_tex=NULL;
-		} else if (n>0) {
-			for (i=(m-n);i<m;i++) {
-				if (obj->p_tex[i].buf!=NULL)
+			obj->n_tex = 0;
+			obj->p_tex = NULL;
+		} else if (n > 0) {
+			for (i = (m - n);i < m;i++) {
+				if (obj->p_tex[i].buf != NULL)
 					free(obj->p_tex[i].buf);
 				if (obj->p_tex[i].gl_texnum) {
-					t=obj->p_tex[i].gl_texnum;
-					glDeleteTextures(1,&t);
+					t = obj->p_tex[i].gl_texnum;
+					glDeleteTextures(1, &t);
 				}
 
 			}
-			if (NULL!=(p_tex=realloc(obj->p_tex,sizeof(struct t_tex) * ( m - n)))) {
+			if (NULL != (p_tex = realloc(obj->p_tex, sizeof(struct t_tex) * (m - n)))) {
 				if (obj->dplist) {
-					s3dprintf(VLOW,"freeing display list %d to get new data",obj->dplist);
-					glDeleteLists(obj->dplist,1);
-					obj->dplist=0;
+					s3dprintf(VLOW, "freeing display list %d to get new data", obj->dplist);
+					glDeleteLists(obj->dplist, 1);
+					obj->dplist = 0;
 				}
-				obj->p_tex=p_tex;
-				obj->n_tex=n;
+				obj->p_tex = p_tex;
+				obj->n_tex = n;
 			}
 		}
 	} else
@@ -1053,32 +1053,32 @@
 int obj_translate(struct t_process *p, int32_t oid, float *transv)
 {
 	struct t_obj *obj;
-	struct t_process *mcp_p=get_proc_by_pid(MCP);
+	struct t_process *mcp_p = get_proc_by_pid(MCP);
 	float v[3];
-	if (OBJ_VALID(p,oid,obj)) {
-		if (isnan(transv[0])||isinf(transv[0])) return(-1);
-		if (isnan(transv[1])||isinf(transv[1])) return(-1);
-		if (isnan(transv[2])||isinf(transv[2])) return(-1);
-		if ((p->id!=MCP) && (obj->oflags&OF_SYSTEM)) {
-			if (focus_oid==p->mcp_oid) {
-				v[0]=transv[0];
-				v[1]=transv[1];
-				v[2]=transv[2];
+	if (OBJ_VALID(p, oid, obj)) {
+		if (isnan(transv[0]) || isinf(transv[0])) return(-1);
+		if (isnan(transv[1]) || isinf(transv[1])) return(-1);
+		if (isnan(transv[2]) || isinf(transv[2])) return(-1);
+		if ((p->id != MCP) && (obj->oflags&OF_SYSTEM)) {
+			if (focus_oid == p->mcp_oid) {
+				v[0] = transv[0];
+				v[1] = transv[1];
+				v[2] = transv[2];
 				mySetMatrix(mcp_p->object[p->mcp_oid]->m);
 				myTransform3f(v);
-				/*				mySetMatrix(mcp_p->object[oid]->m);
-								myInvert();
-								myTransform3f(v);
-								s3dprintf(LOW,"%3.3f %3.3f %3.3f",v[0],v[1],v[2]);*/
-				obj_translate(mcp_p,oid,v);
+				/*    mySetMatrix(mcp_p->object[oid]->m);
+				    myInvert();
+				    myTransform3f(v);
+				    s3dprintf(LOW,"%3.3f %3.3f %3.3f",v[0],v[1],v[2]);*/
+				obj_translate(mcp_p, oid, v);
 			}
 		} else {
-			obj->translate.x=*transv;
-			obj->translate.y=*(transv+1);
-			obj->translate.z=*(transv+2);
-			obj_pos_update(p,oid,oid);
+			obj->translate.x = *transv;
+			obj->translate.y = *(transv + 1);
+			obj->translate.z = *(transv + 2);
+			obj_pos_update(p, oid, oid);
 		}
-		s3dprintf(VLOW,"[translate|pid %d] %d: %3.3f %3.3f %3.3f",p->id,oid,obj->translate.x,obj->translate.y,obj->translate.z);
+		s3dprintf(VLOW, "[translate|pid %d] %d: %3.3f %3.3f %3.3f", p->id, oid, obj->translate.x, obj->translate.y, obj->translate.z);
 	}
 	return(0);
 }
@@ -1086,36 +1086,36 @@
 int obj_rotate(struct t_process *p, int32_t oid, float *rotv)
 {
 	struct t_obj *obj;
-	struct t_process *mcp_p=get_proc_by_pid(MCP);
+	struct t_process *mcp_p = get_proc_by_pid(MCP);
 	float v[3];
 	float f;
-	if (OBJ_VALID(p,oid,obj)) {
-		if (isnan(rotv[0])||isinf(rotv[0])) return(-1);
-		if (isnan(rotv[1])||isinf(rotv[1])) return(-1);
-		if (isnan(rotv[2])||isinf(rotv[2])) return(-1);
-		if ((p->id!=MCP) && (obj->oflags&OF_SYSTEM)) {
-			if (focus_oid==p->mcp_oid) {
-				v[0]=obj->rotate.x + (rotv[0] - obj->rotate.x);
-				v[1]=obj->rotate.y + (rotv[1] - obj->rotate.y);
-				v[2]=obj->rotate.z + (rotv[2] - obj->rotate.z);
-				obj_rotate(mcp_p,oid,v);
+	if (OBJ_VALID(p, oid, obj)) {
+		if (isnan(rotv[0]) || isinf(rotv[0])) return(-1);
+		if (isnan(rotv[1]) || isinf(rotv[1])) return(-1);
+		if (isnan(rotv[2]) || isinf(rotv[2])) return(-1);
+		if ((p->id != MCP) && (obj->oflags&OF_SYSTEM)) {
+			if (focus_oid == p->mcp_oid) {
+				v[0] = obj->rotate.x + (rotv[0] - obj->rotate.x);
+				v[1] = obj->rotate.y + (rotv[1] - obj->rotate.y);
+				v[2] = obj->rotate.z + (rotv[2] - obj->rotate.z);
+				obj_rotate(mcp_p, oid, v);
 			}
 		} else {
-			f=*rotv;
-			if (f<0.0)		f+=(float)((int)-f/360)*360;
-			if (f>360.0)	f+=(float)((int)f/360)*-360;
-			obj->rotate.x=f;
-			f=*(rotv+1);
-			if (f<0.0)		f+=(float)((int)-f/360)*360;
-			if (f>360.0)	f+=(float)((int)f/360)*-360;
-			obj->rotate.y=f;
-			f=*(rotv+2);
-			if (f<0.0)		f+=(float)((int)-f/360)*360;
-			if (f>360.0)	f+=(float)((int)f/360)*-360;
-			obj->rotate.z=f;
-			obj_pos_update(p,oid,oid);
+			f = *rotv;
+			if (f < 0.0)  f += (float)((int) - f / 360) * 360;
+			if (f > 360.0) f += (float)((int)f / 360) * -360;
+			obj->rotate.x = f;
+			f = *(rotv + 1);
+			if (f < 0.0)  f += (float)((int) - f / 360) * 360;
+			if (f > 360.0) f += (float)((int)f / 360) * -360;
+			obj->rotate.y = f;
+			f = *(rotv + 2);
+			if (f < 0.0)  f += (float)((int) - f / 360) * 360;
+			if (f > 360.0) f += (float)((int)f / 360) * -360;
+			obj->rotate.z = f;
+			obj_pos_update(p, oid, oid);
 		}
-		s3dprintf(VLOW,"[rotate|pid %d] %d: %3.3f %3.3f %3.3f",p->id,oid,obj->rotate.x,obj->rotate.y,obj->rotate.z);
+		s3dprintf(VLOW, "[rotate|pid %d] %d: %3.3f %3.3f %3.3f", p->id, oid, obj->rotate.x, obj->rotate.y, obj->rotate.z);
 	}
 	return(0);
 }
@@ -1123,16 +1123,16 @@
 int obj_scale(struct t_process *p, int32_t oid, float scav)
 {
 	struct t_obj *obj;
-	if (OBJ_VALID(p,oid,obj)) {
-		if ((p->id==MCP) || (!(obj->oflags&OF_SYSTEM)))
-			if (!isinf(scav) && !isnan(scav) && !((scav<1.0e-10) && (scav>-1.0e-10))) { /* ignore very low values */
-				s3dprintf(VLOW,"[scale|pid %d] obj %d to %f",p->id,oid,scav);
-				obj->scale=scav;
-				/*		obj->scale.x=*scav;
-						obj->scale.y=*(scav+1);
-						obj->scale.z=*(scav+2);*/
-				obj_size_update(p,oid);
-				obj_pos_update(p,oid,oid);
+	if (OBJ_VALID(p, oid, obj)) {
+		if ((p->id == MCP) || (!(obj->oflags&OF_SYSTEM)))
+			if (!isinf(scav) && !isnan(scav) && !((scav < 1.0e-10) && (scav > -1.0e-10))) { /* ignore very low values */
+				s3dprintf(VLOW, "[scale|pid %d] obj %d to %f", p->id, oid, scav);
+				obj->scale = scav;
+				/*  obj->scale.x=*scav;
+				  obj->scale.y=*(scav+1);
+				  obj->scale.z=*(scav+2);*/
+				obj_size_update(p, oid);
+				obj_pos_update(p, oid, oid);
 			}
 	}
 	return(0);
@@ -1141,70 +1141,70 @@
 void into_position(struct t_process *p, struct t_obj *obj, int depth)
 {
 	struct t_obj *on;
-	if ((obj->oflags&OF_LINK) && (depth<p->n_obj)) {
+	if ((obj->oflags&OF_LINK) && (depth < p->n_obj)) {
 		/* TODO: only MultMatrix if m_uptodate ?! */
-		if (OBJ_VALID(p,obj->linkid,on)) {
-			into_position(p,on,depth+1);
+		if (OBJ_VALID(p, obj->linkid, on)) {
+			into_position(p, on, depth + 1);
 		} else {
-			obj->oflags&=~OF_LINK;
-			s3dprintf(LOW,"link object is broken, removing link");
+			obj->oflags &= ~OF_LINK;
+			s3dprintf(LOW, "link object is broken, removing link");
 		}
 	}
 	/* if (depth>=MAXLOOP) */
-	if (depth>=p->n_obj)
-		s3dprintf(MED,"too much looping ...");
-	glTranslatef(obj->translate.x,obj->translate.y,obj->translate.z);
-	glRotatef(obj->rotate.y,0.0,1.0,0.0);
-	glRotatef(obj->rotate.x,1.0,0.0,0.0);
-	glRotatef(obj->rotate.z,0.0,0.0,1.0);
-	/*	glScalef(obj->scale.x,obj->scale.y,obj->scale.z);*/
-	glScalef(obj->scale,obj->scale,obj->scale);
+	if (depth >= p->n_obj)
+		s3dprintf(MED, "too much looping ...");
+	glTranslatef(obj->translate.x, obj->translate.y, obj->translate.z);
+	glRotatef(obj->rotate.y, 0.0, 1.0, 0.0);
+	glRotatef(obj->rotate.x, 1.0, 0.0, 0.0);
+	glRotatef(obj->rotate.z, 0.0, 0.0, 1.0);
+	/* glScalef(obj->scale.x,obj->scale.y,obj->scale.z);*/
+	glScalef(obj->scale, obj->scale, obj->scale);
 }
 
 void obj_size_update(struct t_process *p, int32_t oid)
 {
-	struct t_obj *o,*o2;
-	struct t_vertex *a,*vp;
+	struct t_obj *o, *o2;
+	struct t_vertex *a, *vp;
 	float r;
-	int vn,is_clnsrc;
+	int vn, is_clnsrc;
 	int32_t i;
-	if (p->id==MCP) return; /*  mcp does not need that. */
-	if (OBJ_VALID(p,oid,o)) {
+	if (p->id == MCP) return; /*  mcp does not need that. */
+	if (OBJ_VALID(p, oid, o)) {
 		if (o->oflags&OF_SYSTEM) {
-			o->r=o->or=0; /* we don't care about system objects */
+			o->r = o->or = 0; /* we don't care about system objects */
 			return;
 		}
-		vp=o->p_vertex;
-		vn=o->n_vertex;
+		vp = o->p_vertex;
+		vn = o->n_vertex;
 		if (o->oflags&OF_CLONE) {
-			o2=p->object[o->n_vertex];	 /*  get the target into o2*/
-			o->r= o2->r * (o->scale/o2->scale);
-			obj_check_biggest_object(p,oid);
+			o2 = p->object[o->n_vertex];  /*  get the target into o2*/
+			o->r = o2->r * (o->scale / o2->scale);
+			obj_check_biggest_object(p, oid);
 			return;
 		} else {
-			/* 			printf(MED,"looking through vertices..."); */
-			for (i=0;i<vn;i++) {
-				a=&(vp[i]);
-				r=o->scale * sqrt(
-				          (a->x  * a->x ) +
-				          (a->y  * a->y ) +
-				          (a->z  * a->z ));
-				if (r > o->r) o->r=r;
+			/*    printf(MED,"looking through vertices..."); */
+			for (i = 0;i < vn;i++) {
+				a = &(vp[i]);
+				r = o->scale * sqrt(
+				            (a->x  * a->x) +
+				            (a->y  * a->y) +
+				            (a->z  * a->z));
+				if (r > o->r) o->r = r;
 			}
-			obj_check_biggest_object(p,oid);
+			obj_check_biggest_object(p, oid);
 			if (p->object[oid]->oflags&OF_CLONE_SRC) {
-				is_clnsrc=0;
-				for (i=0;i<p->n_obj;i++) {
-					if (p->object[i]!=NULL) {
-						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex== oid)) { /* if it's pointing to our object ... */
-							is_clnsrc=1;
-							p->object[i]->r=o->r*(p->object[i]->r/o->scale); /* give it the new radius too! */
-							obj_check_biggest_object(p,i);
+				is_clnsrc = 0;
+				for (i = 0;i < p->n_obj;i++) {
+					if (p->object[i] != NULL) {
+						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex == oid)) { /* if it's pointing to our object ... */
+							is_clnsrc = 1;
+							p->object[i]->r = o->r * (p->object[i]->r / o->scale); /* give it the new radius too! */
+							obj_check_biggest_object(p, i);
 						}
 					}
 				}
 				if (!is_clnsrc)
-					p->object[oid]->oflags&=~OF_CLONE_SRC;
+					p->object[oid]->oflags &= ~OF_CLONE_SRC;
 			}
 		}
 	}
@@ -1213,39 +1213,39 @@
 /*  is valid */
 void obj_check_biggest_object(struct t_process *p, int32_t oid)
 {
-	struct t_obj *o,*mcp_o;
+	struct t_obj *o, *mcp_o;
 	struct t_process *mcp_p;
-	float r,r2;
+	float r, r2;
 	int32_t i;
 	int found;
-	mcp_p=get_proc_by_pid(MCP);
-	mcp_o=mcp_p->object[p->mcp_oid];
-	o=p->object[oid];
+	mcp_p = get_proc_by_pid(MCP);
+	mcp_o = mcp_p->object[p->mcp_oid];
+	o = p->object[oid];
 	if (o->oflags&OF_SYSTEM)
 		return; /* we don't care, system objects don't count. */
-	r=o->r+o->or;
-	if (r>mcp_o->r) {	 /*  this is now the biggest object. */
-		mcp_o->r=r;
-		p->biggest_obj=oid;
-		/*		s3dprintf(MED,"there is a new biggest object in [%d:\"\"]",p->id,p->name);*/
-		mcp_rep_object(p->mcp_oid);	  /*  and tell the mcp */
+	r = o->r + o->or;
+	if (r > mcp_o->r) {  /*  this is now the biggest object. */
+		mcp_o->r = r;
+		p->biggest_obj = oid;
+		/*  s3dprintf(MED,"there is a new biggest object in [%d:\"\"]",p->id,p->name);*/
+		mcp_rep_object(p->mcp_oid);   /*  and tell the mcp */
 	} else {
-		if (p->biggest_obj==oid) { /*  oid might now lose the status of the "biggest object". let's check: */
-			found=0;
-			for (i=0;i<p->n_obj;i++)
-				if (p->object[i]!=NULL) {
-					if ((r2=p->object[i]->r+p->object[i]->or)>r) { /*  this object is bigger than the old biggest one. */
+		if (p->biggest_obj == oid) { /*  oid might now lose the status of the "biggest object". let's check: */
+			found = 0;
+			for (i = 0;i < p->n_obj;i++)
+				if (p->object[i] != NULL) {
+					if ((r2 = p->object[i]->r + p->object[i]->or) > r) { /*  this object is bigger than the old biggest one. */
 						if (!(p->object[i]->oflags&OF_SYSTEM)) {
-							p->biggest_obj=oid;
-							r=r2;
-							found=1;
+							p->biggest_obj = oid;
+							r = r2;
+							found = 1;
 						}
 					}
 				}
 			if (found) {
-				s3dprintf(VLOW,"there is a new biggest object in [%d:\"\"]",p->id,p->name);
-				mcp_o->r=r;  /*  save the new size */
-				mcp_rep_object(p->mcp_oid);	  /*  and tell the mcp */
+				s3dprintf(VLOW, "there is a new biggest object in [%d:\"\"]", p->id, p->name);
+				mcp_o->r = r;  /*  save the new size */
+				mcp_rep_object(p->mcp_oid);   /*  and tell the mcp */
 			}
 		}   /*  if it wasn't the biggest object, no one cares if it's smaller than process */
 		/*  radius */
@@ -1256,104 +1256,104 @@
 {
 	GLint matrixmode;
 	if (!p->object[oid]->m_uptodate) {
-		glGetIntegerv(GL_MATRIX_MODE,&matrixmode); 		 /*  save matrixmode */
-		glMatrixMode(GL_MODELVIEW); 					 /*  go into modelview */
+		glGetIntegerv(GL_MATRIX_MODE, &matrixmode);   /*  save matrixmode */
+		glMatrixMode(GL_MODELVIEW);       /*  go into modelview */
 		glPushMatrix();
 		glLoadIdentity();
-		into_position(p,p->object[oid],0);
-		glGetFloatv( GL_MODELVIEW_MATRIX, p->object[oid]->m );
+		into_position(p, p->object[oid], 0);
+		glGetFloatv(GL_MODELVIEW_MATRIX, p->object[oid]->m);
 		glPopMatrix();
 		glMatrixMode(matrixmode);
-		p->object[oid]->m_uptodate=1;
+		p->object[oid]->m_uptodate = 1;
 	}
 }
 void obj_sys_update(struct t_process *p, int32_t oid)
 {
-	struct t_process *mcp_p=get_proc_by_pid(MCP);
-	struct t_obj	 *o;
-	struct t_vertex	 fs,fa;
-	float 			 ss,sa,v[3];
-	fs.x=fs.y=fs.z=0.0F;
-	fa.x=fa.y=fa.z=0.0F;
-	sa=ss=1.0F;
+	struct t_process *mcp_p = get_proc_by_pid(MCP);
+	struct t_obj  *o;
+	struct t_vertex  fs, fa;
+	float     ss, sa, v[3];
+	fs.x = fs.y = fs.z = 0.0F;
+	fa.x = fa.y = fa.z = 0.0F;
+	sa = ss = 1.0F;
 	/* find the angel of the sys object */
-	o=mcp_p->object[oid];
-	while (o!=NULL) {
-		fs.x+=o->rotate.x;
-		fs.y+=o->rotate.y;
-		fs.z+=o->rotate.z;
-		ss*=o->scale;
+	o = mcp_p->object[oid];
+	while (o != NULL) {
+		fs.x += o->rotate.x;
+		fs.y += o->rotate.y;
+		fs.z += o->rotate.z;
+		ss *= o->scale;
 		if (o->oflags&OF_LINK)
-			o=mcp_p->object[o->linkid];
-		else o=NULL;
+			o = mcp_p->object[o->linkid];
+		else o = NULL;
 	}
 	/* mov in the mcp space */
 	mySetMatrix(mcp_p->object[oid]->m);
-	v[0]=v[1]=v[2]=0.0;
+	v[0] = v[1] = v[2] = 0.0;
 	myTransform3f(v);
 
-	o=mcp_p->object[p->mcp_oid];
-	while (o!=NULL) {
-		fa.x+=o->rotate.x;
-		fa.y+=o->rotate.y;
-		fa.z+=o->rotate.z;
-		sa*=o->scale;
+	o = mcp_p->object[p->mcp_oid];
+	while (o != NULL) {
+		fa.x += o->rotate.x;
+		fa.y += o->rotate.y;
+		fa.z += o->rotate.z;
+		sa *= o->scale;
 		if (o->oflags&OF_LINK)
-			o=mcp_p->object[o->linkid];
-		else o=NULL;
+			o = mcp_p->object[o->linkid];
+		else o = NULL;
 	}
 	/* reverse in the application space */
 	mySetMatrix(mcp_p->object[p->mcp_oid]->m);
 	if (myInvert()) return; /* we don't bother if the matrix doesn't work. */
 	myTransform3f(v);
 
-	p->object[oid]->rotate.x=fs.x-fa.x;
-	p->object[oid]->rotate.y=fs.y-fa.y;
-	p->object[oid]->rotate.z=fs.z-fa.z;
+	p->object[oid]->rotate.x = fs.x - fa.x;
+	p->object[oid]->rotate.y = fs.y - fa.y;
+	p->object[oid]->rotate.z = fs.z - fa.z;
 
-	p->object[oid]->translate.x=v[0];
-	p->object[oid]->translate.y=v[1];
-	p->object[oid]->translate.z=v[2];
+	p->object[oid]->translate.x = v[0];
+	p->object[oid]->translate.y = v[1];
+	p->object[oid]->translate.z = v[2];
 
-	p->object[oid]->scale=ss/sa;
+	p->object[oid]->scale = ss / sa;
 
-	/*	obj_debug(p,oid);*/
-	obj_pos_update(p,oid,oid); /* now also update the matrix and the objects linking to our sys-object ... */
+	/* obj_debug(p,oid);*/
+	obj_pos_update(p, oid, oid); /* now also update the matrix and the objects linking to our sys-object ... */
 }
 /*  recalculate the position of an object. this assumes that oid is valid. */
 void obj_pos_update(struct t_process *p, int32_t oid, int32_t first_oid)
 {
 	float v[3];
-	struct t_obj 		*ao,*o;
-	struct t_process	*ap;
-	o=p->object[oid];
-	s3dprintf(VLOW,"[obj_pos_upd|pid %d] %d",p->id, oid,first_oid);
-	o->m_uptodate=0;
-	obj_recalc_tmat(p,oid);
-	if (p->id!=MCP) {/*  mcp does not need that. */
+	struct t_obj   *ao, *o;
+	struct t_process *ap;
+	o = p->object[oid];
+	s3dprintf(VLOW, "[obj_pos_upd|pid %d] %d", p->id, oid, first_oid);
+	o->m_uptodate = 0;
+	obj_recalc_tmat(p, oid);
+	if (p->id != MCP) {/*  mcp does not need that. */
 		/*  save the matrixmode to reset it later on */
-		v[0]=v[1]=v[2]=0.0F;
+		v[0] = v[1] = v[2] = 0.0F;
 		mySetMatrix(o->m);
 		myTransform3f(v);
 		/*  and get it's destination point. phew */
-		o->or=sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
+		o->or = sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
 	} else
 		if (o->oflags&OF_SYSTEM) /* TODO: what will we do if $sys_object is linked to another? */
 		{ /* a system object changed position? let's update the focus'ed sys-objects */
-			if (OBJ_VALID(p,focus_oid,ao))
-				if (NULL!=(ap=get_proc_by_pid(ao->n_mat))) {
-					if (OF_POINTER==(o->oflags&0xF0000000)) { /* we dont have to do that much in this case ... */
-						if (OBJ_VALID(ap,get_pointer(ap),ao)) { /* we can redefine ao here -> ao = focused app's pointer*/
-							ao->rotate.x=o->rotate.x;
-							ao->rotate.y=o->rotate.y;
-							ao->rotate.z=o->rotate.z;
-							ao->translate.x=o->translate.x;
-							ao->translate.y=o->translate.y;
-							ao->translate.z=o->translate.z; /* just copy */
-							obj_pos_update(ap,get_pointer(ap),get_pointer(ap));
+			if (OBJ_VALID(p, focus_oid, ao))
+				if (NULL != (ap = get_proc_by_pid(ao->n_mat))) {
+					if (OF_POINTER == (o->oflags&0xF0000000)) { /* we dont have to do that much in this case ... */
+						if (OBJ_VALID(ap, get_pointer(ap), ao)) { /* we can redefine ao here -> ao = focused app's pointer*/
+							ao->rotate.x = o->rotate.x;
+							ao->rotate.y = o->rotate.y;
+							ao->rotate.z = o->rotate.z;
+							ao->translate.x = o->translate.x;
+							ao->translate.y = o->translate.y;
+							ao->translate.z = o->translate.z; /* just copy */
+							obj_pos_update(ap, get_pointer(ap), get_pointer(ap));
 						}
 					} else {
-						obj_sys_update(ap,oid);
+						obj_sys_update(ap, oid);
 					}
 				}
 			switch (o->oflags&0xF0000000) {
@@ -1364,57 +1364,57 @@
 				event_ptr_changed();
 				break;
 			default:
-				s3dprintf(LOW,"[obj_pos_upd|pid %d] %d unknown system event",p->id,oid);
+				s3dprintf(LOW, "[obj_pos_upd|pid %d] %d unknown system event", p->id, oid);
 
 			}
 
 		}
 	/* if it's the root (oid==first_oid), only go down */
 
-	if (o->lsub!=-1)						obj_pos_update(p,o->lsub,first_oid);
-	if ((o->lnext!=-1) && (oid!=first_oid))	obj_pos_update(p,o->lnext,first_oid);
-	if (p->id!=MCP)
-		obj_check_biggest_object(p,oid);
+	if (o->lsub != -1)      obj_pos_update(p, o->lsub, first_oid);
+	if ((o->lnext != -1) && (oid != first_oid)) obj_pos_update(p, o->lnext, first_oid);
+	if (p->id != MCP)
+		obj_check_biggest_object(p, oid);
 }
 /*  calculates the normal for one polygon, if not present. */
 int calc_normal(struct t_obj *obj, uint32_t pn)
 {
-	struct t_vertex a,b,n;
+	struct t_vertex a, b, n;
 	struct t_vertex *v[3];
-	int32_t vp,i;
+	int32_t vp, i;
 
 	float len;
-	for (i=0;i<3;i++) { /*  set and check */
-		vp= obj->p_poly[pn].v[i];  /*  ... get the vertices ... */
-		if ( vp < obj->n_vertex)
-			v[i]=&(obj->p_vertex[vp]);
+	for (i = 0;i < 3;i++) { /*  set and check */
+		vp = obj->p_poly[pn].v[i]; /*  ... get the vertices ... */
+		if (vp < obj->n_vertex)
+			v[i] = &(obj->p_vertex[vp]);
 		else return(-1);
 	}
 	/*  check for already set normal */
-	if ((obj->p_poly[pn].n[0].x*obj->p_poly[pn].n[0].x+
-	                obj->p_poly[pn].n[0].y*obj->p_poly[pn].n[0].y+
-	                obj->p_poly[pn].n[0].z*obj->p_poly[pn].n[0].z)==0) {/*  normal already defined? */
-		a.x=v[1]->x-v[0]->x;
-		a.y=v[1]->y-v[0]->y;
-		a.z=v[1]->z-v[0]->z;
-		b.x=v[2]->x-v[0]->x;
-		b.y=v[2]->y-v[0]->y;
-		b.z=v[2]->z-v[0]->z;
-		n.x=a.y*b.z - a.z*b.y;
-		n.y=a.z*b.x - a.x*b.z;
-		n.z=a.x*b.y - a.y*b.x;
+	if ((obj->p_poly[pn].n[0].x*obj->p_poly[pn].n[0].x +
+	                obj->p_poly[pn].n[0].y*obj->p_poly[pn].n[0].y +
+	                obj->p_poly[pn].n[0].z*obj->p_poly[pn].n[0].z) == 0) {/*  normal already defined? */
+		a.x = v[1]->x - v[0]->x;
+		a.y = v[1]->y - v[0]->y;
+		a.z = v[1]->z - v[0]->z;
+		b.x = v[2]->x - v[0]->x;
+		b.y = v[2]->y - v[0]->y;
+		b.z = v[2]->z - v[0]->z;
+		n.x = a.y * b.z - a.z * b.y;
+		n.y = a.z * b.x - a.x * b.z;
+		n.z = a.x * b.y - a.y * b.x;
 
-		len=sqrt(n.x*n.x+n.y*n.y+n.z*n.z);
-		if (len==0.0F) {
-			/* 		errds(VLOW,"bad polygon (can't normalize ...)"); */
+		len = sqrt(n.x * n.x + n.y * n.y + n.z * n.z);
+		if (len == 0.0F) {
+			/*   errds(VLOW,"bad polygon (can't normalize ...)"); */
 		} else {
-			n.x=n.x/len;
-			n.y=n.y/len;
-			n.z=n.z/len;
-			for (i=0;i<3;i++) {
-				obj->p_poly[pn].n[i].x=n.x;
-				obj->p_poly[pn].n[i].y=n.y;
-				obj->p_poly[pn].n[i].z=n.z;
+			n.x = n.x / len;
+			n.y = n.y / len;
+			n.z = n.z / len;
+			for (i = 0;i < 3;i++) {
+				obj->p_poly[pn].n[i].x = n.x;
+				obj->p_poly[pn].n[i].y = n.y;
+				obj->p_poly[pn].n[i].z = n.z;
 			}
 		}
 	}
@@ -1425,20 +1425,20 @@
 int check_line_normal(struct t_obj *obj, uint32_t pn)
 {
 	struct t_vertex *v[2];
-	int i,vp;
-	for (i=0;i<2;i++) { /*  set and check */
-		vp= obj->p_line[pn].v[i];  /*  ... get the vertices ... */
+	int i, vp;
+	for (i = 0;i < 2;i++) { /*  set and check */
+		vp = obj->p_line[pn].v[i]; /*  ... get the vertices ... */
 		if (vp < (int)obj->n_vertex)
-			v[i]=&(obj->p_vertex[vp]);
+			v[i] = &(obj->p_vertex[vp]);
 		else return(-1);
 	}
-	if ((obj->p_line[pn].n[0].x*obj->p_line[pn].n[0].x+
-	                obj->p_line[pn].n[0].y*obj->p_line[pn].n[0].y+
-	                obj->p_line[pn].n[0].z*obj->p_line[pn].n[0].z)==0) { /* guess we have nothing set yet, so set something */
-		for (i=0;i<2;i++) {
-			obj->p_line[pn].n[0].x=0;
-			obj->p_line[pn].n[0].y=0;
-			obj->p_line[pn].n[0].z=1;
+	if ((obj->p_line[pn].n[0].x*obj->p_line[pn].n[0].x +
+	                obj->p_line[pn].n[0].y*obj->p_line[pn].n[0].y +
+	                obj->p_line[pn].n[0].z*obj->p_line[pn].n[0].z) == 0) { /* guess we have nothing set yet, so set something */
+		for (i = 0;i < 2;i++) {
+			obj->p_line[pn].n[0].x = 0;
+			obj->p_line[pn].n[0].y = 0;
+			obj->p_line[pn].n[0].z = 1;
 		}
 	}
 	return(0);
@@ -1446,40 +1446,40 @@
 }
 
 /* activate/bind texture for object */
-static struct t_tex *get_texture(struct t_obj *obj,struct t_mat *m) {
+static struct t_tex *get_texture(struct t_obj *obj, struct t_mat *m) {
 	GLuint t;
-	struct t_tex *tex=NULL;
+	struct t_tex *tex = NULL;
 	GLfloat matgl[4];
-	/* 	int i,j; */
+	/*  int i,j; */
 	if (m->tex < obj->n_tex) {
-		tex=&obj->p_tex[m->tex];
-		if (tex->buf!=NULL) { /*  texture seems to be okay, select it. */
-			matgl[0]=0.5f;
-			matgl[1]=0.5f;
-			matgl[2]=0.5f;
-			matgl[3]=1.0f;
-			glMaterialfv(GL_FRONT,GL_AMBIENT,matgl);
-			glMaterialfv(GL_FRONT,GL_DIFFUSE,matgl);
-			glMaterialfv(GL_FRONT,GL_SPECULAR,matgl);
-			if (tex->gl_texnum!=-1) {
-				glBindTexture( GL_TEXTURE_2D,tex->gl_texnum);
+		tex = &obj->p_tex[m->tex];
+		if (tex->buf != NULL) { /*  texture seems to be okay, select it. */
+			matgl[0] = 0.5f;
+			matgl[1] = 0.5f;
+			matgl[2] = 0.5f;
+			matgl[3] = 1.0f;
+			glMaterialfv(GL_FRONT, GL_AMBIENT, matgl);
+			glMaterialfv(GL_FRONT, GL_DIFFUSE, matgl);
+			glMaterialfv(GL_FRONT, GL_SPECULAR, matgl);
+			if (tex->gl_texnum != -1) {
+				glBindTexture(GL_TEXTURE_2D, tex->gl_texnum);
 			} else {
-				glGenTextures(1,&t);
-				glBindTexture( GL_TEXTURE_2D, t);
-				tex->gl_texnum=t;
-				s3dprintf(HIGH,"generated texture %d [%dx%d, in memory %dx%d]",t,tex->tw,tex->th,tex->w,tex->h);
-				/*				for (j=0;j<tex->th;j++)
-								for (i=0;i<tex->tw;i++)
-								{
-									s3dprintf(MED,"pixel[%d,%d], %d %d %d %d",i,j,
-													tex->buf[(j*tex->w+i)*4+0],
-													tex->buf[(j*tex->w+i)*4+1],
-													tex->buf[(j*tex->w+i)*4+2],
-													tex->buf[(j*tex->w+i)*4+3]);
-								}*/
-				glTexImage2D(	GL_TEXTURE_2D,0, GL_RGBA,
-				              tex->w,tex->h,0,  /*  no border. */
-				              GL_RGBA,GL_UNSIGNED_BYTE,tex->buf);
+				glGenTextures(1, &t);
+				glBindTexture(GL_TEXTURE_2D, t);
+				tex->gl_texnum = t;
+				s3dprintf(HIGH, "generated texture %d [%dx%d, in memory %dx%d]", t, tex->tw, tex->th, tex->w, tex->h);
+				/*    for (j=0;j<tex->th;j++)
+				    for (i=0;i<tex->tw;i++)
+				    {
+				     s3dprintf(MED,"pixel[%d,%d], %d %d %d %d",i,j,
+				         tex->buf[(j*tex->w+i)*4+0],
+				         tex->buf[(j*tex->w+i)*4+1],
+				         tex->buf[(j*tex->w+i)*4+2],
+				         tex->buf[(j*tex->w+i)*4+3]);
+				    }*/
+				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
+				             tex->w, tex->h, 0,  /*  no border. */
+				             GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);
 				/*  texture has to be generated yet ... */
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
@@ -1490,148 +1490,148 @@
 
 			}
 		} else { /* . can't use a texture  */
-			tex=NULL;
+			tex = NULL;
 		}
 	}
 	return(tex);
 }
 /*  finally, the rendering portion. */
-int obj_render(struct t_process *p,int32_t oid)
+int obj_render(struct t_process *p, int32_t oid)
 {
 	int32_t pn;
-	int32_t mat,omat=-1;
+	int32_t mat, omat = -1;
 	int32_t v;
-	/* 	int link_obj; */
+	/*  int link_obj; */
 	struct t_vertex *on;
 	struct t_obj *obj;
 	struct t_mat *m;
-	struct t_tex *tex=NULL;
+	struct t_tex *tex = NULL;
 	GLfloat matgl[4];
 	int32_t i;
 
-	obj=p->object[oid];
+	obj = p->object[oid];
 	glPushMatrix();
 	glMultMatrixf(obj->m);
-	/*	into_position(p,obj,0);*/
-	if (obj->oflags&OF_SYSTEM)		return(-1); 					/* can't render system objects */
-	if (obj->oflags&OF_CLONE)		obj=p->object[obj->n_vertex]; 	/* it's a clone - draw the clone! */
+	/* into_position(p,obj,0);*/
+	if (obj->oflags&OF_SYSTEM)  return(-1);      /* can't render system objects */
+	if (obj->oflags&OF_CLONE)  obj = p->object[obj->n_vertex];  /* it's a clone - draw the clone! */
 	if (!obj->dplist) {
-		obj->dplist=glGenLists(1);
-		if (obj->dplist)	glNewList(obj->dplist,GL_COMPILE); /* only compile and calling later should save time. maybe. */
-		else 				s3dprintf(LOW,"couldn't get a new list :/");
-		omat=-1;
-		for (pn=0; pn<obj->n_poly; pn++) { /*  cycle throu our polygons ... */
-			if (calc_normal(obj,pn)) {
-				s3dprintf(HIGH,"something is wrong with polygon %d!",pn);
+		obj->dplist = glGenLists(1);
+		if (obj->dplist) glNewList(obj->dplist, GL_COMPILE); /* only compile and calling later should save time. maybe. */
+		else     s3dprintf(LOW, "couldn't get a new list :/");
+		omat = -1;
+		for (pn = 0; pn < obj->n_poly; pn++) { /*  cycle throu our polygons ... */
+			if (calc_normal(obj, pn)) {
+				s3dprintf(HIGH, "something is wrong with polygon %d!", pn);
 				if (obj->dplist) glEndList();
 				glPopMatrix(); /* clean up GL-stuff */
 				return(-1);
 			}
-			/* 		glNormal3f(-n.x,-n.y,-n.z); */
-			mat= obj->p_poly[pn].mat;
-			if (mat!=omat) {
-				tex=NULL;
-				if (mat< obj->n_mat) {
-					m=&obj->p_mat[mat];
-					if (m->tex!=-1)		tex=get_texture(obj,m);
-					if (tex==NULL) {	/* still NULL? then it couldn't get the texture. */
-						/*						s3dprintf(VLOW,"no texture, using standard material...");*/
-						glBindTexture( GL_TEXTURE_2D,0);
-						matgl[0]=m->amb_r/2;
-						matgl[1]=m->amb_g/2;
-						matgl[2]=m->amb_b/2;
-						matgl[3]=m->amb_a;
-						/* 				glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
-						glMaterialfv(GL_FRONT,GL_AMBIENT,matgl);
-						matgl[0]=m->diff_r/2;
-						matgl[1]=m->diff_g/2;
-						matgl[2]=m->diff_b/2;
-						matgl[3]=m->diff_a;
-						/* 				glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
-						glMaterialfv(GL_FRONT,GL_DIFFUSE,matgl);
-						matgl[0]=m->spec_r/2;
-						matgl[1]=m->spec_g/2;
-						matgl[2]=m->spec_b/2;
-						matgl[3]=m->spec_a;
-						/* 				glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
-						glMaterialfv(GL_FRONT,GL_SPECULAR,matgl);
+			/*   glNormal3f(-n.x,-n.y,-n.z); */
+			mat = obj->p_poly[pn].mat;
+			if (mat != omat) {
+				tex = NULL;
+				if (mat < obj->n_mat) {
+					m = &obj->p_mat[mat];
+					if (m->tex != -1)  tex = get_texture(obj, m);
+					if (tex == NULL) { /* still NULL? then it couldn't get the texture. */
+						/*      s3dprintf(VLOW,"no texture, using standard material...");*/
+						glBindTexture(GL_TEXTURE_2D, 0);
+						matgl[0] = m->amb_r / 2;
+						matgl[1] = m->amb_g / 2;
+						matgl[2] = m->amb_b / 2;
+						matgl[3] = m->amb_a;
+						/*     glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
+						glMaterialfv(GL_FRONT, GL_AMBIENT, matgl);
+						matgl[0] = m->diff_r / 2;
+						matgl[1] = m->diff_g / 2;
+						matgl[2] = m->diff_b / 2;
+						matgl[3] = m->diff_a;
+						/*     glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
+						glMaterialfv(GL_FRONT, GL_DIFFUSE, matgl);
+						matgl[0] = m->spec_r / 2;
+						matgl[1] = m->spec_g / 2;
+						matgl[2] = m->spec_b / 2;
+						matgl[3] = m->spec_a;
+						/*     glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
+						glMaterialfv(GL_FRONT, GL_SPECULAR, matgl);
 					}
 				} else {
-					s3dprintf(MED,"something is wrong with polygon %d! material: [%d,%d]",pn, mat,obj->n_mat);
+					s3dprintf(MED, "something is wrong with polygon %d! material: [%d,%d]", pn, mat, obj->n_mat);
 					if (obj->dplist) glEndList();
 					glEnd();
 					glPopMatrix();
 					return(-1);
 				}
 			}
-			omat=mat;		 /*  saving old material */
+			omat = mat; /*  saving old material */
 			glBegin(GL_TRIANGLES);
-			for (i=0; i<3; i++) {
-				on=&(obj->p_poly[pn].n[i]);
-				glNormal3f(-on->x,-on->y,-on->z);
-				if (tex!=NULL) {
-					/*						s3dprintf(MED,"using texture coordinate (%f,%f) for polygon %d point %d",
-															obj->p_poly[pn].tc[i].x *tex->xs,
-															obj->p_poly[pn].tc[i].y *tex->ys,
-															pn,i);*/
+			for (i = 0; i < 3; i++) {
+				on = &(obj->p_poly[pn].n[i]);
+				glNormal3f(-on->x, -on->y, -on->z);
+				if (tex != NULL) {
+					/*      s3dprintf(MED,"using texture coordinate (%f,%f) for polygon %d point %d",
+					          obj->p_poly[pn].tc[i].x *tex->xs,
+					          obj->p_poly[pn].tc[i].y *tex->ys,
+					          pn,i);*/
 
-					glTexCoord2f(	obj->p_poly[pn].tc[i].x *tex->xs,
-					              (obj->p_poly[pn].tc[i].y *tex->ys));
+					glTexCoord2f(obj->p_poly[pn].tc[i].x *tex->xs,
+					             (obj->p_poly[pn].tc[i].y *tex->ys));
 				}
-				v= obj->p_poly[pn].v[i];  /*  ... get the vertices ... */
+				v = obj->p_poly[pn].v[i]; /*  ... get the vertices ... */
 				glVertex3f(obj->p_vertex[v].x, obj->p_vertex[v].y, obj->p_vertex[v].z);  /*  ...and draw them */
 			}
 			glEnd();
 		}
-		if (tex!=NULL)			glBindTexture( GL_TEXTURE_2D, 0);  /*  switch back to standard texture */
-		for (pn=0;pn<obj->n_line; pn++) {
-			if (check_line_normal(obj,pn)) {
-				s3dprintf(HIGH,"something is wrong with line %d!",pn);
+		if (tex != NULL)   glBindTexture(GL_TEXTURE_2D, 0); /*  switch back to standard texture */
+		for (pn = 0;pn < obj->n_line; pn++) {
+			if (check_line_normal(obj, pn)) {
+				s3dprintf(HIGH, "something is wrong with line %d!", pn);
 				if (obj->dplist) glEndList();
 				glPopMatrix(); /* clean up GL-stuff */
 				return(-1);
 			}
 
-			mat= obj->p_line[pn].mat;
-			if (mat!=omat) {
-				tex=NULL;
-				if (mat< obj->n_mat) {
-					m=&obj->p_mat[mat];
+			mat = obj->p_line[pn].mat;
+			if (mat != omat) {
+				tex = NULL;
+				if (mat < obj->n_mat) {
+					m = &obj->p_mat[mat];
 					/* dont need to care about textures ...  it's rather impossible
 					 * to get some textures on a line. at least it would look ugly ;)*/
-					matgl[0]=m->amb_r/2;
-					matgl[1]=m->amb_g/2;
-					matgl[2]=m->amb_b/2;
-					matgl[3]=m->amb_a;
-					/* 			glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
-					glMaterialfv(GL_FRONT,GL_AMBIENT,matgl);
-					matgl[0]=m->diff_r/2;
-					matgl[1]=m->diff_g/2;
-					matgl[2]=m->diff_b/2;
-					matgl[3]=m->diff_a;
-					/* 			glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
-					glMaterialfv(GL_FRONT,GL_DIFFUSE,matgl);
-					matgl[0]=m->spec_r/2;
-					matgl[1]=m->spec_g/2;
-					matgl[2]=m->spec_b/2;
-					matgl[3]=m->spec_a;
-					/* 			glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
-					glMaterialfv(GL_FRONT,GL_SPECULAR,matgl);
+					matgl[0] = m->amb_r / 2;
+					matgl[1] = m->amb_g / 2;
+					matgl[2] = m->amb_b / 2;
+					matgl[3] = m->amb_a;
+					/*    glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,matgl); */
+					glMaterialfv(GL_FRONT, GL_AMBIENT, matgl);
+					matgl[0] = m->diff_r / 2;
+					matgl[1] = m->diff_g / 2;
+					matgl[2] = m->diff_b / 2;
+					matgl[3] = m->diff_a;
+					/*    glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,matgl); */
+					glMaterialfv(GL_FRONT, GL_DIFFUSE, matgl);
+					matgl[0] = m->spec_r / 2;
+					matgl[1] = m->spec_g / 2;
+					matgl[2] = m->spec_b / 2;
+					matgl[3] = m->spec_a;
+					/*    glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,matgl); */
+					glMaterialfv(GL_FRONT, GL_SPECULAR, matgl);
 				} else {
-					s3dprintf(MED,"something is wrong with line %d! material: [%d,%d]",pn, mat,obj->n_mat);
+					s3dprintf(MED, "something is wrong with line %d! material: [%d,%d]", pn, mat, obj->n_mat);
 					if (obj->dplist) glEndList();
 					glEnd();
 					glPopMatrix();
 					return(-1);
 				}
 			}
-			omat=mat;		 /*  saving old material */
+			omat = mat; /*  saving old material */
 			glBegin(GL_LINES);
-			for (i=0; i<2; i++) {
-				on=&(obj->p_line[pn].n[i]);
-				glNormal3f(-on->x,-on->y,-on->z);
+			for (i = 0; i < 2; i++) {
+				on = &(obj->p_line[pn].n[i]);
+				glNormal3f(-on->x, -on->y, -on->z);
 
-				v= obj->p_line[pn].v[i];  /*  ... get the vertices ... */
+				v = obj->p_line[pn].v[i]; /*  ... get the vertices ... */
 				glVertex3f(obj->p_vertex[v].x, obj->p_vertex[v].y, obj->p_vertex[v].z);  /*  ...and draw them */
 			}
 			glEnd();
@@ -1639,7 +1639,7 @@
 		if (obj->dplist) glEndList();
 	}
 	if (obj->dplist)
-		glCallList(obj->dplist);		/* call the just compiled ore old display list */
+		glCallList(obj->dplist);  /* call the just compiled ore old display list */
 	glPopMatrix();
 	return(0);
 }
@@ -1647,80 +1647,80 @@
 /* remove the oid out of the link chain */
 void link_delete(struct t_process *p, int32_t oid)
 {
-	struct t_obj *o,*o2;
-	if (OBJ_VALID(p,oid,o)) {
-		s3dprintf(VLOW,"link_delete(): [%d] unlinking %d from %d",p->id, oid, o->linkid);
-		if (o->linkid!=-1) {
-			if (o->lprev!=-1)
-				if (OBJ_VALID(p,o->lprev,o2)) { /* we have a previous pointer linking to us */
-					o2->lnext=o->lnext; /* might also be -1 */
+	struct t_obj *o, *o2;
+	if (OBJ_VALID(p, oid, o)) {
+		s3dprintf(VLOW, "link_delete(): [%d] unlinking %d from %d", p->id, oid, o->linkid);
+		if (o->linkid != -1) {
+			if (o->lprev != -1)
+				if (OBJ_VALID(p, o->lprev, o2)) { /* we have a previous pointer linking to us */
+					o2->lnext = o->lnext; /* might also be -1 */
 				}
-			if (OBJ_VALID(p,o->linkid,o2)) {
-				if (o2->lsub==oid) {/* parent is having oid as it's first link in chain */
-					o2->lsub=o->lnext;
+			if (OBJ_VALID(p, o->linkid, o2)) {
+				if (o2->lsub == oid) {/* parent is having oid as it's first link in chain */
+					o2->lsub = o->lnext;
 				}
 			}
-			if (o->lnext!=-1)
-				if (OBJ_VALID(p,o->lnext,o2)) { /* fixing next's previous pointer */
-					o2->lprev=o->lprev;
+			if (o->lnext != -1)
+				if (OBJ_VALID(p, o->lnext, o2)) { /* fixing next's previous pointer */
+					o2->lprev = o->lprev;
 				}
 		}
-		o->lnext=-1;
-		o->lprev=-1;
-		o->linkid=-1;
-		o->oflags&=~OF_LINK;
+		o->lnext = -1;
+		o->lprev = -1;
+		o->linkid = -1;
+		o->oflags &= ~OF_LINK;
 	}
 }
 /* add an element into the link chain */
 void link_insert(struct t_process *p, int32_t oid, int32_t target)
 {
-	struct t_obj *o,*ot,*o2;
-	if (OBJ_VALID(p,oid,o) && OBJ_VALID(p,target,ot)) {
-		s3dprintf(VLOW,"link_insert(): [%d] linking %d to %d",p->id, oid, target);
-		o->oflags|=OF_LINK;
-		o->linkid=target;
-		o->lnext=ot->lsub; /* we have a new "first" element */
-		if (o->lnext!=-1) if (OBJ_VALID(p,o->lnext,o2))  /* if we already had an element
-														  in the chain, create the backlink */
+	struct t_obj *o, *ot, *o2;
+	if (OBJ_VALID(p, oid, o) && OBJ_VALID(p, target, ot)) {
+		s3dprintf(VLOW, "link_insert(): [%d] linking %d to %d", p->id, oid, target);
+		o->oflags |= OF_LINK;
+		o->linkid = target;
+		o->lnext = ot->lsub; /* we have a new "first" element */
+		if (o->lnext != -1) if (OBJ_VALID(p, o->lnext, o2))  /* if we already had an element
+                in the chain, create the backlink */
 			{
-				o2->lprev=oid;
+				o2->lprev = oid;
 			}
-		ot->lsub=oid;
+		ot->lsub = oid;
 	}
 }
 /*  creates a link from object from an object to another  */
 /*  to have a translation or anything move with other things */
 int obj_link(struct t_process *p, int32_t oid_from, int32_t oid_to)
 {
-	struct t_obj *o,*o2;
-	if (OBJ_VALID(p,oid_from,o) && OBJ_VALID(p,oid_to,o2)) {
-		if (oid_to==oid_from) {
-			errds(VHIGH,"obj_link()","can't link to itself!!");
+	struct t_obj *o, *o2;
+	if (OBJ_VALID(p, oid_from, o) && OBJ_VALID(p, oid_to, o2)) {
+		if (oid_to == oid_from) {
+			errds(VHIGH, "obj_link()", "can't link to itself!!");
 			return(-1);
 		}
-		if (OF_POINTER==(o->oflags&0xF0000000)) {
-			errds(VHIGH,"obj_link()","may not change the link of a pointer");
+		if (OF_POINTER == (o->oflags&0xF0000000)) {
+			errds(VHIGH, "obj_link()", "may not change the link of a pointer");
 			return(-1);
 		}
 
 		while (o2->oflags&OF_LINK) {
-			if (o2->linkid==oid_from) { /*  circular link!! we can't do that */
-				errds(VHIGH,"obj_link()","link from %d to %d would produce a circular link!",oid_from,oid_to);
+			if (o2->linkid == oid_from) { /*  circular link!! we can't do that */
+				errds(VHIGH, "obj_link()", "link from %d to %d would produce a circular link!", oid_from, oid_to);
 				return(-1);
 			}
-			o2=p->object[o2->linkid];  /*   move to the next object in the linkchain */
+			o2 = p->object[o2->linkid];  /*   move to the next object in the linkchain */
 		}
-		if ((o->oflags&OF_SYSTEM) && (p->id==MCP)) {
-			errds(VHIGH,"obj_link()","can't link system-objects in non-mcp-apps!");
+		if ((o->oflags&OF_SYSTEM) && (p->id == MCP)) {
+			errds(VHIGH, "obj_link()", "can't link system-objects in non-mcp-apps!");
 			return(-1);
 		}
-		s3dprintf(VLOW,"[link|pid %d] %d -> %d",p->id, oid_from,oid_to);
-		if (oid_to!=o->linkid) { /* only if something changed ... */
-			if (o->linkid!=-1)
-				link_delete(p,oid_from);
-			link_insert(p,oid_from,oid_to);
-			p->object[oid_to]->oflags|=OF_LINK_SRC;
-			obj_pos_update(p,oid_from,oid_from);
+		s3dprintf(VLOW, "[link|pid %d] %d -> %d", p->id, oid_from, oid_to);
+		if (oid_to != o->linkid) { /* only if something changed ... */
+			if (o->linkid != -1)
+				link_delete(p, oid_from);
+			link_insert(p, oid_from, oid_to);
+			p->object[oid_to]->oflags |= OF_LINK_SRC;
+			obj_pos_update(p, oid_from, oid_from);
 		}
 		return(0);
 	}
@@ -1730,15 +1730,15 @@
 int obj_unlink(struct t_process *p, int32_t oid)
 {
 	struct t_obj *o;
-	if (OBJ_VALID(p,oid,o)) {
-		if (OF_POINTER==(o->oflags&0xF0000000)) {
-			errds(VHIGH,"obj_link()","may not change the link of a pointer");
+	if (OBJ_VALID(p, oid, o)) {
+		if (OF_POINTER == (o->oflags&0xF0000000)) {
+			errds(VHIGH, "obj_link()", "may not change the link of a pointer");
 			return(-1);
 		}
-		link_delete(p,oid);
-		s3dprintf(VLOW,"removing link of object %d from pid %d",oid,p->id);
+		link_delete(p, oid);
+		s3dprintf(VLOW, "removing link of object %d from pid %d", oid, p->id);
 
-		obj_pos_update(p,oid,oid);
+		obj_pos_update(p, oid, oid);
 		return(0);
 	}
 	return(-1);
@@ -1747,42 +1747,42 @@
 int obj_new(struct t_process *p)
 {
 	struct t_obj *obj;
-	int32_t pos,reuse=0;
-	obj=malloc(sizeof(struct t_obj));  /*  get an object and define it with our data */
-	memset(obj,0,sizeof(struct t_obj));
-	obj->linkid=-1;
-	obj->lsub=-1;
-	obj->lnext=-1;
-	obj->lprev=-1;
-	obj->rotate.x=obj->rotate.y=obj->rotate.z=0.0F;
-	obj->translate.x=obj->translate.y=obj->translate.z=0.0F;
-	obj->scale=1.0F;
-	obj->n_vertex=obj->n_poly=obj->n_mat=obj->n_tex=0;
-	obj->r=obj->or=0.0F;
-	obj->m_uptodate=0;
-	memcpy(obj->m,Identity,sizeof(t_mtrx));
+	int32_t pos, reuse = 0;
+	obj = malloc(sizeof(struct t_obj));  /*  get an object and define it with our data */
+	memset(obj, 0, sizeof(struct t_obj));
+	obj->linkid = -1;
+	obj->lsub = -1;
+	obj->lnext = -1;
+	obj->lprev = -1;
+	obj->rotate.x = obj->rotate.y = obj->rotate.z = 0.0F;
+	obj->translate.x = obj->translate.y = obj->translate.z = 0.0F;
+	obj->scale = 1.0F;
+	obj->n_vertex = obj->n_poly = obj->n_mat = obj->n_tex = 0;
+	obj->r = obj->or = 0.0F;
+	obj->m_uptodate = 0;
+	memcpy(obj->m, Identity, sizeof(t_mtrx));
 	/*  fresh and clean ... */
-	if (p!=NULL) {
+	if (p != NULL) {
 		/*  look for an old object for reuse ... */
-		for (pos=0; pos < p->n_obj ; pos++) {
-			if (p->object[pos]==NULL) {
-				reuse=1;
+		for (pos = 0; pos < p->n_obj ; pos++) {
+			if (p->object[pos] == NULL) {
+				reuse = 1;
 				break;
-				/* 				s3dprintf(HIGH,"reusing position %d",pos); */
+				/*     s3dprintf(HIGH,"reusing position %d",pos); */
 			}
 		}
 		if (!reuse) {
-			if (p->n_obj>0)
-				p->object=realloc(p->object,sizeof(struct t_obj *)*(p->n_obj+1));
-			else p->object=malloc(sizeof(struct t_obj *)*(p->n_obj+1));
-			pos=p->n_obj; 				 /*  add object at the end */
-			p->n_obj++;					 /*  increment counter */
+			if (p->n_obj > 0)
+				p->object = realloc(p->object, sizeof(struct t_obj *) * (p->n_obj + 1));
+			else p->object = malloc(sizeof(struct t_obj *) * (p->n_obj + 1));
+			pos = p->n_obj;    /*  add object at the end */
+			p->n_obj++;      /*  increment counter */
 		}
-		p->object[pos]=obj;
-		s3dprintf(VLOW,"pid %d added new object %d at %010p [pos %d]",p->id,pos,obj,pos);
+		p->object[pos] = obj;
+		s3dprintf(VLOW, "pid %d added new object %d at %010p [pos %d]", p->id, pos, obj, pos);
 		return (pos);
 	} else {
-		s3dprintf(HIGH,"obj_new(): no such process %d",p->id);
+		s3dprintf(HIGH, "obj_new(): no such process %d", p->id);
 		return(-1);
 	}
 }
@@ -1791,50 +1791,50 @@
 /*  this will check and supress looplinks and clonechains */
 int obj_clone_change(struct t_process *p, int32_t oid, int32_t toid)
 {
-	struct t_obj *o,*no;
-	int already_clone,is_clnsrc;
+	struct t_obj *o, *no;
+	int already_clone, is_clnsrc;
 	int32_t i;
-	if (OBJ_VALID(p,oid,o) && OBJ_VALID(p,toid,no)) {
+	if (OBJ_VALID(p, oid, o) && OBJ_VALID(p, toid, no)) {
 		if ((o->oflags&OF_SYSTEM) || (no->oflags&OF_SYSTEM)) {
-			s3dprintf(MED,"can't clone from or to system objects");
+			s3dprintf(MED, "can't clone from or to system objects");
 		}
 		/*  get obj pointer and check for availability of the other object. */
-		if (((already_clone=(o->oflags&OF_CLONE)) || (!(o->n_vertex|o->n_mat|o->n_poly|o->n_tex))) && (!(o->oflags&OF_VIRTUAL))) {
-			if (no->oflags&OF_CLONE) {	 /*  target is clone */
-				errds(VHIGH,"obj_clone_change()","couldn't clone %d from %d (on pid %d): clone target is already clone.",oid,toid,p->id,oid);
+		if (((already_clone = (o->oflags & OF_CLONE)) || (!(o->n_vertex | o->n_mat | o->n_poly | o->n_tex))) && (!(o->oflags & OF_VIRTUAL))) {
+			if (no->oflags&OF_CLONE) {  /*  target is clone */
+				errds(VHIGH, "obj_clone_change()", "couldn't clone %d from %d (on pid %d): clone target is already clone.", oid, toid, p->id, oid);
 				return(-1);
 			}
 			if (!already_clone) { /*  some other object could link to us, so we check the other objects and forward them just in case. */
 				if (p->object[oid]->oflags&OF_CLONE_SRC) {
-					is_clnsrc=0;
-					for (i=0;i<p->n_obj;i++)
-						if (p->object[i]!=NULL)
-							if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid)) { /*  it's linking to our object! */
-								errds(VHIGH,"obj_clone_change()","couldn't clone %d from %d (on pid %d): object %d is already cloning from object %d.",
-								      oid,toid,p->id,oid,i,oid);
+					is_clnsrc = 0;
+					for (i = 0;i < p->n_obj;i++)
+						if (p->object[i] != NULL)
+							if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex == oid)) { /*  it's linking to our object! */
+								errds(VHIGH, "obj_clone_change()", "couldn't clone %d from %d (on pid %d): object %d is already cloning from object %d.",
+								      oid, toid, p->id, oid, i, oid);
 								return(-1);
 							}
 					if (!is_clnsrc) {
-						s3dprintf(MED,"obj_clone_change(): %d in process %d is no longer a clone-source",oid,p->id);
-						p->object[oid]->oflags&=~OF_CLONE_SRC;
+						s3dprintf(MED, "obj_clone_change(): %d in process %d is no longer a clone-source", oid, p->id);
+						p->object[oid]->oflags &= ~OF_CLONE_SRC;
 					}
 				}
 			}
-			if (oid!=toid) { /*  don't looplink */
-				o->oflags|=OF_CLONE;
-				no->oflags|=OF_CLONE_SRC;
-				o->n_vertex=toid;  /*  n_vertex is not used for this as it's just cloned, so we can use it ... */
-				obj_size_update(p,oid);
-				s3dprintf(LOW,"changed clone-target of obj %d to %d of process %d",oid,toid,p->id);
-				if (p->id!=MCP) obj_check_biggest_object(p,oid);
+			if (oid != toid) { /*  don't looplink */
+				o->oflags |= OF_CLONE;
+				no->oflags |= OF_CLONE_SRC;
+				o->n_vertex = toid;  /*  n_vertex is not used for this as it's just cloned, so we can use it ... */
+				obj_size_update(p, oid);
+				s3dprintf(LOW, "changed clone-target of obj %d to %d of process %d", oid, toid, p->id);
+				if (p->id != MCP) obj_check_biggest_object(p, oid);
 			} else {
-				errds(MED,"obj_clone_change()","couldn't clone %d from %d (on pid %d): cloning from itself doesn't make sense!",oid,toid,p->id,oid);
+				errds(MED, "obj_clone_change()", "couldn't clone %d from %d (on pid %d): cloning from itself doesn't make sense!", oid, toid, p->id, oid);
 				return(-1);
 			}
 		} else {
-			errds(MED,"obj_clone_change()","couldn't clone %d from %d (on pid %d): object %d is not empty",oid,toid,p->id,oid);
-			obj_debug(p,oid);
-			obj_debug(p,toid);
+			errds(MED, "obj_clone_change()", "couldn't clone %d from %d (on pid %d): object %d is not empty", oid, toid, p->id, oid);
+			obj_debug(p, oid);
+			obj_debug(p, toid);
 			return(-1);
 		}
 	}
@@ -1847,53 +1847,53 @@
 {
 	struct t_process *mcp_p;
 	struct t_obj *o;
-	float r,mr;
+	float r, mr;
 	int32_t i;
-	int32_t mcp_oid=-1;
-	mcp_p=get_proc_by_pid(MCP);
-	if (OBJ_VALID(p,oid,o)) {
+	int32_t mcp_oid = -1;
+	mcp_p = get_proc_by_pid(MCP);
+	if (OBJ_VALID(p, oid, o)) {
 		if (o->oflags&OF_SYSTEM) {
-			s3dprintf(HIGH,"can't delete system object!");
+			s3dprintf(HIGH, "can't delete system object!");
 			return(0);
 		}
 
 
-		if (p->id==MCP) {
+		if (p->id == MCP) {
 			if (o->oflags&OF_VIRTUAL) { /*  only delete if virtual */
-				s3dprintf(HIGH,"the mcp wants %d to be closed",o->n_mat);
+				s3dprintf(HIGH, "the mcp wants %d to be closed", o->n_mat);
 				event_quit(get_proc_by_pid(o->n_mat));
 				return(0);
 			}
 		} else
-			mcp_oid=p->mcp_oid;
+			mcp_oid = p->mcp_oid;
 
-		if (OBJ_VALID(p,oid,o)) {
-			obj_free(p,oid);
-			if ((p->id!=MCP) && (p->biggest_obj==oid)) { /*  if object was the biggest object, find a new one. */
-				mr=-1;
-				p->biggest_obj=-1;
-				for (i=0;i<p->n_obj;i++)
-					if (p->object[i]!=NULL) {
-						r=p->object[i]->r+p->object[i]->or;
-						if (r>mr) {
+		if (OBJ_VALID(p, oid, o)) {
+			obj_free(p, oid);
+			if ((p->id != MCP) && (p->biggest_obj == oid)) { /*  if object was the biggest object, find a new one. */
+				mr = -1;
+				p->biggest_obj = -1;
+				for (i = 0;i < p->n_obj;i++)
+					if (p->object[i] != NULL) {
+						r = p->object[i]->r + p->object[i]->or;
+						if (r > mr) {
 							if (!(p->object[i]->oflags&OF_SYSTEM)) {
-								p->biggest_obj=i;
-								mr=r;
+								p->biggest_obj = i;
+								mr = r;
 							}
 						}
 					}
-				mcp_p->object[mcp_oid]->r=mr;
-				s3dprintf(MED,"new biggest object is :%d (size: %f)",p->biggest_obj,mr);
+				mcp_p->object[mcp_oid]->r = mr;
+				s3dprintf(MED, "new biggest object is :%d (size: %f)", p->biggest_obj, mr);
 			}
 			/*  check if someone depended on this object as clone.... */
 			if (o->oflags&OF_CLONE_SRC)
-				for (i=0;i<p->n_obj;i++)
-					if (p->object[i]!=NULL)
-						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex==oid)) { /*  it's linking to our object! */
-							p->object[i]->oflags&=~OF_CLONE;  	 /*  disable clone flag */
-							p->object[i]->n_vertex=0; 			 /*  and "clone reference" to 0 */
-							p->object[i]->r=0.0F;				 /*  empty object, so radius is zero! */
-							if (p->id!=MCP) obj_check_biggest_object(p,i);
+				for (i = 0;i < p->n_obj;i++)
+					if (p->object[i] != NULL)
+						if ((p->object[i]->oflags&OF_CLONE) && (p->object[i]->n_vertex == oid)) { /*  it's linking to our object! */
+							p->object[i]->oflags &= ~OF_CLONE;  /*  disable clone flag */
+							p->object[i]->n_vertex = 0;   /*  and "clone reference" to 0 */
+							p->object[i]->r = 0.0F;   /*  empty object, so radius is zero! */
+							if (p->id != MCP) obj_check_biggest_object(p, i);
 						}
 			return(0);
 		}
@@ -1902,53 +1902,53 @@
 }
 
 /*  this is the "direct" freeing function, without checking for perfomance */
-int obj_free(struct t_process *p,int32_t oid)
+int obj_free(struct t_process *p, int32_t oid)
 {
 	int32_t i;
 	GLuint t;
-	struct t_obj *o=p->object[oid];
-	s3dprintf(HIGH,"deleting object %d of process %d",oid,p->id);
+	struct t_obj *o = p->object[oid];
+	s3dprintf(HIGH, "deleting object %d of process %d", oid, p->id);
 
 	/* clearing links */
-	if (o->linkid!=-1)		link_delete(p,oid);
-	while (o->lsub!=-1) {
-		i=o->lsub;
-		link_delete(p,o->lsub);
-		if (i==o->lsub) {
-			s3dprintf(HIGH,"something is wrong!!");
-			o=NULL; /* segfault */
-			o->lsub=-1;
+	if (o->linkid != -1)  link_delete(p, oid);
+	while (o->lsub != -1) {
+		i = o->lsub;
+		link_delete(p, o->lsub);
+		if (i == o->lsub) {
+			s3dprintf(HIGH, "something is wrong!!");
+			o = NULL; /* segfault */
+			o->lsub = -1;
 		}
 	}
 
 	if (!(o->oflags&OF_NODATA)) {
-		if (o->n_vertex>0) free(o->p_vertex);
-		if (o->n_poly>0) free(o->p_poly);
-		if (o->n_mat>0) free(o->p_mat);
-		for (i=0;i<o->n_tex;i++) {
-			if (o->p_tex[i].buf!=NULL)
+		if (o->n_vertex > 0) free(o->p_vertex);
+		if (o->n_poly > 0) free(o->p_poly);
+		if (o->n_mat > 0) free(o->p_mat);
+		for (i = 0;i < o->n_tex;i++) {
+			if (o->p_tex[i].buf != NULL)
 				free(o->p_tex[i].buf);
 			if (o->p_tex[i].gl_texnum) {
-				t=o->p_tex[i].gl_texnum;
-				glDeleteTextures(1,&t);
+				t = o->p_tex[i].gl_texnum;
+				glDeleteTextures(1, &t);
 			}
 		}
-		if (o->n_tex>0) free(o->p_tex);
+		if (o->n_tex > 0) free(o->p_tex);
 
 	}
 	if (o->dplist) {
-		if (!(o->oflags&(OF_CLONE|OF_SYSTEM))) {
-			s3dprintf(VLOW,"freeing display list %d",o->dplist);
-			glDeleteLists(o->dplist,1);
+		if (!(o->oflags&(OF_CLONE | OF_SYSTEM))) {
+			s3dprintf(VLOW, "freeing display list %d", o->dplist);
+			glDeleteLists(o->dplist, 1);
 		}
 	}
 	free(o);
-	p->object[oid]=NULL;
-	if (oid==(p->n_obj-1)) {
-		i=oid;
-		while ((i!=-1) && (p->object[i]==NULL)) i--;
-		p->n_obj=i+1;
-		p->object=realloc(p->object,sizeof(struct t_obj *)*(p->n_obj));
+	p->object[oid] = NULL;
+	if (oid == (p->n_obj - 1)) {
+		i = oid;
+		while ((i != -1) && (p->object[i] == NULL)) i--;
+		p->n_obj = i + 1;
+		p->object = realloc(p->object, sizeof(struct t_obj *) * (p->n_obj));
 	}
 	return(0);
 }
@@ -1956,9 +1956,9 @@
 int32_t get_pointer(struct t_process *p)
 {
 	int32_t i;
-	for (i=0;i<p->n_obj;i++) {
+	for (i = 0;i < p->n_obj;i++) {
 
-		if (OF_POINTER==(p->object[i]->oflags&0xF0000000)) {
+		if (OF_POINTER == (p->object[i]->oflags&0xF0000000)) {
 			return(i);
 		}
 	}

Modified: trunk/server/process.c
===================================================================
--- trunk/server/process.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/process.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,13 +24,13 @@
 
 #include "global.h"
 #include <stdlib.h>  /*  for malloc, free */
-#include <string.h>	 /*  strncmp(), strncpy() */
+#include <string.h>  /*  strncmp(), strncpy() */
 /*  this piece of code handles processes */
 
 #define mcp_p (&procs_p[0])
-struct t_process  *procs_p=NULL;				/* pointer to the processes */
-int 			   procs_n; 					/* number of processes */
-static int p_del(struct t_process *p);			/*  local prototype */
+struct t_process  *procs_p = NULL;  /* pointer to the processes */
+int       procs_n;      /* number of processes */
+static int p_del(struct t_process *p);   /*  local prototype */
 static int process_list_rm(int pid);
 int process_sys_init(struct t_process *p);
 
@@ -38,29 +38,29 @@
 struct t_process *process_protinit(struct t_process *p, char *name) {
 	int con_type;
 	int32_t mcp_oid;
-	if ((strncmp(name,"sys_",4)==0)) { /* we don't like "sys_"-apps, kicking this */
-		errds(VHIGH,"process_protinit()","appnames starting with 'sys_' not allowed.");
+	if ((strncmp(name, "sys_", 4) == 0)) { /* we don't like "sys_"-apps, kicking this */
+		errds(VHIGH, "process_protinit()", "appnames starting with 'sys_' not allowed.");
 		return(NULL);
 	}
-	if ((p->id!=MCP) && (strncmp(name,"mcp",3)==0)) {
-		if (procs_p[MCP].con_type==CON_NULL) {
-			s3dprintf(MED,"free mcp place, pid %d becoming mcp!",p->id);
-			con_type=p->con_type; /* move connection data */
+	if ((p->id != MCP) && (strncmp(name, "mcp", 3) == 0)) {
+		if (procs_p[MCP].con_type == CON_NULL) {
+			s3dprintf(MED, "free mcp place, pid %d becoming mcp!", p->id);
+			con_type = p->con_type; /* move connection data */
 #ifdef TCP
-			procs_p[MCP].sockid=p->sockid; /* don't save contype yet,
-									or p_del will notify mcp about a deleted
-									mcp-object (which is itselfs, actually) */
+			procs_p[MCP].sockid = p->sockid; /* don't save contype yet,
+         or p_del will notify mcp about a deleted
+         mcp-object (which is itselfs, actually) */
 #endif
 #ifdef SHM
-			memcpy(&procs_p[MCP].shmsock,&p->shmsock,sizeof(struct t_shmcb));
+			memcpy(&procs_p[MCP].shmsock, &p->shmsock, sizeof(struct t_shmcb));
 #endif
 			p_del(p); /* deleting data/mcp object */
-			procs_p[MCP].con_type=con_type;
+			procs_p[MCP].con_type = con_type;
 			mcp_init();
 			process_list_rm(p->id); /* remove old process, but don't kill connection */
 			return(&procs_p[MCP]);
 		} else {
-			s3dprintf(LOW,"the place for the mcp is already taken ...");
+			s3dprintf(LOW, "the place for the mcp is already taken ...");
 			return(NULL);
 		}
 	} else {
@@ -68,20 +68,20 @@
 		process_sys_init(p);
 
 		/* register the new process in the mcp */
-		if (-1!=(mcp_oid= obj_new(&procs_p[MCP]))) {
-			mcp_p->object[mcp_oid]->oflags|=OF_VIRTUAL|OF_VISIBLE|OF_SELECTABLE;
-			mcp_p->object[mcp_oid]->n_mat=p->id;
+		if (-1 != (mcp_oid = obj_new(&procs_p[MCP]))) {
+			mcp_p->object[mcp_oid]->oflags |= OF_VIRTUAL | OF_VISIBLE | OF_SELECTABLE;
+			mcp_p->object[mcp_oid]->n_mat = p->id;
 
-			/* 		mcp_p->object[mcp_oid]->p_mat=(struct t_material *)new_p; */
+			/*   mcp_p->object[mcp_oid]->p_mat=(struct t_material *)new_p; */
 			/*  dirty, but it's just a pointer after all ... */
-			p->mcp_oid=mcp_oid;
-			s3dprintf(LOW,"process %d now has mcp_oid %d",p->id,mcp_oid);
+			p->mcp_oid = mcp_oid;
+			s3dprintf(LOW, "process %d now has mcp_oid %d", p->id, mcp_oid);
 			mcp_rep_object(mcp_oid);
-			if (mcp_p->con_type==CON_NULL) { /*  there is no mcp connected! setting focus to the new program: */
+			if (mcp_p->con_type == CON_NULL) { /*  there is no mcp connected! setting focus to the new program: */
 				mcp_focus(mcp_oid);
 			}
 		} else {
-			s3dprintf(LOW,"couldn't add object to mcp ...");
+			s3dprintf(LOW, "couldn't add object to mcp ...");
 		}
 	}
 	return(p);
@@ -89,38 +89,38 @@
 /* adds system objects to the app, like camera, pointers etc ... */
 int process_sys_init(struct t_process *p)
 {
-	int cam,ptr;
+	int cam, ptr;
 	struct t_obj *o;
-	cam=obj_new(p);
-	ptr=obj_new(p);
-	if (p->id==MCP) {   /* this is only called once within process_init, later mcp's are
-		   will be registered as "real" apps first */
-		p->object[cam]->translate.z=5;
-		p->object[cam]->oflags=OF_CAM;
-		p->object[ptr]->translate.z=-1;
-		p->object[ptr]->oflags=OF_POINTER;
-		link_insert(p,ptr,cam);
+	cam = obj_new(p);
+	ptr = obj_new(p);
+	if (p->id == MCP) {   /* this is only called once within process_init, later mcp's are
+     will be registered as "real" apps first */
+		p->object[cam]->translate.z = 5;
+		p->object[cam]->oflags = OF_CAM;
+		p->object[ptr]->translate.z = -1;
+		p->object[ptr]->oflags = OF_POINTER;
+		link_insert(p, ptr, cam);
 	} else {
 		/* TODO: ... get the cam and ptr position of the mcp, somehow */
-		p->object[cam]->oflags=OF_CAM;
+		p->object[cam]->oflags = OF_CAM;
 
-		if (OBJ_VALID(mcp_p,get_pointer(mcp_p),o)) { /* get parent pointer, copy parent */
-			p->object[ptr]->rotate.x=o->rotate.x;
-			p->object[ptr]->rotate.y=o->rotate.y;
-			p->object[ptr]->rotate.z=o->rotate.z;
-			p->object[ptr]->translate.x=o->translate.x;
-			p->object[ptr]->translate.y=o->translate.y;
-			p->object[ptr]->translate.z=o->translate.z;
+		if (OBJ_VALID(mcp_p, get_pointer(mcp_p), o)) { /* get parent pointer, copy parent */
+			p->object[ptr]->rotate.x = o->rotate.x;
+			p->object[ptr]->rotate.y = o->rotate.y;
+			p->object[ptr]->rotate.z = o->rotate.z;
+			p->object[ptr]->translate.x = o->translate.x;
+			p->object[ptr]->translate.y = o->translate.y;
+			p->object[ptr]->translate.z = o->translate.z;
 		}
-		p->object[ptr]->oflags=OF_POINTER;
-		link_insert(p,ptr,cam);
+		p->object[ptr]->oflags = OF_POINTER;
+		link_insert(p, ptr, cam);
 	}
-	s3dprintf(MED,"process_sys_init(): added object cam0 %d",cam);
-	s3dprintf(MED,"process_sys_init(): added object ptr0 %d",ptr);
-	obj_pos_update(get_proc_by_pid(MCP),cam,cam);
-	obj_pos_update(get_proc_by_pid(MCP),ptr,ptr);
-	/*	obj_recalc_tmat(p,0);*/
-	event_obj_info(p,0); /* tell the new program about the thing */
+	s3dprintf(MED, "process_sys_init(): added object cam0 %d", cam);
+	s3dprintf(MED, "process_sys_init(): added object ptr0 %d", ptr);
+	obj_pos_update(get_proc_by_pid(MCP), cam, cam);
+	obj_pos_update(get_proc_by_pid(MCP), ptr, ptr);
+	/* obj_recalc_tmat(p,0);*/
+	event_obj_info(p, 0); /* tell the new program about the thing */
 
 	return(0);
 }
@@ -129,30 +129,30 @@
 struct t_process *process_add() {
 	struct t_process *new_p;
 	procs_n++;
-	procs_p=realloc(procs_p,sizeof(struct t_process)*procs_n); /* increase the block */
-	new_p=&procs_p[procs_n-1];
+	procs_p = realloc(procs_p, sizeof(struct t_process)*procs_n); /* increase the block */
+	new_p = &procs_p[procs_n-1];
 
-	new_p->id	  = procs_n-1;
-	/*	if (new_p->id==0)
-			mcp_p=&procs_p[0];*/
+	new_p->id   = procs_n - 1;
+	/* if (new_p->id==0)
+	  mcp_p=&procs_p[0];*/
 	new_p->object = NULL;
 	new_p->n_obj  = 0;
-	/*	new_p->netin  = 0;*/
+	/* new_p->netin  = 0;*/
 	new_p->mcp_oid = -1;
-	new_p->biggest_obj=-1;
-	new_p->con_type=CON_NULL;	/* this is to be changed by the caller */
-	new_p->name[0]='\0';
+	new_p->biggest_obj = -1;
+	new_p->con_type = CON_NULL; /* this is to be changed by the caller */
+	new_p->name[0] = '\0';
 	return(new_p);
 }
 /* deletes the process with pid */
 int process_del(int pid)
 {
-	if (pid==MCP) {
+	if (pid == MCP) {
 		n_remove(&procs_p[pid]);
 		p_del(&procs_p[pid]);
 		return(0);
 	}
-	if ((pid>0) && (pid<procs_n)) {
+	if ((pid > 0) && (pid < procs_n)) {
 		n_remove(&procs_p[pid]);
 		p_del(&procs_p[pid]);
 		process_list_rm(pid);
@@ -163,21 +163,21 @@
 /* just kick process out of the process list, no network/mcp-oid cleanup */
 int process_list_rm(int pid)
 {
-	if (pid!=(procs_n-1)) { /* copy last block, swap pid */
-		memcpy(&procs_p[pid],&procs_p[procs_n-1],sizeof(struct t_process));
-		procs_p[pid].id=pid; /* change the pid of the new procs_p */
-		if (procs_p[pid].mcp_oid!=-1) /* the last process could just appear without initializing yet ... */
-			procs_p[0].object[procs_p[pid].mcp_oid]->n_mat=pid;
+	if (pid != (procs_n - 1)) { /* copy last block, swap pid */
+		memcpy(&procs_p[pid], &procs_p[procs_n-1], sizeof(struct t_process));
+		procs_p[pid].id = pid; /* change the pid of the new procs_p */
+		if (procs_p[pid].mcp_oid != -1) /* the last process could just appear without initializing yet ... */
+			procs_p[0].object[procs_p[pid].mcp_oid]->n_mat = pid;
 		/* change the mcp-objects pid-pointer to the right position! */
 		/* this is kind of pointer madness */
 	}
 	procs_n--;
-	procs_p=realloc(procs_p,sizeof(struct t_process)*procs_n); /* decrease the block,
-		wipe the last one */
+	procs_p = realloc(procs_p, sizeof(struct t_process) * procs_n); /* decrease the block,
+  wipe the last one */
 	return(0);
 }
 struct t_process *get_proc_by_pid(int pid) {
-	if ((pid>=0) && (pid<procs_n))
+	if ((pid >= 0) && (pid < procs_n))
 		return(&procs_p[pid]);
 	return(NULL);
 }
@@ -185,58 +185,58 @@
 /* it's quite the same as the original version, but without free() */
 static int p_del(struct t_process *p)
 {
-	int j,i=p->n_obj;
-	if (p->id!=MCP) {
-		if (p->mcp_oid!=-1) {
-			for (j=0;j<mcp_p->n_obj;j++)	 /*  remove clones and links pointing on this app-object ... */
-				if (mcp_p->object[j]!=NULL) {
+	int j, i = p->n_obj;
+	if (p->id != MCP) {
+		if (p->mcp_oid != -1) {
+			for (j = 0;j < mcp_p->n_obj;j++)  /*  remove clones and links pointing on this app-object ... */
+				if (mcp_p->object[j] != NULL) {
 					if ((mcp_p->object[j]->oflags&OF_CLONE) && (mcp_p->object[j]->n_vertex == p->mcp_oid)) { /*  it's linking to our object! */
-						mcp_p->object[j]->oflags&=~OF_CLONE;  	 /*  disable clone flag */
-						mcp_p->object[j]->n_vertex=0; 			 /*  and "clone reference" to 0 */
-						mcp_p->object[j]->r=0.0F;				 /*  empty object, so radius is zero! */
+						mcp_p->object[j]->oflags &= ~OF_CLONE;  /*  disable clone flag */
+						mcp_p->object[j]->n_vertex = 0;   /*  and "clone reference" to 0 */
+						mcp_p->object[j]->r = 0.0F;   /*  empty object, so radius is zero! */
 					}
 				}
-			obj_free(mcp_p,p->mcp_oid); 	 /*  free the mcp-app-object. */
-			mcp_del_object(p->mcp_oid); 	 /*  tell MCP that it's object is beeing deleted. */
+			obj_free(mcp_p, p->mcp_oid);  /*  free the mcp-app-object. */
+			mcp_del_object(p->mcp_oid);   /*  tell MCP that it's object is beeing deleted. */
 		} else /*
-			errs("p_del()","bad mcp_oid, unable to free mcp object");*/
-			if (i>0) {
-				for (i=0;i<p->n_obj;i++)
-					if (p->object[i]) obj_free(p,i);
+   errs("p_del()","bad mcp_oid, unable to free mcp object");*/
+			if (i > 0) {
+				for (i = 0;i < p->n_obj;i++)
+					if (p->object[i]) obj_free(p, i);
 				free(p->object);
 			}
 	} else {
 		/*  the mcp keeps in our memory ... */
 		/*  so we just delete the objects added */
 		/*  by the last mcp */
-		s3dprintf(MED,"clean up mcp's junk ...");
-		for (i=0;i<p->n_obj;i++) {
-			if (p->object[i]!=NULL)
-				if (!(p->object[i]->oflags&(OF_SYSTEM|OF_VIRTUAL)))
-					obj_free(p,i);
+		s3dprintf(MED, "clean up mcp's junk ...");
+		for (i = 0;i < p->n_obj;i++) {
+			if (p->object[i] != NULL)
+				if (!(p->object[i]->oflags&(OF_SYSTEM | OF_VIRTUAL)))
+					obj_free(p, i);
 		}
 	}
 	return(0);  /*  successfully deleted */
 }
 int process_init()
 {
-	procs_n=0;
-	procs_p=NULL;
+	procs_n = 0;
+	procs_p = NULL;
 	process_add();
 	/* set up mcp */
-	strncpy(mcp_p->name,"mcp",NAME_MAX);
-	mcp_p->con_type=CON_NULL;
+	strncpy(mcp_p->name, "mcp", NAME_MAX);
+	mcp_p->con_type = CON_NULL;
 	process_sys_init(mcp_p);
 	return(0);
 }
 int process_quit()
 {
 	int i;
-	s3dprintf(HIGH,"telling %d processes to go away",procs_n);
-	for (i=(procs_n-1);i>=0;i--) {
-		s3dprintf(HIGH,"[QUIT] for %d",i);
+	s3dprintf(HIGH, "telling %d processes to go away", procs_n);
+	for (i = (procs_n - 1);i >= 0;i--) {
+		s3dprintf(HIGH, "[QUIT] for %d", i);
 		event_quit(&procs_p[i]);
-		/*		process_del(procs_p[i].id);*/
+		/*  process_del(procs_p[i].id);*/
 	}
 	free(procs_p);
 	return(0);

Modified: trunk/server/proto.c
===================================================================
--- trunk/server/proto.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/proto.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -35,361 +35,361 @@
 /*  this code should do the protocol work .... */
 /*  */
 extern uint8_t obuf[MAXPLEN];
-int focus_oid=-1;  /*  initially focus the pid */
+int focus_oid = -1;  /*  initially focus the pid */
 /*  handle an incoming command from the client .. */
 
 
 int prot_com_in(struct t_process *p, uint8_t *pbuf)
 {
-	uint8_t 	command;
-	int 	i;
-	char 	name[NAME_MAX];
+	uint8_t  command;
+	int  i;
+	char  name[NAME_MAX];
 	struct t_process *np;
-	uint8_t	*buf,*cptr=NULL;
+	uint8_t *buf, *cptr = NULL;
 	uint16_t length;
 	uint16_t num;
-	uint16_t w,h,x,y;
-	uint32_t oid,toid;
-	uint8_t	type;
-	int32_t flags,mcp_oid=-1;
-	command=pbuf[0];
-	if (p->id!=0) {
-		mcp_oid=p->mcp_oid;		 /*  get mcp-oid if we need to report something to */
+	uint16_t w, h, x, y;
+	uint32_t oid, toid;
+	uint8_t type;
+	int32_t flags, mcp_oid = -1;
+	command = pbuf[0];
+	if (p->id != 0) {
+		mcp_oid = p->mcp_oid; /*  get mcp-oid if we need to report something to */
 		/*  the mcp */
-		if ((mcp_oid==-1) && (command!=S3D_P_C_INIT)) {
-			s3dprintf(MED,"prot_com_in(): commands without beeing initialized ?! no way, kicking ...");
+		if ((mcp_oid == -1) && (command != S3D_P_C_INIT)) {
+			s3dprintf(MED, "prot_com_in(): commands without beeing initialized ?! no way, kicking ...");
 			event_quit(p);
 		}
 	}
-	length=ntohs(*((uint16_t *)((uint8_t *)pbuf+1)));
-	cptr=buf=pbuf+3;
-	/* 	if (mcp_oid==-1) s3dprintf(HIGH,"couldn't find mcp-oid for pid %d!",p->id); */
+	length = ntohs(*((uint16_t *)((uint8_t *)pbuf + 1)));
+	cptr = buf = pbuf + 3;
+	/*  if (mcp_oid==-1) s3dprintf(HIGH,"couldn't find mcp-oid for pid %d!",p->id); */
 	switch (command) {
 	case S3D_P_C_INIT:
-		memset(name,0,NAME_MAX);
-		if (length>NAME_MAX) i=NAME_MAX;
-		else i=length;
-		strncpy(name,(char *)buf,i);
-		s3dprintf(LOW,"[%d]\"%s\" logged in", p->id,name);
-		if (NULL==(np=process_protinit(p,name)))
+		memset(name, 0, NAME_MAX);
+		if (length > NAME_MAX) i = NAME_MAX;
+		else i = length;
+		strncpy(name, (char *)buf, i);
+		s3dprintf(LOW, "[%d]\"%s\" logged in", p->id, name);
+		if (NULL == (np = process_protinit(p, name)))
 			event_quit(p);  /*  couldn't get process */
 		else
 			event_init(np);
 		break;
 	case S3D_P_C_NEW_OBJ:
-		oid=htonl(obj_new(p));
-		/* 				s3dprintf(LOW,"pid %d registering new object %d",p->id,ntohl(oid)); */
-		prot_com_out(p,S3D_P_S_NEWOBJ,(uint8_t *)&oid, 4);
+		oid = htonl(obj_new(p));
+		/*     s3dprintf(LOW,"pid %d registering new object %d",p->id,ntohl(oid)); */
+		prot_com_out(p, S3D_P_S_NEWOBJ, (uint8_t *)&oid, 4);
 		break;
 	case S3D_P_C_DEL_OBJ:
-		if (length==4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			obj_del(p,oid);
+		if (length == 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			obj_del(p, oid);
 		}
 		break;
 	case S3D_P_C_CLONE:
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			obj_clone_change(p,oid,toid);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			obj_clone_change(p, oid, toid);
 		}
 		break;
 	case S3D_P_C_LINK:
-		if (length==4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			obj_unlink(p,oid);
+		if (length == 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			obj_unlink(p, oid);
 		}
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			obj_link(p,oid,toid);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			obj_link(p, oid, toid);
 		}
 		break;
 	case S3D_P_C_QUIT:
-		s3dprintf(LOW,"QUIT issued");
+		s3dprintf(LOW, "QUIT issued");
 		event_quit(p);
 		break;
 	case S3D_P_C_PUSH_VERTEX:
-		if (length>4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*3);
-			/* 					s3dprintf(LOW,"received %d new vertices for object oid...%d", num, oid); */
-			obj_push_vertex(p,oid, (float  *)cptr, num);
+		if (length > 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 3);
+			/*      s3dprintf(LOW,"received %d new vertices for object oid...%d", num, oid); */
+			obj_push_vertex(p, oid, (float  *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PUSH_MAT:
-		if (length>4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*12);
-			/* 					s3dprintf(LOW,"received %d new materials for object oid...%d", num, oid); */
-			obj_push_mat(p,oid, (float *)cptr, num);
+		if (length > 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 12);
+			/*      s3dprintf(LOW,"received %d new materials for object oid...%d", num, oid); */
+			obj_push_mat(p, oid, (float *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PUSH_POLY:
-		if (length>4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*4);
-			/* 					s3dprintf(LOW,"received %d new polygons for object oid...%d", num, oid); */
-			for (i=0;i<(num*4);i++)
-				*((uint32_t *)cptr+i)=
-				        ntohl(*((uint32_t *)cptr+i));
+		if (length > 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 4);
+			/*      s3dprintf(LOW,"received %d new polygons for object oid...%d", num, oid); */
+			for (i = 0;i < (num*4);i++)
+				*((uint32_t *)cptr + i) =
+				        ntohl(*((uint32_t *)cptr + i));
 			/*  convert index names */
-			obj_push_poly(p,oid, (uint32_t *)cptr, num);
+			obj_push_poly(p, oid, (uint32_t *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PUSH_LINE:
-		if (length>4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*3);
-			s3dprintf(VLOW,"received %d new lines for object oid...%d", num, oid);
-			for (i=0;i<(num*3);i++)
-				*((uint32_t *)cptr+i)=
-				        ntohl(*((uint32_t *)cptr+i));
+		if (length > 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 3);
+			s3dprintf(VLOW, "received %d new lines for object oid...%d", num, oid);
+			for (i = 0;i < (num*3);i++)
+				*((uint32_t *)cptr + i) =
+				        ntohl(*((uint32_t *)cptr + i));
 			/*  convert index names */
-			obj_push_line(p,oid, (uint32_t *)cptr, num);
+			obj_push_line(p, oid, (uint32_t *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PUSH_TEX:
-		if (length>4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(2*2);
-			s3dprintf(LOW,"received %d new textures for object oid...%d", num, oid);
-			for (i=0;i<(num*2);i++)
-				*((uint16_t *)cptr+i)=
-				        ntohs(*((uint16_t *)cptr+i));
+		if (length > 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (2 * 2);
+			s3dprintf(LOW, "received %d new textures for object oid...%d", num, oid);
+			for (i = 0;i < (num*2);i++)
+				*((uint16_t *)cptr + i) =
+				        ntohs(*((uint16_t *)cptr + i));
 			/*  convert index names */
-			obj_push_tex(p,oid, (uint16_t *)cptr, num);
+			obj_push_tex(p, oid, (uint16_t *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PEP_POLY_NORMAL:
-		if (length>4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(9*4);
-			s3dprintf(VLOW,"PEP_POLY_NORMAL[%d]: oid %d, %f polys",length,oid, (length-4)/(9.0*4.0));
-			obj_pep_poly_normal(p,oid, (float *)cptr, num);
+		if (length > 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (9 * 4);
+			s3dprintf(VLOW, "PEP_POLY_NORMAL[%d]: oid %d, %f polys", length, oid, (length - 4) / (9.0*4.0));
+			obj_pep_poly_normal(p, oid, (float *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PEP_LINE_NORMAL:
-		if (length>4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(6*4);
-			s3dprintf(VLOW,"PEP_LINE_NORMAL[%d]: oid %d, %.1f lines",length,oid, (length-4)/(6.0*4.0));
-			obj_pep_line_normal(p,oid, (float *)cptr, num);
+		if (length > 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (6 * 4);
+			s3dprintf(VLOW, "PEP_LINE_NORMAL[%d]: oid %d, %.1f lines", length, oid, (length - 4) / (6.0*4.0));
+			obj_pep_line_normal(p, oid, (float *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PEP_POLY_TEXC:
-		if (length>4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(6*4);
-			s3dprintf(VLOW,"PEP_POLY_TEXC[%d]: oid %d, %f polys",length,oid, (length-4)/(6.0*4.0));
-			obj_pep_poly_texc(p,oid, (float *)cptr, num);
+		if (length > 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (6 * 4);
+			s3dprintf(VLOW, "PEP_POLY_TEXC[%d]: oid %d, %f polys", length, oid, (length - 4) / (6.0*4.0));
+			obj_pep_poly_texc(p, oid, (float *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PEP_MAT:
-		if (length>4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*12);
-			s3dprintf(VLOW,"PEP_MAT[%d]: %d materials for object oid...%d", length, num, oid);
-			obj_pep_mat(p,oid, (float *)cptr, num);
+		if (length > 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 12);
+			s3dprintf(VLOW, "PEP_MAT[%d]: %d materials for object oid...%d", length, num, oid);
+			obj_pep_mat(p, oid, (float *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PEP_VERTEX:
-		if (length>4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*3);
-			s3dprintf(VLOW,"pepping %d new vertices for object oid...%d", num, oid);
-			obj_pep_vertex(p,oid, (float  *)cptr, num);
+		if (length > 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 3);
+			s3dprintf(VLOW, "pepping %d new vertices for object oid...%d", num, oid);
+			obj_pep_vertex(p, oid, (float  *)cptr, num);
 		}
 		break;
 
 	case S3D_P_C_PEP_MAT_TEX:
-		if (length>4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4);
-			s3dprintf(VLOW,"PEP_MAT_TEX[%d]: %d materials for object oid...%d", length, num, oid);
-			obj_pep_mat_tex(p,oid, (uint32_t *)cptr, num);
+		if (length > 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4);
+			s3dprintf(VLOW, "PEP_MAT_TEX[%d]: %d materials for object oid...%d", length, num, oid);
+			obj_pep_mat_tex(p, oid, (uint32_t *)cptr, num);
 		}
 		break;
 	case S3D_P_C_PEP_LINE:
-		if (length>4) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-4)/(4*3);
-			s3dprintf(VLOW,"pepping %d new lines for object oid...%d", num, oid);
-			for (i=0;i<(num*3);i++)
-				*((uint32_t *)cptr+i)=
-				        ntohl(*((uint32_t *)cptr+i));
-			obj_pep_line(p,oid, (uint32_t *)cptr, num);
+		if (length > 4) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 4) / (4 * 3);
+			s3dprintf(VLOW, "pepping %d new lines for object oid...%d", num, oid);
+			for (i = 0;i < (num*3);i++)
+				*((uint32_t *)cptr + i) =
+				        ntohl(*((uint32_t *)cptr + i));
+			obj_pep_line(p, oid, (uint32_t *)cptr, num);
 		}
 		break;
 	case S3D_P_C_LOAD_LINE_NORMAL:
-		if (length>8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-8)/(6*4);
-			s3dprintf(VLOW,"LOAD_POLY_NORMAL[%d]: oid %d, %.2f lines",length,oid, (length-8)/(6.0*4.0));
-			obj_load_line_normal(p,oid, (float *)cptr, toid, num);
+		if (length > 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 8) / (6 * 4);
+			s3dprintf(VLOW, "LOAD_POLY_NORMAL[%d]: oid %d, %.2f lines", length, oid, (length - 8) / (6.0*4.0));
+			obj_load_line_normal(p, oid, (float *)cptr, toid, num);
 		}
 		break;
 	case S3D_P_C_LOAD_POLY_NORMAL:
-		if (length>8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-8)/(9*4);
-			s3dprintf(MED,"LOAD_POLY_NORMAL[%d]: oid %d, %f polys",length,oid, (length-8)/(9.0*4.0));
-			obj_load_poly_normal(p,oid, (float *)cptr, toid, num);
+		if (length > 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 8) / (9 * 4);
+			s3dprintf(MED, "LOAD_POLY_NORMAL[%d]: oid %d, %f polys", length, oid, (length - 8) / (9.0*4.0));
+			obj_load_poly_normal(p, oid, (float *)cptr, toid, num);
 		}
 		break;
 	case S3D_P_C_LOAD_POLY_TEXC:
-		if (length>8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-8)/(6*4);
-			s3dprintf(MED,"LOAD_POLY_TEXC[%d]: oid %d, %f polys",length,oid, (length-8)/(6.0*4.0));
-			obj_load_poly_texc(p,oid, (float *)cptr, toid, num);
+		if (length > 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 8) / (6 * 4);
+			s3dprintf(MED, "LOAD_POLY_TEXC[%d]: oid %d, %f polys", length, oid, (length - 8) / (6.0*4.0));
+			obj_load_poly_texc(p, oid, (float *)cptr, toid, num);
 		}
 		break;
 	case S3D_P_C_LOAD_MAT:
-		if (length>8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=(length-8)/(4*12);
-			s3dprintf(LOW,"LOAD_MAT[%d]: %d materials for object oid...%d", length, num, oid);
-			obj_load_mat(p,oid, (float *)cptr, toid, num);
+		if (length > 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = (length - 8) / (4 * 12);
+			s3dprintf(LOW, "LOAD_MAT[%d]: %d materials for object oid...%d", length, num, oid);
+			obj_load_mat(p, oid, (float *)cptr, toid, num);
 		}
 		break;
 	case S3D_P_C_LOAD_TEX:
-		if (length>8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			toid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			x=ntohs(*((uint16_t *)cptr));
-			cptr+=2;
-			y=ntohs(*((uint16_t *)cptr));
-			cptr+=2;
-			w=ntohs(*((uint16_t *)cptr));
-			cptr+=2;
-			h=ntohs(*((uint16_t *)cptr));
-			cptr+=2;
-			num=length-16;
-			/* 				s3dprintf(MED,"LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)",length, oid,toid,w,h,x,y,num,w*h*4,num); */
-			if ((w*h*4)==num)  /*  check correct size */
-				obj_load_tex(p,oid, toid, x, y, w, h, cptr);
+		if (length > 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			toid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			x = ntohs(*((uint16_t *)cptr));
+			cptr += 2;
+			y = ntohs(*((uint16_t *)cptr));
+			cptr += 2;
+			w = ntohs(*((uint16_t *)cptr));
+			cptr += 2;
+			h = ntohs(*((uint16_t *)cptr));
+			cptr += 2;
+			num = length - 16;
+			/*     s3dprintf(MED,"LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)",length, oid,toid,w,h,x,y,num,w*h*4,num); */
+			if ((w*h*4) == num)  /*  check correct size */
+				obj_load_tex(p, oid, toid, x, y, w, h, cptr);
 		}
 		break;
 	case S3D_P_C_DEL_VERTEX:
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			/* 					s3dprintf(LOW,"deleting %d vertices for object oid...%d", num, oid); */
-			obj_del_vertex(p,oid,num);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			/*      s3dprintf(LOW,"deleting %d vertices for object oid...%d", num, oid); */
+			obj_del_vertex(p, oid, num);
 		}
 		break;
 	case S3D_P_C_DEL_POLY:
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			/* 					s3dprintf(LOW,"deleting %d vertices for object oid...%d", num, oid); */
-			obj_del_poly(p,oid,num);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			/*      s3dprintf(LOW,"deleting %d vertices for object oid...%d", num, oid); */
+			obj_del_poly(p, oid, num);
 		}
 		break;
 	case S3D_P_C_DEL_LINE:
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			s3dprintf(VLOW,"deleting %d lines for object oid...%d", num, oid);
-			obj_del_line(p,oid,num);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			s3dprintf(VLOW, "deleting %d lines for object oid...%d", num, oid);
+			obj_del_line(p, oid, num);
 		}
 		break;
 
 	case S3D_P_C_DEL_MAT:
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			/* 					s3dprintf(LOW,"deleting %d materials for object oid...%d", num, oid); */
-			obj_del_mat(p,oid,num);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			/*      s3dprintf(LOW,"deleting %d materials for object oid...%d", num, oid); */
+			obj_del_mat(p, oid, num);
 		}
 		break;
 	case S3D_P_C_DEL_TEX:
-		if (length==8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			num=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			/* 					s3dprintf(LOW,"deleting %d textures for object oid...%d", num, oid); */
-			obj_del_tex(p,oid,num);
+		if (length == 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			num = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			/*      s3dprintf(LOW,"deleting %d textures for object oid...%d", num, oid); */
+			obj_del_tex(p, oid, num);
 		}
 		break;
 	case S3D_P_C_TOGGLE_FLAGS:
-		if (length==9) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			type=*cptr;
-			cptr+=1;
-			flags=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			obj_toggle_flags(p,oid, type, flags);
+		if (length == 9) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			type = *cptr;
+			cptr += 1;
+			flags = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			obj_toggle_flags(p, oid, type, flags);
 		}
 		break;
 	case S3D_P_C_TRANSLATE:
-		if (length>=16) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			obj_translate(p,oid,(float *)cptr);
+		if (length >= 16) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			obj_translate(p, oid, (float *)cptr);
 		}
 		break;
 	case S3D_P_C_ROTATE:
-		if (length>=16) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			obj_rotate(p,oid,(float *)cptr);
+		if (length >= 16) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			obj_rotate(p, oid, (float *)cptr);
 		}
 		break;
 	case S3D_P_C_SCALE:
-		if (length>=8) {
-			oid=ntohl(*((uint32_t *)cptr));
-			cptr+=4;
-			obj_scale(p,oid,*((float *)cptr));
+		if (length >= 8) {
+			oid = ntohl(*((uint32_t *)cptr));
+			cptr += 4;
+			obj_scale(p, oid, *((float *)cptr));
 		}
 		break;
 	case S3D_P_MCP_FOCUS:
-		if ((p->id==MCP) && (length==4)) {
-			oid=ntohl(*((uint32_t *)cptr));
+		if ((p->id == MCP) && (length == 4)) {
+			oid = ntohl(*((uint32_t *)cptr));
 			mcp_focus(oid);
 		}
 		break;
 	default:
-		s3dprintf(LOW,"don't know this command (%d)",command);
+		s3dprintf(LOW, "don't know this command (%d)", command);
 	}
 	return(0);
 }
@@ -397,14 +397,14 @@
 int prot_com_out(struct t_process *p, uint8_t opcode, uint8_t *buf, uint16_t length)
 {
 	uint8_t *ptr;
-	if (p->con_type!=CON_NULL) {
-		*(obuf)=opcode;
-		ptr=obuf+1;
-		*((uint16_t *) ptr)=htons(length);
+	if (p->con_type != CON_NULL) {
+		*(obuf) = opcode;
+		ptr = obuf + 1;
+		*((uint16_t *) ptr) = htons(length);
 		if (length)
-			memcpy(obuf+3,buf,length);
-		if (n_writen(p,obuf,length+3)<0) {
-			s3dprintf(LOW,"prot_com_out():n_writen(): connection seems to be dead (pid %d)", p->id);
+			memcpy(obuf + 3, buf, length);
+		if (n_writen(p, obuf, length + 3) < 0) {
+			s3dprintf(LOW, "prot_com_out():n_writen(): connection seems to be dead (pid %d)", p->id);
 			process_del(p->id);
 		}
 		return(0);

Modified: trunk/server/proto.h
===================================================================
--- trunk/server/proto.h	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/proto.h	2007-09-17 13:51:17 UTC (rev 667)
@@ -34,151 +34,151 @@
 /*  C/S defines if who can invoke the command  */
 /*  */
 /*  every command is 1 byte long, arguments differ. */
-#define S3D_P_C_INIT			1
-/*  max 256b: 	name */
-#define S3D_P_C_QUIT			2  /*  no argument */
+#define S3D_P_C_INIT   1
+/*  max 256b:  name */
+#define S3D_P_C_QUIT   2  /*  no argument */
 
-#define S3D_P_C_NEW_OBJ			3  /*  add a new object */
-/*  return: 4b:	object id  */
-#define S3D_P_C_DEL_OBJ			4
-/*  4b:			object id */
-#define S3D_P_C_CLONE			5
-/*  4b:			object id */
+#define S3D_P_C_NEW_OBJ   3  /*  add a new object */
+/*  return: 4b: object id  */
+#define S3D_P_C_DEL_OBJ   4
+/*  4b:   object id */
+#define S3D_P_C_CLONE   5
+/*  4b:   object id */
 /*  return: 4b: object id */
-/*  if 8b: 		 */
-/*  4b:			object id */
-/*  4b:			target oid */
-#define S3D_P_C_LINK			6
+/*  if 8b:    */
+/*  4b:   object id */
+/*  4b:   target oid */
+#define S3D_P_C_LINK   6
 /*  if 4b: */
-/*  4b:		oid (for unlink) */
+/*  4b:  oid (for unlink) */
 /*  if 8b: */
-/*  4b:		oid from */
-/*  4b:		oid to */
-#define S3D_P_C_PUSH_LINE		7
-/*  4b: 		object id */
-/*  n*3d		from vertex, to vertex, color */
-#define S3D_P_C_PUSH_VERTEX		8
-/*  4b:		object id */
-/*  n*3f:	vertexes, each with x,y,z in float */
-#define S3D_P_C_PUSH_MAT		9
-/*  4b:		object id */
-/*  3*4f:	material elements [amb,spec,diff with r,g,b,a] */
-#define S3D_P_C_PUSH_POLY		10
-/*  4b:		object id */
-#define S3D_P_C_PUSH_TEX		11
-/*  4b: 			object id */
-/*  nx(2x2b):	width,height */
-#define S3D_P_C_DEL_VERTEX		12
-/*  4b:		object id */
-/*  4b:		number */
-#define S3D_P_C_DEL_POLY		13
-/*  4b:		object id */
-/*  4b:		number */
-#define S3D_P_C_DEL_MAT			14
-/*  4b:		object id */
-/*  4b:		number */
-#define S3D_P_C_DEL_TEX			15
-/*  4b:		object id */
-/*  4b:		number */
-#define S3D_P_C_PEP_POLY_NORMAL	16
-/*  4b:		object id */
-/*  n*9f:		normals (3* x/y/z for each vertex of the poly) */
-#define S3D_P_C_PEP_POLY_TEXC	17
-/*  4b:		object id */
-/*  n*6f		poly texture coordinates (3* u/v for each vertex of the poly) */
-#define S3D_P_C_PEP_MAT			18
-/*  4b:		object id */
-/*  3*4f:		material elements [amb,spec,diff with r,g,b,a] */
-#define S3D_P_C_PEP_MAT_TEX		19
-/*  4b:		object id */
-/*  4b:		texture index references */
-#define S3D_P_C_PEP_VERTEX		20
-/*  4b:		object id */
-/*  n*3f:	vertexes, each with x,y,z in float */
-#define S3D_P_C_PEP_LINE		21
-/* 4b:			object id */
-/* n*3u:		line information (from,to,color)*/
-#define S3D_P_C_DEL_LINE		22
-/*  4b:		object id */
-/*  4b:		number */
-#define S3D_P_C_PEP_LINE_NORMAL	23
-/*  4b:		object id */
-/*  n*6f:		normals (2* x/y/z for each vertex of the line) */
-#define S3D_P_C_LOAD_POLY_NORMAL	24
-/*  4b:		object id */
-/*  4b:		position */
-/*  n*9f:	normals (3* x/y/z for each vertex of the poly) */
-#define S3D_P_C_LOAD_POLY_TEXC	25
-/*  4b:		object id */
-/*  4b:		position */
-/*  n*6f		poly texture coordinates (3* u/v for each vertex of the poly) */
-#define S3D_P_C_LOAD_MAT		26
-/*  4b:		object id */
-/*  4b:		position */
-/*  3*4f:	material elements [amb,spec,diff with r,g,b,a] */
-#define S3D_P_C_LOAD_TEX		28
-/*  4b:		object id */
-/*  4b:		texture number */
-/*  4*2b:	xpos,ypos,width,height */
-/*  n*2b:	pixbuf (16bit) */
-#define S3D_P_C_LOAD_MAT_TEX	29
-/*  4b:		object id */
-/*  4b:		texture index references */
+/*  4b:  oid from */
+/*  4b:  oid to */
+#define S3D_P_C_PUSH_LINE  7
+/*  4b:   object id */
+/*  n*3d  from vertex, to vertex, color */
+#define S3D_P_C_PUSH_VERTEX  8
+/*  4b:  object id */
+/*  n*3f: vertexes, each with x,y,z in float */
+#define S3D_P_C_PUSH_MAT  9
+/*  4b:  object id */
+/*  3*4f: material elements [amb,spec,diff with r,g,b,a] */
+#define S3D_P_C_PUSH_POLY  10
+/*  4b:  object id */
+#define S3D_P_C_PUSH_TEX  11
+/*  4b:    object id */
+/*  nx(2x2b): width,height */
+#define S3D_P_C_DEL_VERTEX  12
+/*  4b:  object id */
+/*  4b:  number */
+#define S3D_P_C_DEL_POLY  13
+/*  4b:  object id */
+/*  4b:  number */
+#define S3D_P_C_DEL_MAT   14
+/*  4b:  object id */
+/*  4b:  number */
+#define S3D_P_C_DEL_TEX   15
+/*  4b:  object id */
+/*  4b:  number */
+#define S3D_P_C_PEP_POLY_NORMAL 16
+/*  4b:  object id */
+/*  n*9f:  normals (3* x/y/z for each vertex of the poly) */
+#define S3D_P_C_PEP_POLY_TEXC 17
+/*  4b:  object id */
+/*  n*6f  poly texture coordinates (3* u/v for each vertex of the poly) */
+#define S3D_P_C_PEP_MAT   18
+/*  4b:  object id */
+/*  3*4f:  material elements [amb,spec,diff with r,g,b,a] */
+#define S3D_P_C_PEP_MAT_TEX  19
+/*  4b:  object id */
+/*  4b:  texture index references */
+#define S3D_P_C_PEP_VERTEX  20
+/*  4b:  object id */
+/*  n*3f: vertexes, each with x,y,z in float */
+#define S3D_P_C_PEP_LINE  21
+/* 4b:   object id */
+/* n*3u:  line information (from,to,color)*/
+#define S3D_P_C_DEL_LINE  22
+/*  4b:  object id */
+/*  4b:  number */
+#define S3D_P_C_PEP_LINE_NORMAL 23
+/*  4b:  object id */
+/*  n*6f:  normals (2* x/y/z for each vertex of the line) */
+#define S3D_P_C_LOAD_POLY_NORMAL 24
+/*  4b:  object id */
+/*  4b:  position */
+/*  n*9f: normals (3* x/y/z for each vertex of the poly) */
+#define S3D_P_C_LOAD_POLY_TEXC 25
+/*  4b:  object id */
+/*  4b:  position */
+/*  n*6f  poly texture coordinates (3* u/v for each vertex of the poly) */
+#define S3D_P_C_LOAD_MAT  26
+/*  4b:  object id */
+/*  4b:  position */
+/*  3*4f: material elements [amb,spec,diff with r,g,b,a] */
+#define S3D_P_C_LOAD_TEX  28
+/*  4b:  object id */
+/*  4b:  texture number */
+/*  4*2b: xpos,ypos,width,height */
+/*  n*2b: pixbuf (16bit) */
+#define S3D_P_C_LOAD_MAT_TEX 29
+/*  4b:  object id */
+/*  4b:  texture index references */
 #define S3D_P_C_LOAD_LINE_NORMAL 30
-/*  4b:		object id */
-/*  4b:		position */
-/*  n*6f:		normals (2* x/y/z for each vertex of the line) */
+/*  4b:  object id */
+/*  4b:  position */
+/*  n*6f:  normals (2* x/y/z for each vertex of the line) */
 
 
-#define S3D_P_C_TOGGLE_FLAGS 	32
-/*  4b:		object id */
-/*  1b:		type  */
-/*  4b:		flags */
-#define S3D_P_C_TRANSLATE 		33
-/*  4b:		object id */
-/*  3f:		position */
-#define S3D_P_C_ROTATE			34
-/*  4b:		object id */
-/*  3f:		rotation angle over x,y,z axis */
-#define S3D_P_C_SCALE			35
-/*  4b: 		object id */
-/*  1f:		scale */
-#define S3D_P_C_GET_SIZE		36
+#define S3D_P_C_TOGGLE_FLAGS  32
+/*  4b:  object id */
+/*  1b:  type  */
+/*  4b:  flags */
+#define S3D_P_C_TRANSLATE   33
+/*  4b:  object id */
+/*  3f:  position */
+#define S3D_P_C_ROTATE   34
+/*  4b:  object id */
+/*  3f:  rotation angle over x,y,z axis */
+#define S3D_P_C_SCALE   35
+/*  4b:   object id */
+/*  1f:  scale */
+#define S3D_P_C_GET_SIZE  36
 /*  4b: object id */
-#define S3D_P_MCP_FOCUS			66		 /*  set the app which should get the keystrokes etc */
-/*  4b:		object id/pid */
+#define S3D_P_MCP_FOCUS   66   /*  set the app which should get the keystrokes etc */
+/*  4b:  object id/pid */
 /*  */
 /*  */
 /*   */
-#define S3D_P_MCP_OBJECT	67
-/*  4b: 		oid */
-/*  3*f:		translate */
+#define S3D_P_MCP_OBJECT 67
+/*  4b:   oid */
+/*  3*f:  translate */
 /*  ... ? */
 /*  max 256b:name */
 #define S3D_P_MCP_DEL_OBJECT 68
 
-#define S3D_P_S_INIT	1
+#define S3D_P_S_INIT 1
 /*  1b: acknowledged */
 /*  3b: version,major,minor */
 /*  description string */
-#define S3D_P_S_QUIT	2
-#define S3D_P_S_CLICK	3
+#define S3D_P_S_QUIT 2
+#define S3D_P_S_CLICK 3
 /*  4b: oid */
-#define	S3D_P_S_KEY		4
+#define S3D_P_S_KEY  4
 /*  2b: button */
 /*  2b: unicode translation */
 /*  2b: modifier information */
 /*  2b: state */
-#define S3D_P_S_MBUTTON	5
+#define S3D_P_S_MBUTTON 5
 /*  1b: button number */
 /*  2b: butotn state */
-#define S3D_P_S_NEWOBJ	16
+#define S3D_P_S_NEWOBJ 16
 /*  4b: oid */
 
-#define S3D_P_S_OINFO	32
-/*  4b: 		oid */
-/*  3*f:		translate */
-/*  3*f:		rotate */
-/*  1*f:		scale */
-/*  1*f:		radius */
+#define S3D_P_S_OINFO 32
+/*  4b:   oid */
+/*  3*f:  translate */
+/*  3*f:  rotate */
+/*  1*f:  scale */
+/*  1*f:  radius */
 /*  max 256b:name */

Modified: trunk/server/shm.c
===================================================================
--- trunk/server/shm.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/shm.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,15 +24,15 @@
 
 #include "global.h"
 #ifdef G_SDL
-#include <SDL.h>	/* SDL_SetTimer() */
+#include <SDL.h> /* SDL_SetTimer() */
 #endif
 #ifdef SHM
 #include <stdio.h>  /* printf(),fopen(),fclose() */
-#include <unistd.h>	/* unlink(),usleep() */
+#include <unistd.h> /* unlink(),usleep() */
 #include <stdlib.h> /* realloc(),free() */
 #include <string.h> /* memcpy() */
-#include <signal.h>	/* signal() */
-#include <errno.h>	/* errno */
+#include <signal.h> /* signal() */
+#include <errno.h> /* errno */
 #ifdef WIN32  /*  sohn wars */
 #include <winsock2.h>
 #else  /* sohn wars */
@@ -41,23 +41,23 @@
 #include <sys/types.h>
 #include <sys/ipc.h>
 #include <sys/shm.h>
-#include <time.h>	/* nanosleep() */
+#include <time.h> /* nanosleep() */
 
 extern uint8_t ibuf[MAXPLEN];
 extern struct t_process *procs_p;
 extern int procs_n;
 struct t_shmcb waiting_comblock;
 
-key_t *data=NULL;
-char ftoken[]="/tmp/.s3d";
+key_t *data = NULL;
+char ftoken[] = "/tmp/.s3d";
 int shmid;
-int mkey;	/* increasing key */
+int mkey; /* increasing key */
 
 static int shm_new_comblock(key_t *data);
 
 static int next_key(int oldkey)
 {
-	return(oldkey+1);
+	return(oldkey + 1);
 }
 int shm_init()
 {
@@ -65,25 +65,25 @@
 	key_t key;
 
 	/* create an empty token file */
-	fp=fopen(ftoken,"w");
+	fp = fopen(ftoken, "w");
 	fclose(fp);
 	/* make the key: */
 	if ((key = ftok(ftoken, 'R')) == -1) {
-		errnf("shm_init():ftok()",errno);
+		errnf("shm_init():ftok()", errno);
 		return(1);
 	}
-	s3dprintf(LOW,"shm_init(): init key is 0x%08x",key);
-	mkey=next_key(key);
+	s3dprintf(LOW, "shm_init(): init key is 0x%08x", key);
+	mkey = next_key(key);
 	/* connect to (and possibly create) the segment: */
 	if ((shmid = shmget(key, SHM_SIZE, 0644 | IPC_CREAT)) == -1) {
-		errnf("shm_init():shmget()",errno);
+		errnf("shm_init():shmget()", errno);
 		return(1);
 	}
 
 	/* attach to the segment to get a pointer to it: */
 	data = shmat(shmid, (void *)0, 0);
 	if (data == (key_t *)(-1)) {
-		errnf("shm_init():shmat()",errno);
+		errnf("shm_init():shmat()", errno);
 		return(1);
 	}
 	shm_new_comblock(data);
@@ -91,136 +91,136 @@
 }
 void comblock_init(struct t_shmcb *p_cb)
 {
-	p_cb->shmid_ctos=-1;
-	p_cb->shmid_stoc=-1;
-	p_cb->key_stoc=-1;
-	p_cb->key_ctos=-1;
-	p_cb->data_ctos=NULL;
-	p_cb->data_stoc=NULL;
+	p_cb->shmid_ctos = -1;
+	p_cb->shmid_stoc = -1;
+	p_cb->key_stoc = -1;
+	p_cb->key_ctos = -1;
+	p_cb->data_ctos = NULL;
+	p_cb->data_stoc = NULL;
 }
 /* registers a communication block, and sets waiting_comblock */
 static int shm_new_comblock(key_t *data)
 {
 	struct t_shmcb *mycb;
 	comblock_init(&waiting_comblock);
-	mycb=&waiting_comblock;
-	mycb->key_stoc=mkey;
-	mkey=next_key(mkey);
-	mycb->key_ctos=mkey;
-	mkey=next_key(mkey);
-	s3dprintf(MED,"shm_open_comblock():stoc: %08x, ctos: %08x",mycb->key_stoc,mycb->key_ctos);
+	mycb = &waiting_comblock;
+	mycb->key_stoc = mkey;
+	mkey = next_key(mkey);
+	mycb->key_ctos = mkey;
+	mkey = next_key(mkey);
+	s3dprintf(MED, "shm_open_comblock():stoc: %08x, ctos: %08x", mycb->key_stoc, mycb->key_ctos);
 	/* connect & create the client to server segment: */
 	if ((mycb->shmid_ctos = shmget(mycb->key_ctos, RB_STD_SIZE, 0644 | IPC_CREAT)) == -1) {
-		errn("shm_open_comblock:shmget()",errno);
+		errn("shm_open_comblock:shmget()", errno);
 		return(1);
 	}
 	mycb->data_ctos = shmat(mycb->shmid_ctos, (void *)0, 0);
 	if (mycb->data_ctos == (char *)(-1)) {
-		errn("shm_open_comblock:shmat()",errno);
+		errn("shm_open_comblock:shmat()", errno);
 		return(1);
 	}
 	/* connect & create the client to server segment: */
 	if ((mycb->shmid_stoc = shmget(mycb->key_stoc, RB_STD_SIZE, 0644 | IPC_CREAT)) == -1) {
-		errn("shm_open_comblock:shmget()",errno);
+		errn("shm_open_comblock:shmget()", errno);
 		return(1);
 	}
 	mycb->data_stoc = shmat(mycb->shmid_stoc, (void *)0, 0);
 	if (mycb->data_stoc == (char *)(-1)) {
-		errn("shm_open_comblock:shmat()",errno);
+		errn("shm_open_comblock:shmat()", errno);
 		return(1);
 	}
 
 	/* init ringbuffers */
-	ringbuf_init(mycb->data_stoc,RB_STD_SIZE);
-	ringbuf_init(mycb->data_ctos,RB_STD_SIZE);
-	data[0]=mycb->key_ctos;
-	data[1]=mycb->key_stoc;
-	mycb->idle=0;
-	s3dprintf(LOW,"shm_open_comblock():data: %08x, %08x",data[0],data[1]);
+	ringbuf_init(mycb->data_stoc, RB_STD_SIZE);
+	ringbuf_init(mycb->data_ctos, RB_STD_SIZE);
+	data[0] = mycb->key_ctos;
+	data[1] = mycb->key_stoc;
+	mycb->idle = 0;
+	s3dprintf(LOW, "shm_open_comblock():data: %08x, %08x", data[0], data[1]);
 	return(0);
 }
 
 int shm_quit()
 {
 	/* detach from the segment: */
-	s3dprintf(LOW,"shm_quit()...");
+	s3dprintf(LOW, "shm_quit()...");
 	unlink(ftoken);
-	if (data!=NULL) {
-		data[0]=data[1]=0;
-		data=0;
-		s3dprintf(MED,"shm_quit():removing init block");
+	if (data != NULL) {
+		data[0] = data[1] = 0;
+		data = 0;
+		s3dprintf(MED, "shm_quit():removing init block");
 		if (shmdt(data) == -1)
-			errn("shm_quit():shmdt()",errno);
+			errn("shm_quit():shmdt()", errno);
 		if (shmctl(shmid, IPC_RMID, NULL) == -1)
-			errn("shm_quit():shmctl()",errno);
+			errn("shm_quit():shmctl()", errno);
 	}
 	return(0);
 }
 int shm_remove(struct t_process *p)
 {
-	s3dprintf(MED,"shm_remove(): removing pid %d",p->id);
-	s3dprintf(MED,"shm_remove():freeing keys: %08x, %08x",p->shmsock.key_ctos,p->shmsock.key_stoc);
+	s3dprintf(MED, "shm_remove(): removing pid %d", p->id);
+	s3dprintf(MED, "shm_remove():freeing keys: %08x, %08x", p->shmsock.key_ctos, p->shmsock.key_stoc);
 	if (shmdt(p->shmsock.data_ctos) == -1)
-		errn("shm_rmove():shmdt()",errno);
+		errn("shm_rmove():shmdt()", errno);
 	if (shmctl(p->shmsock.shmid_ctos, IPC_RMID, NULL) == -1)
-		errn("shm_quit():shmctl()",errno);
+		errn("shm_quit():shmctl()", errno);
 	if (shmdt(p->shmsock.data_stoc) == -1)
-		errn("shm_quit():shmdt()",errno);
+		errn("shm_quit():shmdt()", errno);
 	if (shmctl(p->shmsock.shmid_stoc, IPC_RMID, NULL) == -1)
-		errn("shm_quit():shmctl()",errno);
+		errn("shm_quit():shmctl()", errno);
 	return(0);
 }
 
-extern int	turn;	/* set turn to 0 when timeslice is over */
+extern int turn; /* set turn to 0 when timeslice is over */
 int shm_main()
 {
-	int 				 i/*,found*/;
-	struct buf_t 		*dai; /* data in, data out */
-	struct t_process	*new_p;
-	struct shmid_ds		 d;
-	/*	do*/
+	int      i/*,found*/;
+	struct buf_t   *dai; /* data in, data out */
+	struct t_process *new_p;
+	struct shmid_ds   d;
+	/* do*/
 	{
-		/*		found=0;*/
-		turn=1;
-		for (i=0;i<procs_n;i++) {
+		/*  found=0;*/
+		turn = 1;
+		for (i = 0;i < procs_n;i++) {
 #ifdef G_SDL
-			SDL_SetTimer(100,(SDL_TimerCallback) net_turn_off);
+			SDL_SetTimer(100, (SDL_TimerCallback) net_turn_off);
 #endif
-			if (procs_p[i].con_type==CON_SHM) {
-				dai=(struct buf_t *) procs_p[i].shmsock.data_ctos;
-				if (dai->start!=dai->end) {
-					/*					found=1;*/
-					procs_p[i].shmsock.idle=0;
+			if (procs_p[i].con_type == CON_SHM) {
+				dai = (struct buf_t *) procs_p[i].shmsock.data_ctos;
+				if (dai->start != dai->end) {
+					/*     found=1;*/
+					procs_p[i].shmsock.idle = 0;
 					shm_prot_com_in(&procs_p[i]);
 					if (turn)
 						i--; /* evil hack: decrease i so it will be our turn again in the next round */
 					else {
-						s3dprintf(MED,"client %d [%s] seems to want to keep us busy ... ",i, procs_p[i].name);
-						turn=1; /* don't decrease, it's next connections turn */
+						s3dprintf(MED, "client %d [%s] seems to want to keep us busy ... ", i, procs_p[i].name);
+						turn = 1; /* don't decrease, it's next connections turn */
 					}
 				} else {
-					if (procs_p[i].shmsock.idle++>MAX_IDLE) { /* maybe the function timed out somehow ...? let's check ...*/
-						shmctl(procs_p[i].shmsock.shmid_ctos,IPC_STAT,&d);
-						if (d.shm_nattch==1) { /* we're all alone ... remove it!! */
-							s3dprintf(MED,"client [%s] detached, removing ... ",procs_p[i].name);
+					if (procs_p[i].shmsock.idle++ > MAX_IDLE) { /* maybe the function timed out somehow ...? let's check ...*/
+						shmctl(procs_p[i].shmsock.shmid_ctos, IPC_STAT, &d);
+						if (d.shm_nattch == 1) { /* we're all alone ... remove it!! */
+							s3dprintf(MED, "client [%s] detached, removing ... ", procs_p[i].name);
 							process_del(procs_p[i].id);
 						} else {
-							procs_p[i].shmsock.idle=0;
+							procs_p[i].shmsock.idle = 0;
 						}
 					}
 				}
 			}
 		}
 #ifdef G_SDL
-		SDL_SetTimer(0,NULL);
+		SDL_SetTimer(0, NULL);
 #endif
 	} /*while (found);*/
-	if ((data[0]==0) && (data[1]==0)) {
-		new_p=process_add();
-		new_p->con_type=CON_SHM;
-		memcpy(&new_p->shmsock,&waiting_comblock,sizeof(struct t_shmcb));
-		s3dprintf(HIGH,"shm_main():registered new connection (keys %d, %d) as pid %d",new_p->shmsock.key_ctos,new_p->shmsock.key_stoc, new_p->id);
-		s3dprintf(LOW,"shm_main():new client attached! allocating shm block for further clients ...");
+	if ((data[0] == 0) && (data[1] == 0)) {
+		new_p = process_add();
+		new_p->con_type = CON_SHM;
+		memcpy(&new_p->shmsock, &waiting_comblock, sizeof(struct t_shmcb));
+		s3dprintf(HIGH, "shm_main():registered new connection (keys %d, %d) as pid %d", new_p->shmsock.key_ctos, new_p->shmsock.key_stoc, new_p->id);
+		s3dprintf(LOW, "shm_main():new client attached! allocating shm block for further clients ...");
 		if (shm_new_comblock(data))
 			return(1);
 	}
@@ -228,60 +228,60 @@
 }
 int shm_prot_com_in(struct t_process *p)
 {
-	uint16_t	length;
+	uint16_t length;
 	struct buf_t *dai;
-	dai=(struct buf_t *)p->shmsock.data_ctos;
-	if (dai!=NULL)
-		/*	if ((pid=get_proc_by_dai( */
-		if (3==shm_readn(dai,ibuf,3)) {
-			length=ntohs(*((uint16_t *)((uint8_t *)ibuf+1)));
-			s3dprintf(VLOW,"command %d, length %d",ibuf[0], length);
-			if (length>0) {
-				shm_readn(dai,ibuf+3,length);
+	dai = (struct buf_t *)p->shmsock.data_ctos;
+	if (dai != NULL)
+		/* if ((pid=get_proc_by_dai( */
+		if (3 == shm_readn(dai, ibuf, 3)) {
+			length = ntohs(*((uint16_t *)((uint8_t *)ibuf + 1)));
+			s3dprintf(VLOW, "command %d, length %d", ibuf[0], length);
+			if (length > 0) {
+				shm_readn(dai, ibuf + 3, length);
 			}
-			prot_com_in(p,ibuf);
+			prot_com_in(p, ibuf);
 		}
 	return(0);
 }
-#define SHM_MAXLOOP		20
-static	struct timespec t= {
-	0,1000*1000
+#define SHM_MAXLOOP  20
+static struct timespec t = {
+	0, 1000*1000
 }; /* 1 mili seconds */
-int shm_writen(struct buf_t *rb,uint8_t *buf, int n)
+int shm_writen(struct buf_t *rb, uint8_t *buf, int n)
 {
-	int no_left,no_written,wait=0;
+	int no_left, no_written, wait = 0;
 	no_left = n;
 	while (no_left > 0) {
-		no_written = shm_write(rb,(char *)buf,no_left);
-		if (no_written <=0)
+		no_written = shm_write(rb, (char *)buf, no_left);
+		if (no_written <= 0)
 			return(no_written);
 		no_left -= no_written;
 		buf += no_written;
-		if (wait++>SHM_MAXLOOP) {
-			s3dprintf(HIGH,"shm_writen():waited too long ...");
+		if (wait++ > SHM_MAXLOOP) {
+			s3dprintf(HIGH, "shm_writen():waited too long ...");
 			return(-1);
 		}
-		if (wait>10)		nanosleep(&t,NULL);
+		if (wait > 10)  nanosleep(&t, NULL);
 	}
 	return(n - no_left);
 }
-int shm_readn(struct buf_t *rb,uint8_t *buf, int n)
+int shm_readn(struct buf_t *rb, uint8_t *buf, int n)
 {
-	int no_left,no_read,wait=0;
+	int no_left, no_read, wait = 0;
 	no_left = n;
 	while (no_left > 0) {
-		no_read = shm_read(rb,(char *)buf,no_left);
-		if (no_read <0)
+		no_read = shm_read(rb, (char *)buf, no_left);
+		if (no_read < 0)
 			return(no_read);
 		if (no_read == 0)
 			break;
 		no_left -= no_read;
 		buf += no_read;
-		if (wait++>SHM_MAXLOOP) {
-			s3dprintf(HIGH,"shm_readn():waited too long ...");
+		if (wait++ > SHM_MAXLOOP) {
+			s3dprintf(HIGH, "shm_readn():waited too long ...");
 			return(-1);
 		}
-		if (wait>10)		nanosleep(&t,NULL);
+		if (wait > 10)  nanosleep(&t, NULL);
 	}
 	return(n - no_left);
 }

Modified: trunk/server/shm_ringbuf.c
===================================================================
--- trunk/server/shm_ringbuf.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/shm_ringbuf.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,88 +23,88 @@
 
 
 #include "global.h"
-#include <stdio.h>	/* printf(), getchar() */
+#include <stdio.h> /* printf(), getchar() */
 #include <stdint.h> /* uint32_t */
-#include <string.h>	/* memcpy() */
-int shm_write(struct buf_t *rb,char *buf, int n)
+#include <string.h> /* memcpy() */
+int shm_write(struct buf_t *rb, char *buf, int n)
 {
-	int wrap=0;
+	int wrap = 0;
 	int rs;
-	int32_t e,s,size;
+	int32_t e, s, size;
 	char *data;
 
-	e=rb->end;
-	s=rb->start;
-	size=rb->bufsize;
-	data=((char *)rb)+sizeof(struct buf_t);
-	if (e<s) {
-		wrap=1;
+	e = rb->end;
+	s = rb->start;
+	size = rb->bufsize;
+	data = ((char *)rb) + sizeof(struct buf_t);
+	if (e < s) {
+		wrap = 1;
 	}
-	while ((((s+size*(1-wrap))-e) < (n+1))) { /* checking free space */
+	while ((((s + size*(1 - wrap)) - e) < (n + 1))) { /* checking free space */
 		if /*((size*2)>RB_MAX_SIZE)*/ (1) {
 			printf("buffer reached maxsize, no resizing possible");
 			return(-1);
 		}
-		/*		printf("buffer full!! resizing ... (to size %d)",(int)size*2);
-				if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
-				{
-					printf("realloc failed - fatal!!");
-					return(-1);
-				}
-				if (wrap)
-				{
-					memcpy(data+size,data,e);
-					e+=size;
-					wrap=0;
-				}
-				size=rb->bufsize=size*2;
-				rb->end=e;*/
+		/*  printf("buffer full!! resizing ... (to size %d)",(int)size*2);
+		  if (NULL==(realloc(rb, size*2+RB_OVERHEAD)))
+		  {
+		   printf("realloc failed - fatal!!");
+		   return(-1);
+		  }
+		  if (wrap)
+		  {
+		   memcpy(data+size,data,e);
+		   e+=size;
+		   wrap=0;
+		  }
+		  size=rb->bufsize=size*2;
+		  rb->end=e;*/
 	}
-	if ((e+n)>size) {
-		rs=size-e;
-		memcpy(data+e,buf,rs);			/* copy the first part ... */
-		memcpy(data,buf+rs,n-rs); 		/* .. end the rest */
+	if ((e + n) > size) {
+		rs = size - e;
+		memcpy(data + e, buf, rs);   /* copy the first part ... */
+		memcpy(data, buf + rs, n - rs);   /* .. end the rest */
 	} else {
-		memcpy(data+e,buf,n);			/* plain copy */
+		memcpy(data + e, buf, n);   /* plain copy */
 	}
-	rb->end=e+n;	/* update end of the buffer */
-	if (rb->end>=rb->bufsize) rb->end-=rb->bufsize;
+	rb->end = e + n; /* update end of the buffer */
+	if (rb->end >= rb->bufsize) rb->end -= rb->bufsize;
 	return(0);
 }
-int shm_read(struct buf_t *rb,char *buf, int n)
+int shm_read(struct buf_t *rb, char *buf, int n)
 {
-	int wrap=0;
-	int mn=n;
+	int wrap = 0;
+	int mn = n;
 	int rs;
-	int32_t e,s,size;
+	int32_t e, s, size;
 	char *data;
 
-	e=rb->end;
-	s=rb->start;
-	size=rb->bufsize;
-	data=((char *)rb)+sizeof(struct buf_t);
-	if (e<s) wrap=1;
-	rs=(e+wrap*size-s);
-	mn=(n>rs)?rs:n;
-	if ((wrap) && (mn>(size-s))) {
-		rs=size-s;	/* size of the first part */
-		memcpy(buf,data+s,rs);
-		memcpy(buf+rs,data,mn-rs);
+	e = rb->end;
+	s = rb->start;
+	size = rb->bufsize;
+	data = ((char *)rb) + sizeof(struct buf_t);
+	if (e < s) wrap = 1;
+	rs = (e + wrap * size - s);
+	mn = (n > rs) ? rs : n;
+	if ((wrap) && (mn > (size - s))) {
+		rs = size - s; /* size of the first part */
+		memcpy(buf, data + s, rs);
+		memcpy(buf + rs, data, mn - rs);
 	} else { /* no wrap (needed)*/
-		memcpy(buf,data+s,mn);
+		memcpy(buf, data + s, mn);
 	}
-	rb->start=s+mn;
-	if (rb->start>=rb->bufsize) rb->start-=rb->bufsize;
+	rb->start = s + mn;
+	if (rb->start >= rb->bufsize) rb->start -= rb->bufsize;
 	return(mn);
 }
-void ringbuf_init(char *data,uint32_t init_size)
+void ringbuf_init(char *data, uint32_t init_size)
 {
-	struct buf_t *ringbuf=(struct buf_t *)data;
-	/*	ringbuf=malloc(init_size); */
-	ringbuf->start=0;
-	ringbuf->end=0;
-	ringbuf->bufsize=init_size-RB_OVERHEAD;
-	/*	return (ringbuf); */
+	struct buf_t *ringbuf = (struct buf_t *)data;
+	/* ringbuf=malloc(init_size); */
+	ringbuf->start = 0;
+	ringbuf->end = 0;
+	ringbuf->bufsize = init_size - RB_OVERHEAD;
+	/* return (ringbuf); */
 }
 
 

Modified: trunk/server/tcp.c
===================================================================
--- trunk/server/tcp.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/tcp.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,25 +24,25 @@
 
 #include "global.h"
 #ifdef TCP
-#include <errno.h>		 /*  errno */
-#include <string.h>		 /*  memset() */
+#include <errno.h>   /*  errno */
+#include <string.h>   /*  memset() */
 #ifdef WIN32  /*  sohn wars */
 #include <winsock2.h>
 #else  /* sohn wars */
 #include <sys/types.h>   /* fd_set, FD*, socket, accept ... */
 #include <sys/socket.h>  /* socket, accept ... */
 #include <sys/select.h>  /* fd_set,FD* */
-#include <sys/time.h>	 /* fd_set,FD* */
+#include <sys/time.h>  /* fd_set,FD* */
 #include <netinet/in.h>  /* ntohs(),htons(),htonl(),ntohl() */
 #include <arpa/inet.h>   /* network */
 #endif   /*  sohn wars */
-#include <time.h>		 /*  select() timeval things */
-#include <fcntl.h>		 /*  fcntl(),F_SETOWN */
+#include <time.h>   /*  select() timeval things */
+#include <fcntl.h>   /*  fcntl(),F_SETOWN */
 #ifndef F_SETOWN /* somehow it is not set with -ansi */
-#define F_SETOWN	8
+#define F_SETOWN 8
 #endif
-#include <unistd.h>		 /*  read(),write(),getpid(),close() */
-#include <stdlib.h>		 /*  malloc(),free() */
+#include <unistd.h>   /*  read(),write(),getpid(),close() */
+#include <stdlib.h>   /*  malloc(),free() */
 
 extern struct t_con *con_list;
 extern struct t_con mcp;
@@ -51,35 +51,35 @@
 int tcp_sockid;
 int tcp_init()
 {
-	int yes=1;
+	int yes = 1;
 	struct sockaddr_in my_addr;
-	s3dprintf(LOW,"server: creating socket");
+	s3dprintf(LOW, "server: creating socket");
 #ifdef WIN32  /*  sohn wars */
 	WSADATA datainfo;
 	if (WSAStartup(257, &datainfo) != 0)
 		errnf("startup()", 0);
 #endif  /*  auch sohn */
-	if ((tcp_sockid = socket(AF_INET,SOCK_STREAM,0)) < 0)
+	if ((tcp_sockid = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 		errnf("socket()", errno);
 
-	s3dprintf(LOW,"server: binding my local socket");
+	s3dprintf(LOW, "server: binding my local socket");
 	/*  allow addresses to be reused */
 	/*  this seems to have something to do with servers using one port */
-	if ( setsockopt(tcp_sockid, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1 )
-		errn("setsockopt(...,SO_REUSEADDR...)",errno );
-	memset((char *) &my_addr,0,sizeof(my_addr));
+	if (setsockopt(tcp_sockid, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)
+		errn("setsockopt(...,SO_REUSEADDR...)", errno);
+	memset((char *) &my_addr, 0, sizeof(my_addr));
 	my_addr.sin_family = AF_INET;
 	my_addr.sin_port = htons(S3D_PORT);
 	my_addr.sin_addr.s_addr = htons(INADDR_ANY);
-	if (bind(tcp_sockid ,(struct sockaddr *) &my_addr,sizeof(my_addr)) < 0)
-		errnf("bind()",errno);
-	if (listen(tcp_sockid,5) < 0)
-		errnf("listen()",errno);
+	if (bind(tcp_sockid , (struct sockaddr *) &my_addr, sizeof(my_addr)) < 0)
+		errnf("bind()", errno);
+	if (listen(tcp_sockid, 5) < 0)
+		errnf("listen()", errno);
 #ifdef SIGS
-	if ( fcntl(tcp_sockid, F_SETFL, O_ASYNC | O_NONBLOCK) < 0 )
-		errnf("fcntl()",errno);
-	if ( fcntl(tcp_sockid, F_SETOWN, getpid()) < 0 )
-		errnf("fcntl()",errno);
+	if (fcntl(tcp_sockid, F_SETFL, O_ASYNC | O_NONBLOCK) < 0)
+		errnf("fcntl()", errno);
+	if (fcntl(tcp_sockid, F_SETOWN, getpid()) < 0)
+		errnf("fcntl()", errno);
 #endif
 	return(0);
 
@@ -95,40 +95,40 @@
 /*  watches the port for new connections */
 int tcp_pollport()
 {
-	fd_set				 fs_port; 	 /*  filedescriptor set for listening port(s) */
-	int 				 newsd; 	 /*  new socket descriptor */
-	struct timeval		 tv;		 /*  time structure */
-	/*	struct t_con 		*new_con;	*/ /*  pointer to new connection */
-	struct t_process	*new_p;		 /*  pointer to new process */
-	struct sockaddr		 client_addr;  /*  new client's address */
-	socklen_t			 clilen=sizeof(client_addr);		 /*  length of client's address */
+	fd_set     fs_port;   /*  filedescriptor set for listening port(s) */
+	int      newsd;   /*  new socket descriptor */
+	struct timeval   tv;   /*  time structure */
+	/* struct t_con   *new_con; */ /*  pointer to new connection */
+	struct t_process *new_p;   /*  pointer to new process */
+	struct sockaddr   client_addr;  /*  new client's address */
+	socklen_t    clilen = sizeof(client_addr); /*  length of client's address */
 	/* int i; */
 	FD_ZERO(&fs_port);
-	FD_SET(tcp_sockid,&fs_port);
+	FD_SET(tcp_sockid, &fs_port);
 select_again:
-	tv.tv_sec=tv.tv_usec=0;
-	if (select(FD_SETSIZE, &fs_port, NULL,NULL,&tv)<0) {
-		if (errno==EINTR) { /*  interruption by some evil signal, just do again :) */
-			errn("tcp_pollport():select()",errno);
+	tv.tv_sec = tv.tv_usec = 0;
+	if (select(FD_SETSIZE, &fs_port, NULL, NULL, &tv) < 0) {
+		if (errno == EINTR) { /*  interruption by some evil signal, just do again :) */
+			errn("tcp_pollport():select()", errno);
 			goto select_again;  /*  oh no, a goto!! that's evil */
 		} else
-			errn("tcp_pollport():select()",errno);
+			errn("tcp_pollport():select()", errno);
 	} else
-		if (FD_ISSET(tcp_sockid,&fs_port)) {  /* redundant, I guess */
-			s3dprintf(HIGH,"select(): new connection!!");
-			if ((newsd = accept(tcp_sockid ,(struct sockaddr *) &client_addr,&clilen)) < 0)
-				errn("accept()",errno);
+		if (FD_ISSET(tcp_sockid, &fs_port)) { /* redundant, I guess */
+			s3dprintf(HIGH, "select(): new connection!!");
+			if ((newsd = accept(tcp_sockid , (struct sockaddr *) & client_addr, &clilen)) < 0)
+				errn("accept()", errno);
 			else {
 #ifdef SIGS
-				if ( fcntl(newsd, F_SETFL, O_ASYNC ) < 0 )
-					errnf("fcntl()",errno);
-				if ( fcntl(newsd, F_SETOWN, getpid()) < 0 )
-					errnf("fcntl()",errno);
+				if (fcntl(newsd, F_SETFL, O_ASYNC) < 0)
+					errnf("fcntl()", errno);
+				if (fcntl(newsd, F_SETOWN, getpid()) < 0)
+					errnf("fcntl()", errno);
 #endif
-				new_p=process_add();
-				new_p->con_type=CON_TCP;
-				new_p->sockid=newsd;
-				s3dprintf(HIGH,"registered new connection %d as pid %d",new_p->sockid, new_p->id);
+				new_p = process_add();
+				new_p->con_type = CON_TCP;
+				new_p->sockid = newsd;
+				s3dprintf(HIGH, "registered new connection %d as pid %d", new_p->sockid, new_p->id);
 			}
 		}
 	return(0);
@@ -139,24 +139,24 @@
 /*  returns 1 when there was new data. */
 int tcp_pollproc()
 {
-	fd_set				 fs_proc; 	 /*  filedescriptor set for listening port(s) */
-	struct timeval		 tv;		 /*  time structure */
-	struct t_process	*p;
-	int 				 found=0;
-	int 				 i,unfinished,n,off;
-	off=0;
+	fd_set     fs_proc;   /*  filedescriptor set for listening port(s) */
+	struct timeval   tv;   /*  time structure */
+	struct t_process *p;
+	int      found = 0;
+	int      i, unfinished, n, off;
+	off = 0;
 	do {
 		FD_ZERO(&fs_proc);
-		unfinished=0;
-		n=0;
-		for (i=off;i<procs_n;i++) {
-			p=&procs_p[i];
-			if (p->con_type==CON_TCP) {
-				FD_SET(p->sockid,&fs_proc);
+		unfinished = 0;
+		n = 0;
+		for (i = off;i < procs_n;i++) {
+			p = &procs_p[i];
+			if (p->con_type == CON_TCP) {
+				FD_SET(p->sockid, &fs_proc);
 				n++;
-				if (n>=FD_SETSIZE) {	/* don't overflow the setsize! */
-					off=i;
-					unfinished=1;
+				if (n >= FD_SETSIZE) { /* don't overflow the setsize! */
+					off = i;
+					unfinished = 1;
 					break;
 				}
 			}
@@ -164,23 +164,23 @@
 		/*  maybe having a global fd_set for all the processes would have been better */
 		/*  than generating them new in every poll. to be optimized... */
 select_again_poll:
-		tv.tv_sec=tv.tv_usec=0;
-		if (select(FD_SETSIZE, &fs_proc, NULL,NULL,&tv) ==-1) {
-			if (errno==EINTR) {
-				errn("tcp_pollproc():select()",errno);
+		tv.tv_sec = tv.tv_usec = 0;
+		if (select(FD_SETSIZE, &fs_proc, NULL, NULL, &tv) == -1) {
+			if (errno == EINTR) {
+				errn("tcp_pollproc():select()", errno);
 				goto select_again_poll;
 			} else {
-				errn("tcp_pollproc():select()",errno);
+				errn("tcp_pollproc():select()", errno);
 			}
 		} else {
 			/*  data is available */
-			for (i=0;i<procs_n;i++) {
-				p=&procs_p[i];
-				if (p->con_type==CON_TCP) {
-					if (FD_ISSET(p->sockid,&fs_proc)) {
-						FD_CLR(p->sockid,&fs_proc);  /*  clear it from the fd */
+			for (i = 0;i < procs_n;i++) {
+				p = &procs_p[i];
+				if (p->con_type == CON_TCP) {
+					if (FD_ISSET(p->sockid, &fs_proc)) {
+						FD_CLR(p->sockid, &fs_proc); /*  clear it from the fd */
 						tcp_prot_com_in(p);
-						found=1;
+						found = 1;
 					}
 				}
 			}
@@ -191,29 +191,29 @@
 /* read some data from the line, pushes it into the buffer and calls prot_com_in */
 int tcp_prot_com_in(struct t_process *p)
 {
-	uint16_t	length;
-	if (3==tcp_readn(p->sockid, ibuf,3)) {
-		length=ntohs(*((uint16_t *)((uint8_t *)ibuf+1)));
-		s3dprintf(VLOW,"command %d, length %d",ibuf[0], length);
-		if (length>0) {
-			tcp_readn(p->sockid,ibuf+3,length);	  /*  uint16_t is limited to 65536, so  */
+	uint16_t length;
+	if (3 == tcp_readn(p->sockid, ibuf, 3)) {
+		length = ntohs(*((uint16_t *)((uint8_t *)ibuf + 1)));
+		s3dprintf(VLOW, "command %d, length %d", ibuf[0], length);
+		if (length > 0) {
+			tcp_readn(p->sockid, ibuf + 3, length);   /*  uint16_t is limited to 65536, so  */
 			/*  length can't be bigger than that ... lucky */
 		}
-		prot_com_in(p,ibuf);
+		prot_com_in(p, ibuf);
 	} else {
-		s3dprintf(LOW,"tcp_prot_com_in():n_readn():fd seems to be dead (pid %d, sock %d)", p->id, p->sockid);
+		s3dprintf(LOW, "tcp_prot_com_in():n_readn():fd seems to be dead (pid %d, sock %d)", p->id, p->sockid);
 		process_del(p->id);
 	}
 	return(0);
 }
 /*  shamelessly ripped from simple ftp server */
-int tcp_readn(int sock, uint8_t *str,int s)
+int tcp_readn(int sock, uint8_t *str, int s)
 {
-	int no_left,no_read;
+	int no_left, no_read;
 	no_left = s;
 	while (no_left > 0) {
-		no_read = read(sock,str,no_left);
-		if (no_read <0) {
+		no_read = read(sock, str, no_left);
+		if (no_read < 0) {
 			errn("read()", errno);
 			return(no_read);
 		}
@@ -223,14 +223,14 @@
 	}
 	return(s - no_left);
 }
-int tcp_writen(int sock, uint8_t *str,int s)
+int tcp_writen(int sock, uint8_t *str, int s)
 {
-	int no_left,no_written;
+	int no_left, no_written;
 	no_left = s;
 	while (no_left > 0) {
-		no_written = write(sock,str,no_left);
-		if (no_written <=0) {
-			errn("write()",errno);
+		no_written = write(sock, str, no_left);
+		if (no_written <= 0) {
+			errn("write()", errno);
 			return(no_written);
 		}
 		no_left -= no_written;

Modified: trunk/server/user.c
===================================================================
--- trunk/server/user.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/user.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -24,9 +24,9 @@
 
 #include "global.h"
 /*  this file reads user input */
-static int ox,oy;
+static int ox, oy;
 static int pressed;
-int but=-1;
+int but = -1;
 int user_init()
 {
 	switch (frame_mode) {
@@ -43,8 +43,8 @@
 	default:
 		return(-1);
 	}
-	pressed=0;
-	ox=oy=0xFFFFFF;
+	pressed = 0;
+	ox = oy = 0xFFFFFF;
 	return(0);
 }
 int user_main()
@@ -65,7 +65,7 @@
 }
 void user_key(uint16_t key, uint16_t unicode, uint16_t mod, int state)
 {
-	event_key_pressed(key,unicode,mod,state);
+	event_key_pressed(key, unicode, mod, state);
 }
 void user_mouse(int button, int state, int x, int y)
 {
@@ -73,15 +73,15 @@
 	case 0: /*  mouse_down ... */
 		switch (button) {
 		case 0:
-			graphics_pick_obj(x,y);
+			graphics_pick_obj(x, y);
 			break;
 		case 1:
-			if ((ox!=0xFFFFFF) && (oy!=0xFFFFFF))
-				navi_pos(ox-x,oy-y);
+			if ((ox != 0xFFFFFF) && (oy != 0xFFFFFF))
+				navi_pos(ox - x, oy - y);
 			break;
 		case 2:
-			if ((ox!=0xFFFFFF) && (oy!=0xFFFFFF))
-				navi_rot(ox-x,oy-y);
+			if ((ox != 0xFFFFFF) && (oy != 0xFFFFFF))
+				navi_rot(ox - x, oy - y);
 			break;
 		case 3:
 			navi_fwd();
@@ -90,26 +90,26 @@
 			navi_back();
 			break;
 		default:
-			s3dprintf(VLOW,"button is ... %d", button);
+			s3dprintf(VLOW, "button is ... %d", button);
 		}
-		ox=x;
-		oy=y;
-		event_mbutton_clicked(button,state);
+		ox = x;
+		oy = y;
+		event_mbutton_clicked(button, state);
 		break;
 	case 1:  /*  mouse up */
-		ox=oy=0xFFFFFF;
-		event_mbutton_clicked(button,state);
-		/*		s3dprintf(LOW,"state is: %d,button is %d",state,button);*/
+		ox = oy = 0xFFFFFF;
+		event_mbutton_clicked(button, state);
+		/*  s3dprintf(LOW,"state is: %d,button is %d",state,button);*/
 		break;
-	case 2:	 /*  mouse still down */
+	case 2:  /*  mouse still down */
 		switch (button) {
 		case 1:
-			if ((ox!=0xFFFFFF) && (oy!=0xFFFFFF))
-				navi_pos(ox-x,oy-y);
+			if ((ox != 0xFFFFFF) && (oy != 0xFFFFFF))
+				navi_pos(ox - x, oy - y);
 			break;
 		case 2:
-			if ((ox!=0xFFFFFF) && (oy!=0xFFFFFF))
-				navi_rot(ox-x,oy-y);
+			if ((ox != 0xFFFFFF) && (oy != 0xFFFFFF))
+				navi_rot(ox - x, oy - y);
 			break;
 		case 3:
 			navi_fwd();
@@ -118,15 +118,15 @@
 			navi_back();
 			break;
 		default:
-			s3dprintf(VLOW,"button is ... %d", button);
+			s3dprintf(VLOW, "button is ... %d", button);
 		}
-		ox=x;
-		oy=y;
+		ox = x;
+		oy = y;
 		break;
 	}
-	but=button;
+	but = button;
 	/* mouse changed? */
-	ptr_move(x,y);
+	ptr_move(x, y);
 }
 int user_quit()
 {

Modified: trunk/server/user_glut.c
===================================================================
--- trunk/server/user_glut.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/user_glut.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -23,7 +23,7 @@
 
 
 #include "global.h"
-#include <GL/glut.h> 	 /*  all the glut functions */
+#include <GL/glut.h>   /*  all the glut functions */
 #include <s3d_keysym.h> /* our very own (haha) keysyms */
 /*  local prototypes */
 void keyboard(uint8_t key, int x, int y);
@@ -34,10 +34,10 @@
 /*  init user input things for glut */
 int user_init_glut()
 {
-	s3dprintf(MED,"using GLUT for user input");
-	glutKeyboardFunc (keyboard);
-	glutSpecialFunc (special);
-	glutMouseFunc (user_mouse);
+	s3dprintf(MED, "using GLUT for user input");
+	glutKeyboardFunc(keyboard);
+	glutSpecialFunc(special);
+	glutMouseFunc(user_mouse);
 	glutMotionFunc(mouse_motion);
 	glutPassiveMotionFunc(passive_mouse_motion);
 	return(0);
@@ -45,89 +45,89 @@
 
 void keyboard(uint8_t key, int x, int y)
 {
-	user_key(key,key,0,0);
-	user_key(key,key,0,1);
+	user_key(key, key, 0, 0);
+	user_key(key, key, 0, 1);
 }
 void special(int skey, int x, int y)
 {
 	uint16_t mkey;
 	switch (skey) { /* handle special keys */
 	case GLUT_KEY_F1:
-		mkey=S3DK_F1;
+		mkey = S3DK_F1;
 		break;
 	case GLUT_KEY_F2:
-		mkey=S3DK_F2;
+		mkey = S3DK_F2;
 		break;
 	case GLUT_KEY_F3:
-		mkey=S3DK_F3;
+		mkey = S3DK_F3;
 		break;
 	case GLUT_KEY_F4:
-		mkey=S3DK_F4;
+		mkey = S3DK_F4;
 		break;
 	case GLUT_KEY_F5:
-		mkey=S3DK_F5;
+		mkey = S3DK_F5;
 		break;
 	case GLUT_KEY_F6:
-		mkey=S3DK_F6;
+		mkey = S3DK_F6;
 		break;
 	case GLUT_KEY_F7:
-		mkey=S3DK_F7;
+		mkey = S3DK_F7;
 		break;
 	case GLUT_KEY_F8:
-		mkey=S3DK_F8;
+		mkey = S3DK_F8;
 		break;
 	case GLUT_KEY_F9:
-		mkey=S3DK_F9;
+		mkey = S3DK_F9;
 		break;
 	case GLUT_KEY_F10:
-		mkey=S3DK_F10;
+		mkey = S3DK_F10;
 		break;
 	case GLUT_KEY_F11:
-		mkey=S3DK_F11;
+		mkey = S3DK_F11;
 		break;
 	case GLUT_KEY_F12:
-		mkey=S3DK_F12;
+		mkey = S3DK_F12;
 		break;
 	case GLUT_KEY_LEFT:
-		mkey=S3DK_LEFT;
+		mkey = S3DK_LEFT;
 		break;
 	case GLUT_KEY_RIGHT:
-		mkey=S3DK_RIGHT;
+		mkey = S3DK_RIGHT;
 		break;
 	case GLUT_KEY_UP:
-		mkey=S3DK_UP;
+		mkey = S3DK_UP;
 		break;
 	case GLUT_KEY_DOWN:
-		mkey=S3DK_DOWN;
+		mkey = S3DK_DOWN;
 		break;
 	case GLUT_KEY_PAGE_UP:
-		mkey=S3DK_PAGEUP;
+		mkey = S3DK_PAGEUP;
 		break;
 	case GLUT_KEY_PAGE_DOWN:
-		mkey=S3DK_PAGEDOWN;
+		mkey = S3DK_PAGEDOWN;
 		break;
 	case GLUT_KEY_HOME:
-		mkey=S3DK_HOME;
+		mkey = S3DK_HOME;
 		break;
 	case GLUT_KEY_END:
-		mkey=S3DK_END;
+		mkey = S3DK_END;
 		break;
 	case GLUT_KEY_INSERT:
-		mkey=S3DK_INSERT;
+		mkey = S3DK_INSERT;
 		break;
 	default:
-		mkey=skey;
+		mkey = skey;
 		break;
 	}
-	s3dprintf(MED,"special(): %d -> %d",skey,mkey);
-	user_key(mkey,0,0,0);
-	user_key(mkey,0,0,1);
+	s3dprintf(MED, "special(): %d -> %d", skey, mkey);
+	user_key(mkey, 0, 0, 0);
+	user_key(mkey, 0, 0, 1);
 }
 void mouse_motion(int x, int y)
 {
-	user_mouse(but,2,x,y);
+	user_mouse(but, 2, x, y);
 }
 void passive_mouse_motion(int x, int y)
 {
-	user_mouse(-1,-1,x,y);
+	user_mouse(-1, -1, x, y);
 }

Modified: trunk/server/user_sdl.c
===================================================================
--- trunk/server/user_sdl.c	2007-09-17 13:43:05 UTC (rev 666)
+++ trunk/server/user_sdl.c	2007-09-17 13:51:17 UTC (rev 667)
@@ -35,124 +35,124 @@
 }
 int user_main_sdl()
 {
-	SDL_Event 	event;
+	SDL_Event  event;
 	SDL_Surface *GLwin = NULL;
 	while (SDL_PollEvent(&event)) {
 		switch (event.type) {
 		case SDL_MOUSEMOTION:
-			/* 			s3dprintf(VLOW,"Current mouse position is: (%d, %d),button %d", event.motion.x, event.motion.y,event.button.button); */
+			/*    s3dprintf(VLOW,"Current mouse position is: (%d, %d),button %d", event.motion.x, event.motion.y,event.button.button); */
 			switch (event.button.button) {
 			case SDL_BUTTON_LEFT:
-				user_mouse(0,2,event.motion.x,event.motion.y);
+				user_mouse(0, 2, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_MIDDLE:
-				user_mouse(1,2,event.motion.x,event.motion.y);
+				user_mouse(1, 2, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_RIGHT:
 			case SDL_BUTTON_RMASK:
-				user_mouse(2,2,event.motion.x,event.motion.y);
+				user_mouse(2, 2, event.motion.x, event.motion.y);
 				break;
-				/*				case SDL_BUTTON_WHEELUP:
-							 		user_mouse(3,2,event.motion.x,event.motion.y);break;
-								case SDL_BUTTON_WHEELDOWN:
-							 		user_mouse(4,2,event.motion.x,event.motion.y);break;*/
+				/*    case SDL_BUTTON_WHEELUP:
+				      user_mouse(3,2,event.motion.x,event.motion.y);break;
+				    case SDL_BUTTON_WHEELDOWN:
+				      user_mouse(4,2,event.motion.x,event.motion.y);break;*/
 			case 0:
-				user_mouse(-1,-1,event.motion.x,event.motion.y);
+				user_mouse(-1, -1, event.motion.x, event.motion.y);
 				break;
 				/*  no button ... */
 			default:
-				s3dprintf(LOW,"don't know button %d", event.button.button);
+				s3dprintf(LOW, "don't know button %d", event.button.button);
 
 			}
 			break;
 		case SDL_MOUSEBUTTONDOWN:
 			switch (event.button.button) {
 			case SDL_BUTTON_LEFT:
-				user_mouse(0,0,event.motion.x,event.motion.y);
+				user_mouse(0, 0, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_MIDDLE:
-				user_mouse(1,0,event.motion.x,event.motion.y);
+				user_mouse(1, 0, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_RIGHT:
-				user_mouse(2,0,event.motion.x,event.motion.y);
+				user_mouse(2, 0, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_WHEELUP:
-				user_mouse(3,0,event.motion.x,event.motion.y);
+				user_mouse(3, 0, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_WHEELDOWN:
-				user_mouse(4,0,event.motion.x,event.motion.y);
+				user_mouse(4, 0, event.motion.x, event.motion.y);
 				break;
 			default:
-				s3dprintf(LOW,"don't know button %d", event.button.button);
+				s3dprintf(LOW, "don't know button %d", event.button.button);
 			}
 			break;
 		case SDL_MOUSEBUTTONUP:
 			switch (event.button.button) {
 			case SDL_BUTTON_LEFT:
-				user_mouse(0,1,event.motion.x,event.motion.y);
+				user_mouse(0, 1, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_MIDDLE:
-				user_mouse(1,1,event.motion.x,event.motion.y);
+				user_mouse(1, 1, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_RIGHT:
-				user_mouse(2,1,event.motion.x,event.motion.y);
+				user_mouse(2, 1, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_WHEELUP:
-				user_mouse(3,1,event.motion.x,event.motion.y);
+				user_mouse(3, 1, event.motion.x, event.motion.y);
 				break;
 			case SDL_BUTTON_WHEELDOWN:
-				user_mouse(4,1,event.motion.x,event.motion.y);
+				user_mouse(4, 1, event.motion.x, event.motion.y);
 				break;
 			default:
-				s3dprintf(LOW,"don't know button %d", event.button.button);
+				s3dprintf(LOW, "don't know button %d", event.button.button);
 			}
 			break;
 
 		case SDL_KEYDOWN:
-			user_key(event.key.keysym.sym,event.key.keysym.unicode,event.key.keysym.mod,0);
+			user_key(event.key.keysym.sym, event.key.keysym.unicode, event.key.keysym.mod, 0);
 			break;
 		case SDL_KEYUP:
-			user_key(event.key.keysym.sym,event.key.keysym.unicode,event.key.keysym.mod,1);
+			user_key(event.key.keysym.sym, event.key.keysym.unicode, event.key.keysym.mod, 1);
 			break;
 		case SDL_QUIT:
-			s3dprintf(HIGH,"SDL_QUIT");
+			s3dprintf(HIGH, "SDL_QUIT");
 			quit();
 			break;
 			/*  these events are not processed right now ... */
 		case SDL_ACTIVEEVENT:
-			s3dprintf(VLOW,"SDL_ACTIVEEVENT");
+			s3dprintf(VLOW, "SDL_ACTIVEEVENT");
 			break;
 		case SDL_SYSWMEVENT:
-			s3dprintf(VLOW,"SDL_SYSWMEVENT");
+			s3dprintf(VLOW, "SDL_SYSWMEVENT");
 			break;
 		case SDL_VIDEORESIZE:
-			if ((GLwin = SDL_SetVideoMode(event.resize.w,event.resize.h,16,SDLFlags))==NULL)
-				errsf("SDL_SetVideoMode()",SDL_GetError());
-			graphics_reshape(event.resize.w,event.resize.h);
+			if ((GLwin = SDL_SetVideoMode(event.resize.w, event.resize.h, 16, SDLFlags)) == NULL)
+				errsf("SDL_SetVideoMode()", SDL_GetError());
+			graphics_reshape(event.resize.w, event.resize.h);
 			break;
 		case SDL_VIDEOEXPOSE:
-			s3dprintf(VLOW,"SDL_VIDEOEXPOSE");
+			s3dprintf(VLOW, "SDL_VIDEOEXPOSE");
 			break;
 		case SDL_USEREVENT:
-			s3dprintf(VLOW,"SDL_USEREVENT");
+			s3dprintf(VLOW, "SDL_USEREVENT");
 			break;
 		case SDL_JOYAXISMOTION:
-			s3dprintf(VLOW,"SDL_JOYAXISMOTION");
+			s3dprintf(VLOW, "SDL_JOYAXISMOTION");
 			break;
 		case SDL_JOYBALLMOTION:
-			s3dprintf(VLOW,"SDL_JOYBALLMOTION");
+			s3dprintf(VLOW, "SDL_JOYBALLMOTION");
 			break;
 		case SDL_JOYHATMOTION:
-			s3dprintf(VLOW,"SDL_JOYHATMOTION");
+			s3dprintf(VLOW, "SDL_JOYHATMOTION");
 			break;
 		case SDL_JOYBUTTONDOWN:
-			s3dprintf(VLOW,"SDL_JOYBUTTONDOWN");
+			s3dprintf(VLOW, "SDL_JOYBUTTONDOWN");
 			break;
 		case SDL_JOYBUTTONUP:
-			s3dprintf(VLOW,"SDL_JOYBUTTONUP");
+			s3dprintf(VLOW, "SDL_JOYBUTTONUP");
 			break;
 		default:
-			s3dprintf(MED,"SDL_PollEvent(): unhandled event");
+			s3dprintf(MED, "SDL_PollEvent(): unhandled event");
 			break;
 		}
 	}



From dotslash at mail.berlios.de  Fri Sep 21 16:39:49 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Fri, 21 Sep 2007 16:39:49 +0200
Subject: [S3d-svn] r668 - in trunk: . libs3dw
Message-ID: <200709211439.l8LEdnON019044@sheep.berlios.de>

Author: dotslash
Date: 2007-09-21 16:39:49 +0200 (Fri, 21 Sep 2007)
New Revision: 668

Modified:
   trunk/
   trunk/libs3dw/animate.c
   trunk/libs3dw/root.c
   trunk/libs3dw/s3dw_int.h
   trunk/libs3dw/scrollbar.c
   trunk/libs3dw/textbox.c
   trunk/libs3dw/widget.c
Log:
 r2408 at kero:  dotslash | 2007-09-21 16:39:29 +0200
 - remove some ugly bug: 
      pointers in the animation stack were not properly removed when widget was deleted, so the animation
 	 was still executed on a not (or re-)allocated chunk of memory, causing fancy things to happen.
 - remove warnings for -W
 



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2374
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2408

Modified: trunk/libs3dw/animate.c
===================================================================
--- trunk/libs3dw/animate.c	2007-09-17 13:51:17 UTC (rev 667)
+++ trunk/libs3dw/animate.c	2007-09-21 14:39:49 UTC (rev 668)
@@ -33,25 +33,26 @@
 int ani_need_arr = 0;
 
 /* is item f already on stack? */
-int s3dw_ani_onstack(s3dw_widget *f)
+int s3dw_ani_stackpos(s3dw_widget *f)
 {
 	int i;
 	for (i = 0;i < ani_n;i++)
 		if (ani_s[i] == f)
-			return(1);  /* already in list */
-	return(0);
+			return(i);  /* already in list */
+	return(-1);
 
 }
 /* add an item on the animation stack */
 void s3dw_ani_add(s3dw_widget *f)
 {
 
+	s3dprintf(VLOW, "[A]ni ADD (%010p), oid = %d, ani_n = %d, type is %s\n", f, f->oid, ani_n, s3dw_get_type_string(f->type));
 	if ((f->oid == 0) && (f->type != S3DW_TCAM)) {
-		s3dprintf(HIGH, "s3dw_ani_add() assert failed: weird, moving cam but its not a cam obeject?");
+		s3dprintf(HIGH, "s3dw_ani_add() assert failed: weird, moving cam but its not a cam object?");
 		return;
 	}
 	if ((ani_n < MAXANI) && (animation_on)) {
-		if (s3dw_ani_onstack(f))
+		if (s3dw_ani_stackpos(f) != -1)
 			return;  /* already in list */
 		ani_s[ani_n] = f;
 		s3dw_ani_iterate(f);
@@ -63,18 +64,18 @@
 void s3dw_ani_del(int i)
 {
 	if ((i >= 0) && (i < ani_n)) {
-		/*  printf("[A]ni DEL %d\n",i);*/
+		s3dprintf(VLOW, "[A]ni DEL %d, ani_n = %d\n",i, ani_n);
 		ani_n--;
 		ani_s[i] = ani_s[ani_n]; /* that should also work if i is the last one */
 	} else {
 		s3dprintf(MED, "[F]ATAL: can't delete animation!\n");
 	}
 }
-/* well ... */
+/* apply the animation */
 void s3dw_ani_doit(s3dw_widget *f)
 {
 	if ((f->oid == 0) && (f->type != S3DW_TCAM)) {
-		s3dprintf(HIGH, "s3dw_ani_doit() assert failed: weird, moving cam but its not a cam obeject?");
+		s3dprintf(HIGH, "s3dw_ani_doit() assert failed: weird, moving cam but its not a cam object?");
 	} else {
 		if (f->oid == 0) {
 			s3dprintf(HIGH, "moving cam");
@@ -99,6 +100,7 @@
 	if (i != -1)
 		s3dw_ani_del(i);
 }
+/* do one step of the animation */
 void s3dw_ani_iterate(s3dw_widget *f)
 {
 	f->ax = (f->x + f->ax * ZOOMS) / (ZOOMS + 1);

Modified: trunk/libs3dw/root.c
===================================================================
--- trunk/libs3dw/root.c	2007-09-17 13:51:17 UTC (rev 667)
+++ trunk/libs3dw/root.c	2007-09-21 14:39:49 UTC (rev 668)
@@ -54,6 +54,21 @@
 	return(0);
 }
 
+char *s3dw_get_type_string(int type) 
+{
+	switch (type) {
+	case S3DW_TROOT: 		return("root");
+	case S3DW_TCAM: 		return("cam");
+	case S3DW_TSURFACE:		return("surface");
+	case S3DW_TBUTTON: 		return("button");
+	case S3DW_TLABEL: 		return("label");
+	case S3DW_TINPUT: 		return("input");
+	case S3DW_TTEXTBOX: 	return("textbox");
+	case S3DW_TSCROLLBAR: 	return("scrollbar");
+	}
+	return(NULL);
+}
+
 /* get the root .... if it's NULL, the lib is not initialized, so do this too ... */
 s3dw_widget *s3dw_getroot()
 {

Modified: trunk/libs3dw/s3dw_int.h
===================================================================
--- trunk/libs3dw/s3dw_int.h	2007-09-17 13:51:17 UTC (rev 667)
+++ trunk/libs3dw/s3dw_int.h	2007-09-21 14:39:49 UTC (rev 668)
@@ -39,6 +39,7 @@
 int s3dw_click_nothing(s3dw_widget *widget, uint32_t dummy);
 int s3dw_key_nothing(s3dw_widget *widget, struct s3d_key_event *dummy);
 void s3dw_root_destroy(s3dw_widget *widget);
+char *s3dw_get_type_string(int type);
 /* widget.c */
 s3dw_widget *s3dw_widget_new();
 void s3dw_widget_append(s3dw_widget *parent, s3dw_widget *widget);
@@ -105,7 +106,7 @@
 /* style.c */
 extern s3dw_style def_style;
 /* animate.c */
-int  s3dw_ani_onstack(s3dw_widget *f);
+int  s3dw_ani_stackpos(s3dw_widget *f);
 void s3dw_ani_add(s3dw_widget *f);
 void s3dw_ani_del(int i);
 void s3dw_ani_doit(s3dw_widget *f);

Modified: trunk/libs3dw/scrollbar.c
===================================================================
--- trunk/libs3dw/scrollbar.c	2007-09-17 13:51:17 UTC (rev 667)
+++ trunk/libs3dw/scrollbar.c	2007-09-21 14:39:49 UTC (rev 668)
@@ -372,11 +372,11 @@
 int s3dw_scrollbar_event_click(s3dw_widget *widget, uint32_t oid)
 {
 	s3dw_scrollbar *scrollbar = (s3dw_scrollbar *)widget;
-	if (scrollbar->loid == oid) {
+	if (scrollbar->loid == (int)oid) {
 		scrollbar->lonclick(widget);
 		return(1);
 	}
-	if (scrollbar->roid == oid) {
+	if (scrollbar->roid == (int)oid) {
 		scrollbar->ronclick(widget);
 		return(1);
 	}

Modified: trunk/libs3dw/textbox.c
===================================================================
--- trunk/libs3dw/textbox.c	2007-09-17 13:51:17 UTC (rev 667)
+++ trunk/libs3dw/textbox.c	2007-09-21 14:39:49 UTC (rev 668)
@@ -124,7 +124,7 @@
 	rest = text = strdup(textbox->text);
 	while (NULL != (linefeedpos = strchr(rest, '\n'))) { /* process every line */
 		linefeedpos[0] = 0;
-		if ((x < strlen(rest)) && ((y >= 0) && y < textbox->n_lineoids)) { /* don't bother, if it's not visible anyway */
+		if ((x < (int)strlen(rest)) && ((y >= 0) && y < textbox->n_lineoids)) { /* don't bother, if it's not visible anyway */
 			rest += x; /* ignore the first x chars because we've scrolled a bit right */
 			while ((strlen(rest) > 0) && (s3d_strlen(rest) > width))
 				rest[strlen(rest)-1] = 0; /* remove last character and try again until it fits */

Modified: trunk/libs3dw/widget.c
===================================================================
--- trunk/libs3dw/widget.c	2007-09-17 13:51:17 UTC (rev 667)
+++ trunk/libs3dw/widget.c	2007-09-21 14:39:49 UTC (rev 668)
@@ -82,7 +82,11 @@
 void s3dw_widget_remove(s3dw_widget *widget)
 {
 	s3dw_widget *parent = widget->parent;
-	int i;
+	int i, stackpos;
+
+    stackpos = s3dw_ani_stackpos(widget);
+	if (stackpos != -1 )
+		s3dw_ani_del(stackpos);
 	if (parent == NULL) return;
 
 	for (i = 0;i < parent->nobj;i++) /* search ... */



From lazhur at mail.berlios.de  Sat Sep 22 12:57:05 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 22 Sep 2007 12:57:05 +0200
Subject: [S3d-svn] r669 - trunk/server
Message-ID: <200709221057.l8MAv5wr010134@sheep.berlios.de>

Author: lazhur
Date: 2007-09-22 12:57:04 +0200 (Sat, 22 Sep 2007)
New Revision: 669

Modified:
   trunk/server/graphics.c
Log:
Fixed Gentoo QA notice about implicit declaration of glutSwapBuffers


Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2007-09-21 14:39:49 UTC (rev 668)
+++ trunk/server/graphics.c	2007-09-22 10:57:04 UTC (rev 669)
@@ -24,11 +24,11 @@
 #include "global.h"
 #include <stdlib.h>   /*  malloc() */
 #include <string.h>   /*  memcpy() */
-/*
+
 #ifdef G_GLUT
-#include <GL/glut.h>   *  glutWireTorus() -  to be removed later *
+#include <GL/glut.h>   /*  glutSwapBuffers() */
 #endif
-*/
+
 #include <GL/gl.h>   /*  GLint */
 #ifdef G_SDL
 #include <SDL.h>  /*  SDL_GL_SwapBuffers */



From lazhur at mail.berlios.de  Sat Sep 22 18:05:58 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 22 Sep 2007 18:05:58 +0200
Subject: [S3d-svn] r670 - in trunk: . apps/s3dosm libs3d libs3dw
Message-ID: <200709221605.l8MG5wGB008106@sheep.berlios.de>

Author: lazhur
Date: 2007-09-22 18:05:56 +0200 (Sat, 22 Sep 2007)
New Revision: 670

Modified:
   trunk/apps/s3dosm/LICENSE
   trunk/gpl.txt
   trunk/libs3d/lgpl.txt
   trunk/libs3dw/lgpl.txt
Log:
Updated (L)GPL license files

GPL delivered with s3d used the old term "GNU Library General Public License" instead of "GNU Lesser General Public License" used in the source files. Files were taken from FSF and no license restrictions of s3d and/or it's components were changed.


Modified: trunk/apps/s3dosm/LICENSE
===================================================================
--- trunk/apps/s3dosm/LICENSE	2007-09-22 10:57:04 UTC (rev 669)
+++ trunk/apps/s3dosm/LICENSE	2007-09-22 16:05:56 UTC (rev 670)
@@ -1,8 +1,8 @@
 		    GNU GENERAL PUBLIC LICENSE
 		       Version 2, June 1991
 
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
@@ -15,7 +15,7 @@
 General Public License applies to most of the Free Software
 Foundation's software and to any other program whose authors commit to
 using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
+the GNU Lesser General Public License instead.)  You can apply it to
 your programs, too.
 
   When we speak of free software, we are referring to freedom, not
@@ -55,7 +55,7 @@
 
   The precise terms and conditions for copying, distribution and
 modification follow.
-
+
 		    GNU GENERAL PUBLIC LICENSE
    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 
@@ -110,7 +110,7 @@
     License.  (Exception: if the Program itself is interactive but
     does not normally print such an announcement, your work based on
     the Program is not required to print an announcement.)
-
+
 These requirements apply to the modified work as a whole.  If
 identifiable sections of that work are not derived from the Program,
 and can be reasonably considered independent and separate works in
@@ -168,7 +168,7 @@
 access to copy the source code from the same place counts as
 distribution of the source code, even though third parties are not
 compelled to copy the source along with the object code.
-
+
   4. You may not copy, modify, sublicense, or distribute the Program
 except as expressly provided under this License.  Any attempt
 otherwise to copy, modify, sublicense or distribute the Program is
@@ -225,7 +225,7 @@
 
 This section is intended to make thoroughly clear what is believed to
 be a consequence of the rest of this License.
-
+
   8. If the distribution and/or use of the Program is restricted in
 certain countries either by patents or by copyrighted interfaces, the
 original copyright holder who places the Program under this License
@@ -278,7 +278,7 @@
 POSSIBILITY OF SUCH DAMAGES.
 
 		     END OF TERMS AND CONDITIONS
-
+
 	    How to Apply These Terms to Your New Programs
 
   If you develop a new program, and you want it to be of the greatest
@@ -303,11 +303,10 @@
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-
 Also add information on how to contact you by electronic and paper mail.
 
 If the program is interactive, make it output a short notice like this
@@ -336,5 +335,5 @@
 This General Public License does not permit incorporating your program into
 proprietary programs.  If your program is a subroutine library, you may
 consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
+library.  If this is what you want to do, use the GNU Lesser General
 Public License instead of this License.

Modified: trunk/gpl.txt
===================================================================
--- trunk/gpl.txt	2007-09-22 10:57:04 UTC (rev 669)
+++ trunk/gpl.txt	2007-09-22 16:05:56 UTC (rev 670)
@@ -1,8 +1,8 @@
 		    GNU GENERAL PUBLIC LICENSE
 		       Version 2, June 1991
 
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
@@ -15,7 +15,7 @@
 General Public License applies to most of the Free Software
 Foundation's software and to any other program whose authors commit to
 using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
+the GNU Lesser General Public License instead.)  You can apply it to
 your programs, too.
 
   When we speak of free software, we are referring to freedom, not
@@ -55,7 +55,7 @@
 
   The precise terms and conditions for copying, distribution and
 modification follow.
-
+
 		    GNU GENERAL PUBLIC LICENSE
    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 
@@ -110,7 +110,7 @@
     License.  (Exception: if the Program itself is interactive but
     does not normally print such an announcement, your work based on
     the Program is not required to print an announcement.)
-
+
 These requirements apply to the modified work as a whole.  If
 identifiable sections of that work are not derived from the Program,
 and can be reasonably considered independent and separate works in
@@ -168,7 +168,7 @@
 access to copy the source code from the same place counts as
 distribution of the source code, even though third parties are not
 compelled to copy the source along with the object code.
-
+
   4. You may not copy, modify, sublicense, or distribute the Program
 except as expressly provided under this License.  Any attempt
 otherwise to copy, modify, sublicense or distribute the Program is
@@ -225,7 +225,7 @@
 
 This section is intended to make thoroughly clear what is believed to
 be a consequence of the rest of this License.
-
+
   8. If the distribution and/or use of the Program is restricted in
 certain countries either by patents or by copyrighted interfaces, the
 original copyright holder who places the Program under this License
@@ -278,7 +278,7 @@
 POSSIBILITY OF SUCH DAMAGES.
 
 		     END OF TERMS AND CONDITIONS
-
+
 	    How to Apply These Terms to Your New Programs
 
   If you develop a new program, and you want it to be of the greatest
@@ -303,11 +303,10 @@
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
-
 Also add information on how to contact you by electronic and paper mail.
 
 If the program is interactive, make it output a short notice like this
@@ -336,5 +335,5 @@
 This General Public License does not permit incorporating your program into
 proprietary programs.  If your program is a subroutine library, you may
 consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
+library.  If this is what you want to do, use the GNU Lesser General
 Public License instead of this License.

Modified: trunk/libs3d/lgpl.txt
===================================================================
--- trunk/libs3d/lgpl.txt	2007-09-22 10:57:04 UTC (rev 669)
+++ trunk/libs3d/lgpl.txt	2007-09-22 16:05:56 UTC (rev 670)
@@ -2,7 +2,7 @@
 		       Version 2.1, February 1999
 
  Copyright (C) 1991, 1999 Free Software Foundation, Inc.
-     51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
@@ -485,7 +485,7 @@
 
     You should have received a copy of the GNU Lesser General Public
     License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 
 Also add information on how to contact you by electronic and paper mail.
 

Modified: trunk/libs3dw/lgpl.txt
===================================================================
--- trunk/libs3dw/lgpl.txt	2007-09-22 10:57:04 UTC (rev 669)
+++ trunk/libs3dw/lgpl.txt	2007-09-22 16:05:56 UTC (rev 670)
@@ -2,7 +2,7 @@
 		       Version 2.1, February 1999
 
  Copyright (C) 1991, 1999 Free Software Foundation, Inc.
-     51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
@@ -485,7 +485,7 @@
 
     You should have received a copy of the GNU Lesser General Public
     License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 
 Also add information on how to contact you by electronic and paper mail.
 



From lazhur at mail.berlios.de  Sat Sep 22 18:06:27 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 22 Sep 2007 18:06:27 +0200
Subject: [S3d-svn] r671 - trunk/apps/s3dosm
Message-ID: <200709221606.l8MG6RBS008170@sheep.berlios.de>

Author: lazhur
Date: 2007-09-22 18:06:25 +0200 (Sat, 22 Sep 2007)
New Revision: 671

Modified:
   trunk/apps/s3dosm/http_error_codes.c
   trunk/apps/s3dosm/http_error_codes.h
   trunk/apps/s3dosm/http_fetcher.c
   trunk/apps/s3dosm/http_fetcher.h
Log:
Changed license of http_* from Lyle Hanson to GPL2

Files are used in a GPL2 program and are now licensed under GPL2 according to LGPL2 section 3


Modified: trunk/apps/s3dosm/http_error_codes.c
===================================================================
--- trunk/apps/s3dosm/http_error_codes.c	2007-09-22 16:05:56 UTC (rev 670)
+++ trunk/apps/s3dosm/http_error_codes.c	2007-09-22 16:06:25 UTC (rev 671)
@@ -1,19 +1,24 @@
 /* http_error_codes.c - Error code declarations
-
- HTTP Fetcher
-  Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
-
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Library General Public
- License as published by the Free Software Foundation; either
- version 2 of the License, or (at your option) any later version.
-
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Library General Public License for more details.
-
- See LICENSE file for details
+ *
+ * HTTP Fetcher
+ *  Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
+ *
+ * This file is part of s3dosm, a gps card application for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * s3dosm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * s3dosm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with s3dosm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 

Modified: trunk/apps/s3dosm/http_error_codes.h
===================================================================
--- trunk/apps/s3dosm/http_error_codes.h	2007-09-22 16:05:56 UTC (rev 670)
+++ trunk/apps/s3dosm/http_error_codes.h	2007-09-22 16:06:25 UTC (rev 671)
@@ -1,19 +1,23 @@
 /* http_error_codes.h - Error code definitions
-
- Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
-
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Library General Public
- License as published by the Free Software Foundation; either
- version 2 of the License, or (at your option) any later version.
-
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Library General Public License for more details.
-
- See LICENSE file for details
-
+ *
+ * Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
+ *
+ * This file is part of s3dosm, a gps card application for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * s3dosm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * s3dosm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with s3dosm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 #ifndef HTTP_ERROR_CODES_H

Modified: trunk/apps/s3dosm/http_fetcher.c
===================================================================
--- trunk/apps/s3dosm/http_fetcher.c	2007-09-22 16:05:56 UTC (rev 670)
+++ trunk/apps/s3dosm/http_fetcher.c	2007-09-22 16:06:25 UTC (rev 671)
@@ -1,23 +1,28 @@
 /* http_fetcher.c - HTTP handling functions
-
- Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
-
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Library General Public
- License as published by the Free Software Foundation; either
- version 2 of the License, or (at your option) any later version.
-
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Library General Public License for more details.
-
- See included LICENSE file for details
-
- Changes:
-  Simon Wunderlich <dotslash at packetmixer.de>
-  + added http_setAuth() to support basic http-authentication and some minor fixes
-
+ *
+ * Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
+ *
+ * This file is part of s3dosm, a gps card application for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * s3dosm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * s3dosm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with s3dosm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *
+ * Changes:
+ *  Simon Wunderlich <dotslash at packetmixer.de>
+ *  + added http_setAuth() to support basic http-authentication and some minor fixes
  */
 
 #include <stdlib.h>

Modified: trunk/apps/s3dosm/http_fetcher.h
===================================================================
--- trunk/apps/s3dosm/http_fetcher.h	2007-09-22 16:05:56 UTC (rev 670)
+++ trunk/apps/s3dosm/http_fetcher.h	2007-09-22 16:06:25 UTC (rev 671)
@@ -1,24 +1,29 @@
 /* http_fetcher.h - HTTP handling functions
-
- HTTP Fetcher
- Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
-
- This library is free software; you can redistribute it and/or
- modify it under the terms of the GNU Library General Public
- License as published by the Free Software Foundation; either
- version 2 of the License, or (at your option) any later version.
-
- This library is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- Library General Public License for more details.
-
- See LICENSE file for details
-
- Changes:
-  Simon Wunderlich <dotslash at packetmixer.de>
-  + added http_setAuth() to support basic http-authentication and some minor fixes
-
+ *
+ * HTTP Fetcher
+ * Copyright (C) 2001 Lyle Hanson (lhanson at cs.nmu.edu)
+ *
+ * This file is part of s3dosm, a gps card application for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * s3dosm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * s3dosm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with s3dosm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ *
+ * Changes:
+ *  Simon Wunderlich <dotslash at packetmixer.de>
+ *  + added http_setAuth() to support basic http-authentication and some minor fixes
  */
 
 #ifndef HTTP_FETCHER_H



From lazhur at mail.berlios.de  Sat Sep 22 18:06:51 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 22 Sep 2007 18:06:51 +0200
Subject: [S3d-svn] r672 - trunk
Message-ID: <200709221606.l8MG6pj7008240@sheep.berlios.de>

Author: lazhur
Date: 2007-09-22 18:06:50 +0200 (Sat, 22 Sep 2007)
New Revision: 672

Modified:
   trunk/README
Log:
Added list with license informations to README


Modified: trunk/README
===================================================================
--- trunk/README	2007-09-22 16:06:25 UTC (rev 671)
+++ trunk/README	2007-09-22 16:06:50 UTC (rev 672)
@@ -53,6 +53,24 @@
 if I'm mistaken in any ownership-concerns, please tell me and don't be 
 too mad at me, as I have had no idea of licensing at all.
 
+Applications (GPLv2 or later):
+* apps/dot_mcp
+* apps/kism3d
+* apps/olsrs3d
+* apps/s3d_x11gate
+* apps/s3dfm
+* apps/s3dosm
+* apps/s3dvt
+* example/*
+* server
+
+Applications (GPLv2):
+* apps/meshs3d
+
+Librarys (LGPLv2.1 or later)
+* libs3d
+* libs3dw
+
 5. DOCUMENTATION
 ----------------
 



From lazhur at mail.berlios.de  Sat Sep 22 18:07:14 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 22 Sep 2007 18:07:14 +0200
Subject: [S3d-svn] r673 - in trunk: . apps/s3dosm libs3d libs3dw
Message-ID: <200709221607.l8MG7EFI008307@sheep.berlios.de>

Author: lazhur
Date: 2007-09-22 18:07:11 +0200 (Sat, 22 Sep 2007)
New Revision: 673

Added:
   trunk/COPYING
   trunk/COPYING.LESSER
Removed:
   trunk/apps/s3dosm/LICENSE
   trunk/gpl.txt
   trunk/libs3d/lgpl.txt
   trunk/libs3dw/lgpl.txt
Modified:
   trunk/README
Log:
Moved (L)GPL license files to the root directory


Copied: trunk/COPYING (from rev 672, trunk/apps/s3dosm/LICENSE)
===================================================================
--- trunk/apps/s3dosm/LICENSE	2007-09-22 16:06:50 UTC (rev 672)
+++ trunk/COPYING	2007-09-22 16:07:11 UTC (rev 673)
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.

Copied: trunk/COPYING.LESSER (from rev 672, trunk/libs3d/lgpl.txt)
===================================================================
--- trunk/libs3d/lgpl.txt	2007-09-22 16:06:50 UTC (rev 672)
+++ trunk/COPYING.LESSER	2007-09-22 16:07:11 UTC (rev 673)
@@ -0,0 +1,504 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+ 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+

Modified: trunk/README
===================================================================
--- trunk/README	2007-09-22 16:06:50 UTC (rev 672)
+++ trunk/README	2007-09-22 16:07:11 UTC (rev 673)
@@ -49,7 +49,7 @@
 The Library is licensed under the GNU Lesser GPL (LGPL), so you can 
 also write close-sourced thing which links to the library (if you 
 really have to ...).
-gpl.txt for the GPL and client/lgpl.txt for the LGPL are included too.
+COPYING for the GPLv2 and COPYING.LESSER for the LGPLv2.1 are included too.
 if I'm mistaken in any ownership-concerns, please tell me and don't be 
 too mad at me, as I have had no idea of licensing at all.
 

Deleted: trunk/apps/s3dosm/LICENSE
===================================================================
--- trunk/apps/s3dosm/LICENSE	2007-09-22 16:06:50 UTC (rev 672)
+++ trunk/apps/s3dosm/LICENSE	2007-09-22 16:07:11 UTC (rev 673)
@@ -1,339 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License along
-    with this program; if not, write to the Free Software Foundation, Inc.,
-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.

Deleted: trunk/gpl.txt
===================================================================
--- trunk/gpl.txt	2007-09-22 16:06:50 UTC (rev 672)
+++ trunk/gpl.txt	2007-09-22 16:07:11 UTC (rev 673)
@@ -1,339 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License along
-    with this program; if not, write to the Free Software Foundation, Inc.,
-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.

Deleted: trunk/libs3d/lgpl.txt
===================================================================
--- trunk/libs3d/lgpl.txt	2007-09-22 16:06:50 UTC (rev 672)
+++ trunk/libs3d/lgpl.txt	2007-09-22 16:07:11 UTC (rev 673)
@@ -1,504 +0,0 @@
-		  GNU LESSER GENERAL PUBLIC LICENSE
-		       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
- 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-		  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
-
-

Deleted: trunk/libs3dw/lgpl.txt
===================================================================
--- trunk/libs3dw/lgpl.txt	2007-09-22 16:06:50 UTC (rev 672)
+++ trunk/libs3dw/lgpl.txt	2007-09-22 16:07:11 UTC (rev 673)
@@ -1,504 +0,0 @@
-		  GNU LESSER GENERAL PUBLIC LICENSE
-		       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
- 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-		  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
-
-



From lazhur at mail.berlios.de  Sat Sep 22 18:44:24 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 22 Sep 2007 18:44:24 +0200
Subject: [S3d-svn] r674 - in trunk: . apps/meshs3d
Message-ID: <200709221644.l8MGiOXC011163@sheep.berlios.de>

Author: lazhur
Date: 2007-09-22 18:44:22 +0200 (Sat, 22 Sep 2007)
New Revision: 674

Modified:
   trunk/README
   trunk/apps/meshs3d/allocate.c
   trunk/apps/meshs3d/allocate.h
   trunk/apps/meshs3d/hash.c
   trunk/apps/meshs3d/hash.h
Log:
Changed the license of meshs3d to GPLv2 or later with the agreement of the respective authors


Modified: trunk/README
===================================================================
--- trunk/README	2007-09-22 16:07:11 UTC (rev 673)
+++ trunk/README	2007-09-22 16:44:22 UTC (rev 674)
@@ -56,6 +56,7 @@
 Applications (GPLv2 or later):
 * apps/dot_mcp
 * apps/kism3d
+* apps/meshs3d
 * apps/olsrs3d
 * apps/s3d_x11gate
 * apps/s3dfm
@@ -64,9 +65,6 @@
 * example/*
 * server
 
-Applications (GPLv2):
-* apps/meshs3d
-
 Librarys (LGPLv2.1 or later)
 * libs3d
 * libs3dw

Modified: trunk/apps/meshs3d/allocate.c
===================================================================
--- trunk/apps/meshs3d/allocate.c	2007-09-22 16:07:11 UTC (rev 673)
+++ trunk/apps/meshs3d/allocate.c	2007-09-22 16:44:22 UTC (rev 674)
@@ -1,20 +1,25 @@
 /*
- * Copyright (C) 2006 B.A.T.M.A.N. contributors:
- * Thomas Lopatic, Corinna 'Elektra' Aichele, Axel Neumann, Marek Lindner
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of version 2 of the GNU General Public
- * License as published by the Free Software Foundation.
+ * allocate.c
  *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
+ * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                    Marek Lindner <lindner_marek at yahoo.de>
  *
+ * This file is part of meshs3d, an olsr/batman topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA
- *
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 

Modified: trunk/apps/meshs3d/allocate.h
===================================================================
--- trunk/apps/meshs3d/allocate.h	2007-09-22 16:07:11 UTC (rev 673)
+++ trunk/apps/meshs3d/allocate.h	2007-09-22 16:44:22 UTC (rev 674)
@@ -1,20 +1,25 @@
 /*
- * Copyright (C) 2006 B.A.T.M.A.N. contributors:
- * Thomas Lopatic, Corinna 'Elektra' Aichele, Axel Neumann, Marek Lindner
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of version 2 of the GNU General Public
- * License as published by the Free Software Foundation.
+ * allocate.h
  *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
+ * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                    Marek Lindner <lindner_marek at yahoo.de>
  *
+ * This file is part of meshs3d, an olsr/batman topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA
- *
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 

Modified: trunk/apps/meshs3d/hash.c
===================================================================
--- trunk/apps/meshs3d/hash.c	2007-09-22 16:07:11 UTC (rev 673)
+++ trunk/apps/meshs3d/hash.c	2007-09-22 16:44:22 UTC (rev 674)
@@ -1,20 +1,25 @@
-/* Copyright (C) 2006 B.A.T.M.A.N. contributors:
- * Simon Wunderlich, Marek Lindner
+/*
+ * hash.c
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of version 2 of the GNU General Public
- * License as published by the Free Software Foundation.
+ * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                    Marek Lindner <lindner_marek at yahoo.de>
  *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
+ * This file is part of meshs3d, an olsr/batman topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
  *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA
- *
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 

Modified: trunk/apps/meshs3d/hash.h
===================================================================
--- trunk/apps/meshs3d/hash.h	2007-09-22 16:07:11 UTC (rev 673)
+++ trunk/apps/meshs3d/hash.h	2007-09-22 16:44:22 UTC (rev 674)
@@ -1,20 +1,25 @@
-/* Copyright (C) 2006 B.A.T.M.A.N. contributors:
- * Simon Wunderlich, Marek Lindner
+/*
+ * hash.h
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of version 2 of the GNU General Public
- * License as published by the Free Software Foundation.
+ * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                    Marek Lindner <lindner_marek at yahoo.de>
  *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
+ * This file is part of meshs3d, an olsr/batman topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
  *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA
- *
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 



From lazhur at mail.berlios.de  Sat Sep 22 18:52:23 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 22 Sep 2007 18:52:23 +0200
Subject: [S3d-svn] r675 - trunk/libs3dw
Message-ID: <200709221652.l8MGqNOl018855@sheep.berlios.de>

Author: lazhur
Date: 2007-09-22 18:52:22 +0200 (Sat, 22 Sep 2007)
New Revision: 675

Modified:
   trunk/libs3dw/animate.c
   trunk/libs3dw/root.c
   trunk/libs3dw/widget.c
Log:
Reformatted commit 668 according to the new style guidelines


Modified: trunk/libs3dw/animate.c
===================================================================
--- trunk/libs3dw/animate.c	2007-09-22 16:44:22 UTC (rev 674)
+++ trunk/libs3dw/animate.c	2007-09-22 16:52:22 UTC (rev 675)
@@ -64,7 +64,7 @@
 void s3dw_ani_del(int i)
 {
 	if ((i >= 0) && (i < ani_n)) {
-		s3dprintf(VLOW, "[A]ni DEL %d, ani_n = %d\n",i, ani_n);
+		s3dprintf(VLOW, "[A]ni DEL %d, ani_n = %d\n", i, ani_n);
 		ani_n--;
 		ani_s[i] = ani_s[ani_n]; /* that should also work if i is the last one */
 	} else {

Modified: trunk/libs3dw/root.c
===================================================================
--- trunk/libs3dw/root.c	2007-09-22 16:44:22 UTC (rev 674)
+++ trunk/libs3dw/root.c	2007-09-22 16:52:22 UTC (rev 675)
@@ -54,17 +54,25 @@
 	return(0);
 }
 
-char *s3dw_get_type_string(int type) 
+char *s3dw_get_type_string(int type)
 {
 	switch (type) {
-	case S3DW_TROOT: 		return("root");
-	case S3DW_TCAM: 		return("cam");
-	case S3DW_TSURFACE:		return("surface");
-	case S3DW_TBUTTON: 		return("button");
-	case S3DW_TLABEL: 		return("label");
-	case S3DW_TINPUT: 		return("input");
-	case S3DW_TTEXTBOX: 	return("textbox");
-	case S3DW_TSCROLLBAR: 	return("scrollbar");
+	case S3DW_TROOT:
+		return("root");
+	case S3DW_TCAM:
+		return("cam");
+	case S3DW_TSURFACE:
+		return("surface");
+	case S3DW_TBUTTON:
+		return("button");
+	case S3DW_TLABEL:
+		return("label");
+	case S3DW_TINPUT:
+		return("input");
+	case S3DW_TTEXTBOX:
+		return("textbox");
+	case S3DW_TSCROLLBAR:
+		return("scrollbar");
 	}
 	return(NULL);
 }

Modified: trunk/libs3dw/widget.c
===================================================================
--- trunk/libs3dw/widget.c	2007-09-22 16:44:22 UTC (rev 674)
+++ trunk/libs3dw/widget.c	2007-09-22 16:52:22 UTC (rev 675)
@@ -84,8 +84,8 @@
 	s3dw_widget *parent = widget->parent;
 	int i, stackpos;
 
-    stackpos = s3dw_ani_stackpos(widget);
-	if (stackpos != -1 )
+	stackpos = s3dw_ani_stackpos(widget);
+	if (stackpos != -1)
 		s3dw_ani_del(stackpos);
 	if (parent == NULL) return;
 



From dotslash at mail.berlios.de  Sat Sep 22 19:54:11 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 22 Sep 2007 19:54:11 +0200
Subject: [S3d-svn] r676 - trunk/apps/s3dosm
Message-ID: <200709221754.l8MHsBtQ030356@sheep.berlios.de>

Author: dotslash
Date: 2007-09-22 19:54:11 +0200 (Sat, 22 Sep 2007)
New Revision: 676

Modified:
   trunk/apps/s3dosm/gps.c
   trunk/apps/s3dosm/main.c
Log:
- nonblocking gps mode, don't block if gps does not send data

Modified: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2007-09-22 16:52:22 UTC (rev 675)
+++ trunk/apps/s3dosm/gps.c	2007-09-22 17:54:11 UTC (rev 676)
@@ -41,6 +41,8 @@
 #include <stdio.h>   /*  snprintf(), printf(), NULL */
 #include <time.h>  /*  nanosleep(), struct tm, time_t...  */
 #include <math.h> /* fabs(), finite () */
+#include <fcntl.h>  /* fcntl() */
+#include <unistd.h> /* fcntl() */
 static struct gps_data_t  *dgps;
 static int       frame = 0;
 static int       lastfix = 0;
@@ -175,6 +177,7 @@
 }
 int gps_init(char *gpshost)
 {
+	int sock_opts;
 	char *err_str;
 	dgps = gps_open(gpshost, "2947");
 	if (dgps == NULL) {
@@ -205,6 +208,9 @@
 		fprintf(stderr, "s3dosm: no gpsd running or network error: %d, %s\n" ,  errno, err_str);
 		return(-1);
 	}
+	sock_opts = fcntl(dgps->gps_fd, F_GETFL, 0);
+	fcntl(dgps->gps_fd, F_SETFL, sock_opts | O_NONBLOCK);
+
 	user_icon = s3d_clone(icons[ICON_ARROW].oid);
 	user_icon_rotator = s3d_new_object();
 	s3d_link(user_icon, user_icon_rotator);
@@ -221,8 +227,11 @@
 {
 	if (gps_active && ((frame % 6) == 0)) {
 		if (gps_poll(dgps) < 0) {
-			printf("read error on server socket\n");
-			gps_quit();
+			if (errno != EWOULDBLOCK) {
+
+				printf("read error on server socket\n");
+				gps_quit();
+			}
 		}
 
 		/*show_gpsdata(dgps);*/

Modified: trunk/apps/s3dosm/main.c
===================================================================
--- trunk/apps/s3dosm/main.c	2007-09-22 16:52:22 UTC (rev 675)
+++ trunk/apps/s3dosm/main.c	2007-09-22 17:54:11 UTC (rev 676)
@@ -39,17 +39,7 @@
 		gps_main();
 		nav_main();
 		s3dw_ani_mate();
-	} /* else {
-  s3d_net_check(); / * we are not yet in the mainloop of
-       s3d_mainloop(), because ready==0,
-       so we check protocol things ourselves.
-       This just prevents timing out from the server
-       because map loading takes so long, you shouldn't take
-       this as good example and write proper threaded or
-       timesliced loaders :) * /
-  s3d_process_stack();
- }
- s3dw_ani_mate();*/
+	}
 }
 int init(int argc, char **argv)
 {



From lazhur at mail.berlios.de  Sun Sep 23 23:55:51 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:55:51 +0200
Subject: [S3d-svn] r677 - trunk/libs3d
Message-ID: <200709232155.l8NLtpUP013003@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:55:51 +0200 (Sun, 23 Sep 2007)
New Revision: 677

Modified:
   trunk/libs3d/modelread.c
   trunk/libs3d/object_queue.c
   trunk/libs3d/s3dlib.h
   trunk/libs3d/shm_ringbuf.c
Log:
Fix -Wextra sign warnings in libs3d


Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2007-09-22 17:54:11 UTC (rev 676)
+++ trunk/libs3d/modelread.c	2007-09-23 21:55:51 UTC (rev 677)
@@ -124,7 +124,8 @@
 	G3DFace     *face;
 	GSList      *oitem, *oface;
 	struct material2texture *mat2tex;
-	int       j, k, material_count, texture_count, voff, obj_id;
+	unsigned int i, k;
+	int       j, material_count, texture_count, voff, obj_id;
 #define      PMAX 100
 	uint32_t     polybuf[PMAX * 4], npoly, oldflags;
 	float      normalbuf[PMAX * 9], texcoordbuf[PMAX * 6];
@@ -146,12 +147,12 @@
 			object = (G3DObject *)oitem->data;
 
 			/* push vertices */
-			for (j = 0; j < object->vertex_count; j++) {
+			for (i = 0; i < object->vertex_count; i++) {
 				/* 2. and 3. coord have to change places otherwise the object will be turned */
-				object->vertex_data[j * 3 + 0] =  object->vertex_data[j * 3 + 0];
-				swaph =         object->vertex_data[j * 3 + 2];
-				object->vertex_data[j * 3 + 2] = -object->vertex_data[j * 3 + 1];
-				object->vertex_data[j * 3 + 1] = swaph;
+				object->vertex_data[i * 3 + 0] =  object->vertex_data[i * 3 + 0];
+				swaph =         object->vertex_data[i * 3 + 2];
+				object->vertex_data[i * 3 + 2] = -object->vertex_data[i * 3 + 1];
+				object->vertex_data[i * 3 + 1] = swaph;
 			}
 			s3d_push_vertices(obj_id, object->vertex_data, object->vertex_count);
 

Modified: trunk/libs3d/object_queue.c
===================================================================
--- trunk/libs3d/object_queue.c	2007-09-22 17:54:11 UTC (rev 676)
+++ trunk/libs3d/object_queue.c	2007-09-23 21:55:51 UTC (rev 677)
@@ -39,7 +39,7 @@
 /*  access when needed. this also makes things more asynchronous, */
 /*  therefore faster (I hope). */
 
-#define Q_UNUSED -1      /*  unused slot magic number */
+#define Q_UNUSED ((unsigned int)~0)      /*  unused slot magic number */
 #define MAX_REQ  100      /*  don't request more than that. */
 static unsigned int *queue;     /*  the object id's */
 static int queue_size = 0;   /*  the size of the object queue */

Modified: trunk/libs3d/s3dlib.h
===================================================================
--- trunk/libs3d/s3dlib.h	2007-09-22 17:54:11 UTC (rev 676)
+++ trunk/libs3d/s3dlib.h	2007-09-23 21:55:51 UTC (rev 677)
@@ -120,8 +120,8 @@
 struct buf_t {
 	uint32_t start, end, bufsize; /* start/end of the data */
 };
-int shm_write(struct buf_t *rb, char *buf, int n);
-int shm_read(struct buf_t *rb, char *buf, int n);
+unsigned int shm_write(struct buf_t *rb, char *buf, unsigned int n);
+unsigned int shm_read(struct buf_t *rb, char *buf, unsigned int n);
 /* shm.c */
 int _shm_init(char *ftoken);
 int _shm_quit();

Modified: trunk/libs3d/shm_ringbuf.c
===================================================================
--- trunk/libs3d/shm_ringbuf.c	2007-09-22 17:54:11 UTC (rev 676)
+++ trunk/libs3d/shm_ringbuf.c	2007-09-23 21:55:51 UTC (rev 677)
@@ -27,9 +27,9 @@
 #include <stdint.h> /* uint32_t */
 #include <string.h> /* memcpy() */
 #ifdef SHM
-int shm_write(struct buf_t *rb, char *buf, int n)
+unsigned int shm_write(struct buf_t *rb, char *buf, unsigned int n)
 {
-	int wrap = 0;
+	unsigned int wrap = 0;
 	int rs;
 	uint32_t e, s, size;
 	char *data;
@@ -72,11 +72,11 @@
 	if (rb->end >= rb->bufsize) rb->end -= rb->bufsize;
 	return(n);
 }
-int shm_read(struct buf_t *rb, char *buf, int n)
+unsigned int shm_read(struct buf_t *rb, char *buf, unsigned int n)
 {
 	int wrap = 0;
-	int mn = n;
-	int rs;
+	unsigned int mn = n;
+	unsigned int rs;
 	uint32_t e, s, size;
 	char *data;
 



From lazhur at mail.berlios.de  Sun Sep 23 23:55:59 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:55:59 +0200
Subject: [S3d-svn] r678 - trunk/apps/dot_mcp
Message-ID: <200709232155.l8NLtx2m013041@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:55:58 +0200 (Sun, 23 Sep 2007)
New Revision: 678

Modified:
   trunk/apps/dot_mcp/main.c
   trunk/apps/dot_mcp/menu.c
Log:
Fix -Wextra sign warnings in dot_mcp by adapting libs3d api changes


Modified: trunk/apps/dot_mcp/main.c
===================================================================
--- trunk/apps/dot_mcp/main.c	2007-09-23 21:55:51 UTC (rev 677)
+++ trunk/apps/dot_mcp/main.c	2007-09-23 21:55:58 UTC (rev 678)
@@ -44,7 +44,7 @@
 float xdif = 0, ydif = 0;
 
 struct app {
-	unsigned int oid, oid_c;
+	int oid, oid_c;
 	float r;
 	int init;
 	float trans_x, trans_y, trans_z;
@@ -65,7 +65,7 @@
 struct app *focus = NULL;
 float focus_r = 0;
 float alpha = 0;
-unsigned int min_but, rotate, close_but, sphere, reset, menu = -1;
+int rotate, reset, min_but, close_but, sphere, menu = -1;
 
 void place_apps();
 
@@ -349,8 +349,9 @@
 int object_click(struct s3d_evt *hrmz)
 {
 	struct app *a;
-	unsigned int i, oid;
-	oid = *((unsigned int *)hrmz->buf);
+	unsigned int i;
+	int oid;
+	oid = *((int *)hrmz->buf);
 	a = apps;
 	i = 0;
 	if (oid == rotate) {

Modified: trunk/apps/dot_mcp/menu.c
===================================================================
--- trunk/apps/dot_mcp/menu.c	2007-09-23 21:55:51 UTC (rev 677)
+++ trunk/apps/dot_mcp/menu.c	2007-09-23 21:55:58 UTC (rev 678)
@@ -76,7 +76,8 @@
 }
 int menu_init()
 {
-	int i, menu_o;
+	unsigned int i;
+	int menu_o;
 	menu_o = s3d_new_object();
 	act = 0; /* menu deactived */
 	go = s3d_import_model_file("objs/s3dstart.3ds");



From lazhur at mail.berlios.de  Sun Sep 23 23:56:06 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:56:06 +0200
Subject: [S3d-svn] r679 - trunk/apps/kism3d
Message-ID: <200709232156.l8NLu64M013085@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:56:05 +0200 (Sun, 23 Sep 2007)
New Revision: 679

Modified:
   trunk/apps/kism3d/gui.c
Log:
Fix -Wextra sign warnings in kisms3d


Modified: trunk/apps/kism3d/gui.c
===================================================================
--- trunk/apps/kism3d/gui.c	2007-09-23 21:55:58 UTC (rev 678)
+++ trunk/apps/kism3d/gui.c	2007-09-23 21:56:05 UTC (rev 679)
@@ -37,7 +37,7 @@
 float CamPosition[2][3];          /* CamPosition[trans|rot][x-z] */
 
 int Last_Click_Oid = 0;
-int Last_Click_Time = 0;
+unsigned int Last_Click_Time = 0;
 
 void *Cam_target = NULL;
 



From lazhur at mail.berlios.de  Sun Sep 23 23:56:13 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:56:13 +0200
Subject: [S3d-svn] r680 - trunk/apps/olsrs3d
Message-ID: <200709232156.l8NLuDIm013144@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:56:12 +0200 (Sun, 23 Sep 2007)
New Revision: 680

Modified:
   trunk/apps/olsrs3d/main.c
Log:
Fix -Wextra sign warnings in olsrs3d


Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2007-09-23 21:56:05 UTC (rev 679)
+++ trunk/apps/olsrs3d/main.c	2007-09-23 21:56:12 UTC (rev 680)
@@ -88,7 +88,7 @@
 int Btn_close_id = -1;
 
 int Btn_close_obj;
-int Last_Click_Time = 0;
+unsigned int Last_Click_Time = 0;
 int Last_Click_Oid = 0;
 float Title_len;
 



From lazhur at mail.berlios.de  Sun Sep 23 23:56:20 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:56:20 +0200
Subject: [S3d-svn] r681 - trunk/apps/s3dfm
Message-ID: <200709232156.l8NLuKnd013181@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:56:19 +0200 (Sun, 23 Sep 2007)
New Revision: 681

Modified:
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/string.c
Log:
Fix -Wextra sign warnings in s3dfm


Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2007-09-23 21:56:12 UTC (rev 680)
+++ trunk/apps/s3dfm/dialog.c	2007-09-23 21:56:19 UTC (rev 681)
@@ -171,7 +171,8 @@
 	s3dw_button  *okbutton, *abortbutton;
 	float l;
 
-	int i, m;
+	int i;
+	unsigned int m;
 
 	if (fs_lock)  {
 		window_fs_another();
@@ -221,7 +222,8 @@
 	s3dw_button  *okbutton, *abortbutton;
 	float l;
 
-	int i, m;
+	int i;
+	unsigned int m;
 
 	if (fs_lock)  {
 		window_fs_another();

Modified: trunk/apps/s3dfm/string.c
===================================================================
--- trunk/apps/s3dfm/string.c	2007-09-23 21:56:12 UTC (rev 680)
+++ trunk/apps/s3dfm/string.c	2007-09-23 21:56:19 UTC (rev 681)
@@ -58,7 +58,7 @@
 void dotted_int(char *s, unsigned int i)
 {
 	char st[M_DIR];
-	int p;
+	unsigned int p;
 	p = 0;
 	st[0] = 0;
 	while (i > 0) {



From lazhur at mail.berlios.de  Sun Sep 23 23:56:33 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:56:33 +0200
Subject: [S3d-svn] r682 - trunk/apps/s3dvt
Message-ID: <200709232156.l8NLuXuW013246@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:56:32 +0200 (Sun, 23 Sep 2007)
New Revision: 682

Modified:
   trunk/apps/s3dvt/main.c
Log:
Fix -Wextra sign warnings in s3dvt by adapting libs3d api changes


Modified: trunk/apps/s3dvt/main.c
===================================================================
--- trunk/apps/s3dvt/main.c	2007-09-23 21:56:19 UTC (rev 681)
+++ trunk/apps/s3dvt/main.c	2007-09-23 21:56:32 UTC (rev 682)
@@ -57,7 +57,7 @@
 
 #ifdef M_CHAR
 static unsigned int charbuf[256];
-static unsigned int screenbuf[MAX_LINES*MAX_CHARS];
+static int screenbuf[MAX_LINES*MAX_CHARS];
 static char   last_c[MAX_LINES*MAX_CHARS];
 #endif
 



From lazhur at mail.berlios.de  Sun Sep 23 23:56:40 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:56:40 +0200
Subject: [S3d-svn] r683 - trunk/apps/s3dosm
Message-ID: <200709232156.l8NLueIe013278@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:56:40 +0200 (Sun, 23 Sep 2007)
New Revision: 683

Modified:
   trunk/apps/s3dosm/io.c
Log:
Fix -Wextra sign warnings in s3dosm


Modified: trunk/apps/s3dosm/io.c
===================================================================
--- trunk/apps/s3dosm/io.c	2007-09-23 21:56:32 UTC (rev 682)
+++ trunk/apps/s3dosm/io.c	2007-09-23 21:56:40 UTC (rev 683)
@@ -98,11 +98,11 @@
 		}
 	}
 	for (i = 1;i < argc;i++) {
-		if (strstr(argv[i], ".osm") - argv[i] == strlen(argv[i]) - 4) {
+		if (strstr(argv[i], ".osm") - argv[i] == (signed)(strlen(argv[i]) - 4)) {
 			snprintf(info, 1024, "loading OSM-File: %s", argv[i]);
 			load_window(info);
 			layerset_add(load_osm_file(argv[i]));
-		} else if (strstr(argv[i], ".xml") - argv[i] == strlen(argv[i]) - 4) { /* might be osm or kismet xml */
+		} else if (strstr(argv[i], ".xml") - argv[i] == (signed)(strlen(argv[i]) - 4)) { /* might be osm or kismet xml */
 			char *file;
 			int fsize;
 			if (NULL == (file = read_file(argv[i], &fsize)))



From lazhur at mail.berlios.de  Sun Sep 23 23:57:02 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:57:02 +0200
Subject: [S3d-svn] r684 - trunk/apps/s3d_x11gate
Message-ID: <200709232157.l8NLv2Dm013363@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:57:02 +0200 (Sun, 23 Sep 2007)
New Revision: 684

Modified:
   trunk/apps/s3d_x11gate/s3d_x11gate.c
Log:
Fix -Wextra sign warnings in s3d_x11gate


Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-23 21:56:40 UTC (rev 683)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-23 21:57:02 UTC (rev 684)
@@ -35,10 +35,6 @@
 #include <sys/time.h>  /* gettimeofday */
 #include <sys/ipc.h>
 #include <sys/shm.h>
-static struct timespec t = {
-	0, 100*1000*1000
-}; /* 100 mili seconds */
-
 int oid;
 XImage *image;
 Display *dpy = 0;
@@ -67,12 +63,13 @@
 }
 void mainloop()
 {
-	int x, y;
+#define MAGIC_CHANGED ((unsigned int)~0)
+	unsigned int x, y;
 	int rs, gs, bs;
 	unsigned long d;
 	int bpp;
 	char *swap_timg;
-	int last_change, start_change;
+	unsigned int last_change, start_change;
 	gettimeofday(&end, NULL);
 	count[0] += (end.tv_sec - start.tv_sec) * 10000000 + end.tv_usec - start.tv_usec;
 	start.tv_sec = end.tv_sec;
@@ -101,8 +98,8 @@
 		  printf("green: size %d, offset %d\n",gs,goff);
 		  printf("blue: size %d, offset %d\n",bs,boff);
 		  printf("bits per pixel:%d\n",bpp);*/
-		last_change = -1;
-		start_change = -1;
+		last_change = MAGIC_CHANGED;
+		start_change = MAGIC_CHANGED;
 		for (y = 0;y < height;y++) {
 
 			for (x = 0;x < width;x++) {
@@ -116,20 +113,20 @@
 				                ((unsigned long *)otex_image)[(y*width+x)])
 					last_change = y;
 			}
-			if (last_change != -1) {
-				if (start_change == -1) {
+			if (last_change != MAGIC_CHANGED) {
+				if (start_change == MAGIC_CHANGED) {
 					start_change = y;
 					/*      printf("setting start_change to %d\n",start_change); */
 				}
 				if (last_change != y) {  /*  last change is already over, post it! */
 					s3d_load_texture(oid, 0, 0, start_change, width, last_change - start_change + 1, (unsigned char *)tex_image + start_change*width*4);
-					start_change = -1;
-					last_change = -1;
+					start_change = MAGIC_CHANGED;
+					last_change = MAGIC_CHANGED;
 				}
 			}
 		}
 		/*  posting the last bit, maybe */
-		if (last_change != -1) {
+		if (last_change != MAGIC_CHANGED) {
 			/*   printf("last one: [%d-%d]",start_change,last_change);*/
 			s3d_load_texture(oid, 0, 0, start_change, width, last_change - start_change, (unsigned char *)tex_image + start_change*width*4);
 		}



From lazhur at mail.berlios.de  Sun Sep 23 23:57:25 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:57:25 +0200
Subject: [S3d-svn] r685 - trunk/apps/s3d_x11gate
Message-ID: <200709232157.l8NLvPOm013443@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:57:24 +0200 (Sun, 23 Sep 2007)
New Revision: 685

Modified:
   trunk/apps/s3d_x11gate/s3d_x11gate.c
Log:
Fix segfaults of s3d_x11gate on amd64


Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-23 21:57:02 UTC (rev 684)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-23 21:57:24 UTC (rev 685)
@@ -52,7 +52,7 @@
 int iterations;
 float count[3];
 
-int get_shift(unsigned long t)
+int get_shift(uint32_t t)
 {
 	int i = 0;
 	while (t) {
@@ -66,7 +66,7 @@
 #define MAGIC_CHANGED ((unsigned int)~0)
 	unsigned int x, y;
 	int rs, gs, bs;
-	unsigned long d;
+	uint32_t d;
 	int bpp;
 	char *swap_timg;
 	unsigned int last_change, start_change;
@@ -103,14 +103,14 @@
 		for (y = 0;y < height;y++) {
 
 			for (x = 0;x < width;x++) {
-				d = *((unsigned long *)(image->data + (y * width + x) * bpp));
-				((unsigned long *)tex_image)[(y*width+x)] =
+				d = *((uint32_t *)(image->data + (y * width + x) * bpp));
+				((uint32_t *)tex_image)[(y*width+x)] =
 				        (rs > 0 ? ((d & image->red_mask) >> rs) : ((d & image->red_mask) << -rs)) |
 				        (gs > 0 ? ((d & image->green_mask) >> gs) : ((d & image->green_mask) << -gs)) |
 				        (bs > 0 ? ((d & image->blue_mask) >> bs) : ((d & image->blue_mask) << -bs)) |
 				        255 << 24;
-				if (((unsigned long *)tex_image)[(y*width+x)] !=
-				                ((unsigned long *)otex_image)[(y*width+x)])
+				if (((uint32_t *)tex_image)[(y*width+x)] !=
+				                ((uint32_t *)otex_image)[(y*width+x)])
 					last_change = y;
 			}
 			if (last_change != MAGIC_CHANGED) {
@@ -119,7 +119,7 @@
 					/*      printf("setting start_change to %d\n",start_change); */
 				}
 				if (last_change != y) {  /*  last change is already over, post it! */
-					s3d_load_texture(oid, 0, 0, start_change, width, last_change - start_change + 1, (unsigned char *)tex_image + start_change*width*4);
+					s3d_load_texture(oid, 0, 0, start_change, width, last_change - start_change + 1, (unsigned char *)tex_image + start_change*width * sizeof(uint32_t));
 					start_change = MAGIC_CHANGED;
 					last_change = MAGIC_CHANGED;
 				}
@@ -128,7 +128,7 @@
 		/*  posting the last bit, maybe */
 		if (last_change != MAGIC_CHANGED) {
 			/*   printf("last one: [%d-%d]",start_change,last_change);*/
-			s3d_load_texture(oid, 0, 0, start_change, width, last_change - start_change, (unsigned char *)tex_image + start_change*width*4);
+			s3d_load_texture(oid, 0, 0, start_change, width, last_change - start_change, (unsigned char *)tex_image + start_change*width * sizeof(uint32_t));
 		}
 		/*   s3d_load_texture(oid,0,0,0,width,height,tex_image); */
 		/*  swap images */
@@ -220,8 +220,8 @@
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK, mouseclick);
 		s3d_set_callback(S3D_EVENT_KEY, keypress);
 		printf("screen: %dx%d\n", width, height);
-		img1 = malloc(width * height * 4);
-		img2 = malloc(width * height * 4);
+		img1 = malloc(width * height * sizeof(uint32_t));
+		img2 = malloc(width * height * sizeof(uint32_t));
 		tex_image = img1;
 		otex_image = img2;
 		oid = s3d_new_object();



From lazhur at mail.berlios.de  Sun Sep 23 23:57:39 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:57:39 +0200
Subject: [S3d-svn] r686 - trunk/apps/s3dosm
Message-ID: <200709232157.l8NLvddW013481@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:57:37 +0200 (Sun, 23 Sep 2007)
New Revision: 686

Modified:
   trunk/apps/s3dosm/db.c
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/s3dosm.h
   trunk/apps/s3dosm/ui.c
Log:
Mark unused parameter in s3dosm as S3DOSMUNUSED to fix warnings


Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2007-09-23 21:57:24 UTC (rev 685)
+++ trunk/apps/s3dosm/db.c	2007-09-23 21:57:37 UTC (rev 686)
@@ -194,7 +194,7 @@
 }
 
 /* sqlite3-callback to get an integer of the database */
-int db_getint(void *tagid, int argc, char **argv, char **azColName)
+int db_getint(void *tagid, int S3DOSMUNUSED(argc), char **argv, char **S3DOSMUNUSED(azColName))
 {
 	if (argv[0] != NULL)
 		*((int *)tagid) = atoi(argv[0]);
@@ -202,7 +202,7 @@
 }
 
 /* sqlite3-callback to get a string of the database */
-static int db_getstr(void *string, int argc, char **argv, char **azColName)
+static int db_getstr(void *string, int S3DOSMUNUSED(argc), char **argv, char **S3DOSMUNUSED(azColName))
 {
 	if (argv[0])
 		strncpy((char *)string, argv[0], MAXQ);
@@ -220,7 +220,7 @@
 	return(target[0] == 0);
 }
 
-int callback(void *NotUsed, int argc, char **argv, char **azColName)
+int callback(void *S3DOSMUNUSED(NotUsed), int argc, char **argv, char **azColName)
 {
 	int i;
 	for (i = 0; i < argc; i++) {

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2007-09-23 21:57:24 UTC (rev 685)
+++ trunk/apps/s3dosm/draw.c	2007-09-23 21:57:37 UTC (rev 686)
@@ -82,7 +82,7 @@
 	x[1] = (ESIZE + alt) *   sin(la);
 	x[2] = (ESIZE + alt) * cos(lo) * cos(la);
 }
-int draw_icon(void *data, int argc, char **argv, char **azColName)
+int draw_icon(void *S3DOSMUNUSED(data), int argc, char **argv, char **S3DOSMUNUSED(azColName))
 {
 	int i, tagid = -1, oid;
 	int nodeid = -1, layerid = -1;
@@ -142,7 +142,7 @@
 	}
 	return(0);
 }
-int select_waytype(void *data, int argc, char **argv, char **azColName)
+int select_waytype(void *data, int argc, char **argv, char **S3DOSMUNUSED(azColName))
 {
 	int i;
 	for (i = 0; i < argc; i++) {

Modified: trunk/apps/s3dosm/s3dosm.h
===================================================================
--- trunk/apps/s3dosm/s3dosm.h	2007-09-23 21:57:24 UTC (rev 685)
+++ trunk/apps/s3dosm/s3dosm.h	2007-09-23 21:57:37 UTC (rev 686)
@@ -7,6 +7,16 @@
 #define MAXQ 4096
 #define QBUF 1024*128
 
+#ifndef S3DOSMUNUSED
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define S3DOSMUNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define S3DOSMUNUSED(x) /* x */
+#else
+#define S3DOSMUNUSED(x) x
+#endif
+#endif
+
 /* stack it */
 /* #define DB_STACK 1*/
 

Modified: trunk/apps/s3dosm/ui.c
===================================================================
--- trunk/apps/s3dosm/ui.c	2007-09-23 21:57:24 UTC (rev 685)
+++ trunk/apps/s3dosm/ui.c	2007-09-23 21:57:37 UTC (rev 686)
@@ -51,7 +51,7 @@
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 }
 
-int ui_getinfo_node(void *data, int argc, char **argv, char **azColName)
+int ui_getinfo_node(void *S3DOSMUNUSED(data), int argc, char **argv, char **azColName)
 {
 	int i, tagid = -1;
 	char type[MAXQ];
@@ -79,7 +79,7 @@
 
 	return(0);
 }
-int ui_getinfo_way(void *data, int argc, char **argv, char **azColName)
+int ui_getinfo_way(void *S3DOSMUNUSED(data), int argc, char **argv, char **azColName)
 {
 	int i, tagid = -1;
 	char name[MAXQ];



From lazhur at mail.berlios.de  Sun Sep 23 23:57:48 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:57:48 +0200
Subject: [S3d-svn] r687 - trunk/apps/olsrs3d
Message-ID: <200709232157.l8NLvmXk013516@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:57:47 +0200 (Sun, 23 Sep 2007)
New Revision: 687

Modified:
   trunk/apps/olsrs3d/olsrs3d.h
   trunk/apps/olsrs3d/search.c
Log:
Mark unused parameter in olsrs3d as OLSRS3DUNUSED to fix warnings


Modified: trunk/apps/olsrs3d/olsrs3d.h
===================================================================
--- trunk/apps/olsrs3d/olsrs3d.h	2007-09-23 21:57:37 UTC (rev 686)
+++ trunk/apps/olsrs3d/olsrs3d.h	2007-09-23 21:57:47 UTC (rev 687)
@@ -24,13 +24,21 @@
  */
 
 #include "structs.h"
+#include <config-s3d.h>
 
-
 #define max(x,y)((x)>(y)?(x):(y))
 #define min(x,y)((x)<(y)?(x):(y))
 
+#ifndef OLSRS3DUNUSED
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define OLSRS3DUNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define OLSRS3DUNUSED(x) /* x */
+#else
+#define OLSRS3DUNUSED(x) x
+#endif
+#endif
 
-
 extern int Debug;
 
 extern struct olsr_con *Con_begin;   /* begin of connection list */

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2007-09-23 21:57:37 UTC (rev 686)
+++ trunk/apps/olsrs3d/search.c	2007-09-23 21:57:47 UTC (rev 687)
@@ -115,7 +115,7 @@
 }
 
 /* public */
-void create_search_widget(float x, float y, float z)
+void create_search_widget(float OLSRS3DUNUSED(x), float OLSRS3DUNUSED(y), float OLSRS3DUNUSED(z))
 {
 	s3dw_button *search_button, *abort_button;
 
@@ -348,7 +348,7 @@
 }
 
 /* private */
-void _search_node(s3dw_widget *dummy)
+void _search_node(s3dw_widget *OLSRS3DUNUSED(dummy))
 {
 	char *ip;
 	int result;
@@ -375,7 +375,7 @@
 }
 
 /* private */
-void _abort_search(s3dw_widget *dummy)
+void _abort_search(s3dw_widget *OLSRS3DUNUSED(dummy))
 {
 	set_search_status(ABORT);
 }



From lazhur at mail.berlios.de  Sun Sep 23 23:58:03 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:58:03 +0200
Subject: [S3d-svn] r689 - trunk/apps/s3dfm
Message-ID: <200709232158.l8NLw3Yo013597@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:58:02 +0200 (Sun, 23 Sep 2007)
New Revision: 689

Modified:
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/s3dfm.h
Log:
Mark unused parameter in s3dfm as S3DFMUNUSED to fix warnings


Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2007-09-23 21:57:54 UTC (rev 688)
+++ trunk/apps/s3dfm/dialog.c	2007-09-23 21:58:02 UTC (rev 689)
@@ -140,7 +140,7 @@
 	fs_lock = TYPE_NONE;
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 }
-void *thread_start(void *ptr)
+void *thread_start(void *S3DFMUNUSED(ptr))
 {
 	switch (fs_lock) {
 	case TYPE_COPY:
@@ -165,7 +165,7 @@
 	pthread_create(&filethread, NULL, thread_start, NULL);
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 }
-void window_copy(char *path)
+void window_copy(char *S3DFMUNUSED(path))
 {
 	s3dw_surface *infwin;
 	s3dw_button  *okbutton, *abortbutton;
@@ -309,7 +309,7 @@
 	s3dw_show(S3DWIDGET(infwin));
 }
 
-void window_move(char *path)
+void window_move(char *S3DFMUNUSED(path))
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2007-09-23 21:57:54 UTC (rev 688)
+++ trunk/apps/s3dfm/s3dfm.h	2007-09-23 21:58:02 UTC (rev 689)
@@ -25,6 +25,18 @@
 #include <s3d.h>
 #include <s3dw.h>
 #include <stdlib.h>  /* uintXX_t */
+#include <config-s3d.h>
+
+#ifndef S3DFMUNUSED
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define S3DFMUNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define S3DFMUNUSED(x) /* x */
+#else
+#define S3DFMUNUSED(x) x
+#endif
+#endif
+
 #define T_DUNO  0
 #define T_FOLDER 1
 #define T_TYPENUM 2



From lazhur at mail.berlios.de  Sun Sep 23 23:57:54 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:57:54 +0200
Subject: [S3d-svn] r688 - trunk/apps/kism3d
Message-ID: <200709232157.l8NLvsEG013556@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:57:54 +0200 (Sun, 23 Sep 2007)
New Revision: 688

Modified:
   trunk/apps/kism3d/gui.c
   trunk/apps/kism3d/kism3d.h
Log:
Mark unused parameter in kism3d as KISM3DUNUSED to fix warnings


Modified: trunk/apps/kism3d/gui.c
===================================================================
--- trunk/apps/kism3d/gui.c	2007-09-23 21:57:47 UTC (rev 687)
+++ trunk/apps/kism3d/gui.c	2007-09-23 21:57:54 UTC (rev 688)
@@ -423,7 +423,7 @@
 
 
 
-void* gui_main(void *unused)
+void* gui_main(void *KISM3DUNUSED(unused))
 {
 
 	if (!s3d_init(NULL, NULL, "kism3d")) {

Modified: trunk/apps/kism3d/kism3d.h
===================================================================
--- trunk/apps/kism3d/kism3d.h	2007-09-23 21:57:47 UTC (rev 687)
+++ trunk/apps/kism3d/kism3d.h	2007-09-23 21:57:54 UTC (rev 688)
@@ -26,9 +26,20 @@
 #include "list.h"
 #include <pthread.h>
 #include <netinet/in.h>   /* sockaddr_in */
+#include <config-s3d.h>
 
+#ifndef KISM3DUNUSED
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define KISM3DUNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define KISM3DUNUSED(x) /* x */
+#else
+#define KISM3DUNUSED(x) x
+#endif
+#endif
 
 
+
 #define NETWORK_TEXT_SCALE 0.2
 #define CLIENT_TEXT_SCALE 0.2
 



From lazhur at mail.berlios.de  Sun Sep 23 23:58:17 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:58:17 +0200
Subject: [S3d-svn] r691 - trunk/example
Message-ID: <200709232158.l8NLwHCR013703@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:58:16 +0200 (Sun, 23 Sep 2007)
New Revision: 691

Added:
   trunk/example/example.h
Modified:
   trunk/example/filebrowser.c
   trunk/example/linetest.c
   trunk/example/modelloader.c
   trunk/example/ptrtest.c
   trunk/example/s3dclock.c
   trunk/example/strtest.c
   trunk/example/widgets.c
   trunk/example/wiresphere.c
Log:
Mark unused parameter in example as S3DUNUSED to fix warnings


Added: trunk/example/example.h
===================================================================
--- trunk/example/example.h	2007-09-23 21:58:09 UTC (rev 690)
+++ trunk/example/example.h	2007-09-23 21:58:16 UTC (rev 691)
@@ -0,0 +1,39 @@
+/*
+ * examples.h
+ *
+ * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _EXAMPLES_H_
+#define _EXAMPLES_H_
+
+#include <config-s3d.h>
+
+#ifndef S3DUNUSED
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define S3DUNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define S3DUNUSED(x) /* x */
+#else
+#define S3DUNUSED(x) x
+#endif
+#endif
+
+#endif /* _EXAMPLES_H_ */

Modified: trunk/example/filebrowser.c
===================================================================
--- trunk/example/filebrowser.c	2007-09-23 21:58:09 UTC (rev 690)
+++ trunk/example/filebrowser.c	2007-09-23 21:58:16 UTC (rev 691)
@@ -32,6 +32,7 @@
 #include <unistd.h>  /*  chdir() */
 #include <math.h>  /*  sin(),cos() */
 #include <time.h> /* nanosleep() */
+#include "example.h" /* S3DUNUSED */
 static struct timespec t = {
 	0, 100*1000*1000
 }; /* 100 mili seconds */
@@ -54,7 +55,7 @@
 };
 struct t_item *item;
 int n_item = 0;
-int display_dir(char *dir, int depth, int  posx, int posy, int posz)
+int display_dir(char *dir, int S3DUNUSED(depth), int  posx, int posy, int posz)
 {
 	struct dirent **namelist;
 	int n, i;

Modified: trunk/example/linetest.c
===================================================================
--- trunk/example/linetest.c	2007-09-23 21:58:09 UTC (rev 690)
+++ trunk/example/linetest.c	2007-09-23 21:58:16 UTC (rev 691)
@@ -26,9 +26,10 @@
 #include <s3d.h>
 #include <stdio.h>  /*  NULL*/
 #include <unistd.h> /* sleep() */
+#include "example.h" /* S3DUNUSED */
 int i;
 int o;
-void stop(struct s3d_evt *evt)
+void stop(struct s3d_evt *S3DUNUSED(evt))
 {
 	s3d_quit();
 }

Modified: trunk/example/modelloader.c
===================================================================
--- trunk/example/modelloader.c	2007-09-23 21:58:09 UTC (rev 690)
+++ trunk/example/modelloader.c	2007-09-23 21:58:16 UTC (rev 691)
@@ -27,6 +27,7 @@
 #include <s3d.h>
 #include <stdio.h>  /* NULL */
 #include <time.h> /* nanosleep() */
+#include "example.h" /* S3DUNUSED */
 static struct timespec t = {
 	0, 100*1000*1000
 }; /* 100 mili seconds */
@@ -37,7 +38,7 @@
 	i = (i + 1) % 360;
 	nanosleep(&t, NULL);
 }
-int object_click(struct s3d_evt *evt)
+int object_click(struct s3d_evt *S3DUNUSED(evt))
 {
 	s3d_quit();
 	return(0);

Modified: trunk/example/ptrtest.c
===================================================================
--- trunk/example/ptrtest.c	2007-09-23 21:58:09 UTC (rev 690)
+++ trunk/example/ptrtest.c	2007-09-23 21:58:16 UTC (rev 691)
@@ -26,6 +26,7 @@
 #include <stdio.h>  /*  NULL*/
 #include <time.h> /* nanosleep() */
 #include <math.h> /* sin(), cos() */
+#include "example.h" /* S3DUNUSED */
 int i;
 int o;
 float bottom = -1.0;
@@ -36,7 +37,7 @@
 static struct timespec t = {
 	0, 10*1000*1000
 }; /* 100 mili seconds */
-int stop(struct s3d_evt *evt)
+int stop(struct s3d_evt *S3DUNUSED(evt))
 {
 	s3d_quit();
 	return(0);

Modified: trunk/example/s3dclock.c
===================================================================
--- trunk/example/s3dclock.c	2007-09-23 21:58:09 UTC (rev 690)
+++ trunk/example/s3dclock.c	2007-09-23 21:58:16 UTC (rev 691)
@@ -26,6 +26,7 @@
 #include <stdio.h>  /*  NULL, sprintf() */
 #include <time.h>  /*  nanosleep(), struct tm, time_t...  */
 #include <string.h>  /*  strlen() */
+#include "example.h" /* S3DUNUSED */
 static struct timespec t = {
 	0, 100*1000*1000
 }; /* 100 mili seconds */
@@ -35,7 +36,7 @@
 time_t now, onow;
 char time_str[256];
 
-void stop(struct s3d_evt *evt)
+void stop(struct s3d_evt *S3DUNUSED(evt))
 {
 	s3d_quit();
 }

Modified: trunk/example/strtest.c
===================================================================
--- trunk/example/strtest.c	2007-09-23 21:58:09 UTC (rev 690)
+++ trunk/example/strtest.c	2007-09-23 21:58:16 UTC (rev 691)
@@ -26,8 +26,9 @@
 #include <s3d.h>
 #include <stdio.h>  /*  NULL*/
 #include <unistd.h> /* sleep() */
+#include "example.h" /* S3DUNUSED */
 int o;
-void stop(struct s3d_evt *evt)
+void stop(struct s3d_evt *S3DUNUSED(evt))
 {
 	s3d_quit();
 }

Modified: trunk/example/widgets.c
===================================================================
--- trunk/example/widgets.c	2007-09-23 21:58:09 UTC (rev 690)
+++ trunk/example/widgets.c	2007-09-23 21:58:16 UTC (rev 691)
@@ -30,6 +30,7 @@
 #include <time.h> /* nanosleep() */
 #include <stdlib.h> /* free() */
 #include <string.h> /* strlen() */
+#include "example.h"
 
 s3dw_surface *surface;
 s3dw_input *input;
@@ -78,12 +79,12 @@
 
 }
 
-void done_button(s3dw_widget *dummy)
+void done_button(s3dw_widget *S3DUNUSED(dummy))
 {
 	s3d_quit();
 }
 
-void okay_button(s3dw_widget *dummy)
+void okay_button(s3dw_widget *S3DUNUSED(dummy))
 {
 	s3dw_button *button;
 	char string[32];
@@ -115,7 +116,7 @@
 	/* we don't need it anymore. always free strings, don't leak around */
 	free(age);
 }
-void no_button(s3dw_widget *dummy)
+void no_button(s3dw_widget *S3DUNUSED(dummy))
 {
 	s3dw_button *button;
 	s3dw_delete(S3DWIDGET(surface));

Modified: trunk/example/wiresphere.c
===================================================================
--- trunk/example/wiresphere.c	2007-09-23 21:58:09 UTC (rev 690)
+++ trunk/example/wiresphere.c	2007-09-23 21:58:16 UTC (rev 691)
@@ -27,6 +27,7 @@
 #include <time.h> /* nanosleep()  */
 #include <math.h> /* M_PI, cos(), sin() */
 #include <stdlib.h> /* malloc(), free() */
+#include "example.h" /* S3DUNUSED */
 static struct timespec t = {
 	0, 100*1000*1000
 }; /* 100 mili seconds */
@@ -98,7 +99,7 @@
 	free(l);
 	return(o);
 }
-void stop(struct s3d_evt *evt)
+void stop(struct s3d_evt *S3DUNUSED(evt))
 {
 	s3d_quit();
 }



From lazhur at mail.berlios.de  Sun Sep 23 23:58:10 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:58:10 +0200
Subject: [S3d-svn] r690 - trunk/apps/s3dvt
Message-ID: <200709232158.l8NLwAVF013662@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:58:09 +0200 (Sun, 23 Sep 2007)
New Revision: 690

Modified:
   trunk/apps/s3dvt/main.c
   trunk/apps/s3dvt/s3dvt.h
Log:
Mark unused parameter in s3dvt as S3DVTUNUSED to fix warnings


Modified: trunk/apps/s3dvt/main.c
===================================================================
--- trunk/apps/s3dvt/main.c	2007-09-23 21:58:02 UTC (rev 689)
+++ trunk/apps/s3dvt/main.c	2007-09-23 21:58:09 UTC (rev 690)
@@ -65,7 +65,7 @@
 static int    lines[MAX_LINES];
 #endif
 
-void *thread_terminal(void *a)
+void *thread_terminal(void *S3DVTUNUSED(a))
 {
 	int iscon = 1, ret;
 	char buffer[1024];
@@ -486,7 +486,7 @@
 		paintit();
 	}
 }
-int stop(struct s3d_evt *event)
+int stop(struct s3d_evt *S3DVTUNUSED(event))
 {
 	s3d_quit();
 	return(0);

Modified: trunk/apps/s3dvt/s3dvt.h
===================================================================
--- trunk/apps/s3dvt/s3dvt.h	2007-09-23 21:58:02 UTC (rev 689)
+++ trunk/apps/s3dvt/s3dvt.h	2007-09-23 21:58:09 UTC (rev 690)
@@ -22,6 +22,18 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
+#include <config-s3d.h>
+
+#ifndef S3DVTUNUSED
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define S3DVTUNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define S3DVTUNUSED(x) /* x */
+#else
+#define S3DVTUNUSED(x) x
+#endif
+#endif
+
 #define MAX_LINES 50
 #define MAX_CHARS 80
 #define DEFAULT_FGCOLOR 2



From lazhur at mail.berlios.de  Sun Sep 23 23:58:25 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:58:25 +0200
Subject: [S3d-svn] r692 - trunk/apps/s3d_x11gate
Message-ID: <200709232158.l8NLwPRB013760@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:58:25 +0200 (Sun, 23 Sep 2007)
New Revision: 692

Modified:
   trunk/apps/s3d_x11gate/s3d_x11gate.c
Log:
Mark unused parameter in s3d_x11gate as S3DX11UNUSED to fix warnings


Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-23 21:58:16 UTC (rev 691)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2007-09-23 21:58:25 UTC (rev 692)
@@ -35,6 +35,18 @@
 #include <sys/time.h>  /* gettimeofday */
 #include <sys/ipc.h>
 #include <sys/shm.h>
+#include <config-s3d.h>
+
+#ifndef S3DX11UNUSED
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define S3DX11UNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define S3DX11UNUSED(x) /* x */
+#else
+#define S3DX11UNUSED(x) x
+#endif
+#endif
+
 int oid;
 XImage *image;
 Display *dpy = 0;
@@ -168,7 +180,7 @@
 	return(0);
 
 }
-int mouseclick(struct s3d_evt *event)
+int mouseclick(struct s3d_evt *S3DX11UNUSED(event))
 {
 	int i;
 	printf("thats it, collecting:\n");



From lazhur at mail.berlios.de  Sun Sep 23 23:58:38 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 23 Sep 2007 23:58:38 +0200
Subject: [S3d-svn] r693 - in trunk: . apps/kism3d apps/s3d_x11gate
	apps/s3dfm apps/s3dosm apps/s3dvt cmake/modules
Message-ID: <200709232158.l8NLwc5J013820@sheep.berlios.de>

Author: lazhur
Date: 2007-09-23 23:58:37 +0200 (Sun, 23 Sep 2007)
New Revision: 693

Added:
   trunk/cmake/modules/LateStatus.cmake
Modified:
   trunk/ConfigureChecks.cmake
   trunk/apps/kism3d/CMakeLists.txt
   trunk/apps/s3d_x11gate/CMakeLists.txt
   trunk/apps/s3dfm/CMakeLists.txt
   trunk/apps/s3dosm/CMakeLists.txt
   trunk/apps/s3dvt/CMakeLists.txt
Log:
Print all missing packages after configure for optional modules


Modified: trunk/ConfigureChecks.cmake
===================================================================
--- trunk/ConfigureChecks.cmake	2007-09-23 21:58:25 UTC (rev 692)
+++ trunk/ConfigureChecks.cmake	2007-09-23 21:58:37 UTC (rev 693)
@@ -1,4 +1,5 @@
 include(LateErrors)
+include(LateStatus)
 
 # find required lib and add include dir for FREETYPE
 find_package(FREETYPE)

Modified: trunk/apps/kism3d/CMakeLists.txt
===================================================================
--- trunk/apps/kism3d/CMakeLists.txt	2007-09-23 21:58:25 UTC (rev 692)
+++ trunk/apps/kism3d/CMakeLists.txt	2007-09-23 21:58:37 UTC (rev 693)
@@ -8,4 +8,9 @@
 
 	# install 
 	install(TARGETS kism3d RUNTIME DESTINATION bin)
+else (PTHREADS_FOUND)
+	PkgStatus_Later("pthreads")
+	
+	# print late status
+	Collected_PkgStatus("kism3d")
 endif (PTHREADS_FOUND)

Modified: trunk/apps/s3d_x11gate/CMakeLists.txt
===================================================================
--- trunk/apps/s3d_x11gate/CMakeLists.txt	2007-09-23 21:58:25 UTC (rev 692)
+++ trunk/apps/s3d_x11gate/CMakeLists.txt	2007-09-23 21:58:37 UTC (rev 693)
@@ -8,4 +8,9 @@
 
 	# install
 	install(TARGETS s3d_x11gate RUNTIME DESTINATION bin)
+else (XTST_FOUND)
+	PkgStatus_Later("xtst (pkg name: libxtst-dev)")
+	
+	# print late status
+	Collected_PkgStatus("s3d_x11gate")
 endif (XTST_FOUND)

Modified: trunk/apps/s3dfm/CMakeLists.txt
===================================================================
--- trunk/apps/s3dfm/CMakeLists.txt	2007-09-23 21:58:25 UTC (rev 692)
+++ trunk/apps/s3dfm/CMakeLists.txt	2007-09-23 21:58:37 UTC (rev 693)
@@ -9,4 +9,9 @@
 
 	# install 
 	install(TARGETS s3dfm RUNTIME DESTINATION bin)
+else (PTHREADS_FOUND)
+	PkgStatus_Later("pthreads")
+	
+	# print late status
+	Collected_PkgStatus("s3dfm")
 endif (PTHREADS_FOUND)

Modified: trunk/apps/s3dosm/CMakeLists.txt
===================================================================
--- trunk/apps/s3dosm/CMakeLists.txt	2007-09-23 21:58:25 UTC (rev 692)
+++ trunk/apps/s3dosm/CMakeLists.txt	2007-09-23 21:58:37 UTC (rev 693)
@@ -16,4 +16,15 @@
 
 	# install 
 	install(TARGETS s3dosm RUNTIME DESTINATION bin)
+else (LIBXML2_FOUND AND SQLITE3_FOUND)
+	if (NOT LIBXML2_FOUND)
+		PkgStatus_Later("libxml2 (pkg name: libxml2-dev)")
+	endif (NOT LIBXML2_FOUND)
+	
+	if (NOT SQLITE3_FOUND)
+		PkgStatus_Later("SQLite3 (pkg name: libsqlite3-dev)")
+	endif (NOT SQLITE3_FOUND)
+	
+	# print late status
+	Collected_PkgStatus("s3dosm")
 endif (LIBXML2_FOUND AND SQLITE3_FOUND)

Modified: trunk/apps/s3dvt/CMakeLists.txt
===================================================================
--- trunk/apps/s3dvt/CMakeLists.txt	2007-09-23 21:58:25 UTC (rev 692)
+++ trunk/apps/s3dvt/CMakeLists.txt	2007-09-23 21:58:37 UTC (rev 693)
@@ -8,4 +8,9 @@
 
 	# install
 	install(TARGETS s3dvt RUNTIME DESTINATION bin)
+else (PTHREADS_FOUND)
+	PkgStatus_Later("pthreads")
+	
+	# print late status
+	Collected_PkgStatus("s3dvt")
 endif (PTHREADS_FOUND)

Added: trunk/cmake/modules/LateStatus.cmake
===================================================================
--- trunk/cmake/modules/LateStatus.cmake	2007-09-23 21:58:25 UTC (rev 692)
+++ trunk/cmake/modules/LateStatus.cmake	2007-09-23 21:58:37 UTC (rev 693)
@@ -0,0 +1,15 @@
+# Defines the following macros:
+#
+# PkgStatus_Later(errmsg)
+# Collected_PkgStatus(modulename)
+
+macro(PkgStatus_Later _errmsg)
+	set(pgk_status "${pgk_status}\n\t${_errmsg}")
+endmacro(PkgStatus_Later _errmsg)
+
+macro(Collected_PkgStatus _modulename)
+	if (pgk_status)
+		message(STATUS "${_modulename} will not be build because of missing packages: ${pgk_status}\n\t"
+			"The exact names can differ depending on the distribution.")
+	endif (pgk_status)
+endmacro(Collected_PkgStatus _modulename)



From dotslash at mail.berlios.de  Mon Sep 24 00:26:12 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 24 Sep 2007 00:26:12 +0200
Subject: [S3d-svn] r694 - in trunk: . libs3d
Message-ID: <200709232226.l8NMQCEH016834@sheep.berlios.de>

Author: dotslash
Date: 2007-09-24 00:26:12 +0200 (Mon, 24 Sep 2007)
New Revision: 694

Modified:
   trunk/
   trunk/libs3d/shm.c
Log:
 r2424 at kero:  dotslash | 2007-09-23 21:30:51 +0200
 - reactivate grace timeout for shared memory, don't just loop



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2408
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2424

Modified: trunk/libs3d/shm.c
===================================================================
--- trunk/libs3d/shm.c	2007-09-23 21:58:37 UTC (rev 693)
+++ trunk/libs3d/shm.c	2007-09-23 22:26:12 UTC (rev 694)
@@ -140,8 +140,8 @@
 			s3dprintf(HIGH, "shm_writen():waited too long ...");
 			return(-1);
 		}
-		/*  if (wait>10)
-		   nanosleep(&t,NULL); */
+		if (wait>10)
+		   nanosleep(&t,NULL); 
 	}
 	return(s - no_left);
 }
@@ -161,8 +161,8 @@
 			s3dprintf(HIGH, "shm_readn():waited too long ...");
 			return(-1);
 		}
-		/*  if (wait>10)
-		   nanosleep(&t,NULL); */
+		if (wait>10)
+		   nanosleep(&t,NULL); 
 	}
 	return(s - no_left);
 }



From dotslash at mail.berlios.de  Mon Sep 24 00:26:28 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 24 Sep 2007 00:26:28 +0200
Subject: [S3d-svn] r695 - in trunk: . example server
Message-ID: <200709232226.l8NMQS2i016953@sheep.berlios.de>

Author: dotslash
Date: 2007-09-24 00:26:27 +0200 (Mon, 24 Sep 2007)
New Revision: 695

Modified:
   trunk/
   trunk/example/texturetest.c
   trunk/server/global.h
   trunk/server/graphics.c
   trunk/server/object.c
   trunk/server/proto.c
Log:
 r2451 at kero:  dotslash | 2007-09-24 00:23:38 +0200
 - linear filtering beautifies our textures 
 - add (non-functional) mipmapping support
 - decrease texturetest texture size for mipmap testing/debugging



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2424
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2451

Modified: trunk/example/texturetest.c
===================================================================
--- trunk/example/texturetest.c	2007-09-23 22:26:12 UTC (rev 694)
+++ trunk/example/texturetest.c	2007-09-23 22:26:27 UTC (rev 695)
@@ -37,8 +37,8 @@
 	s3d_rotate(oid, 0, i, 0);
 	nanosleep(&t, NULL);
 }
-#define MAXX 300
-#define MAXY 300
+#define MAXX 32
+#define MAXY 32
 int main(int argc, char **argv)
 {
 	unsigned int x, y;
@@ -63,7 +63,7 @@
 		s3d_pep_polygon_tex_coord(oid, 0.0, 0.0,
 		                          1.0, 1.0,
 		                          0.0, 1.0);
-		s3d_translate(oid, 0, 0, 5);
+		s3d_translate(oid, 0, 0, -5);
 		for (y = 0;y < MAXY;y++)
 			for (x = 0;x < MAXX;x++) {
 				data[(y*MAXX+x)*4+0] = (char)((x * 255) / MAXX);

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2007-09-23 22:26:12 UTC (rev 694)
+++ trunk/server/global.h	2007-09-23 22:26:27 UTC (rev 695)
@@ -47,8 +47,8 @@
 #endif
 #define NAME_MAX 256   /*  limit for names [e.g. process names] */
 #define MCP   0   /*  the mcp's pid  */
-#define TEXTURE_MAX_W 2048
-#define TEXTURE_MAX_H 2048
+#define TEXTURE_MAX_W 4096
+#define TEXTURE_MAX_H 4096
 /*  server version */
 #define S3D_SERVER_MAJOR 0
 #define S3D_SERVER_MINOR 1

Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2007-09-23 22:26:12 UTC (rev 694)
+++ trunk/server/graphics.c	2007-09-23 22:26:27 UTC (rev 695)
@@ -73,6 +73,7 @@
 	/*     glDepthFunc( GL_LEQUAL ); */
 
 	/* textures */
+	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
 	glEnable(GL_TEXTURE_2D);
 	glShadeModel(GL_SMOOTH);
 	glDisable(GL_DITHER);

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-09-23 22:26:12 UTC (rev 694)
+++ trunk/server/object.c	2007-09-23 22:26:27 UTC (rev 695)
@@ -1445,8 +1445,45 @@
 
 }
 
+void tex_build_mipmaps(struct t_tex *tex) 
+{
+	int 			 i, w, h, x, y, c;
+	unsigned char 	*buf, *src;
+	w = tex->w;
+	h = tex->h;
+	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
+	             tex->w, tex->h, 0,  /*  no border. */
+	             GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);
+	/* this is fairly hacky, but we only use one buffer and decrease the image left-top to right-bottom,
+	 * so we only read from elements AFTER the updated (written) elements. */
+	buf = malloc( (w / 2) * (h /2 ) * 4);
+	src = tex->buf;
+	for (i = 1 ; i < 4 ; i++) {
+		w /= 2;
+		h /= 2;
+
+		if ((w == 0) || (h == 0)) break;
+		/* TODO: handle texture borders which have not even width or height */
+		for (y = 0; y < h; y++)
+			for (x = 0; x < w; x++) 
+				for (c = 0; c < 4; c++) {
+					buf[(y * w + x)*4 + c] = ((uint16_t) 
+											  src[( 2 * y      * w + 2 * x    )*4 + c] + 
+											  src[((2 * y + 1) * w + 2 * x    )*4 + c] + 
+											  src[( 2 * y      * w + 2 * x + 1)*4 + c] + 
+											  src[((2 * y + 1) * w + 2 * x + 1)*4 + c]) / 4;
+/*					s3dprintf(MED,"texture: %d, x = %d, y = %d, c = %d, buf = %02x\n", i, x, y, c, buf[(y * w + x)*4 + c]);*/
+
+				}
+		glTexImage2D(GL_TEXTURE_2D, i, GL_RGBA, w, h, 0,   GL_RGBA, GL_UNSIGNED_BYTE, buf);
+		src = buf;
+	}
+	free(buf);
+}
+
 /* activate/bind texture for object */
-static struct t_tex *get_texture(struct t_obj *obj, struct t_mat *m) {
+struct t_tex *get_texture(struct t_obj *obj, struct t_mat *m) {
 	GLuint t;
 	struct t_tex *tex = NULL;
 	GLfloat matgl[4];
@@ -1454,9 +1491,9 @@
 	if (m->tex < obj->n_tex) {
 		tex = &obj->p_tex[m->tex];
 		if (tex->buf != NULL) { /*  texture seems to be okay, select it. */
-			matgl[0] = 0.5f;
-			matgl[1] = 0.5f;
-			matgl[2] = 0.5f;
+			matgl[0] = 0.9f;
+			matgl[1] = 0.9f;
+			matgl[2] = 0.9f;
 			matgl[3] = 1.0f;
 			glMaterialfv(GL_FRONT, GL_AMBIENT, matgl);
 			glMaterialfv(GL_FRONT, GL_DIFFUSE, matgl);
@@ -1477,17 +1514,27 @@
 				         tex->buf[(j*tex->w+i)*4+2],
 				         tex->buf[(j*tex->w+i)*4+3]);
 				    }*/
+				/*  texture has to be generated yet ... */
+/*				tex_build_mipmaps(tex);*/
 				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
 				             tex->w, tex->h, 0,  /*  no border. */
-				             GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);
-				/*  texture has to be generated yet ... */
+			    	         GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);
+
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
-				                GL_NEAREST);
+				                GL_LINEAR);
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
-				                GL_NEAREST);
+				                GL_LINEAR);
+/*				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
+				                GL_LINEAR_MIPMAP_LINEAR);
+				TODO: does not work?! Textures are still blank. */
 
+
+
+
+
 			}
 		} else { /* . can't use a texture  */
 			tex = NULL;

Modified: trunk/server/proto.c
===================================================================
--- trunk/server/proto.c	2007-09-23 22:26:12 UTC (rev 694)
+++ trunk/server/proto.c	2007-09-23 22:26:27 UTC (rev 695)
@@ -294,7 +294,7 @@
 			h = ntohs(*((uint16_t *)cptr));
 			cptr += 2;
 			num = length - 16;
-			/*     s3dprintf(MED,"LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)",length, oid,toid,w,h,x,y,num,w*h*4,num); */
+			s3dprintf(MED,"LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)",length, oid,toid,w,h,x,y,num,w*h*4,num); 
 			if ((w*h*4) == num)  /*  check correct size */
 				obj_load_tex(p, oid, toid, x, y, w, h, cptr);
 		}



From dotslash at mail.berlios.de  Mon Sep 24 00:26:34 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 24 Sep 2007 00:26:34 +0200
Subject: [S3d-svn] r696 - in trunk: . apps apps/comptest
Message-ID: <200709232226.l8NMQYe7017029@sheep.berlios.de>

Author: dotslash
Date: 2007-09-24 00:26:33 +0200 (Mon, 24 Sep 2007)
New Revision: 696

Added:
   trunk/apps/comptest/
   trunk/apps/comptest/Makefile
   trunk/apps/comptest/comptest
   trunk/apps/comptest/comptest.c
Modified:
   trunk/
Log:
 r2452 at kero:  dotslash | 2007-09-24 00:26:05 +0200
 - add comptest, a proof-of-concept composite manager which actually manages nothing.



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2451
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2452

Added: trunk/apps/comptest/Makefile
===================================================================
--- trunk/apps/comptest/Makefile	2007-09-23 22:26:27 UTC (rev 695)
+++ trunk/apps/comptest/Makefile	2007-09-23 22:26:33 UTC (rev 696)
@@ -0,0 +1,18 @@
+LIBS=-lXcomposite -lXdamage -lXfixes -lXrender -lX11 -lXext -ls3d  -lm 
+CFLAGS= -I/usr/local/x.org/include -g -O2
+LDFLAGS=-g -O2 $(LIBS)
+SOURCES=comptest.c
+OBJS=$(SOURCES:.c=.o)
+CC=gcc
+LD=gcc
+BIN=comptest
+
+
+.SUFFIXES: .c .o
+all:	comptest
+comptest:	$(OBJS)
+	$(LD) $(LDFLAGS) $< -o $@
+.c.o:  $(HEADERS)
+	   $(CC) $(CFLAGS) -c $< -o $@
+clean:
+	rm -rf $(OBJS) $(BIN)

Added: trunk/apps/comptest/comptest
===================================================================
(Binary files differ)


Property changes on: trunk/apps/comptest/comptest
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/x-executable-file

Added: trunk/apps/comptest/comptest.c
===================================================================
--- trunk/apps/comptest/comptest.c	2007-09-23 22:26:27 UTC (rev 695)
+++ trunk/apps/comptest/comptest.c	2007-09-23 22:26:33 UTC (rev 696)
@@ -0,0 +1,302 @@
+/*
+ * comptest.c
+ *
+ * Copyright (C) 2007 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of comptest, a one-day-proof-of-concept composite manager hack.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>								/* malloc(), free() */
+#include <time.h> 								/* nanosleep() */
+#include <s3d.h>
+#include <X11/Xlib.h>							/* Ximage, Display, X*() */
+#include <X11/Xutil.h>							/* XDestroyImage() */
+#include <X11/Xatom.h>
+#include <X11/extensions/Xcomposite.h>
+#include <X11/extensions/Xdamage.h>
+#include <X11/extensions/Xrender.h>
+
+struct extension {
+	int event, error;
+};
+
+struct window {
+	Window 						 id;
+	XWindowAttributes			 attr;			/* position, size etc. */
+	XImage						*image;
+	Damage						 damage;		/* damage notification */
+	XRenderPictureAttributes	 pa;
+	XRenderPictFormat 			*format; 
+	Picture						 picture;
+	int							 oid;
+	int 						 no;
+
+	char						*bitmap;		/* bitmap to upload */
+	struct window 				*next;
+};
+
+struct extension 	  xrender, xcomposite, xdamage, xfixes;
+struct window		 *window_head = NULL;
+Display     		*dpy;
+char				*display = NULL;
+int					 scr;
+Window				 root;
+
+static int 			 win_no = 0;				/* XXX: REMOVE */
+static struct timespec t = {
+	0, 10*1000*1000
+}; /* 10 mili seconds */
+
+int xinit();
+void window_update(struct window *win, int x, int y, int width, int height);
+
+void mainloop()
+{
+	nanosleep(&t, NULL);
+}
+
+int get_shift(unsigned long t)
+{
+	int i;
+	for (i = 0; t ; i++)
+		t >>= 1;
+	return(i);
+}
+
+static int error(Display *dpy, XErrorEvent *event)		
+{
+/*    printf ("error %d request %d minor %d serial %d\n",
+        event->error_code, event->request_code, event->minor_code, event->serial);*/
+    return 0;
+}
+
+
+int xinit() 
+{
+	dpy = XOpenDisplay(display);
+	if (!dpy) {
+		fprintf(stderr, "Can't open display\n");
+		return(1);
+	}
+    if (!XRenderQueryExtension (dpy, &xrender.event, &xrender.error)) {
+	    fprintf(stderr, "No render extension\n");
+		return(1);
+    }
+/*    XCompositeQueryVersion (dpy, &composite_major, &composite_minor); */
+
+	if (!XCompositeQueryExtension (dpy, &xcomposite.event, &xcomposite.error)) {
+	    fprintf (stderr, "No composite extension\n");
+		return(1);
+	}
+
+    if (!XDamageQueryExtension (dpy, &xdamage.event, &xdamage.error))
+    {
+	    fprintf (stderr, "No damage extension\n");
+		return(1);
+    }
+    if (!XFixesQueryExtension (dpy, &xfixes.event, &xfixes.error))
+    {
+	    fprintf (stderr, "No XFixes extension\n");
+	    return(1);
+    }
+	XSetErrorHandler(error);
+	return(0);
+}
+
+void deco_box(struct window *win) {
+	float vertices[8*3] = {
+		0, 0, 0,
+		1, 0, 0,
+		1, 1, 0,
+		0, 1, 0,
+		0, 0, 1,
+		1, 0, 1,
+		1, 1, 1,
+		0, 1, 1
+	};
+	float sver[8*3];
+	uint32_t polygon[12*4] = {
+		1, 5, 6, 1,
+		1, 6, 2, 1,
+		2, 6, 7, 1,
+		2, 7, 3, 1,
+		4, 0, 3, 1,
+		4, 3, 7, 1,
+		5, 4, 7, 1,
+		5, 7, 6, 1,
+		0, 4, 1, 1,
+		4, 5, 1, 1,
+		0, 1, 2, 0,
+		0, 2, 3, 0
+
+	};
+	float tbuf[] = { 0.0, 0.0,  1.0, 0.0,  1.0, 1.0,
+					 0.0, 0.0,  1.0, 1.0,  0.0, 1.0};
+	int i;
+
+	win->no = win_no++;		/* TODO: REMOVE */
+	win->oid = s3d_new_object();
+
+	for (i = 0;i < 8;i++) {
+		sver[i*3 + 0] = vertices[i*3+0] * win->attr.width/20;
+		sver[i*3 + 1] = vertices[i*3+1] * -win->attr.height/20;
+		sver[i*3 + 2] = vertices[i*3+2] * -1;
+	}
+
+	s3d_push_material_a(win->oid,
+						0.8, 0.0, 0.0 , 1.0,
+						1.0, 1.0, 1.0 , 1.0,
+						0.8, 0.0, 0.0 , 1.0);
+	s3d_push_texture(win->oid, win->attr.width, win->attr.height);
+	s3d_pep_material_texture(win->oid, 0); /*  assign texture 0 to material 0 */
+	s3d_push_material_a(win->oid,
+						0.0, 0.8, 0.0 , 1.0,
+						1.0, 1.0, 1.0 , 1.0,
+						0.0, 0.8, 0.0 , 1.0);
+
+	s3d_push_vertices(win->oid, sver, 8);
+
+	s3d_push_polygons(win->oid, polygon, 12);
+	s3d_pep_polygon_tex_coords(win->oid, tbuf, 2);
+	s3d_translate(win->oid, win->attr.x/20, -win->attr.y/20, 5 * win->no);
+	/*  push data on texture 0 position (0,0) */
+	s3d_flags_on(win->oid, S3D_OF_VISIBLE);
+	
+}
+
+void window_add(Display *dpy, Window id) {
+	struct window *win;
+	win = malloc(sizeof(*win));
+	if (!win) 
+		return;
+	win->id = id;
+	XGetWindowAttributes(dpy, win->id, &win->attr);
+	win->format = XRenderFindVisualFormat( dpy, win->attr.visual );
+/*	printf("add window: %d:%d size: %dx%d\n", win->attr.x, win->attr.y, win->attr.width, win->attr.height);*/
+	win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty );
+
+	win->pa.subwindow_mode = IncludeInferiors;
+	win->picture = XRenderCreatePicture(dpy, win->id, win->format, CPSubwindowMode, &win->pa);
+
+	win->oid = 0;
+
+	win->bitmap = NULL;
+	window_update(win, 0, 0, win->attr.width, win->attr.height);
+
+	win->next = window_head;
+	window_head = win;
+	
+}
+
+void window_remove(struct window *win) {
+	/* TODO */
+	free(win);
+}
+
+void window_update(struct window *win, int x, int y, int width, int height) {
+	int xi, yi;
+	int rs, gs, bs;
+	int bpp;
+	unsigned char *img_ptr, *bmp_ptr;
+	unsigned long *s, *t;
+	XImage *image;
+
+/*	printf("[D]oing window update for window %d at position %d:%d with size %dx%d\n",win->id, x,y,width,height);*/
+	image = XGetImage(dpy, win->id, x, y, win->attr.width, win->attr.height, AllPlanes, ZPixmap);
+	if (!image) {
+/*		printf("[P]roblem with the image\n");*/
+		return;
+	}
+	if (!win->bitmap)
+		win->bitmap = malloc(win->attr.width * win->attr.height * 4);
+	if (!win->oid)
+		deco_box(win);
+	if (image->format == ZPixmap) {
+		printf("XImage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n", 
+				image->width, image->height, image->format, 
+				ZPixmap, image->bits_per_pixel, image->depth, image->bitmap_pad);
+		rs = get_shift(image->red_mask) - 8;
+		gs = get_shift(image->green_mask) - 8;
+		bs = get_shift(image->blue_mask) - 8;
+
+		bpp = (image->bits_per_pixel / 8);
+		/* rgb is not bgr */
+		rs = rs;
+		gs = gs - 8;
+		bs = bs - 16;
+		printf("Ximage: rgb: %d|%d|%d\n", rs, gs, bs);;
+		/*  printf("red: size %d, offset %d\n",rs,roff);
+		  printf("green: size %d, offset %d\n",gs,goff);
+		  printf("blue: size %d, offset %d\n",bs,boff);
+		  printf("bits per pixel:%d\n",bpp);*/
+		for (yi = 0; yi < height ; yi++) {
+			img_ptr = image->data + (yi * width ) * bpp;
+			bmp_ptr = win->bitmap + ((y + yi) * win->attr.width + x) * 4;
+			for (xi = 0; xi < width; xi++) {
+				s = (unsigned long *)img_ptr;
+				t = (unsigned long *)bmp_ptr;
+/*				bmp_ptr[0] = (rs > 0 ? ((*d & image->red_mask) >> rs) 	: ((*d  & image->red_mask) << -rs)) ;
+				bmp_ptr[1] = (gs > 0 ? ((*d & image->green_mask) >> gs) : ((*d  & image->green_mask) << -gs)) ;
+				bmp_ptr[2] = (bs > 0 ? ((*d & image->blue_mask) >> bs)  : ((*d  & image->blue_mask) << -bs));
+				bmp_ptr[3] = 255 ;*/
+				*t = (rs > 0 ? ((*s & image->red_mask) >> rs) 	: ((*s  & image->red_mask) << -rs)) |
+					 (gs > 0 ? ((*s & image->green_mask) >> gs) : ((*s  & image->green_mask) << -gs)) |
+				     (bs > 0 ? ((*s & image->blue_mask) >> bs)  : ((*s  & image->blue_mask) << -bs)) |
+				     255 << 24;
+
+				bmp_ptr += 4;
+				img_ptr += bpp;
+			}
+			bmp_ptr = win->bitmap + ((y + yi) * win->attr.width + x) * 4;
+		}
+/*		s3d_load_texture(win->oid,0,x,y,width,height, ???); */
+		s3d_load_texture(win->oid,0,0,0,win->attr.width, win->attr.height, win->bitmap);
+		/*  swap images */
+	}
+	XDestroyImage(image);
+}
+
+void event() {
+/*	XNextEvent (dpy, &ev);*/
+}
+
+
+int main(int argc, char **argv) {
+    Window      	 root_return, parent_return;
+    unsigned int     nchildren;
+    Window      	*children;
+	int 			 i, scr_no;
+
+
+	if (xinit())
+		return(1);
+	if (!s3d_init(&argc, &argv, "compotest")) {
+		for (scr_no = 0; scr_no < ScreenCount(dpy); scr_no++) {
+			XCompositeRedirectSubwindows(dpy, RootWindow(dpy, scr_no), CompositeRedirectAutomatic);
+		    XQueryTree (dpy, RootWindow(dpy, scr_no), &root_return, &parent_return, &children, &nchildren);
+		    for (i = 0; i < nchildren; i++)
+		        window_add(dpy, children[i]);
+		    XFree(children);
+		}
+		s3d_mainloop(mainloop);
+	}
+
+
+	return(0);
+}



From lazhur at mail.berlios.de  Mon Sep 24 00:47:58 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 24 Sep 2007 00:47:58 +0200
Subject: [S3d-svn] r697 - trunk/apps/comptest
Message-ID: <200709232247.l8NMlwgh011931@sheep.berlios.de>

Author: lazhur
Date: 2007-09-24 00:47:57 +0200 (Mon, 24 Sep 2007)
New Revision: 697

Removed:
   trunk/apps/comptest/comptest
Modified:
   trunk/apps/comptest/Makefile
   trunk/apps/comptest/comptest.c
Log:
Fix segfaults of comptest on amd64


Modified: trunk/apps/comptest/Makefile
===================================================================
--- trunk/apps/comptest/Makefile	2007-09-23 22:26:33 UTC (rev 696)
+++ trunk/apps/comptest/Makefile	2007-09-23 22:47:57 UTC (rev 697)
@@ -1,6 +1,6 @@
 LIBS=-lXcomposite -lXdamage -lXfixes -lXrender -lX11 -lXext -ls3d  -lm 
-CFLAGS= -I/usr/local/x.org/include -g -O2
-LDFLAGS=-g -O2 $(LIBS)
+CFLAGS= -I/usr/local/x.org/include -I../../libs3d -g -O2
+LDFLAGS=-g -O2 $(LIBS)  -L../../build/libs3d
 SOURCES=comptest.c
 OBJS=$(SOURCES:.c=.o)
 CC=gcc

Deleted: trunk/apps/comptest/comptest
===================================================================
(Binary files differ)

Modified: trunk/apps/comptest/comptest.c
===================================================================
--- trunk/apps/comptest/comptest.c	2007-09-23 22:26:33 UTC (rev 696)
+++ trunk/apps/comptest/comptest.c	2007-09-23 22:47:57 UTC (rev 697)
@@ -22,11 +22,11 @@
  */
 
 #include <stdio.h>
-#include <stdlib.h>								/* malloc(), free() */
-#include <time.h> 								/* nanosleep() */
+#include <stdlib.h>        /* malloc(), free() */
+#include <time.h>         /* nanosleep() */
 #include <s3d.h>
-#include <X11/Xlib.h>							/* Ximage, Display, X*() */
-#include <X11/Xutil.h>							/* XDestroyImage() */
+#include <X11/Xlib.h>       /* Ximage, Display, X*() */
+#include <X11/Xutil.h>       /* XDestroyImage() */
 #include <X11/Xatom.h>
 #include <X11/extensions/Xcomposite.h>
 #include <X11/extensions/Xdamage.h>
@@ -37,28 +37,28 @@
 };
 
 struct window {
-	Window 						 id;
-	XWindowAttributes			 attr;			/* position, size etc. */
-	XImage						*image;
-	Damage						 damage;		/* damage notification */
-	XRenderPictureAttributes	 pa;
-	XRenderPictFormat 			*format; 
-	Picture						 picture;
-	int							 oid;
-	int 						 no;
+	Window        id;
+	XWindowAttributes    attr;   /* position, size etc. */
+	XImage      *image;
+	Damage       damage;  /* damage notification */
+	XRenderPictureAttributes  pa;
+	XRenderPictFormat    *format;
+	Picture       picture;
+	int        oid;
+	int        no;
 
-	char						*bitmap;		/* bitmap to upload */
-	struct window 				*next;
+	char      *bitmap;  /* bitmap to upload */
+	struct window     *next;
 };
 
-struct extension 	  xrender, xcomposite, xdamage, xfixes;
-struct window		 *window_head = NULL;
-Display     		*dpy;
-char				*display = NULL;
-int					 scr;
-Window				 root;
+struct extension    xrender, xcomposite, xdamage, xfixes;
+struct window   *window_head = NULL;
+Display       *dpy;
+char    *display = NULL;
+int      scr;
+Window     root;
 
-static int 			 win_no = 0;				/* XXX: REMOVE */
+static int     win_no = 0;    /* XXX: REMOVE */
 static struct timespec t = {
 	0, 10*1000*1000
 }; /* 10 mili seconds */
@@ -79,47 +79,46 @@
 	return(i);
 }
 
-static int error(Display *dpy, XErrorEvent *event)		
+static int error(Display *dpy, XErrorEvent *event)
 {
-/*    printf ("error %d request %d minor %d serial %d\n",
-        event->error_code, event->request_code, event->minor_code, event->serial);*/
-    return 0;
+	/*    printf ("error %d request %d minor %d serial %d\n",
+	        event->error_code, event->request_code, event->minor_code, event->serial);*/
+	return 0;
 }
 
 
-int xinit() 
+int xinit()
 {
 	dpy = XOpenDisplay(display);
 	if (!dpy) {
 		fprintf(stderr, "Can't open display\n");
 		return(1);
 	}
-    if (!XRenderQueryExtension (dpy, &xrender.event, &xrender.error)) {
-	    fprintf(stderr, "No render extension\n");
+	if (!XRenderQueryExtension(dpy, &xrender.event, &xrender.error)) {
+		fprintf(stderr, "No render extension\n");
 		return(1);
-    }
-/*    XCompositeQueryVersion (dpy, &composite_major, &composite_minor); */
+	}
+	/*    XCompositeQueryVersion (dpy, &composite_major, &composite_minor); */
 
-	if (!XCompositeQueryExtension (dpy, &xcomposite.event, &xcomposite.error)) {
-	    fprintf (stderr, "No composite extension\n");
+	if (!XCompositeQueryExtension(dpy, &xcomposite.event, &xcomposite.error)) {
+		fprintf(stderr, "No composite extension\n");
 		return(1);
 	}
 
-    if (!XDamageQueryExtension (dpy, &xdamage.event, &xdamage.error))
-    {
-	    fprintf (stderr, "No damage extension\n");
+	if (!XDamageQueryExtension(dpy, &xdamage.event, &xdamage.error)) {
+		fprintf(stderr, "No damage extension\n");
 		return(1);
-    }
-    if (!XFixesQueryExtension (dpy, &xfixes.event, &xfixes.error))
-    {
-	    fprintf (stderr, "No XFixes extension\n");
-	    return(1);
-    }
+	}
+	if (!XFixesQueryExtension(dpy, &xfixes.event, &xfixes.error)) {
+		fprintf(stderr, "No XFixes extension\n");
+		return(1);
+	}
 	XSetErrorHandler(error);
 	return(0);
 }
 
-void deco_box(struct window *win) {
+void deco_box(struct window *win)
+{
 	float vertices[8*3] = {
 		0, 0, 0,
 		1, 0, 0,
@@ -147,49 +146,51 @@
 
 	};
 	float tbuf[] = { 0.0, 0.0,  1.0, 0.0,  1.0, 1.0,
-					 0.0, 0.0,  1.0, 1.0,  0.0, 1.0};
+	                 0.0, 0.0,  1.0, 1.0,  0.0, 1.0
+	               };
 	int i;
 
-	win->no = win_no++;		/* TODO: REMOVE */
+	win->no = win_no++;  /* TODO: REMOVE */
 	win->oid = s3d_new_object();
 
 	for (i = 0;i < 8;i++) {
-		sver[i*3 + 0] = vertices[i*3+0] * win->attr.width/20;
-		sver[i*3 + 1] = vertices[i*3+1] * -win->attr.height/20;
+		sver[i*3 + 0] = vertices[i*3+0] * win->attr.width / 20;
+		sver[i*3 + 1] = vertices[i*3+1] * -win->attr.height / 20;
 		sver[i*3 + 2] = vertices[i*3+2] * -1;
 	}
 
 	s3d_push_material_a(win->oid,
-						0.8, 0.0, 0.0 , 1.0,
-						1.0, 1.0, 1.0 , 1.0,
-						0.8, 0.0, 0.0 , 1.0);
+	                    0.8, 0.0, 0.0 , 1.0,
+	                    1.0, 1.0, 1.0 , 1.0,
+	                    0.8, 0.0, 0.0 , 1.0);
 	s3d_push_texture(win->oid, win->attr.width, win->attr.height);
 	s3d_pep_material_texture(win->oid, 0); /*  assign texture 0 to material 0 */
 	s3d_push_material_a(win->oid,
-						0.0, 0.8, 0.0 , 1.0,
-						1.0, 1.0, 1.0 , 1.0,
-						0.0, 0.8, 0.0 , 1.0);
+	                    0.0, 0.8, 0.0 , 1.0,
+	                    1.0, 1.0, 1.0 , 1.0,
+	                    0.0, 0.8, 0.0 , 1.0);
 
 	s3d_push_vertices(win->oid, sver, 8);
 
 	s3d_push_polygons(win->oid, polygon, 12);
 	s3d_pep_polygon_tex_coords(win->oid, tbuf, 2);
-	s3d_translate(win->oid, win->attr.x/20, -win->attr.y/20, 5 * win->no);
+	s3d_translate(win->oid, win->attr.x / 20, -win->attr.y / 20, 5 * win->no);
 	/*  push data on texture 0 position (0,0) */
 	s3d_flags_on(win->oid, S3D_OF_VISIBLE);
-	
+
 }
 
-void window_add(Display *dpy, Window id) {
+void window_add(Display *dpy, Window id)
+{
 	struct window *win;
 	win = malloc(sizeof(*win));
-	if (!win) 
+	if (!win)
 		return;
 	win->id = id;
 	XGetWindowAttributes(dpy, win->id, &win->attr);
-	win->format = XRenderFindVisualFormat( dpy, win->attr.visual );
-/*	printf("add window: %d:%d size: %dx%d\n", win->attr.x, win->attr.y, win->attr.width, win->attr.height);*/
-	win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty );
+	win->format = XRenderFindVisualFormat(dpy, win->attr.visual);
+	/* printf("add window: %d:%d size: %dx%d\n", win->attr.x, win->attr.y, win->attr.width, win->attr.height);*/
+	win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty);
 
 	win->pa.subwindow_mode = IncludeInferiors;
 	win->picture = XRenderCreatePicture(dpy, win->id, win->format, CPSubwindowMode, &win->pa);
@@ -201,36 +202,39 @@
 
 	win->next = window_head;
 	window_head = win;
-	
+
 }
 
-void window_remove(struct window *win) {
+void window_remove(struct window *win)
+{
 	/* TODO */
 	free(win);
 }
 
-void window_update(struct window *win, int x, int y, int width, int height) {
+void window_update(struct window *win, int x, int y, int width, int height)
+{
 	int xi, yi;
 	int rs, gs, bs;
 	int bpp;
 	unsigned char *img_ptr, *bmp_ptr;
-	unsigned long *s, *t;
+	unsigned long *s;
+	uint32_t *t;
 	XImage *image;
 
-/*	printf("[D]oing window update for window %d at position %d:%d with size %dx%d\n",win->id, x,y,width,height);*/
+	/* printf("[D]oing window update for window %d at position %d:%d with size %dx%d\n",win->id, x,y,width,height);*/
 	image = XGetImage(dpy, win->id, x, y, win->attr.width, win->attr.height, AllPlanes, ZPixmap);
 	if (!image) {
-/*		printf("[P]roblem with the image\n");*/
+		/*  printf("[P]roblem with the image\n");*/
 		return;
 	}
 	if (!win->bitmap)
-		win->bitmap = malloc(win->attr.width * win->attr.height * 4);
+		win->bitmap = malloc(win->attr.width * win->attr.height * sizeof(uint32_t));
 	if (!win->oid)
 		deco_box(win);
 	if (image->format == ZPixmap) {
-		printf("XImage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n", 
-				image->width, image->height, image->format, 
-				ZPixmap, image->bits_per_pixel, image->depth, image->bitmap_pad);
+		printf("XImage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n",
+		       image->width, image->height, image->format,
+		       ZPixmap, image->bits_per_pixel, image->depth, image->bitmap_pad);
 		rs = get_shift(image->red_mask) - 8;
 		gs = get_shift(image->green_mask) - 8;
 		bs = get_shift(image->blue_mask) - 8;
@@ -246,42 +250,44 @@
 		  printf("blue: size %d, offset %d\n",bs,boff);
 		  printf("bits per pixel:%d\n",bpp);*/
 		for (yi = 0; yi < height ; yi++) {
-			img_ptr = image->data + (yi * width ) * bpp;
-			bmp_ptr = win->bitmap + ((y + yi) * win->attr.width + x) * 4;
+			img_ptr = image->data + (yi * width) * bpp;
+			bmp_ptr = win->bitmap + ((y + yi) * win->attr.width + x) * sizeof(uint32_t);
 			for (xi = 0; xi < width; xi++) {
 				s = (unsigned long *)img_ptr;
-				t = (unsigned long *)bmp_ptr;
-/*				bmp_ptr[0] = (rs > 0 ? ((*d & image->red_mask) >> rs) 	: ((*d  & image->red_mask) << -rs)) ;
-				bmp_ptr[1] = (gs > 0 ? ((*d & image->green_mask) >> gs) : ((*d  & image->green_mask) << -gs)) ;
-				bmp_ptr[2] = (bs > 0 ? ((*d & image->blue_mask) >> bs)  : ((*d  & image->blue_mask) << -bs));
-				bmp_ptr[3] = 255 ;*/
-				*t = (rs > 0 ? ((*s & image->red_mask) >> rs) 	: ((*s  & image->red_mask) << -rs)) |
-					 (gs > 0 ? ((*s & image->green_mask) >> gs) : ((*s  & image->green_mask) << -gs)) |
+				t = (uint32_t *)bmp_ptr;
+				/*    bmp_ptr[0] = (rs > 0 ? ((*d & image->red_mask) >> rs)  : ((*d  & image->red_mask) << -rs)) ;
+				    bmp_ptr[1] = (gs > 0 ? ((*d & image->green_mask) >> gs) : ((*d  & image->green_mask) << -gs)) ;
+				    bmp_ptr[2] = (bs > 0 ? ((*d & image->blue_mask) >> bs)  : ((*d  & image->blue_mask) << -bs));
+				    bmp_ptr[3] = 255 ;*/
+				*t = (rs > 0 ? ((*s & image->red_mask) >> rs)  : ((*s  & image->red_mask) << -rs)) |
+				     (gs > 0 ? ((*s & image->green_mask) >> gs) : ((*s  & image->green_mask) << -gs)) |
 				     (bs > 0 ? ((*s & image->blue_mask) >> bs)  : ((*s  & image->blue_mask) << -bs)) |
 				     255 << 24;
 
-				bmp_ptr += 4;
+				bmp_ptr += sizeof(uint32_t);
 				img_ptr += bpp;
 			}
-			bmp_ptr = win->bitmap + ((y + yi) * win->attr.width + x) * 4;
+			bmp_ptr = win->bitmap + ((y + yi) * win->attr.width + x) * sizeof(uint32_t);
 		}
-/*		s3d_load_texture(win->oid,0,x,y,width,height, ???); */
-		s3d_load_texture(win->oid,0,0,0,win->attr.width, win->attr.height, win->bitmap);
+		/*  s3d_load_texture(win->oid,0,x,y,width,height, ???); */
+		s3d_load_texture(win->oid, 0, 0, 0, win->attr.width, win->attr.height, win->bitmap);
 		/*  swap images */
 	}
 	XDestroyImage(image);
 }
 
-void event() {
-/*	XNextEvent (dpy, &ev);*/
+void event()
+{
+	/* XNextEvent (dpy, &ev);*/
 }
 
 
-int main(int argc, char **argv) {
-    Window      	 root_return, parent_return;
-    unsigned int     nchildren;
-    Window      	*children;
-	int 			 i, scr_no;
+int main(int argc, char **argv)
+{
+	Window        root_return, parent_return;
+	unsigned int     nchildren;
+	Window       *children;
+	int     i, scr_no;
 
 
 	if (xinit())
@@ -289,10 +295,10 @@
 	if (!s3d_init(&argc, &argv, "compotest")) {
 		for (scr_no = 0; scr_no < ScreenCount(dpy); scr_no++) {
 			XCompositeRedirectSubwindows(dpy, RootWindow(dpy, scr_no), CompositeRedirectAutomatic);
-		    XQueryTree (dpy, RootWindow(dpy, scr_no), &root_return, &parent_return, &children, &nchildren);
-		    for (i = 0; i < nchildren; i++)
-		        window_add(dpy, children[i]);
-		    XFree(children);
+			XQueryTree(dpy, RootWindow(dpy, scr_no), &root_return, &parent_return, &children, &nchildren);
+			for (i = 0; i < nchildren; i++)
+				window_add(dpy, children[i]);
+			XFree(children);
 		}
 		s3d_mainloop(mainloop);
 	}



From lazhur at mail.berlios.de  Mon Sep 24 04:19:22 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 24 Sep 2007 04:19:22 +0200
Subject: [S3d-svn] r698 - trunk/server
Message-ID: <200709240219.l8O2JMGN012622@sheep.berlios.de>

Author: lazhur
Date: 2007-09-24 04:19:21 +0200 (Mon, 24 Sep 2007)
New Revision: 698

Modified:
   trunk/server/object.c
Log:
Fix that no texture was displayed at all when mip mapping is enabled


Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-09-23 22:47:57 UTC (rev 697)
+++ trunk/server/object.c	2007-09-24 02:19:21 UTC (rev 698)
@@ -1445,10 +1445,10 @@
 
 }
 
-void tex_build_mipmaps(struct t_tex *tex) 
+void tex_build_mipmaps(struct t_tex *tex)
 {
-	int 			 i, w, h, x, y, c;
-	unsigned char 	*buf, *src;
+	int     i, w, h, x, y, c;
+	unsigned char  *buf, *src;
 	w = tex->w;
 	h = tex->h;
 	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
@@ -1457,27 +1457,34 @@
 	             GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);
 	/* this is fairly hacky, but we only use one buffer and decrease the image left-top to right-bottom,
 	 * so we only read from elements AFTER the updated (written) elements. */
-	buf = malloc( (w / 2) * (h /2 ) * 4);
+	buf = malloc((w / 2) * (h / 2) * 4);
 	src = tex->buf;
-	for (i = 1 ; i < 4 ; i++) {
-		w /= 2;
-		h /= 2;
+	i = 1;
+	while (w != 1 || h != 1) {
+		if (w != 1) {
+			w /= 2;
+		}
 
+		if (h != 1) {
+			h /= 2;
+		}
+
 		if ((w == 0) || (h == 0)) break;
 		/* TODO: handle texture borders which have not even width or height */
 		for (y = 0; y < h; y++)
-			for (x = 0; x < w; x++) 
+			for (x = 0; x < w; x++)
 				for (c = 0; c < 4; c++) {
-					buf[(y * w + x)*4 + c] = ((uint16_t) 
-											  src[( 2 * y      * w + 2 * x    )*4 + c] + 
-											  src[((2 * y + 1) * w + 2 * x    )*4 + c] + 
-											  src[( 2 * y      * w + 2 * x + 1)*4 + c] + 
-											  src[((2 * y + 1) * w + 2 * x + 1)*4 + c]) / 4;
-/*					s3dprintf(MED,"texture: %d, x = %d, y = %d, c = %d, buf = %02x\n", i, x, y, c, buf[(y * w + x)*4 + c]);*/
+					buf[(y * w + x)*4 + c] = ((uint16_t)
+					                          src[(2  * y      * w + 2 * x)     * 4 + c] +
+					                          src[((2 * y + 1) * w + 2 * x)     * 4 + c] +
+					                          src[(2  * y      * w + 2 * x + 1) * 4 + c] +
+					                          src[((2 * y + 1) * w + 2 * x + 1) * 4 + c]) / 4;
+					/*     s3dprintf(MED,"texture: %d, x = %d, y = %d, c = %d, buf = %02x\n", i, x, y, c, buf[(y * w + x)*4 + c]);*/
 
 				}
 		glTexImage2D(GL_TEXTURE_2D, i, GL_RGBA, w, h, 0,   GL_RGBA, GL_UNSIGNED_BYTE, buf);
 		src = buf;
+		i++;
 	}
 	free(buf);
 }
@@ -1515,10 +1522,10 @@
 				         tex->buf[(j*tex->w+i)*4+3]);
 				    }*/
 				/*  texture has to be generated yet ... */
-/*				tex_build_mipmaps(tex);*/
+				tex_build_mipmaps(tex);
 				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
 				             tex->w, tex->h, 0,  /*  no border. */
-			    	         GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);
+				             GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);
 
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
@@ -1527,14 +1534,8 @@
 				                GL_LINEAR);
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
 				                GL_LINEAR);
-/*				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
 				                GL_LINEAR_MIPMAP_LINEAR);
-				TODO: does not work?! Textures are still blank. */
-
-
-
-
-
 			}
 		} else { /* . can't use a texture  */
 			tex = NULL;



From lazhur at mail.berlios.de  Mon Sep 24 04:19:28 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 24 Sep 2007 04:19:28 +0200
Subject: [S3d-svn] r699 - trunk/apps/comptest
Message-ID: <200709240219.l8O2JSGs012665@sheep.berlios.de>

Author: lazhur
Date: 2007-09-24 04:19:27 +0200 (Mon, 24 Sep 2007)
New Revision: 699

Modified:
   trunk/apps/comptest/comptest.c
Log:
Prevent a segfault in XRenderCreatePicture when there was an error in XRenderFindVisualFormat


Modified: trunk/apps/comptest/comptest.c
===================================================================
--- trunk/apps/comptest/comptest.c	2007-09-24 02:19:21 UTC (rev 698)
+++ trunk/apps/comptest/comptest.c	2007-09-24 02:19:27 UTC (rev 699)
@@ -189,20 +189,22 @@
 	win->id = id;
 	XGetWindowAttributes(dpy, win->id, &win->attr);
 	win->format = XRenderFindVisualFormat(dpy, win->attr.visual);
-	/* printf("add window: %d:%d size: %dx%d\n", win->attr.x, win->attr.y, win->attr.width, win->attr.height);*/
-	win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty);
 
-	win->pa.subwindow_mode = IncludeInferiors;
-	win->picture = XRenderCreatePicture(dpy, win->id, win->format, CPSubwindowMode, &win->pa);
+	if (win->format != 0) {
+		/* printf("add window: %d:%d size: %dx%d\n", win->attr.x, win->attr.y, win->attr.width, win->attr.height);*/
+		win->damage = XDamageCreate(dpy, win->id, XDamageReportNonEmpty);
 
-	win->oid = 0;
+		win->pa.subwindow_mode = IncludeInferiors;
+		win->picture = XRenderCreatePicture(dpy, win->id, win->format, CPSubwindowMode, &win->pa);
 
-	win->bitmap = NULL;
-	window_update(win, 0, 0, win->attr.width, win->attr.height);
+		win->oid = 0;
 
-	win->next = window_head;
-	window_head = win;
+		win->bitmap = NULL;
+		window_update(win, 0, 0, win->attr.width, win->attr.height);
 
+		win->next = window_head;
+		window_head = win;
+	}
 }
 
 void window_remove(struct window *win)



From lazhur at mail.berlios.de  Mon Sep 24 04:19:33 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 24 Sep 2007 04:19:33 +0200
Subject: [S3d-svn] r700 - trunk/cmake/modules
Message-ID: <200709240219.l8O2JX8U012722@sheep.berlios.de>

Author: lazhur
Date: 2007-09-24 04:19:33 +0200 (Mon, 24 Sep 2007)
New Revision: 700

Added:
   trunk/cmake/modules/FindXcomposite.cmake
   trunk/cmake/modules/FindXdamage.cmake
   trunk/cmake/modules/FindXfixes.cmake
   trunk/cmake/modules/FindXrender.cmake
Modified:
   trunk/cmake/modules/FindXtst.cmake
Log:
Added cmake check for Xcomposite, Xdamage, Xfixes, Xrender


Added: trunk/cmake/modules/FindXcomposite.cmake
===================================================================
--- trunk/cmake/modules/FindXcomposite.cmake	2007-09-24 02:19:27 UTC (rev 699)
+++ trunk/cmake/modules/FindXcomposite.cmake	2007-09-24 02:19:33 UTC (rev 700)
@@ -0,0 +1,39 @@
+# Try to find Xcomposite
+#  XCOMPOSITE_FOUND - If false, do not try to use Xcomposite
+#  XCOMPOSITE_LIBRARIES - the libraries to link against
+#  XCOMPOSITE_DEFINITIONS - switches required for Xcomposite
+
+
+if (XCOMPOSITE_LIBRARIES)
+	# path set by user or was found in the past
+	set(XCOMPOSITE_FOUND TRUE)
+else (XCOMPOSITE_LIBRARIES)
+	include(UsePkgConfig)
+
+	pkgconfig(xcomposite _IncDir _LinkDir _LinkFlags _CFlags)
+	set(XCOMPOSITE_DEFINITIONS ${_CFlags})
+
+	find_library(XCOMPOSITE_LIBRARIES
+		NAMES Xcomposite
+		PATHS ${_LinkDir}
+	)
+
+	if (XCOMPOSITE_LIBRARIES)
+		set(XCOMPOSITE_FOUND TRUE)
+	endif (XCOMPOSITE_LIBRARIES)
+
+	if (XCOMPOSITE_FOUND)
+		if (NOT XCOMPOSITE_FIND_QUIETLY)
+			message(STATUS "Found Xcomposite: ${XCOMPOSITE_LIBRARIES}")
+		endif (NOT XCOMPOSITE_FIND_QUIETLY)
+	else (XCOMPOSITE_FOUND)
+		if (XCOMPOSITE_FIND_REQUIRED)
+			message(FATAL_ERROR "Could not find Xcomposite")
+		endif (XCOMPOSITE_FIND_REQUIRED)
+	endif (XCOMPOSITE_FOUND)
+
+	# set visibility in cache
+	set(XCOMPOSITE_DEFINITIONS ${XCOMPOSITE_DEFINITIONS} CACHE STRING "Defines for compilation." FORCE)
+ 	mark_as_advanced(XCOMPOSITE_LIBRARIES XCOMPOSITE_DEFINITIONS)
+
+endif (XCOMPOSITE_LIBRARIES)

Added: trunk/cmake/modules/FindXdamage.cmake
===================================================================
--- trunk/cmake/modules/FindXdamage.cmake	2007-09-24 02:19:27 UTC (rev 699)
+++ trunk/cmake/modules/FindXdamage.cmake	2007-09-24 02:19:33 UTC (rev 700)
@@ -0,0 +1,39 @@
+# Try to find Xdamage
+#  XDAMAGE_FOUND - If false, do not try to use Xdamage
+#  XDAMAGE_LIBRARIES - the libraries to link against
+#  XDAMAGE_DEFINITIONS - switches required for Xdamage
+
+
+if (XDAMAGE_LIBRARIES)
+	# path set by user or was found in the past
+	set(XDAMAGE_FOUND TRUE)
+else (XDAMAGE_LIBRARIES)
+	include(UsePkgConfig)
+
+	pkgconfig(xdamage _IncDir _LinkDir _LinkFlags _CFlags)
+	set(XDAMAGE_DEFINITIONS ${_CFlags})
+
+	find_library(XDAMAGE_LIBRARIES
+		NAMES Xdamage
+		PATHS ${_LinkDir}
+	)
+
+	if (XDAMAGE_LIBRARIES)
+		set(XDAMAGE_FOUND TRUE)
+	endif (XDAMAGE_LIBRARIES)
+
+	if (XDAMAGE_FOUND)
+		if (NOT XDAMAGE_FIND_QUIETLY)
+			message(STATUS "Found Xdamage: ${XDAMAGE_LIBRARIES}")
+		endif (NOT XDAMAGE_FIND_QUIETLY)
+	else (XDAMAGE_FOUND)
+		if (XDAMAGE_FIND_REQUIRED)
+			message(FATAL_ERROR "Could not find Xdamage")
+		endif (XDAMAGE_FIND_REQUIRED)
+	endif (XDAMAGE_FOUND)
+
+	# set visibility in cache
+	set(XDAMAGE_DEFINITIONS ${XDAMAGE_DEFINITIONS} CACHE STRING "Defines for compilation." FORCE)
+ 	mark_as_advanced(XDAMAGE_LIBRARIES XDAMAGE_DEFINITIONS)
+
+endif (XDAMAGE_LIBRARIES)

Added: trunk/cmake/modules/FindXfixes.cmake
===================================================================
--- trunk/cmake/modules/FindXfixes.cmake	2007-09-24 02:19:27 UTC (rev 699)
+++ trunk/cmake/modules/FindXfixes.cmake	2007-09-24 02:19:33 UTC (rev 700)
@@ -0,0 +1,39 @@
+# Try to find Xfixes
+#  XFIXES_FOUND - If false, do not try to use Xfixes
+#  XFIXES_LIBRARIES - the libraries to link against
+#  XFIXES_DEFINITIONS - switches required for Xfixes
+
+
+if (XFIXES_LIBRARIES)
+	# path set by user or was found in the past
+	set(XFIXES_FOUND TRUE)
+else (XFIXES_LIBRARIES)
+	include(UsePkgConfig)
+
+	pkgconfig(xfixes _IncDir _LinkDir _LinkFlags _CFlags)
+	set(XFIXES_DEFINITIONS ${_CFlags})
+
+	find_library(XFIXES_LIBRARIES
+		NAMES Xfixes
+		PATHS ${_LinkDir}
+	)
+
+	if (XFIXES_LIBRARIES)
+		set(XFIXES_FOUND TRUE)
+	endif (XFIXES_LIBRARIES)
+
+	if (XFIXES_FOUND)
+		if (NOT XFIXES_FIND_QUIETLY)
+			message(STATUS "Found Xfixes: ${XFIXES_LIBRARIES}")
+		endif (NOT XFIXES_FIND_QUIETLY)
+	else (XFIXES_FOUND)
+		if (XFIXES_FIND_REQUIRED)
+			message(FATAL_ERROR "Could not find Xfixes")
+		endif (XFIXES_FIND_REQUIRED)
+	endif (XFIXES_FOUND)
+
+	# set visibility in cache
+	set(XFIXES_DEFINITIONS ${XFIXES_DEFINITIONS} CACHE STRING "Defines for compilation." FORCE)
+ 	mark_as_advanced(XFIXES_LIBRARIES XFIXES_DEFINITIONS)
+
+endif (XFIXES_LIBRARIES)

Added: trunk/cmake/modules/FindXrender.cmake
===================================================================
--- trunk/cmake/modules/FindXrender.cmake	2007-09-24 02:19:27 UTC (rev 699)
+++ trunk/cmake/modules/FindXrender.cmake	2007-09-24 02:19:33 UTC (rev 700)
@@ -0,0 +1,39 @@
+# Try to find Xrender
+#  XRENDER_FOUND - If false, do not try to use Xrender
+#  XRENDER_LIBRARIES - the libraries to link against
+#  XRENDER_DEFINITIONS - switches required for Xrender
+
+
+if (XRENDER_LIBRARIES)
+	# path set by user or was found in the past
+	set(XRENDER_FOUND TRUE)
+else (XRENDER_LIBRARIES)
+	include(UsePkgConfig)
+
+	pkgconfig(xrender _IncDir _LinkDir _LinkFlags _CFlags)
+	set(XRENDER_DEFINITIONS ${_CFlags})
+
+	find_library(XRENDER_LIBRARIES
+		NAMES Xrender
+		PATHS ${_LinkDir}
+	)
+
+	if (XRENDER_LIBRARIES)
+		set(XRENDER_FOUND TRUE)
+	endif (XRENDER_LIBRARIES)
+
+	if (XRENDER_FOUND)
+		if (NOT XRENDER_FIND_QUIETLY)
+			message(STATUS "Found Xrender: ${XRENDER_LIBRARIES}")
+		endif (NOT XRENDER_FIND_QUIETLY)
+	else (XRENDER_FOUND)
+		if (XRENDER_FIND_REQUIRED)
+			message(FATAL_ERROR "Could not find Xrender")
+		endif (XRENDER_FIND_REQUIRED)
+	endif (XRENDER_FOUND)
+
+	# set visibility in cache
+	set(XRENDER_DEFINITIONS ${XRENDER_DEFINITIONS} CACHE STRING "Defines for compilation." FORCE)
+ 	mark_as_advanced(XRENDER_LIBRARIES XRENDER_DEFINITIONS)
+
+endif (XRENDER_LIBRARIES)

Modified: trunk/cmake/modules/FindXtst.cmake
===================================================================
--- trunk/cmake/modules/FindXtst.cmake	2007-09-24 02:19:27 UTC (rev 699)
+++ trunk/cmake/modules/FindXtst.cmake	2007-09-24 02:19:33 UTC (rev 700)
@@ -10,7 +10,7 @@
 else (XTST_LIBRARIES)
 	include(UsePkgConfig)
 
-	pkgconfig(XTST _IncDir _LinkDir _LinkFlags _CFlags)
+	pkgconfig(xtst _IncDir _LinkDir _LinkFlags _CFlags)
 	set(XTST_DEFINITIONS ${_CFlags})
 
 	find_library(XTST_LIBRARIES



From lazhur at mail.berlios.de  Mon Sep 24 04:19:39 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 24 Sep 2007 04:19:39 +0200
Subject: [S3d-svn] r701 - in trunk: . apps apps/comptest
Message-ID: <200709240219.l8O2JdFf012759@sheep.berlios.de>

Author: lazhur
Date: 2007-09-24 04:19:38 +0200 (Mon, 24 Sep 2007)
New Revision: 701

Added:
   trunk/apps/comptest/CMakeLists.txt
Removed:
   trunk/apps/comptest/Makefile
Modified:
   trunk/ConfigureChecks.cmake
   trunk/apps/CMakeLists.txt
Log:
Added comptest to normal s3d build environment


Modified: trunk/ConfigureChecks.cmake
===================================================================
--- trunk/ConfigureChecks.cmake	2007-09-24 02:19:33 UTC (rev 700)
+++ trunk/ConfigureChecks.cmake	2007-09-24 02:19:38 UTC (rev 701)
@@ -76,6 +76,30 @@
 endif (LIBXML2_FOUND)
 
 
+# try to find lib and add include dir for Xcomposite
+find_package(Xcomposite)
+if (XCOMPOSITE_FOUND)
+	add_definitions(${XCOMPOSITE_DEFINITIONS})
+endif (XCOMPOSITE_FOUND)
+
+# try to find lib and add include dir for Xdamage
+find_package(Xdamage)
+if (XDAMAGE_FOUND)
+	add_definitions(${XDAMAGE_DEFINITIONS})
+endif (XDAMAGE_FOUND)
+
+# try to find lib and add include dir for Xfixes
+find_package(Xfixes)
+if (XFIXES_FOUND)
+	add_definitions(${XFIXES_DEFINITIONS})
+endif (XFIXES_FOUND)
+
+# try to find lib and add include dir for Xrender
+find_package(Xrender)
+if (XRENDER_FOUND)
+	add_definitions(${XRENDER_DEFINITIONS})
+endif (XRENDER_FOUND)
+
 # try to find lib and add include dir for Xtst
 find_package(Xtst)
 if (XTST_FOUND)

Modified: trunk/apps/CMakeLists.txt
===================================================================
--- trunk/apps/CMakeLists.txt	2007-09-24 02:19:33 UTC (rev 700)
+++ trunk/apps/CMakeLists.txt	2007-09-24 02:19:38 UTC (rev 701)
@@ -1,3 +1,4 @@
+add_subdirectory(comptest)
 add_subdirectory(dot_mcp)
 add_subdirectory(kism3d)
 add_subdirectory(meshs3d)

Added: trunk/apps/comptest/CMakeLists.txt
===================================================================
--- trunk/apps/comptest/CMakeLists.txt	2007-09-24 02:19:33 UTC (rev 700)
+++ trunk/apps/comptest/CMakeLists.txt	2007-09-24 02:19:38 UTC (rev 701)
@@ -0,0 +1,31 @@
+project(comptest)
+
+if (XCOMPOSITE_FOUND AND XDAMAGE_FOUND AND XFIXES_FOUND AND XRENDER_FOUND)
+	include_directories(${s3d_SOURCE_DIR}/libs3d)
+
+	add_executable(comptest comptest.c)
+	target_link_libraries(comptest s3d ${XCOMPOSITE_LIBRARIES}
+		${XFIXES_LIBRARIES} ${XDAMAGE_LIBRARIES} ${XRENDER_LIBRARIES})
+
+	# install
+	install(TARGETS comptest RUNTIME DESTINATION bin)
+else (XCOMPOSITE_FOUND AND XDAMAGE_FOUND AND XFIXES_FOUND AND XRENDER_FOUND)
+	if (NOT XCOMPOSITE_FOUND)
+		PkgStatus_Later("xcomposite (pkg name: libxcomposite-dev)")
+	endif (NOT XCOMPOSITE_FOUND)
+	
+	if (NOT XDAMAGE_FOUND)
+		PkgStatus_Later("xdamage (pkg name: libxdamage-dev)")
+	endif (NOT XDAMAGE_FOUND)
+	
+	if (NOT XFIXES_FOUND)
+		PkgStatus_Later("xfixes (pkg name: libxfixes-dev)")
+	endif (NOT XFIXES_FOUND)
+	
+	if (NOT XRENDER_FOUND)
+		PkgStatus_Later("xrender (pkg name: libxrender-dev)")
+	endif (NOT XRENDER_FOUND)
+	
+	# print late status
+	Collected_PkgStatus("comptest")
+endif (XCOMPOSITE_FOUND AND XDAMAGE_FOUND AND XFIXES_FOUND AND XRENDER_FOUND)

Deleted: trunk/apps/comptest/Makefile
===================================================================
--- trunk/apps/comptest/Makefile	2007-09-24 02:19:33 UTC (rev 700)
+++ trunk/apps/comptest/Makefile	2007-09-24 02:19:38 UTC (rev 701)
@@ -1,18 +0,0 @@
-LIBS=-lXcomposite -lXdamage -lXfixes -lXrender -lX11 -lXext -ls3d  -lm 
-CFLAGS= -I/usr/local/x.org/include -I../../libs3d -g -O2
-LDFLAGS=-g -O2 $(LIBS)  -L../../build/libs3d
-SOURCES=comptest.c
-OBJS=$(SOURCES:.c=.o)
-CC=gcc
-LD=gcc
-BIN=comptest
-
-
-.SUFFIXES: .c .o
-all:	comptest
-comptest:	$(OBJS)
-	$(LD) $(LDFLAGS) $< -o $@
-.c.o:  $(HEADERS)
-	   $(CC) $(CFLAGS) -c $< -o $@
-clean:
-	rm -rf $(OBJS) $(BIN)



From lazhur at mail.berlios.de  Mon Sep 24 04:19:45 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 24 Sep 2007 04:19:45 +0200
Subject: [S3d-svn] r702 - trunk/server
Message-ID: <200709240219.l8O2JjgV012807@sheep.berlios.de>

Author: lazhur
Date: 2007-09-24 04:19:45 +0200 (Mon, 24 Sep 2007)
New Revision: 702

Modified:
   trunk/server/user_glut.c
Log:
Mark unused parameter in server/user_glut.c as S3DUNUSED to fix warnings


Modified: trunk/server/user_glut.c
===================================================================
--- trunk/server/user_glut.c	2007-09-24 02:19:38 UTC (rev 701)
+++ trunk/server/user_glut.c	2007-09-24 02:19:45 UTC (rev 702)
@@ -43,12 +43,12 @@
 	return(0);
 }
 
-void keyboard(uint8_t key, int x, int y)
+void keyboard(uint8_t key, int S3DUNUSED(x), int S3DUNUSED(y))
 {
 	user_key(key, key, 0, 0);
 	user_key(key, key, 0, 1);
 }
-void special(int skey, int x, int y)
+void special(int skey, int S3DUNUSED(x), int S3DUNUSED(y))
 {
 	uint16_t mkey;
 	switch (skey) { /* handle special keys */



From lazhur at mail.berlios.de  Mon Sep 24 04:19:55 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 24 Sep 2007 04:19:55 +0200
Subject: [S3d-svn] r703 - in trunk: libs3d server
Message-ID: <200709240219.l8O2Jtiq012845@sheep.berlios.de>

Author: lazhur
Date: 2007-09-24 04:19:55 +0200 (Mon, 24 Sep 2007)
New Revision: 703

Modified:
   trunk/libs3d/shm.c
   trunk/server/proto.c
Log:
Minor code beautifyings in server and libs3d


Modified: trunk/libs3d/shm.c
===================================================================
--- trunk/libs3d/shm.c	2007-09-24 02:19:45 UTC (rev 702)
+++ trunk/libs3d/shm.c	2007-09-24 02:19:55 UTC (rev 703)
@@ -140,8 +140,8 @@
 			s3dprintf(HIGH, "shm_writen():waited too long ...");
 			return(-1);
 		}
-		if (wait>10)
-		   nanosleep(&t,NULL); 
+		if (wait > 10)
+			nanosleep(&t, NULL);
 	}
 	return(s - no_left);
 }
@@ -161,8 +161,8 @@
 			s3dprintf(HIGH, "shm_readn():waited too long ...");
 			return(-1);
 		}
-		if (wait>10)
-		   nanosleep(&t,NULL); 
+		if (wait > 10)
+			nanosleep(&t, NULL);
 	}
 	return(s - no_left);
 }

Modified: trunk/server/proto.c
===================================================================
--- trunk/server/proto.c	2007-09-24 02:19:45 UTC (rev 702)
+++ trunk/server/proto.c	2007-09-24 02:19:55 UTC (rev 703)
@@ -294,7 +294,7 @@
 			h = ntohs(*((uint16_t *)cptr));
 			cptr += 2;
 			num = length - 16;
-			s3dprintf(MED,"LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)",length, oid,toid,w,h,x,y,num,w*h*4,num); 
+			s3dprintf(MED, "LOAD_TEX[%d]: oid %d, texture %d, [%d x %d] data at [%d x %d] (%d = %d)", length, oid, toid, w, h, x, y, num, w*h*4, num);
 			if ((w*h*4) == num)  /*  check correct size */
 				obj_load_tex(p, oid, toid, x, y, w, h, cptr);
 		}



From lazhur at mail.berlios.de  Mon Sep 24 04:29:06 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 24 Sep 2007 04:29:06 +0200
Subject: [S3d-svn] r704 - trunk/server
Message-ID: <200709240229.l8O2T6Rn013189@sheep.berlios.de>

Author: lazhur
Date: 2007-09-24 04:29:06 +0200 (Mon, 24 Sep 2007)
New Revision: 704

Modified:
   trunk/server/object.c
Log:
Fix calculation of source pixels in tex_build_mipmaps


Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-09-24 02:19:55 UTC (rev 703)
+++ trunk/server/object.c	2007-09-24 02:29:06 UTC (rev 704)
@@ -1475,10 +1475,10 @@
 			for (x = 0; x < w; x++)
 				for (c = 0; c < 4; c++) {
 					buf[(y * w + x)*4 + c] = ((uint16_t)
-					                          src[(2  * y      * w + 2 * x)     * 4 + c] +
-					                          src[((2 * y + 1) * w + 2 * x)     * 4 + c] +
-					                          src[(2  * y      * w + 2 * x + 1) * 4 + c] +
-					                          src[((2 * y + 1) * w + 2 * x + 1) * 4 + c]) / 4;
+					                          src[(2  * y      * 2 * w + 2 * x)     * 4 + c] +
+					                          src[((2 * y + 1) * 2 * w + 2 * x)     * 4 + c] +
+					                          src[(2  * y      * 2 * w + 2 * x + 1) * 4 + c] +
+					                          src[((2 * y + 1) * 2 * w + 2 * x + 1) * 4 + c]) / 4;
 					/*     s3dprintf(MED,"texture: %d, x = %d, y = %d, c = %d, buf = %02x\n", i, x, y, c, buf[(y * w + x)*4 + c]);*/
 
 				}



From dotslash at mail.berlios.de  Mon Sep 24 12:50:41 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 24 Sep 2007 12:50:41 +0200
Subject: [S3d-svn] r705 - in trunk: . apps/comptest
Message-ID: <200709241050.l8OAof58026682@sheep.berlios.de>

Author: dotslash
Date: 2007-09-24 12:50:39 +0200 (Mon, 24 Sep 2007)
New Revision: 705

Modified:
   trunk/
   trunk/apps/comptest/comptest.c
Log:
 r2465 at kero:  dotslash | 2007-09-24 12:50:24 +0200
 - remove warnings for comptest



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2452
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2465

Modified: trunk/apps/comptest/comptest.c
===================================================================
--- trunk/apps/comptest/comptest.c	2007-09-24 02:29:06 UTC (rev 704)
+++ trunk/apps/comptest/comptest.c	2007-09-24 10:50:39 UTC (rev 705)
@@ -31,7 +31,18 @@
 #include <X11/extensions/Xcomposite.h>
 #include <X11/extensions/Xdamage.h>
 #include <X11/extensions/Xrender.h>
+#include <config-s3d.h>
 
+#ifndef COMPUNUSED
+#if defined(UNUSEDPARAM_ATTRIBUTE)
+#define COMPUNUSED(x) (x)__attribute__((unused))
+#elif defined(UNUSEDPARAM_OMIT)
+#define COMPUNUSED(x) /* x */
+#else
+#define COMPUNUSED(x) x
+#endif
+#endif
+
 struct extension {
 	int event, error;
 };
@@ -79,7 +90,7 @@
 	return(i);
 }
 
-static int error(Display *dpy, XErrorEvent *event)
+static int error(Display *COMPUNUSED(dpy), XErrorEvent *COMPUNUSED(event))
 {
 	/*    printf ("error %d request %d minor %d serial %d\n",
 	        event->error_code, event->request_code, event->minor_code, event->serial);*/
@@ -218,7 +229,7 @@
 	int xi, yi;
 	int rs, gs, bs;
 	int bpp;
-	unsigned char *img_ptr, *bmp_ptr;
+	char *img_ptr, *bmp_ptr;
 	unsigned long *s;
 	uint32_t *t;
 	XImage *image;
@@ -272,7 +283,7 @@
 			bmp_ptr = win->bitmap + ((y + yi) * win->attr.width + x) * sizeof(uint32_t);
 		}
 		/*  s3d_load_texture(win->oid,0,x,y,width,height, ???); */
-		s3d_load_texture(win->oid, 0, 0, 0, win->attr.width, win->attr.height, win->bitmap);
+		s3d_load_texture(win->oid, 0, 0, 0, win->attr.width, win->attr.height, (unsigned char *)win->bitmap);
 		/*  swap images */
 	}
 	XDestroyImage(image);
@@ -298,7 +309,7 @@
 		for (scr_no = 0; scr_no < ScreenCount(dpy); scr_no++) {
 			XCompositeRedirectSubwindows(dpy, RootWindow(dpy, scr_no), CompositeRedirectAutomatic);
 			XQueryTree(dpy, RootWindow(dpy, scr_no), &root_return, &parent_return, &children, &nchildren);
-			for (i = 0; i < nchildren; i++)
+			for (i = 0; i < (int)nchildren; i++)
 				window_add(dpy, children[i]);
 			XFree(children);
 		}



From dotslash at mail.berlios.de  Mon Sep 24 15:31:33 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 24 Sep 2007 15:31:33 +0200
Subject: [S3d-svn] r706 - in trunk: . server
Message-ID: <200709241331.l8ODVXn3017835@sheep.berlios.de>

Author: dotslash
Date: 2007-09-24 15:31:33 +0200 (Mon, 24 Sep 2007)
New Revision: 706

Modified:
   trunk/
   trunk/server/object.c
Log:
 r2467 at kero:  dotslash | 2007-09-24 15:31:28 +0200
 - don't allow textures with width or height 0



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2465
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2467

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-09-24 10:50:39 UTC (rev 705)
+++ trunk/server/object.c	2007-09-24 13:31:33 UTC (rev 706)
@@ -282,7 +282,8 @@
 				obj->p_tex[m+i].gl_texnum = -1;
 				obj->p_tex[m+i].tw = *(px++);
 				obj->p_tex[m+i].th = *(px++);
-				if ((obj->p_tex[m+i].tw <= TEXTURE_MAX_W) && (obj->p_tex[m+i].th <= TEXTURE_MAX_H)) {
+				if ((obj->p_tex[m+i].tw <= TEXTURE_MAX_W) && (obj->p_tex[m+i].th <= TEXTURE_MAX_H) &&
+						(obj->p_tex[m+i].tw > 0) && (obj->p_tex[m+i].th > 0)) {
 					d = log((double)obj->p_tex[m+i].tw) / log(2.0);
 					hm = pow(2, floor(d));
 					s3dprintf(MED, "hm %d, tw %d", hm, obj->p_tex[m+i].tw);



From dotslash at mail.berlios.de  Mon Sep 24 16:51:07 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 24 Sep 2007 16:51:07 +0200
Subject: [S3d-svn] r707 - in trunk: . server
Message-ID: <200709241451.l8OEp7q8025106@sheep.berlios.de>

Author: dotslash
Date: 2007-09-24 16:51:06 +0200 (Mon, 24 Sep 2007)
New Revision: 707

Modified:
   trunk/
   trunk/server/allocate.c
   trunk/server/global.h
   trunk/server/proto.c
Log:
 r2469 at kero:  dotslash | 2007-09-24 16:51:00 +0200
 - activate memory integrity check on each call in debugging mode
 - fix forgotten ntohl() when pepping material textures



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2467
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2469

Modified: trunk/server/allocate.c
===================================================================
--- trunk/server/allocate.c	2007-09-24 13:31:33 UTC (rev 706)
+++ trunk/server/allocate.c	2007-09-24 14:51:06 UTC (rev 707)
@@ -93,6 +93,8 @@
 	struct chunkTrailer *chunkTrailer;
 	unsigned char *chunk;
 
+	checkIntegrity();
+
 	/*  printf("sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\n", sizeof (struct chunkHeader), sizeof (struct chunkTrailer)); */
 
 	memory = malloc(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer));
@@ -126,6 +128,8 @@
 	unsigned char *result;
 	unsigned int copyLength;
 
+	checkIntegrity();
+
 	if (memoryParameter) { /* if memoryParameter==NULL, realloc() should work like malloc() !! */
 		memory = memoryParameter;
 		chunkHeader = (struct chunkHeader *)(memory - sizeof(struct chunkHeader));
@@ -167,6 +171,8 @@
 	struct chunkHeader *walker;
 	struct chunkHeader *previous;
 
+	checkIntegrity();
+
 	memory = memoryParameter;
 	chunkHeader = (struct chunkHeader *)(memory - sizeof(struct chunkHeader));
 

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2007-09-24 13:31:33 UTC (rev 706)
+++ trunk/server/global.h	2007-09-24 14:51:06 UTC (rev 707)
@@ -385,7 +385,7 @@
 int  cull_sphere_in_frustum(struct t_vertex *center, float radius);
 
 /* allocate.c */
-#if DEBUG <= VLOW
+#if DEBUG <= HIGH
 #include <stdlib.h>
 void checkIntegrity(void);
 void checkLeak(void);

Modified: trunk/server/proto.c
===================================================================
--- trunk/server/proto.c	2007-09-24 13:31:33 UTC (rev 706)
+++ trunk/server/proto.c	2007-09-24 14:51:06 UTC (rev 707)
@@ -220,6 +220,9 @@
 			cptr += 4;
 			num = (length - 4) / (4);
 			s3dprintf(VLOW, "PEP_MAT_TEX[%d]: %d materials for object oid...%d", length, num, oid);
+			for (i = 0;i < num;i++)
+				*((uint32_t *)cptr + i) =
+				        ntohl(*((uint32_t *)cptr + i));
 			obj_pep_mat_tex(p, oid, (uint32_t *)cptr, num);
 		}
 		break;



From dotslash at mail.berlios.de  Mon Sep 24 20:37:49 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 24 Sep 2007 20:37:49 +0200
Subject: [S3d-svn] r708 - in trunk: . server
Message-ID: <200709241837.l8OIbnVv022627@sheep.berlios.de>

Author: dotslash
Date: 2007-09-24 20:37:48 +0200 (Mon, 24 Sep 2007)
New Revision: 708

Modified:
   trunk/
   trunk/server/object.c
Log:
 r2471 at kero:  dotslash | 2007-09-24 20:37:36 +0200
 - fix output (m-1 vs m)
 - fix off by one error when loading things into textures
 - don't add the big texture twice.



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2469
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2471

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-09-24 14:51:06 UTC (rev 707)
+++ trunk/server/object.c	2007-09-24 18:37:48 UTC (rev 708)
@@ -349,7 +349,7 @@
 			glDeleteLists(obj->dplist, 1);
 			obj->dplist = 0;
 		}
-		s3dprintf(VLOW, "pepping poly's %d to %d", (m - n), m);
+		s3dprintf(VLOW, "pepping poly's %d to %d", (m - n), m - 1);
 		for (i = (m - n);i < m;i++) {
 			for (j = 0;j < 3;j++) {
 				obj->p_poly[i].n[j].x = *(px++);
@@ -393,7 +393,7 @@
 			glDeleteLists(obj->dplist, 1);
 			obj->dplist = 0;
 		}
-		s3dprintf(VLOW, "pepping line's %d to %d", (m - n), m);
+		s3dprintf(VLOW, "pepping line's %d to %d", (m - n), m - 1);
 		for (i = (m - n);i < m;i++) {
 			for (j = 0;j < 2;j++) {
 				obj->p_line[i].n[j].x = *(px++);
@@ -439,7 +439,7 @@
 			glDeleteLists(obj->dplist, 1);
 			obj->dplist = 0;
 		}
-		s3dprintf(VLOW, "pepping poly's %d to %d", (m - n), m);
+		s3dprintf(VLOW, "pepping poly's %d to %d", (m - n), m - 1);
 		for (i = (m - n);i < m;i++) {
 			for (j = 0;j < 3;j++) {
 				obj->p_poly[i].tc[j].x = *(px++);
@@ -472,7 +472,7 @@
 			glDeleteLists(obj->dplist, 1);
 			obj->dplist = 0;
 		}
-		s3dprintf(VLOW, "pepping mats %d to %d", (m - n), m);
+		s3dprintf(VLOW, "pepping mats %d to %d", (m - n), m - 1);
 		for (i = (m - n);i < m;i++) {
 			obj->p_mat[i].amb_r = *(px++);
 			obj->p_mat[i].amb_g = *(px++);
@@ -513,7 +513,7 @@
 			glDeleteLists(obj->dplist, 1);
 			obj->dplist = 0;
 		}
-		s3dprintf(VLOW, "pepping lines %d to %d", (m - n), m);
+		s3dprintf(VLOW, "pepping lines %d to %d", (m - n), m - 1);
 		for (i = (m - n);i < m;i++) {
 			obj->p_line[i].v[0] = *(px++);
 			obj->p_line[i].v[1] = *(px++);
@@ -609,7 +609,7 @@
 			glDeleteLists(obj->dplist, 1);
 			obj->dplist = 0;
 		}
-		s3dprintf(MED, "pepping mats %d to %d", (m - n), m);
+		s3dprintf(MED, "pepping mats %d to %d", (m - n), m - 1);
 		for (i = (m - n);i < m;i++)
 			obj->p_mat[i].tex = *(px++);
 	} else {
@@ -796,7 +796,7 @@
 	struct t_obj *obj;
 	struct t_tex *t;
 	int32_t i, p1, p2, m;
-	int16_t mw;
+	int16_t mw, mh;
 	if (OBJ_VALID(p, oid, obj)) {
 		if (obj->oflags&OF_NODATA) {
 			errds(MED, "obj_load_tex()", "error: no data on object allowed!");
@@ -812,22 +812,33 @@
 					obj->dplist = 0;
 				}
 
-				m = (t->w - 1) * t->th + t->tw;     /*  maximum: position of the last pixel in the buffer */
-				if ((x + w) > t->tw) mw = (t->tw - x);
-				else mw = w;
+				m = t->w * t->th + t->tw;     /*  maximum: position of the last pixel in the buffer */
+				if ((x + w) > t->tw) 
+					mw = (t->tw - x);
+				else 
+					mw = w;
+				if ((y + h) > t->th) 
+					mh = (t->th - y);
+				else 
+					mh = h;
+
 				if (mw <= 0)  /*  nothing to do */
+				{
+					s3dprintf(MED,"oid %d: texture %d: update out of range\n", oid, tex);
 					return(-1);
-				for (i = 0;i < h;i++) {
+				}
+				for (i = 0;i < mh;i++) {
 					p1 = (y + i) * t->w + x;  /*  scanline start position */
 					p2 = mw;  /*  and length */
-					if (p1 > m)
-						return(0);   /*  need to break here. */
-					if ((p1 + w) > m)
-						p2 = m - p1;  /*  only draw a part of the scanline */
+					if (p1 > m) {
+						s3dprintf(MED,"oid %d: texture %d: assert: we shouldn't break here.\n", oid, tex);
+						break;   /*  need to break here. */
+					}
 					memcpy(t->buf + 4*p1,    /*  draw at p1 position ... */
 					       pixbuf + 4*i*w,   /*  scanline number i ... */
 					       4*p2);
 				}
+				s3dprintf(MED, "updating texture %d\n",t->gl_texnum);
 				obj_update_tex(t, x, y, w, h, pixbuf);
 				return(0);
 			} else {
@@ -1499,14 +1510,15 @@
 	if (m->tex < obj->n_tex) {
 		tex = &obj->p_tex[m->tex];
 		if (tex->buf != NULL) { /*  texture seems to be okay, select it. */
-			matgl[0] = 0.9f;
-			matgl[1] = 0.9f;
-			matgl[2] = 0.9f;
+			matgl[0] = 1.0f;
+			matgl[1] = 1.0f;
+			matgl[2] = 1.0f;
 			matgl[3] = 1.0f;
 			glMaterialfv(GL_FRONT, GL_AMBIENT, matgl);
 			glMaterialfv(GL_FRONT, GL_DIFFUSE, matgl);
 			glMaterialfv(GL_FRONT, GL_SPECULAR, matgl);
 			if (tex->gl_texnum != -1) {
+				s3dprintf(HIGH, "already have texture %d [%dx%d, in memory %dx%d]", tex->gl_texnum, tex->tw, tex->th, tex->w, tex->h);
 				glBindTexture(GL_TEXTURE_2D, tex->gl_texnum);
 			} else {
 				glGenTextures(1, &t);
@@ -1524,19 +1536,14 @@
 				    }*/
 				/*  texture has to be generated yet ... */
 				tex_build_mipmaps(tex);
-				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
-				             tex->w, tex->h, 0,  /*  no border. */
-				             GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);
+/*				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
+				             tex->w, tex->h, 0,  / *  no border. * /
+				             GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);*/
 
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
 				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-
-				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
-				                GL_LINEAR);
-				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
-				                GL_LINEAR);
-				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
-				                GL_LINEAR_MIPMAP_LINEAR);
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
 			}
 		} else { /* . can't use a texture  */
 			tex = NULL;



From dotslash at mail.berlios.de  Mon Sep 24 21:04:49 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 24 Sep 2007 21:04:49 +0200
Subject: [S3d-svn] r709 - in trunk: . server
Message-ID: <200709241904.l8OJ4nn9023746@sheep.berlios.de>

Author: dotslash
Date: 2007-09-24 21:04:48 +0200 (Mon, 24 Sep 2007)
New Revision: 709

Modified:
   trunk/
   trunk/server/object.c
Log:
 r2473 at kero:  dotslash | 2007-09-24 21:04:44 +0200
 - don't generate textures while compiling the display list. 



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2471
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2473

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-09-24 18:37:48 UTC (rev 708)
+++ trunk/server/object.c	2007-09-24 19:04:48 UTC (rev 709)
@@ -1500,7 +1500,37 @@
 	}
 	free(buf);
 }
+/* generate textures */
+void texture_gen(struct t_obj *obj) 
+{
+	GLuint t;
+	int i;
+	struct t_tex *tex = NULL;
+	for (i=0; i < obj->n_tex; i++) {
+		tex = &obj->p_tex[i];
+		if (tex->gl_texnum == -1) {
+			glGenTextures(1, &t);
+			glBindTexture(GL_TEXTURE_2D, t);
+			tex->gl_texnum = t;
+			s3dprintf(HIGH, "generated texture %d [%dx%d, in memory %dx%d]", t, tex->tw, tex->th, tex->w, tex->h);
+			/*    for (j=0;j<tex->th;j++)
+			    for (i=0;i<tex->tw;i++)
+			    {
+			     s3dprintf(MED,"pixel[%d,%d], %d %d %d %d",i,j,
+			         tex->buf[(j*tex->w+i)*4+0],
+			         tex->buf[(j*tex->w+i)*4+1],
+			         tex->buf[(j*tex->w+i)*4+2],
+			         tex->buf[(j*tex->w+i)*4+3]);
+			    }*/
+			/*  texture has to be generated yet ... */
+			tex_build_mipmaps(tex);
+/*			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
+			             tex->w, tex->h, 0,  / *  no border. * /
+			             GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);*/
 
+		}
+	}
+}
 /* activate/bind texture for object */
 struct t_tex *get_texture(struct t_obj *obj, struct t_mat *m) {
 	GLuint t;
@@ -1509,7 +1539,7 @@
 	/*  int i,j; */
 	if (m->tex < obj->n_tex) {
 		tex = &obj->p_tex[m->tex];
-		if (tex->buf != NULL) { /*  texture seems to be okay, select it. */
+		if (tex->buf != NULL && tex->gl_texnum != -1) { /*  texture seems to be okay, select it. */
 			matgl[0] = 1.0f;
 			matgl[1] = 1.0f;
 			matgl[2] = 1.0f;
@@ -1517,35 +1547,14 @@
 			glMaterialfv(GL_FRONT, GL_AMBIENT, matgl);
 			glMaterialfv(GL_FRONT, GL_DIFFUSE, matgl);
 			glMaterialfv(GL_FRONT, GL_SPECULAR, matgl);
-			if (tex->gl_texnum != -1) {
-				s3dprintf(HIGH, "already have texture %d [%dx%d, in memory %dx%d]", tex->gl_texnum, tex->tw, tex->th, tex->w, tex->h);
-				glBindTexture(GL_TEXTURE_2D, tex->gl_texnum);
-			} else {
-				glGenTextures(1, &t);
-				glBindTexture(GL_TEXTURE_2D, t);
-				tex->gl_texnum = t;
-				s3dprintf(HIGH, "generated texture %d [%dx%d, in memory %dx%d]", t, tex->tw, tex->th, tex->w, tex->h);
-				/*    for (j=0;j<tex->th;j++)
-				    for (i=0;i<tex->tw;i++)
-				    {
-				     s3dprintf(MED,"pixel[%d,%d], %d %d %d %d",i,j,
-				         tex->buf[(j*tex->w+i)*4+0],
-				         tex->buf[(j*tex->w+i)*4+1],
-				         tex->buf[(j*tex->w+i)*4+2],
-				         tex->buf[(j*tex->w+i)*4+3]);
-				    }*/
-				/*  texture has to be generated yet ... */
-				tex_build_mipmaps(tex);
-/*				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
-				             tex->w, tex->h, 0,  / *  no border. * /
-				             GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);*/
-
-				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
-			}
-		} else { /* . can't use a texture  */
+			s3dprintf(VLOW, "already have texture %d [%dx%d, in memory %dx%d]", tex->gl_texnum, tex->tw, tex->th, tex->w, tex->h);
+			glBindTexture(GL_TEXTURE_2D, tex->gl_texnum);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+			
+		} else { /* can't use a texture  */
 			tex = NULL;
 		}
 	}
@@ -1572,6 +1581,7 @@
 	if (obj->oflags&OF_SYSTEM)  return(-1);      /* can't render system objects */
 	if (obj->oflags&OF_CLONE)  obj = p->object[obj->n_vertex];  /* it's a clone - draw the clone! */
 	if (!obj->dplist) {
+		texture_gen(obj);
 		obj->dplist = glGenLists(1);
 		if (obj->dplist) glNewList(obj->dplist, GL_COMPILE); /* only compile and calling later should save time. maybe. */
 		else     s3dprintf(LOW, "couldn't get a new list :/");



From dotslash at mail.berlios.de  Mon Sep 24 21:12:05 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 24 Sep 2007 21:12:05 +0200
Subject: [S3d-svn] r710 - in trunk: . apps/comptest
Message-ID: <200709241912.l8OJC5Gf024114@sheep.berlios.de>

Author: dotslash
Date: 2007-09-24 21:12:05 +0200 (Mon, 24 Sep 2007)
New Revision: 710

Modified:
   trunk/
   trunk/apps/comptest/comptest.c
Log:
 r2475 at kero:  dotslash | 2007-09-24 21:12:01 +0200
 - use multiple textures (256x256) for performance reasons
 - don't store bitmap in program
 - it's a bit dirty again ... ;)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2473
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:2475

Modified: trunk/apps/comptest/comptest.c
===================================================================
--- trunk/apps/comptest/comptest.c	2007-09-24 19:04:48 UTC (rev 709)
+++ trunk/apps/comptest/comptest.c	2007-09-24 19:12:05 UTC (rev 710)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2007 Simon Wunderlich <dotslash at packetmixer.de>
  *
- * This file is part of comptest, a one-day-proof-of-concept composite manager hack.
+ * This file is part of comptest, a proof-of-concept composite manager hack.
  * See http://s3d.berlios.de/ for more updates.
  *
  * olsrs3d is free software; you can redistribute it and/or modify
@@ -43,6 +43,9 @@
 #endif
 #endif
 
+#define TEXW	256
+#define TEXH	256
+
 struct extension {
 	int event, error;
 };
@@ -58,7 +61,6 @@
 	int        oid;
 	int        no;
 
-	char      *bitmap;  /* bitmap to upload */
 	struct window     *next;
 };
 
@@ -130,7 +132,7 @@
 
 void deco_box(struct window *win)
 {
-	float vertices[8*3] = {
+/*	float vertices[8*3] = {
 		0, 0, 0,
 		1, 0, 0,
 		1, 1, 0,
@@ -155,27 +157,30 @@
 		0, 1, 2, 0,
 		0, 2, 3, 0
 
-	};
+	};*/
 	float tbuf[] = { 0.0, 0.0,  1.0, 0.0,  1.0, 1.0,
 	                 0.0, 0.0,  1.0, 1.0,  0.0, 1.0
 	               };
-	int i;
+/*	int i;*/
+	int x, y;
+	int vindex, voffset, pindex;
+	int	xpos, ypos;
 
 	win->no = win_no++;  /* TODO: REMOVE */
 	win->oid = s3d_new_object();
-
+/*
 	for (i = 0;i < 8;i++) {
 		sver[i*3 + 0] = vertices[i*3+0] * win->attr.width / 20;
 		sver[i*3 + 1] = vertices[i*3+1] * -win->attr.height / 20;
 		sver[i*3 + 2] = vertices[i*3+2] * -1;
 	}
-
+	
 	s3d_push_material_a(win->oid,
 	                    0.8, 0.0, 0.0 , 1.0,
 	                    1.0, 1.0, 1.0 , 1.0,
 	                    0.8, 0.0, 0.0 , 1.0);
 	s3d_push_texture(win->oid, win->attr.width, win->attr.height);
-	s3d_pep_material_texture(win->oid, 0); /*  assign texture 0 to material 0 */
+	s3d_pep_material_texture(win->oid, 0); / *  assign texture 0 to material 0 * /
 	s3d_push_material_a(win->oid,
 	                    0.0, 0.8, 0.0 , 1.0,
 	                    1.0, 1.0, 1.0 , 1.0,
@@ -184,11 +189,41 @@
 	s3d_push_vertices(win->oid, sver, 8);
 
 	s3d_push_polygons(win->oid, polygon, 12);
-	s3d_pep_polygon_tex_coords(win->oid, tbuf, 2);
+	s3d_pep_polygon_tex_coords(win->oid, tbuf, 2);*/
+	voffset = 1;
+	vindex = 0;
+	pindex = 0;
+	s3d_push_vertex(win->oid, 0, 0, -1);			/* the first point */
+
+	for (y = 0; y < win->attr.height; y+= TEXH) {	/* the first column */
+		ypos = (y + TEXH > win->attr.height) ? win->attr.height : y + TEXH ;
+		s3d_push_vertex(win->oid, 0, -((float)ypos) / 20, -1);
+		voffset++;
+	}
+	for (x = 0; x < win->attr.width; x+= TEXW) {	/* the first row */
+		xpos = (x + TEXW > win->attr.width) ? win->attr.width : x + TEXW ;
+		s3d_push_vertex(win->oid, ((float)xpos) / 20, 0, -1);
+
+		for (y = 0; y < win->attr.height; y+= TEXH) {
+			ypos = (y + TEXH > win->attr.height) ? win->attr.height : y + TEXH  ;
+			s3d_push_vertex(win->oid, ((float)xpos) / 20, -((float)ypos) / 20, -1);
+			s3d_push_material_a(win->oid,
+		                    0.0, 0.8, 0.0 , 1.0,
+		                    1.0, 1.0, 1.0 , 1.0,
+		                    0.0, 0.8, 0.0 , 1.0);
+			s3d_push_texture(win->oid, xpos - x, ypos - y);
+			s3d_pep_material_texture(win->oid, pindex); 
+			s3d_push_polygon(win->oid, vindex, vindex + voffset, vindex + voffset + 1, pindex);
+			s3d_push_polygon(win->oid, vindex, vindex + voffset + 1, vindex + 1, pindex);
+			s3d_pep_polygon_tex_coords(win->oid, tbuf, 2);
+			pindex++;
+			vindex++;
+		}
+		vindex++;
+	}
 	s3d_translate(win->oid, win->attr.x / 20, -win->attr.y / 20, 5 * win->no);
 	/*  push data on texture 0 position (0,0) */
 	s3d_flags_on(win->oid, S3D_OF_VISIBLE);
-
 }
 
 void window_add(Display *dpy, Window id)
@@ -210,7 +245,6 @@
 
 		win->oid = 0;
 
-		win->bitmap = NULL;
 		window_update(win, 0, 0, win->attr.width, win->attr.height);
 
 		win->next = window_head;
@@ -226,69 +260,92 @@
 
 void window_update(struct window *win, int x, int y, int width, int height)
 {
+	int chunk_width, chunk_height;
+	int xleft, xright;
+	int ytop, ybottom;
+	int texnum;
 	int xi, yi;
 	int rs, gs, bs;
 	int bpp;
 	char *img_ptr, *bmp_ptr;
+	char *bitmap;
 	unsigned long *s;
 	uint32_t *t;
 	XImage *image;
 
-	/* printf("[D]oing window update for window %d at position %d:%d with size %dx%d\n",win->id, x,y,width,height);*/
-	image = XGetImage(dpy, win->id, x, y, win->attr.width, win->attr.height, AllPlanes, ZPixmap);
-	if (!image) {
-		/*  printf("[P]roblem with the image\n");*/
-		return;
-	}
-	if (!win->bitmap)
-		win->bitmap = malloc(win->attr.width * win->attr.height * sizeof(uint32_t));
-	if (!win->oid)
+	/* update the whole window for now. */
+	x = 0;
+	y = 0;
+	width = win->attr.width;
+	height = win->attr.height;
+
+	texnum = 0;
+
+
+/*	if (!win->oid)
 		deco_box(win);
-	if (image->format == ZPixmap) {
-		printf("XImage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n",
-		       image->width, image->height, image->format,
-		       ZPixmap, image->bits_per_pixel, image->depth, image->bitmap_pad);
-		rs = get_shift(image->red_mask) - 8;
-		gs = get_shift(image->green_mask) - 8;
-		bs = get_shift(image->blue_mask) - 8;
+*/
+	for (xleft = 0; xleft < width ; xleft += TEXW) {
+		xright = (xleft + TEXW > width) ? width : xleft + TEXW;
+		chunk_width = xright - xleft;
+		image = XGetImage(dpy, win->id, xleft, y, chunk_width, win->attr.height, AllPlanes, ZPixmap);
+		if (!image) 
+			return;
+		bitmap = malloc( chunk_width * height * sizeof(uint32_t));
+		if (!win->oid)
+			deco_box(win);
+		if (image->format == ZPixmap) {
+			printf("XImage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n",
+				   image->width, image->height, image->format,
+				   ZPixmap, image->bits_per_pixel, image->depth, image->bitmap_pad);
+			rs = get_shift(image->red_mask) - 8;
+			gs = get_shift(image->green_mask) - 8;
+			bs = get_shift(image->blue_mask) - 8;
 
-		bpp = (image->bits_per_pixel / 8);
-		/* rgb is not bgr */
-		rs = rs;
-		gs = gs - 8;
-		bs = bs - 16;
-		printf("Ximage: rgb: %d|%d|%d\n", rs, gs, bs);;
-		/*  printf("red: size %d, offset %d\n",rs,roff);
-		  printf("green: size %d, offset %d\n",gs,goff);
-		  printf("blue: size %d, offset %d\n",bs,boff);
-		  printf("bits per pixel:%d\n",bpp);*/
-		for (yi = 0; yi < height ; yi++) {
-			img_ptr = image->data + (yi * width) * bpp;
-			bmp_ptr = win->bitmap + ((y + yi) * win->attr.width + x) * sizeof(uint32_t);
-			for (xi = 0; xi < width; xi++) {
-				s = (unsigned long *)img_ptr;
-				t = (uint32_t *)bmp_ptr;
-				/*    bmp_ptr[0] = (rs > 0 ? ((*d & image->red_mask) >> rs)  : ((*d  & image->red_mask) << -rs)) ;
-				    bmp_ptr[1] = (gs > 0 ? ((*d & image->green_mask) >> gs) : ((*d  & image->green_mask) << -gs)) ;
-				    bmp_ptr[2] = (bs > 0 ? ((*d & image->blue_mask) >> bs)  : ((*d  & image->blue_mask) << -bs));
-				    bmp_ptr[3] = 255 ;*/
-				*t = (rs > 0 ? ((*s & image->red_mask) >> rs)  : ((*s  & image->red_mask) << -rs)) |
-				     (gs > 0 ? ((*s & image->green_mask) >> gs) : ((*s  & image->green_mask) << -gs)) |
-				     (bs > 0 ? ((*s & image->blue_mask) >> bs)  : ((*s  & image->blue_mask) << -bs)) |
-				     255 << 24;
+			bpp = (image->bits_per_pixel / 8);
+			/* rgb is not bgr */
+			rs = rs;
+			gs = gs - 8;
+			bs = bs - 16;
+			printf("Ximage: rgb: %d|%d|%d\n", rs, gs, bs);;
+			/*  printf("red: size %d, offset %d\n",rs,roff);
+			  printf("green: size %d, offset %d\n",gs,goff);
+			  printf("blue: size %d, offset %d\n",bs,boff);
+			  printf("bits per pixel:%d\n",bpp);*/
+			for (yi = 0; yi < height ; yi++) {
+				img_ptr = image->data + (yi * image->width) * bpp;
+				bmp_ptr = bitmap + ((y + yi) * chunk_width + x) * sizeof(uint32_t);
+				for (xi = 0; xi < xright - xleft; xi++) {
+					s = (unsigned long *)img_ptr;
+					t = (uint32_t *)bmp_ptr;
+					/*    bmp_ptr[0] = (rs > 0 ? ((*d & image->red_mask) >> rs)  : ((*d  & image->red_mask) << -rs)) ;
+						bmp_ptr[1] = (gs > 0 ? ((*d & image->green_mask) >> gs) : ((*d  & image->green_mask) << -gs)) ;
+						bmp_ptr[2] = (bs > 0 ? ((*d & image->blue_mask) >> bs)  : ((*d  & image->blue_mask) << -bs));
+						bmp_ptr[3] = 255 ;*/
+					*t = (rs > 0 ? ((*s & image->red_mask) >> rs)  : ((*s  & image->red_mask) << -rs)) |
+						 (gs > 0 ? ((*s & image->green_mask) >> gs) : ((*s  & image->green_mask) << -gs)) |
+						 (bs > 0 ? ((*s & image->blue_mask) >> bs)  : ((*s  & image->blue_mask) << -bs)) |
+						 255 << 24;
 
-				bmp_ptr += sizeof(uint32_t);
-				img_ptr += bpp;
+					bmp_ptr += sizeof(uint32_t);
+					img_ptr += bpp;
+				}
 			}
-			bmp_ptr = win->bitmap + ((y + yi) * win->attr.width + x) * sizeof(uint32_t);
+			/*  s3d_load_texture(win->oid,0,x,y,width,height, ???); */
+			for (ytop = 0; ytop < height; ytop += TEXH) {
+				ybottom = (ytop + TEXH > height) ? height : ytop + TEXH;
+				chunk_height = ybottom - ytop;
+				s3d_load_texture(win->oid, texnum, 0, 0, chunk_width, chunk_height, (unsigned char *)bitmap + chunk_width * ytop * 4);
+				texnum++;
+			}
+			/*  swap images */
 		}
-		/*  s3d_load_texture(win->oid,0,x,y,width,height, ???); */
-		s3d_load_texture(win->oid, 0, 0, 0, win->attr.width, win->attr.height, (unsigned char *)win->bitmap);
-		/*  swap images */
+		XDestroyImage(image);
+		free(bitmap);
 	}
-	XDestroyImage(image);
 }
 
+
 void event()
 {
 	/* XNextEvent (dpy, &ev);*/



From lazhur at mail.berlios.de  Mon Sep 24 21:37:36 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 24 Sep 2007 21:37:36 +0200
Subject: [S3d-svn] r711 - trunk/apps/dot_mcp
Message-ID: <200709241937.l8OJbadE025937@sheep.berlios.de>

Author: lazhur
Date: 2007-09-24 21:37:35 +0200 (Mon, 24 Sep 2007)
New Revision: 711

Modified:
   trunk/apps/dot_mcp/menu.c
Log:
dot_mcp: translate menu in correct direction


Modified: trunk/apps/dot_mcp/menu.c
===================================================================
--- trunk/apps/dot_mcp/menu.c	2007-09-24 19:12:05 UTC (rev 710)
+++ trunk/apps/dot_mcp/menu.c	2007-09-24 19:37:35 UTC (rev 711)
@@ -83,13 +83,13 @@
 	go = s3d_import_model_file("objs/s3dstart.3ds");
 	s3d_flags_on(go, S3D_OF_VISIBLE | S3D_OF_SELECTABLE);
 	s3d_link(go, menu_o);
-	for (i = 0;i < (sizeof(menu) / sizeof(struct menu_entry));i++) {
+	for (i = 0; i < (sizeof(menu) / sizeof(struct menu_entry)); i++) {
 		if (-1 == (menu[i].icon_oid = s3d_import_model_file(menu[i].icon)))
 			menu[i].icon_oid = s3d_new_object();
 		menu[i].str_oid = s3d_draw_string(menu[i].name, NULL);
 		s3d_link(menu[i].str_oid, menu[i].icon_oid);
 		s3d_link(menu[i].icon_oid, menu_o);
-		s3d_translate(menu[i].icon_oid, 0, -3 + (-3*i), 0);
+		s3d_translate(menu[i].icon_oid, 0, -3 + (-3 * (signed)i), 0);
 		s3d_translate(menu[i].str_oid, 2, 0, 0);
 		/*  s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 		  s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);*/



From lazhur at mail.berlios.de  Mon Sep 24 21:37:46 2007
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Mon, 24 Sep 2007 21:37:46 +0200
Subject: [S3d-svn] r712 - trunk/server
Message-ID: <200709241937.l8OJbkQo026001@sheep.berlios.de>

Author: lazhur
Date: 2007-09-24 21:37:45 +0200 (Mon, 24 Sep 2007)
New Revision: 712

Modified:
   trunk/server/object.c
Log:
server: Remove unused variables


Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2007-09-24 19:37:35 UTC (rev 711)
+++ trunk/server/object.c	2007-09-24 19:37:45 UTC (rev 712)
@@ -283,7 +283,7 @@
 				obj->p_tex[m+i].tw = *(px++);
 				obj->p_tex[m+i].th = *(px++);
 				if ((obj->p_tex[m+i].tw <= TEXTURE_MAX_W) && (obj->p_tex[m+i].th <= TEXTURE_MAX_H) &&
-						(obj->p_tex[m+i].tw > 0) && (obj->p_tex[m+i].th > 0)) {
+				                (obj->p_tex[m+i].tw > 0) && (obj->p_tex[m+i].th > 0)) {
 					d = log((double)obj->p_tex[m+i].tw) / log(2.0);
 					hm = pow(2, floor(d));
 					s3dprintf(MED, "hm %d, tw %d", hm, obj->p_tex[m+i].tw);
@@ -813,32 +813,31 @@
 				}
 
 				m = t->w * t->th + t->tw;     /*  maximum: position of the last pixel in the buffer */
-				if ((x + w) > t->tw) 
+				if ((x + w) > t->tw)
 					mw = (t->tw - x);
-				else 
+				else
 					mw = w;
-				if ((y + h) > t->th) 
+				if ((y + h) > t->th)
 					mh = (t->th - y);
-				else 
+				else
 					mh = h;
 
-				if (mw <= 0)  /*  nothing to do */
-				{
-					s3dprintf(MED,"oid %d: texture %d: update out of range\n", oid, tex);
+				if (mw <= 0) { /*  nothing to do */
+					s3dprintf(MED, "oid %d: texture %d: update out of range\n", oid, tex);
 					return(-1);
 				}
 				for (i = 0;i < mh;i++) {
 					p1 = (y + i) * t->w + x;  /*  scanline start position */
 					p2 = mw;  /*  and length */
 					if (p1 > m) {
-						s3dprintf(MED,"oid %d: texture %d: assert: we shouldn't break here.\n", oid, tex);
+						s3dprintf(MED, "oid %d: texture %d: assert: we shouldn't break here.\n", oid, tex);
 						break;   /*  need to break here. */
 					}
 					memcpy(t->buf + 4*p1,    /*  draw at p1 position ... */
 					       pixbuf + 4*i*w,   /*  scanline number i ... */
 					       4*p2);
 				}
-				s3dprintf(MED, "updating texture %d\n",t->gl_texnum);
+				s3dprintf(MED, "updating texture %d\n", t->gl_texnum);
 				obj_update_tex(t, x, y, w, h, pixbuf);
 				return(0);
 			} else {
@@ -1501,12 +1500,12 @@
 	free(buf);
 }
 /* generate textures */
-void texture_gen(struct t_obj *obj) 
+void texture_gen(struct t_obj *obj)
 {
 	GLuint t;
 	int i;
 	struct t_tex *tex = NULL;
-	for (i=0; i < obj->n_tex; i++) {
+	for (i = 0; i < obj->n_tex; i++) {
 		tex = &obj->p_tex[i];
 		if (tex->gl_texnum == -1) {
 			glGenTextures(1, &t);
@@ -1524,16 +1523,15 @@
 			    }*/
 			/*  texture has to be generated yet ... */
 			tex_build_mipmaps(tex);
-/*			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
-			             tex->w, tex->h, 0,  / *  no border. * /
-			             GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);*/
+			/*   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
+			                tex->w, tex->h, 0,  / *  no border. * /
+			                GL_RGBA, GL_UNSIGNED_BYTE, tex->buf);*/
 
 		}
 	}
 }
 /* activate/bind texture for object */
 struct t_tex *get_texture(struct t_obj *obj, struct t_mat *m) {
-	GLuint t;
 	struct t_tex *tex = NULL;
 	GLfloat matgl[4];
 	/*  int i,j; */
@@ -1553,7 +1551,7 @@
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
-			
+
 		} else { /* can't use a texture  */
 			tex = NULL;
 		}



