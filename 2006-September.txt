From dotslash at mail.berlios.de  Sun Sep  3 14:48:33 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 3 Sep 2006 14:48:33 +0200
Subject: [S3d-svn] r376 - trunk/apps/s3dfm
Message-ID: <200609031248.k83CmXh2022675@sheep.berlios.de>

Author: dotslash
Date: 2006-09-03 14:48:29 +0200 (Sun, 03 Sep 2006)
New Revision: 376

Added:
   trunk/apps/s3dfm/parse.c
Modified:
   trunk/apps/s3dfm/Makefile.am
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/main.c
   trunk/apps/s3dfm/s3dfm.h
Log:
- notebook merge (warning, unstable)

Modified: trunk/apps/s3dfm/Makefile.am
===================================================================
--- trunk/apps/s3dfm/Makefile.am	2006-08-05 19:54:52 UTC (rev 375)
+++ trunk/apps/s3dfm/Makefile.am	2006-09-03 12:48:29 UTC (rev 376)
@@ -6,7 +6,7 @@
 	s3dfm.h
 s3dfm_SOURCES =  \
 	main.c box.c animation.c \
-	fs.c dialog.c
+	fs.c dialog.c parse.c
 
 s3dfm_CPPFLAGS=		-I${top_srcdir}/libs3d -I${top_srcdir}/libs3dw
 s3dfm_LDADD=		${top_builddir}/libs3d/libs3d.la ${top_builddir}/libs3dw/libs3dw.la

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2006-08-05 19:54:52 UTC (rev 375)
+++ trunk/apps/s3dfm/box.c	2006-09-03 12:48:29 UTC (rev 376)
@@ -42,6 +42,7 @@
 
 	dir->len=0;
 	dir->disp=0;
+	dir->parsed=0;
 
 	dir->px=root.pz=0.0;
 	dir->dirs_opened=0;
@@ -53,6 +54,16 @@
 
 	return(0);
 }
+/* remove old items on the box */
+void box_dissolve(t_item *dir)
+{
+	if (dir->close!=-1)		{	s3d_del_object(dir->close);		dir->close=-1; }
+	if (dir->select!=-1)	{	s3d_del_object(dir->select);	dir->select=-1; }
+	if (dir->title!=-1)		{	s3d_del_object(dir->title);		dir->title=-1; }
+	if (dir->titlestr!=-1)	{	s3d_del_object(dir->titlestr);	dir->titlestr=-1; }
+	if (dir->block!=-1)			s3d_del_object(dir->block);
+
+}
 /* draws icon i in the block of dir */
 int box_icon(t_item *dir,int i)
 {
@@ -81,11 +92,7 @@
 	dir->list[i].dpz = dir->list[i].pz=1.0;
 	dir->list[i].scale = dir->list[i].dscale = (float)1.0/((float)dps);
 	/* create the block */
-	if (dir->list[i].close!=-1)		{	s3d_del_object(dir->list[i].close);		dir->list[i].close=-1; }
-	if (dir->list[i].select!=-1)	{	s3d_del_object(dir->list[i].select);	dir->list[i].select=-1; }
-	if (dir->list[i].title!=-1)		{	s3d_del_object(dir->list[i].title);		dir->list[i].title=-1; }
-	if (dir->list[i].titlestr!=-1)	{	s3d_del_object(dir->list[i].titlestr);	dir->list[i].titlestr=-1; }
-	if (dir->list[i].block!=-1)			s3d_del_object(dir->list[i].block);
+	box_dissolve(&(dir->list[i]));
 	dir->list[i].block=s3d_new_object();
 	s3d_push_vertices(dir->list[i].block,vertices,8);
 	d=((int)(((i+(dps+1)%2*(i/dps)))%2))*0.2;
@@ -314,7 +321,10 @@
 	}
 	for (i=0;i<dir->n_item;i++)
 	{
-		box_icon(dir,i);
+		if (!dir->list[i].disp)
+			box_icon(dir,i);
+		else 
+			s3d_link(dir->list[i].block,dir->block); /* if it's already displayed, make sure it linked properly ... */
 	}
 	dir->disp=1;
 	if (dir->parent!=NULL)
@@ -340,13 +350,56 @@
     s3d_flags_on(dir->titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	return(0);
 }
+void box_undisplay(t_item *dir)
+{
+	int i;
+	t_item *par;
+	for (i=0;i<dir->n_item;i++)
+	{
+		if (!dir->list[i].disp)
+		{
+			if (dir->list[i].block!=-1)
+			{
+				s3d_del_object(dir->list[i].block);
+				dir->list[i].block=-1;
+			}
+			if (dir->list[i].str!=-1)
+			{
+				s3d_del_object(dir->list[i].str);
+				dir->list[i].str=-1;
+			}
+		} else {
+			printf("not undisplaying: %s\n",dir->list[i].name);
+		}
+	}
+	if ((par=dir->parent)!=NULL) /* we can't do this on root.... */
+	{
+		for (i=0;i<par->n_item;i++)
+			if (&par->list[i]==dir)
+				break;
+		if (i!=par->n_item) /* if it actually was in the parents item list */
+		{
+			box_icon(par,i);
+			s3d_flags_on(dir->block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(dir->str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		}
+		par->dirs_opened--;
+	} else {
+		/* we're root ... */
+		box_dissolve(dir);
 
+	}
+	printf("[U]ndisplayed %s\n",dir->name);
+	dir->dirs_opened=0;
+	dir->disp=0;
+	dir->detached=0;
+	
+}
 /* undisplay a directory, thus recursively removing the kids.*/
 int box_collapse(t_item *dir,int force)
 {
 	int i;
 	int ret;
-	t_item *par;
 	if (&root==dir)
 	{
 		printf("won't undisplay root window ... \n");
@@ -356,7 +409,7 @@
 		return(1);
 	if (dir->disp==0)
 	{
-/*		printf("[A]lready undisplayed, nothing to do ...\n");*/
+		printf("[A]lready undisplayed %s, nothing to do ...\n",dir->name);
 		return(-1);
 	}
 	ret=0;
@@ -364,36 +417,8 @@
 		if (dir->list[i].disp)
 			ret|=box_collapse(&dir->list[i],force);
 
-	if (ret && !force) return(ret);
-	for (i=0;i<dir->n_item;i++)
-	{
-		if (dir->list[i].block!=-1)
-		{
-			s3d_del_object(dir->list[i].block);
-			dir->list[i].block=-1;
-		}
-		if (dir->list[i].str!=-1)
-		{
-			s3d_del_object(dir->list[i].str);
-			dir->list[i].str=-1;
-		}
-	}
-	if ((par=dir->parent)!=NULL) /* should never be because there we don't process root */
-	{
-		for (i=0;i<par->n_item;i++)
-			if (&par->list[i]==dir)
-				break;
-		if (i!=par->n_item)
-		{
-			box_icon(par,i);
-			s3d_flags_on(dir->block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_on(dir->str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		}
-		par->dirs_opened--;
-	}
-	dir->dirs_opened=0;
-	dir->disp=0;
-	dir->detached=0;
+	if (ret && !force) return(ret); /* if anything got wrong, return here ... */
+	box_undisplay(dir);
 	if (dir->parent!=NULL)
 	{
 		box_position_kids(dir->parent);

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2006-08-05 19:54:52 UTC (rev 375)
+++ trunk/apps/s3dfm/dialog.c	2006-09-03 12:48:29 UTC (rev 376)
@@ -41,6 +41,13 @@
 				info_window(path);
 				}
 				break;
+		case 'r':
+		case 'R':
+				{/* refresh this window ... */
+					printf("[R]efreshing %s\n",focus->name);
+					parse_again(focus);
+				}
+				break;
 	}
 	s3dw_handle_key(evt);
 }
@@ -70,7 +77,7 @@
 		if (f->type==T_FOLDER)
 		{
 			printf("[F]ound, expanding %s\n",f->name);
-			parse_dir(f);
+			if (!f->disp)		parse_dir(f);
 			box_expand(f);
 			focus=f;
 			ani_focus(f);

Modified: trunk/apps/s3dfm/main.c
===================================================================
--- trunk/apps/s3dfm/main.c	2006-08-05 19:54:52 UTC (rev 375)
+++ trunk/apps/s3dfm/main.c	2006-09-03 12:48:29 UTC (rev 376)
@@ -68,63 +68,6 @@
 	} else
 		mstrncpy(path,dir->name,M_DIR);
 }
-int parse_dir(t_item *dir)
-{
-	t_item *list;
-	struct dirent **namelist;
-	int n,i;
-	char *ext,*nstr;
-	char path[M_DIR];
-	char ndir[M_DIR];  
-	if (dir->n_item>0) /* refusing */
-		return(-1);
-	get_path(dir,path);
-/*	printf("scanning %s\n",path);*/
-    n = i = scandir(path, &namelist, 0, alphasort);
-    if (n < 0)
-	{
-        perror("scandir");
-		return(-1);
-	} else {
-		if (dir->n_item>0)
-			free(dir->list); /* this is a refresh, free old items */
-		list=malloc(sizeof(t_item)*i);
-		dir->list=list;
-		dir->n_item=n;
-/*		printf("found %d items, processing ...\n",n);*/
-        while(n--) {
-			box_init(&list[n]);
-			nstr=namelist[n]->d_name;
-			strncpy(list[n].name,nstr,M_NAME);
- 		    if ((0==strncmp(nstr,".",1)) && (strlen(nstr)==1))
-				list[n].type=T_LOCALDIR;
-			else if (0==strncmp(nstr,"..",strlen(nstr)<2?strlen(nstr):2))
-			   list[n].type=T_BACKDIR;
-			else {
-				ext=strrchr(nstr,'.');
-				strncpy(ndir,path,M_DIR);
-		    	strncat(ndir,namelist[n]->d_name,M_DIR);
-			    if ((namelist[n]->d_type==DT_DIR) ||
-					((namelist[n]->d_type==DT_UNKNOWN) && (opendir(ndir)!=NULL)))
-						list[n].type=T_FOLDER;
-				else 
-				{
-				   if (ext!=NULL)
-				   {
-					   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))
-							   list[n].type=T_GEOMETRY;
-					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))
-							   list[n].type=T_MUSIC;
-				   }
-				}
-			}
-			list[n].parent=dir;
-        	free(namelist[n]);
-		}
-		free(namelist);
-   	}
-	return(0);
-}
 /* finds an item in the tree by oid */
 t_item *finditem(t_item *t, int oid)
 {

Added: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2006-08-05 19:54:52 UTC (rev 375)
+++ trunk/apps/s3dfm/parse.c	2006-09-03 12:48:29 UTC (rev 376)
@@ -0,0 +1,143 @@
+/*
+ * main.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include "s3dfm.h"
+#include <s3dw.h>	 /* s3dw_ani_mate() */
+#include <stdio.h> 	 /*  printf() */
+#include <dirent.h>  /*  dirent */
+#include <stdlib.h>	 /*  malloc() */
+#include <string.h>  /*  strlen(), strncmp(), strrchr() */
+#include <time.h>	/* nanosleep() */
+int parse_dir(t_item *dir)
+{
+	t_item *list;
+	struct dirent **namelist;
+	int n,i;
+	char *ext,*nstr;
+	char path[M_DIR];
+	char ndir[M_DIR]; 
+
+	if (dir->parsed) return(-1);
+	get_path(dir,path);
+/*	printf("scanning %s\n",path);*/
+    n = i = scandir(path, &namelist, 0, alphasort);
+	
+    if (n < 0)
+	{
+        perror("scandir");
+		return(-1);
+	} else {
+		list=malloc(sizeof(t_item)*i);
+		dir->list=list;
+		dir->n_item=n;
+        while(n--) {
+			/* setup kids in the list */
+			box_init(&list[n]);
+			nstr=namelist[n]->d_name;
+			strncpy(list[n].name,nstr,M_NAME);
+ 		    if ((0==strncmp(nstr,".",1)) && (strlen(nstr)==1))
+				list[n].type=T_LOCALDIR;
+			else if (0==strncmp(nstr,"..",strlen(nstr)<2?strlen(nstr):2))
+			   list[n].type=T_BACKDIR;
+			else {
+				ext=strrchr(nstr,'.');
+				strncpy(ndir,path,M_DIR);
+		    	strncat(ndir,namelist[n]->d_name,M_DIR);
+			    if ((namelist[n]->d_type==DT_DIR) ||
+					((namelist[n]->d_type==DT_UNKNOWN) && (opendir(ndir)!=NULL)))
+						list[n].type=T_FOLDER;
+				else 
+				{
+				   if (ext!=NULL)
+				   {
+					   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))
+							   list[n].type=T_GEOMETRY;
+					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))
+							   list[n].type=T_MUSIC;
+				   }
+				}
+			}
+			list[n].parent=dir;
+        	free(namelist[n]);
+		}
+		free(namelist);
+		dir->parsed=1;
+   	}
+	return(0);
+}
+void parse_again(t_item *dir)
+{
+	int oldn,redisp;
+	t_item *oldlist;
+	int i,j;
+	oldlist=dir->list;
+	oldn   =dir->n_item;
+	redisp=0;
+	if (dir->disp)	{ box_undisplay(dir); redisp=1; }
+	parse_dir(dir);
+
+	printf("oldn = %d\n",oldn);
+	if (oldn>0)
+	{
+		/* find old, already displayed contents, and copy the data, or remove them if 
+		 * deleted */
+		
+		for (i=0;i<oldn;i++)
+		{
+			if (oldlist[i].disp)
+			{
+				for (j=0;j<dir->n_item;j++)
+				{
+					if (0==strcmp(oldlist[i].name,dir->list[j].name))
+					{
+						printf("we still have %s - %s (%d,%d) , copy to new list ... \n",dir->list[j].name, oldlist[i].name,j,i);
+						memcpy(&(dir->list[j]),&oldlist[i],sizeof(t_item));
+						break; /* found */
+					}
+				}
+				if (j==dir->n_item) /* not found, collapse it */
+					freeitem(&oldlist[i]);
+				else {}/* don't collapse it!! keep as it is */
+			} else freeitem(&oldlist[i]);
+		}
+		free(oldlist);
+		if (redisp)
+		{
+			/* if it was displayed, redisplay it ... */
+			box_expand(dir);
+		}
+	}	
+}
+void freeitem(t_item *t)
+{
+	int i;
+	box_collapse(t,1); /* collapse this and its kids */
+	if (t->n_item>0) {
+		for (i=0;i<t->n_item;i++)
+			freeitem(&(t->list[i]));
+		free(t->list);
+	}
+	t->n_item=0;
+}
+

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2006-08-05 19:54:52 UTC (rev 375)
+++ trunk/apps/s3dfm/s3dfm.h	2006-09-03 12:48:29 UTC (rev 376)
@@ -58,7 +58,7 @@
 	float dpx,dpy,dpz,dscale;				/* current state in animation */
 	int n_item;								/* number of items in list ( = -1 for normal or not-expanded files) */
 	int type;								/* type, determined by extension or file type like dir, pipe, link etc */
-	int disp;
+	int disp,parsed;						/* Flags for displayed/parsed items ... */
 };
 struct _filelist {
 	char **p;
@@ -71,9 +71,12 @@
 extern t_item root;
 /* main.c */
 void get_path(t_item *dir, char *path);
-int parse_dir(t_item *dir);
 t_item *finditem(t_item *t, int oid);
 void mainloop();
+/* parse.c */
+int parse_dir(t_item *dir);
+void freeitem(t_item *t);
+void parse_again(t_item *t);
 /* animation.c */
 float ani_get_scale(t_item *f);
 void ani_focus(t_item *f);
@@ -92,6 +95,8 @@
 int box_buildblock(t_item *dir);
 int box_icon(t_item *dir,int i);
 int box_init(t_item *dir);
+void box_dissolve(t_item *dir);
+void box_undisplay(t_item *dir);
 void box_sidelabel(t_item *dir);
 void box_position_kids(t_item *dir);
 void box_select(t_item *dir);



From dotslash at mail.berlios.de  Sun Sep  3 15:59:26 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 3 Sep 2006 15:59:26 +0200
Subject: [S3d-svn] r377 - in trunk: . libs3d
Message-ID: <200609031359.k83DxQNN019857@sheep.berlios.de>

Author: dotslash
Date: 2006-09-03 15:59:25 +0200 (Sun, 03 Sep 2006)
New Revision: 377

Modified:
   trunk/
   trunk/libs3d/freetype.c
Log:
 r893 at balthasar:  dotslash | 2006-09-03 15:58:55 +0200
 - remove annoying debug messages (LOW -> VLOW)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:887
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:893

Modified: trunk/libs3d/freetype.c
===================================================================
--- trunk/libs3d/freetype.c	2006-09-03 12:48:29 UTC (rev 376)
+++ trunk/libs3d/freetype.c	2006-09-03 13:59:25 UTC (rev 377)
@@ -142,7 +142,7 @@
 		errds(VHIGH,"_s3d_add_tessbuf():FT_Load_Char()","can't load character %d : (%d) %s",a,ft_errors[error].err_code,ft_errors[error].err_msg);
 		return(-1);
 	} 
-	s3dprintf(LOW,"[T]riangulating character %c",a);
+	s3dprintf(VLOW,"[T]riangulating character %c",a);
 	norm=1.0/face->glyph->metrics.vertAdvance;
 	ch=a;
 	v_off=0;



From dotslash at mail.berlios.de  Sun Sep  3 18:57:36 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 3 Sep 2006 18:57:36 +0200
Subject: [S3d-svn] r378 - in trunk: . apps/s3dfm
Message-ID: <200609031657.k83GvaAR021252@sheep.berlios.de>

Author: dotslash
Date: 2006-09-03 18:57:33 +0200 (Sun, 03 Sep 2006)
New Revision: 378

Added:
   trunk/apps/s3dfm/icon.c
Modified:
   trunk/
   trunk/apps/s3dfm/Makefile.am
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/main.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dfm/s3dfm.h
Log:
 r896 at balthasar:  dotslash | 2006-09-03 18:57:09 +0200
 - some code cleanup, dir->disp now storing how node is displayed
 - still bugs in refresh-code ... :(



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:893
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:896

Modified: trunk/apps/s3dfm/Makefile.am
===================================================================
--- trunk/apps/s3dfm/Makefile.am	2006-09-03 13:59:25 UTC (rev 377)
+++ trunk/apps/s3dfm/Makefile.am	2006-09-03 16:57:33 UTC (rev 378)
@@ -6,7 +6,7 @@
 	s3dfm.h
 s3dfm_SOURCES =  \
 	main.c box.c animation.c \
-	fs.c dialog.c parse.c
+	fs.c dialog.c parse.c icon.c
 
 s3dfm_CPPFLAGS=		-I${top_srcdir}/libs3d -I${top_srcdir}/libs3dw
 s3dfm_LDADD=		${top_builddir}/libs3d/libs3d.la ${top_builddir}/libs3dw/libs3dw.la

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2006-09-03 13:59:25 UTC (rev 377)
+++ trunk/apps/s3dfm/animation.c	2006-09-03 16:57:33 UTC (rev 378)
@@ -22,6 +22,7 @@
  */
 
 #include "s3dfm.h"
+#include <s3dw.h>
 #include <stdio.h> 	 /*  printf(),NULL */
 #include <math.h>	 /*  fabs() */
 #define SCALE 	1

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2006-09-03 13:59:25 UTC (rev 377)
+++ trunk/apps/s3dfm/box.c	2006-09-03 16:57:33 UTC (rev 378)
@@ -26,34 +26,7 @@
 #include <math.h>	 /*  sin(),cos() */
 #include <string.h>  /*  strlen() */
 
-/* clear the dirs attributes */
-int box_init(t_item *dir)
-{
-	dir->parent=NULL;
-	dir->list=NULL;
-	dir->n_item=-1;
 
-	dir->block=-1;
-	dir->str=-1;
-	dir->close=-1;
-	dir->select=-1;
-	dir->title=-1;
-	dir->titlestr=-1;
-
-	dir->len=0;
-	dir->disp=0;
-	dir->parsed=0;
-
-	dir->px=root.pz=0.0;
-	dir->dirs_opened=0;
-	dir->type=T_DUNO;
-	dir->px=dir->py=dir->pz=0.0;
-	dir->dpx=dir->dpy=dir->dpz=0.0;
-	dir->scale=dir->dscale=1.0;
-	dir->detached=0;
-
-	return(0);
-}
 /* remove old items on the box */
 void box_dissolve(t_item *dir)
 {
@@ -64,71 +37,7 @@
 	if (dir->block!=-1)			s3d_del_object(dir->block);
 
 }
-/* draws icon i in the block of dir */
-int box_icon(t_item *dir,int i)
-{
-	float vertices[]={	-1,-0.5,0,
-						-1, 0.5,0,
-						 1, 0.5,0,
-						 1,-0.5,0,
-						-1,-0.5,-1,
-						-1, 0.5,-1,
-						 1, 0.5,-1,
-						 1,-0.5,-1};
-	unsigned long polys[]={
-				1,3,0,0,				2,3,1,0,
-				5,6,2,0,				1,5,2,0,
-				2,6,7,0,				2,7,3,0,
-				0,3,7,0,				0,7,4,0,
-				5,1,0,0,				5,0,4,0	
-				};
-	float len;
-	float d;
-	int dps;
-	dps=ceil(sqrt(dir->n_item)); /* directories per line */
-	/* find position for the new block in our directory box */
-	dir->list[i].dpx = dir->list[i].px=-1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
-	dir->list[i].dpy = dir->list[i].py=0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
-	dir->list[i].dpz = dir->list[i].pz=1.0;
-	dir->list[i].scale = dir->list[i].dscale = (float)1.0/((float)dps);
-	/* create the block */
-	box_dissolve(&(dir->list[i]));
-	dir->list[i].block=s3d_new_object();
-	s3d_push_vertices(dir->list[i].block,vertices,8);
-	d=((int)(((i+(dps+1)%2*(i/dps)))%2))*0.2;
-	switch (dir->list[i].type)
-	{
-		case T_FOLDER:
-			s3d_push_material(dir->list[i].block,
-									0.4-d,0.4-d,0,
-									0.4-d,0.4-d,0,
-									0.4-d,0.4-d,0);
-			break;
-		default:
-			s3d_push_material(dir->list[i].block,
-									0,0,0.5-d,
-									0,0,0.5-d,
-									0,0,0.5-d);
-	};
-	s3d_push_polygons(dir->list[i].block,polys,10);
-	s3d_link(dir->list[i].block,dir->block);
 
-	/* draw and position the string */
-	if (dir->list[i].str==-1)
-	{
-		dir->list[i].str=s3d_draw_string(dir->list[i].name,&len);
-		if (len<2) len=2;
-		dir->list[i].len=len;
-	}
-	else 
-		len=dir->list[i].len;
-	s3d_scale(dir->list[i].str,(float)1.8/len);
-	s3d_translate(dir->list[i].str,-0.9,-0.3,0.1);
-	s3d_rotate(dir->list[i].str,0,0,0);
-	s3d_link(dir->list[i].str,dir->list[i].block);
-	ani_finish(&dir->list[i],-1); /* apply transformation */
-	return(0);
-}
 
 
 /* places the string at the left side of the cube */
@@ -294,10 +203,19 @@
 		s3d_scale(dir->titlestr,0.2);
 	s3d_translate(dir->titlestr,-1.0,1.05,1.01);
 	s3d_link(dir->titlestr,dir->block);
+	dir->disp=D_DIR;
 /*	printf("FULLNAME is [%s]\n",fullname);*/
 	return(0);
 }
-
+int undisplay(t_item *dir)
+{
+	switch (dir->disp)
+	{
+		case D_DIR: return(box_undisplay(dir));break;
+		case D_ICON:return(icon_undisplay(dir));break;
+		default:	return(-1);
+	}
+}
 /* display a directoy on the top of another, draw it's icons etc ... */
 int box_expand(t_item *dir)
 {
@@ -305,28 +223,27 @@
 	float  px,pz;
 	int dirn;
 	px=pz=0.0;
-	if (dir->disp)
-		return(-1); /* already displayed ... */ 
-	s3d_del_object(dir->block);
+	printf("box_expand( %s )\n",dir->name);
+	if (dir->disp)		undisplay(dir);
 	box_buildblock(dir);
 	if (dir->parent!=NULL)
 		dir->parent->dirs_opened++;
-	dir->dirs_opened=0;
  /* count directories */
 	dirn=0;
 	for (i=0;i<dir->n_item;i++)
 	{
-		if (dir->list[i].type==T_FOLDER)
-			dirn++;
+		if (dir->list[i].type==T_FOLDER) dirn++;
 	}
+
+	/* draw icons, if necceasry */
 	for (i=0;i<dir->n_item;i++)
 	{
-		if (!dir->list[i].disp)
-			box_icon(dir,i);
-		else 
+		if (!dir->list[i].disp)	icon_draw(dir,i);
+		else {
+			printf("link %d to the block %d of %s\n",dir->list[i].block,dir->block,dir->name);
 			s3d_link(dir->list[i].block,dir->block); /* if it's already displayed, make sure it linked properly ... */
+		}
 	}
-	dir->disp=1;
 	if (dir->parent!=NULL)
 	{
 		s3d_link(dir->block,dir->parent->block);
@@ -348,29 +265,19 @@
     s3d_flags_on(dir->title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
     s3d_flags_on(dir->select,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
     s3d_flags_on(dir->titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	dir->disp=D_DIR;
 	return(0);
 }
-void box_undisplay(t_item *dir)
+int box_undisplay(t_item *dir)
 {
 	int i;
 	t_item *par;
+	printf("box_undisplay( %s )\n",dir->name);
 	for (i=0;i<dir->n_item;i++)
 	{
-		if (!dir->list[i].disp)
-		{
-			if (dir->list[i].block!=-1)
-			{
-				s3d_del_object(dir->list[i].block);
-				dir->list[i].block=-1;
-			}
-			if (dir->list[i].str!=-1)
-			{
-				s3d_del_object(dir->list[i].str);
-				dir->list[i].str=-1;
-			}
-		} else {
-			printf("not undisplaying: %s\n",dir->list[i].name);
-		}
+		if (dir->list[i].disp==D_ICON)	icon_undisplay(&(dir->list[i]));
+		else if (dir->list[i].disp!=0)	
+				printf("not undisplaying: %s (disp = %d)\n",dir->list[i].name, dir->list[i].disp);
 	}
 	if ((par=dir->parent)!=NULL) /* we can't do this on root.... */
 	{
@@ -379,7 +286,7 @@
 				break;
 		if (i!=par->n_item) /* if it actually was in the parents item list */
 		{
-			box_icon(par,i);
+			icon_draw(par,i);
 			s3d_flags_on(dir->block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			s3d_flags_on(dir->str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 		}
@@ -387,19 +294,18 @@
 	} else {
 		/* we're root ... */
 		box_dissolve(dir);
-
 	}
 	printf("[U]ndisplayed %s\n",dir->name);
-	dir->dirs_opened=0;
-	dir->disp=0;
+/*	dir->dirs_opened=0;*/
 	dir->detached=0;
-	
+	return(0);
 }
 /* undisplay a directory, thus recursively removing the kids.*/
 int box_collapse(t_item *dir,int force)
 {
 	int i;
 	int ret;
+	printf("box_collapse( %s )\n",dir->name);
 	if (&root==dir)
 	{
 		printf("won't undisplay root window ... \n");
@@ -407,18 +313,19 @@
 	}
 	if (dir->detached && !force)
 		return(1);
-	if (dir->disp==0)
+	if (dir->disp!=D_DIR)
 	{
 		printf("[A]lready undisplayed %s, nothing to do ...\n",dir->name);
 		return(-1);
 	}
+	/* undisplaying kids. ret will be != 0 if any of the kids did not close correctly */
 	ret=0;
 	for (i=0;i<dir->n_item;i++)
-		if (dir->list[i].disp)
+		if (dir->list[i].disp==D_DIR)
 			ret|=box_collapse(&dir->list[i],force);
 
 	if (ret && !force) return(ret); /* if anything got wrong, return here ... */
-	box_undisplay(dir);
+	undisplay(dir);
 	if (dir->parent!=NULL)
 	{
 		box_position_kids(dir->parent);
@@ -431,10 +338,11 @@
 	int i,j;
 	t_item *kid;
 	for (i=0;i<dir->n_item;i++)
-		if (dir->list[i].disp)
+		if (dir->list[i].disp==D_DIR)
 		{
 			kid=&dir->list[i];
 			for (j=0;j<kid->n_item;j++)
+			if (kid->list[j].disp==D_DIR)
 				box_collapse(&kid->list[j],0);
 		}
 	return(0);
@@ -444,14 +352,14 @@
 void box_position_kids(t_item *dir)
 {
 	int i,j;
-/*	printf("placeontop dir %s, %d\n",dir->name,dir->dirs_opened);*/
+	printf("box_position_kids( %s ): %d dirs opened\n",dir->name,dir->dirs_opened);
 	switch (dir->dirs_opened)
 	{
 		case 0: return;
 		case 1:
 			for (i=0;i<dir->n_item;i++)
 			{
-				if (dir->list[i].disp)
+				if (dir->list[i].disp==D_DIR)
 				{
 					dir->list[i].px=0.0;
 					dir->list[i].py=BOXHEIGHT+dir->list[i].detached*DETHEIGHT;
@@ -465,7 +373,7 @@
 			j=0;
 			for (i=0;i<dir->n_item;i++)
 			{
-				if (dir->list[i].disp)
+				if (dir->list[i].disp==D_DIR)
 				{
 					dir->list[i].px=0.8 * sin(((float)j*2*M_PI)/((float)dir->dirs_opened));
 					dir->list[i].py=BOXHEIGHT+dir->list[i].detached*DETHEIGHT;

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2006-09-03 13:59:25 UTC (rev 377)
+++ trunk/apps/s3dfm/dialog.c	2006-09-03 16:57:33 UTC (rev 378)
@@ -76,13 +76,17 @@
 		}
 		if (f->type==T_FOLDER)
 		{
-			printf("[F]ound, expanding %s\n",f->name);
-			if (!f->disp)		parse_dir(f);
-			box_expand(f);
+			if (f->disp == D_DIR)
+			{
+				printf("[F]ound, Already displayed - ani_focus( %s )\n",f->name);
+			} else {
+				if (!f->parsed)	parse_dir(f);
+				box_expand(f);
+			}
 			focus=f;
 			ani_focus(f);
 		} else
-			printf("[F]ound, but is %s no folder\n",f->name);
+			printf("[F]ound, but %s is no folder\n",f->name);
 	} else {
 /*		printf("[C]ould not find :/\n");*/
 	}
@@ -91,6 +95,7 @@
 {
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 }
+/* add some dots to an integer value for better readability */
 void dotted_int(char *s,unsigned int i)
 {
 	char st[M_DIR];
@@ -113,7 +118,7 @@
 		s[i]=st[p-i];
 	s[p+1]=0;
 }
-
+/* a small window which counts directories/files and displays the result */
 void info_window(char *path)
 {
 	s3dw_surface *infwin;

Added: trunk/apps/s3dfm/icon.c
===================================================================
--- trunk/apps/s3dfm/icon.c	2006-09-03 13:59:25 UTC (rev 377)
+++ trunk/apps/s3dfm/icon.c	2006-09-03 16:57:33 UTC (rev 378)
@@ -0,0 +1,110 @@
+/*
+ * icon.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "s3dfm.h"
+#include <stdio.h> 	 /*  printf() */
+#include <math.h>	 /*  sin(),cos() */
+#include <string.h>  /*  strlen() */
+/* draws icon i in the block of dir */
+int icon_draw(t_item *dir,int i)
+{
+	float vertices[]={	-1,-0.5,0,
+						-1, 0.5,0,
+						 1, 0.5,0,
+						 1,-0.5,0,
+						-1,-0.5,-1,
+						-1, 0.5,-1,
+						 1, 0.5,-1,
+						 1,-0.5,-1};
+	unsigned long polys[]={
+				1,3,0,0,				2,3,1,0,
+				5,6,2,0,				1,5,2,0,
+				2,6,7,0,				2,7,3,0,
+				0,3,7,0,				0,7,4,0,
+				5,1,0,0,				5,0,4,0	
+				};
+	float len;
+	float d;
+	int dps;
+	printf("icon_draw( %s )\n",dir->list[i].name);
+	dps=ceil(sqrt(dir->n_item)); /* directories per line */
+	/* find position for the new block in our directory box */
+	dir->list[i].dpx = dir->list[i].px=-1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
+	dir->list[i].dpy = dir->list[i].py=0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
+	dir->list[i].dpz = dir->list[i].pz=1.0;
+	dir->list[i].scale = dir->list[i].dscale = (float)1.0/((float)dps);
+	/* create the block */
+	box_dissolve(&(dir->list[i]));
+	dir->list[i].block=s3d_new_object();
+	s3d_push_vertices(dir->list[i].block,vertices,8);
+	d=((int)(((i+(dps+1)%2*(i/dps)))%2))*0.2;
+	switch (dir->list[i].type)
+	{
+		case T_FOLDER:
+			s3d_push_material(dir->list[i].block,
+									0.4-d,0.4-d,0,
+									0.4-d,0.4-d,0,
+									0.4-d,0.4-d,0);
+			break;
+		default:
+			s3d_push_material(dir->list[i].block,
+									0,0,0.5-d,
+									0,0,0.5-d,
+									0,0,0.5-d);
+	};
+	s3d_push_polygons(dir->list[i].block,polys,10);
+	s3d_link(dir->list[i].block,dir->block);
+
+	/* draw and position the string */
+	if (dir->list[i].str==-1)
+	{
+		dir->list[i].str=s3d_draw_string(dir->list[i].name,&len);
+		if (len<2) len=2;
+		dir->list[i].len=len;
+	}
+	else 
+		len=dir->list[i].len;
+	s3d_scale(dir->list[i].str,(float)1.8/len);
+	s3d_translate(dir->list[i].str,-0.9,-0.3,0.1);
+	s3d_rotate(dir->list[i].str,0,0,0);
+	s3d_link(dir->list[i].str,dir->list[i].block);
+	ani_finish(&dir->list[i],-1); /* apply transformation */
+	dir->list[i].disp=D_ICON;
+	return(0);
+}
+int icon_undisplay(t_item *dir)
+{
+	printf("icon_undisplay( %s )\n",dir->name);
+	if (dir->block!=-1)
+	{
+		s3d_del_object(dir->block);
+		dir->block=-1;
+	}
+	if (dir->str!=-1)
+	{
+		s3d_del_object(dir->str);
+		dir->str=-1;
+	}
+	dir->disp=0;
+	return(0);
+}

Modified: trunk/apps/s3dfm/main.c
===================================================================
--- trunk/apps/s3dfm/main.c	2006-09-03 13:59:25 UTC (rev 377)
+++ trunk/apps/s3dfm/main.c	2006-09-03 16:57:33 UTC (rev 378)
@@ -116,7 +116,7 @@
 
 		
 		/* set up file system representation */
-		box_init(&root);
+		node_init(&root);
 		strncpy(root.name,"/",M_NAME);
 		focus=&root;
 		root.dscale=0.1;
@@ -128,7 +128,7 @@
 		ani_doit(&root);
 		ani_focus(&root);
 		
-		box_init(&cam); /* a virtual object, just to push the cam throu our animation stack */
+		node_init(&cam); /* a virtual object, just to push the cam throu our animation stack */
 		cam.block=0;
 		
 		

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2006-09-03 13:59:25 UTC (rev 377)
+++ trunk/apps/s3dfm/parse.c	2006-09-03 16:57:33 UTC (rev 378)
@@ -29,6 +29,36 @@
 #include <stdlib.h>	 /*  malloc() */
 #include <string.h>  /*  strlen(), strncmp(), strrchr() */
 #include <time.h>	/* nanosleep() */
+
+
+/* clear the dirs attributes */
+int node_init(t_item *dir)
+{
+	dir->parent=NULL;
+	dir->list=NULL;
+	dir->n_item=-1;
+
+	dir->block=-1;
+	dir->str=-1;
+	dir->close=-1;
+	dir->select=-1;
+	dir->title=-1;
+	dir->titlestr=-1;
+
+	dir->len=0;
+	dir->disp=0;
+	dir->parsed=0;
+
+	dir->px=root.pz=0.0;
+	dir->dirs_opened=0;
+	dir->type=T_DUNO;
+	dir->px=dir->py=dir->pz=0.0;
+	dir->dpx=dir->dpy=dir->dpz=0.0;
+	dir->scale=dir->dscale=1.0;
+	dir->detached=0;
+
+	return(0);
+}
 int parse_dir(t_item *dir)
 {
 	t_item *list;
@@ -37,8 +67,9 @@
 	char *ext,*nstr;
 	char path[M_DIR];
 	char ndir[M_DIR]; 
-
-	if (dir->parsed) return(-1);
+	
+	printf("parse_dir( %s )",dir->name);
+/*	if (dir->parsed) return(-1);*/
 	get_path(dir,path);
 /*	printf("scanning %s\n",path);*/
     n = i = scandir(path, &namelist, 0, alphasort);
@@ -53,7 +84,7 @@
 		dir->n_item=n;
         while(n--) {
 			/* setup kids in the list */
-			box_init(&list[n]);
+			node_init(&list[n]);
 			nstr=namelist[n]->d_name;
 			strncpy(list[n].name,nstr,M_NAME);
  		    if ((0==strncmp(nstr,".",1)) && (strlen(nstr)==1))
@@ -94,7 +125,12 @@
 	oldlist=dir->list;
 	oldn   =dir->n_item;
 	redisp=0;
-	if (dir->disp)	{ box_undisplay(dir); redisp=1; }
+	printf("parse_again( %s )\n",dir->name);
+	if (dir->disp==D_DIR)	/* undisplay it later */
+	{ 
+		box_undisplay(dir); 
+		redisp=1; 
+	}
 	parse_dir(dir);
 
 	printf("oldn = %d\n",oldn);
@@ -105,8 +141,9 @@
 		
 		for (i=0;i<oldn;i++)
 		{
-			if (oldlist[i].disp)
+			if (oldlist[i].disp == D_DIR)	/* old things expanded as directory */
 			{
+				/* see if it's also in the new list */
 				for (j=0;j<dir->n_item;j++)
 				{
 					if (0==strcmp(oldlist[i].name,dir->list[j].name))
@@ -116,26 +153,35 @@
 						break; /* found */
 					}
 				}
-				if (j==dir->n_item) /* not found, collapse it */
-					freeitem(&oldlist[i]);
+				if (j == dir->n_item) /* not found, collapse it */
+					node_free(&oldlist[i]);
 				else {}/* don't collapse it!! keep as it is */
-			} else freeitem(&oldlist[i]);
+			} else node_free(&oldlist[i]);
 		}
 		free(oldlist);
+
+		printf("finished copying old content, redisplay if neccesary\n");
 		if (redisp)
 		{
+			printf("redisplay ... (opened: %d) ", dir->dirs_opened);
 			/* if it was displayed, redisplay it ... */
 			box_expand(dir);
+			printf("done (opened: %d)\n", dir->dirs_opened);
 		}
 	}	
 }
-void freeitem(t_item *t)
+void node_free(t_item *t)
 {
 	int i;
-	box_collapse(t,1); /* collapse this and its kids */
+	printf("node_free( %s )\n",t->name);
+	switch (t->disp)
+	{
+			case D_DIR:  box_collapse(t,1); /* collapse this and its kids */
+			case D_ICON: icon_undisplay(t);
+	}
 	if (t->n_item>0) {
 		for (i=0;i<t->n_item;i++)
-			freeitem(&(t->list[i]));
+			node_free(&(t->list[i]));
 		free(t->list);
 	}
 	t->n_item=0;

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2006-09-03 13:59:25 UTC (rev 377)
+++ trunk/apps/s3dfm/s3dfm.h	2006-09-03 16:57:33 UTC (rev 378)
@@ -59,6 +59,8 @@
 	int n_item;								/* number of items in list ( = -1 for normal or not-expanded files) */
 	int type;								/* type, determined by extension or file type like dir, pipe, link etc */
 	int disp,parsed;						/* Flags for displayed/parsed items ... */
+#define D_ICON	1
+#define D_DIR	2
 };
 struct _filelist {
 	char **p;
@@ -74,8 +76,9 @@
 t_item *finditem(t_item *t, int oid);
 void mainloop();
 /* parse.c */
+int node_init(t_item *dir);
+void node_free(t_item *t);
 int parse_dir(t_item *dir);
-void freeitem(t_item *t);
 void parse_again(t_item *t);
 /* animation.c */
 float ani_get_scale(t_item *f);
@@ -93,13 +96,14 @@
 int box_collapse_grandkids(t_item *dir);
 int box_expand(t_item *dir);
 int box_buildblock(t_item *dir);
-int box_icon(t_item *dir,int i);
-int box_init(t_item *dir);
 void box_dissolve(t_item *dir);
-void box_undisplay(t_item *dir);
+int  box_undisplay(t_item *dir);
 void box_sidelabel(t_item *dir);
 void box_position_kids(t_item *dir);
 void box_select(t_item *dir);
+/* icon.c */
+int icon_draw(t_item *dir,int i);
+int icon_undisplay(t_item *dir);
 /* fs.c */
 filelist *fl_new(char *path);
 void fl_del(filelist *fl);



From dotslash at mail.berlios.de  Mon Sep 11 22:04:38 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 11 Sep 2006 22:04:38 +0200
Subject: [S3d-svn] r379 - in trunk: . apps/s3dfm
Message-ID: <200609112004.k8BK4cud006635@sheep.berlios.de>

Author: dotslash
Date: 2006-09-11 22:04:38 +0200 (Mon, 11 Sep 2006)
New Revision: 379

Modified:
   trunk/
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/main.c
   trunk/apps/s3dfm/s3dfm.h
Log:
 r898 at balthasar:  dotslash | 2006-09-11 22:04:32 +0200
 - mkdir works ... somehow ^^ (F7)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:896
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:898

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2006-09-03 16:57:33 UTC (rev 378)
+++ trunk/apps/s3dfm/dialog.c	2006-09-11 20:04:38 UTC (rev 379)
@@ -26,19 +26,30 @@
 #include <s3dw.h>
 #include <stdio.h> 	/* NULL, printf() */
 #include <string.h> /* strlen() */
+#include <stdlib.h> /* realloc(),malloc() */
+#include <errno.h>  /* errno */
+#include <sys/stat.h> /* mkdir() */
+#include <sys/types.h> /* mkdir() */
 extern t_item *focus;
+filelist fp={NULL,0};
+int typeinput=0;
 /* keyevent handler */
 void key_handler(struct s3d_evt *evt)
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)evt->buf;
+	char path[M_DIR];
+	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */	
+			printf("inputting text ...\n");
+			s3dw_handle_key(evt); 
+			return; 
+	}
+	get_path(focus,path);
 	switch (keys->keysym)
 	{
 		case 'i':
 		case 'I':
 				{
-				char path[M_DIR];
-				get_path(focus,path);
-				info_window(path);
+				window_info(path);
 				}
 				break;
 		case 'r':
@@ -48,6 +59,20 @@
 					parse_again(focus);
 				}
 				break;
+		case S3DK_F1:
+				window_help();
+				break;
+		case S3DK_F5:
+				window_copy(path);
+				break;
+		case S3DK_F6:
+				window_move(path);
+				break;
+		case S3DK_F7:
+				window_mkdir(path);
+				break;
+
+
 	}
 	s3dw_handle_key(evt);
 }
@@ -118,8 +143,196 @@
 		s[i]=st[p-i];
 	s[p+1]=0;
 }
+/* add all selected dirs in the new filelist */
+int get_selected(filelist *fp, t_item *dir)
+{
+	int i;
+	char *s;
+	for (i=0;i<dir->n_item;i++)
+	{
+		if (dir->list[i].list!=NULL)	get_selected(fp,&(dir->list[i])); /* scan subdir */
+		if (dir->list[i].detached)
+		{
+			fp->n++;
+			fp->p=realloc(fp->p,sizeof(char *) * fp->n);
+			s=malloc(M_DIR);
+			get_path(&(dir->list[i]),s);
+			fp->p[fp->n - 1]=s;
+		}
+	}
+	return(0);
+}
+void window_help()
+{
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+	char string1[M_DIR];
+	infwin=s3dw_surface_new("Help Window",12,12);
+	snprintf(string1,M_DIR,"F1 - This Help Window");
+	s3dw_label_new(infwin,string1,1,2);
+	snprintf(string1,M_DIR,"F5 - Copy");
+	s3dw_label_new(infwin,string1,1,3);
+	snprintf(string1,M_DIR,"F6 - Move");
+	s3dw_label_new(infwin,string1,1,4);
+	snprintf(string1,M_DIR,"R - Refresh");
+	s3dw_label_new(infwin,string1,1,5);
+	snprintf(string1,M_DIR,"I - Info");
+	s3dw_label_new(infwin,string1,1,6);
+
+	button=s3dw_button_new(infwin,"OK",4,10);
+	button->onclick=close_win;
+	s3dw_show(S3DWIDGET(infwin));
+
+}
+void window_fs_another()
+{
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+	infwin=s3dw_surface_new("Error",12,8);
+	s3dw_label_new(infwin,"Sorry, another FS Action is in Progress",1,2);
+	button=s3dw_button_new(infwin,"OK",5,5);
+	button->onclick=close_win;
+	s3dw_show(S3DWIDGET(infwin));
+}
+void window_fs_nothing()
+{
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+	infwin=s3dw_surface_new("Error",12,8);
+	s3dw_label_new(infwin,"Nothing selected :(",1,2);
+	button=s3dw_button_new(infwin,"OK",5,5);
+	button->onclick=close_win;
+	s3dw_show(S3DWIDGET(infwin));
+
+}
+void window_fs_errno(char *errmsg)
+{
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+	char string[M_DIR];
+	float l;
+	snprintf(string,M_DIR,"%s: %s",errmsg,strerror(errno));
+	l=strlen(string)*0.7;
+	infwin=s3dw_surface_new("Error",l,8);
+	s3dw_label_new(infwin,string,1,2);
+	button=s3dw_button_new(infwin,"OK",l/2-1,5);
+	button->onclick=close_win;
+	s3dw_show(S3DWIDGET(infwin));
+}
+
+void window_fs_abort(s3dw_widget *button)
+{
+	int i;
+	for (i=0;i<fp.n;i++)
+		free(fp.p[i]);
+	if (fp.p!=NULL) free(fp.p);
+	fp.n=0;
+	fp.p=NULL;
+	typeinput=0;
+	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
+}
+void window_copy(char *path)
+{
+	s3dw_surface *infwin;
+	s3dw_button  *okbutton,*abortbutton;
+	float l;
+	char destdir[M_DIR];
+
+	int i,m;
+
+	if (fp.n!=0) 	{	window_fs_another(); 	return; }
+	fp.n=0;
+	fp.p=NULL;
+	get_selected(&fp,&root);
+	printf("selected %d nodes\n",fp.n);
+	if (fp.n == 0)	{	window_fs_nothing();	return;	}
+	m=10;
+	for (i=0;i<fp.n;i++)
+	{
+		if (strlen(fp.p[i])>m) m=strlen(fp.p[i]);
+		printf("%d: %s\n",i,fp.p[i]);
+	}
+
+	l=(m+3)*0.7;
+	infwin=s3dw_surface_new("Copy Window",l,fp.n+8);
+	s3dw_label_new(infwin,"Copy: ",1,1);
+	for (i=0;i<fp.n;i++)
+		s3dw_label_new(infwin,fp.p[i],3,2+i);
+	s3dw_label_new(infwin,"to:",1,fp.n+3);
+	get_path(focus,destdir);
+	s3dw_label_new(infwin,destdir,3,fp.n+4);
+
+	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp.n+5);
+	okbutton->onclick=window_fs_abort;
+	abortbutton=s3dw_button_new(infwin,"abort",l/2,fp.n+5);
+	abortbutton->onclick=window_fs_abort;
+
+	s3dw_show(S3DWIDGET(infwin));
+
+}
+s3dw_input	 *input;
+void window_fs_mkdir(s3dw_widget *button)
+{
+	char *dir;
+	t_item *item;
+	dir=s3dw_input_gettext(input);
+	printf("creating Directory ...%s\n",dir);
+	if (-1==mkdir(dir,0777)) /* umask ?! */
+		window_fs_errno("could not create directory");
+	else {
+		/* success, now refresh it */
+		item=get_item(dir);
+		if (item==NULL)
+		{
+			printf("cannot refresh\n");
+		} else {
+			printf("refreshing %s\n",item->name);
+			parse_again(item);
+
+		}
+				
+	}
+	window_fs_abort(button); /* finish */
+
+}
+void window_mkdir(char *path)
+{
+	s3dw_surface *infwin;
+	s3dw_button  *okbutton,*abortbutton;
+	char string1[M_DIR];
+	float l;
+	if (fp.n!=0) {window_fs_another(); return; }
+	snprintf(string1,M_DIR,"Create Directory in %s",path);
+	l=strlen(string1)*0.7;
+	infwin=s3dw_surface_new("Create Directory",l,8);
+	s3dw_label_new(infwin,string1,1,2);
+	input=s3dw_input_new(infwin,10,1,3);
+	s3dw_input_change_text(input, path);
+	s3dw_focus(S3DWIDGET(input));
+	s3dw_focus(S3DWIDGET(infwin));
+	typeinput=1;
+	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp.n+5);
+	okbutton->onclick=window_fs_mkdir;
+	abortbutton=s3dw_button_new(infwin,"abort",l/2,fp.n+5);
+	abortbutton->onclick=window_fs_abort;
+	s3dw_show(S3DWIDGET(infwin));
+
+}
+
+void window_move(char *path)
+{
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+	if (fp.n!=0) {window_fs_another(); return; }
+	infwin=s3dw_surface_new("Info Window",20,8);
+	s3dw_label_new(infwin,"Sorry, moving is not implemented yet.. :(",1,2);
+	button=s3dw_button_new(infwin,"Too bad",7,5);
+	button->onclick=close_win;
+	s3dw_show(S3DWIDGET(infwin));
+
+}
 /* a small window which counts directories/files and displays the result */
-void info_window(char *path)
+void window_info(char *path)
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;
@@ -145,5 +358,4 @@
 	button->onclick=close_win;
 	/* of couse, show it */
 	s3dw_show(S3DWIDGET(infwin));
-
 }

Modified: trunk/apps/s3dfm/main.c
===================================================================
--- trunk/apps/s3dfm/main.c	2006-09-03 16:57:33 UTC (rev 378)
+++ trunk/apps/s3dfm/main.c	2006-09-11 20:04:38 UTC (rev 379)
@@ -68,6 +68,42 @@
 	} else
 		mstrncpy(path,dir->name,M_DIR);
 }
+/* find the item to a path, return NULL if not parsed yet */
+t_item *get_item(char *path)
+{
+	char p[M_DIR];
+	char *s,*match;
+	t_item *cur;
+	int i;
+	
+	if (path==NULL) return NULL;
+	if (path[0]=='/')
+	{
+		strncpy(p,path,M_DIR);
+		s=p+1;
+		cur=&root;
+	} else return NULL; /* TODO: also process local paths. right now, we are to lazy */
+	printf("processing rest of string %s\n",s);
+	match=s;
+	while ((s=index(s,'/'))!=NULL) { /* while we have slashes inside */
+		s[0]=0; /* mark the slash with space */
+		s++;	/* move to the next */
+		/* parse ... */
+		printf("looking for a match for %s\n",match);
+		for (i=0;i<cur->n_item;i++)
+			if (0==strcmp(cur->list[i].name,match))
+			{ /* found !! */
+				cur=&(cur->list[i]); /* forward */
+				match=s; /* select next */
+				break;
+			}
+		if (i==cur->n_item) {
+			printf("found no match for %s :(\n",match);
+			return NULL; /* not found */
+		}
+	}
+	return(cur);
+}
 /* finds an item in the tree by oid */
 t_item *finditem(t_item *t, int oid)
 {

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2006-09-03 16:57:33 UTC (rev 378)
+++ trunk/apps/s3dfm/s3dfm.h	2006-09-11 20:04:38 UTC (rev 379)
@@ -73,6 +73,7 @@
 extern t_item root;
 /* main.c */
 void get_path(t_item *dir, char *path);
+t_item *get_item(char *path);
 t_item *finditem(t_item *t, int oid);
 void mainloop();
 /* parse.c */
@@ -118,4 +119,8 @@
 /* dialog.c */
 void key_handler(struct s3d_evt *evt);
 void object_click(struct s3d_evt *evt);
-void info_window(char *path);
+void window_info(char *path);
+void window_help();
+void window_copy(char *path);
+void window_move(char *path);
+void window_mkdir(char *path);



From dotslash at mail.berlios.de  Mon Sep 11 22:13:04 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 11 Sep 2006 22:13:04 +0200
Subject: [S3d-svn] r380 - in trunk: . apps/s3dfm
Message-ID: <200609112013.k8BKD4a0009073@sheep.berlios.de>

Author: dotslash
Date: 2006-09-11 22:13:03 +0200 (Mon, 11 Sep 2006)
New Revision: 380

Modified:
   trunk/
   trunk/apps/s3dfm/dialog.c
Log:
 r900 at balthasar:  dotslash | 2006-09-11 22:12:59 +0200
 - properly refreshing root (focus fix)
 - help window cleanup



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:898
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:900

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2006-09-11 20:04:38 UTC (rev 379)
+++ trunk/apps/s3dfm/dialog.c	2006-09-11 20:13:03 UTC (rev 380)
@@ -57,6 +57,7 @@
 				{/* refresh this window ... */
 					printf("[R]efreshing %s\n",focus->name);
 					parse_again(focus);
+					ani_focus(focus);
 				}
 				break;
 		case S3DK_F1:
@@ -166,18 +167,13 @@
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;
-	char string1[M_DIR];
 	infwin=s3dw_surface_new("Help Window",12,12);
-	snprintf(string1,M_DIR,"F1 - This Help Window");
-	s3dw_label_new(infwin,string1,1,2);
-	snprintf(string1,M_DIR,"F5 - Copy");
-	s3dw_label_new(infwin,string1,1,3);
-	snprintf(string1,M_DIR,"F6 - Move");
-	s3dw_label_new(infwin,string1,1,4);
-	snprintf(string1,M_DIR,"R - Refresh");
-	s3dw_label_new(infwin,string1,1,5);
-	snprintf(string1,M_DIR,"I - Info");
-	s3dw_label_new(infwin,string1,1,6);
+	s3dw_label_new(infwin,"F1 - This Help Window",1,2);
+	s3dw_label_new(infwin,"F5 - Copy",1,3);
+	s3dw_label_new(infwin,"F6 - Move",1,4);
+	s3dw_label_new(infwin,"F7 - Create Directory",1,5);
+	s3dw_label_new(infwin,"R - Refresh",1,6);
+	s3dw_label_new(infwin,"I - Info",1,7);
 
 	button=s3dw_button_new(infwin,"OK",4,10);
 	button->onclick=close_win;



From marec at mail.berlios.de  Fri Sep 15 18:23:18 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Fri, 15 Sep 2006 18:23:18 +0200
Subject: [S3d-svn] r381 - in trunk: example libs3d libs3d/libg3d/include/g3d
	libs3d/libg3d/plugins/image libs3d/libg3d/plugins/import
	libs3d/libg3d/src
Message-ID: <200609151623.k8FGNI4d018431@sheep.berlios.de>

Author: marec
Date: 2006-09-15 18:23:16 +0200 (Fri, 15 Sep 2006)
New Revision: 381

Added:
   trunk/libs3d/libg3d/include/g3d/config.h
   trunk/libs3d/libg3d/plugins/import/imp_3ds.h
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.h
   trunk/libs3d/libg3d/plugins/import/imp_3ds_chunks.h
   trunk/libs3d/libg3d/plugins/import/imp_iob.h
   trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.c
   trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.h
   trunk/libs3d/libg3d/plugins/import/imp_iob_chunks.h
   trunk/libs3d/libg3d/plugins/import/imp_lwo.h
   trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.c
   trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.h
   trunk/libs3d/libg3d/plugins/import/imp_lwo_chunks.h
   trunk/libs3d/libg3d/plugins/import/imp_maya.c
   trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.c
   trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.h
   trunk/libs3d/libg3d/plugins/import/imp_maya_chunks.h
   trunk/libs3d/libg3d/plugins/import/imp_maya_obj.c
   trunk/libs3d/libg3d/plugins/import/imp_maya_obj.h
   trunk/libs3d/libg3d/plugins/import/imp_maya_var.c
   trunk/libs3d/libg3d/plugins/import/imp_maya_var.h
   trunk/libs3d/libg3d/plugins/import/imp_r4.c
   trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.c
   trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.h
   trunk/libs3d/libg3d/plugins/import/imp_r4_chunks.h
   trunk/libs3d/libg3d/plugins/import/imp_test.c
   trunk/libs3d/libg3d/src/object-orig.c
Removed:
   trunk/libs3d/libg3d/plugins/image/img_bmp.c.patch
   trunk/libs3d/libg3d/plugins/image/img_bmp_org.c
Modified:
   trunk/example/3dsloader_g3d.c
   trunk/libs3d/3dsread.c
   trunk/libs3d/libg3d/include/g3d/iff.h
   trunk/libs3d/libg3d/include/g3d/matrix.h
   trunk/libs3d/libg3d/include/g3d/model.h
   trunk/libs3d/libg3d/include/g3d/primitive.h
   trunk/libs3d/libg3d/include/g3d/read.h
   trunk/libs3d/libg3d/include/g3d/texture.h
   trunk/libs3d/libg3d/include/g3d/types.h
   trunk/libs3d/libg3d/plugins/image/img_bmp.c
   trunk/libs3d/libg3d/plugins/import/imp_3dmf.c
   trunk/libs3d/libg3d/plugins/import/imp_3ds.c
   trunk/libs3d/libg3d/plugins/import/imp_cob.c
   trunk/libs3d/libg3d/plugins/import/imp_iob.c
   trunk/libs3d/libg3d/plugins/import/imp_leocad.c
   trunk/libs3d/libg3d/plugins/import/imp_leocad_library.c
   trunk/libs3d/libg3d/plugins/import/imp_lwo.c
   trunk/libs3d/libg3d/plugins/import/imp_obj.c
   trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.l
   trunk/libs3d/libg3d/src/iff.c
   trunk/libs3d/libg3d/src/matrix.c
   trunk/libs3d/libg3d/src/model.c
   trunk/libs3d/libg3d/src/object.c
   trunk/libs3d/libg3d/src/plugins.c
   trunk/libs3d/libg3d/src/primitive.c
   trunk/libs3d/libg3d/src/read.c
   trunk/libs3d/libg3d/src/texture.c
   trunk/libs3d/libg3d/src/vector.c
Log:
libg3d update

Modified: trunk/example/3dsloader_g3d.c
===================================================================
--- trunk/example/3dsloader_g3d.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/example/3dsloader_g3d.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -130,7 +130,7 @@
 			while ( oitem ) {
 
 				object = (G3DObject *)oitem->data;
-				
+
 				/* push vertices */
 				for ( j = 0; j < object->vertex_count; j++ ) {
 					/* 3. and 4. param have to change places otherwise the object will be turned */
@@ -202,9 +202,10 @@
 					/* face with texture */
 					if ( ( mat2tex->texture_id != -1 ) && ( face->flags & G3D_FLAG_FAC_TEXMAP ) ) {
 
-						/* printf( "neues face: %i\n", face->tex_vertex_count ); */
-						s3d_pep_polygon_tex_coord( obj_id, face->tex_vertex_data[5], face->tex_vertex_data[4], face->tex_vertex_data[3], face->tex_vertex_data[2], face->tex_vertex_data[1], face->tex_vertex_data[0] );
+						/* printf( "text_coords: %f:%f %f:%f %f:%f\n", face->tex_vertex_data[0], face->tex_vertex_data[1], face->tex_vertex_data[2], face->tex_vertex_data[3], face->tex_vertex_data[4], face->tex_vertex_data[5] ); */
 
+						s3d_pep_polygon_tex_coord( obj_id, face->tex_vertex_data[0], face->tex_vertex_data[1], face->tex_vertex_data[2], face->tex_vertex_data[3], face->tex_vertex_data[4], face->tex_vertex_data[5] );
+
 					}
 
 
@@ -216,6 +217,7 @@
 				oitem = oitem->next;
 
 			}
+
 			s3d_flags_on( obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE );
 
 			s3d_mainloop(mainloop);

Modified: trunk/libs3d/3dsread.c
===================================================================
--- trunk/libs3d/3dsread.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/3dsread.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -38,14 +38,14 @@
 #ifndef OBJSDIR
 #define OBJSDIR 	"./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/"
 #endif
-	
+
 	strncpy(searchpath,OBJSDIR,1023);
 	searchpath[1023]=0;							/* just in case */
 	next=ptr=searchpath;
 	while (next!=NULL)
 	{
 		next=NULL;
-		
+
 		if (NULL!=(next=strchr(ptr,':')))
 		{
 			*next=0; 							/* clear the delimiter */
@@ -97,7 +97,7 @@
 	min=0;
 	for (i=0;i<polynum;i++)
 	{
-		if (smooth_list[i]<minv) 
+		if (smooth_list[i]<minv)
 		{
 			min=i;
 			minv=smooth_list[i];
@@ -108,7 +108,7 @@
 #define EL	4*sizeof(unsigned long)
 		memcpy(polyel,poly_buf,EL);  /* save */
 		memcpy(poly_buf,poly_buf+4*min,EL);  /* put at first place */
-		memcpy(poly_buf+4*min,polyel,EL); 
+		memcpy(poly_buf+4*min,polyel,EL);
 		 /*  now the same with smooth_list */
 		i=smooth_list[0];
 		smooth_list[0]=smooth_list[min];
@@ -119,7 +119,7 @@
 	{
 		sort_poly(smooth_list+1,poly_buf+4,polynum-1);
 	}
-	
+
 }
 struct t_vertex_normal
 {
@@ -168,7 +168,7 @@
 						v_t_buf[k].n[n]=0;
 					v_t_buf[k].g=-1;  /*  we're telling this by setting group to -1 */
 				}
-				else 
+				else
 					for (n=0;n<3;n++)
 						v_t_buf[k].n[n]/=len;
 				v_t_buf[k].num=1;
@@ -224,7 +224,7 @@
 			}
 		}
 		 /* s3dprintf(LOW,"polygon [%d/%d]: %d %d %d is in smoothlist %d",i,polynum,v[0],v[1],v[2],g); */
-		
+
 		normal(	vertex_buf+v[0]*3,
 				vertex_buf+v[1]*3,
 				vertex_buf+v[2]*3,
@@ -276,7 +276,7 @@
 	char materials[256][MAXSTRN+1];
 	int clen,cid;
 	int filesize=1;  /*  just so it hops above the main chunk ... */
-	int vertex_offset=0; 
+	int vertex_offset=0;
 	int v=0;
 	int col_obj=-1;
 	unsigned long *poly_buf=NULL,*tpbuf,*smooth_list=NULL;
@@ -294,7 +294,7 @@
 	{
 		cid=gints(ptr);
 		clen=gintl(ptr+2);
-		
+
 		s3dprintf (VLOW,"[pos %x]: \t%04x [len:%d]",(ptr-buf),cid,(clen-6));
 		if ((ptr==buf) && (cid!=0x4d4d))
 		{
@@ -304,7 +304,7 @@
 		ptr=ptr+6;  /*  point to the data .. */
 		switch (cid)
 		{
-		  case 0x4d4d: 
+		  case 0x4d4d:
 			  s3dprintf(VLOW,"-- the main chunk!!");
 			  filesize=clen;
 			  if (cur_oid==-1)
@@ -331,7 +331,7 @@
 			  smooth_list=NULL;
 			  mesh_end=ptr+(clen-6);
 			  break;
-		  case 0x4110: 
+		  case 0x4110:
 			  vertexnum=gints(ptr);
 			  ptr+=sizeof(unsigned short);
 			  s3dprintf(VLOW,"-- vertices list!! number of vertices: %d",vertexnum);
@@ -355,7 +355,7 @@
 			if (poly_buf==NULL) break;
 		    for (j=0; j<polynum; j++)
 			{
-				poly_buf[j*4+0]=vertex_offset+gints(ptr+0); 
+				poly_buf[j*4+0]=vertex_offset+gints(ptr+0);
 				poly_buf[j*4+1]=vertex_offset+gints(ptr+4);
 				poly_buf[j*4+2]=vertex_offset+gints(ptr+2);
 				poly_buf[j*4+3]=col_obj;  /*  we should have a default material .... */
@@ -381,7 +381,7 @@
 			{
 				j=gints(ptr+2*i);
 				if (j>=0 && j<polynum)
-					poly_buf[gints(ptr+2*i)*4+3]=col_obj; 
+					poly_buf[gints(ptr+2*i)*4+3]=col_obj;
 				else {
 					errds(MED,"s3d_import_3ds()","polygon %d out of range!",j);
 				}
@@ -390,10 +390,12 @@
 			break;
 		  case 0x4150:
 			s3dprintf(VLOW,"-- smoothing group information (length %d [%d])", clen,clen/4);
+			printf( "-- smoothing group information (length %d [%d])", clen, clen/4 );
 			smooth_list=(unsigned long *)ptr;
 			for (j=0;j<(clen/4);j++)
 			{
 				smooth_list[j]=gintl(ptr+j*4);
+				printf( "smooth_list[%i] = %i", j, smooth_list[j] );
 			}
 
 			ptr=(char *)ptr+(clen-6);
@@ -496,7 +498,7 @@
 		{
 			mesh_end=NULL;
 			if ((vertex_buf!=NULL))
-			    s3d_push_vertices(cur_oid, vertex_buf, vertexnum); 
+			    s3d_push_vertices(cur_oid, vertex_buf, vertexnum);
 			if (poly_buf!=NULL)
 			{
 				if (smooth_list!=NULL)

Added: trunk/libs3d/libg3d/include/g3d/config.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/config.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/config.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,149 @@
+/* libs3d/libg3d/include/g3d/config.h.  Generated from config.h.in by configure.  */
+/* libs3d/libg3d/include/g3d/config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Use GLUT */
+/* #undef G_GLUT */
+
+/* Use SDL */
+#define G_SDL 1
+
+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+   */
+#define HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+/* #undef HAVE_NDIR_H */
+
+/* Define to 1 if you have the `select' function. */
+#define HAVE_SELECT 1
+
+/* Define to 1 if you have the `shmget' function. */
+#define HAVE_SHMGET 1
+
+/* Define to 1 if you have the `signal' function. */
+#define HAVE_SIGNAL 1
+
+/* Define to 1 if you have the `socket' function. */
+#define HAVE_SOCKET 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strtod' function. */
+#define HAVE_STRTOD 1
+
+/* Define to 1 if you have the `strtol' function. */
+#define HAVE_STRTOL 1
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Name of package */
+#define PACKAGE "s3d"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "s3d"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "s3d 0.1"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "s3d"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.1"
+
+/* Plugin directory */
+#define PLUGIN_DIR "/usr/local/lib/s3d/plugins"
+
+/* Define to 1 if the C compiler supports function prototypes. */
+#define PROTOTYPES 1
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* Define to 1 if the `setvbuf' function takes the buffering type as its
+   second argument and the buffer pointer as the third, as on System V before
+   release 3. */
+/* #undef SETVBUF_REVERSED */
+
+/* Define if shared memory networking code should be compiled */
+#define SHM 1
+
+/* Define if signal code should be compiled */
+#define SIGS 1
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define if TCP/IP network code should be compiled */
+#define TCP 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+/* #undef TM_IN_SYS_TIME */
+
+/* Version number of package */
+#define VERSION "0.1"
+
+/* Define to 1 if the X Window System is missing or not being used. */
+/* #undef X_DISPLAY_MISSING */
+
+/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
+   `char[]'. */
+#define YYTEXT_POINTER 1
+
+/* Define like PROTOTYPES; this can be used by system headers. */
+#define __PROTOTYPES 1
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */

Modified: trunk/libs3d/libg3d/include/g3d/iff.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/iff.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/iff.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -26,6 +26,16 @@
 #include <stdio.h>
 #include <glib.h>
 
+#include <g3d/types.h>
+
+#define G3D_IFF_PAD1   0x01
+#define G3D_IFF_PAD2   0x02
+#define G3D_IFF_PAD4   0x04
+#define G3D_IFF_PAD8   0x08
+
+#define G3D_IFF_SUBCHUNK_LEN16   0x10
+#define G3D_IFF_LEN16            0x20
+
 #define G3D_IFF_MKID(a,b,c,d) ( \
 	(((guint32)(a))<<24) | \
 	(((guint32)(b))<<16) | \
@@ -34,6 +44,37 @@
 
 G_BEGIN_DECLS
 
+/* global data */
+typedef struct {
+	G3DContext *context;
+	G3DModel *model;
+	FILE *f;
+	guint32 flags;
+	gpointer user_data;
+	long int max_fpos;
+} g3d_iff_gdata;
+
+/* local data */
+typedef struct {
+	guint32 id;
+	guint32 parent_id;
+	gpointer object;
+	gint32 level;
+	gpointer level_object;
+	gint32 nb;
+	gboolean finalize;
+} g3d_iff_ldata;
+
+typedef gboolean (*g3d_iff_chunk_callback)(
+	g3d_iff_gdata *global, g3d_iff_ldata *local);
+
+typedef struct {
+	gchar *id;
+	gchar *description;
+	gboolean container;
+	g3d_iff_chunk_callback callback;
+} g3d_iff_chunk_info;
+
 /**
  * g3d_iff_open:
  * @filename: file name of IFF file
@@ -51,13 +92,22 @@
  * @f: the open IFF file pointer
  * @id: ID of chunk (out)
  * @len: length of chunk (excluding header) (out)
+ * @flags: flags
  *
  * Reads one chunk header from an IFF file.
  *
  * Returns: real length of chunk including header and possible padding byte
  */
-int g3d_iff_readchunk(FILE *f, guint32 *id, guint32 *len);
+int g3d_iff_readchunk(FILE *f, guint32 *id, guint32 *len, guint32 flags);
 
+gchar *g3d_iff_id_to_text(guint32 id);
+
+gboolean g3d_iff_chunk_matches(guint32 id, gchar *tid);
+
+gboolean g3d_iff_read_ctnr(g3d_iff_gdata *global, g3d_iff_ldata *local,
+	g3d_iff_chunk_info *chunks, guint32 flags);
+
+
 G_END_DECLS
 
 #endif

Modified: trunk/libs3d/libg3d/include/g3d/matrix.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/matrix.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/matrix.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -27,6 +27,13 @@
 
 G_BEGIN_DECLS
 
+/*
+ * gfloat matrix[16]:
+ *
+ * matrix[col * 4 + row] = f;
+ *
+ */
+
 /**
  * g3d_matrix_identity:
  * @matrix: 4x4 matrix (float[16])
@@ -90,6 +97,39 @@
  */
 gboolean g3d_matrix_rotate_xyz(gfloat rx, gfloat ry, gfloat rz, gfloat *rm);
 
+/**
+ * g3d_matrix_scale:
+ * @x: x factor
+ * @y: y factor
+ * @z: z factor
+ * @rm: resulting matrix
+ *
+ * Adds a scaling to the matrix.
+ *
+ * Returns: TRUE on success, FALSE else
+ */
+gboolean g3d_matrix_scale(gfloat x, gfloat y, gfloat z, gfloat *rm);
+
+/**
+ * g3d_matrix_transpose:
+ * @matrix: the matrix
+ *
+ * Transposes the matrix.
+ *
+ * Returns: TRUE on success, FALSE else
+ */
+gboolean g3d_matrix_transpose(gfloat *matrix);
+
+/**
+ * g3d_matrix_dump:
+ * @matrix: the matrix
+ *
+ * If debugging is enabled, this function dump the matrix to stderr.
+ *
+ * Returns: TRUE if matrix is dumped, FALSE else
+ */
+gboolean g3d_matrix_dump(gfloat *matrix);
+
 G_END_DECLS
 
 #endif /* __G3D_MATRIX_H__ */

Modified: trunk/libs3d/libg3d/include/g3d/model.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/model.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/model.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -85,6 +85,17 @@
  */
 void g3d_model_free(G3DModel *model);
 
+/**
+ * g3d_model_get_object_by_name:
+ * @model: the model containing all objects
+ * @name: the name of the requested object
+ *
+ * Searches the object tree for an object with the given name.
+ *
+ * Returns: the requested object or NULL if non was found
+ */
+G3DObject *g3d_model_get_object_by_name(G3DModel *model, const gchar *name);
+
 G_END_DECLS
 
 #endif /* __G3D_MODEL_H__ */

Modified: trunk/libs3d/libg3d/include/g3d/primitive.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/primitive.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/primitive.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -27,6 +27,9 @@
 
 G_BEGIN_DECLS
 
+G3DObject *g3d_primitive_cube(gfloat width, gfloat height, gfloat depth,
+	G3DMaterial *material);
+
 /**
  * g3d_primitive_cylinder:
  * @radius: the radius of the cylinder
@@ -60,6 +63,20 @@
 G3DObject *g3d_primitive_tube(gfloat r_in, gfloat r_out, gfloat height,
 	guint32 sides, gboolean top, gboolean bottom, G3DMaterial *material);
 
+/**
+ * g3d_primitive_sphere:
+ * @radius: radius
+ * @vseg: number of vertical segments
+ * @hseg: number of horizontal segments
+ * @materal: material to use for faces
+ *
+ * Generates an object containing a sphere.
+ *
+ * Returns: sphere object
+ */
+G3DObject *g3d_primitive_sphere(gfloat radius, guint32 vseg, guint32 hseg,
+	G3DMaterial *material);
+
 G_END_DECLS
 
 #endif /* __G3D_PRIMITIVE_H__ */

Modified: trunk/libs3d/libg3d/include/g3d/read.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/read.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/read.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -98,6 +98,30 @@
  */
 gfloat g3d_read_float_le(FILE *f);
 
+/**
+ * g3d_read_double_be:
+ * @f: the file to read from
+ *
+ * Read a 8 byte big-endian double-precision floating point number from file.
+ *
+ * Returns: The read value, 0 in case of error
+ */
+gdouble g3d_read_double_be(FILE *f);
+
+/**
+ * g3d_read_double_be:
+ * @f: the file to read from
+ *
+ * Read a 8 byte little-endian double-precision floating point number from
+ * file.
+ *
+ * Returns: The read value, 0 in case of error
+ */
+
+gdouble g3d_read_double_le(FILE *f);
+
+gint32 g3d_read_cstr(FILE *f, gchar *buffer, gint32 max_len);
+
 G_END_DECLS
 
 #endif /* __G3D_READ_H__ */

Modified: trunk/libs3d/libg3d/include/g3d/texture.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/texture.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/texture.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -27,6 +27,8 @@
 
 G_BEGIN_DECLS
 
+G3DImage *g3d_texture_load(G3DContext *context, const gchar *filename);
+
 /**
  * g3d_texture_load_cached:
  * @context: a valid context
@@ -41,6 +43,8 @@
 G3DImage *g3d_texture_load_cached(G3DContext *context, G3DModel *model,
 	const gchar *filename);
 
+void g3d_texture_free(G3DImage *texture);
+
 /**
  * g3d_texture_prepare:
  * @texture: a texture image
@@ -53,6 +57,10 @@
  */
 gboolean g3d_texture_prepare(G3DImage *texture);
 
+gboolean g3d_texture_flip_y(G3DImage *texture);
+
+G3DImage *g3d_texture_merge_alpha(G3DImage *image, G3DImage *aimage);
+
 G_END_DECLS
 
 #endif /* __G3D_TEXTURE_H__ */

Modified: trunk/libs3d/libg3d/include/g3d/types.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/types.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/include/g3d/types.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -85,6 +85,16 @@
 } G3DFace;
 
 /*****************************************************************************
+ * G3DTransformation
+ *****************************************************************************/
+
+typedef struct {
+	gfloat matrix[16];
+	guint32 flags;
+} G3DTransformation;
+
+
+/*****************************************************************************
  * G3DObject
  *****************************************************************************/
 typedef struct {
@@ -94,6 +104,9 @@
 	GSList *faces;
 	GSList *objects;
 
+	/* transformation, may be NULL */
+	G3DTransformation *transformation;
+
 	/* don't render this object */
 	gboolean hide;
 

Modified: trunk/libs3d/libg3d/plugins/image/img_bmp.c
===================================================================
--- trunk/libs3d/libg3d/plugins/image/img_bmp.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/image/img_bmp.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -57,7 +57,7 @@
 	headsize = g3d_read_int32_le(f);      /* size of header */
 	image->width  = g3d_read_int32_le(f); /* width */
 	image->height = g3d_read_int32_le(f); /* height */
-	g3d_read_int16_le(f);                               /* num of color planes */
+	g3d_read_int16_le(f);                 /* num of color planes */
 	image->depth  = g3d_read_int16_le(f); /* bits per pixel */
 	compression   = g3d_read_int32_le(f); /* compression */
 	g3d_read_int32_le(f);                 /* image size */

Deleted: trunk/libs3d/libg3d/plugins/image/img_bmp.c.patch
===================================================================
--- trunk/libs3d/libg3d/plugins/image/img_bmp.c.patch	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/image/img_bmp.c.patch	2006-09-15 16:23:16 UTC (rev 381)
@@ -1,11 +0,0 @@
---- img_bmp_org.c	2006-01-24 11:04:19.000000000 +0100
-+++ img_bmp.c	2006-05-18 18:11:23.000000000 +0200
-@@ -32,7 +32,7 @@
- {
- 	FILE *f;
- 	guint32 filesize, offset, headsize, compression;
--	guint32 x, y;
-+	gint32 x, y;
- 
- 	f = fopen(filename, "r");
- 	if(f == NULL)

Deleted: trunk/libs3d/libg3d/plugins/image/img_bmp_org.c
===================================================================
--- trunk/libs3d/libg3d/plugins/image/img_bmp_org.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/image/img_bmp_org.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -1,130 +0,0 @@
-/* $Id: img_bmp.c,v 1.1.2.2 2006/01/23 16:44:28 dahms Exp $ */
-
-/*
-    libg3d - 3D object loading library
-
-    Copyright (C) 2005, 2006  Markus Dahms <mad at automagically.de>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-
-#include <g3d/types.h>
-#include <g3d/read.h>
-
-gboolean plugin_load_image(G3DContext *context, const gchar *filename,
-	G3DImage *image, gpointer user_data)
-{
-	FILE *f;
-	guint32 filesize, offset, headsize, compression;
-	guint32 x, y;
-
-	f = fopen(filename, "r");
-	if(f == NULL)
-	{
-		g_printerr("couldn't open image file '%s': %s\n", filename,
-			strerror(errno));
-		return FALSE;
-	}
-
-	/* bitmap file always starts with 'BM' */
-	if(g3d_read_int16_le(f) != ('B' | ('M' << 8)))
-	{
-		g_printerr("bitmap magic not found: image seems to be corrupt\n");
-		return FALSE;
-	}
-
-	image->name = g_strdup(filename);
-
-	filesize = g3d_read_int32_le(f);      /* file size */
-	g3d_read_int32_le(f);                 /* 2 x UINT16 reserved */
-	offset   = g3d_read_int32_le(f);      /* offset of data */
-	headsize = g3d_read_int32_le(f);      /* size of header */
-	image->width  = g3d_read_int32_le(f); /* width */
-	image->height = g3d_read_int32_le(f); /* height */
-	g3d_read_int16_le(f);                               /* num of color planes */
-	image->depth  = g3d_read_int16_le(f); /* bits per pixel */
-	compression   = g3d_read_int32_le(f); /* compression */
-	g3d_read_int32_le(f);                 /* image size */
-	g3d_read_int32_le(f);                 /* v/res (dpi) */
-	g3d_read_int32_le(f);                 /* h/res (dpi) */
-
-	fseek(f, offset, SEEK_SET);
-
-#define ALL32BIT
-#ifndef ALL32BIT /* always 32bit for now.. */
-	image->pixeldata = g_malloc0(image->width*image->height*(image->depth/8));
-#else
-	image->pixeldata = g_malloc0(image->width * image->height * 4);
-#endif
-
-	for(y=image->height-1; y>=0; y--)
-	{
-#if DEBUG > 5
-		g_printerr("| ");
-#endif
-		for(x=0; x<image->width; x++)
-		{
-			switch(image->depth)
-			{
-				case 8:
-#ifndef ALL32BIT
-					image->pixeldata[y*image->width+x] = g3d_read_int8(f);
-#else
-					image->pixeldata[(y*image->width+x)*4+0] = g3d_read_int8(f);
-					image->pixeldata[(y*image->width+x)*4+3] = 0xFF;
-#endif
-#if DEBUG > 5
-					g_printerr("%2.2X ", image->pixeldata[y*image->width+x]);
-#endif
-					break;
-				case 24:
-					image->pixeldata[(y*image->width+x)*4+0] = g3d_read_int8(f);
-					image->pixeldata[(y*image->width+x)*4+1] = g3d_read_int8(f);
-					image->pixeldata[(y*image->width+x)*4+2] = g3d_read_int8(f);
-					image->pixeldata[(y*image->width+x)*4+3] = 0xFF;
-					break;
-				default:
-					break;
-			}
-		}
-#if DEBUG > 5
-		g_printerr("\n");
-#endif
-	}
-	image->depth = 32;
-#if DEBUG > 2
-	g_printerr("bitmap successfully loaded\n");
-#endif
-
-	return TRUE;
-}
-
-gchar *plugin_description(G3DContext *context)
-{ 
-	return g_strdup(
-		"Plugin to read Windows Bitmap (.bmp) images\n"
-		"(for use as textures or height fields)\n"
-		"Author: Markus Dahms");
-}
-
-gchar **plugin_extensions(G3DContext *context)
-{
-	return g_strsplit("bmp", ":", 0);
-}
-

Modified: trunk/libs3d/libg3d/plugins/import/imp_3dmf.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3dmf.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_3dmf.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -72,7 +72,7 @@
 		return FALSE;
 	}
 
-	g3d_iff_readchunk(f, &id, &len);
+	g3d_iff_readchunk(f, &id, &len, 0);
 	if((id != G3D_IFF_MKID('3', 'D', 'M', 'F')) ||
 		(len != 16))
 	{
@@ -409,7 +409,7 @@
 
 	object = x3dmf_object_new(f, model);
 
-	g3d_iff_readchunk(f, &id, &len);
+	g3d_iff_readchunk(f, &id, &len, 0);
 	switch(id)
 	{
 		case G3D_IFF_MKID('c', 't', 'n', 'r'):
@@ -438,7 +438,7 @@
 	{
 		if(feof(f)) break;
 
-		g3d_iff_readchunk(f, &id, &len);
+		g3d_iff_readchunk(f, &id, &len, 0);
 		length -= 8;
 
 		if(id == 0)

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -29,19 +29,9 @@
 #include <g3d/material.h>
 #include <g3d/texture.h>
 
-int x3ds_container(FILE *f, guint32 nb, G3DContext *context, G3DModel *model,
-	gpointer pobject, gint32 level, gint32 parent);
-int x3ds_read_cstr(FILE *f, char *string);
-int x3ds_read_pointarray(FILE *f, int nb, G3DObject *object, int level);
-int x3ds_read_facearray(FILE *f, int nb, G3DObject *object);
-int x3ds_read_meshmatgrp(FILE *f, int nb, G3DModel *model, G3DObject *object,
-	int level);
-void x3ds_debug(int level, char *format, ...);
-G3DObject *x3ds_newobject(G3DModel *model, const char *name);
+#include "imp_3ds.h"
+#include "imp_3ds_chunks.h"
 
-/* FIXME: replace */
-float x3ds_global_scale = 1.0;
-
 /*****************************************************************************/
 /* plugin interface                                                          */
 /*****************************************************************************/
@@ -51,6 +41,9 @@
 {
 	FILE *f;
 	gint32 nbytes, magic;
+	x3ds_global_data global;
+	x3ds_parent_data *parent;
+	long int fpos;
 
 	f = fopen(filename, "r");
 	if(f == NULL)
@@ -70,7 +63,29 @@
 	nbytes -= 6;
 	g_printerr("[%4.4X] 3DS file: main length: %d\n", magic, nbytes);
 
+	global.context = context;
+	global.model = model;
+	global.f = f;
+	global.scale = 1.0;
+	global.max_tex_id = 0;
+
+	/* get size of file */
+	fpos = ftell(global.f);
+	fseek(global.f, 0, SEEK_END);
+	global.max_fpos = ftell(global.f);
+	fseek(global.f, fpos, SEEK_SET);
+
+	parent = g_new0(x3ds_parent_data, 1);
+	parent->id = magic;
+	parent->nb = nbytes;
+
+	x3ds_read_ctnr(&global, parent);
+
+	g_free(parent);
+
+	/*
 	x3ds_container(f, nbytes, context, model, NULL, 1, magic);
+	*/
 
 	fclose(f);
 #if DEBUG > 0
@@ -92,380 +107,94 @@
 
 /*****************************************************************************/
 
-int x3ds_container(FILE *f, guint32 nb, G3DContext *context, G3DModel *model,
-	gpointer pobject, gint32 level, gint32 parent)
+gboolean x3ds_read_ctnr(x3ds_global_data *global, x3ds_parent_data *parent)
 {
-	gint32 chunk_id, chunk_len, nbytes, toread;
-	char name[2048];
-	G3DObject *new_object;
+	gint32 chunk_id, chunk_len, i;
+	x3ds_parent_data *subparent;
+	gpointer level_object;
 
-	nbytes = nb;
-	while(nbytes > 0)
+	level_object = NULL;
+
+	while(parent->nb > 0)
 	{
-		chunk_id  = g3d_read_int16_le(f);
-		chunk_len = g3d_read_int32_le(f);
-		nbytes -= 6;
+		chunk_id  = g3d_read_int16_le(global->f);
+		chunk_len = g3d_read_int32_le(global->f);
+		parent->nb -= 6;
 		chunk_len -= 6;
-		toread = chunk_len;
-		switch(chunk_id)
-		{
-			case 0x0002: { /* M3D version */
-				int version = g3d_read_int32_le(f);
-				x3ds_debug(level, "[%4.4XH] M3D Version: %d.%d (%d byte)\n",
-					 chunk_id, version & 0xFF, version >> 16, toread);
-				toread -= 4; }
-				break;
-			case 0x0011: { /* color 24 */
-				int r,g,b;
-				r = g3d_read_int8(f);
-				g = g3d_read_int8(f);
-				b = g3d_read_int8(f);
-				x3ds_debug(level,
-					"[%4.4XH] color (24 bit): #%.2X%.2X%.2X (%d byte)\n",
-					chunk_id, r,g,b, toread);
-				if((parent == 0xA010) || /* ambient color */
-					 (parent == 0xA020))   /* diffuse */
-				{
-					((G3DMaterial*)pobject)->r = (float)r / 255.0;
-					((G3DMaterial*)pobject)->g = (float)g / 255.0;
-					((G3DMaterial*)pobject)->b = (float)b / 255.0;
-				}
-				else if(parent == 0xA030) /* specular */
-				{
-					((G3DMaterial*)pobject)->specular[0] = (float)r / 255.0;
-					((G3DMaterial*)pobject)->specular[1] = (float)g / 255.0;
-					((G3DMaterial*)pobject)->specular[2] = (float)b / 255.0;
-					((G3DMaterial*)pobject)->specular[3] = 0.25;
-				}
-				else g_printerr("*** unhandled ***\n");
-				toread -= 3; }
-				break;
-			case 0x0030: { /* short percentage */
-				int percent = g3d_read_int16_le(f);
-				x3ds_debug(level, "[%4.4XH] percentage: %d%% (%d byte)\n",
-					chunk_id, percent, toread);
-				toread -= 2;
-				if(parent == 0xA040) /* shininess */
-				{
-					((G3DMaterial*)pobject)->shininess =
-						(gfloat)percent / 100.0;
-				}
-				else if(parent == 0xA050) /* transparency */
-				{
-					((G3DMaterial*)pobject)->a =
-						1.0 - ((gfloat)percent / 100.0);
-				}
-				else g_printerr("*** unhandled ***\n");
-				} break;
 
-			case 0x0031: { /* float percentage */
-				float fpercent = g3d_read_float_le(f);
-				x3ds_debug(level, "[%4.4XH] float percentage: %f (%d byte)\n",
-					chunk_id, fpercent, toread);
-				toread -= 4;
-				if(parent == 0xA040) /* shininess */
-				{
-					((G3DMaterial*)pobject)->shininess = fpercent;
-				}
-				else g_printerr("*** unhandled ***\n");
-				} break;
+		i = 0;
+		while((x3ds_chunks[i].id != 0) && (x3ds_chunks[i].id != chunk_id))
+			i ++;
 
-			case 0x0100: /* global scale */
-				x3ds_global_scale = g3d_read_float_le(f);
-				x3ds_debug(level, "[%4.4XH] master scale: %f (%d byte)\n",
-									 chunk_id, x3ds_global_scale, toread);
-				toread -= 4;
-				break;
-			case 0x3D3D: /* mesh */
-				x3ds_debug(level, "[%4.4XH] 3DS mesh object (%d byte)\n",
-									 chunk_id, toread);
-				x3ds_container(f, toread, context, model, NULL, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0x3D3E: { /* mesh version */
-				int minor, major;
-				major = g3d_read_int16_le(f);
-				minor = g3d_read_int16_le(f);
-				x3ds_debug(level, "[%4.4XH] mesh version %d.%d (%d byte)\n",
-					chunk_id, major, minor, toread);
-				toread -= 4; }
-				break;
-			case 0x4000: /* named object */
-				toread -= x3ds_read_cstr(f, name);
-				new_object = x3ds_newobject(model, name);
-				x3ds_debug(level,
-					"[%4.4XH] named object: %s (%d byte)\n", chunk_id,
-					 name, toread);
-				x3ds_container(f, toread, context, model, new_object,
-					level + 1, chunk_id);
-				toread = 0;
-				break;
-			case 0x4100: /* named triangle object */
-				x3ds_debug(level,
-					"[%4.4XH] named triangle object: %s (%d byte)\n",
-					chunk_id, "", chunk_len);
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0x4110: /* point array */
-				toread = x3ds_read_pointarray(f, toread, (G3DObject*)pobject,
-					level);
-				break;
-			case 0x4111: /* point flag array */
-				x3ds_debug(level, "[%4.4XH] point flag array (%d byte)\n",
-					chunk_id, toread);
-				fseek(f, toread, SEEK_CUR);
-				toread = 0;
-				break;
-			case 0x4120: /* face array */
-				x3ds_debug(level, "[%4.4XH] face array (%d byte)\n",
-									 chunk_id, toread);
-				toread = x3ds_read_facearray(f, toread, (G3DObject*)pobject);
-				if(toread != 0)
-				{
-					x3ds_container(f, toread, context, model, pobject,
-						level + 1, 0x4120);
-					toread = 0;
-				}
-				break;
-			case 0x4130: /* mesh mat group */
-				toread = x3ds_read_meshmatgrp(f, toread, model,
-					(G3DObject*)pobject, level);
-				break;
-			case 0x4140: { /* texture vertices */
-				G3DObject *object = (G3DObject*)pobject;
-				int i, bytes = toread;
-				object->tex_vertex_count = g3d_read_int16_le(f);
-				toread -= 2;
-				object->tex_vertex_data =
-					g_new0(gfloat, object->tex_vertex_count * 2);
-				for(i=0; i<object->tex_vertex_count; i++)
-				{
-					object->tex_vertex_data[i*2+0] = g3d_read_float_le(f);
-					object->tex_vertex_data[i*2+1] = g3d_read_float_le(f);
-					toread -= 8;
-				}
-				x3ds_debug(level,
-					"[%4.4XH] texture vertices: %d verts (%d byte)\n",
-					chunk_id, object->tex_vertex_count, bytes);
-				} break;
-			case 0x4150: /* smooth group */
-				x3ds_debug(level, "[%4.4XH] smooth group (%d byte)\n",
-					chunk_id, toread);
-				fseek(f, toread, SEEK_CUR);
-				toread = 0;
-				break;
-			case 0x4160: { /* mesh matrix / local axis */
-				gfloat matrix[16];
-				int w, h;
-				x3ds_debug(level, "[%4.4XH] mesh matrix (%d byte)\n",
-					chunk_id, toread);
-				for(w = 0; w < 4; w ++)
-				{
-#if DEBUG > 0
-					g_print("MATRIX:");
-#endif
-					for(h = 0; h < 3; h ++)
-					{
-						matrix[h * 4 + w] = g3d_read_float_le(f);
-#if DEBUG > 0
-						g_print(" %+2.2f", matrix[h * 4 + w]);
-#endif
-					}
-#if DEBUG > 0
-					g_print("\n");
-#endif
-				}
+		if(x3ds_chunks[i].id == chunk_id)
+		{
+			x3ds_debug(parent->level, "[0x%04X][%c%c] %s (%d bytes)\n",
+				chunk_id,
+				x3ds_chunks[i].container ? 'c' : ' ',
+				x3ds_chunks[i].callback ? 'f' : ' ',
+				x3ds_chunks[i].desc, chunk_len);
 
-				matrix[12] = matrix[13] = matrix[14] = 0.0;
-				matrix[15] = 1.0;
+			subparent = g_new0(x3ds_parent_data, 1);
+			subparent->id = parent->id;
+			subparent->object = parent->object;
+			subparent->level = parent->level + 1;
+			subparent->level_object = level_object;
+			subparent->nb = chunk_len;
 
-#if 0
-				for(i = 0; i < object->vertex_count; i ++)
-					g3d_vector_transform(
-						&(object->vertices[i * 3 + 0]),
-						&(object->vertices[i * 3 + 1]),
-						&(object->vertices[i * 3 + 2]),
-						matrix);
-#endif
-				toread -= 48;
-				} break;
+			if(x3ds_chunks[i].callback)
+			{
+				/* callback may change "nb" and "object" of
+				 * "subparent" structure for following container run */
 
-			case 0x4165: /* mesh color */
-				x3ds_debug(level, "[%4.4XH] mesh color %d (%d byte)\n",
-					chunk_id, g3d_read_int8(f), toread);
-				toread -= 1;
-				fseek(f, toread, SEEK_CUR);
-				toread = 0;
-				break;
+				x3ds_chunks[i].callback(global, subparent);
+			}
 
-			case 0x4170: /* texture info */
-				x3ds_debug(level, "[%4.4XH] texture info (%d byte)\n",
-					chunk_id, toread);
-				g3d_read_int16_le(f); /* map_type */
-				toread -= 2;
-				g3d_read_float_le(f); /* x_tiling */
-				g3d_read_float_le(f); /* y_tiling */
-				toread -= 8;
-				g3d_read_float_le(f); /* icon_x */
-				g3d_read_float_le(f); /* icon_y */
-				g3d_read_float_le(f); /* icon_z */
-				toread -= 12;
-				fseek(f, 4 * 12, SEEK_CUR); /* matrix (4 x 3) */
-				toread -= 4 * 12;
-				g3d_read_float_le(f); /* scaling */
-				g3d_read_float_le(f); /* plan_icon_w */
-				g3d_read_float_le(f); /* plan_icon_h */
-				g3d_read_float_le(f); /* cyl_icon_h */
-				toread -= 16;
-				break;
+			subparent->id = chunk_id;
 
-			case 0xA000: /* material name */
-				toread -= x3ds_read_cstr(f, name);
-				if(pobject != NULL)
-				{
-					((G3DMaterial*)pobject)->name = g_strdup(name);
-				}
-				else
-				{
-					g_printerr("material object = NULL :(\n");
-				}
-				x3ds_debug(level, "[%4.4XH] material name: %s (%d byte)\n",
-									 chunk_id, name, chunk_len);
-				break;
+			if(x3ds_chunks[i].container)
+			{
+				x3ds_read_ctnr(global, subparent);
+			}
 
-			case 0xA010: /* ambient color */
-			case 0xA020: /* diffuse color */
-			case 0xA030: /* specular color */
-				x3ds_debug(level, "[%4.4XH] material color (%d byte)\n",
-					chunk_id, toread);
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0xA040: /* shininess */
-				x3ds_debug(level, "[%4.4XH] shininess (%d byte)\n", chunk_id,
-									 toread);
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0xA050: /* transparency */
-				x3ds_debug(level, "[%4.4XH] transparency (%d byte)\n", chunk_id,
-									 toread);
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0xA052: /* XPFALL? */
-				x3ds_debug(level, "[%4.4XH] fallthrough?? (%d byte)\n", chunk_id,
-									 toread);
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0xA053: /* REFBLUR? */
-				x3ds_debug(level, "[%4.4XH] blur?? (%d byte)\n", chunk_id,
-									 toread);
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0xA081:
-				x3ds_debug(level, "[%4.4XH] mat two side (%d byte)\n", chunk_id,
-									 toread);
-				((G3DMaterial*)pobject)->flags |= G3D_FLAG_MAT_TWOSIDE;
-				break;
-			case 0xA100: { /* shading */
-				int shade = g3d_read_int16_le(f);
-				x3ds_debug(level, "[%4.4XH] shading: %d (%d byte)\n", chunk_id,
-									 shade, toread);
-				toread -= 2; }
-				break;
-			case 0xA200: /* texture map */
-				x3ds_debug(level, "[%4.4XH] texture map (%d byte)\n", chunk_id,
-									 toread);
-				((G3DMaterial*)pobject)->flags |= G3D_FLAG_FAC_TEXMAP;
-				x3ds_container(f, toread, context, model, pobject, level + 1,
-					chunk_id);
-				toread = 0;
-				break;
-			case 0xA300: /* map name */
-				if(parent == 0xA200)
-				{
-					G3DMaterial *material = (G3DMaterial*)pobject;
-					toread -= x3ds_read_cstr(f, name);
-					x3ds_debug(level, "[%4.4XH] map name \"%s\" (%d byte)\n",
-						chunk_id, name, toread);
-					material->tex_image = g3d_texture_load_cached(context,
-						model, name);
-					if(material->tex_image)
-					{
-						/* FIXME: better way to generate unique texture ids */
-						material->tex_image->tex_id = g_random_int();
-						/*
-						g3d_texture_prepare(material->texture);
-						*/
-					}
-				}
-				break;
+			if(subparent->nb)
+			{
+				fseek(global->f, subparent->nb, SEEK_CUR);
+			}
 
-			case 0xA351: /* map tiling */
-				x3ds_debug(level, "[%4.4XH] texture map tiling (%d byte)\n",
-					chunk_id, toread);
-				g3d_read_int16_le(f);
-				toread -= 2;
-				break;
+			level_object = subparent->level_object;
 
-			case 0xA352: /* old map blurring */
-				x3ds_debug(level,
-					"[%4.4XH] texture map blurring (old) (%d byte)\n",
-					chunk_id, toread);
-				break;
-
-			case 0xA353: /* map blurring */
-				x3ds_debug(level, "[%4.4XH] texture map blurring (%d byte)\n",
-					chunk_id, toread);
-				g3d_read_float_le(f);
-				toread -= 4;
-				break;
-
-			case 0xAFFF: { /* material entry */
-				G3DMaterial *material = g3d_material_new();
-				x3ds_debug(level, "[%4.4XH] material entry (%d byte)\n",
-					chunk_id, toread);
-				model->materials = g_slist_append(model->materials, material);
-#if DEBUG > 3
-				g_printerr("DEBUG: material created & appended\n");
-#endif
-				x3ds_container(f, toread, context, model, material, level + 1,
-					chunk_id);
-				toread = 0; }
-				break;
-			default: /* unknown chunk type */
-				x3ds_debug(level, "[%4.4XH] unknown (%d byte)\n",
-					chunk_id, toread);
-				fseek(f, toread, SEEK_CUR);
-				toread = 0;
+			g_free(subparent);
 		}
-		if(toread != 0)
+		else
 		{
-			g_printerr("WARNING: toread != 0 (%d), chunk_id: %4.4X\n", 
-								 toread, chunk_id);
-			fseek(f, toread, SEEK_CUR);
+			g_printerr("[3DS] unknown chunk type 0x%04X\n", chunk_id);
+			fseek(global->f, chunk_len, SEEK_CUR);
 		}
-		nbytes -= chunk_len;
+
+		parent->nb -= chunk_len;
+
+		/* update progress bar */
+		x3ds_update_progress(global);
 	}
+
 	return TRUE;
 }
 
-int x3ds_read_cstr(FILE *f, char *string)
+void x3ds_update_progress(x3ds_global_data *global)
 {
+	long int fpos;
+
+	/* update progress bar */
+	fpos = ftell(global->f);
+	g3d_context_update_progress_bar(global->context,
+		((gfloat)fpos / (gfloat)global->max_fpos), TRUE);
+}
+
+gint32 x3ds_read_cstr(FILE *f, char *string)
+{
 	gint32 n = 0;
 	char c;
-	do 
+	do
 	{
 		c = g3d_read_int8(f);
 		string[n] = c;
@@ -474,134 +203,6 @@
 	return n;
 }
 
-int x3ds_read_pointarray(FILE *f, int nb, G3DObject *object, int level)
-{
-	int i, nbytes = nb;
-
-	object->vertex_count = g3d_read_int16_le(f);
-
-	x3ds_debug(level, "[%4.4XH] point array: %d verts (%d bytes)\n",
-			0x4110, object->vertex_count, nbytes);
-
-	object->vertex_data = g_new0(gfloat, object->vertex_count * 3);
-	nbytes -= 2;
-	nbytes -= (object->vertex_count * 3 * 4);
-	for(i=0; i<object->vertex_count; i++)
-	{
-		object->vertex_data[i*3+0] = g3d_read_float_le(f) * x3ds_global_scale;
-		object->vertex_data[i*3+1] = g3d_read_float_le(f) * x3ds_global_scale;
-		object->vertex_data[i*3+2] = g3d_read_float_le(f) * x3ds_global_scale;
-	}
-	return nbytes;
-}
-
-int x3ds_read_facearray(FILE *f, int nb, G3DObject *object)
-{
-	int nbytes = nb;
-	int i, flags, nfaces = g3d_read_int16_le(f);
-#if 1
-	int p1=-1, p2=-1;
-#endif
-	nbytes -= 2;
-#if DEBUG > 3
-	g_printerr("faces: %d\n", nfaces);
-#endif
-	for(i=0; i<nfaces; i++)
-	{
-		G3DFace *face = g_malloc0(sizeof(G3DFace));
-
-		face->vertex_count = 3;
-		face->vertex_indices = g_malloc(3 * sizeof(int));
-		face->vertex_indices[0] = g3d_read_int16_le(f);
-		face->vertex_indices[1] = g3d_read_int16_le(f);
-		face->vertex_indices[2] = g3d_read_int16_le(f);
-		flags = g3d_read_int16_le(f); /* flags */
-
-#if 1
-		if((p1 == face->vertex_indices[0]) && (p2 == face->vertex_indices[1]))
-		{
-			int bottle = face->vertex_indices[0];
-			face->vertex_indices[0] = face->vertex_indices[2];
-			face->vertex_indices[2] = bottle;
-		}
-#endif
-#if DEBUG > 3
-		g_printerr("x3ds_read_facearray: (%d|%d|%d) flags: 0x%4.4X\n",
-			face->vertex_indices[0], face->vertex_indices[1],
-			face->vertex_indices[2], flags);
-#endif
-#if 1
-		p1 = face->vertex_indices[0];
-		p2 = face->vertex_indices[1];
-#endif
-		nbytes -= 8;
-		face->material = g_slist_nth_data(object->materials, 0);
-
-		object->faces = g_slist_append(object->faces, face);
-	}
-	return nbytes;
-}
-
-int x3ds_read_meshmatgrp(FILE *f, int nb, G3DModel *model, G3DObject *object,
-	int level)
-{
-	int nbytes = nb;
-	char name[2048];
-	int nfaces, i, j, facenum;
-	G3DMaterial *material = NULL;
-	GSList *mlist;
-
-	nbytes -= x3ds_read_cstr(f, name);
-	x3ds_debug(level, "[%4.4XH] mesh mat group: %s\n", 0x4130, name);
-
-	mlist = model->materials;
-	while(mlist != NULL)
-	{
-		G3DMaterial *mat = (G3DMaterial*)mlist->data;
-		if(strcmp(mat->name, name) == 0)
-		{
-			material = mat;
-			break;
-		}
-		mlist = mlist->next;
-	}
-
-	nfaces = g3d_read_int16_le(f);
-	nbytes -= 2;
-	for(i=0; i<nfaces; i++)
-	{
-		facenum = g3d_read_int16_le(f);
-		nbytes -= 2;
-		if(material != NULL)
-		{
-			G3DFace *face = (G3DFace*)g_slist_nth_data(object->faces, facenum);
-			if(face != NULL) face->material = material;
-
-			if(face->material->tex_image && object->tex_vertex_data)
-			{
-#if DEBUG > 5
-				g_print("3ds: textured face\n");
-#endif
-				face->flags |= G3D_FLAG_FAC_TEXMAP;
-				face->tex_image = face->material->tex_image;
-				face->tex_vertex_count = 3;
-				face->tex_vertex_data = g_new0(gfloat, 6);
-				for(j = 0; j < 3; j ++)
-				{
-					face->tex_vertex_data[j * 2 + 0] =
-						object->tex_vertex_data[
-							face->vertex_indices[j] * 2 + 0];
-					face->tex_vertex_data[j * 2 + 1] =
-						object->tex_vertex_data[
-							face->vertex_indices[j] * 2 + 1];
-				}
-			} /* textured face */
-
-		}
-	}
-	return nbytes;
-}
-
 void x3ds_debug(int level, char *format, ...)
 {
 #if DEBUG > 0

Added: trunk/libs3d/libg3d/plugins/import/imp_3ds.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,36 @@
+#ifndef _IMP_3DS_H
+#define _IMP_3DS_H
+
+#include <stdio.h>
+#include <glib.h>
+#include <g3d/g3d.h>
+
+typedef struct {
+    G3DContext *context;
+    G3DModel *model;
+    FILE *f;
+    gfloat scale;
+	gint32 max_tex_id;
+	long int max_fpos;
+} x3ds_global_data;
+
+typedef struct {
+    gint32 id;
+    gpointer object;
+	gpointer misc_object;
+    gint32 level;
+	gpointer level_object;
+    guint32 nb;
+} x3ds_parent_data;
+
+typedef gboolean (* x3ds_callback)(x3ds_global_data *global,
+    x3ds_parent_data *parent);
+
+
+gboolean x3ds_read_ctnr(x3ds_global_data *global, x3ds_parent_data *parent);
+void x3ds_update_progress(x3ds_global_data *global);
+gint32 x3ds_read_cstr(FILE *f, char *string);
+G3DObject *x3ds_newobject(G3DModel *model, const char *name);
+void x3ds_debug(int level, char *format, ...);
+
+#endif /* _IMP_3DS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,838 @@
+#include <string.h>
+
+#include <g3d/read.h>
+#include <g3d/texture.h>
+#include <g3d/vector.h>
+#include <g3d/matrix.h>
+
+#include "imp_3ds_callbacks.h"
+
+#define X3DS_FLAG_TENSION       0x01
+#define X3DS_FLAG_CONTINUITY    0x02
+#define X3DS_FLAG_BIAS          0x04
+#define X3DS_FLAG_EASE_TO       0x08
+#define X3DS_FLAG_EASE_FROM     0x10
+
+gboolean x3ds_cb_0x0002(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	gint32 version;
+
+	version = g3d_read_int32_le(global->f);
+	parent->nb -= 4;
+#if DEBUG > 0
+	g_printerr("[3DS] M3D version %d\n", version);
+#endif
+	return TRUE;
+}
+
+/* color float */
+gboolean x3ds_cb_0x0010(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	gfloat r, g, b;
+
+	r = g3d_read_float_le(global->f);
+	g = g3d_read_float_le(global->f);
+	b = g3d_read_float_le(global->f);
+	parent->nb -= 12;
+
+	switch(parent->id)
+	{
+		case 0x1200: /* SOLID_BGND */
+			g3d_context_set_bgcolor(global->context, r, g, b, 1.0);
+			break;
+
+		case 0xA010: /* ambient color */
+		case 0xA020: /* diffuse color */
+			material = (G3DMaterial *)parent->object;
+			g_return_val_if_fail(material, FALSE);
+
+			material->r = r;
+			material->g = g;
+			material->b = b;
+			break;
+
+		case 0xA030: /* specular color */
+			material = (G3DMaterial *)parent->object;
+			g_return_val_if_fail(material, FALSE);
+
+			material->specular[0] = r;
+			material->specular[1] = g;
+			material->specular[2] = b;
+			material->specular[3] = 0.25;
+			break;
+
+		default:
+			g_printerr("[3DS] unhandled COLOR_F in 0x%04X\n", parent->id);
+			break;
+	}
+
+	return TRUE;
+}
+
+/* color 24 */
+gboolean x3ds_cb_0x0011(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	gint32 r, g, b;
+
+	material = (G3DMaterial *)parent->object;
+	g_return_val_if_fail(material, FALSE);
+
+	r = g3d_read_int8(global->f);
+	g = g3d_read_int8(global->f);
+	b = g3d_read_int8(global->f);
+	parent->nb -= 3;
+
+	switch(parent->id)
+	{
+#if 0
+		case 0xA010: /* ambient color */
+#endif
+		case 0xA020: /* diffuse color */
+			material->r = (gfloat)r / 255.0;
+			material->g = (gfloat)g / 255.0;
+			material->b = (gfloat)b / 255.0;
+			break;
+
+		case 0xA030: /* specular color */
+			material->specular[0] = (gfloat)r / 255.0;
+			material->specular[1] = (gfloat)g / 255.0;
+			material->specular[2] = (gfloat)b / 255.0;
+			material->specular[3] = 0.25;
+			break;
+
+		default:
+			g_printerr("[3DS] unhandled COLOR_24 in 0x%04X\n", parent->id);
+			break;
+	}
+
+	return TRUE;
+}
+
+/* short percentage */
+gboolean x3ds_cb_0x0030(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	gint32 percent;
+
+	material = (G3DMaterial *)parent->object;
+	g_return_val_if_fail(material, FALSE);
+
+	percent = g3d_read_int16_le(global->f);
+	parent->nb -= 2;
+
+	switch(parent->id)
+	{
+		case 0xA040: /* shininess */
+			material->shininess = (gfloat)percent / 100.0;
+			break;
+
+		case 0xA041: /* shininess (2) */
+			/* TODO: do something here? */
+			break;
+
+		case 0xA050: /* transparency */
+			material->a = 1.0 - ((gfloat)percent / 100.0);
+			break;
+
+		case 0xA052: /* fallthrough */
+			/* TODO: do something here? */
+			break;
+
+		case 0xA053: /* blur */
+			/* TODO: do something here? */
+			break;
+
+		case 0xA084: /* self illumination */
+			/* TODO: do something here? */
+			break;
+
+		case 0xA200: /* texture map */
+			/* TODO: do something here? */
+			break;
+
+		case 0xA210: /* opacity map */
+			/* TODO: do something here? */
+			g_printerr("[3DS] opacity percentage: %d%%\n", percent);
+			break;
+
+		case 0xA220: /* reflection map */
+			/* TODO: do something here? */
+			break;
+
+		case 0xA230: /* bump map */
+			/* TODO: do something here? */
+			break;
+
+		default:
+			g_printerr("[3DS] unhandled INT_PERCENTAGE in 0x%04X\n",
+				parent->id);
+			break;
+	}
+
+	return TRUE;
+}
+
+/* float percentage */
+gboolean x3ds_cb_0x0031(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	gfloat percent;
+
+	material = (G3DMaterial *)parent->object;
+	g_return_val_if_fail(material, FALSE);
+
+	percent = g3d_read_float_le(global->f);
+	parent->nb -= 4;
+
+	switch(parent->id)
+	{
+		case 0xA040: /* shininess */
+			material->shininess = percent;
+			break;
+
+		case 0xA050: /* transparency */
+			material->a = 1.0 - percent;
+			break;
+
+		default:
+			g_printerr("[3DS] unhandled FLOAT_PERCENTAGE in 0x%04X\n",
+				parent->id);
+			break;
+	}
+
+	return TRUE;
+}
+
+/* master scale */
+gboolean x3ds_cb_0x0100(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	global->scale = g3d_read_float_le(global->f);
+	parent->nb -= 4;
+
+	return TRUE;
+}
+
+/* named object */
+gboolean x3ds_cb_0x4000(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	gchar buffer[1024];
+
+	parent->nb -= x3ds_read_cstr(global->f, buffer);
+	parent->object = x3ds_newobject(global->model, buffer);
+
+	return TRUE;
+}
+
+/* point array */
+gboolean x3ds_cb_0x4110(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DObject *object;
+	gint32 i;
+
+	object = (G3DObject *)parent->object;
+	g_return_val_if_fail(object, FALSE);
+
+	object->vertex_count = g3d_read_int16_le(global->f);
+	parent->nb -= 2;
+
+	object->vertex_data = g_new0(gfloat, object->vertex_count * 3);
+	for(i = 0; i < object->vertex_count; i ++)
+	{
+		object->vertex_data[i * 3 + 0] = g3d_read_float_le(global->f);
+		object->vertex_data[i * 3 + 1] = g3d_read_float_le(global->f);
+		object->vertex_data[i * 3 + 2] = g3d_read_float_le(global->f);
+		parent->nb -= 12;
+
+		if((i % 1000) == 0) x3ds_update_progress(global);
+	}
+	return TRUE;
+}
+
+/* face array */
+gboolean x3ds_cb_0x4120(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	gint32 i, flags, nfaces;
+#define X3DS_REORDER_FACES
+#ifdef X3DS_REORDER_FACES
+	gint32 p1 = -1, p2 = -1, bottle;
+#endif
+	G3DFace *face;
+	G3DObject *object;
+
+	object = (G3DObject *)parent->object;
+	g_return_val_if_fail(object, FALSE);
+
+	nfaces = g3d_read_int16_le(global->f);
+	parent->nb -= 2;
+
+	for(i = 0; i < nfaces; i ++)
+	{
+		face = g_new0(G3DFace, 1);
+
+		face->vertex_count = 3;
+		face->vertex_indices = g_malloc(3 * sizeof(guint32));
+
+		face->vertex_indices[0] = g3d_read_int16_le(global->f);
+		face->vertex_indices[1] = g3d_read_int16_le(global->f);
+		face->vertex_indices[2] = g3d_read_int16_le(global->f);
+		flags = g3d_read_int16_le(global->f);
+		parent->nb -= 8;
+
+#ifdef X3DS_REORDER_FACES
+		/* try to put all faces in the same direction */
+		if((p1 == face->vertex_indices[0]) && (p2 == face->vertex_indices[1]))
+		{
+			bottle = face->vertex_indices[0];
+			face->vertex_indices[0] = face->vertex_indices[2];
+			face->vertex_indices[2] = bottle;
+		}
+
+		p1 = face->vertex_indices[0];
+		p2 = face->vertex_indices[1];
+#endif
+
+		face->material = g_slist_nth_data(object->materials, 0);
+
+		object->faces = g_slist_append(object->faces, face);
+
+		if((i % 1000) == 0) x3ds_update_progress(global);
+	}
+
+	return TRUE;
+}
+
+/* mesh mat group */
+gboolean x3ds_cb_0x4130(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DObject *object;
+	gint32 i, j, facenum, nfaces;
+	gchar buffer[512];
+	G3DMaterial *material = NULL, *mat;
+	G3DFace *face;
+	GSList *mlist;
+
+	object = (G3DObject *)parent->object;
+	g_return_val_if_fail(object, FALSE);
+
+	/* name of material */
+	parent->nb -= x3ds_read_cstr(global->f, buffer);
+
+	/* find material in list */
+	mlist = global->model->materials;
+	while(mlist != NULL)
+	{
+		mat = (G3DMaterial*)mlist->data;
+		if(strcmp(mat->name, buffer) == 0)
+		{
+			material = mat;
+			break;
+		}
+		mlist = mlist->next;
+	}
+
+	nfaces = g3d_read_int16_le(global->f);
+	parent->nb -= 2;
+
+	for(i = 0; i < nfaces; i ++)
+	{
+		facenum = g3d_read_int16_le(global->f);
+		parent->nb -= 2;
+
+		if(material != NULL)
+		{
+			face = (G3DFace*)g_slist_nth_data(object->faces, facenum);
+			if(face == NULL) continue;
+
+			face->material = material;
+
+			if(face->material->tex_image && object->tex_vertex_data)
+			{
+				face->flags |= G3D_FLAG_FAC_TEXMAP;
+				face->tex_image = face->material->tex_image;
+				face->tex_vertex_count = 3;
+				face->tex_vertex_data = g_new0(gfloat, 6);
+				for(j = 0; j < 3; j ++)
+				{
+					face->tex_vertex_data[j * 2 + 0] = object->tex_vertex_data[
+						face->vertex_indices[j] * 2 + 0];
+					face->tex_vertex_data[j * 2 + 1] = object->tex_vertex_data[
+						face->vertex_indices[j] * 2 + 1];
+				}
+			} /* textured face */
+		} /* material != NULL */
+
+		if((i % 1000) == 0) x3ds_update_progress(global);
+	} /* 0..nfaces */
+
+	return TRUE;
+}
+
+/* texture vertices */
+gboolean x3ds_cb_0x4140(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DObject *object;
+	gint32 i;
+
+	object = (G3DObject *)parent->object;
+	g_return_val_if_fail(object, FALSE);
+
+	object->tex_vertex_count = g3d_read_int16_le(global->f);
+	parent->nb -= 2;
+
+	object->tex_vertex_data = g_new0(gfloat, object->tex_vertex_count * 2);
+
+	for(i = 0; i < object->tex_vertex_count; i ++)
+	{
+		object->tex_vertex_data[i * 2 + 0] = g3d_read_float_le(global->f);
+		object->tex_vertex_data[i * 2 + 1] = g3d_read_float_le(global->f);
+		parent->nb -= 8;
+
+		if((i % 1000) == 0) x3ds_update_progress(global);
+	}
+
+	return TRUE;
+}
+
+/* texture vertices */
+gboolean x3ds_cb_0x4150(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+// 	G3DObject *object;
+// 	gint32 i;
+//
+// 	object = (G3DObject *)parent->object;
+// 	g_return_val_if_fail(object, FALSE);
+//
+// 	object->tex_vertex_count = g3d_read_int16_le(global->f);
+// 	parent->nb -= 2;
+//
+// 	object->tex_vertex_data = g_new0(gfloat, object->tex_vertex_count * 2);
+//
+// 	for(i = 0; i < object->tex_vertex_count; i ++)
+// 	{
+// 		object->tex_vertex_data[i * 2 + 0] = g3d_read_float_le(global->f);
+// 		object->tex_vertex_data[i * 2 + 1] = g3d_read_float_le(global->f);
+// 		parent->nb -= 8;
+//
+// 		if((i % 1000) == 0) x3ds_update_progress(global);
+// 	}
+
+	return TRUE;
+}
+
+/* mesh matrix */
+gboolean x3ds_cb_0x4160(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	gfloat matrix[16];
+	gint32 i;
+
+	g3d_matrix_identity(matrix);
+	for(i = 0; i < 12; i ++)
+		matrix[i] = g3d_read_float_le(global->f);
+
+#if 0
+	for(w = 0; w < 4; w ++)
+	{
+		for(h = 0; h < 3; h ++)
+		{
+			matrix[w * 4 + h] = g3d_read_float_le(global->f);
+		}
+	}
+#endif
+
+	parent->nb -= 48;
+
+/* #define X3DS_MESH_TRANSFORM */
+#ifdef X3DS_MESH_TRANSFORM
+	if(parent->object)
+	{
+		gint32 i;
+		G3DObject *object = (G3DObject *)parent->object;
+
+		for(i = 0; i < object->vertex_count; i ++)
+		{
+			g3d_vector_transform(
+				&(object->vertex_data[i * 3 + 0]),
+				&(object->vertex_data[i * 3 + 1]),
+				&(object->vertex_data[i * 3 + 2]),
+				matrix);
+		}
+	}
+#endif
+
+	return TRUE;
+}
+
+/* material name */
+gboolean x3ds_cb_0xA000(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	gchar buffer[1024];
+
+	g_return_val_if_fail(parent->object, FALSE);
+
+	parent->nb -= x3ds_read_cstr(global->f, buffer);
+	material = (G3DMaterial *)(parent->object);
+
+	material->name = g_strdup(buffer);
+
+	return TRUE;
+}
+
+/* two sided material */
+gboolean x3ds_cb_0xA081(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+
+	material = (G3DMaterial *)parent->object;
+	g_return_val_if_fail(material, FALSE);
+
+	material->flags |= G3D_FLAG_MAT_TWOSIDE;
+
+	return TRUE;
+}
+
+/* texture map name */
+gboolean x3ds_cb_0xA300(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	G3DImage *image;
+	gchar buffer[512];
+
+	material = (G3DMaterial *)parent->object;
+	g_return_val_if_fail(material, FALSE);
+
+	parent->nb -= x3ds_read_cstr(global->f, buffer);
+
+	switch(parent->id)
+	{
+		case 0xA200: /* texture map */
+			material->tex_image = g3d_texture_load_cached(global->context,
+				global->model, buffer);
+			if(material->tex_image)
+			{
+				g3d_texture_flip_y(material->tex_image);
+				material->tex_image->tex_id = ++ global->max_tex_id;
+			}
+			break;
+
+		case 0xA210: /* opacity map */
+			image = g3d_texture_load(global->context, buffer);
+			if(image != NULL)
+			{
+				g3d_texture_flip_y(image);
+				material->tex_image = g3d_texture_merge_alpha(
+					material->tex_image, image);
+				g3d_texture_free(image);
+			}
+			break;
+
+		case 0xA220: /* reflection map */
+			/* TODO: implement */
+			break;
+
+		case 0xA230: /* bump map */
+			/* TODO: implement */
+			break;
+
+		default:
+			g_printerr("[3DS] unhandled texture name in 0x%04X\n", parent->id);
+			break;
+	}
+
+	return TRUE;
+}
+
+/* texture map scale u */
+gboolean x3ds_cb_0xA354(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	G3DImage *image;
+	gfloat scale;
+
+	material = (G3DMaterial *)parent->object;
+	g_return_val_if_fail(material, FALSE);
+
+	image = material->tex_image;
+	g_return_val_if_fail(image, FALSE);
+
+	scale = g3d_read_float_le(global->f);
+	parent->nb -= 4;
+
+	image->tex_scale_u = scale;
+#if DEBUG > 3
+	g_print("[3DS] scale_u: %f\n", image->tex_scale_u);
+#endif
+
+	return TRUE;
+}
+
+/* texture map scale v */
+gboolean x3ds_cb_0xA356(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	G3DImage *image;
+	gfloat scale;
+
+	material = (G3DMaterial *)parent->object;
+	g_return_val_if_fail(material, FALSE);
+
+	image = material->tex_image;
+	g_return_val_if_fail(image, FALSE);
+
+	scale = g3d_read_float_le(global->f);
+	parent->nb -= 4;
+
+	image->tex_scale_v = scale;
+#if DEBUG > 3
+	g_print("[3DS] scale_v: %f\n", image->tex_scale_v);
+#endif
+
+	return TRUE;
+}
+
+/* material */
+gboolean x3ds_cb_0xAFFF(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DMaterial *material;
+	G3DObject *object;
+
+	material = g3d_material_new();
+
+	if(parent->object)
+	{
+		object = (G3DObject *)parent->object;
+		object->materials = g_slist_append(object->materials, material);
+	}
+	else
+	{
+		global->model->materials = g_slist_append(global->model->materials,
+			material);
+	}
+
+	parent->object = material;
+
+	return TRUE;
+}
+
+/* keyframe data header */
+gboolean x3ds_cb_0xB00A(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	gint32 rev, len;
+	gchar buffer[512];
+
+	rev = g3d_read_int16_le(global->f);
+	parent->nb -= 2;
+	parent->nb -= x3ds_read_cstr(global->f, buffer);
+	len = g3d_read_int16_le(global->f);
+	parent->nb -= 2;
+
+#if DEBUG > 0
+	g_printerr("[3DS] keyframe data: r%d, %d frames, \"%s\"\n",
+		rev, len, buffer);
+#endif
+	return TRUE;
+}
+
+/* node header */
+gboolean x3ds_cb_0xB010(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	GSList *olist;
+	G3DObject *object;
+	gchar buffer[512];
+
+	parent->nb -= x3ds_read_cstr(global->f, buffer);
+#if DEBUG > 3
+	g_printerr("[3DS] NODE_HDR: %s\n", buffer);
+#endif
+
+	/* find object by name */
+	olist = global->model->objects;
+	while(olist)
+	{
+		object = (G3DObject *)olist->data;
+		if(strcmp(object->name, buffer) == 0)
+		{
+			parent->level_object = object;
+			break;
+		}
+		olist = olist->next;
+	}
+
+	g3d_read_int16_le(global->f); /* flags 1 */
+	g3d_read_int16_le(global->f); /* flags 2 */
+	g3d_read_int16_le(global->f); /* ? */
+	parent->nb -= 6;
+
+	return TRUE;
+}
+
+/* pivot */
+gboolean x3ds_cb_0xB013(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DObject *object;
+#if 0
+	gint32 i;
+#endif
+	gfloat x, y, z;
+
+	object = parent->level_object;
+	if(object == NULL) return FALSE;
+
+	x = g3d_read_float_le(global->f);
+	y = g3d_read_float_le(global->f);
+	z = g3d_read_float_le(global->f);
+	parent->nb -= 12;
+
+#if DEBUG > 3
+	g_printerr("[3DS]: PIVOT: (%.2f,%.2f,%.2f)\n", x, y, z);
+#endif
+
+	return TRUE;
+}
+
+#define X3DS_ENABLE_POS_TRACK_TAG 0
+
+/* position tracking tag */
+gboolean x3ds_cb_0xB020(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DObject *object;
+	gint32 i, flags, fflags, nkeys, fnum;
+#if X3DS_ENABLE_POS_TRACK_TAG
+	gint32 j;
+#endif
+	gfloat x, y, z;
+
+	object = parent->level_object;
+	if(object == NULL) return FALSE;
+
+	flags = g3d_read_int16_le(global->f);
+	fseek(global->f, 8, SEEK_CUR);
+	nkeys = g3d_read_int32_le(global->f);
+
+	parent->nb -= 14;
+
+	for(i = 0; i < nkeys; i ++)
+	{
+		fnum = g3d_read_int32_le(global->f);
+		fflags = g3d_read_int16_le(global->f);
+		parent->nb -= 6;
+
+		if(fflags & X3DS_FLAG_TENSION)
+		{
+			g3d_read_float_le(global->f);
+			parent->nb -= 4;
+		}
+		if(fflags & X3DS_FLAG_CONTINUITY)
+		{
+			g3d_read_float_le(global->f);
+			parent->nb -= 4;
+		}
+		if(fflags & X3DS_FLAG_BIAS)
+		{
+			g3d_read_float_le(global->f);
+			parent->nb -= 4;
+		}
+		if(fflags & X3DS_FLAG_EASE_TO)
+		{
+			g3d_read_float_le(global->f);
+			parent->nb -= 4;
+		}
+		if(fflags & X3DS_FLAG_EASE_FROM)
+		{
+			g3d_read_float_le(global->f);
+			parent->nb -= 4;
+		}
+
+		x = g3d_read_float_le(global->f);
+		y = g3d_read_float_le(global->f);
+		z = g3d_read_float_le(global->f);
+		parent->nb -= 12;
+#if DEBUG > 2
+		g_printerr("[3DS]: POS_TRACK_TAG: frame %d: (%.2f,%.2f,%.2f) (0x%X)\n",
+			fnum, x, y, z, fflags);
+#endif
+
+#if X3DS_ENABLE_POS_TRACK_TAG
+		if(fnum == 0)
+		{
+			for(j = 0; j < object->vertex_count; j ++)
+			{
+				object->vertex_data[j * 3 + 0] -= x;
+				object->vertex_data[j * 3 + 1] -= y;
+				object->vertex_data[j * 3 + 2] -= z;
+			}
+		}
+#endif
+	}
+
+	return TRUE;
+}
+
+/* rotation tracking tag */
+gboolean x3ds_cb_0xB021(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	G3DObject *object;
+	gint32 i, j, flags, nkeys, fnum;
+	gfloat x, y, z, rot;
+	gfloat matrix[16];
+
+	object = parent->level_object;
+	if(object == NULL) return FALSE;
+
+	flags = g3d_read_int16_le(global->f);
+	fseek(global->f, 8, SEEK_CUR);
+	nkeys = g3d_read_int16_le(global->f);
+	g3d_read_int16_le(global->f);
+	parent->nb -= 14;
+
+	for(i = 0; i < nkeys; i ++)
+	{
+		fnum = g3d_read_int16_le(global->f);
+		g3d_read_int32_le(global->f);
+		parent->nb -= 6;
+
+		rot = g3d_read_float_le(global->f);
+		x = g3d_read_float_le(global->f);
+		y = g3d_read_float_le(global->f);
+		z = g3d_read_float_le(global->f);
+		parent->nb -= 16;
+#if DEBUG > 3
+		g_printerr(
+			"[3DS]: ROT_TRACK_TAG: frame %d: (%.2f,%.2f,%.2f), %.2f rad\n",
+			fnum, x, y, z, rot);
+#endif
+		if(fnum == -1)
+		{
+			g3d_matrix_identity(matrix);
+			g3d_matrix_rotate(rot, x, y, z, matrix);
+
+			for(j = 0; j < object->vertex_count; j ++)
+			{
+				g3d_vector_transform(
+					&(object->vertex_data[j * 3 + 0]),
+					&(object->vertex_data[j * 3 + 1]),
+					&(object->vertex_data[j * 3 + 2]),
+					matrix);
+			}
+		}
+	}
+
+	return TRUE;
+
+}
+
+/* node id */
+gboolean x3ds_cb_0xB030(x3ds_global_data *global, x3ds_parent_data *parent)
+{
+	gint32 id;
+
+	id = g3d_read_int16_le(global->f);
+	parent->nb -= 2;
+#if DEBUG > 3
+	g_printerr("[3DS] NODE_ID: %d\n", id);
+#endif
+
+	return TRUE;
+}

Added: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,35 @@
+#ifndef _IMP_3DS_CALLBACKS_H
+#define _IMP_3DS_CALLBACKS_H
+
+#include "imp_3ds.h"
+
+gboolean x3ds_cb_0x0002(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x0010(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x0011(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x0030(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x0031(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x0100(x3ds_global_data *global, x3ds_parent_data *parent);
+
+gboolean x3ds_cb_0x4000(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x4110(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x4120(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x4130(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x4140(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x4150(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0x4160(x3ds_global_data *global, x3ds_parent_data *parent);
+
+gboolean x3ds_cb_0xA000(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xA081(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xA300(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xA354(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xA356(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xAFFF(x3ds_global_data *global, x3ds_parent_data *parent);
+
+gboolean x3ds_cb_0xB00A(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xB010(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xB013(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xB020(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xB021(x3ds_global_data *global, x3ds_parent_data *parent);
+gboolean x3ds_cb_0xB030(x3ds_global_data *global, x3ds_parent_data *parent);
+
+#endif /* _IMP_3DS_CALLBACKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_3ds_chunks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_chunks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_chunks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,135 @@
+#ifndef _IMP_3DS_CHUNKS_H
+#define _IMP_3DS_CHUNKS_H
+
+#include <glib.h>
+
+#include "imp_3ds_callbacks.h"
+
+typedef struct {
+	guint32 id;
+	char *desc;
+	gboolean container;
+	x3ds_callback callback;
+} x3ds_chunk_desc;
+
+static x3ds_chunk_desc x3ds_chunks[] = {
+	{ 0x0002, "M3D version",                0, x3ds_cb_0x0002 },
+	{ 0x0001, "(unknown)",                  0, NULL },
+	{ 0x0010, "color (float)",              0, x3ds_cb_0x0010 },
+	{ 0x0011, "color (24 bit)",             0, x3ds_cb_0x0011 },
+	{ 0x0012, "line color (24 bit)",        0, NULL },
+	{ 0x0013, "line color (float)",         0, NULL },
+	{ 0x0030, "percentage (short)",         0, x3ds_cb_0x0030 },
+	{ 0x0031, "percentage (float)",         0, x3ds_cb_0x0031 },
+	{ 0x0100, "global scale",               0, NULL },
+
+	{ 0x1100, "BIT_MAP",                    0, NULL },
+	{ 0x1200, "SOLID_BGND",                 1, NULL },
+	{ 0x1201, "USE_SOLID_BGND",             0, NULL },
+	{ 0x1300, "V_GRADIENT",                 0, NULL },
+	{ 0x1301, "USE_V_GRADIENT",             0, NULL },
+	{ 0x1400, "LO_SHADOW_BIAS",             0, NULL },
+	{ 0x1410, "HI_SHADOW_BIAS",             0, NULL },
+	{ 0x1420, "SHADOW_MAP_SIZE",            0, NULL },
+	{ 0x1430, "SHADOW_SAMPLES",             0, NULL },
+	{ 0x1440, "SHADOW_RANGE",               0, NULL },
+	{ 0x1450, "SHADOW_FILTER",              0, NULL },
+	{ 0x1460, "RAY_BIAS",                   0, NULL },
+	{ 0x1500, "O_CONSTS",                   0, NULL },
+
+	{ 0x2100, "AMBIENT_LIGHT",              0, NULL },
+	{ 0x2200, "FOG",                        0, NULL },
+	{ 0x2300, "DISTANCE_CUE",               0, NULL },
+	{ 0x2301, "USE_DISTANCE_CUE",           0, NULL },
+	{ 0x2302, "LAYER_FOG",                  0, NULL },
+
+	{ 0x3000, "default view",               0, NULL },
+	{ 0x3D3D, "mesh",                       1, NULL },
+	{ 0x3D3E, "mesh version",               0, NULL },
+
+	{ 0x4000, "named object",               1, x3ds_cb_0x4000 },
+	{ 0x4100, "triangle object",            1, NULL },
+	{ 0x4110, "point array",                0, x3ds_cb_0x4110 },
+	{ 0x4111, "point flag array",           0, NULL },
+	{ 0x4120, "face array",                 1, x3ds_cb_0x4120 },
+	{ 0x4130, "mesh mat group",             0, x3ds_cb_0x4130 },
+	{ 0x4140, "texture vertices",           0, x3ds_cb_0x4140 },
+	{ 0x4150, "smooth group",               0, x3ds_cb_0x4150 },
+	{ 0x4160, "mesh matrix",                0, x3ds_cb_0x4160 },
+	{ 0x4165, "mesh color",                 0, NULL },
+	{ 0x4170, "texture info",               0, NULL },
+	{ 0x4600, "N_DIRECT_LIGHT",             0, NULL },
+	{ 0x4700, "N_CAMERA",                   0, NULL },
+
+	{ 0x7001, "VIEWPORT_LAYOUT",            0, NULL },
+
+	{ 0xA000, "material name",              0, x3ds_cb_0xA000 },
+	{ 0xA010, "ambient color",              1, NULL },
+	{ 0xA020, "diffuse color",              1, NULL },
+	{ 0xA030, "specular color",             1, NULL },
+	{ 0xA040, "shininess",                  1, NULL },
+	{ 0xA041, "shininess (2)",              1, NULL },
+	{ 0xA042, "shininess (3)",              1, NULL },
+	{ 0xA050, "transparency",               1, NULL },
+	{ 0xA052, "fallthrough",                1, NULL },
+	{ 0xA053, "blur",                       1, NULL },
+	{ 0xA081, "two-sided",                  0, x3ds_cb_0xA081 },
+	{ 0xA084, "self illumination",          1, NULL },
+	{ 0xA085, "wire",                       0, NULL },
+	{ 0xA086, "super-sampling",             0, NULL },
+	{ 0xA087, "wire size",                  0, NULL },
+	{ 0xA08A, "MAT_XPFALLIN",               0, NULL },
+	{ 0xA08C, "MAT_PHONGSOFT",              0, NULL },
+	{ 0xA08E, "MAT_WIREABS",                0, NULL },
+	{ 0xA100, "shading",                    0, NULL },
+	{ 0xA200, "texture map",                1, NULL },
+	{ 0xA210, "opacity map",                1, NULL },
+	{ 0xA220, "reflection map",             1, NULL },
+	{ 0xA230, "bump map",                   1, NULL },
+	{ 0xA250, "MAT_USE_REFBLUR",            0, NULL },
+	{ 0xA252, "bump percentage",            0, NULL },
+	{ 0xA300, "texture map name",           0, x3ds_cb_0xA300 },
+	{ 0xA351, "texture map tiling",         0, NULL },
+	{ 0xA352, "texture map blurring (old)", 0, NULL },
+	{ 0xA353, "texture map blurring",       0, NULL },
+	{ 0xA354, "texture map scale u",        0, x3ds_cb_0xA354 },
+	{ 0xA356, "texture map scale v",        0, x3ds_cb_0xA356 },
+	{ 0xA358, "texture map offset u",       0, NULL },
+	{ 0xA35A, "texture map offset v",       0, NULL },
+	{ 0xAFFF, "material",                   1, x3ds_cb_0xAFFF },
+
+	{ 0xB000, "keyframe data",              1, NULL },
+	{ 0xB001, "ambient data node",          1, NULL },
+	{ 0xB002, "object node",                1, NULL },
+	{ 0xB003, "camera node",                1, NULL },
+	{ 0xB004, "target node",                1, NULL },
+	{ 0xB005, "light node",                 1, NULL },
+	{ 0xB006, "L_TARGET_NODE_TAG",          1, NULL },
+	{ 0xB007, "spotlight node",             1, NULL },
+	{ 0xB008, "KFSEG",                      0, NULL },
+	{ 0xB009, "KFCURTIME",                  0, NULL },
+	{ 0xB00A, "keyframe data header",       0, x3ds_cb_0xB00A },
+	{ 0xB010, "node header",                0, x3ds_cb_0xB010 },
+	{ 0xB011, "instance name",              0, NULL },
+	{ 0xB012, "PRESCALE",                   0, NULL },
+	{ 0xB013, "pivot",                      0, x3ds_cb_0xB013 },
+	{ 0xB014, "bounding box",               0, NULL },
+	{ 0xB015, "MORPH_SMOOTH",               0, NULL },
+	{ 0xB020, "position tracking tag",      0, x3ds_cb_0xB020 },
+	{ 0xB021, "rotation tracking tag",      0, x3ds_cb_0xB021 },
+	{ 0xB022, "scale tracking tag",         0, NULL },
+	{ 0xB023, "FOV_TRACK_TAG",              0, NULL },
+	{ 0xB024, "ROLL_TRACK_TAG",             0, NULL },
+	{ 0xB025, "COL_TRACK_TAG",              0, NULL },
+	{ 0xB026, "MORPH_TRACK_TAG",            0, NULL },
+	{ 0xB027, "HOT_TRACK_TAG",              0, NULL },
+	{ 0xB028, "FALL_TRACK_TAG",             0, NULL },
+	{ 0xB029, "HIDE_TRACK_TAG",             0, NULL },
+	{ 0xB030, "node identification",        0, x3ds_cb_0xB030 },
+
+	{ 0xD000, "VPDATA",                     0, NULL },
+
+	{ 0x0000, NULL, 0, NULL }
+};
+
+#endif

Modified: trunk/libs3d/libg3d/plugins/import/imp_cob.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_cob.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_cob.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -28,6 +28,7 @@
 #include <g3d/context.h>
 #include <g3d/material.h>
 #include <g3d/vector.h>
+#include <g3d/matrix.h>
 #include <g3d/read.h>
 #include <g3d/iff.h>
 
@@ -188,23 +189,15 @@
 	len -= 48;
 
 	/* current position: 3 x 16 */
-	curpos[12] = curpos[13] = curpos[14] = 0.0;
-	curpos[15] = 1.0;
-
+	g3d_matrix_identity(curpos);
 	for(i = 0; i < 12; i ++)
 	{
 		curpos[i] = cob_read_e(f, float, is_be);
 		len -= 4;
 	}
+	g3d_matrix_transpose(curpos);
 
-#if DEBUG > 0
-	for(i = 0; i < 4; i ++)
-	{
-		g_print("COB: PolH: CurPos: %+1.2f %+1.2f %+1.2f %+1.2f\n",
-			curpos[i * 4 + 0], curpos[i * 4 + 1],
-			curpos[i * 4 + 2], curpos[i * 4 + 3]);
-	}
-#endif
+	/*g3d_matrix_dump(curpos);*/
 
 	/* vertex list */
 	object->vertex_count = cob_read_e(f, int32, is_be);

Modified: trunk/libs3d/libg3d/plugins/import/imp_iob.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_iob.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_iob.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -31,12 +31,13 @@
 #include <g3d/read.h>
 #include <g3d/iff.h>
 
-int iob_read_directory(FILE *f, guint32 nbytes, G3DModel *model,
-	void *pobject, guint32 parentid, int level, G3DContext *context);
+#include "imp_iob_chunks.h"
 
 gboolean plugin_load_model(G3DContext *context, const gchar *filename,
 	G3DModel *model, gpointer user_data)
 {
+	g3d_iff_gdata *global;
+	g3d_iff_ldata *local;
 	guint32 id, len;
 	FILE *f;
 
@@ -48,8 +49,21 @@
 		return FALSE;
 	}
 
-	iob_read_directory(f, len, model, NULL, id, 1, context);
+	local = g_new0(g3d_iff_ldata, 1);
+	global = g_new0(g3d_iff_gdata, 1);
 
+	global->context = context;
+	global->model = model;
+	global->f = f;
+
+	local->parent_id = id;
+	local->nb = len;
+
+	g3d_iff_read_ctnr(global, local, iob_chunks, G3D_IFF_PAD2);
+
+	g_free(local);
+	g_free(global);
+
 	return TRUE;
 }
 
@@ -69,428 +83,9 @@
 /* IOB specific                                                              */
 /*****************************************************************************/
 
-
-int iob_read_pnts(FILE *f, int nbytes, G3DObject* object, int type);
-int *iob_read_edges(FILE *f, int nbytes, G3DObject* object, int type);
-int iob_read_mat_lists(FILE *f, int nbytes, G3DObject* object, int type);
-int iob_read_faces(FILE *f, int nbytes, G3DObject* object, int *edges,
-	int type);
-gfloat iob_read_fract(FILE *f);
-
-int iob_read_directory(FILE *f, guint32 nbytes, G3DModel *model,
-	void *pobject, guint32 parentid, int level, G3DContext *context)
-{
-	guint32 id, len;
-	gint32 toread = nbytes;
-#if DEBUG > 0
-	int i;
-#endif
-	int *iob_edges = NULL;
-	guint32 typeShape, typeLamp;
-	gdouble offx, offy, offz;
-	G3DObject *iob_object = NULL;
-	G3DMaterial *material;
-
-	while(toread > 0)
-	{
-		toread -= g3d_iff_readchunk(f, &id, &len);
-#if DEBUG > 0
-		for(i=0; i<level; i++) g_printerr("  ");
-		g_printerr("[%c%c%c%c] %d bytes\n",
-			(id >> 24) & 0xFF, (id >> 16) & 0xFF,
-			(id >> 8) & 0xFF, id & 0xFF, len);
-#endif
-		switch(id)
-		{
-			case G3D_IFF_MKID('A','X','I','S'):
-				/* direction vectors for coordinate system */
-				/* x */
-				iob_read_fract(f);
-				iob_read_fract(f);
-				iob_read_fract(f);
-				/* y */
-				iob_read_fract(f);
-				iob_read_fract(f);
-				iob_read_fract(f);
-				/* z */
-				iob_read_fract(f);
-				iob_read_fract(f);
-				iob_read_fract(f);
-				break;
-
-			case G3D_IFF_MKID('O','B','J',' '):
-				iob_read_directory(f, len, model, NULL, id, level+1, context);
-				break;
-
-			case G3D_IFF_MKID('D','E','S','C'):
-				iob_object = g_new0(G3DObject, 1);
-				model->objects = g_slist_append(model->objects, iob_object);
-				material = g3d_material_new();
-				material->flags |= G3D_FLAG_MAT_TWOSIDE;
-				iob_object->materials = g_slist_append(iob_object->materials,
-					material);
-				material->name = g_strdup("material");
-				iob_read_directory(f, len, model, iob_object, id, level+1,
-					context);
-				break;
-
-			case G3D_IFF_MKID('N','A','M','E'):
-				((G3DObject*)pobject)->name = g_malloc0(19);
-				fread(((G3DObject*)pobject)->name, 1, len, f);
-				break;
-
-			case G3D_IFF_MKID('S','H','P','2'):
-				typeShape = g3d_read_int16_be(f);
-				typeLamp  = g3d_read_int16_be(f);
-#if DEBUG > 3
-				g_printerr("shapes: shape: 0x%4.4X lamp 0x%4.4X\n",
-					 typeShape, typeLamp);
-#endif
-				break;
-
-			case G3D_IFF_MKID('P','O','S','I'):
-				offx = (gdouble)g3d_read_int32_be(f) / 0xFFFF;
-				offy = (gdouble)g3d_read_int32_be(f) / 0xFFFF;
-				offz = (gdouble)g3d_read_int32_be(f) / 0xFFFF;
-				break;
-
-			case G3D_IFF_MKID('P','N','T','S'):
-			case G3D_IFF_MKID('P','N','T','2'):
-				iob_read_pnts(f,len,(G3DObject*)pobject, id);
-				break;
-
-			case G3D_IFF_MKID('E','D','G','E'):
-			case G3D_IFF_MKID('E','D','G','2'):
-				iob_edges = iob_read_edges(f, len, (G3DObject*)pobject, id);
-				break;
-
-			case G3D_IFF_MKID('F','A','C','E'):
-			case G3D_IFF_MKID('F','A','C','2'):
-				iob_read_faces(f, len, (G3DObject*)pobject, iob_edges, id);
-				break;
-
-#if 0
-			/* too slow and maybe buggy for now */
-			case G3D_IFF_MKID('C','L','S','T'):
-			case G3D_IFF_MKID('R','L','S','T'):
-			case G3D_IFF_MKID('T','L','S','T'):
-			case G3D_IFF_MKID('C','L','S','2'):
-			case G3D_IFF_MKID('R','L','S','2'):
-			case G3D_IFF_MKID('T','L','S','2'):
-				iob_read_mat_lists(f, len, (G3DObject*)pobject, id);
-				break;
-#endif
-
-			case G3D_IFF_MKID('C','O','L','R'):
-				material = g_slist_nth_data(((G3DObject*)pobject)->materials,
-					0);
-				g3d_read_int8(f);
-				material->r = (float)g3d_read_int8(f) / 255.0;
-				material->g = (float)g3d_read_int8(f) / 255.0;
-				material->b = (float)g3d_read_int8(f) / 255.0;
-#if DEBUG > 3
-				g_printerr("rgb: %f,%f,%f\n", material->r, material->g,
-					material->b);
-#endif
-				break;
-			case G3D_IFF_MKID('R','E','F','L'): {
-				int r,g,b;
-				material = g_slist_nth_data(((G3DObject*)pobject)->materials,
-					0);
-				g3d_read_int8(f);
-				r = g3d_read_int8(f);
-				g = g3d_read_int8(f);
-				b = g3d_read_int8(f);
-				material->specular[0] = (float)r / 255.0;
-				material->specular[1] = (float)g / 255.0;
-				material->specular[2] = (float)b / 255.0;
-				} break;
-
-			case G3D_IFF_MKID('T','O','B','J'):
-				/* end of child objects */
-				break;
-
-			case G3D_IFF_MKID('T','R','A','N'): {
-				int r,g,b;
-				material = g_slist_nth_data(((G3DObject*)pobject)->materials,
-					0);
-				g3d_read_int8(f);
-				r = g3d_read_int8(f);
-				g = g3d_read_int8(f);
-				b = g3d_read_int8(f);
-#if DEBUG > 3
-				g_printerr("rgb: %d,%d,%d\n", r, g, b);
-#endif
-				material->a = 1.0 - ((float)r / 255.0);
-				} break;
-
-			default:
-#if DEBUG > 0
-				g_printerr("*** unhandled ***\n");
-#endif
-				fseek(f, len+(len%2), SEEK_CUR);
-		}
-
-		g3d_context_update_interface(context);
-	}
-	if(iob_edges != NULL) g_free(iob_edges);
-	return TRUE;
-}
-
 gfloat iob_read_fract(FILE *f)
 {
 	gint32 i = g3d_read_int32_be(f);
 	return (gfloat)(i / 0xFFFF);
 }
 
-int iob_read_pnts(FILE *f, int nbytes, G3DObject* object, int type)
-{
-	int i, toread = nbytes;
-
-	g_return_val_if_fail(object != NULL, FALSE);
-
-	if(type == G3D_IFF_MKID('P','N','T','S'))
-	{
-		object->vertex_count = g3d_read_int16_be(f);
-		toread -= 2;
-	}
-	else
-	{
-		object->vertex_count = g3d_read_int32_be(f);
-		toread -= 4;
-	}
-	object->vertex_data = g_new0(gfloat, object->vertex_count * 3);
-#if DEBUG > 3
-	g_printerr("iob_read_pnts: malloc'ed object->vertices (%d vertices)\n",
-						 object->vertex_count);
-#endif
-	for(i=0; i<object->vertex_count; i++)
-	{
-		object->vertex_data[i * 3 + 0] = iob_read_fract(f);
-		object->vertex_data[i * 3 + 1] = iob_read_fract(f);
-		object->vertex_data[i * 3 + 2] = iob_read_fract(f);
-		toread -= 12;
-#if DEBUG > 3
-	g_printerr("iob_read_pnts: reading vertex #%d (%le|%le|%le)\n", i+1,
-		object->vertex_data[i*3+0], object->vertex_data[i*3+1],
-		object->vertex_data[i*3+2]);
-#endif
-	}
-	if(toread != 0)
-	{
-		g_printerr("error in PNTS chunk (%d bytes to read)\n", toread);
-		fseek(f, toread, SEEK_CUR);
-		return FALSE;
-	}
-	return TRUE;
-}
-
-int *iob_read_edges(FILE *f, int nbytes, G3DObject* object, int type)
-{
-	int i, nedges;
-	int toread = nbytes;
-	int *edges = NULL;
-
-	if(type == G3D_IFF_MKID('E','D','G','E'))
-	{
-		nedges = g3d_read_int16_be(f);
-		toread -= 2;
-	}
-	else
-	{
-		nedges = g3d_read_int32_be(f);
-		toread -= 4;
-	}
-#if DEBUG > 3
-	g_printerr("iob_read_edges: %d edges\n", nedges);
-#endif
-	edges = g_malloc(nedges * 2 * sizeof(int));
-	for(i=0; i<nedges; i++)
-	{
-		if(type == G3D_IFF_MKID('E','D','G','E'))
-		{
-			edges[i*2+0] = g3d_read_int16_be(f);
-			edges[i*2+1] = g3d_read_int16_be(f);
-			toread -= 4;
-		}
-		else
-		{
-			edges[i*2+0] = g3d_read_int32_be(f);
-			edges[i*2+1] = g3d_read_int32_be(f);
-			toread -= 8;
-		}
-	}
-	if(toread != 0)
-	{
-		g_printerr("error in EDGE chunk (%d bytes to read)\n", toread);
-		fseek(f, toread, SEEK_CUR);
-	}
-	return edges;
-}
-
-int iob_read_mat_lists(FILE *f, int nbytes, G3DObject* object, int type)
-{
-	guint32 nitems;
-	guint32 i;
-	G3DMaterial *material;
-	G3DFace *face;
-
-	if((type & 0xFF) == '2')
-		nitems = g3d_read_int32_be(f);
-	else
-		nitems = g3d_read_int16_be(f);
-
-#if DEBUG > 0
-	g_print("IOB: xLST / xLS2: %d items\n", nitems);
-#endif
-	for(i = 0; i < nitems; i ++)
-	{
-		/* default material + nth */
-		material = g_slist_nth_data(object->materials, i + 1);
-		if(material == NULL)
-		{
-			material = g3d_material_new();
-			material->name = g_strdup_printf("per face material #%d", i);
-			object->materials = g_slist_append(object->materials, material);
-
-			/* assign to face */
-			face = g_slist_nth_data(object->faces, i);
-			if(face)
-			{
-				face->material = material;
-			}
-		}
-
-		switch(type)
-		{
-			case G3D_IFF_MKID('C', 'L', 'S', 'T'):
-			case G3D_IFF_MKID('C', 'L', 'S', '2'):
-				material->r = (gfloat)(g3d_read_int8(f) / 255.0);
-				material->g = (gfloat)(g3d_read_int8(f) / 255.0);
-				material->b = (gfloat)(g3d_read_int8(f) / 255.0);
-				break;
-
-			case G3D_IFF_MKID('R', 'L', 'S', 'T'):
-			case G3D_IFF_MKID('R', 'L', 'S', '2'):
-				material->specular[0] = (gfloat)(g3d_read_int8(f) / 255.0);
-				material->specular[1] = (gfloat)(g3d_read_int8(f) / 255.0);
-				material->specular[2] = (gfloat)(g3d_read_int8(f) / 255.0);
-				break;
-
-			case G3D_IFF_MKID('T', 'L', 'S', 'T'):
-			case G3D_IFF_MKID('T', 'L', 'S', '2'):
-				material->a = 1.0 - (
-					(gfloat)(g3d_read_int8(f) / 255.0) +
-					(gfloat)(g3d_read_int8(f) / 255.0) +
-					(gfloat)(g3d_read_int8(f) / 255.0)) / 3.0;
-				break;
-		}
-	}
-
-	/* padding */
-	if(nitems % 2)
-		g3d_read_int8(f);
-
-	return TRUE;
-}
-
-void iob_order_array(int *array, int numelems)
-{
-	int elem = 0;
-
-	while(elem < numelems)
-	{
-		int i;
-		for(i=elem+1; i<numelems; i++)
-		{
-			if(array[elem] > array[i])
-			{
-				int bottle = array[elem];
-				array[elem] = array[i];
-				array[i] = bottle;
-			}
-		}
-		elem++;
-	}
-}
-
-int iob_read_faces(FILE *f, int nbytes, G3DObject* object, int *edges, 
-									 int type)
-{
-	int i, nfaces;
-	int toread = nbytes;
-	int v1, v2, v3;
-	int e[3];
-
-	if(type == G3D_IFF_MKID('F','A','C','E'))
-	{
-		nfaces = g3d_read_int16_be(f);
-		toread -= 2;
-	}
-	else
-	{
-		nfaces = g3d_read_int32_be(f);
-		toread -= 4;
-	}
-
-	for(i=0; i<nfaces; i++)
-	{
-		G3DFace *face = g_new0(G3DFace, 1);
-		face->vertex_count = 3;
-		face->vertex_indices = g_new0(guint32, 3);
-		if(type == G3D_IFF_MKID('F','A','C','E'))
-		{
-			e[0] = g3d_read_int16_be(f);
-			e[1] = g3d_read_int16_be(f);
-			e[2] = g3d_read_int16_be(f);
-			toread -= 6;
-		}
-		else
-		{
-			e[0] = g3d_read_int32_be(f);
-			e[1] = g3d_read_int32_be(f);
-			e[2] = g3d_read_int32_be(f);
-			toread -= 12;
-		}
-#if DEBUG > 3
-		g_printerr("iob_read_faces: #%d (%d|%d)-(%d|%d)-(%d|%d)\n", i,
-			edges[e[0]*2], edges[e[0]*2+1],
-			edges[e[1]*2], edges[e[1]*2+1],
-			edges[e[2]*2], edges[e[2]*2+1]);
-#endif
-#if 0 /* all mats twoside */
-		iob_order_array(e, 3);
-#endif
-		face->vertex_indices[0] = v1 = edges[e[0]*2+0];
-		face->vertex_indices[1] = v2 = edges[e[0]*2+1];
-
-		if((v1!=edges[e[1]*2+0]) && (v2!=edges[e[1]*2+0]))
-			v3=edges[e[1]*2+0];
-		else if((v1!=edges[e[1]*2+1]) && (v2!=edges[e[1]*2+1]))
-			v3=edges[e[1]*2+1];
-		else if((v1!=edges[e[2]*2+0]) && (v2!=edges[e[2]*2+0]))
-			v3=edges[e[2]*2+0];
-		else
-			v3 = edges[e[2]*2+1];
-
-		face->vertex_indices[2] = v3;
-
-		face->material = g_slist_nth_data(object->materials, 0);
-		object->faces = g_slist_prepend(object->faces, face);
-
-#if DEBUG > 3
-		g_printerr("iob_read_faces: face: #%d (%d/%d/%d)\n", i+1,
-			face->vertex_indices[0], face->vertex_indices[1],
-			face->vertex_indices[2]);
-#endif
-	}
-	if(toread != 0)
-	{
-		g_printerr("error in FACE chunk (%d bytes to read)\n", toread);
-		fseek(f, toread, SEEK_CUR);
-		return FALSE;
-	}
-	return TRUE;
-}
-
-

Added: trunk/libs3d/libg3d/plugins/import/imp_iob.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_iob.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_iob.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,9 @@
+#ifndef _IMP_IOB_H
+#define _IMP_IOB_H
+
+#include <stdio.h>
+#include <glib.h>
+
+gfloat iob_read_fract(FILE *f);
+
+#endif /* _IMP_IOB_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,324 @@
+#include <g3d/iff.h>
+#include <g3d/read.h>
+#include <g3d/material.h>
+
+#include "imp_iob.h"
+
+gboolean iob_cb_xLSx(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	G3DMaterial *material;
+	G3DFace *face;
+	gint32 i, nitems;
+
+	object = (G3DObject *)local->object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	if((local->id & 0xFF) == '2')
+	{
+		nitems = g3d_read_int32_be(global->f);
+		local->nb -= 4;
+	}
+	else
+	{
+		nitems = g3d_read_int16_be(global->f);
+		local->nb -= 2;
+	}
+
+	for(i = 0; i < nitems; i ++)
+	{
+		/* TODO: find material by parameters, don't create too much
+		 * materials */
+
+		/* default material + nth */
+		material = g_slist_nth_data(object->materials, i + 1);
+		if(material == NULL)
+		{
+			material = g3d_material_new();
+			material->name = g_strdup_printf("per face material #%d", i);
+			object->materials = g_slist_append(object->materials, material);
+
+			/* assign to face */
+			face = g_slist_nth_data(object->faces, i);
+			if(face)
+				face->material = material;
+		}
+
+		switch(local->id)
+		{
+			case G3D_IFF_MKID('C', 'L', 'S', 'T'):
+			case G3D_IFF_MKID('C', 'L', 'S', '2'):
+				material->r = (gfloat)g3d_read_int8(global->f) / 255.0;
+				material->g = (gfloat)g3d_read_int8(global->f) / 255.0;
+				material->b = (gfloat)g3d_read_int8(global->f) / 255.0;
+				break;
+
+			case G3D_IFF_MKID('R', 'L', 'S', 'T'):
+			case G3D_IFF_MKID('R', 'L', 'S', '2'):
+				material->specular[0] =
+					(gfloat)g3d_read_int8(global->f) / 255.0;
+				material->specular[1] =
+					(gfloat)g3d_read_int8(global->f) / 255.0;
+				material->specular[2] =
+					(gfloat)g3d_read_int8(global->f) / 255.0;
+				break;
+
+			case G3D_IFF_MKID('T', 'L', 'S', 'T'):
+			case G3D_IFF_MKID('T', 'L', 'S', '2'):
+				material->a = 1.0 - (
+					(gfloat)g3d_read_int8(global->f) / 255.0 +
+					(gfloat)g3d_read_int8(global->f) / 255.0 +
+					(gfloat)g3d_read_int8(global->f) / 255.0) / 3.0;
+				break;
+		}
+
+		local->nb -= 3;
+	}
+
+	return TRUE;
+}
+
+gboolean iob_cb_COLR(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	G3DMaterial *material;
+
+	object = (G3DObject *)local->object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	material = g_slist_nth_data(object->materials, 0);
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	g3d_read_int8(global->f);
+	material->r = (float)g3d_read_int8(global->f) / 255.0;
+	material->g = (float)g3d_read_int8(global->f) / 255.0;
+	material->b = (float)g3d_read_int8(global->f) / 255.0;
+	local->nb -= 4;
+
+	return TRUE;
+}
+
+gboolean iob_cb_DESC(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	G3DMaterial *material;
+
+	if(local->finalize) return TRUE;
+
+	object = g_new0(G3DObject, 1);
+	global->model->objects = g_slist_append(global->model->objects, object);
+
+	material = g3d_material_new();
+	material->flags |= G3D_FLAG_MAT_TWOSIDE;
+	material->name = g_strdup("(default material)");
+
+	object->materials = g_slist_append(object->materials, material);
+
+	local->object = object;
+
+	return TRUE;
+}
+
+gboolean iob_cb_EDGx(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	gint32 i, nedges;
+	gint32 *edges;
+
+	object = (G3DObject *)local->object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	if(local->id == G3D_IFF_MKID('E','D','G','E'))
+	{
+		nedges = g3d_read_int16_be(global->f);
+		local->nb -= 2;
+	}
+	else
+	{
+		nedges = g3d_read_int32_be(global->f);
+		local->nb -= 4;
+	}
+
+	edges = g_malloc(nedges * 2 * sizeof(gint32));
+	for(i = 0; i < nedges; i ++)
+	{
+		if(local->id == G3D_IFF_MKID('E','D','G','E'))
+		{
+			edges[i * 2 + 0] = g3d_read_int16_be(global->f);
+			edges[i * 2 + 1] = g3d_read_int16_be(global->f);
+			local->nb -= 4;
+		}
+		else
+		{
+			edges[i * 2 + 0] = g3d_read_int32_be(global->f);
+			edges[i * 2 + 1] = g3d_read_int32_be(global->f);
+			local->nb -= 8;
+		}
+	}
+
+	local->level_object = edges;
+
+	return TRUE;
+}
+
+gboolean iob_cb_FACx(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	gint32 *edges, e[3], v1, v2, v3;
+	gint32 i, nfaces;
+
+	object = (G3DObject *)local->object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	/* edges are read in EDGE/EDG2 chunk */
+	edges = (gint32 *)local->level_object;
+	g_return_val_if_fail(edges != NULL, FALSE);
+
+	if(local->id == G3D_IFF_MKID('F','A','C','E'))
+	{
+		nfaces = g3d_read_int16_be(global->f);
+		local->nb -= 2;
+	}
+	else
+	{
+		nfaces = g3d_read_int32_be(global->f);
+		local->nb -= 4;
+	}
+
+	for(i = 0; i < nfaces; i ++)
+	{
+		G3DFace *face = g_new0(G3DFace, 1);
+		face->vertex_count = 3;
+		face->vertex_indices = g_new0(guint32, 3);
+
+		if(local->id == G3D_IFF_MKID('F','A','C','E'))
+		{
+			e[0] = g3d_read_int16_be(global->f);
+			e[1] = g3d_read_int16_be(global->f);
+			e[2] = g3d_read_int16_be(global->f);
+			local->nb -= 6;
+		}
+		else
+		{
+			e[0] = g3d_read_int32_be(global->f);
+			e[1] = g3d_read_int32_be(global->f);
+			e[2] = g3d_read_int32_be(global->f);
+			local->nb -= 12;
+		}
+
+		face->vertex_indices[0] = v1 = edges[e[0] * 2 + 0];
+		face->vertex_indices[1] = v2 = edges[e[0] * 2 + 1];
+		if((v1 != edges[e[1] * 2 + 0]) && (v2 != edges[e[1] * 2 + 0]))
+			v3 = edges[e[1] * 2 + 0];
+		else if((v1 != edges[e[1] * 2 + 1]) && (v2 != edges[e[1] * 2 + 1]))
+			v3 = edges[e[1] * 2 + 1];
+		else if((v1 != edges[e[2] * 2 + 0]) && (v2 != edges[e[2] * 2 + 0]))
+			v3 = edges[e[2] * 2 + 0];
+		else
+			v3 = edges[e[2] * 2 + 1];
+
+		face->vertex_indices[2] = v3;
+
+		face->material = g_slist_nth_data(object->materials, 0);
+		object->faces = g_slist_append(object->faces, face);
+	}
+
+	/* free edges now */
+	g_free(edges);
+	local->level_object = NULL;
+
+	return TRUE;
+}
+
+gboolean iob_cb_NAME(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	gchar buffer[512];
+
+	object = (G3DObject *)local->object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	fread(buffer, 1, local->nb, global->f);
+
+	object->name = g_convert(buffer, local->nb,
+		"UTF-8", "ISO-8859-1",
+		NULL, NULL, NULL);
+
+	local->nb = 0;
+
+	return TRUE;
+}
+
+gboolean iob_cb_PNTx(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	gint32 i;
+
+	object = (G3DObject *)local->object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	if(local->id == G3D_IFF_MKID('P','N','T','S'))
+	{
+		object->vertex_count = g3d_read_int16_be(global->f);
+		local->nb -= 2;
+	}
+	else
+	{
+		object->vertex_count = g3d_read_int32_be(global->f);
+		local->nb -= 4;
+	}
+
+	object->vertex_data = g_new0(gfloat, object->vertex_count * 3);
+
+	for(i = 0; i < object->vertex_count; i ++)
+	{
+		object->vertex_data[i * 3 + 0] = iob_read_fract(global->f);
+		object->vertex_data[i * 3 + 1] = iob_read_fract(global->f);
+		object->vertex_data[i * 3 + 2] = iob_read_fract(global->f);
+		local->nb -= 12;
+	}
+
+	return TRUE;
+}
+
+gboolean iob_cb_REFL(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	G3DMaterial *material;
+
+	object = (G3DObject *)local->object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	material = g_slist_nth_data(object->materials, 0);
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	g3d_read_int8(global->f);
+	material->specular[0] = (float)g3d_read_int8(global->f) / 255.0;
+	material->specular[1] = (float)g3d_read_int8(global->f) / 255.0;
+	material->specular[2] = (float)g3d_read_int8(global->f) / 255.0;
+	local->nb -= 4;
+
+	return TRUE;
+}
+
+gboolean iob_cb_TRAN(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	G3DMaterial *material;
+
+	object = (G3DObject *)local->object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	material = g_slist_nth_data(object->materials, 0);
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	g3d_read_int8(global->f);
+	material->a = 1.0 - (
+		(gfloat)g3d_read_int8(global->f) / 255.0 +
+		(gfloat)g3d_read_int8(global->f) / 255.0 +
+		(gfloat)g3d_read_int8(global->f) / 255.0) / 3.0;
+	local->nb -= 4;
+
+	return TRUE;
+}
+

Added: trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_iob_callbacks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,16 @@
+#ifndef _IMP_IOB_CALLBACKS_H
+#define _IMP_IOB_CALLBACKS_H
+
+#include <g3d/iff.h>
+
+gboolean iob_cb_xLSx(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_COLR(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_DESC(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_EDGx(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_FACx(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_NAME(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_PNTx(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_REFL(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean iob_cb_TRAN(g3d_iff_gdata *global, g3d_iff_ldata *local);
+
+#endif /* _IMP_IOB_CALLBACKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_iob_chunks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_iob_chunks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_iob_chunks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,52 @@
+#ifndef _IMP_IOB_CHUNKS_H
+#define _IMP_IOB_CHUNKS_H
+
+#include <g3d/iff.h>
+
+#include "imp_iob_callbacks.h"
+
+static g3d_iff_chunk_info iob_chunks[] = {
+	{ "AXIS", "coordinate system",                0, NULL },
+	{ "BBOX", "bounding box data",                0, NULL },
+	{ "BRS4", "brush (4)",                        0, NULL },
+	{ "BRS5", "brush (5)",                        0, NULL },
+	{ "COLR", "color",                            0, iob_cb_COLR },
+	{ "CLS2", "color list (2)",                   0, iob_cb_xLSx },
+	{ "CLST", "color list",                       0, iob_cb_xLSx },
+	{ "DESC", "object description",               1, iob_cb_DESC },
+	{ "EDG2", "edges",                            0, iob_cb_EDGx },
+	{ "EDGE", "edges",                            0, iob_cb_EDGx },
+	{ "EFLG", "edge flags",                       0, NULL },
+	{ "FACE", "faces",                            0, iob_cb_FACx },
+	{ "FAC2", "faces (2)",                        0, iob_cb_FACx },
+	{ "FGR2", "face group (2)",                   0, NULL },
+	{ "FGR3", "face group (3)",                   0, NULL },
+	{ "FGR4", "face group (4)",                   0, NULL },
+	{ "INT1", "light intensity (1)",              0, NULL },
+	{ "NAME", "name",                             0, iob_cb_NAME },
+	{ "OBJ ", "object",                           1, NULL },
+	{ "PART", "particle parameters",              0, NULL },
+	{ "PNT2", "points (2)",                       0, iob_cb_PNTx },
+	{ "PNTS", "points",                           0, iob_cb_PNTx },
+	{ "POSI", "position in world",                0, NULL },
+	{ "PRP1", "properties (1)",                   0, NULL },
+	{ "PRP2", "properties (2)",                   0, NULL },
+	{ "REFL", "reflection",                       0, iob_cb_REFL },
+	{ "RLS2", "reflection list (2)",              0, iob_cb_xLSx },
+	{ "RLST", "reflection list",                  0, iob_cb_xLSx },
+	{ "SPC1", "specularity (1)",                  0, NULL },
+	{ "SPC2", "specularity (2)",                  0, NULL },
+	{ "SHAP", "shape type",                       0, NULL },
+	{ "SHP2", "shape type (2)",                   0, NULL },
+	{ "SIZE", "size",                             0, NULL },
+	{ "TLS2", "transparency list",                0, iob_cb_xLSx },
+	{ "TLST", "transparency list (2)",            0, iob_cb_xLSx },
+	{ "TOBJ", "end of object",                    0, NULL },
+	{ "TRAN", "transparency",                     0, iob_cb_TRAN },
+	{ "TXT3", "texture data (3)",                 0, NULL },
+	{ "TXT4", "texture data (4)",                 0, NULL },
+
+	{ NULL, NULL, 0, NULL }
+};
+
+#endif /* _IMP_IOB_CHUNKS_H */

Modified: trunk/libs3d/libg3d/plugins/import/imp_leocad.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_leocad.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_leocad.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -67,7 +67,9 @@
 	LeoCadLibrary *library;
 
 	library = (LeoCadLibrary *)user_data;
-	leocad_library_free(library);
+
+	if(library)
+		leocad_library_free(library);
 }
 
 gboolean plugin_load_model(G3DContext *context, const gchar *filename,
@@ -157,9 +159,15 @@
 						switch(ktype)
 						{
 							case 0x00: /* translation */
+#if 1
 								mloc[0 * 4 + 3] = param[0];
 								mloc[1 * 4 + 3] = param[1];
 								mloc[2 * 4 + 3] = param[2];
+#else
+								mloc[3 * 4 + 0] = param[0];
+								mloc[3 * 4 + 1] = param[1];
+								mloc[3 * 4 + 2] = param[2];
+#endif
 								g3d_matrix_multiply(matrix, mloc, matrix);
 								valid_matrix = TRUE;
 								break;
@@ -216,8 +224,12 @@
 								if((j % 4) == 0)
 									g_print("LeoCAD: matrix:");
 #endif
+#if 0
 								matrix[(j % 4) * 4 + j / 4] =
 									g3d_read_float_le(f);
+#else
+								matrix[j] = g3d_read_float_le(f);
+#endif
 #if DEBUG > 2
 								g_print(" %+.2f", matrix[j]);
 								if((j % 4) == 3)
@@ -335,10 +347,15 @@
 	if(!valid_matrix)
 	{
 		/* translation */
+#if 0
 		mloc[0 * 4 + 3] = offx;
 		mloc[1 * 4 + 3] = offy;
 		mloc[2 * 4 + 3] = offz;
-
+#else
+		mloc[3 * 4 + 0] = offx;
+		mloc[3 * 4 + 1] = offy;
+		mloc[3 * 4 + 2] = offz;
+#endif
 		/* rotation */
 		rotx = (gfloat)(rotx * M_PI) / 180.0;
 		roty = (gfloat)(roty * M_PI) / 180.0;
@@ -350,6 +367,8 @@
 		g3d_matrix_multiply(mloc, matrix, matrix);
 	}
 
+	/*g3d_matrix_dump(matrix);*/
+
 	/* transform vertices */
 	for(i = 0; i < object->vertex_count; i ++)
 		g3d_vector_transform(

Modified: trunk/libs3d/libg3d/plugins/import/imp_leocad_library.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_leocad_library.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_leocad_library.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -44,6 +44,7 @@
 #define LEOCAD_FLAG_PIECE_SMALL         0x10
 #define LEOCAD_FLAG_PIECE_MEDIUM        0x20
 #define LEOCAD_FLAG_LONGDATA_RUNTIME    0x40
+#define LEOCAD_FLAG_PIECE_RENAMED       0x80
 
 #define LEOCAD_TYPE_MESH                0x01
 #define LEOCAD_TYPE_STUD                0x02
@@ -99,11 +100,45 @@
 	return library;
 }
 
+static gboolean leocad_free_piece_cb(gpointer key, gpointer value,
+	gpointer user_data)
+{
+	LeoCadPiece *piece;
+
+	piece = (LeoCadPiece *)value;
+
+#if DEBUG > 3
+	g_print("D: freeing piece %s\n", piece->name);
+#endif
+
+	if(piece->name) g_free(piece->name);
+	if(piece->description) g_free(piece->description);
+	if(piece->moved_to) g_free(piece->moved_to);
+
+	if(!(piece->flags & LEOCAD_FLAG_PIECE_RENAMED))
+		if(piece->object) g3d_object_free(piece->object);
+
+	g_free(piece);
+
+	return TRUE;
+}
+
 void leocad_library_free(LeoCadLibrary *library)
 {
+	GSList *mlist;
+	G3DMaterial *material;
+
 	/* remove materials */
+	mlist = library->materials;
+	while(mlist)
+	{
+		material = (G3DMaterial *)mlist->data;
+		mlist = g_slist_remove(mlist, material);
+		g3d_material_free(material);
+	}
+
 	/* remove pieces */
-	/* FIXME: remove pieces */
+	g_hash_table_foreach_remove(library->pieces, leocad_free_piece_cb, NULL);
 	g_hash_table_destroy(library->pieces);
 
 	/* free library */
@@ -408,8 +443,13 @@
 
 						g3d_matrix_identity(matrix);
 						for(j = 0; j < 12; j ++)
-							matrix[(j % 3) * 4 + (j / 3)] =
+#if 1
+							matrix[(j / 3) * 4 + (j % 3)] =
 								g3d_read_float_le(bin);
+#else
+							matrix[j] = g3d_read_float_le(bin);
+#endif
+							/* g3d_matrix_dump(matrix); */
 
 						if(stud && piece->object)
 						{
@@ -542,7 +582,7 @@
 	gchar magic[32], nameold[9], namenew[9];
 	guint8 version, lastupdate;
 	guint32 nmoved, nbinsize, npieces, i;
-	LeoCadPiece *piece;
+	LeoCadPiece *piece, *newpiece;
 
 	fread(magic, 1, 32, idx);
 	if(strncmp(magic, "LeoCAD piece library index file", 31) != 0)
@@ -583,7 +623,17 @@
 
 		piece = g_hash_table_lookup(library->pieces, namenew);
 		if(piece)
-			g_hash_table_insert(library->pieces, g_strdup(nameold), piece);
+		{
+			newpiece = g_new0(LeoCadPiece, 1);
+			memcpy(newpiece, piece, sizeof(LeoCadPiece));
+			newpiece->name = g_strdup(nameold);
+			newpiece->description = g_strdup(piece->description);
+			newpiece->moved_to = g_strdup(namenew);
+			newpiece->object = piece->object;
+			newpiece->flags |= LEOCAD_FLAG_PIECE_RENAMED;
+
+			g_hash_table_insert(library->pieces, piece->name, newpiece);
+		}
 	}
 
 	return TRUE;

Modified: trunk/libs3d/libg3d/plugins/import/imp_lwo.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_lwo.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_lwo.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -39,24 +39,26 @@
 
 #define LW_MAX_POINTS   200
 #define LW_MAX_NAME_LEN 500
+#define LW_F_LWO2 1
 
-#define LW_F_LWO2		(1 << 0)
+#include "imp_lwo.h"
+#include "imp_lwo_chunks.h"
 
-static gboolean lwo_read_directory(FILE *f, guint32 nbytes, G3DModel *model,
-	gpointer pobject, guint32 parentid, guint32 level, guint32 flags,
-	G3DContext *context);
-
 /*****************************************************************************/
 /* plugin interface                                                          */
 /*****************************************************************************/
 
+static void lwo_fix_texfaces(G3DModel *model);
+
 gboolean plugin_load_model(G3DContext *context, const gchar *filename,
 	G3DModel *model, gpointer user_data)
 {
-	G3DObject *lwo_object = NULL;
+	LwoObject *obj;
 	G3DMaterial *material;
 	FILE *f;
-	guint32 id, len, flags = 0;
+	guint32 id, len;
+	g3d_iff_gdata *global;
+	g3d_iff_ldata *local;
 
 	f = g3d_iff_open(filename, &id, &len);
 	if(f == NULL)
@@ -73,26 +75,51 @@
 		return FALSE;
 	}
 
-	/* LWO2 object file */
+	obj = g_new0(LwoObject, 1);
+
+	global = g_new0(g3d_iff_gdata, 1);
+	global->f = f;
+	global->context = context;
+	global->model = model;
 	if(id == G3D_IFF_MKID('L','W','O','2'))
-		flags |= LW_F_LWO2;
+		global->flags |= LWO_FLAG_LWO2;
+	global->user_data = obj;
 
-	g3d_context_update_progress_bar(context, 0.0, TRUE);
+	local = g_new0(g3d_iff_ldata, 1);
+	local->id = id;
+	local->nb = len;
 
 	material = g3d_material_new();
 	material->name = g_strdup("fallback material");
 	model->materials = g_slist_append(model->materials, material);
 
-	lwo_read_directory(f, len, model, lwo_object, id, 1, flags, context);
+	g3d_iff_read_ctnr(global, local, lwo_chunks,
+		G3D_IFF_PAD2 | G3D_IFF_SUBCHUNK_LEN16);
 
+	lwo_fix_texfaces(model);
+
+	/* cleanup */
+	if(obj->ntags)
+		g_strfreev(obj->tags);
+
+	if(obj->nclips)
+	{
+		g_free(obj->clips);
+		g_strfreev(obj->clipfiles);
+	}
+
+	if(obj->tex_vertices)
+		g_free(obj->tex_vertices);
+
+	g_free(obj);
+
+	g_free(local);
+	g_free(global);
+
 	fclose(f);
 
 	g3d_context_update_progress_bar(context, 0.0, FALSE);
 
-#if DEBUG > 2
-	g_printerr("DEBUG: lwo file loaded\n");
-#endif
-
 	return TRUE;
 }
 
@@ -100,7 +127,7 @@
 {
 	return g_strdup(
 		"Import plugin to load LightWave Objects (.lwo files)\n"
-		"Author: Markus Dahms, heavily copied from gtkglarea examples\n");
+		"Author: Markus Dahms\n");
 }
 
 gchar **plugin_extensions(G3DContext *context)
@@ -112,16 +139,7 @@
 /* private                                                                   */
 /*****************************************************************************/
 
-static gint lwo_read_string(FILE *f, char *s);
-static void lwo_read_srfs(FILE *f, gint nbytes, G3DObject *object);
-static void lwo_read_surf(FILE *f, gint nbytes, G3DObject *object,
-	guint32 flags);
-static void lwo_read_pols(FILE *f, gint nbytes,
-	G3DModel *model, G3DObject *object, guint32 flags, G3DContext *context);
-static void lwo_read_pnts(FILE *f, gint nbytes, G3DObject *object,
-	G3DContext *context);
-
-static G3DObject *lwo_create_object(FILE *f, G3DModel *model, guint32 flags)
+G3DObject *lwo_create_object(FILE *f, G3DModel *model, guint32 flags)
 {
 	G3DObject *object = g_new0(G3DObject, 1);
 	object->name = g_strdup_printf("LWO%c object @ 0x%08lx",
@@ -136,73 +154,11 @@
 	return object;
 }
 
-static gboolean lwo_read_directory(FILE *f, guint32 nbytes, G3DModel *model,
-	gpointer pobject, guint32 parentid, guint32 level, guint32 flags,
-	G3DContext *context)
-{
-	G3DObject *object = NULL;
-	int toread = nbytes;
-	float pscale = (float)toread / 100.0;
-	while(toread > 0)
-	{
-		guint32 id, len;
-
-		if(level == 0)
-		{
-			g3d_context_update_progress_bar(context,
-				100.0 - (float)toread / pscale, TRUE);
-		}
-
-		toread -= g3d_iff_readchunk(f, &id, &len);
-#if DEBUG > 0
-		g_printerr("%.*s[%c%c%c%c] @ 0x%08lx (%d bytes)\n",
-			level * 2, "                   ",
-			(id >> 24) & 0xFF, (id >> 16) & 0xFF,
-			(id >> 8) & 0xFF, id & 0xFF,
-			ftell(f) - 8, len);
-#endif
-		switch(id)
-		{
-			case G3D_IFF_MKID('P','N','T','S'):
-				if(object == NULL)
-					object = lwo_create_object(f, model, flags);
-				lwo_read_pnts(f, len, object, context);
-				break;
-
-			case G3D_IFF_MKID('P','O','L','S'):
-				lwo_read_pols(f, len, model, object, flags, context);
-				break;
-
-			case G3D_IFF_MKID('S','R','F','S'):
-				/* LWOB: surfaces */
-				if(object == NULL)
-					object = lwo_create_object(f, model, flags);
-				lwo_read_srfs(f, len, object);
-				break;
-
-			case G3D_IFF_MKID('S','U','R','F'):
-				lwo_read_surf(f, len, object, flags);
-				break;
-
-			case G3D_IFF_MKID('T','A','G','S'):
-				/* LWO2: first (used) chunk of object */
-				object = lwo_create_object(f, model, flags);
-				lwo_read_srfs(f, len, object);
-				break;
-
-			default:
-				fseek(f, len + (len%2), SEEK_CUR);
-				break;
-		}
-	}
-	return TRUE;
-}
-
 /*****************************************************************************/
 /* LWO specific                                                              */
 /*****************************************************************************/
 
-static gint lwo_read_string(FILE *f, char *s)
+gint lwo_read_string(FILE *f, char *s)
 {
 	gint c;
 	gint cnt = 0;
@@ -222,7 +178,7 @@
 	return cnt;
 }
 
-static guint32 lwo_read_vx(FILE *f, guint *index)
+guint32 lwo_read_vx(FILE *f, guint *index)
 {
 	*index = g3d_read_int16_be(f);
 	if((*index & 0xFF00) == 0xFF00)
@@ -238,319 +194,32 @@
 	}
 }
 
-static void lwo_read_srfs(FILE *f, gint nbytes, G3DObject *object)
+static void lwo_fix_texfaces(G3DModel *model)
 {
-#if DEBUG > 2
-	g_printerr("lwo_read_srfs {");
-#endif
-	while(nbytes > 0)
-	{
-		char text[1024];
-		G3DMaterial *material = g3d_material_new();
-
-		nbytes -= lwo_read_string(f, text);
-		material->name = g_strdup(text);
-		object->materials = g_slist_append(object->materials, material);
-	}
-#if DEBUG > 2
-	g_printerr(" }\n");
-#endif
-}
-
-static void lwo_read_surf(FILE *f, gint nbytes, G3DObject *object,
-	guint32 flags)
-{
-	GSList *mlist;
-	G3DMaterial *material = NULL, *tmat;
-	gfloat tmpf;
-	char name[LW_MAX_NAME_LEN];
-	guint32 len = 0, tmp;
-
-	len = lwo_read_string(f, name);
-	nbytes -= len;
-
-	if(flags & LW_F_LWO2)
-	{
-		g3d_read_int16_be(f);
-		nbytes -= 2;
-	}
-
-	mlist = object->materials;
-	g_return_if_fail(mlist != NULL);
-	while(mlist != NULL)
-	{
-		tmat = (G3DMaterial*)mlist->data;
-		if(strcmp(name, tmat->name) == 0)
-		{
-			material = tmat;
-			break;
-		}
-		mlist = mlist->next;
-	}
-	g_return_if_fail(material != NULL);
-#if DEBUG > 1
-	g_print("LWO: surf: %s\n", material->name);
-#endif
-
-	material->a = 1.0;
-
-	while(nbytes > 0)
-	{
-		gint32 id = g3d_read_int32_be(f);
-		nbytes -= 4;
-		len = g3d_read_int16_be(f);
-		nbytes -= 2;
-
-		switch(id)
-		{
-			case G3D_IFF_MKID('C','O','L','R'):
-				if(flags & LW_F_LWO2)
-				{
-					material->r = g3d_read_float_be(f);
-					material->g = g3d_read_float_be(f);
-					material->b = g3d_read_float_be(f);
-#if DEBUG > 0
-					g_print("LWO: SURF: COLR: %+1.2f %+1.2f %+1.2f\n",
-						material->r, material->g, material->b);
-#endif
-					g3d_read_int16_be(f);
-					nbytes -= 14;
-				}
-				else
-				{
-					material->r = g3d_read_int8(f) / 255.0;
-					material->g = g3d_read_int8(f) / 255.0;
-					material->b = g3d_read_int8(f) / 255.0;
-					g3d_read_int8(f);
-					nbytes -= 4;
-				}
-				break;
-
-			case G3D_IFF_MKID('D','I','F','F'):
-				/* diffuse */
-				if(flags & LW_F_LWO2)
-				{
-					g3d_read_float_be(f); /* intensity */
-					nbytes -= 4;
-					nbytes -= lwo_read_vx(f, &tmp); /* envelope ?? */
-				}
-				else
-				{
-					g3d_read_int16_be(f);
-					nbytes -= 2;
-				}
-				break;
-
-			case G3D_IFF_MKID('S','P','E','C'):
-				/* specular */
-				if(flags & LW_F_LWO2)
-				{
-					tmpf = 1.0 - g3d_read_float_be(f); /* intensity */
-					nbytes -= 4;
-					nbytes -= lwo_read_vx(f, &tmp); /* envelope ?? */
-				}
-				else
-				{
-					tmpf = 1.0 - (float)g3d_read_int16_be(f) / 256.0;
-					nbytes -= 2;
-				}
-
-				material->specular[0] = material->r * tmpf;
-				material->specular[1] = material->g * tmpf;
-				material->specular[2] = material->b * tmpf;
-				break;
-
-			case G3D_IFF_MKID('T','R','A','N'):
-				/* transparency */
-				if(flags & LW_F_LWO2)
-				{
-					material->a = 1.0 - g3d_read_float_be(f); /* intensity */
-					nbytes -= 4;
-					nbytes -= lwo_read_vx(f, &tmp); /* envelope ?? */
-				}
-				else
-				{
-					material->a = 1.0 - (float)g3d_read_int16_be(f) / 256.0;
-					nbytes -= 2;
-				}
-				if(material->a < 0.1)
-					material->a = 0.1;
-				break;
-
-			default:
-#if DEBUG > 0
-				g_print("LWO: surf: [%c%c%c%c] (%d bytes)\n",
-					(id >> 24) & 0xFF, (id >> 16) & 0xFF,
-					(id >> 8) & 0xFF, id & 0xFF,
-					len);
-#endif
-				fseek(f, len+(len%2), SEEK_CUR);
-				nbytes -= len+(len%2);
-				break;
-		}
-	}
-#if DEBUG > 2
-	g_printerr(" }\n");
-#endif
-}
-
-static void lwo_read_pols(FILE *f, gint nbytes,
-	G3DModel *model, G3DObject *object, guint32 flags, G3DContext *context)
-{
+	GSList *olist, *flist;
+	G3DObject *object;
 	G3DFace *face;
-	guint32 n = 0, type, i;
-	gint16 nmat;
 
-	if(flags & LW_F_LWO2)
+	olist = model->objects;
+	while(olist)
 	{
-		type = g3d_read_int32_be(f);
-		nbytes -= 4;
+		object = (G3DObject *)olist->data;
+		olist = olist->next;
 
-		if(type != G3D_IFF_MKID('F', 'A', 'C', 'E'))
+		flist = object->faces;
+		while(flist)
 		{
-			fseek(f, nbytes, SEEK_CUR);
-			return;
-		}
-	}
+			face = (G3DFace *)flist->data;
+			flist = flist->next;
 
-	while(nbytes > 0)
-	{
-		n++;
-		face = g_new0(G3DFace, 1);
-		face->vertex_count = g3d_read_int16_be(f);
-		nbytes -= 2;
-
-		if(flags & LW_F_LWO2)
-			face->vertex_count &= 0x03FF; /* 6 high order bits are flags */
-
-		face->vertex_indices = g_new0(guint32, face->vertex_count);
-
-		for(i = 0; i < face->vertex_count; i ++)
-		{
-			if(flags & LW_F_LWO2)
+			if(face->flags & G3D_FLAG_FAC_TEXMAP)
 			{
-				nbytes -= lwo_read_vx(f, &(face->vertex_indices[i]));
-#if DEBUG > 0
-				if(face->vertex_indices[i] >= object->vertex_count)
+				face->tex_image = face->material->tex_image;
+				if(face->tex_image == NULL)
 				{
-					g_print(
-						"LWO: vertex_indices[%d] (%d) >= vertex_count (%d)\n",
-						i, face->vertex_indices[i], object->vertex_count);
+					face->flags &= ~G3D_FLAG_FAC_TEXMAP;
 				}
-#endif
 			}
-			else
-			{
-				face->vertex_indices[i] = g3d_read_int16_be(f);
-				nbytes -= 2;
-
-				if(face->vertex_indices[i] > object->vertex_count)
-				{
-#if DEBUG > 0
-					g_print(
-						"LWO: vertex_indices[%d] (%d) >= vertex_count (%d)\n",
-						i, face->vertex_indices[i], object->vertex_count);
-#endif
-					face->vertex_indices[i] = 0;
-				}
-			}
-			g3d_context_update_interface(context);
 		}
-
-		if(!(flags & LW_F_LWO2))
-		{
-			nmat = g3d_read_int16_be(f);
-			nbytes -= 2;
-
-			if(nmat < 0)
-			{
-				/* detail polygons, skipped */
-				int det_cnt = g3d_read_int16_be(f);
-				nbytes -= 2;
-				nmat *= -1;
-				while(det_cnt-- > 0)
-				{
-					int cnt = g3d_read_int16_be(f);
-					nbytes -= 2;
-
-					fseek(f, cnt*2+2, SEEK_CUR);
-					nbytes -= cnt*2+2;
-					g3d_context_update_interface(context);
-				}
-			}
-			else if(nmat == 0)
-			{
-				nmat = 1;
-			}
-
-			face->material = g_slist_nth_data(object->materials,
-				(guint) nmat - 1);
-			if(face->material == NULL)
-			{
-#if DEBUG > 0
-				g_print("LWO: face->material is NULL (#%d)\n", nmat - 1);
-#endif
-				face->material = g_slist_nth_data(model->materials, 0);
-			}
-#if DEBUG > 3
-			g_printerr("lwo_read_pols: face #%d (nbytes: %d)\n", n, nb);
-#endif
-		} /* ! LW_F_LWO2 */
-		else
-		{
-			face->material = g_slist_nth_data(object->materials, 0);
-			if(face->material == NULL)
-				face->material = g_slist_nth_data(model->materials, 0);
-		}
-
-		if(face->vertex_count < 3)
-		{
-			g_free(face->vertex_indices);
-			g_free(face);
-		}
-		else
-			object->faces = g_slist_prepend(object->faces, face);
-	} /* nb > 0 */
-
-#if DEBUG > 0
-	g_print("LWO: POLS: %d faces\n", g_slist_length(object->faces));
-#endif
-
-	if(nbytes != 0)
-	{
-		fseek(f, nbytes, SEEK_CUR);
-#if DEBUG > 0
-		g_print("LWO: POLS: had to seek %d bytes", nbytes);
-#endif
 	}
 }
-
-static void lwo_read_pnts(FILE *f, gint nbytes, G3DObject *object,
-	G3DContext *context)
-{
-	guint32 i, off;
-
-	off = object->vertex_count;
-	object->vertex_count += (nbytes / 12);
-	if(object->vertex_count < 3)
-	{
-#if DEBUG > 0
-		g_print("LWO: PNTS: object->vertex_count < 3 (%d)\n",
-			object->vertex_count);
-#endif
-		return;
-	}
-
-	object->vertex_data = g_realloc(object->vertex_data,
-		sizeof(gfloat) * object->vertex_count * 3);
-
-	for(i = off; i < object->vertex_count; i ++)
-	{
-		object->vertex_data[i * 3 + 0] = g3d_read_float_be(f);
-		object->vertex_data[i * 3 + 1] = g3d_read_float_be(f);
-		object->vertex_data[i * 3 + 2] = g3d_read_float_be(f);
-		g3d_context_update_interface(context);
-	}
-}
-
-

Added: trunk/libs3d/libg3d/plugins/import/imp_lwo.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_lwo.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_lwo.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,28 @@
+#ifndef _IMP_LWO_H
+#define _IMP_LWO_H
+
+#include <stdio.h>
+#include <g3d/types.h>
+
+#define LWO_FLAG_LWO2          (1 << 0)
+
+typedef struct
+{
+	gint32 ntags;
+	gchar **tags;
+
+	gint32 nclips;
+	guint32 *clips;
+	gchar **clipfiles;
+
+	gfloat *tex_vertices;
+
+	G3DObject *object;
+}
+LwoObject;
+
+G3DObject *lwo_create_object(FILE *f, G3DModel *model, guint32 flags);
+gint lwo_read_string(FILE *f, char *s);
+guint32 lwo_read_vx(FILE *f, guint *index);
+
+#endif /* _IMP_LWO_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,584 @@
+
+#include <string.h>
+
+#include <glib.h>
+
+#include <g3d/context.h>
+#include <g3d/material.h>
+#include <g3d/texture.h>
+#include <g3d/iff.h>
+#include <g3d/read.h>
+
+#include "imp_lwo.h"
+
+gboolean lwo_cb_CLIP(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	guint32 index;
+
+	obj = (LwoObject *)global->user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	if(!local->finalize)
+	{
+		index = g3d_read_int32_be(global->f);
+		local->nb -= 4;
+
+		obj->nclips ++;
+		obj->clips = g_realloc(obj->clips, obj->nclips * sizeof(guint32));
+		obj->clipfiles = g_realloc(obj->clipfiles,
+			(obj->nclips + 1) * sizeof(gchar *));
+
+		obj->clips[obj->nclips - 1] = index;
+		obj->clipfiles[obj->nclips - 1] = g_strdup("undef");
+		obj->clipfiles[obj->nclips] = NULL;
+	}
+
+	return TRUE;
+}
+
+gboolean lwo_cb_COLR(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DMaterial *material;
+
+	material = (G3DMaterial *)local->object;
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	if(global->flags & LWO_FLAG_LWO2)
+	{
+		material->r = g3d_read_float_be(global->f);
+		material->g = g3d_read_float_be(global->f);
+		material->b = g3d_read_float_be(global->f);
+		local->nb -= 12;
+		g3d_read_int16_be(global->f);
+		local->nb -= 2;
+	}
+	else
+	{
+		material->r = g3d_read_int8(global->f) / 255.0;
+		material->g = g3d_read_int8(global->f) / 255.0;
+		material->b = g3d_read_int8(global->f) / 255.0;
+		g3d_read_int8(global->f);
+		local->nb -= 4;
+	}
+
+	return TRUE;
+}
+
+/* image index */
+gboolean lwo_cb_IMAG(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DMaterial *material;
+	guint32 index, i;
+
+	obj = (LwoObject *)global->user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	material = (G3DMaterial *)local->object;
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	local->nb -= lwo_read_vx(global->f, &index);
+
+	for(i = 0; i < obj->nclips; i ++)
+	{
+		if(obj->clips[i] == index)
+			break;
+	}
+
+	if(obj->clips[i] == index)
+	{
+		material->tex_image = g3d_texture_load_cached(
+			global->context, global->model, obj->clipfiles[i]);
+	}
+
+	return TRUE;
+}
+
+/* points */
+gboolean lwo_cb_PNTS(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DObject *object;
+	gint32 i, off;
+
+	obj = (LwoObject *)global->user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	if(global->flags & LWO_FLAG_LWO2)
+	{
+		object = lwo_create_object(global->f, global->model, global->flags);
+		obj->object = object;
+
+		if(obj->tex_vertices)
+		{
+			g_free(obj->tex_vertices);
+			obj->tex_vertices = NULL;
+		}
+	}
+	else
+	{
+		object = (G3DObject *)obj->object;
+		if(object == NULL)
+		{
+			object = lwo_create_object(global->f, global->model,
+				global->flags);
+			obj->object = object;
+		}
+	}
+
+	off = object->vertex_count;
+	object->vertex_count += (local->nb / 12);
+	g_return_val_if_fail(object->vertex_count >= 3, FALSE);
+
+	object->vertex_data = g_realloc(object->vertex_data,
+		sizeof(gfloat) * object->vertex_count * 3);
+
+	for(i = off; i < object->vertex_count; i ++)
+	{
+		object->vertex_data[i * 3 + 0] = g3d_read_float_be(global->f);
+		object->vertex_data[i * 3 + 1] = g3d_read_float_be(global->f);
+		object->vertex_data[i * 3 + 2] = g3d_read_float_be(global->f);
+		local->nb -= 12;
+	}
+
+	return TRUE;
+}
+
+/* polygons */
+gboolean lwo_cb_POLS(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DObject *object;
+	G3DFace *face;
+	guint32 type;
+	gint32 n = 0, i, nmat, det_cnt, cnt;
+	gint16 i16;
+	gchar *tmp;
+
+	obj = (LwoObject *)global->user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	object = (G3DObject *)obj->object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	if(global->flags & LWO_FLAG_LWO2)
+	{
+		type = g3d_read_int32_be(global->f);
+		local->nb -= 4;
+
+		if(type != G3D_IFF_MKID('F', 'A', 'C', 'E'))
+		{
+			tmp = g3d_iff_id_to_text(type);
+			g_warning("[LWO] unhandled polygon type %s", tmp);
+			g_free(tmp);
+			return FALSE;
+		}
+	}
+
+	while(local->nb > 0)
+	{
+		n ++;
+		face = g_new0(G3DFace, 1);
+		face->vertex_count = g3d_read_int16_be(global->f);
+		local->nb -= 2;
+
+		if(global->flags & LWO_FLAG_LWO2)
+			face->vertex_count &= 0x03FF;
+
+		face->vertex_indices = g_new0(guint32, face->vertex_count);
+
+		if(obj->tex_vertices)
+		{
+			face->flags |= G3D_FLAG_FAC_TEXMAP;
+			face->tex_vertex_count = face->vertex_count;
+			face->tex_vertex_data = g_new0(gfloat, face->tex_vertex_count * 2);
+		}
+
+		for(i = 0; i < face->vertex_count; i ++)
+		{
+			if(global->flags & LWO_FLAG_LWO2)
+			{
+				local->nb -= lwo_read_vx(global->f,
+					&(face->vertex_indices[i]));
+			}
+			else
+			{
+				face->vertex_indices[i] = g3d_read_int16_be(global->f);
+				local->nb -= 2;
+#if 0
+				i16 = g3d_read_int16_be(global->f);
+				local->nb -= 2;
+
+				if(i16 < 0)
+					face->vertex_indices[i] = - i16;
+				else
+					face->vertex_indices[i] = i16;
+#endif
+
+				if(face->vertex_indices[i] > object->vertex_count)
+					face->vertex_indices[i] = 0;
+			}
+
+			if(obj->tex_vertices)
+			{
+				face->tex_vertex_data[i * 2 + 0] =
+					obj->tex_vertices[face->vertex_indices[i] * 2 + 0];
+				face->tex_vertex_data[i * 2 + 1] =
+					obj->tex_vertices[face->vertex_indices[i] * 2 + 1];
+			}
+		} /* i: 0..face->vertex_count */
+
+		if(!(global->flags & LWO_FLAG_LWO2))
+		{
+			nmat = g3d_read_int16_be(global->f);
+			local->nb -= 2;
+
+			if(nmat < 0)
+			{
+				/* detail polygons, skipped */
+				det_cnt = g3d_read_int16_be(global->f);
+				local->nb -= 2;
+				nmat *= -1;
+				while(det_cnt-- > 0)
+				{
+					cnt = g3d_read_int16_be(global->f);
+					local->nb -= 2;
+
+					fseek(global->f, cnt * 2 + 2, SEEK_CUR);
+					local->nb -= cnt * 2 + 2;
+				}
+			}
+			else if(nmat == 0)
+			{
+				nmat = 1;
+			}
+
+			face->material = g_slist_nth_data(global->model->materials, nmat);
+
+			if(face->material == NULL)
+			{
+#if 0
+				g_warning("[LWO] face->material is NULL (#%d)\n", nmat - 1);
+#endif
+				face->material = g_slist_nth_data(global->model->materials, 0);
+			}
+
+		} /* !LWO2 */
+		else
+		{
+			face->material = g_slist_nth_data(global->model->materials, 0);
+		} /* LWO2 */
+
+		if(face->vertex_count < 3)
+		{
+			g_free(face->vertex_indices);
+			g_free(face);
+		}
+		else
+		{
+			object->faces = g_slist_prepend(object->faces, face);
+		}
+
+		g3d_context_update_interface(global->context);
+	} /* local->nb > 0 */
+
+	return TRUE;
+}
+
+/* poly tag mapping */
+gboolean lwo_cb_PTAG(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DObject *object;
+	G3DMaterial *material, *tmat;
+	G3DFace *face;
+	GSList *mlist;
+	gint32 id, fmax;
+	guint32 poly, tag;
+
+	obj = (LwoObject *)global->user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	object = (G3DObject *)obj->object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	id = g3d_read_int32_be(global->f);
+	local->nb -= 4;
+
+	if(id != G3D_IFF_MKID('S','U','R','F'))
+		return FALSE;
+
+	fmax = g_slist_length(object->faces) - 1;
+
+	while(local->nb > 0)
+	{
+		local->nb -= lwo_read_vx(global->f, &poly);
+		tag = g3d_read_int16_be(global->f);
+		local->nb -= 2;
+
+		face = (G3DFace *)g_slist_nth_data(object->faces, fmax - poly);
+		g_return_val_if_fail(face != NULL, FALSE);
+
+		if(tag > obj->ntags)
+		{
+			g_printerr("[LWO] tag %d not listed (%d tags)\n", tag, obj->ntags);
+			continue;
+		}
+
+		material = NULL;
+		mlist = global->model->materials;
+		while(mlist != NULL)
+		{
+			tmat = (G3DMaterial*)mlist->data;
+			if(strcmp(obj->tags[tag], tmat->name) == 0)
+			{
+				material = tmat;
+				break;
+			}
+			mlist = mlist->next;
+		}
+
+		if(material)
+			face->material = material;
+		else
+			g_printerr("[LWO] unknown material tag %s\n", obj->tags[tag]);
+	}
+
+	return TRUE;
+}
+
+/* specularity */
+gboolean lwo_cb_SPEC(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DMaterial *material;
+	gfloat tmpf;
+
+	material = (G3DMaterial *)local->object;
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	if(global->flags & LWO_FLAG_LWO2)
+	{
+		tmpf = 1.0 - g3d_read_float_be(global->f);
+		local->nb -= 4;
+	}
+	else
+	{
+		tmpf = 1.0 - (gfloat)g3d_read_int16_be(global->f) / 256.0;
+		local->nb -= 2;
+	}
+
+	material->specular[0] = material->r * tmpf;
+	material->specular[1] = material->g * tmpf;
+	material->specular[2] = material->b * tmpf;
+
+	return TRUE;
+}
+
+/* surfaces */
+gboolean lwo_cb_SRFS(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DMaterial *material;
+	gchar buffer[512];
+
+	obj = (LwoObject *)global->user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	while(local->nb > 0)
+	{
+		material = g3d_material_new();
+		local->nb -= lwo_read_string(global->f, buffer);
+		material->name = g_strdup(buffer);
+		global->model->materials = g_slist_append(global->model->materials,
+			material);
+
+	}
+
+	return TRUE;
+}
+
+/* still image */
+gboolean lwo_cb_STIL(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+
+	gchar buffer[512];
+
+    obj = (LwoObject *)global->user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	local->nb -= lwo_read_string(global->f, buffer);
+
+	g_free(obj->clipfiles[obj->nclips - 1]);
+	obj->clipfiles[obj->nclips - 1] = g_strdup(buffer);
+	obj->clipfiles[obj->nclips] = NULL;
+
+	return TRUE;
+}
+
+/* surface */
+gboolean lwo_cb_SURF(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DObject *object;
+	G3DMaterial *material = NULL, *tmat;
+	GSList *mlist;
+	gchar name[512];
+
+	obj = (LwoObject *)global->user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	object = (G3DObject *)obj->object;
+	g_return_val_if_fail(object != NULL, FALSE);
+
+	if(!local->finalize)
+	{
+		local->nb -= lwo_read_string(global->f, name);
+
+		if(global->flags & LWO_FLAG_LWO2)
+		{
+			g3d_read_int16_be(global->f);
+			local->nb -= 2;
+		}
+
+		mlist = global->model->materials;
+		while(mlist != NULL)
+		{
+			tmat = (G3DMaterial*)mlist->data;
+			if(strcmp(name, tmat->name) == 0)
+			{
+				material = tmat;
+				break;
+			}
+			mlist = mlist->next;
+		}
+
+		if(material == NULL)
+		{
+			material = g3d_material_new();
+			material->name = g_strdup(name);
+			global->model->materials = g_slist_append(global->model->materials,
+				material);
+		}
+
+		local->object = material;
+	}
+
+	return TRUE;
+}
+
+/* tags */
+gboolean lwo_cb_TAGS(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	G3DMaterial *material;
+	gchar buffer[512];
+
+	obj = (LwoObject *)global->user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	if(obj->ntags)
+	{
+		g_strfreev(obj->tags);
+		obj->ntags = 0;
+	}
+
+	/* read tags */
+	while(local->nb > 0)
+	{
+		local->nb -= lwo_read_string(global->f, buffer);
+		obj->ntags ++;
+		obj->tags = g_realloc(obj->tags, (1 + obj->ntags) * sizeof(gchar *));
+		obj->tags[obj->ntags - 1] = g_strdup(buffer);
+		obj->tags[obj->ntags] = NULL;
+
+		material = g3d_material_new();
+		material->name = g_strdup(buffer);
+		global->model->materials = g_slist_append(global->model->materials,
+			material);
+	}
+
+	return TRUE;
+}
+
+/* transparency */
+gboolean lwo_cb_TRAN(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DMaterial *material;
+
+	material = (G3DMaterial *)local->object;
+	g_return_val_if_fail(material != NULL, FALSE);
+
+	if(global->flags & LWO_FLAG_LWO2)
+	{
+		material->a = 1.0 - g3d_read_float_be(global->f);
+		local->nb -= 4;
+	}
+	else
+	{
+		material->a = 1.0 - (gfloat)g3d_read_int16_be(global->f) / 256.0;
+		local->nb -= 2;
+	}
+
+	if(material->a < 0.1)
+		material->a = 0.1;
+
+	return TRUE;
+}
+
+/* vertex mapping */
+gboolean lwo_cb_VMAP(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	LwoObject *obj;
+	guint32 index, type, dim;
+	gchar buffer[512], *tmp;
+
+	obj = (LwoObject *)global->user_data;
+	g_return_val_if_fail(obj != NULL, FALSE);
+
+	tmp = g3d_iff_id_to_text(local->parent_id);
+	g_debug("[LWO][VMAP] parent is %s", tmp);
+	g_free(tmp);
+
+	if(local->parent_id == G3D_IFF_MKID('L','W','O','2'))
+	{
+		type = g3d_read_int32_be(global->f);
+		local->nb -= 4;
+
+		dim = g3d_read_int16_be(global->f);
+		local->nb -= 2;
+
+		local->nb -= lwo_read_string(global->f, buffer);
+
+		if(type == G3D_IFF_MKID('T','X','U','V'))
+		{
+			g_debug("[LWO][VMAP] **TXUV**");
+
+			g_return_val_if_fail(obj->tex_vertices == NULL, FALSE);
+
+			obj->tex_vertices = g_new0(gfloat,
+				obj->object->vertex_count * 2);
+
+			while(local->nb > 0)
+			{
+				local->nb -= lwo_read_vx(global->f, &index);
+				g_return_val_if_fail(index < obj->object->vertex_count, FALSE);
+
+				obj->tex_vertices[index * 2 + 0] =
+					g3d_read_float_be(global->f);
+				obj->tex_vertices[index * 2 + 1] =
+					1.0 - g3d_read_float_be(global->f);
+				local->nb -= 8;
+			}
+		}
+		else
+		{
+			tmp = g3d_iff_id_to_text(type);
+			g_warning("[LWO][VMAP] unhandled vertex mapping %s", tmp);
+			g_free(tmp);
+		}
+	}
+
+	return TRUE;
+}

Added: trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_lwo_callbacks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,18 @@
+#ifndef _IMP_LWO_CALLBACKS_H
+#define _IMP_LWO_CALLBACKS_H
+
+gboolean lwo_cb_CLIP(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_COLR(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_IMAG(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_PNTS(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_POLS(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_PTAG(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_SPEC(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_SRFS(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_STIL(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_SURF(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_TAGS(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_TRAN(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean lwo_cb_VMAP(g3d_iff_gdata *global, g3d_iff_ldata *local);
+
+#endif

Added: trunk/libs3d/libg3d/plugins/import/imp_lwo_chunks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_lwo_chunks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_lwo_chunks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,98 @@
+#ifndef _IMP_LWO_CHUNKS_H
+#define _IMP_LWO_CHUNKS_H
+
+#include <g3d/iff.h>
+
+#include "imp_lwo_callbacks.h"
+
+static g3d_iff_chunk_info lwo_chunks[] = {
+	{ "AAST", "antialiasing strength",       0, NULL },
+	{ "ALPH", "alpha mode",                  0, NULL },
+	{ "AXIS", "major axis",                  0, NULL },
+	{ "BBOX", "bounding box",                0, NULL },
+	{ "BLOK", "block",                       1, NULL },
+	{ "BTEX", "unknown",                     0, NULL },
+	{ "BUMP", "bump intensity",              0, NULL },
+	{ "CLIP", "image or image sequence",     1, lwo_cb_CLIP },
+	{ "CLRF", "color filter",                0, NULL },
+	{ "CLRH", "color highlights",            0, NULL },
+	{ "CMNT", "unknown",                     0, NULL },
+	{ "COLR", "color",                       0, lwo_cb_COLR },
+	{ "CTEX", "unknown",                     0, NULL },
+	{ "DESC", "description",                 0, NULL },
+	{ "DIFF", "diffuse",                     0, NULL },
+	{ "DTEX", "unknown",                     0, NULL },
+	{ "FKEY", "gradient key values",         0, NULL },
+	{ "FLAG", "flags",                       0, NULL },
+	{ "FUNC", "algorithm and parameters",    0, NULL },
+	{ "GLOS", "specular glossiness",         0, NULL },
+	{ "GRAD", "gradient texture (header)",   0, NULL },
+	{ "GREN", "gradient end",                0, NULL },
+	{ "GRPT", "gradient repeat mode",        0, NULL },
+	{ "GRST", "gradient start",              0, NULL },
+	{ "ICON", "icon",                        0, NULL },
+	{ "IKEY", "gradient key parameters",     0, NULL },
+	{ "IMAG", "image index",                 0, lwo_cb_IMAG },
+	{ "IMAP", "image map (header)",          0, NULL },
+	{ "INAM", "item name",                   0, NULL },
+	{ "LAYR", "layer",                       0, NULL },
+	{ "LTEX", "unknown",                     0, NULL },
+	{ "LUMI", "luminosity",                  0, NULL },
+	{ "PIXB", "pixel blending",              0, NULL },
+	{ "PNAM", "parameter name",              0, NULL },
+	{ "PNTS", "points",                      0, lwo_cb_PNTS },
+	{ "POLS", "polygons",                    0, lwo_cb_POLS },
+	{ "PROC", "procedural texture (header)", 0, NULL },
+	{ "PROJ", "projection mode",             0, NULL },
+	{ "PTAG", "polygon tag mapping",         0, lwo_cb_PTAG },
+	{ "REFL", "reflection",                  0, NULL },
+	{ "RFLT", "unknown",                     0, NULL },
+	{ "RFOP", "reflection options",          0, NULL },
+	{ "RIMG", "reflection map image",        0, NULL },
+	{ "RIND", "refractive index",            0, NULL },
+	{ "RSAN", "reflection map seam angle",   0, NULL },
+	{ "SIDE", "polygon sidedness",           0, NULL },
+	{ "SMAN", "max smooting angle",          0, NULL },
+	{ "SPEC", "specular",                    0, lwo_cb_SPEC },
+	{ "SRFS", "surface materials",           0, lwo_cb_SRFS },
+	{ "STEX", "unknown",                     0, NULL },
+	{ "STIL", "still image",                 0, lwo_cb_STIL },
+	{ "SURF", "surface material",            1, lwo_cb_SURF },
+	{ "TAAS", "unknown",                     0, NULL },
+	{ "TAGS", "tags",                        0, lwo_cb_TAGS },
+	{ "TAMP", "texture amplitude",           0, NULL },
+	{ "TCLR", "unknown",                     0, NULL },
+	{ "TCTR", "unknown",                     0, NULL },
+	{ "TEXT", "commentary text",             0, NULL },
+	{ "TFAL", "unknown",                     0, NULL },
+	{ "TFLG", "unknown",                     0, NULL },
+	{ "TFP0", "unknown",                     0, NULL },
+	{ "TFP1", "unknown",                     0, NULL },
+	{ "TFP2", "unknown",                     0, NULL },
+	{ "TFP3", "unknown",                     0, NULL },
+	{ "TFRQ", "unknown",                     0, NULL },
+	{ "TIMG", "refraction map image",        0, NULL },
+	{ "TIP0", "unknown",                     0, NULL },
+	{ "TMAP", "texture map",                 0, NULL },
+	{ "TRAN", "transparency",                0, lwo_cb_TRAN },
+	{ "TRNL", "translucency",                0, NULL },
+	{ "TROP", "transparency options",        0, NULL },
+	{ "TSIZ", "unknown",                     0, NULL },
+	{ "TSP0", "unknown",                     0, NULL },
+	{ "TTEX", "unknown",                     0, NULL },
+	{ "TVAL", "unknown",                     0, NULL },
+	{ "VALU", "basic value",                 0, NULL },
+	{ "VDIF", "unknown",                     0, NULL },
+	{ "VMAD", "discontinuous vertex map",    0, NULL },
+	{ "VMAP", "uv vertex map",               0, lwo_cb_VMAP },
+	{ "VRFL", "unknown",                     0, NULL },
+	{ "VSPC", "unknown",                     0, NULL },
+	{ "VTRN", "unknown",                     0, NULL },
+	{ "WRAP", "image wrap options",          0, NULL },
+	{ "WRPH", "wrap amount (width)",         0, NULL },
+	{ "WRPW", "wrap amount (height)",        0, NULL },
+
+	{ NULL, NULL, 0, NULL }
+};
+
+#endif /* _IMP_LWO_CHUNKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_maya.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,77 @@
+/* $Id: imp_iob.c,v 1.1.2.2 2006/01/23 17:03:06 dahms Exp $ */
+
+/*
+    libg3d - 3D object loading library
+
+    Copyright (C) 2005, 2006  Markus Dahms <mad at automagically.de>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <stdio.h>
+#include <string.h>
+
+#include <glib.h>
+
+#include <g3d/iff.h>
+
+#include "imp_maya_chunks.h"
+
+gboolean plugin_load_model(G3DContext *context, const gchar *filename,
+	G3DModel *model, gpointer user_data)
+{
+	g3d_iff_gdata *global;
+	g3d_iff_ldata *local;
+	guint32 id, len;
+	FILE *f;
+
+	f = g3d_iff_open(filename, &id, &len);
+	if(id != G3D_IFF_MKID('M','a','y','a'))
+	{
+		g_warning("file is not an Maya file %s", filename);
+		if(f) fclose(f);
+		return FALSE;
+	}
+
+	local = g_new0(g3d_iff_ldata, 1);
+	global = g_new0(g3d_iff_gdata, 1);
+
+	global->context = context;
+	global->model = model;
+	global->f = f;
+
+	local->parent_id = id;
+	local->nb = len;
+
+	g3d_iff_read_ctnr(global, local, maya_chunks, G3D_IFF_PAD4);
+
+	g_free(local);
+	g_free(global);
+
+	return TRUE;
+}
+
+gchar *plugin_description(void)
+{
+	return g_strdup(
+		"import plugin for Maya files\n");
+}
+
+gchar **plugin_extensions(void)
+{
+	return g_strsplit("mb", ":", 0);
+}
+
+

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,494 @@
+#include <string.h>
+
+#include <g3d/iff.h>
+#include <g3d/model.h>
+#include <g3d/material.h>
+#include <g3d/primitive.h>
+#include <g3d/read.h>
+#include <g3d/matrix.h>
+
+#include "imp_maya_obj.h"
+#include "imp_maya_var.h"
+
+/* compound? */
+gboolean maya_cb_CMPD(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gint32 flags, i;
+	gdouble *val;
+	gchar *var;
+	gchar *padding = "                    ";
+
+	if(local->nb < 26)
+	{
+		g_warning("[Maya][CMPD] size: %d", local->nb);
+		return FALSE;
+	}
+
+	/* var */
+	var = g_new0(gchar, local->nb - 25);
+	fread(var, 1, local->nb - 25, global->f);
+	local->nb -= (local->nb - 25);
+
+	/* flags ? */
+	flags = g3d_read_int8(global->f);
+	local->nb -= 1;
+
+	val = g_new0(gdouble, 3);
+
+	for(i = 0; i < 3; i ++)
+	{
+		val[i] = g3d_read_double_be(global->f);
+		local->nb -= 8;
+	}
+
+	g_debug("%s[Maya][CMPD] %s = [%g %g %g]",
+		padding + (strlen(padding) - local->level) + 1,
+		var,
+		val[0], val[1], val[2]);
+
+	g_free(val);
+	g_free(var);
+
+	return TRUE;
+}
+
+/* creator */
+gboolean maya_cb_CREA(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	MayaObject *obj;
+	gint32 max_len, flags;
+	gchar *buffer, *name;
+	gchar *padding = "                    ";
+
+	/* flags ? */
+	flags = g3d_read_int8(global->f);
+	local->nb -= 1;
+
+	max_len = local->nb;
+	buffer = g_malloc(max_len + 1);
+
+	/* object name */
+	local->nb -= g3d_read_cstr(global->f, buffer, max_len);
+	name = g_strdup(buffer);
+
+	obj = (MayaObject *)local->object;
+	if(obj)
+		obj->name = g_strdup(buffer);
+
+	/* parent name */
+	if(local->nb > 0)
+		local->nb -= g3d_read_cstr(global->f, buffer, max_len);
+	else
+		*buffer = '\0';
+
+	if(obj && *buffer)
+		obj->parent = g_strdup(buffer);
+
+	g_debug("%s[Maya][CREA] %s (%s)",
+		padding + (strlen(padding) - local->level) + 1,
+		name, *buffer ? buffer : "none");
+
+	g_free(buffer);
+	g_free(name);
+
+	return TRUE;
+}
+
+/* double # */
+gboolean maya_cb_DBLn(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gint32 len, flags, ndbl, i;
+	gdouble *val;
+	gchar *var;
+	gchar *padding = "                         ";
+
+	len = local->nb - 9;
+	var = g_malloc(len);
+	fread(var, 1, len, global->f);
+	local->nb -= len;
+
+	flags = g3d_read_int8(global->f);
+	local->nb -= 1;
+
+	ndbl = local->nb / 8;
+	val = g_new0(gdouble, ndbl);
+	for(i = 0; i < ndbl; i ++)
+	{
+		val[i] = g3d_read_double_be(global->f);
+		local->nb -= 8;
+	}
+
+	g_debug("%s[Maya][DBL#] %s (%d doubles) (0x%02X)",
+		padding + (strlen(padding) - local->level) + 1,
+		var, ndbl, flags);
+
+	if(local->object)
+		maya_var_set((MayaObject *)local->object, var, val);
+	else
+		g_free(val);
+
+	g_free(var);
+
+	return TRUE;
+}
+
+/* double 2 */
+gboolean maya_cb_DBL2(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gint32 len, flags;
+	gdouble *val;
+	gchar *var;
+	gchar *padding = "                         ";
+
+	len = local->nb - 17;
+	var = g_malloc(len);
+	fread(var, 1, len, global->f);
+	local->nb -= len;
+
+	flags = g3d_read_int8(global->f);
+	local->nb -= 1;
+
+	val = g_new0(gdouble, 2);
+	val[0] = g3d_read_double_be(global->f);
+	val[1] = g3d_read_double_be(global->f);
+	local->nb -= 16;
+
+	g_debug("%s[Maya][DBL2] %s = (%g,%g) (0x%02X)",
+		padding + (strlen(padding) - local->level) + 1,
+		var, val[0], val[1], flags);
+
+	if(local->object)
+		maya_var_set((MayaObject *)local->object, var, val);
+	else
+		g_free(val);
+
+	g_free(var);
+
+	return TRUE;
+}
+
+/* double 3 */
+gboolean maya_cb_DBL3(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gint32 len, flags;
+	gdouble *val;
+	gchar *var;
+	gchar *padding = "                         ";
+
+	len = local->nb - 25;
+	var = g_malloc(len);
+	fread(var, 1, len, global->f);
+	local->nb -= len;
+
+	flags = g3d_read_int8(global->f);
+	local->nb -= 1;
+
+	val = g_new0(gdouble, 3);
+	val[0] = g3d_read_double_be(global->f);
+	val[1] = g3d_read_double_be(global->f);
+	val[2] = g3d_read_double_be(global->f);
+	local->nb -= 24;
+
+	g_debug("%s[Maya][DBL3] %s = (%g,%g,%g) (0x%02X)",
+		padding + (strlen(padding) - local->level) + 1,
+		var, val[0], val[1], val[2], flags);
+
+	if(local->object)
+		maya_var_set((MayaObject *)local->object, var, val);
+	else
+		g_free(val);
+
+	g_free(var);
+
+	return TRUE;
+}
+
+/* double */
+gboolean maya_cb_DBLE(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gint32 len, flags;
+	gdouble val;
+	gchar *var;
+	gchar *padding = "                         ";
+
+	len = local->nb - 9;
+	if(len <= 0)
+	{
+		g_warning("[Maya][DBLE] length of chunk: %d", local->nb);
+		return FALSE;
+	}
+
+	var = g_malloc(len);
+	fread(var, 1, len, global->f);
+	local->nb -= len;
+
+	flags = g3d_read_int8(global->f);
+	local->nb -= 1;
+
+	val = g3d_read_double_be(global->f);
+	local->nb -= 8;
+
+	g_debug("%s[Maya][DBLE] %s = %g (0x%02X)",
+		padding + (strlen(padding) - local->level) + 1,
+		var, val, flags);
+
+	if(local->object)
+		maya_var_set_double((MayaObject *)local->object, var, val);
+
+	g_free(var);
+
+	return TRUE;
+}
+
+/* mesh object */
+gboolean maya_cb_DMSH(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	MayaObject *obj;
+	G3DObject *object;
+	G3DMaterial *material;
+
+	if(local->finalize)
+	{
+		obj = (MayaObject *)local->object;
+
+		object = (G3DObject *)obj->user_data;
+		object->name = obj->name ? g_strdup(obj->name) : "(unnamed mesh)";
+
+		maya_obj_add_to_tree(obj, global->model, object);
+		maya_obj_free(obj);
+	}
+	else
+	{
+		obj = maya_obj_new();
+		local->object = obj;
+
+		material = g3d_material_new();
+		material->name = g_strdup("(default material)");
+
+		object = g_new0(G3DObject, 1);
+		object->materials = g_slist_append(object->materials, material);
+
+		obj->user_data = object;
+	}
+
+	return TRUE;
+}
+
+/* float 3 */
+gboolean maya_cb_FLT3(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gint32 len, flags;
+	gfloat *val;
+	gchar *var;
+	gchar *padding = "                         ";
+
+	len = local->nb - 13;
+	var = g_malloc(len);
+	fread(var, 1, len, global->f);
+	local->nb -= len;
+
+	flags = g3d_read_int8(global->f);
+	local->nb -= 1;
+
+	val = g_new0(gfloat, 3);
+	val[0] = g3d_read_float_be(global->f);
+	val[1] = g3d_read_float_be(global->f);
+	val[2] = g3d_read_float_be(global->f);
+	local->nb -= 12;
+
+	g_debug("%s[Maya][DBL3] %s = (%g; %g; %g) (0x%02X)",
+		padding + (strlen(padding) - local->level) + 1,
+		var, val[0], val[1], val[2], flags);
+
+	if(local->object)
+		maya_var_set((MayaObject *)local->object, var, val);
+	else
+		g_free(val);
+
+	g_free(var);
+
+	return TRUE;
+}
+
+/* mesh */
+gboolean maya_cb_MESH(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	G3DObject *object;
+	G3DMaterial *material;
+	G3DFace *face;
+	gint32 x1, x2, x3, x4, i, i1, i2;
+
+	x1 = g3d_read_int16_be(global->f);
+	x2 = g3d_read_int16_be(global->f);
+	x3 = g3d_read_int16_be(global->f);
+	x4 = g3d_read_int16_be(global->f);
+	local->nb -= 8;
+
+	object = (G3DObject *)((MayaObject *)local->object)->user_data;
+	material = (G3DMaterial *)g_slist_nth_data(object->materials, 0);
+
+	if(x1 == 0x6369)
+	{
+		object->vertex_count = x4 / 3;
+		object->vertex_data = g_new0(gfloat, object->vertex_count * 3);
+
+		for(i = 0; i < object->vertex_count; i ++)
+		{
+			object->vertex_data[i * 3 + 0] = g3d_read_float_be(global->f);
+			object->vertex_data[i * 3 + 1] = g3d_read_float_be(global->f);
+			object->vertex_data[i * 3 + 2] = g3d_read_float_be(global->f);
+			local->nb -= 12;
+		}
+
+		x3 = g3d_read_int16_be(global->f);
+		x4 = g3d_read_int16_be(global->f);
+		local->nb -= 4;
+#if 0
+		g_debug("[Maya][MESH] %d %d", x3, x4);
+#endif
+		i1 = -1;
+		i2 = -1;
+		for(i = 0; i < x4 / 2; i ++)
+		{
+			if(i1 == -1)
+			{
+				i1 = g3d_read_int32_be(global->f) & 0xFFFFFF;
+				i2 = g3d_read_int32_be(global->f) & 0xFFFFFF;
+				local->nb -= 8;
+			}
+			else
+			{
+				face = g_new0(G3DFace, 1);
+				face->vertex_count = 4;
+				face->vertex_indices = g_new0(guint32, 4);
+				face->vertex_indices[0] = i1;
+				face->vertex_indices[1] = i2;
+				face->vertex_indices[2] =
+					g3d_read_int32_be(global->f) & 0xFFFFFF;
+				face->vertex_indices[3] =
+					g3d_read_int32_be(global->f) & 0xFFFFFF;
+				face->material = material;
+				local->nb -= 8;
+				i1 = face->vertex_indices[3];
+				i2 = face->vertex_indices[2];
+
+				object->faces = g_slist_append(object->faces, face);
+			}
+		}
+
+		x3 = g3d_read_int16_be(global->f);
+		x4 = g3d_read_int16_be(global->f);
+		local->nb -= 4;
+	}
+	return TRUE;
+}
+
+/* poly cube */
+gboolean maya_cb_PCUB(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	MayaObject *obj;
+	G3DObject *object;
+	G3DMaterial *material;
+	gdouble w, h, d;
+
+	if(local->finalize)
+	{
+		obj = (MayaObject *)local->object;
+		g_return_val_if_fail(obj != NULL, FALSE);
+
+		w = maya_var_get_double(obj, "sw", 1.0);
+		h = maya_var_get_double(obj, "sh", 1.0);
+		d = maya_var_get_double(obj, "sd", 1.0);
+
+		material = g3d_material_new();
+		object = g3d_primitive_cube(w, h, d, material);
+		object->name = obj->name ? g_strdup(obj->name) : "(unnamed cube)";
+
+		object->materials = g_slist_append(object->materials, material);
+		maya_obj_add_to_tree(obj, global->model, object);
+
+		/* destroy object */
+		maya_obj_free(obj);
+	}
+	else
+	{
+		/* create object */
+		obj = maya_obj_new();
+		local->object = obj;
+	}
+
+	return TRUE;
+}
+
+/* string */
+gboolean maya_cb_STR_(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gchar *buffer, *var;
+	gchar *padding = "                       ";
+
+	/* variable */
+	buffer = g_malloc(local->nb);
+	local->nb -= g3d_read_cstr(global->f, buffer, local->nb);
+	var = g_strdup(buffer);
+
+	/* value */
+	local->nb -= g3d_read_cstr(global->f, buffer, local->nb);
+
+	g_debug("%s[Maya][STR ] %s = '%.*s' (%d characters)",
+		padding + (strlen(padding) - local->level) + 1,
+		var, 40, buffer, strlen(buffer));
+
+	if(local->object)
+		maya_var_set((MayaObject *)local->object, var, g_strdup(buffer));
+
+	g_free(buffer);
+	g_free(var);
+
+	return TRUE;
+}
+
+/* transformation */
+gboolean maya_cb_XFRM(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	MayaObject *obj;
+	G3DObject *object;
+	G3DTransformation *tf;
+	gdouble *val;
+
+	if(local->finalize)
+	{
+		obj = (MayaObject *)local->object;
+
+		object = maya_obj_to_g3d(obj);
+
+		tf = g_new0(G3DTransformation, 1);
+		g3d_matrix_identity(tf->matrix);
+
+		val = maya_var_get(obj, "t");
+		if(val)
+			g3d_matrix_translate(val[0], val[1], val[2], tf->matrix);
+
+		val = maya_var_get(obj, "r");
+		if(val)
+			g3d_matrix_rotate_xyz(val[0], val[1], val[2], tf->matrix);
+
+		val = maya_var_get(obj, "s");
+		if(val)
+			g3d_matrix_scale(val[0], val[1], val[2], tf->matrix);
+
+		/* g3d_matrix_dump(tf->matrix); */
+
+		object->transformation = tf;
+
+		maya_obj_add_to_tree(obj, global->model, object);
+
+		maya_obj_free(obj);
+	}
+	else
+	{
+		obj = maya_obj_new();
+		local->object = obj;
+	}
+
+	return TRUE;
+}

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_callbacks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,19 @@
+#ifndef _IMP_MAYA_CALLBACKS_H
+#define _IMP_MAYA_CALLBACKS_H
+
+#include <g3d/iff.h>
+
+gboolean maya_cb_CMPD(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_CREA(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_DBLn(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_DBL2(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_DBL3(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_DBLE(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_DMSH(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_FLT3(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_MESH(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_PCUB(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_STR_(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean maya_cb_XFRM(g3d_iff_gdata *global, g3d_iff_ldata *local);
+
+#endif /* _IMP_MAYA_CALLBACKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_chunks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_chunks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_chunks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,109 @@
+#ifndef _IMP_MAYA_CHUNKS_H
+#define _IMP_MAYA_CHUNKS_H
+
+#include <g3d/iff.h>
+
+#include "imp_maya_callbacks.h"
+
+static g3d_iff_chunk_info maya_chunks[] = {
+	{ "ATTR", "unknown",                           0, NULL },
+	{ "AUDI", "audio",                             1, NULL }, /* FOR4 */
+	{ "AUNI", "angle unit",                        0, NULL },
+	{ "BRSH", "brush",                             1, NULL }, /* FOR4 */
+	{ "CHNG", "changes",                           0, NULL },
+	{ "CMP#", "unknown",                           0, NULL },
+	{ "CMPD", "compound",                          0, maya_cb_CMPD },
+	{ "CONN", "unknown",                           1, NULL }, /* FOR4 */
+	{ "CONS", "unknown",                           1, NULL }, /* LIS4 */
+	{ "CWFL", "unknown",                           0, NULL },
+	{ "CREA", "creator",                           0, maya_cb_CREA },
+	{ "DBL#", "double #",                          0, maya_cb_DBLn },
+	{ "DBL2", "double 2",                          0, maya_cb_DBL2 },
+	{ "DBL3", "double 3",                          0, maya_cb_DBL3 },
+	{ "DBLE", "double",                            0, maya_cb_DBLE },
+	{ "DCAM", "camera",                            1, NULL }, /* FOR4 */
+	{ "DECT", "delete component",                  1, NULL }, /* FOR4 */
+	{ "DELA", "unknown",                           1, NULL }, /* FOR4 */
+	{ "DELL", "unknown",                           1, NULL }, /* LIS4 */
+	{ "DISC", "unknown",                           0, NULL },
+	{ "DISL", "unknown",                           1, NULL }, /* LIS4 */
+	{ "DMSH", "mesh",                              1, maya_cb_DMSH },
+	{ "DMTI", "material info",                     1, NULL }, /* FOR4 */
+	{ "DPLM", "layer manager",                     1, NULL }, /* FOR4 */
+	{ "DSPL", "layer ?",                           1, NULL }, /* FOR4 */
+	{ "FINF", "file information",                  0, maya_cb_STR_ },
+	{ "FDFL", "flare ?",                           1, NULL }, /* FOR4 */
+	{ "FLGS", "flags",                             0, NULL },
+	{ "FLT2", "float 2",                           0, NULL },
+	{ "FLT3", "float 3",                           0, maya_cb_FLT3 },
+	{ "FMPT", "unknown",                           1, NULL }, /* FOR4 */
+	{ "FNLD", "unknown",                           1, NULL }, /* FOR4 */
+	{ "GPID", "group id",                          1, NULL }, /* FOR4 */
+	{ "GRPP", "group parts",                       1, NULL }, /* FOR4 */
+	{ "HEAD", "header",                            1, NULL }, /* FOR4 */
+	{ "ICON", "icon",                              0, NULL },
+	{ "INCL", "includes",                          0, NULL },
+	{ "INFO", "information",                       0, NULL },
+	{ "LUNI", "length unit",                       0, NULL },
+	{ "MADE", "creation date",                     0, NULL },
+	{ "MATR", "unknown",                           0, NULL },
+	{ "MESH", "mesh",                              0, maya_cb_MESH },
+	{ "NPLN", "unknown",                           0, NULL },
+	{ "NRBS", "NURBS ?",                           0, NULL },
+	{ "NSRF", "surface",                           1, NULL }, /* FOR4 */
+	{ "OBJN", "unknown",                           0, NULL },
+	{ "OBST", "unknown",                           1, NULL }, /* FOR4 */
+	{ "PAUP", "poly auto proj",                    1, NULL }, /* FOR4 */
+	{ "PBOP", "poly boolean operation",            1, NULL }, /* FOR4 */
+	{ "PBVL", "poly bevel",                        1, NULL }, /* FOR4 */
+	{ "PCRE", "poly create face",                  1, NULL }, /* FOR4 */
+	{ "PCTA", "poly rotate ?",                     1, NULL }, /* FOR4 */
+	{ "PCTL", "poly translate ?",                  1, NULL }, /* FOR4 */
+	{ "PCTU", "poly scale ?",                      1, NULL }, /* FOR4 */
+	{ "PCUB", "poly cube",                         1, maya_cb_PCUB },
+	{ "PCYL", "poly cylinder",                     1, NULL }, /* FOR4 */
+	{ "PEXE", "poly extrude",                      1, NULL }, /* FOR4 */
+	{ "PEXF", "poly extrude face",                 1, NULL }, /* FOR4 */
+	{ "PFUV", "poly flip UV",                      1, NULL }, /* FOR4 */
+	{ "PING", "unknown",                           1, NULL }, /* FOR4 */
+	{ "PLUG", "plugin ?",                          0, NULL },
+	{ "PMIR", "poly mirror",                       1, NULL }, /* FOR4 */
+	{ "PMVE", "poly merge vertices",               1, NULL }, /* FOR4 */
+	{ "PPCT", "poly cut",                          1, NULL }, /* FOR4 */
+	{ "PPIP", "poly pipe",                         1, NULL }, /* FOR4 */
+	{ "PRNS", "unknown",                           0, NULL },
+	{ "PRNT", "unknown",                           0, NULL },
+	{ "PSEP", "poly separate",                     1, NULL }, /* FOR4 */
+	{ "PSMF", "poly smooth face",                  1, NULL }, /* FOR4 */
+	{ "PSOE", "poly soft edge",                    1, NULL }, /* FOR4 */
+	{ "PSPH", "poly sphere",                       1, NULL }, /* FOR4 */
+	{ "PSPL", "poly split",                        1, NULL }, /* FOR4 */
+	{ "PTRI", "poly triangulate",                  1, NULL }, /* FOR4 */
+	{ "PTUV", "poly tweak UV",                     1, NULL }, /* FOR4 */
+	{ "PTWK", "poly tweak",                        1, NULL }, /* FOR4 */
+	{ "PUNI", "poly unite",                        1, NULL }, /* FOR4 */
+	{ "RANI", "anisotropic",                       1, NULL }, /* FOR4 */
+	{ "RBLN", "unknown",                           1, NULL }, /* FOR4 */
+	{ "RLAM", "lambert",                           1, NULL }, /* FOR4 */
+	{ "RLLK", "light linker",                      1, NULL }, /* FOR4 */
+	{ "RNDL", "render layer",                      1, NULL }, /* FOR4 */
+	{ "RNLM", "render layer manager",              1, NULL }, /* FOR4 */
+	{ "RPHO", "phong ?",                           1, NULL }, /* FOR4 */
+	{ "RPL2", "place texture",                     1, NULL }, /* FOR4 */
+	{ "RPLD", "place texture",                     1, NULL }, /* FOR4 */
+	{ "RPRJ", "projection",                        1, NULL }, /* FOR4 */
+	{ "RTFT", "texture file",                      1, NULL }, /* FOR4 */
+	{ "SCRP", "script",                            1, NULL }, /* FOR4 */
+	{ "SHAD", "shadow",                            1, NULL }, /* FOR4 */
+	{ "SLCT", "unknown",                           0, NULL }, /* evil ;) */
+	{ "STR ", "string",                            0, maya_cb_STR_ },
+	{ "TGEO", "transform geometry",                1, NULL }, /* FOR4 */
+	{ "TUNI", "time unit",                         0, NULL },
+	{ "UVER", "minor version?",                    0, NULL },
+	{ "VERS", "version",                           0, NULL },
+	{ "XFRM", "transformation",                    1, maya_cb_XFRM },
+
+	{ NULL, NULL, 0, NULL }
+};
+
+#endif /* _IMP_MAYA_CHUNKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_obj.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_obj.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_obj.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,89 @@
+#include <string.h>
+
+#include <g3d/model.h>
+
+#include "imp_maya_obj.h"
+
+MayaObject *maya_obj_new(void)
+{
+	MayaObject *obj;
+
+	obj = g_new0(MayaObject, 1);
+	obj->vars = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+
+	return obj;
+}
+
+void maya_obj_free(MayaObject *obj)
+{
+	g_hash_table_destroy(obj->vars);
+	if(obj->name) g_free(obj->name);
+	g_free(obj);
+}
+
+G3DObject *maya_obj_to_g3d(MayaObject *obj)
+{
+	G3DObject *object;
+
+	object = g_new0(G3DObject, 1);
+	object->name = obj->name ? g_strdup(obj->name) : "(unnamed)";
+
+	return object;
+}
+
+static G3DObject *get_by_path(G3DModel *model, gchar *path)
+{
+	gchar **parts, **partp;
+	G3DObject *object = NULL;
+	GSList *olist;
+
+	partp = parts = g_strsplit(path, "|", 0);
+	olist = model->objects;
+	while(*partp)
+	{
+		while(olist)
+		{
+			object = (G3DObject *)olist->data;
+
+			if(strcmp(object->name, *partp) == 0) break;
+
+			olist = olist->next;
+			object = NULL;
+		}
+
+		if(object == NULL) return NULL;
+
+		partp ++;
+		olist = object->objects;
+	}
+
+	g_strfreev(parts);
+
+	return object;
+}
+
+gboolean maya_obj_add_to_tree(MayaObject *obj, G3DModel *model,
+	G3DObject *object)
+{
+	G3DObject *parent = NULL;
+
+	if(obj->parent)
+	{
+		if(*(obj->parent) == '|')
+			parent = get_by_path(model, obj->parent + 1);
+		else
+			parent = g3d_model_get_object_by_name(model, obj->parent);
+
+		if(parent == NULL)
+			g_warning(
+				"[Maya] maya_obj_add_to_tree: parent object '%s' not found",
+				obj->parent);
+	}
+
+	if(parent != NULL)
+		parent->objects = g_slist_append(parent->objects, object);
+	else
+		model->objects = g_slist_append(model->objects, object);
+
+	return TRUE;
+}

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_obj.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_obj.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_obj.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,20 @@
+#ifndef _IMP_MAYA_OBJ_H
+#define _IMP_MAYA_OBJ_H
+
+#include <glib.h>
+#include <g3d/types.h>
+
+typedef struct {
+	gchar *name;
+	gchar *parent;
+	GHashTable *vars;
+	gpointer user_data;
+} MayaObject;
+
+MayaObject *maya_obj_new(void);
+void maya_obj_free(MayaObject *obj);
+G3DObject *maya_obj_to_g3d(MayaObject *obj);
+gboolean maya_obj_add_to_tree(MayaObject *obj, G3DModel *model,
+	G3DObject *object);
+
+#endif /* _IMP_MAYA_OBJ_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_var.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_var.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_var.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,39 @@
+#include <glib.h>
+
+#include "imp_maya_obj.h"
+
+gboolean maya_var_set(MayaObject *obj, const gchar *var, gpointer value)
+{
+	g_hash_table_replace(obj->vars, g_strdup(var), value);
+
+	return TRUE;
+}
+
+gpointer maya_var_get(MayaObject *obj, const gchar *var)
+{
+	gpointer val;
+
+	val = g_hash_table_lookup(obj->vars, var);
+	return val;
+}
+
+gboolean maya_var_set_double(MayaObject *obj, const gchar *var, gdouble value)
+{
+	gdouble *pval;
+
+	pval = g_new0(gdouble, 1);
+	*pval = value;
+
+	return maya_var_set(obj, var, pval);
+}
+
+gdouble maya_var_get_double(MayaObject *obj, const gchar *var, gdouble defval)
+{
+	gdouble *pval;
+
+	pval = maya_var_get(obj, var);
+	if(pval == NULL)
+		return defval;
+
+	return *pval;
+}

Added: trunk/libs3d/libg3d/plugins/import/imp_maya_var.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_maya_var.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_maya_var.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,12 @@
+#ifndef _IMP_MAYA_VAR_H
+#define _IMP_MAYA_VAR_H
+
+#include "imp_maya_obj.h"
+
+gboolean maya_var_set(MayaObject *obj, const gchar *var, gpointer value);
+gpointer maya_var_get(MayaObject *obj, const gchar *var);
+
+gboolean maya_var_set_double(MayaObject *obj, const gchar *var, gdouble value);
+gdouble maya_var_get_double(MayaObject *obj, const gchar *var, gdouble defval);
+
+#endif /* _IMP_MAYA_VAR_H */

Modified: trunk/libs3d/libg3d/plugins/import/imp_obj.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_obj.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_obj.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -31,6 +31,7 @@
 
 static G3DObject *obj_createobject(G3DModel *model, const gchar *name);
 static gboolean obj_tryloadmat(G3DModel *model, const gchar *filename);
+static G3DMaterial *obj_usemat(G3DModel *model, const gchar *matname);
 
 gboolean plugin_load_model(G3DContext *context, const gchar *filename,
 	G3DModel *model, gpointer user_data)
@@ -75,6 +76,7 @@
 					}
 					else if(sscanf(line, "g %s", oname) == 1)
 					{
+						material = obj_usemat(model, oname);
 #if 0
 						object = obj_createobject(model, oname);
 						v_off += v_cnt;
@@ -158,18 +160,7 @@
 				case 's':
 					if(sscanf(line, "usemtl %s", matname) == 1)
 					{
-						/* sets new active material from named list */
-						GSList *mlist = model->materials;
-						while(mlist != NULL)
-						{
-							G3DMaterial *mat = (G3DMaterial*)mlist->data;
-							if(strcmp(matname, mat->name) == 0)
-							{
-								material = mat;
-								break;
-							}
-							mlist = mlist->next;
-						}
+						material = obj_usemat(model, matname);
 					}
 					else if(sscanf(line, "mtllib %s", matfile) == 1)
 					{
@@ -227,7 +218,7 @@
 	if(f == NULL)
 	{
 #if DEBUG > 1
-		g_printerr("obj_tryloadmat: loading '%s' failed: %s\n", filename, 
+		g_printerr("obj_tryloadmat: loading '%s' failed: %s\n", filename,
 							 strerror(errno));
 #endif
 		return FALSE;
@@ -240,7 +231,7 @@
 		char line[2048];
 		float r,g,b, t1,t2, ni;
 		int tf, ns, il;
-	 
+
 		fgets(line, 2048, f);
 		if(strlen(line))
 		{
@@ -294,3 +285,21 @@
 	}
 	return TRUE;
 }
+
+G3DMaterial *obj_usemat(G3DModel *model, const gchar *matname)
+{
+	/* sets new active material from named list */
+	GSList *mlist = model->materials;
+	while(mlist != NULL)
+	{
+		G3DMaterial *mat = (G3DMaterial*)mlist->data;
+		if(strcmp(matname, mat->name) == 0)
+		{
+			return mat;
+		}
+		mlist = mlist->next;
+	}
+
+	return NULL;
+}
+

Added: trunk/libs3d/libg3d/plugins/import/imp_r4.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_r4.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_r4.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,77 @@
+/* $Id: imp_iob.c,v 1.1.2.2 2006/01/23 17:03:06 dahms Exp $ */
+
+/*
+    libg3d - 3D object loading library
+
+    Copyright (C) 2005, 2006  Markus Dahms <mad at automagically.de>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <stdio.h>
+#include <string.h>
+
+#include <glib.h>
+
+#include <g3d/iff.h>
+
+#include "imp_r4_chunks.h"
+
+gboolean plugin_load_model(G3DContext *context, const gchar *filename,
+	G3DModel *model, gpointer user_data)
+{
+	g3d_iff_gdata *global;
+	g3d_iff_ldata *local;
+	guint32 id, len;
+	FILE *f;
+
+	f = g3d_iff_open(filename, &id, &len);
+	if(id != G3D_IFF_MKID('R','E','F','L'))
+	{
+		g_warning("file is not an .r4 (REFL) file %s", filename);
+		fclose(f);
+		return FALSE;
+	}
+
+	local = g_new0(g3d_iff_ldata, 1);
+	global = g_new0(g3d_iff_gdata, 1);
+
+	global->context = context;
+	global->model = model;
+	global->f = f;
+
+	local->parent_id = id;
+	local->nb = len;
+
+	g3d_iff_read_ctnr(global, local, r4_chunks, G3D_IFF_PAD1);
+
+	g_free(local);
+	g_free(global);
+
+	return TRUE;
+}
+
+gchar *plugin_description(void)
+{
+	return g_strdup(
+		"import plugin for Reflections R4\n");
+}
+
+gchar **plugin_extensions(void)
+{
+	return g_strsplit("r4", ":", 0);
+}
+
+

Added: trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,49 @@
+#include <g3d/iff.h>
+#include <g3d/read.h>
+
+#include "imp_r4_chunks.h"
+
+/* camera related */
+gboolean r4_cb_RKA2(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	guint32 chunk_id, chunk_len;
+	g3d_iff_ldata *sublocal;
+
+	/* RGE1 chunk */
+	g3d_iff_readchunk(global->f, &chunk_id, &chunk_len, 0);
+	local->nb -= 8;
+
+	sublocal = g_new0(g3d_iff_ldata, 1);
+	sublocal->parent_id = local->id;
+	sublocal->id = chunk_id;
+	sublocal->object = local->object;
+	sublocal->level = local->level + 1;
+	sublocal->nb = chunk_len;
+	g3d_iff_read_ctnr(global, sublocal, r4_chunks, G3D_IFF_PAD1);
+	g_free(sublocal);
+
+	/* more stuff... */
+	/* TODO: */
+
+	return TRUE;
+}
+
+/* object name */
+gboolean r4_cb_ROBJ(g3d_iff_gdata *global, g3d_iff_ldata *local)
+{
+	gchar buffer[512];
+	gint32 len;
+
+	len = g3d_read_int16_be(global->f);
+	local->nb -= 2;
+
+	fread(buffer, 1, len, global->f);
+	local->nb -= len;
+	buffer[len] = '\0';
+
+#if DEBUG > 0
+	g_printerr("[R4] ROBJ: %s\n", buffer);
+#endif
+
+	return TRUE;
+}

Added: trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_r4_callbacks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,9 @@
+#ifndef _G3D_R4_CALLBACKS_H
+#define _G3D_R4_CALLBACKS_H
+
+#include <g3d/iff.h>
+
+gboolean r4_cb_RKA2(g3d_iff_gdata *global, g3d_iff_ldata *local);
+gboolean r4_cb_ROBJ(g3d_iff_gdata *global, g3d_iff_ldata *local);
+
+#endif /* _G3D_R4_CALLBACKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_r4_chunks.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_r4_chunks.h	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_r4_chunks.h	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,25 @@
+#ifndef _IMP_R4_CHUNKS_H
+#define _IMP_R4_CHUNKS_H
+
+#include <g3d/iff.h>
+
+#include "imp_r4_callbacks.h"
+
+static g3d_iff_chunk_info r4_chunks[] = {
+	{ "INFO", "information",                       0, NULL },
+	{ "DRE2", "unknown",                           0, NULL },
+	{ "GMAT", "unknown",                           1, NULL },
+	{ "KSYS", "unknown",                           0, NULL },
+	{ "LGH3", "unknown",                           0, NULL },
+	{ "PKTM", "unknown",                           0, NULL },
+	{ "RGE1", "unknown",                           1, NULL },
+	{ "RKA2", "unknown",                           0, r4_cb_RKA2 },
+	{ "ROBJ", "unknown",                           0, r4_cb_ROBJ },
+	{ "SURF", "unknown",                           0, NULL },
+	{ "TXM1", "unknown",                           1, NULL },
+	{ "TXO1", "unknown",                           0, NULL },
+
+	{ NULL, NULL, 0, NULL }
+};
+
+#endif /* _IMP_R4_CHUNKS_H */

Added: trunk/libs3d/libg3d/plugins/import/imp_test.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_test.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_test.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,91 @@
+/* $Id:$ */
+
+/*
+    libg3d - 3D object loading library
+
+    Copyright (C) 2005, 2006  Markus Dahms <mad at automagically.de>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <g3d/types.h>
+#include <g3d/context.h>
+#include <g3d/material.h>
+#include <g3d/matrix.h>
+#include <g3d/primitive.h>
+#include <g3d/object.h>
+
+/*****************************************************************************/
+/* plugin interface                                                          */
+/*****************************************************************************/
+
+gboolean plugin_load_model(G3DContext *context, const gchar *filename,
+	G3DModel *model, gpointer user_data)
+{
+	G3DObject *sphere, *cntr;
+	G3DMaterial *material;
+	G3DTransformation *tf;
+	gfloat matrix[16];
+	gint32 i, j;
+
+	cntr = g_new0(G3DObject, 1);
+	cntr->name = g_strdup("container");
+
+	tf = g_new0(G3DTransformation, 1);
+	g3d_matrix_identity(tf->matrix);
+	g3d_matrix_scale(1.0, 1.0, 2.0, tf->matrix);
+	cntr->transformation = tf;
+	model->objects = g_slist_append(model->objects, cntr);
+
+	material = g3d_material_new();
+	model->materials = g_slist_append(model->materials, material);
+
+	/* 1 */
+	sphere = g3d_primitive_sphere(1.0, 36, 36, material);
+	cntr->objects = g_slist_append(cntr->objects, sphere);
+
+	/* 2 */
+	sphere = g3d_primitive_sphere(1.0, 6, 6, material);
+	cntr->objects = g_slist_append(cntr->objects, sphere);
+
+	tf = g_new0(G3DTransformation, 1);
+	g3d_matrix_identity(tf->matrix);
+	g3d_matrix_translate(2.5, 1.0, 1.0, tf->matrix);
+	sphere->transformation = tf;
+
+	/* 3 */
+	sphere = g3d_primitive_sphere(1.0, 12, 12, material);
+	cntr->objects = g_slist_append(cntr->objects, sphere);
+
+	g3d_matrix_identity(matrix);
+	g3d_matrix_translate(5, 2.0, 2.0, matrix);
+	g3d_matrix_scale(2.0, 2.0, 1.0, matrix);
+	g3d_object_transform(sphere, matrix);
+
+	return TRUE;
+}
+
+gchar *plugin_description(G3DContext *context)
+{
+	return g_strdup(
+		"Test plugin\n"
+		);
+}
+
+gchar **plugin_extensions(G3DContext *context)
+{
+	return g_strsplit("test", ":", 0);
+}
+

Modified: trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.l
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.l	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.l	2006-09-15 16:23:16 UTC (rev 381)
@@ -309,23 +309,23 @@
 	{
 		if(sscanf(yytext, "%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f",
 			&matrix[0 * 4 + 0],
+			&matrix[0 * 4 + 1],
+			&matrix[0 * 4 + 2],
+			&matrix[0 * 4 + 3],
+
 			&matrix[1 * 4 + 0],
+            &matrix[1 * 4 + 1],
+            &matrix[1 * 4 + 2],
+            &matrix[1 * 4 + 3],
+
 			&matrix[2 * 4 + 0],
+            &matrix[2 * 4 + 1],
+            &matrix[2 * 4 + 2],
+            &matrix[2 * 4 + 3],
+
 			&matrix[3 * 4 + 0],
-
-			&matrix[0 * 4 + 1],
-            &matrix[1 * 4 + 1],
-            &matrix[2 * 4 + 1],
             &matrix[3 * 4 + 1],
-
-			&matrix[0 * 4 + 2],
-            &matrix[1 * 4 + 2],
-            &matrix[2 * 4 + 2],
             &matrix[3 * 4 + 2],
-
-			&matrix[0 * 4 + 3],
-            &matrix[1 * 4 + 3],
-            &matrix[2 * 4 + 3],
             &matrix[3 * 4 + 3]) != 16)
 		{
 			g_warning("VRML: failed to read matrix line (%s)", yytext);

Modified: trunk/libs3d/libg3d/src/iff.c
===================================================================
--- trunk/libs3d/libg3d/src/iff.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/iff.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -20,25 +20,33 @@
     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
 #include <stdio.h>
+#include <string.h>
 #include <g3d/read.h>
 #include <g3d/iff.h>
+#include <g3d/context.h>
 
 FILE *g3d_iff_open(const gchar *filename, guint32 *id, guint32 *len)
 {
 	FILE *f;
-	guint32 form_bytes;
+	guint32 form_bytes, magic;
 
 	f = fopen(filename, "r");
 	if(f == NULL)
 	{
-		g_warning("can't open file '%s'", filename);
+		g_critical("can't open file '%s'", filename);
 		return NULL;
 	}
 
-	if(g3d_read_int32_be(f) != G3D_IFF_MKID('F','O','R','M'))
+	magic = g3d_read_int32_be(f);
+	if((magic != G3D_IFF_MKID('F','O','R','M')) &&
+		(magic != G3D_IFF_MKID('F','O','R','4')))
 	{
-		g_warning("file %s is not an IFF file", filename);
+		g_critical("file %s is not an IFF file", filename);
 		fclose(f);
 		return NULL;
 	}
@@ -51,10 +59,203 @@
 	return f;
 }
 
-int g3d_iff_readchunk(FILE *f, guint32 *id, guint32 *len)
+int g3d_iff_readchunk(FILE *f, guint32 *id, guint32 *len, guint32 flags)
 {
 	*id = g3d_read_int32_be(f);
-	*len = g3d_read_int32_be(f);
-	return 8 + *len + (*len % 2);
+	if(flags & G3D_IFF_LEN16)
+	{
+		*len = g3d_read_int16_be(f);
+		return 6 + *len + (*len % 2);
+	}
+	else
+	{
+		*len = g3d_read_int32_be(f);
+		return 8 + *len + (*len % 2);
+	}
 }
 
+gchar *g3d_iff_id_to_text(guint32 id)
+{
+	gchar *tid;
+
+	tid = g_new0(gchar, 5);
+
+	tid[0] = (id >> 24) & 0xFF;
+	tid[1] = (id >> 16) & 0xFF;
+	tid[2] = (id >> 8) & 0xFF;
+	tid[3] = id & 0xFF;
+
+	return tid;
+}
+
+gboolean g3d_iff_chunk_matches(guint32 id, gchar *tid)
+{
+	if(((id >> 24) & 0xFF) != tid[0]) return FALSE;
+	if(((id >> 16) & 0xFF) != tid[1]) return FALSE;
+	if(((id >> 8) & 0xFF) != tid[2]) return FALSE;
+	return (id & 0xFF) == tid[3];
+}
+
+gboolean g3d_iff_read_ctnr(g3d_iff_gdata *global, g3d_iff_ldata *local,
+	g3d_iff_chunk_info *chunks, guint32 flags)
+{
+	g3d_iff_ldata *sublocal;
+	guint32 chunk_id, chunk_len, chunk_mod, chunk_type;
+	gint32 i;
+	gchar *tid;
+	gpointer level_object;
+	gchar *padding = "                                   ";
+	long int fpos;
+
+	level_object = NULL;
+
+	if(global->max_fpos == 0)
+		global->max_fpos = local->nb + 12;
+
+	while(local->nb >= ((flags & G3D_IFF_LEN16) ? 6 : 8))
+	{
+		chunk_id = 0;
+
+		g3d_iff_readchunk(global->f, &chunk_id, &chunk_len, flags);
+		local->nb -= ((flags & G3D_IFF_LEN16) ? 6 : 8);
+
+		chunk_mod = flags & 0x0F;
+		if(chunk_mod == 0)
+		{
+			g_warning("[IFF] mod = 0 (flags: 0x%02X\n)", flags);
+			chunk_mod = 2;
+		}
+		chunk_type = ' ';
+
+		/* handle special chunks */
+		switch(chunk_id)
+		{
+			case 0:
+			case 0xFFFFFFFF:
+				g_warning(
+					"[IFF] got invalid ID, skipping %d bytes @ 0x%08x",
+					local->nb, (unsigned int)ftell(global->f));
+
+				/* skip rest of parent chunk */
+				if(local->nb > 0)
+				{
+					fseek(global->f, local->nb, SEEK_CUR);
+					local->nb = 0;
+				}
+				return FALSE;
+				break;
+
+			case G3D_IFF_MKID('F','O','R','4'):
+				chunk_id = g3d_read_int32_be(global->f);
+				chunk_len -= 4;
+				chunk_mod = 4;
+				chunk_type = 'F';
+				local->nb -= 4;
+				break;
+
+			case G3D_IFF_MKID('L','I','S','4'):
+				chunk_id = g3d_read_int32_be(global->f);
+				chunk_len -= 4;
+				chunk_mod = 4;
+				chunk_type = 'L';
+				local->nb -= 4;
+				break;
+
+			default:
+				break;
+		}
+
+		i = 0;
+		while(chunks[i].id && !g3d_iff_chunk_matches(chunk_id, chunks[i].id))
+			i ++;
+
+		if(chunks[i].id)
+		{
+			tid = g3d_iff_id_to_text(chunk_id);
+			g_debug("%s[%s][%c%c%c] %s (%d) - %d bytes left",
+				padding + (strlen(padding) - local->level),
+				tid,
+				chunk_type,
+				chunks[i].container ? 'c' : ' ',
+				chunks[i].callback ? 'f' : ' ',
+				chunks[i].description,
+				chunk_len,
+				local->nb);
+			g_free(tid);
+
+			sublocal = g_new0(g3d_iff_ldata, 1);
+			sublocal->parent_id = local->id;
+			sublocal->id = chunk_id;
+			sublocal->object = local->object;
+			sublocal->level = local->level + 1;
+			sublocal->level_object = level_object;
+			sublocal->nb = chunk_len;
+
+			if(chunks[i].callback)
+			{
+				chunks[i].callback(global, sublocal);
+			}
+
+			if(chunks[i].container)
+			{
+				/* LWO has 16 bit length in subchunks */
+				if(flags & G3D_IFF_SUBCHUNK_LEN16)
+				{
+					g3d_iff_read_ctnr(global, sublocal, chunks,
+						flags | G3D_IFF_LEN16);
+				}
+				else
+				{
+					g3d_iff_read_ctnr(global, sublocal, chunks, flags);
+				}
+			}
+
+			if(chunks[i].container && chunks[i].callback)
+			{
+				sublocal->finalize = TRUE;
+				chunks[i].callback(global, sublocal);
+			}
+
+			if(sublocal->nb > 0)
+			{
+				fseek(global->f, sublocal->nb, SEEK_CUR);
+			}
+
+			level_object = sublocal->level_object;
+
+			g_free(sublocal);
+		}
+		else
+		{
+			tid = g3d_iff_id_to_text(chunk_id);
+			g_warning("[IFF] unknown chunk type \"%s\" (%d) @ 0x%08x",
+				tid, chunk_len, (unsigned int)ftell(global->f) - 8);
+			g_free(tid);
+			fseek(global->f, chunk_len, SEEK_CUR);
+		}
+
+		local->nb -= chunk_len;
+
+		if(chunk_len % chunk_mod)
+		{
+			fseek(global->f, chunk_mod - (chunk_len % chunk_mod), SEEK_CUR);
+			local->nb -= (chunk_mod - (chunk_len % chunk_mod));
+		}
+
+		fpos = ftell(global->f);
+		g3d_context_update_progress_bar(global->context,
+			((gfloat)fpos / (gfloat)global->max_fpos), TRUE);
+	} /* nb >= 8/6 */
+
+	if(local->nb > 0)
+	{
+		g_warning("[IFF] skipping %d bytes at the end of chunk",
+			local->nb);
+
+		fseek(global->f, local->nb, SEEK_CUR);
+		local->nb = 0;
+	}
+
+	return TRUE;
+}
+

Modified: trunk/libs3d/libg3d/src/matrix.c
===================================================================
--- trunk/libs3d/libg3d/src/matrix.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/matrix.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -44,11 +44,19 @@
 
 	for(i = 0; i < 4; i ++)
 		for(j = 0; j < 4; j ++)
+#if 0
 			matrix[i * 4 + j] =
 				m2[0 * 4 + j] * m1[i * 4 + 0] +
 				m2[1 * 4 + j] * m1[i * 4 + 1] +
 				m2[2 * 4 + j] * m1[i * 4 + 2] +
 				m2[3 * 4 + j] * m1[i * 4 + 3];
+#else
+			matrix[j * 4 + i] =
+				m2[j * 4 + 0] * m1[0 * 4 + i] +
+				m2[j * 4 + 1] * m1[1 * 4 + i] +
+				m2[j * 4 + 2] * m1[2 * 4 + i] +
+				m2[j * 4 + 3] * m1[3 * 4 + i];
+#endif
 
 	memcpy(rm, matrix, 16 * sizeof(gfloat));
 	return TRUE;
@@ -60,6 +68,7 @@
 	g3d_vector_unify(&ax, &ay, &az);
 	g3d_matrix_identity(rm);
 
+#if 0
 	rm[0 * 4 + 0] = cos(angle) + (ax * ax) * (1 - cos(angle));
 	rm[0 * 4 + 1] = ax * ay * (1 - cos(angle)) - az * sin(angle);
 	rm[0 * 4 + 2] = ax * az * (1 - cos(angle)) + ay * sin(angle);
@@ -71,7 +80,20 @@
 	rm[2 * 4 + 0] = az * ax * (1 - cos(angle)) - ay * sin(angle);
 	rm[2 * 4 + 1] = az * ay * (1 - cos(angle)) + ax * sin(angle);
 	rm[2 * 4 + 2] = cos(angle) + (az * az) * (1 - cos(angle));
+#else
+	rm[0 * 4 + 0] = cos(angle) + (ax * ax) * (1 - cos(angle));
+	rm[1 * 4 + 0] = ax * ay * (1 - cos(angle)) - az * sin(angle);
+	rm[2 * 4 + 0] = ax * az * (1 - cos(angle)) + ay * sin(angle);
 
+	rm[0 * 4 + 1] = ay * ax * (1 - cos(angle)) + az * sin(angle);
+	rm[1 * 4 + 1] = cos(angle) + (ay * ay) * (1 - cos(angle));
+	rm[2 * 4 + 1] = ay * az * (1 - cos(angle)) - ax * sin(angle);
+
+	rm[0 * 4 + 2] = az * ax * (1 - cos(angle)) - ay * sin(angle);
+	rm[1 * 4 + 2] = az * ay * (1 - cos(angle)) + ax * sin(angle);
+	rm[2 * 4 + 2] = cos(angle) + (az * az) * (1 - cos(angle));
+#endif
+
 	return TRUE;
 }
 
@@ -97,12 +119,69 @@
 {
 	guint32 i;
 
+#if 0
 	for(i = 0; i < 4; i ++)
+		rm[i * 4 + 3] =
+			rm[i * 4 + 0] * x +
+			rm[i * 4 + 1] * y +
+			rm[i * 4 + 2] * z +
+			rm[i * 4 + 3];
+#else
+	for(i = 0; i < 4; i ++)
 		rm[3 * 4 + i] =
 			rm[0 * 4 + i] * x +
 			rm[1 * 4 + i] * y +
 			rm[2 * 4 + i] * z +
 			rm[3 * 4 + i];
+#endif
+	return TRUE;
+}
 
+gboolean g3d_matrix_scale(gfloat x, gfloat y, gfloat z, gfloat *rm)
+{
+	gfloat sm[16];
+
+	g3d_matrix_identity(sm);
+	sm[0] = x;
+	sm[5] = y;
+	sm[10] = z;
+
+	g3d_matrix_multiply(rm, sm, rm);
+
 	return TRUE;
 }
+
+gboolean g3d_matrix_transpose(gfloat *matrix)
+{
+	gfloat tmp[16];
+	gint32 i, j;
+
+	memcpy(tmp, matrix, 16 * sizeof(gfloat));
+
+	for(i = 0; i < 4; i ++)
+		for(j = 0; j < 4; j ++)
+			matrix[i * 4 + j] = tmp[j * 4 + i];
+
+	return TRUE;
+}
+
+gboolean g3d_matrix_dump(gfloat *matrix)
+{
+#if DEBUG > 0
+	gint32 row, col;
+
+	for(row = 0; row < 4; row ++)
+	{
+		g_printerr("[Matrix]");
+		for(col = 0; col < 4; col ++)
+		{
+			g_printerr(" %-2.2f", matrix[col * 4 + row]);
+		}
+		g_printerr("\n");
+	}
+
+	return TRUE;
+#else
+	return FALSE;
+#endif
+}

Modified: trunk/libs3d/libg3d/src/model.c
===================================================================
--- trunk/libs3d/libg3d/src/model.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/model.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -20,6 +20,8 @@
     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
 
+#include <string.h>
+
 #include <g3d/types.h>
 #include <g3d/context.h>
 #include <g3d/model.h>
@@ -79,58 +81,14 @@
 	}
 }
 
-G3DModel *g3d_model_load(G3DContext *context, const gchar *filename)
+static gboolean objects_check(GSList *objects)
 {
-	G3DModel *model;
-	gdouble max_rad;
-
-	model = g3d_model_new();
-
-	g3d_context_update_progress_bar(context, 0.0, TRUE);
-
-	if(g3d_plugins_load_model(context, filename, model))
-	{
-		g3d_context_update_progress_bar(context, 0.0, FALSE);
-
-		/* check model */
-		if(!g3d_model_check(model))
-		{
-			g3d_model_free(model);
-			return NULL;
-		}
-
-		/* center model */
-		g3d_model_center(model);
-
-		/* get maximum radius of all objects */
-		max_rad = objects_max_radius(model->objects);
-
-		/* scale and optimize objects */
-		objects_post_load(model->objects, max_rad);
-
-		/* save filename */
-		if(model->filename == NULL)
-			model->filename = g_strdup(filename);
-
-		return model;
-	}
-	else
-	{
-		g3d_context_update_progress_bar(context, 0.0, FALSE);
-		g3d_model_free(model);
-	}
-
-	return NULL;
-}
-
-gboolean g3d_model_check(G3DModel *model)
-{
 	G3DFace *face;
 	G3DObject *object;
 	GSList *fitem, *oitem;
 	guint32 i, no = 0, nf;
 
-	oitem = model->objects;
+	oitem = objects;
 	while(oitem)
 	{
 		object = (G3DObject *)oitem->data;
@@ -171,50 +129,110 @@
 			nf ++;
 			fitem = fitem->next;
 		} /* while(fitem) */
+
+		if(objects_check(object->objects) == FALSE)
+			return FALSE;
+
 		oitem = oitem->next;
 	} /* while(oitem) */
 	return TRUE;
+
 }
 
-gboolean g3d_model_center(G3DModel *model)
+gboolean g3d_model_check(G3DModel *model)
 {
-	gdouble min_x = 10.0e99, min_y = 10.0e99, min_z = 10.0e99;
-	gdouble max_x = -9.9e99, max_y = -9.9e99, max_z = -9.9e99;
-	gdouble off_x, off_y, off_z;
+	return objects_check(model->objects);
+}
+
+
+G3DModel *g3d_model_load(G3DContext *context, const gchar *filename)
+{
+	G3DModel *model;
+	gdouble max_rad;
+
+	model = g3d_model_new();
+
+	g3d_context_update_progress_bar(context, 0.0, TRUE);
+
+	if(g3d_plugins_load_model(context, filename, model))
+	{
+		g3d_context_update_progress_bar(context, 0.0, FALSE);
+
+		/* check model */
+		if(!g3d_model_check(model))
+		{
+			g3d_model_free(model);
+			return NULL;
+		}
+
+		/* center model */
+		g3d_model_center(model);
+
+		/* get maximum radius of all objects */
+		max_rad = objects_max_radius(model->objects);
+
+		/* scale and optimize objects */
+		objects_post_load(model->objects, max_rad);
+
+		/* save filename */
+		if(model->filename == NULL)
+			model->filename = g_strdup(filename);
+
+		return model;
+	}
+	else
+	{
+		g3d_context_update_progress_bar(context, 0.0, FALSE);
+		g3d_model_free(model);
+	}
+
+	return NULL;
+}
+
+static void objects_max_extension(GSList *objects,
+	gdouble *min_x, gdouble *min_y, gdouble *min_z,
+	gdouble *max_x,	gdouble *max_y, gdouble *max_z)
+{
 	GSList *oitem;
 	G3DObject *object;
 	guint32 i;
 
-	/* determine maximum extension */
-	oitem = model->objects;
+	oitem = objects;
 	while(oitem)
 	{
 		object = (G3DObject *)oitem->data;
 		for(i = 0; i < object->vertex_count; i ++)
 		{
-			if(object->vertex_data[i * 3 + 0] < min_x)
-				min_x = object->vertex_data[i * 3 + 0];
-			if(object->vertex_data[i * 3 + 1] < min_y)
-				min_y = object->vertex_data[i * 3 + 1];
-			if(object->vertex_data[i * 3 + 2] < min_z)
-				min_z = object->vertex_data[i * 3 + 2];
+			if(object->vertex_data[i * 3 + 0] < *min_x)
+				*min_x = object->vertex_data[i * 3 + 0];
+			if(object->vertex_data[i * 3 + 1] < *min_y)
+				*min_y = object->vertex_data[i * 3 + 1];
+			if(object->vertex_data[i * 3 + 2] < *min_z)
+				*min_z = object->vertex_data[i * 3 + 2];
 
-			if(object->vertex_data[i * 3 + 0] > max_x)
-				max_x = object->vertex_data[i * 3 + 0];
-			if(object->vertex_data[i * 3 + 1] > max_y)
-				max_y = object->vertex_data[i * 3 + 1];
-			if(object->vertex_data[i * 3 + 2] > max_z)
-				max_z = object->vertex_data[i * 3 + 2];
+			if(object->vertex_data[i * 3 + 0] > *max_x)
+				*max_x = object->vertex_data[i * 3 + 0];
+			if(object->vertex_data[i * 3 + 1] > *max_y)
+				*max_y = object->vertex_data[i * 3 + 1];
+			if(object->vertex_data[i * 3 + 2] > *max_z)
+				*max_z = object->vertex_data[i * 3 + 2];
 		}
+
+		objects_max_extension(object->objects,
+			min_x, min_y, min_z, max_x, max_y, max_z);
+
 		oitem = oitem->next;
 	}
+}
 
-	/* move model */
-	off_x = max_x - ((max_x - min_x) / 2.0);
-	off_y = max_y - ((max_y - min_y) / 2.0);
-	off_z = max_z - ((max_z - min_z) / 2.0);
+static void objects_move(GSList *objects,
+	gdouble off_x, gdouble off_y, gdouble off_z)
+{
+	GSList *oitem;
+	G3DObject *object;
+	guint32 i;
 
-	oitem = model->objects;
+	oitem = objects;
 	while(oitem)
 	{
 		object = (G3DObject *)oitem->data;
@@ -224,9 +242,30 @@
 			object->vertex_data[i * 3 + 1] -= off_y;
 			object->vertex_data[i * 3 + 2] -= off_z;
 		}
+
+		objects_move(object->objects, off_x, off_y, off_z);
+
 		oitem = oitem->next;
 	}
+}
 
+gboolean g3d_model_center(G3DModel *model)
+{
+	gdouble min_x = 10.0e99, min_y = 10.0e99, min_z = 10.0e99;
+	gdouble max_x = -9.9e99, max_y = -9.9e99, max_z = -9.9e99;
+	gdouble off_x, off_y, off_z;
+
+	/* determine maximum extension */
+	objects_max_extension(model->objects,
+		&min_x, &min_y, &min_z, &max_x, &max_y, &max_z);
+
+	/* move model */
+	off_x = max_x - ((max_x - min_x) / 2.0);
+	off_y = max_y - ((max_y - min_y) / 2.0);
+	off_z = max_z - ((max_z - min_z) / 2.0);
+
+	objects_move(model->objects, off_x, off_y, off_z);
+
 	return TRUE;
 }
 
@@ -246,25 +285,33 @@
 	return TRUE;
 }
 
-void g3d_model_clear(G3DModel *model)
+static void objects_clear(GSList *objects)
 {
 	GSList *list, *next;
 	G3DObject *object;
-	G3DMaterial *mat;
 
-	/* lights */
-	/* TODO */
-
-	/* objects */
-	list = model->objects;
+	list = objects;
 	while(list)
 	{
 		object = (G3DObject*)list->data;
+		objects_clear(object->objects);
 		g3d_object_free(object);
 		next = list->next;
 		g_slist_free_1(list);
 		list = next;
 	}
+}
+
+void g3d_model_clear(G3DModel *model)
+{
+	GSList *list, *next;
+	G3DMaterial *mat;
+
+	/* lights */
+	/* TODO */
+
+	/* objects */
+	objects_clear(model->objects);
 	model->objects = NULL;
 
 	/* materials */
@@ -293,4 +340,30 @@
 	g_free(model);
 }
 
+static G3DObject *objects_get_by_name(GSList *objects, const gchar *name)
+{
+	GSList *olist;
+	G3DObject *object;
 
+	olist = objects;
+	while(olist)
+	{
+		object = (G3DObject *)olist->data;
+
+		if((object->name != NULL) && (strcmp(object->name, name) == 0))
+			return object;
+
+		object = objects_get_by_name(object->objects, name);
+		if(object != NULL)
+			return object;
+
+		olist = olist->next;
+	}
+	return NULL;
+}
+
+G3DObject *g3d_model_get_object_by_name(G3DModel *model, const gchar *name)
+{
+	return objects_get_by_name(model->objects, name);
+}
+

Added: trunk/libs3d/libg3d/src/object-orig.c
===================================================================
--- trunk/libs3d/libg3d/src/object-orig.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/object-orig.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -0,0 +1,368 @@
+/* $Id: object.c,v 1.1.2.7 2006/01/23 16:38:47 dahms Exp $ */
+
+/*
+    libg3d - 3D object loading library
+
+    Copyright (C) 2005, 2006  Markus Dahms <mad at automagically.de>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <string.h>
+#include <math.h>
+
+#include <g3d/types.h>
+#include <g3d/vector.h>
+#include <g3d/matrix.h>
+#include <g3d/face.h>
+
+void g3d_object_free(G3DObject *object)
+{
+	GSList *slist, *snext;
+	G3DMaterial *mat;
+	G3DFace *face;
+
+	if(object->name != NULL)
+		g_free(object->name);
+
+	/* materials */
+	slist = object->materials;
+	while(slist != NULL)
+	{
+		mat = (G3DMaterial*)slist->data;
+		snext = slist->next;
+		g_slist_free_1(slist);
+		slist = snext;
+	}
+
+	/* faces */
+	slist = object->faces;
+	while(slist != NULL)
+	{
+		face = (G3DFace*)slist->data;
+		g3d_face_free(face);
+		snext = slist->next;
+		g_slist_free_1(slist);
+		slist = snext;
+	}
+
+	/* vertices */
+	if(object->vertex_data != NULL) g_free(object->vertex_data);
+	if(object->tex_vertex_data != NULL) g_free(object->tex_vertex_data);
+	if(object->_normals != NULL) g_free(object->_normals);
+	if(object->_indices != NULL) g_free(object->_indices);
+	if(object->_materials != NULL) g_free(object->_materials);
+	if(object->_flags != NULL) g_free(object->_flags);
+
+	g_free(object);
+}
+
+gdouble g3d_object_radius(G3DObject *object)
+{
+	guint32 i;
+	gdouble max_radius = 0.0, r;
+	gfloat *v;
+
+	for(i = 0; i < object->vertex_count; i ++)
+	{
+		v = &object->vertex_data[i * 3];
+		r = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
+		if(r > max_radius)
+			max_radius = r;
+	}
+
+	return sqrt(max_radius);
+}
+
+gboolean g3d_object_scale(G3DObject *object, gfloat scale)
+{
+	guint32 i;
+	gfloat *matrix;
+
+	for(i = 0; i < object->vertex_count; i ++)
+	{
+		object->vertex_data[i * 3 + 0] *= scale;
+		object->vertex_data[i * 3 + 1] *= scale;
+		object->vertex_data[i * 3 + 2] *= scale;
+	}
+
+	if(object->transformation)
+	{
+		matrix = object->transformation->matrix;
+		g3d_matrix_translate(
+			- (matrix[12] - (matrix[12] * scale)),
+			- (matrix[13] - (matrix[13] * scale)),
+			- (matrix[14] - (matrix[14] * scale)),
+			matrix);
+	}
+
+	return TRUE;
+}
+
+#define G3D_OBJECT_TRANSFORM_NORMALS 0
+
+gboolean g3d_object_transform(G3DObject *object, gfloat *matrix)
+{
+	guint32 i;
+#if G3D_OBJECT_TRANSFORM_NORMALS
+	G3DFace *face;
+	GSList *fitem;
+#endif
+
+	/* transform vertices */
+	for(i = 0; i < object->vertex_count; i ++)
+	{
+		g3d_vector_transform(
+			&(object->vertex_data[i * 3 + 0]),
+			&(object->vertex_data[i * 3 + 1]),
+			&(object->vertex_data[i * 3 + 2]),
+			matrix);
+	}
+
+#if G3D_OBJECT_TRANSFORM_NORMALS
+	fitem = object->faces;
+	while(fitem)
+	{
+		face = (G3DFace *)fitem->data;
+
+		if(face->flags & G3D_FLAG_FAC_NORMALS)
+		{
+			for(i = 0; i < face->vertex_count; i ++)
+			{
+				g3d_vector_transform(
+					&(face->normals[i * 3 + 0]),
+					&(face->normals[i * 3 + 1]),
+					&(face->normals[i * 3 + 2]),
+					matrix);
+				g3d_vector_unify(
+					&(face->normals[i * 3 + 0]),
+					&(face->normals[i * 3 + 1]),
+					&(face->normals[i * 3 + 2]));
+			}
+		}
+
+		fitem = fitem->next;
+	}
+#endif
+
+	return TRUE;
+}
+
+G3DObject *g3d_object_duplicate(G3DObject *object)
+{
+	G3DObject *new;
+	G3DFace *face, *oface;
+	GSList *litem;
+
+	new = g_new0(G3DObject, 1);
+
+	/* name */
+	if(object->name)
+		new->name = g_strdup(object->name);
+
+	/* vertices */
+	new->vertex_count = object->vertex_count;
+	new->vertex_data = g_new0(gfloat, new->vertex_count * 3);
+	memcpy(new->vertex_data, object->vertex_data,
+		new->vertex_count * 3 * sizeof(gfloat));
+
+	/* texture stuff */
+	/* TODO: implement? */
+
+	/* faces */
+	litem = object->faces;
+	while(litem)
+	{
+		oface = (G3DFace *)litem->data;
+
+		face = g_new0(G3DFace, 1);
+		face->material = oface->material;
+		face->vertex_count = oface->vertex_count;
+		face->vertex_indices = g_new0(guint32, face->vertex_count);
+		memcpy(face->vertex_indices, oface->vertex_indices,
+			face->vertex_count * sizeof(guint32));
+		face->flags = oface->flags;
+		if(face->flags & G3D_FLAG_FAC_NORMALS)
+		{
+			face->normals = g_new0(gfloat, face->vertex_count * 3);
+			memcpy(face->normals, oface->normals,
+				face->vertex_count * 3 * sizeof(gfloat));
+		}
+		if(face->flags & G3D_FLAG_FAC_TEXMAP)
+		{
+			face->tex_image = oface->tex_image;
+			face->tex_vertex_count = oface->tex_vertex_count;
+			face->tex_vertex_data = g_new0(gfloat, face->tex_vertex_count * 2);
+			memcpy(face->tex_vertex_data, oface->tex_vertex_data,
+				face->tex_vertex_count * 2 * sizeof(gfloat));
+		}
+
+		new->faces = g_slist_prepend(new->faces, face);
+
+		litem = litem->next;
+	}
+
+	return new;
+}
+
+gboolean g3d_object_merge(G3DObject *o1, G3DObject *o2)
+{
+	G3DFace *face;
+	GSList *fitem;
+	guint32 i, voff, foff = 0;
+
+	/* copy vertices */
+	voff = o1->vertex_count;
+	o1->vertex_count += o2->vertex_count;
+
+	o1->vertex_data = g_realloc(o1->vertex_data,
+		o1->vertex_count * 3 * sizeof(gfloat));
+
+	memcpy(o1->vertex_data + voff * 3, o2->vertex_data,
+		o2->vertex_count * 3 * sizeof(gfloat));
+
+	/* attach faces to first object */
+	fitem = o2->faces;
+	while(fitem)
+	{
+		face = (G3DFace *)fitem->data;
+		foff ++;
+
+		if(face->vertex_count > 100)
+		{
+			g_printerr("face->vertex_count > 100: %d (%dth)",
+				face->vertex_count, foff);
+		}
+
+		for(i = 0; i < face->vertex_count; i ++)
+			face->vertex_indices[i] += voff;
+
+		o1->faces = g_slist_prepend(o1->faces, face);
+
+		fitem = fitem->next;
+	}
+
+	/* FIXME: clean up o2 or copy faces */
+
+	return TRUE;
+}
+
+gboolean g3d_object_smooth(G3DObject *object)
+{
+	/* FIXME: implement */
+	return FALSE;
+}
+
+gboolean g3d_object_optimize(G3DObject *object)
+{
+	G3DFace *face;
+	guint32 index = 0, i, j;
+	GSList *fitem;
+	gfloat nx, ny, nz;
+
+	/* count number of faces (optimized) */
+	object->_num_faces = 0;
+	fitem = object->faces;
+	while(fitem)
+	{
+		face = (G3DFace *)fitem->data;
+		object->_num_faces += face->vertex_count - 2;
+
+		fitem = fitem->next;
+	}
+
+	object->_normals = g_new0(gfloat, object->_num_faces * 9);
+	object->_materials = g_new0(G3DMaterial *, object->_num_faces);
+	object->_flags = g_new0(guint32, object->_num_faces);
+	object->_indices = g_new0(guint32, object->_num_faces * 3);
+	object->_tex_images = g_new0(guint32, object->_num_faces);
+	object->_tex_coords = g_new0(gfloat, object->_num_faces * 6);
+
+	/* copy faces */
+	fitem = object->faces;
+	while(fitem)
+	{
+		face = (G3DFace *)fitem->data;
+
+		/* generate default normal for face */
+		if(!(face->flags & G3D_FLAG_FAC_NORMALS))
+		{
+			if(!g3d_face_get_normal(face, object, &nx, &ny, &nz))
+			{
+				fitem = fitem->next;
+				object->_num_faces -= face->vertex_count - 2;
+			}
+
+			g3d_vector_unify(&nx, &ny, &nz);
+		}
+
+		for(i = 0; i < (face->vertex_count - 2); i ++)
+		{
+			object->_materials[index] = face->material;
+			object->_flags[index] = face->flags;
+
+			if(face->flags & G3D_FLAG_FAC_TEXMAP)
+				object->_tex_images[index] = face->tex_image->tex_id;
+
+			for(j = 0; j < 3; j ++)
+			{
+				/* vertex stuff */
+				if(j == 0)
+					object->_indices[index * 3] = face->vertex_indices[0];
+				else
+					object->_indices[index * 3+j] = face->vertex_indices[i+j];
+
+				/* normal stuff */
+				if(face->flags & G3D_FLAG_FAC_NORMALS)
+				{
+					object->_normals[(index * 3 + j) * 3 + 0] =
+						face->normals[(i + j) * 3 + 0];
+					object->_normals[(index * 3 + j) * 3 + 1] =
+						face->normals[(i + j) * 3 + 1];
+					object->_normals[(index * 3 + j) * 3 + 2] =
+						face->normals[(i + j) * 3 + 2];
+				}
+				else
+				{
+					object->_normals[(index * 3 + j) * 3 + 0] = nx;
+					object->_normals[(index * 3 + j) * 3 + 1] = ny;
+					object->_normals[(index * 3 + j) * 3 + 2] = nz;
+				}
+
+				/* texture stuff */
+				if(face->flags & G3D_FLAG_FAC_TEXMAP)
+				{
+					/* u */
+					object->_tex_coords[(index * 3 + j) * 2 + 0] =
+						(j == 0) ?
+							face->tex_vertex_data[0] :
+							face->tex_vertex_data[(i + j) * 2 + 0];
+					/* v */
+					object->_tex_coords[(index * 3 + j) * 2 + 1] =
+						(j == 0) ?
+							face->tex_vertex_data[1] :
+							face->tex_vertex_data[(i + j) * 2 + 1];
+				}
+			} /* j: 0 < 3 */
+
+			index ++;
+		} /* i: 0 < vertex_count - 2 */
+
+		fitem = fitem->next;
+	} /* while(fitem) */
+
+	return TRUE;
+}
+

Modified: trunk/libs3d/libg3d/src/object.c
===================================================================
--- trunk/libs3d/libg3d/src/object.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/object.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -25,6 +25,7 @@
 
 #include <g3d/types.h>
 #include <g3d/vector.h>
+#include <g3d/matrix.h>
 #include <g3d/face.h>
 
 void g3d_object_free(G3DObject *object)
@@ -88,6 +89,7 @@
 gboolean g3d_object_scale(G3DObject *object, gfloat scale)
 {
 	guint32 i;
+	gfloat *matrix;
 
 	for(i = 0; i < object->vertex_count; i ++)
 	{
@@ -96,14 +98,28 @@
 		object->vertex_data[i * 3 + 2] *= scale;
 	}
 
+	if(object->transformation)
+	{
+		matrix = object->transformation->matrix;
+		g3d_matrix_translate(
+			- (matrix[12] - (matrix[12] * scale)),
+			- (matrix[13] - (matrix[13] * scale)),
+			- (matrix[14] - (matrix[14] * scale)),
+			matrix);
+	}
+
 	return TRUE;
 }
 
+#define G3D_OBJECT_TRANSFORM_NORMALS 0
+
 gboolean g3d_object_transform(G3DObject *object, gfloat *matrix)
 {
 	guint32 i;
+#if G3D_OBJECT_TRANSFORM_NORMALS
 	G3DFace *face;
 	GSList *fitem;
+#endif
 
 	/* transform vertices */
 	for(i = 0; i < object->vertex_count; i ++)
@@ -115,6 +131,7 @@
 			matrix);
 	}
 
+#if G3D_OBJECT_TRANSFORM_NORMALS
 	fitem = object->faces;
 	while(fitem)
 	{
@@ -138,6 +155,7 @@
 
 		fitem = fitem->next;
 	}
+#endif
 
 	return TRUE;
 }

Modified: trunk/libs3d/libg3d/src/plugins.c
===================================================================
--- trunk/libs3d/libg3d/src/plugins.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/plugins.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -122,10 +122,10 @@
 					{
 						if(plugin->type == G3D_PLUGIN_IMAGE)
 							g_hash_table_insert(context->exts_image,
-								g_strdup(*ext), plugin);
+								*ext, plugin);
 						else if(plugin->type == G3D_PLUGIN_IMPORT)
 							g_hash_table_insert(context->exts_import,
-								g_strdup(*ext), plugin);
+								*ext, plugin);
 
 						ext ++;
 					}
@@ -158,15 +158,60 @@
 	context->exts_import = g_hash_table_new(g_str_hash, g_str_equal);
 	context->exts_image = g_hash_table_new(g_str_hash, g_str_equal);
 
-	printf("Loading plugins from " PLUGIN_DIR "\n");
 	plugins_loaddirectory(context, PLUGIN_DIR "/image");
 	plugins_loaddirectory(context, PLUGIN_DIR "/import");
+
 	return TRUE;
 }
 
+/**
+ * g3d_plugins_cleanup:
+ * @context: an initialized context
+ *
+ * Tries to free any memory allocated during g3d_plugins_init.
+ */
+
 void g3d_plugins_cleanup(G3DContext *context)
 {
-	/* TODO: implement */
+	GSList *plist;
+	G3DPlugin *plugin;
+	gchar **pext;
+
+	plist = context->plugins;
+	while(plist)
+	{
+		plugin = (G3DPlugin *)plist->data;
+
+#if DEBUG > 2
+		g_print("D: cleaning up plugin '%s'\n", plugin->name);
+#endif
+
+		/* cleanup plugin-specific data */
+		if(plugin->cleanup_func)
+			plugin->cleanup_func(plugin->user_data);
+
+		/* remove extensions from hash tables */
+		pext = plugin->extensions;
+		while(*pext)
+		{
+			if(plugin->type == G3D_PLUGIN_IMAGE)
+				g_hash_table_remove(context->exts_image, *pext);
+			else if(plugin->type == G3D_PLUGIN_IMPORT)
+				g_hash_table_remove(context->exts_import, *pext);
+
+			pext ++;
+		}
+
+		/* cleanup struct data */
+		plugins_free_plugin(plugin);
+
+		/* free list item */
+		plist = g_slist_remove(plist, plugin);
+	}
+
+	/* remove hash tables */
+	g_hash_table_destroy(context->exts_image);
+	g_hash_table_destroy(context->exts_import);
 }
 
 gchar *g3d_plugins_get_filetype(const gchar *filename)

Modified: trunk/libs3d/libg3d/src/primitive.c
===================================================================
--- trunk/libs3d/libg3d/src/primitive.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/primitive.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -21,6 +21,7 @@
 */
 
 #include <math.h>
+#include <string.h>
 
 #ifndef M_PI
 #	define M_PI 3.14159265358979323846
@@ -29,6 +30,73 @@
 #include <g3d/types.h>
 #include <g3d/vector.h>
 
+G3DObject *g3d_primitive_cube(gfloat width, gfloat height, gfloat depth,
+	G3DMaterial *material)
+{
+	G3DObject *object;
+	G3DFace *face;
+	gint32 faces[6][4] = {
+		{ 0, 1, 2, 3 },
+		{ 4, 5, 6, 7 },
+		{ 0, 1, 5, 4 },
+		{ 2, 3, 7, 6 },
+		{ 1, 2, 6, 5 },
+		{ 0, 4, 7, 3 }};
+	gint32 i, j;
+
+	object = g_new0(G3DObject, 1);
+
+	object->vertex_count = 8;
+	object->vertex_data = g_new0(gfloat, object->vertex_count * 3);
+
+	object->vertex_data[0 * 3 + 0] = -(width / 2);
+	object->vertex_data[0 * 3 + 1] = -(height / 2);
+	object->vertex_data[0 * 3 + 2] = -(depth / 2);
+
+	object->vertex_data[1 * 3 + 0] = -(width / 2);
+	object->vertex_data[1 * 3 + 1] = -(height / 2);
+	object->vertex_data[1 * 3 + 2] = (depth / 2);
+
+	object->vertex_data[2 * 3 + 0] = (width / 2);
+	object->vertex_data[2 * 3 + 1] = -(height / 2);
+	object->vertex_data[2 * 3 + 2] = (depth / 2);
+
+	object->vertex_data[3 * 3 + 0] = (width / 2);
+	object->vertex_data[3 * 3 + 1] = -(height / 2);
+	object->vertex_data[3 * 3 + 2] = -(depth / 2);
+
+	object->vertex_data[4 * 3 + 0] = -(width / 2);
+	object->vertex_data[4 * 3 + 1] = (height / 2);
+	object->vertex_data[4 * 3 + 2] = -(depth / 2);
+
+	object->vertex_data[5 * 3 + 0] = -(width / 2);
+	object->vertex_data[5 * 3 + 1] = (height / 2);
+	object->vertex_data[5 * 3 + 2] = (depth / 2);
+
+	object->vertex_data[6 * 3 + 0] = (width / 2);
+	object->vertex_data[6 * 3 + 1] = (height / 2);
+	object->vertex_data[6 * 3 + 2] = (depth / 2);
+
+	object->vertex_data[7 * 3 + 0] = (width / 2);
+	object->vertex_data[7 * 3 + 1] = (height / 2);
+	object->vertex_data[7 * 3 + 2] = -(depth / 2);
+
+	for(i = 0; i < 6; i ++)
+	{
+		face = g_new0(G3DFace, 1);
+		face->vertex_count = 4;
+		face->vertex_indices = g_new0(guint32, 4);
+		for(j = 0; j < 4; j ++)
+		{
+			face->vertex_indices[j] = faces[i][j];
+		}
+		face->material = material;
+		object->faces = g_slist_append(object->faces, face);
+	}
+
+	return object;
+}
+
 G3DObject *g3d_primitive_cylinder(gfloat radius, gfloat height,
 	guint32 sides, gboolean top, gboolean bottom, G3DMaterial *material)
 {
@@ -328,3 +396,128 @@
 
 	return object;
 }
+
+G3DObject *g3d_primitive_sphere(gfloat radius, guint32 vseg, guint32 hseg,
+	G3DMaterial *material)
+{
+	G3DObject *object;
+	G3DFace *face;
+	GSList *flist;
+	gint32 sh, sv, i;
+	gdouble x, y, z, u;
+
+	g_return_val_if_fail(vseg >= 2, NULL);
+	g_return_val_if_fail(hseg >= 3, NULL);
+
+	object = g_new0(G3DObject, 1);
+	object->vertex_count = (vseg - 1) * hseg + 2;
+	object->vertex_data = g_new0(gfloat, 3 * object->vertex_count);
+
+	for(sv = 1; sv < vseg; sv ++)
+	{
+		y = radius * cos(M_PI * sv / vseg);
+		u = radius * sin(M_PI * sv / vseg);
+		for(sh = 0; sh < hseg; sh ++)
+		{
+			x = radius * cos(M_PI * 2 * sh / hseg) * u;
+			z = radius * sin(M_PI * 2 * sh / hseg) * u;
+
+			object->vertex_data[((sv - 1) * hseg + sh) * 3 + 0] = x;
+			object->vertex_data[((sv - 1) * hseg + sh) * 3 + 1] = y;
+			object->vertex_data[((sv - 1) * hseg + sh) * 3 + 2] = z;
+
+			if(sv > 1)
+			{
+				/* first triangle */
+				face = g_new0(G3DFace, 1);
+				face->material = material;
+				face->vertex_count = 3;
+				face->vertex_indices = g_new0(guint32, 3);
+				face->vertex_indices[0] = (sv - 1) * hseg + sh;
+				face->vertex_indices[1] = (sh == (hseg - 1)) ?
+					(sv - 1) * hseg :
+					(sv - 1) * hseg + sh + 1;
+				face->vertex_indices[2] = (sv - 2) * hseg + sh;
+				object->faces = g_slist_append(object->faces, face);
+
+				/* second triangle */
+				face = g_new0(G3DFace, 1);
+				face->material = material;
+				face->vertex_count = 3;
+				face->vertex_indices = g_new0(guint32, 3);
+				face->vertex_indices[0] = (sv - 2) * hseg + sh;
+				face->vertex_indices[1] = (sh == (hseg - 1)) ?
+					(sv - 1) * hseg :
+					(sv - 1) * hseg + sh + 1;
+				face->vertex_indices[2] = (sh == (hseg - 1)) ?
+					(sv - 2) * hseg :
+					(sv - 2) * hseg + sh + 1;
+				object->faces = g_slist_append(object->faces, face);
+			} /* sv > 1 */
+		} /* hseg */
+	} /* vseg */
+
+	object->vertex_data[(object->vertex_count - 1) * 3 + 0] = 0;
+	object->vertex_data[(object->vertex_count - 1) * 3 + 1] = radius;
+	object->vertex_data[(object->vertex_count - 1) * 3 + 2] = 0;
+
+	object->vertex_data[(object->vertex_count - 2) * 3 + 0] = 0;
+	object->vertex_data[(object->vertex_count - 2) * 3 + 1] = -radius;
+	object->vertex_data[(object->vertex_count - 2) * 3 + 2] = 0;
+
+	for(sh = 0; sh < hseg; sh ++)
+	{
+		/* top */
+		face = g_new0(G3DFace, 1);
+		face->material = material;
+		face->vertex_count = 3;
+		face->vertex_indices = g_new0(guint32, 3);
+
+		face->vertex_indices[0] = object->vertex_count - 1;
+		face->vertex_indices[1] = sh;
+		face->vertex_indices[2] = (sh == (hseg - 1)) ? 0 : sh + 1;
+
+		object->faces = g_slist_append(object->faces, face);
+
+		/* bottom */
+		face = g_new0(G3DFace, 1);
+		face->material = material;
+		face->vertex_count = 3;
+		face->vertex_indices = g_new0(guint32, 3);
+
+		face->vertex_indices[2] = object->vertex_count - 2;
+		face->vertex_indices[1] = (vseg - 2) * hseg + sh;
+		face->vertex_indices[0] = (sh == (hseg - 1)) ?
+			(vseg - 2) * hseg :
+			(vseg - 2) * hseg + sh + 1;
+
+		object->faces = g_slist_append(object->faces, face);
+	}
+
+	/* generate normals */
+	flist = object->faces;
+	while(flist)
+	{
+		face = (G3DFace *)flist->data;
+		face->flags |= G3D_FLAG_FAC_NORMALS;
+		face->normals = g_new0(gfloat, face->vertex_count * 3);
+		for(i = 0; i < face->vertex_count; i ++)
+		{
+			face->normals[i * 3 + 0] =
+				- object->vertex_data[face->vertex_indices[i] * 3 + 0];
+			face->normals[i * 3 + 1] =
+				- object->vertex_data[face->vertex_indices[i] * 3 + 1];
+			face->normals[i * 3 + 2] =
+				- object->vertex_data[face->vertex_indices[i] * 3 + 2];
+
+			g3d_vector_unify(
+				&(face->normals[i * 3 + 0]),
+				&(face->normals[i * 3 + 1]),
+				&(face->normals[i * 3 + 2]));
+		}
+
+		flist = flist->next;
+	}
+
+	return object;
+}

Modified: trunk/libs3d/libg3d/src/read.c
===================================================================
--- trunk/libs3d/libg3d/src/read.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/read.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -84,3 +84,48 @@
 	return u.f;
 }
 
+gdouble g3d_read_double_be(FILE *f)
+{
+	union {
+		gdouble d;
+		guint8 u[8];
+	} u;
+	gint32 i;
+
+	for(i = 7; i >= 0; i --)
+		u.u[i] = g3d_read_int8(f);
+
+	return u.d;
+}
+
+gdouble g3d_read_double_le(FILE *f)
+{
+	union {
+		gdouble d;
+		guint8 u[8];
+	} u;
+	gint32 i;
+
+	for(i = 0; i < 8; i ++)
+		u.u[i] = g3d_read_int8(f);
+
+	return u.d;
+}
+
+gint32 g3d_read_cstr(FILE *f, gchar *buffer, gint32 max_len)
+{
+	gint32 n = 0;
+	gchar c;
+
+	do
+	{
+		c = g3d_read_int8(f);
+		buffer[n] = c;
+		n ++;
+	}
+	while((c != 0) && (n < max_len));
+
+	buffer[max_len - 1] = '\0';
+
+	return n;
+}

Modified: trunk/libs3d/libg3d/src/texture.c
===================================================================
--- trunk/libs3d/libg3d/src/texture.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/texture.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -27,56 +27,96 @@
 
 static gboolean dump_ppm(G3DImage *image, const gchar *filename);
 
-G3DImage *g3d_texture_load_cached(G3DContext *context, G3DModel *model,
-	const gchar *filename)
+G3DImage *g3d_texture_load(G3DContext *context, const gchar *filename)
 {
 	G3DImage *image;
-	gchar *basename, *ppmname, *path;
+	gchar *basename, *path, *casedup, *caseddown, *realfile = NULL;
 
 	/* convert DOS path separator */
 	path = g_strdup(filename);
 	g_strdelimit(path, "\\", '/');
 
-	/* create hash table if it does not exist yet */
-	if(model->tex_images == NULL)
-		model->tex_images = g_hash_table_new(g_str_hash, g_str_equal);
-
-	/* if already loaded, return cached image */
-	image = g_hash_table_lookup(model->tex_images, path);
-	if(image != NULL)
-		return image;
-
-	/* create emtpy G3DImage */
-	image = g_new0(G3DImage, 1);
-	image->tex_scale_u = 1.0;
-	image->tex_scale_v = 1.0;
-	if(g3d_plugins_load_image(context, path, image))
+	if(g_file_test(path, G_FILE_TEST_EXISTS))
 	{
-		g_hash_table_insert(model->tex_images, (gpointer)g_strdup(path),
-			image);
+		realfile = g_strdup(path);
 	}
 	else
 	{
-		/* try to load file without path */
 		basename = g_path_get_basename(path);
-		if(g3d_plugins_load_image(context, basename, image))
+		if(g_file_test(basename, G_FILE_TEST_EXISTS))
 		{
-			g_hash_table_insert(model->tex_images,
-				(gpointer)g_strdup(path), image);
+			realfile = g_strdup(basename);
 		}
 		else
 		{
-			g_free(image);
-			image = NULL;
+			casedup = g_ascii_strup(basename, -1);
+			if(g_file_test(casedup, G_FILE_TEST_EXISTS))
+			{
+				realfile = g_strdup(casedup);
+			}
+			else
+			{
+				caseddown = g_ascii_strdown(basename, -1);
+				if(g_file_test(caseddown, G_FILE_TEST_EXISTS))
+				{
+					realfile = g_strdup(caseddown);
+				}
+				g_free(caseddown);
+			}
+			g_free(casedup);
 		}
 		g_free(basename);
 	}
-
 	g_free(path);
 
+	if(realfile == NULL)
+	{
+		g_printerr("failed to find a file matching '%s'\n", filename);
+		return NULL;
+	}
+
+	/* create emtpy G3DImage */
+	image = g_new0(G3DImage, 1);
+	image->tex_scale_u = 1.0;
+	image->tex_scale_v = 1.0;
+
+	if(g3d_plugins_load_image(context, realfile, image))
+	{
+		g_free(realfile);
+		return image;
+	}
+
+	g_free(image);
+	g_free(realfile);
+
+	return NULL;
+}
+
+G3DImage *g3d_texture_load_cached(G3DContext *context, G3DModel *model,
+	const gchar *filename)
+{
+	G3DImage *image;
+	gchar *basename, *ppmname;
+
+	/* create hash table if it does not exist yet */
+	if(model->tex_images == NULL)
+		model->tex_images = g_hash_table_new(g_str_hash, g_str_equal);
+
+	/* if already loaded, return cached image */
+	image = g_hash_table_lookup(model->tex_images, filename);
+	if(image != NULL)
+		return image;
+
+	image = g3d_texture_load(context, filename);
+	if(image != NULL)
+	{
+		g_hash_table_insert(model->tex_images, (gpointer)g_strdup(filename),
+			image);
+	}
+
 	if(0 && image)
 	{
-		basename = g_path_get_basename(path);
+		basename = g_path_get_basename(filename);
 		ppmname = g_strdup_printf("/tmp/%s.ppm", basename);
 		dump_ppm(image, ppmname);
 		g_free(ppmname);
@@ -86,11 +126,42 @@
 	return image;
 }
 
+void g3d_texture_free(G3DImage *texture)
+{
+	if(texture->name) g_free(texture->name);
+	if(texture->pixeldata) g_free(texture->pixeldata);
+	g_free(texture);
+}
+
 gboolean g3d_texture_prepare(G3DImage *texture)
 {
 	return FALSE;
 }
 
+gboolean g3d_texture_flip_y(G3DImage *texture)
+{
+	guint8 *newpixel;
+	gint32 y;
+
+	g_return_val_if_fail(texture != NULL, FALSE);
+
+	newpixel = g_new0(guint8, texture->width * texture->height * 4);
+
+	for(y = 0; y < texture->height; y ++)
+	{
+		memcpy(
+			newpixel + (y * texture->width * 4),
+			texture->pixeldata + (
+				(texture->height - y - 1) * texture->width * 4),
+			texture->width * 4);
+	}
+
+	g_free(texture->pixeldata);
+	texture->pixeldata = newpixel;
+
+	return TRUE;
+}
+
 static gboolean dump_ppm(G3DImage *image, const gchar *filename)
 {
 	FILE *f;
@@ -116,3 +187,54 @@
 	fclose(f);
 	return TRUE;
 }
+
+G3DImage *g3d_texture_merge_alpha(G3DImage *image, G3DImage *aimage)
+{
+	G3DImage *texture;
+	gint32 x, y;
+	gboolean negative;
+
+	g_return_val_if_fail(aimage != NULL, NULL);
+
+	if(image && (
+			(image->width != aimage->width) ||
+			(image->height != aimage->height)))
+	{
+		/* size doesn't match, don't do something */
+		return image;
+	}
+
+	if(image)
+	{
+		texture = image;
+	}
+	else
+	{
+		texture = g_new0(G3DImage, 1);
+		texture->tex_scale_u = 1.0;
+		texture->tex_scale_v = 1.0;
+		texture->width = aimage->width;
+		texture->height = aimage->height;
+		texture->depth = 4;
+		texture->pixeldata = g_malloc(texture->width * texture->height * 4);
+	}
+
+	/* negative map? */
+	/* FIXME: better solution? */
+	if(aimage->pixeldata[0] == 0)
+		negative = TRUE;
+	else
+		negative = FALSE;
+
+	for(y = 0; y < texture->height; y ++)
+	{
+		for(x = 0; x < texture->width; x ++)
+		{
+			texture->pixeldata[(y * image->width + x) * 4 + 3] = (negative ?
+				255 - aimage->pixeldata[(y * image->width + x) * 4 + 0] :
+				aimage->pixeldata[(y * image->width + x) * 4 + 0]);
+		}
+	}
+
+	return texture;
+}

Modified: trunk/libs3d/libg3d/src/vector.c
===================================================================
--- trunk/libs3d/libg3d/src/vector.c	2006-09-11 20:13:03 UTC (rev 380)
+++ trunk/libs3d/libg3d/src/vector.c	2006-09-15 16:23:16 UTC (rev 381)
@@ -63,7 +63,11 @@
 		result[i] = 0.0;
 
 		for(k = 0; k < 4; k ++)
+#if 0
 			result[i] += matrix[i * 4 + k] * vector[k];
+#else
+			result[i] += matrix[k * 4 + i] * vector[k];
+#endif
 	}
 
 	*x = result[0];



From dotslash at mail.berlios.de  Fri Sep 15 18:25:56 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Fri, 15 Sep 2006 18:25:56 +0200
Subject: [S3d-svn] r382 - trunk/libs3d
Message-ID: <200609151625.k8FGPu7o018688@sheep.berlios.de>

Author: dotslash
Date: 2006-09-15 18:25:56 +0200 (Fri, 15 Sep 2006)
New Revision: 382

Modified:
   trunk/libs3d/3dsread.c
Log:
-evil printf

Modified: trunk/libs3d/3dsread.c
===================================================================
--- trunk/libs3d/3dsread.c	2006-09-15 16:23:16 UTC (rev 381)
+++ trunk/libs3d/3dsread.c	2006-09-15 16:25:56 UTC (rev 382)
@@ -390,12 +390,11 @@
 			break;
 		  case 0x4150:
 			s3dprintf(VLOW,"-- smoothing group information (length %d [%d])", clen,clen/4);
-			printf( "-- smoothing group information (length %d [%d])", clen, clen/4 );
 			smooth_list=(unsigned long *)ptr;
 			for (j=0;j<(clen/4);j++)
 			{
 				smooth_list[j]=gintl(ptr+j*4);
-				printf( "smooth_list[%i] = %i", j, smooth_list[j] );
+				s3dprintf(VLOW, "smooth_list[%i] = %i", j, smooth_list[j] );
 			}
 
 			ptr=(char *)ptr+(clen-6);



From dotslash at mail.berlios.de  Fri Sep 15 18:41:00 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Fri, 15 Sep 2006 18:41:00 +0200
Subject: [S3d-svn] r383 - in trunk/libs3d/libg3d: . plugins/import
Message-ID: <200609151641.k8FGf0uf016962@sheep.berlios.de>

Author: dotslash
Date: 2006-09-15 18:40:59 +0200 (Fri, 15 Sep 2006)
New Revision: 383

Added:
   trunk/libs3d/libg3d/version_svn67
Removed:
   trunk/libs3d/libg3d/version - 0.0.3
Modified:
   trunk/libs3d/libg3d/plugins/import/Makefile.am
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
Log:
- it compiles!! :o

Modified: trunk/libs3d/libg3d/plugins/import/Makefile.am
===================================================================
--- trunk/libs3d/libg3d/plugins/import/Makefile.am	2006-09-15 16:25:56 UTC (rev 382)
+++ trunk/libs3d/libg3d/plugins/import/Makefile.am	2006-09-15 16:40:59 UTC (rev 383)
@@ -6,7 +6,6 @@
 	imp_ac3d.la \
 	imp_cob.la \
 	imp_dxf.la \
-	imp_flt.la \
 	imp_heightfield.la \
 	imp_iob.la \
 	imp_leocad.la \
@@ -18,8 +17,16 @@
 	imp_q3o.la \
 	imp_vrml.la
 
+# we are experimental ;D
+pluginimp_LTLIBRARIES += \
+	imp_flt.la \
+	imp_maya.la \
+	imp_r4.la \
+	imp_test.la
+
 AM_CFLAGS = \
 	-Wall -ansi -pedantic \
+	-DG_LOG_DOMAIN=\"LibG3D\" \
 	@DBG_CFLAGS@ -DDEBUG=@DEBUG@ \
 	@GLIB_CFLAGS@
 
@@ -37,22 +44,32 @@
 LIBTOOL += --quiet
 
 imp_3dmf_la_SOURCES = imp_3dmf.c
-imp_3ds_la_SOURCES = imp_3ds.c
+imp_3ds_la_SOURCES = imp_3ds.c imp_3ds.h imp_3ds_chunks.h \
+	imp_3ds_callbacks.c imp_3ds_callbacks.h
 imp_ac3d_la_SOURCES = imp_ac3d.c
 imp_cob_la_SOURCES = imp_cob.c
 imp_dxf_la_SOURCES = imp_dxf.c
 imp_flt_la_SOURCES = imp_flt.c
 imp_heightfield_la_SOURCES = imp_heightfield.c
-imp_iob_la_SOURCES = imp_iob.c
+imp_iob_la_SOURCES = imp_iob.c imp_iob.h imp_iob_chunks.h \
+	imp_iob_callbacks.c imp_iob_callbacks.h
 imp_leocad_la_SOURCES = imp_leocad.c imp_leocad_library.h imp_leocad_library.c
-imp_lwo_la_SOURCES = imp_lwo.c
+imp_lwo_la_SOURCES = imp_lwo.c imp_lwo.h imp_lwo_chunks.h \
+	imp_lwo_callbacks.c imp_lwo_callbacks.h
+imp_maya_la_SOURCES = imp_maya.c imp_maya_chunks.h \
+	imp_maya_callbacks.c imp_maya_callbacks.h \
+	imp_maya_obj.c imp_maya_obj.h \
+	imp_maya_var.c imp_maya_var.h
 imp_md2_la_SOURCES = imp_md2.c imp_md2_normals.h
 imp_md3_la_SOURCES = imp_md3.c
 imp_nff_la_SOURCES = imp_nff.c
 imp_obj_la_SOURCES = imp_obj.c
 imp_q3o_la_SOURCES = imp_q3o.c
+imp_r4_la_SOURCES = imp_r4.c imp_r4_chunks.h \
+	imp_r4_callbacks.c imp_r4_callbacks.h
 imp_vrml_la_SOURCES = imp_vrml_v1.l imp_vrml.c
 imp_vrml_la_LIBADD = ${LEXLIB}
+imp_test_la_SOURCES = imp_test.c
 
 # by default imp_vrml_v1.c seems to be included in package, so add .h too
 # also removes strong dependancy on flex

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 16:25:56 UTC (rev 382)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 16:40:59 UTC (rev 383)
@@ -398,26 +398,26 @@
 /* texture vertices */
 gboolean x3ds_cb_0x4150(x3ds_global_data *global, x3ds_parent_data *parent)
 {
-// 	G3DObject *object;
-// 	gint32 i;
-//
-// 	object = (G3DObject *)parent->object;
-// 	g_return_val_if_fail(object, FALSE);
-//
-// 	object->tex_vertex_count = g3d_read_int16_le(global->f);
-// 	parent->nb -= 2;
-//
-// 	object->tex_vertex_data = g_new0(gfloat, object->tex_vertex_count * 2);
-//
-// 	for(i = 0; i < object->tex_vertex_count; i ++)
-// 	{
-// 		object->tex_vertex_data[i * 2 + 0] = g3d_read_float_le(global->f);
-// 		object->tex_vertex_data[i * 2 + 1] = g3d_read_float_le(global->f);
-// 		parent->nb -= 8;
-//
-// 		if((i % 1000) == 0) x3ds_update_progress(global);
-// 	}
+/* 	G3DObject *object;
+ 	gint32 i;
 
+	object = (G3DObject *)parent->object;
+ 	g_return_val_if_fail(object, FALSE);
+
+ 	object->tex_vertex_count = g3d_read_int16_le(global->f);
+ 	parent->nb -= 2;
+
+ 	object->tex_vertex_data = g_new0(gfloat, object->tex_vertex_count * 2);
+
+ 	for(i = 0; i < object->tex_vertex_count; i ++)
+ 	{
+ 		object->tex_vertex_data[i * 2 + 0] = g3d_read_float_le(global->f);
+ 		object->tex_vertex_data[i * 2 + 1] = g3d_read_float_le(global->f);
+ 		parent->nb -= 8;
+
+ 		if((i % 1000) == 0) x3ds_update_progress(global);
+ 	}*/
+
 	return TRUE;
 }
 

Deleted: trunk/libs3d/libg3d/version - 0.0.3
===================================================================
--- trunk/libs3d/libg3d/version - 0.0.3	2006-09-15 16:25:56 UTC (rev 382)
+++ trunk/libs3d/libg3d/version - 0.0.3	2006-09-15 16:40:59 UTC (rev 383)
@@ -1 +0,0 @@
- 

Copied: trunk/libs3d/libg3d/version_svn67 (from rev 298, trunk/libs3d/libg3d/version - 0.0.3)



From dotslash at mail.berlios.de  Fri Sep 15 18:42:12 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Fri, 15 Sep 2006 18:42:12 +0200
Subject: [S3d-svn] r384 - trunk/libs3d/libg3d/include/g3d
Message-ID: <200609151642.k8FGgC1h018787@sheep.berlios.de>

Author: dotslash
Date: 2006-09-15 18:42:11 +0200 (Fri, 15 Sep 2006)
New Revision: 384

Removed:
   trunk/libs3d/libg3d/include/g3d/config.h
Log:
- automatically generated by autohell, we don't need to version this

Deleted: trunk/libs3d/libg3d/include/g3d/config.h
===================================================================
--- trunk/libs3d/libg3d/include/g3d/config.h	2006-09-15 16:40:59 UTC (rev 383)
+++ trunk/libs3d/libg3d/include/g3d/config.h	2006-09-15 16:42:11 UTC (rev 384)
@@ -1,149 +0,0 @@
-/* libs3d/libg3d/include/g3d/config.h.  Generated from config.h.in by configure.  */
-/* libs3d/libg3d/include/g3d/config.h.in.  Generated from configure.ac by autoheader.  */
-
-/* Use GLUT */
-/* #undef G_GLUT */
-
-/* Use SDL */
-#define G_SDL 1
-
-/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
-   */
-#define HAVE_DIRENT_H 1
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#define HAVE_DLFCN_H 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#define HAVE_INTTYPES_H 1
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
-/* #undef HAVE_NDIR_H */
-
-/* Define to 1 if you have the `select' function. */
-#define HAVE_SELECT 1
-
-/* Define to 1 if you have the `shmget' function. */
-#define HAVE_SHMGET 1
-
-/* Define to 1 if you have the `signal' function. */
-#define HAVE_SIGNAL 1
-
-/* Define to 1 if you have the `socket' function. */
-#define HAVE_SOCKET 1
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#define HAVE_STDINT_H 1
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the `strerror' function. */
-#define HAVE_STRERROR 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#define HAVE_STRINGS_H 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the `strtod' function. */
-#define HAVE_STRTOD 1
-
-/* Define to 1 if you have the `strtol' function. */
-#define HAVE_STRTOL 1
-
-/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
-   */
-/* #undef HAVE_SYS_DIR_H */
-
-/* Define to 1 if you have the <sys/ioctl.h> header file. */
-#define HAVE_SYS_IOCTL_H 1
-
-/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
-   */
-/* #undef HAVE_SYS_NDIR_H */
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#define HAVE_SYS_TIME_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#define HAVE_UNISTD_H 1
-
-/* Name of package */
-#define PACKAGE "s3d"
-
-/* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT ""
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME "s3d"
-
-/* Define to the full name and version of this package. */
-#define PACKAGE_STRING "s3d 0.1"
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME "s3d"
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION "0.1"
-
-/* Plugin directory */
-#define PLUGIN_DIR "/usr/local/lib/s3d/plugins"
-
-/* Define to 1 if the C compiler supports function prototypes. */
-#define PROTOTYPES 1
-
-/* Define as the return type of signal handlers (`int' or `void'). */
-#define RETSIGTYPE void
-
-/* Define to 1 if the `setvbuf' function takes the buffering type as its
-   second argument and the buffer pointer as the third, as on System V before
-   release 3. */
-/* #undef SETVBUF_REVERSED */
-
-/* Define if shared memory networking code should be compiled */
-#define SHM 1
-
-/* Define if signal code should be compiled */
-#define SIGS 1
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* Define if TCP/IP network code should be compiled */
-#define TCP 1
-
-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-#define TIME_WITH_SYS_TIME 1
-
-/* Define to 1 if your <sys/time.h> declares `struct tm'. */
-/* #undef TM_IN_SYS_TIME */
-
-/* Version number of package */
-#define VERSION "0.1"
-
-/* Define to 1 if the X Window System is missing or not being used. */
-/* #undef X_DISPLAY_MISSING */
-
-/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
-   `char[]'. */
-#define YYTEXT_POINTER 1
-
-/* Define like PROTOTYPES; this can be used by system headers. */
-#define __PROTOTYPES 1
-
-/* Define to empty if `const' does not conform to ANSI C. */
-/* #undef const */



From marec at mail.berlios.de  Fri Sep 15 18:47:40 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Fri, 15 Sep 2006 18:47:40 +0200
Subject: [S3d-svn] r385 - in trunk/libs3d/libg3d: . plugins/import src
Message-ID: <200609151647.k8FGleai027539@sheep.berlios.de>

Author: marec
Date: 2006-09-15 18:47:39 +0200 (Fri, 15 Sep 2006)
New Revision: 385

Removed:
   trunk/libs3d/libg3d/s3d/
   trunk/libs3d/libg3d/src/object-orig.c
Modified:
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
Log:
libg3d update II

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 16:42:11 UTC (rev 384)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 16:47:39 UTC (rev 385)
@@ -395,29 +395,18 @@
 	return TRUE;
 }
 
-/* texture vertices */
+/* smoothing groups */
 gboolean x3ds_cb_0x4150(x3ds_global_data *global, x3ds_parent_data *parent)
 {
-/* 	G3DObject *object;
- 	gint32 i;
 
+	G3DObject *object;
+
 	object = (G3DObject *)parent->object;
- 	g_return_val_if_fail(object, FALSE);
+	g_return_val_if_fail(object, FALSE);
 
- 	object->tex_vertex_count = g3d_read_int16_le(global->f);
- 	parent->nb -= 2;
+	/* g3d_read_int16_le(global->f) */
+	/* smooth list goes here face->normals */
 
- 	object->tex_vertex_data = g_new0(gfloat, object->tex_vertex_count * 2);
-
- 	for(i = 0; i < object->tex_vertex_count; i ++)
- 	{
- 		object->tex_vertex_data[i * 2 + 0] = g3d_read_float_le(global->f);
- 		object->tex_vertex_data[i * 2 + 1] = g3d_read_float_le(global->f);
- 		parent->nb -= 8;
-
- 		if((i % 1000) == 0) x3ds_update_progress(global);
- 	}*/
-
 	return TRUE;
 }
 

Deleted: trunk/libs3d/libg3d/src/object-orig.c
===================================================================
--- trunk/libs3d/libg3d/src/object-orig.c	2006-09-15 16:42:11 UTC (rev 384)
+++ trunk/libs3d/libg3d/src/object-orig.c	2006-09-15 16:47:39 UTC (rev 385)
@@ -1,368 +0,0 @@
-/* $Id: object.c,v 1.1.2.7 2006/01/23 16:38:47 dahms Exp $ */
-
-/*
-    libg3d - 3D object loading library
-
-    Copyright (C) 2005, 2006  Markus Dahms <mad at automagically.de>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-#include <string.h>
-#include <math.h>
-
-#include <g3d/types.h>
-#include <g3d/vector.h>
-#include <g3d/matrix.h>
-#include <g3d/face.h>
-
-void g3d_object_free(G3DObject *object)
-{
-	GSList *slist, *snext;
-	G3DMaterial *mat;
-	G3DFace *face;
-
-	if(object->name != NULL)
-		g_free(object->name);
-
-	/* materials */
-	slist = object->materials;
-	while(slist != NULL)
-	{
-		mat = (G3DMaterial*)slist->data;
-		snext = slist->next;
-		g_slist_free_1(slist);
-		slist = snext;
-	}
-
-	/* faces */
-	slist = object->faces;
-	while(slist != NULL)
-	{
-		face = (G3DFace*)slist->data;
-		g3d_face_free(face);
-		snext = slist->next;
-		g_slist_free_1(slist);
-		slist = snext;
-	}
-
-	/* vertices */
-	if(object->vertex_data != NULL) g_free(object->vertex_data);
-	if(object->tex_vertex_data != NULL) g_free(object->tex_vertex_data);
-	if(object->_normals != NULL) g_free(object->_normals);
-	if(object->_indices != NULL) g_free(object->_indices);
-	if(object->_materials != NULL) g_free(object->_materials);
-	if(object->_flags != NULL) g_free(object->_flags);
-
-	g_free(object);
-}
-
-gdouble g3d_object_radius(G3DObject *object)
-{
-	guint32 i;
-	gdouble max_radius = 0.0, r;
-	gfloat *v;
-
-	for(i = 0; i < object->vertex_count; i ++)
-	{
-		v = &object->vertex_data[i * 3];
-		r = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
-		if(r > max_radius)
-			max_radius = r;
-	}
-
-	return sqrt(max_radius);
-}
-
-gboolean g3d_object_scale(G3DObject *object, gfloat scale)
-{
-	guint32 i;
-	gfloat *matrix;
-
-	for(i = 0; i < object->vertex_count; i ++)
-	{
-		object->vertex_data[i * 3 + 0] *= scale;
-		object->vertex_data[i * 3 + 1] *= scale;
-		object->vertex_data[i * 3 + 2] *= scale;
-	}
-
-	if(object->transformation)
-	{
-		matrix = object->transformation->matrix;
-		g3d_matrix_translate(
-			- (matrix[12] - (matrix[12] * scale)),
-			- (matrix[13] - (matrix[13] * scale)),
-			- (matrix[14] - (matrix[14] * scale)),
-			matrix);
-	}
-
-	return TRUE;
-}
-
-#define G3D_OBJECT_TRANSFORM_NORMALS 0
-
-gboolean g3d_object_transform(G3DObject *object, gfloat *matrix)
-{
-	guint32 i;
-#if G3D_OBJECT_TRANSFORM_NORMALS
-	G3DFace *face;
-	GSList *fitem;
-#endif
-
-	/* transform vertices */
-	for(i = 0; i < object->vertex_count; i ++)
-	{
-		g3d_vector_transform(
-			&(object->vertex_data[i * 3 + 0]),
-			&(object->vertex_data[i * 3 + 1]),
-			&(object->vertex_data[i * 3 + 2]),
-			matrix);
-	}
-
-#if G3D_OBJECT_TRANSFORM_NORMALS
-	fitem = object->faces;
-	while(fitem)
-	{
-		face = (G3DFace *)fitem->data;
-
-		if(face->flags & G3D_FLAG_FAC_NORMALS)
-		{
-			for(i = 0; i < face->vertex_count; i ++)
-			{
-				g3d_vector_transform(
-					&(face->normals[i * 3 + 0]),
-					&(face->normals[i * 3 + 1]),
-					&(face->normals[i * 3 + 2]),
-					matrix);
-				g3d_vector_unify(
-					&(face->normals[i * 3 + 0]),
-					&(face->normals[i * 3 + 1]),
-					&(face->normals[i * 3 + 2]));
-			}
-		}
-
-		fitem = fitem->next;
-	}
-#endif
-
-	return TRUE;
-}
-
-G3DObject *g3d_object_duplicate(G3DObject *object)
-{
-	G3DObject *new;
-	G3DFace *face, *oface;
-	GSList *litem;
-
-	new = g_new0(G3DObject, 1);
-
-	/* name */
-	if(object->name)
-		new->name = g_strdup(object->name);
-
-	/* vertices */
-	new->vertex_count = object->vertex_count;
-	new->vertex_data = g_new0(gfloat, new->vertex_count * 3);
-	memcpy(new->vertex_data, object->vertex_data,
-		new->vertex_count * 3 * sizeof(gfloat));
-
-	/* texture stuff */
-	/* TODO: implement? */
-
-	/* faces */
-	litem = object->faces;
-	while(litem)
-	{
-		oface = (G3DFace *)litem->data;
-
-		face = g_new0(G3DFace, 1);
-		face->material = oface->material;
-		face->vertex_count = oface->vertex_count;
-		face->vertex_indices = g_new0(guint32, face->vertex_count);
-		memcpy(face->vertex_indices, oface->vertex_indices,
-			face->vertex_count * sizeof(guint32));
-		face->flags = oface->flags;
-		if(face->flags & G3D_FLAG_FAC_NORMALS)
-		{
-			face->normals = g_new0(gfloat, face->vertex_count * 3);
-			memcpy(face->normals, oface->normals,
-				face->vertex_count * 3 * sizeof(gfloat));
-		}
-		if(face->flags & G3D_FLAG_FAC_TEXMAP)
-		{
-			face->tex_image = oface->tex_image;
-			face->tex_vertex_count = oface->tex_vertex_count;
-			face->tex_vertex_data = g_new0(gfloat, face->tex_vertex_count * 2);
-			memcpy(face->tex_vertex_data, oface->tex_vertex_data,
-				face->tex_vertex_count * 2 * sizeof(gfloat));
-		}
-
-		new->faces = g_slist_prepend(new->faces, face);
-
-		litem = litem->next;
-	}
-
-	return new;
-}
-
-gboolean g3d_object_merge(G3DObject *o1, G3DObject *o2)
-{
-	G3DFace *face;
-	GSList *fitem;
-	guint32 i, voff, foff = 0;
-
-	/* copy vertices */
-	voff = o1->vertex_count;
-	o1->vertex_count += o2->vertex_count;
-
-	o1->vertex_data = g_realloc(o1->vertex_data,
-		o1->vertex_count * 3 * sizeof(gfloat));
-
-	memcpy(o1->vertex_data + voff * 3, o2->vertex_data,
-		o2->vertex_count * 3 * sizeof(gfloat));
-
-	/* attach faces to first object */
-	fitem = o2->faces;
-	while(fitem)
-	{
-		face = (G3DFace *)fitem->data;
-		foff ++;
-
-		if(face->vertex_count > 100)
-		{
-			g_printerr("face->vertex_count > 100: %d (%dth)",
-				face->vertex_count, foff);
-		}
-
-		for(i = 0; i < face->vertex_count; i ++)
-			face->vertex_indices[i] += voff;
-
-		o1->faces = g_slist_prepend(o1->faces, face);
-
-		fitem = fitem->next;
-	}
-
-	/* FIXME: clean up o2 or copy faces */
-
-	return TRUE;
-}
-
-gboolean g3d_object_smooth(G3DObject *object)
-{
-	/* FIXME: implement */
-	return FALSE;
-}
-
-gboolean g3d_object_optimize(G3DObject *object)
-{
-	G3DFace *face;
-	guint32 index = 0, i, j;
-	GSList *fitem;
-	gfloat nx, ny, nz;
-
-	/* count number of faces (optimized) */
-	object->_num_faces = 0;
-	fitem = object->faces;
-	while(fitem)
-	{
-		face = (G3DFace *)fitem->data;
-		object->_num_faces += face->vertex_count - 2;
-
-		fitem = fitem->next;
-	}
-
-	object->_normals = g_new0(gfloat, object->_num_faces * 9);
-	object->_materials = g_new0(G3DMaterial *, object->_num_faces);
-	object->_flags = g_new0(guint32, object->_num_faces);
-	object->_indices = g_new0(guint32, object->_num_faces * 3);
-	object->_tex_images = g_new0(guint32, object->_num_faces);
-	object->_tex_coords = g_new0(gfloat, object->_num_faces * 6);
-
-	/* copy faces */
-	fitem = object->faces;
-	while(fitem)
-	{
-		face = (G3DFace *)fitem->data;
-
-		/* generate default normal for face */
-		if(!(face->flags & G3D_FLAG_FAC_NORMALS))
-		{
-			if(!g3d_face_get_normal(face, object, &nx, &ny, &nz))
-			{
-				fitem = fitem->next;
-				object->_num_faces -= face->vertex_count - 2;
-			}
-
-			g3d_vector_unify(&nx, &ny, &nz);
-		}
-
-		for(i = 0; i < (face->vertex_count - 2); i ++)
-		{
-			object->_materials[index] = face->material;
-			object->_flags[index] = face->flags;
-
-			if(face->flags & G3D_FLAG_FAC_TEXMAP)
-				object->_tex_images[index] = face->tex_image->tex_id;
-
-			for(j = 0; j < 3; j ++)
-			{
-				/* vertex stuff */
-				if(j == 0)
-					object->_indices[index * 3] = face->vertex_indices[0];
-				else
-					object->_indices[index * 3+j] = face->vertex_indices[i+j];
-
-				/* normal stuff */
-				if(face->flags & G3D_FLAG_FAC_NORMALS)
-				{
-					object->_normals[(index * 3 + j) * 3 + 0] =
-						face->normals[(i + j) * 3 + 0];
-					object->_normals[(index * 3 + j) * 3 + 1] =
-						face->normals[(i + j) * 3 + 1];
-					object->_normals[(index * 3 + j) * 3 + 2] =
-						face->normals[(i + j) * 3 + 2];
-				}
-				else
-				{
-					object->_normals[(index * 3 + j) * 3 + 0] = nx;
-					object->_normals[(index * 3 + j) * 3 + 1] = ny;
-					object->_normals[(index * 3 + j) * 3 + 2] = nz;
-				}
-
-				/* texture stuff */
-				if(face->flags & G3D_FLAG_FAC_TEXMAP)
-				{
-					/* u */
-					object->_tex_coords[(index * 3 + j) * 2 + 0] =
-						(j == 0) ?
-							face->tex_vertex_data[0] :
-							face->tex_vertex_data[(i + j) * 2 + 0];
-					/* v */
-					object->_tex_coords[(index * 3 + j) * 2 + 1] =
-						(j == 0) ?
-							face->tex_vertex_data[1] :
-							face->tex_vertex_data[(i + j) * 2 + 1];
-				}
-			} /* j: 0 < 3 */
-
-			index ++;
-		} /* i: 0 < vertex_count - 2 */
-
-		fitem = fitem->next;
-	} /* while(fitem) */
-
-	return TRUE;
-}
-



From marec at mail.berlios.de  Fri Sep 15 19:47:17 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Fri, 15 Sep 2006 19:47:17 +0200
Subject: [S3d-svn] r386 - trunk/libs3d/libg3d/plugins/import
Message-ID: <200609151747.k8FHlH4P030706@sheep.berlios.de>

Author: marec
Date: 2006-09-15 19:47:17 +0200 (Fri, 15 Sep 2006)
New Revision: 386

Modified:
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
Log:
libg3d update III

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 16:47:39 UTC (rev 385)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 17:47:17 UTC (rev 386)
@@ -400,13 +400,27 @@
 {
 
 	G3DObject *object;
+	G3DFace *face;
+	GSList *oface;
+	gint32 chunk_length, i;
 
 	object = (G3DObject *)parent->object;
 	g_return_val_if_fail(object, FALSE);
 
-	/* g3d_read_int16_le(global->f) */
-	/* smooth list goes here face->normals */
+	oface = object->faces;
+	while ( oface->next ) {
+		oface = oface->next;
+	}
 
+	face = (G3DFace *)oface->data;
+	face->normals = g_malloc(chunk_length);
+	chunk_length = g3d_read_int16_le(global->f);
+
+	for ( i = 0; i < ( chunk_length / 4 ); i++ )
+	{
+		face->normals[i] = gintl(ptr+j*4);
+	}
+
 	return TRUE;
 }
 



From dotslash at mail.berlios.de  Fri Sep 15 19:50:15 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Fri, 15 Sep 2006 19:50:15 +0200
Subject: [S3d-svn] r387 - in trunk: example libs3d/libg3d/plugins/import
Message-ID: <200609151750.k8FHoFDZ031075@sheep.berlios.de>

Author: dotslash
Date: 2006-09-15 19:50:15 +0200 (Fri, 15 Sep 2006)
New Revision: 387

Modified:
   trunk/example/3dsloader_g3d.c
   trunk/libs3d/libg3d/plugins/import/Makefile.am
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
Log:
- added printfs to find why objects are sccaled :/

Modified: trunk/example/3dsloader_g3d.c
===================================================================
--- trunk/example/3dsloader_g3d.c	2006-09-15 17:47:17 UTC (rev 386)
+++ trunk/example/3dsloader_g3d.c	2006-09-15 17:50:15 UTC (rev 387)
@@ -134,6 +134,7 @@
 				/* push vertices */
 				for ( j = 0; j < object->vertex_count; j++ ) {
 					/* 3. and 4. param have to change places otherwise the object will be turned */
+					printf("vertex: %d/%d: %f %f %f\n",j, object->vertex_count, object->vertex_data[j * 3], object->vertex_data[j * 3 + 2], object->vertex_data[j * 3 + 1]);
 					s3d_push_vertex( obj_id, object->vertex_data[j * 3], object->vertex_data[j * 3 + 2], object->vertex_data[j * 3 + 1] );
 				}
 

Modified: trunk/libs3d/libg3d/plugins/import/Makefile.am
===================================================================
--- trunk/libs3d/libg3d/plugins/import/Makefile.am	2006-09-15 17:47:17 UTC (rev 386)
+++ trunk/libs3d/libg3d/plugins/import/Makefile.am	2006-09-15 17:50:15 UTC (rev 387)
@@ -24,10 +24,12 @@
 	imp_r4.la \
 	imp_test.la
 
+#	@DBG_CFLAGS@ -DDEBUG=@DEBUG@ 
+#	we currently have no global DEBUG in autohell, so we just turn it on
 AM_CFLAGS = \
 	-Wall -ansi -pedantic \
 	-DG_LOG_DOMAIN=\"LibG3D\" \
-	@DBG_CFLAGS@ -DDEBUG=@DEBUG@ \
+	@DBG_CFLAGS@ -DDEBUG=1 \
 	@GLIB_CFLAGS@
 
 INCLUDES = -I$(top_builddir)/libs3d/libg3d/include

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 17:47:17 UTC (rev 386)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 17:50:15 UTC (rev 387)
@@ -243,6 +243,8 @@
 		object->vertex_data[i * 3 + 0] = g3d_read_float_le(global->f);
 		object->vertex_data[i * 3 + 1] = g3d_read_float_le(global->f);
 		object->vertex_data[i * 3 + 2] = g3d_read_float_le(global->f);
+
+		printf("point array original vertex data: %f, %f, %f\n",object->vertex_data[i * 3 + 0], object->vertex_data[i * 3 + 1], object->vertex_data[i * 3 + 2]);
 		parent->nb -= 12;
 
 		if((i % 1000) == 0) x3ds_update_progress(global);



From dotslash at mail.berlios.de  Sat Sep 16 00:31:46 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 16 Sep 2006 00:31:46 +0200
Subject: [S3d-svn] r388 - trunk/libs3d/libg3d/plugins/import
Message-ID: <200609152231.k8FMVkRT024271@sheep.berlios.de>

Author: dotslash
Date: 2006-09-16 00:31:45 +0200 (Sat, 16 Sep 2006)
New Revision: 388

Modified:
   trunk/libs3d/libg3d/plugins/import/imp_3ds.c
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
Log:
- 3ds smoothing so far

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds.c	2006-09-15 17:50:15 UTC (rev 387)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds.c	2006-09-15 22:31:45 UTC (rev 388)
@@ -133,6 +133,13 @@
 				x3ds_chunks[i].container ? 'c' : ' ',
 				x3ds_chunks[i].callback ? 'f' : ' ',
 				x3ds_chunks[i].desc, chunk_len);
+			
+			if (chunk_id==0)
+			{
+				g_printerr("error: bad chunk id\n");
+		/*		return FALSE;*/
+				exit(-1);
+			}
 
 			subparent = g_new0(x3ds_parent_data, 1);
 			subparent->id = parent->id;

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 17:50:15 UTC (rev 387)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 22:31:45 UTC (rev 388)
@@ -1,4 +1,5 @@
 #include <string.h>
+#include <math.h>
 
 #include <g3d/read.h>
 #include <g3d/texture.h>
@@ -404,25 +405,125 @@
 	G3DObject *object;
 	G3DFace *face;
 	GSList *oface;
-	gint32 chunk_length, i;
+	gint32 i, j, k, n=0, polynum, group;
+	guint32 *smooth_list;
+	gfloat *pnormal_list, *v_t_buf;			 	
+	gfloat a[3],b[3], *p0,*p1,*p2,*r;
+	gfloat len;
 
+	/* read data */
 	object = (G3DObject *)parent->object;
 	g_return_val_if_fail(object, FALSE);
 
-	oface = object->faces;
-	while ( oface->next ) {
-		oface = oface->next;
+	oface=object->faces;
+	polynum=0;
+	for (oface=object->faces; oface != NULL ; oface=oface->next) polynum++; /* count polygons */
+
+	pnormal_list=	g_new(float, 3*polynum);							/* polygon normal list */
+	v_t_buf=		g_new0(float,3*object->vertex_count);				/* normals per vertice */
+	smooth_list = 	g_new(guint32, polynum);
+	printf("reading %d int32 values\n",polynum);
+	for ( i=0 ; i<polynum ; i++ ) {
+		smooth_list[i] = g3d_read_int32_le(global->f);
+		printf("smoothlist[%d] = %d\n",i,smooth_list[i]);
 	}
-
-	face = (G3DFace *)oface->data;
-	face->normals = g_malloc(chunk_length);
-	chunk_length = g3d_read_int16_le(global->f);
-
-	for ( i = 0; i < ( chunk_length / 4 ); i++ )
+	parent->nb -= polynum * 4;
+	/* first, we calculate the normal by the polygon vertices (just vector product) */
+	i=0;
+	for (oface=object->faces; oface != NULL ; oface=oface->next)
 	{
-		face->normals[i] = gintl(ptr+j*4);
+		face=(G3DFace *)oface->data;
+		r=&(pnormal_list[i*3]);
+		p0=&(object->vertex_data[3* face->vertex_indices[0]]);
+		p1=&(object->vertex_data[3* face->vertex_indices[1]]);
+		p2=&(object->vertex_data[3* face->vertex_indices[2]]);
+		
+		a[0]=p1[0] - p0[0];
+		a[1]=p1[1] - p0[1];
+		a[2]=p1[2] - p0[2];
+		b[0]=p2[0] - p0[0];
+		b[1]=p2[1] - p0[1];
+		b[2]=p2[2] - p0[2];
+		r[0]=a[1]*b[2] - a[2]*b[1];
+		r[1]=a[2]*b[0] - a[0]*b[2];
+		r[2]=a[0]*b[1] - a[1]*b[0];
+	
+		len=sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);
+		if (len!=0.0F)
+		{
+			r[0]=r[0]/len;
+			r[1]=r[1]/len;
+			r[2]=r[2]/len;
+		} else {
+			r[0]=r[1]=r[2]=0.0F;
+		}
+		face->flags|=G3D_FLAG_FAC_NORMALS;
+		i++;
 	}
+	do {
+		/* find a suitable group. -1 means we've already taken care */
+		group=-1;
+		for (i=0;i<polynum;i++)
+			if ((group=smooth_list[i])!=-1) /* found a group */
+				break;
+		/* handle this group */
+		if (group!=-1)
+		{
+			/* SMOOTH */
+			/*  this functions takes a shitload of arguments, but that's because of optimization.  */
+			/*  we add normals of the polygons's vertices so each vertex will finally have */
+			/*  the sum of the polygons normals where the vertex is part of. */
 
+			/* run0: clear the v_t_buf for this group */
+			for (i=0;i<object->vertex_count*3;i++)
+				v_t_buf[i]=0.0;
+			 /*  run1: add normals on themselves into the v_t_buf */
+			i=0;
+			for (oface=object->faces; oface != NULL ; oface=oface->next)
+			{
+				if (smooth_list[i]==group)
+				{
+					for (j=0;j<3;j++) /* for all 3 vertices of the polygon */
+					{
+						k=face->vertex_indices[j];
+						for (n=0;n<3;n++)
+							v_t_buf[ k*3+n ]+= pnormal_list[i*3 + n];
+					}
+				}
+				i++;
+			}
+			i=0;
+			 /*  run2: apply to the final vertex buffer */
+			for (oface=object->faces; oface != NULL ; oface=oface->next)
+			{
+				face=(G3DFace *)oface->data;
+				if (smooth_list[i]==group)
+				{
+					face->normals=g_new(gfloat,9);
+					for (j=0;j<3;j++)
+					{
+						k=face->vertex_indices[j];
+						len=sqrt(	v_t_buf[k*3]   * v_t_buf[k]+
+									v_t_buf[k*3+1] * v_t_buf[k*3+1]+
+									v_t_buf[k*3+2] * v_t_buf[k*3+2]);
+						if (len==0.0F)   /*  this should not happen. well ... */
+								for (n=0;n<3;n++)	v_t_buf[k*3 + n]=0;
+						else	for (n=0;n<3;n++)	v_t_buf[k*3 + n]/=len; /* normalize it */
+						
+						if (len!=0.0) 	memcpy(face->normals +j*3, v_t_buf+ 	k*3,sizeof(gfloat)*3);	/*  finally, we save the normal in our normal buffer */
+						else  			memcpy(face->normals +j*3, pnormal_list+i*3,sizeof(gfloat)*3);	/*  use the pbuf normal */
+					}
+					smooth_list[i]=-1; /* finished this polygon */
+				}
+				i++;
+			}
+			/* SMOOTH END */
+		}
+	} while (group!=-1);
+
+	g_free(pnormal_list);
+	g_free(v_t_buf);
+	g_free(smooth_list);
 	return TRUE;
 }
 



From dotslash at mail.berlios.de  Sat Sep 16 00:47:56 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 16 Sep 2006 00:47:56 +0200
Subject: [S3d-svn] r389 - trunk/libs3d/libg3d/plugins/import
Message-ID: <200609152247.k8FMlufB024456@sheep.berlios.de>

Author: dotslash
Date: 2006-09-16 00:47:55 +0200 (Sat, 16 Sep 2006)
New Revision: 389

Modified:
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
Log:
- imp_3ds chunk 4150, already smoothing something :)

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 22:31:45 UTC (rev 388)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 22:47:55 UTC (rev 389)
@@ -245,7 +245,6 @@
 		object->vertex_data[i * 3 + 1] = g3d_read_float_le(global->f);
 		object->vertex_data[i * 3 + 2] = g3d_read_float_le(global->f);
 
-		printf("point array original vertex data: %f, %f, %f\n",object->vertex_data[i * 3 + 0], object->vertex_data[i * 3 + 1], object->vertex_data[i * 3 + 2]);
 		parent->nb -= 12;
 
 		if((i % 1000) == 0) x3ds_update_progress(global);
@@ -423,10 +422,8 @@
 	v_t_buf=		g_new0(float,3*object->vertex_count);				/* normals per vertice */
 	smooth_list = 	g_new(guint32, polynum);
 	printf("reading %d int32 values\n",polynum);
-	for ( i=0 ; i<polynum ; i++ ) {
+	for ( i=0 ; i<polynum ; i++ ) 
 		smooth_list[i] = g3d_read_int32_le(global->f);
-		printf("smoothlist[%d] = %d\n",i,smooth_list[i]);
-	}
 	parent->nb -= polynum * 4;
 	/* first, we calculate the normal by the polygon vertices (just vector product) */
 	i=0;
@@ -466,6 +463,7 @@
 		for (i=0;i<polynum;i++)
 			if ((group=smooth_list[i])!=-1) /* found a group */
 				break;
+		printf("handling group %d\n",group);
 		/* handle this group */
 		if (group!=-1)
 		{
@@ -481,6 +479,7 @@
 			i=0;
 			for (oface=object->faces; oface != NULL ; oface=oface->next)
 			{
+				face=(G3DFace *) oface->data;
 				if (smooth_list[i]==group)
 				{
 					for (j=0;j<3;j++) /* for all 3 vertices of the polygon */
@@ -506,12 +505,15 @@
 						len=sqrt(	v_t_buf[k*3]   * v_t_buf[k]+
 									v_t_buf[k*3+1] * v_t_buf[k*3+1]+
 									v_t_buf[k*3+2] * v_t_buf[k*3+2]);
+						printf("vertex buffer : %f %f %f ... len = %f\n",v_t_buf[k*3],v_t_buf[k*3+1],v_t_buf[k*3+2],len);
 						if (len==0.0F)   /*  this should not happen. well ... */
 								for (n=0;n<3;n++)	v_t_buf[k*3 + n]=0;
 						else	for (n=0;n<3;n++)	v_t_buf[k*3 + n]/=len; /* normalize it */
 						
 						if (len!=0.0) 	memcpy(face->normals +j*3, v_t_buf+ 	k*3,sizeof(gfloat)*3);	/*  finally, we save the normal in our normal buffer */
-						else  			memcpy(face->normals +j*3, pnormal_list+i*3,sizeof(gfloat)*3);	/*  use the pbuf normal */
+						else  			{memcpy(face->normals +j*3, pnormal_list+i*3,sizeof(gfloat)*3);	/*  use the pbuf normal */
+							printf("using pnormal_list as fallback\n");
+						}
 					}
 					smooth_list[i]=-1; /* finished this polygon */
 				}



From marec at mail.berlios.de  Sat Sep 16 00:51:28 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Sat, 16 Sep 2006 00:51:28 +0200
Subject: [S3d-svn] r390 - in trunk/libs3d/libg3d: plugins/import src
Message-ID: <200609152251.k8FMpSpD029141@sheep.berlios.de>

Author: marec
Date: 2006-09-16 00:51:28 +0200 (Sat, 16 Sep 2006)
New Revision: 390

Modified:
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
   trunk/libs3d/libg3d/src/model.c
Log:
g3d scaling deactivated

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 22:47:55 UTC (rev 389)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 22:51:28 UTC (rev 390)
@@ -406,7 +406,7 @@
 	GSList *oface;
 	gint32 i, j, k, n=0, polynum, group;
 	guint32 *smooth_list;
-	gfloat *pnormal_list, *v_t_buf;			 	
+	gfloat *pnormal_list, *v_t_buf;
 	gfloat a[3],b[3], *p0,*p1,*p2,*r;
 	gfloat len;
 
@@ -424,6 +424,7 @@
 	printf("reading %d int32 values\n",polynum);
 	for ( i=0 ; i<polynum ; i++ ) 
 		smooth_list[i] = g3d_read_int32_le(global->f);
+
 	parent->nb -= polynum * 4;
 	/* first, we calculate the normal by the polygon vertices (just vector product) */
 	i=0;
@@ -434,7 +435,7 @@
 		p0=&(object->vertex_data[3* face->vertex_indices[0]]);
 		p1=&(object->vertex_data[3* face->vertex_indices[1]]);
 		p2=&(object->vertex_data[3* face->vertex_indices[2]]);
-		
+
 		a[0]=p1[0] - p0[0];
 		a[1]=p1[1] - p0[1];
 		a[2]=p1[2] - p0[2];
@@ -444,7 +445,7 @@
 		r[0]=a[1]*b[2] - a[2]*b[1];
 		r[1]=a[2]*b[0] - a[0]*b[2];
 		r[2]=a[0]*b[1] - a[1]*b[0];
-	
+
 		len=sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);
 		if (len!=0.0F)
 		{
@@ -457,6 +458,7 @@
 		face->flags|=G3D_FLAG_FAC_NORMALS;
 		i++;
 	}
+
 	do {
 		/* find a suitable group. -1 means we've already taken care */
 		group=-1;
@@ -509,7 +511,7 @@
 						if (len==0.0F)   /*  this should not happen. well ... */
 								for (n=0;n<3;n++)	v_t_buf[k*3 + n]=0;
 						else	for (n=0;n<3;n++)	v_t_buf[k*3 + n]/=len; /* normalize it */
-						
+
 						if (len!=0.0) 	memcpy(face->normals +j*3, v_t_buf+ 	k*3,sizeof(gfloat)*3);	/*  finally, we save the normal in our normal buffer */
 						else  			{memcpy(face->normals +j*3, pnormal_list+i*3,sizeof(gfloat)*3);	/*  use the pbuf normal */
 							printf("using pnormal_list as fallback\n");

Modified: trunk/libs3d/libg3d/src/model.c
===================================================================
--- trunk/libs3d/libg3d/src/model.c	2006-09-15 22:47:55 UTC (rev 389)
+++ trunk/libs3d/libg3d/src/model.c	2006-09-15 22:51:28 UTC (rev 390)
@@ -72,8 +72,8 @@
 	{
 		object = (G3DObject *)oitem->data;
 
-		g3d_object_scale(object, (10.0 / max_rad));
-		g3d_object_optimize(object);
+ 		g3d_object_scale(object, (10.0 / max_rad));
+ 		g3d_object_optimize(object);
 
 		objects_post_load(object->objects, max_rad);
 
@@ -165,14 +165,14 @@
 			return NULL;
 		}
 
-		/* center model */
-		g3d_model_center(model);
+		/* center model
+		g3d_model_center(model); */
 
-		/* get maximum radius of all objects */
-		max_rad = objects_max_radius(model->objects);
+		/* get maximum radius of all objects
+		max_rad = objects_max_radius(model->objects); */
 
-		/* scale and optimize objects */
-		objects_post_load(model->objects, max_rad);
+		/* scale and optimize objects
+		objects_post_load(model->objects, max_rad); */
 
 		/* save filename */
 		if(model->filename == NULL)



From dotslash at mail.berlios.de  Sat Sep 16 02:44:19 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 16 Sep 2006 02:44:19 +0200
Subject: [S3d-svn] r391 - in trunk: apps/dot_mcp apps/olsrs3d
	apps/s3d_x11gate apps/s3dfm apps/s3dgps apps/s3dvt example
	libs3d libs3d/libg3d/plugins/import
Message-ID: <200609160044.k8G0iJGV003229@sheep.berlios.de>

Author: dotslash
Date: 2006-09-16 02:44:17 +0200 (Sat, 16 Sep 2006)
New Revision: 391

Added:
   trunk/example/modelloader.c
Removed:
   trunk/example/3dsloader.c
   trunk/example/3dsloader_g3d.c
Modified:
   trunk/apps/dot_mcp/main.c
   trunk/apps/dot_mcp/menu.c
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/net.c
   trunk/apps/olsrs3d/process.c
   trunk/apps/olsrs3d/search.c
   trunk/apps/s3d_x11gate/s3d_x11gate.c
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/fs.c
   trunk/apps/s3dfm/icon.c
   trunk/apps/s3dfm/main.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dgps/s3dgps.c
   trunk/apps/s3dvt/main.c
   trunk/apps/s3dvt/terminal.c
   trunk/example/Makefile.am
   trunk/example/filebrowser.c
   trunk/example/hudtest.c
   trunk/example/katze.c
   trunk/example/linetest.c
   trunk/example/nichtsnutz.c
   trunk/example/ptrtest.c
   trunk/example/radius_test.c
   trunk/example/s3dclock.c
   trunk/example/snowman.c
   trunk/example/strtest.c
   trunk/example/texturetest.c
   trunk/example/widgets.c
   trunk/libs3d/3dsread.c
   trunk/libs3d/Makefile.am
   trunk/libs3d/libg3d/plugins/import/Makefile.am
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
   trunk/libs3d/s3d.h
Log:
- 3ds -> model
- now using new 3dsloader!! (yay)

Modified: trunk/apps/dot_mcp/main.c
===================================================================
--- trunk/apps/dot_mcp/main.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/dot_mcp/main.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,525 +0,0 @@
-/*
- * main.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of dot_mcp, a mcp for s3d.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * dot_mcp is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * dot_mcp is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with dot_mcp; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include <s3d.h>
-#include <s3d_keysym.h>
-#include "dot_mcp.h"
-#include <unistd.h>  /*  sleep() */
-#include <stdlib.h>  /*  free(), malloc() */
-#include <string.h>  /*  strncpy() */
-#include <stdio.h>  /*  printf() */
-#include <math.h>	/* sin(), cos() */
-#include <time.h>	/* nanosleep() */
-static struct timespec t={0,33*1000*1000}; 
-
-#define bsize 	0.2
-struct tver
-{
-	float x,y,z;
-};
-struct tver campos, camrot;
-float xdif=0,ydif=0;
-
-struct app {
-	unsigned int oid,oid_c;
-	float r;
-	int init;
-	float trans_x,trans_y,trans_z;
-	float textw;
-	char name[256]; 
-	int min_but,close_but,title;
-	int sphere;
-	struct app *next;
-};
-int ego_mode=0;
-float asp=1.0;
-struct app *apps=NULL;
-float bottom=-1.0;
-float left=-1.0;
-float zoom=5.0;
-int n_app=0;
-int rot_flag=0;
-struct app *focus=NULL;
-float focus_r=0;
-float alpha=0;
-unsigned int min_but,rotate,close_but,sphere,reset,menu=-1;
-
-void place_apps();
-
-#define SIDES	60
-#define RINGS	60
-int greentorus()
-{
-	int o,i,j;
-	float R,r,a;
-	float ia,ja,iap,jap;
-	float v[SIDES*RINGS*3];
-	float n[SIDES*12]; /* normals */
-	unsigned long l[SIDES*RINGS*6];
-	o=s3d_new_object();
-	R=100; /* outer radius */
-	r=100; /* inner radius */
-	a=M_PI/180;
-	s3d_push_material_a(o, 0.2,0.6,0.2,0.5,
-						   1  ,1  ,1  ,0.5,
-						   0.2,0.6,0.2,0.5);
-	for (i=0;i<RINGS;i++)
-	{
-		for (j=0;j<SIDES;j++)
-		{
-			ia=a*((float)i*360.0/RINGS);
-			ja=a*((float)j*360.0/SIDES);
-			iap=a*((float)(i+1)*360.0/RINGS);
-			jap=a*((float)(j+1)*360.0/SIDES);
-
-			v[i*SIDES*3+ j*3 +0]=(R+r*cos(ja))* cos(ia);
-			v[i*SIDES*3+ j*3 +1]=r*sin(ja);
-			v[i*SIDES*3+ j*3 +2]=(R+r*cos(ja))* sin(ia);
-		
-			l[i*SIDES*6+ j*6 +0]=i*SIDES+ j;
-			l[i*SIDES*6+ j*6 +1]=i*SIDES+ (j+1)%SIDES;
-			l[i*SIDES*6+ j*6 +2]=0;
-			l[i*SIDES*6+ j*6 +3]=i*SIDES+ j;
-			l[i*SIDES*6+ j*6 +4]=((i+1)%RINGS)*SIDES+ j;
-			l[i*SIDES*6+ j*6 +5]=0;
-			
-			n[j*12 +0] =R*r*cos(ja)*    cos(ia) + r*r*cos(ja)* cos(ia)*cos(ia);
-			n[j*12 +1] =R*r*sin(ja)*    cos(ia) + r*r*sin(ja)* cos(ia)*cos(ia);
-			n[j*12 +2] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
-			n[j*12 +3] =R*r*cos(jap)*    cos(ia)+ r*r*cos(jap)*cos(ia)*cos(ia);
-			n[j*12 +4] =R*r*sin(jap)*    cos(ia)+ r*r*sin(jap)*cos(ia)*cos(ia);
-			n[j*12 +5] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
-
-			n[j*12 +6] =R*r*cos(ja)*    cos(ia) + r*r*cos(ja)* cos(ia)*cos(ia);
-			n[j*12 +7] =R*r*sin(ja)*    cos(ia) + r*r*sin(ja)* cos(ia)*cos(ia);
-			n[j*12 +8] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
-			n[j*12 +9] =R*r*cos(ja)*    cos(iap)+ r*r*cos(ja)* cos(ia)*cos(iap);
-			n[j*12 +10]=R*r*sin(ja)*    cos(iap)+ r*r*sin(ja)* cos(ia)*cos(iap);
-			n[j*12 +11]=R*r*sin(iap) 			+ r*r*sin(iap)*cos(iap);
-		}
-		s3d_push_vertices(o,&v[i*SIDES*3],SIDES);
-		s3d_push_lines(o,   &l[i*SIDES*6],SIDES*2);
-		s3d_pep_line_normals(o,n,SIDES*2);
-	}
-/*	s3d_push_vertices(o,v,SIDES*RINGS);
-	s3d_push_lines(o,   l,SIDES*RINGS*2);*/
-
-	s3d_flags_on(o,S3D_OF_VISIBLE);
-	return(o);
-}
-void set_focus(struct app *a)
-{
-	if (focus!=a)
-		/* resetting old focus */
-		if (focus!=NULL)
-		{
-			printf("unfocusing app name %s\n",focus->name);
-			s3d_scale(focus->oid,1/focus->r);
-			s3d_scale(focus->sphere,focus->r);
-
-  			s3d_flags_on(focus->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_off(focus->min_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_translate(	focus->title,-focus->textw-1.2,0.0,0);
-			s3d_translate(	focus->close_but,bsize*focus->textw/2,1.2,0);
-			s3d_link(		focus->close_but,focus->sphere);
-			s3d_link(		focus->oid,0); 
-		}
-	focus=a;
-	if (a==NULL)
-	{
-		focus_r=n_app;
-		s3d_mcp_focus(-1);
-		s3d_flags_off(rotate,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_off(reset,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		rot_flag=0;
-	} else {
-		/* set the new focus app up */
-		s3d_translate(	a->title,-a->textw-9.6,0.0,0);
-		s3d_translate(	reset,-7.2,0.0,0);
-		s3d_translate(	rotate,-4.8,0.0,0);
-		s3d_translate(	a->min_but,-2.4,0.0,0);
-		s3d_link(		a->close_but,0);
-		s3d_link(		rotate,a->close_but);
-		s3d_link(		reset,a->close_but);
-		s3d_flags_on(	a->min_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(	rotate,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(	reset,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_off(	a->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_unlink(a->oid);
-		s3d_rotate(a->oid,		0,0,0);
-		s3d_translate(a->oid,	0,0,0);
-		focus_r=a->r;
-		s3d_scale(a->oid,1);
-		s3d_mcp_focus(	a->oid);
-	}
-	place_apps();
-}
-
-int add_app(struct app *a)
-{
-	struct app *prev=NULL,*a2=apps;
-	while ((a2)!=NULL)
-	{
-		prev=a2;
-		if (a2->oid==a->oid)
-		{  /*  already added, so free() and return */
-			free(a);
-			return(1);
-		}
-		a2=a2->next;  /*  go to the end */
-	}
-	a->next=NULL;
-	if (prev==NULL)
-		apps=a;
-	else 
-		prev->next=a;
-	n_app+=1;
-	return(0);
-}
-void *find_app(int oid)
-{
-	struct app *a=apps;
-	while (a!=NULL)
-	{
-		if (oid==a->oid)
-			break;
-		a=a->next;
-	}
-	return(a);
-}
-void *del_app(int oid)
-{
-	struct app *prev=NULL,*a=apps;
-	while ((a!=NULL)  && (a->oid!=oid))
-	{
-		prev=a;
-		a=a->next;
-	}
-	if (a!=NULL)
-	{  /*  found ... */
-		if (a->init)
-		{
-			s3d_del_object(a->close_but);
-			s3d_del_object(a->min_but);
-			s3d_del_object(a->title);
-			s3d_del_object(a->sphere);
-			s3d_del_object(a->oid);
-		}
-		if (prev==NULL) 
-			apps=a->next;  /*  new head */
-		else
-			prev->next=a->next;
-		n_app--;
-		if (focus==a)
-		{
-			set_focus(NULL);
-			focus=NULL;
-		}
-		free(a);
-		place_apps();
-	} 
-	return(a);
-}
-void stop()
-{
-	s3d_quit();
-}
-void place_apps()
-{
-	struct app *a=apps;
-	int j=0;
-	float u[3],v[3],ya,xa;
-	while (a!=NULL)
-	{
-		if (a->init)	
-		{
-/*			printf("placing app [%d,'%s'], oid %d, r=%f\n",j,a->name,a->oid,a->r); */
-			if (focus==a)
-			{
-				s3d_translate(a->close_but,(-left)*zoom-0.4,(-bottom)*zoom-0.4,-zoom);
-			}
-			else 
-			{
-				s3d_translate(	a->oid,	zoom*(left)+j*2+1.0,zoom*bottom+1.0,-zoom);
-				s3d_rotate(		a->oid,	0,10,0);
-				j++;
-			}
-		}
-		a=a->next;
-	}
-	s3d_translate(menu,	left*zoom+0.4,(-bottom)*zoom-0.4,-zoom);
-	
-	v[0]=0;				v[1]=0;					v[2]=1;
-	u[0]=left*zoom+0.4; u[1]=0;					u[2]=-zoom;
-	ya=s3d_vector_angle(v,u);
-	u[0]=0; 			u[1]=(-bottom)*zoom;	u[2]=-zoom;
-	xa=s3d_vector_angle(v,u);
-	s3d_rotate(menu, 0 ,30,0); 
-}
-void mcp_object(struct s3d_evt *hrmz)
-{
-	struct mcp_object *mo;
-	struct app *a;
-	mo=(struct mcp_object *)hrmz->buf;
-	if (NULL==(a=find_app(mo->object)))
-	{
-		printf("adding new object ......");
-		a=malloc(sizeof(struct app));
-		a->oid=mo->object;
-		a->r=mo->r;
-		strncpy(a->name,mo->name,256);
-		a->init=0;
-		add_app(a);
-		place_apps();
-		printf("..%s\n",a->name);
-	} else {
-/*		printf("updating app %d\n",a->oid);*/
-		a->trans_x=mo->trans_x;
-		a->trans_y=mo->trans_y;
-		a->trans_z=mo->trans_z;
-		a->r=mo->r;
-		if (a->init)
-		{
-			if (a==focus)
-			{
-				focus_r=a->r;
-			} else {
-				s3d_scale(a->sphere,a->r);
-				s3d_scale(a->oid,1/a->r);
-			}
-		}
-		place_apps();
-	}
-}
-void app_init(struct app *a)
-{
-	printf("building some window decorations on %d ['%s']\n",a->oid,a->name);
-	printf("radius of object %d is %f\n",a->oid,a->r);
-	s3d_scale(a->oid,		1/a->r);
-
-	a->sphere=s3d_clone(sphere);
-	s3d_scale(		a->sphere,a->r);
-	s3d_link(		a->sphere,a->oid);
-  	s3d_flags_on(	a->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-
-	a->title=s3d_draw_string(a->name,&a->textw);
-
-	a->close_but=s3d_clone(close_but);
-	s3d_translate(	a->close_but,bsize*a->textw/2.0,1.2f,0.0f);
-	s3d_link(		a->close_but,a->sphere);
-  	s3d_flags_on(	a->close_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-
-
-	s3d_translate(	a->title,-a->textw-1.2f,0.0f,0.0f);
-	s3d_link(		a->title,a->close_but);
-   	s3d_flags_on(	a->title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	
-	a->min_but=s3d_clone(min_but);
-	s3d_link(		a->min_but,a->close_but);
-	
-	
-	s3d_scale(		a->close_but,bsize);
-	
-	s3d_link(		a->oid,0);
-	a->init=1;
-/*	if (focus==NULL)
-		set_focus(a);
-	else*/
-		place_apps();
-}
-void mcp_del_object(struct s3d_evt *hrmz)
-{
-	struct mcp_object *mo;
-	printf("omg, something got deleted!!\n");
-	mo=(struct mcp_object *)hrmz->buf;
-	del_app(mo->object);
-}
-void object_click(struct s3d_evt *hrmz)
-{
-	struct app *a;
-	unsigned int i, oid;
-	oid=*((unsigned int *)hrmz->buf);
-	printf("%d got clicked\n",oid);
-	a=apps;i=0;
-	if (oid==rotate)
-	{
-		rot_flag=!rot_flag;
-		return;
-	}
-	if (oid==reset)
-	{
-		s3d_translate(0,0.0,0.0,5.0);
-		s3d_rotate(0,0,0,0);
-	}
-	while (a!=NULL)
-	{
-		if (oid==a->close_but)
-		{
-			del_app(a->oid);
-			return;
-		} else 	if (oid==a->min_but)
-		{
-			if (a==focus)
-			{
-				set_focus(NULL); /* nothing is focused now */
-			}
-			return;
-		} else 	if (((oid==a->title) || (oid==a->sphere)) || (oid==a->oid))
-		{
-			printf("giving focus to [%s], %d\n",a->name,oid);
-			set_focus(a);
-			return;
-		}
-		i++;
-		a=a->next;
-	}
-	menu_click(oid);
-}
-void object_info(struct s3d_evt *hrmz)
-{
-	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz->buf;
-	if (inf->object==0)
-	{
-		campos.x=inf->trans_x;
-		campos.y=inf->trans_y;
-		campos.z=inf->trans_z;
-		camrot.x=inf->rot_x;
-		camrot.y=inf->rot_y;
-		camrot.z=inf->rot_z;
-
-		if (asp!=inf->scale)
-		{
-			asp=inf->scale;
-			printf("screen aspect: %f\n",asp);
-			if (asp>1.0) /* wide screen */
-			{
-				bottom=-1.0;
-				left=-asp;
-			} else {  /* high screen */
-				bottom=(-1.0/asp);
-				left=-1.0;
-			}
-			place_apps(); /* replace apps */
-		}
-	}
-}
-void mainloop()
-{
-	struct app *a;
-	float al,r;
-	int i;
-	a=apps;i=0;
-	while (a!=NULL)
-	{
-		if (!a->init)
-			app_init(a);
-		i++;
-		a=a->next;
-	}
-	if (rot_flag)
-	{
-		al=(alpha*M_PI/180);
-		r=(focus_r>20.0)?20.0:focus_r;
-		s3d_translate(0,sin(al)*(r+5),0,cos(al)*(r+5));
-		s3d_rotate(0,0,alpha,0);
-		alpha=alpha+0.1;
-		if (alpha>360.0) alpha=0.0;
-	}
-	if (ego_mode)
-	{
-		if ((ydif!=0) || (xdif!=0))
-		{
-			campos.x+=ydif*sin((camrot.y*M_PI)/180);
-			campos.z+=ydif*cos((camrot.y*M_PI)/180);
-			campos.x+=xdif*cos((-camrot.y*M_PI)/180);
-			campos.z+=xdif*sin((-camrot.y*M_PI)/180);
-			campos.y+=ydif*sin((-camrot.x*M_PI)/180);
-			s3d_translate(	0,campos.x,campos.y,campos.z);
-		}
-	}
-	nanosleep(&t,NULL); 
-}
-
-void keydown(struct s3d_evt *event)
-{
-	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
-	switch (keys->keysym)
-	{
-		case S3DK_F1:  ego_mode=(ego_mode+1)%2;
-				 xdif=0;
-			     ydif=0;
-				 printf("ego mode %d\n",ego_mode);
-				 break;
-		case 'w':ydif+=-1.0;break;
-		case 'a':xdif+=-1.0;break;
-		case 's':ydif+= 1.0;break;
-		case 'd':xdif+= 1.0;break;
-	}
-}
-void keyup(struct s3d_evt *event)
-{
-	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
-	switch (keys->keysym)
-	{
-		case 'w':ydif-=-1.0;break;
-		case 'a':xdif-=-1.0;break;
-		case 's':ydif-= 1.0;break;
-		case 'd':xdif-= 1.0;break;
-	}
-
-}
-
-int main (int argc, char **argv)
-{
-	s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-	s3d_set_callback(S3D_MCP_OBJECT,mcp_object);
-	s3d_set_callback(S3D_EVENT_QUIT,stop);
-	s3d_set_callback(S3D_MCP_DEL_OBJECT,mcp_del_object);
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-	s3d_set_callback(S3D_EVENT_KEYDOWN,keydown);
-	s3d_set_callback(S3D_EVENT_KEYUP,keyup);
-
-	if (!s3d_init(&argc,&argv,"mcp"))	
-	{
-		greentorus(); /* just call ... */
-
-		if (s3d_select_font("vera"))
-		{
-			printf("font not found\n");
-		}
-		min_but=s3d_import_3ds_file("objs/btn_minimize.3ds");
-		rotate=s3d_import_3ds_file("objs/btn_rotate.3ds");
-		reset=s3d_import_3ds_file("objs/reset.3ds");
-		close_but=s3d_import_3ds_file("objs/btn_close.3ds");
-		sphere=s3d_import_3ds_file("objs/ringsystem.3ds");
-		menu=menu_init();
-		s3d_link(menu,0);
-		s3d_scale(menu,bsize);
-		place_apps();
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/apps/dot_mcp/menu.c
===================================================================
--- trunk/apps/dot_mcp/menu.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/dot_mcp/menu.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,111 +0,0 @@
-/*
- * menu.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of dot_mcp, a mcp for s3d.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * dot_mcp is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * dot_mcp is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with dot_mcp; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include "s3d.h"
-#include "dot_mcp.h"
-#include <unistd.h> /* fork(), execl() */
-#include <stdio.h> /* printf() */
-#include <stdlib.h> /* exit() */
-#include <string.h> /* strlen(),strncpy(), strncat() */
-struct menu_entry {
-	char *icon, *name, *path;
-	int icon_oid, str_oid;
-};
-static int go=-1;
-static int act;
-static struct menu_entry menu[]={
-		{"objs/comp.3ds","terminal","s3dvt",				0,0},
-		{"objs/comp.3ds","olsrs3d","olsrs3d",				0,0},
-		{"objs/comp.3ds","s3d_x11gate","s3d_x11gate",		0,0},
-		{"objs/comp.3ds","filebrowser","filebrowser",		0,0}, 
-		{"objs/comp.3ds","logout","LOGOUT",					0,0}, 
-};
-void menu_click(int oid)
-{
-	unsigned int i;
-	char exec[256];
-	printf("%d got clicked\n",oid);
-	if (oid==go)
-	{
-		act=!act;
-		for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++)
-		{
-			if (act)
-			{
-				s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-				s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			} else {
-				s3d_flags_off(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-				s3d_flags_off(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			}
-
-		}
-		return;
-	}
-	if (act)
-	{
-		for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++)
-		{
-			if ((oid==menu[i].icon_oid) || (oid==menu[i].str_oid))
-			{
-				if (0==strncmp(menu[i].path,"LOGOUT",6))
-				{
-					s3d_quit();
-					return;
-				}
-				strncpy(exec,menu[i].path,256);
-				strncat(exec,"> /dev/null 2>&1 &",256); /* ignoring output, starting in background */
-				printf("executing [%s]\n",exec);
-				system(exec);
-				return;
-			}
-		}
-	}
-}
-int menu_init ()
-{
-	int i,menu_o;
-	menu_o=s3d_new_object();
-	act=0; /* menu deactived */
-	go=s3d_import_3ds_file("objs/s3dstart.3ds");
-	s3d_flags_on(go,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	s3d_link(go,menu_o);
-	for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++)
-	{
-		if (-1==(menu[i].icon_oid=s3d_import_3ds_file(menu[i].icon)))
-				menu[i].icon_oid=s3d_new_object();
-		menu[i].str_oid=s3d_draw_string(menu[i].name,NULL);
-		s3d_link(menu[i].str_oid,menu[i].icon_oid);
-		s3d_link(menu[i].icon_oid,menu_o);
-		s3d_translate(menu[i].icon_oid,0,-3+(-3*i),0);
-		s3d_translate(menu[i].str_oid,2,0,0);
-/*		s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);*/
-		printf("menu item menu[%d], icon_oid=%d, icon_str=%d\n",i,menu[i].icon_oid,menu[i].str_oid);
-	}
-	return(menu_o);
-}
-
-

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/olsrs3d/main.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,1102 +0,0 @@
-/*
- * main.c
- *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *                         Marek Lindner <lindner_marek at yahoo.de>
- *                         Andreas Langer <andreas_lbg at gmx.de>
- *
- * This file is part of olsrs3d, an olsr topology visualizer for s3d.
- * See http://s3d.berlios.de/ for more updates.
- *
- * olsrs3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * olsrs3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include <stdio.h>
-#include <s3d.h>
-#include <s3d_keysym.h>
-#include <s3dw.h>
-#include <time.h>	      /* nanosleep() */
-#include <string.h>	/* strncpy() */
-#include <math.h>		/* sqrt() */
-#include <getopt.h>	/* getopt() */
-#include <stdlib.h>	/* exit() */
-#include "olsrs3d.h"
-#include "search.h"
-
-#define SPEED		10.0
-
-static struct timespec sleep_time = { 0, 100 * 1000 * 1000 };   /* 100 mili seconds */
-
-int Debug = 0;
-
-char Olsr_host[256];   /* ip or hostname of olsr node with running dot_draw plugin */
-
-struct olsr_con *Con_begin = NULL;   /* begin of connection list */
-struct olsr_node *Olsr_root = NULL;   /* top of olsr node tree */
-struct Obj_to_ip *Obj_to_ip_head, *Obj_to_ip_end, *List_ptr;   /* needed pointer for linked list */
-
-int Olsr_node_count = 0, Last_olsr_node_count = -1;
-int Olsr_node_count_obj = -1;
-int Olsr_ip_label_obj = -1;
-int Output_border[4];
-int *Olsr_neighbour_label_obj = NULL;
-int Size;
-
-
-int Net_read_count;
-int Output_block_counter = 0;
-int Output_block_completed = 0;
-
-int Olsr_node_obj, Olsr_node_inet_obj, Olsr_node_hna_net;
-
-float Asp = 1.0;
-float Bottom = -1.0;
-float Left = -1.0;
-
-float CamPosition[2][3];	/* CamPosition[trans|rot][x-z] */
-float CamPosition2[2][3];	/* CamPosition[trans|rot][x-z] */
-
-/* needed ? */
-/* float ZeroPosition[3] = {0,0,0};	 current position zero position */
-
-int ZeroPoint;   /* object zeropoint */
-float Zp_rotate = 0.0;
-int ColorSwitch = 0;   /* enable/disable colored olsr connections */
-int RotateSwitch = 0;
-float RotateSpeed = 0.5;
-float Factor = 0.6;	/* Factor in calc_olsr_node_mov */
-struct olsr_node *Olsr_node_pEtx;
-
-int Btn_close_id = -1;
-
-int Btn_close_obj;
-float Title_len;
-
-/***
- *
- * print usage info
- *
- ***/
-
-void print_usage( void ) {
-
-	printf( "Usage is olsrs3d [options] [-- [s3d options]]\n" );
-	printf( "olsrs3d options:\n" );
-	printf( "   -h\tprint this short help\n" );
-	printf( "   -d\tenable debug mode\n" );
-	printf( "   -H\tconnect to olsr node [default: localhost]\n" );
-	s3d_usage();
-
-}
-
-
-
-/***
- *
- * print error and exit
- *
- ***/
-
-void out_of_mem( void ) {
-
-	printf( "Sorry - you ran out of memory !\n" );
-	exit(8);
-
-}
-
-
-
-/***
- *
- * calculate distance between 2 vectors => http://en.wikipedia.org/wiki/Euclidean_distance
- *
- *   p1   =>   vector of node 1
- *   p2   =>   vector of node 2
- *
- *   return distance
- *
- ***/
-
-float dist(float p1[], float p2[])
-{
-	float p[3];
-	p[0]=p1[0]-p2[0];
-	p[1]=p1[1]-p2[1];
-	p[2]=p1[2]-p2[2];
-	return (sqrt(p[0]*p[0]   +  p[1]*p[1]  +  p[2]*p[2]));
-
-}
-
-
-
-/***
- *
- * calculate distance between 2 vectors and substract vector1 from vector2
- *  => http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction
- *
- *   p1   =>   vector of node 1
- *   p2   =>   vector of node 2
- *
- *   return distance
- *
- ***/
-
-float dirt(float p1[], float p2[], float p3[])
-{
-	float d;
-	d=dist(p1,p2);
-	if (d!=0.0)
-	{
-		p3[0]=p2[0]-p1[0];
-		p3[1]=p2[1]-p1[1];
-		p3[2]=p2[2]-p1[2];
-	} else {
-		p3[0]=p2[0]=p1[0]=0.0;
-	}
-	return(d);
-}
-
-
-
-/***
- *
- * calculate new movement of node by adding the product of the factor and the vector to the movement vector
- *  => http://en.wikipedia.org/wiki/Vector_%28spatial%29#Scalar_multiplication
- *
- *   mov  =>   current mov vector
- *   p    =>   vector of node
- *   fac  =>   factor which is
- *
- ***/
-
-void mov_add(float mov[], float p[], float fac)
-{
-/*	if (fac>1000)
-		return;
-	fac=1000; */
-	mov[0]+=fac*p[0];
-	mov[1]+=fac*p[1];
-	mov[2]+=fac*p[2];
-}
-
-
-
-/***
- *
- * check whether is a new / modified / vanished node and handle it accordingly
- *
- *   *olsr_node =>   pointer to current olsr_node
- *
- ***/
-
-void handle_olsr_node( struct olsr_node *olsr_node ) {
-
-	float distance, angle, angle_rad;
-	float tmp_mov_vec[3], desc_norm_vec[3] = {0,0,-1};
-	struct olsr_node *other_node;
-	struct Obj_to_ip *Obj_to_ip_curr;
-	struct olsr_neigh_list *olsr_neigh_list, *prev_olsr_neigh_list, *other_node_neigh_list, *tmp_olsr_neigh_list;
-
-	/* no more nodes left */
-	if ( olsr_node == NULL ) return;
-
-	/* olsr node vanished */
-	if ( ( olsr_node->last_seen < Output_block_counter - 1 ) && ( olsr_node->visible ) ) {
-
-		if ( Debug ) printf( "olsr node vanished: %s\n", olsr_node->ip );
-
-		Olsr_node_count--;
-
-		olsr_node->visible = 0;
-
-		/* delete shape */
-		if ( olsr_node->obj_id != -1 ) {
-
-			/* remove element from ob2ip list */
-			lst_del( olsr_node->obj_id );
-			/* remove object from s3d server */
-			s3d_del_object( olsr_node->obj_id );
-
-			olsr_node->obj_id = -1;
-
-		}
-
-		if ( olsr_node->desc_id != -1 ) {
-
-			s3d_del_object( olsr_node->desc_id );
-			olsr_node->desc_id = -1;
-
-		}
-
-		/* delete olsr connections of this node */
-		olsr_neigh_list = olsr_node->olsr_neigh_list;
-
-		while ( olsr_neigh_list != NULL ) {
-
-			/* get connection list of 'other' node */
-			if ( olsr_neigh_list->olsr_con->left_olsr_node == olsr_node ) {
-				other_node = olsr_neigh_list->olsr_con->right_olsr_node;
-			} else {
-				other_node = olsr_neigh_list->olsr_con->left_olsr_node;
-			}
-
-			/* find this connection in 'other' nodes connection list ... */
-			prev_olsr_neigh_list = NULL;
-			other_node_neigh_list = other_node->olsr_neigh_list;
-
-			while ( other_node_neigh_list != NULL ) {
-
-				if ( other_node_neigh_list->olsr_con == olsr_neigh_list->olsr_con ) {
-
-					/* and delete it ! */
-					if ( prev_olsr_neigh_list != NULL ) {
-						/* is first, any or last element in the list */
-						prev_olsr_neigh_list->next_olsr_neigh_list = other_node_neigh_list->next_olsr_neigh_list;
-					} else {
-						/* the only element in the list */
-						other_node->olsr_neigh_list = NULL;
-					}
-
-					free( other_node_neigh_list );
-
-					break;
-
-				}
-
-				prev_olsr_neigh_list = other_node_neigh_list;
-				other_node_neigh_list = other_node_neigh_list->next_olsr_neigh_list;
-
-			}
-
-			s3d_del_object( olsr_neigh_list->olsr_con->obj_id );
-
-			/* delete connection */
-			if ( olsr_neigh_list->olsr_con->prev_olsr_con != NULL ) olsr_neigh_list->olsr_con->prev_olsr_con->next_olsr_con = olsr_neigh_list->olsr_con->next_olsr_con;
-			if ( olsr_neigh_list->olsr_con->next_olsr_con != NULL ) olsr_neigh_list->olsr_con->next_olsr_con->prev_olsr_con = olsr_neigh_list->olsr_con->prev_olsr_con;
-
-			tmp_olsr_neigh_list = olsr_neigh_list;
-
-			olsr_neigh_list = olsr_neigh_list->next_olsr_neigh_list;
-
-			free( tmp_olsr_neigh_list->olsr_con );
-			free( tmp_olsr_neigh_list );
-
-		}
-
-		olsr_node->olsr_neigh_list = NULL;
-
-	} else if ( olsr_node->visible ) {
-
-		/* olsr node shape has been modified */
-		if ( olsr_node->node_type_modified ) {
-
-			/* delete old shape */
-			if ( olsr_node->obj_id != -1 ) {
-				/* remove element from ob2ip list */
-				lst_del( olsr_node->obj_id );
-				s3d_del_object( olsr_node->obj_id );
-			}
-
-			if ( olsr_node->desc_id != -1 ) s3d_del_object( olsr_node->desc_id );
-
-			/* create new shape */
-			if ( olsr_node->node_type == 1 ) {
-				/* olsr node offers internet access */
-				olsr_node->obj_id = s3d_clone( Olsr_node_inet_obj );
-			} else if ( olsr_node->node_type == 2 ) {
-				/* via hna announced network */
-				olsr_node->obj_id = s3d_clone( Olsr_node_hna_net );
-			} else {
-				/* normal olsr node */
-				olsr_node->obj_id = s3d_clone( Olsr_node_obj );
-			}
-
-			s3d_flags_on( olsr_node->obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-
-			/* link newly created object to ZeroPoint */
-			s3d_link( olsr_node->obj_id, ZeroPoint );
-			/* add object_id and olsr_node to linked list */
-			lst_add(olsr_node->obj_id,&olsr_node);
-
-			/* create olsr node text and attach (link) it to the node */
-			olsr_node->desc_id = s3d_draw_string( olsr_node->ip, &olsr_node->desc_length );
-			s3d_link( olsr_node->desc_id, olsr_node->obj_id );
-			s3d_translate( olsr_node->desc_id, - olsr_node->desc_length / 2, -2, 0 );
-			s3d_flags_on( olsr_node->desc_id, S3D_OF_VISIBLE );
-
-			olsr_node->node_type_modified = 0;
-
-		}
-
-
-		/* rotate node description so that they are always readable */
-		tmp_mov_vec[0] = CamPosition2[0][0] - olsr_node->pos_vec[0];
-		tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
-		tmp_mov_vec[2] = CamPosition2[0][2] - olsr_node->pos_vec[2];
-
-		angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
-
-		/* take care of inverse cosinus */
-		if ( tmp_mov_vec[0] > 0 ) {
-			angle_rad = 90.0/M_PI - angle;
-			angle = 180 - ( 180.0/M_PI * angle );
-		} else {
-			angle_rad = 90.0/M_PI + angle;
-			angle = 180 + ( 180.0/M_PI * angle );
-		}
-
-		s3d_rotate( olsr_node->desc_id, 0, angle , 0 );
-		s3d_translate( olsr_node->desc_id, -cos(angle_rad)*olsr_node->desc_length/2 ,-1.5, sin(angle_rad)*olsr_node->desc_length/2 );
-
-
-		/* drift away from unrelated nodes */
-		Obj_to_ip_curr = Obj_to_ip_head->next;
-		while ( Obj_to_ip_curr != Obj_to_ip_end ) {
-
-			/* myself ... */
-			if ( olsr_node != Obj_to_ip_curr->olsr_node ) {
-
-				olsr_neigh_list = olsr_node->olsr_neigh_list;
-				while ( olsr_neigh_list != NULL ) {
-
-					/* nodes are related */
-					if ( ( olsr_neigh_list->olsr_con->left_olsr_node->visible == 1 ) && ( olsr_neigh_list->olsr_con->right_olsr_node->visible == 1 ) ) {
-
-						if ( ( olsr_neigh_list->olsr_con->left_olsr_node == Obj_to_ip_curr->olsr_node ) || (  olsr_neigh_list->olsr_con->right_olsr_node == Obj_to_ip_curr->olsr_node ) ) break;
-
-					}
-
-					olsr_neigh_list = olsr_neigh_list->next_olsr_neigh_list;
-
-				}
-
-				/* nodes are not related - so drift */
-				if ( olsr_neigh_list == NULL ) {
-
-					distance = dirt( olsr_node->pos_vec, Obj_to_ip_curr->olsr_node->pos_vec, tmp_mov_vec );
-					if ( distance < 0.1 ) distance = 0.1;
-					mov_add( olsr_node->mov_vec, tmp_mov_vec,-100 / ( distance * distance ) );
-					mov_add( Obj_to_ip_curr->olsr_node->mov_vec, tmp_mov_vec, 100 / ( distance * distance ) );
-
-				}
-
-			}
-
-			Obj_to_ip_curr = Obj_to_ip_curr->next;
-
-		}
-
-	}
-
-	handle_olsr_node( olsr_node->left );
-	handle_olsr_node( olsr_node->right );
-
-}
-
-
-
-/***
- *
- * calculate movement vector of all olsr nodes
- *
- ***/
-
-void calc_olsr_node_mov( void ) {
-
-	float distance;
-	float tmp_mov_vec[3];
-	float f;
-	struct olsr_con *olsr_con = Con_begin;
-
-	while ( olsr_con != NULL ) {
-
-		distance = dirt( olsr_con->left_olsr_node->pos_vec, olsr_con->right_olsr_node->pos_vec, tmp_mov_vec );
-		f = ( ( olsr_con->left_etx_sqrt + olsr_con->left_etx_sqrt ) / 4.0 ) / distance;
-
-		/***
-		 * drift factor - 0.0 < factor < 1.0 ( best results: 0.3 < factor < 0.9
-		 * small factor: fast and strong drift to neighbours
-		 ***/
-		if ( f < Factor ) f = Factor;
-
-		mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, 1 / f - 1 );
-		mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, - ( 1 / f - 1 ) );
-
-		olsr_con = olsr_con->next_olsr_con;
-
-	}
-
-}
-
-
-
-/***
- *
- * move all olsr nodes and their connections
- *
- ***/
-
-void move_olsr_nodes( void ) {
-
-	float null_vec[3] = {0,0,0}, vertex_buf[6];
-	float tmp_mov_vec[3];
-	float distance, etx, rgb;
-	struct olsr_con *olsr_con = Con_begin;
-
-	while ( olsr_con != NULL ) {
-
-		/* move left olsr node if it has not been moved yet */
-		if ( !( ( olsr_con->left_olsr_node->mov_vec[0] == 0 ) && ( olsr_con->left_olsr_node->mov_vec[1] == 0 ) && ( olsr_con->left_olsr_node->mov_vec[2] == 0 ) ) && olsr_con->left_olsr_node->visible ) {
-
-			distance = dirt( olsr_con->left_olsr_node->pos_vec, null_vec, tmp_mov_vec );
-			mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, distance / 100 ); /* move a little bit to point zero */
-			mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, 1 ); /* move a little bit to point zero */
-
-			if ( ( distance = dist( olsr_con->left_olsr_node->mov_vec, null_vec ) ) > 10.0 ) {
-				mov_add( olsr_con->left_olsr_node->pos_vec, olsr_con->left_olsr_node->mov_vec, 1.0 / ( ( float ) distance ) );
-			} else {
-				mov_add( olsr_con->left_olsr_node->pos_vec, olsr_con->left_olsr_node->mov_vec, 0.1 );
-			}
-
-			s3d_translate( olsr_con->left_olsr_node->obj_id, olsr_con->left_olsr_node->pos_vec[0], olsr_con->left_olsr_node->pos_vec[1], olsr_con->left_olsr_node->pos_vec[2] );
-
-			/* reset movement vector */
-			olsr_con->left_olsr_node->mov_vec[0] = olsr_con->left_olsr_node->mov_vec[1] = olsr_con->left_olsr_node->mov_vec[2] = 0.0;
-
-		}
-
-		/* move right olsr node if it has not been moved yet */
-		if ( !( ( olsr_con->right_olsr_node->mov_vec[0] == 0 ) && ( olsr_con->right_olsr_node->mov_vec[1] == 0 ) && ( olsr_con->right_olsr_node->mov_vec[2] == 0 ) ) && olsr_con->right_olsr_node->visible ) {
-
-			distance = dirt( olsr_con->right_olsr_node->pos_vec, null_vec, tmp_mov_vec );
-			mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, distance / 100 ); /* move a little bit to point zero */
-			mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, 1 ); /* move a little bit to point zero */
-
-			if ( ( distance = dist( olsr_con->right_olsr_node->mov_vec, null_vec ) ) > 10.0 ) {
-				mov_add( olsr_con->right_olsr_node->pos_vec, olsr_con->right_olsr_node->mov_vec, 1.0 / ( ( float ) distance ) );
-			} else {
-				mov_add( olsr_con->right_olsr_node->pos_vec, olsr_con->right_olsr_node->mov_vec, 0.1 );
-			}
-
-			s3d_translate( olsr_con->right_olsr_node->obj_id, olsr_con->right_olsr_node->pos_vec[0], olsr_con->right_olsr_node->pos_vec[1], olsr_con->right_olsr_node->pos_vec[2] );
-
-			/* reset movement vector */
-			olsr_con->right_olsr_node->mov_vec[0] = olsr_con->right_olsr_node->mov_vec[1] = olsr_con->right_olsr_node->mov_vec[2] = 0.0;
-
-		}
-
-
-		/* move connection between left and right olsr node */
-		vertex_buf[0] = olsr_con->left_olsr_node->pos_vec[0];
-		vertex_buf[1] = olsr_con->left_olsr_node->pos_vec[1];
-		vertex_buf[2] = olsr_con->left_olsr_node->pos_vec[2];
-		vertex_buf[3] = olsr_con->right_olsr_node->pos_vec[0];
-		vertex_buf[4] = olsr_con->right_olsr_node->pos_vec[1];
-		vertex_buf[5] = olsr_con->right_olsr_node->pos_vec[2];
-
-		s3d_pep_vertices( olsr_con->obj_id, vertex_buf, 2 );
-
-
-		if ( ColorSwitch ) {
-
-			/* HNA */
-			if ( olsr_con->left_etx == -1000.00 ) {
-
-				if(olsr_con->color != 1) {
-					s3d_pep_material( olsr_con->obj_id,
-								   0.0,0.0,1.0,
-								   0.0,0.0,1.0,
-								   0.0,0.0,1.0);
-					olsr_con->color = 1;
-				}
-
-			} else {
-
-				etx = ( olsr_con->left_etx + olsr_con->right_etx ) / 2.0;
-
-				/* very good link - bright blue */
-				if ( ( etx >= 1.0 ) && ( etx < 1.5 ) ) {
-
-					if(olsr_con->color != 2) {
-						s3d_pep_material( olsr_con->obj_id,
-								0.5,1.0,1.0,
-								0.5,1.0,1.0,
-								0.5,1.0,1.0);
-						olsr_con->color = 2;
-					}
-
-				/* good link - bright yellow */
-				} else if ( ( etx >= 1.5 ) && ( etx < 2.0 ) ) {
-
-					rgb = 2.0 - etx;
-					if( olsr_con->color != 3 || (olsr_con->color == 3 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
-						s3d_pep_material( olsr_con->obj_id,
-								1.0,1.0,rgb,
-								1.0,1.0,rgb,
-								1.0,1.0,rgb);
-						olsr_con->color = 3;
-
-						olsr_con->rgb =  rgb;
-					}
-
-				/* not so good link - orange */
-				} else if ( ( etx >= 2.0 ) && ( etx < 3.0 ) ) {
-
-					rgb = 1.5 - ( etx / 2.0 );
-					if( olsr_con->color != 4 || (olsr_con->color == 4 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
-						s3d_pep_material( olsr_con->obj_id,
-								1.0,rgb,0.0,
-								1.0,rgb,0.0,
-								1.0,rgb,0.0);
-						olsr_con->color = 4;
-
-						olsr_con->rgb = rgb;
-					}
-
-				/* bad link (almost dead) - brown */
-				} else if ( ( etx >= 3.0 ) && ( etx < 5.0 ) ) {
-
-					rgb = 1.75 - ( etx / 4.0 );
-
-					if( olsr_con->color != 5 || (olsr_con->color == 5 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
-
-						s3d_pep_material( olsr_con->obj_id,
-								rgb,rgb - 0.5,0.0,
-								rgb,rgb - 0.5,0.0,
-								rgb,rgb - 0.5,0.0);
-						olsr_con->color = 5;
-
-						olsr_con->rgb = rgb;
-					}
-
-				/* zombie link - grey */
-				} else if ( ( etx >= 5.0 ) && ( etx < 1000.0 ) ) {
-
-					rgb = 1000.0 / ( 1500.0 + etx );
-
-					if( olsr_con->color != 6 || (olsr_con->color == 6 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
-
-						s3d_pep_material( olsr_con->obj_id,
-								rgb,rgb,rgb,
-								rgb,rgb,rgb,
-								rgb,rgb,rgb);
-						olsr_con->color = 6;
-
-						olsr_con->rgb = rgb;
-					}
-
-				/* wtf - dark grey */
-				} else {
-
-					if(olsr_con->color != 7) {
-						s3d_pep_material( olsr_con->obj_id,
-								0.3,0.3,0.3,
-								0.3,0.3,0.3,
-								0.3,0.3,0.3);
-						olsr_con->color = 7;
-					}
-
-				}
-
-			}
-
-		} else {
-
-			if(olsr_con->color != 0) {
-				s3d_pep_material( olsr_con->obj_id,
-							1.0,1.0,1.0,
-							1.0,1.0,1.0,
-							1.0,1.0,1.0);
-				olsr_con->color = 0;
-			}
-
-		}
-
-
-		olsr_con = olsr_con->next_olsr_con;
-
-	}
-
-}
-
-
-
-void mainloop() {
-
-	int net_result;   /* result of function net_main */
-	char nc_str[20];
-	float strLen;
-	
-	/* calculate new movement vector */
-	calc_olsr_node_mov();
-
-	/* prepare nodes */
-	handle_olsr_node( Olsr_root );
-
-	/* move it */
-	move_olsr_nodes();
-
-	/* if we have more or less nodes now - redraw node count */
-	if ( Olsr_node_count != Last_olsr_node_count ) {
-
-		if ( Olsr_node_count_obj != -1 ) s3d_del_object( Olsr_node_count_obj );
-		snprintf( nc_str, 20, "node count: %d", Olsr_node_count );
-		Olsr_node_count_obj = s3d_draw_string( nc_str, &strLen );
-		s3d_link( Olsr_node_count_obj, 0 );
-		s3d_flags_on( Olsr_node_count_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_node_count_obj, 0.2 );
-		s3d_translate( Olsr_node_count_obj, -Left*3.0-(strLen * 0.2), -Bottom*3.0-0.5, -3.0 );
-		Last_olsr_node_count = Olsr_node_count;
-
-	}
-
-	if ( Output_block_completed ) {
-
-		Output_block_counter++;
-		Output_block_completed = 0;
-
-	}
-
-	/* read data from socket */
-	Net_read_count = 0;
-	while ( ( net_result = net_main() ) != 0 ) {
-		if ( net_result == -1 ) {
-			s3d_quit();
-			break;
-		}
-	}
-	
-	/* rotate modus */
-	if(RotateSwitch) {
-		Zp_rotate = ( Zp_rotate + RotateSpeed ) > 360 ? 0.0 : ( Zp_rotate + RotateSpeed );	
-		s3d_rotate(ZeroPoint,0,Zp_rotate,0);
-	}
-
-	/* calc for node description */
-	CamPosition2[0][0]=  CamPosition[0][0]*cos(Zp_rotate*M_PI/180.0) - CamPosition[0][2] * sin (Zp_rotate*M_PI/180.0);
-	CamPosition2[0][1]=  CamPosition[0][1];
-	CamPosition2[0][2]=  CamPosition[0][0]*sin(Zp_rotate*M_PI/180.0) + CamPosition[0][2] * cos (Zp_rotate*M_PI/180.0);
-
-	/* check search status */
-	if( get_search_status() == WIDGET )
-		move_to_search_widget( CamPosition[0], CamPosition[1] );
-	if( get_search_status() == FOLLOW )
-		follow_node( CamPosition[0], CamPosition[1], Zp_rotate );
-	if( get_search_status() == ABORT )
-		move_to_return_point( CamPosition[0], CamPosition[1] );
-	
-
-	if( Olsr_ip_label_obj != -1 )
-	{
-		print_etx();
-	}
-
-	nanosleep( &sleep_time, NULL );
-
-	return;
-
-}
-
-void stop() {
-
-	s3d_quit();
-	net_quit();
-
-}
-
-/***
- *
- * eventhandler when key pressed
- *
- ***/
-
-void keypress(struct s3d_evt *event) {
-
-	struct s3d_key_event *key=(struct s3d_key_event *)event->buf;
-	printf("%d\n",key->unicode);	
-	if( get_search_status() != WIDGET )
-	{
-		switch(key->unicode)
-		{
-			case S3DK_ESCAPE: /* abort action */
-			
-				set_search_status( get_search_status() == WIDGET ? ABORT : NOTHING );
-				break;
-				
-			case S3DK_s: /* move to search widget, give widget focus */
-
-				set_search_status(WIDGET);							/* set status for mainloop */
-				set_return_point(CamPosition[0],CamPosition[1]);	/* save the return position */
-				set_node_root( Olsr_root );
-				break;
-			
-			case S3DK_c: /* color on/off */
-				
-				ColorSwitch =  ColorSwitch ? 0 : 1;
-				break;
-				
-			case S3DK_r: /* rotate start/stop*/
-				
-				RotateSwitch = RotateSwitch ? 0 : 1;
-				break;
-				
-			case S3DK_PLUS: /* rotate speed increase */
-				
-				if(RotateSwitch && RotateSpeed < 5)
-				{
-					if(RotateSpeed >= 1.0)
-						RotateSpeed += 1.0;
-					else
-						RotateSpeed += 0.1;
-					printf("%f,\n",RotateSpeed);
-				}
-				break;
-				
-			case S3DK_MINUS: /* - -> rotate speed decrease */
-				
-				if(RotateSwitch)
-				{
-					if( RotateSpeed >= 2.0 )
-						RotateSpeed -= 1.0;
-					else {
-						if(RotateSpeed > 0.2)
-							RotateSpeed -= 0.1;
-					}
-					printf("%f,\n",RotateSpeed);
-				}
-				break;
-				
-			case 16: /* strg + p -> reset nodes ( zeroPoint to 0,0,0 ) */
-				
-				s3d_rotate(ZeroPoint, 0, 0, 0);
-				Zp_rotate = 0.0;
-				break;
-				
-			case S3DK_PAGEUP: /* change factor in calc_olsr_node_mov */
-				
-				if(Factor < 0.9)
-					Factor += 0.1;
-				break;
-				
-			case S3DK_PAGEDOWN: /* change factor in calc_olsr_node_mov */
-				
-				if(Factor > 0.3)
-					Factor -= 0.1;
-				break;
-				
-		}
-	} else {
-		if( (key->unicode >= S3DK_PERIOD && key->unicode <= S3DK_9) || key->unicode == S3DK_COMMA || key->unicode == S3DK_RETURN || key->unicode == S3DK_BACKSPACE )
-			search_widget_write( key->unicode );
-	}
-}
-
-/***
- *
- * eventhandler when object clicked
- *
- ***/
-
-void object_click(struct s3d_evt *evt)
-{
-	int oid,i;
-	char ip_str[50];
-
-	if( get_search_status() == WIDGET )
-	{
-		s3dw_handle_click(evt);	
-		return;
-	}
-	
-	oid=(int)*((unsigned long *)evt->buf);
-
-	if( oid == Btn_close_id )
-	{
-		s3d_del_object(Btn_close_id);
-		s3d_del_object(Olsr_ip_label_obj);
-		Btn_close_id = Olsr_ip_label_obj = -1;
-		for(i=0; i < Size; i++)
-			s3d_del_object( Olsr_neighbour_label_obj[i] );
-		free(Olsr_neighbour_label_obj);
-		Olsr_neighbour_label_obj = NULL;
-		for(i = 0; i < 4; i++)
-		{
-			if(Output_border[i] != -1)
-				s3d_del_object(Output_border[i]);
-			Output_border[i] = -1;
-		}
-		return;
-	}
-
-	Olsr_node_pEtx = *lst_search(oid);
-
-	if( Olsr_node_pEtx != NULL )
-	{
-		if( Btn_close_id == -1 )
-		{
-			Btn_close_id = s3d_clone( Btn_close_obj );
-			s3d_link(Btn_close_id,0);
-			s3d_flags_on(Btn_close_id,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_scale( Btn_close_id, 0.10 );
-			s3d_translate( Btn_close_id,-Left*3.0-0.150, -Bottom*3.0-0.9, -3.0 );
-		}
-		
-		if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
-		snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
-		Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
-		s3d_link( Olsr_ip_label_obj, 0 );
-		s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_ip_label_obj, 0.2 );
-		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.2, -3.0 );
-		/*
-		cam_go=1;
-		if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
-		snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
-		Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
-		s3d_link( Olsr_ip_label_obj, 0 );
-		s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
-		s3d_scale( Olsr_ip_label_obj, 0.2 );
-		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
-		*/
-	} 
-}
-
-void print_etx()
-{
-	struct olsr_neigh_list *tmpNeighbour;
-	float p = 1.4;
-	int i;
-	float len = 0.0, max_len=0.0;
-
-	if( Olsr_neighbour_label_obj != NULL )
-	{
-		/* int n = sizeof(Olsr_neighbour_label_obj) / sizeof(int);*/
-		for(i=0; i < Size; i++)
-			s3d_del_object( Olsr_neighbour_label_obj[i] );
-		free(Olsr_neighbour_label_obj);
-		Olsr_neighbour_label_obj = NULL;
-	}
-
-	tmpNeighbour = Olsr_node_pEtx->olsr_neigh_list;
-
-	Size = 0;
-	while(tmpNeighbour != NULL)
-	{
-		Size++;
-		tmpNeighbour = tmpNeighbour->next_olsr_neigh_list;
-	}
-
-	Olsr_neighbour_label_obj = malloc(Size*sizeof(int));
-	tmpNeighbour = Olsr_node_pEtx->olsr_neigh_list;
-
-	for(i = 0; i < Size ;i++)
-	{
-		char nIpStr[60];
-		float mEtx = ( tmpNeighbour->olsr_con->left_etx + tmpNeighbour->olsr_con->right_etx ) / 2;
-
-		if( mEtx != -1000 )
-			snprintf(nIpStr, 60, "%15s --> %.2f",(strcmp(Olsr_node_pEtx->ip,tmpNeighbour->olsr_con->right_olsr_node->ip)?tmpNeighbour->olsr_con->right_olsr_node->ip:tmpNeighbour->olsr_con->left_olsr_node->ip),mEtx);
-		else
-			snprintf(nIpStr, 60, "%15s --> HNA",(strcmp(Olsr_node_pEtx->ip,tmpNeighbour->olsr_con->right_olsr_node->ip)?tmpNeighbour->olsr_con->right_olsr_node->ip:tmpNeighbour->olsr_con->left_olsr_node->ip));
-
-		Olsr_neighbour_label_obj[i] = s3d_draw_string( nIpStr, &len );
-		s3d_link(Olsr_neighbour_label_obj[i], 0);
-		s3d_flags_on(Olsr_neighbour_label_obj[i], S3D_OF_VISIBLE );
-		s3d_scale(Olsr_neighbour_label_obj[i], 0.2 );
-		s3d_translate(Olsr_neighbour_label_obj[i], -Left*3.0-(len * 0.2)-0.15, -Bottom*3.0-p, -3.0 );
-		tmpNeighbour = tmpNeighbour->next_olsr_neigh_list;
-		p += 0.2;
-		max_len = (len > max_len - 0.2)?len+0.2:max_len;
-		max_len = (Title_len > max_len - 0.2)?len+0.2:max_len;
-		/* printf("title: %f len: %f maxlen: %f %s\n",Title_len,len,max_len-0.2,nIpStr);*/
-	}
-
-	if( Btn_close_id != -1)
-	{
-		if( Output_border[0] == -1 )
-		{
-			for(i = 0; i < 4; i++)
-			{
-				Output_border[i] = s3d_new_object();
-				s3d_push_material( Output_border[i],
-					1.0,1.0,1.0,
-					1.0,1.0,1.0,
-					1.0,1.0,1.0);
-			}
-			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,			-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-1.0, -3.0);
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
-
-			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
-			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
-
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
-
-			s3d_push_line( Output_border[0], 0,1,0);
-			s3d_push_line( Output_border[1], 0,1,0);
-			s3d_push_line( Output_border[2], 0,1,0);
-			s3d_push_line( Output_border[3], 0,1,0);
-
-			s3d_flags_on( Output_border[0], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[1], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[2], S3D_OF_VISIBLE);
-			s3d_flags_on( Output_border[3], S3D_OF_VISIBLE);
-
-			s3d_link( Output_border[0], 0);
-			s3d_link( Output_border[1], 0);
-			s3d_link( Output_border[2], 0);
-			s3d_link( Output_border[3], 0);
-		} else {
-			s3d_pop_vertex(Output_border[0], 2);
-			s3d_pop_vertex(Output_border[1], 2);
-			s3d_pop_vertex(Output_border[2], 2);
-			s3d_pop_vertex(Output_border[3], 2);
-			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,				-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-1.0, -3.0);
-			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
-
-			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
-			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p,	 -3.0);
-
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
-			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	 -3.0);
-		}
-	}
-}
-
-
-
-/***
- *
- * eventhandler when object change by user
- * such as Cam
- *
- ***/
-
-void object_info(struct s3d_evt *hrmz)
-{
-	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz->buf;
-	if (inf->object==0)
-	{
-		CamPosition[0][0] = inf->trans_x;
-		CamPosition[0][1] = inf->trans_y;
-		CamPosition[0][2] = inf->trans_z;
-		CamPosition[1][0] = inf->rot_x;
-		CamPosition[1][1] = inf->rot_y;
-		CamPosition[1][2] = inf->rot_z;
-		Asp=inf->scale;
-		if (Asp>1.0) /* wide screen */
-		{
-			Bottom=-1.0;
-			Left=-Asp;
-		} else {  /* high screen */
-			Bottom=(-1.0/Asp);
-			Left=-1.0;
-
-		}
-
-	}
-	/* printf("%f %f %f\n",inf->trans_x,inf->trans_y,inf->trans_z); */
-}
-
-void mbutton_press(struct s3d_evt *hrmz)
-{
-	struct s3d_but_info *inf;
-	inf=(struct s3d_but_info *)hrmz->buf;
-	printf("button %d, state %d\n", inf->button,inf->state);
-	return;
-}
-
-int main( int argc, char *argv[] ) {
-
-	int optchar;
-	strncpy( Olsr_host, "127.0.0.1", 256 );
-	lbuf[0] = '\0';   /* init lbuf */
-
-	while ( ( optchar = getopt ( argc, argv, "dhH:" ) ) != -1 ) {
-
-		switch ( optchar ) {
-
-			case 'd':
-				Debug = 1;
-				break;
-
-			case 'H':
-				strncpy( Olsr_host, optarg, 256 );
-				break;
-
-			case 'h':
-			default:
-				print_usage();
-				return (0);
-
-		}
-
-	}
-
-	if ( Debug ) printf( "debug mode enabled ...\n" );
-
-	/* initialize obj2ip linked list */
-	lst_initialize();
-
-	/* delete olsrs3d options */
-	while ( ( optind < argc ) && ( argv[optind][0] != '-' ) ) optind++;   /* optind may point to ip addr of '-H' */
-	optind--;
-	argv[optind] = argv[0];   /* save program path */
-	argc -= optind;   /* jump over olsrs3d options */
-	argv += optind;
-
-	/* set extern int optind = 0 for parse_args in io.c */
-	optind = 0;
-
-
-	if (!net_init(Olsr_host))
-	{
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-		s3d_set_callback(S3D_EVENT_KEY,keypress);
-		s3d_set_callback(S3D_EVENT_QUIT,stop);
-
-		if (!s3d_init(&argc,&argv,"olsrs3d"))
-		{
-
-			if (s3d_select_font("vera"))
-				printf("font not found\n");
-
-			Olsr_node_obj = s3d_import_3ds_file( "objs/accesspoint.3ds" );
-			Olsr_node_inet_obj = s3d_import_3ds_file( "objs/accesspoint_inet.3ds" );
-			Olsr_node_hna_net = s3d_import_3ds_file( "objs/internet.3ds" );
-			Btn_close_obj = s3d_import_3ds_file( "objs/btn_close.3ds" );
-			create_search_widget( 0, 0, 300 );			
-			
-			ZeroPoint = s3d_new_object();
-			Output_border[0] = Output_border[1] = Output_border[2] = Output_border[3] = -1;
-			
-			s3d_mainloop(mainloop);
-			s3d_quit();
-			net_quit();
-		}
-	}
-	return(0);
-}
-

Modified: trunk/apps/olsrs3d/net.c
===================================================================
--- trunk/apps/olsrs3d/net.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/olsrs3d/net.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,129 +0,0 @@
-/*
- * net.c
- *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *                         Marek Lindner <lindner_marek at yahoo.de>
- *                         Andreas Langer <andreas_lbg at gmx.de>
- *
- * This file is part of olsrs3d, an olsr topology visualizer for s3d.
- * See http://s3d.berlios.de/ for more updates.
- *
- * olsrs3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * olsrs3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>	/* close() */
-#include <errno.h>
-#include <string.h> 	/* strlen(), memmove(), strncpy(), strncat() */
-#include <netdb.h>
-#include <sys/types.h>
-#include <netinet/in.h>
-#include <sys/socket.h>
-#include <fcntl.h>		/* fnctl() */
-#include "olsrs3d.h"
-
-#define PORT 2004 		/* the port client will be connecting to  */
-char buf[MAXDATASIZE];
-
-
-int sockfd, numbytes;
-int net_init(char *host)
-{
-    struct hostent *he;
-    struct sockaddr_in their_addr; /* connector's address information  */
-
-    if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
-        herror("gethostbyname");
-        return(1);
-    }
-
-    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
-        perror("socket");
-        return(1);
-    }
-
-    their_addr.sin_family = AF_INET;    /* host byte order  */
-    their_addr.sin_port = htons(PORT);  /* short, network byte order  */
-    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
-    memset(&(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
-
-    if (connect(sockfd, (struct sockaddr *)&their_addr,
-                                          sizeof(struct sockaddr)) == -1) {
-        perror("connect");
-        return(1);
-    }
-	fcntl(sockfd,F_SETFL, O_NONBLOCK);
-	return(0);
-}
-
-int net_main() {
-
-	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
-		if (errno==EAGAIN)
-			return(0); /* well, that's okay ... */
-		perror("recv");
-		return(-1);
-	}
-
-	if (numbytes==0) {
-		printf("connection reset\n");
-		return(-1);
-	}
-
-	buf[numbytes] = '\0';
-
-	/* check for potential buffer overflow */
-	if ( ( strlen( lbuf ) + strlen( buf ) ) < MAXLINESIZE ) {
-
-		strncat( lbuf, buf, MAXLINESIZE );
-
-	} else {
-
-		/* hope that carriage return is now in buf */
-		if ( strlen( lbuf ) < MAXLINESIZE ) {
-
-			if ( Debug ) printf( "WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n" );
-			strncat( lbuf, buf, MAXLINESIZE - strlen( lbuf ) );
-
-		} else {
-
-			if ( Debug ) printf( "ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n" );
-			strncpy( lbuf, buf, MAXLINESIZE );
-
-		}
-
-	}
-
-	process_main();
-
-	if ( ++Net_read_count > 5 ) {
-		return(0);   /* continue mainloop */
-	} else {
-		return(1);   /* continue reading data from socket */
-	}
-
-}
-
-int net_quit()
-{
-    close(sockfd);
-
-    return 0;
-}
-
-

Modified: trunk/apps/olsrs3d/process.c
===================================================================
--- trunk/apps/olsrs3d/process.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/olsrs3d/process.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,517 +0,0 @@
-/*
- * process.c
- *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *                         Marek Lindner <lindner_marek at yahoo.de>
- *                         Andreas Langer <andreas_lbg at gmx.de>
- *
- * This file is part of olsrs3d, an olsr topology visualizer for s3d.
- * See http://s3d.berlios.de/ for more updates.
- *
- * olsrs3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * olsrs3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include <stdio.h> 	/* NULL */
-#include <string.h> 	/* strlen(), memmove() */
-#include <stdlib.h> 	/* rand(), malloc(), realloc(), free() */
-#include <s3d.h>
-#include <math.h>       /* sqrt() */
-#include "olsrs3d.h"
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-
-
-char lbuf[MAXLINESIZE];
-
-
-
-/***
- *
- * create new or alter connection between 2 nodes
- *
- *   con_from =>   current node
- *   con_to   =>   node to connect to
- *   etx      =>   ETX
- *
- ***/
-
-int add_olsr_con( struct olsr_node *con_from, struct olsr_node *con_to, float etx ) {
-
-	struct olsr_con **olsr_con = &Con_begin;
-	struct olsr_con *prev_olsr_con = NULL;   /* previous olsr connection */
-	struct olsr_neigh_list **olsr_neigh_list;
-
-	while ( (*olsr_con) != NULL ) {
-
-		/* connection already exists */
-		if ( ( strncmp( (*olsr_con)->left_olsr_node->ip, con_from->ip, NAMEMAX ) == 0 ) && ( strncmp( (*olsr_con)->right_olsr_node->ip, con_to->ip, NAMEMAX ) == 0 ) ) {
-			(*olsr_con)->left_etx = etx;
-			(*olsr_con)->left_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
-			break;
-
-		} else if ( ( strncmp( (*olsr_con)->right_olsr_node->ip, con_from->ip, NAMEMAX ) == 0 ) && ( strncmp( (*olsr_con)->left_olsr_node->ip, con_to->ip, NAMEMAX ) == 0 ) ) {
-
-			(*olsr_con)->right_etx = etx;
-			(*olsr_con)->right_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
-			break;
-
-		}
-
-		/* save previous olsr connection for later use */
-		prev_olsr_con = (*olsr_con);
-
-		olsr_con = &(*olsr_con)->next_olsr_con;
-
-	}
-
-	/* new connection */
-	if ( (*olsr_con) == NULL ) {
-
-		(*olsr_con) = malloc( sizeof( struct olsr_con ) );
-		if ( (*olsr_con) == NULL ) out_of_mem();
-
-		/* create connection object */
-		(*olsr_con)->obj_id = s3d_new_object();
-
-		/* add olsr node to new olsr connection in order to access the nodes from the connection list */
-		(*olsr_con)->left_olsr_node = con_from;
-		(*olsr_con)->right_olsr_node = con_to;
-
-		/* add connection color */
-		(*olsr_con)->color = 0;
-		s3d_push_material( (*olsr_con)->obj_id,
-				  1.0,1.0,1.0,
-				  1.0,1.0,1.0,
-				  1.0,1.0,1.0);
-
-		/* add connection endpoints */
-		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->left_olsr_node->pos_vec[0], (*olsr_con)->left_olsr_node->pos_vec[1], (*olsr_con)->left_olsr_node->pos_vec[2] );
-		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->right_olsr_node->pos_vec[0], (*olsr_con)->right_olsr_node->pos_vec[1], (*olsr_con)->right_olsr_node->pos_vec[2] );
-
-		s3d_push_line( (*olsr_con)->obj_id, 0,1,0 );
-
-		s3d_flags_on( (*olsr_con)->obj_id, S3D_OF_VISIBLE );
-
-		s3d_link( (*olsr_con)->obj_id,  ZeroPoint );
-
-		/* HNA */
-		if ( etx == -1000.00 ) {
-
-			(*olsr_con)->left_etx = etx;
-			(*olsr_con)->left_etx_sqrt = 10.0;
-			(*olsr_con)->right_etx = etx;
-			(*olsr_con)->right_etx_sqrt = 10.0;
-
-		} else {
-
-			(*olsr_con)->left_etx = etx;
-			(*olsr_con)->left_etx_sqrt = sqrt( etx );
-			(*olsr_con)->right_etx = 999.0;
-			(*olsr_con)->right_etx_sqrt = sqrt( 999.0 );
-
-		}
-
-		(*olsr_con)->next_olsr_con = NULL;
-		(*olsr_con)->prev_olsr_con = prev_olsr_con;
-
-		/* add new olsr connection to olsr nodes in order to access the connection from the olsr node */
-		olsr_neigh_list = &(*olsr_con)->left_olsr_node->olsr_neigh_list;
-		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
-		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
-		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
-		(*olsr_neigh_list)->olsr_con = (*olsr_con);
-		(*olsr_neigh_list)->next_olsr_neigh_list = NULL;
-
-		olsr_neigh_list = &(*olsr_con)->right_olsr_node->olsr_neigh_list;
-		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
-		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
-		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
-		(*olsr_neigh_list)->olsr_con = (*olsr_con);
-		(*olsr_neigh_list)->next_olsr_neigh_list = NULL;
-
-	}
-
-	return(0);
-
-}
-
-
-
-/***
- *
- * get pointer to olsr node or create new node if node string could not be found
- *
- *   **node =>   pointer to current olsr_node
- *   *ip    =>   node ip
- *
- *   return olsr node pointer
- *
- ***/
-
-void *get_olsr_node( struct olsr_node **olsr_node, char *ip ) {
-
-	int result;   /* result of strcmp */
-
-	while ( (*olsr_node) != NULL ) {
-
-		result = strncmp( (*olsr_node)->ip, ip, NAMEMAX );
-
-		/* we found the node */
-		if ( result == 0 ) {
-
-			(*olsr_node)->last_seen = Output_block_counter;
-
-			/* former invisble (deleted) node */
-			if ( (*olsr_node)->visible == 0 ) {
-
-				(*olsr_node)->node_type = 0;
-				(*olsr_node)->node_type_modified = 1;
-
-				(*olsr_node)->visible = 1;
-
-				(*olsr_node)->mov_vec[0] = (*olsr_node)->mov_vec[1] = (*olsr_node)->mov_vec[2] = 0.0;
-
-				if ( Debug ) printf( "new olsr node: %s\n", (*olsr_node)->ip );
-
-				Olsr_node_count++;
-
-			}
-
-			return (*olsr_node);
-
-		}
-
-		/* the searched node must be in the subtree */
-		if ( result < 0 ) {
-			olsr_node = &(*olsr_node)->right;
-		} else {
-			olsr_node = &(*olsr_node)->left;
-		}
-
-	}
-
-	/* if node is NULL we reached the end of the tree and must create a new olsr_node */
-	if ( (*olsr_node) == NULL ) {
-
-		(*olsr_node) = malloc( sizeof( struct olsr_node ) );
-		if ( (*olsr_node) == NULL ) out_of_mem();
-
-		(*olsr_node)->left = NULL;
-		(*olsr_node)->right = NULL;
-
-		strncpy( (*olsr_node)->ip, ip, NAMEMAX );
-
-		(*olsr_node)->node_type = 0;
-		(*olsr_node)->node_type_modified = 1;
-
-		(*olsr_node)->last_seen = Output_block_counter;
-		(*olsr_node)->visible = 1;
-
-		if ( Debug ) printf( "new olsr node: %s\n", (*olsr_node)->ip );
-
-		Olsr_node_count++;
-
-		(*olsr_node)->pos_vec[0] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)->pos_vec[1] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)->pos_vec[2] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
-		(*olsr_node)->mov_vec[0] = (*olsr_node)->mov_vec[1] = (*olsr_node)->mov_vec[2] = 0.0;
-
-		(*olsr_node)->obj_id = -1;
-		(*olsr_node)->desc_id = -1;
-		(*olsr_node)->olsr_neigh_list = NULL;
-
-		return (*olsr_node);
-
-	}
-	return(0);
-}
-
-/*
- *
- * initialize the struct for a linked list obj2ip
- *
- */
-
-void lst_initialize() {
-	Obj_to_ip_head = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	Obj_to_ip_end = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	if(Obj_to_ip_head == NULL || Obj_to_ip_end == NULL)
-		out_of_mem();
-	Obj_to_ip_head->id = 0;
-	Obj_to_ip_end->id = 0;
-	Obj_to_ip_head->prev = Obj_to_ip_end->prev = Obj_to_ip_head;
-	Obj_to_ip_head->next = Obj_to_ip_end->next = Obj_to_ip_end;
-	List_ptr = Obj_to_ip_head;
-}
-
-/*
- *
- * add a link object_id to olsr_node, to get ip adress and coordinates per object_id
- *                 id => object_id, returned from s3d_clone or s3d_new_object
- *  **olsr_node => pointer to pointer of current olsr_node
- *
- */
-
-void lst_add(int id,struct olsr_node **olsr_node) {
-	struct Obj_to_ip *new;
-	new = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
-	if(new == NULL)
-		out_of_mem();
-	new->id = id;
-	new->olsr_node = *olsr_node;
-	move_lst_ptr(&id);
-	new->prev = List_ptr;
-	new->next = List_ptr->next;
-	List_ptr->next->prev = new;
-	List_ptr->next = new;
-	/* printf("obj2ip: add object %d between %d .. %d ip %s to list\n",new->id,new->prev->id,new->next->id,new->olsr_node->ip); */
-}
-
-/*
- *void move_lst_ptr(int *id)
- * remove element from obj2ip linked list
- * id => object_id, returned from s3d_clone or s3d_new_object
- *
- */
-
-void lst_del(int id) {
-	struct Obj_to_ip *del;
-	move_lst_ptr(&id);
-	if(id != List_ptr->id)
-	{
-		printf("obj2ip: remove id %d failed move_lst_ptr return id %d\n",id,List_ptr->next->id);
-	} else {
-		del = List_ptr;
-		List_ptr->next->prev = List_ptr->prev;
-		List_ptr->prev->next = List_ptr->next;
-		/* printf("obj2ip: remove object %d --> %d <-- %d ip %s from list\n",List_ptr->prev->id,del->id,List_ptr->next->id,del->olsr_node->ip); */
-		free(del);
-	}
-}
-
-/*
- *
- * move the List_ptr one positon ahead the searched element
- *	*id => pointer of object_id , returned from s3d_clone or s3d_new_object
- *
- */
-
-void move_lst_ptr(int *id) {
-	/* printf("obj2ip: move for %d\n",*id); */
-	/* head to point at end or id lass then first element in linked list*/
-	if(Obj_to_ip_head->next == Obj_to_ip_head || *id < Obj_to_ip_head->next->id)
-		List_ptr = Obj_to_ip_head;
- 	/* id is greather then last element in linked list */
-	else if(*id > Obj_to_ip_end->prev->id)
-		List_ptr = Obj_to_ip_end->prev;
-	else {
-		/* printf("obj2ip: ok i search deeper ;-) for id=%d\n",*id); */
-		if((*id - (int) Obj_to_ip_head->next->id) <= ((int)(Obj_to_ip_end->prev->id)-*id)) {
-			List_ptr = Obj_to_ip_head;
-			/* printf("obj2ip: start at head id %d - %d <= %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id); */
-			while(*id >= List_ptr->next->id) {
-				/* printf("obj2ip: %d > %d move to ",*id,List_ptr->id); */
-				List_ptr = List_ptr->next;
-				/* printf("%d\n",List_ptr->id); */
-			}
-		} else {
-			List_ptr = Obj_to_ip_end;
-			/* printf("obj2ip: start at end id %d - %d > %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id);  */
-			/*  do List_ptr = List_ptr->prev; while(*id > List_ptr->prev->id); */
-			while(*id < List_ptr->prev->id) {
-				/* printf("obj2ip: %d < %d move to ",*id,List_ptr->id); */
-				List_ptr = List_ptr->prev;
-				/* printf("%d\n",List_ptr->id); */
-			}
-			List_ptr = List_ptr->prev;
-		}
-		/* printf("obj2ip: found id to insert between %d--> .. <--%d to search/delete %d--> .. <--%d\n",List_ptr->id,List_ptr->next->next->id,List_ptr->prev->id,List_ptr->next->id); */
-	}
-}
-
-/*
- *
- * search a object_id in linked list and return pointer on struct olsr_node
- *	id => object_id , returned from s3d_clone or s3d_new_object
- *
- * <example>
- *     struct olsr_node *olsr_node;
- *     olsr_node = *lst_search(oid);
- *     printf("obj2ip: search return %s\n",olsr_node->ip);
- * </example>
- *
- */
-
-struct olsr_node **lst_search(int id) {
-	move_lst_ptr(&id);
-	/* TODO: return NULL when no node found */
-	/* if(id != List_ptr->id) */
-		/* printf("obj2ip: search id....id not found\n"); */
-	/* else */
-		/* printf("obj2ip: search found objekt_id=%d objekt_ip=%s\n",List_ptr->id,List_ptr->olsr_node->ip); */
-	return(&List_ptr->olsr_node);
-}
-
-void lst_out() {
-	struct Obj_to_ip *ptr;
-	ptr = Obj_to_ip_head;
-	while(ptr != ptr->next) {
-		printf("id-> %d\n",ptr->id);
-		ptr = ptr->next;
-	}
-}
-
-int process_main() {
-
-	int dn;
-	float f;
-	char *lbuf_ptr, *last_cr_ptr, *con_from, *con_from_end, *con_to, *con_to_end, *etx, *etx_end, *tmpChar;
-	struct olsr_node *olsr_node1;   /* pointer to olsr nodes */
-	struct olsr_node *olsr_node2;
-	int address;
-	char hna_name[NAMEMAX];
-	char hna_node[NAMEMAX];
-
-	lbuf_ptr = lbuf;
-	last_cr_ptr = NULL;
-
-	con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
-	dn = 0;
-
-	/*printf("---lbuf-start---\n%s\n---lbuf-end---\n",lbuf);*/
-
-	while ( (*lbuf_ptr) != '\0' ) {
-
-		/* printf( "%c",(*lbuf_ptr) ); */
-
-		if ( (*lbuf_ptr) == '\n' ) {
-
-			last_cr_ptr = lbuf_ptr;
-			con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
-			dn = 0;
-
-		}
-
-		if ( (*lbuf_ptr) == '"' ) {
-
-			switch ( dn ) {
-
-				case 0:
-					con_from = lbuf_ptr + 1;
-					break;
-				case 1:
-					con_from_end = lbuf_ptr;
-					break;
-				case 2:
-					con_to = lbuf_ptr + 1;
-					break;
-				case 3:
-					con_to_end = lbuf_ptr;
-					break;
-				case 4:
-					etx = lbuf_ptr + 1;
-					break;
-				case 5:
-					etx_end = lbuf_ptr;
-					break;
-
-			}
-
-			if ( ++dn == 6 ) {
-
-				/* terminate strings - but not before 6 times '"' */
-				(*con_from_end) = (*con_to_end) = (*etx_end) = '\0';
-
-				/* printf( "con_from: %s, con_to: %s, etx: %s\n", con_from, con_to, etx ); */
-
-				/* announced network via HNA */
-				if ( strncmp( etx, "HNA", NAMEMAX ) == 0 ) {
-
-					/* connection to internet */
-					if ( strncmp( con_to, "0.0.0.0/0.0.0.0", NAMEMAX ) == 0 ) {
-
-						olsr_node1 = get_olsr_node( &Olsr_root, con_from );
-
-						if ( olsr_node1->node_type != 1 ) {
-
-							olsr_node1->node_type = 1;
-							olsr_node1->node_type_modified = 1;
-							if ( Debug ) printf( "new internet: %s\n", olsr_node1->ip );
-
-						}
-
-					/* normal HNA */
-					} else {
-						memmove(hna_node,con_to,NAMEMAX);
-						if( (tmpChar = strchr(hna_node, (int)'/')))
-						{
-							tmpChar++;
-							address = (int)-inet_network(tmpChar);
-							sprintf(hna_name,"%d",(int)(32 - ceil(log(address)/log(2))));
-							strcpy(tmpChar,hna_name);
-						}
-
-						olsr_node1 = get_olsr_node( &Olsr_root, con_from );
-						olsr_node2 = get_olsr_node( &Olsr_root, hna_node );
-
-						if ( olsr_node2->node_type != 2 ) {
-
-							olsr_node2->node_type = 2;
-							olsr_node2->node_type_modified = 1;
-							if ( Debug ) printf( "new hna network: %s\n", olsr_node2->ip );
-
-						}
-						if ( olsr_node1->visible && olsr_node2->visible )
-							add_olsr_con( olsr_node1, olsr_node2, -1000.00 );
-
-					}
-
-				/* normal node */
-				} else {
-
-					olsr_node1 = get_olsr_node( &Olsr_root, con_from );
-					olsr_node2 = get_olsr_node( &Olsr_root, con_to );
-					f = strtod(etx,NULL);
-					if ( f < 1.0 )
-						f = 999.0;
-					add_olsr_con( olsr_node1, olsr_node2, f );
-				}
-				/* remove zerobyte */
-				(*con_from_end) = (*con_to_end) = (*etx_end) = '"';
-
-				con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
-				dn = 0;
-				last_cr_ptr = lbuf_ptr;
-
-			}
-
-		} else if ( ( (*lbuf_ptr) == '}' ) && ( (*(lbuf_ptr + 1)) == '\n' ) ) {
-
-			Output_block_completed = 1;
-
-		}
-
-		lbuf_ptr++;
-
-	}
-
-	if ( last_cr_ptr != NULL ) memmove( lbuf, last_cr_ptr + 1, strlen( last_cr_ptr ) );
-	/*printf("---memmove-lbuf-start---\n%s\n---memmove-lbuf-end---\n",lbuf);*/
-	return(0);
-
-}

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/olsrs3d/search.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,304 +0,0 @@
-/*
- * search.c
- * 
- * Copyright (C) 2006 Andreas Langer <andreas_lbg at gmx.de>
- *
- * This file is part of the olsrs3d, an olsr topology visualizer for s3d.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include <s3d.h>
-#include <s3dw.h>
-#include <s3d_keysym.h>
-#include <math.h>
-#include <stdio.h>	/* TODO can remove then no more printf needed */
-#include <string.h>
-#include "structs.h"
-#include "search.h"
-
-s3dw_surface	*_search_surface;
-s3dw_input		*_search_input;
-s3dw_widget		*_search_widget;
-
-struct olsr_node *_node_root = NULL;
-struct olsr_node **search_node = NULL;
-
-float	_return_point[2][3];				/* cam position before move to the widget */
-int		_search_status = NOTHING;			/* status of search */
-											
-void _search_node(s3dw_widget *dummy);
-void _abort_search(s3dw_widget *dummy);
-
-/* public */
-void follow_node(float cam_position_t[], float cam_position_r[],float rotate)
-{
-	float real_node_pos[3],
-		  cam_target[3],
-		  tmp_vec[3],
-		  diff_vec[3],
-		  angle;
-	
-	real_node_pos[0] =  (*search_node)->pos_vec[0] * cos( rotate * M_PI / 180.0 ) - (*search_node)->pos_vec[2] * -sin ( rotate * M_PI / 180.0 );
-	real_node_pos[1] =  (*search_node)->pos_vec[1];
-	real_node_pos[2] =  (*search_node)->pos_vec[0] * -sin( rotate * M_PI / 180.0) + (*search_node)->pos_vec[2] * cos ( rotate * M_PI / 180.0 );
-
-	cam_target[0] = ( real_node_pos[0] + 7);
-	cam_target[1] =   real_node_pos[1];
-	cam_target[2] = ( real_node_pos[2] + 7);
-	
-	cam_position_t[0]=( cam_position_t[0] * 4 + cam_target[0] ) / 5;
-	cam_position_t[1]=( cam_position_t[1] * 4 + cam_target[1] ) / 5;
-	cam_position_t[2]=( cam_position_t[2] * 4 + cam_target[2] ) / 5;
-	
-	tmp_vec[0] =  0.0;
-	tmp_vec[1] =  0.0;
-	tmp_vec[2] = -1.0;
-	
-	diff_vec[0] = cam_position_t[0] - real_node_pos[0];
-	diff_vec[1] = 0.0;
-	diff_vec[2] = cam_position_t[2] - real_node_pos[2];
-	angle = s3d_vector_angle( diff_vec, tmp_vec );
-	/* angle = ( real_node_pos[0] > 0) ? ( 180 - ( 180 / M_PI * angle ) ) : ( 180 + ( 180 / M_PI * angle ) ); */
-	angle = 180 - ( 180 / M_PI * angle );
-	cam_position_r[1] = ( cam_position_r[1] * 4 + angle ) / 5;
-	
-	s3d_translate( 0, cam_position_t[0], cam_position_t[1], cam_position_t[2] );
-	s3d_rotate( 0, cam_position_r[0], cam_position_r[1], cam_position_r[2] );
-}
-
-/* public */
-void create_search_widget(float x, float y, float z)
-{
-	s3dw_button *search_button, *abort_button;
-	
-	_search_surface	= s3dw_surface_new( "Node Search", 17, 10 );
-	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
-	
-	s3dw_label_new( _search_surface, "Enter the IP of the node.", 1, 2);
-	s3dw_focus( S3DWIDGET( _search_input ) );
-	
-	search_button = s3dw_button_new( _search_surface, "Search", 11.5, 7 );
-	abort_button  = s3dw_button_new( _search_surface, "Abort", 1, 7 );
-	search_button->onclick = _search_node;
-	abort_button->onclick = _abort_search;
-
-	/* TODO calc position for ok button */
-	
-	s3dw_focus	( S3DWIDGET( _search_input ) );	
-	s3dw_focus	( S3DWIDGET( _search_surface ) );
-	s3dw_show	( S3DWIDGET( _search_surface ) );
-	
-	_search_widget	= s3dw_getroot();
-	move_search_widget( x, y, z );
-
-	_search_widget->ary = 180;
-	s3d_rotate( _search_widget->oid, _search_widget->arx, _search_widget->ary, _search_widget->arz );
-}
-
-/* public */
-void move_search_widget(float x, float y, float z)
-{
-	_search_widget->x = x; _search_widget->y = y; _search_widget->z = z;
-	s3dw_moveit( _search_widget );
-}
-
-/* public */
-void move_to_search_widget(float cam_position_t[], float cam_position_r[])
-{
-	float target, current;
-	
-	set_search_status(WIDGET);
-	cam_position_t[0] = ( cam_position_t[0] * 4 + _search_widget->x ) / 5;
-	cam_position_t[1] = ( cam_position_t[1] * 4 + _search_widget->y ) / 5;
-	cam_position_t[2] = ( cam_position_t[2] * 4 + ( _search_widget->z - 10 ) ) / 5;
-
-	target = _search_widget->arx;
-	current = cam_position_r[0];
-
-	if( _search_widget->arx - cam_position_r[0] > 180 )
-		target -= 360;
-	if( _search_widget->arx - cam_position_r[0] < -180 )
-		current -= 360;
-	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
-
-	target = _search_widget->ary;
-	current = cam_position_r[1];
-
-	if( _search_widget->ary - cam_position_r[1] > 180 )
-		target -= 360;
-	if( _search_widget->ary - cam_position_r[1] < -180 )
-		current -= 360;
-	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
-
-	target = _search_widget->arz;
-	current = cam_position_r[2];
-
-	if( _search_widget->arz - cam_position_r[2] > 180 )
-		target -= 360;
-	if( _search_widget->arz - cam_position_r[2] < -180 )
-		current -= 360;
-	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
-	
-	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
-	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
-	
-	if ( sqrt(  (( cam_position_t[0] - _search_widget->x)*( cam_position_t[0] - _search_widget->x)) + 
-				(( cam_position_t[1] - _search_widget->y)*( cam_position_t[1] - _search_widget->y)) + 
-				(( cam_position_t[2] - _search_widget->z)*( cam_position_t[2] - _search_widget->z)) ) < 0.2 )
-	{
-		s3d_translate( 0, _search_widget->x, _search_widget->y, ( _search_widget->z - 10 ) );
-		s3d_rotate( 0, _search_widget->arx, _search_widget->ary, _search_widget->arz );
-	}
-}
-
-/* public */
-void move_to_return_point(float cam_position_t[], float cam_position_r[])
-{
-	float target, current;
-
-	cam_position_t[0] = ( cam_position_t[0] * 4 + _return_point[0][0] ) / 5;
-	cam_position_t[1] = ( cam_position_t[1] * 4 + _return_point[0][1] ) / 5;
-	cam_position_t[2] = ( cam_position_t[2] * 4 + _return_point[0][2] ) / 5;
-
-	target = _return_point[1][0];
-	current = cam_position_r[0];
-
-	if( _return_point[1][0] - cam_position_r[0] > 180 )
-		target -= 360;
-	if( _return_point[1][0] - cam_position_r[0] < -180 )
-		current -= 360;
-	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
-
-	target = _return_point[1][1];
-	current = cam_position_r[1];
-
-	if( _return_point[1][1] - cam_position_r[1] > 180 )
-		target -= 360;
-	if( _return_point[1][1] - cam_position_r[1] < -180 )
-		current -= 360;
-	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
-
-	target = _return_point[1][2];
-	current = cam_position_r[2];
-
-	if( _return_point[1][2] - cam_position_r[2] > 180 )
-		target -= 360;
-	if( _return_point[1][2] - cam_position_r[2] < -180 )
-		current -= 360;
-	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
-	
-	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
-	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
-	
-	if ( sqrt(  (( cam_position_t[0] - _return_point[0][0])*( cam_position_t[0] - _return_point[0][0])) + 
-				(( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) + 
-				(( cam_position_t[2] - _return_point[0][2])*( cam_position_t[2] - _return_point[0][2])) ) < 0.2 )
-	{
-		s3d_translate( 0, _return_point[0][0], _return_point[0][1], _return_point[0][2] );
-		s3d_rotate( 0, _return_point[1][0], _return_point[1][1], _return_point[1][2] );
-		set_search_status(NOTHING);
-	}
-}
-
-/* public */
-void search_widget_write(int key)
-{
-	static char s[20];
-	int ln = strlen(s);
-	
-	if( key == S3DK_COMMA ) key = S3DK_PERIOD;
-	
-	if( key != S3DK_RETURN )
-	{
-		if( key == S3DK_BACKSPACE )
-		{
-			if( ln > 0 )
-				s[ln-1] = '\0';
-		} else {
-			if( ln < 20 )
-				s[ln] = key;
-		}
-		s3dw_input_change_text( _search_input, s );
-	} else {
-		_search_node( _search_widget );	
-	}
-}
-
-/* public */
-void set_return_point(float cam_position_t[], float cam_position_r[])
-{
-	int i;
-	for( i = 0; i < 3; i++ )
-		_return_point[0][i] = cam_position_t[i];
-	for( i = 0; i < 3; i++ )
-		_return_point[1][i] = cam_position_r[i];
-}
-
-/* public */
-int get_search_status(void)
-{
-	return _search_status;
-}
-
-/* public */
-void set_search_status(int stat)
-{
-	/* TODO check if stat between 0-3 else debug printf */
-	_search_status = stat;
-}
-
-/* public */
-void set_node_root(struct olsr_node *root)
-{
-	_node_root = root;
-}
-
-/* private */
-void _search_node(s3dw_widget *dummy)
-{
-	char *ip;
-	int result;
-	
-	search_node = &_node_root;
-	
-	ip = s3dw_input_gettext( _search_input );
-	
-	while ( (*search_node) != NULL )
-	{
-
-		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
-
-		if ( result == 0 ) 
-			break;
-		
-		if ( result < 0 )
-			(*search_node) = (*search_node)->right;
-		else
-			(*search_node) = (*search_node)->left;
-	}
-
-	if( (*search_node) != NULL )
-		set_search_status( FOLLOW );
-}
-
-/* private */
-void _abort_search(s3dw_widget *dummy)
-{
-	set_search_status(ABORT);
-}
-
-	

Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,217 +0,0 @@
-/*
- * s3d_x11gate.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d_x11gate, a 3d gateway for x11 desktops.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d_x11gate is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d_x11gate is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d_x11gate; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include <s3d.h>		 /*  s3d_*() */
-#include <stdlib.h> 	 /*  getenv() */
-#include <stdio.h>		 /*  printf() */
-#include <X11/Xlib.h>	 /*  Ximage, Display, X*() */
-#include <X11/Xutil.h>	 /*  XDestroyImage() */
-#define XK_MISCELLANY
-#include <X11/keysymdef.h>	 /* keysyms */
-#include <X11/extensions/XTest.h>	/* keyboard/mouse input via s3d */
-#include <time.h>	/* nanosleep() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
-
-int oid;
-XImage *image;
-Display *dpy=0;
-int window,scr;
-int width,height;
-char *tex_image=NULL,*otex_image=NULL,*img1,*img2;
-int get_shift(unsigned long t)
-{
-	int i=0;
-	while (t)
-	{
-		t>>=1;
-		i++;
-	}
-	return(i);
-}
-void mainloop()
-{
-	int x,y;
-	int rs,gs,bs;
-	unsigned long d;
-	int bpp;
-	char *swap_timg;
-	int last_change,start_change;
-	image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);
-	if (image->format==ZPixmap)
-	{
-		printf("Ximage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n",image->width,image->height,image->format,ZPixmap,
-					image->bits_per_pixel,image->depth,image->bitmap_pad);
-		rs=get_shift(image->red_mask)-8;
-		gs=get_shift(image->green_mask)-8;
-		bs=get_shift(image->blue_mask)-8;
-
-		bpp=(image->bits_per_pixel/8);
-		/* rgb is not bgr */
-		rs=rs;
-		gs=gs-8;
-		bs=bs-16;
-		printf("Ximage: rgb: %d|%d|%d\n",	rs,gs,bs);;
-/*		printf("red: size %d, offset %d\n",rs,roff);
-		printf("green: size %d, offset %d\n",gs,goff);
-		printf("blue: size %d, offset %d\n",bs,boff);
-		printf("bits per pixel:%d\n",bpp);*/
-		last_change=-1;
-		start_change=-1;
-		for (y=0;y<height;y++)
-		{
-			
-			for (x=0;x<width;x++)
-			{
-				d=*((unsigned long *)(image->data+(y*width+x)*bpp));
-				((unsigned long *)tex_image)[(y*width+x)]=
-						(rs>0?((d&image->red_mask)>>rs):	((d&image->red_mask)<<-rs))|
-						(gs>0?((d&image->green_mask)>>gs):	((d&image->green_mask)<<-gs))|
-						(bs>0?((d&image->blue_mask)>>bs):	((d&image->blue_mask)<<-bs))|
-						255<<24;
-				if (((unsigned long *)tex_image)[(y*width+x)]!=
-					((unsigned long *)otex_image)[(y*width+x)])
-					last_change=y;
-			}
-			if (last_change!=-1)
-			{
-				if (start_change==-1)
-				{
-					start_change=y;
-/* 					printf("setting start_change to %d\n",start_change); */
-				}
-				if (last_change!=y)
-				{	 /*  last change is already over, post it! */
-/*					printf("[%d to %d]",start_change,last_change);*/
-					s3d_load_texture(oid,0,0,start_change,width,last_change-start_change+1,(unsigned char *)tex_image+start_change*width*4);
-					start_change=-1;
-					last_change=-1;
-				}
-			}
-		}
-		 /*  posting the last bit, maybe */
-		if (last_change!=-1)
-		{
-/*			printf("last one: [%d-%d]",start_change,last_change);*/
-			s3d_load_texture(oid,0,0,start_change,width,last_change-start_change,(unsigned char *)tex_image+start_change*width*4);
-		}
-/* 		s3d_load_texture(oid,0,0,0,width,height,tex_image); */
-		 /*  swap images */
-		swap_timg=tex_image;
-		tex_image=otex_image;
-		otex_image=swap_timg;
-	}
-	XDestroyImage(image);
-
-	nanosleep(&t,NULL); 
-}
-void keypress(struct s3d_evt *event)
-{
-	int key;
-	int kc;
-	key=*((unsigned short *)event->buf);
-	printf("received key %d ",key);
-    kc = XKeysymToKeycode(dpy, key);
-	if (kc==0) 
-	{
-	    kc = XKeysymToKeycode(dpy, 0xFF00+ key);
-		printf(" (%04x) ",0xFF00+key);
-	}
-	if (kc==0)
-	{
-		if (key==8)
-		{
-			kc=22; printf("!backspace!");
-		}
-	}
-	printf("using key: %d, keycode %d (%04x)\n",key,kc,kc);
-	if (kc!=0)
-	    XTestFakeKeyEvent(dpy, kc, 1, 1);
-/*	    XTestFakeKeyEvent(dpy, kc, 0, 1);*/
-
-}
-void mouseclick(struct s3d_evt *event)
-{
-	printf("not processing mouse clicks yet ... \n");
-}
-int main(int argc, char **argv)
-{
-	char *disp=NULL;
-	int a,b,c,d;
-	int xt;
-	if (disp==NULL) disp=getenv("DISPLAY");
-	if (disp==NULL) disp="";  /*  fallback */
-	dpy = XOpenDisplay(disp);
-	if (!dpy)
-	{
-		printf("couldn't open display\n");
-		return(-1);
-	}
-	if (!s3d_init(&argc,&argv,"X11-gate"))
-	{
-		scr = DefaultScreen(dpy);
-		window = RootWindow(dpy, scr);
-		width = DisplayWidth(dpy, scr);
-		height = DisplayHeight(dpy, scr);
-		XLockDisplay(dpy);
-		xt=XTestQueryExtension(dpy,&a,&b,&c,&d);
-		XUnlockDisplay(dpy);
-		if (xt)
-		{
-			printf("having xtest extension ...\n");
-		}
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,mouseclick);
-		s3d_set_callback(S3D_EVENT_KEY,keypress);
-		printf("screen: %dx%d\n",width,height);
-		img1=malloc(width*height*4);
-		img2=malloc(width*height*4);
-		tex_image=img1;
-		otex_image=img2;
-		oid=s3d_new_object();
-		s3d_push_vertex(oid,-5,-5,0);
-		s3d_push_vertex(oid, 5,-5,0);
-		s3d_push_vertex(oid, 5, 5,0);
-		s3d_push_vertex(oid,-5, 5,0);
-		s3d_push_material_a(oid,
-						0.8,	0.0,	0.0	,1.0,
-						1.0,	1.0,	1.0	,1.0,
-						0.8,	0.0,	0.0	,1.0);
-		s3d_push_polygon(oid,0,2,1,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,1.0, 
-									   1.0,0.0,
-									   1.0,1.0);
-		s3d_push_polygon(oid,0,3,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,1.0, 
-									   0.0,0.0,
-									   1.0,0.0);
-		s3d_push_texture(oid,width,height);
-					 /*  push data on texture 0 position (0,0) */
-		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
-		s3d_flags_on(oid,S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-		free(img1);
-		free(img2);
-	}
-	s3d_quit();
-	return(0);
-}

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/animation.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,172 +0,0 @@
-/*
- * animation.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3dfm, a s3d file manager.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include "s3dfm.h"
-#include <s3dw.h>
-#include <stdio.h> 	 /*  printf(),NULL */
-#include <math.h>	 /*  fabs() */
-#define SCALE 	1
-
-/* the animation stack */
-static t_item *ani_s[MAXANI];
-static int ani_n=0;
-extern t_item root,cam;
-int moveon=1;
-
-/* get the scale for the rootbox zoom */
-float ani_get_scale(t_item *f)
-{
-	float scale,s;
-	s=0.2;
-	scale=1/s;
-	if (f->parent!=NULL)
-		scale=1/s*ani_get_scale(f->parent);
-	else
-		return(1.0);
-	root.px-=f->px;
-	root.pz-=f->pz;
-	root.py-=BOXHEIGHT+f->detached*DETHEIGHT;
-	root.px*=1/s;
-	root.py*=1/s;
-	root.pz*=1/s;
-	
-	return(scale);
-}
-/* center f for the viewer, therefore moving the root box ... */
-void ani_focus(t_item *f)
-{
-	root.px=0.0;
-	root.py=0.0;
-	root.pz=0.0;
-	moveon=1;
-/*	printf("[Z]ooming to %s\n",f->name);*/
-	box_collapse_grandkids(f);
-	root.scale=ani_get_scale(f);
-	root.py-=1.5;
-/*	printf("[R]escaling to %f\n",root.scale);
-	printf("px: %f py:%f pz: %f\n",root.px,root.py,root.pz);*/
-
-	ani_add(&root);
-	if (((cam.dpx-cam.px)* (cam.dpx-cam.px) + (cam.dpy-cam.py)* (cam.dpy-cam.py) 
-		  + (cam.dpz-cam.pz)* (cam.dpz-cam.pz))	> ( 10 * 10))
-	{
-		cam.px=0;
-		cam.py=0;
-		cam.pz=5;
-		ani_add(&cam);
-	}
-}
-/* is item f already on stack? */
-int ani_onstack(t_item *f)
-{
-	int i;
-	for (i=0;i<ani_n;i++)
-		if (ani_s[i]==f)
-			return(1);		/* already in list */
-	return(0);
-
-}
-/* add an item on the animation stack */
-void ani_add(t_item *f)
-{
-	if (ani_n<MAXANI)
-	{
-		if (ani_onstack(f))
-			return;		/* already in list */
-		ani_s[ani_n]=f;
-		ani_iterate(f);
-	/*	printf("[A]ni ADD %d\n",ani_n); */
-		ani_n++;
-	}
-	else /* no place, finish now */
-		ani_finish(f,-1);
-}
-/* delete an item from the animation stack */
-void ani_del(int i)
-{
-	if ((i>=0) && (i<ani_n))
-	{
-/*		printf("[A]ni DEL %d\n",i);*/
-		ani_n--;
-		ani_s[i]=ani_s[ani_n]; /* that should also work if i is the last one */
-	} else {
-		printf("[F]ATAL: can't delete animation!\n");
-	}
-}
-/* well ... */
-void ani_doit(t_item *f)
-{
-	s3d_translate(	f->block, f->dpx,f->dpy,f->dpz);
-	s3d_scale(		f->block, f->dscale);
-}
-
-/* finish an animation on the stack, stack index i */
-void ani_finish(t_item *f, int i)
-{
-	f->dpx= f->px;
-	f->dpy= f->py;
-	f->dpz= f->pz;
-	f->dscale= f->scale;
-	ani_doit(f);
-	if (i!=-1)
-		ani_del(i);
-}
-void ani_iterate(t_item *f)
-{
-	f->dpx=(f->px + f->dpx*ZOOMS)/(ZOOMS+1);
-	f->dpy=(f->py + f->dpy*ZOOMS)/(ZOOMS+1);
-	f->dpz=(f->pz + f->dpz*ZOOMS)/(ZOOMS+1);
-	f->dscale=(f->scale + f->dscale*ZOOMS)/(ZOOMS+1);
-
-}
-
-/* checks if f is good enough */
-int ani_check(t_item *f)
-{
-	float x,y,z;
-	x=f->dpx - f->px;
-	y=f->dpy - f->py;
-	z=f->dpz - f->pz;
-	if (((fabs(f->dscale - f->scale)/f->scale)>0.01) || (sqrt(x*x+y*y+z*z) > 0.01))
-		return(0);
-	return(1);
-}
-/* doing the whole animation thing */
-void ani_mate()
-{
-	int i;
-	t_item *f;
-	s3dw_ani_mate();
-	for (i=0;i<ani_n;i++)
-	{
-		f=ani_s[i];
-		ani_iterate(f);
-		if (ani_check(f))
-		{
-			ani_finish(f,i);
-			i--; /* a new object is here now, take care in the next iteration */
-		} else {
-			ani_doit(f);
-		}
-	}
-}

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/box.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,399 +0,0 @@
-/*
- * box.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3dfm, a s3d file manager.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include "s3dfm.h"
-#include <stdio.h> 	 /*  printf() */
-#include <math.h>	 /*  sin(),cos() */
-#include <string.h>  /*  strlen() */
-
-
-/* remove old items on the box */
-void box_dissolve(t_item *dir)
-{
-	if (dir->close!=-1)		{	s3d_del_object(dir->close);		dir->close=-1; }
-	if (dir->select!=-1)	{	s3d_del_object(dir->select);	dir->select=-1; }
-	if (dir->title!=-1)		{	s3d_del_object(dir->title);		dir->title=-1; }
-	if (dir->titlestr!=-1)	{	s3d_del_object(dir->titlestr);	dir->titlestr=-1; }
-	if (dir->block!=-1)			s3d_del_object(dir->block);
-
-}
-
-
-
-/* places the string at the left side of the cube */
-void box_sidelabel(t_item *dir)
-{
-
-	s3d_rotate(dir->str,0,90,0);
-	s3d_translate(dir->str,1.1,0.3,1);
-	s3d_scale(dir->str,(float)1.8/(dir->len));
-	s3d_scale(dir->str,(float)1.8/(dir->len));
-	s3d_link(dir->str,dir->block);
-	s3d_flags_on(dir->str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-}
-
-/* creates a big block which will hold files and subdirs on top */
-int box_buildblock(t_item *dir)
-{
-	char fname[30];
-	char *fullname=fname;
-	t_item *d;
-	int i,j;
-	float len;
-	float vertices[]=
-			{-BHP,0,-BHP,
-			 -BHP,0, BHP,
-			  BHP,0, BHP,
-			  BHP,0,-BHP,
-			 -BHP,BHH,-BHP,
-			 -BHP,BHH, BHP,
-			  BHP,BHH, BHP,
-			  BHP,BHH,-BHP,
-			 -1,0, 0.8,
-			 -1,BOXHEIGHT, 0.8,
-			  1,BOXHEIGHT, 0.8,
-			  1,0, 0.8
-				};
-	float xvertices[]=
-			{
-			  0.8,BHH-0.2, 0.8,
-			  0.8,BHH    , 0.8,
-			  BHP,BHH    , 0.8,
-			  BHP,BHH-0.2, 0.8,
-			  0.8,BHH-0.2, 1.0,
-			  0.8,BHH    , 1.0,
-			  BHP,BHH    , 1.0,
-			  BHP,BHH-0.2, 1.0
-			 };
-	float svertices[]=
-			{
-			  0.6,BHH-0.2, 0.8,
-			  0.6,BHH    , 0.8,
-			  0.8,BHH    , 0.8,
-			  0.8,BHH-0.2, 0.8,
-			  0.6,BHH-0.2, 1.0,
-			  0.6,BHH    , 1.0,
-			  0.8,BHH    , 1.0,
-			  0.8,BHH-0.2, 1.0
-			 };
-	float tvertices[]=
-			{
-			  -BHP,BHH-0.2, 0.8,
-			  -BHP,BHH    , 0.8,
-			  0.6, BHH    , 0.8,
-			  0.6, BHH-0.2, 0.8,
-			  -BHP,BHH-0.2, 1.0,
-			  -BHP,BHH    , 1.0,
-			  0.6, BHH    , 1.0,
-			  0.6, BHH-0.2, 1.0
-			 };
-	unsigned long bar_poly[]={
-		4,5,6,0,
-		4,6,7,0,
-		3,7,4,0,
-		3,4,0,0
-	};
-/*	printf("new block for %s\n",dir->name);*/
-
-	dir->block=s3d_new_object();
-	s3d_push_vertices(dir->block,vertices,sizeof(vertices)/(3*sizeof(float)));
-	s3d_push_material(dir->block,
-						0.5,0.5,0.5,
-						0.5,0.5,0.5,
-						0.5,0.5,0.5
-					);
-	s3d_push_material(dir->block,
-						0.5,0.5,0.6,
-						0.5,0.5,0.6,
-						0.5,0.5,0.6);
-
-	s3d_push_polygon(dir->block,4,6,5,1);
-	s3d_push_polygon(dir->block,4,7,6,1);
-
-	s3d_push_polygon(dir->block,0,4,5,0);
-	s3d_push_polygon(dir->block,0,5,1,0);
-	
-	s3d_push_polygon(dir->block,3,7,4,0);
-	s3d_push_polygon(dir->block,3,4,0,0);
-
-	s3d_push_polygon(dir->block,2,6,7,0);
-	s3d_push_polygon(dir->block,2,7,3,0);
-	
-	s3d_push_polygon(dir->block,8,9,10,0);
-	s3d_push_polygon(dir->block,8,10,11,0);
-
-	dir->close=s3d_new_object();
-	s3d_push_material(dir->close,
-						0.5,0.3,0.3,
-						0.5,0.3,0.3,
-						0.5,0.3,0.3
-					);
-	s3d_push_vertices(dir->close,xvertices,sizeof(xvertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir->close,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
-	s3d_link(dir->close,dir->block);
-	
-	dir->select=s3d_new_object();
-	s3d_push_material(dir->select,
-						0.1,0.1,0.3,
-						0.1,0.1,0.3,
-						0.1,0.1,0.3
-					);
-	s3d_push_vertices(dir->select,svertices,sizeof(svertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir->select,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
-	s3d_link(dir->select,dir->block);
-	
-	dir->title=s3d_new_object();
-	s3d_push_material(dir->title,
-						0.3,0.3,0.3,
-						0.3,0.3,0.3,
-						0.3,0.3,0.3
-					);
-	s3d_push_vertices(dir->title,tvertices,sizeof(tvertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir->title,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
-	s3d_link(dir->title,dir->block);
-	i=28;
-	fullname[29]=0;
-	d=dir;
-	do {
-		j=strlen(d->name)-1;
-		if (NULL!=(d->parent))
-		{
-			fullname[i]='/';
-			i--;
-		}
-		while ((i >= 0) && (j >= 0))
-		{
-			fullname[i]=d->name[j];
-			j--;
-			i--;
-		}
-		if (i<0) 
-			break;
-
-
-	} while ((d=d->parent)!=NULL);
-	if (i<0)
-		fullname[0]=fullname[1]='.';
-	else 
-		fullname=(char *)fullname+i+1; /* jump to start of the string */
-	dir->titlestr=s3d_draw_string(fullname,&len);
-	if (len>(1.6*5.0))
-		s3d_scale(dir->titlestr,1.6/len);
-	else
-		s3d_scale(dir->titlestr,0.2);
-	s3d_translate(dir->titlestr,-1.0,1.05,1.01);
-	s3d_link(dir->titlestr,dir->block);
-	dir->disp=D_DIR;
-/*	printf("FULLNAME is [%s]\n",fullname);*/
-	return(0);
-}
-int undisplay(t_item *dir)
-{
-	switch (dir->disp)
-	{
-		case D_DIR: return(box_undisplay(dir));break;
-		case D_ICON:return(icon_undisplay(dir));break;
-		default:	return(-1);
-	}
-}
-/* display a directoy on the top of another, draw it's icons etc ... */
-int box_expand(t_item *dir)
-{
-	int i;
-	float  px,pz;
-	int dirn;
-	px=pz=0.0;
-	printf("box_expand( %s )\n",dir->name);
-	if (dir->disp)		undisplay(dir);
-	box_buildblock(dir);
-	if (dir->parent!=NULL)
-		dir->parent->dirs_opened++;
- /* count directories */
-	dirn=0;
-	for (i=0;i<dir->n_item;i++)
-	{
-		if (dir->list[i].type==T_FOLDER) dirn++;
-	}
-
-	/* draw icons, if necceasry */
-	for (i=0;i<dir->n_item;i++)
-	{
-		if (!dir->list[i].disp)	icon_draw(dir,i);
-		else {
-			printf("link %d to the block %d of %s\n",dir->list[i].block,dir->block,dir->name);
-			s3d_link(dir->list[i].block,dir->block); /* if it's already displayed, make sure it linked properly ... */
-		}
-	}
-	if (dir->parent!=NULL)
-	{
-		s3d_link(dir->block,dir->parent->block);
-		dir->dpx=0.0;
-		dir->dpy=BOXHEIGHT;
-		dir->dpz=0.0;
-		dir->dscale=0.0;
-		box_position_kids(dir->parent);
-		ani_doit(dir);
-	}
-	for (i=0;i<dir->n_item;i++)
-	{
-		s3d_flags_on(dir->list[i].block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(dir->list[i].str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	}
-	box_sidelabel(dir);
-    s3d_flags_on(dir->block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir->close,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir->title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir->select,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir->titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	dir->disp=D_DIR;
-	return(0);
-}
-int box_undisplay(t_item *dir)
-{
-	int i;
-	t_item *par;
-	printf("box_undisplay( %s )\n",dir->name);
-	for (i=0;i<dir->n_item;i++)
-	{
-		if (dir->list[i].disp==D_ICON)	icon_undisplay(&(dir->list[i]));
-		else if (dir->list[i].disp!=0)	
-				printf("not undisplaying: %s (disp = %d)\n",dir->list[i].name, dir->list[i].disp);
-	}
-	if ((par=dir->parent)!=NULL) /* we can't do this on root.... */
-	{
-		for (i=0;i<par->n_item;i++)
-			if (&par->list[i]==dir)
-				break;
-		if (i!=par->n_item) /* if it actually was in the parents item list */
-		{
-			icon_draw(par,i);
-			s3d_flags_on(dir->block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_on(dir->str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		}
-		par->dirs_opened--;
-	} else {
-		/* we're root ... */
-		box_dissolve(dir);
-	}
-	printf("[U]ndisplayed %s\n",dir->name);
-/*	dir->dirs_opened=0;*/
-	dir->detached=0;
-	return(0);
-}
-/* undisplay a directory, thus recursively removing the kids.*/
-int box_collapse(t_item *dir,int force)
-{
-	int i;
-	int ret;
-	printf("box_collapse( %s )\n",dir->name);
-	if (&root==dir)
-	{
-		printf("won't undisplay root window ... \n");
-		return(-1);
-	}
-	if (dir->detached && !force)
-		return(1);
-	if (dir->disp!=D_DIR)
-	{
-		printf("[A]lready undisplayed %s, nothing to do ...\n",dir->name);
-		return(-1);
-	}
-	/* undisplaying kids. ret will be != 0 if any of the kids did not close correctly */
-	ret=0;
-	for (i=0;i<dir->n_item;i++)
-		if (dir->list[i].disp==D_DIR)
-			ret|=box_collapse(&dir->list[i],force);
-
-	if (ret && !force) return(ret); /* if anything got wrong, return here ... */
-	undisplay(dir);
-	if (dir->parent!=NULL)
-	{
-		box_position_kids(dir->parent);
-	}
-	return(ret);
-}
-/* only display dir and its kids, but nothing below. */
-int box_collapse_grandkids(t_item *dir)
-{
-	int i,j;
-	t_item *kid;
-	for (i=0;i<dir->n_item;i++)
-		if (dir->list[i].disp==D_DIR)
-		{
-			kid=&dir->list[i];
-			for (j=0;j<kid->n_item;j++)
-			if (kid->list[j].disp==D_DIR)
-				box_collapse(&kid->list[j],0);
-		}
-	return(0);
-}
-/* orders the directory objects on top of its parent objects 
- * to be called after adding or removing things ...*/
-void box_position_kids(t_item *dir)
-{
-	int i,j;
-	printf("box_position_kids( %s ): %d dirs opened\n",dir->name,dir->dirs_opened);
-	switch (dir->dirs_opened)
-	{
-		case 0: return;
-		case 1:
-			for (i=0;i<dir->n_item;i++)
-			{
-				if (dir->list[i].disp==D_DIR)
-				{
-					dir->list[i].px=0.0;
-					dir->list[i].py=BOXHEIGHT+dir->list[i].detached*DETHEIGHT;
-					dir->list[i].pz=0.0;
-					dir->list[i].scale=0.2;
-					ani_add(&dir->list[i]);
-				}
-			}
-			break;
-		default:
-			j=0;
-			for (i=0;i<dir->n_item;i++)
-			{
-				if (dir->list[i].disp==D_DIR)
-				{
-					dir->list[i].px=0.8 * sin(((float)j*2*M_PI)/((float)dir->dirs_opened));
-					dir->list[i].py=BOXHEIGHT+dir->list[i].detached*DETHEIGHT;
-					dir->list[i].pz=0.8 * cos(((float)j*2*M_PI)/((float)dir->dirs_opened));
-					dir->list[i].scale=0.2;
-					ani_add(&dir->list[i]);
-					j++;
-				}
-
-			}
-	}
-}
-void box_select(t_item *dir)
-{
-	dir->detached=dir->detached?0:1; /* swapping, not sure if !dir->detached would do the same .. */
-	if ((dir->type==T_FOLDER) && dir->disp)
-	{
-		if (dir->parent!=NULL)
-			box_position_kids(dir->parent);
-	} else {
-		/* nothing yet ... */
-	}
-}

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/dialog.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,357 +0,0 @@
-/*
- * dialog.c
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3dfm, a s3d file manager.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include "s3dfm.h"
-#include <s3d_keysym.h>
-#include <s3dw.h>
-#include <stdio.h> 	/* NULL, printf() */
-#include <string.h> /* strlen() */
-#include <stdlib.h> /* realloc(),malloc() */
-#include <errno.h>  /* errno */
-#include <sys/stat.h> /* mkdir() */
-#include <sys/types.h> /* mkdir() */
-extern t_item *focus;
-filelist fp={NULL,0};
-int typeinput=0;
-/* keyevent handler */
-void key_handler(struct s3d_evt *evt)
-{
-	struct s3d_key_event *keys=(struct s3d_key_event *)evt->buf;
-	char path[M_DIR];
-	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */	
-			printf("inputting text ...\n");
-			s3dw_handle_key(evt); 
-			return; 
-	}
-	get_path(focus,path);
-	switch (keys->keysym)
-	{
-		case 'i':
-		case 'I':
-				{
-				window_info(path);
-				}
-				break;
-		case 'r':
-		case 'R':
-				{/* refresh this window ... */
-					printf("[R]efreshing %s\n",focus->name);
-					parse_again(focus);
-					ani_focus(focus);
-				}
-				break;
-		case S3DK_F1:
-				window_help();
-				break;
-		case S3DK_F5:
-				window_copy(path);
-				break;
-		case S3DK_F6:
-				window_move(path);
-				break;
-		case S3DK_F7:
-				window_mkdir(path);
-				break;
-
-
-	}
-	s3dw_handle_key(evt);
-}
-
-/* object click handler */
-void object_click(struct s3d_evt *evt)
-{
-	int oid;
-	t_item *f;
-	s3dw_handle_click(evt);
-	oid=(int)*((unsigned long *)evt->buf);
-	if (NULL!=(f=finditem(&root,oid)))
-	{
-		if (f->close==oid)
-		{
-			box_collapse(f,1);
-/*			if (f->parent!=NULL)
-				ani_focus(f->parent);*/
-			return;
-		}
-		if (f->select==oid)
-		{
-			printf("[S]electing %s\n",f->name);
-			box_select(f);
-			return;
-		}
-		if (f->type==T_FOLDER)
-		{
-			if (f->disp == D_DIR)
-			{
-				printf("[F]ound, Already displayed - ani_focus( %s )\n",f->name);
-			} else {
-				if (!f->parsed)	parse_dir(f);
-				box_expand(f);
-			}
-			focus=f;
-			ani_focus(f);
-		} else
-			printf("[F]ound, but %s is no folder\n",f->name);
-	} else {
-/*		printf("[C]ould not find :/\n");*/
-	}
-}
-void close_win(s3dw_widget *button)
-{
-	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
-}
-/* add some dots to an integer value for better readability */
-void dotted_int(char *s,unsigned int i)
-{
-	char st[M_DIR];
-	int p;
-	p=0;
-	st[0]=0;
-	while (i>0)
-	{
-		if ((p+1)%4==0) {
-			st[p]='.';
-			p++;
-		}
-		st[p]=(i%10)+'0';
-		i=i/10;
-		p++;
-	}
-	if (p>0) p--;
-	st[p+1]=0;
-	for (i=0;i<p+1;i++)
-		s[i]=st[p-i];
-	s[p+1]=0;
-}
-/* add all selected dirs in the new filelist */
-int get_selected(filelist *fp, t_item *dir)
-{
-	int i;
-	char *s;
-	for (i=0;i<dir->n_item;i++)
-	{
-		if (dir->list[i].list!=NULL)	get_selected(fp,&(dir->list[i])); /* scan subdir */
-		if (dir->list[i].detached)
-		{
-			fp->n++;
-			fp->p=realloc(fp->p,sizeof(char *) * fp->n);
-			s=malloc(M_DIR);
-			get_path(&(dir->list[i]),s);
-			fp->p[fp->n - 1]=s;
-		}
-	}
-	return(0);
-}
-void window_help()
-{
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-	infwin=s3dw_surface_new("Help Window",12,12);
-	s3dw_label_new(infwin,"F1 - This Help Window",1,2);
-	s3dw_label_new(infwin,"F5 - Copy",1,3);
-	s3dw_label_new(infwin,"F6 - Move",1,4);
-	s3dw_label_new(infwin,"F7 - Create Directory",1,5);
-	s3dw_label_new(infwin,"R - Refresh",1,6);
-	s3dw_label_new(infwin,"I - Info",1,7);
-
-	button=s3dw_button_new(infwin,"OK",4,10);
-	button->onclick=close_win;
-	s3dw_show(S3DWIDGET(infwin));
-
-}
-void window_fs_another()
-{
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-	infwin=s3dw_surface_new("Error",12,8);
-	s3dw_label_new(infwin,"Sorry, another FS Action is in Progress",1,2);
-	button=s3dw_button_new(infwin,"OK",5,5);
-	button->onclick=close_win;
-	s3dw_show(S3DWIDGET(infwin));
-}
-void window_fs_nothing()
-{
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-	infwin=s3dw_surface_new("Error",12,8);
-	s3dw_label_new(infwin,"Nothing selected :(",1,2);
-	button=s3dw_button_new(infwin,"OK",5,5);
-	button->onclick=close_win;
-	s3dw_show(S3DWIDGET(infwin));
-
-}
-void window_fs_errno(char *errmsg)
-{
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-	char string[M_DIR];
-	float l;
-	snprintf(string,M_DIR,"%s: %s",errmsg,strerror(errno));
-	l=strlen(string)*0.7;
-	infwin=s3dw_surface_new("Error",l,8);
-	s3dw_label_new(infwin,string,1,2);
-	button=s3dw_button_new(infwin,"OK",l/2-1,5);
-	button->onclick=close_win;
-	s3dw_show(S3DWIDGET(infwin));
-}
-
-void window_fs_abort(s3dw_widget *button)
-{
-	int i;
-	for (i=0;i<fp.n;i++)
-		free(fp.p[i]);
-	if (fp.p!=NULL) free(fp.p);
-	fp.n=0;
-	fp.p=NULL;
-	typeinput=0;
-	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
-}
-void window_copy(char *path)
-{
-	s3dw_surface *infwin;
-	s3dw_button  *okbutton,*abortbutton;
-	float l;
-	char destdir[M_DIR];
-
-	int i,m;
-
-	if (fp.n!=0) 	{	window_fs_another(); 	return; }
-	fp.n=0;
-	fp.p=NULL;
-	get_selected(&fp,&root);
-	printf("selected %d nodes\n",fp.n);
-	if (fp.n == 0)	{	window_fs_nothing();	return;	}
-	m=10;
-	for (i=0;i<fp.n;i++)
-	{
-		if (strlen(fp.p[i])>m) m=strlen(fp.p[i]);
-		printf("%d: %s\n",i,fp.p[i]);
-	}
-
-	l=(m+3)*0.7;
-	infwin=s3dw_surface_new("Copy Window",l,fp.n+8);
-	s3dw_label_new(infwin,"Copy: ",1,1);
-	for (i=0;i<fp.n;i++)
-		s3dw_label_new(infwin,fp.p[i],3,2+i);
-	s3dw_label_new(infwin,"to:",1,fp.n+3);
-	get_path(focus,destdir);
-	s3dw_label_new(infwin,destdir,3,fp.n+4);
-
-	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp.n+5);
-	okbutton->onclick=window_fs_abort;
-	abortbutton=s3dw_button_new(infwin,"abort",l/2,fp.n+5);
-	abortbutton->onclick=window_fs_abort;
-
-	s3dw_show(S3DWIDGET(infwin));
-
-}
-s3dw_input	 *input;
-void window_fs_mkdir(s3dw_widget *button)
-{
-	char *dir;
-	t_item *item;
-	dir=s3dw_input_gettext(input);
-	printf("creating Directory ...%s\n",dir);
-	if (-1==mkdir(dir,0777)) /* umask ?! */
-		window_fs_errno("could not create directory");
-	else {
-		/* success, now refresh it */
-		item=get_item(dir);
-		if (item==NULL)
-		{
-			printf("cannot refresh\n");
-		} else {
-			printf("refreshing %s\n",item->name);
-			parse_again(item);
-
-		}
-				
-	}
-	window_fs_abort(button); /* finish */
-
-}
-void window_mkdir(char *path)
-{
-	s3dw_surface *infwin;
-	s3dw_button  *okbutton,*abortbutton;
-	char string1[M_DIR];
-	float l;
-	if (fp.n!=0) {window_fs_another(); return; }
-	snprintf(string1,M_DIR,"Create Directory in %s",path);
-	l=strlen(string1)*0.7;
-	infwin=s3dw_surface_new("Create Directory",l,8);
-	s3dw_label_new(infwin,string1,1,2);
-	input=s3dw_input_new(infwin,10,1,3);
-	s3dw_input_change_text(input, path);
-	s3dw_focus(S3DWIDGET(input));
-	s3dw_focus(S3DWIDGET(infwin));
-	typeinput=1;
-	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp.n+5);
-	okbutton->onclick=window_fs_mkdir;
-	abortbutton=s3dw_button_new(infwin,"abort",l/2,fp.n+5);
-	abortbutton->onclick=window_fs_abort;
-	s3dw_show(S3DWIDGET(infwin));
-
-}
-
-void window_move(char *path)
-{
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-	if (fp.n!=0) {window_fs_another(); return; }
-	infwin=s3dw_surface_new("Info Window",20,8);
-	s3dw_label_new(infwin,"Sorry, moving is not implemented yet.. :(",1,2);
-	button=s3dw_button_new(infwin,"Too bad",7,5);
-	button->onclick=close_win;
-	s3dw_show(S3DWIDGET(infwin));
-
-}
-/* a small window which counts directories/files and displays the result */
-void window_info(char *path)
-{
-	s3dw_surface *infwin;
-	s3dw_button  *button;
-	char string1[M_DIR];
-	char string2[M_DIR];
-	int b,d,f;
-	char bd[M_DIR];
-	float l;
-	snprintf(string1,M_DIR,"Info for %s",path);
-	fs_approx(path, &f, &d, &b);
-	dotted_int(bd,b);
-	snprintf(string2 ,M_DIR,"%s bytes in %d files and %d Directories",bd,f,d);
-	
-	l=((strlen(string1)>strlen(string2)) ? strlen(string1) :strlen(string2))*0.7;
-	
-	infwin=s3dw_surface_new("Info Window",l,12);
-
-	s3dw_label_new(infwin,string1,1,2);
-	s3dw_label_new(infwin,string2,1,4);
-
-	button=s3dw_button_new(infwin,"OK",l/2-1,6);
-	/* clicking on the button will exit ... */
-	button->onclick=close_win;
-	/* of couse, show it */
-	s3dw_show(S3DWIDGET(infwin));
-}

Modified: trunk/apps/s3dfm/fs.c
===================================================================
--- trunk/apps/s3dfm/fs.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/fs.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,302 +0,0 @@
-/*
- * fs.c 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3dfm, a s3d file manager.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include "s3dfm.h"
-#include <stdio.h>	/*  printf() */
-#include <dirent.h>	/* scandir() */
-#include <stdlib.h>	/*  malloc() */
-
-/* we want GNU version of basename */
-#define _GNU_SOURCE 
-#include <string.h>	/*  strlen(), strncmp(), strrchr() */
-#include <libgen.h> /* basename() */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-
-#include <errno.h>
-
-
-
-
-/* generates the file list */
-filelist *fl_new(char *path)
-{
-	struct dirent **namelist;
-	filelist *fl;
-	int n,i,j;
-	char *name;
-
-	fl=malloc(sizeof(filelist));
-	fl->p=NULL;
-	fl->n=0;
-    n = scandir(path, &namelist, 0, alphasort);
-    if (n <= 2) /* . and .. is always included. */
-	{
-		if (n<0)
-	        perror("scandir");
-	} else {
-		j=0;
-		fl->n=n-2 ; /* ignore . and .. */
-		fl->p=malloc(sizeof(char *)*fl->n);
-		for (i=0;i<n;i++)
-		{
-			name=namelist[i]->d_name;
-			if (!((strcmp(name,".")==0) || (strcmp(name,"..")==0))) /* ignore */
-			{
-				fl->p[j]=malloc(strlen(name)+strlen(path)+2);
-				strcpy(fl->p[j],path);
-				strcat(fl->p[j],"/");
-				strcat(fl->p[j],name);
-				j++;
-			}
-			free(namelist[i]);
-		}
-		if (j!=fl->n)
-		{
-			printf("assertion failed\n");
-			exit(-1);
-		}
-		free (namelist);
-	}
-	return(fl);	
-}
-/* delete the filelist */
-void fl_del(filelist *fl)
-{
-	int i;
-	for (i=0;i<fl->n;i++)
-	{
-		free(fl->p[i]);
-	}
-	free(fl);
-}
-/* approximate the heaviness of a single */
-void fs_approx(char *source, int *files, int *dirs, int *bytes)
-{
-	int sfiles,sdirs,sbytes; 	/* for subdirs */
-	filelist *fl;
-	struct stat s;
-
-	*files=	sfiles=	0;
-	*dirs=	sdirs=	0;
-	*bytes=	sbytes=	0;
-
-/*	printf("start: %d files, %d dirs, %d bytes in %s\n",*files,*dirs,*bytes,source);*/
-	if (-1==stat(source,&s))
-		return;
-/*	printf("%s: %08x (%db)\n",source,s.st_mode,(int)s.st_size);*/
-	if ((s.st_mode&S_IFMT) == S_IFDIR)
-	{
-		
-		fl=fl_new(source);
-		if (fl->n>0)
-			fs_fl_approx(fl,&sfiles,&sdirs,&sbytes);
-		fl_del(fl);
-/*		printf("%d files, %d dirs, %d bytes in %s\n",sfiles,sdirs,sbytes,source);*/
-
-		*files=		sfiles;
-		*bytes+=	sbytes;
-		*dirs=		sdirs;
-		*dirs+=		1;
-	} else 
-		*files=		1;
-	*bytes+=s.st_size;
-/*	printf("end: %d files, %d dirs, %d bytes in %s\n",*files,*dirs,*bytes,source);*/
-}
-/* approximate the heaviness of our source ...*/
-void fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes)
-{
-	int i;
-	int sfiles,sdirs,sbytes; 	/* for subdirs */
-
-	*files=0;
-	*dirs=0;
-	*bytes=0;
-
-	for (i=0;i<fl->n;i++)
-	{
-		fs_approx(fl->p[i],&sfiles,&sdirs,&sbytes);
-		*files+=		sfiles;
-		*dirs+=			sdirs;
-		*bytes+=		sbytes;
-	}
-}
-/* copy a certain file */
-int fs_copy(char *source, char *dest)
-{
-	FILE *fps, *fpd;
-	filelist *fl;
-	struct stat s;
-	char buf[1024];
-	int n;
-	if (-1==stat(source,&s))
-		return(0);
-	switch (s.st_mode&S_IFMT)
-	{
-		case S_IFDIR:
-			fl=fl_new(source);
-		
-			printf("mkdir %s\n",dest);
-			mkdir(dest,0777);
-		
-			fs_fl_copy(fl, dest);
-
-			fl_del(fl);
-			break;
-		case S_IFIFO:
-			printf("link the fifo\n");
-
-			link(source,dest);
-			break;
-		default:
-			printf("atomic copy ... from %s to %s\n", source, dest);
-			if (NULL==(fps=fopen(source,"r"))) return(-1);
-			if (NULL==(fpd=fopen(dest,"w"))) return(-1);
-			/* TODO: overwrite protection etc */
-		
-			while (!feof(fps))
-			{
-				n=fread(buf,1,1024,fps);
-				fwrite(buf,1,n,fpd);
-			}
-			fclose(fps);
-			fclose(fpd);
-
-	}
-	return(0);
-}
-/* copy the source to the destination, destination should be a directory. */
-int fs_fl_copy(filelist *fl, char *dest)
-{
-	int i;
-	int r;
-	char *sdest;
-	char *bname;
-	r=0;
-	for (i=0;i<fl->n;i++)
-	{
-		bname=basename(fl->p[i]);
-		sdest=malloc(strlen(dest)+strlen(bname)+2);
-
-		strcpy(sdest,dest);
-		strcat(sdest,"/");
-		strcat(sdest,bname);
-		r|=fs_copy(fl->p[i],sdest);
-
-		free(sdest);
-	}
-
-	return(r);
-}
-/* recursively unlink a dir or file. */
-int fs_unlink(char *dest)
-{
-	filelist *fl;
-	struct stat s;
-	
-	if (-1==stat(dest,&s))		return(-1);
-	if ((s.st_mode&S_IFMT) == S_IFDIR)
-	{
-		printf("%s is a dir, removing below ...\n",dest);
-		fl=fl_new(dest);
-		if (fs_fl_unlink(fl)) {
-			fl_del(fl);
-			return(-1);
-		} else {
-			fl_del(fl);
-			printf("removing %s\n",dest);
-			if (rmdir(dest)==-1)
-			{
-				perror("fs_fl_unlink(): rmdir()");
-				return(-1);
-			}
-		}
-	} else {
-		if (unlink(dest)==-1)
-		{
-			perror("fs_fl_unlink(): unlink()");
-			return(-1);
-		}
-	}
-	return(0);
-}
-/* remove a lot of files */
-int fs_fl_unlink(filelist *fl)
-{
-	int i,r;
-	r=0;
-	for (i=0;i<fl->n;i++)
-	{
-		printf("-> atomic unlink %s\n",fl->p[i]);
-		r|=fs_unlink(fl->p[i]);
-	}
-	return(r);
-
-}
-int fs_move(char *source, char *dest)
-{
-	if (!rename(source,dest))
-	{
-		switch (errno)
-		{
-			case EXDEV:
-				fs_copy(source,dest);
-				fs_unlink(source);
-				break;
-			default: 
-				perror("fs_move()");
-				return(-1); /* can't help it */
-			
-		}
-	}
-	return(0);	
-}
-
-/* moves the source to the destination */
-int fs_fl_move(filelist *fl, char *dest)
-{
-	int i;
-	int r;
-	char *sdest;
-	char *bname;
-	r=0;
-	for (i=0;i<fl->n;i++)
-	{
-		bname=basename(fl->p[i]);
-		sdest=malloc(strlen(dest)+strlen(bname)+2);
-
-		strcpy(sdest,dest);
-		strcat(sdest,"/");
-		strcat(sdest,bname);
-		r|=fs_move(fl->p[i],sdest);
-
-		free(sdest);
-	}
-
-	return(r);
-
-	return(0);
-}
-
-

Modified: trunk/apps/s3dfm/icon.c
===================================================================
--- trunk/apps/s3dfm/icon.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/icon.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,110 +0,0 @@
-/*
- * icon.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3dfm, a s3d file manager.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include "s3dfm.h"
-#include <stdio.h> 	 /*  printf() */
-#include <math.h>	 /*  sin(),cos() */
-#include <string.h>  /*  strlen() */
-/* draws icon i in the block of dir */
-int icon_draw(t_item *dir,int i)
-{
-	float vertices[]={	-1,-0.5,0,
-						-1, 0.5,0,
-						 1, 0.5,0,
-						 1,-0.5,0,
-						-1,-0.5,-1,
-						-1, 0.5,-1,
-						 1, 0.5,-1,
-						 1,-0.5,-1};
-	unsigned long polys[]={
-				1,3,0,0,				2,3,1,0,
-				5,6,2,0,				1,5,2,0,
-				2,6,7,0,				2,7,3,0,
-				0,3,7,0,				0,7,4,0,
-				5,1,0,0,				5,0,4,0	
-				};
-	float len;
-	float d;
-	int dps;
-	printf("icon_draw( %s )\n",dir->list[i].name);
-	dps=ceil(sqrt(dir->n_item)); /* directories per line */
-	/* find position for the new block in our directory box */
-	dir->list[i].dpx = dir->list[i].px=-1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
-	dir->list[i].dpy = dir->list[i].py=0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
-	dir->list[i].dpz = dir->list[i].pz=1.0;
-	dir->list[i].scale = dir->list[i].dscale = (float)1.0/((float)dps);
-	/* create the block */
-	box_dissolve(&(dir->list[i]));
-	dir->list[i].block=s3d_new_object();
-	s3d_push_vertices(dir->list[i].block,vertices,8);
-	d=((int)(((i+(dps+1)%2*(i/dps)))%2))*0.2;
-	switch (dir->list[i].type)
-	{
-		case T_FOLDER:
-			s3d_push_material(dir->list[i].block,
-									0.4-d,0.4-d,0,
-									0.4-d,0.4-d,0,
-									0.4-d,0.4-d,0);
-			break;
-		default:
-			s3d_push_material(dir->list[i].block,
-									0,0,0.5-d,
-									0,0,0.5-d,
-									0,0,0.5-d);
-	};
-	s3d_push_polygons(dir->list[i].block,polys,10);
-	s3d_link(dir->list[i].block,dir->block);
-
-	/* draw and position the string */
-	if (dir->list[i].str==-1)
-	{
-		dir->list[i].str=s3d_draw_string(dir->list[i].name,&len);
-		if (len<2) len=2;
-		dir->list[i].len=len;
-	}
-	else 
-		len=dir->list[i].len;
-	s3d_scale(dir->list[i].str,(float)1.8/len);
-	s3d_translate(dir->list[i].str,-0.9,-0.3,0.1);
-	s3d_rotate(dir->list[i].str,0,0,0);
-	s3d_link(dir->list[i].str,dir->list[i].block);
-	ani_finish(&dir->list[i],-1); /* apply transformation */
-	dir->list[i].disp=D_ICON;
-	return(0);
-}
-int icon_undisplay(t_item *dir)
-{
-	printf("icon_undisplay( %s )\n",dir->name);
-	if (dir->block!=-1)
-	{
-		s3d_del_object(dir->block);
-		dir->block=-1;
-	}
-	if (dir->str!=-1)
-	{
-		s3d_del_object(dir->str);
-		dir->str=-1;
-	}
-	dir->disp=0;
-	return(0);
-}

Modified: trunk/apps/s3dfm/main.c
===================================================================
--- trunk/apps/s3dfm/main.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/main.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,175 +0,0 @@
-/*
- * main.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3dfm, a s3d file manager.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include "s3dfm.h"
-#include <s3dw.h>	 /* s3dw_ani_mate() */
-#include <stdio.h> 	 /*  printf() */
-#include <dirent.h>  /*  dirent */
-#include <stdlib.h>	 /*  malloc() */
-#include <string.h>  /*  strlen(), strncmp(), strrchr() */
-#include <time.h>	/* nanosleep() */
-static struct timespec t={0,33*1000*1000}; 
-t_item root,cam,*focus;
-
-/* save concatting 2 strings, this version takes argument n
- * as the size of the buffer of dest. */
-char *mstrncat(char *dest, const char *src, int n)
-{
-	int i,j;
-	dest[n-1]=0;						/* for malformed destinations */
-	j=0;
-	for (i=strlen(dest);i<(n-1);i++)
-	{
-		dest[i]=src[j]; 
-		if (dest[i]==0) break;
-		j++;
-	}
-	for (;i<n;i++)
-		dest[i]=0; /* pad the rest with zero */
-	return(dest);
-}
-/* same as strncpy, but have a terminating zero even if
- * source is too big */
-char *mstrncpy(char *dest, const char *src, int n)
-{
-	strncpy(dest,src,n);
-	dest[n-1]=0;
-	return(dest);
-}
-/* writes the path of dir into *path. path should be of type path[M_DIR] */
-void get_path(t_item *dir, char *path)
-{
-	if (dir->parent!=NULL)
-	{
-		get_path(dir->parent,path);
-		mstrncat(path,dir->name,M_DIR);
-		mstrncat(path,"/",M_DIR);
-	} else
-		mstrncpy(path,dir->name,M_DIR);
-}
-/* find the item to a path, return NULL if not parsed yet */
-t_item *get_item(char *path)
-{
-	char p[M_DIR];
-	char *s,*match;
-	t_item *cur;
-	int i;
-	
-	if (path==NULL) return NULL;
-	if (path[0]=='/')
-	{
-		strncpy(p,path,M_DIR);
-		s=p+1;
-		cur=&root;
-	} else return NULL; /* TODO: also process local paths. right now, we are to lazy */
-	printf("processing rest of string %s\n",s);
-	match=s;
-	while ((s=index(s,'/'))!=NULL) { /* while we have slashes inside */
-		s[0]=0; /* mark the slash with space */
-		s++;	/* move to the next */
-		/* parse ... */
-		printf("looking for a match for %s\n",match);
-		for (i=0;i<cur->n_item;i++)
-			if (0==strcmp(cur->list[i].name,match))
-			{ /* found !! */
-				cur=&(cur->list[i]); /* forward */
-				match=s; /* select next */
-				break;
-			}
-		if (i==cur->n_item) {
-			printf("found no match for %s :(\n",match);
-			return NULL; /* not found */
-		}
-	}
-	return(cur);
-}
-/* finds an item in the tree by oid */
-t_item *finditem(t_item *t, int oid)
-{
-	int i;
-	t_item *f;
-	if (t->block==oid)		return(t);
-	if (t->str==oid)		return(t);
-	if (t->close==oid)		return(t);
-	if (t->select==oid)		return(t);
-	if (t->title==oid)		return(t);
-	if (t->titlestr==oid)	return(t);
-	if (t->type==T_FOLDER)
-		for (i=0;i<t->n_item;i++)
-			if ((f=finditem(&(t->list[i]),oid))!=NULL)
-				return(f);
-	return(NULL);
-}
-/* info packets handler, we're just interested in the cam */
-void object_info(struct s3d_evt *hrmz)
-{
-	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz->buf;
-	if ((inf->object==0) && (!ani_onstack(&cam)))
-	{
-		cam.dpx=inf->trans_x;
-		cam.dpy=inf->trans_y;
-		cam.dpz=inf->trans_z;
-	}
-	s3dw_object_info(hrmz);
-}
-void mainloop()
-{
-	ani_mate();
-	s3dw_ani_mate();
-	nanosleep(&t,NULL); 
-}
-int main (int argc, char **argv)
-{
-
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-	s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-	s3d_set_callback(S3D_EVENT_KEY,key_handler);
-	if (!s3d_init(&argc,&argv,"s3dfm"))	
-	{
-		s3d_select_font("vera");
-
-		
-		/* set up file system representation */
-		node_init(&root);
-		strncpy(root.name,"/",M_NAME);
-		focus=&root;
-		root.dscale=0.1;
-		root.type=T_FOLDER;
-		root.str=s3d_draw_string(root.name,&root.len);
-		if (root.len<2) root.len=2;
-		parse_dir(&root);
-		box_expand(&root);
-		ani_doit(&root);
-		ani_focus(&root);
-		
-		node_init(&cam); /* a virtual object, just to push the cam throu our animation stack */
-		cam.block=0;
-		
-		
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dfm/parse.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,189 +0,0 @@
-/*
- * main.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3dfm, a s3d file manager.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3dfm is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dfm is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dfm; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include "s3dfm.h"
-#include <s3dw.h>	 /* s3dw_ani_mate() */
-#include <stdio.h> 	 /*  printf() */
-#include <dirent.h>  /*  dirent */
-#include <stdlib.h>	 /*  malloc() */
-#include <string.h>  /*  strlen(), strncmp(), strrchr() */
-#include <time.h>	/* nanosleep() */
-
-
-/* clear the dirs attributes */
-int node_init(t_item *dir)
-{
-	dir->parent=NULL;
-	dir->list=NULL;
-	dir->n_item=-1;
-
-	dir->block=-1;
-	dir->str=-1;
-	dir->close=-1;
-	dir->select=-1;
-	dir->title=-1;
-	dir->titlestr=-1;
-
-	dir->len=0;
-	dir->disp=0;
-	dir->parsed=0;
-
-	dir->px=root.pz=0.0;
-	dir->dirs_opened=0;
-	dir->type=T_DUNO;
-	dir->px=dir->py=dir->pz=0.0;
-	dir->dpx=dir->dpy=dir->dpz=0.0;
-	dir->scale=dir->dscale=1.0;
-	dir->detached=0;
-
-	return(0);
-}
-int parse_dir(t_item *dir)
-{
-	t_item *list;
-	struct dirent **namelist;
-	int n,i;
-	char *ext,*nstr;
-	char path[M_DIR];
-	char ndir[M_DIR]; 
-	
-	printf("parse_dir( %s )",dir->name);
-/*	if (dir->parsed) return(-1);*/
-	get_path(dir,path);
-/*	printf("scanning %s\n",path);*/
-    n = i = scandir(path, &namelist, 0, alphasort);
-	
-    if (n < 0)
-	{
-        perror("scandir");
-		return(-1);
-	} else {
-		list=malloc(sizeof(t_item)*i);
-		dir->list=list;
-		dir->n_item=n;
-        while(n--) {
-			/* setup kids in the list */
-			node_init(&list[n]);
-			nstr=namelist[n]->d_name;
-			strncpy(list[n].name,nstr,M_NAME);
- 		    if ((0==strncmp(nstr,".",1)) && (strlen(nstr)==1))
-				list[n].type=T_LOCALDIR;
-			else if (0==strncmp(nstr,"..",strlen(nstr)<2?strlen(nstr):2))
-			   list[n].type=T_BACKDIR;
-			else {
-				ext=strrchr(nstr,'.');
-				strncpy(ndir,path,M_DIR);
-		    	strncat(ndir,namelist[n]->d_name,M_DIR);
-			    if ((namelist[n]->d_type==DT_DIR) ||
-					((namelist[n]->d_type==DT_UNKNOWN) && (opendir(ndir)!=NULL)))
-						list[n].type=T_FOLDER;
-				else 
-				{
-				   if (ext!=NULL)
-				   {
-					   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))
-							   list[n].type=T_GEOMETRY;
-					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))
-							   list[n].type=T_MUSIC;
-				   }
-				}
-			}
-			list[n].parent=dir;
-        	free(namelist[n]);
-		}
-		free(namelist);
-		dir->parsed=1;
-   	}
-	return(0);
-}
-void parse_again(t_item *dir)
-{
-	int oldn,redisp;
-	t_item *oldlist;
-	int i,j;
-	oldlist=dir->list;
-	oldn   =dir->n_item;
-	redisp=0;
-	printf("parse_again( %s )\n",dir->name);
-	if (dir->disp==D_DIR)	/* undisplay it later */
-	{ 
-		box_undisplay(dir); 
-		redisp=1; 
-	}
-	parse_dir(dir);
-
-	printf("oldn = %d\n",oldn);
-	if (oldn>0)
-	{
-		/* find old, already displayed contents, and copy the data, or remove them if 
-		 * deleted */
-		
-		for (i=0;i<oldn;i++)
-		{
-			if (oldlist[i].disp == D_DIR)	/* old things expanded as directory */
-			{
-				/* see if it's also in the new list */
-				for (j=0;j<dir->n_item;j++)
-				{
-					if (0==strcmp(oldlist[i].name,dir->list[j].name))
-					{
-						printf("we still have %s - %s (%d,%d) , copy to new list ... \n",dir->list[j].name, oldlist[i].name,j,i);
-						memcpy(&(dir->list[j]),&oldlist[i],sizeof(t_item));
-						break; /* found */
-					}
-				}
-				if (j == dir->n_item) /* not found, collapse it */
-					node_free(&oldlist[i]);
-				else {}/* don't collapse it!! keep as it is */
-			} else node_free(&oldlist[i]);
-		}
-		free(oldlist);
-
-		printf("finished copying old content, redisplay if neccesary\n");
-		if (redisp)
-		{
-			printf("redisplay ... (opened: %d) ", dir->dirs_opened);
-			/* if it was displayed, redisplay it ... */
-			box_expand(dir);
-			printf("done (opened: %d)\n", dir->dirs_opened);
-		}
-	}	
-}
-void node_free(t_item *t)
-{
-	int i;
-	printf("node_free( %s )\n",t->name);
-	switch (t->disp)
-	{
-			case D_DIR:  box_collapse(t,1); /* collapse this and its kids */
-			case D_ICON: icon_undisplay(t);
-	}
-	if (t->n_item>0) {
-		for (i=0;i<t->n_item;i++)
-			node_free(&(t->list[i]));
-		free(t->list);
-	}
-	t->n_item=0;
-}
-

Modified: trunk/apps/s3dgps/s3dgps.c
===================================================================
--- trunk/apps/s3dgps/s3dgps.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dgps/s3dgps.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,395 +0,0 @@
-/*
- * s3dgps.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3dgps, a gps navigator for s3d.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3dgps is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dgps is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dgps; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include <s3d.h>
-#include <gps.h> 	/* gps_*() */
-#ifdef NMEA_CHANNELS
-#define GPS_NEW
-#endif
-#include <stdio.h> 	/* printf() */
-#include <errno.h>  /* errno */
-#include <stdlib.h>	/* malloc(), free() */
-#include <string.h> /* strlen() */
-#include <math.h>	/* sin(),cos(), M_PI */
-#include <simage.h> /* simage things */
-
-#include <time.h>	/* nanosleep() */
-static struct timespec t={0,33*1000*1000}; /* 30 fps */
-
-
-#define PIXELFACT	2817.947378
-#define PIXELFACTN	281794.7378
-#define BFS			1024
-
-#define ICON_ARROW	0
-
-#define ICON_MAX	1
-
-struct map_t {
-	int lng, lat,scale;
-	char path[BFS];
-	struct map_t *next;
-};
-struct point_t {
-	int lng,lat;
-	char name[BFS];
-	int icon;
-	struct point_t *next;
-};
-
-struct gps_data_t 	*dgps;
-int 				 frame=0;
-struct point_t		 posicon;
-int					 iconlist[ICON_MAX];
-char				*iconnames[]={"objs/arrow.3ds"};
-
-unsigned char 		*recode_image(unsigned char *data, int nc, int w, int h);
-int 				 load_mapimage(char *path,float lng, float lat, int scale);
-void 				 parse_mapkoords();
-void				 load_icons();
-void 				 show_gpsdata(struct gps_data_t *dgps);
-void				 show_position(struct gps_data_t *dgps);
-void				 calc_position(float lng, float lat, float *x, float *y, float *z);
-
-void mainloop()
-{
-	if ((frame%60)==0)
-	{
-		printf("polling ...\n");
-		if (gps_poll(dgps) < 0) 
-		{
-			printf("read error on server socket\n");
-			s3d_quit();
-			return;
-		}
-		printf("done");
-		printf("calling show_gpsdata");
-		show_gpsdata(dgps);
-	}
-	show_position(dgps);
-	frame++;
-
-	nanosleep(&t,NULL); 
-}
-
-/* a bad 2d-calculation right now ... */
-void				 calc_position(float lng, float lat, float *x, float *y, float *z)
-{
-	*x=-(lng-12.934980)*50;
-	*y=-3;
-	*z=(lat-50.817515)*50;
-/*	*x=sinf(M_PI*lng/180.0)*cosf(M_PI*lat/180.0);
-	*y=cosf(M_PI*lat/180.0);
-	*z=cosf(M_PI*lng/180.0)*cosf(M_PI*lat/180.0);
-	printf("position for lng/lat %f %f, xyz: %f %f %f, sin-lng:%f\n",lng,lat,*x,*y,*z,sinf(M_PI*lng/180.0));*/
-}
-/* recodes the image if it's not in rgba format */
-unsigned char *recode_image(unsigned char *data, int nc, int w, int h)
-{
-	unsigned char *new_block=NULL;
-	int x,y;
-	switch (nc)
-	{
-		case 1:	new_block=malloc(w*h*4);
-			  	for (y=0;y<h;y++)
-					for (x=0;x<w;x++)
-					{
-						 new_block[(y*w+x)*4]=
-						 new_block[(y*w+x)*4+1]=
-						 new_block[(y*w+x)*4+2]=data[y*w+x];
-						 new_block[(y*w+x)*4+3]=255;
-					}
-				puts("grayscale");
-				free(data);
-			   	break;
-		case 2:	new_block=malloc(w*h*4);
-			  	for (y=0;y<h;y++)
-					for (x=0;x<w;x++)
-					{
-						 new_block[(y*w+x)*4]=
-						 new_block[(y*w+x)*4+1]=
-						 new_block[(y*w+x)*4+2]=data[(y*w+x)*2];
-						 new_block[(y*w+x)*4+3]=data[(y*w+x)*2+1];
-					}
-				puts("grayscale+a");
-				free(data);
-				break;
-		case 3:	new_block=malloc(w*h*4);
-			  	for (y=0;y<h;y++)
-					for (x=0;x<w;x++)
-					{
-						 new_block[(y*w+x)*4]=data[(y*w+x)*3];
-						 new_block[(y*w+x)*4+1]=data[(y*w+x)*3+1];
-						 new_block[(y*w+x)*4+2]=data[(y*w+x)*3+2];
-						 new_block[(y*w+x)*4+3]=255;
-					}
-				puts("rgb");
-				free(data);
-				break;
-		case 4:	new_block=data;
-			   	puts("rgba");
-				break;
-	}
-	return(new_block);
-}
-int 				 load_mapimage(char *path,float lng, float lat, int scale)
-{
-	int w,h,nc;
-	float x,y,z;
-	double wr,hr,er;
-	unsigned char *data;
-	int oid=-1;
-	if (simage_check_supported(path))
-	{
-		printf("file %s can be loaded!!\n",path);
-		data=simage_read_image(path,&w,&h,&nc);
-		data=recode_image(data,nc,w,h);
-		oid=s3d_new_object();
-		er=6378.2; /* earth radius */
-		hr=(180*asin(((1.024*scale)/(PIXELFACT*2))/er))/M_PI; /* half height of card in degress */
-		er=6378.2*cos((lat*180)/M_PI); /* radius at latitude position ... */
-		wr=-(180*asin(((1.37*scale)/(PIXELFACT*2))/er))/M_PI; /* half width of card in degress */
-		printf("wr = %f, hr = %f slice radius for wr =%f \n",hr,wr,er);
-		calc_position(lng-wr,lat-hr,&x,&y,&z);
-		y-=scale/10000000.0;
-		s3d_push_vertex(oid,x,y,z);
-		calc_position(lng+wr,lat-hr,&x,&y,&z);
-		y-=scale/10000000.0;
-		s3d_push_vertex(oid,x,y,z);
-		calc_position(lng+wr,lat+hr,&x,&y,&z);
-		y-=scale/10000000.0;
-		s3d_push_vertex(oid,x,y,z);
-		calc_position(lng-wr,lat+hr,&x,&y,&z);
-		y-=scale/10000000.0;
-		s3d_push_vertex(oid,x,y,z);
-		s3d_push_material_a(oid,
-						0.8,	0.0,	0.0	,1.0,
-						1.0,	1.0,	1.0	,1.0,
-						0.8,	0.0,	0.0	,1.0);
-		s3d_push_polygon(oid,0,1,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
-									   1.0,0.0,
-									   1.0,1.0);
-		s3d_push_polygon(oid,0,2,3,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
-									   1.0,1.0,
-									   0.0,1.0);
-		s3d_push_texture(oid,w,h);		
-		s3d_load_texture(oid,0,0,0,w,h,(unsigned char *)data);
-		free(data);
-		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
-	} else {
-		printf("can't load %s\n",path);
-	}
-	return(oid);
-}
-void load_icons()
-{
-	int i;
-	
-	for (i=0;i<ICON_MAX;i++)
-		iconlist[i]=s3d_import_3ds_file(iconnames[i]);	
-}
-void show_gpsdata(struct gps_data_t *dgps)
-{
-/*	if (!dgps->online) 
-		printf("WARNING: no connection to gps device\n");
-	printf("[%d] lat/long: [%f|%f], altitude %f\n",frame,dgps->latitude,dgps->longitude,dgps->altitude);
-	printf("speed [kph]: %f",dgps->speed/KNOTS_TO_KPH);
-	printf("used %d/%d satellits\n",dgps->satellites_used,dgps->satellites);
-	switch (dgps->status)
-	{
-		case STATUS_NO_FIX:		printf("status: no fix");break;
-		case STATUS_FIX:		printf("status: fix");break;
-		case STATUS_DGPS_FIX:	printf("status: dgps fix");break;
-	}
-	switch (dgps->mode)
-	{
-		case MODE_NOT_SEEN:	printf("mode: not seen yet\n");break;
-		case MODE_NO_FIX:	printf("mode: no fix\n");break;
-		case MODE_2D:		printf("mode: 2d fix\n");break;
-		case MODE_3D:		printf("mode: 3d fix\n");break;
-	}*/
-}
-int lastfix=0;
-void show_position(struct gps_data_t *dgps)
-{
-	int fix=1;
-	float x,y,z,p;
-#ifdef GPS_NEW
-	if (!dgps->online) 
-		fix=0;
-	switch (dgps->fix.mode)
-	{
-		case MODE_NOT_SEEN:	fix=0;break;
-		case MODE_NO_FIX:	fix=0;break;
-	}
-	if (fix) {
-		calc_position(dgps->fix.longitude,dgps->fix.latitude,&x,&y,&z);
-#else
-	if (!dgps->online) 
-		fix=0;
-	switch (dgps->mode)
-	{
-		case MODE_NOT_SEEN:	fix=0;break;
-		case MODE_NO_FIX:	fix=0;break;
-	}
-	if (fix) {
-		calc_position(dgps->longitude,dgps->latitude,&x,&y,&z);
-#endif
-/*		calc_position(dgps->latitude,dgps->longitude,&x,&y,&z);*/
-		p=sin(M_PI*((2*frame)%180)/180.0);
-/*		if (p<0.0) p*=-1.0;*/
-		s3d_translate(posicon.icon,x,y+p,z);
-		if (!lastfix)
-			s3d_flags_on(posicon.icon,S3D_OF_VISIBLE);
-	}
-	else 
-		if (lastfix)
-			s3d_flags_off(posicon.icon,S3D_OF_VISIBLE);
-	lastfix=fix;
-}
-/*
-static void update(struct gps_data_t *gpsdata, char *message)
-{
-	printf("updating!!");
-}*/
-void parse_mapkoords()
-{
-	FILE *fp;
-	char buf[BFS],*ptr,*sptr,*filename=NULL,c;
-	char path[BFS];
-	char *prefix="/home/dotslash/.s3dgps/";
-	int len;
-	int word;
-	double lng,lat;
-	int i;
-	long scale;
-	lng=lat=0;
-	scale=0;
-	
-	strncpy(path,prefix,BFS);
-	strncpy(path+strlen(path),"map_koord.txt",BFS);
-	if (NULL!=(fp=fopen(path,"r")))
-	{
-		while (!feof(fp))
-		{
-			ptr=buf;
-			/* read one line */
-			while ((ptr<(buf+BFS+2)))
-			{
-				if (!fread(ptr,1,1,fp))
-					break;
-				c=*ptr;
-				if ((c=='\n') || (c=='\0'))
-					break;
-				ptr++;
-			}
-			*ptr='\0';
-			len=strlen(buf);
-			/* now we have one line in the buffer, proably */
-			sptr=buf;
-			word=0;
-			do {
-				ptr=sptr;
-				/* get word */
-				while ((ptr-buf)<len)
-				{
-					c=*ptr;
-					if ((c=='\t') || (c=='\n') || (c==' ') || (c=='\0'))
-					break;
-					ptr++;
-				}
-				*(ptr)='\0';
-				switch (word)
-				{
-					case 0: filename=sptr;break;
-					case 1: lat=strtod(sptr,NULL);break;
-					case 2: lng=strtod(sptr,NULL);break;
-					case 3: scale=strtol(sptr,NULL,10);break;
-				}
-				if (word==3)
-				{
-					strncpy(path,prefix,BFS);
-					strncpy(path+strlen(path),filename,BFS);
-					printf("going to load %s (located at %f %f with scale %d)\n",path,lng,lat,(int)scale);
-/*					if ((scale>1000) && (scale<100000))*/
-					{
-						i=load_mapimage(path,lng,lat,scale);
-						s3d_flags_on(i,S3D_OF_VISIBLE);
-					}
-				}
-				sptr=(ptr+1); /* move to next word */
-				word++;
-			} while ((ptr-buf)<len);
-		}
-		fclose(fp);
-	}
-}
-int main(int argc, char **argv)
-{
-	char *gpshost;
-	char *err_str;
-	if (argc>1)
-		gpshost=argv[1];
-	else 
-		gpshost="localhost";
-	if (!s3d_init(&argc,&argv,"s3dgps")) 
-	{
-		printf("connecting to %s\n",gpshost);
-		dgps=gps_open(gpshost,"2947");
-	    if (dgps==NULL) {
-			switch ( errno ) {
-				case NL_NOSERVICE: 	err_str = "can't get service entry"; break;
-				case NL_NOHOST: 	err_str = "can't get host entry"; break;
-				case NL_NOPROTO: 	err_str = "can't get protocol entry"; break;
-				case NL_NOSOCK: 	err_str = "can't create socket"; break;
-				case NL_NOSOCKOPT: 	err_str = "error SETSOCKOPT SO_REUSEADDR"; break;
-				case NL_NOCONNECT: 	err_str = "can't connect to host"; break;
-				default:             	err_str = "Unknown"; break;
-			}
-			printf("no connection to gpsd\n");
-			fprintf( stderr, "xgps: no gpsd running or network error: %d, %s\n"	, errno, err_str);
-		} else {
-			parse_mapkoords();
-			load_icons();
-			/* init the position */
-			posicon.lng=0;
-			posicon.lat=0;
-			posicon.icon=s3d_clone(iconlist[ICON_ARROW]);
-			posicon.next=NULL;
-			
-			printf("connection established !!\n");
-			printf("query ...\n");
-			gps_query(dgps, "w+x\n");
-			printf("done\n");
-			s3d_mainloop(mainloop);
-			printf("done\n");
-			gps_close(dgps);
-		}
-		s3d_quit(); 
-	}
-	printf("program finished\n");
-	return(0);
-}

Modified: trunk/apps/s3dvt/main.c
===================================================================
--- trunk/apps/s3dvt/main.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dvt/main.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,594 +0,0 @@
-/*
- * main.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- * Copyright (C) 2002 Alexander Graf <helly at gmx.net>
- *
- * This file is part of s3dvt, a 3d terminal emulator for s3d.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3dvt is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dvt is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dvt; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include "s3dvt.h"
-#include <stdio.h> 		 /*  FILE,NULL */
-#include <unistd.h> 	 /*  read(),write(), sleep(),close() ... */
-#include <errno.h>		 /*  errno() */
-#include <fcntl.h> 		 /*  open() */
-#include <signal.h>		 /*  signal() */
-#include <stdlib.h>		 /*  exit(),getenv(),setenv() */
-#include <sys/ioctl.h> 	 /*  ioctl() */
-#include <pthread.h>	 /*  pthread_create() */
-#include <s3d.h>		 /*  s3d_* */
-#include <s3d_keysym.h>	 /*  key symbols */
-#include <time.h>	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-
-
-static int pid;
-static int term_mode=0;
-
-static int cursor;		/* the object id of the cursor */
-
-static pthread_t term_thread;
-
-#ifdef M_PIPE
-static int mpipe_in[2];
-static int mpipe_out[2];
-#endif
-#ifdef M_PTY
-static int curtty,curpty;
-#endif
-
-#ifdef M_CHAR
-static unsigned int charbuf[256];
-static unsigned int screenbuf[MAX_LINES*MAX_CHARS];
-static char 		last_c[MAX_LINES*MAX_CHARS];
-#endif
-
-#ifdef M_LINE
-static int 			lines[MAX_LINES];
-#endif
-
-void *thread_terminal(void *a)
-{
-	int iscon=1,ret;
-	char buffer[1024];
-	while(iscon) 
-	{
-		switch (term_mode)
-		{
-			case M_PIPE:
-				ret=read(mpipe_out[0], &buffer, 1000);
-				break;
-			case M_PTY:
-				ret=read(curpty, &buffer, 1000);
-				break;
-			default:
-				ret=-1;
-		}
-		if(ret>0) 
-		{ 
-			buffer[ret]='\0';
-			printf("<<<new data(%d bytes)\n", ret);
-			AddChar(buffer);
-		} else {
-			if (ret==-1)
-			{
-				perror("read()");
-				printf("Connection to pty lost (ret=%d)\n",ret); 
-				close(mpipe_in[0]);
-				close(mpipe_out[1]);
-		/* 		close(curpty);  */
-		/* 		close(curtty);  */
-				printf("********CONNECTION TO PTY LOST!*******\n");
-				sleep(1);
-				s3d_quit();
-				exit(0);
-			}
-		}
-    }
-	return(NULL); /* huh?! */
-}
-int pty_init_terminal()
-{
-    int i;
-    char buf[256];
-    char tmpstr[1024];
-    int curtty;
-    int uid=0,gid=0;
-    char exe[]="/bin/bash";
-    char curchar;
-    char *disp;
-    
-    disp=getenv("DISPLAY");
-    uid=getuid();
-    gid=getgid();
-	term_mode=M_PTY;
-    for(curchar='p'; curchar<'z';curchar++) 
-	{
-		for(i=0;i < 16;i++) 
-		{
-			sprintf(buf, "/dev/pty%c%x", curchar, i);
-			curpty=open(buf, O_RDWR);
-			if (curpty >= 0) 
-				goto endloop;
-		}
-    }
-endloop:
-    if(curpty < 0) {
-		printf("Error opening pty\n"); 
-		return 0; 
-	}
-/* 	fnctl(F_SETFL,O_NONBLOCK); */
-	signal(SIGCHLD, SIG_IGN);
-    pid = fork();
-	if(!pid) 
-	{
-	    buf[5]='t';
-	    curtty=open(buf, O_RDWR);
-	    if (curtty < 0) { 
-			printf("Error opening tty\n"); 
-			return 0; 
-		}
-	    setuid(uid);
-	    setgid(gid);
-	    if(setsid()<0) 
-			printf("ERROR (setsid)\n"); 
-	/*     tcflush(curpty, TCIOFLUSH); */
-	    if(ioctl(curtty, TIOCSCTTY, NULL)) 
-			printf("ERROR! (ttyflush)\n");;
-	    dup2(curtty, 0);
-	    dup2(curtty, 1);
-	    dup2(curtty, 2);
-	    sprintf(tmpstr, "%d", MAX_LINES-1);
-	    setenv("LINES", tmpstr, 1);
-	    sprintf(tmpstr, "%d", MAX_CHARS-1);
-	    setenv("COLUMNS", tmpstr, 1);
-	    setenv("TERM", "rxvt", 1);
-	    execl(exe, exe, NULL);
-		sleep(1);
-		printf("that's it, exiting");
-		close(curtty);
-		exit(0);
-	} else if(pid<0) {
-		printf("Cant fork()\n");
-		exit(0);
-	} else {
-    	pthread_create(&term_thread, NULL, thread_terminal, NULL);
-	}
-    return 1;
-}
-/*  terminal.c */
-void term_addchar(char toprint)
-{
-/*    printf("sending: %.3d\n", toprint);*/
-	switch (term_mode)
-	{
-		case M_PIPE:
-			write(mpipe_in[1],&toprint,1);
-			write(mpipe_out[1],&toprint,1);
-			break;
-		case M_PTY:
-			write(curpty, &toprint, 1);
-			break;
-	}
-}
-
-
-int pipe_init_terminal()
-{
-    char buf[256];
-    int uid=0,gid=0;
-    char *exe="/bin/bash";
-    char *args="-i";
-    char *disp;
-
-	term_mode=M_PIPE;
-	if ((pipe(mpipe_in)==-1) || (pipe(mpipe_out)==-1))
-	{
-		printf("pipe failed\n");
-		return(-1);
-	}
-    disp=getenv("DISPLAY");
-    uid=getuid();
-    gid=getgid();
-    pid = fork();
-	if(pid==0) 
-	{  /*  the child */
-	    char tmpstr[1024];
-	    buf[5]='t';
-	    setuid(uid);
-	    setgid(gid);
-	    if(setsid()<0) 
-			printf("ERROR (setsid)\n"); 
-/*     tcflush(curpty, TCIOFLUSH); */
-/*     if(ioctl(curtty, TIOCSCTTY, NULL)) printf("ERROR! (ttyflush)\n");; */
-		setvbuf(stdout,(char*)NULL,_IONBF,0);
-	    dup2(mpipe_in[0], fileno(stdin));
-	    dup2(mpipe_out[1], fileno(stdout));
-	    dup2(mpipe_out[1], fileno(stderr));
-		 /*  close unneded things: */
-		close(mpipe_out[0]); 
-		close(mpipe_in[1]); 
-	    sprintf(tmpstr, "%d", MAX_LINES-1);
-	    setenv("LINES", tmpstr, 1);
-	    sprintf(tmpstr, "%d", MAX_CHARS-1);
-	    setenv("COLUMNS", tmpstr, 1);
-	    setenv("TERM", "rxvt", 1);
-	    execl(exe, exe, args,NULL);
-		printf("that's it, exiting");
-		close(curtty);
-		exit(0);
-   } else if(pid<0) {
-    printf("Cant fork()\n");
-	exit(0);
-   } else {
-	 /*  close unneded things... */
-		close(mpipe_in[0]);
-	    pthread_create(&term_thread, NULL, thread_terminal, NULL);
-   }
-    return 1;
-}
-int init_terminal()
-{
-	int i;
-	for (i=0;i<5;i++)
-		if (pty_init_terminal())  /*  find an open pty. */
-			return(0);
-	return(pipe_init_terminal());  /*  if not, fallback to pipe mode */
-}
-void term_unload()
-{
-	printf("unloading tty!!\n");
-	switch (term_mode)
-	{
-		case M_PTY:
-			write(curpty, '\0', 1);  /*  send an EOF, just in case */
-		    close(curpty);
-		    close(curtty);
-			 /* kill(pid); */
-			break;
-		case M_PIPE:
-			 /*  bash should fade with "broken pipe" */
-			close(mpipe_in[1]);
-			close(mpipe_out[0]);
-			break;
-	}
-}
-#ifdef M_CHAR
-void paintit()
-{
-	int cline;
-	int c;
-	unsigned char ch,och;
-	unsigned int ci;
-	int i,line_end;
-
-	s3d_translate(	cursor,cx*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cy*CS + CS*MAX_LINES/2,0);
-	s3d_scale(		cursor,CS);
-	for(cline=0;cline<MAX_LINES;cline++)
-	{
-		line_end=0;
-		for (c=0;c<MAX_CHARS;c++)
-		{
-			i=cline*MAX_CHARS+c;			 /*  calculate position */
-			if (((ch=line[cline].chars[c].character)!=(och=last_c[i])))
-			{
-				if (screenbuf[i]==-1)
-				{
-					screenbuf[i]=s3d_new_object();
-					s3d_translate(screenbuf[i],c*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cline*CS + CS*MAX_LINES/2,0);
-					s3d_scale(screenbuf[i],CS);
-					s3d_flags_on(screenbuf[i],S3D_OF_VISIBLE);
-				}
-				if ((ch==0) || (line_end))
-				{	/*  the new character is zero! delete! */
-					line[cline].chars[c].character=0;
-					ci=charbuf[' '];
-					s3d_clone_target(screenbuf[i],ci);
-					line_end=1;
-/* 					printf("-%03d",ch); */
-				} else {
-					ci=charbuf[ch];
-/* 					printf("!%03d",ch); */
-					s3d_clone_target(screenbuf[i],ci);
-				}
-			} else {
-/* 				printf("=%03d",ch); */
-			} 
-			last_c[i]=ch;			
-		}
-/* 		printf("\n"); */
-	}
-	gotnewdata=0;
-}
-#endif
-#ifdef M_LINE
-void paintit()
-{
-	int cline;
-	int oid,c;
-	int len;
-	int changed;
-	char cl[MAX_CHARS];
-	for(cline=0;cline<MAX_LINES;cline++)
-	{
-		len=MAX_CHARS;
-		changed=0;
-		for (c=MAX_CHARS;c>=0;c--)
-		{
-			cl[c]=line[cline].chars[c].character;
-			if (line[cline].chars[c].character!=line[cline].chars[c].last_c)
-			{
-				changed=c+1;
-/*				printf("changed [%d/%d] from %d to %d\n",cline,c,
-								line[cline].chars[c].last_c,
-								line[cline].chars[c].character
-								);*/
-				line[cline].chars[c].last_c=line[cline].chars[c].character;
-			}
-			if (cl[c]==0) len=c;
-		}
-		if (changed)
-		{
-		if (len>0)
-		{
-			printf("[p: line %d [len: %d/changed: %d]\n",cline,len,changed);
-			oid=s3d_draw_string(cl,NULL);
-			s3d_translate(oid,0,-cline,0);
-			if (lines[cline]!=-1) 
-			{
-				s3d_del_object(lines[cline]);
-				lines[cline]=-1;
-			}
-			s3d_flags_on(oid,S3D_OF_VISIBLE);
-			lines[cline]=oid;
-		} else {
-			if (lines[cline]!=-1)
-			{
-				s3d_del_object(lines[cline]);
-				lines[cline]=-1;
-			}
-		}
-		}
-		
-	}
-	gotnewdata=0;
-}
-#endif
-/*
-void paint_chars()
-{
-	char c;
-	int oid;
-	int cline,cchar;
-	for(cline=0;cline<MAX_LINES;cline++)
-	{
-	    for(cchar=0;cchar<MAX_CHARS;cchar++)
-		{
-			c=line[cline].chars[cchar].character;
-/ * 			printf("%02x|",c); * /
-	        if(!islastchar(cline,cchar))
-	         if(line[cline].chars[cchar].character && line[cline].chars[cchar].character != ' ')
-			 {
-/ * 				if (screenbuf[MAX_LINES*MAX_CHARS]!=-1) s3d_del_object(screenbuf[MAX_LINES*MAX_CHARS]); * /
-				oid=s3d_clone(cobjs[c]);
-				s3d_translate(oid,10*cchar,10*cline,0);
-				s3d_flags_on(oid,S3D_OF_VISIBLE);
-				screenbuf[MAX_LINES*MAX_CHARS]=oid;
-			 }
-	    }
-/ * 		printf("\n"); * / 
-	}
-}*/
-void keypress(struct s3d_evt *event)
-{
-	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
-	int key;
-/*	printf("received key: %d\n",key);*/
-	switch (key=keys->keysym)
-	{
-		case S3DK_F1:
-		case S3DK_F2:
-		case S3DK_F3:
-		case S3DK_F4:
-		case S3DK_F5:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('1');
-			term_addchar(key-S3DK_F1+'1');
-			break;
-		case S3DK_F6:
-		case S3DK_F7:
-		case S3DK_F8:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('1');
-			term_addchar((key-S3DK_F6)+'7');
-			break;
-		case S3DK_F9:
-		case S3DK_F10:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('2');
-			term_addchar((key-S3DK_F9)+'0');
-			break;
-		case S3DK_F11:
-		case S3DK_F12:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('2');
-			term_addchar((key-S3DK_F11)+'3');
-			break;
-		case S3DK_UP:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('A');
-			break;
-		case S3DK_DOWN:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('B');
-			break;
-		case S3DK_RIGHT:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('C');
-			break;
-		case S3DK_LEFT:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('D');
-			break;
-		case S3DK_PAGEUP:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('5');
-			term_addchar('~');
-			break;
-		case S3DK_PAGEDOWN:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('6');
-			term_addchar('~');
-			break;
-		case S3DK_HOME:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('7');
-			term_addchar('~');
-			break;
-		case S3DK_END:
-			term_addchar(0x1b);
-			term_addchar('[');
-			term_addchar('8');
-			term_addchar('~');
-			break;
-		case 13:
-			term_addchar(10);
-			break;
-		default:
-			if ((char)keys->unicode)  /*  \0 is no good idea .. */
-				term_addchar((char)keys->unicode);
-	}
-
-}
-int i=0;
-void mainloop()
-{
-	usleep(10000);
-	nanosleep(&t,NULL); 
-
-	if ((i+=2)>100)
-	{
-		if (i%2)
-		{
-			s3d_flags_on(cursor,S3D_OF_VISIBLE);
-			i=0;
-		}
-		else
-		{
-			s3d_flags_off(cursor,S3D_OF_VISIBLE);
-			i=1;
-		}
-	}
-	if (gotnewdata) {
-/* 		printf("got new data,displaying\n"); */
-		paintit();
-	}
-}
-void stop(struct s3d_evt *event)
-{
-	s3d_quit();
-}
-unsigned int draw_background()
-{
-	unsigned int b;
-	b=s3d_new_object();
-	s3d_push_vertex(b,-MAX_CHARS/2*X_RATIO*CS	,CS	+CS*MAX_LINES/2		,-0.01);
-	s3d_push_vertex(b, MAX_CHARS/2*X_RATIO*CS	,CS	+CS*MAX_LINES/2		,-0.01);
-	s3d_push_vertex(b, MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
-	s3d_push_vertex(b,-MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
-	s3d_push_material_a(b,0.5,0.5,0.5,0.7,
-						  1,1,1,0.7,
-						  0,0,0,0.7);
-	s3d_push_polygon(b,1,2,0,0);
-	s3d_push_polygon(b,2,3,0,0);
-	s3d_flags_on(b,S3D_OF_VISIBLE);
-	return(b);
-}
-void chars_s3d_init()
-{
-#ifdef M_CHAR
-	char c[2];
-	c[1]='\0';
-	for (i=0;i<128;i++)
-	{
-		c[0]=i;
-		charbuf[i]=s3d_draw_string(c,NULL);
-	}
-	for (i=128;i<256;i++)
-	{
-		charbuf[i]=s3d_new_object();
-	}
-	cursor=s3d_new_object();
-	s3d_clone_target(cursor,charbuf['_']);
-#endif
-}
-void chars_init()
-{
-#ifdef M_CHAR
-	int x,y;
-	for (y=0;y<(MAX_LINES);y++)
-	for (x=0;x<(MAX_CHARS);x++)
-	{
-		line[y].chars[x].character=line[y].chars[x].character=0;
-		i=y*MAX_CHARS+x;
-		screenbuf[i]=-1;
-		last_c[i]=0;
-	}
-#endif
-#ifdef M_LINE
-	int i;
-	for (i=0;i<MAX_LINES;i++)
-		lines[i]=-1;
-#endif
-}
-int main (int argc, char **argv)
-{
-	unsigned int b;
-	chars_init();
-   	init_terminal();
-	s3d_set_callback(S3D_EVENT_QUIT,stop);
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,stop);
-	s3d_set_callback(S3D_EVENT_KEY,keypress);
-
-	if (!s3d_init(&argc,&argv,"s3dvt"))	
-	{
-		if (s3d_select_font("vera"))
-		{
-			printf("font not found");
-			exit(-1);
-		}
-		b=draw_background();
-		chars_s3d_init();
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	term_unload();
-	return(0);
-}

Modified: trunk/apps/s3dvt/terminal.c
===================================================================
--- trunk/apps/s3dvt/terminal.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/apps/s3dvt/terminal.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,513 +0,0 @@
-/*
- * terminal.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- * Copyright (C) 2002 Alexander Graf <helly at gmx.net>
- *
- * This file is part of s3dvt, a 3d terminal emulator for s3d.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3dvt is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3dvt is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3dvt; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include "s3dvt.h"
-#include <stdio.h> 		 /*  NULL,perror() */
-#include <string.h>		 /*  memcpy() */
-#include <stdlib.h>		 /*  atoi() */
-#define MOVE_RIGHT 	1
-#define MOVE_LEFT 	2
-#define MOVE_UP	 	3
-#define MOVE_DOWN 	4
-
-
-int cx=0,cy=0;
-
-int gotnewdata=1;
-t_line line[MAX_LINES+1];
-static int isansi=0;
-static int isansi2=0;
-
-static int bottom=MAX_LINES-1;
-static int top=0;
-
-static int curfgcolor=DEFAULT_FGCOLOR;
-static int curbgcolor=DEFAULT_BGCOLOR;
-
-void move_all_lines_up()
-{
-    t_line *pfirstline=(t_line*)&line;
-    t_line *psecondline=(t_line*)&line+1;
-    t_line tmpline[MAX_LINES];
-    memcpy(&tmpline, psecondline, (MAX_LINES-1)*sizeof(struct line_struct));
-    memcpy(pfirstline, &tmpline, (MAX_LINES-1)*sizeof(struct line_struct));
-}
-
-void clear_char(int lineid, int charid)
-{
-    line[lineid].chars[charid].character=0;
-    line[lineid].chars[charid].fgcolor=DEFAULT_FGCOLOR;
-    line[lineid].chars[charid].bgcolor=DEFAULT_BGCOLOR;
-}
-
-void clear_line(int lineid)
-{
-    int i;
-    for(i=0;i<MAX_CHARS;i++)
-		clear_char(lineid, i);
-}
-
-void clear_line_after_lastchar()
-{
-    int i;
-    for(i=cx;i<MAX_CHARS;i++) 
-		clear_char(cy, i);
-}
-
-t_line *line_is_full()
-{
-    t_line *pcurline=(t_line*)&line+cy;
-    cy++;
-    if (cy>=MAX_LINES) {       /*  damn it ... our display is filled ... let's move everything upwards */
-		cy=MAX_LINES-1;
-		pcurline=(t_line*)&line+cy;
-        move_all_lines_up();
-        clear_line(cy);
-		gotnewdata=1;
-    } else {
-        pcurline=(t_line*)&line+cy;
-    }
-	cx=0;
-    return pcurline;
-}
-
-void add_char_append(char toappend)
-{
-    int shouldinc=1;
-    t_line *pcurline=(t_line*)&line+cy;
-    if (cx==MAX_CHARS-1)
-	{ 
-		pcurline=line_is_full(); 
-		shouldinc=0; 
-	}  /*  our line is full */
-    pcurline->chars[cx].character=toappend;
-    pcurline->chars[cx].fgcolor=curfgcolor;
-    pcurline->chars[cx].bgcolor=curbgcolor;
-    if(shouldinc) 
-		cx++;
-}
-
-void backspace()
-{
-    if(cx>0)
-		cx--;
-    else 
-		cx=0;
-}
-
-void endansi()
-{
-    printf(" [/ANSI(%d)]\n", isansi2);
-    isansi=0;
-    isansi2=0;
-}
-
-/*
-              Parameter                              Parameter Meaning                                     
-	      
-	      0                                      Attributes off                                                                                      
-	      1                                      Bold or increased intensity                                                                                       
-	      4                                      Underscore                                                                                            
-	      5                                      Blink                                                                                                     
-	      7                                      Negative (reverse) image                                                                           
-*/	      
-
-void ansi_change_graphic(char **args)
-{
-    int curcol;
-    int i;
-    
-    if (args[0][0]=='\0') 
-	{
-		args[0][0]='0';
-		args[0][1]='\0';
-	}
-    
-    for(i=0;i<5;i++)
-	{
-		if(args[i][0])
-		{
-		    curcol=atoi(args[i]);
-			
-			switch(curcol)
-			{
-			    case 0:
-					curbgcolor=DEFAULT_BGCOLOR;
-					curfgcolor=DEFAULT_FGCOLOR;
-					break;
-			    case 1:	 /*  Bold or increased intensity */
-			    case 4:	 /*  Underscore */
-			    case 5:	 /*  Blink */
-			    case 7:	 /*  Negative (reverse) image */
-			    case 10:	 /*  primary font */
-			    case 11:	 /*  alternate font */
-					break;
-				case 30:
-				case 31:
-				case 32:
-				case 33:
-				case 34:
-				case 35:
-				case 36:
-				case 37:
-					curfgcolor=curcol-30;
-					break;
-			    case 39:
-					curbgcolor=DEFAULT_FGCOLOR;
-					break;
-				case 40:
-				case 41:
-				case 42:
-				case 43:
-				case 44:
-				case 45:
-				case 46:
-				case 47:
-					curbgcolor=curcol-40;
-					break;
-	
-			    case 49:
-					curbgcolor=DEFAULT_BGCOLOR;
-					break;
-	
-			    default:
-					printf("*** don't know color-code %d\n", curcol);
-					break;
-		    }
-		}
-    }
-}
-void move_up_x_lines(char *arg)
-{
-    t_line *pfirstline;
-    t_line *psecondline;
-    t_line tmpline[MAX_LINES];
-    int amount;
-    int i;
-    
-    if(arg[0]) amount=atoi(arg); else amount=0;
-    
-    printf("moving up %d lines", amount);
-    
-    for(i=0;i<amount;i++)
-	{
-    
-		pfirstline=(t_line*)&line+cy;
-		psecondline=pfirstline+1;
-    
-		memcpy(&tmpline, psecondline, (bottom-top)*sizeof(struct line_struct));
-		memcpy(pfirstline, &tmpline,  (bottom-top)*sizeof(struct line_struct));
-    
-    }
-}
-
-void move_down_x_lines(char *arg)
-{
-    t_line *pfirstline;
-    t_line *psecondline;
-    t_line tmpline[MAX_LINES];
-    int amount;
-    int i;
-    
-    if(arg[0]) amount=atoi(arg); else amount=0;
-    
-    printf("moving down %d lines", amount);
-    
-    for(i=0;i<amount;i++)
-	{
-		pfirstline=(t_line*)&line+cy;
-		psecondline=pfirstline+1;
-    
-		memcpy(&tmpline, pfirstline, (bottom-top)*sizeof(struct line_struct));
-		memcpy(psecondline, &tmpline,  (bottom-top)*sizeof(struct line_struct));
-    }
-}
-void delete_x_letters(char *arg1)
-{
-    int tmpint;t_line *pcurline;int i;
-	if(arg1[0]) tmpint=atoi(arg1);
-	else	    tmpint=1;
-	pcurline=(t_line*)&line+cy;
-	if (tmpint+cx>MAX_CHARS) 
-		tmpint=MAX_CHARS-cx;
-	for(i=cx;i<cx+tmpint;i++)
-	    clear_char(cy,i);
-}
-void move_x_letters(int mode, char *arg1)
-{
-    int tmpint;t_line *pcurline;int i;
-	if(arg1[0])
-	    tmpint=atoi(arg1);
-	else
-	    tmpint=1;
-	pcurline=(t_line*)&line+cy;
-	switch(mode) {
-	    case MOVE_RIGHT:
-	        for(i=0;i<tmpint;i++)
-			{
-/*	    	    pcurline->nextchar++; 
-				lastchar++;*/
-				cx++;
-		    	if (cx==MAX_CHARS) 
-					pcurline=line_is_full();  /*  our line is full */
-			}
-			break;
-	    case MOVE_LEFT:
-	        for(i=0;i<tmpint;i++)
-			{
-				cx--;
-			    if(cx==-1) 
-				{ 
-					cy--; 
-					pcurline=(t_line*)&line+cy; 
-					cx=MAX_CHARS-1; 
-				}  /*  need to go up one line */
-			}
-			break;
-	    case MOVE_UP:
-			cy--;
-			break;
-	    case MOVE_DOWN:
-			line_is_full();
-			break;
-	    default:
-			break;
-	}
-}
-void remove_beginning_from_curpos()
-{
-    int i,j=cx;
-    for(i=cy;i<MAX_LINES;i++) {
-	for(;j<MAX_CHARS;j++){
-	    clear_char(i,j);
-	}
-	j=0;
-    }
-}
-
-int parseansi(char curchar)
-{
-	static char arg1[16]="";
-	static char arg2[16]="";
-	static char arg3[16]="";
-	static char arg4[16]="";
-	static char arg5[16]="";
-	static char curindex=0;
-	static char curarg=0;
-	static char *args[]={arg1,arg2,arg3,arg4,arg5};
-	/* 	static char *args[]={&arg1,&arg2,&arg3,&arg4,&arg5}; */
-	    printf("%c", curchar);
-	switch (isansi2)
-	{
-	case 1:
-		switch(curchar)
-		{
-		    case '0':
-		    case '1':
-		    case '2':
-		    case '3':
-		    case '4':
-		    case '5':
-		    case '6':
-		    case '7':
-		    case '8':
-		    case '9':  /*  we got an argument */
-				args[(int)curarg][(int)curindex]=curchar;
-				curindex++; 
-				args[(int)curarg][(int)curindex]='\0';
-				break;
-		    case ';':  /*  some arg is finished */
-				curarg++; 
-				curindex=0; 
-				args[(int)curarg][0]='\0';
-				break;
-		    case 'J':  /*  remove beginning from current cursor to end of screen */
-				remove_beginning_from_curpos();
-				gotnewdata=1;
-				break;
-		    case 'K':  /*  remove everything in line beginning from lastchar */
-				clear_line_after_lastchar();
-				break;
-		    case 'H':  /*  move to position x=arg1 y=arg2 */
-				if(arg1[0]) cy=atoi(arg1)-1; 
-					else 	cy=0;
-				if(arg2[0]) cx=atoi(arg2)-1; 
-					else 	cx=0;
-				break;
-		    case 'G':  /*  move to position x=arg1 y=MAX */
-				if(arg1[0]) cx=atoi(arg1)-1; else cx=-1;
-				cy=bottom-1;
-				break;
-		    case 'd':  /*  move to position x=MAX y=arg1 */
-				if(arg1[0]) cy=atoi(arg1)-1; else cy=0;
-				cy=top+cy;
-				cx=MAX_CHARS-1;
-				break;
-		    case 'm':  /*  change graphic */
-				ansi_change_graphic(args);
-				break;
-		    case 'M':  /*  Move memory in range ('r') one uo */
-				move_up_x_lines(arg1);
-				break;
-		    case 'L':  /*  Move memory in range ('r') one down */
-				move_down_x_lines(arg1);
-				break;
-		    case 'l':
-	/*		RM -- Reset Mode
-			
-			ESC [ Ps ; Ps ; . . . ; Ps l                                                                                                          default value: none
-			
-			Resets one or more VT100 modes as specified by each selective parameter in the parameter string. Each mode to be reset is specified by a separate
-			parameter. [See Set Mode (SM) control sequence]. (See Modes following this section).*/
-			
-			 /*  mc only resets the '4' !?! => IRM (Insert/Replacement-Mode) */
-			 /*  perhaps Set Cursor to Block mode ? */
-				break;
-			case 'r':  /*  define scroll-range  */
-				if(arg1[0]) top=atoi(arg1); else top=0;
-				if(arg2[0]) bottom=atoi(arg2); else bottom=0;
-				cy=0; 
-				cx=0;
-				break;
-			case 'a':
-			case 'A':  /*  move x letters up */
-				move_x_letters(MOVE_UP, arg1);	break;
-			case 'B':  /*  move x letters down */
-				move_x_letters(MOVE_DOWN, arg1);	break;
-			case 'C':  /*  move x letters right */
-				move_x_letters(MOVE_RIGHT, arg1);	break;
-			case 'D':  /*  move x letters left */
-				move_x_letters(MOVE_LEFT, arg1);	break;
-			case 'P':  /*  delete x letters */
-				delete_x_letters(arg1);	break;
-			case '?':
-				isansi2=4;
-				return 0;
-			default:
-				printf("***unknown***");
-		}
-		if(!((curchar>='0' && curchar<='9') || curchar==';'))
-		{  /*  clean our args */
-			args[0][0]='\0';
-			args[1][0]='\0';
-			args[2][0]='\0';
-			args[3][0]='\0';
-			args[4][0]='\0';
-			curindex=0;
-			curarg=0;
-			endansi();
-		} 
-		break;
-	case 0:
-		switch(curchar)
-		{
-		    case '[': isansi2=1; break;
-		    case '(': isansi2=2; break;
-		    case ')': isansi2=3; break;
-		    case ']': isansi2=5; break;
-		    default:
-			endansi();
-			break;
-		}
-		break;
-	case 4:
-		if (curchar>'9' || curchar<'0') 
-			endansi();
-		break;
-	case 5:
-		if(curchar==7) endansi(); /* FIXME: Window Title*/
-		break;
-	default:
-		endansi();
-		break;
-    }
-	return(0);
-}
-
-void AddChar(char *_toadd)
-{
-    char *toadd;
-    char curchar;
-
-    for(toadd=_toadd;toadd[0];toadd++) 
-	{
-		curchar=toadd[0];
-	/*	printf("%.3d (", curchar);*/
-		if(isansi) 
-			parseansi(curchar); 
-		else
-		{
-			switch(curchar) 
-			{
-			case 7:
-			    printf("<BEEP>\n");
-			    break;
-			case 8:
-			    printf("<BS>\n");
-			    backspace();
-			    break;
-			case 27:
-			     /*  ANSI */
-			    printf("<ESC>[ANSI] ");
-			    isansi=1;
-			    break;
-			case 10:
-			    printf("<LF>\n");/* get onto the next line */
-			    line_is_full();
-			    break;
-			case 13:
-			    printf("<CR>\n");/* carriage return, get back */
-				if (cx==MAX_CHARS-1) 
-					line_is_full();
-				cx=0;
-			    break;
-			default:
-				if ((curchar>=32) && (curchar<127))
-				{
-			/*	    printf("%c", curchar);*/
-				    add_char_append(curchar);
-				}
-			    break;
-		    }
-/*	printf(")\n");*/
-		}
-    }
-    gotnewdata=1;
-}
-void init_line()
-{
-    int i;
-    for(i=0;i<MAX_LINES;i++){
-		clear_line(i);
-    }
-}
-void term_addstring(char *toprint)
-{
-    char *ns;
-    for(ns=toprint;ns[0];ns++)
-	{
-		term_addchar(ns[0]);
-    }  /*  better method */
-}

Deleted: trunk/example/3dsloader.c
===================================================================
--- trunk/example/3dsloader.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/3dsloader.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,63 +0,0 @@
-/*
- * 3dsloader.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-
-#include <s3d.h>
-#include <stdio.h>  /* NULL */
-#include <time.h>	/* nanosleep() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
-int i,oid;
-void mainloop()
-{
-	s3d_rotate(oid,0,i,0);
-	i++;
-	nanosleep(&t,NULL); 
-}
-void object_click(struct s3d_evt *evt)
-{
-	s3d_quit();
-}
-	
-int main (int argc, char **argv)
-{
-	if (argc<2)
-	{
-		printf("usage: %s [somefile.3ds]\n",argv[0]);
-		return(-1);
-	}
-	if (!s3d_init(&argc,&argv,"3dsloader"))	
-	{
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-	    if (-1!=(oid=s3d_import_3ds_file(argv[1])))
-		{
-		    s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_mainloop(mainloop);
-		} else {
-			printf("file not found ... \n");
-		}
-		s3d_quit();
-	}
-	return(0);
-}

Deleted: trunk/example/3dsloader_g3d.c
===================================================================
--- trunk/example/3dsloader_g3d.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/3dsloader_g3d.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,234 +0,0 @@
-/*
- * 3dsloader_g3d.c
- *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *                         Marek Lindner <lindner_marek at yahoo.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- *
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-
-#include <s3d.h>
-#include <stdio.h>  /* NULL */
-#include <time.h>	/* nanosleep() */
-#include <g3d/g3d.h>
-#include <stdlib.h>
-
-
-struct material2texture {
-	struct material2texture *next_ptr;   /* pointer to next */
-	void *material_ptr;
-	void *texture_ptr;
-	int material_id;
-	int texture_id;
-};
-
-
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
-struct material2texture *mat2tex_root = NULL;
-int i,obj_id;
-
-
-
-void mainloop() {
-	s3d_rotate(obj_id,0,i,0);
-	i++;
-	nanosleep(&t,NULL);
-}
-
-
-
-void object_click(struct s3d_evt *evt) {
-	s3d_quit();
-}
-
-
-
-void *get_mat2tex( struct material2texture **mat2tex, void *mat_ptr ) {
-
-	while ( (*mat2tex) != NULL ) {
-
-		if ( (*mat2tex)->material_ptr == mat_ptr ) return (*mat2tex);
-
-		mat2tex = &(*mat2tex)->next_ptr;
-
-	}
-
-	if ( (*mat2tex) == NULL ) {
-
-		(*mat2tex) = malloc( sizeof( struct material2texture ) );
-
-		if ( (*mat2tex) == NULL ) {
-			printf( "Sorry - you ran out of memory !\n" );
-			exit(8);
-		}
-
-		(*mat2tex)->next_ptr = NULL;
-		(*mat2tex)->material_ptr = mat_ptr;
-		(*mat2tex)->texture_ptr = NULL;
-		(*mat2tex)->material_id = -1;
-		(*mat2tex)->texture_id = -1;
-
-		return (*mat2tex);
-
-	}
-
-	return(0);
-
-}
-
-
-
-int main (int argc, char **argv) {
-
-	G3DContext *context;
-	G3DModel *model;
-	G3DObject *object;
-	G3DFace *face;
-	GSList *oitem, *oface;
-	struct material2texture *mat2tex;
-	int j, k, material_count, texture_count, voff;
-	int polys=0;
-	unsigned char *s3d_pixeldata = NULL;
-
-	if (argc<2) {
-		printf("usage: %s [somefile.3ds]\n",argv[0]);
-		return(-1);
-	}
-
-	context = g3d_context_new();
-
-	if ( !s3d_init( &argc,&argv,"3dsloader_g3d" ) ) {
-
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-
-		model = g3d_model_load(context, argv[1]);
-
-		if ( model ) {
-
-			oitem = model->objects;
-			obj_id = s3d_new_object();
-			material_count = texture_count = voff = 0;
-
-			while ( oitem ) {
-
-				object = (G3DObject *)oitem->data;
-
-				/* push vertices */
-				for ( j = 0; j < object->vertex_count; j++ ) {
-					/* 3. and 4. param have to change places otherwise the object will be turned */
-					printf("vertex: %d/%d: %f %f %f\n",j, object->vertex_count, object->vertex_data[j * 3], object->vertex_data[j * 3 + 2], object->vertex_data[j * 3 + 1]);
-					s3d_push_vertex( obj_id, object->vertex_data[j * 3], object->vertex_data[j * 3 + 2], object->vertex_data[j * 3 + 1] );
-				}
-
-
-				oface = object->faces;
-
-				while ( oface ) {
-
-					face = (G3DFace *)oface->data;
-
-					mat2tex = get_mat2tex( &mat2tex_root, face->material );
-
-					if ( mat2tex->material_id == -1 ) {
-
-						/* printf( "push material: %i\n", material_count ); */
-
-						s3d_push_material_a( obj_id, face->material->r, face->material->g, face->material->b, face->material->a, face->material->specular[0], face->material->specular[1], face->material->specular[2], face->material->specular[3], face->material->r, face->material->g, face->material->b, face->material->a );
-
-						mat2tex->material_id = material_count;
-						material_count++;
-
-						if ( face->tex_image != NULL ) {
-
-							/* reorder pixeldata - s3d wants rgba */
-							if ( s3d_pixeldata != NULL ) free( s3d_pixeldata );
-
-							s3d_pixeldata = malloc( sizeof( unsigned char ) * face->tex_image->width * face->tex_image->height * 32 );
-
-							if ( s3d_pixeldata == NULL ) {
-								printf( "Sorry - you ran out of memory !\n" );
-								exit(8);
-							}
-
-							for ( j = ( face->tex_image->height - 1 ); j >= 0; j-- ) {
-
-								for ( k = 0; k < face->tex_image->width; k++ ) {
-
-									s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ];
-									s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ];
-									s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ];
-									s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ];
-
-								}
-
-							}
-
-							s3d_push_texture( obj_id, face->tex_image->width, face->tex_image->height );
-							s3d_pep_material_texture( obj_id, texture_count );
-							s3d_load_texture( obj_id, texture_count, 0, 0, face->tex_image->width, face->tex_image->height, s3d_pixeldata );
-
-							mat2tex->texture_id = texture_count;
-							texture_count++;
-
-						}
-
-					}
-
-					/* printf( "push polygone with material: %i\n", mat2tex->material_id ); */
-
-					/* push polygones */
-					s3d_push_polygon( obj_id, face->vertex_indices[0] + voff, face->vertex_indices[1] + voff , face->vertex_indices[2] + voff, mat2tex->material_id );
-
-					/* has polygone normals */
-					if ( face->flags & G3D_FLAG_FAC_NORMALS ) s3d_pep_polygon_normals( obj_id, face->normals, 1 );
-
-					/* face with texture */
-					if ( ( mat2tex->texture_id != -1 ) && ( face->flags & G3D_FLAG_FAC_TEXMAP ) ) {
-
-						/* printf( "text_coords: %f:%f %f:%f %f:%f\n", face->tex_vertex_data[0], face->tex_vertex_data[1], face->tex_vertex_data[2], face->tex_vertex_data[3], face->tex_vertex_data[4], face->tex_vertex_data[5] ); */
-
-						s3d_pep_polygon_tex_coord( obj_id, face->tex_vertex_data[0], face->tex_vertex_data[1], face->tex_vertex_data[2], face->tex_vertex_data[3], face->tex_vertex_data[4], face->tex_vertex_data[5] );
-
-					}
-
-
-					oface = oface->next;
-
-				}
-
-				voff += object->vertex_count; /* increase vertex offset */
-				oitem = oitem->next;
-
-			}
-
-			s3d_flags_on( obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE );
-
-			s3d_mainloop(mainloop);
-
-		}
-
-		s3d_quit();
-
-	}
-
-	return(0);
-
-}

Modified: trunk/example/Makefile.am
===================================================================
--- trunk/example/Makefile.am	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/Makefile.am	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,10 +1,10 @@
 noinst_PROGRAMS=	hudtest katze \
 			ptrtest radius_test s3dclock snowman \
 			strtest texturetest linetest widgets \
-			3dsloader_g3d nichtsnutz
-bin_PROGRAMS= filebrowser 3dsloader
+			nichtsnutz
+bin_PROGRAMS= filebrowser modelloader
 			
-3dsloader_SOURCES=		3dsloader.c
+3dsloader_SOURCES=		modelloader.c
 widgets_SOURCES=		widgets.c
 filebrowser_SOURCES=	filebrowser.c
 hudtest_SOURCES=		hudtest.c
@@ -16,15 +16,12 @@
 strtest_SOURCES=		strtest.c
 texturetest_SOURCES=	texturetest.c
 ptrtest_SOURCES=		ptrtest.c
-3dsloader_g3d_SOURCES=	3dsloader_g3d.c
 nichtsnutz_SOURCES=		nichtsnutz.c
 
 CPPFLAGS=		-I$(top_srcdir)/server -I$(top_srcdir)/libs3d 
 LIBS=			$(top_builddir)/libs3d/libs3d.la  
-3dsloader_g3d_CFLAGS=	-I$(top_srcdir)/libs3d/libg3d/include @GLIB_CFLAGS@
 widgets_CFLAGS=			-I$(top_srcdir)/libs3dw 
 widgets_LDFLAGS=		$(top_builddir)/libs3dw/libs3dw.la
-3dsloader_g3d_LDFLAGS=	$(top_builddir)/libs3d/libg3d/src/libg3d.la
 
 EXTRA_DIST=	\
 	TODO

Modified: trunk/example/filebrowser.c
===================================================================
--- trunk/example/filebrowser.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/filebrowser.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,245 +0,0 @@
-/*
- * filebrowser.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-
-#include <s3d.h>
-#include <stdio.h> 	 /*  printf() */
-#include <dirent.h>  /*  dirent */
-#include <stdlib.h>	 /*  malloc() */
-#include <string.h>  /*  strlen(), strncmp(), strrchr() */
-#include <unistd.h>	 /*  chdir() */
-#include <math.h>	 /*  sin(),cos() */
-#include <time.h>	/* nanosleep() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
-
-#define T_DUNO		0
-#define T_LOCALDIR	1
-#define T_BACKDIR	2
-#define T_FOLDER	3
-#define T_GEOMETRY	4
-#define T_MUSIC		5
-#define	T_MOVIE		6
-
-#define M_DIR		512
-#define M_NAME		256
-int folder,geometry,mp3,movie,duno,dot,dotdot;
-struct t_item {
-	int icon_oid, descr_oid, pie_oid;
-	char name[M_NAME];
-	int type;
-};
-struct t_item *item;
-int n_item=0;
-int display_dir(char *dir, int depth, int  posx, int posy, int posz)
-{
-	struct dirent **namelist;
-	int n,i;
-	int  px,py,pz;
-	char *ext;
-	char *nstr;
-	float alpha,al,radius,f;
-	char ndir[M_DIR+1];
-	if (n_item)
-	{
-		printf("freeing %d old items\n",n_item);
-		for (i=0;i<n_item;i++)
-		{
-			printf("deleting %d and %d\n",item[i].icon_oid,	item[i].descr_oid);
-			s3d_del_object(item[i].descr_oid);
-			s3d_del_object(item[i].icon_oid);
-			s3d_del_object(item[i].pie_oid);
-		}
-		free(item);
-		
-	}
-    n = i = scandir(dir, &namelist, 0, alphasort);
-    if (n < 0)
-	{
-        perror("scandir");
-		return(-1);
-	}
-    else {
-		item=malloc(sizeof(struct t_item)*i);
-		n_item=i;
-        while(n--) {
-			item[n].type=T_DUNO;
-			nstr=namelist[n]->d_name;
-			strncpy(item[n].name,nstr,M_NAME);
- 		    if ((0==strncmp(nstr,".",1)) && (strlen(nstr)==1))
-				item[n].type=T_LOCALDIR;
-			else if (0==strncmp(nstr,"..",strlen(nstr)<2?strlen(nstr):2))
-			   item[n].type=T_BACKDIR;
-			else {
-				ext=strrchr(nstr,'.');
-			    strncpy(ndir,dir,M_DIR);
-				ndir[M_DIR]=0;		/* just in case */
-			    strncat(ndir,"/",M_DIR-strlen(ndir));
-		    	strncat(ndir,namelist[n]->d_name,M_DIR-strlen(ndir));
-/* 				printf("displaying %s\n",ndir); */
-			    if ((namelist[n]->d_type==DT_DIR) ||
-					((namelist[n]->d_type==DT_UNKNOWN) && (opendir(ndir)!=NULL)))
-					item[n].type=T_FOLDER;
-				else 
-				{
-				   if (ext!=NULL)
-				   {
-					   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))
-							   item[n].type=T_GEOMETRY;
-					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))
-							   item[n].type=T_MUSIC;
-					   else if (0==strncmp(ext,".mpg",strlen(ext)<4?strlen(ext):4))
-							   item[n].type=T_MOVIE;
-
-				   }
-				}
-			}
-			switch (item[n].type)
-			{
-				case T_LOCALDIR:   	item[n].icon_oid=s3d_clone(dot);break;
-				case T_BACKDIR:   	item[n].icon_oid=s3d_clone(dotdot);break;
-				case T_FOLDER:   	item[n].icon_oid=s3d_clone(folder);
-									break;
-				case T_GEOMETRY:   	item[n].icon_oid=s3d_clone(geometry);break;
-				case T_MUSIC:	   	item[n].icon_oid=s3d_clone(mp3);break;
-				case T_MOVIE:		item[n].icon_oid=s3d_clone(movie);break;
-				default:   			printf("don't know type, defaulting to duno %d...\n",duno);
-									item[n].icon_oid=s3d_clone(duno);break;
-			}
-
-			px=posx;py=posy;pz=posz;
-			alpha=((360.0*n)/((float)i));
-			radius=((n_item*10)/(M_PI*4));
-			if (n_item<5)
-				radius=((50)/(M_PI*4));
-			else
-				radius=((n_item*10)/(M_PI*4));
-			px=posx-sin(alpha*M_PI/180.0)*radius;
-			pz=posy;
-			pz=posz-cos(alpha*M_PI/180.0)*radius;
-
-			item[n].pie_oid=s3d_new_object();
-			s3d_push_vertex(item[n].pie_oid,0,-2,0);
-			al=((360.0*(n-0.5))/((float)i));
-			s3d_push_vertex(item[n].pie_oid,		
-						posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
-			al=((360.0*(n+0.5))/((float)i));
-			s3d_push_vertex(item[n].pie_oid,		
-						posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
-			
-			f=1.0-0.05*(n%2);
-			switch (item[n].type)
-			{
-				case T_LOCALDIR:s3d_push_material(item[n].pie_oid,		0,f,0,			0.5,0.5,0.5,		f,f,f);		break;
-				case T_BACKDIR:	s3d_push_material(item[n].pie_oid,		0,f/2,0,		0.5,0.5,0.5,		f,f,f);		break;
-				case T_FOLDER:	s3d_push_material(item[n].pie_oid,		f,f,0,			0.5,0.5,0.0,		f,f,1);		break;
-				default:		s3d_push_material(item[n].pie_oid,		f,f,f,			0.5,0.5,0.5,		f,f,f);		break;
-			}
-			s3d_push_polygon(item[n].pie_oid,	0,2,1,	0);
-
-			s3d_push_vertex(item[n].pie_oid,pz,-2,0);
-			s3d_translate(item[n].icon_oid,px,py,pz);
-			s3d_rotate(item[n].icon_oid,0,alpha,0);
-		    s3d_flags_on(item[n].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		    s3d_flags_on(item[n].pie_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			item[n].descr_oid=s3d_draw_string(nstr,NULL);
-			s3d_link(item[n].descr_oid,item[n].icon_oid);
-			s3d_translate(item[n].descr_oid,-1,-2,0); 
-/* 			r=s3d_get_radius(p); */
-/* 			s3d_scale(p,1.0/r,1.0/r,1.0/r); */
-		    s3d_flags_on(item[n].descr_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-            printf("%s [%d]\n", nstr,namelist[n]->d_type);
-			printf("string %d linked to %d\n",item[n].descr_oid,item[n].icon_oid);
-        	free(namelist[n]);
-        }
-		free(namelist);
-   	}
-	return(0);
-}
-
-void object_click(struct s3d_evt *evt)
-{
-	int i,oid;
-	char execstr[256];
-	oid=(int)*((unsigned long *)evt->buf);
-	printf("!!!!!!!!! clicked object %d\n",oid);
-	for (i=0;i<n_item;i++)
-	{
-		if (((oid==item[i].icon_oid) || (oid==item[i].descr_oid)) ||
-			(oid==item[i].pie_oid) )
-		{
-			switch (item[i].type)
-			{
-				case T_BACKDIR:
-				case T_FOLDER:
-				case T_LOCALDIR:
-						printf("going into %s\n",item[i].name);
-						chdir(item[i].name);
-						display_dir(".",0,0,0,0);
-						return;
-						break;
-				case T_GEOMETRY:
-						printf("loading geometry %s\n",item[i].name);
-						snprintf(execstr,256,"3dsloader \"%s\"&\n",item[i].name);
-						system(execstr);
-						return;
-						break;
-				case T_MOVIE:
-						printf("playing %s\n",item[i].name);
-						snprintf(execstr,256,"mplayer -vo s3d \"%s\"&\n",item[i].name);
-						system(execstr);
-						return;
-						break;
-
-						
-			}
-		}
-	}
-}
-void mainloop()
-{
-	nanosleep(&t,NULL); 
-}
-int main (int argc, char **argv)
-{
-	int i;
-	if (!s3d_init(&argc,&argv,"filebrowser"))	
-	{
-		i=0;
-		 /*  load the object files */
-		folder=s3d_import_3ds_file("objs/folder.3ds");
-		geometry=s3d_import_3ds_file("objs/geometry.3ds");
-		mp3=s3d_import_3ds_file("objs/notes.3ds");
-		movie=s3d_import_3ds_file("objs/film.3ds");
-		duno=s3d_import_3ds_file("objs/duno.3ds");
-		dot=s3d_import_3ds_file("objs/dot.3ds");
-		dotdot=s3d_import_3ds_file("objs/dotdot.3ds");
-		s3d_select_font("vera");
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-		display_dir(".",0,0,0,0);
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/example/hudtest.c
===================================================================
--- trunk/example/hudtest.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/hudtest.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,51 +0,0 @@
-/*
- * hudtest.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include <s3d.h>
-#include <unistd.h>  /*  sleep() */
-#include <stdio.h>  /*  printf() */
-void mainloop()
-{
-	sleep(1);
-}
-int main(int argc, char **argv)
-{
-	int o,m;
-	if (!s3d_init(&argc,&argv,"hud-test"))
-	{
-		if (s3d_select_font("vera"))
-			printf("font not found\n");
-		o=s3d_draw_string("hud-test",NULL);
-		m=s3d_import_3ds_file("objs/star.3ds");
-		s3d_translate(o,0,0,-5);
-		s3d_link(o,0);
-		s3d_flags_on(o,S3D_OF_VISIBLE);
-		s3d_flags_on(m,S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-
-}

Modified: trunk/example/katze.c
===================================================================
--- trunk/example/katze.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/katze.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,91 +0,0 @@
-/*
- * katze.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-
-#include <s3d.h>
-#include <math.h>	/* sin() */
-#include <time.h>	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-
-int a;
-int rot_point,body,legfr,legbr,legfl,legbl,tail;
-
-void mainloop()
-{
-	float pos;
-	a=(a+2)%360;
-	pos=sin((5*a*M_PI)/180)*20;
-	s3d_rotate(legfr,0,90,180+pos);
-	s3d_rotate(legfl,0,90,180-pos);
-	s3d_rotate(legbr,0,0,180+pos);
-	s3d_rotate(legbl,0,0,180-pos);
-
-	s3d_rotate(tail,0,30,110+pos);
-	s3d_rotate(rot_point,0,-a,0);
-	nanosleep(&t,NULL); 
-}
-int main(int argc, char **argv)
-{
-	if (!s3d_init(&argc,&argv,"running cat"))
-	{
-			
-		rot_point=s3d_new_object();
-		body=s3d_import_3ds_file("objs/katze_body.3ds");
-		legfr=s3d_import_3ds_file("objs/katze_leg.3ds");
-		tail=s3d_import_3ds_file("objs/katze_tail.3ds");
-		legfl=s3d_clone(legfr);
-		legbl=s3d_clone(legfr);
-		legbr=s3d_clone(legfr);
-		s3d_translate(legfl,2.3,1.0,0.5);
-		s3d_translate(legfr,0,1.0,0.2);
-		s3d_translate(legbl,-1.2,1.0,-1.8);
-		s3d_translate(legbr,-1.2,1.0,0.0);
-		s3d_translate(tail,-1.6,1.6,-0.8);
-		s3d_translate(body,1.3,0.0,-1.3);
-		s3d_link(legfr,body);
-		s3d_link(legfl,body);
-		s3d_link(legbr,body);
-		s3d_link(legbl,body);
-		s3d_link(tail,body);
-		s3d_link(body,rot_point);
-/*		s3d_link(oid_foot,oid_head);
- *		s3d_link(oid_middle,oid_head);
- *		s3d_translate(oid_head,0,4,0);
-		
- *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
- *		s3d_translate(oid_foot,0,-3.5,0); */
-		
-
-		s3d_flags_on(body,S3D_OF_VISIBLE);
-		s3d_flags_on(legfr,S3D_OF_VISIBLE);
-		s3d_flags_on(legfl,S3D_OF_VISIBLE);
-		s3d_flags_on(legbr,S3D_OF_VISIBLE);
-		s3d_flags_on(legbl,S3D_OF_VISIBLE);
-		s3d_flags_on(tail,S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/example/linetest.c
===================================================================
--- trunk/example/linetest.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/linetest.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,95 +0,0 @@
-/*
- * linetest.c
- * 
- * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include <s3d.h>
-#include <stdio.h>  /*  NULL*/
-#include <unistd.h> /* sleep() */
-int i;
-int o;
-void stop(struct s3d_evt *evt)
-{
-	s3d_quit();
-}
-
-void mainloop()
-{
-	i=(i+1)%2;
-	if (i)
-	{
-		s3d_pep_vertex(o,1,-2,0);
-		s3d_pep_line(o,0,2,3);
-	}
-	else
-	{
-		s3d_pep_vertex(o,1,-1,0);
-		s3d_pep_line(o,0,1,0);
-
-	}
-/* 	printf("now it's %s\n",time_str); */
-	sleep(1);
-
-}
-int main (int argc, char **argv)
-{
-	i=0;
-	if (!s3d_init(&argc,&argv,"linetest"))	
-	{
-		o=s3d_new_object();
-		
-		s3d_push_material(o,
-						1,0,0,
-						1,0,0,
-						1,0,0);
-		s3d_push_material(o,
-						0,1,0,
-						0,1,0,
-						0,1,0);
-		s3d_push_material(o,
-						0,1,0,
-						0,1,0,
-						0,1,0);
-		s3d_push_material(o,
-						1,1,0,
-						1,1,0,
-						1,1,0);
-		s3d_push_vertex(o,-1,-1,0);
-		s3d_push_vertex(o,-1,1,0);
-		s3d_push_vertex(o,1,1,0);
-		s3d_push_vertex(o,1,-1,0);
-		s3d_push_line(o,2,3,1);
-		s3d_push_line(o,0,1,0);
-
-		s3d_flags_on(o,S3D_OF_VISIBLE);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
-		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
-		s3d_quit();
-	}
-	return(0);
-}
-
-
-

Copied: trunk/example/modelloader.c (from rev 229, trunk/example/3dsloader.c)
===================================================================

Modified: trunk/example/nichtsnutz.c
===================================================================
--- trunk/example/nichtsnutz.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/nichtsnutz.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,167 +0,0 @@
-/*
- * nichtsnutz.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-
-#include <s3d.h>
-#include <s3d_keysym.h>
-#include <stdio.h>
-#include <math.h>
-#include <time.h>	
-
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-
-int object,foll;
-float al, r, rc ,alpha=0.0, Asp, Bottom, Left, angle;
-float CamPosition[2][3],
-	  TmpMove[3],
-	  Tmp[3],
-	  TmpCam[2][3],
-	  RotCam[2][3],
-	  CatPos[3];
-
-float length;
-
-void mainloop()
-{
-	
-	al=(alpha*M_PI/180);
-    r = 5.0;
-	rc = 12.0;
-	
-	CatPos[0] = sin(al)*r;
-	CatPos[1] = 0;
-	CatPos[2] = cos(al)*r;
-	/*
-	RotCam[0][0] = sin(al) * rc;
-	RotCam[0][1] = 0.0;
-	RotCam[0][2] = cos(al) * rc;
-	*/
-	s3d_translate(object,CatPos[0] ,CatPos[1], CatPos[2]);
-	s3d_rotate(object, 0, alpha, 0);
-	alpha = alpha+0.1;
-	if (alpha>360.0) alpha=0.0;
-	
-	length = s3d_vector_length(CatPos);
-
-
-	RotCam[0][0] = ( CatPos[0] * 12.0 ) / length;
-	RotCam[0][1] = ( CatPos[1] * 12.0 ) / length;
-	RotCam[0][2] = ( CatPos[2] * 12.0 ) / length;
-	
-	
-	if( foll )
-	{
-		
-		CamPosition[0][0] = ((CamPosition[0][0]*4 + RotCam[0][0])/5);
-		CamPosition[0][1] = ((CamPosition[0][1]*4 + RotCam[0][1])/5);
-		CamPosition[0][2] = ((CamPosition[0][2]*4 + RotCam[0][2])/5);
-		s3d_translate(0,CamPosition[0][0],CamPosition[0][1],CamPosition[0][2]);
-
-		TmpMove[0] = 0.0;
-		TmpMove[1] = 0.0;
-		TmpMove[2] = -1.0;
-
-		Tmp[0] = CamPosition[0][0] - CatPos[0];
-		Tmp[1] = 0.0;
-		Tmp[2] = CamPosition[0][2] - CatPos[2];
-		
-		angle = s3d_vector_angle(Tmp,TmpMove);
-		angle = (CatPos[0] > 0)?(180-(180 / M_PI * angle)):(180+(180 / M_PI * angle));
-		printf("%f %f\n",angle,al);
-	
-		CamPosition[1][1] = (CamPosition[1][1]*4 + angle)/5;
-		s3d_rotate(0,CamPosition[1][0], CamPosition[1][1], CamPosition[1][2]);
-	}
-	
-
-	
-	nanosleep(&t,NULL); 
-}
-
-void object_info(struct s3d_evt *hrmz)
-{
-	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz->buf;
-	
-	if (inf->object==0)
-	{
-		CamPosition[0][0] = inf->trans_x;
-		CamPosition[0][1] = inf->trans_y;
-		CamPosition[0][2] = inf->trans_z;
-		CamPosition[1][0] = inf->rot_x;
-		CamPosition[1][1] = inf->rot_y;
-		CamPosition[1][2] = inf->rot_z;
-
-		Asp=inf->scale;
-		if (Asp>1.0) /* wide screen */
-		{
-			Bottom=-1.0;
-			Left=-Asp;
-		} else {  /* high screen */
-			Bottom=(-1.0/Asp);
-			Left=-1.0;
-		}
-	}
-}
-
-
-
-void keypress(struct s3d_evt *event)
-{
-	int key;
-	key=*((unsigned short *)event->buf);
-	switch(key)
-	{
-		case 'f':
-				foll = foll ? 0 : 1;
-				if( foll )
-				{
-					TmpCam[0][0] = CamPosition[0][0];
-					TmpCam[0][1] = CamPosition[0][1];
-					TmpCam[0][2] = CamPosition[0][2];
-					TmpCam[1][0] = CamPosition[1][0];
-					TmpCam[1][1] = CamPosition[1][1];
-					TmpCam[1][2] = CamPosition[1][2];
-				}
-				break;
-	}
-}
-
-
-int main(int argc, char **argv)
-{
-	
-	if (!s3d_init(&argc,&argv,"running cat"))
-	{
-		s3d_set_callback(S3D_EVENT_KEY,keypress);
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-		
-		object = s3d_import_3ds_file("objs/katze_body.3ds");
-		s3d_flags_on(object, S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/example/ptrtest.c
===================================================================
--- trunk/example/ptrtest.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/ptrtest.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,114 +0,0 @@
-/*
- * ptrtest.c
- * 
- * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include <s3d.h>
-#include <stdio.h>  /*  NULL*/
-#include <time.h>	/* nanosleep() */
-#include <math.h>	/* sin(), cos() */
-int i;
-int o;
-float bottom=-1.0;
-float left=-1.0;
-float asp=1.0;
-float len=1.0;
-int alpha=0;
-static struct timespec t={0,10*1000*1000}; /* 100 mili seconds */
-void stop(struct s3d_evt *evt)
-{
-	s3d_quit();
-}
-
-void mainloop()
-{
-	float a;
-	alpha=(alpha+1)%360;
-	s3d_rotate(o,alpha,0,0);
-	a=(((float)alpha)*M_PI/180);
-	s3d_translate(0,sin(a)*30,0,30+cos(a)*30);
-	s3d_rotate(0,sin(a)*30,alpha,0);
-	nanosleep(&t,NULL); 
-}
-void object_info(struct s3d_evt *hrmz)
-{
-	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz->buf;
-	if (inf->object==0)
-	{
-		if (asp!=inf->scale)
-		{
-			asp=inf->scale;
-			printf("screen aspect: %f\n",asp);
-			if (asp>1.0) /* wide screen */
-			{
-				bottom=-1.0;
-				left=-asp;
-			} else {  /* high screen */
-				bottom=(-1.0/asp);
-				left=-1.0;
-			}
-		}
-	}
-	if (inf->object==1)
-	{ /* of course, a link s3d_link(o,1 would be much easier ... */
-		s3d_translate(o,(inf->trans_x)*2.0,(inf->trans_y)*2.0,-2);
-	}
-}
-void mbutton_press(struct s3d_evt *hrmz)
-{
-	struct s3d_but_info *inf;
-	char s[256];
-	inf=(struct s3d_but_info *)hrmz->buf;
-	snprintf(s,256,"please, watch your stomach! button %d, state %d", inf->button,inf->state);
-	printf("button %d, state %d\n", inf->button,inf->state);
-	s3d_del_object(o);
-	o=s3d_draw_string(s,&len);
-	s3d_translate(o,0,0,-2);
-	s3d_scale(o,0.2);
-	s3d_link(o,0);			/* link to cam */
-/*	s3d_link(o,1);*/
-	s3d_flags_on(o,S3D_OF_VISIBLE);
-}
-int main (int argc, char **argv)
-{
-	i=0;
-	if (!s3d_init(&argc,&argv,"ptr and cam test"))	
-	{
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-		s3d_set_callback(S3D_EVENT_MBUTTON,mbutton_press);
-		s3d_set_callback(S3D_EVENT_QUIT,stop);
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,stop);
-		s3d_select_font("vera");
-		o=s3d_draw_string("hello",&len);
-		s3d_translate(o,0,0,-2);
-		s3d_link(o,0);			/* link to cam */
-/*		s3d_link(o,1);*/
-		s3d_scale(o,0.2);
-		s3d_flags_on(o,S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
-		s3d_quit();
-	}
-	return(0);
-}
-

Modified: trunk/example/radius_test.c
===================================================================
--- trunk/example/radius_test.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/radius_test.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,75 +0,0 @@
-/*
- * radius_test.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include <s3d.h>
-#include <stdio.h>  /*  NULL */
-#include <time.h>	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-
-#include <math.h>	/* sin(), cos() */
-int item1, item2, item3;
-int i=0;
-void mainloop()
-{
-	float f,g,h;
-	f=sin((M_PI*(i%360))/180.0);
-	g=cos((M_PI*(i%360))/180.0);
-	h=sin((M_PI*((3*i)%360))/180.0);
-	
-	s3d_translate(item1,f*10,h*2, g*5);
-	s3d_rotate(item1,0,i%360,0);
-/*	s3d_scale(item1,h+3,h+3,h+3);*/
-
-/*	s3d_translate(item2,f*10,0, g*5);*/
-	s3d_translate(item2,0,0,10);
-/*	s3d_rotate(item2,i%360,0,-i%360);
-	s3d_scale(item2,2*f+5,2*f+5,2*f+5);*/
-
-	s3d_translate(item3,0,0,10);
-/*	s3d_rotate(item3,((8*i)%360),0,-((8*i)%360));
-	s3d_scale(item3,2*f+5,2*f+5,2*f+5);*/
-
-	
-
-	i++;
-	nanosleep(&t,NULL); 
-}
-int main (int argc, char **argv)
-{
-	if (!s3d_init(&argc,&argv,"radius test"))	
-	{
-		item1=s3d_import_3ds_file("objs/cubeyholes.3ds");
-		item2=s3d_import_3ds_file("objs/folder.3ds");
-		s3d_select_font("vera");
-		item3=s3d_draw_string("radius test",NULL);
-		s3d_link(item2,item1);
-		s3d_link(item3,item2);
-	    s3d_flags_on(item1,S3D_OF_VISIBLE);
-	    s3d_flags_on(item2,S3D_OF_VISIBLE);
-	    s3d_flags_on(item3,S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-			 /*  wait for some object to be clicked */
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/example/s3dclock.c
===================================================================
--- trunk/example/s3dclock.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/s3dclock.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,87 +0,0 @@
-/*
- * s3dclock.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include <s3d.h>
-#include <stdio.h>  /*  NULL, sprintf() */
-#include <time.h>	 /*  nanosleep(), struct tm, time_t...  */
-#include <string.h>  /*  strlen() */
-static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
-int big_p,lil_p,bg,sec_p;
-int str_oid=-1, o_str_oid;
-struct tm *mytime;
-time_t now,onow;
-char time_str[256];
-
-void stop(struct s3d_evt *evt)
-{
-	s3d_quit();
-}
-
-void mainloop()
-{
-	onow=now;
-	now=time(NULL);
-	if (now!=onow)
-	{
-		o_str_oid=str_oid;
-		mytime=localtime(&now);	
-		s3d_rotate(lil_p,0,0,-((mytime->tm_hour%12)/12.0)*360.0);
-		s3d_rotate(big_p,0,0,-(mytime->tm_min/60.0)*360.0);
-		s3d_rotate(sec_p,0,0,-(mytime->tm_sec/60.0)*360.0);
-		sprintf(time_str,"%02d:%02d:%02d",mytime->tm_hour,mytime->tm_min,mytime->tm_sec);
-		str_oid=s3d_draw_string(time_str,NULL);
-		s3d_translate(str_oid,-1,-1.3,0);
-		s3d_scale(str_oid,0.5);
-		s3d_flags_on(str_oid,S3D_OF_VISIBLE);
-		if (str_oid!=-1)
-			s3d_del_object(o_str_oid);
-	}
-/* 	printf("now it's %s\n",time_str); */
-	nanosleep(&t,NULL); 
-
-}
-int main (int argc, char **argv)
-{
-	if (!s3d_init(&argc,&argv,"clock"))	
-	{
-		lil_p=s3d_import_3ds_file("objs/lil_p.3ds");
-		big_p=s3d_import_3ds_file("objs/big_p.3ds");
-		sec_p=s3d_import_3ds_file("objs/sec_p.3ds");
-		bg=s3d_import_3ds_file("objs/clock_bg.3ds");
-
-		s3d_flags_on(big_p,S3D_OF_VISIBLE);
-		s3d_flags_on(lil_p,S3D_OF_VISIBLE);
-		s3d_flags_on(sec_p,S3D_OF_VISIBLE);
-		s3d_flags_on(bg,S3D_OF_VISIBLE);
-		s3d_select_font("vera");
-
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
-		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
-		s3d_quit();
-	}
-	return(0);
-}
-

Modified: trunk/example/snowman.c
===================================================================
--- trunk/example/snowman.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/snowman.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,74 +0,0 @@
-/*
- * snowman.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-#include <s3d.h>
-#include <math.h>	/* sin() */
-#include <time.h>	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-
-int a;
-int oid_head;
-int oid_middle;
-int oid_foot;
-
-void mainloop()
-{
-	float pos;
-	a=(a+3)%360;
-	pos=sin((a*M_PI)/180)*5;
-	if (pos<0) pos*=-1;
-	s3d_rotate(oid_head,0,a,0);
-	s3d_rotate(oid_middle,0,a,0);
-	s3d_rotate(oid_foot,0,a,0);
-	s3d_translate(oid_head,		0,1.5 +2.00*pos,0);
-	s3d_translate(oid_middle,	0,0   +1.25*pos,0);
-	s3d_translate(oid_foot,		0,-2  +1.00*pos,0);
-	nanosleep(&t,NULL); 
-}
-int main(int argc, char **argv)
-{
-	if (!s3d_init(&argc,&argv,"snowman"))
-	{
-			
-		oid_head=s3d_import_3ds_file("objs/snow_head.3ds");
-		oid_middle=s3d_import_3ds_file("objs/snow_body.3ds");
-		oid_foot=s3d_import_3ds_file("objs/snow_foot.3ds");
-
-/*		s3d_link(oid_foot,oid_head);
- *		s3d_link(oid_middle,oid_head);
- *		s3d_translate(oid_head,0,4,0);
-		
- *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
- *		s3d_translate(oid_foot,0,-3.5,0); */
-		
-		s3d_scale(oid_middle,1.25);
-		s3d_scale(oid_foot,1.5);
-
-		s3d_flags_on(oid_head,S3D_OF_VISIBLE);
-		s3d_flags_on(oid_middle,S3D_OF_VISIBLE);
-		s3d_flags_on(oid_foot,S3D_OF_VISIBLE);
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/example/strtest.c
===================================================================
--- trunk/example/strtest.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/strtest.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,64 +0,0 @@
-/*
- * strtest.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-#include <s3d.h>
-#include <stdio.h>  /*  NULL*/
-#include <unistd.h> /* sleep() */
-int o;
-void stop(struct s3d_evt *evt)
-{
-	s3d_quit();
-}
-
-void mainloop()
-{
-/* 	printf("now it's %s\n",time_str); */
-	sleep(1);
-
-}
-int main (int argc, char **argv)
-{
-	char c[256];
-	int i;
-	if (!s3d_init(&argc,&argv,"strtest"))	
-	{
-		s3d_select_font("vera");
-/*		o=s3d_draw_string("The lazy fox is bored enough to jump over everything it sees. weird, isn't it?!",NULL);  */
-		for (i=0;i<256;i++)
-			c[255-i]=i;
-		o=s3d_draw_string(c,NULL);
-/*		o=s3d_draw_string("A",NULL);*/
-		s3d_flags_on(o,S3D_OF_VISIBLE);
-
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
-		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
-		s3d_mainloop(mainloop);
-		 /*  wait for some object to be clicked */
-		s3d_quit();
-	}
-	return(0);
-}
-
-

Modified: trunk/example/texturetest.c
===================================================================
--- trunk/example/texturetest.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/texturetest.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,86 +0,0 @@
-/*
- * texturetest.c
- * 
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include <s3d.h>
-#include <stdio.h>  /*  NULL */
-#include <stdlib.h>  /* malloc(),free() */
-#include <time.h>	/* nanosleep() */
-static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
-
-int i,oid;
-void mainloop()
-{
-	i=(i+1)%360;
-	s3d_rotate(oid,0,i,0);
-	nanosleep(&t,NULL); 
-}
-#define MAXX	300
-#define MAXY	300
-int main (int argc, char **argv)
-{
-	unsigned int x,y;
-	unsigned char *data;
-						
-	if (!s3d_init(&argc,&argv,"texturetest"))	
-	{
-		data=malloc(MAXX*MAXY*4);
-		oid=s3d_new_object();
-		s3d_push_vertex(oid,-1,-1,0);
-		s3d_push_vertex(oid, 1,-1,0);
-		s3d_push_vertex(oid, 1, 1,0);
-		s3d_push_vertex(oid,-1, 1,0);
-		s3d_push_material_a(oid,
-						0.8,	0.0,	0.0	,1.0,
-						1.0,	1.0,	1.0	,1.0,
-						0.8,	0.0,	0.0	,1.0);
-		s3d_push_polygon(oid,0,1,2,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
-									   1.0,0.0,
-									   1.0,1.0);
-		s3d_push_polygon(oid,0,2,3,0);
-		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
-									   1.0,1.0,
-									   0.0,1.0);
-		s3d_translate(oid,0,0,5);
-		for (y=0;y<MAXY;y++)
-			for (x=0;x<MAXX;x++)
-			{
-				data[(y*MAXX+x)*4+0]=(char)((x*255)/MAXX);
-				data[(y*MAXX+x)*4+1]=((x*y)/(MAXX*MAXY));
-				data[(y*MAXX+x)*4+2]=((y*255)/MAXX);
-				data[(y*MAXX+x)*4+3]=255;
-			}
-		s3d_push_texture(oid,MAXX,MAXY);		
-		s3d_load_texture(oid,0,0,0,MAXX,MAXY,data);
-					 /*  push data on texture 0 position (0,0) */
-		free(data);
-		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
-		s3d_flags_on(oid,S3D_OF_VISIBLE);
-		i=0;
-		s3d_mainloop(mainloop);
-			 /*  wait for some object to be clicked */
-		s3d_quit();
-	}
-	return(0);
-}

Modified: trunk/example/widgets.c
===================================================================
--- trunk/example/widgets.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/example/widgets.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,174 +0,0 @@
-/*
- * widgets.c
- * 
- * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of s3d, a 3d network display server.
- * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * s3d is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-
-
-#include <s3d.h>
-#include <s3dw.h>
-#include <stdio.h>  /* NULL */
-#include <time.h>	/* nanosleep() */
-#include <stdlib.h>	/* free() */
-#include <string.h> /* strlen() */
-
-s3dw_surface *surface;
-s3dw_input *input;
-static struct timespec t={0,33*1000*1000}; /* 33 mili seconds */
-void mainloop()
-{
-	/* keep this in your mainloop. this will do smooth animations for you ... */
-	s3dw_ani_mate();
-	nanosleep(&t,NULL); 
-}
-/* you should always put the s3dw-handler in your own event handler,
- * if you want s3dw to react on clicks or keys ... and i'm sure you
- * want that ... */
-void click(struct s3d_evt *evt)
-{
-	s3dw_handle_click(evt);
-}
-void key_button(s3dw_widget *button)
-{
-	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
-}
-void key(struct s3d_evt *evt)
-{
-	struct s3d_key_event *key=(struct s3d_key_event *)evt->buf;
-	char string[8];
-	s3dw_surface *miniwin;
-	s3dw_button  *button;
-	
-	s3dw_handle_key(evt);
-	/* okay, that's a little bit insane ... ;) 
-	 * we create some little windows with the actual key pressed. */
-
-	if (key->unicode!=0)
-	{
-		miniwin=s3dw_surface_new("Key",6,6);
-		sprintf(string,"%c",key->unicode);
-		s3dw_label_new(miniwin,string,1,2);
-		button=s3dw_button_new(miniwin,"OK",2,4);
-		/* clicking on the button will exit ... */
-		button->onclick=key_button;
-		/* of couse, show it */
-		s3dw_show(S3DWIDGET(miniwin));
-	}
-
-}
-
-void done_button(s3dw_widget *dummy)
-{
-	s3d_quit();
-}
-
-void okay_button(s3dw_widget *dummy)
-{
-	s3dw_button *button;
-	char string[32];
-	char *age;
-
-	/* get the input of the text ... before its destroyed, of course*/
-	age=s3dw_input_gettext(input);
-
-	/* delete the old surface with it subwidgets */
-	s3dw_delete(S3DWIDGET(surface));
-	
-	/* and create a new one ... */
-	surface=s3dw_surface_new("Ah!",10,7);
-	
-	/* just cutting the string if it's too long */
-	if (strlen(age)>8) age[8]=0;
-	
-	/* assemble the string ..*/
-	sprintf(string,"I see, %s!!",age);
-
-	s3dw_label_new(surface,string,1,2);
-	button=s3dw_button_new(surface,"Great",4,4);
-	/* clicking on the button will exit ... */
-	button->onclick=done_button;
-	
-	/* of couse, show it */
-	s3dw_show(S3DWIDGET(surface));
-
-	/* we don't need it anymore. always free strings, don't leak around */
-	free(age); 
-}
-void no_button(s3dw_widget *dummy)
-{
-	s3dw_button *button;
-	s3dw_delete(S3DWIDGET(surface));
-	surface=s3dw_surface_new("Well ...",10,7);
-	s3dw_label_new(surface,"If you don't want to tell me ...",1,2);
-	button=s3dw_button_new(surface,"Bye",4,4);
-	/* clicking on the button will exit ... */
-	
-	button->onclick=done_button;
-	/* of couse, show it */
-	
-	s3dw_show(S3DWIDGET(surface));
-}
-
-int main (int argc, char **argv)
-{
-	s3dw_button *button;
-	if (!s3d_init(&argc,&argv,"widgettest"))
-	{
-		s3d_set_callback(S3D_EVENT_OBJ_CLICK,click);
-		s3d_set_callback(S3D_EVENT_KEY,key);
-		s3d_set_callback(S3D_EVENT_OBJ_INFO,s3dw_object_info);
-		/* this creates the "window" */
-		surface=s3dw_surface_new("Hello World",20,10);
-		
-		/* put a label (which is simply text) at position x=1, y=2 */
-		s3dw_label_new(surface,"How old are you?",1,2);
-
-		/* put an input box right below. we grab the pointer because we want to focus it (need for reference) */
-		input=s3dw_input_new(surface,8,1,4);
-		
-		/* we want the input-field be focused on our widget */
-		s3dw_focus(S3DWIDGET(input));
-
-		/* create the okay button */
-		button=s3dw_button_new(surface,"OK",1,7);
-
-		/* define the callback when the button is clicked. in our case, okay_button() will handle the event */
-		button->onclick=okay_button;
-
-		/* another button  */
-		button=s3dw_button_new(surface,"Won't tell you",10,7);
-
-		/* we will tell him how sad we are ... */
-		button->onclick=no_button;
-
-		/* this widget is focused (of course, it's our only one ... */
-		s3dw_focus(S3DWIDGET(surface));
-
-		/* show it. without showing, things would be boring... */
-		s3dw_show(S3DWIDGET(surface));
-
-		s3d_mainloop(mainloop);
-		s3d_quit();
-	}
-	return(0);
-}
-

Modified: trunk/libs3d/3dsread.c
===================================================================
--- trunk/libs3d/3dsread.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/libs3d/3dsread.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -1,5 +1,5 @@
 /*
- * 3dsread.c
+ * modelread.c
  *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
@@ -24,17 +24,31 @@
 
 #include "s3d.h"
 #include "s3dlib.h"
+#include <g3d/g3d.h>
 #include <stdlib.h> 	 /*  exit(), malloc() */
 #include <math.h>		 /*  sqrt() */
 #include <string.h> 	 /*  strncpy() */
 #include <errno.h> 		 /*  errno */
+
+
+struct material2texture {
+	struct material2texture *next_ptr;   /* pointer to next */
+	void *material_ptr;
+	void *texture_ptr;
+	int material_id;
+	int texture_id;
+};
+struct material2texture *mat2tex_root = NULL;
+
 #define MAXSTRN		20
+static int model_load(char *file);
 /*  just a helper function for reading from file instead of memory. */
-int s3d_import_3ds_file(char *fname)
+int s3d_import_model_file(char *fname)
 {
 	char *buf,*ptr,*next;
 	char searchpath[1024];
 	char path[1024];
+	int oid;
 #ifndef OBJSDIR
 #define OBJSDIR 	"./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/"
 #endif
@@ -56,494 +70,177 @@
 			strcpy(path,ptr); 					/* can use "unsafe" functions because size was verified above */
 			strcat(path,fname);
 			if (s3d_open_file(path,&buf)!=-1)  /* found something */
-				return(s3d_import_3ds(buf));
+			{
+				free(buf); /* TODO: badbadbad ... */
+				if (-1!=(oid=model_load(path))) return(oid);
+
+			}
 		}
 		if (next!=NULL)
 			ptr=next;							/* move pointer to the next position */
 	}
-	errds(LOW,"s3d_import_3ds_file()","Could not open %s", fname);
+	errds(LOW,"s3d_import_model_file()","Could not open %s", fname);
 	return(-1); /* nothing in search path ... */
 }
-static void normal(float *p0, float *p1, float *p2, float *r)
-{
-	float a[3],b[3],n[3];
-	float len;
-	a[0]=p1[0]-p0[0];
-	a[1]=p1[1]-p0[1];
-	a[2]=p1[2]-p0[2];
-	b[0]=p2[0]-p0[0];
-	b[1]=p2[1]-p0[1];
-	b[2]=p2[2]-p0[2];
-	n[0]=a[1]*b[2] - a[2]*b[1];
-	n[1]=a[2]*b[0] - a[0]*b[2];
-	n[2]=a[0]*b[1] - a[1]*b[0];
 
-	len=sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);
-	if (len!=0.0F)
-	{
-		r[0]=n[0]/len;
-		r[1]=n[1]/len;
-		r[2]=n[2]/len;
-	} else {
-		s3dprintf(VLOW,"normal(): couldn't calc normal");
-		r[0]=r[1]=r[2]=0.0F;
+void *get_mat2tex( struct material2texture **mat2tex, void *mat_ptr ) {
+
+	while ( (*mat2tex) != NULL ) {
+
+		if ( (*mat2tex)->material_ptr == mat_ptr ) return (*mat2tex);
+
+		mat2tex = &(*mat2tex)->next_ptr;
+
 	}
-}
-void sort_poly(unsigned long *smooth_list, unsigned long *poly_buf,int polynum)
-{
-	unsigned long min,minv,i;
-	unsigned long polyel[4];
-	minv=-1;
-	min=0;
-	for (i=0;i<polynum;i++)
-	{
-		if (smooth_list[i]<minv)
-		{
-			min=i;
-			minv=smooth_list[i];
-		}
-	}
-	if (min!=0)  /*  swap */
-	{
-#define EL	4*sizeof(unsigned long)
-		memcpy(polyel,poly_buf,EL);  /* save */
-		memcpy(poly_buf,poly_buf+4*min,EL);  /* put at first place */
-		memcpy(poly_buf+4*min,polyel,EL);
-		 /*  now the same with smooth_list */
-		i=smooth_list[0];
-		smooth_list[0]=smooth_list[min];
-		smooth_list[min]=i;
-#undef EL
-	}
-	if (polynum>1)
-	{
-		sort_poly(smooth_list+1,poly_buf+4,polynum-1);
-	}
 
-}
-struct t_vertex_normal
-{
-	float n[3];
-	unsigned long g,num;
-};
-/*  this functions takes a shitload of arguments, but that's because of optimization.  */
-/*  we add normals of the polygons's vertices so each vertex will finally have */
-/*  the sum of the polygons normals where the vertex is part of. */
-static int smooth(float *vbuf,int voff, unsigned long *pbuf, float *pnbuf, float *nbuf, struct t_vertex_normal *v_t_buf, int pnum, int g)
-{
-	int i,j,n;
-	unsigned long k;
-	float len;
-	 /*  run1: add normals on themselves into the v_t_buf */
-	for (i=0;i<pnum;i++)
-	{
-		for (j=0;j<3;j++)
-		{
-			k=pbuf[i*4+j]-voff;
-			if (v_t_buf[k].g!=g)  /*  not added in this group yet */
-			{
-				for (n=0;n<3;n++)
-					v_t_buf[k].n[n]=(pnbuf+i*3)[n];
-				v_t_buf[k].num=1;
-				v_t_buf[k].g=g;  /*  now it's  in our group. */
-			} else {
-				for (n=0;n<3;n++)
-					v_t_buf[k].n[n]+=(pnbuf+i*3)[n];
-				v_t_buf[k].num++;
-			}
+	if ( (*mat2tex) == NULL ) {
+
+		(*mat2tex) = malloc( sizeof( struct material2texture ) );
+
+		if ( (*mat2tex) == NULL ) {
+			errs( "model_import()", "Sorry - you ran out of memory !\n" );
+			exit(8);
 		}
+
+		(*mat2tex)->next_ptr = NULL;
+		(*mat2tex)->material_ptr = mat_ptr;
+		(*mat2tex)->texture_ptr = NULL;
+		(*mat2tex)->material_id = -1;
+		(*mat2tex)->texture_id = -1;
+
+		return (*mat2tex);
+
 	}
-	 /*  run2: apply to the final vertex buffer */
-	for (i=0;i<pnum;i++)
-	{
-		for (j=0;j<3;j++)
-		{
-			k=pbuf[i*4+j]-voff;
-			if (v_t_buf[k].num>1)  /*  if more than 1, normalize. */
-			{
-				len=sqrt(v_t_buf[k].n[0]*v_t_buf[k].n[0]+v_t_buf[k].n[1]*v_t_buf[k].n[1]+v_t_buf[k].n[2]*v_t_buf[k].n[2]);
-				if (len==0.0F)   /*  this should not happen. well ... */
-				{
-					for (n=0;n<3;n++)
-						v_t_buf[k].n[n]=0;
-					v_t_buf[k].g=-1;  /*  we're telling this by setting group to -1 */
-				}
-				else
-					for (n=0;n<3;n++)
-						v_t_buf[k].n[n]/=len;
-				v_t_buf[k].num=1;
-			}
-			if (v_t_buf[k].g==g)  /*  just making sure, or for the case of bad normals. */
-				memcpy(nbuf+i*9+j*3,v_t_buf[k].n,sizeof(float)*3);  /*  finally, we save the normal in our normal buffer */
-			else  /*  use the pbuf normal */
-			{
-				memcpy(nbuf+i*9+j*3,pnbuf+i*3,sizeof(float)*3);
-			}
-		}
-	}
+
 	return(0);
+
 }
-/*  calculates the normals: */
-static float *calc_normals(float *vertex_buf, int vertexnum, unsigned long *poly_buf,
-				int polynum, int voff,unsigned long *smooth_list)
+
+
+
+int model_load(char *file)
 {
-	int i,j,n=0;
-	float *pnormal_list, *nbuf;  /*  pnormal_list has the space for normals per polygon, */
-								 /*  nbuf has 3 normals per polygon for each vertex */
-	struct t_vertex_normal *v_t_buf;
-								 /*  this buffer will save temporary normals for each vector */
-								 /*  along with the information of group (each group might */
-								 /*  have another normal for a certain vertex) and of polygons */
-								 /*  sharing this vertex. */
-	unsigned long v[3];
-	unsigned long lg,g;  /*  last group and group */
-	lg=-1;g=0;
-	pnormal_list=malloc(sizeof(float)*3*polynum);
-	nbuf=malloc(sizeof(float)*3*3*polynum);
-	v_t_buf=malloc(sizeof(struct t_vertex_normal)*vertexnum);
-	memset(v_t_buf,0,sizeof(struct t_vertex_normal)*vertexnum);
-	sort_poly(smooth_list, poly_buf, polynum);
-	for (i=0;i<polynum;i++)
-	{
-		g=smooth_list[i];
-		if (lg!=g)  /*  a different group */
-		{
-			if (n>0)  /*  that should only be false in the first loop */
-			{
-				smooth(vertex_buf,voff,poly_buf+(i-n)*4,pnormal_list+(i-n)*3, nbuf+(i-n)*9,v_t_buf,n,g);
-			}
-			n=0;  /*  no elements so far in the new group */
-		}
-		for (j=0;j<3;j++)
-		{
-			v[j]=poly_buf[i*4+j]-voff;
-			if (v[j]>=vertexnum)  /*  bad input */
-			{
-				errds(VHIGH,"calc_normals()","bad input, polygon vertex index out of range");
-				return(NULL);
-			}
-		}
-		 /* s3dprintf(LOW,"polygon [%d/%d]: %d %d %d is in smoothlist %d",i,polynum,v[0],v[1],v[2],g); */
+	G3DContext			 	*context;
+	G3DModel				*model;
+	G3DObject 				*object;
+	G3DFace 				*face;
+	GSList 					*oitem, *oface;
+	struct material2texture *mat2tex;
+	int						 i, j, k, material_count, texture_count, voff,obj_id;
+#define 					PMAX	100
+	unsigned long 			 polybuf[PMAX * 4],npoly,oldflags;
+	float					 normalbuf[PMAX * 9],texcoordbuf[PMAX * 6];
+	float 					 swaph;				/* swap helper */
+	unsigned char 			*s3d_pixeldata = NULL;
 
-		normal(	vertex_buf+v[0]*3,
-				vertex_buf+v[1]*3,
-				vertex_buf+v[2]*3,
-				pnormal_list+i*3);
-		lg=g; 	 /*  save the last group */
-		n++;	 /*  save the number of how much elements are in the group now. */
-	}
+	context = g3d_context_new();
+	obj_id=-1;
+	model = g3d_model_load(context, file);
 
+	if ( model ) {
 
+		oitem = model->objects;
+		obj_id = s3d_new_object();
+		material_count = texture_count = voff = 0;
 
-	 /* s3dprintf(MED,"processing the final group ... %d (%d members)",g,n); */
-	smooth(vertex_buf,voff,poly_buf+(i-n)*4,pnormal_list+(i-n)*3, nbuf+(i-n)*9,v_t_buf,n,g);
-/*	for (i=0;i<polynum;i++)
-	{
-		for (j=0;j<3;j++)
-			s3dprintf(MED,"poly[%d/%d],point[%d/3]: %f %f %f",i,polynum,j,
-							nbuf[i*9+j*3],
-							nbuf[i*9+j*3+1],
-							nbuf[i*9+j*3+2]);
-	}*/
-	free(pnormal_list);
-	free(v_t_buf);
-	return(nbuf);
-}
-/* get the intergers in the right order */
-unsigned short gints(char *ptr)
-{
-	register unsigned short i;
-	i= ((unsigned char )ptr[0]);
-	i+=((unsigned char )ptr[1])*0x100;
-	return i;
-}
-unsigned long gintl(char *ptr)
-{
-	register unsigned long i;
-	i= ((unsigned char )ptr[0]);
-	i+=((unsigned char )ptr[1])*0x100;
-	i+=((unsigned char )ptr[2])*0x10000;
-	i+=((unsigned char )ptr[3])*0x1000000;
-	return i;
-}
-/*  imports a 3ds file as ONE object, even it virtually contains more. */
-/*  it returns the object id ... */
-int s3d_import_3ds(char *buf)
-{
-	char *ptr,*ptr2,*mesh_end=NULL;
-	int i,j,polynum=0,vertexnum=0;
-	char ostr[MAXSTRN+1];
-	char materials[256][MAXSTRN+1];
-	int clen,cid;
-	int filesize=1;  /*  just so it hops above the main chunk ... */
-	int vertex_offset=0;
-	int v=0;
-	int col_obj=-1;
-	unsigned long *poly_buf=NULL,*tpbuf,*smooth_list=NULL;
-	unsigned char r1,g1,b1,r2,g2,b2,r3,g3,b3;
-	unsigned char r_amb=255,g_amb=255,b_amb=255,
-				  r_diff=255,g_diff=255,b_diff=255,
-				  r_spec=255,g_spec=255,b_spec=255;
-	unsigned char color=0;
-	unsigned short nfaces;
-	float *vertex_buf=NULL, *nbuf=NULL,*tnbuf;
-	int cur_oid=-1;
-	if (buf==NULL) return(-1);
-	ptr=buf;
-	while (((ptr)>=buf) && ((ptr)<(buf+filesize)))
-	{
-		cid=gints(ptr);
-		clen=gintl(ptr+2);
+		while ( oitem ) {
 
-		s3dprintf (VLOW,"[pos %x]: \t%04x [len:%d]",(ptr-buf),cid,(clen-6));
-		if ((ptr==buf) && (cid!=0x4d4d))
-		{
-			errs("3d_import_3ds()","file doesn't start with 0x4d4d, maybe file corrupt?");
-			return(-1);
-		}
-		ptr=ptr+6;  /*  point to the data .. */
-		switch (cid)
-		{
-		  case 0x4d4d:
-			  s3dprintf(VLOW,"-- the main chunk!!");
-			  filesize=clen;
-			  if (cur_oid==-1)
-			  {
-				  cur_oid=s3d_new_object();
-				   /*  standard material for fallback reasons */
-			      s3d_push_material(cur_oid,0.2,0.2,0,0.2,0.2,0,0.2,0.2,0);
-				  col_obj++;
-			  }
+			object = (G3DObject *)oitem->data;
 
-           	  break;
-		  case 0x3D3D:
-			  s3dprintf(VLOW,"-- the 3d editor chunk!");
-			  break;
-		  case 0x4000:
-			  s3dprintf(VLOW,"-- an object block. let's see ...");
-			  strncpy((char *)ostr,(char *)ptr,MAXSTRN);
-			  vertex_offset+=v;
-			  v=0;
-			  ptr=(ptr+strlen(ostr)+1);
-			  break;
-		  case 0x4100:
-			  s3dprintf(VLOW,"-- Triangular mesh");
-			  smooth_list=NULL;
-			  mesh_end=ptr+(clen-6);
-			  break;
-		  case 0x4110:
-			  vertexnum=gints(ptr);
-			  ptr+=sizeof(unsigned short);
-			  s3dprintf(VLOW,"-- vertices list!! number of vertices: %d",vertexnum);
-			  vertex_buf=malloc(sizeof(float)*3*vertexnum);
-			  if (vertex_buf==NULL) break;
-/* 			  memcpy(vertex_buf,ptr,sizeof(float)*3*i); */
-			  for (j=0; j<vertexnum; j++)
-		 	  {
-				*(vertex_buf+j*3+0)=*((float *)ptr+0);
-				*(vertex_buf+j*3+1)=*((float *)ptr+2);
-				*(vertex_buf+j*3+2)=-*((float *)ptr+1);
-				ptr+=sizeof(float)*3;
-			  }
-			  v+=vertexnum;  /*  for the correct vertex offset */
-			break;
-		  case 0x4120:
-			polynum=gints(ptr);
-			ptr+=sizeof(unsigned short);
-			s3dprintf(VLOW,"-- polygon list!! number of polygons: %d",polynum);
-			poly_buf=malloc(sizeof(unsigned long)*4*polynum);
-			if (poly_buf==NULL) break;
-		    for (j=0; j<polynum; j++)
-			{
-				poly_buf[j*4+0]=vertex_offset+gints(ptr+0);
-				poly_buf[j*4+1]=vertex_offset+gints(ptr+4);
-				poly_buf[j*4+2]=vertex_offset+gints(ptr+2);
-				poly_buf[j*4+3]=col_obj;  /*  we should have a default material .... */
-				ptr+=sizeof(unsigned short)*4;
-		    }
-			break;
-		  case 0x4130:
-			ptr2=(char *)ptr+(clen-6);  /*  backup our endpointer ... */
-			s3dprintf(VLOW,"-- material information for faces .....");
-			strncpy((char *)ostr,(char *)ptr,MAXSTRN);
-			ptr+=strlen(ptr)+1;
-			s3dprintf(VLOW,".. material string name is %s",ostr);
-			col_obj=0;
-			while (col_obj<256 && (strncmp(ostr,materials[col_obj],MAXSTRN)!=0)) col_obj++;
-			if (col_obj>=256)
-			{
-				errds(MED,"s3d_import_3ds()","couldn't find material %s",ostr);
-				col_obj=0;
+			/* push vertices */
+			for ( j = 0; j < object->vertex_count; j++ ) {
+				/* 2. and 3. coord have to change places otherwise the object will be turned */
+				swaph=							 object->vertex_data[j * 3 + 2];
+				object->vertex_data[j * 3 + 2] = object->vertex_data[j * 3 + 1];
+				object->vertex_data[j * 3 + 1] = swaph;
 			}
-			nfaces=gints(ptr);
-			ptr+=2;
-			for (i=0;i<nfaces;i++)
-			{
-				j=gints(ptr+2*i);
-				if (j>=0 && j<polynum)
-					poly_buf[gints(ptr+2*i)*4+3]=col_obj;
-				else {
-					errds(MED,"s3d_import_3ds()","polygon %d out of range!",j);
-				}
-			}
-			ptr=ptr2;
-			break;
-		  case 0x4150:
-			s3dprintf(VLOW,"-- smoothing group information (length %d [%d])", clen,clen/4);
-			smooth_list=(unsigned long *)ptr;
-			for (j=0;j<(clen/4);j++)
-			{
-				smooth_list[j]=gintl(ptr+j*4);
-				s3dprintf(VLOW, "smooth_list[%i] = %i", j, smooth_list[j] );
-			}
+			s3d_push_vertices( obj_id, object->vertex_data, object->vertex_count);
+					
 
-			ptr=(char *)ptr+(clen-6);
-			break;
-		  case 0x4160:
-			  s3dprintf(VLOW,"-- translation matrix");
-			  for (j=0; j<4; j++)
-		 	  {
-				s3dprintf(VLOW,"[%f:%f:%f:%f]",
-								*((float *)ptr),
-								*((float *)ptr+1),
-								*((float *)ptr+2),
-								((j==3)?1.0:0.0)
-								);
-				ptr+=sizeof(float)*3;
-			  }
-			  break;
-		  case 0xafff:
-			  s3dprintf(VLOW,"-- material chunk O_o");
-			  break;
-		  case 0xa000:
-			  strncpy((char *)ostr,(char *)ptr,MAXSTRN);
-			  s3dprintf(VLOW,"-- material string name is %s",ostr);
-			  ptr=(char *)ptr+(clen-6);
-			  color|=8;
-			  break;
-		  case 0xa010:
-			  r1=(unsigned char)*(ptr);
-			  g1=(unsigned char)*(ptr+1);
-			  b1=(unsigned char)*(ptr+2);
-			  r2=(unsigned char)*(ptr+3);
-			  g2=(unsigned char)*(ptr+4);
-			  b2=(unsigned char)*(ptr+5);
-			  r3=(unsigned char)*(ptr+6);
-			  g3=(unsigned char)*(ptr+7);
-			  b3=(unsigned char)*(ptr+8);
-			  s3dprintf(VLOW,"-- ambient color 3:>> [rgb] [%x %x %x]",r3,g3,b3);
-			  r_amb=r3;g_amb=g3;b_amb=b3;
-			  color=color|1;
-			  ptr=(char *)ptr+(clen-6);
-			  break;
-		  case 0xa020:
-			  r1=(unsigned char)*(ptr);
-			  g1=(unsigned char)*(ptr+1);
-			  b1=(unsigned char)*(ptr+2);
-			  r2=(unsigned char)*(ptr+3);
-			  g2=(unsigned char)*(ptr+4);
-			  b2=(unsigned char)*(ptr+5);
-			  r3=(unsigned char)*(ptr+6);
-			  g3=(unsigned char)*(ptr+7);
-			  b3=(unsigned char)*(ptr+8);
-			  s3dprintf(VLOW,"-- diffuse color 3:>> [rgb] [%x %x %x]",r3,g3,b3);
-			  r_diff=r3;g_diff=g3;b_diff=b3;
-			  color=color|2;
-			  ptr=(char *)ptr+(clen-6);
-			  break;
-		  case 0xa030:
-			  r1=(unsigned char)*(ptr);
-			  g1=(unsigned char)*(ptr+1);
-			  b1=(unsigned char)*(ptr+2);
-			  r2=(unsigned char)*(ptr+3);
-			  g2=(unsigned char)*(ptr+4);
-			  b2=(unsigned char)*(ptr+5);
-			  r3=(unsigned char)*(ptr+6);
-			  g3=(unsigned char)*(ptr+7);
-			  b3=(unsigned char)*(ptr+8);
-			  s3dprintf(VLOW,"-- spec color 3:>> [rgb] [%x %x %x]",r3,g3,b3);
-			  r_spec=r3;g_spec=g3;b_spec=b3;
-			  color=color|4;
-			  ptr=(char *)ptr+(clen-6);
-			  break;
-		  default:
-			ptr=(char *)ptr+(clen-6);
-		}
-		 /*  color finished? then upload. I know, this is not real implementation ... */
-		if (color==15)
-		{
-			col_obj++;
-			if (col_obj<256)  /*  TODO: we currently don't support  */
-							  /*  more than 256 materials ...  */
-							  /*  that's just because i'm lazy */
-			{
-				strncpy(materials[col_obj],ostr,MAXSTRN);
-				s3dprintf(VLOW,"assigned material %s on position %d",
-								materials[col_obj],col_obj);
-			}
-			s3dprintf(VLOW,"-- [%d]colors... amb: %d %d %d, spec %d %d %d, diff %d %d %d",col_obj,
-							r_amb,g_amb,b_amb,
-							r_spec,g_spec,b_spec,
-							r_diff,g_diff,b_diff
-				   );
-			s3d_push_material(cur_oid,
-							r_amb/255.0,g_amb/255.0,b_amb/255.0,
-							r_spec/255.0,g_spec/255.0,b_spec/255.0,
-							r_diff/255.0,g_diff/255.0,b_diff/255.0
-							);
-			color=0;
-		}
-		if ((mesh_end!=NULL) && (ptr>=mesh_end))
-		{
-			mesh_end=NULL;
-			if ((vertex_buf!=NULL))
-			    s3d_push_vertices(cur_oid, vertex_buf, vertexnum);
-			if (poly_buf!=NULL)
-			{
-				if (smooth_list!=NULL)
-					nbuf=calc_normals(vertex_buf,vertexnum,poly_buf,polynum,vertex_offset,smooth_list);
 
-				 /*  do in 1000 chunks */
-				s3dprintf(LOW,"committing %d polys",polynum);
-				tnbuf=nbuf;
-				tpbuf=poly_buf;
-#define CSIZE	1000
-				while (polynum>CSIZE)
+			oface = object->faces;
+			npoly=0;
+			oldflags = ((G3DFace *) (oface->data))->flags;
+
+			while ( oface ) {
+
+				face = (G3DFace *)oface->data;
+				mat2tex = get_mat2tex( &mat2tex_root, face->material );
+
+				if ( mat2tex->material_id == -1 ) { /* create a new texture if nothing found */
+					s3d_push_material_a( obj_id, 	face->material->r, face->material->g, face->material->b,face->material->a, 
+													face->material->specular[0], face->material->specular[1], face->material->specular[2], face->material->specular[3],
+													face->material->r, face->material->g, face->material->b, face->material->a );
+
+					mat2tex->material_id = material_count;
+					material_count++;
+
+					if ( face->tex_image != NULL ) {
+
+						/* reorder pixeldata - s3d wants rgba */
+						if ( s3d_pixeldata != NULL ) free( s3d_pixeldata );
+
+						s3d_pixeldata = malloc( sizeof( unsigned char ) * face->tex_image->width * face->tex_image->height * 32 );
+
+						if ( s3d_pixeldata == NULL ) {
+							errs("model_load()", "Sorry - you ran out of memory !\n" );
+							exit(8);
+						}
+
+						for ( j = ( face->tex_image->height - 1 ); j >= 0; j-- ) {
+							for ( k = 0; k < face->tex_image->width; k++ ) {
+								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ];
+								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ];
+								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ];
+								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ];
+							}
+						}
+
+						s3d_push_texture( obj_id, face->tex_image->width, face->tex_image->height );
+						s3d_pep_material_texture( obj_id, texture_count );
+						s3d_load_texture( obj_id, texture_count, 0, 0, face->tex_image->width, face->tex_image->height, s3d_pixeldata );
+
+						mat2tex->texture_id = texture_count;
+						texture_count++;
+
+					}
+				}
+				if (face->flags != oldflags || npoly>=PMAX)
 				{
-					s3d_push_polygons(cur_oid, tpbuf, CSIZE);
-					if (nbuf!=NULL)
-						s3d_pep_polygon_normals(cur_oid,tnbuf, CSIZE);
-					tnbuf+=	CSIZE*9;
-					tpbuf+=	CSIZE*4;
-					polynum-=CSIZE;
+					/* push things so far */
+					s3d_push_polygons(obj_id, polybuf, npoly);
+					if (oldflags & G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
+					if (oldflags & G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);
+					npoly=0;
 				}
-				s3d_push_polygons(cur_oid, tpbuf, polynum);
-				if (nbuf!=NULL)
-					s3d_pep_polygon_normals(cur_oid,tnbuf, polynum);
-			}
+				oldflags=face->flags;
 
+				/* add polygon to the polygon buffer */
+				for (i=0;i<3;i++)
+					polybuf[npoly*4+i]=face->vertex_indices[i] + voff;
+				polybuf[npoly*4+3]=mat2tex->material_id;
 
-			 /*  clean things up */
-			if (vertex_buf!=NULL)
-			{
-				free(vertex_buf);vertex_buf=NULL;
+				if ( face->flags & G3D_FLAG_FAC_NORMALS ) memcpy( normalbuf + npoly*9,  face->normals, sizeof(float) * 9);
+				if ( face->flags & G3D_FLAG_FAC_TEXMAP )  memcpy( texcoordbuf + npoly*6,  face->tex_vertex_data, sizeof(float) * 6);
+				npoly++;
+				oface = oface->next;
 			}
-			if (poly_buf!=NULL)
+			/* push the last packets in buffer */
+			if (npoly > 0)
 			{
-				free(poly_buf);poly_buf=NULL;
+				s3d_push_polygons(obj_id, polybuf, npoly);
+				if (oldflags & G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
+				if (oldflags & G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);
+				npoly=0;
 			}
-			if (smooth_list!=NULL)
-			{
-				/*FIXME: free(smooth_list);*/
-				smooth_list=NULL;
-			}
-			if (nbuf!=NULL)
-			{
-				free(nbuf);nbuf=NULL;
-			}
+	
+			voff += object->vertex_count; /* increase vertex offset */
+			oitem = oitem->next;
 		}
 	}
-	s3dprintf(VLOW,"-- done [ptr:%010p,buf:%010p]...",ptr,buf);
-	free(buf);
-	return(cur_oid);
+	g3d_model_free(model);
+	g3d_context_free(context);
+	
+	return(obj_id);
 }
+

Modified: trunk/libs3d/Makefile.am
===================================================================
--- trunk/libs3d/Makefile.am	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/libs3d/Makefile.am	2006-09-16 00:44:17 UTC (rev 391)
@@ -10,7 +10,7 @@
 noinst_HEADERS=		config.h s3dlib.h sei_triangulate.h sei_interface.h
 
 libs3d_la_CPPFLAGS=	-I${top_srcdir}/server
-libs3d_la_CFLAGS=	@FONTCONFIG_CFLAGS@ @FREETYPE_CFLAGS@ 
-libs3d_la_LIBADD=	@FONTCONFIG_LIBS@ @FREETYPE_LIBS@ @LIBM@
+libs3d_la_CFLAGS=	@FONTCONFIG_CFLAGS@ @FREETYPE_CFLAGS@ -I$(top_srcdir)/libs3d/libg3d/include @GLIB_CFLAGS@
+libs3d_la_LIBADD=	@FONTCONFIG_LIBS@ @FREETYPE_LIBS@ @LIBM@ $(top_builddir)/libs3d/libg3d/src/libg3d.la
 
 EXTRA_DIST=		lgpl.txt

Modified: trunk/libs3d/libg3d/plugins/import/Makefile.am
===================================================================
--- trunk/libs3d/libg3d/plugins/import/Makefile.am	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/libs3d/libg3d/plugins/import/Makefile.am	2006-09-16 00:44:17 UTC (rev 391)
@@ -29,8 +29,8 @@
 AM_CFLAGS = \
 	-Wall -ansi -pedantic \
 	-DG_LOG_DOMAIN=\"LibG3D\" \
-	@DBG_CFLAGS@ -DDEBUG=1 \
-	@GLIB_CFLAGS@
+	@DBG_CFLAGS@ \
+	@GLIB_CFLAGS@ #-DDEBUG=1 
 
 INCLUDES = -I$(top_builddir)/libs3d/libg3d/include
 

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-16 00:44:17 UTC (rev 391)
@@ -406,7 +406,7 @@
 	GSList *oface;
 	gint32 i, j, k, n=0, polynum, group;
 	guint32 *smooth_list;
-	gfloat *pnormal_list, *v_t_buf;
+	gfloat *pnormal_list, *vertex_normal_buf;			 	
 	gfloat a[3],b[3], *p0,*p1,*p2,*r;
 	gfloat len;
 
@@ -418,13 +418,11 @@
 	polynum=0;
 	for (oface=object->faces; oface != NULL ; oface=oface->next) polynum++; /* count polygons */
 
-	pnormal_list=	g_new(float, 3*polynum);							/* polygon normal list */
-	v_t_buf=		g_new0(float,3*object->vertex_count);				/* normals per vertice */
-	smooth_list = 	g_new(guint32, polynum);
-	printf("reading %d int32 values\n",polynum);
+	pnormal_list=		g_new(float, 3*polynum);							/* polygon normal list */
+	vertex_normal_buf=	g_new0(float,3*object->vertex_count);				/* normals per vertice */
+	smooth_list = 		g_new(guint32, polynum);
 	for ( i=0 ; i<polynum ; i++ ) 
 		smooth_list[i] = g3d_read_int32_le(global->f);
-
 	parent->nb -= polynum * 4;
 	/* first, we calculate the normal by the polygon vertices (just vector product) */
 	i=0;
@@ -435,7 +433,7 @@
 		p0=&(object->vertex_data[3* face->vertex_indices[0]]);
 		p1=&(object->vertex_data[3* face->vertex_indices[1]]);
 		p2=&(object->vertex_data[3* face->vertex_indices[2]]);
-
+		
 		a[0]=p1[0] - p0[0];
 		a[1]=p1[1] - p0[1];
 		a[2]=p1[2] - p0[2];
@@ -445,7 +443,7 @@
 		r[0]=a[1]*b[2] - a[2]*b[1];
 		r[1]=a[2]*b[0] - a[0]*b[2];
 		r[2]=a[0]*b[1] - a[1]*b[0];
-
+	
 		len=sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);
 		if (len!=0.0F)
 		{
@@ -458,26 +456,23 @@
 		face->flags|=G3D_FLAG_FAC_NORMALS;
 		i++;
 	}
-
 	do {
 		/* find a suitable group. -1 means we've already taken care */
 		group=-1;
 		for (i=0;i<polynum;i++)
 			if ((group=smooth_list[i])!=-1) /* found a group */
 				break;
-		printf("handling group %d\n",group);
 		/* handle this group */
 		if (group!=-1)
 		{
 			/* SMOOTH */
-			/*  this functions takes a shitload of arguments, but that's because of optimization.  */
 			/*  we add normals of the polygons's vertices so each vertex will finally have */
 			/*  the sum of the polygons normals where the vertex is part of. */
 
-			/* run0: clear the v_t_buf for this group */
+			/* run0: clear the vertex_normal_buf for this group */
 			for (i=0;i<object->vertex_count*3;i++)
-				v_t_buf[i]=0.0;
-			 /*  run1: add normals on themselves into the v_t_buf */
+				vertex_normal_buf[i]=0.0;
+			 /*  run1: add normals on themselves into the vertex_normal_buf */
 			i=0;
 			for (oface=object->faces; oface != NULL ; oface=oface->next)
 			{
@@ -488,7 +483,7 @@
 					{
 						k=face->vertex_indices[j];
 						for (n=0;n<3;n++)
-							v_t_buf[ k*3+n ]+= pnormal_list[i*3 + n];
+							vertex_normal_buf[ k*3+n ]+= pnormal_list[i*3 + n];
 					}
 				}
 				i++;
@@ -504,18 +499,15 @@
 					for (j=0;j<3;j++)
 					{
 						k=face->vertex_indices[j];
-						len=sqrt(	v_t_buf[k*3]   * v_t_buf[k]+
-									v_t_buf[k*3+1] * v_t_buf[k*3+1]+
-									v_t_buf[k*3+2] * v_t_buf[k*3+2]);
-						printf("vertex buffer : %f %f %f ... len = %f\n",v_t_buf[k*3],v_t_buf[k*3+1],v_t_buf[k*3+2],len);
+						len=sqrt(	vertex_normal_buf[k*3]   * vertex_normal_buf[k*3]+
+									vertex_normal_buf[k*3+1] * vertex_normal_buf[k*3+1]+
+									vertex_normal_buf[k*3+2] * vertex_normal_buf[k*3+2]);
 						if (len==0.0F)   /*  this should not happen. well ... */
-								for (n=0;n<3;n++)	v_t_buf[k*3 + n]=0;
-						else	for (n=0;n<3;n++)	v_t_buf[k*3 + n]/=len; /* normalize it */
-
-						if (len!=0.0) 	memcpy(face->normals +j*3, v_t_buf+ 	k*3,sizeof(gfloat)*3);	/*  finally, we save the normal in our normal buffer */
-						else  			{memcpy(face->normals +j*3, pnormal_list+i*3,sizeof(gfloat)*3);	/*  use the pbuf normal */
-							printf("using pnormal_list as fallback\n");
-						}
+								for (n=0;n<3;n++)	vertex_normal_buf[k*3 + n]=0;
+						else	for (n=0;n<3;n++)	vertex_normal_buf[k*3 + n]/=len; /* normalize it */
+						
+						if (len!=0.0) 	memcpy(face->normals +j*3, vertex_normal_buf+ 	k*3,sizeof(gfloat)*3);	/*  finally, we save the normal in our normal buffer */
+						else  			memcpy(face->normals +j*3, pnormal_list+i*3,sizeof(gfloat)*3);	/*  use the pbuf normal */
 					}
 					smooth_list[i]=-1; /* finished this polygon */
 				}
@@ -526,7 +518,7 @@
 	} while (group!=-1);
 
 	g_free(pnormal_list);
-	g_free(v_t_buf);
+	g_free(vertex_normal_buf);
 	g_free(smooth_list);
 	return TRUE;
 }

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2006-09-15 22:51:28 UTC (rev 390)
+++ trunk/libs3d/s3d.h	2006-09-16 00:44:17 UTC (rev 391)
@@ -151,8 +151,7 @@
 int s3d_scale(int object, float s);
 
 /* high-level object creating */
-int s3d_import_3ds_file(char *fname);
-int s3d_import_3ds(char *buf);
+int s3d_import_model_file(char *fname);
 int s3d_open_file(char *fname, char **pointer);
 int s3d_select_font(char *mask);
 int s3d_draw_string( char *str, float *xlen);



From dotslash at mail.berlios.de  Sat Sep 16 02:59:52 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 16 Sep 2006 02:59:52 +0200
Subject: [S3d-svn] r392 - in trunk: apps/dot_mcp apps/olsrs3d
	apps/s3d_x11gate apps/s3dfm apps/s3dgps apps/s3dvt example libs3d
Message-ID: <200609160059.k8G0xqG8003885@sheep.berlios.de>

Author: dotslash
Date: 2006-09-16 02:59:49 +0200 (Sat, 16 Sep 2006)
New Revision: 392

Added:
   trunk/libs3d/modelread.c
Removed:
   trunk/libs3d/3dsread.c
Modified:
   trunk/apps/dot_mcp/main.c
   trunk/apps/dot_mcp/menu.c
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/net.c
   trunk/apps/olsrs3d/process.c
   trunk/apps/olsrs3d/search.c
   trunk/apps/s3d_x11gate/s3d_x11gate.c
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/fs.c
   trunk/apps/s3dfm/icon.c
   trunk/apps/s3dfm/main.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dgps/s3dgps.c
   trunk/apps/s3dvt/main.c
   trunk/apps/s3dvt/terminal.c
   trunk/example/filebrowser.c
   trunk/example/hudtest.c
   trunk/example/katze.c
   trunk/example/linetest.c
   trunk/example/modelloader.c
   trunk/example/nichtsnutz.c
   trunk/example/ptrtest.c
   trunk/example/radius_test.c
   trunk/example/s3dclock.c
   trunk/example/snowman.c
   trunk/example/strtest.c
   trunk/example/texturetest.c
   trunk/example/widgets.c
   trunk/libs3d/Makefile.am
Log:
- oops, reverted ;)

Modified: trunk/apps/dot_mcp/main.c
===================================================================
--- trunk/apps/dot_mcp/main.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/dot_mcp/main.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,525 @@
+/*
+ * main.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of dot_mcp, a mcp for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * dot_mcp is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * dot_mcp is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with dot_mcp; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <s3d.h>
+#include <s3d_keysym.h>
+#include "dot_mcp.h"
+#include <unistd.h>  /*  sleep() */
+#include <stdlib.h>  /*  free(), malloc() */
+#include <string.h>  /*  strncpy() */
+#include <stdio.h>  /*  printf() */
+#include <math.h>	/* sin(), cos() */
+#include <time.h>	/* nanosleep() */
+static struct timespec t={0,33*1000*1000}; 
+
+#define bsize 	0.2
+struct tver
+{
+	float x,y,z;
+};
+struct tver campos, camrot;
+float xdif=0,ydif=0;
+
+struct app {
+	unsigned int oid,oid_c;
+	float r;
+	int init;
+	float trans_x,trans_y,trans_z;
+	float textw;
+	char name[256]; 
+	int min_but,close_but,title;
+	int sphere;
+	struct app *next;
+};
+int ego_mode=0;
+float asp=1.0;
+struct app *apps=NULL;
+float bottom=-1.0;
+float left=-1.0;
+float zoom=5.0;
+int n_app=0;
+int rot_flag=0;
+struct app *focus=NULL;
+float focus_r=0;
+float alpha=0;
+unsigned int min_but,rotate,close_but,sphere,reset,menu=-1;
+
+void place_apps();
+
+#define SIDES	60
+#define RINGS	60
+int greentorus()
+{
+	int o,i,j;
+	float R,r,a;
+	float ia,ja,iap,jap;
+	float v[SIDES*RINGS*3];
+	float n[SIDES*12]; /* normals */
+	unsigned long l[SIDES*RINGS*6];
+	o=s3d_new_object();
+	R=100; /* outer radius */
+	r=100; /* inner radius */
+	a=M_PI/180;
+	s3d_push_material_a(o, 0.2,0.6,0.2,0.5,
+						   1  ,1  ,1  ,0.5,
+						   0.2,0.6,0.2,0.5);
+	for (i=0;i<RINGS;i++)
+	{
+		for (j=0;j<SIDES;j++)
+		{
+			ia=a*((float)i*360.0/RINGS);
+			ja=a*((float)j*360.0/SIDES);
+			iap=a*((float)(i+1)*360.0/RINGS);
+			jap=a*((float)(j+1)*360.0/SIDES);
+
+			v[i*SIDES*3+ j*3 +0]=(R+r*cos(ja))* cos(ia);
+			v[i*SIDES*3+ j*3 +1]=r*sin(ja);
+			v[i*SIDES*3+ j*3 +2]=(R+r*cos(ja))* sin(ia);
+		
+			l[i*SIDES*6+ j*6 +0]=i*SIDES+ j;
+			l[i*SIDES*6+ j*6 +1]=i*SIDES+ (j+1)%SIDES;
+			l[i*SIDES*6+ j*6 +2]=0;
+			l[i*SIDES*6+ j*6 +3]=i*SIDES+ j;
+			l[i*SIDES*6+ j*6 +4]=((i+1)%RINGS)*SIDES+ j;
+			l[i*SIDES*6+ j*6 +5]=0;
+			
+			n[j*12 +0] =R*r*cos(ja)*    cos(ia) + r*r*cos(ja)* cos(ia)*cos(ia);
+			n[j*12 +1] =R*r*sin(ja)*    cos(ia) + r*r*sin(ja)* cos(ia)*cos(ia);
+			n[j*12 +2] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
+			n[j*12 +3] =R*r*cos(jap)*    cos(ia)+ r*r*cos(jap)*cos(ia)*cos(ia);
+			n[j*12 +4] =R*r*sin(jap)*    cos(ia)+ r*r*sin(jap)*cos(ia)*cos(ia);
+			n[j*12 +5] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
+
+			n[j*12 +6] =R*r*cos(ja)*    cos(ia) + r*r*cos(ja)* cos(ia)*cos(ia);
+			n[j*12 +7] =R*r*sin(ja)*    cos(ia) + r*r*sin(ja)* cos(ia)*cos(ia);
+			n[j*12 +8] =R*r*sin(ia) 			+ r*r*sin(ia)* cos(ia);
+			n[j*12 +9] =R*r*cos(ja)*    cos(iap)+ r*r*cos(ja)* cos(ia)*cos(iap);
+			n[j*12 +10]=R*r*sin(ja)*    cos(iap)+ r*r*sin(ja)* cos(ia)*cos(iap);
+			n[j*12 +11]=R*r*sin(iap) 			+ r*r*sin(iap)*cos(iap);
+		}
+		s3d_push_vertices(o,&v[i*SIDES*3],SIDES);
+		s3d_push_lines(o,   &l[i*SIDES*6],SIDES*2);
+		s3d_pep_line_normals(o,n,SIDES*2);
+	}
+/*	s3d_push_vertices(o,v,SIDES*RINGS);
+	s3d_push_lines(o,   l,SIDES*RINGS*2);*/
+
+	s3d_flags_on(o,S3D_OF_VISIBLE);
+	return(o);
+}
+void set_focus(struct app *a)
+{
+	if (focus!=a)
+		/* resetting old focus */
+		if (focus!=NULL)
+		{
+			printf("unfocusing app name %s\n",focus->name);
+			s3d_scale(focus->oid,1/focus->r);
+			s3d_scale(focus->sphere,focus->r);
+
+  			s3d_flags_on(focus->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_off(focus->min_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_translate(	focus->title,-focus->textw-1.2,0.0,0);
+			s3d_translate(	focus->close_but,bsize*focus->textw/2,1.2,0);
+			s3d_link(		focus->close_but,focus->sphere);
+			s3d_link(		focus->oid,0); 
+		}
+	focus=a;
+	if (a==NULL)
+	{
+		focus_r=n_app;
+		s3d_mcp_focus(-1);
+		s3d_flags_off(rotate,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_off(reset,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		rot_flag=0;
+	} else {
+		/* set the new focus app up */
+		s3d_translate(	a->title,-a->textw-9.6,0.0,0);
+		s3d_translate(	reset,-7.2,0.0,0);
+		s3d_translate(	rotate,-4.8,0.0,0);
+		s3d_translate(	a->min_but,-2.4,0.0,0);
+		s3d_link(		a->close_but,0);
+		s3d_link(		rotate,a->close_but);
+		s3d_link(		reset,a->close_but);
+		s3d_flags_on(	a->min_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_on(	rotate,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_on(	reset,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_off(	a->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_unlink(a->oid);
+		s3d_rotate(a->oid,		0,0,0);
+		s3d_translate(a->oid,	0,0,0);
+		focus_r=a->r;
+		s3d_scale(a->oid,1);
+		s3d_mcp_focus(	a->oid);
+	}
+	place_apps();
+}
+
+int add_app(struct app *a)
+{
+	struct app *prev=NULL,*a2=apps;
+	while ((a2)!=NULL)
+	{
+		prev=a2;
+		if (a2->oid==a->oid)
+		{  /*  already added, so free() and return */
+			free(a);
+			return(1);
+		}
+		a2=a2->next;  /*  go to the end */
+	}
+	a->next=NULL;
+	if (prev==NULL)
+		apps=a;
+	else 
+		prev->next=a;
+	n_app+=1;
+	return(0);
+}
+void *find_app(int oid)
+{
+	struct app *a=apps;
+	while (a!=NULL)
+	{
+		if (oid==a->oid)
+			break;
+		a=a->next;
+	}
+	return(a);
+}
+void *del_app(int oid)
+{
+	struct app *prev=NULL,*a=apps;
+	while ((a!=NULL)  && (a->oid!=oid))
+	{
+		prev=a;
+		a=a->next;
+	}
+	if (a!=NULL)
+	{  /*  found ... */
+		if (a->init)
+		{
+			s3d_del_object(a->close_but);
+			s3d_del_object(a->min_but);
+			s3d_del_object(a->title);
+			s3d_del_object(a->sphere);
+			s3d_del_object(a->oid);
+		}
+		if (prev==NULL) 
+			apps=a->next;  /*  new head */
+		else
+			prev->next=a->next;
+		n_app--;
+		if (focus==a)
+		{
+			set_focus(NULL);
+			focus=NULL;
+		}
+		free(a);
+		place_apps();
+	} 
+	return(a);
+}
+void stop()
+{
+	s3d_quit();
+}
+void place_apps()
+{
+	struct app *a=apps;
+	int j=0;
+	float u[3],v[3],ya,xa;
+	while (a!=NULL)
+	{
+		if (a->init)	
+		{
+/*			printf("placing app [%d,'%s'], oid %d, r=%f\n",j,a->name,a->oid,a->r); */
+			if (focus==a)
+			{
+				s3d_translate(a->close_but,(-left)*zoom-0.4,(-bottom)*zoom-0.4,-zoom);
+			}
+			else 
+			{
+				s3d_translate(	a->oid,	zoom*(left)+j*2+1.0,zoom*bottom+1.0,-zoom);
+				s3d_rotate(		a->oid,	0,10,0);
+				j++;
+			}
+		}
+		a=a->next;
+	}
+	s3d_translate(menu,	left*zoom+0.4,(-bottom)*zoom-0.4,-zoom);
+	
+	v[0]=0;				v[1]=0;					v[2]=1;
+	u[0]=left*zoom+0.4; u[1]=0;					u[2]=-zoom;
+	ya=s3d_vector_angle(v,u);
+	u[0]=0; 			u[1]=(-bottom)*zoom;	u[2]=-zoom;
+	xa=s3d_vector_angle(v,u);
+	s3d_rotate(menu, 0 ,30,0); 
+}
+void mcp_object(struct s3d_evt *hrmz)
+{
+	struct mcp_object *mo;
+	struct app *a;
+	mo=(struct mcp_object *)hrmz->buf;
+	if (NULL==(a=find_app(mo->object)))
+	{
+		printf("adding new object ......");
+		a=malloc(sizeof(struct app));
+		a->oid=mo->object;
+		a->r=mo->r;
+		strncpy(a->name,mo->name,256);
+		a->init=0;
+		add_app(a);
+		place_apps();
+		printf("..%s\n",a->name);
+	} else {
+/*		printf("updating app %d\n",a->oid);*/
+		a->trans_x=mo->trans_x;
+		a->trans_y=mo->trans_y;
+		a->trans_z=mo->trans_z;
+		a->r=mo->r;
+		if (a->init)
+		{
+			if (a==focus)
+			{
+				focus_r=a->r;
+			} else {
+				s3d_scale(a->sphere,a->r);
+				s3d_scale(a->oid,1/a->r);
+			}
+		}
+		place_apps();
+	}
+}
+void app_init(struct app *a)
+{
+	printf("building some window decorations on %d ['%s']\n",a->oid,a->name);
+	printf("radius of object %d is %f\n",a->oid,a->r);
+	s3d_scale(a->oid,		1/a->r);
+
+	a->sphere=s3d_clone(sphere);
+	s3d_scale(		a->sphere,a->r);
+	s3d_link(		a->sphere,a->oid);
+  	s3d_flags_on(	a->sphere,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+
+	a->title=s3d_draw_string(a->name,&a->textw);
+
+	a->close_but=s3d_clone(close_but);
+	s3d_translate(	a->close_but,bsize*a->textw/2.0,1.2f,0.0f);
+	s3d_link(		a->close_but,a->sphere);
+  	s3d_flags_on(	a->close_but,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+
+
+	s3d_translate(	a->title,-a->textw-1.2f,0.0f,0.0f);
+	s3d_link(		a->title,a->close_but);
+   	s3d_flags_on(	a->title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	
+	a->min_but=s3d_clone(min_but);
+	s3d_link(		a->min_but,a->close_but);
+	
+	
+	s3d_scale(		a->close_but,bsize);
+	
+	s3d_link(		a->oid,0);
+	a->init=1;
+/*	if (focus==NULL)
+		set_focus(a);
+	else*/
+		place_apps();
+}
+void mcp_del_object(struct s3d_evt *hrmz)
+{
+	struct mcp_object *mo;
+	printf("omg, something got deleted!!\n");
+	mo=(struct mcp_object *)hrmz->buf;
+	del_app(mo->object);
+}
+void object_click(struct s3d_evt *hrmz)
+{
+	struct app *a;
+	unsigned int i, oid;
+	oid=*((unsigned int *)hrmz->buf);
+	printf("%d got clicked\n",oid);
+	a=apps;i=0;
+	if (oid==rotate)
+	{
+		rot_flag=!rot_flag;
+		return;
+	}
+	if (oid==reset)
+	{
+		s3d_translate(0,0.0,0.0,5.0);
+		s3d_rotate(0,0,0,0);
+	}
+	while (a!=NULL)
+	{
+		if (oid==a->close_but)
+		{
+			del_app(a->oid);
+			return;
+		} else 	if (oid==a->min_but)
+		{
+			if (a==focus)
+			{
+				set_focus(NULL); /* nothing is focused now */
+			}
+			return;
+		} else 	if (((oid==a->title) || (oid==a->sphere)) || (oid==a->oid))
+		{
+			printf("giving focus to [%s], %d\n",a->name,oid);
+			set_focus(a);
+			return;
+		}
+		i++;
+		a=a->next;
+	}
+	menu_click(oid);
+}
+void object_info(struct s3d_evt *hrmz)
+{
+	struct s3d_obj_info *inf;
+	inf=(struct s3d_obj_info *)hrmz->buf;
+	if (inf->object==0)
+	{
+		campos.x=inf->trans_x;
+		campos.y=inf->trans_y;
+		campos.z=inf->trans_z;
+		camrot.x=inf->rot_x;
+		camrot.y=inf->rot_y;
+		camrot.z=inf->rot_z;
+
+		if (asp!=inf->scale)
+		{
+			asp=inf->scale;
+			printf("screen aspect: %f\n",asp);
+			if (asp>1.0) /* wide screen */
+			{
+				bottom=-1.0;
+				left=-asp;
+			} else {  /* high screen */
+				bottom=(-1.0/asp);
+				left=-1.0;
+			}
+			place_apps(); /* replace apps */
+		}
+	}
+}
+void mainloop()
+{
+	struct app *a;
+	float al,r;
+	int i;
+	a=apps;i=0;
+	while (a!=NULL)
+	{
+		if (!a->init)
+			app_init(a);
+		i++;
+		a=a->next;
+	}
+	if (rot_flag)
+	{
+		al=(alpha*M_PI/180);
+		r=(focus_r>20.0)?20.0:focus_r;
+		s3d_translate(0,sin(al)*(r+5),0,cos(al)*(r+5));
+		s3d_rotate(0,0,alpha,0);
+		alpha=alpha+0.1;
+		if (alpha>360.0) alpha=0.0;
+	}
+	if (ego_mode)
+	{
+		if ((ydif!=0) || (xdif!=0))
+		{
+			campos.x+=ydif*sin((camrot.y*M_PI)/180);
+			campos.z+=ydif*cos((camrot.y*M_PI)/180);
+			campos.x+=xdif*cos((-camrot.y*M_PI)/180);
+			campos.z+=xdif*sin((-camrot.y*M_PI)/180);
+			campos.y+=ydif*sin((-camrot.x*M_PI)/180);
+			s3d_translate(	0,campos.x,campos.y,campos.z);
+		}
+	}
+	nanosleep(&t,NULL); 
+}
+
+void keydown(struct s3d_evt *event)
+{
+	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
+	switch (keys->keysym)
+	{
+		case S3DK_F1:  ego_mode=(ego_mode+1)%2;
+				 xdif=0;
+			     ydif=0;
+				 printf("ego mode %d\n",ego_mode);
+				 break;
+		case 'w':ydif+=-1.0;break;
+		case 'a':xdif+=-1.0;break;
+		case 's':ydif+= 1.0;break;
+		case 'd':xdif+= 1.0;break;
+	}
+}
+void keyup(struct s3d_evt *event)
+{
+	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
+	switch (keys->keysym)
+	{
+		case 'w':ydif-=-1.0;break;
+		case 'a':xdif-=-1.0;break;
+		case 's':ydif-= 1.0;break;
+		case 'd':xdif-= 1.0;break;
+	}
+
+}
+
+int main (int argc, char **argv)
+{
+	s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
+	s3d_set_callback(S3D_MCP_OBJECT,mcp_object);
+	s3d_set_callback(S3D_EVENT_QUIT,stop);
+	s3d_set_callback(S3D_MCP_DEL_OBJECT,mcp_del_object);
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
+	s3d_set_callback(S3D_EVENT_KEYDOWN,keydown);
+	s3d_set_callback(S3D_EVENT_KEYUP,keyup);
+
+	if (!s3d_init(&argc,&argv,"mcp"))	
+	{
+		greentorus(); /* just call ... */
+
+		if (s3d_select_font("vera"))
+		{
+			printf("font not found\n");
+		}
+		min_but=s3d_import_model_file("objs/btn_minimize.3ds");
+		rotate=s3d_import_model_file("objs/btn_rotate.3ds");
+		reset=s3d_import_model_file("objs/reset.3ds");
+		close_but=s3d_import_model_file("objs/btn_close.3ds");
+		sphere=s3d_import_model_file("objs/ringsystem.3ds");
+		menu=menu_init();
+		s3d_link(menu,0);
+		s3d_scale(menu,bsize);
+		place_apps();
+		s3d_mainloop(mainloop);
+		s3d_quit();
+	}
+	return(0);
+}

Modified: trunk/apps/dot_mcp/menu.c
===================================================================
--- trunk/apps/dot_mcp/menu.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/dot_mcp/menu.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,111 @@
+/*
+ * menu.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of dot_mcp, a mcp for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * dot_mcp is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * dot_mcp is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with dot_mcp; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+#include "s3d.h"
+#include "dot_mcp.h"
+#include <unistd.h> /* fork(), execl() */
+#include <stdio.h> /* printf() */
+#include <stdlib.h> /* exit() */
+#include <string.h> /* strlen(),strncpy(), strncat() */
+struct menu_entry {
+	char *icon, *name, *path;
+	int icon_oid, str_oid;
+};
+static int go=-1;
+static int act;
+static struct menu_entry menu[]={
+		{"objs/comp.model","terminal","s3dvt",				0,0},
+		{"objs/comp.model","olsrs3d","olsrs3d",				0,0},
+		{"objs/comp.model","s3d_x11gate","s3d_x11gate",		0,0},
+		{"objs/comp.model","filebrowser","filebrowser",		0,0}, 
+		{"objs/comp.model","logout","LOGOUT",					0,0}, 
+};
+void menu_click(int oid)
+{
+	unsigned int i;
+	char exec[256];
+	printf("%d got clicked\n",oid);
+	if (oid==go)
+	{
+		act=!act;
+		for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++)
+		{
+			if (act)
+			{
+				s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+				s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			} else {
+				s3d_flags_off(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+				s3d_flags_off(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			}
+
+		}
+		return;
+	}
+	if (act)
+	{
+		for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++)
+		{
+			if ((oid==menu[i].icon_oid) || (oid==menu[i].str_oid))
+			{
+				if (0==strncmp(menu[i].path,"LOGOUT",6))
+				{
+					s3d_quit();
+					return;
+				}
+				strncpy(exec,menu[i].path,256);
+				strncat(exec,"> /dev/null 2>&1 &",256); /* ignoring output, starting in background */
+				printf("executing [%s]\n",exec);
+				system(exec);
+				return;
+			}
+		}
+	}
+}
+int menu_init ()
+{
+	int i,menu_o;
+	menu_o=s3d_new_object();
+	act=0; /* menu deactived */
+	go=s3d_import_model_file("objs/s3dstart.3ds");
+	s3d_flags_on(go,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_link(go,menu_o);
+	for (i=0;i<(sizeof(menu)/sizeof(struct menu_entry));i++)
+	{
+		if (-1==(menu[i].icon_oid=s3d_import_model_file(menu[i].icon)))
+				menu[i].icon_oid=s3d_new_object();
+		menu[i].str_oid=s3d_draw_string(menu[i].name,NULL);
+		s3d_link(menu[i].str_oid,menu[i].icon_oid);
+		s3d_link(menu[i].icon_oid,menu_o);
+		s3d_translate(menu[i].icon_oid,0,-3+(-3*i),0);
+		s3d_translate(menu[i].str_oid,2,0,0);
+/*		s3d_flags_on(menu[i].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_on(menu[i].str_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);*/
+		printf("menu item menu[%d], icon_oid=%d, icon_str=%d\n",i,menu[i].icon_oid,menu[i].str_oid);
+	}
+	return(menu_o);
+}
+
+

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/olsrs3d/main.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,1102 @@
+/*
+ * main.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                         Marek Lindner <lindner_marek at yahoo.de>
+ *                         Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of olsrs3d, an olsr topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+#include <stdio.h>
+#include <s3d.h>
+#include <s3d_keysym.h>
+#include <s3dw.h>
+#include <time.h>	      /* nanosleep() */
+#include <string.h>	/* strncpy() */
+#include <math.h>		/* sqrt() */
+#include <getopt.h>	/* getopt() */
+#include <stdlib.h>	/* exit() */
+#include "olsrs3d.h"
+#include "search.h"
+
+#define SPEED		10.0
+
+static struct timespec sleep_time = { 0, 100 * 1000 * 1000 };   /* 100 mili seconds */
+
+int Debug = 0;
+
+char Olsr_host[256];   /* ip or hostname of olsr node with running dot_draw plugin */
+
+struct olsr_con *Con_begin = NULL;   /* begin of connection list */
+struct olsr_node *Olsr_root = NULL;   /* top of olsr node tree */
+struct Obj_to_ip *Obj_to_ip_head, *Obj_to_ip_end, *List_ptr;   /* needed pointer for linked list */
+
+int Olsr_node_count = 0, Last_olsr_node_count = -1;
+int Olsr_node_count_obj = -1;
+int Olsr_ip_label_obj = -1;
+int Output_border[4];
+int *Olsr_neighbour_label_obj = NULL;
+int Size;
+
+
+int Net_read_count;
+int Output_block_counter = 0;
+int Output_block_completed = 0;
+
+int Olsr_node_obj, Olsr_node_inet_obj, Olsr_node_hna_net;
+
+float Asp = 1.0;
+float Bottom = -1.0;
+float Left = -1.0;
+
+float CamPosition[2][3];	/* CamPosition[trans|rot][x-z] */
+float CamPosition2[2][3];	/* CamPosition[trans|rot][x-z] */
+
+/* needed ? */
+/* float ZeroPosition[3] = {0,0,0};	 current position zero position */
+
+int ZeroPoint;   /* object zeropoint */
+float Zp_rotate = 0.0;
+int ColorSwitch = 0;   /* enable/disable colored olsr connections */
+int RotateSwitch = 0;
+float RotateSpeed = 0.5;
+float Factor = 0.6;	/* Factor in calc_olsr_node_mov */
+struct olsr_node *Olsr_node_pEtx;
+
+int Btn_close_id = -1;
+
+int Btn_close_obj;
+float Title_len;
+
+/***
+ *
+ * print usage info
+ *
+ ***/
+
+void print_usage( void ) {
+
+	printf( "Usage is olsrs3d [options] [-- [s3d options]]\n" );
+	printf( "olsrs3d options:\n" );
+	printf( "   -h\tprint this short help\n" );
+	printf( "   -d\tenable debug mode\n" );
+	printf( "   -H\tconnect to olsr node [default: localhost]\n" );
+	s3d_usage();
+
+}
+
+
+
+/***
+ *
+ * print error and exit
+ *
+ ***/
+
+void out_of_mem( void ) {
+
+	printf( "Sorry - you ran out of memory !\n" );
+	exit(8);
+
+}
+
+
+
+/***
+ *
+ * calculate distance between 2 vectors => http://en.wikipedia.org/wiki/Euclidean_distance
+ *
+ *   p1   =>   vector of node 1
+ *   p2   =>   vector of node 2
+ *
+ *   return distance
+ *
+ ***/
+
+float dist(float p1[], float p2[])
+{
+	float p[3];
+	p[0]=p1[0]-p2[0];
+	p[1]=p1[1]-p2[1];
+	p[2]=p1[2]-p2[2];
+	return (sqrt(p[0]*p[0]   +  p[1]*p[1]  +  p[2]*p[2]));
+
+}
+
+
+
+/***
+ *
+ * calculate distance between 2 vectors and substract vector1 from vector2
+ *  => http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction
+ *
+ *   p1   =>   vector of node 1
+ *   p2   =>   vector of node 2
+ *
+ *   return distance
+ *
+ ***/
+
+float dirt(float p1[], float p2[], float p3[])
+{
+	float d;
+	d=dist(p1,p2);
+	if (d!=0.0)
+	{
+		p3[0]=p2[0]-p1[0];
+		p3[1]=p2[1]-p1[1];
+		p3[2]=p2[2]-p1[2];
+	} else {
+		p3[0]=p2[0]=p1[0]=0.0;
+	}
+	return(d);
+}
+
+
+
+/***
+ *
+ * calculate new movement of node by adding the product of the factor and the vector to the movement vector
+ *  => http://en.wikipedia.org/wiki/Vector_%28spatial%29#Scalar_multiplication
+ *
+ *   mov  =>   current mov vector
+ *   p    =>   vector of node
+ *   fac  =>   factor which is
+ *
+ ***/
+
+void mov_add(float mov[], float p[], float fac)
+{
+/*	if (fac>1000)
+		return;
+	fac=1000; */
+	mov[0]+=fac*p[0];
+	mov[1]+=fac*p[1];
+	mov[2]+=fac*p[2];
+}
+
+
+
+/***
+ *
+ * check whether is a new / modified / vanished node and handle it accordingly
+ *
+ *   *olsr_node =>   pointer to current olsr_node
+ *
+ ***/
+
+void handle_olsr_node( struct olsr_node *olsr_node ) {
+
+	float distance, angle, angle_rad;
+	float tmp_mov_vec[3], desc_norm_vec[3] = {0,0,-1};
+	struct olsr_node *other_node;
+	struct Obj_to_ip *Obj_to_ip_curr;
+	struct olsr_neigh_list *olsr_neigh_list, *prev_olsr_neigh_list, *other_node_neigh_list, *tmp_olsr_neigh_list;
+
+	/* no more nodes left */
+	if ( olsr_node == NULL ) return;
+
+	/* olsr node vanished */
+	if ( ( olsr_node->last_seen < Output_block_counter - 1 ) && ( olsr_node->visible ) ) {
+
+		if ( Debug ) printf( "olsr node vanished: %s\n", olsr_node->ip );
+
+		Olsr_node_count--;
+
+		olsr_node->visible = 0;
+
+		/* delete shape */
+		if ( olsr_node->obj_id != -1 ) {
+
+			/* remove element from ob2ip list */
+			lst_del( olsr_node->obj_id );
+			/* remove object from s3d server */
+			s3d_del_object( olsr_node->obj_id );
+
+			olsr_node->obj_id = -1;
+
+		}
+
+		if ( olsr_node->desc_id != -1 ) {
+
+			s3d_del_object( olsr_node->desc_id );
+			olsr_node->desc_id = -1;
+
+		}
+
+		/* delete olsr connections of this node */
+		olsr_neigh_list = olsr_node->olsr_neigh_list;
+
+		while ( olsr_neigh_list != NULL ) {
+
+			/* get connection list of 'other' node */
+			if ( olsr_neigh_list->olsr_con->left_olsr_node == olsr_node ) {
+				other_node = olsr_neigh_list->olsr_con->right_olsr_node;
+			} else {
+				other_node = olsr_neigh_list->olsr_con->left_olsr_node;
+			}
+
+			/* find this connection in 'other' nodes connection list ... */
+			prev_olsr_neigh_list = NULL;
+			other_node_neigh_list = other_node->olsr_neigh_list;
+
+			while ( other_node_neigh_list != NULL ) {
+
+				if ( other_node_neigh_list->olsr_con == olsr_neigh_list->olsr_con ) {
+
+					/* and delete it ! */
+					if ( prev_olsr_neigh_list != NULL ) {
+						/* is first, any or last element in the list */
+						prev_olsr_neigh_list->next_olsr_neigh_list = other_node_neigh_list->next_olsr_neigh_list;
+					} else {
+						/* the only element in the list */
+						other_node->olsr_neigh_list = NULL;
+					}
+
+					free( other_node_neigh_list );
+
+					break;
+
+				}
+
+				prev_olsr_neigh_list = other_node_neigh_list;
+				other_node_neigh_list = other_node_neigh_list->next_olsr_neigh_list;
+
+			}
+
+			s3d_del_object( olsr_neigh_list->olsr_con->obj_id );
+
+			/* delete connection */
+			if ( olsr_neigh_list->olsr_con->prev_olsr_con != NULL ) olsr_neigh_list->olsr_con->prev_olsr_con->next_olsr_con = olsr_neigh_list->olsr_con->next_olsr_con;
+			if ( olsr_neigh_list->olsr_con->next_olsr_con != NULL ) olsr_neigh_list->olsr_con->next_olsr_con->prev_olsr_con = olsr_neigh_list->olsr_con->prev_olsr_con;
+
+			tmp_olsr_neigh_list = olsr_neigh_list;
+
+			olsr_neigh_list = olsr_neigh_list->next_olsr_neigh_list;
+
+			free( tmp_olsr_neigh_list->olsr_con );
+			free( tmp_olsr_neigh_list );
+
+		}
+
+		olsr_node->olsr_neigh_list = NULL;
+
+	} else if ( olsr_node->visible ) {
+
+		/* olsr node shape has been modified */
+		if ( olsr_node->node_type_modified ) {
+
+			/* delete old shape */
+			if ( olsr_node->obj_id != -1 ) {
+				/* remove element from ob2ip list */
+				lst_del( olsr_node->obj_id );
+				s3d_del_object( olsr_node->obj_id );
+			}
+
+			if ( olsr_node->desc_id != -1 ) s3d_del_object( olsr_node->desc_id );
+
+			/* create new shape */
+			if ( olsr_node->node_type == 1 ) {
+				/* olsr node offers internet access */
+				olsr_node->obj_id = s3d_clone( Olsr_node_inet_obj );
+			} else if ( olsr_node->node_type == 2 ) {
+				/* via hna announced network */
+				olsr_node->obj_id = s3d_clone( Olsr_node_hna_net );
+			} else {
+				/* normal olsr node */
+				olsr_node->obj_id = s3d_clone( Olsr_node_obj );
+			}
+
+			s3d_flags_on( olsr_node->obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+
+			/* link newly created object to ZeroPoint */
+			s3d_link( olsr_node->obj_id, ZeroPoint );
+			/* add object_id and olsr_node to linked list */
+			lst_add(olsr_node->obj_id,&olsr_node);
+
+			/* create olsr node text and attach (link) it to the node */
+			olsr_node->desc_id = s3d_draw_string( olsr_node->ip, &olsr_node->desc_length );
+			s3d_link( olsr_node->desc_id, olsr_node->obj_id );
+			s3d_translate( olsr_node->desc_id, - olsr_node->desc_length / 2, -2, 0 );
+			s3d_flags_on( olsr_node->desc_id, S3D_OF_VISIBLE );
+
+			olsr_node->node_type_modified = 0;
+
+		}
+
+
+		/* rotate node description so that they are always readable */
+		tmp_mov_vec[0] = CamPosition2[0][0] - olsr_node->pos_vec[0];
+		tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
+		tmp_mov_vec[2] = CamPosition2[0][2] - olsr_node->pos_vec[2];
+
+		angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
+
+		/* take care of inverse cosinus */
+		if ( tmp_mov_vec[0] > 0 ) {
+			angle_rad = 90.0/M_PI - angle;
+			angle = 180 - ( 180.0/M_PI * angle );
+		} else {
+			angle_rad = 90.0/M_PI + angle;
+			angle = 180 + ( 180.0/M_PI * angle );
+		}
+
+		s3d_rotate( olsr_node->desc_id, 0, angle , 0 );
+		s3d_translate( olsr_node->desc_id, -cos(angle_rad)*olsr_node->desc_length/2 ,-1.5, sin(angle_rad)*olsr_node->desc_length/2 );
+
+
+		/* drift away from unrelated nodes */
+		Obj_to_ip_curr = Obj_to_ip_head->next;
+		while ( Obj_to_ip_curr != Obj_to_ip_end ) {
+
+			/* myself ... */
+			if ( olsr_node != Obj_to_ip_curr->olsr_node ) {
+
+				olsr_neigh_list = olsr_node->olsr_neigh_list;
+				while ( olsr_neigh_list != NULL ) {
+
+					/* nodes are related */
+					if ( ( olsr_neigh_list->olsr_con->left_olsr_node->visible == 1 ) && ( olsr_neigh_list->olsr_con->right_olsr_node->visible == 1 ) ) {
+
+						if ( ( olsr_neigh_list->olsr_con->left_olsr_node == Obj_to_ip_curr->olsr_node ) || (  olsr_neigh_list->olsr_con->right_olsr_node == Obj_to_ip_curr->olsr_node ) ) break;
+
+					}
+
+					olsr_neigh_list = olsr_neigh_list->next_olsr_neigh_list;
+
+				}
+
+				/* nodes are not related - so drift */
+				if ( olsr_neigh_list == NULL ) {
+
+					distance = dirt( olsr_node->pos_vec, Obj_to_ip_curr->olsr_node->pos_vec, tmp_mov_vec );
+					if ( distance < 0.1 ) distance = 0.1;
+					mov_add( olsr_node->mov_vec, tmp_mov_vec,-100 / ( distance * distance ) );
+					mov_add( Obj_to_ip_curr->olsr_node->mov_vec, tmp_mov_vec, 100 / ( distance * distance ) );
+
+				}
+
+			}
+
+			Obj_to_ip_curr = Obj_to_ip_curr->next;
+
+		}
+
+	}
+
+	handle_olsr_node( olsr_node->left );
+	handle_olsr_node( olsr_node->right );
+
+}
+
+
+
+/***
+ *
+ * calculate movement vector of all olsr nodes
+ *
+ ***/
+
+void calc_olsr_node_mov( void ) {
+
+	float distance;
+	float tmp_mov_vec[3];
+	float f;
+	struct olsr_con *olsr_con = Con_begin;
+
+	while ( olsr_con != NULL ) {
+
+		distance = dirt( olsr_con->left_olsr_node->pos_vec, olsr_con->right_olsr_node->pos_vec, tmp_mov_vec );
+		f = ( ( olsr_con->left_etx_sqrt + olsr_con->left_etx_sqrt ) / 4.0 ) / distance;
+
+		/***
+		 * drift factor - 0.0 < factor < 1.0 ( best results: 0.3 < factor < 0.9
+		 * small factor: fast and strong drift to neighbours
+		 ***/
+		if ( f < Factor ) f = Factor;
+
+		mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, 1 / f - 1 );
+		mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, - ( 1 / f - 1 ) );
+
+		olsr_con = olsr_con->next_olsr_con;
+
+	}
+
+}
+
+
+
+/***
+ *
+ * move all olsr nodes and their connections
+ *
+ ***/
+
+void move_olsr_nodes( void ) {
+
+	float null_vec[3] = {0,0,0}, vertex_buf[6];
+	float tmp_mov_vec[3];
+	float distance, etx, rgb;
+	struct olsr_con *olsr_con = Con_begin;
+
+	while ( olsr_con != NULL ) {
+
+		/* move left olsr node if it has not been moved yet */
+		if ( !( ( olsr_con->left_olsr_node->mov_vec[0] == 0 ) && ( olsr_con->left_olsr_node->mov_vec[1] == 0 ) && ( olsr_con->left_olsr_node->mov_vec[2] == 0 ) ) && olsr_con->left_olsr_node->visible ) {
+
+			distance = dirt( olsr_con->left_olsr_node->pos_vec, null_vec, tmp_mov_vec );
+			mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, distance / 100 ); /* move a little bit to point zero */
+			mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, 1 ); /* move a little bit to point zero */
+
+			if ( ( distance = dist( olsr_con->left_olsr_node->mov_vec, null_vec ) ) > 10.0 ) {
+				mov_add( olsr_con->left_olsr_node->pos_vec, olsr_con->left_olsr_node->mov_vec, 1.0 / ( ( float ) distance ) );
+			} else {
+				mov_add( olsr_con->left_olsr_node->pos_vec, olsr_con->left_olsr_node->mov_vec, 0.1 );
+			}
+
+			s3d_translate( olsr_con->left_olsr_node->obj_id, olsr_con->left_olsr_node->pos_vec[0], olsr_con->left_olsr_node->pos_vec[1], olsr_con->left_olsr_node->pos_vec[2] );
+
+			/* reset movement vector */
+			olsr_con->left_olsr_node->mov_vec[0] = olsr_con->left_olsr_node->mov_vec[1] = olsr_con->left_olsr_node->mov_vec[2] = 0.0;
+
+		}
+
+		/* move right olsr node if it has not been moved yet */
+		if ( !( ( olsr_con->right_olsr_node->mov_vec[0] == 0 ) && ( olsr_con->right_olsr_node->mov_vec[1] == 0 ) && ( olsr_con->right_olsr_node->mov_vec[2] == 0 ) ) && olsr_con->right_olsr_node->visible ) {
+
+			distance = dirt( olsr_con->right_olsr_node->pos_vec, null_vec, tmp_mov_vec );
+			mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, distance / 100 ); /* move a little bit to point zero */
+			mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, 1 ); /* move a little bit to point zero */
+
+			if ( ( distance = dist( olsr_con->right_olsr_node->mov_vec, null_vec ) ) > 10.0 ) {
+				mov_add( olsr_con->right_olsr_node->pos_vec, olsr_con->right_olsr_node->mov_vec, 1.0 / ( ( float ) distance ) );
+			} else {
+				mov_add( olsr_con->right_olsr_node->pos_vec, olsr_con->right_olsr_node->mov_vec, 0.1 );
+			}
+
+			s3d_translate( olsr_con->right_olsr_node->obj_id, olsr_con->right_olsr_node->pos_vec[0], olsr_con->right_olsr_node->pos_vec[1], olsr_con->right_olsr_node->pos_vec[2] );
+
+			/* reset movement vector */
+			olsr_con->right_olsr_node->mov_vec[0] = olsr_con->right_olsr_node->mov_vec[1] = olsr_con->right_olsr_node->mov_vec[2] = 0.0;
+
+		}
+
+
+		/* move connection between left and right olsr node */
+		vertex_buf[0] = olsr_con->left_olsr_node->pos_vec[0];
+		vertex_buf[1] = olsr_con->left_olsr_node->pos_vec[1];
+		vertex_buf[2] = olsr_con->left_olsr_node->pos_vec[2];
+		vertex_buf[3] = olsr_con->right_olsr_node->pos_vec[0];
+		vertex_buf[4] = olsr_con->right_olsr_node->pos_vec[1];
+		vertex_buf[5] = olsr_con->right_olsr_node->pos_vec[2];
+
+		s3d_pep_vertices( olsr_con->obj_id, vertex_buf, 2 );
+
+
+		if ( ColorSwitch ) {
+
+			/* HNA */
+			if ( olsr_con->left_etx == -1000.00 ) {
+
+				if(olsr_con->color != 1) {
+					s3d_pep_material( olsr_con->obj_id,
+								   0.0,0.0,1.0,
+								   0.0,0.0,1.0,
+								   0.0,0.0,1.0);
+					olsr_con->color = 1;
+				}
+
+			} else {
+
+				etx = ( olsr_con->left_etx + olsr_con->right_etx ) / 2.0;
+
+				/* very good link - bright blue */
+				if ( ( etx >= 1.0 ) && ( etx < 1.5 ) ) {
+
+					if(olsr_con->color != 2) {
+						s3d_pep_material( olsr_con->obj_id,
+								0.5,1.0,1.0,
+								0.5,1.0,1.0,
+								0.5,1.0,1.0);
+						olsr_con->color = 2;
+					}
+
+				/* good link - bright yellow */
+				} else if ( ( etx >= 1.5 ) && ( etx < 2.0 ) ) {
+
+					rgb = 2.0 - etx;
+					if( olsr_con->color != 3 || (olsr_con->color == 3 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
+						s3d_pep_material( olsr_con->obj_id,
+								1.0,1.0,rgb,
+								1.0,1.0,rgb,
+								1.0,1.0,rgb);
+						olsr_con->color = 3;
+
+						olsr_con->rgb =  rgb;
+					}
+
+				/* not so good link - orange */
+				} else if ( ( etx >= 2.0 ) && ( etx < 3.0 ) ) {
+
+					rgb = 1.5 - ( etx / 2.0 );
+					if( olsr_con->color != 4 || (olsr_con->color == 4 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
+						s3d_pep_material( olsr_con->obj_id,
+								1.0,rgb,0.0,
+								1.0,rgb,0.0,
+								1.0,rgb,0.0);
+						olsr_con->color = 4;
+
+						olsr_con->rgb = rgb;
+					}
+
+				/* bad link (almost dead) - brown */
+				} else if ( ( etx >= 3.0 ) && ( etx < 5.0 ) ) {
+
+					rgb = 1.75 - ( etx / 4.0 );
+
+					if( olsr_con->color != 5 || (olsr_con->color == 5 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
+
+						s3d_pep_material( olsr_con->obj_id,
+								rgb,rgb - 0.5,0.0,
+								rgb,rgb - 0.5,0.0,
+								rgb,rgb - 0.5,0.0);
+						olsr_con->color = 5;
+
+						olsr_con->rgb = rgb;
+					}
+
+				/* zombie link - grey */
+				} else if ( ( etx >= 5.0 ) && ( etx < 1000.0 ) ) {
+
+					rgb = 1000.0 / ( 1500.0 + etx );
+
+					if( olsr_con->color != 6 || (olsr_con->color == 6 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
+
+						s3d_pep_material( olsr_con->obj_id,
+								rgb,rgb,rgb,
+								rgb,rgb,rgb,
+								rgb,rgb,rgb);
+						olsr_con->color = 6;
+
+						olsr_con->rgb = rgb;
+					}
+
+				/* wtf - dark grey */
+				} else {
+
+					if(olsr_con->color != 7) {
+						s3d_pep_material( olsr_con->obj_id,
+								0.3,0.3,0.3,
+								0.3,0.3,0.3,
+								0.3,0.3,0.3);
+						olsr_con->color = 7;
+					}
+
+				}
+
+			}
+
+		} else {
+
+			if(olsr_con->color != 0) {
+				s3d_pep_material( olsr_con->obj_id,
+							1.0,1.0,1.0,
+							1.0,1.0,1.0,
+							1.0,1.0,1.0);
+				olsr_con->color = 0;
+			}
+
+		}
+
+
+		olsr_con = olsr_con->next_olsr_con;
+
+	}
+
+}
+
+
+
+void mainloop() {
+
+	int net_result;   /* result of function net_main */
+	char nc_str[20];
+	float strLen;
+	
+	/* calculate new movement vector */
+	calc_olsr_node_mov();
+
+	/* prepare nodes */
+	handle_olsr_node( Olsr_root );
+
+	/* move it */
+	move_olsr_nodes();
+
+	/* if we have more or less nodes now - redraw node count */
+	if ( Olsr_node_count != Last_olsr_node_count ) {
+
+		if ( Olsr_node_count_obj != -1 ) s3d_del_object( Olsr_node_count_obj );
+		snprintf( nc_str, 20, "node count: %d", Olsr_node_count );
+		Olsr_node_count_obj = s3d_draw_string( nc_str, &strLen );
+		s3d_link( Olsr_node_count_obj, 0 );
+		s3d_flags_on( Olsr_node_count_obj, S3D_OF_VISIBLE );
+		s3d_scale( Olsr_node_count_obj, 0.2 );
+		s3d_translate( Olsr_node_count_obj, -Left*3.0-(strLen * 0.2), -Bottom*3.0-0.5, -3.0 );
+		Last_olsr_node_count = Olsr_node_count;
+
+	}
+
+	if ( Output_block_completed ) {
+
+		Output_block_counter++;
+		Output_block_completed = 0;
+
+	}
+
+	/* read data from socket */
+	Net_read_count = 0;
+	while ( ( net_result = net_main() ) != 0 ) {
+		if ( net_result == -1 ) {
+			s3d_quit();
+			break;
+		}
+	}
+	
+	/* rotate modus */
+	if(RotateSwitch) {
+		Zp_rotate = ( Zp_rotate + RotateSpeed ) > 360 ? 0.0 : ( Zp_rotate + RotateSpeed );	
+		s3d_rotate(ZeroPoint,0,Zp_rotate,0);
+	}
+
+	/* calc for node description */
+	CamPosition2[0][0]=  CamPosition[0][0]*cos(Zp_rotate*M_PI/180.0) - CamPosition[0][2] * sin (Zp_rotate*M_PI/180.0);
+	CamPosition2[0][1]=  CamPosition[0][1];
+	CamPosition2[0][2]=  CamPosition[0][0]*sin(Zp_rotate*M_PI/180.0) + CamPosition[0][2] * cos (Zp_rotate*M_PI/180.0);
+
+	/* check search status */
+	if( get_search_status() == WIDGET )
+		move_to_search_widget( CamPosition[0], CamPosition[1] );
+	if( get_search_status() == FOLLOW )
+		follow_node( CamPosition[0], CamPosition[1], Zp_rotate );
+	if( get_search_status() == ABORT )
+		move_to_return_point( CamPosition[0], CamPosition[1] );
+	
+
+	if( Olsr_ip_label_obj != -1 )
+	{
+		print_etx();
+	}
+
+	nanosleep( &sleep_time, NULL );
+
+	return;
+
+}
+
+void stop() {
+
+	s3d_quit();
+	net_quit();
+
+}
+
+/***
+ *
+ * eventhandler when key pressed
+ *
+ ***/
+
+void keypress(struct s3d_evt *event) {
+
+	struct s3d_key_event *key=(struct s3d_key_event *)event->buf;
+	printf("%d\n",key->unicode);	
+	if( get_search_status() != WIDGET )
+	{
+		switch(key->unicode)
+		{
+			case S3DK_ESCAPE: /* abort action */
+			
+				set_search_status( get_search_status() == WIDGET ? ABORT : NOTHING );
+				break;
+				
+			case S3DK_s: /* move to search widget, give widget focus */
+
+				set_search_status(WIDGET);							/* set status for mainloop */
+				set_return_point(CamPosition[0],CamPosition[1]);	/* save the return position */
+				set_node_root( Olsr_root );
+				break;
+			
+			case S3DK_c: /* color on/off */
+				
+				ColorSwitch =  ColorSwitch ? 0 : 1;
+				break;
+				
+			case S3DK_r: /* rotate start/stop*/
+				
+				RotateSwitch = RotateSwitch ? 0 : 1;
+				break;
+				
+			case S3DK_PLUS: /* rotate speed increase */
+				
+				if(RotateSwitch && RotateSpeed < 5)
+				{
+					if(RotateSpeed >= 1.0)
+						RotateSpeed += 1.0;
+					else
+						RotateSpeed += 0.1;
+					printf("%f,\n",RotateSpeed);
+				}
+				break;
+				
+			case S3DK_MINUS: /* - -> rotate speed decrease */
+				
+				if(RotateSwitch)
+				{
+					if( RotateSpeed >= 2.0 )
+						RotateSpeed -= 1.0;
+					else {
+						if(RotateSpeed > 0.2)
+							RotateSpeed -= 0.1;
+					}
+					printf("%f,\n",RotateSpeed);
+				}
+				break;
+				
+			case 16: /* strg + p -> reset nodes ( zeroPoint to 0,0,0 ) */
+				
+				s3d_rotate(ZeroPoint, 0, 0, 0);
+				Zp_rotate = 0.0;
+				break;
+				
+			case S3DK_PAGEUP: /* change factor in calc_olsr_node_mov */
+				
+				if(Factor < 0.9)
+					Factor += 0.1;
+				break;
+				
+			case S3DK_PAGEDOWN: /* change factor in calc_olsr_node_mov */
+				
+				if(Factor > 0.3)
+					Factor -= 0.1;
+				break;
+				
+		}
+	} else {
+		if( (key->unicode >= S3DK_PERIOD && key->unicode <= S3DK_9) || key->unicode == S3DK_COMMA || key->unicode == S3DK_RETURN || key->unicode == S3DK_BACKSPACE )
+			search_widget_write( key->unicode );
+	}
+}
+
+/***
+ *
+ * eventhandler when object clicked
+ *
+ ***/
+
+void object_click(struct s3d_evt *evt)
+{
+	int oid,i;
+	char ip_str[50];
+
+	if( get_search_status() == WIDGET )
+	{
+		s3dw_handle_click(evt);	
+		return;
+	}
+	
+	oid=(int)*((unsigned long *)evt->buf);
+
+	if( oid == Btn_close_id )
+	{
+		s3d_del_object(Btn_close_id);
+		s3d_del_object(Olsr_ip_label_obj);
+		Btn_close_id = Olsr_ip_label_obj = -1;
+		for(i=0; i < Size; i++)
+			s3d_del_object( Olsr_neighbour_label_obj[i] );
+		free(Olsr_neighbour_label_obj);
+		Olsr_neighbour_label_obj = NULL;
+		for(i = 0; i < 4; i++)
+		{
+			if(Output_border[i] != -1)
+				s3d_del_object(Output_border[i]);
+			Output_border[i] = -1;
+		}
+		return;
+	}
+
+	Olsr_node_pEtx = *lst_search(oid);
+
+	if( Olsr_node_pEtx != NULL )
+	{
+		if( Btn_close_id == -1 )
+		{
+			Btn_close_id = s3d_clone( Btn_close_obj );
+			s3d_link(Btn_close_id,0);
+			s3d_flags_on(Btn_close_id,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_scale( Btn_close_id, 0.10 );
+			s3d_translate( Btn_close_id,-Left*3.0-0.150, -Bottom*3.0-0.9, -3.0 );
+		}
+		
+		if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
+		snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
+		Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
+		s3d_link( Olsr_ip_label_obj, 0 );
+		s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
+		s3d_scale( Olsr_ip_label_obj, 0.2 );
+		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.2, -3.0 );
+		/*
+		cam_go=1;
+		if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
+		snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
+		Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
+		s3d_link( Olsr_ip_label_obj, 0 );
+		s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
+		s3d_scale( Olsr_ip_label_obj, 0.2 );
+		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
+		*/
+	} 
+}
+
+void print_etx()
+{
+	struct olsr_neigh_list *tmpNeighbour;
+	float p = 1.4;
+	int i;
+	float len = 0.0, max_len=0.0;
+
+	if( Olsr_neighbour_label_obj != NULL )
+	{
+		/* int n = sizeof(Olsr_neighbour_label_obj) / sizeof(int);*/
+		for(i=0; i < Size; i++)
+			s3d_del_object( Olsr_neighbour_label_obj[i] );
+		free(Olsr_neighbour_label_obj);
+		Olsr_neighbour_label_obj = NULL;
+	}
+
+	tmpNeighbour = Olsr_node_pEtx->olsr_neigh_list;
+
+	Size = 0;
+	while(tmpNeighbour != NULL)
+	{
+		Size++;
+		tmpNeighbour = tmpNeighbour->next_olsr_neigh_list;
+	}
+
+	Olsr_neighbour_label_obj = malloc(Size*sizeof(int));
+	tmpNeighbour = Olsr_node_pEtx->olsr_neigh_list;
+
+	for(i = 0; i < Size ;i++)
+	{
+		char nIpStr[60];
+		float mEtx = ( tmpNeighbour->olsr_con->left_etx + tmpNeighbour->olsr_con->right_etx ) / 2;
+
+		if( mEtx != -1000 )
+			snprintf(nIpStr, 60, "%15s --> %.2f",(strcmp(Olsr_node_pEtx->ip,tmpNeighbour->olsr_con->right_olsr_node->ip)?tmpNeighbour->olsr_con->right_olsr_node->ip:tmpNeighbour->olsr_con->left_olsr_node->ip),mEtx);
+		else
+			snprintf(nIpStr, 60, "%15s --> HNA",(strcmp(Olsr_node_pEtx->ip,tmpNeighbour->olsr_con->right_olsr_node->ip)?tmpNeighbour->olsr_con->right_olsr_node->ip:tmpNeighbour->olsr_con->left_olsr_node->ip));
+
+		Olsr_neighbour_label_obj[i] = s3d_draw_string( nIpStr, &len );
+		s3d_link(Olsr_neighbour_label_obj[i], 0);
+		s3d_flags_on(Olsr_neighbour_label_obj[i], S3D_OF_VISIBLE );
+		s3d_scale(Olsr_neighbour_label_obj[i], 0.2 );
+		s3d_translate(Olsr_neighbour_label_obj[i], -Left*3.0-(len * 0.2)-0.15, -Bottom*3.0-p, -3.0 );
+		tmpNeighbour = tmpNeighbour->next_olsr_neigh_list;
+		p += 0.2;
+		max_len = (len > max_len - 0.2)?len+0.2:max_len;
+		max_len = (Title_len > max_len - 0.2)?len+0.2:max_len;
+		/* printf("title: %f len: %f maxlen: %f %s\n",Title_len,len,max_len-0.2,nIpStr);*/
+	}
+
+	if( Btn_close_id != -1)
+	{
+		if( Output_border[0] == -1 )
+		{
+			for(i = 0; i < 4; i++)
+			{
+				Output_border[i] = s3d_new_object();
+				s3d_push_material( Output_border[i],
+					1.0,1.0,1.0,
+					1.0,1.0,1.0,
+					1.0,1.0,1.0);
+			}
+			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,			-Bottom*3.0-0.9, -3.0);
+			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
+
+			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-1.0, -3.0);
+			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
+
+			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
+			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
+
+			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
+			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
+
+			s3d_push_line( Output_border[0], 0,1,0);
+			s3d_push_line( Output_border[1], 0,1,0);
+			s3d_push_line( Output_border[2], 0,1,0);
+			s3d_push_line( Output_border[3], 0,1,0);
+
+			s3d_flags_on( Output_border[0], S3D_OF_VISIBLE);
+			s3d_flags_on( Output_border[1], S3D_OF_VISIBLE);
+			s3d_flags_on( Output_border[2], S3D_OF_VISIBLE);
+			s3d_flags_on( Output_border[3], S3D_OF_VISIBLE);
+
+			s3d_link( Output_border[0], 0);
+			s3d_link( Output_border[1], 0);
+			s3d_link( Output_border[2], 0);
+			s3d_link( Output_border[3], 0);
+		} else {
+			s3d_pop_vertex(Output_border[0], 2);
+			s3d_pop_vertex(Output_border[1], 2);
+			s3d_pop_vertex(Output_border[2], 2);
+			s3d_pop_vertex(Output_border[3], 2);
+			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,				-Bottom*3.0-0.9, -3.0);
+			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
+
+			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-1.0, -3.0);
+			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
+
+			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
+			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p,	 -3.0);
+
+			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
+			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	 -3.0);
+		}
+	}
+}
+
+
+
+/***
+ *
+ * eventhandler when object change by user
+ * such as Cam
+ *
+ ***/
+
+void object_info(struct s3d_evt *hrmz)
+{
+	struct s3d_obj_info *inf;
+	inf=(struct s3d_obj_info *)hrmz->buf;
+	if (inf->object==0)
+	{
+		CamPosition[0][0] = inf->trans_x;
+		CamPosition[0][1] = inf->trans_y;
+		CamPosition[0][2] = inf->trans_z;
+		CamPosition[1][0] = inf->rot_x;
+		CamPosition[1][1] = inf->rot_y;
+		CamPosition[1][2] = inf->rot_z;
+		Asp=inf->scale;
+		if (Asp>1.0) /* wide screen */
+		{
+			Bottom=-1.0;
+			Left=-Asp;
+		} else {  /* high screen */
+			Bottom=(-1.0/Asp);
+			Left=-1.0;
+
+		}
+
+	}
+	/* printf("%f %f %f\n",inf->trans_x,inf->trans_y,inf->trans_z); */
+}
+
+void mbutton_press(struct s3d_evt *hrmz)
+{
+	struct s3d_but_info *inf;
+	inf=(struct s3d_but_info *)hrmz->buf;
+	printf("button %d, state %d\n", inf->button,inf->state);
+	return;
+}
+
+int main( int argc, char *argv[] ) {
+
+	int optchar;
+	strncpy( Olsr_host, "127.0.0.1", 256 );
+	lbuf[0] = '\0';   /* init lbuf */
+
+	while ( ( optchar = getopt ( argc, argv, "dhH:" ) ) != -1 ) {
+
+		switch ( optchar ) {
+
+			case 'd':
+				Debug = 1;
+				break;
+
+			case 'H':
+				strncpy( Olsr_host, optarg, 256 );
+				break;
+
+			case 'h':
+			default:
+				print_usage();
+				return (0);
+
+		}
+
+	}
+
+	if ( Debug ) printf( "debug mode enabled ...\n" );
+
+	/* initialize obj2ip linked list */
+	lst_initialize();
+
+	/* delete olsrs3d options */
+	while ( ( optind < argc ) && ( argv[optind][0] != '-' ) ) optind++;   /* optind may point to ip addr of '-H' */
+	optind--;
+	argv[optind] = argv[0];   /* save program path */
+	argc -= optind;   /* jump over olsrs3d options */
+	argv += optind;
+
+	/* set extern int optind = 0 for parse_args in io.c */
+	optind = 0;
+
+
+	if (!net_init(Olsr_host))
+	{
+		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
+		s3d_set_callback(S3D_EVENT_KEY,keypress);
+		s3d_set_callback(S3D_EVENT_QUIT,stop);
+
+		if (!s3d_init(&argc,&argv,"olsrs3d"))
+		{
+
+			if (s3d_select_font("vera"))
+				printf("font not found\n");
+
+			Olsr_node_obj = s3d_import_model_file( "objs/accesspoint.3ds" );
+			Olsr_node_inet_obj = s3d_import_model_file( "objs/accesspoint_inet.3ds" );
+			Olsr_node_hna_net = s3d_import_model_file( "objs/internet.3ds" );
+			Btn_close_obj = s3d_import_model_file( "objs/btn_close.3ds" );
+			create_search_widget( 0, 0, 300 );			
+			
+			ZeroPoint = s3d_new_object();
+			Output_border[0] = Output_border[1] = Output_border[2] = Output_border[3] = -1;
+			
+			s3d_mainloop(mainloop);
+			s3d_quit();
+			net_quit();
+		}
+	}
+	return(0);
+}
+

Modified: trunk/apps/olsrs3d/net.c
===================================================================
--- trunk/apps/olsrs3d/net.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/olsrs3d/net.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,129 @@
+/*
+ * net.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                         Marek Lindner <lindner_marek at yahoo.de>
+ *                         Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of olsrs3d, an olsr topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>	/* close() */
+#include <errno.h>
+#include <string.h> 	/* strlen(), memmove(), strncpy(), strncat() */
+#include <netdb.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <fcntl.h>		/* fnctl() */
+#include "olsrs3d.h"
+
+#define PORT 2004 		/* the port client will be connecting to  */
+char buf[MAXDATASIZE];
+
+
+int sockfd, numbytes;
+int net_init(char *host)
+{
+    struct hostent *he;
+    struct sockaddr_in their_addr; /* connector's address information  */
+
+    if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
+        herror("gethostbyname");
+        return(1);
+    }
+
+    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
+        perror("socket");
+        return(1);
+    }
+
+    their_addr.sin_family = AF_INET;    /* host byte order  */
+    their_addr.sin_port = htons(PORT);  /* short, network byte order  */
+    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
+    memset(&(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
+
+    if (connect(sockfd, (struct sockaddr *)&their_addr,
+                                          sizeof(struct sockaddr)) == -1) {
+        perror("connect");
+        return(1);
+    }
+	fcntl(sockfd,F_SETFL, O_NONBLOCK);
+	return(0);
+}
+
+int net_main() {
+
+	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
+		if (errno==EAGAIN)
+			return(0); /* well, that's okay ... */
+		perror("recv");
+		return(-1);
+	}
+
+	if (numbytes==0) {
+		printf("connection reset\n");
+		return(-1);
+	}
+
+	buf[numbytes] = '\0';
+
+	/* check for potential buffer overflow */
+	if ( ( strlen( lbuf ) + strlen( buf ) ) < MAXLINESIZE ) {
+
+		strncat( lbuf, buf, MAXLINESIZE );
+
+	} else {
+
+		/* hope that carriage return is now in buf */
+		if ( strlen( lbuf ) < MAXLINESIZE ) {
+
+			if ( Debug ) printf( "WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n" );
+			strncat( lbuf, buf, MAXLINESIZE - strlen( lbuf ) );
+
+		} else {
+
+			if ( Debug ) printf( "ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n" );
+			strncpy( lbuf, buf, MAXLINESIZE );
+
+		}
+
+	}
+
+	process_main();
+
+	if ( ++Net_read_count > 5 ) {
+		return(0);   /* continue mainloop */
+	} else {
+		return(1);   /* continue reading data from socket */
+	}
+
+}
+
+int net_quit()
+{
+    close(sockfd);
+
+    return 0;
+}
+
+

Modified: trunk/apps/olsrs3d/process.c
===================================================================
--- trunk/apps/olsrs3d/process.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/olsrs3d/process.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,517 @@
+/*
+ * process.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                         Marek Lindner <lindner_marek at yahoo.de>
+ *                         Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of olsrs3d, an olsr topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+#include <stdio.h> 	/* NULL */
+#include <string.h> 	/* strlen(), memmove() */
+#include <stdlib.h> 	/* rand(), malloc(), realloc(), free() */
+#include <s3d.h>
+#include <math.h>       /* sqrt() */
+#include "olsrs3d.h"
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+
+char lbuf[MAXLINESIZE];
+
+
+
+/***
+ *
+ * create new or alter connection between 2 nodes
+ *
+ *   con_from =>   current node
+ *   con_to   =>   node to connect to
+ *   etx      =>   ETX
+ *
+ ***/
+
+int add_olsr_con( struct olsr_node *con_from, struct olsr_node *con_to, float etx ) {
+
+	struct olsr_con **olsr_con = &Con_begin;
+	struct olsr_con *prev_olsr_con = NULL;   /* previous olsr connection */
+	struct olsr_neigh_list **olsr_neigh_list;
+
+	while ( (*olsr_con) != NULL ) {
+
+		/* connection already exists */
+		if ( ( strncmp( (*olsr_con)->left_olsr_node->ip, con_from->ip, NAMEMAX ) == 0 ) && ( strncmp( (*olsr_con)->right_olsr_node->ip, con_to->ip, NAMEMAX ) == 0 ) ) {
+			(*olsr_con)->left_etx = etx;
+			(*olsr_con)->left_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
+			break;
+
+		} else if ( ( strncmp( (*olsr_con)->right_olsr_node->ip, con_from->ip, NAMEMAX ) == 0 ) && ( strncmp( (*olsr_con)->left_olsr_node->ip, con_to->ip, NAMEMAX ) == 0 ) ) {
+
+			(*olsr_con)->right_etx = etx;
+			(*olsr_con)->right_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
+			break;
+
+		}
+
+		/* save previous olsr connection for later use */
+		prev_olsr_con = (*olsr_con);
+
+		olsr_con = &(*olsr_con)->next_olsr_con;
+
+	}
+
+	/* new connection */
+	if ( (*olsr_con) == NULL ) {
+
+		(*olsr_con) = malloc( sizeof( struct olsr_con ) );
+		if ( (*olsr_con) == NULL ) out_of_mem();
+
+		/* create connection object */
+		(*olsr_con)->obj_id = s3d_new_object();
+
+		/* add olsr node to new olsr connection in order to access the nodes from the connection list */
+		(*olsr_con)->left_olsr_node = con_from;
+		(*olsr_con)->right_olsr_node = con_to;
+
+		/* add connection color */
+		(*olsr_con)->color = 0;
+		s3d_push_material( (*olsr_con)->obj_id,
+				  1.0,1.0,1.0,
+				  1.0,1.0,1.0,
+				  1.0,1.0,1.0);
+
+		/* add connection endpoints */
+		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->left_olsr_node->pos_vec[0], (*olsr_con)->left_olsr_node->pos_vec[1], (*olsr_con)->left_olsr_node->pos_vec[2] );
+		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->right_olsr_node->pos_vec[0], (*olsr_con)->right_olsr_node->pos_vec[1], (*olsr_con)->right_olsr_node->pos_vec[2] );
+
+		s3d_push_line( (*olsr_con)->obj_id, 0,1,0 );
+
+		s3d_flags_on( (*olsr_con)->obj_id, S3D_OF_VISIBLE );
+
+		s3d_link( (*olsr_con)->obj_id,  ZeroPoint );
+
+		/* HNA */
+		if ( etx == -1000.00 ) {
+
+			(*olsr_con)->left_etx = etx;
+			(*olsr_con)->left_etx_sqrt = 10.0;
+			(*olsr_con)->right_etx = etx;
+			(*olsr_con)->right_etx_sqrt = 10.0;
+
+		} else {
+
+			(*olsr_con)->left_etx = etx;
+			(*olsr_con)->left_etx_sqrt = sqrt( etx );
+			(*olsr_con)->right_etx = 999.0;
+			(*olsr_con)->right_etx_sqrt = sqrt( 999.0 );
+
+		}
+
+		(*olsr_con)->next_olsr_con = NULL;
+		(*olsr_con)->prev_olsr_con = prev_olsr_con;
+
+		/* add new olsr connection to olsr nodes in order to access the connection from the olsr node */
+		olsr_neigh_list = &(*olsr_con)->left_olsr_node->olsr_neigh_list;
+		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
+		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
+		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
+		(*olsr_neigh_list)->olsr_con = (*olsr_con);
+		(*olsr_neigh_list)->next_olsr_neigh_list = NULL;
+
+		olsr_neigh_list = &(*olsr_con)->right_olsr_node->olsr_neigh_list;
+		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
+		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
+		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
+		(*olsr_neigh_list)->olsr_con = (*olsr_con);
+		(*olsr_neigh_list)->next_olsr_neigh_list = NULL;
+
+	}
+
+	return(0);
+
+}
+
+
+
+/***
+ *
+ * get pointer to olsr node or create new node if node string could not be found
+ *
+ *   **node =>   pointer to current olsr_node
+ *   *ip    =>   node ip
+ *
+ *   return olsr node pointer
+ *
+ ***/
+
+void *get_olsr_node( struct olsr_node **olsr_node, char *ip ) {
+
+	int result;   /* result of strcmp */
+
+	while ( (*olsr_node) != NULL ) {
+
+		result = strncmp( (*olsr_node)->ip, ip, NAMEMAX );
+
+		/* we found the node */
+		if ( result == 0 ) {
+
+			(*olsr_node)->last_seen = Output_block_counter;
+
+			/* former invisble (deleted) node */
+			if ( (*olsr_node)->visible == 0 ) {
+
+				(*olsr_node)->node_type = 0;
+				(*olsr_node)->node_type_modified = 1;
+
+				(*olsr_node)->visible = 1;
+
+				(*olsr_node)->mov_vec[0] = (*olsr_node)->mov_vec[1] = (*olsr_node)->mov_vec[2] = 0.0;
+
+				if ( Debug ) printf( "new olsr node: %s\n", (*olsr_node)->ip );
+
+				Olsr_node_count++;
+
+			}
+
+			return (*olsr_node);
+
+		}
+
+		/* the searched node must be in the subtree */
+		if ( result < 0 ) {
+			olsr_node = &(*olsr_node)->right;
+		} else {
+			olsr_node = &(*olsr_node)->left;
+		}
+
+	}
+
+	/* if node is NULL we reached the end of the tree and must create a new olsr_node */
+	if ( (*olsr_node) == NULL ) {
+
+		(*olsr_node) = malloc( sizeof( struct olsr_node ) );
+		if ( (*olsr_node) == NULL ) out_of_mem();
+
+		(*olsr_node)->left = NULL;
+		(*olsr_node)->right = NULL;
+
+		strncpy( (*olsr_node)->ip, ip, NAMEMAX );
+
+		(*olsr_node)->node_type = 0;
+		(*olsr_node)->node_type_modified = 1;
+
+		(*olsr_node)->last_seen = Output_block_counter;
+		(*olsr_node)->visible = 1;
+
+		if ( Debug ) printf( "new olsr node: %s\n", (*olsr_node)->ip );
+
+		Olsr_node_count++;
+
+		(*olsr_node)->pos_vec[0] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+		(*olsr_node)->pos_vec[1] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+		(*olsr_node)->pos_vec[2] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+		(*olsr_node)->mov_vec[0] = (*olsr_node)->mov_vec[1] = (*olsr_node)->mov_vec[2] = 0.0;
+
+		(*olsr_node)->obj_id = -1;
+		(*olsr_node)->desc_id = -1;
+		(*olsr_node)->olsr_neigh_list = NULL;
+
+		return (*olsr_node);
+
+	}
+	return(0);
+}
+
+/*
+ *
+ * initialize the struct for a linked list obj2ip
+ *
+ */
+
+void lst_initialize() {
+	Obj_to_ip_head = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
+	Obj_to_ip_end = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
+	if(Obj_to_ip_head == NULL || Obj_to_ip_end == NULL)
+		out_of_mem();
+	Obj_to_ip_head->id = 0;
+	Obj_to_ip_end->id = 0;
+	Obj_to_ip_head->prev = Obj_to_ip_end->prev = Obj_to_ip_head;
+	Obj_to_ip_head->next = Obj_to_ip_end->next = Obj_to_ip_end;
+	List_ptr = Obj_to_ip_head;
+}
+
+/*
+ *
+ * add a link object_id to olsr_node, to get ip adress and coordinates per object_id
+ *                 id => object_id, returned from s3d_clone or s3d_new_object
+ *  **olsr_node => pointer to pointer of current olsr_node
+ *
+ */
+
+void lst_add(int id,struct olsr_node **olsr_node) {
+	struct Obj_to_ip *new;
+	new = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
+	if(new == NULL)
+		out_of_mem();
+	new->id = id;
+	new->olsr_node = *olsr_node;
+	move_lst_ptr(&id);
+	new->prev = List_ptr;
+	new->next = List_ptr->next;
+	List_ptr->next->prev = new;
+	List_ptr->next = new;
+	/* printf("obj2ip: add object %d between %d .. %d ip %s to list\n",new->id,new->prev->id,new->next->id,new->olsr_node->ip); */
+}
+
+/*
+ *void move_lst_ptr(int *id)
+ * remove element from obj2ip linked list
+ * id => object_id, returned from s3d_clone or s3d_new_object
+ *
+ */
+
+void lst_del(int id) {
+	struct Obj_to_ip *del;
+	move_lst_ptr(&id);
+	if(id != List_ptr->id)
+	{
+		printf("obj2ip: remove id %d failed move_lst_ptr return id %d\n",id,List_ptr->next->id);
+	} else {
+		del = List_ptr;
+		List_ptr->next->prev = List_ptr->prev;
+		List_ptr->prev->next = List_ptr->next;
+		/* printf("obj2ip: remove object %d --> %d <-- %d ip %s from list\n",List_ptr->prev->id,del->id,List_ptr->next->id,del->olsr_node->ip); */
+		free(del);
+	}
+}
+
+/*
+ *
+ * move the List_ptr one positon ahead the searched element
+ *	*id => pointer of object_id , returned from s3d_clone or s3d_new_object
+ *
+ */
+
+void move_lst_ptr(int *id) {
+	/* printf("obj2ip: move for %d\n",*id); */
+	/* head to point at end or id lass then first element in linked list*/
+	if(Obj_to_ip_head->next == Obj_to_ip_head || *id < Obj_to_ip_head->next->id)
+		List_ptr = Obj_to_ip_head;
+ 	/* id is greather then last element in linked list */
+	else if(*id > Obj_to_ip_end->prev->id)
+		List_ptr = Obj_to_ip_end->prev;
+	else {
+		/* printf("obj2ip: ok i search deeper ;-) for id=%d\n",*id); */
+		if((*id - (int) Obj_to_ip_head->next->id) <= ((int)(Obj_to_ip_end->prev->id)-*id)) {
+			List_ptr = Obj_to_ip_head;
+			/* printf("obj2ip: start at head id %d - %d <= %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id); */
+			while(*id >= List_ptr->next->id) {
+				/* printf("obj2ip: %d > %d move to ",*id,List_ptr->id); */
+				List_ptr = List_ptr->next;
+				/* printf("%d\n",List_ptr->id); */
+			}
+		} else {
+			List_ptr = Obj_to_ip_end;
+			/* printf("obj2ip: start at end id %d - %d > %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id);  */
+			/*  do List_ptr = List_ptr->prev; while(*id > List_ptr->prev->id); */
+			while(*id < List_ptr->prev->id) {
+				/* printf("obj2ip: %d < %d move to ",*id,List_ptr->id); */
+				List_ptr = List_ptr->prev;
+				/* printf("%d\n",List_ptr->id); */
+			}
+			List_ptr = List_ptr->prev;
+		}
+		/* printf("obj2ip: found id to insert between %d--> .. <--%d to search/delete %d--> .. <--%d\n",List_ptr->id,List_ptr->next->next->id,List_ptr->prev->id,List_ptr->next->id); */
+	}
+}
+
+/*
+ *
+ * search a object_id in linked list and return pointer on struct olsr_node
+ *	id => object_id , returned from s3d_clone or s3d_new_object
+ *
+ * <example>
+ *     struct olsr_node *olsr_node;
+ *     olsr_node = *lst_search(oid);
+ *     printf("obj2ip: search return %s\n",olsr_node->ip);
+ * </example>
+ *
+ */
+
+struct olsr_node **lst_search(int id) {
+	move_lst_ptr(&id);
+	/* TODO: return NULL when no node found */
+	/* if(id != List_ptr->id) */
+		/* printf("obj2ip: search id....id not found\n"); */
+	/* else */
+		/* printf("obj2ip: search found objekt_id=%d objekt_ip=%s\n",List_ptr->id,List_ptr->olsr_node->ip); */
+	return(&List_ptr->olsr_node);
+}
+
+void lst_out() {
+	struct Obj_to_ip *ptr;
+	ptr = Obj_to_ip_head;
+	while(ptr != ptr->next) {
+		printf("id-> %d\n",ptr->id);
+		ptr = ptr->next;
+	}
+}
+
+int process_main() {
+
+	int dn;
+	float f;
+	char *lbuf_ptr, *last_cr_ptr, *con_from, *con_from_end, *con_to, *con_to_end, *etx, *etx_end, *tmpChar;
+	struct olsr_node *olsr_node1;   /* pointer to olsr nodes */
+	struct olsr_node *olsr_node2;
+	int address;
+	char hna_name[NAMEMAX];
+	char hna_node[NAMEMAX];
+
+	lbuf_ptr = lbuf;
+	last_cr_ptr = NULL;
+
+	con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
+	dn = 0;
+
+	/*printf("---lbuf-start---\n%s\n---lbuf-end---\n",lbuf);*/
+
+	while ( (*lbuf_ptr) != '\0' ) {
+
+		/* printf( "%c",(*lbuf_ptr) ); */
+
+		if ( (*lbuf_ptr) == '\n' ) {
+
+			last_cr_ptr = lbuf_ptr;
+			con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
+			dn = 0;
+
+		}
+
+		if ( (*lbuf_ptr) == '"' ) {
+
+			switch ( dn ) {
+
+				case 0:
+					con_from = lbuf_ptr + 1;
+					break;
+				case 1:
+					con_from_end = lbuf_ptr;
+					break;
+				case 2:
+					con_to = lbuf_ptr + 1;
+					break;
+				case 3:
+					con_to_end = lbuf_ptr;
+					break;
+				case 4:
+					etx = lbuf_ptr + 1;
+					break;
+				case 5:
+					etx_end = lbuf_ptr;
+					break;
+
+			}
+
+			if ( ++dn == 6 ) {
+
+				/* terminate strings - but not before 6 times '"' */
+				(*con_from_end) = (*con_to_end) = (*etx_end) = '\0';
+
+				/* printf( "con_from: %s, con_to: %s, etx: %s\n", con_from, con_to, etx ); */
+
+				/* announced network via HNA */
+				if ( strncmp( etx, "HNA", NAMEMAX ) == 0 ) {
+
+					/* connection to internet */
+					if ( strncmp( con_to, "0.0.0.0/0.0.0.0", NAMEMAX ) == 0 ) {
+
+						olsr_node1 = get_olsr_node( &Olsr_root, con_from );
+
+						if ( olsr_node1->node_type != 1 ) {
+
+							olsr_node1->node_type = 1;
+							olsr_node1->node_type_modified = 1;
+							if ( Debug ) printf( "new internet: %s\n", olsr_node1->ip );
+
+						}
+
+					/* normal HNA */
+					} else {
+						memmove(hna_node,con_to,NAMEMAX);
+						if( (tmpChar = strchr(hna_node, (int)'/')))
+						{
+							tmpChar++;
+							address = (int)-inet_network(tmpChar);
+							sprintf(hna_name,"%d",(int)(32 - ceil(log(address)/log(2))));
+							strcpy(tmpChar,hna_name);
+						}
+
+						olsr_node1 = get_olsr_node( &Olsr_root, con_from );
+						olsr_node2 = get_olsr_node( &Olsr_root, hna_node );
+
+						if ( olsr_node2->node_type != 2 ) {
+
+							olsr_node2->node_type = 2;
+							olsr_node2->node_type_modified = 1;
+							if ( Debug ) printf( "new hna network: %s\n", olsr_node2->ip );
+
+						}
+						if ( olsr_node1->visible && olsr_node2->visible )
+							add_olsr_con( olsr_node1, olsr_node2, -1000.00 );
+
+					}
+
+				/* normal node */
+				} else {
+
+					olsr_node1 = get_olsr_node( &Olsr_root, con_from );
+					olsr_node2 = get_olsr_node( &Olsr_root, con_to );
+					f = strtod(etx,NULL);
+					if ( f < 1.0 )
+						f = 999.0;
+					add_olsr_con( olsr_node1, olsr_node2, f );
+				}
+				/* remove zerobyte */
+				(*con_from_end) = (*con_to_end) = (*etx_end) = '"';
+
+				con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
+				dn = 0;
+				last_cr_ptr = lbuf_ptr;
+
+			}
+
+		} else if ( ( (*lbuf_ptr) == '}' ) && ( (*(lbuf_ptr + 1)) == '\n' ) ) {
+
+			Output_block_completed = 1;
+
+		}
+
+		lbuf_ptr++;
+
+	}
+
+	if ( last_cr_ptr != NULL ) memmove( lbuf, last_cr_ptr + 1, strlen( last_cr_ptr ) );
+	/*printf("---memmove-lbuf-start---\n%s\n---memmove-lbuf-end---\n",lbuf);*/
+	return(0);
+
+}

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/olsrs3d/search.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,304 @@
+/*
+ * search.c
+ * 
+ * Copyright (C) 2006 Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of the olsrs3d, an olsr topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <s3d.h>
+#include <s3dw.h>
+#include <s3d_keysym.h>
+#include <math.h>
+#include <stdio.h>	/* TODO can remove then no more printf needed */
+#include <string.h>
+#include "structs.h"
+#include "search.h"
+
+s3dw_surface	*_search_surface;
+s3dw_input		*_search_input;
+s3dw_widget		*_search_widget;
+
+struct olsr_node *_node_root = NULL;
+struct olsr_node **search_node = NULL;
+
+float	_return_point[2][3];				/* cam position before move to the widget */
+int		_search_status = NOTHING;			/* status of search */
+											
+void _search_node(s3dw_widget *dummy);
+void _abort_search(s3dw_widget *dummy);
+
+/* public */
+void follow_node(float cam_position_t[], float cam_position_r[],float rotate)
+{
+	float real_node_pos[3],
+		  cam_target[3],
+		  tmp_vec[3],
+		  diff_vec[3],
+		  angle;
+	
+	real_node_pos[0] =  (*search_node)->pos_vec[0] * cos( rotate * M_PI / 180.0 ) - (*search_node)->pos_vec[2] * -sin ( rotate * M_PI / 180.0 );
+	real_node_pos[1] =  (*search_node)->pos_vec[1];
+	real_node_pos[2] =  (*search_node)->pos_vec[0] * -sin( rotate * M_PI / 180.0) + (*search_node)->pos_vec[2] * cos ( rotate * M_PI / 180.0 );
+
+	cam_target[0] = ( real_node_pos[0] + 7);
+	cam_target[1] =   real_node_pos[1];
+	cam_target[2] = ( real_node_pos[2] + 7);
+	
+	cam_position_t[0]=( cam_position_t[0] * 4 + cam_target[0] ) / 5;
+	cam_position_t[1]=( cam_position_t[1] * 4 + cam_target[1] ) / 5;
+	cam_position_t[2]=( cam_position_t[2] * 4 + cam_target[2] ) / 5;
+	
+	tmp_vec[0] =  0.0;
+	tmp_vec[1] =  0.0;
+	tmp_vec[2] = -1.0;
+	
+	diff_vec[0] = cam_position_t[0] - real_node_pos[0];
+	diff_vec[1] = 0.0;
+	diff_vec[2] = cam_position_t[2] - real_node_pos[2];
+	angle = s3d_vector_angle( diff_vec, tmp_vec );
+	/* angle = ( real_node_pos[0] > 0) ? ( 180 - ( 180 / M_PI * angle ) ) : ( 180 + ( 180 / M_PI * angle ) ); */
+	angle = 180 - ( 180 / M_PI * angle );
+	cam_position_r[1] = ( cam_position_r[1] * 4 + angle ) / 5;
+	
+	s3d_translate( 0, cam_position_t[0], cam_position_t[1], cam_position_t[2] );
+	s3d_rotate( 0, cam_position_r[0], cam_position_r[1], cam_position_r[2] );
+}
+
+/* public */
+void create_search_widget(float x, float y, float z)
+{
+	s3dw_button *search_button, *abort_button;
+	
+	_search_surface	= s3dw_surface_new( "Node Search", 17, 10 );
+	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
+	
+	s3dw_label_new( _search_surface, "Enter the IP of the node.", 1, 2);
+	s3dw_focus( S3DWIDGET( _search_input ) );
+	
+	search_button = s3dw_button_new( _search_surface, "Search", 11.5, 7 );
+	abort_button  = s3dw_button_new( _search_surface, "Abort", 1, 7 );
+	search_button->onclick = _search_node;
+	abort_button->onclick = _abort_search;
+
+	/* TODO calc position for ok button */
+	
+	s3dw_focus	( S3DWIDGET( _search_input ) );	
+	s3dw_focus	( S3DWIDGET( _search_surface ) );
+	s3dw_show	( S3DWIDGET( _search_surface ) );
+	
+	_search_widget	= s3dw_getroot();
+	move_search_widget( x, y, z );
+
+	_search_widget->ary = 180;
+	s3d_rotate( _search_widget->oid, _search_widget->arx, _search_widget->ary, _search_widget->arz );
+}
+
+/* public */
+void move_search_widget(float x, float y, float z)
+{
+	_search_widget->x = x; _search_widget->y = y; _search_widget->z = z;
+	s3dw_moveit( _search_widget );
+}
+
+/* public */
+void move_to_search_widget(float cam_position_t[], float cam_position_r[])
+{
+	float target, current;
+	
+	set_search_status(WIDGET);
+	cam_position_t[0] = ( cam_position_t[0] * 4 + _search_widget->x ) / 5;
+	cam_position_t[1] = ( cam_position_t[1] * 4 + _search_widget->y ) / 5;
+	cam_position_t[2] = ( cam_position_t[2] * 4 + ( _search_widget->z - 10 ) ) / 5;
+
+	target = _search_widget->arx;
+	current = cam_position_r[0];
+
+	if( _search_widget->arx - cam_position_r[0] > 180 )
+		target -= 360;
+	if( _search_widget->arx - cam_position_r[0] < -180 )
+		current -= 360;
+	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
+
+	target = _search_widget->ary;
+	current = cam_position_r[1];
+
+	if( _search_widget->ary - cam_position_r[1] > 180 )
+		target -= 360;
+	if( _search_widget->ary - cam_position_r[1] < -180 )
+		current -= 360;
+	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
+
+	target = _search_widget->arz;
+	current = cam_position_r[2];
+
+	if( _search_widget->arz - cam_position_r[2] > 180 )
+		target -= 360;
+	if( _search_widget->arz - cam_position_r[2] < -180 )
+		current -= 360;
+	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
+	
+	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
+	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
+	
+	if ( sqrt(  (( cam_position_t[0] - _search_widget->x)*( cam_position_t[0] - _search_widget->x)) + 
+				(( cam_position_t[1] - _search_widget->y)*( cam_position_t[1] - _search_widget->y)) + 
+				(( cam_position_t[2] - _search_widget->z)*( cam_position_t[2] - _search_widget->z)) ) < 0.2 )
+	{
+		s3d_translate( 0, _search_widget->x, _search_widget->y, ( _search_widget->z - 10 ) );
+		s3d_rotate( 0, _search_widget->arx, _search_widget->ary, _search_widget->arz );
+	}
+}
+
+/* public */
+void move_to_return_point(float cam_position_t[], float cam_position_r[])
+{
+	float target, current;
+
+	cam_position_t[0] = ( cam_position_t[0] * 4 + _return_point[0][0] ) / 5;
+	cam_position_t[1] = ( cam_position_t[1] * 4 + _return_point[0][1] ) / 5;
+	cam_position_t[2] = ( cam_position_t[2] * 4 + _return_point[0][2] ) / 5;
+
+	target = _return_point[1][0];
+	current = cam_position_r[0];
+
+	if( _return_point[1][0] - cam_position_r[0] > 180 )
+		target -= 360;
+	if( _return_point[1][0] - cam_position_r[0] < -180 )
+		current -= 360;
+	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
+
+	target = _return_point[1][1];
+	current = cam_position_r[1];
+
+	if( _return_point[1][1] - cam_position_r[1] > 180 )
+		target -= 360;
+	if( _return_point[1][1] - cam_position_r[1] < -180 )
+		current -= 360;
+	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
+
+	target = _return_point[1][2];
+	current = cam_position_r[2];
+
+	if( _return_point[1][2] - cam_position_r[2] > 180 )
+		target -= 360;
+	if( _return_point[1][2] - cam_position_r[2] < -180 )
+		current -= 360;
+	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
+	
+	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
+	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
+	
+	if ( sqrt(  (( cam_position_t[0] - _return_point[0][0])*( cam_position_t[0] - _return_point[0][0])) + 
+				(( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) + 
+				(( cam_position_t[2] - _return_point[0][2])*( cam_position_t[2] - _return_point[0][2])) ) < 0.2 )
+	{
+		s3d_translate( 0, _return_point[0][0], _return_point[0][1], _return_point[0][2] );
+		s3d_rotate( 0, _return_point[1][0], _return_point[1][1], _return_point[1][2] );
+		set_search_status(NOTHING);
+	}
+}
+
+/* public */
+void search_widget_write(int key)
+{
+	static char s[20];
+	int ln = strlen(s);
+	
+	if( key == S3DK_COMMA ) key = S3DK_PERIOD;
+	
+	if( key != S3DK_RETURN )
+	{
+		if( key == S3DK_BACKSPACE )
+		{
+			if( ln > 0 )
+				s[ln-1] = '\0';
+		} else {
+			if( ln < 20 )
+				s[ln] = key;
+		}
+		s3dw_input_change_text( _search_input, s );
+	} else {
+		_search_node( _search_widget );	
+	}
+}
+
+/* public */
+void set_return_point(float cam_position_t[], float cam_position_r[])
+{
+	int i;
+	for( i = 0; i < 3; i++ )
+		_return_point[0][i] = cam_position_t[i];
+	for( i = 0; i < 3; i++ )
+		_return_point[1][i] = cam_position_r[i];
+}
+
+/* public */
+int get_search_status(void)
+{
+	return _search_status;
+}
+
+/* public */
+void set_search_status(int stat)
+{
+	/* TODO check if stat between 0-3 else debug printf */
+	_search_status = stat;
+}
+
+/* public */
+void set_node_root(struct olsr_node *root)
+{
+	_node_root = root;
+}
+
+/* private */
+void _search_node(s3dw_widget *dummy)
+{
+	char *ip;
+	int result;
+	
+	search_node = &_node_root;
+	
+	ip = s3dw_input_gettext( _search_input );
+	
+	while ( (*search_node) != NULL )
+	{
+
+		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
+
+		if ( result == 0 ) 
+			break;
+		
+		if ( result < 0 )
+			(*search_node) = (*search_node)->right;
+		else
+			(*search_node) = (*search_node)->left;
+	}
+
+	if( (*search_node) != NULL )
+		set_search_status( FOLLOW );
+}
+
+/* private */
+void _abort_search(s3dw_widget *dummy)
+{
+	set_search_status(ABORT);
+}
+
+	

Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,217 @@
+/*
+ * s3d_x11gate.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d_x11gate, a 3d gateway for x11 desktops.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d_x11gate is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d_x11gate is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d_x11gate; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <s3d.h>		 /*  s3d_*() */
+#include <stdlib.h> 	 /*  getenv() */
+#include <stdio.h>		 /*  printf() */
+#include <X11/Xlib.h>	 /*  Ximage, Display, X*() */
+#include <X11/Xutil.h>	 /*  XDestroyImage() */
+#define XK_MISCELLANY
+#include <X11/keysymdef.h>	 /* keysyms */
+#include <X11/extensions/XTest.h>	/* keyboard/mouse input via s3d */
+#include <time.h>	/* nanosleep() */
+static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+
+int oid;
+XImage *image;
+Display *dpy=0;
+int window,scr;
+int width,height;
+char *tex_image=NULL,*otex_image=NULL,*img1,*img2;
+int get_shift(unsigned long t)
+{
+	int i=0;
+	while (t)
+	{
+		t>>=1;
+		i++;
+	}
+	return(i);
+}
+void mainloop()
+{
+	int x,y;
+	int rs,gs,bs;
+	unsigned long d;
+	int bpp;
+	char *swap_timg;
+	int last_change,start_change;
+	image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);
+	if (image->format==ZPixmap)
+	{
+		printf("Ximage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n",image->width,image->height,image->format,ZPixmap,
+					image->bits_per_pixel,image->depth,image->bitmap_pad);
+		rs=get_shift(image->red_mask)-8;
+		gs=get_shift(image->green_mask)-8;
+		bs=get_shift(image->blue_mask)-8;
+
+		bpp=(image->bits_per_pixel/8);
+		/* rgb is not bgr */
+		rs=rs;
+		gs=gs-8;
+		bs=bs-16;
+		printf("Ximage: rgb: %d|%d|%d\n",	rs,gs,bs);;
+/*		printf("red: size %d, offset %d\n",rs,roff);
+		printf("green: size %d, offset %d\n",gs,goff);
+		printf("blue: size %d, offset %d\n",bs,boff);
+		printf("bits per pixel:%d\n",bpp);*/
+		last_change=-1;
+		start_change=-1;
+		for (y=0;y<height;y++)
+		{
+			
+			for (x=0;x<width;x++)
+			{
+				d=*((unsigned long *)(image->data+(y*width+x)*bpp));
+				((unsigned long *)tex_image)[(y*width+x)]=
+						(rs>0?((d&image->red_mask)>>rs):	((d&image->red_mask)<<-rs))|
+						(gs>0?((d&image->green_mask)>>gs):	((d&image->green_mask)<<-gs))|
+						(bs>0?((d&image->blue_mask)>>bs):	((d&image->blue_mask)<<-bs))|
+						255<<24;
+				if (((unsigned long *)tex_image)[(y*width+x)]!=
+					((unsigned long *)otex_image)[(y*width+x)])
+					last_change=y;
+			}
+			if (last_change!=-1)
+			{
+				if (start_change==-1)
+				{
+					start_change=y;
+/* 					printf("setting start_change to %d\n",start_change); */
+				}
+				if (last_change!=y)
+				{	 /*  last change is already over, post it! */
+/*					printf("[%d to %d]",start_change,last_change);*/
+					s3d_load_texture(oid,0,0,start_change,width,last_change-start_change+1,(unsigned char *)tex_image+start_change*width*4);
+					start_change=-1;
+					last_change=-1;
+				}
+			}
+		}
+		 /*  posting the last bit, maybe */
+		if (last_change!=-1)
+		{
+/*			printf("last one: [%d-%d]",start_change,last_change);*/
+			s3d_load_texture(oid,0,0,start_change,width,last_change-start_change,(unsigned char *)tex_image+start_change*width*4);
+		}
+/* 		s3d_load_texture(oid,0,0,0,width,height,tex_image); */
+		 /*  swap images */
+		swap_timg=tex_image;
+		tex_image=otex_image;
+		otex_image=swap_timg;
+	}
+	XDestroyImage(image);
+
+	nanosleep(&t,NULL); 
+}
+void keypress(struct s3d_evt *event)
+{
+	int key;
+	int kc;
+	key=*((unsigned short *)event->buf);
+	printf("received key %d ",key);
+    kc = XKeysymToKeycode(dpy, key);
+	if (kc==0) 
+	{
+	    kc = XKeysymToKeycode(dpy, 0xFF00+ key);
+		printf(" (%04x) ",0xFF00+key);
+	}
+	if (kc==0)
+	{
+		if (key==8)
+		{
+			kc=22; printf("!backspace!");
+		}
+	}
+	printf("using key: %d, keycode %d (%04x)\n",key,kc,kc);
+	if (kc!=0)
+	    XTestFakeKeyEvent(dpy, kc, 1, 1);
+/*	    XTestFakeKeyEvent(dpy, kc, 0, 1);*/
+
+}
+void mouseclick(struct s3d_evt *event)
+{
+	printf("not processing mouse clicks yet ... \n");
+}
+int main(int argc, char **argv)
+{
+	char *disp=NULL;
+	int a,b,c,d;
+	int xt;
+	if (disp==NULL) disp=getenv("DISPLAY");
+	if (disp==NULL) disp="";  /*  fallback */
+	dpy = XOpenDisplay(disp);
+	if (!dpy)
+	{
+		printf("couldn't open display\n");
+		return(-1);
+	}
+	if (!s3d_init(&argc,&argv,"X11-gate"))
+	{
+		scr = DefaultScreen(dpy);
+		window = RootWindow(dpy, scr);
+		width = DisplayWidth(dpy, scr);
+		height = DisplayHeight(dpy, scr);
+		XLockDisplay(dpy);
+		xt=XTestQueryExtension(dpy,&a,&b,&c,&d);
+		XUnlockDisplay(dpy);
+		if (xt)
+		{
+			printf("having xtest extension ...\n");
+		}
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK,mouseclick);
+		s3d_set_callback(S3D_EVENT_KEY,keypress);
+		printf("screen: %dx%d\n",width,height);
+		img1=malloc(width*height*4);
+		img2=malloc(width*height*4);
+		tex_image=img1;
+		otex_image=img2;
+		oid=s3d_new_object();
+		s3d_push_vertex(oid,-5,-5,0);
+		s3d_push_vertex(oid, 5,-5,0);
+		s3d_push_vertex(oid, 5, 5,0);
+		s3d_push_vertex(oid,-5, 5,0);
+		s3d_push_material_a(oid,
+						0.8,	0.0,	0.0	,1.0,
+						1.0,	1.0,	1.0	,1.0,
+						0.8,	0.0,	0.0	,1.0);
+		s3d_push_polygon(oid,0,2,1,0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,1.0, 
+									   1.0,0.0,
+									   1.0,1.0);
+		s3d_push_polygon(oid,0,3,2,0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,1.0, 
+									   0.0,0.0,
+									   1.0,0.0);
+		s3d_push_texture(oid,width,height);
+					 /*  push data on texture 0 position (0,0) */
+		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
+		s3d_flags_on(oid,S3D_OF_VISIBLE);
+		s3d_mainloop(mainloop);
+		free(img1);
+		free(img2);
+	}
+	s3d_quit();
+	return(0);
+}

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/s3dfm/animation.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,172 @@
+/*
+ * animation.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "s3dfm.h"
+#include <s3dw.h>
+#include <stdio.h> 	 /*  printf(),NULL */
+#include <math.h>	 /*  fabs() */
+#define SCALE 	1
+
+/* the animation stack */
+static t_item *ani_s[MAXANI];
+static int ani_n=0;
+extern t_item root,cam;
+int moveon=1;
+
+/* get the scale for the rootbox zoom */
+float ani_get_scale(t_item *f)
+{
+	float scale,s;
+	s=0.2;
+	scale=1/s;
+	if (f->parent!=NULL)
+		scale=1/s*ani_get_scale(f->parent);
+	else
+		return(1.0);
+	root.px-=f->px;
+	root.pz-=f->pz;
+	root.py-=BOXHEIGHT+f->detached*DETHEIGHT;
+	root.px*=1/s;
+	root.py*=1/s;
+	root.pz*=1/s;
+	
+	return(scale);
+}
+/* center f for the viewer, therefore moving the root box ... */
+void ani_focus(t_item *f)
+{
+	root.px=0.0;
+	root.py=0.0;
+	root.pz=0.0;
+	moveon=1;
+/*	printf("[Z]ooming to %s\n",f->name);*/
+	box_collapse_grandkids(f);
+	root.scale=ani_get_scale(f);
+	root.py-=1.5;
+/*	printf("[R]escaling to %f\n",root.scale);
+	printf("px: %f py:%f pz: %f\n",root.px,root.py,root.pz);*/
+
+	ani_add(&root);
+	if (((cam.dpx-cam.px)* (cam.dpx-cam.px) + (cam.dpy-cam.py)* (cam.dpy-cam.py) 
+		  + (cam.dpz-cam.pz)* (cam.dpz-cam.pz))	> ( 10 * 10))
+	{
+		cam.px=0;
+		cam.py=0;
+		cam.pz=5;
+		ani_add(&cam);
+	}
+}
+/* is item f already on stack? */
+int ani_onstack(t_item *f)
+{
+	int i;
+	for (i=0;i<ani_n;i++)
+		if (ani_s[i]==f)
+			return(1);		/* already in list */
+	return(0);
+
+}
+/* add an item on the animation stack */
+void ani_add(t_item *f)
+{
+	if (ani_n<MAXANI)
+	{
+		if (ani_onstack(f))
+			return;		/* already in list */
+		ani_s[ani_n]=f;
+		ani_iterate(f);
+	/*	printf("[A]ni ADD %d\n",ani_n); */
+		ani_n++;
+	}
+	else /* no place, finish now */
+		ani_finish(f,-1);
+}
+/* delete an item from the animation stack */
+void ani_del(int i)
+{
+	if ((i>=0) && (i<ani_n))
+	{
+/*		printf("[A]ni DEL %d\n",i);*/
+		ani_n--;
+		ani_s[i]=ani_s[ani_n]; /* that should also work if i is the last one */
+	} else {
+		printf("[F]ATAL: can't delete animation!\n");
+	}
+}
+/* well ... */
+void ani_doit(t_item *f)
+{
+	s3d_translate(	f->block, f->dpx,f->dpy,f->dpz);
+	s3d_scale(		f->block, f->dscale);
+}
+
+/* finish an animation on the stack, stack index i */
+void ani_finish(t_item *f, int i)
+{
+	f->dpx= f->px;
+	f->dpy= f->py;
+	f->dpz= f->pz;
+	f->dscale= f->scale;
+	ani_doit(f);
+	if (i!=-1)
+		ani_del(i);
+}
+void ani_iterate(t_item *f)
+{
+	f->dpx=(f->px + f->dpx*ZOOMS)/(ZOOMS+1);
+	f->dpy=(f->py + f->dpy*ZOOMS)/(ZOOMS+1);
+	f->dpz=(f->pz + f->dpz*ZOOMS)/(ZOOMS+1);
+	f->dscale=(f->scale + f->dscale*ZOOMS)/(ZOOMS+1);
+
+}
+
+/* checks if f is good enough */
+int ani_check(t_item *f)
+{
+	float x,y,z;
+	x=f->dpx - f->px;
+	y=f->dpy - f->py;
+	z=f->dpz - f->pz;
+	if (((fabs(f->dscale - f->scale)/f->scale)>0.01) || (sqrt(x*x+y*y+z*z) > 0.01))
+		return(0);
+	return(1);
+}
+/* doing the whole animation thing */
+void ani_mate()
+{
+	int i;
+	t_item *f;
+	s3dw_ani_mate();
+	for (i=0;i<ani_n;i++)
+	{
+		f=ani_s[i];
+		ani_iterate(f);
+		if (ani_check(f))
+		{
+			ani_finish(f,i);
+			i--; /* a new object is here now, take care in the next iteration */
+		} else {
+			ani_doit(f);
+		}
+	}
+}

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/s3dfm/box.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,399 @@
+/*
+ * box.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "s3dfm.h"
+#include <stdio.h> 	 /*  printf() */
+#include <math.h>	 /*  sin(),cos() */
+#include <string.h>  /*  strlen() */
+
+
+/* remove old items on the box */
+void box_dissolve(t_item *dir)
+{
+	if (dir->close!=-1)		{	s3d_del_object(dir->close);		dir->close=-1; }
+	if (dir->select!=-1)	{	s3d_del_object(dir->select);	dir->select=-1; }
+	if (dir->title!=-1)		{	s3d_del_object(dir->title);		dir->title=-1; }
+	if (dir->titlestr!=-1)	{	s3d_del_object(dir->titlestr);	dir->titlestr=-1; }
+	if (dir->block!=-1)			s3d_del_object(dir->block);
+
+}
+
+
+
+/* places the string at the left side of the cube */
+void box_sidelabel(t_item *dir)
+{
+
+	s3d_rotate(dir->str,0,90,0);
+	s3d_translate(dir->str,1.1,0.3,1);
+	s3d_scale(dir->str,(float)1.8/(dir->len));
+	s3d_scale(dir->str,(float)1.8/(dir->len));
+	s3d_link(dir->str,dir->block);
+	s3d_flags_on(dir->str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+}
+
+/* creates a big block which will hold files and subdirs on top */
+int box_buildblock(t_item *dir)
+{
+	char fname[30];
+	char *fullname=fname;
+	t_item *d;
+	int i,j;
+	float len;
+	float vertices[]=
+			{-BHP,0,-BHP,
+			 -BHP,0, BHP,
+			  BHP,0, BHP,
+			  BHP,0,-BHP,
+			 -BHP,BHH,-BHP,
+			 -BHP,BHH, BHP,
+			  BHP,BHH, BHP,
+			  BHP,BHH,-BHP,
+			 -1,0, 0.8,
+			 -1,BOXHEIGHT, 0.8,
+			  1,BOXHEIGHT, 0.8,
+			  1,0, 0.8
+				};
+	float xvertices[]=
+			{
+			  0.8,BHH-0.2, 0.8,
+			  0.8,BHH    , 0.8,
+			  BHP,BHH    , 0.8,
+			  BHP,BHH-0.2, 0.8,
+			  0.8,BHH-0.2, 1.0,
+			  0.8,BHH    , 1.0,
+			  BHP,BHH    , 1.0,
+			  BHP,BHH-0.2, 1.0
+			 };
+	float svertices[]=
+			{
+			  0.6,BHH-0.2, 0.8,
+			  0.6,BHH    , 0.8,
+			  0.8,BHH    , 0.8,
+			  0.8,BHH-0.2, 0.8,
+			  0.6,BHH-0.2, 1.0,
+			  0.6,BHH    , 1.0,
+			  0.8,BHH    , 1.0,
+			  0.8,BHH-0.2, 1.0
+			 };
+	float tvertices[]=
+			{
+			  -BHP,BHH-0.2, 0.8,
+			  -BHP,BHH    , 0.8,
+			  0.6, BHH    , 0.8,
+			  0.6, BHH-0.2, 0.8,
+			  -BHP,BHH-0.2, 1.0,
+			  -BHP,BHH    , 1.0,
+			  0.6, BHH    , 1.0,
+			  0.6, BHH-0.2, 1.0
+			 };
+	unsigned long bar_poly[]={
+		4,5,6,0,
+		4,6,7,0,
+		3,7,4,0,
+		3,4,0,0
+	};
+/*	printf("new block for %s\n",dir->name);*/
+
+	dir->block=s3d_new_object();
+	s3d_push_vertices(dir->block,vertices,sizeof(vertices)/(3*sizeof(float)));
+	s3d_push_material(dir->block,
+						0.5,0.5,0.5,
+						0.5,0.5,0.5,
+						0.5,0.5,0.5
+					);
+	s3d_push_material(dir->block,
+						0.5,0.5,0.6,
+						0.5,0.5,0.6,
+						0.5,0.5,0.6);
+
+	s3d_push_polygon(dir->block,4,6,5,1);
+	s3d_push_polygon(dir->block,4,7,6,1);
+
+	s3d_push_polygon(dir->block,0,4,5,0);
+	s3d_push_polygon(dir->block,0,5,1,0);
+	
+	s3d_push_polygon(dir->block,3,7,4,0);
+	s3d_push_polygon(dir->block,3,4,0,0);
+
+	s3d_push_polygon(dir->block,2,6,7,0);
+	s3d_push_polygon(dir->block,2,7,3,0);
+	
+	s3d_push_polygon(dir->block,8,9,10,0);
+	s3d_push_polygon(dir->block,8,10,11,0);
+
+	dir->close=s3d_new_object();
+	s3d_push_material(dir->close,
+						0.5,0.3,0.3,
+						0.5,0.3,0.3,
+						0.5,0.3,0.3
+					);
+	s3d_push_vertices(dir->close,xvertices,sizeof(xvertices)/(3*sizeof(float)));
+	s3d_push_polygons(dir->close,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
+	s3d_link(dir->close,dir->block);
+	
+	dir->select=s3d_new_object();
+	s3d_push_material(dir->select,
+						0.1,0.1,0.3,
+						0.1,0.1,0.3,
+						0.1,0.1,0.3
+					);
+	s3d_push_vertices(dir->select,svertices,sizeof(svertices)/(3*sizeof(float)));
+	s3d_push_polygons(dir->select,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
+	s3d_link(dir->select,dir->block);
+	
+	dir->title=s3d_new_object();
+	s3d_push_material(dir->title,
+						0.3,0.3,0.3,
+						0.3,0.3,0.3,
+						0.3,0.3,0.3
+					);
+	s3d_push_vertices(dir->title,tvertices,sizeof(tvertices)/(3*sizeof(float)));
+	s3d_push_polygons(dir->title,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
+	s3d_link(dir->title,dir->block);
+	i=28;
+	fullname[29]=0;
+	d=dir;
+	do {
+		j=strlen(d->name)-1;
+		if (NULL!=(d->parent))
+		{
+			fullname[i]='/';
+			i--;
+		}
+		while ((i >= 0) && (j >= 0))
+		{
+			fullname[i]=d->name[j];
+			j--;
+			i--;
+		}
+		if (i<0) 
+			break;
+
+
+	} while ((d=d->parent)!=NULL);
+	if (i<0)
+		fullname[0]=fullname[1]='.';
+	else 
+		fullname=(char *)fullname+i+1; /* jump to start of the string */
+	dir->titlestr=s3d_draw_string(fullname,&len);
+	if (len>(1.6*5.0))
+		s3d_scale(dir->titlestr,1.6/len);
+	else
+		s3d_scale(dir->titlestr,0.2);
+	s3d_translate(dir->titlestr,-1.0,1.05,1.01);
+	s3d_link(dir->titlestr,dir->block);
+	dir->disp=D_DIR;
+/*	printf("FULLNAME is [%s]\n",fullname);*/
+	return(0);
+}
+int undisplay(t_item *dir)
+{
+	switch (dir->disp)
+	{
+		case D_DIR: return(box_undisplay(dir));break;
+		case D_ICON:return(icon_undisplay(dir));break;
+		default:	return(-1);
+	}
+}
+/* display a directoy on the top of another, draw it's icons etc ... */
+int box_expand(t_item *dir)
+{
+	int i;
+	float  px,pz;
+	int dirn;
+	px=pz=0.0;
+	printf("box_expand( %s )\n",dir->name);
+	if (dir->disp)		undisplay(dir);
+	box_buildblock(dir);
+	if (dir->parent!=NULL)
+		dir->parent->dirs_opened++;
+ /* count directories */
+	dirn=0;
+	for (i=0;i<dir->n_item;i++)
+	{
+		if (dir->list[i].type==T_FOLDER) dirn++;
+	}
+
+	/* draw icons, if necceasry */
+	for (i=0;i<dir->n_item;i++)
+	{
+		if (!dir->list[i].disp)	icon_draw(dir,i);
+		else {
+			printf("link %d to the block %d of %s\n",dir->list[i].block,dir->block,dir->name);
+			s3d_link(dir->list[i].block,dir->block); /* if it's already displayed, make sure it linked properly ... */
+		}
+	}
+	if (dir->parent!=NULL)
+	{
+		s3d_link(dir->block,dir->parent->block);
+		dir->dpx=0.0;
+		dir->dpy=BOXHEIGHT;
+		dir->dpz=0.0;
+		dir->dscale=0.0;
+		box_position_kids(dir->parent);
+		ani_doit(dir);
+	}
+	for (i=0;i<dir->n_item;i++)
+	{
+		s3d_flags_on(dir->list[i].block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_on(dir->list[i].str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	}
+	box_sidelabel(dir);
+    s3d_flags_on(dir->block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+    s3d_flags_on(dir->close,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+    s3d_flags_on(dir->title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+    s3d_flags_on(dir->select,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+    s3d_flags_on(dir->titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	dir->disp=D_DIR;
+	return(0);
+}
+int box_undisplay(t_item *dir)
+{
+	int i;
+	t_item *par;
+	printf("box_undisplay( %s )\n",dir->name);
+	for (i=0;i<dir->n_item;i++)
+	{
+		if (dir->list[i].disp==D_ICON)	icon_undisplay(&(dir->list[i]));
+		else if (dir->list[i].disp!=0)	
+				printf("not undisplaying: %s (disp = %d)\n",dir->list[i].name, dir->list[i].disp);
+	}
+	if ((par=dir->parent)!=NULL) /* we can't do this on root.... */
+	{
+		for (i=0;i<par->n_item;i++)
+			if (&par->list[i]==dir)
+				break;
+		if (i!=par->n_item) /* if it actually was in the parents item list */
+		{
+			icon_draw(par,i);
+			s3d_flags_on(dir->block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(dir->str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		}
+		par->dirs_opened--;
+	} else {
+		/* we're root ... */
+		box_dissolve(dir);
+	}
+	printf("[U]ndisplayed %s\n",dir->name);
+/*	dir->dirs_opened=0;*/
+	dir->detached=0;
+	return(0);
+}
+/* undisplay a directory, thus recursively removing the kids.*/
+int box_collapse(t_item *dir,int force)
+{
+	int i;
+	int ret;
+	printf("box_collapse( %s )\n",dir->name);
+	if (&root==dir)
+	{
+		printf("won't undisplay root window ... \n");
+		return(-1);
+	}
+	if (dir->detached && !force)
+		return(1);
+	if (dir->disp!=D_DIR)
+	{
+		printf("[A]lready undisplayed %s, nothing to do ...\n",dir->name);
+		return(-1);
+	}
+	/* undisplaying kids. ret will be != 0 if any of the kids did not close correctly */
+	ret=0;
+	for (i=0;i<dir->n_item;i++)
+		if (dir->list[i].disp==D_DIR)
+			ret|=box_collapse(&dir->list[i],force);
+
+	if (ret && !force) return(ret); /* if anything got wrong, return here ... */
+	undisplay(dir);
+	if (dir->parent!=NULL)
+	{
+		box_position_kids(dir->parent);
+	}
+	return(ret);
+}
+/* only display dir and its kids, but nothing below. */
+int box_collapse_grandkids(t_item *dir)
+{
+	int i,j;
+	t_item *kid;
+	for (i=0;i<dir->n_item;i++)
+		if (dir->list[i].disp==D_DIR)
+		{
+			kid=&dir->list[i];
+			for (j=0;j<kid->n_item;j++)
+			if (kid->list[j].disp==D_DIR)
+				box_collapse(&kid->list[j],0);
+		}
+	return(0);
+}
+/* orders the directory objects on top of its parent objects 
+ * to be called after adding or removing things ...*/
+void box_position_kids(t_item *dir)
+{
+	int i,j;
+	printf("box_position_kids( %s ): %d dirs opened\n",dir->name,dir->dirs_opened);
+	switch (dir->dirs_opened)
+	{
+		case 0: return;
+		case 1:
+			for (i=0;i<dir->n_item;i++)
+			{
+				if (dir->list[i].disp==D_DIR)
+				{
+					dir->list[i].px=0.0;
+					dir->list[i].py=BOXHEIGHT+dir->list[i].detached*DETHEIGHT;
+					dir->list[i].pz=0.0;
+					dir->list[i].scale=0.2;
+					ani_add(&dir->list[i]);
+				}
+			}
+			break;
+		default:
+			j=0;
+			for (i=0;i<dir->n_item;i++)
+			{
+				if (dir->list[i].disp==D_DIR)
+				{
+					dir->list[i].px=0.8 * sin(((float)j*2*M_PI)/((float)dir->dirs_opened));
+					dir->list[i].py=BOXHEIGHT+dir->list[i].detached*DETHEIGHT;
+					dir->list[i].pz=0.8 * cos(((float)j*2*M_PI)/((float)dir->dirs_opened));
+					dir->list[i].scale=0.2;
+					ani_add(&dir->list[i]);
+					j++;
+				}
+
+			}
+	}
+}
+void box_select(t_item *dir)
+{
+	dir->detached=dir->detached?0:1; /* swapping, not sure if !dir->detached would do the same .. */
+	if ((dir->type==T_FOLDER) && dir->disp)
+	{
+		if (dir->parent!=NULL)
+			box_position_kids(dir->parent);
+	} else {
+		/* nothing yet ... */
+	}
+}

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/s3dfm/dialog.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,357 @@
+/*
+ * dialog.c
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include "s3dfm.h"
+#include <s3d_keysym.h>
+#include <s3dw.h>
+#include <stdio.h> 	/* NULL, printf() */
+#include <string.h> /* strlen() */
+#include <stdlib.h> /* realloc(),malloc() */
+#include <errno.h>  /* errno */
+#include <sys/stat.h> /* mkdir() */
+#include <sys/types.h> /* mkdir() */
+extern t_item *focus;
+filelist fp={NULL,0};
+int typeinput=0;
+/* keyevent handler */
+void key_handler(struct s3d_evt *evt)
+{
+	struct s3d_key_event *keys=(struct s3d_key_event *)evt->buf;
+	char path[M_DIR];
+	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */	
+			printf("inputting text ...\n");
+			s3dw_handle_key(evt); 
+			return; 
+	}
+	get_path(focus,path);
+	switch (keys->keysym)
+	{
+		case 'i':
+		case 'I':
+				{
+				window_info(path);
+				}
+				break;
+		case 'r':
+		case 'R':
+				{/* refresh this window ... */
+					printf("[R]efreshing %s\n",focus->name);
+					parse_again(focus);
+					ani_focus(focus);
+				}
+				break;
+		case S3DK_F1:
+				window_help();
+				break;
+		case S3DK_F5:
+				window_copy(path);
+				break;
+		case S3DK_F6:
+				window_move(path);
+				break;
+		case S3DK_F7:
+				window_mkdir(path);
+				break;
+
+
+	}
+	s3dw_handle_key(evt);
+}
+
+/* object click handler */
+void object_click(struct s3d_evt *evt)
+{
+	int oid;
+	t_item *f;
+	s3dw_handle_click(evt);
+	oid=(int)*((unsigned long *)evt->buf);
+	if (NULL!=(f=finditem(&root,oid)))
+	{
+		if (f->close==oid)
+		{
+			box_collapse(f,1);
+/*			if (f->parent!=NULL)
+				ani_focus(f->parent);*/
+			return;
+		}
+		if (f->select==oid)
+		{
+			printf("[S]electing %s\n",f->name);
+			box_select(f);
+			return;
+		}
+		if (f->type==T_FOLDER)
+		{
+			if (f->disp == D_DIR)
+			{
+				printf("[F]ound, Already displayed - ani_focus( %s )\n",f->name);
+			} else {
+				if (!f->parsed)	parse_dir(f);
+				box_expand(f);
+			}
+			focus=f;
+			ani_focus(f);
+		} else
+			printf("[F]ound, but %s is no folder\n",f->name);
+	} else {
+/*		printf("[C]ould not find :/\n");*/
+	}
+}
+void close_win(s3dw_widget *button)
+{
+	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
+}
+/* add some dots to an integer value for better readability */
+void dotted_int(char *s,unsigned int i)
+{
+	char st[M_DIR];
+	int p;
+	p=0;
+	st[0]=0;
+	while (i>0)
+	{
+		if ((p+1)%4==0) {
+			st[p]='.';
+			p++;
+		}
+		st[p]=(i%10)+'0';
+		i=i/10;
+		p++;
+	}
+	if (p>0) p--;
+	st[p+1]=0;
+	for (i=0;i<p+1;i++)
+		s[i]=st[p-i];
+	s[p+1]=0;
+}
+/* add all selected dirs in the new filelist */
+int get_selected(filelist *fp, t_item *dir)
+{
+	int i;
+	char *s;
+	for (i=0;i<dir->n_item;i++)
+	{
+		if (dir->list[i].list!=NULL)	get_selected(fp,&(dir->list[i])); /* scan subdir */
+		if (dir->list[i].detached)
+		{
+			fp->n++;
+			fp->p=realloc(fp->p,sizeof(char *) * fp->n);
+			s=malloc(M_DIR);
+			get_path(&(dir->list[i]),s);
+			fp->p[fp->n - 1]=s;
+		}
+	}
+	return(0);
+}
+void window_help()
+{
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+	infwin=s3dw_surface_new("Help Window",12,12);
+	s3dw_label_new(infwin,"F1 - This Help Window",1,2);
+	s3dw_label_new(infwin,"F5 - Copy",1,3);
+	s3dw_label_new(infwin,"F6 - Move",1,4);
+	s3dw_label_new(infwin,"F7 - Create Directory",1,5);
+	s3dw_label_new(infwin,"R - Refresh",1,6);
+	s3dw_label_new(infwin,"I - Info",1,7);
+
+	button=s3dw_button_new(infwin,"OK",4,10);
+	button->onclick=close_win;
+	s3dw_show(S3DWIDGET(infwin));
+
+}
+void window_fs_another()
+{
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+	infwin=s3dw_surface_new("Error",12,8);
+	s3dw_label_new(infwin,"Sorry, another FS Action is in Progress",1,2);
+	button=s3dw_button_new(infwin,"OK",5,5);
+	button->onclick=close_win;
+	s3dw_show(S3DWIDGET(infwin));
+}
+void window_fs_nothing()
+{
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+	infwin=s3dw_surface_new("Error",12,8);
+	s3dw_label_new(infwin,"Nothing selected :(",1,2);
+	button=s3dw_button_new(infwin,"OK",5,5);
+	button->onclick=close_win;
+	s3dw_show(S3DWIDGET(infwin));
+
+}
+void window_fs_errno(char *errmsg)
+{
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+	char string[M_DIR];
+	float l;
+	snprintf(string,M_DIR,"%s: %s",errmsg,strerror(errno));
+	l=strlen(string)*0.7;
+	infwin=s3dw_surface_new("Error",l,8);
+	s3dw_label_new(infwin,string,1,2);
+	button=s3dw_button_new(infwin,"OK",l/2-1,5);
+	button->onclick=close_win;
+	s3dw_show(S3DWIDGET(infwin));
+}
+
+void window_fs_abort(s3dw_widget *button)
+{
+	int i;
+	for (i=0;i<fp.n;i++)
+		free(fp.p[i]);
+	if (fp.p!=NULL) free(fp.p);
+	fp.n=0;
+	fp.p=NULL;
+	typeinput=0;
+	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
+}
+void window_copy(char *path)
+{
+	s3dw_surface *infwin;
+	s3dw_button  *okbutton,*abortbutton;
+	float l;
+	char destdir[M_DIR];
+
+	int i,m;
+
+	if (fp.n!=0) 	{	window_fs_another(); 	return; }
+	fp.n=0;
+	fp.p=NULL;
+	get_selected(&fp,&root);
+	printf("selected %d nodes\n",fp.n);
+	if (fp.n == 0)	{	window_fs_nothing();	return;	}
+	m=10;
+	for (i=0;i<fp.n;i++)
+	{
+		if (strlen(fp.p[i])>m) m=strlen(fp.p[i]);
+		printf("%d: %s\n",i,fp.p[i]);
+	}
+
+	l=(m+3)*0.7;
+	infwin=s3dw_surface_new("Copy Window",l,fp.n+8);
+	s3dw_label_new(infwin,"Copy: ",1,1);
+	for (i=0;i<fp.n;i++)
+		s3dw_label_new(infwin,fp.p[i],3,2+i);
+	s3dw_label_new(infwin,"to:",1,fp.n+3);
+	get_path(focus,destdir);
+	s3dw_label_new(infwin,destdir,3,fp.n+4);
+
+	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp.n+5);
+	okbutton->onclick=window_fs_abort;
+	abortbutton=s3dw_button_new(infwin,"abort",l/2,fp.n+5);
+	abortbutton->onclick=window_fs_abort;
+
+	s3dw_show(S3DWIDGET(infwin));
+
+}
+s3dw_input	 *input;
+void window_fs_mkdir(s3dw_widget *button)
+{
+	char *dir;
+	t_item *item;
+	dir=s3dw_input_gettext(input);
+	printf("creating Directory ...%s\n",dir);
+	if (-1==mkdir(dir,0777)) /* umask ?! */
+		window_fs_errno("could not create directory");
+	else {
+		/* success, now refresh it */
+		item=get_item(dir);
+		if (item==NULL)
+		{
+			printf("cannot refresh\n");
+		} else {
+			printf("refreshing %s\n",item->name);
+			parse_again(item);
+
+		}
+				
+	}
+	window_fs_abort(button); /* finish */
+
+}
+void window_mkdir(char *path)
+{
+	s3dw_surface *infwin;
+	s3dw_button  *okbutton,*abortbutton;
+	char string1[M_DIR];
+	float l;
+	if (fp.n!=0) {window_fs_another(); return; }
+	snprintf(string1,M_DIR,"Create Directory in %s",path);
+	l=strlen(string1)*0.7;
+	infwin=s3dw_surface_new("Create Directory",l,8);
+	s3dw_label_new(infwin,string1,1,2);
+	input=s3dw_input_new(infwin,10,1,3);
+	s3dw_input_change_text(input, path);
+	s3dw_focus(S3DWIDGET(input));
+	s3dw_focus(S3DWIDGET(infwin));
+	typeinput=1;
+	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp.n+5);
+	okbutton->onclick=window_fs_mkdir;
+	abortbutton=s3dw_button_new(infwin,"abort",l/2,fp.n+5);
+	abortbutton->onclick=window_fs_abort;
+	s3dw_show(S3DWIDGET(infwin));
+
+}
+
+void window_move(char *path)
+{
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+	if (fp.n!=0) {window_fs_another(); return; }
+	infwin=s3dw_surface_new("Info Window",20,8);
+	s3dw_label_new(infwin,"Sorry, moving is not implemented yet.. :(",1,2);
+	button=s3dw_button_new(infwin,"Too bad",7,5);
+	button->onclick=close_win;
+	s3dw_show(S3DWIDGET(infwin));
+
+}
+/* a small window which counts directories/files and displays the result */
+void window_info(char *path)
+{
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+	char string1[M_DIR];
+	char string2[M_DIR];
+	int b,d,f;
+	char bd[M_DIR];
+	float l;
+	snprintf(string1,M_DIR,"Info for %s",path);
+	fs_approx(path, &f, &d, &b);
+	dotted_int(bd,b);
+	snprintf(string2 ,M_DIR,"%s bytes in %d files and %d Directories",bd,f,d);
+	
+	l=((strlen(string1)>strlen(string2)) ? strlen(string1) :strlen(string2))*0.7;
+	
+	infwin=s3dw_surface_new("Info Window",l,12);
+
+	s3dw_label_new(infwin,string1,1,2);
+	s3dw_label_new(infwin,string2,1,4);
+
+	button=s3dw_button_new(infwin,"OK",l/2-1,6);
+	/* clicking on the button will exit ... */
+	button->onclick=close_win;
+	/* of couse, show it */
+	s3dw_show(S3DWIDGET(infwin));
+}

Modified: trunk/apps/s3dfm/fs.c
===================================================================
--- trunk/apps/s3dfm/fs.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/s3dfm/fs.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,302 @@
+/*
+ * fs.c 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "s3dfm.h"
+#include <stdio.h>	/*  printf() */
+#include <dirent.h>	/* scandir() */
+#include <stdlib.h>	/*  malloc() */
+
+/* we want GNU version of basename */
+#define _GNU_SOURCE 
+#include <string.h>	/*  strlen(), strncmp(), strrchr() */
+#include <libgen.h> /* basename() */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <errno.h>
+
+
+
+
+/* generates the file list */
+filelist *fl_new(char *path)
+{
+	struct dirent **namelist;
+	filelist *fl;
+	int n,i,j;
+	char *name;
+
+	fl=malloc(sizeof(filelist));
+	fl->p=NULL;
+	fl->n=0;
+    n = scandir(path, &namelist, 0, alphasort);
+    if (n <= 2) /* . and .. is always included. */
+	{
+		if (n<0)
+	        perror("scandir");
+	} else {
+		j=0;
+		fl->n=n-2 ; /* ignore . and .. */
+		fl->p=malloc(sizeof(char *)*fl->n);
+		for (i=0;i<n;i++)
+		{
+			name=namelist[i]->d_name;
+			if (!((strcmp(name,".")==0) || (strcmp(name,"..")==0))) /* ignore */
+			{
+				fl->p[j]=malloc(strlen(name)+strlen(path)+2);
+				strcpy(fl->p[j],path);
+				strcat(fl->p[j],"/");
+				strcat(fl->p[j],name);
+				j++;
+			}
+			free(namelist[i]);
+		}
+		if (j!=fl->n)
+		{
+			printf("assertion failed\n");
+			exit(-1);
+		}
+		free (namelist);
+	}
+	return(fl);	
+}
+/* delete the filelist */
+void fl_del(filelist *fl)
+{
+	int i;
+	for (i=0;i<fl->n;i++)
+	{
+		free(fl->p[i]);
+	}
+	free(fl);
+}
+/* approximate the heaviness of a single */
+void fs_approx(char *source, int *files, int *dirs, int *bytes)
+{
+	int sfiles,sdirs,sbytes; 	/* for subdirs */
+	filelist *fl;
+	struct stat s;
+
+	*files=	sfiles=	0;
+	*dirs=	sdirs=	0;
+	*bytes=	sbytes=	0;
+
+/*	printf("start: %d files, %d dirs, %d bytes in %s\n",*files,*dirs,*bytes,source);*/
+	if (-1==stat(source,&s))
+		return;
+/*	printf("%s: %08x (%db)\n",source,s.st_mode,(int)s.st_size);*/
+	if ((s.st_mode&S_IFMT) == S_IFDIR)
+	{
+		
+		fl=fl_new(source);
+		if (fl->n>0)
+			fs_fl_approx(fl,&sfiles,&sdirs,&sbytes);
+		fl_del(fl);
+/*		printf("%d files, %d dirs, %d bytes in %s\n",sfiles,sdirs,sbytes,source);*/
+
+		*files=		sfiles;
+		*bytes+=	sbytes;
+		*dirs=		sdirs;
+		*dirs+=		1;
+	} else 
+		*files=		1;
+	*bytes+=s.st_size;
+/*	printf("end: %d files, %d dirs, %d bytes in %s\n",*files,*dirs,*bytes,source);*/
+}
+/* approximate the heaviness of our source ...*/
+void fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes)
+{
+	int i;
+	int sfiles,sdirs,sbytes; 	/* for subdirs */
+
+	*files=0;
+	*dirs=0;
+	*bytes=0;
+
+	for (i=0;i<fl->n;i++)
+	{
+		fs_approx(fl->p[i],&sfiles,&sdirs,&sbytes);
+		*files+=		sfiles;
+		*dirs+=			sdirs;
+		*bytes+=		sbytes;
+	}
+}
+/* copy a certain file */
+int fs_copy(char *source, char *dest)
+{
+	FILE *fps, *fpd;
+	filelist *fl;
+	struct stat s;
+	char buf[1024];
+	int n;
+	if (-1==stat(source,&s))
+		return(0);
+	switch (s.st_mode&S_IFMT)
+	{
+		case S_IFDIR:
+			fl=fl_new(source);
+		
+			printf("mkdir %s\n",dest);
+			mkdir(dest,0777);
+		
+			fs_fl_copy(fl, dest);
+
+			fl_del(fl);
+			break;
+		case S_IFIFO:
+			printf("link the fifo\n");
+
+			link(source,dest);
+			break;
+		default:
+			printf("atomic copy ... from %s to %s\n", source, dest);
+			if (NULL==(fps=fopen(source,"r"))) return(-1);
+			if (NULL==(fpd=fopen(dest,"w"))) return(-1);
+			/* TODO: overwrite protection etc */
+		
+			while (!feof(fps))
+			{
+				n=fread(buf,1,1024,fps);
+				fwrite(buf,1,n,fpd);
+			}
+			fclose(fps);
+			fclose(fpd);
+
+	}
+	return(0);
+}
+/* copy the source to the destination, destination should be a directory. */
+int fs_fl_copy(filelist *fl, char *dest)
+{
+	int i;
+	int r;
+	char *sdest;
+	char *bname;
+	r=0;
+	for (i=0;i<fl->n;i++)
+	{
+		bname=basename(fl->p[i]);
+		sdest=malloc(strlen(dest)+strlen(bname)+2);
+
+		strcpy(sdest,dest);
+		strcat(sdest,"/");
+		strcat(sdest,bname);
+		r|=fs_copy(fl->p[i],sdest);
+
+		free(sdest);
+	}
+
+	return(r);
+}
+/* recursively unlink a dir or file. */
+int fs_unlink(char *dest)
+{
+	filelist *fl;
+	struct stat s;
+	
+	if (-1==stat(dest,&s))		return(-1);
+	if ((s.st_mode&S_IFMT) == S_IFDIR)
+	{
+		printf("%s is a dir, removing below ...\n",dest);
+		fl=fl_new(dest);
+		if (fs_fl_unlink(fl)) {
+			fl_del(fl);
+			return(-1);
+		} else {
+			fl_del(fl);
+			printf("removing %s\n",dest);
+			if (rmdir(dest)==-1)
+			{
+				perror("fs_fl_unlink(): rmdir()");
+				return(-1);
+			}
+		}
+	} else {
+		if (unlink(dest)==-1)
+		{
+			perror("fs_fl_unlink(): unlink()");
+			return(-1);
+		}
+	}
+	return(0);
+}
+/* remove a lot of files */
+int fs_fl_unlink(filelist *fl)
+{
+	int i,r;
+	r=0;
+	for (i=0;i<fl->n;i++)
+	{
+		printf("-> atomic unlink %s\n",fl->p[i]);
+		r|=fs_unlink(fl->p[i]);
+	}
+	return(r);
+
+}
+int fs_move(char *source, char *dest)
+{
+	if (!rename(source,dest))
+	{
+		switch (errno)
+		{
+			case EXDEV:
+				fs_copy(source,dest);
+				fs_unlink(source);
+				break;
+			default: 
+				perror("fs_move()");
+				return(-1); /* can't help it */
+			
+		}
+	}
+	return(0);	
+}
+
+/* moves the source to the destination */
+int fs_fl_move(filelist *fl, char *dest)
+{
+	int i;
+	int r;
+	char *sdest;
+	char *bname;
+	r=0;
+	for (i=0;i<fl->n;i++)
+	{
+		bname=basename(fl->p[i]);
+		sdest=malloc(strlen(dest)+strlen(bname)+2);
+
+		strcpy(sdest,dest);
+		strcat(sdest,"/");
+		strcat(sdest,bname);
+		r|=fs_move(fl->p[i],sdest);
+
+		free(sdest);
+	}
+
+	return(r);
+
+	return(0);
+}
+
+

Modified: trunk/apps/s3dfm/icon.c
===================================================================
--- trunk/apps/s3dfm/icon.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/s3dfm/icon.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,110 @@
+/*
+ * icon.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "s3dfm.h"
+#include <stdio.h> 	 /*  printf() */
+#include <math.h>	 /*  sin(),cos() */
+#include <string.h>  /*  strlen() */
+/* draws icon i in the block of dir */
+int icon_draw(t_item *dir,int i)
+{
+	float vertices[]={	-1,-0.5,0,
+						-1, 0.5,0,
+						 1, 0.5,0,
+						 1,-0.5,0,
+						-1,-0.5,-1,
+						-1, 0.5,-1,
+						 1, 0.5,-1,
+						 1,-0.5,-1};
+	unsigned long polys[]={
+				1,3,0,0,				2,3,1,0,
+				5,6,2,0,				1,5,2,0,
+				2,6,7,0,				2,7,3,0,
+				0,3,7,0,				0,7,4,0,
+				5,1,0,0,				5,0,4,0	
+				};
+	float len;
+	float d;
+	int dps;
+	printf("icon_draw( %s )\n",dir->list[i].name);
+	dps=ceil(sqrt(dir->n_item)); /* directories per line */
+	/* find position for the new block in our directory box */
+	dir->list[i].dpx = dir->list[i].px=-1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
+	dir->list[i].dpy = dir->list[i].py=0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
+	dir->list[i].dpz = dir->list[i].pz=1.0;
+	dir->list[i].scale = dir->list[i].dscale = (float)1.0/((float)dps);
+	/* create the block */
+	box_dissolve(&(dir->list[i]));
+	dir->list[i].block=s3d_new_object();
+	s3d_push_vertices(dir->list[i].block,vertices,8);
+	d=((int)(((i+(dps+1)%2*(i/dps)))%2))*0.2;
+	switch (dir->list[i].type)
+	{
+		case T_FOLDER:
+			s3d_push_material(dir->list[i].block,
+									0.4-d,0.4-d,0,
+									0.4-d,0.4-d,0,
+									0.4-d,0.4-d,0);
+			break;
+		default:
+			s3d_push_material(dir->list[i].block,
+									0,0,0.5-d,
+									0,0,0.5-d,
+									0,0,0.5-d);
+	};
+	s3d_push_polygons(dir->list[i].block,polys,10);
+	s3d_link(dir->list[i].block,dir->block);
+
+	/* draw and position the string */
+	if (dir->list[i].str==-1)
+	{
+		dir->list[i].str=s3d_draw_string(dir->list[i].name,&len);
+		if (len<2) len=2;
+		dir->list[i].len=len;
+	}
+	else 
+		len=dir->list[i].len;
+	s3d_scale(dir->list[i].str,(float)1.8/len);
+	s3d_translate(dir->list[i].str,-0.9,-0.3,0.1);
+	s3d_rotate(dir->list[i].str,0,0,0);
+	s3d_link(dir->list[i].str,dir->list[i].block);
+	ani_finish(&dir->list[i],-1); /* apply transformation */
+	dir->list[i].disp=D_ICON;
+	return(0);
+}
+int icon_undisplay(t_item *dir)
+{
+	printf("icon_undisplay( %s )\n",dir->name);
+	if (dir->block!=-1)
+	{
+		s3d_del_object(dir->block);
+		dir->block=-1;
+	}
+	if (dir->str!=-1)
+	{
+		s3d_del_object(dir->str);
+		dir->str=-1;
+	}
+	dir->disp=0;
+	return(0);
+}

Modified: trunk/apps/s3dfm/main.c
===================================================================
--- trunk/apps/s3dfm/main.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/s3dfm/main.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,175 @@
+/*
+ * main.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include "s3dfm.h"
+#include <s3dw.h>	 /* s3dw_ani_mate() */
+#include <stdio.h> 	 /*  printf() */
+#include <dirent.h>  /*  dirent */
+#include <stdlib.h>	 /*  malloc() */
+#include <string.h>  /*  strlen(), strncmp(), strrchr() */
+#include <time.h>	/* nanosleep() */
+static struct timespec t={0,33*1000*1000}; 
+t_item root,cam,*focus;
+
+/* save concatting 2 strings, this version takes argument n
+ * as the size of the buffer of dest. */
+char *mstrncat(char *dest, const char *src, int n)
+{
+	int i,j;
+	dest[n-1]=0;						/* for malformed destinations */
+	j=0;
+	for (i=strlen(dest);i<(n-1);i++)
+	{
+		dest[i]=src[j]; 
+		if (dest[i]==0) break;
+		j++;
+	}
+	for (;i<n;i++)
+		dest[i]=0; /* pad the rest with zero */
+	return(dest);
+}
+/* same as strncpy, but have a terminating zero even if
+ * source is too big */
+char *mstrncpy(char *dest, const char *src, int n)
+{
+	strncpy(dest,src,n);
+	dest[n-1]=0;
+	return(dest);
+}
+/* writes the path of dir into *path. path should be of type path[M_DIR] */
+void get_path(t_item *dir, char *path)
+{
+	if (dir->parent!=NULL)
+	{
+		get_path(dir->parent,path);
+		mstrncat(path,dir->name,M_DIR);
+		mstrncat(path,"/",M_DIR);
+	} else
+		mstrncpy(path,dir->name,M_DIR);
+}
+/* find the item to a path, return NULL if not parsed yet */
+t_item *get_item(char *path)
+{
+	char p[M_DIR];
+	char *s,*match;
+	t_item *cur;
+	int i;
+	
+	if (path==NULL) return NULL;
+	if (path[0]=='/')
+	{
+		strncpy(p,path,M_DIR);
+		s=p+1;
+		cur=&root;
+	} else return NULL; /* TODO: also process local paths. right now, we are to lazy */
+	printf("processing rest of string %s\n",s);
+	match=s;
+	while ((s=index(s,'/'))!=NULL) { /* while we have slashes inside */
+		s[0]=0; /* mark the slash with space */
+		s++;	/* move to the next */
+		/* parse ... */
+		printf("looking for a match for %s\n",match);
+		for (i=0;i<cur->n_item;i++)
+			if (0==strcmp(cur->list[i].name,match))
+			{ /* found !! */
+				cur=&(cur->list[i]); /* forward */
+				match=s; /* select next */
+				break;
+			}
+		if (i==cur->n_item) {
+			printf("found no match for %s :(\n",match);
+			return NULL; /* not found */
+		}
+	}
+	return(cur);
+}
+/* finds an item in the tree by oid */
+t_item *finditem(t_item *t, int oid)
+{
+	int i;
+	t_item *f;
+	if (t->block==oid)		return(t);
+	if (t->str==oid)		return(t);
+	if (t->close==oid)		return(t);
+	if (t->select==oid)		return(t);
+	if (t->title==oid)		return(t);
+	if (t->titlestr==oid)	return(t);
+	if (t->type==T_FOLDER)
+		for (i=0;i<t->n_item;i++)
+			if ((f=finditem(&(t->list[i]),oid))!=NULL)
+				return(f);
+	return(NULL);
+}
+/* info packets handler, we're just interested in the cam */
+void object_info(struct s3d_evt *hrmz)
+{
+	struct s3d_obj_info *inf;
+	inf=(struct s3d_obj_info *)hrmz->buf;
+	if ((inf->object==0) && (!ani_onstack(&cam)))
+	{
+		cam.dpx=inf->trans_x;
+		cam.dpy=inf->trans_y;
+		cam.dpz=inf->trans_z;
+	}
+	s3dw_object_info(hrmz);
+}
+void mainloop()
+{
+	ani_mate();
+	s3dw_ani_mate();
+	nanosleep(&t,NULL); 
+}
+int main (int argc, char **argv)
+{
+
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
+	s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
+	s3d_set_callback(S3D_EVENT_KEY,key_handler);
+	if (!s3d_init(&argc,&argv,"s3dfm"))	
+	{
+		s3d_select_font("vera");
+
+		
+		/* set up file system representation */
+		node_init(&root);
+		strncpy(root.name,"/",M_NAME);
+		focus=&root;
+		root.dscale=0.1;
+		root.type=T_FOLDER;
+		root.str=s3d_draw_string(root.name,&root.len);
+		if (root.len<2) root.len=2;
+		parse_dir(&root);
+		box_expand(&root);
+		ani_doit(&root);
+		ani_focus(&root);
+		
+		node_init(&cam); /* a virtual object, just to push the cam throu our animation stack */
+		cam.block=0;
+		
+		
+		s3d_mainloop(mainloop);
+		s3d_quit();
+	}
+	return(0);
+}

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/s3dfm/parse.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,189 @@
+/*
+ * main.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include "s3dfm.h"
+#include <s3dw.h>	 /* s3dw_ani_mate() */
+#include <stdio.h> 	 /*  printf() */
+#include <dirent.h>  /*  dirent */
+#include <stdlib.h>	 /*  malloc() */
+#include <string.h>  /*  strlen(), strncmp(), strrchr() */
+#include <time.h>	/* nanosleep() */
+
+
+/* clear the dirs attributes */
+int node_init(t_item *dir)
+{
+	dir->parent=NULL;
+	dir->list=NULL;
+	dir->n_item=-1;
+
+	dir->block=-1;
+	dir->str=-1;
+	dir->close=-1;
+	dir->select=-1;
+	dir->title=-1;
+	dir->titlestr=-1;
+
+	dir->len=0;
+	dir->disp=0;
+	dir->parsed=0;
+
+	dir->px=root.pz=0.0;
+	dir->dirs_opened=0;
+	dir->type=T_DUNO;
+	dir->px=dir->py=dir->pz=0.0;
+	dir->dpx=dir->dpy=dir->dpz=0.0;
+	dir->scale=dir->dscale=1.0;
+	dir->detached=0;
+
+	return(0);
+}
+int parse_dir(t_item *dir)
+{
+	t_item *list;
+	struct dirent **namelist;
+	int n,i;
+	char *ext,*nstr;
+	char path[M_DIR];
+	char ndir[M_DIR]; 
+	
+	printf("parse_dir( %s )",dir->name);
+/*	if (dir->parsed) return(-1);*/
+	get_path(dir,path);
+/*	printf("scanning %s\n",path);*/
+    n = i = scandir(path, &namelist, 0, alphasort);
+	
+    if (n < 0)
+	{
+        perror("scandir");
+		return(-1);
+	} else {
+		list=malloc(sizeof(t_item)*i);
+		dir->list=list;
+		dir->n_item=n;
+        while(n--) {
+			/* setup kids in the list */
+			node_init(&list[n]);
+			nstr=namelist[n]->d_name;
+			strncpy(list[n].name,nstr,M_NAME);
+ 		    if ((0==strncmp(nstr,".",1)) && (strlen(nstr)==1))
+				list[n].type=T_LOCALDIR;
+			else if (0==strncmp(nstr,"..",strlen(nstr)<2?strlen(nstr):2))
+			   list[n].type=T_BACKDIR;
+			else {
+				ext=strrchr(nstr,'.');
+				strncpy(ndir,path,M_DIR);
+		    	strncat(ndir,namelist[n]->d_name,M_DIR);
+			    if ((namelist[n]->d_type==DT_DIR) ||
+					((namelist[n]->d_type==DT_UNKNOWN) && (opendir(ndir)!=NULL)))
+						list[n].type=T_FOLDER;
+				else 
+				{
+				   if (ext!=NULL)
+				   {
+					   if (0==strncmp(ext,".model",strlen(ext)<4?strlen(ext):4))
+							   list[n].type=T_GEOMETRY;
+					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))
+							   list[n].type=T_MUSIC;
+				   }
+				}
+			}
+			list[n].parent=dir;
+        	free(namelist[n]);
+		}
+		free(namelist);
+		dir->parsed=1;
+   	}
+	return(0);
+}
+void parse_again(t_item *dir)
+{
+	int oldn,redisp;
+	t_item *oldlist;
+	int i,j;
+	oldlist=dir->list;
+	oldn   =dir->n_item;
+	redisp=0;
+	printf("parse_again( %s )\n",dir->name);
+	if (dir->disp==D_DIR)	/* undisplay it later */
+	{ 
+		box_undisplay(dir); 
+		redisp=1; 
+	}
+	parse_dir(dir);
+
+	printf("oldn = %d\n",oldn);
+	if (oldn>0)
+	{
+		/* find old, already displayed contents, and copy the data, or remove them if 
+		 * deleted */
+		
+		for (i=0;i<oldn;i++)
+		{
+			if (oldlist[i].disp == D_DIR)	/* old things expanded as directory */
+			{
+				/* see if it's also in the new list */
+				for (j=0;j<dir->n_item;j++)
+				{
+					if (0==strcmp(oldlist[i].name,dir->list[j].name))
+					{
+						printf("we still have %s - %s (%d,%d) , copy to new list ... \n",dir->list[j].name, oldlist[i].name,j,i);
+						memcpy(&(dir->list[j]),&oldlist[i],sizeof(t_item));
+						break; /* found */
+					}
+				}
+				if (j == dir->n_item) /* not found, collapse it */
+					node_free(&oldlist[i]);
+				else {}/* don't collapse it!! keep as it is */
+			} else node_free(&oldlist[i]);
+		}
+		free(oldlist);
+
+		printf("finished copying old content, redisplay if neccesary\n");
+		if (redisp)
+		{
+			printf("redisplay ... (opened: %d) ", dir->dirs_opened);
+			/* if it was displayed, redisplay it ... */
+			box_expand(dir);
+			printf("done (opened: %d)\n", dir->dirs_opened);
+		}
+	}	
+}
+void node_free(t_item *t)
+{
+	int i;
+	printf("node_free( %s )\n",t->name);
+	switch (t->disp)
+	{
+			case D_DIR:  box_collapse(t,1); /* collapse this and its kids */
+			case D_ICON: icon_undisplay(t);
+	}
+	if (t->n_item>0) {
+		for (i=0;i<t->n_item;i++)
+			node_free(&(t->list[i]));
+		free(t->list);
+	}
+	t->n_item=0;
+}
+

Modified: trunk/apps/s3dgps/s3dgps.c
===================================================================
--- trunk/apps/s3dgps/s3dgps.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/s3dgps/s3dgps.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,395 @@
+/*
+ * s3dgps.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dgps, a gps navigator for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dgps is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dgps is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dgps; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <s3d.h>
+#include <gps.h> 	/* gps_*() */
+#ifdef NMEA_CHANNELS
+#define GPS_NEW
+#endif
+#include <stdio.h> 	/* printf() */
+#include <errno.h>  /* errno */
+#include <stdlib.h>	/* malloc(), free() */
+#include <string.h> /* strlen() */
+#include <math.h>	/* sin(),cos(), M_PI */
+#include <simage.h> /* simage things */
+
+#include <time.h>	/* nanosleep() */
+static struct timespec t={0,33*1000*1000}; /* 30 fps */
+
+
+#define PIXELFACT	2817.947378
+#define PIXELFACTN	281794.7378
+#define BFS			1024
+
+#define ICON_ARROW	0
+
+#define ICON_MAX	1
+
+struct map_t {
+	int lng, lat,scale;
+	char path[BFS];
+	struct map_t *next;
+};
+struct point_t {
+	int lng,lat;
+	char name[BFS];
+	int icon;
+	struct point_t *next;
+};
+
+struct gps_data_t 	*dgps;
+int 				 frame=0;
+struct point_t		 posicon;
+int					 iconlist[ICON_MAX];
+char				*iconnames[]={"objs/arrow.model"};
+
+unsigned char 		*recode_image(unsigned char *data, int nc, int w, int h);
+int 				 load_mapimage(char *path,float lng, float lat, int scale);
+void 				 parse_mapkoords();
+void				 load_icons();
+void 				 show_gpsdata(struct gps_data_t *dgps);
+void				 show_position(struct gps_data_t *dgps);
+void				 calc_position(float lng, float lat, float *x, float *y, float *z);
+
+void mainloop()
+{
+	if ((frame%60)==0)
+	{
+		printf("polling ...\n");
+		if (gps_poll(dgps) < 0) 
+		{
+			printf("read error on server socket\n");
+			s3d_quit();
+			return;
+		}
+		printf("done");
+		printf("calling show_gpsdata");
+		show_gpsdata(dgps);
+	}
+	show_position(dgps);
+	frame++;
+
+	nanosleep(&t,NULL); 
+}
+
+/* a bad 2d-calculation right now ... */
+void				 calc_position(float lng, float lat, float *x, float *y, float *z)
+{
+	*x=-(lng-12.934980)*50;
+	*y=-3;
+	*z=(lat-50.817515)*50;
+/*	*x=sinf(M_PI*lng/180.0)*cosf(M_PI*lat/180.0);
+	*y=cosf(M_PI*lat/180.0);
+	*z=cosf(M_PI*lng/180.0)*cosf(M_PI*lat/180.0);
+	printf("position for lng/lat %f %f, xyz: %f %f %f, sin-lng:%f\n",lng,lat,*x,*y,*z,sinf(M_PI*lng/180.0));*/
+}
+/* recodes the image if it's not in rgba format */
+unsigned char *recode_image(unsigned char *data, int nc, int w, int h)
+{
+	unsigned char *new_block=NULL;
+	int x,y;
+	switch (nc)
+	{
+		case 1:	new_block=malloc(w*h*4);
+			  	for (y=0;y<h;y++)
+					for (x=0;x<w;x++)
+					{
+						 new_block[(y*w+x)*4]=
+						 new_block[(y*w+x)*4+1]=
+						 new_block[(y*w+x)*4+2]=data[y*w+x];
+						 new_block[(y*w+x)*4+3]=255;
+					}
+				puts("grayscale");
+				free(data);
+			   	break;
+		case 2:	new_block=malloc(w*h*4);
+			  	for (y=0;y<h;y++)
+					for (x=0;x<w;x++)
+					{
+						 new_block[(y*w+x)*4]=
+						 new_block[(y*w+x)*4+1]=
+						 new_block[(y*w+x)*4+2]=data[(y*w+x)*2];
+						 new_block[(y*w+x)*4+3]=data[(y*w+x)*2+1];
+					}
+				puts("grayscale+a");
+				free(data);
+				break;
+		case 3:	new_block=malloc(w*h*4);
+			  	for (y=0;y<h;y++)
+					for (x=0;x<w;x++)
+					{
+						 new_block[(y*w+x)*4]=data[(y*w+x)*3];
+						 new_block[(y*w+x)*4+1]=data[(y*w+x)*3+1];
+						 new_block[(y*w+x)*4+2]=data[(y*w+x)*3+2];
+						 new_block[(y*w+x)*4+3]=255;
+					}
+				puts("rgb");
+				free(data);
+				break;
+		case 4:	new_block=data;
+			   	puts("rgba");
+				break;
+	}
+	return(new_block);
+}
+int 				 load_mapimage(char *path,float lng, float lat, int scale)
+{
+	int w,h,nc;
+	float x,y,z;
+	double wr,hr,er;
+	unsigned char *data;
+	int oid=-1;
+	if (simage_check_supported(path))
+	{
+		printf("file %s can be loaded!!\n",path);
+		data=simage_read_image(path,&w,&h,&nc);
+		data=recode_image(data,nc,w,h);
+		oid=s3d_new_object();
+		er=6378.2; /* earth radius */
+		hr=(180*asin(((1.024*scale)/(PIXELFACT*2))/er))/M_PI; /* half height of card in degress */
+		er=6378.2*cos((lat*180)/M_PI); /* radius at latitude position ... */
+		wr=-(180*asin(((1.37*scale)/(PIXELFACT*2))/er))/M_PI; /* half width of card in degress */
+		printf("wr = %f, hr = %f slice radius for wr =%f \n",hr,wr,er);
+		calc_position(lng-wr,lat-hr,&x,&y,&z);
+		y-=scale/10000000.0;
+		s3d_push_vertex(oid,x,y,z);
+		calc_position(lng+wr,lat-hr,&x,&y,&z);
+		y-=scale/10000000.0;
+		s3d_push_vertex(oid,x,y,z);
+		calc_position(lng+wr,lat+hr,&x,&y,&z);
+		y-=scale/10000000.0;
+		s3d_push_vertex(oid,x,y,z);
+		calc_position(lng-wr,lat+hr,&x,&y,&z);
+		y-=scale/10000000.0;
+		s3d_push_vertex(oid,x,y,z);
+		s3d_push_material_a(oid,
+						0.8,	0.0,	0.0	,1.0,
+						1.0,	1.0,	1.0	,1.0,
+						0.8,	0.0,	0.0	,1.0);
+		s3d_push_polygon(oid,0,1,2,0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
+									   1.0,0.0,
+									   1.0,1.0);
+		s3d_push_polygon(oid,0,2,3,0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
+									   1.0,1.0,
+									   0.0,1.0);
+		s3d_push_texture(oid,w,h);		
+		s3d_load_texture(oid,0,0,0,w,h,(unsigned char *)data);
+		free(data);
+		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
+	} else {
+		printf("can't load %s\n",path);
+	}
+	return(oid);
+}
+void load_icons()
+{
+	int i;
+	
+	for (i=0;i<ICON_MAX;i++)
+		iconlist[i]=s3d_import_model_file(iconnames[i]);	
+}
+void show_gpsdata(struct gps_data_t *dgps)
+{
+/*	if (!dgps->online) 
+		printf("WARNING: no connection to gps device\n");
+	printf("[%d] lat/long: [%f|%f], altitude %f\n",frame,dgps->latitude,dgps->longitude,dgps->altitude);
+	printf("speed [kph]: %f",dgps->speed/KNOTS_TO_KPH);
+	printf("used %d/%d satellits\n",dgps->satellites_used,dgps->satellites);
+	switch (dgps->status)
+	{
+		case STATUS_NO_FIX:		printf("status: no fix");break;
+		case STATUS_FIX:		printf("status: fix");break;
+		case STATUS_DGPS_FIX:	printf("status: dgps fix");break;
+	}
+	switch (dgps->mode)
+	{
+		case MODE_NOT_SEEN:	printf("mode: not seen yet\n");break;
+		case MODE_NO_FIX:	printf("mode: no fix\n");break;
+		case MODE_2D:		printf("mode: 2d fix\n");break;
+		case MODE_3D:		printf("mode: 3d fix\n");break;
+	}*/
+}
+int lastfix=0;
+void show_position(struct gps_data_t *dgps)
+{
+	int fix=1;
+	float x,y,z,p;
+#ifdef GPS_NEW
+	if (!dgps->online) 
+		fix=0;
+	switch (dgps->fix.mode)
+	{
+		case MODE_NOT_SEEN:	fix=0;break;
+		case MODE_NO_FIX:	fix=0;break;
+	}
+	if (fix) {
+		calc_position(dgps->fix.longitude,dgps->fix.latitude,&x,&y,&z);
+#else
+	if (!dgps->online) 
+		fix=0;
+	switch (dgps->mode)
+	{
+		case MODE_NOT_SEEN:	fix=0;break;
+		case MODE_NO_FIX:	fix=0;break;
+	}
+	if (fix) {
+		calc_position(dgps->longitude,dgps->latitude,&x,&y,&z);
+#endif
+/*		calc_position(dgps->latitude,dgps->longitude,&x,&y,&z);*/
+		p=sin(M_PI*((2*frame)%180)/180.0);
+/*		if (p<0.0) p*=-1.0;*/
+		s3d_translate(posicon.icon,x,y+p,z);
+		if (!lastfix)
+			s3d_flags_on(posicon.icon,S3D_OF_VISIBLE);
+	}
+	else 
+		if (lastfix)
+			s3d_flags_off(posicon.icon,S3D_OF_VISIBLE);
+	lastfix=fix;
+}
+/*
+static void update(struct gps_data_t *gpsdata, char *message)
+{
+	printf("updating!!");
+}*/
+void parse_mapkoords()
+{
+	FILE *fp;
+	char buf[BFS],*ptr,*sptr,*filename=NULL,c;
+	char path[BFS];
+	char *prefix="/home/dotslash/.s3dgps/";
+	int len;
+	int word;
+	double lng,lat;
+	int i;
+	long scale;
+	lng=lat=0;
+	scale=0;
+	
+	strncpy(path,prefix,BFS);
+	strncpy(path+strlen(path),"map_koord.txt",BFS);
+	if (NULL!=(fp=fopen(path,"r")))
+	{
+		while (!feof(fp))
+		{
+			ptr=buf;
+			/* read one line */
+			while ((ptr<(buf+BFS+2)))
+			{
+				if (!fread(ptr,1,1,fp))
+					break;
+				c=*ptr;
+				if ((c=='\n') || (c=='\0'))
+					break;
+				ptr++;
+			}
+			*ptr='\0';
+			len=strlen(buf);
+			/* now we have one line in the buffer, proably */
+			sptr=buf;
+			word=0;
+			do {
+				ptr=sptr;
+				/* get word */
+				while ((ptr-buf)<len)
+				{
+					c=*ptr;
+					if ((c=='\t') || (c=='\n') || (c==' ') || (c=='\0'))
+					break;
+					ptr++;
+				}
+				*(ptr)='\0';
+				switch (word)
+				{
+					case 0: filename=sptr;break;
+					case 1: lat=strtod(sptr,NULL);break;
+					case 2: lng=strtod(sptr,NULL);break;
+					case 3: scale=strtol(sptr,NULL,10);break;
+				}
+				if (word==3)
+				{
+					strncpy(path,prefix,BFS);
+					strncpy(path+strlen(path),filename,BFS);
+					printf("going to load %s (located at %f %f with scale %d)\n",path,lng,lat,(int)scale);
+/*					if ((scale>1000) && (scale<100000))*/
+					{
+						i=load_mapimage(path,lng,lat,scale);
+						s3d_flags_on(i,S3D_OF_VISIBLE);
+					}
+				}
+				sptr=(ptr+1); /* move to next word */
+				word++;
+			} while ((ptr-buf)<len);
+		}
+		fclose(fp);
+	}
+}
+int main(int argc, char **argv)
+{
+	char *gpshost;
+	char *err_str;
+	if (argc>1)
+		gpshost=argv[1];
+	else 
+		gpshost="localhost";
+	if (!s3d_init(&argc,&argv,"s3dgps")) 
+	{
+		printf("connecting to %s\n",gpshost);
+		dgps=gps_open(gpshost,"2947");
+	    if (dgps==NULL) {
+			switch ( errno ) {
+				case NL_NOSERVICE: 	err_str = "can't get service entry"; break;
+				case NL_NOHOST: 	err_str = "can't get host entry"; break;
+				case NL_NOPROTO: 	err_str = "can't get protocol entry"; break;
+				case NL_NOSOCK: 	err_str = "can't create socket"; break;
+				case NL_NOSOCKOPT: 	err_str = "error SETSOCKOPT SO_REUSEADDR"; break;
+				case NL_NOCONNECT: 	err_str = "can't connect to host"; break;
+				default:             	err_str = "Unknown"; break;
+			}
+			printf("no connection to gpsd\n");
+			fprintf( stderr, "xgps: no gpsd running or network error: %d, %s\n"	, errno, err_str);
+		} else {
+			parse_mapkoords();
+			load_icons();
+			/* init the position */
+			posicon.lng=0;
+			posicon.lat=0;
+			posicon.icon=s3d_clone(iconlist[ICON_ARROW]);
+			posicon.next=NULL;
+			
+			printf("connection established !!\n");
+			printf("query ...\n");
+			gps_query(dgps, "w+x\n");
+			printf("done\n");
+			s3d_mainloop(mainloop);
+			printf("done\n");
+			gps_close(dgps);
+		}
+		s3d_quit(); 
+	}
+	printf("program finished\n");
+	return(0);
+}

Modified: trunk/apps/s3dvt/main.c
===================================================================
--- trunk/apps/s3dvt/main.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/s3dvt/main.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,594 @@
+/*
+ * main.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2002 Alexander Graf <helly at gmx.net>
+ *
+ * This file is part of s3dvt, a 3d terminal emulator for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dvt is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dvt is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dvt; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include "s3dvt.h"
+#include <stdio.h> 		 /*  FILE,NULL */
+#include <unistd.h> 	 /*  read(),write(), sleep(),close() ... */
+#include <errno.h>		 /*  errno() */
+#include <fcntl.h> 		 /*  open() */
+#include <signal.h>		 /*  signal() */
+#include <stdlib.h>		 /*  exit(),getenv(),setenv() */
+#include <sys/ioctl.h> 	 /*  ioctl() */
+#include <pthread.h>	 /*  pthread_create() */
+#include <s3d.h>		 /*  s3d_* */
+#include <s3d_keysym.h>	 /*  key symbols */
+#include <time.h>	/* nanosleep() */
+static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+
+
+static int pid;
+static int term_mode=0;
+
+static int cursor;		/* the object id of the cursor */
+
+static pthread_t term_thread;
+
+#ifdef M_PIPE
+static int mpipe_in[2];
+static int mpipe_out[2];
+#endif
+#ifdef M_PTY
+static int curtty,curpty;
+#endif
+
+#ifdef M_CHAR
+static unsigned int charbuf[256];
+static unsigned int screenbuf[MAX_LINES*MAX_CHARS];
+static char 		last_c[MAX_LINES*MAX_CHARS];
+#endif
+
+#ifdef M_LINE
+static int 			lines[MAX_LINES];
+#endif
+
+void *thread_terminal(void *a)
+{
+	int iscon=1,ret;
+	char buffer[1024];
+	while(iscon) 
+	{
+		switch (term_mode)
+		{
+			case M_PIPE:
+				ret=read(mpipe_out[0], &buffer, 1000);
+				break;
+			case M_PTY:
+				ret=read(curpty, &buffer, 1000);
+				break;
+			default:
+				ret=-1;
+		}
+		if(ret>0) 
+		{ 
+			buffer[ret]='\0';
+			printf("<<<new data(%d bytes)\n", ret);
+			AddChar(buffer);
+		} else {
+			if (ret==-1)
+			{
+				perror("read()");
+				printf("Connection to pty lost (ret=%d)\n",ret); 
+				close(mpipe_in[0]);
+				close(mpipe_out[1]);
+		/* 		close(curpty);  */
+		/* 		close(curtty);  */
+				printf("********CONNECTION TO PTY LOST!*******\n");
+				sleep(1);
+				s3d_quit();
+				exit(0);
+			}
+		}
+    }
+	return(NULL); /* huh?! */
+}
+int pty_init_terminal()
+{
+    int i;
+    char buf[256];
+    char tmpstr[1024];
+    int curtty;
+    int uid=0,gid=0;
+    char exe[]="/bin/bash";
+    char curchar;
+    char *disp;
+    
+    disp=getenv("DISPLAY");
+    uid=getuid();
+    gid=getgid();
+	term_mode=M_PTY;
+    for(curchar='p'; curchar<'z';curchar++) 
+	{
+		for(i=0;i < 16;i++) 
+		{
+			sprintf(buf, "/dev/pty%c%x", curchar, i);
+			curpty=open(buf, O_RDWR);
+			if (curpty >= 0) 
+				goto endloop;
+		}
+    }
+endloop:
+    if(curpty < 0) {
+		printf("Error opening pty\n"); 
+		return 0; 
+	}
+/* 	fnctl(F_SETFL,O_NONBLOCK); */
+	signal(SIGCHLD, SIG_IGN);
+    pid = fork();
+	if(!pid) 
+	{
+	    buf[5]='t';
+	    curtty=open(buf, O_RDWR);
+	    if (curtty < 0) { 
+			printf("Error opening tty\n"); 
+			return 0; 
+		}
+	    setuid(uid);
+	    setgid(gid);
+	    if(setsid()<0) 
+			printf("ERROR (setsid)\n"); 
+	/*     tcflush(curpty, TCIOFLUSH); */
+	    if(ioctl(curtty, TIOCSCTTY, NULL)) 
+			printf("ERROR! (ttyflush)\n");;
+	    dup2(curtty, 0);
+	    dup2(curtty, 1);
+	    dup2(curtty, 2);
+	    sprintf(tmpstr, "%d", MAX_LINES-1);
+	    setenv("LINES", tmpstr, 1);
+	    sprintf(tmpstr, "%d", MAX_CHARS-1);
+	    setenv("COLUMNS", tmpstr, 1);
+	    setenv("TERM", "rxvt", 1);
+	    execl(exe, exe, NULL);
+		sleep(1);
+		printf("that's it, exiting");
+		close(curtty);
+		exit(0);
+	} else if(pid<0) {
+		printf("Cant fork()\n");
+		exit(0);
+	} else {
+    	pthread_create(&term_thread, NULL, thread_terminal, NULL);
+	}
+    return 1;
+}
+/*  terminal.c */
+void term_addchar(char toprint)
+{
+/*    printf("sending: %.3d\n", toprint);*/
+	switch (term_mode)
+	{
+		case M_PIPE:
+			write(mpipe_in[1],&toprint,1);
+			write(mpipe_out[1],&toprint,1);
+			break;
+		case M_PTY:
+			write(curpty, &toprint, 1);
+			break;
+	}
+}
+
+
+int pipe_init_terminal()
+{
+    char buf[256];
+    int uid=0,gid=0;
+    char *exe="/bin/bash";
+    char *args="-i";
+    char *disp;
+
+	term_mode=M_PIPE;
+	if ((pipe(mpipe_in)==-1) || (pipe(mpipe_out)==-1))
+	{
+		printf("pipe failed\n");
+		return(-1);
+	}
+    disp=getenv("DISPLAY");
+    uid=getuid();
+    gid=getgid();
+    pid = fork();
+	if(pid==0) 
+	{  /*  the child */
+	    char tmpstr[1024];
+	    buf[5]='t';
+	    setuid(uid);
+	    setgid(gid);
+	    if(setsid()<0) 
+			printf("ERROR (setsid)\n"); 
+/*     tcflush(curpty, TCIOFLUSH); */
+/*     if(ioctl(curtty, TIOCSCTTY, NULL)) printf("ERROR! (ttyflush)\n");; */
+		setvbuf(stdout,(char*)NULL,_IONBF,0);
+	    dup2(mpipe_in[0], fileno(stdin));
+	    dup2(mpipe_out[1], fileno(stdout));
+	    dup2(mpipe_out[1], fileno(stderr));
+		 /*  close unneded things: */
+		close(mpipe_out[0]); 
+		close(mpipe_in[1]); 
+	    sprintf(tmpstr, "%d", MAX_LINES-1);
+	    setenv("LINES", tmpstr, 1);
+	    sprintf(tmpstr, "%d", MAX_CHARS-1);
+	    setenv("COLUMNS", tmpstr, 1);
+	    setenv("TERM", "rxvt", 1);
+	    execl(exe, exe, args,NULL);
+		printf("that's it, exiting");
+		close(curtty);
+		exit(0);
+   } else if(pid<0) {
+    printf("Cant fork()\n");
+	exit(0);
+   } else {
+	 /*  close unneded things... */
+		close(mpipe_in[0]);
+	    pthread_create(&term_thread, NULL, thread_terminal, NULL);
+   }
+    return 1;
+}
+int init_terminal()
+{
+	int i;
+	for (i=0;i<5;i++)
+		if (pty_init_terminal())  /*  find an open pty. */
+			return(0);
+	return(pipe_init_terminal());  /*  if not, fallback to pipe mode */
+}
+void term_unload()
+{
+	printf("unloading tty!!\n");
+	switch (term_mode)
+	{
+		case M_PTY:
+			write(curpty, '\0', 1);  /*  send an EOF, just in case */
+		    close(curpty);
+		    close(curtty);
+			 /* kill(pid); */
+			break;
+		case M_PIPE:
+			 /*  bash should fade with "broken pipe" */
+			close(mpipe_in[1]);
+			close(mpipe_out[0]);
+			break;
+	}
+}
+#ifdef M_CHAR
+void paintit()
+{
+	int cline;
+	int c;
+	unsigned char ch,och;
+	unsigned int ci;
+	int i,line_end;
+
+	s3d_translate(	cursor,cx*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cy*CS + CS*MAX_LINES/2,0);
+	s3d_scale(		cursor,CS);
+	for(cline=0;cline<MAX_LINES;cline++)
+	{
+		line_end=0;
+		for (c=0;c<MAX_CHARS;c++)
+		{
+			i=cline*MAX_CHARS+c;			 /*  calculate position */
+			if (((ch=line[cline].chars[c].character)!=(och=last_c[i])))
+			{
+				if (screenbuf[i]==-1)
+				{
+					screenbuf[i]=s3d_new_object();
+					s3d_translate(screenbuf[i],c*X_RATIO*CS - CS*X_RATIO*MAX_CHARS/2,-cline*CS + CS*MAX_LINES/2,0);
+					s3d_scale(screenbuf[i],CS);
+					s3d_flags_on(screenbuf[i],S3D_OF_VISIBLE);
+				}
+				if ((ch==0) || (line_end))
+				{	/*  the new character is zero! delete! */
+					line[cline].chars[c].character=0;
+					ci=charbuf[' '];
+					s3d_clone_target(screenbuf[i],ci);
+					line_end=1;
+/* 					printf("-%03d",ch); */
+				} else {
+					ci=charbuf[ch];
+/* 					printf("!%03d",ch); */
+					s3d_clone_target(screenbuf[i],ci);
+				}
+			} else {
+/* 				printf("=%03d",ch); */
+			} 
+			last_c[i]=ch;			
+		}
+/* 		printf("\n"); */
+	}
+	gotnewdata=0;
+}
+#endif
+#ifdef M_LINE
+void paintit()
+{
+	int cline;
+	int oid,c;
+	int len;
+	int changed;
+	char cl[MAX_CHARS];
+	for(cline=0;cline<MAX_LINES;cline++)
+	{
+		len=MAX_CHARS;
+		changed=0;
+		for (c=MAX_CHARS;c>=0;c--)
+		{
+			cl[c]=line[cline].chars[c].character;
+			if (line[cline].chars[c].character!=line[cline].chars[c].last_c)
+			{
+				changed=c+1;
+/*				printf("changed [%d/%d] from %d to %d\n",cline,c,
+								line[cline].chars[c].last_c,
+								line[cline].chars[c].character
+								);*/
+				line[cline].chars[c].last_c=line[cline].chars[c].character;
+			}
+			if (cl[c]==0) len=c;
+		}
+		if (changed)
+		{
+		if (len>0)
+		{
+			printf("[p: line %d [len: %d/changed: %d]\n",cline,len,changed);
+			oid=s3d_draw_string(cl,NULL);
+			s3d_translate(oid,0,-cline,0);
+			if (lines[cline]!=-1) 
+			{
+				s3d_del_object(lines[cline]);
+				lines[cline]=-1;
+			}
+			s3d_flags_on(oid,S3D_OF_VISIBLE);
+			lines[cline]=oid;
+		} else {
+			if (lines[cline]!=-1)
+			{
+				s3d_del_object(lines[cline]);
+				lines[cline]=-1;
+			}
+		}
+		}
+		
+	}
+	gotnewdata=0;
+}
+#endif
+/*
+void paint_chars()
+{
+	char c;
+	int oid;
+	int cline,cchar;
+	for(cline=0;cline<MAX_LINES;cline++)
+	{
+	    for(cchar=0;cchar<MAX_CHARS;cchar++)
+		{
+			c=line[cline].chars[cchar].character;
+/ * 			printf("%02x|",c); * /
+	        if(!islastchar(cline,cchar))
+	         if(line[cline].chars[cchar].character && line[cline].chars[cchar].character != ' ')
+			 {
+/ * 				if (screenbuf[MAX_LINES*MAX_CHARS]!=-1) s3d_del_object(screenbuf[MAX_LINES*MAX_CHARS]); * /
+				oid=s3d_clone(cobjs[c]);
+				s3d_translate(oid,10*cchar,10*cline,0);
+				s3d_flags_on(oid,S3D_OF_VISIBLE);
+				screenbuf[MAX_LINES*MAX_CHARS]=oid;
+			 }
+	    }
+/ * 		printf("\n"); * / 
+	}
+}*/
+void keypress(struct s3d_evt *event)
+{
+	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
+	int key;
+/*	printf("received key: %d\n",key);*/
+	switch (key=keys->keysym)
+	{
+		case S3DK_F1:
+		case S3DK_F2:
+		case S3DK_F3:
+		case S3DK_F4:
+		case S3DK_F5:
+			term_addchar(0x1b);
+			term_addchar('[');
+			term_addchar('1');
+			term_addchar(key-S3DK_F1+'1');
+			break;
+		case S3DK_F6:
+		case S3DK_F7:
+		case S3DK_F8:
+			term_addchar(0x1b);
+			term_addchar('[');
+			term_addchar('1');
+			term_addchar((key-S3DK_F6)+'7');
+			break;
+		case S3DK_F9:
+		case S3DK_F10:
+			term_addchar(0x1b);
+			term_addchar('[');
+			term_addchar('2');
+			term_addchar((key-S3DK_F9)+'0');
+			break;
+		case S3DK_F11:
+		case S3DK_F12:
+			term_addchar(0x1b);
+			term_addchar('[');
+			term_addchar('2');
+			term_addchar((key-S3DK_F11)+'3');
+			break;
+		case S3DK_UP:
+			term_addchar(0x1b);
+			term_addchar('[');
+			term_addchar('A');
+			break;
+		case S3DK_DOWN:
+			term_addchar(0x1b);
+			term_addchar('[');
+			term_addchar('B');
+			break;
+		case S3DK_RIGHT:
+			term_addchar(0x1b);
+			term_addchar('[');
+			term_addchar('C');
+			break;
+		case S3DK_LEFT:
+			term_addchar(0x1b);
+			term_addchar('[');
+			term_addchar('D');
+			break;
+		case S3DK_PAGEUP:
+			term_addchar(0x1b);
+			term_addchar('[');
+			term_addchar('5');
+			term_addchar('~');
+			break;
+		case S3DK_PAGEDOWN:
+			term_addchar(0x1b);
+			term_addchar('[');
+			term_addchar('6');
+			term_addchar('~');
+			break;
+		case S3DK_HOME:
+			term_addchar(0x1b);
+			term_addchar('[');
+			term_addchar('7');
+			term_addchar('~');
+			break;
+		case S3DK_END:
+			term_addchar(0x1b);
+			term_addchar('[');
+			term_addchar('8');
+			term_addchar('~');
+			break;
+		case 13:
+			term_addchar(10);
+			break;
+		default:
+			if ((char)keys->unicode)  /*  \0 is no good idea .. */
+				term_addchar((char)keys->unicode);
+	}
+
+}
+int i=0;
+void mainloop()
+{
+	usleep(10000);
+	nanosleep(&t,NULL); 
+
+	if ((i+=2)>100)
+	{
+		if (i%2)
+		{
+			s3d_flags_on(cursor,S3D_OF_VISIBLE);
+			i=0;
+		}
+		else
+		{
+			s3d_flags_off(cursor,S3D_OF_VISIBLE);
+			i=1;
+		}
+	}
+	if (gotnewdata) {
+/* 		printf("got new data,displaying\n"); */
+		paintit();
+	}
+}
+void stop(struct s3d_evt *event)
+{
+	s3d_quit();
+}
+unsigned int draw_background()
+{
+	unsigned int b;
+	b=s3d_new_object();
+	s3d_push_vertex(b,-MAX_CHARS/2*X_RATIO*CS	,CS	+CS*MAX_LINES/2		,-0.01);
+	s3d_push_vertex(b, MAX_CHARS/2*X_RATIO*CS	,CS	+CS*MAX_LINES/2		,-0.01);
+	s3d_push_vertex(b, MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
+	s3d_push_vertex(b,-MAX_CHARS/2*X_RATIO*CS	,	-CS*MAX_LINES/2		,-0.01);
+	s3d_push_material_a(b,0.5,0.5,0.5,0.7,
+						  1,1,1,0.7,
+						  0,0,0,0.7);
+	s3d_push_polygon(b,1,2,0,0);
+	s3d_push_polygon(b,2,3,0,0);
+	s3d_flags_on(b,S3D_OF_VISIBLE);
+	return(b);
+}
+void chars_s3d_init()
+{
+#ifdef M_CHAR
+	char c[2];
+	c[1]='\0';
+	for (i=0;i<128;i++)
+	{
+		c[0]=i;
+		charbuf[i]=s3d_draw_string(c,NULL);
+	}
+	for (i=128;i<256;i++)
+	{
+		charbuf[i]=s3d_new_object();
+	}
+	cursor=s3d_new_object();
+	s3d_clone_target(cursor,charbuf['_']);
+#endif
+}
+void chars_init()
+{
+#ifdef M_CHAR
+	int x,y;
+	for (y=0;y<(MAX_LINES);y++)
+	for (x=0;x<(MAX_CHARS);x++)
+	{
+		line[y].chars[x].character=line[y].chars[x].character=0;
+		i=y*MAX_CHARS+x;
+		screenbuf[i]=-1;
+		last_c[i]=0;
+	}
+#endif
+#ifdef M_LINE
+	int i;
+	for (i=0;i<MAX_LINES;i++)
+		lines[i]=-1;
+#endif
+}
+int main (int argc, char **argv)
+{
+	unsigned int b;
+	chars_init();
+   	init_terminal();
+	s3d_set_callback(S3D_EVENT_QUIT,stop);
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK,stop);
+	s3d_set_callback(S3D_EVENT_KEY,keypress);
+
+	if (!s3d_init(&argc,&argv,"s3dvt"))	
+	{
+		if (s3d_select_font("vera"))
+		{
+			printf("font not found");
+			exit(-1);
+		}
+		b=draw_background();
+		chars_s3d_init();
+		s3d_mainloop(mainloop);
+		s3d_quit();
+	}
+	term_unload();
+	return(0);
+}

Modified: trunk/apps/s3dvt/terminal.c
===================================================================
--- trunk/apps/s3dvt/terminal.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/apps/s3dvt/terminal.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,513 @@
+/*
+ * terminal.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ * Copyright (C) 2002 Alexander Graf <helly at gmx.net>
+ *
+ * This file is part of s3dvt, a 3d terminal emulator for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dvt is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dvt is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dvt; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include "s3dvt.h"
+#include <stdio.h> 		 /*  NULL,perror() */
+#include <string.h>		 /*  memcpy() */
+#include <stdlib.h>		 /*  atoi() */
+#define MOVE_RIGHT 	1
+#define MOVE_LEFT 	2
+#define MOVE_UP	 	3
+#define MOVE_DOWN 	4
+
+
+int cx=0,cy=0;
+
+int gotnewdata=1;
+t_line line[MAX_LINES+1];
+static int isansi=0;
+static int isansi2=0;
+
+static int bottom=MAX_LINES-1;
+static int top=0;
+
+static int curfgcolor=DEFAULT_FGCOLOR;
+static int curbgcolor=DEFAULT_BGCOLOR;
+
+void move_all_lines_up()
+{
+    t_line *pfirstline=(t_line*)&line;
+    t_line *psecondline=(t_line*)&line+1;
+    t_line tmpline[MAX_LINES];
+    memcpy(&tmpline, psecondline, (MAX_LINES-1)*sizeof(struct line_struct));
+    memcpy(pfirstline, &tmpline, (MAX_LINES-1)*sizeof(struct line_struct));
+}
+
+void clear_char(int lineid, int charid)
+{
+    line[lineid].chars[charid].character=0;
+    line[lineid].chars[charid].fgcolor=DEFAULT_FGCOLOR;
+    line[lineid].chars[charid].bgcolor=DEFAULT_BGCOLOR;
+}
+
+void clear_line(int lineid)
+{
+    int i;
+    for(i=0;i<MAX_CHARS;i++)
+		clear_char(lineid, i);
+}
+
+void clear_line_after_lastchar()
+{
+    int i;
+    for(i=cx;i<MAX_CHARS;i++) 
+		clear_char(cy, i);
+}
+
+t_line *line_is_full()
+{
+    t_line *pcurline=(t_line*)&line+cy;
+    cy++;
+    if (cy>=MAX_LINES) {       /*  damn it ... our display is filled ... let's move everything upwards */
+		cy=MAX_LINES-1;
+		pcurline=(t_line*)&line+cy;
+        move_all_lines_up();
+        clear_line(cy);
+		gotnewdata=1;
+    } else {
+        pcurline=(t_line*)&line+cy;
+    }
+	cx=0;
+    return pcurline;
+}
+
+void add_char_append(char toappend)
+{
+    int shouldinc=1;
+    t_line *pcurline=(t_line*)&line+cy;
+    if (cx==MAX_CHARS-1)
+	{ 
+		pcurline=line_is_full(); 
+		shouldinc=0; 
+	}  /*  our line is full */
+    pcurline->chars[cx].character=toappend;
+    pcurline->chars[cx].fgcolor=curfgcolor;
+    pcurline->chars[cx].bgcolor=curbgcolor;
+    if(shouldinc) 
+		cx++;
+}
+
+void backspace()
+{
+    if(cx>0)
+		cx--;
+    else 
+		cx=0;
+}
+
+void endansi()
+{
+    printf(" [/ANSI(%d)]\n", isansi2);
+    isansi=0;
+    isansi2=0;
+}
+
+/*
+              Parameter                              Parameter Meaning                                     
+	      
+	      0                                      Attributes off                                                                                      
+	      1                                      Bold or increased intensity                                                                                       
+	      4                                      Underscore                                                                                            
+	      5                                      Blink                                                                                                     
+	      7                                      Negative (reverse) image                                                                           
+*/	      
+
+void ansi_change_graphic(char **args)
+{
+    int curcol;
+    int i;
+    
+    if (args[0][0]=='\0') 
+	{
+		args[0][0]='0';
+		args[0][1]='\0';
+	}
+    
+    for(i=0;i<5;i++)
+	{
+		if(args[i][0])
+		{
+		    curcol=atoi(args[i]);
+			
+			switch(curcol)
+			{
+			    case 0:
+					curbgcolor=DEFAULT_BGCOLOR;
+					curfgcolor=DEFAULT_FGCOLOR;
+					break;
+			    case 1:	 /*  Bold or increased intensity */
+			    case 4:	 /*  Underscore */
+			    case 5:	 /*  Blink */
+			    case 7:	 /*  Negative (reverse) image */
+			    case 10:	 /*  primary font */
+			    case 11:	 /*  alternate font */
+					break;
+				case 30:
+				case 31:
+				case 32:
+				case 33:
+				case 34:
+				case 35:
+				case 36:
+				case 37:
+					curfgcolor=curcol-30;
+					break;
+			    case 39:
+					curbgcolor=DEFAULT_FGCOLOR;
+					break;
+				case 40:
+				case 41:
+				case 42:
+				case 43:
+				case 44:
+				case 45:
+				case 46:
+				case 47:
+					curbgcolor=curcol-40;
+					break;
+	
+			    case 49:
+					curbgcolor=DEFAULT_BGCOLOR;
+					break;
+	
+			    default:
+					printf("*** don't know color-code %d\n", curcol);
+					break;
+		    }
+		}
+    }
+}
+void move_up_x_lines(char *arg)
+{
+    t_line *pfirstline;
+    t_line *psecondline;
+    t_line tmpline[MAX_LINES];
+    int amount;
+    int i;
+    
+    if(arg[0]) amount=atoi(arg); else amount=0;
+    
+    printf("moving up %d lines", amount);
+    
+    for(i=0;i<amount;i++)
+	{
+    
+		pfirstline=(t_line*)&line+cy;
+		psecondline=pfirstline+1;
+    
+		memcpy(&tmpline, psecondline, (bottom-top)*sizeof(struct line_struct));
+		memcpy(pfirstline, &tmpline,  (bottom-top)*sizeof(struct line_struct));
+    
+    }
+}
+
+void move_down_x_lines(char *arg)
+{
+    t_line *pfirstline;
+    t_line *psecondline;
+    t_line tmpline[MAX_LINES];
+    int amount;
+    int i;
+    
+    if(arg[0]) amount=atoi(arg); else amount=0;
+    
+    printf("moving down %d lines", amount);
+    
+    for(i=0;i<amount;i++)
+	{
+		pfirstline=(t_line*)&line+cy;
+		psecondline=pfirstline+1;
+    
+		memcpy(&tmpline, pfirstline, (bottom-top)*sizeof(struct line_struct));
+		memcpy(psecondline, &tmpline,  (bottom-top)*sizeof(struct line_struct));
+    }
+}
+void delete_x_letters(char *arg1)
+{
+    int tmpint;t_line *pcurline;int i;
+	if(arg1[0]) tmpint=atoi(arg1);
+	else	    tmpint=1;
+	pcurline=(t_line*)&line+cy;
+	if (tmpint+cx>MAX_CHARS) 
+		tmpint=MAX_CHARS-cx;
+	for(i=cx;i<cx+tmpint;i++)
+	    clear_char(cy,i);
+}
+void move_x_letters(int mode, char *arg1)
+{
+    int tmpint;t_line *pcurline;int i;
+	if(arg1[0])
+	    tmpint=atoi(arg1);
+	else
+	    tmpint=1;
+	pcurline=(t_line*)&line+cy;
+	switch(mode) {
+	    case MOVE_RIGHT:
+	        for(i=0;i<tmpint;i++)
+			{
+/*	    	    pcurline->nextchar++; 
+				lastchar++;*/
+				cx++;
+		    	if (cx==MAX_CHARS) 
+					pcurline=line_is_full();  /*  our line is full */
+			}
+			break;
+	    case MOVE_LEFT:
+	        for(i=0;i<tmpint;i++)
+			{
+				cx--;
+			    if(cx==-1) 
+				{ 
+					cy--; 
+					pcurline=(t_line*)&line+cy; 
+					cx=MAX_CHARS-1; 
+				}  /*  need to go up one line */
+			}
+			break;
+	    case MOVE_UP:
+			cy--;
+			break;
+	    case MOVE_DOWN:
+			line_is_full();
+			break;
+	    default:
+			break;
+	}
+}
+void remove_beginning_from_curpos()
+{
+    int i,j=cx;
+    for(i=cy;i<MAX_LINES;i++) {
+	for(;j<MAX_CHARS;j++){
+	    clear_char(i,j);
+	}
+	j=0;
+    }
+}
+
+int parseansi(char curchar)
+{
+	static char arg1[16]="";
+	static char arg2[16]="";
+	static char arg3[16]="";
+	static char arg4[16]="";
+	static char arg5[16]="";
+	static char curindex=0;
+	static char curarg=0;
+	static char *args[]={arg1,arg2,arg3,arg4,arg5};
+	/* 	static char *args[]={&arg1,&arg2,&arg3,&arg4,&arg5}; */
+	    printf("%c", curchar);
+	switch (isansi2)
+	{
+	case 1:
+		switch(curchar)
+		{
+		    case '0':
+		    case '1':
+		    case '2':
+		    case '3':
+		    case '4':
+		    case '5':
+		    case '6':
+		    case '7':
+		    case '8':
+		    case '9':  /*  we got an argument */
+				args[(int)curarg][(int)curindex]=curchar;
+				curindex++; 
+				args[(int)curarg][(int)curindex]='\0';
+				break;
+		    case ';':  /*  some arg is finished */
+				curarg++; 
+				curindex=0; 
+				args[(int)curarg][0]='\0';
+				break;
+		    case 'J':  /*  remove beginning from current cursor to end of screen */
+				remove_beginning_from_curpos();
+				gotnewdata=1;
+				break;
+		    case 'K':  /*  remove everything in line beginning from lastchar */
+				clear_line_after_lastchar();
+				break;
+		    case 'H':  /*  move to position x=arg1 y=arg2 */
+				if(arg1[0]) cy=atoi(arg1)-1; 
+					else 	cy=0;
+				if(arg2[0]) cx=atoi(arg2)-1; 
+					else 	cx=0;
+				break;
+		    case 'G':  /*  move to position x=arg1 y=MAX */
+				if(arg1[0]) cx=atoi(arg1)-1; else cx=-1;
+				cy=bottom-1;
+				break;
+		    case 'd':  /*  move to position x=MAX y=arg1 */
+				if(arg1[0]) cy=atoi(arg1)-1; else cy=0;
+				cy=top+cy;
+				cx=MAX_CHARS-1;
+				break;
+		    case 'm':  /*  change graphic */
+				ansi_change_graphic(args);
+				break;
+		    case 'M':  /*  Move memory in range ('r') one uo */
+				move_up_x_lines(arg1);
+				break;
+		    case 'L':  /*  Move memory in range ('r') one down */
+				move_down_x_lines(arg1);
+				break;
+		    case 'l':
+	/*		RM -- Reset Mode
+			
+			ESC [ Ps ; Ps ; . . . ; Ps l                                                                                                          default value: none
+			
+			Resets one or more VT100 modes as specified by each selective parameter in the parameter string. Each mode to be reset is specified by a separate
+			parameter. [See Set Mode (SM) control sequence]. (See Modes following this section).*/
+			
+			 /*  mc only resets the '4' !?! => IRM (Insert/Replacement-Mode) */
+			 /*  perhaps Set Cursor to Block mode ? */
+				break;
+			case 'r':  /*  define scroll-range  */
+				if(arg1[0]) top=atoi(arg1); else top=0;
+				if(arg2[0]) bottom=atoi(arg2); else bottom=0;
+				cy=0; 
+				cx=0;
+				break;
+			case 'a':
+			case 'A':  /*  move x letters up */
+				move_x_letters(MOVE_UP, arg1);	break;
+			case 'B':  /*  move x letters down */
+				move_x_letters(MOVE_DOWN, arg1);	break;
+			case 'C':  /*  move x letters right */
+				move_x_letters(MOVE_RIGHT, arg1);	break;
+			case 'D':  /*  move x letters left */
+				move_x_letters(MOVE_LEFT, arg1);	break;
+			case 'P':  /*  delete x letters */
+				delete_x_letters(arg1);	break;
+			case '?':
+				isansi2=4;
+				return 0;
+			default:
+				printf("***unknown***");
+		}
+		if(!((curchar>='0' && curchar<='9') || curchar==';'))
+		{  /*  clean our args */
+			args[0][0]='\0';
+			args[1][0]='\0';
+			args[2][0]='\0';
+			args[3][0]='\0';
+			args[4][0]='\0';
+			curindex=0;
+			curarg=0;
+			endansi();
+		} 
+		break;
+	case 0:
+		switch(curchar)
+		{
+		    case '[': isansi2=1; break;
+		    case '(': isansi2=2; break;
+		    case ')': isansi2=3; break;
+		    case ']': isansi2=5; break;
+		    default:
+			endansi();
+			break;
+		}
+		break;
+	case 4:
+		if (curchar>'9' || curchar<'0') 
+			endansi();
+		break;
+	case 5:
+		if(curchar==7) endansi(); /* FIXME: Window Title*/
+		break;
+	default:
+		endansi();
+		break;
+    }
+	return(0);
+}
+
+void AddChar(char *_toadd)
+{
+    char *toadd;
+    char curchar;
+
+    for(toadd=_toadd;toadd[0];toadd++) 
+	{
+		curchar=toadd[0];
+	/*	printf("%.3d (", curchar);*/
+		if(isansi) 
+			parseansi(curchar); 
+		else
+		{
+			switch(curchar) 
+			{
+			case 7:
+			    printf("<BEEP>\n");
+			    break;
+			case 8:
+			    printf("<BS>\n");
+			    backspace();
+			    break;
+			case 27:
+			     /*  ANSI */
+			    printf("<ESC>[ANSI] ");
+			    isansi=1;
+			    break;
+			case 10:
+			    printf("<LF>\n");/* get onto the next line */
+			    line_is_full();
+			    break;
+			case 13:
+			    printf("<CR>\n");/* carriage return, get back */
+				if (cx==MAX_CHARS-1) 
+					line_is_full();
+				cx=0;
+			    break;
+			default:
+				if ((curchar>=32) && (curchar<127))
+				{
+			/*	    printf("%c", curchar);*/
+				    add_char_append(curchar);
+				}
+			    break;
+		    }
+/*	printf(")\n");*/
+		}
+    }
+    gotnewdata=1;
+}
+void init_line()
+{
+    int i;
+    for(i=0;i<MAX_LINES;i++){
+		clear_line(i);
+    }
+}
+void term_addstring(char *toprint)
+{
+    char *ns;
+    for(ns=toprint;ns[0];ns++)
+	{
+		term_addchar(ns[0]);
+    }  /*  better method */
+}

Modified: trunk/example/filebrowser.c
===================================================================
--- trunk/example/filebrowser.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/filebrowser.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,245 @@
+/*
+ * filebrowser.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+
+#include <s3d.h>
+#include <stdio.h> 	 /*  printf() */
+#include <dirent.h>  /*  dirent */
+#include <stdlib.h>	 /*  malloc() */
+#include <string.h>  /*  strlen(), strncmp(), strrchr() */
+#include <unistd.h>	 /*  chdir() */
+#include <math.h>	 /*  sin(),cos() */
+#include <time.h>	/* nanosleep() */
+static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+
+#define T_DUNO		0
+#define T_LOCALDIR	1
+#define T_BACKDIR	2
+#define T_FOLDER	3
+#define T_GEOMETRY	4
+#define T_MUSIC		5
+#define	T_MOVIE		6
+
+#define M_DIR		512
+#define M_NAME		256
+int folder,geometry,mp3,movie,duno,dot,dotdot;
+struct t_item {
+	int icon_oid, descr_oid, pie_oid;
+	char name[M_NAME];
+	int type;
+};
+struct t_item *item;
+int n_item=0;
+int display_dir(char *dir, int depth, int  posx, int posy, int posz)
+{
+	struct dirent **namelist;
+	int n,i;
+	int  px,py,pz;
+	char *ext;
+	char *nstr;
+	float alpha,al,radius,f;
+	char ndir[M_DIR+1];
+	if (n_item)
+	{
+		printf("freeing %d old items\n",n_item);
+		for (i=0;i<n_item;i++)
+		{
+			printf("deleting %d and %d\n",item[i].icon_oid,	item[i].descr_oid);
+			s3d_del_object(item[i].descr_oid);
+			s3d_del_object(item[i].icon_oid);
+			s3d_del_object(item[i].pie_oid);
+		}
+		free(item);
+		
+	}
+    n = i = scandir(dir, &namelist, 0, alphasort);
+    if (n < 0)
+	{
+        perror("scandir");
+		return(-1);
+	}
+    else {
+		item=malloc(sizeof(struct t_item)*i);
+		n_item=i;
+        while(n--) {
+			item[n].type=T_DUNO;
+			nstr=namelist[n]->d_name;
+			strncpy(item[n].name,nstr,M_NAME);
+ 		    if ((0==strncmp(nstr,".",1)) && (strlen(nstr)==1))
+				item[n].type=T_LOCALDIR;
+			else if (0==strncmp(nstr,"..",strlen(nstr)<2?strlen(nstr):2))
+			   item[n].type=T_BACKDIR;
+			else {
+				ext=strrchr(nstr,'.');
+			    strncpy(ndir,dir,M_DIR);
+				ndir[M_DIR]=0;		/* just in case */
+			    strncat(ndir,"/",M_DIR-strlen(ndir));
+		    	strncat(ndir,namelist[n]->d_name,M_DIR-strlen(ndir));
+/* 				printf("displaying %s\n",ndir); */
+			    if ((namelist[n]->d_type==DT_DIR) ||
+					((namelist[n]->d_type==DT_UNKNOWN) && (opendir(ndir)!=NULL)))
+					item[n].type=T_FOLDER;
+				else 
+				{
+				   if (ext!=NULL)
+				   {
+					   if (0==strncmp(ext,".model",strlen(ext)<4?strlen(ext):4))
+							   item[n].type=T_GEOMETRY;
+					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))
+							   item[n].type=T_MUSIC;
+					   else if (0==strncmp(ext,".mpg",strlen(ext)<4?strlen(ext):4))
+							   item[n].type=T_MOVIE;
+
+				   }
+				}
+			}
+			switch (item[n].type)
+			{
+				case T_LOCALDIR:   	item[n].icon_oid=s3d_clone(dot);break;
+				case T_BACKDIR:   	item[n].icon_oid=s3d_clone(dotdot);break;
+				case T_FOLDER:   	item[n].icon_oid=s3d_clone(folder);
+									break;
+				case T_GEOMETRY:   	item[n].icon_oid=s3d_clone(geometry);break;
+				case T_MUSIC:	   	item[n].icon_oid=s3d_clone(mp3);break;
+				case T_MOVIE:		item[n].icon_oid=s3d_clone(movie);break;
+				default:   			printf("don't know type, defaulting to duno %d...\n",duno);
+									item[n].icon_oid=s3d_clone(duno);break;
+			}
+
+			px=posx;py=posy;pz=posz;
+			alpha=((360.0*n)/((float)i));
+			radius=((n_item*10)/(M_PI*4));
+			if (n_item<5)
+				radius=((50)/(M_PI*4));
+			else
+				radius=((n_item*10)/(M_PI*4));
+			px=posx-sin(alpha*M_PI/180.0)*radius;
+			pz=posy;
+			pz=posz-cos(alpha*M_PI/180.0)*radius;
+
+			item[n].pie_oid=s3d_new_object();
+			s3d_push_vertex(item[n].pie_oid,0,-2,0);
+			al=((360.0*(n-0.5))/((float)i));
+			s3d_push_vertex(item[n].pie_oid,		
+						posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
+			al=((360.0*(n+0.5))/((float)i));
+			s3d_push_vertex(item[n].pie_oid,		
+						posx-sin(al*M_PI/180.0)*radius,-2,posz-cos(al*M_PI/180.0)*radius);
+			
+			f=1.0-0.05*(n%2);
+			switch (item[n].type)
+			{
+				case T_LOCALDIR:s3d_push_material(item[n].pie_oid,		0,f,0,			0.5,0.5,0.5,		f,f,f);		break;
+				case T_BACKDIR:	s3d_push_material(item[n].pie_oid,		0,f/2,0,		0.5,0.5,0.5,		f,f,f);		break;
+				case T_FOLDER:	s3d_push_material(item[n].pie_oid,		f,f,0,			0.5,0.5,0.0,		f,f,1);		break;
+				default:		s3d_push_material(item[n].pie_oid,		f,f,f,			0.5,0.5,0.5,		f,f,f);		break;
+			}
+			s3d_push_polygon(item[n].pie_oid,	0,2,1,	0);
+
+			s3d_push_vertex(item[n].pie_oid,pz,-2,0);
+			s3d_translate(item[n].icon_oid,px,py,pz);
+			s3d_rotate(item[n].icon_oid,0,alpha,0);
+		    s3d_flags_on(item[n].icon_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		    s3d_flags_on(item[n].pie_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			item[n].descr_oid=s3d_draw_string(nstr,NULL);
+			s3d_link(item[n].descr_oid,item[n].icon_oid);
+			s3d_translate(item[n].descr_oid,-1,-2,0); 
+/* 			r=s3d_get_radius(p); */
+/* 			s3d_scale(p,1.0/r,1.0/r,1.0/r); */
+		    s3d_flags_on(item[n].descr_oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+            printf("%s [%d]\n", nstr,namelist[n]->d_type);
+			printf("string %d linked to %d\n",item[n].descr_oid,item[n].icon_oid);
+        	free(namelist[n]);
+        }
+		free(namelist);
+   	}
+	return(0);
+}
+
+void object_click(struct s3d_evt *evt)
+{
+	int i,oid;
+	char execstr[256];
+	oid=(int)*((unsigned long *)evt->buf);
+	printf("!!!!!!!!! clicked object %d\n",oid);
+	for (i=0;i<n_item;i++)
+	{
+		if (((oid==item[i].icon_oid) || (oid==item[i].descr_oid)) ||
+			(oid==item[i].pie_oid) )
+		{
+			switch (item[i].type)
+			{
+				case T_BACKDIR:
+				case T_FOLDER:
+				case T_LOCALDIR:
+						printf("going into %s\n",item[i].name);
+						chdir(item[i].name);
+						display_dir(".",0,0,0,0);
+						return;
+						break;
+				case T_GEOMETRY:
+						printf("loading geometry %s\n",item[i].name);
+						snprintf(execstr,256,"modelloader \"%s\"&\n",item[i].name);
+						system(execstr);
+						return;
+						break;
+				case T_MOVIE:
+						printf("playing %s\n",item[i].name);
+						snprintf(execstr,256,"mplayer -vo s3d \"%s\"&\n",item[i].name);
+						system(execstr);
+						return;
+						break;
+
+						
+			}
+		}
+	}
+}
+void mainloop()
+{
+	nanosleep(&t,NULL); 
+}
+int main (int argc, char **argv)
+{
+	int i;
+	if (!s3d_init(&argc,&argv,"filebrowser"))	
+	{
+		i=0;
+		 /*  load the object files */
+		folder=s3d_import_model_file("objs/folder.3ds");
+		geometry=s3d_import_model_file("objs/geometry.3ds");
+		mp3=s3d_import_model_file("objs/notes.3ds");
+		movie=s3d_import_model_file("objs/film.3ds");
+		duno=s3d_import_model_file("objs/duno.3ds");
+		dot=s3d_import_model_file("objs/dot.3ds");
+		dotdot=s3d_import_model_file("objs/dotdot.3ds");
+		s3d_select_font("vera");
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
+		display_dir(".",0,0,0,0);
+		s3d_mainloop(mainloop);
+		s3d_quit();
+	}
+	return(0);
+}

Modified: trunk/example/hudtest.c
===================================================================
--- trunk/example/hudtest.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/hudtest.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,51 @@
+/*
+ * hudtest.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+#include <s3d.h>
+#include <unistd.h>  /*  sleep() */
+#include <stdio.h>  /*  printf() */
+void mainloop()
+{
+	sleep(1);
+}
+int main(int argc, char **argv)
+{
+	int o,m;
+	if (!s3d_init(&argc,&argv,"hud-test"))
+	{
+		if (s3d_select_font("vera"))
+			printf("font not found\n");
+		o=s3d_draw_string("hud-test",NULL);
+		m=s3d_import_model_file("objs/star.3ds");
+		s3d_translate(o,0,0,-5);
+		s3d_link(o,0);
+		s3d_flags_on(o,S3D_OF_VISIBLE);
+		s3d_flags_on(m,S3D_OF_VISIBLE);
+		s3d_mainloop(mainloop);
+		s3d_quit();
+	}
+	return(0);
+
+}

Modified: trunk/example/katze.c
===================================================================
--- trunk/example/katze.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/katze.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,91 @@
+/*
+ * katze.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+
+#include <s3d.h>
+#include <math.h>	/* sin() */
+#include <time.h>	/* nanosleep() */
+static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+
+int a;
+int rot_point,body,legfr,legbr,legfl,legbl,tail;
+
+void mainloop()
+{
+	float pos;
+	a=(a+2)%360;
+	pos=sin((5*a*M_PI)/180)*20;
+	s3d_rotate(legfr,0,90,180+pos);
+	s3d_rotate(legfl,0,90,180-pos);
+	s3d_rotate(legbr,0,0,180+pos);
+	s3d_rotate(legbl,0,0,180-pos);
+
+	s3d_rotate(tail,0,30,110+pos);
+	s3d_rotate(rot_point,0,-a,0);
+	nanosleep(&t,NULL); 
+}
+int main(int argc, char **argv)
+{
+	if (!s3d_init(&argc,&argv,"running cat"))
+	{
+			
+		rot_point=s3d_new_object();
+		body=s3d_import_model_file("objs/katze_body.3ds");
+		legfr=s3d_import_model_file("objs/katze_leg.3ds");
+		tail=s3d_import_model_file("objs/katze_tail.3ds");
+		legfl=s3d_clone(legfr);
+		legbl=s3d_clone(legfr);
+		legbr=s3d_clone(legfr);
+		s3d_translate(legfl,2.3,1.0,0.5);
+		s3d_translate(legfr,0,1.0,0.2);
+		s3d_translate(legbl,-1.2,1.0,-1.8);
+		s3d_translate(legbr,-1.2,1.0,0.0);
+		s3d_translate(tail,-1.6,1.6,-0.8);
+		s3d_translate(body,1.3,0.0,-1.3);
+		s3d_link(legfr,body);
+		s3d_link(legfl,body);
+		s3d_link(legbr,body);
+		s3d_link(legbl,body);
+		s3d_link(tail,body);
+		s3d_link(body,rot_point);
+/*		s3d_link(oid_foot,oid_head);
+ *		s3d_link(oid_middle,oid_head);
+ *		s3d_translate(oid_head,0,4,0);
+		
+ *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
+ *		s3d_translate(oid_foot,0,-3.5,0); */
+		
+
+		s3d_flags_on(body,S3D_OF_VISIBLE);
+		s3d_flags_on(legfr,S3D_OF_VISIBLE);
+		s3d_flags_on(legfl,S3D_OF_VISIBLE);
+		s3d_flags_on(legbr,S3D_OF_VISIBLE);
+		s3d_flags_on(legbl,S3D_OF_VISIBLE);
+		s3d_flags_on(tail,S3D_OF_VISIBLE);
+		s3d_mainloop(mainloop);
+		s3d_quit();
+	}
+	return(0);
+}

Modified: trunk/example/linetest.c
===================================================================
--- trunk/example/linetest.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/linetest.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,95 @@
+/*
+ * linetest.c
+ * 
+ * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+#include <s3d.h>
+#include <stdio.h>  /*  NULL*/
+#include <unistd.h> /* sleep() */
+int i;
+int o;
+void stop(struct s3d_evt *evt)
+{
+	s3d_quit();
+}
+
+void mainloop()
+{
+	i=(i+1)%2;
+	if (i)
+	{
+		s3d_pep_vertex(o,1,-2,0);
+		s3d_pep_line(o,0,2,3);
+	}
+	else
+	{
+		s3d_pep_vertex(o,1,-1,0);
+		s3d_pep_line(o,0,1,0);
+
+	}
+/* 	printf("now it's %s\n",time_str); */
+	sleep(1);
+
+}
+int main (int argc, char **argv)
+{
+	i=0;
+	if (!s3d_init(&argc,&argv,"linetest"))	
+	{
+		o=s3d_new_object();
+		
+		s3d_push_material(o,
+						1,0,0,
+						1,0,0,
+						1,0,0);
+		s3d_push_material(o,
+						0,1,0,
+						0,1,0,
+						0,1,0);
+		s3d_push_material(o,
+						0,1,0,
+						0,1,0,
+						0,1,0);
+		s3d_push_material(o,
+						1,1,0,
+						1,1,0,
+						1,1,0);
+		s3d_push_vertex(o,-1,-1,0);
+		s3d_push_vertex(o,-1,1,0);
+		s3d_push_vertex(o,1,1,0);
+		s3d_push_vertex(o,1,-1,0);
+		s3d_push_line(o,2,3,1);
+		s3d_push_line(o,0,1,0);
+
+		s3d_flags_on(o,S3D_OF_VISIBLE);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
+		s3d_mainloop(mainloop);
+		 /*  wait for some object to be clicked */
+		s3d_quit();
+	}
+	return(0);
+}
+
+
+

Modified: trunk/example/modelloader.c
===================================================================
--- trunk/example/modelloader.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/modelloader.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,63 @@
+/*
+ * modelloader.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+
+#include <s3d.h>
+#include <stdio.h>  /* NULL */
+#include <time.h>	/* nanosleep() */
+static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+int i,oid;
+void mainloop()
+{
+	s3d_rotate(oid,0,i,0);
+	i++;
+	nanosleep(&t,NULL); 
+}
+void object_click(struct s3d_evt *evt)
+{
+	s3d_quit();
+}
+	
+int main (int argc, char **argv)
+{
+	if (argc<2)
+	{
+		printf("usage: %s [somefile.model]\n",argv[0]);
+		return(-1);
+	}
+	if (!s3d_init(&argc,&argv,"modelloader"))	
+	{
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
+	    if (-1!=(oid=s3d_import_model_file(argv[1])))
+		{
+		    s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_mainloop(mainloop);
+		} else {
+			printf("file not found ... \n");
+		}
+		s3d_quit();
+	}
+	return(0);
+}

Modified: trunk/example/nichtsnutz.c
===================================================================
--- trunk/example/nichtsnutz.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/nichtsnutz.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,167 @@
+/*
+ * nichtsnutz.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+
+#include <s3d.h>
+#include <s3d_keysym.h>
+#include <stdio.h>
+#include <math.h>
+#include <time.h>	
+
+static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+
+int object,foll;
+float al, r, rc ,alpha=0.0, Asp, Bottom, Left, angle;
+float CamPosition[2][3],
+	  TmpMove[3],
+	  Tmp[3],
+	  TmpCam[2][3],
+	  RotCam[2][3],
+	  CatPos[3];
+
+float length;
+
+void mainloop()
+{
+	
+	al=(alpha*M_PI/180);
+    r = 5.0;
+	rc = 12.0;
+	
+	CatPos[0] = sin(al)*r;
+	CatPos[1] = 0;
+	CatPos[2] = cos(al)*r;
+	/*
+	RotCam[0][0] = sin(al) * rc;
+	RotCam[0][1] = 0.0;
+	RotCam[0][2] = cos(al) * rc;
+	*/
+	s3d_translate(object,CatPos[0] ,CatPos[1], CatPos[2]);
+	s3d_rotate(object, 0, alpha, 0);
+	alpha = alpha+0.1;
+	if (alpha>360.0) alpha=0.0;
+	
+	length = s3d_vector_length(CatPos);
+
+
+	RotCam[0][0] = ( CatPos[0] * 12.0 ) / length;
+	RotCam[0][1] = ( CatPos[1] * 12.0 ) / length;
+	RotCam[0][2] = ( CatPos[2] * 12.0 ) / length;
+	
+	
+	if( foll )
+	{
+		
+		CamPosition[0][0] = ((CamPosition[0][0]*4 + RotCam[0][0])/5);
+		CamPosition[0][1] = ((CamPosition[0][1]*4 + RotCam[0][1])/5);
+		CamPosition[0][2] = ((CamPosition[0][2]*4 + RotCam[0][2])/5);
+		s3d_translate(0,CamPosition[0][0],CamPosition[0][1],CamPosition[0][2]);
+
+		TmpMove[0] = 0.0;
+		TmpMove[1] = 0.0;
+		TmpMove[2] = -1.0;
+
+		Tmp[0] = CamPosition[0][0] - CatPos[0];
+		Tmp[1] = 0.0;
+		Tmp[2] = CamPosition[0][2] - CatPos[2];
+		
+		angle = s3d_vector_angle(Tmp,TmpMove);
+		angle = (CatPos[0] > 0)?(180-(180 / M_PI * angle)):(180+(180 / M_PI * angle));
+		printf("%f %f\n",angle,al);
+	
+		CamPosition[1][1] = (CamPosition[1][1]*4 + angle)/5;
+		s3d_rotate(0,CamPosition[1][0], CamPosition[1][1], CamPosition[1][2]);
+	}
+	
+
+	
+	nanosleep(&t,NULL); 
+}
+
+void object_info(struct s3d_evt *hrmz)
+{
+	struct s3d_obj_info *inf;
+	inf=(struct s3d_obj_info *)hrmz->buf;
+	
+	if (inf->object==0)
+	{
+		CamPosition[0][0] = inf->trans_x;
+		CamPosition[0][1] = inf->trans_y;
+		CamPosition[0][2] = inf->trans_z;
+		CamPosition[1][0] = inf->rot_x;
+		CamPosition[1][1] = inf->rot_y;
+		CamPosition[1][2] = inf->rot_z;
+
+		Asp=inf->scale;
+		if (Asp>1.0) /* wide screen */
+		{
+			Bottom=-1.0;
+			Left=-Asp;
+		} else {  /* high screen */
+			Bottom=(-1.0/Asp);
+			Left=-1.0;
+		}
+	}
+}
+
+
+
+void keypress(struct s3d_evt *event)
+{
+	int key;
+	key=*((unsigned short *)event->buf);
+	switch(key)
+	{
+		case 'f':
+				foll = foll ? 0 : 1;
+				if( foll )
+				{
+					TmpCam[0][0] = CamPosition[0][0];
+					TmpCam[0][1] = CamPosition[0][1];
+					TmpCam[0][2] = CamPosition[0][2];
+					TmpCam[1][0] = CamPosition[1][0];
+					TmpCam[1][1] = CamPosition[1][1];
+					TmpCam[1][2] = CamPosition[1][2];
+				}
+				break;
+	}
+}
+
+
+int main(int argc, char **argv)
+{
+	
+	if (!s3d_init(&argc,&argv,"running cat"))
+	{
+		s3d_set_callback(S3D_EVENT_KEY,keypress);
+		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
+		
+		object = s3d_import_model_file("objs/katze_body.3ds");
+		s3d_flags_on(object, S3D_OF_VISIBLE);
+		s3d_mainloop(mainloop);
+		s3d_quit();
+	}
+	return(0);
+}

Modified: trunk/example/ptrtest.c
===================================================================
--- trunk/example/ptrtest.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/ptrtest.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,114 @@
+/*
+ * ptrtest.c
+ * 
+ * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <s3d.h>
+#include <stdio.h>  /*  NULL*/
+#include <time.h>	/* nanosleep() */
+#include <math.h>	/* sin(), cos() */
+int i;
+int o;
+float bottom=-1.0;
+float left=-1.0;
+float asp=1.0;
+float len=1.0;
+int alpha=0;
+static struct timespec t={0,10*1000*1000}; /* 100 mili seconds */
+void stop(struct s3d_evt *evt)
+{
+	s3d_quit();
+}
+
+void mainloop()
+{
+	float a;
+	alpha=(alpha+1)%360;
+	s3d_rotate(o,alpha,0,0);
+	a=(((float)alpha)*M_PI/180);
+	s3d_translate(0,sin(a)*30,0,30+cos(a)*30);
+	s3d_rotate(0,sin(a)*30,alpha,0);
+	nanosleep(&t,NULL); 
+}
+void object_info(struct s3d_evt *hrmz)
+{
+	struct s3d_obj_info *inf;
+	inf=(struct s3d_obj_info *)hrmz->buf;
+	if (inf->object==0)
+	{
+		if (asp!=inf->scale)
+		{
+			asp=inf->scale;
+			printf("screen aspect: %f\n",asp);
+			if (asp>1.0) /* wide screen */
+			{
+				bottom=-1.0;
+				left=-asp;
+			} else {  /* high screen */
+				bottom=(-1.0/asp);
+				left=-1.0;
+			}
+		}
+	}
+	if (inf->object==1)
+	{ /* of course, a link s3d_link(o,1 would be much easier ... */
+		s3d_translate(o,(inf->trans_x)*2.0,(inf->trans_y)*2.0,-2);
+	}
+}
+void mbutton_press(struct s3d_evt *hrmz)
+{
+	struct s3d_but_info *inf;
+	char s[256];
+	inf=(struct s3d_but_info *)hrmz->buf;
+	snprintf(s,256,"please, watch your stomach! button %d, state %d", inf->button,inf->state);
+	printf("button %d, state %d\n", inf->button,inf->state);
+	s3d_del_object(o);
+	o=s3d_draw_string(s,&len);
+	s3d_translate(o,0,0,-2);
+	s3d_scale(o,0.2);
+	s3d_link(o,0);			/* link to cam */
+/*	s3d_link(o,1);*/
+	s3d_flags_on(o,S3D_OF_VISIBLE);
+}
+int main (int argc, char **argv)
+{
+	i=0;
+	if (!s3d_init(&argc,&argv,"ptr and cam test"))	
+	{
+		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
+		s3d_set_callback(S3D_EVENT_MBUTTON,mbutton_press);
+		s3d_set_callback(S3D_EVENT_QUIT,stop);
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK,stop);
+		s3d_select_font("vera");
+		o=s3d_draw_string("hello",&len);
+		s3d_translate(o,0,0,-2);
+		s3d_link(o,0);			/* link to cam */
+/*		s3d_link(o,1);*/
+		s3d_scale(o,0.2);
+		s3d_flags_on(o,S3D_OF_VISIBLE);
+		s3d_mainloop(mainloop);
+		 /*  wait for some object to be clicked */
+		s3d_quit();
+	}
+	return(0);
+}
+

Modified: trunk/example/radius_test.c
===================================================================
--- trunk/example/radius_test.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/radius_test.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,75 @@
+/*
+ * radius_test.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <s3d.h>
+#include <stdio.h>  /*  NULL */
+#include <time.h>	/* nanosleep() */
+static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+
+#include <math.h>	/* sin(), cos() */
+int item1, item2, item3;
+int i=0;
+void mainloop()
+{
+	float f,g,h;
+	f=sin((M_PI*(i%360))/180.0);
+	g=cos((M_PI*(i%360))/180.0);
+	h=sin((M_PI*((3*i)%360))/180.0);
+	
+	s3d_translate(item1,f*10,h*2, g*5);
+	s3d_rotate(item1,0,i%360,0);
+/*	s3d_scale(item1,h+3,h+3,h+3);*/
+
+/*	s3d_translate(item2,f*10,0, g*5);*/
+	s3d_translate(item2,0,0,10);
+/*	s3d_rotate(item2,i%360,0,-i%360);
+	s3d_scale(item2,2*f+5,2*f+5,2*f+5);*/
+
+	s3d_translate(item3,0,0,10);
+/*	s3d_rotate(item3,((8*i)%360),0,-((8*i)%360));
+	s3d_scale(item3,2*f+5,2*f+5,2*f+5);*/
+
+	
+
+	i++;
+	nanosleep(&t,NULL); 
+}
+int main (int argc, char **argv)
+{
+	if (!s3d_init(&argc,&argv,"radius test"))	
+	{
+		item1=s3d_import_model_file("objs/cubeyholes.3ds");
+		item2=s3d_import_model_file("objs/folder.3ds");
+		s3d_select_font("vera");
+		item3=s3d_draw_string("radius test",NULL);
+		s3d_link(item2,item1);
+		s3d_link(item3,item2);
+	    s3d_flags_on(item1,S3D_OF_VISIBLE);
+	    s3d_flags_on(item2,S3D_OF_VISIBLE);
+	    s3d_flags_on(item3,S3D_OF_VISIBLE);
+		s3d_mainloop(mainloop);
+			 /*  wait for some object to be clicked */
+		s3d_quit();
+	}
+	return(0);
+}

Modified: trunk/example/s3dclock.c
===================================================================
--- trunk/example/s3dclock.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/s3dclock.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,87 @@
+/*
+ * s3dclock.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <s3d.h>
+#include <stdio.h>  /*  NULL, sprintf() */
+#include <time.h>	 /*  nanosleep(), struct tm, time_t...  */
+#include <string.h>  /*  strlen() */
+static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
+int big_p,lil_p,bg,sec_p;
+int str_oid=-1, o_str_oid;
+struct tm *mytime;
+time_t now,onow;
+char time_str[256];
+
+void stop(struct s3d_evt *evt)
+{
+	s3d_quit();
+}
+
+void mainloop()
+{
+	onow=now;
+	now=time(NULL);
+	if (now!=onow)
+	{
+		o_str_oid=str_oid;
+		mytime=localtime(&now);	
+		s3d_rotate(lil_p,0,0,-((mytime->tm_hour%12)/12.0)*360.0);
+		s3d_rotate(big_p,0,0,-(mytime->tm_min/60.0)*360.0);
+		s3d_rotate(sec_p,0,0,-(mytime->tm_sec/60.0)*360.0);
+		sprintf(time_str,"%02d:%02d:%02d",mytime->tm_hour,mytime->tm_min,mytime->tm_sec);
+		str_oid=s3d_draw_string(time_str,NULL);
+		s3d_translate(str_oid,-1,-1.3,0);
+		s3d_scale(str_oid,0.5);
+		s3d_flags_on(str_oid,S3D_OF_VISIBLE);
+		if (str_oid!=-1)
+			s3d_del_object(o_str_oid);
+	}
+/* 	printf("now it's %s\n",time_str); */
+	nanosleep(&t,NULL); 
+
+}
+int main (int argc, char **argv)
+{
+	if (!s3d_init(&argc,&argv,"clock"))	
+	{
+		lil_p=s3d_import_model_file("objs/lil_p.3ds");
+		big_p=s3d_import_model_file("objs/big_p.3ds");
+		sec_p=s3d_import_model_file("objs/sec_p.3ds");
+		bg=s3d_import_model_file("objs/clock_bg.3ds");
+
+		s3d_flags_on(big_p,S3D_OF_VISIBLE);
+		s3d_flags_on(lil_p,S3D_OF_VISIBLE);
+		s3d_flags_on(sec_p,S3D_OF_VISIBLE);
+		s3d_flags_on(bg,S3D_OF_VISIBLE);
+		s3d_select_font("vera");
+
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
+		s3d_mainloop(mainloop);
+		 /*  wait for some object to be clicked */
+		s3d_quit();
+	}
+	return(0);
+}
+

Modified: trunk/example/snowman.c
===================================================================
--- trunk/example/snowman.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/snowman.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,74 @@
+/*
+ * snowman.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <s3d.h>
+#include <math.h>	/* sin() */
+#include <time.h>	/* nanosleep() */
+static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+
+int a;
+int oid_head;
+int oid_middle;
+int oid_foot;
+
+void mainloop()
+{
+	float pos;
+	a=(a+3)%360;
+	pos=sin((a*M_PI)/180)*5;
+	if (pos<0) pos*=-1;
+	s3d_rotate(oid_head,0,a,0);
+	s3d_rotate(oid_middle,0,a,0);
+	s3d_rotate(oid_foot,0,a,0);
+	s3d_translate(oid_head,		0,1.5 +2.00*pos,0);
+	s3d_translate(oid_middle,	0,0   +1.25*pos,0);
+	s3d_translate(oid_foot,		0,-2  +1.00*pos,0);
+	nanosleep(&t,NULL); 
+}
+int main(int argc, char **argv)
+{
+	if (!s3d_init(&argc,&argv,"snowman"))
+	{
+			
+		oid_head=s3d_import_model_file("objs/snow_head.3ds");
+		oid_middle=s3d_import_model_file("objs/snow_body.3ds");
+		oid_foot=s3d_import_model_file("objs/snow_foot.3ds");
+
+/*		s3d_link(oid_foot,oid_head);
+ *		s3d_link(oid_middle,oid_head);
+ *		s3d_translate(oid_head,0,4,0);
+		
+ *		s3d_translate(oid_middle,0,-1.5,0); 	* relative to head: *
+ *		s3d_translate(oid_foot,0,-3.5,0); */
+		
+		s3d_scale(oid_middle,1.25);
+		s3d_scale(oid_foot,1.5);
+
+		s3d_flags_on(oid_head,S3D_OF_VISIBLE);
+		s3d_flags_on(oid_middle,S3D_OF_VISIBLE);
+		s3d_flags_on(oid_foot,S3D_OF_VISIBLE);
+		s3d_mainloop(mainloop);
+		s3d_quit();
+	}
+	return(0);
+}

Modified: trunk/example/strtest.c
===================================================================
--- trunk/example/strtest.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/strtest.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,64 @@
+/*
+ * strtest.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+#include <s3d.h>
+#include <stdio.h>  /*  NULL*/
+#include <unistd.h> /* sleep() */
+int o;
+void stop(struct s3d_evt *evt)
+{
+	s3d_quit();
+}
+
+void mainloop()
+{
+/* 	printf("now it's %s\n",time_str); */
+	sleep(1);
+
+}
+int main (int argc, char **argv)
+{
+	char c[256];
+	int i;
+	if (!s3d_init(&argc,&argv,"strtest"))	
+	{
+		s3d_select_font("vera");
+/*		o=s3d_draw_string("The lazy fox is bored enough to jump over everything it sees. weird, isn't it?!",NULL);  */
+		for (i=0;i<256;i++)
+			c[255-i]=i;
+		o=s3d_draw_string(c,NULL);
+/*		o=s3d_draw_string("A",NULL);*/
+		s3d_flags_on(o,S3D_OF_VISIBLE);
+
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);
+		s3d_set_callback(S3D_EVENT_QUIT,		(s3d_cb)stop);
+		s3d_mainloop(mainloop);
+		 /*  wait for some object to be clicked */
+		s3d_quit();
+	}
+	return(0);
+}
+
+

Modified: trunk/example/texturetest.c
===================================================================
--- trunk/example/texturetest.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/texturetest.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,86 @@
+/*
+ * texturetest.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <s3d.h>
+#include <stdio.h>  /*  NULL */
+#include <stdlib.h>  /* malloc(),free() */
+#include <time.h>	/* nanosleep() */
+static struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
+
+int i,oid;
+void mainloop()
+{
+	i=(i+1)%360;
+	s3d_rotate(oid,0,i,0);
+	nanosleep(&t,NULL); 
+}
+#define MAXX	300
+#define MAXY	300
+int main (int argc, char **argv)
+{
+	unsigned int x,y;
+	unsigned char *data;
+						
+	if (!s3d_init(&argc,&argv,"texturetest"))	
+	{
+		data=malloc(MAXX*MAXY*4);
+		oid=s3d_new_object();
+		s3d_push_vertex(oid,-1,-1,0);
+		s3d_push_vertex(oid, 1,-1,0);
+		s3d_push_vertex(oid, 1, 1,0);
+		s3d_push_vertex(oid,-1, 1,0);
+		s3d_push_material_a(oid,
+						0.8,	0.0,	0.0	,1.0,
+						1.0,	1.0,	1.0	,1.0,
+						0.8,	0.0,	0.0	,1.0);
+		s3d_push_polygon(oid,0,1,2,0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
+									   1.0,0.0,
+									   1.0,1.0);
+		s3d_push_polygon(oid,0,2,3,0);
+		s3d_pep_polygon_tex_coord(oid, 0.0,0.0, 
+									   1.0,1.0,
+									   0.0,1.0);
+		s3d_translate(oid,0,0,5);
+		for (y=0;y<MAXY;y++)
+			for (x=0;x<MAXX;x++)
+			{
+				data[(y*MAXX+x)*4+0]=(char)((x*255)/MAXX);
+				data[(y*MAXX+x)*4+1]=((x*y)/(MAXX*MAXY));
+				data[(y*MAXX+x)*4+2]=((y*255)/MAXX);
+				data[(y*MAXX+x)*4+3]=255;
+			}
+		s3d_push_texture(oid,MAXX,MAXY);		
+		s3d_load_texture(oid,0,0,0,MAXX,MAXY,data);
+					 /*  push data on texture 0 position (0,0) */
+		free(data);
+		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
+		s3d_flags_on(oid,S3D_OF_VISIBLE);
+		i=0;
+		s3d_mainloop(mainloop);
+			 /*  wait for some object to be clicked */
+		s3d_quit();
+	}
+	return(0);
+}

Modified: trunk/example/widgets.c
===================================================================
--- trunk/example/widgets.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/example/widgets.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -0,0 +1,174 @@
+/*
+ * widgets.c
+ * 
+ * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+
+#include <s3d.h>
+#include <s3dw.h>
+#include <stdio.h>  /* NULL */
+#include <time.h>	/* nanosleep() */
+#include <stdlib.h>	/* free() */
+#include <string.h> /* strlen() */
+
+s3dw_surface *surface;
+s3dw_input *input;
+static struct timespec t={0,33*1000*1000}; /* 33 mili seconds */
+void mainloop()
+{
+	/* keep this in your mainloop. this will do smooth animations for you ... */
+	s3dw_ani_mate();
+	nanosleep(&t,NULL); 
+}
+/* you should always put the s3dw-handler in your own event handler,
+ * if you want s3dw to react on clicks or keys ... and i'm sure you
+ * want that ... */
+void click(struct s3d_evt *evt)
+{
+	s3dw_handle_click(evt);
+}
+void key_button(s3dw_widget *button)
+{
+	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
+}
+void key(struct s3d_evt *evt)
+{
+	struct s3d_key_event *key=(struct s3d_key_event *)evt->buf;
+	char string[8];
+	s3dw_surface *miniwin;
+	s3dw_button  *button;
+	
+	s3dw_handle_key(evt);
+	/* okay, that's a little bit insane ... ;) 
+	 * we create some little windows with the actual key pressed. */
+
+	if (key->unicode!=0)
+	{
+		miniwin=s3dw_surface_new("Key",6,6);
+		sprintf(string,"%c",key->unicode);
+		s3dw_label_new(miniwin,string,1,2);
+		button=s3dw_button_new(miniwin,"OK",2,4);
+		/* clicking on the button will exit ... */
+		button->onclick=key_button;
+		/* of couse, show it */
+		s3dw_show(S3DWIDGET(miniwin));
+	}
+
+}
+
+void done_button(s3dw_widget *dummy)
+{
+	s3d_quit();
+}
+
+void okay_button(s3dw_widget *dummy)
+{
+	s3dw_button *button;
+	char string[32];
+	char *age;
+
+	/* get the input of the text ... before its destroyed, of course*/
+	age=s3dw_input_gettext(input);
+
+	/* delete the old surface with it subwidgets */
+	s3dw_delete(S3DWIDGET(surface));
+	
+	/* and create a new one ... */
+	surface=s3dw_surface_new("Ah!",10,7);
+	
+	/* just cutting the string if it's too long */
+	if (strlen(age)>8) age[8]=0;
+	
+	/* assemble the string ..*/
+	sprintf(string,"I see, %s!!",age);
+
+	s3dw_label_new(surface,string,1,2);
+	button=s3dw_button_new(surface,"Great",4,4);
+	/* clicking on the button will exit ... */
+	button->onclick=done_button;
+	
+	/* of couse, show it */
+	s3dw_show(S3DWIDGET(surface));
+
+	/* we don't need it anymore. always free strings, don't leak around */
+	free(age); 
+}
+void no_button(s3dw_widget *dummy)
+{
+	s3dw_button *button;
+	s3dw_delete(S3DWIDGET(surface));
+	surface=s3dw_surface_new("Well ...",10,7);
+	s3dw_label_new(surface,"If you don't want to tell me ...",1,2);
+	button=s3dw_button_new(surface,"Bye",4,4);
+	/* clicking on the button will exit ... */
+	
+	button->onclick=done_button;
+	/* of couse, show it */
+	
+	s3dw_show(S3DWIDGET(surface));
+}
+
+int main (int argc, char **argv)
+{
+	s3dw_button *button;
+	if (!s3d_init(&argc,&argv,"widgettest"))
+	{
+		s3d_set_callback(S3D_EVENT_OBJ_CLICK,click);
+		s3d_set_callback(S3D_EVENT_KEY,key);
+		s3d_set_callback(S3D_EVENT_OBJ_INFO,s3dw_object_info);
+		/* this creates the "window" */
+		surface=s3dw_surface_new("Hello World",20,10);
+		
+		/* put a label (which is simply text) at position x=1, y=2 */
+		s3dw_label_new(surface,"How old are you?",1,2);
+
+		/* put an input box right below. we grab the pointer because we want to focus it (need for reference) */
+		input=s3dw_input_new(surface,8,1,4);
+		
+		/* we want the input-field be focused on our widget */
+		s3dw_focus(S3DWIDGET(input));
+
+		/* create the okay button */
+		button=s3dw_button_new(surface,"OK",1,7);
+
+		/* define the callback when the button is clicked. in our case, okay_button() will handle the event */
+		button->onclick=okay_button;
+
+		/* another button  */
+		button=s3dw_button_new(surface,"Won't tell you",10,7);
+
+		/* we will tell him how sad we are ... */
+		button->onclick=no_button;
+
+		/* this widget is focused (of course, it's our only one ... */
+		s3dw_focus(S3DWIDGET(surface));
+
+		/* show it. without showing, things would be boring... */
+		s3dw_show(S3DWIDGET(surface));
+
+		s3d_mainloop(mainloop);
+		s3d_quit();
+	}
+	return(0);
+}
+

Deleted: trunk/libs3d/3dsread.c
===================================================================
--- trunk/libs3d/3dsread.c	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/libs3d/3dsread.c	2006-09-16 00:59:49 UTC (rev 392)
@@ -1,246 +0,0 @@
-/*
- * modelread.c
- *
- * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
- *
- * This file is part of the s3d API, the API of s3d (the 3d network display server).
- * See http://s3d.berlios.de/ for more updates.
- *
- * The s3d API is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2.1 of the License, or
- * (at your option) any later version.
- *
- * The s3d API is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with the s3d API; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- */
-
-
-#include "s3d.h"
-#include "s3dlib.h"
-#include <g3d/g3d.h>
-#include <stdlib.h> 	 /*  exit(), malloc() */
-#include <math.h>		 /*  sqrt() */
-#include <string.h> 	 /*  strncpy() */
-#include <errno.h> 		 /*  errno */
-
-
-struct material2texture {
-	struct material2texture *next_ptr;   /* pointer to next */
-	void *material_ptr;
-	void *texture_ptr;
-	int material_id;
-	int texture_id;
-};
-struct material2texture *mat2tex_root = NULL;
-
-#define MAXSTRN		20
-static int model_load(char *file);
-/*  just a helper function for reading from file instead of memory. */
-int s3d_import_model_file(char *fname)
-{
-	char *buf,*ptr,*next;
-	char searchpath[1024];
-	char path[1024];
-	int oid;
-#ifndef OBJSDIR
-#define OBJSDIR 	"./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/"
-#endif
-
-	strncpy(searchpath,OBJSDIR,1023);
-	searchpath[1023]=0;							/* just in case */
-	next=ptr=searchpath;
-	while (next!=NULL)
-	{
-		next=NULL;
-
-		if (NULL!=(next=strchr(ptr,':')))
-		{
-			*next=0; 							/* clear the delimiter */
-			next+=1;							/* move to the beginner of the next dir */
-		}
-		if ((strlen(ptr)+strlen(fname))<1024) 	/* only try if this fits */
-		{
-			strcpy(path,ptr); 					/* can use "unsafe" functions because size was verified above */
-			strcat(path,fname);
-			if (s3d_open_file(path,&buf)!=-1)  /* found something */
-			{
-				free(buf); /* TODO: badbadbad ... */
-				if (-1!=(oid=model_load(path))) return(oid);
-
-			}
-		}
-		if (next!=NULL)
-			ptr=next;							/* move pointer to the next position */
-	}
-	errds(LOW,"s3d_import_model_file()","Could not open %s", fname);
-	return(-1); /* nothing in search path ... */
-}
-
-void *get_mat2tex( struct material2texture **mat2tex, void *mat_ptr ) {
-
-	while ( (*mat2tex) != NULL ) {
-
-		if ( (*mat2tex)->material_ptr == mat_ptr ) return (*mat2tex);
-
-		mat2tex = &(*mat2tex)->next_ptr;
-
-	}
-
-	if ( (*mat2tex) == NULL ) {
-
-		(*mat2tex) = malloc( sizeof( struct material2texture ) );
-
-		if ( (*mat2tex) == NULL ) {
-			errs( "model_import()", "Sorry - you ran out of memory !\n" );
-			exit(8);
-		}
-
-		(*mat2tex)->next_ptr = NULL;
-		(*mat2tex)->material_ptr = mat_ptr;
-		(*mat2tex)->texture_ptr = NULL;
-		(*mat2tex)->material_id = -1;
-		(*mat2tex)->texture_id = -1;
-
-		return (*mat2tex);
-
-	}
-
-	return(0);
-
-}
-
-
-
-int model_load(char *file)
-{
-	G3DContext			 	*context;
-	G3DModel				*model;
-	G3DObject 				*object;
-	G3DFace 				*face;
-	GSList 					*oitem, *oface;
-	struct material2texture *mat2tex;
-	int						 i, j, k, material_count, texture_count, voff,obj_id;
-#define 					PMAX	100
-	unsigned long 			 polybuf[PMAX * 4],npoly,oldflags;
-	float					 normalbuf[PMAX * 9],texcoordbuf[PMAX * 6];
-	float 					 swaph;				/* swap helper */
-	unsigned char 			*s3d_pixeldata = NULL;
-
-	context = g3d_context_new();
-	obj_id=-1;
-	model = g3d_model_load(context, file);
-
-	if ( model ) {
-
-		oitem = model->objects;
-		obj_id = s3d_new_object();
-		material_count = texture_count = voff = 0;
-
-		while ( oitem ) {
-
-			object = (G3DObject *)oitem->data;
-
-			/* push vertices */
-			for ( j = 0; j < object->vertex_count; j++ ) {
-				/* 2. and 3. coord have to change places otherwise the object will be turned */
-				swaph=							 object->vertex_data[j * 3 + 2];
-				object->vertex_data[j * 3 + 2] = object->vertex_data[j * 3 + 1];
-				object->vertex_data[j * 3 + 1] = swaph;
-			}
-			s3d_push_vertices( obj_id, object->vertex_data, object->vertex_count);
-					
-
-
-			oface = object->faces;
-			npoly=0;
-			oldflags = ((G3DFace *) (oface->data))->flags;
-
-			while ( oface ) {
-
-				face = (G3DFace *)oface->data;
-				mat2tex = get_mat2tex( &mat2tex_root, face->material );
-
-				if ( mat2tex->material_id == -1 ) { /* create a new texture if nothing found */
-					s3d_push_material_a( obj_id, 	face->material->r, face->material->g, face->material->b,face->material->a, 
-													face->material->specular[0], face->material->specular[1], face->material->specular[2], face->material->specular[3],
-													face->material->r, face->material->g, face->material->b, face->material->a );
-
-					mat2tex->material_id = material_count;
-					material_count++;
-
-					if ( face->tex_image != NULL ) {
-
-						/* reorder pixeldata - s3d wants rgba */
-						if ( s3d_pixeldata != NULL ) free( s3d_pixeldata );
-
-						s3d_pixeldata = malloc( sizeof( unsigned char ) * face->tex_image->width * face->tex_image->height * 32 );
-
-						if ( s3d_pixeldata == NULL ) {
-							errs("model_load()", "Sorry - you ran out of memory !\n" );
-							exit(8);
-						}
-
-						for ( j = ( face->tex_image->height - 1 ); j >= 0; j-- ) {
-							for ( k = 0; k < face->tex_image->width; k++ ) {
-								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ];
-								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ];
-								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ];
-								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ];
-							}
-						}
-
-						s3d_push_texture( obj_id, face->tex_image->width, face->tex_image->height );
-						s3d_pep_material_texture( obj_id, texture_count );
-						s3d_load_texture( obj_id, texture_count, 0, 0, face->tex_image->width, face->tex_image->height, s3d_pixeldata );
-
-						mat2tex->texture_id = texture_count;
-						texture_count++;
-
-					}
-				}
-				if (face->flags != oldflags || npoly>=PMAX)
-				{
-					/* push things so far */
-					s3d_push_polygons(obj_id, polybuf, npoly);
-					if (oldflags & G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
-					if (oldflags & G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);
-					npoly=0;
-				}
-				oldflags=face->flags;
-
-				/* add polygon to the polygon buffer */
-				for (i=0;i<3;i++)
-					polybuf[npoly*4+i]=face->vertex_indices[i] + voff;
-				polybuf[npoly*4+3]=mat2tex->material_id;
-
-				if ( face->flags & G3D_FLAG_FAC_NORMALS ) memcpy( normalbuf + npoly*9,  face->normals, sizeof(float) * 9);
-				if ( face->flags & G3D_FLAG_FAC_TEXMAP )  memcpy( texcoordbuf + npoly*6,  face->tex_vertex_data, sizeof(float) * 6);
-				npoly++;
-				oface = oface->next;
-			}
-			/* push the last packets in buffer */
-			if (npoly > 0)
-			{
-				s3d_push_polygons(obj_id, polybuf, npoly);
-				if (oldflags & G3D_FLAG_FAC_NORMALS)		s3d_pep_polygon_normals(obj_id, normalbuf, 		npoly);
-				if (oldflags & G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);
-				npoly=0;
-			}
-	
-			voff += object->vertex_count; /* increase vertex offset */
-			oitem = oitem->next;
-		}
-	}
-	g3d_model_free(model);
-	g3d_context_free(context);
-	
-	return(obj_id);
-}
-

Modified: trunk/libs3d/Makefile.am
===================================================================
--- trunk/libs3d/Makefile.am	2006-09-16 00:44:17 UTC (rev 391)
+++ trunk/libs3d/Makefile.am	2006-09-16 00:59:49 UTC (rev 392)
@@ -1,7 +1,7 @@
 SUBDIRS=. libg3d
 lib_LTLIBRARIES=	libs3d.la
 
-libs3d_la_SOURCES=	3dsread.c callback.c error.c event.c fontselect.c \
+libs3d_la_SOURCES=	modelread.c callback.c error.c event.c fontselect.c \
 			freetype.c io.c network.c object_queue.c proto_in.c \
 			proto_out.c shm.c shm_ringbuf.c tcp.c \
 			sei_construct.c sei_misc.c sei_monotone.c sei_tri.c vector.c

Copied: trunk/libs3d/modelread.c (from rev 391, trunk/libs3d/3dsread.c)



From dotslash at mail.berlios.de  Sat Sep 16 03:21:58 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 16 Sep 2006 03:21:58 +0200
Subject: [S3d-svn] r393 - in trunk: apps/dot_mcp apps/s3dfm apps/s3dgps
	example libs3d
Message-ID: <200609160121.k8G1LwHu005560@sheep.berlios.de>

Author: dotslash
Date: 2006-09-16 03:21:58 +0200 (Sat, 16 Sep 2006)
New Revision: 393

Modified:
   trunk/apps/dot_mcp/menu.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dgps/s3dgps.c
   trunk/example/filebrowser.c
   trunk/example/modelloader.c
   trunk/libs3d/Makefile.am
   trunk/libs3d/modelread.c
Log:
- gefrickel
- TODO: libg3d/libs3d autohell

Modified: trunk/apps/dot_mcp/menu.c
===================================================================
--- trunk/apps/dot_mcp/menu.c	2006-09-16 00:59:49 UTC (rev 392)
+++ trunk/apps/dot_mcp/menu.c	2006-09-16 01:21:58 UTC (rev 393)
@@ -36,11 +36,11 @@
 static int go=-1;
 static int act;
 static struct menu_entry menu[]={
-		{"objs/comp.model","terminal","s3dvt",				0,0},
-		{"objs/comp.model","olsrs3d","olsrs3d",				0,0},
-		{"objs/comp.model","s3d_x11gate","s3d_x11gate",		0,0},
-		{"objs/comp.model","filebrowser","filebrowser",		0,0}, 
-		{"objs/comp.model","logout","LOGOUT",					0,0}, 
+		{"objs/comp.3ds","terminal","s3dvt",				0,0},
+		{"objs/comp.3ds","olsrs3d","olsrs3d",				0,0},
+		{"objs/comp.3ds","s3d_x11gate","s3d_x11gate",		0,0},
+		{"objs/comp.3ds","filebrowser","filebrowser",		0,0}, 
+		{"objs/comp.3ds","logout","LOGOUT",					0,0}, 
 };
 void menu_click(int oid)
 {

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2006-09-16 00:59:49 UTC (rev 392)
+++ trunk/apps/s3dfm/parse.c	2006-09-16 01:21:58 UTC (rev 393)
@@ -102,7 +102,7 @@
 				{
 				   if (ext!=NULL)
 				   {
-					   if (0==strncmp(ext,".model",strlen(ext)<4?strlen(ext):4))
+					   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))
 							   list[n].type=T_GEOMETRY;
 					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))
 							   list[n].type=T_MUSIC;

Modified: trunk/apps/s3dgps/s3dgps.c
===================================================================
--- trunk/apps/s3dgps/s3dgps.c	2006-09-16 00:59:49 UTC (rev 392)
+++ trunk/apps/s3dgps/s3dgps.c	2006-09-16 01:21:58 UTC (rev 393)
@@ -62,7 +62,7 @@
 int 				 frame=0;
 struct point_t		 posicon;
 int					 iconlist[ICON_MAX];
-char				*iconnames[]={"objs/arrow.model"};
+char				*iconnames[]={"objs/arrow.3ds"};
 
 unsigned char 		*recode_image(unsigned char *data, int nc, int w, int h);
 int 				 load_mapimage(char *path,float lng, float lat, int scale);

Modified: trunk/example/filebrowser.c
===================================================================
--- trunk/example/filebrowser.c	2006-09-16 00:59:49 UTC (rev 392)
+++ trunk/example/filebrowser.c	2006-09-16 01:21:58 UTC (rev 393)
@@ -105,7 +105,7 @@
 				{
 				   if (ext!=NULL)
 				   {
-					   if (0==strncmp(ext,".model",strlen(ext)<4?strlen(ext):4))
+					   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))
 							   item[n].type=T_GEOMETRY;
 					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))
 							   item[n].type=T_MUSIC;

Modified: trunk/example/modelloader.c
===================================================================
--- trunk/example/modelloader.c	2006-09-16 00:59:49 UTC (rev 392)
+++ trunk/example/modelloader.c	2006-09-16 01:21:58 UTC (rev 393)
@@ -31,7 +31,7 @@
 int i,oid;
 void mainloop()
 {
-	s3d_rotate(oid,0,i,0);
+/*	s3d_rotate(oid,0,i,0);*/
 	i++;
 	nanosleep(&t,NULL); 
 }
@@ -44,7 +44,7 @@
 {
 	if (argc<2)
 	{
-		printf("usage: %s [somefile.model]\n",argv[0]);
+		printf("usage: %s [somefile.3ds]\n",argv[0]);
 		return(-1);
 	}
 	if (!s3d_init(&argc,&argv,"modelloader"))	

Modified: trunk/libs3d/Makefile.am
===================================================================
--- trunk/libs3d/Makefile.am	2006-09-16 00:59:49 UTC (rev 392)
+++ trunk/libs3d/Makefile.am	2006-09-16 01:21:58 UTC (rev 393)
@@ -11,6 +11,7 @@
 
 libs3d_la_CPPFLAGS=	-I${top_srcdir}/server
 libs3d_la_CFLAGS=	@FONTCONFIG_CFLAGS@ @FREETYPE_CFLAGS@ -I$(top_srcdir)/libs3d/libg3d/include @GLIB_CFLAGS@
-libs3d_la_LIBADD=	@FONTCONFIG_LIBS@ @FREETYPE_LIBS@ @LIBM@ $(top_builddir)/libs3d/libg3d/src/libg3d.la
+libs3d_la_LIBADD=	@FONTCONFIG_LIBS@ @FREETYPE_LIBS@ @LIBM@ 
+libs3d_la_LDFLAGS=	$(top_builddir)/libs3d/libg3d/src/libg3d.la
 
 EXTRA_DIST=		lgpl.txt

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2006-09-16 00:59:49 UTC (rev 392)
+++ trunk/libs3d/modelread.c	2006-09-16 01:21:58 UTC (rev 393)
@@ -150,8 +150,9 @@
 			/* push vertices */
 			for ( j = 0; j < object->vertex_count; j++ ) {
 				/* 2. and 3. coord have to change places otherwise the object will be turned */
-				swaph=							 object->vertex_data[j * 3 + 2];
-				object->vertex_data[j * 3 + 2] = object->vertex_data[j * 3 + 1];
+				object->vertex_data[j * 3 + 0] =  object->vertex_data[j * 3 + 0];
+				swaph=							  object->vertex_data[j * 3 + 2];
+				object->vertex_data[j * 3 + 2] = -object->vertex_data[j * 3 + 1];
 				object->vertex_data[j * 3 + 1] = swaph;
 			}
 			s3d_push_vertices( obj_id, object->vertex_data, object->vertex_count);
@@ -216,12 +217,31 @@
 				oldflags=face->flags;
 
 				/* add polygon to the polygon buffer */
-				for (i=0;i<3;i++)
-					polybuf[npoly*4+i]=face->vertex_indices[i] + voff;
+				polybuf[npoly*4+0]=face->vertex_indices[0] + voff;
+				polybuf[npoly*4+1]=face->vertex_indices[2] + voff;
+				polybuf[npoly*4+2]=face->vertex_indices[1] + voff;
 				polybuf[npoly*4+3]=mat2tex->material_id;
 
-				if ( face->flags & G3D_FLAG_FAC_NORMALS ) memcpy( normalbuf + npoly*9,  face->normals, sizeof(float) * 9);
-				if ( face->flags & G3D_FLAG_FAC_TEXMAP )  memcpy( texcoordbuf + npoly*6,  face->tex_vertex_data, sizeof(float) * 6);
+				if ( face->flags & G3D_FLAG_FAC_NORMALS ) {
+					normalbuf[ npoly*9 + 0] =  face->normals[ 0 ];
+					normalbuf[ npoly*9 + 1] =  face->normals[ 1 ];
+					normalbuf[ npoly*9 + 2] =  face->normals[ 2 ];
+					normalbuf[ npoly*9 + 3] =  face->normals[ 6 ];
+					normalbuf[ npoly*9 + 4] =  face->normals[ 7 ];
+					normalbuf[ npoly*9 + 5] =  face->normals[ 8 ];
+					normalbuf[ npoly*9 + 6] =  face->normals[ 3 ];
+					normalbuf[ npoly*9 + 7] =  face->normals[ 4 ];
+					normalbuf[ npoly*9 + 8] =  face->normals[ 5 ];
+				}
+				if ( face->flags & G3D_FLAG_FAC_TEXMAP )  
+				{
+					texcoordbuf[ npoly*6 + 0] = face->tex_vertex_data[ 0 ];
+					texcoordbuf[ npoly*6 + 1] = face->tex_vertex_data[ 1 ];
+					texcoordbuf[ npoly*6 + 2] = face->tex_vertex_data[ 4 ];
+					texcoordbuf[ npoly*6 + 3] = face->tex_vertex_data[ 5 ];
+					texcoordbuf[ npoly*6 + 4] = face->tex_vertex_data[ 2 ];
+					texcoordbuf[ npoly*6 + 5] = face->tex_vertex_data[ 3 ];
+				}
 				npoly++;
 				oface = oface->next;
 			}



From dotslash at mail.berlios.de  Sat Sep 16 12:48:24 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 16 Sep 2006 12:48:24 +0200
Subject: [S3d-svn] r394 - in trunk: example libs3d server
Message-ID: <200609161048.k8GAmO8N015420@sheep.berlios.de>

Author: dotslash
Date: 2006-09-16 12:48:18 +0200 (Sat, 16 Sep 2006)
New Revision: 394

Modified:
   trunk/example/modelloader.c
   trunk/libs3d/modelread.c
   trunk/server/graphics.c
Log:
- corrected normal direction

Modified: trunk/example/modelloader.c
===================================================================
--- trunk/example/modelloader.c	2006-09-16 01:21:58 UTC (rev 393)
+++ trunk/example/modelloader.c	2006-09-16 10:48:18 UTC (rev 394)
@@ -31,7 +31,7 @@
 int i,oid;
 void mainloop()
 {
-/*	s3d_rotate(oid,0,i,0);*/
+	s3d_rotate(oid,0,i,0);
 	i++;
 	nanosleep(&t,NULL); 
 }

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2006-09-16 01:21:58 UTC (rev 393)
+++ trunk/libs3d/modelread.c	2006-09-16 10:48:18 UTC (rev 394)
@@ -223,15 +223,15 @@
 				polybuf[npoly*4+3]=mat2tex->material_id;
 
 				if ( face->flags & G3D_FLAG_FAC_NORMALS ) {
-					normalbuf[ npoly*9 + 0] =  face->normals[ 0 ];
-					normalbuf[ npoly*9 + 1] =  face->normals[ 1 ];
-					normalbuf[ npoly*9 + 2] =  face->normals[ 2 ];
-					normalbuf[ npoly*9 + 3] =  face->normals[ 6 ];
-					normalbuf[ npoly*9 + 4] =  face->normals[ 7 ];
-					normalbuf[ npoly*9 + 5] =  face->normals[ 8 ];
-					normalbuf[ npoly*9 + 6] =  face->normals[ 3 ];
-					normalbuf[ npoly*9 + 7] =  face->normals[ 4 ];
-					normalbuf[ npoly*9 + 8] =  face->normals[ 5 ];
+					normalbuf[ npoly*9 + 0] = -face->normals[ 0 ];
+					normalbuf[ npoly*9 + 1] = -face->normals[ 2 ];
+					normalbuf[ npoly*9 + 2] =  face->normals[ 1 ];
+					normalbuf[ npoly*9 + 3] = -face->normals[ 6 ];
+					normalbuf[ npoly*9 + 4] = -face->normals[ 8 ];
+					normalbuf[ npoly*9 + 5] =  face->normals[ 7 ];
+					normalbuf[ npoly*9 + 6] = -face->normals[ 3 ];
+					normalbuf[ npoly*9 + 7] = -face->normals[ 5 ];
+					normalbuf[ npoly*9 + 8] =  face->normals[ 4 ];
 				}
 				if ( face->flags & G3D_FLAG_FAC_TEXMAP )  
 				{

Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2006-09-16 01:21:58 UTC (rev 393)
+++ trunk/server/graphics.c	2006-09-16 10:48:18 UTC (rev 394)
@@ -349,7 +349,6 @@
 {
 	struct t_process *p=get_proc_by_pid(MCP);
 	t_mtrx m;
-/*	GLfloat pos[]={100.0,20.0,100.0,1.0};*/
 	GLfloat pos[]={0,50,50,1.0};
 	GLfloat light0_spec[]={0.7,0.7,0.7,0.0};
 	GLfloat light0_shininess[] ={50.0};



From dotslash at mail.berlios.de  Sun Sep 17 01:15:42 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 17 Sep 2006 01:15:42 +0200
Subject: [S3d-svn] r395 - trunk/apps/s3d_x11gate
Message-ID: <200609162315.k8GNFg0P025150@sheep.berlios.de>

Author: dotslash
Date: 2006-09-17 01:15:42 +0200 (Sun, 17 Sep 2006)
New Revision: 395

Modified:
   trunk/apps/s3d_x11gate/s3d_x11gate.c
Log:
- some shm testing (not stable!!)

Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2006-09-16 10:48:18 UTC (rev 394)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2006-09-16 23:15:42 UTC (rev 395)
@@ -30,15 +30,30 @@
 #define XK_MISCELLANY
 #include <X11/keysymdef.h>	 /* keysyms */
 #include <X11/extensions/XTest.h>	/* keyboard/mouse input via s3d */
-#include <time.h>	/* nanosleep() */
+#include <X11/extensions/XShm.h> /* */
+#include <time.h>		/* nanosleep() */
+#include <sys/time.h> 	/* gettimeofday */
+#include <sys/ipc.h>
+#include <sys/shm.h>
 static struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
 
 int oid;
 XImage *image;
 Display *dpy=0;
 int window,scr;
-int width,height;
+unsigned int width,height, height, depth;
+int format;
+char *data;
+Visual *visual;
+XShmSegmentInfo shminfo;
 char *tex_image=NULL,*otex_image=NULL,*img1,*img2;
+
+
+
+struct timeval start, end;
+int iterations;
+float count[3];
+
 int get_shift(unsigned long t)
 {
 	int i=0;
@@ -57,7 +72,18 @@
 	int bpp;
 	char *swap_timg;
 	int last_change,start_change;
-	image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);
+	gettimeofday(&end,NULL);
+	count[0]+=(end.tv_sec-start.tv_sec)*10000000 + end.tv_usec-start.tv_usec;
+	start.tv_sec	=end.tv_sec;
+	start.tv_usec 	=end.tv_usec;
+
+/*	image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);*/
+	printf("dpy: %010p, window: %010p, image: %010p\n",dpy,window,image);
+	XShmGetImage(dpy, window, image, 0,0,0xffffffff);
+	gettimeofday(&end,NULL);
+	count[1]+=(end.tv_sec-start.tv_sec)*10000000 + end.tv_usec-start.tv_usec;
+	start.tv_sec	=end.tv_sec;
+	start.tv_usec 	=end.tv_usec;
 	if (image->format==ZPixmap)
 	{
 		printf("Ximage: %dx%d, format %d (%d), bpp: %d, depth %d, pad %d\n",image->width,image->height,image->format,ZPixmap,
@@ -102,7 +128,6 @@
 				}
 				if (last_change!=y)
 				{	 /*  last change is already over, post it! */
-/*					printf("[%d to %d]",start_change,last_change);*/
 					s3d_load_texture(oid,0,0,start_change,width,last_change-start_change+1,(unsigned char *)tex_image+start_change*width*4);
 					start_change=-1;
 					last_change=-1;
@@ -121,9 +146,16 @@
 		tex_image=otex_image;
 		otex_image=swap_timg;
 	}
-	XDestroyImage(image);
+	gettimeofday(&end,NULL);
+	count[2]+=(end.tv_sec-start.tv_sec)*10000000 + end.tv_usec-start.tv_usec;
+	start.tv_sec	=end.tv_sec;
+	start.tv_usec 	=end.tv_usec;
+	iterations++;
+/*	XDestroyImage(image);*/
+	for (x=0;x<3;x++)
+		printf("[%d] %f\n",x,count[x]/iterations);
 
-	nanosleep(&t,NULL); 
+/*	nanosleep(&t,NULL); */
 }
 void keypress(struct s3d_evt *event)
 {
@@ -152,7 +184,11 @@
 }
 void mouseclick(struct s3d_evt *event)
 {
-	printf("not processing mouse clicks yet ... \n");
+	int i;
+	printf("thats it, collecting:\n");
+	for (i=0;i<3;i++)
+		printf("[%d] %f\n",i,count[i]/iterations);
+	exit(0);	
 }
 int main(int argc, char **argv)
 {
@@ -167,12 +203,16 @@
 		printf("couldn't open display\n");
 		return(-1);
 	}
+	count[0]=count[1]=count[2]=0;
+	iterations=0;
 	if (!s3d_init(&argc,&argv,"X11-gate"))
 	{
 		scr = DefaultScreen(dpy);
 		window = RootWindow(dpy, scr);
 		width = DisplayWidth(dpy, scr);
 		height = DisplayHeight(dpy, scr);
+		visual= DefaultVisual(dpy, scr);
+		depth = DefaultDepth(dpy, scr);
 		XLockDisplay(dpy);
 		xt=XTestQueryExtension(dpy,&a,&b,&c,&d);
 		XUnlockDisplay(dpy);
@@ -180,6 +220,19 @@
 		{
 			printf("having xtest extension ...\n");
 		}
+/* X11 shm - http://www.xfree86.org/current/mit-shm.html */
+		
+		image= XShmCreateImage(dpy, visual, depth, ZPixmap, NULL, &shminfo, width, height);
+		shminfo.shmid = shmget(IPC_PRIVATE, image->bytes_per_line * image->height, IPC_CREAT|0777);
+		shminfo.shmaddr = image->data = shmat (shminfo.shmid, 0, 0);
+		shmctl(shminfo.shmid, IPC_RMID, 0);
+		shminfo.readOnly= False;
+		if (!XShmAttach(dpy, &shminfo)) 
+			printf("cannot use the shared memory segment .. :( \n");
+		else
+			printf("can use share segment :D\n");
+		XSync(dpy, False);
+		
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,mouseclick);
 		s3d_set_callback(S3D_EVENT_KEY,keypress);
 		printf("screen: %dx%d\n",width,height);
@@ -207,7 +260,8 @@
 		s3d_push_texture(oid,width,height);
 					 /*  push data on texture 0 position (0,0) */
 		s3d_pep_material_texture(oid,0);	 /*  assign texture 0 to material 0 */
-		s3d_flags_on(oid,S3D_OF_VISIBLE);
+		s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		gettimeofday(&start,NULL);
 		s3d_mainloop(mainloop);
 		free(img1);
 		free(img2);



From marec at mail.berlios.de  Sun Sep 17 15:28:46 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Sun, 17 Sep 2006 15:28:46 +0200
Subject: [S3d-svn] r396 - in trunk: apps/olsrs3d libs3d
Message-ID: <200609171328.k8HDSknb001541@sheep.berlios.de>

Author: marec
Date: 2006-09-17 15:28:46 +0200 (Sun, 17 Sep 2006)
New Revision: 396

Modified:
   trunk/apps/olsrs3d/main.c
   trunk/libs3d/modelread.c
Log:
olsrs3d help window

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-16 23:15:42 UTC (rev 395)
+++ trunk/apps/olsrs3d/main.c	2006-09-17 13:28:46 UTC (rev 396)
@@ -104,7 +104,36 @@
 }
 
 
+void close_win(s3dw_widget *button) {
+	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
+}
 
+
+
+void window_help() {
+
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+
+	infwin = s3dw_surface_new( "Help Window", 12, 14 );
+	s3dw_label_new(infwin,"C        - Colour On/Off",1,2);
+	s3dw_label_new(infwin,"R        - Rotation On/Off",1,3);
+	s3dw_label_new(infwin,"+        - Increase Rotation Speed",1,4);
+	s3dw_label_new(infwin,"-        - Decrease Rotation Speed",1,5);
+	s3dw_label_new(infwin,"S        - Search IP",1,6);
+	s3dw_label_new(infwin,"ESC      - Disable FollowMode",1,7);
+	s3dw_label_new(infwin,"PGUP     - Increase Drift Factor",1,8);
+	s3dw_label_new(infwin,"PGDOWN   - Decrease Drift Factor",1,9);
+	s3dw_label_new(infwin,"STRG + P - Decrease Drift Factor",1,9);
+
+	button=s3dw_button_new(infwin,"OK",4,12);
+	button->onclick = close_win;
+	s3dw_show(S3DWIDGET(infwin));
+
+}
+
+
+
 /***
  *
  * print error and exit
@@ -640,7 +669,7 @@
 	int net_result;   /* result of function net_main */
 	char nc_str[20];
 	float strLen;
-	
+
 	/* calculate new movement vector */
 	calc_olsr_node_mov();
 
@@ -679,10 +708,10 @@
 			break;
 		}
 	}
-	
+
 	/* rotate modus */
 	if(RotateSwitch) {
-		Zp_rotate = ( Zp_rotate + RotateSpeed ) > 360 ? 0.0 : ( Zp_rotate + RotateSpeed );	
+		Zp_rotate = ( Zp_rotate + RotateSpeed ) > 360 ? 0.0 : ( Zp_rotate + RotateSpeed );
 		s3d_rotate(ZeroPoint,0,Zp_rotate,0);
 	}
 
@@ -698,8 +727,8 @@
 		follow_node( CamPosition[0], CamPosition[1], Zp_rotate );
 	if( get_search_status() == ABORT )
 		move_to_return_point( CamPosition[0], CamPosition[1] );
-	
 
+
 	if( Olsr_ip_label_obj != -1 )
 	{
 		print_etx();
@@ -727,35 +756,40 @@
 void keypress(struct s3d_evt *event) {
 
 	struct s3d_key_event *key=(struct s3d_key_event *)event->buf;
-	printf("%d\n",key->unicode);	
+	printf("%d\n",key->unicode);
 	if( get_search_status() != WIDGET )
 	{
 		switch(key->unicode)
 		{
+			case S3DK_F1: /* help */
+				printf("S3DK_F1\n");
+				window_help();
+				break;
+
 			case S3DK_ESCAPE: /* abort action */
-			
+
 				set_search_status( get_search_status() == WIDGET ? ABORT : NOTHING );
 				break;
-				
+
 			case S3DK_s: /* move to search widget, give widget focus */
 
 				set_search_status(WIDGET);							/* set status for mainloop */
 				set_return_point(CamPosition[0],CamPosition[1]);	/* save the return position */
 				set_node_root( Olsr_root );
 				break;
-			
+
 			case S3DK_c: /* color on/off */
-				
+
 				ColorSwitch =  ColorSwitch ? 0 : 1;
 				break;
-				
+
 			case S3DK_r: /* rotate start/stop*/
-				
+
 				RotateSwitch = RotateSwitch ? 0 : 1;
 				break;
-				
+
 			case S3DK_PLUS: /* rotate speed increase */
-				
+
 				if(RotateSwitch && RotateSpeed < 5)
 				{
 					if(RotateSpeed >= 1.0)
@@ -765,9 +799,9 @@
 					printf("%f,\n",RotateSpeed);
 				}
 				break;
-				
+
 			case S3DK_MINUS: /* - -> rotate speed decrease */
-				
+
 				if(RotateSwitch)
 				{
 					if( RotateSpeed >= 2.0 )
@@ -779,25 +813,25 @@
 					printf("%f,\n",RotateSpeed);
 				}
 				break;
-				
+
 			case 16: /* strg + p -> reset nodes ( zeroPoint to 0,0,0 ) */
-				
+
 				s3d_rotate(ZeroPoint, 0, 0, 0);
 				Zp_rotate = 0.0;
 				break;
-				
+
 			case S3DK_PAGEUP: /* change factor in calc_olsr_node_mov */
-				
+
 				if(Factor < 0.9)
 					Factor += 0.1;
 				break;
-				
+
 			case S3DK_PAGEDOWN: /* change factor in calc_olsr_node_mov */
-				
+
 				if(Factor > 0.3)
 					Factor -= 0.1;
 				break;
-				
+
 		}
 	} else {
 		if( (key->unicode >= S3DK_PERIOD && key->unicode <= S3DK_9) || key->unicode == S3DK_COMMA || key->unicode == S3DK_RETURN || key->unicode == S3DK_BACKSPACE )
@@ -818,10 +852,10 @@
 
 	if( get_search_status() == WIDGET )
 	{
-		s3dw_handle_click(evt);	
+		s3dw_handle_click(evt);
 		return;
 	}
-	
+
 	oid=(int)*((unsigned long *)evt->buf);
 
 	if( oid == Btn_close_id )
@@ -854,7 +888,7 @@
 			s3d_scale( Btn_close_id, 0.10 );
 			s3d_translate( Btn_close_id,-Left*3.0-0.150, -Bottom*3.0-0.9, -3.0 );
 		}
-		
+
 		if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
 		snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
 		Olsr_ip_label_obj = s3d_draw_string( ip_str, &Title_len );
@@ -872,7 +906,7 @@
 		s3d_scale( Olsr_ip_label_obj, 0.2 );
 		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
 		*/
-	} 
+	}
 }
 
 void print_etx()
@@ -1087,11 +1121,11 @@
 			Olsr_node_inet_obj = s3d_import_model_file( "objs/accesspoint_inet.3ds" );
 			Olsr_node_hna_net = s3d_import_model_file( "objs/internet.3ds" );
 			Btn_close_obj = s3d_import_model_file( "objs/btn_close.3ds" );
-			create_search_widget( 0, 0, 300 );			
-			
+			create_search_widget( 0, 0, 300 );
+
 			ZeroPoint = s3d_new_object();
 			Output_border[0] = Output_border[1] = Output_border[2] = Output_border[3] = -1;
-			
+
 			s3d_mainloop(mainloop);
 			s3d_quit();
 			net_quit();

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2006-09-16 23:15:42 UTC (rev 395)
+++ trunk/libs3d/modelread.c	2006-09-17 13:28:46 UTC (rev 396)
@@ -156,9 +156,9 @@
 				object->vertex_data[j * 3 + 1] = swaph;
 			}
 			s3d_push_vertices( obj_id, object->vertex_data, object->vertex_count);
-					
 
 
+
 			oface = object->faces;
 			npoly=0;
 			oldflags = ((G3DFace *) (oface->data))->flags;
@@ -169,7 +169,7 @@
 				mat2tex = get_mat2tex( &mat2tex_root, face->material );
 
 				if ( mat2tex->material_id == -1 ) { /* create a new texture if nothing found */
-					s3d_push_material_a( obj_id, 	face->material->r, face->material->g, face->material->b,face->material->a, 
+					s3d_push_material_a( obj_id, 	face->material->r, face->material->g, face->material->b,face->material->a,
 													face->material->specular[0], face->material->specular[1], face->material->specular[2], face->material->specular[3],
 													face->material->r, face->material->g, face->material->b, face->material->a );
 
@@ -188,13 +188,22 @@
 							exit(8);
 						}
 
-						for ( j = ( face->tex_image->height - 1 ); j >= 0; j-- ) {
+						/*for ( j = ( face->tex_image->height - 1 ); j >= 0; j-- ) {
 							for ( k = 0; k < face->tex_image->width; k++ ) {
 								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ];
 								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ];
 								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ];
 								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ];
 							}
+					}*/
+
+						for ( j = ( face->tex_image->height - 1 ); j >= 0; j-- ) {
+							for ( k = 0; k < face->tex_image->width; k++ ) {
+								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ];
+								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ];
+								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ];
+								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ];
+							}
 						}
 
 						s3d_push_texture( obj_id, face->tex_image->width, face->tex_image->height );
@@ -233,7 +242,7 @@
 					normalbuf[ npoly*9 + 7] = -face->normals[ 5 ];
 					normalbuf[ npoly*9 + 8] =  face->normals[ 4 ];
 				}
-				if ( face->flags & G3D_FLAG_FAC_TEXMAP )  
+				if ( face->flags & G3D_FLAG_FAC_TEXMAP )
 				{
 					texcoordbuf[ npoly*6 + 0] = face->tex_vertex_data[ 0 ];
 					texcoordbuf[ npoly*6 + 1] = face->tex_vertex_data[ 1 ];
@@ -253,14 +262,14 @@
 				if (oldflags & G3D_FLAG_FAC_TEXMAP)			s3d_pep_polygon_tex_coords( obj_id, texcoordbuf, npoly);
 				npoly=0;
 			}
-	
+
 			voff += object->vertex_count; /* increase vertex offset */
 			oitem = oitem->next;
 		}
 	}
 	g3d_model_free(model);
 	g3d_context_free(context);
-	
+
 	return(obj_id);
 }
 



From dotslash at mail.berlios.de  Sun Sep 17 15:38:59 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 17 Sep 2006 15:38:59 +0200
Subject: [S3d-svn] r397 - trunk/apps/olsrs3d
Message-ID: <200609171338.k8HDcxx7002615@sheep.berlios.de>

Author: dotslash
Date: 2006-09-17 15:38:59 +0200 (Sun, 17 Sep 2006)
New Revision: 397

Modified:
   trunk/apps/olsrs3d/main.c
Log:
- keycodes

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-17 13:28:46 UTC (rev 396)
+++ trunk/apps/olsrs3d/main.c	2006-09-17 13:38:59 UTC (rev 397)
@@ -759,7 +759,7 @@
 	printf("%d\n",key->unicode);
 	if( get_search_status() != WIDGET )
 	{
-		switch(key->unicode)
+		switch(key->keysym)
 		{
 			case S3DK_F1: /* help */
 				printf("S3DK_F1\n");
@@ -814,10 +814,13 @@
 				}
 				break;
 
-			case 16: /* strg + p -> reset nodes ( zeroPoint to 0,0,0 ) */
+			case S3DK_p: /* strg + p -> reset nodes ( zeroPoint to 0,0,0 ) */
+				if (key->modifier&(S3D_KMOD_LCTRL|S3D_KMOD_RCTRL))
+				{
 
-				s3d_rotate(ZeroPoint, 0, 0, 0);
-				Zp_rotate = 0.0;
+					s3d_rotate(ZeroPoint, 0, 0, 0);
+					Zp_rotate = 0.0;
+				}
 				break;
 
 			case S3DK_PAGEUP: /* change factor in calc_olsr_node_mov */



From marec at mail.berlios.de  Sun Sep 17 15:46:32 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Sun, 17 Sep 2006 15:46:32 +0200
Subject: [S3d-svn] r398 - trunk/libs3d
Message-ID: <200609171346.k8HDkWpU003215@sheep.berlios.de>

Author: marec
Date: 2006-09-17 15:46:32 +0200 (Sun, 17 Sep 2006)
New Revision: 398

Modified:
   trunk/libs3d/modelread.c
Log:
color swap undone

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2006-09-17 13:38:59 UTC (rev 397)
+++ trunk/libs3d/modelread.c	2006-09-17 13:46:32 UTC (rev 398)
@@ -188,22 +188,13 @@
 							exit(8);
 						}
 
-						/*for ( j = ( face->tex_image->height - 1 ); j >= 0; j-- ) {
+						for ( j = ( face->tex_image->height - 1 ); j >= 0; j-- ) {
 							for ( k = 0; k < face->tex_image->width; k++ ) {
 								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ];
 								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ];
 								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ];
 								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ];
 							}
-					}*/
-
-						for ( j = ( face->tex_image->height - 1 ); j >= 0; j-- ) {
-							for ( k = 0; k < face->tex_image->width; k++ ) {
-								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ];
-								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 1 ];
-								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 2 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ];
-								s3d_pixeldata[ ( j * face->tex_image->width + k ) * 4 + 3 ] = face->tex_image->pixeldata[ ( j * face->tex_image->width + k ) * 4 + 0 ];
-							}
 						}
 
 						s3d_push_texture( obj_id, face->tex_image->width, face->tex_image->height );



From dotslash at mail.berlios.de  Sun Sep 17 15:55:23 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 17 Sep 2006 15:55:23 +0200
Subject: [S3d-svn] r399 - trunk/apps/olsrs3d
Message-ID: <200609171355.k8HDtNWY003908@sheep.berlios.de>

Author: dotslash
Date: 2006-09-17 15:55:22 +0200 (Sun, 17 Sep 2006)
New Revision: 399

Modified:
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/search.c
Log:
- window following in olsrs3d on

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-17 13:46:32 UTC (rev 398)
+++ trunk/apps/olsrs3d/main.c	2006-09-17 13:55:22 UTC (rev 399)
@@ -733,6 +733,7 @@
 	{
 		print_etx();
 	}
+	s3dw_ani_mate();
 
 	nanosleep( &sleep_time, NULL );
 
@@ -756,7 +757,6 @@
 void keypress(struct s3d_evt *event) {
 
 	struct s3d_key_event *key=(struct s3d_key_event *)event->buf;
-	printf("%d\n",key->unicode);
 	if( get_search_status() != WIDGET )
 	{
 		switch(key->keysym)
@@ -1033,6 +1033,7 @@
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz->buf;
+	s3dw_object_info(hrmz);
 	if (inf->object==0)
 	{
 		CamPosition[0][0] = inf->trans_x;

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2006-09-17 13:46:32 UTC (rev 398)
+++ trunk/apps/olsrs3d/search.c	2006-09-17 13:55:22 UTC (rev 399)
@@ -101,12 +101,13 @@
 	s3dw_focus	( S3DWIDGET( _search_input ) );	
 	s3dw_focus	( S3DWIDGET( _search_surface ) );
 	s3dw_show	( S3DWIDGET( _search_surface ) );
-	
-	_search_widget	= s3dw_getroot();
+
+	/* disabled for autofollowing mode */
+	/*_search_widget	= s3dw_getroot();
 	move_search_widget( x, y, z );
 
 	_search_widget->ary = 180;
-	s3d_rotate( _search_widget->oid, _search_widget->arx, _search_widget->ary, _search_widget->arz );
+	s3d_rotate( _search_widget->oid, _search_widget->arx, _search_widget->ary, _search_widget->arz );*/
 }
 
 /* public */



From dotslash at mail.berlios.de  Sun Sep 17 16:52:32 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 17 Sep 2006 16:52:32 +0200
Subject: [S3d-svn] r400 - trunk/apps/olsrs3d
Message-ID: <200609171452.k8HEqWUP008770@sheep.berlios.de>

Author: dotslash
Date: 2006-09-17 16:52:32 +0200 (Sun, 17 Sep 2006)
New Revision: 400

Modified:
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/olsrs3d.h
   trunk/apps/olsrs3d/search.c
   trunk/apps/olsrs3d/search.h
Log:
- popping search window

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-17 13:55:22 UTC (rev 399)
+++ trunk/apps/olsrs3d/main.c	2006-09-17 14:52:32 UTC (rev 400)
@@ -133,7 +133,19 @@
 }
 
 
+void window_error(char *msg) {
 
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+
+	infwin = s3dw_surface_new( "Error", 12, 6 );
+	s3dw_label_new(infwin,msg,1,2);
+
+	button=s3dw_button_new(infwin,"OK",4,4);
+	button->onclick = close_win;
+	s3dw_show(S3DWIDGET(infwin));
+
+}
 /***
  *
  * print error and exit
@@ -721,12 +733,12 @@
 	CamPosition2[0][2]=  CamPosition[0][0]*sin(Zp_rotate*M_PI/180.0) + CamPosition[0][2] * cos (Zp_rotate*M_PI/180.0);
 
 	/* check search status */
-	if( get_search_status() == WIDGET )
-		move_to_search_widget( CamPosition[0], CamPosition[1] );
+/*	if( get_search_status() == WIDGET )
+		move_to_search_widget( CamPosition[0], CamPosition[1] );*/
 	if( get_search_status() == FOLLOW )
 		follow_node( CamPosition[0], CamPosition[1], Zp_rotate );
-	if( get_search_status() == ABORT )
-		move_to_return_point( CamPosition[0], CamPosition[1] );
+/*	if( get_search_status() == ABORT )
+		move_to_return_point( CamPosition[0], CamPosition[1] );*/
 
 
 	if( Olsr_ip_label_obj != -1 )
@@ -774,8 +786,10 @@
 			case S3DK_s: /* move to search widget, give widget focus */
 
 				set_search_status(WIDGET);							/* set status for mainloop */
-				set_return_point(CamPosition[0],CamPosition[1]);	/* save the return position */
-				set_node_root( Olsr_root );
+				show_search_window();
+/*				set_return_point(CamPosition[0],CamPosition[1]);	/ * save the return position * /
+				set_node_root( Olsr_root );*/
+				
 				break;
 
 			case S3DK_c: /* color on/off */
@@ -853,11 +867,12 @@
 	int oid,i;
 	char ip_str[50];
 
-	if( get_search_status() == WIDGET )
+	s3dw_handle_click(evt);
+/*	if( get_search_status() == WIDGET )
 	{
 		s3dw_handle_click(evt);
 		return;
-	}
+	}*/
 
 	oid=(int)*((unsigned long *)evt->buf);
 
@@ -1125,7 +1140,7 @@
 			Olsr_node_inet_obj = s3d_import_model_file( "objs/accesspoint_inet.3ds" );
 			Olsr_node_hna_net = s3d_import_model_file( "objs/internet.3ds" );
 			Btn_close_obj = s3d_import_model_file( "objs/btn_close.3ds" );
-			create_search_widget( 0, 0, 300 );
+/*			create_search_widget( 0, 0, 300 );*/
 
 			ZeroPoint = s3d_new_object();
 			Output_border[0] = Output_border[1] = Output_border[2] = Output_border[3] = -1;

Modified: trunk/apps/olsrs3d/olsrs3d.h
===================================================================
--- trunk/apps/olsrs3d/olsrs3d.h	2006-09-17 13:55:22 UTC (rev 399)
+++ trunk/apps/olsrs3d/olsrs3d.h	2006-09-17 14:52:32 UTC (rev 400)
@@ -72,3 +72,4 @@
 struct olsr_node **lst_search(int id);
 void print_etx( void );
 float dist(float p1[], float p2[]);
+void window_error(char *msg); 

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2006-09-17 13:55:22 UTC (rev 399)
+++ trunk/apps/olsrs3d/search.c	2006-09-17 14:52:32 UTC (rev 400)
@@ -27,7 +27,8 @@
 #include <math.h>
 #include <stdio.h>	/* TODO can remove then no more printf needed */
 #include <string.h>
-#include "structs.h"
+#include "olsrs3d.h"	/* for window_error(), structs */
+/* #include "structs.h"  already included by olsrs3d.h */
 #include "search.h"
 
 s3dw_surface	*_search_surface;
@@ -41,8 +42,10 @@
 int		_search_status = NOTHING;			/* status of search */
 											
 void _search_node(s3dw_widget *dummy);
+void _new_search_node(s3dw_widget *dummy);
 void _abort_search(s3dw_widget *dummy);
 
+
 /* public */
 void follow_node(float cam_position_t[], float cam_position_r[],float rotate)
 {
@@ -79,7 +82,37 @@
 	s3d_translate( 0, cam_position_t[0], cam_position_t[1], cam_position_t[2] );
 	s3d_rotate( 0, cam_position_r[0], cam_position_r[1], cam_position_r[2] );
 }
+void _abort_search_window(s3dw_widget *bwidget)
+{
+	s3dw_delete(bwidget->parent); /* remove the window cointaining the button */
+	_search_surface=NULL;
+	_search_input=NULL;
+	_search_widget=NULL;
+	set_search_status(NOTHING);
+}
+void show_search_window()
+{
+	s3dw_button *search_button, *abort_button;
+	
+	_search_surface	= s3dw_surface_new( "Node Search", 17, 10 );
+	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
+	
+	s3dw_label_new( _search_surface, "Enter the IP of the node.", 1, 2);
+	s3dw_focus( S3DWIDGET( _search_input ) );
+	
+	search_button = s3dw_button_new( _search_surface, "Search", 11.5, 7 );
+	abort_button  = s3dw_button_new( _search_surface, "Abort", 1, 7 );
+	search_button->onclick = _new_search_node;
+	abort_button->onclick = _abort_search_window;
 
+	/* TODO calc position for ok button */
+	
+	s3dw_focus	( S3DWIDGET( _search_input ) );	
+	s3dw_focus	( S3DWIDGET( _search_surface ) );
+	s3dw_show	( S3DWIDGET( _search_surface ) );
+
+}
+
 /* public */
 void create_search_widget(float x, float y, float z)
 {
@@ -216,6 +249,11 @@
 }
 
 /* public */
+/* TODO: WTF?! 
+ * please fix: 
+ *  - s is not initialized but still strlen() is used?! 
+ *  - s will vanish after the function is processed. global variable would be better
+ *  - don't forget the terminating \0 after writing a key */
 void search_widget_write(int key)
 {
 	static char s[20];
@@ -267,7 +305,46 @@
 {
 	_node_root = root;
 }
+/* private */
+void _new_search_node(s3dw_widget *dummy)
+{
+	char *ip;
+	int result;
+	
+	search_node = &_node_root;
+	
+	ip = s3dw_input_gettext( _search_input );
+	
+	while ( (*search_node) != NULL )
+	{
 
+		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
+
+		if ( result == 0 ) 
+			break;
+		
+		if ( result < 0 )
+			(*search_node) = (*search_node)->right;
+		else
+			(*search_node) = (*search_node)->left;
+	}
+	s3dw_delete(dummy->parent); /* remove the window cointaining the button */
+	_search_surface=NULL;
+	_search_input=NULL;
+	_search_widget=NULL;
+
+
+	if( (*search_node) != NULL )
+	{
+		window_error("Okay, following");
+		set_search_status( FOLLOW );
+	}
+	else
+	{
+		window_error("Sorry, could not find...");
+		set_search_status( NOTHING );
+	}
+}
 /* private */
 void _search_node(s3dw_widget *dummy)
 {

Modified: trunk/apps/olsrs3d/search.h
===================================================================
--- trunk/apps/olsrs3d/search.h	2006-09-17 13:55:22 UTC (rev 399)
+++ trunk/apps/olsrs3d/search.h	2006-09-17 14:52:32 UTC (rev 400)
@@ -37,3 +37,4 @@
 void set_node_root(struct olsr_node *root);
 void follow_node(float cam_position_t[], float cam_position_r[],float rotate);
 
+void show_search_window();



From dotslash at mail.berlios.de  Sun Sep 17 17:06:31 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 17 Sep 2006 17:06:31 +0200
Subject: [S3d-svn] r401 - trunk/apps/olsrs3d
Message-ID: <200609171506.k8HF6Vvj009809@sheep.berlios.de>

Author: dotslash
Date: 2006-09-17 17:06:30 +0200 (Sun, 17 Sep 2006)
New Revision: 401

Modified:
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/search.c
Log:
- some more search window stuff

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-17 14:52:32 UTC (rev 400)
+++ trunk/apps/olsrs3d/main.c	2006-09-17 15:06:30 UTC (rev 401)
@@ -851,8 +851,8 @@
 
 		}
 	} else {
-		if( (key->unicode >= S3DK_PERIOD && key->unicode <= S3DK_9) || key->unicode == S3DK_COMMA || key->unicode == S3DK_RETURN || key->unicode == S3DK_BACKSPACE )
-			search_widget_write( key->unicode );
+		if( (key->keysym >= S3DK_PERIOD && key->keysym <= S3DK_9) || key->keysym == S3DK_COMMA || key->keysym == S3DK_RETURN || key->keysym == S3DK_BACKSPACE )
+			search_widget_write( key->keysym );
 	}
 }
 

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2006-09-17 14:52:32 UTC (rev 400)
+++ trunk/apps/olsrs3d/search.c	2006-09-17 15:06:30 UTC (rev 401)
@@ -378,5 +378,3 @@
 {
 	set_search_status(ABORT);
 }
-
-	



From marec at mail.berlios.de  Sun Sep 17 18:02:41 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Sun, 17 Sep 2006 18:02:41 +0200
Subject: [S3d-svn] r402 - in trunk: apps/olsrs3d objs
Message-ID: <200609171602.k8HG2fEQ015635@sheep.berlios.de>

Author: marec
Date: 2006-09-17 18:02:40 +0200 (Sun, 17 Sep 2006)
New Revision: 402

Added:
   trunk/objs/s3d_berlios_de.3ds
Modified:
   trunk/apps/olsrs3d/data_structure.xmi
   trunk/apps/olsrs3d/olsrs3d.h
Log:
s3d banner added

Modified: trunk/apps/olsrs3d/data_structure.xmi
===================================================================
--- trunk/apps/olsrs3d/data_structure.xmi	2006-09-17 15:06:30 UTC (rev 401)
+++ trunk/apps/olsrs3d/data_structure.xmi	2006-09-17 16:02:40 UTC (rev 402)
@@ -1,467 +1,468 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<XMI xmlns:UML="http://schema.omg.org/spec/UML/1.3" verified="false" timestamp="2006-02-28T00:33:34" xmi.version="1.2" >
+<XMI xmlns:UML="http://schema.omg.org/spec/UML/1.3" verified="false" timestamp="2006-09-17T16:20:27" xmi.version="1.2" >
  <XMI.header>
   <XMI.documentation>
    <XMI.exporter>umbrello uml modeller http://uml.sf.net</XMI.exporter>
-   <XMI.exporterVersion>1.4.2</XMI.exporterVersion>
+   <XMI.exporterVersion>1.5.3</XMI.exporterVersion>
    <XMI.exporterEncoding>UnicodeUTF8</XMI.exporterEncoding>
   </XMI.documentation>
   <XMI.metamodel xmi.name="UML" href="UML.xml" xmi.version="1.3" />
  </XMI.header>
  <XMI.content>
-  <UML:Model isSpecification="false" isLeaf="false" isRoot="false" isAbstract="false" >
+  <UML:Model isSpecification="false" isLeaf="false" isRoot="false" xmi.id="m1" isAbstract="false" name="UML-Modell" >
    <UML:Namespace.ownedElement>
-    <UML:Stereotype isSpecification="false" isLeaf="false" visibility="public" xmi.id="788" isRoot="false" isAbstract="false" name="Datentyp" />
-    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" xmi.id="787" isRoot="false" isAbstract="false" name="int" />
-    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" xmi.id="789" isRoot="false" isAbstract="false" name="char" />
-    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" xmi.id="790" isRoot="false" isAbstract="false" name="bool" />
-    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" xmi.id="791" isRoot="false" isAbstract="false" name="float" />
-    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" xmi.id="792" isRoot="false" isAbstract="false" name="double" />
-    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" xmi.id="793" isRoot="false" isAbstract="false" name="long" />
-    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" xmi.id="794" isRoot="false" isAbstract="false" name="short" />
-    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" xmi.id="795" isRoot="false" isAbstract="false" name="string" />
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="800" isRoot="false" isAbstract="false" name="olsr_node - 104.130.1.1" >
+    <UML:Stereotype isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="788" isRoot="false" isAbstract="false" name="Datentyp" />
+    <UML:Stereotype isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="3" isRoot="false" isAbstract="false" name="datatype" />
+    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="787" isRoot="false" isAbstract="false" name="int" />
+    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="789" isRoot="false" isAbstract="false" name="char" />
+    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="790" isRoot="false" isAbstract="false" name="bool" />
+    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="791" isRoot="false" isAbstract="false" name="float" />
+    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="792" isRoot="false" isAbstract="false" name="double" />
+    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="793" isRoot="false" isAbstract="false" name="long" />
+    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="794" isRoot="false" isAbstract="false" name="short" />
+    <UML:DataType stereotype="788" isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="795" isRoot="false" isAbstract="false" name="string" />
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="800" isRoot="false" isAbstract="false" name="olsr_node - 104.130.1.1" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="801" isRoot="false" initialValue="" type="789" isAbstract="false" name="ip" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="802" isRoot="false" initialValue="50" type="787" isAbstract="false" name="last_seen" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="862" isRoot="false" initialValue="104.129.1.1" type="825" isAbstract="false" name="left" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="864" isRoot="false" initialValue="104.130.1.99" type="825" isAbstract="false" name="right" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="801" type="789" name="ip" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="802" initialValue="50" type="787" name="last_seen" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="862" initialValue="104.129.1.1" type="825" name="left" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="864" initialValue="104.130.1.99" type="825" name="right" />
      </UML:Classifier.feature>
      <UML:Namespace.ownedElement>
-      <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="1129" isRoot="false" isAbstract="false" name="olsr_con_list - 104.130.1.1:104.131.1.1" >
+      <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="800" xmi.id="1129" isRoot="false" isAbstract="false" name="olsr_con_list - 104.130.1.1:104.131.1.1" >
        <UML:Classifier.feature>
-        <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1150" isRoot="false" initialValue="NULL" type="1127" isAbstract="false" name="next_olsr_con_list" />
-        <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1151" isRoot="false" initialValue="104.130.1.1:104.131.1.1" type="897" isAbstract="false" name="olsr_con" />
+        <UML:Attribute isSpecification="false" visibility="private" xmi.id="1150" initialValue="NULL" type="1127" name="next_olsr_con_list" />
+        <UML:Attribute isSpecification="false" visibility="private" xmi.id="1151" initialValue="104.130.1.1:104.131.1.1" type="897" name="olsr_con" />
        </UML:Classifier.feature>
       </UML:Class>
      </UML:Namespace.ownedElement>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="803" isRoot="false" isAbstract="false" name="olsr_node - 104.131.1.1" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="803" isRoot="false" isAbstract="false" name="olsr_node - 104.131.1.1" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="804" isRoot="false" initialValue="" type="789" isAbstract="false" name="ip" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="805" isRoot="false" initialValue="50" type="787" isAbstract="false" name="last_seen" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="827" isRoot="false" initialValue="104.130.1.1" type="825" isAbstract="false" name="left" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="828" isRoot="false" initialValue="104.132.1.1" type="825" isAbstract="false" name="right" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="804" type="789" name="ip" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="805" initialValue="50" type="787" name="last_seen" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="827" initialValue="104.130.1.1" type="825" name="left" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="828" initialValue="104.132.1.1" type="825" name="right" />
      </UML:Classifier.feature>
      <UML:Namespace.ownedElement>
-      <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="1210" isRoot="false" isAbstract="false" name="olsr_con_list - 104.131.1.1:104.129.1.1" >
+      <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="803" xmi.id="1210" isRoot="false" isAbstract="false" name="olsr_con_list - 104.131.1.1:104.129.1.1" >
        <UML:Classifier.feature>
-        <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1261" isRoot="false" initialValue="104.131.1.1:104.130.1.1" type="1127" isAbstract="false" name="next_olsr_con_list" />
-        <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1262" isRoot="false" initialValue="104.131.1.1:104.129.1.1" type="897" isAbstract="false" name="olsr_con" />
+        <UML:Attribute isSpecification="false" visibility="private" xmi.id="1261" initialValue="104.131.1.1:104.130.1.1" type="1127" name="next_olsr_con_list" />
+        <UML:Attribute isSpecification="false" visibility="private" xmi.id="1262" initialValue="104.131.1.1:104.129.1.1" type="897" name="olsr_con" />
        </UML:Classifier.feature>
       </UML:Class>
      </UML:Namespace.ownedElement>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="806" isRoot="false" isAbstract="false" name="olsr_node - 104.132.1.1" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="806" isRoot="false" isAbstract="false" name="olsr_node - 104.132.1.1" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="807" isRoot="false" initialValue="" type="789" isAbstract="false" name="ip" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="808" isRoot="false" initialValue="50" type="787" isAbstract="false" name="last_seen" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="860" isRoot="false" initialValue="NULL" type="825" isAbstract="false" name="left" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="861" isRoot="false" initialValue="104.133.1.1" type="825" isAbstract="false" name="right" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="807" type="789" name="ip" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="808" initialValue="50" type="787" name="last_seen" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="860" initialValue="NULL" type="825" name="left" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="861" initialValue="104.133.1.1" type="825" name="right" />
      </UML:Classifier.feature>
      <UML:Namespace.ownedElement>
-      <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="1184" isRoot="false" isAbstract="false" name="olsr_con_list - 104.132.1.1:104.133.1.1" >
+      <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="806" xmi.id="1184" isRoot="false" isAbstract="false" name="olsr_con_list - 104.132.1.1:104.133.1.1" >
        <UML:Classifier.feature>
-        <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1205" isRoot="false" initialValue="NULL" type="1127" isAbstract="false" name="next_olsr_con_list" />
-        <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1206" isRoot="false" initialValue="104.132.1.1:104.133.1.1" type="897" isAbstract="false" name="olsr_con" />
+        <UML:Attribute isSpecification="false" visibility="private" xmi.id="1205" initialValue="NULL" type="1127" name="next_olsr_con_list" />
+        <UML:Attribute isSpecification="false" visibility="private" xmi.id="1206" initialValue="104.132.1.1:104.133.1.1" type="897" name="olsr_con" />
        </UML:Classifier.feature>
       </UML:Class>
      </UML:Namespace.ownedElement>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="825" isRoot="false" isAbstract="false" name="olsr_node" />
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="830" isRoot="false" isAbstract="false" name="olsr_node - 104.129.1.1" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="825" isRoot="false" isAbstract="false" name="olsr_node" />
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="830" isRoot="false" isAbstract="false" name="olsr_node - 104.129.1.1" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="832" isRoot="false" initialValue="" type="789" isAbstract="false" name="ip" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="833" isRoot="false" initialValue="50" type="787" isAbstract="false" name="last_seen" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="835" isRoot="false" initialValue="NULL" type="825" isAbstract="false" name="left" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="836" isRoot="false" initialValue="NULL" type="825" isAbstract="false" name="right" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="832" type="789" name="ip" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="833" initialValue="50" type="787" name="last_seen" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="835" initialValue="NULL" type="825" name="left" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="836" initialValue="NULL" type="825" name="right" />
      </UML:Classifier.feature>
      <UML:Namespace.ownedElement>
-      <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="1082" isRoot="false" isAbstract="false" name="olsr_con_list - 104.129.1.1:104.131.1.1" >
+      <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="830" xmi.id="1082" isRoot="false" isAbstract="false" name="olsr_con_list - 104.129.1.1:104.131.1.1" >
        <UML:Classifier.feature>
-        <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1126" isRoot="false" initialValue="NULL" type="1127" isAbstract="false" name="next_olsr_con_list" />
-        <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1128" isRoot="false" initialValue="104.129.1.1:104.131.1.1" type="897" isAbstract="false" name="olsr_con" />
+        <UML:Attribute isSpecification="false" visibility="private" xmi.id="1126" initialValue="NULL" type="1127" name="next_olsr_con_list" />
+        <UML:Attribute isSpecification="false" visibility="private" xmi.id="1128" initialValue="104.129.1.1:104.131.1.1" type="897" name="olsr_con" />
        </UML:Classifier.feature>
       </UML:Class>
      </UML:Namespace.ownedElement>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="831" isRoot="false" isAbstract="false" name="olsr_node - 104.130.1.99" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="831" isRoot="false" isAbstract="false" name="olsr_node - 104.130.1.99" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="837" isRoot="false" initialValue="" type="789" isAbstract="false" name="ip" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="838" isRoot="false" initialValue="50" type="787" isAbstract="false" name="last_seen" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="840" isRoot="false" initialValue="NULL" type="825" isAbstract="false" name="left" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="841" isRoot="false" initialValue="NULL" type="825" isAbstract="false" name="right" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="837" type="789" name="ip" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="838" initialValue="50" type="787" name="last_seen" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="840" initialValue="NULL" type="825" name="left" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="841" initialValue="NULL" type="825" name="right" />
      </UML:Classifier.feature>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="854" isRoot="false" isAbstract="false" name="olsr_node - 104.133.1.1" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="854" isRoot="false" isAbstract="false" name="olsr_node - 104.133.1.1" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="855" isRoot="false" initialValue="" type="789" isAbstract="false" name="ip" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="856" isRoot="false" initialValue="50" type="787" isAbstract="false" name="last_seen" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="858" isRoot="false" initialValue="NULL" type="825" isAbstract="false" name="left" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="859" isRoot="false" initialValue="NULL" type="825" isAbstract="false" name="right" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="855" type="789" name="ip" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="856" initialValue="50" type="787" name="last_seen" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="858" initialValue="NULL" type="825" name="left" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="859" initialValue="NULL" type="825" name="right" />
      </UML:Classifier.feature>
      <UML:Namespace.ownedElement>
-      <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="1155" isRoot="false" isAbstract="false" name="olsr_con_list - 104.133.1.1:104.132.1.1" >
+      <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="854" xmi.id="1155" isRoot="false" isAbstract="false" name="olsr_con_list - 104.133.1.1:104.132.1.1" >
        <UML:Classifier.feature>
-        <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1179" isRoot="false" initialValue="NULL" type="1127" isAbstract="false" name="next_olsr_con_list" />
-        <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1180" isRoot="false" initialValue="104.133.1.1:104.132.1.1" type="897" isAbstract="false" name="olsr_con" />
+        <UML:Attribute isSpecification="false" visibility="private" xmi.id="1179" initialValue="NULL" type="1127" name="next_olsr_con_list" />
+        <UML:Attribute isSpecification="false" visibility="private" xmi.id="1180" initialValue="104.133.1.1:104.132.1.1" type="897" name="olsr_con" />
        </UML:Classifier.feature>
       </UML:Class>
      </UML:Namespace.ownedElement>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="871" isRoot="false" isAbstract="false" name="olsr_con - 104.131.1.1:104.129.1.1" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="871" isRoot="false" isAbstract="false" name="olsr_con - 104.131.1.1:104.129.1.1" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="896" isRoot="false" initialValue="104.131.1.1:104.130.1.1" type="897" isAbstract="false" name="next_olsr_con" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="898" isRoot="false" initialValue="NULL" type="897" isAbstract="false" name="prev_olsr_con" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="874" isRoot="false" initialValue="104.131.1.1" type="825" isAbstract="false" name="left_olsr_node" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="875" isRoot="false" initialValue="104.129.1.1" type="825" isAbstract="false" name="right_olsr_node" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="896" initialValue="104.131.1.1:104.130.1.1" type="897" name="next_olsr_con" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="898" initialValue="NULL" type="897" name="prev_olsr_con" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="874" initialValue="104.131.1.1" type="825" name="left_olsr_node" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="875" initialValue="104.129.1.1" type="825" name="right_olsr_node" />
      </UML:Classifier.feature>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="882" isRoot="false" isAbstract="false" name="olsr_con - 104.131.1.1:104.130.1.1" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="882" isRoot="false" isAbstract="false" name="olsr_con - 104.131.1.1:104.130.1.1" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="899" isRoot="false" initialValue="104.132.1.1:104.133.1.1" type="897" isAbstract="false" name="next_olsr_con" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="900" isRoot="false" initialValue="104.131.1.1:104.129.1.1" type="897" isAbstract="false" name="prev_olsr_con" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="901" isRoot="false" initialValue="104.131.1.1" type="825" isAbstract="false" name="left_olsr_node" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="902" isRoot="false" initialValue="104.130.1.1" type="825" isAbstract="false" name="right_olsr_node" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="899" initialValue="104.132.1.1:104.133.1.1" type="897" name="next_olsr_con" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="900" initialValue="104.131.1.1:104.129.1.1" type="897" name="prev_olsr_con" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="901" initialValue="104.131.1.1" type="825" name="left_olsr_node" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="902" initialValue="104.130.1.1" type="825" name="right_olsr_node" />
      </UML:Classifier.feature>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="897" isRoot="false" isAbstract="false" name="olsr_con" />
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="915" isRoot="false" isAbstract="false" name="olsr_con - 104.132.1.1:104.133.1.1" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="897" isRoot="false" isAbstract="false" name="olsr_con" />
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="915" isRoot="false" isAbstract="false" name="olsr_con - 104.132.1.1:104.133.1.1" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="916" isRoot="false" initialValue="NULL" type="897" isAbstract="false" name="next_olsr_con" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="917" isRoot="false" initialValue="104.131.1.1:104.130.1.1" type="897" isAbstract="false" name="prev_olsr_con" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="918" isRoot="false" initialValue="104.132.1.1" type="825" isAbstract="false" name="left_olsr_node" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="919" isRoot="false" initialValue="104.133.1.1" type="825" isAbstract="false" name="right_olsr_node" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="916" initialValue="NULL" type="897" name="next_olsr_con" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="917" initialValue="104.131.1.1:104.130.1.1" type="897" name="prev_olsr_con" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="918" initialValue="104.132.1.1" type="825" name="left_olsr_node" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="919" initialValue="104.133.1.1" type="825" name="right_olsr_node" />
      </UML:Classifier.feature>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="933" isRoot="false" isAbstract="false" name="Obj_to_ip" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="933" isRoot="false" isAbstract="false" name="Obj_to_ip" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="934" isRoot="false" initialValue="0" type="787" isAbstract="false" name="Object_id" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="935" isRoot="false" initialValue="" type="825" isAbstract="false" name="olsr_node" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="936" isRoot="false" initialValue="Obj_to_ip - 1" type="933" isAbstract="false" name="next" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="938" isRoot="false" initialValue="Obj_to_ip" type="933" isAbstract="false" name="prev" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="934" initialValue="0" type="787" name="Object_id" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="935" type="825" name="olsr_node" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="936" initialValue="Obj_to_ip - 1" type="933" name="next" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="938" initialValue="Obj_to_ip" type="933" name="prev" />
      </UML:Classifier.feature>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="940" isRoot="false" isAbstract="false" name="Obj_to_ip - 1" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="940" isRoot="false" isAbstract="false" name="Obj_to_ip - 1" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="941" isRoot="false" initialValue="1" type="787" isAbstract="false" name="Object_id" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="942" isRoot="false" initialValue="" type="825" isAbstract="false" name="olsr_node" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="943" isRoot="false" initialValue="Obj_to_ip - 2" type="933" isAbstract="false" name="next" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="944" isRoot="false" initialValue="Obj_to_ip" type="933" isAbstract="false" name="prev" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="941" initialValue="1" type="787" name="Object_id" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="942" type="825" name="olsr_node" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="943" initialValue="Obj_to_ip - 2" type="933" name="next" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="944" initialValue="Obj_to_ip" type="933" name="prev" />
      </UML:Classifier.feature>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="967" isRoot="false" isAbstract="false" name="Obj_to_ip - 2" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="967" isRoot="false" isAbstract="false" name="Obj_to_ip - 2" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="968" isRoot="false" initialValue="2" type="787" isAbstract="false" name="Object_id" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="969" isRoot="false" initialValue="" type="825" isAbstract="false" name="olsr_node" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="970" isRoot="false" initialValue="Obj_to_ip - 3" type="933" isAbstract="false" name="next" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="971" isRoot="false" initialValue="Obj_to_ip - 1" type="933" isAbstract="false" name="prev" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="968" initialValue="2" type="787" name="Object_id" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="969" type="825" name="olsr_node" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="970" initialValue="Obj_to_ip - 3" type="933" name="next" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="971" initialValue="Obj_to_ip - 1" type="933" name="prev" />
      </UML:Classifier.feature>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="1004" isRoot="false" isAbstract="false" name="Obj_to_ip -3" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="1004" isRoot="false" isAbstract="false" name="Obj_to_ip -3" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1005" isRoot="false" initialValue="0" type="787" isAbstract="false" name="Object_id" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1006" isRoot="false" initialValue="" type="825" isAbstract="false" name="olsr_node" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1007" isRoot="false" initialValue="Obj_to_ip - 3" type="933" isAbstract="false" name="next" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1008" isRoot="false" initialValue="Obj_to_ip - 2" type="933" isAbstract="false" name="prev" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="1005" initialValue="0" type="787" name="Object_id" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="1006" type="825" name="olsr_node" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="1007" initialValue="Obj_to_ip - 3" type="933" name="next" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="1008" initialValue="Obj_to_ip - 2" type="933" name="prev" />
      </UML:Classifier.feature>
     </UML:Class>
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="1127" isRoot="false" isAbstract="false" name="olsr_con_list" />
-    <UML:Class isSpecification="false" isLeaf="false" visibility="public" xmi.id="1234" isRoot="false" isAbstract="false" name="olsr_con_list - 104.131.1.1:104.130.1.1" >
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="1127" isRoot="false" isAbstract="false" name="olsr_con_list" />
+    <UML:Class isSpecification="false" isLeaf="false" visibility="public" namespace="m1" xmi.id="1234" isRoot="false" isAbstract="false" name="olsr_con_list - 104.131.1.1:104.130.1.1" >
      <UML:Classifier.feature>
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1263" isRoot="false" initialValue="NULL" type="1127" isAbstract="false" name="next_olsr_con_list" />
-      <UML:Attribute isSpecification="false" isLeaf="false" visibility="private" xmi.id="1264" isRoot="false" initialValue="104.131.1.1:104.130.1.1" type="897" isAbstract="false" name="olsr_con" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="1263" initialValue="NULL" type="1127" name="next_olsr_con_list" />
+      <UML:Attribute isSpecification="false" visibility="private" xmi.id="1264" initialValue="104.131.1.1:104.130.1.1" type="897" name="olsr_con" />
      </UML:Classifier.feature>
     </UML:Class>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="809" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="809" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="810" aggregation="none" type="803" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="811" aggregation="none" type="800" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="812" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="812" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="813" aggregation="none" type="803" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="814" aggregation="none" type="806" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="842" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="842" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="843" aggregation="none" type="800" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="844" aggregation="none" type="830" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="845" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="845" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="846" aggregation="none" type="800" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="847" aggregation="none" type="831" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="865" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="865" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="866" aggregation="none" type="806" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="867" aggregation="none" type="854" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Dependency isSpecification="false" visibility="public" xmi.id="879" client="871" name="" supplier="830" />
-    <UML:Dependency isSpecification="false" visibility="public" xmi.id="893" client="871" name="" supplier="803" />
-    <UML:Association isSpecification="false" visibility="public" xmi.id="903" name="" >
+    <UML:Dependency isSpecification="false" visibility="public" namespace="m1" xmi.id="879" client="871" name="" supplier="830" />
+    <UML:Dependency isSpecification="false" visibility="public" namespace="m1" xmi.id="893" client="871" name="" supplier="803" />
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="903" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="904" aggregation="none" type="871" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="905" aggregation="none" type="882" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="906" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="906" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="907" aggregation="none" type="882" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="908" aggregation="none" type="871" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Dependency isSpecification="false" visibility="public" xmi.id="909" client="882" name="" supplier="803" />
-    <UML:Dependency isSpecification="false" visibility="public" xmi.id="912" client="882" name="" supplier="800" />
-    <UML:Dependency isSpecification="false" visibility="public" xmi.id="920" client="915" name="" supplier="806" />
-    <UML:Dependency isSpecification="false" visibility="public" xmi.id="923" client="915" name="" supplier="854" />
-    <UML:Association isSpecification="false" visibility="public" xmi.id="926" name="" >
+    <UML:Dependency isSpecification="false" visibility="public" namespace="m1" xmi.id="909" client="882" name="" supplier="803" />
+    <UML:Dependency isSpecification="false" visibility="public" namespace="m1" xmi.id="912" client="882" name="" supplier="800" />
+    <UML:Dependency isSpecification="false" visibility="public" namespace="m1" xmi.id="920" client="915" name="" supplier="806" />
+    <UML:Dependency isSpecification="false" visibility="public" namespace="m1" xmi.id="923" client="915" name="" supplier="854" />
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="926" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="927" aggregation="none" type="882" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="928" aggregation="none" type="915" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="929" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="929" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="930" aggregation="none" type="915" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="931" aggregation="none" type="882" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="1049" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="1049" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="1050" aggregation="none" type="933" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="1051" aggregation="none" type="933" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="1053" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="1053" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="1054" aggregation="none" type="967" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="1055" aggregation="none" type="1004" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="1056" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="1056" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="1057" aggregation="none" type="1004" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="1058" aggregation="none" type="967" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="1059" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="1059" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="1060" aggregation="none" type="940" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="1061" aggregation="none" type="967" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="1062" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="1062" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="1063" aggregation="none" type="967" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="1064" aggregation="none" type="940" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="1065" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="1065" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="1066" aggregation="none" type="933" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="1067" aggregation="none" type="940" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="1068" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="1068" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="1069" aggregation="none" type="940" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="1070" aggregation="none" type="933" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="1071" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="1071" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="1072" aggregation="none" type="933" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="1073" aggregation="none" type="933" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="1074" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="1074" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="1075" aggregation="none" type="1004" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="1076" aggregation="none" type="1004" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Association isSpecification="false" visibility="public" xmi.id="1077" name="" >
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="1077" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="1078" aggregation="none" type="1004" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="1079" aggregation="none" type="1004" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Dependency isSpecification="false" visibility="public" xmi.id="1123" client="1082" name="" supplier="871" />
-    <UML:Dependency isSpecification="false" visibility="public" xmi.id="1152" client="1129" name="" supplier="882" />
-    <UML:Dependency isSpecification="false" visibility="public" xmi.id="1181" client="1155" name="" supplier="915" />
-    <UML:Dependency isSpecification="false" visibility="public" xmi.id="1207" client="1184" name="" supplier="915" />
-    <UML:Dependency isSpecification="false" visibility="public" xmi.id="1231" client="1210" name="" supplier="871" />
-    <UML:Association isSpecification="false" visibility="public" xmi.id="1255" name="" >
+    <UML:Dependency isSpecification="false" visibility="public" namespace="m1" xmi.id="1123" client="1082" name="" supplier="871" />
+    <UML:Dependency isSpecification="false" visibility="public" namespace="m1" xmi.id="1152" client="1129" name="" supplier="882" />
+    <UML:Dependency isSpecification="false" visibility="public" namespace="m1" xmi.id="1181" client="1155" name="" supplier="915" />
+    <UML:Dependency isSpecification="false" visibility="public" namespace="m1" xmi.id="1207" client="1184" name="" supplier="915" />
+    <UML:Dependency isSpecification="false" visibility="public" namespace="m1" xmi.id="1231" client="1210" name="" supplier="871" />
+    <UML:Association isSpecification="false" visibility="public" namespace="m1" xmi.id="1255" name="" >
      <UML:Association.connection>
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="false" xmi.id="1256" aggregation="none" type="1210" name="" />
       <UML:AssociationEnd isSpecification="false" visibility="public" changeability="changeable" isNavigable="true" xmi.id="1257" aggregation="none" type="1234" name="" />
      </UML:Association.connection>
     </UML:Association>
-    <UML:Dependency isSpecification="false" visibility="public" xmi.id="1258" client="1234" name="" supplier="882" />
+    <UML:Dependency isSpecification="false" visibility="public" namespace="m1" xmi.id="1258" client="1234" name="" supplier="882" />
    </UML:Namespace.ownedElement>
   </UML:Model>
  </XMI.content>
  <XMI.extensions xmi.extender="umbrello" >
-  <docsettings viewid="786" documentation="" uniqueid="1273" />
+  <docsettings viewid="786" documentation="" uniqueid="1282" />
   <diagrams>
-   <diagram snapgrid="0" showattsig="1" fillcolor="#ffffc0" linewidth="0" zoom="75" showgrid="0" showopsig="1" usefillcolor="1" snapx="10" canvaswidth="1413" snapy="10" showatts="1" xmi.id="786" documentation="" type="402" showops="1" showpackage="0" name="Klassendiagramm" localid="900000" showstereotype="0" showscope="1" snapcsgrid="0" font="Sans Serif,10,-1,0,50,0,0,0,0,0" linecolor="#ff0000" canvasheight="1064" >
+   <diagram snapgrid="0" showattsig="1" fillcolor="#ffffc0" linewidth="0" zoom="120" showgrid="0" showopsig="1" usefillcolor="1" snapx="10" canvaswidth="1413" snapy="10" showatts="1" xmi.id="786" documentation="" type="402" showops="1" showpackage="0" name="Klassendiagramm" localid="900000" showstereotype="0" showscope="1" snapcsgrid="0" font="Sans Serif,10,-1,0,50,0,0,0,0,0" linecolor="#ff0000" canvasheight="1056" >
     <widgets>
-     <classwidget usesdiagramfillcolour="0" width="187" showattsigs="601" usesdiagramusefillcolour="0" x="433" linecolour="#ff0000" y="480" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="800" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="180" showattsigs="601" usesdiagramusefillcolour="0" x="600" linecolour="#ff0000" y="290" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="803" showoperations="1" showpackage="1" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="180" showattsigs="601" usesdiagramusefillcolour="0" x="742" linecolour="#ff0000" y="480" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="806" showoperations="1" showpackage="1" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="141" showattsigs="601" usesdiagramusefillcolour="0" x="316" linecolour="#ff0000" y="672" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="830" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="148" showattsigs="601" usesdiagramusefillcolour="0" x="540" linecolour="#ff0000" y="671" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="831" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="141" showattsigs="601" usesdiagramusefillcolour="0" x="876" linecolour="#ff0000" y="668" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="854" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="294" showattsigs="601" usesdiagramusefillcolour="0" x="17" linecolour="#ff0000" y="23" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#7fffb9" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="871" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="294" showattsigs="601" usesdiagramusefillcolour="0" x="548" linecolour="#ff0000" y="23" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#7fffb9" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="882" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="294" showattsigs="601" usesdiagramusefillcolour="0" x="1115" linecolour="#ff0000" y="23" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#7fffb9" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="915" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="174" showattsigs="601" usesdiagramusefillcolour="0" x="113" linecolour="#ff0000" y="971" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="933" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="174" showattsigs="601" usesdiagramusefillcolour="0" x="404" linecolour="#ff0000" y="971" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="940" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="174" showattsigs="601" usesdiagramusefillcolour="0" x="675" linecolour="#ff0000" y="971" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="967" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="174" showattsigs="601" usesdiagramusefillcolour="0" x="955" linecolour="#ff0000" y="971" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1004" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="263" showattsigs="601" usesdiagramusefillcolour="0" x="36" linecolour="#ff0000" y="733" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#0da2ff" height="49" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1082" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="263" showattsigs="601" usesdiagramusefillcolour="0" x="150" linecolour="#ff0000" y="546" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#0da2ff" height="49" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1129" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="263" showattsigs="601" usesdiagramusefillcolour="0" x="1028" linecolour="#ff0000" y="727" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#0da2ff" height="49" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1155" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="263" showattsigs="601" usesdiagramusefillcolour="0" x="932" linecolour="#ff0000" y="545" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#0da2ff" height="49" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1184" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="338" showattsigs="601" usesdiagramusefillcolour="0" x="334" linecolour="#ff0000" y="383" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#0da2ff" height="49" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1210" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
-     <classwidget usesdiagramfillcolour="0" width="263" showattsigs="601" usesdiagramusefillcolour="0" x="770" linecolour="#ff0000" y="382" showopsigs="601" linewidth="none" usesdiagramlinewidth="1" usesdiagramlinecolour="0" fillcolour="#0da2ff" height="49" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1234" showoperations="1" showpackage="0" showscope="1" showstereotype="0" font="Sans Serif,10,-1,5,75,0,0,0,0,0" />
+     <classwidget usesdiagramfillcolour="0" width="187" showattsigs="601" usesdiagramusefillcolour="0" x="433" y="480" showopsigs="601" linewidth="none" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="800" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="180" showattsigs="601" usesdiagramusefillcolour="0" x="600" y="290" showopsigs="601" linewidth="none" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="803" showoperations="1" showpackage="1" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="180" showattsigs="601" usesdiagramusefillcolour="0" x="742" y="480" showopsigs="601" linewidth="none" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="806" showoperations="1" showpackage="1" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="143" showattsigs="601" usesdiagramusefillcolour="0" x="316" y="672" showopsigs="601" linewidth="none" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="830" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="150" showattsigs="601" usesdiagramusefillcolour="0" x="540" y="671" showopsigs="601" linewidth="none" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="831" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="143" showattsigs="601" usesdiagramusefillcolour="0" x="876" y="668" showopsigs="601" linewidth="none" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="854" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="294" showattsigs="601" usesdiagramusefillcolour="0" x="17" y="23" showopsigs="601" linewidth="none" fillcolour="#7fffb9" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="871" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="294" showattsigs="601" usesdiagramusefillcolour="0" x="548" y="23" showopsigs="601" linewidth="none" fillcolour="#7fffb9" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="882" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="294" showattsigs="601" usesdiagramusefillcolour="0" x="1115" y="23" showopsigs="601" linewidth="none" fillcolour="#7fffb9" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="915" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="174" showattsigs="601" usesdiagramusefillcolour="0" x="113" y="971" showopsigs="601" linewidth="none" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="933" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="174" showattsigs="601" usesdiagramusefillcolour="0" x="404" y="971" showopsigs="601" linewidth="none" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="940" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="174" showattsigs="601" usesdiagramusefillcolour="0" x="675" y="971" showopsigs="601" linewidth="none" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="967" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="174" showattsigs="601" usesdiagramusefillcolour="0" x="955" y="971" showopsigs="601" linewidth="none" fillcolour="#ffffc0" height="77" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1004" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="263" showattsigs="601" usesdiagramusefillcolour="0" x="36" y="733" showopsigs="601" linewidth="none" fillcolour="#0da2ff" height="49" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1082" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="263" showattsigs="601" usesdiagramusefillcolour="0" x="150" y="546" showopsigs="601" linewidth="none" fillcolour="#0da2ff" height="49" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1129" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="263" showattsigs="601" usesdiagramusefillcolour="0" x="1028" y="727" showopsigs="601" linewidth="none" fillcolour="#0da2ff" height="49" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1155" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="263" showattsigs="601" usesdiagramusefillcolour="0" x="932" y="545" showopsigs="601" linewidth="none" fillcolour="#0da2ff" height="49" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1184" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="338" showattsigs="601" usesdiagramusefillcolour="0" x="334" y="383" showopsigs="601" linewidth="none" fillcolour="#0da2ff" height="49" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1210" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
+     <classwidget usesdiagramfillcolour="0" width="263" showattsigs="601" usesdiagramusefillcolour="0" x="770" y="382" showopsigs="601" linewidth="none" fillcolour="#0da2ff" height="49" usefillcolor="1" showpubliconly="0" showattributes="1" isinstance="0" xmi.id="1234" showoperations="1" showpackage="0" showscope="1" font="Sans Serif,10,-1,5,75,0,0,0,0,0" linecolor="#ff0000" />
     </widgets>
     <messages/>
     <associations>
-     <assocwidget totalcounta="3" indexa="1" totalcountb="3" indexb="2" widgetbid="800" widgetaid="803" xmi.id="809" >
+     <assocwidget totalcounta="3" indexa="1" totalcountb="3" indexb="2" linewidth="none" widgetbid="800" widgetaid="803" xmi.id="809" linecolor="none" >
       <linepath>
        <startpoint startx="660" starty="367" />
        <endpoint endx="557" endy="480" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="2" totalcountb="3" indexb="1" widgetbid="806" widgetaid="803" xmi.id="812" >
+     <assocwidget totalcounta="3" indexa="2" totalcountb="3" indexb="1" linewidth="none" widgetbid="806" widgetaid="803" xmi.id="812" linecolor="none" >
       <linepath>
        <startpoint startx="720" starty="367" />
        <endpoint endx="802" endy="480" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="1" totalcountb="3" indexb="2" widgetbid="830" widgetaid="800" xmi.id="842" >
+     <assocwidget totalcounta="3" indexa="1" totalcountb="3" indexb="2" linewidth="none" widgetbid="830" widgetaid="800" xmi.id="842" linecolor="none" >
       <linepath>
        <startpoint startx="495" starty="557" />
-       <endpoint endx="410" endy="672" />
+       <endpoint endx="411" endy="672" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="2" totalcountb="2" indexb="1" widgetbid="831" widgetaid="800" xmi.id="845" >
+     <assocwidget totalcounta="3" indexa="2" totalcountb="2" indexb="1" linewidth="none" widgetbid="831" widgetaid="800" xmi.id="845" linecolor="none" >
       <linepath>
        <startpoint startx="557" starty="557" />
-       <endpoint endx="614" endy="671" />
+       <endpoint endx="615" endy="671" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="2" indexa="1" totalcountb="3" indexb="1" widgetbid="854" widgetaid="806" xmi.id="865" >
+     <assocwidget totalcounta="2" indexa="1" totalcountb="3" indexb="1" linewidth="none" widgetbid="854" widgetaid="806" xmi.id="865" linecolor="none" >
       <linepath>
        <startpoint startx="832" starty="557" />
        <endpoint endx="923" endy="668" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="2" totalcountb="3" indexb="1" widgetbid="830" widgetaid="871" xmi.id="879" >
+     <assocwidget totalcounta="5" indexa="2" totalcountb="3" indexb="1" linewidth="none" widgetbid="830" widgetaid="871" xmi.id="879" linecolor="none" >
       <linepath>
        <startpoint startx="134" starty="100" />
        <endpoint endx="363" endy="672" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="4" totalcountb="3" indexb="1" widgetbid="803" widgetaid="871" xmi.id="893" >
+     <assocwidget totalcounta="5" indexa="4" totalcountb="3" indexb="1" linewidth="none" widgetbid="803" widgetaid="871" xmi.id="893" linecolor="none" >
       <linepath>
        <startpoint startx="252" starty="100" />
        <endpoint endx="660" endy="290" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="1" totalcountb="3" indexb="1" widgetbid="882" widgetaid="871" xmi.id="903" >
+     <assocwidget totalcounta="3" indexa="1" totalcountb="3" indexb="1" linewidth="none" widgetbid="882" widgetaid="871" xmi.id="903" linecolor="none" >
       <linepath>
        <startpoint startx="311" starty="48" />
        <endpoint endx="548" endy="48" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="2" totalcountb="3" indexb="2" widgetbid="871" widgetaid="882" xmi.id="906" >
+     <assocwidget totalcounta="3" indexa="2" totalcountb="3" indexb="2" linewidth="none" widgetbid="871" widgetaid="882" xmi.id="906" linecolor="none" >
       <linepath>
        <startpoint startx="548" starty="74" />
        <endpoint endx="311" endy="74" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="3" totalcountb="3" indexb="2" widgetbid="803" widgetaid="882" xmi.id="909" >
+     <assocwidget totalcounta="5" indexa="3" totalcountb="3" indexb="2" linewidth="none" widgetbid="803" widgetaid="882" xmi.id="909" linecolor="none" >
       <linepath>
        <startpoint startx="724" starty="100" />
        <endpoint endx="720" endy="290" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="2" totalcountb="3" indexb="1" widgetbid="800" widgetaid="882" xmi.id="912" >
+     <assocwidget totalcounta="5" indexa="2" totalcountb="3" indexb="1" linewidth="none" widgetbid="800" widgetaid="882" xmi.id="912" linecolor="none" >
       <linepath>
        <startpoint startx="665" starty="100" />
        <endpoint endx="495" endy="480" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="1" totalcountb="3" indexb="2" widgetbid="806" widgetaid="915" xmi.id="920" >
+     <assocwidget totalcounta="5" indexa="1" totalcountb="3" indexb="2" linewidth="none" widgetbid="806" widgetaid="915" xmi.id="920" linecolor="none" >
       <linepath>
        <startpoint startx="1173" starty="100" />
        <endpoint endx="862" endy="480" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="2" totalcountb="3" indexb="2" widgetbid="854" widgetaid="915" xmi.id="923" >
+     <assocwidget totalcounta="5" indexa="2" totalcountb="3" indexb="2" linewidth="none" widgetbid="854" widgetaid="915" xmi.id="923" linecolor="none" >
       <linepath>
        <startpoint startx="1232" starty="100" />
-       <endpoint endx="970" endy="668" />
+       <endpoint endx="971" endy="668" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="1" totalcountb="3" indexb="1" widgetbid="915" widgetaid="882" xmi.id="926" >
+     <assocwidget totalcounta="3" indexa="1" totalcountb="3" indexb="1" linewidth="none" widgetbid="915" widgetaid="882" xmi.id="926" linecolor="none" >
       <linepath>
        <startpoint startx="842" starty="48" />
        <endpoint endx="1115" endy="48" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="2" totalcountb="3" indexb="2" widgetbid="882" widgetaid="915" xmi.id="929" >
+     <assocwidget totalcounta="3" indexa="2" totalcountb="3" indexb="2" linewidth="none" widgetbid="882" widgetaid="915" xmi.id="929" linecolor="none" >
       <linepath>
        <startpoint startx="1115" starty="74" />
        <endpoint endx="842" endy="74" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="1" totalcountb="5" indexb="1" widgetbid="1004" widgetaid="967" xmi.id="1053" >
+     <assocwidget totalcounta="3" indexa="1" totalcountb="5" indexb="1" linewidth="none" widgetbid="1004" widgetaid="967" xmi.id="1053" linecolor="none" >
       <linepath>
        <startpoint startx="849" starty="996" />
        <endpoint endx="955" endy="986" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="2" totalcountb="3" indexb="2" widgetbid="967" widgetaid="1004" xmi.id="1056" >
+     <assocwidget totalcounta="5" indexa="2" totalcountb="3" indexb="2" linewidth="none" widgetbid="967" widgetaid="1004" xmi.id="1056" linecolor="none" >
       <linepath>
        <startpoint startx="955" starty="1001" />
        <endpoint endx="849" endy="1022" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="1" totalcountb="5" indexb="1" widgetbid="967" widgetaid="940" xmi.id="1059" >
+     <assocwidget totalcounta="3" indexa="1" totalcountb="5" indexb="1" linewidth="none" widgetbid="967" widgetaid="940" xmi.id="1059" linecolor="none" >
       <linepath>
        <startpoint startx="578" starty="996" />
        <endpoint endx="675" endy="986" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="2" totalcountb="3" indexb="2" widgetbid="940" widgetaid="967" xmi.id="1062" >
+     <assocwidget totalcounta="5" indexa="2" totalcountb="3" indexb="2" linewidth="none" widgetbid="940" widgetaid="967" xmi.id="1062" linecolor="none" >
       <linepath>
        <startpoint startx="675" starty="1001" />
        <endpoint endx="578" endy="1022" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="9" indexa="1" totalcountb="5" indexb="1" widgetbid="940" widgetaid="933" xmi.id="1065" >
+     <assocwidget totalcounta="9" indexa="1" totalcountb="5" indexb="1" linewidth="none" widgetbid="940" widgetaid="933" xmi.id="1065" linecolor="none" >
       <linepath>
        <startpoint startx="287" starty="979" />
        <endpoint endx="404" endy="986" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="2" totalcountb="9" indexb="2" widgetbid="933" widgetaid="940" xmi.id="1068" >
+     <assocwidget totalcounta="5" indexa="2" totalcountb="9" indexb="2" linewidth="none" widgetbid="933" widgetaid="940" xmi.id="1068" linecolor="none" >
       <linepath>
        <startpoint startx="404" starty="1001" />
        <endpoint endx="287" endy="988" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="2" indexa="1" totalcountb="0" indexb="0" widgetbid="933" widgetaid="933" xmi.id="1071" >
+     <assocwidget totalcounta="2" indexa="1" totalcountb="0" indexb="0" linewidth="none" widgetbid="933" widgetaid="933" xmi.id="1071" linecolor="none" >
       <linepath>
        <startpoint startx="156" starty="971" />
        <endpoint endx="243" endy="971" />
@@ -470,7 +471,7 @@
        <point x="278" y="921" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="2" indexa="1" totalcountb="0" indexb="0" widgetbid="1004" widgetaid="1004" xmi.id="1077" >
+     <assocwidget totalcounta="2" indexa="1" totalcountb="0" indexb="0" linewidth="none" widgetbid="1004" widgetaid="1004" xmi.id="1077" linecolor="none" >
       <linepath>
        <startpoint startx="998" starty="971" />
        <endpoint endx="1085" endy="971" />
@@ -478,133 +479,133 @@
        <point x="1120" y="921" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="2" visibilityB="200" totalcountb="0" indexb="0" widgetbid="933" widgetaid="933" xmi.id="936" type="510" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="3" indexa="2" visibilityB="200" totalcountb="0" indexb="0" linewidth="none" widgetbid="933" widgetaid="933" xmi.id="936" type="510" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
        <startpoint startx="156" starty="971" />
        <endpoint endx="243" endy="971" />
        <point x="156" y="921" />
        <point x="243" y="921" />
       </linepath>
-      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="207" linecolour="none" y="951" linewidth="none" usesdiagramlinewidth="1" posttext="" usesdiagramlinecolour="1" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1265" text="next" font="Sans Serif,10,-1,0,50,0,0,0,0,0" />
+      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="207" y="951" linewidth="none" posttext="" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1274" text="next" font="Sans Serif,10,-1,0,50,0,0,0,0,0" linecolor="none" />
      </assocwidget>
-     <assocwidget totalcounta="4" indexa="3" visibilityB="200" totalcountb="0" indexb="0" widgetbid="933" widgetaid="933" xmi.id="938" type="510" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="4" indexa="3" visibilityB="200" totalcountb="0" indexb="0" linewidth="none" widgetbid="933" widgetaid="933" xmi.id="938" type="510" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
        <startpoint startx="156" starty="971" />
        <endpoint endx="243" endy="971" />
        <point x="156" y="921" />
        <point x="243" y="921" />
       </linepath>
-      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="207" linecolour="none" y="951" linewidth="none" usesdiagramlinewidth="1" posttext="" usesdiagramlinecolour="1" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1266" text="prev" font="Sans Serif,10,-1,0,50,0,0,0,0,0" />
+      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="207" y="951" linewidth="none" posttext="" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1275" text="prev" font="Sans Serif,10,-1,0,50,0,0,0,0,0" linecolor="none" />
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="3" visibilityB="200" totalcountb="9" indexb="6" widgetbid="933" widgetaid="940" xmi.id="943" type="510" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="5" indexa="3" visibilityB="200" totalcountb="9" indexb="6" linewidth="none" widgetbid="933" widgetaid="940" xmi.id="943" type="510" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
        <startpoint startx="404" starty="1017" />
        <endpoint endx="287" endy="1022" />
       </linepath>
-      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="289" linecolour="none" y="1030" linewidth="none" usesdiagramlinewidth="1" posttext="" usesdiagramlinecolour="1" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1267" text="next" font="Sans Serif,10,-1,0,50,0,0,0,0,0" />
+      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="289" y="1030" linewidth="none" posttext="" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1276" text="next" font="Sans Serif,10,-1,0,50,0,0,0,0,0" linecolor="none" />
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="4" visibilityB="200" totalcountb="9" indexb="8" widgetbid="933" widgetaid="940" xmi.id="944" type="510" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="5" indexa="4" visibilityB="200" totalcountb="9" indexb="8" linewidth="none" widgetbid="933" widgetaid="940" xmi.id="944" type="510" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
        <startpoint startx="404" starty="1032" />
        <endpoint endx="287" endy="1039" />
       </linepath>
-      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="289" linecolour="none" y="1034" linewidth="none" usesdiagramlinewidth="1" posttext="" usesdiagramlinecolour="1" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1268" text="prev" font="Sans Serif,10,-1,0,50,0,0,0,0,0" />
+      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="289" y="1034" linewidth="none" posttext="" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1277" text="prev" font="Sans Serif,10,-1,0,50,0,0,0,0,0" linecolor="none" />
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="3" visibilityB="200" totalcountb="9" indexb="4" widgetbid="933" widgetaid="967" xmi.id="970" type="510" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="5" indexa="3" visibilityB="200" totalcountb="9" indexb="4" linewidth="none" widgetbid="933" widgetaid="967" xmi.id="970" type="510" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
        <startpoint startx="675" starty="1017" />
        <endpoint endx="287" endy="1005" />
       </linepath>
-      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="289" linecolour="none" y="1015" linewidth="none" usesdiagramlinewidth="1" posttext="" usesdiagramlinecolour="1" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1269" text="next" font="Sans Serif,10,-1,0,50,0,0,0,0,0" />
+      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="289" y="1015" linewidth="none" posttext="" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1278" text="next" font="Sans Serif,10,-1,0,50,0,0,0,0,0" linecolor="none" />
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="4" visibilityB="200" totalcountb="9" indexb="7" widgetbid="933" widgetaid="967" xmi.id="971" type="510" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="5" indexa="4" visibilityB="200" totalcountb="9" indexb="7" linewidth="none" widgetbid="933" widgetaid="967" xmi.id="971" type="510" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
        <startpoint startx="675" starty="1032" />
        <endpoint endx="287" endy="1030" />
       </linepath>
-      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="289" linecolour="none" y="1017" linewidth="none" usesdiagramlinewidth="1" posttext="" usesdiagramlinecolour="1" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1270" text="prev" font="Sans Serif,10,-1,0,50,0,0,0,0,0" />
+      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="289" y="1017" linewidth="none" posttext="" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1279" text="prev" font="Sans Serif,10,-1,0,50,0,0,0,0,0" linecolor="none" />
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="3" visibilityB="200" totalcountb="9" indexb="3" widgetbid="933" widgetaid="1004" xmi.id="1007" type="510" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="5" indexa="3" visibilityB="200" totalcountb="9" indexb="3" linewidth="none" widgetbid="933" widgetaid="1004" xmi.id="1007" type="510" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
        <startpoint startx="955" starty="1017" />
        <endpoint endx="287" endy="996" />
       </linepath>
-      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="289" linecolour="none" y="1018" linewidth="none" usesdiagramlinewidth="1" posttext="" usesdiagramlinecolour="1" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1271" text="next" font="Sans Serif,10,-1,0,50,0,0,0,0,0" />
+      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="289" y="1018" linewidth="none" posttext="" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1280" text="next" font="Sans Serif,10,-1,0,50,0,0,0,0,0" linecolor="none" />
      </assocwidget>
-     <assocwidget totalcounta="5" indexa="4" visibilityB="200" totalcountb="9" indexb="5" widgetbid="933" widgetaid="1004" xmi.id="1008" type="510" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="5" indexa="4" visibilityB="200" totalcountb="9" indexb="5" linewidth="none" widgetbid="933" widgetaid="1004" xmi.id="1008" type="510" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
        <startpoint startx="955" starty="1032" />
        <endpoint endx="287" endy="1013" />
       </linepath>
-      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="289" linecolour="none" y="1019" linewidth="none" usesdiagramlinewidth="1" posttext="" usesdiagramlinecolour="1" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1272" text="prev" font="Sans Serif,10,-1,0,50,0,0,0,0,0" />
+      <floatingtext usesdiagramfillcolour="1" width="38" usesdiagramusefillcolour="1" x="289" y="1019" linewidth="none" posttext="" role="710" fillcolour="none" height="18" usefillcolor="1" pretext="+" isinstance="0" xmi.id="1281" text="prev" font="Sans Serif,10,-1,0,50,0,0,0,0,0" linecolor="none" />
      </assocwidget>
-     <assocwidget totalcounta="2" indexa="1" visibilityB="200" totalcountb="3" indexb="2" widgetbid="1082" widgetaid="830" roleBdoc="" documentation="" roleAdoc="" type="509" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="2" indexa="1" visibilityB="200" totalcountb="3" indexb="2" linewidth="none" widgetbid="1082" widgetaid="830" roleBdoc="" documentation="" roleAdoc="" type="509" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
        <startpoint startx="316" starty="710" />
        <endpoint endx="211" endy="733" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="1" totalcountb="5" indexb="1" widgetbid="871" widgetaid="1082" xmi.id="1123" >
+     <assocwidget totalcounta="3" indexa="1" totalcountb="5" indexb="1" linewidth="none" widgetbid="871" widgetaid="1082" xmi.id="1123" linecolor="none" >
       <linepath>
        <startpoint startx="123" starty="733" />
        <endpoint endx="75" endy="100" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="2" indexa="1" visibilityB="200" totalcountb="3" indexb="2" widgetbid="1129" widgetaid="800" roleBdoc="" documentation="" roleAdoc="" type="509" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="2" indexa="1" visibilityB="200" totalcountb="3" indexb="2" linewidth="none" widgetbid="1129" widgetaid="800" roleBdoc="" documentation="" roleAdoc="" type="509" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
        <startpoint startx="433" starty="518" />
        <endpoint endx="325" endy="546" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="1" totalcountb="5" indexb="1" widgetbid="882" widgetaid="1129" xmi.id="1152" >
+     <assocwidget totalcounta="3" indexa="1" totalcountb="5" indexb="1" linewidth="none" widgetbid="882" widgetaid="1129" xmi.id="1152" linecolor="none" >
       <linepath>
        <startpoint startx="237" starty="546" />
        <endpoint endx="606" endy="100" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="2" indexa="1" visibilityB="200" totalcountb="3" indexb="1" widgetbid="1155" widgetaid="854" roleBdoc="" documentation="" roleAdoc="" type="509" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="2" indexa="1" visibilityB="200" totalcountb="3" indexb="1" linewidth="none" widgetbid="1155" widgetaid="854" roleBdoc="" documentation="" roleAdoc="" type="509" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
-       <startpoint startx="1017" starty="706" />
+       <startpoint startx="1019" starty="706" />
        <endpoint endx="1115" endy="727" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="2" totalcountb="5" indexb="4" widgetbid="915" widgetaid="1155" xmi.id="1181" >
+     <assocwidget totalcounta="3" indexa="2" totalcountb="5" indexb="4" linewidth="none" widgetbid="915" widgetaid="1155" xmi.id="1181" linecolor="none" >
       <linepath>
        <startpoint startx="1203" starty="727" />
        <endpoint endx="1350" endy="100" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="2" indexa="1" visibilityB="200" totalcountb="3" indexb="1" widgetbid="1184" widgetaid="806" roleBdoc="" documentation="" roleAdoc="" type="509" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="2" indexa="1" visibilityB="200" totalcountb="3" indexb="1" linewidth="none" widgetbid="1184" widgetaid="806" roleBdoc="" documentation="" roleAdoc="" type="509" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
        <startpoint startx="922" starty="518" />
        <endpoint endx="1019" endy="545" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="2" totalcountb="5" indexb="3" widgetbid="915" widgetaid="1184" xmi.id="1207" >
+     <assocwidget totalcounta="3" indexa="2" totalcountb="5" indexb="3" linewidth="none" widgetbid="915" widgetaid="1184" xmi.id="1207" linecolor="none" >
       <linepath>
        <startpoint startx="1107" starty="545" />
        <endpoint endx="1291" endy="100" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="2" indexa="1" visibilityB="200" totalcountb="3" indexb="2" widgetbid="1210" widgetaid="803" roleBdoc="" documentation="" roleAdoc="" type="509" changeabilityA="900" changeabilityB="900" visibilityA="200" >
+     <assocwidget totalcounta="2" indexa="1" visibilityB="200" totalcountb="3" indexb="2" linewidth="none" widgetbid="1210" widgetaid="803" roleBdoc="" documentation="" roleAdoc="" type="509" changeabilityA="900" changeabilityB="900" linecolor="none" visibilityA="200" >
       <linepath>
        <startpoint startx="600" starty="328" />
        <endpoint endx="559" endy="383" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="3" indexa="1" totalcountb="5" indexb="3" widgetbid="871" widgetaid="1210" xmi.id="1231" >
+     <assocwidget totalcounta="3" indexa="1" totalcountb="5" indexb="3" linewidth="none" widgetbid="871" widgetaid="1210" xmi.id="1231" linecolor="none" >
       <linepath>
        <startpoint startx="446" starty="383" />
        <endpoint endx="193" endy="100" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="2" indexa="1" totalcountb="2" indexb="1" widgetbid="1234" widgetaid="1210" xmi.id="1255" >
+     <assocwidget totalcounta="2" indexa="1" totalcountb="2" indexb="1" linewidth="none" widgetbid="1234" widgetaid="1210" xmi.id="1255" linecolor="none" >
       <linepath>
        <startpoint startx="672" starty="407" />
        <endpoint endx="770" endy="406" />
       </linepath>
      </assocwidget>
-     <assocwidget totalcounta="2" indexa="1" totalcountb="5" indexb="4" widgetbid="882" widgetaid="1234" xmi.id="1258" >
+     <assocwidget totalcounta="2" indexa="1" totalcountb="5" indexb="4" linewidth="none" widgetbid="882" widgetaid="1234" xmi.id="1258" linecolor="none" >
       <linepath>
        <startpoint startx="901" starty="382" />
        <endpoint endx="783" endy="100" />
@@ -735,7525 +736,11 @@
     <listitem open="1" type="802" label="Anwendungsfallansicht" />
     <listitem open="1" type="821" label="Komponentenansicht" />
     <listitem open="1" type="827" label="Verteilungsansicht" />
-    <listitem open="1" type="836" label="Entity Relationship Modell" />
+    <listitem open="1" type="836" label="Entity-Relationship-Modell" />
    </listitem>
   </listview>
   <codegeneration>
-   <codegenerator language="Cpp" >
-    <classifiercodedocument writeOutCode="true" package="" id="800" parent_class="800" fileExt=".cpp" fileName="olsr_node - 104.130.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_node - 104.130.1.1.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="801" tag="hblock_tag_0" canDelete="false" classfield_id="801" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="801" tag="hblock_tag_1" canDelete="false" classfield_id="801" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="802" tag="hblock_tag_2" canDelete="false" classfield_id="802" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="802" tag="hblock_tag_3" canDelete="false" classfield_id="802" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="864" tag="hblock_tag_6" canDelete="false" classfield_id="864" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="864" tag="hblock_tag_7" canDelete="false" classfield_id="864" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="862" tag="hblock_tag_4" canDelete="false" classfield_id="862" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="862" tag="hblock_tag_5" canDelete="false" classfield_id="862" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node - 104.130.1.1.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;  !
  If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="801" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="801" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="801" tag="hblock_tag_0" canDelete="false" classfield_id="801" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="801" tag="hblock_tag_1" canDelete="false" classfield_id="801" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="802" field_type="0" initialValue="50" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="802" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="802" tag="hblock_tag_2" canDelete="false" classfield_id="802" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="802" tag="hblock_tag_3" canDelete="false" classfield_id="802" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="862" field_type="0" initialValue="104.129.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="862" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="862" tag="hblock_tag_4" canDelete="false" classfield_id="862" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="862" tag="hblock_tag_5" canDelete="false" classfield_id="862" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="864" field_type="0" initialValue="104.130.1.99" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="864" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="864" tag="hblock_tag_6" canDelete="false" classfield_id="864" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="864" tag="hblock_tag_7" canDelete="false" classfield_id="864" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="803" parent_class="803" fileExt=".cpp" fileName="olsr_node - 104.131.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_node - 104.131.1.1.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="804" tag="hblock_tag_0" canDelete="false" classfield_id="804" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="804" tag="hblock_tag_1" canDelete="false" classfield_id="804" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="805" tag="hblock_tag_2" canDelete="false" classfield_id="805" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="805" tag="hblock_tag_3" canDelete="false" classfield_id="805" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="828" tag="hblock_tag_6" canDelete="false" classfield_id="828" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="828" tag="hblock_tag_7" canDelete="false" classfield_id="828" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="827" tag="hblock_tag_4" canDelete="false" classfield_id="827" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="827" tag="hblock_tag_5" canDelete="false" classfield_id="827" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node - 104.131.1.1.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;  !
  If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="804" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="804" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="804" tag="hblock_tag_0" canDelete="false" classfield_id="804" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="804" tag="hblock_tag_1" canDelete="false" classfield_id="804" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="805" field_type="0" initialValue="50" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="805" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="805" tag="hblock_tag_2" canDelete="false" classfield_id="805" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="805" tag="hblock_tag_3" canDelete="false" classfield_id="805" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="827" field_type="0" initialValue="104.130.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="827" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="827" tag="hblock_tag_4" canDelete="false" classfield_id="827" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="827" tag="hblock_tag_5" canDelete="false" classfield_id="827" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="828" field_type="0" initialValue="104.132.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="828" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="828" tag="hblock_tag_6" canDelete="false" classfield_id="828" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="828" tag="hblock_tag_7" canDelete="false" classfield_id="828" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="806" parent_class="806" fileExt=".cpp" fileName="olsr_node - 104.132.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_node - 104.132.1.1.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="807" tag="hblock_tag_0" canDelete="false" classfield_id="807" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="807" tag="hblock_tag_1" canDelete="false" classfield_id="807" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="808" tag="hblock_tag_2" canDelete="false" classfield_id="808" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="808" tag="hblock_tag_3" canDelete="false" classfield_id="808" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="861" tag="hblock_tag_6" canDelete="false" classfield_id="861" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="861" tag="hblock_tag_7" canDelete="false" classfield_id="861" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="860" tag="hblock_tag_4" canDelete="false" classfield_id="860" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="860" tag="hblock_tag_5" canDelete="false" classfield_id="860" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node - 104.132.1.1.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;  !
  If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="807" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="807" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="807" tag="hblock_tag_0" canDelete="false" classfield_id="807" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="807" tag="hblock_tag_1" canDelete="false" classfield_id="807" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="808" field_type="0" initialValue="50" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="808" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="808" tag="hblock_tag_2" canDelete="false" classfield_id="808" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="808" tag="hblock_tag_3" canDelete="false" classfield_id="808" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="860" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="860" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="860" tag="hblock_tag_4" canDelete="false" classfield_id="860" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="860" tag="hblock_tag_5" canDelete="false" classfield_id="860" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="861" field_type="0" initialValue="104.133.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="861" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="861" tag="hblock_tag_6" canDelete="false" classfield_id="861" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="861" tag="hblock_tag_7" canDelete="false" classfield_id="861" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="825" parent_class="825" fileExt=".cpp" fileName="olsr_node" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name t!
 he file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields/>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="830" parent_class="830" fileExt=".cpp" fileName="olsr_node - 104.129.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_node - 104.129.1.1.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="832" tag="hblock_tag_0" canDelete="false" classfield_id="832" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="832" tag="hblock_tag_1" canDelete="false" classfield_id="832" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="833" tag="hblock_tag_2" canDelete="false" classfield_id="833" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="833" tag="hblock_tag_3" canDelete="false" classfield_id="833" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="836" tag="hblock_tag_6" canDelete="false" classfield_id="836" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="836" tag="hblock_tag_7" canDelete="false" classfield_id="836" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="835" tag="hblock_tag_4" canDelete="false" classfield_id="835" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="835" tag="hblock_tag_5" canDelete="false" classfield_id="835" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node - 104.129.1.1.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;  !
  If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="832" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="832" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="832" tag="hblock_tag_0" canDelete="false" classfield_id="832" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="832" tag="hblock_tag_1" canDelete="false" classfield_id="832" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="833" field_type="0" initialValue="50" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="833" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="833" tag="hblock_tag_2" canDelete="false" classfield_id="833" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="833" tag="hblock_tag_3" canDelete="false" classfield_id="833" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="835" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="835" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="835" tag="hblock_tag_4" canDelete="false" classfield_id="835" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="835" tag="hblock_tag_5" canDelete="false" classfield_id="835" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="836" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="836" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="836" tag="hblock_tag_6" canDelete="false" classfield_id="836" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="836" tag="hblock_tag_7" canDelete="false" classfield_id="836" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="831" parent_class="831" fileExt=".cpp" fileName="olsr_node - 104.130.1.99" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_node - 104.130.1.99.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="837" tag="hblock_tag_0" canDelete="false" classfield_id="837" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="837" tag="hblock_tag_1" canDelete="false" classfield_id="837" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="838" tag="hblock_tag_2" canDelete="false" classfield_id="838" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="838" tag="hblock_tag_3" canDelete="false" classfield_id="838" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="841" tag="hblock_tag_6" canDelete="false" classfield_id="841" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="841" tag="hblock_tag_7" canDelete="false" classfield_id="841" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="840" tag="hblock_tag_4" canDelete="false" classfield_id="840" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="840" tag="hblock_tag_5" canDelete="false" classfield_id="840" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node - 104.130.1.99.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010; !
   If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="837" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="837" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="837" tag="hblock_tag_0" canDelete="false" classfield_id="837" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="837" tag="hblock_tag_1" canDelete="false" classfield_id="837" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="838" field_type="0" initialValue="50" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="838" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="838" tag="hblock_tag_2" canDelete="false" classfield_id="838" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="838" tag="hblock_tag_3" canDelete="false" classfield_id="838" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="840" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="840" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="840" tag="hblock_tag_4" canDelete="false" classfield_id="840" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="840" tag="hblock_tag_5" canDelete="false" classfield_id="840" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="841" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="841" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="841" tag="hblock_tag_6" canDelete="false" classfield_id="841" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="841" tag="hblock_tag_7" canDelete="false" classfield_id="841" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="854" parent_class="854" fileExt=".cpp" fileName="olsr_node - 104.133.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_node - 104.133.1.1.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="855" tag="hblock_tag_0" canDelete="false" classfield_id="855" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="855" tag="hblock_tag_1" canDelete="false" classfield_id="855" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="856" tag="hblock_tag_2" canDelete="false" classfield_id="856" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="856" tag="hblock_tag_3" canDelete="false" classfield_id="856" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="859" tag="hblock_tag_6" canDelete="false" classfield_id="859" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="859" tag="hblock_tag_7" canDelete="false" classfield_id="859" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="858" tag="hblock_tag_4" canDelete="false" classfield_id="858" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="858" tag="hblock_tag_5" canDelete="false" classfield_id="858" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node - 104.133.1.1.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;  !
  If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:19&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="855" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="855" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="855" tag="hblock_tag_0" canDelete="false" classfield_id="855" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="855" tag="hblock_tag_1" canDelete="false" classfield_id="855" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="856" field_type="0" initialValue="50" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="856" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="856" tag="hblock_tag_2" canDelete="false" classfield_id="856" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="856" tag="hblock_tag_3" canDelete="false" classfield_id="856" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="858" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="858" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="858" tag="hblock_tag_4" canDelete="false" classfield_id="858" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="858" tag="hblock_tag_5" canDelete="false" classfield_id="858" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="859" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="859" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="859" tag="hblock_tag_6" canDelete="false" classfield_id="859" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="859" tag="hblock_tag_7" canDelete="false" classfield_id="859" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="871" parent_class="871" fileExt=".cpp" fileName="olsr_con - 104.131.1.1:104.129.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_con - 104.131.1.1:104.129.1.1.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="896" tag="hblock_tag_0" canDelete="false" classfield_id="896" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="896" tag="hblock_tag_1" canDelete="false" classfield_id="896" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="898" tag="hblock_tag_2" canDelete="false" classfield_id="898" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="898" tag="hblock_tag_3" canDelete="false" classfield_id="898" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="874" tag="hblock_tag_4" canDelete="false" classfield_id="874" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="874" tag="hblock_tag_5" canDelete="false" classfield_id="874" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="875" tag="hblock_tag_6" canDelete="false" classfield_id="875" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="875" tag="hblock_tag_7" canDelete="false" classfield_id="875" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_con - 104.131.1.1:104.129.1.1.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&!
 amp;#010;   If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="896" field_type="0" initialValue="104.131.1.1:104.130.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="896" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="896" tag="hblock_tag_0" canDelete="false" classfield_id="896" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="896" tag="hblock_tag_1" canDelete="false" classfield_id="896" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="898" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="898" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="898" tag="hblock_tag_2" canDelete="false" classfield_id="898" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="898" tag="hblock_tag_3" canDelete="false" classfield_id="898" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="874" field_type="0" initialValue="104.131.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="874" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="874" tag="hblock_tag_4" canDelete="false" classfield_id="874" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="874" tag="hblock_tag_5" canDelete="false" classfield_id="874" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="875" field_type="0" initialValue="104.129.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="875" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="875" tag="hblock_tag_6" canDelete="false" classfield_id="875" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="875" tag="hblock_tag_7" canDelete="false" classfield_id="875" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="882" parent_class="882" fileExt=".cpp" fileName="olsr_con - 104.131.1.1:104.130.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_con - 104.131.1.1:104.130.1.1.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="899" tag="hblock_tag_0" canDelete="false" classfield_id="899" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="899" tag="hblock_tag_1" canDelete="false" classfield_id="899" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="900" tag="hblock_tag_2" canDelete="false" classfield_id="900" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="900" tag="hblock_tag_3" canDelete="false" classfield_id="900" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="901" tag="hblock_tag_4" canDelete="false" classfield_id="901" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="901" tag="hblock_tag_5" canDelete="false" classfield_id="901" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="902" tag="hblock_tag_6" canDelete="false" classfield_id="902" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="902" tag="hblock_tag_7" canDelete="false" classfield_id="902" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_con - 104.131.1.1:104.130.1.1.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&!
 amp;#010;   If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="899" field_type="0" initialValue="104.132.1.1:104.133.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="899" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="899" tag="hblock_tag_0" canDelete="false" classfield_id="899" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="899" tag="hblock_tag_1" canDelete="false" classfield_id="899" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="900" field_type="0" initialValue="104.131.1.1:104.129.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="900" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="900" tag="hblock_tag_2" canDelete="false" classfield_id="900" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="900" tag="hblock_tag_3" canDelete="false" classfield_id="900" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="901" field_type="0" initialValue="104.131.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="901" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="901" tag="hblock_tag_4" canDelete="false" classfield_id="901" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="901" tag="hblock_tag_5" canDelete="false" classfield_id="901" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="902" field_type="0" initialValue="104.130.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="902" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="902" tag="hblock_tag_6" canDelete="false" classfield_id="902" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="902" tag="hblock_tag_7" canDelete="false" classfield_id="902" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="897" parent_class="897" fileExt=".cpp" fileName="olsr_con" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_con.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_con.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name th!
 e file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields/>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="915" parent_class="915" fileExt=".cpp" fileName="olsr_con - 104.132.1.1:104.133.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_con - 104.132.1.1:104.133.1.1.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="916" tag="hblock_tag_0" canDelete="false" classfield_id="916" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="916" tag="hblock_tag_1" canDelete="false" classfield_id="916" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="917" tag="hblock_tag_2" canDelete="false" classfield_id="917" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="917" tag="hblock_tag_3" canDelete="false" classfield_id="917" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="918" tag="hblock_tag_4" canDelete="false" classfield_id="918" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="918" tag="hblock_tag_5" canDelete="false" classfield_id="918" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="919" tag="hblock_tag_6" canDelete="false" classfield_id="919" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="919" tag="hblock_tag_7" canDelete="false" classfield_id="919" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_con - 104.132.1.1:104.133.1.1.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&!
 amp;#010;   If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="916" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="916" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="916" tag="hblock_tag_0" canDelete="false" classfield_id="916" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="916" tag="hblock_tag_1" canDelete="false" classfield_id="916" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="917" field_type="0" initialValue="104.131.1.1:104.130.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="917" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="917" tag="hblock_tag_2" canDelete="false" classfield_id="917" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="917" tag="hblock_tag_3" canDelete="false" classfield_id="917" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="918" field_type="0" initialValue="104.132.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="918" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="918" tag="hblock_tag_4" canDelete="false" classfield_id="918" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="918" tag="hblock_tag_5" canDelete="false" classfield_id="918" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="919" field_type="0" initialValue="104.133.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="919" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="919" tag="hblock_tag_6" canDelete="false" classfield_id="919" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="919" tag="hblock_tag_7" canDelete="false" classfield_id="919" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="933" parent_class="933" fileExt=".cpp" fileName="obj_to_ip" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;obj_to_ip.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="934" tag="hblock_tag_0" canDelete="false" classfield_id="934" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="934" tag="hblock_tag_1" canDelete="false" classfield_id="934" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="935" tag="hblock_tag_2" canDelete="false" classfield_id="935" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="935" tag="hblock_tag_3" canDelete="false" classfield_id="935" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="936" tag="hblock_tag_4" canDelete="false" classfield_id="936" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="936" tag="hblock_tag_5" canDelete="false" classfield_id="936" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="938" tag="hblock_tag_6" canDelete="false" classfield_id="938" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="938" tag="hblock_tag_7" canDelete="false" classfield_id="938" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			obj_to_ip.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name t!
 he file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="934" field_type="0" initialValue="0" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="934" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="934" tag="hblock_tag_0" canDelete="false" classfield_id="934" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="934" tag="hblock_tag_1" canDelete="false" classfield_id="934" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="935" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="935" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="935" tag="hblock_tag_2" canDelete="false" classfield_id="935" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="935" tag="hblock_tag_3" canDelete="false" classfield_id="935" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="936" field_type="0" initialValue="Obj_to_ip - 1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="936" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="936" tag="hblock_tag_4" canDelete="false" classfield_id="936" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="936" tag="hblock_tag_5" canDelete="false" classfield_id="936" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="938" field_type="0" initialValue="Obj_to_ip" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="938" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="938" tag="hblock_tag_6" canDelete="false" classfield_id="938" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="938" tag="hblock_tag_7" canDelete="false" classfield_id="938" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="940" parent_class="940" fileExt=".cpp" fileName="obj_to_ip - 1" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;obj_to_ip - 1.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="941" tag="hblock_tag_0" canDelete="false" classfield_id="941" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="941" tag="hblock_tag_1" canDelete="false" classfield_id="941" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="942" tag="hblock_tag_2" canDelete="false" classfield_id="942" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="942" tag="hblock_tag_3" canDelete="false" classfield_id="942" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="943" tag="hblock_tag_4" canDelete="false" classfield_id="943" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="943" tag="hblock_tag_5" canDelete="false" classfield_id="943" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="944" tag="hblock_tag_6" canDelete="false" classfield_id="944" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="944" tag="hblock_tag_7" canDelete="false" classfield_id="944" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			obj_to_ip - 1.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you na!
 me the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="941" field_type="0" initialValue="1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="941" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="941" tag="hblock_tag_0" canDelete="false" classfield_id="941" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="941" tag="hblock_tag_1" canDelete="false" classfield_id="941" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="942" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="942" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="942" tag="hblock_tag_2" canDelete="false" classfield_id="942" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="942" tag="hblock_tag_3" canDelete="false" classfield_id="942" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="943" field_type="0" initialValue="Obj_to_ip - 2" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="943" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="943" tag="hblock_tag_4" canDelete="false" classfield_id="943" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="943" tag="hblock_tag_5" canDelete="false" classfield_id="943" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="944" field_type="0" initialValue="Obj_to_ip" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="944" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="944" tag="hblock_tag_6" canDelete="false" classfield_id="944" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="944" tag="hblock_tag_7" canDelete="false" classfield_id="944" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="967" parent_class="967" fileExt=".cpp" fileName="obj_to_ip - 2" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;obj_to_ip - 2.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="968" tag="hblock_tag_0" canDelete="false" classfield_id="968" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="968" tag="hblock_tag_1" canDelete="false" classfield_id="968" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="969" tag="hblock_tag_2" canDelete="false" classfield_id="969" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="969" tag="hblock_tag_3" canDelete="false" classfield_id="969" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="970" tag="hblock_tag_4" canDelete="false" classfield_id="970" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="970" tag="hblock_tag_5" canDelete="false" classfield_id="970" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="971" tag="hblock_tag_6" canDelete="false" classfield_id="971" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="971" tag="hblock_tag_7" canDelete="false" classfield_id="971" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			obj_to_ip - 2.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you na!
 me the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="968" field_type="0" initialValue="2" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="968" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="968" tag="hblock_tag_0" canDelete="false" classfield_id="968" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="968" tag="hblock_tag_1" canDelete="false" classfield_id="968" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="969" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="969" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="969" tag="hblock_tag_2" canDelete="false" classfield_id="969" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="969" tag="hblock_tag_3" canDelete="false" classfield_id="969" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="970" field_type="0" initialValue="Obj_to_ip - 3" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="970" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="970" tag="hblock_tag_4" canDelete="false" classfield_id="970" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="970" tag="hblock_tag_5" canDelete="false" classfield_id="970" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="971" field_type="0" initialValue="Obj_to_ip - 1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="971" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="971" tag="hblock_tag_6" canDelete="false" classfield_id="971" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="971" tag="hblock_tag_7" canDelete="false" classfield_id="971" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="1004" parent_class="1004" fileExt=".cpp" fileName="obj_to_ip -3" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;obj_to_ip -3.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="1005" tag="hblock_tag_0" canDelete="false" classfield_id="1005" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="1005" tag="hblock_tag_1" canDelete="false" classfield_id="1005" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="1006" tag="hblock_tag_2" canDelete="false" classfield_id="1006" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="1006" tag="hblock_tag_3" canDelete="false" classfield_id="1006" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="1007" tag="hblock_tag_4" canDelete="false" classfield_id="1007" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="1007" tag="hblock_tag_5" canDelete="false" classfield_id="1007" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="1008" tag="hblock_tag_6" canDelete="false" classfield_id="1008" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="1008" tag="hblock_tag_7" canDelete="false" classfield_id="1008" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			obj_to_ip -3.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you nam!
 e the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="1005" field_type="0" initialValue="0" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="1005" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="1005" tag="hblock_tag_0" canDelete="false" classfield_id="1005" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="1005" tag="hblock_tag_1" canDelete="false" classfield_id="1005" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="1006" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="1006" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="1006" tag="hblock_tag_2" canDelete="false" classfield_id="1006" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="1006" tag="hblock_tag_3" canDelete="false" classfield_id="1006" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="1007" field_type="0" initialValue="Obj_to_ip - 3" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="1007" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="1007" tag="hblock_tag_4" canDelete="false" classfield_id="1007" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="1007" tag="hblock_tag_5" canDelete="false" classfield_id="1007" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="1008" field_type="0" initialValue="Obj_to_ip - 2" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="1008" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="1008" tag="hblock_tag_6" canDelete="false" classfield_id="1008" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="1008" tag="hblock_tag_7" canDelete="false" classfield_id="1008" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="1127" parent_class="1127" fileExt=".cpp" fileName="olsr_con_list" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_con_list.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_con_list.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you na!
 me the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields/>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="1234" parent_class="1234" fileExt=".cpp" fileName="olsr_con_list - 104.131.1.1:104.130.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="includes" text="#include &quot;olsr_con_list - 104.131.1.1:104.130.1.1.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="constructionMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Constructors/Destructors" />
-       </header>
-       <textblocks/>
-      </hierarchicalcodeblock>
-      <hierarchicalcodeblock tag="otherMethodsBlock" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" text="Methods" />
-       </header>
-       <textblocks>
-        <codeaccessormethod accessType="0" parent_id="1263" tag="hblock_tag_0" canDelete="false" classfield_id="1263" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="1263" tag="hblock_tag_1" canDelete="false" classfield_id="1263" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="0" parent_id="1264" tag="hblock_tag_2" canDelete="false" classfield_id="1264" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-        <codeaccessormethod accessType="1" parent_id="1264" tag="hblock_tag_3" canDelete="false" classfield_id="1264" >
-         <header>
-          <cppcodedocumentation tag="" />
-         </header>
-        </codeaccessormethod>
-       </textblocks>
-      </hierarchicalcodeblock>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_con_list - 104.131.1.1:104.130.1.1.cpp - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.cpp&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java c!
 ode.&amp;#010;   If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="1263" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="1263" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="1263" tag="hblock_tag_0" canDelete="false" classfield_id="1263" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="1263" tag="hblock_tag_1" canDelete="false" classfield_id="1263" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="1264" field_type="0" initialValue="104.131.1.1:104.130.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="1264" tag="" canDelete="false" indentLevel="1" text="FIX ME;" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="1264" tag="hblock_tag_2" canDelete="false" classfield_id="1264" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="1264" tag="hblock_tag_3" canDelete="false" classfield_id="1264" >
-        <header>
-         <cppcodedocumentation tag="" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <codedocument writeOutCode="false" package="" id="Makefile_DOC" fileExt="" fileName="Makefile" >
-     <textblocks/>
-     <header>
-      <codecomment tag="" />
-     </header>
-    </codedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader800" parent_class="800" fileExt=".h" fileName="olsr_node - 104.130.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_NODE_-_104.130.1.1_H&amp;#010;#define OLSR_NODE_-_104.130.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;olsr_node - 104.131.1.1.h&quot;&amp;#010;#include &quot;olsr_node - 104.129.1.1.h&quot;&amp;#010;#include &quot;olsr_node - 104.130.1.99.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="800" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_node - 104.130.1.1&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_node - 104.130.1.1 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="801" tag="tblock_0" canDelete="false" indentLevel="1" text=" char ip;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="802" tag="tblock_1" canDelete="false" indentLevel="1" text=" int last_seen;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="862" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="864" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="801" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="801" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="801" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="801" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="802" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="802" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="802" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="802" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="862" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="862" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="862" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="862" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="864" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="864" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="864" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="864" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_NODE_-_104.130.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node - 104.130.1.1.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If !
 you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="801" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="801" tag="tblock_0" canDelete="false" indentLevel="1" text=" char ip;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="801" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="801" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="801" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="801" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="802" field_type="0" initialValue="50" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="802" tag="tblock_1" canDelete="false" indentLevel="1" text=" int last_seen;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="802" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="802" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="802" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="802" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="862" field_type="0" initialValue="104.129.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="862" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="862" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="862" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="862" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="862" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="864" field_type="0" initialValue="104.130.1.99" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="864" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="864" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="864" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="864" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="864" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader803" parent_class="803" fileExt=".h" fileName="olsr_node - 104.131.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_NODE_-_104.131.1.1_H&amp;#010;#define OLSR_NODE_-_104.131.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;olsr_node - 104.130.1.1.h&quot;&amp;#010;#include &quot;olsr_node - 104.132.1.1.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="803" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_node - 104.131.1.1&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_node - 104.131.1.1 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="804" tag="tblock_0" canDelete="false" indentLevel="1" text=" char ip;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="805" tag="tblock_1" canDelete="false" indentLevel="1" text=" int last_seen;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="827" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="828" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="804" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="804" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="804" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="804" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="805" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="805" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="805" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="805" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="827" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="827" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="827" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="827" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="828" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="828" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="828" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="828" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_NODE_-_104.131.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node - 104.131.1.1.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If !
 you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="804" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="804" tag="tblock_0" canDelete="false" indentLevel="1" text=" char ip;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="804" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="804" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="804" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="804" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="805" field_type="0" initialValue="50" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="805" tag="tblock_1" canDelete="false" indentLevel="1" text=" int last_seen;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="805" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="805" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="805" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="805" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="827" field_type="0" initialValue="104.130.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="827" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="827" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="827" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="827" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="827" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="828" field_type="0" initialValue="104.132.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="828" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="828" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="828" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="828" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="828" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader806" parent_class="806" fileExt=".h" fileName="olsr_node - 104.132.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_NODE_-_104.132.1.1_H&amp;#010;#define OLSR_NODE_-_104.132.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;olsr_node - 104.131.1.1.h&quot;&amp;#010;#include &quot;olsr_node - 104.133.1.1.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="806" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_node - 104.132.1.1&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_node - 104.132.1.1 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="807" tag="tblock_0" canDelete="false" indentLevel="1" text=" char ip;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="808" tag="tblock_1" canDelete="false" indentLevel="1" text=" int last_seen;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="860" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="861" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="807" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="807" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="807" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="807" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="808" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="808" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="808" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="808" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="860" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="860" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="860" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="860" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="861" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="861" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="861" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="861" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_NODE_-_104.132.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node - 104.132.1.1.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If !
 you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="807" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="807" tag="tblock_0" canDelete="false" indentLevel="1" text=" char ip;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="807" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="807" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="807" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="807" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="808" field_type="0" initialValue="50" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="808" tag="tblock_1" canDelete="false" indentLevel="1" text=" int last_seen;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="808" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="808" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="808" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="808" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="860" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="860" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="860" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="860" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="860" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="860" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="861" field_type="0" initialValue="104.133.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="861" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="861" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="861" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="861" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="861" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader825" parent_class="825" fileExt=".h" fileName="olsr_node" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_NODE_H&amp;#010;#define OLSR_NODE_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="825" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_node&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_node ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_NODE_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the f!
 ile &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields/>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader830" parent_class="830" fileExt=".h" fileName="olsr_node - 104.129.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_NODE_-_104.129.1.1_H&amp;#010;#define OLSR_NODE_-_104.129.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;olsr_node - 104.130.1.1.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="830" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_node - 104.129.1.1&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_node - 104.129.1.1 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="832" tag="tblock_0" canDelete="false" indentLevel="1" text=" char ip;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="833" tag="tblock_1" canDelete="false" indentLevel="1" text=" int last_seen;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="835" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="836" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="832" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="832" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="832" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="832" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="833" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="833" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="833" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="833" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="835" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="835" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="835" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="835" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="836" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="836" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="836" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="836" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_NODE_-_104.129.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node - 104.129.1.1.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If !
 you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="832" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="832" tag="tblock_0" canDelete="false" indentLevel="1" text=" char ip;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="832" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="832" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="832" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="832" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="833" field_type="0" initialValue="50" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="833" tag="tblock_1" canDelete="false" indentLevel="1" text=" int last_seen;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="833" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="833" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="833" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="833" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="835" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="835" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="835" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="835" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="835" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="835" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="836" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="836" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="836" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="836" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="836" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="836" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader831" parent_class="831" fileExt=".h" fileName="olsr_node - 104.130.1.99" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_NODE_-_104.130.1.99_H&amp;#010;#define OLSR_NODE_-_104.130.1.99_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;olsr_node - 104.130.1.1.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="831" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_node - 104.130.1.99&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_node - 104.130.1.99 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="837" tag="tblock_0" canDelete="false" indentLevel="1" text=" char ip;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="838" tag="tblock_1" canDelete="false" indentLevel="1" text=" int last_seen;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="840" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="841" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="837" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="837" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="837" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="837" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="838" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="838" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="838" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="838" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="840" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="840" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="840" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="840" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="841" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="841" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="841" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="841" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_NODE_-_104.130.1.99_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node - 104.130.1.99.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If!
  you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="837" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="837" tag="tblock_0" canDelete="false" indentLevel="1" text=" char ip;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="837" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="837" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="837" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="837" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="838" field_type="0" initialValue="50" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="838" tag="tblock_1" canDelete="false" indentLevel="1" text=" int last_seen;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="838" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="838" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="838" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="838" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="840" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="840" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="840" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="840" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="840" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="840" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="841" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="841" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="841" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="841" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="841" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="841" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader854" parent_class="854" fileExt=".h" fileName="olsr_node - 104.133.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_NODE_-_104.133.1.1_H&amp;#010;#define OLSR_NODE_-_104.133.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;olsr_node - 104.132.1.1.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="854" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_node - 104.133.1.1&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_node - 104.133.1.1 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="855" tag="tblock_0" canDelete="false" indentLevel="1" text=" char ip;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="856" tag="tblock_1" canDelete="false" indentLevel="1" text=" int last_seen;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="858" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="859" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="855" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="855" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="855" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="855" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="856" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="856" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="856" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="856" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="858" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="858" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="858" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="858" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="859" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="859" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="859" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="859" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_NODE_-_104.133.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_node - 104.133.1.1.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If !
 you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:19&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="855" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="855" tag="tblock_0" canDelete="false" indentLevel="1" text=" char ip;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="855" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="855" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="855" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="855" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="856" field_type="0" initialValue="50" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="856" tag="tblock_1" canDelete="false" indentLevel="1" text=" int last_seen;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="856" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="856" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="856" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="856" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="858" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="858" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="858" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="858" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="858" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="858" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="859" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="859" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="859" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="859" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="859" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="859" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader871" parent_class="871" fileExt=".h" fileName="olsr_con - 104.131.1.1:104.129.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_CON_-_104.131.1.1:104.129.1.1_H&amp;#010;#define OLSR_CON_-_104.131.1.1:104.129.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;olsr_con - 104.131.1.1:104.130.1.1.h&quot;&amp;#010;#include &quot;olsr_con.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="871" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_con - 104.131.1.1:104.129.1.1&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_con - 104.131.1.1:104.129.1.1 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="896" tag="tblock_0" canDelete="false" indentLevel="1" text=" olsr_con next_olsr_con;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="898" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_con prev_olsr_con;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="874" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left_olsr_node;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="875" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right_olsr_node;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="896" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="896" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="896" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="896" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="898" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="898" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="898" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="898" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="874" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="874" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="874" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="874" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="875" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="875" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="875" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="875" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_CON_-_104.131.1.1:104.129.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_con - 104.131.1.1:104.129.1.1.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;!
 #010;   If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="896" field_type="0" initialValue="104.131.1.1:104.130.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="896" tag="tblock_0" canDelete="false" indentLevel="1" text=" olsr_con next_olsr_con;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="896" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="896" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="896" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="896" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="898" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="898" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_con prev_olsr_con;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="898" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="898" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="898" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="898" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="874" field_type="0" initialValue="104.131.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="874" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left_olsr_node;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="874" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="874" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="874" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="874" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="875" field_type="0" initialValue="104.129.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="875" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right_olsr_node;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="875" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="875" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="875" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="875" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader882" parent_class="882" fileExt=".h" fileName="olsr_con - 104.131.1.1:104.130.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_CON_-_104.131.1.1:104.130.1.1_H&amp;#010;#define OLSR_CON_-_104.131.1.1:104.130.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;olsr_con - 104.131.1.1:104.129.1.1.h&quot;&amp;#010;#include &quot;olsr_con - 104.132.1.1:104.133.1.1.h&quot;&amp;#010;#include &quot;olsr_con.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="882" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_con - 104.131.1.1:104.130.1.1&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_con - 104.131.1.1:104.130.1.1 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="899" tag="tblock_0" canDelete="false" indentLevel="1" text=" olsr_con next_olsr_con;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="900" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_con prev_olsr_con;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="901" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left_olsr_node;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="902" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right_olsr_node;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="899" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="899" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="899" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="899" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="900" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="900" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="900" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="900" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="901" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="901" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="901" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="901" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="902" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="902" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="902" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="902" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_CON_-_104.131.1.1:104.130.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_con - 104.131.1.1:104.130.1.1.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;!
 #010;   If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="899" field_type="0" initialValue="104.132.1.1:104.133.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="899" tag="tblock_0" canDelete="false" indentLevel="1" text=" olsr_con next_olsr_con;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="899" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="899" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="899" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="899" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="900" field_type="0" initialValue="104.131.1.1:104.129.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="900" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_con prev_olsr_con;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="900" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="900" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="900" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="900" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="901" field_type="0" initialValue="104.131.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="901" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left_olsr_node;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="901" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="901" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="901" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="901" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="902" field_type="0" initialValue="104.130.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="902" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right_olsr_node;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="902" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="902" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="902" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="902" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader897" parent_class="897" fileExt=".h" fileName="olsr_con" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_CON_H&amp;#010;#define OLSR_CON_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="897" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_con&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_con ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_CON_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_con.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the fi!
 le &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields/>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader915" parent_class="915" fileExt=".h" fileName="olsr_con - 104.132.1.1:104.133.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_CON_-_104.132.1.1:104.133.1.1_H&amp;#010;#define OLSR_CON_-_104.132.1.1:104.133.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;olsr_con - 104.131.1.1:104.130.1.1.h&quot;&amp;#010;#include &quot;olsr_con.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="915" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_con - 104.132.1.1:104.133.1.1&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_con - 104.132.1.1:104.133.1.1 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="916" tag="tblock_0" canDelete="false" indentLevel="1" text=" olsr_con next_olsr_con;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="917" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_con prev_olsr_con;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="918" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left_olsr_node;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="919" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right_olsr_node;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="916" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="916" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="916" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="916" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="917" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="917" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="917" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="917" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="918" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="918" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="918" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="918" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="919" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="919" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="919" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="919" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_CON_-_104.132.1.1:104.133.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_con - 104.132.1.1:104.133.1.1.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;!
 #010;   If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="916" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="916" tag="tblock_0" canDelete="false" indentLevel="1" text=" olsr_con next_olsr_con;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="916" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="916" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="916" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="916" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="917" field_type="0" initialValue="104.131.1.1:104.130.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="917" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_con prev_olsr_con;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="917" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="917" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="917" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="917" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="918" field_type="0" initialValue="104.132.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="918" tag="tblock_2" canDelete="false" indentLevel="1" text=" olsr_node left_olsr_node;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="918" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="918" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="918" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="918" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="919" field_type="0" initialValue="104.133.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="919" tag="tblock_3" canDelete="false" indentLevel="1" text=" olsr_node right_olsr_node;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="919" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="919" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="919" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="919" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader933" parent_class="933" fileExt=".h" fileName="obj_to_ip" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OBJ_TO_IP_H&amp;#010;#define OBJ_TO_IP_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;obj_to_ip - 1.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="933" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class Obj_to_ip&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="Obj_to_ip ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="934" tag="tblock_0" canDelete="false" indentLevel="1" text=" int Object_id;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="935" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_node olsr_node;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="936" tag="tblock_2" canDelete="false" indentLevel="1" text=" Obj_to_ip next;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="938" tag="tblock_3" canDelete="false" indentLevel="1" text=" Obj_to_ip prev;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="934" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="934" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="934" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="934" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="935" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="935" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="935" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="935" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="936" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="936" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="936" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="936" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="938" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="938" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="938" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="938" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OBJ_TO_IP_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			obj_to_ip.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name the f!
 ile &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="934" field_type="0" initialValue="0" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="934" tag="tblock_0" canDelete="false" indentLevel="1" text=" int Object_id;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="934" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="934" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="934" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="934" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="935" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="935" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_node olsr_node;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="935" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="935" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="935" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="935" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="936" field_type="0" initialValue="Obj_to_ip - 1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="936" tag="tblock_2" canDelete="false" indentLevel="1" text=" Obj_to_ip next;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="936" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="936" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="936" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="936" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="938" field_type="0" initialValue="Obj_to_ip" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="938" tag="tblock_3" canDelete="false" indentLevel="1" text=" Obj_to_ip prev;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="938" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="938" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="938" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="938" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader940" parent_class="940" fileExt=".h" fileName="obj_to_ip - 1" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OBJ_TO_IP_-_1_H&amp;#010;#define OBJ_TO_IP_-_1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;obj_to_ip - 2.h&quot;&amp;#010;#include &quot;obj_to_ip.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="940" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class Obj_to_ip - 1&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="Obj_to_ip - 1 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="941" tag="tblock_0" canDelete="false" indentLevel="1" text=" int Object_id;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="942" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_node olsr_node;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="943" tag="tblock_2" canDelete="false" indentLevel="1" text=" Obj_to_ip next;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="944" tag="tblock_3" canDelete="false" indentLevel="1" text=" Obj_to_ip prev;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="941" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="941" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="941" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="941" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="942" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="942" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="942" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="942" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="943" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="943" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="943" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="943" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="944" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="944" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="944" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="944" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OBJ_TO_IP_-_1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			obj_to_ip - 1.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name t!
 he file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="941" field_type="0" initialValue="1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="941" tag="tblock_0" canDelete="false" indentLevel="1" text=" int Object_id;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="941" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="941" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="941" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="941" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="942" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="942" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_node olsr_node;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="942" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="942" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="942" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="942" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="943" field_type="0" initialValue="Obj_to_ip - 2" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="943" tag="tblock_2" canDelete="false" indentLevel="1" text=" Obj_to_ip next;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="943" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="943" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="943" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="943" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="944" field_type="0" initialValue="Obj_to_ip" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="944" tag="tblock_3" canDelete="false" indentLevel="1" text=" Obj_to_ip prev;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="944" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="944" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="944" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="944" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader967" parent_class="967" fileExt=".h" fileName="obj_to_ip - 2" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OBJ_TO_IP_-_2_H&amp;#010;#define OBJ_TO_IP_-_2_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;obj_to_ip -3.h&quot;&amp;#010;#include &quot;obj_to_ip - 1.h&quot;&amp;#010;#include &quot;obj_to_ip.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="967" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class Obj_to_ip - 2&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="Obj_to_ip - 2 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="968" tag="tblock_0" canDelete="false" indentLevel="1" text=" int Object_id;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="969" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_node olsr_node;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="970" tag="tblock_2" canDelete="false" indentLevel="1" text=" Obj_to_ip next;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="971" tag="tblock_3" canDelete="false" indentLevel="1" text=" Obj_to_ip prev;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="968" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="968" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="968" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="968" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="969" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="969" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="969" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="969" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="970" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="970" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="970" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="970" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="971" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="971" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="971" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="971" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OBJ_TO_IP_-_2_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			obj_to_ip - 2.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name t!
 he file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="968" field_type="0" initialValue="2" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="968" tag="tblock_0" canDelete="false" indentLevel="1" text=" int Object_id;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="968" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="968" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="968" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="968" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="969" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="969" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_node olsr_node;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="969" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="969" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="969" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="969" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="970" field_type="0" initialValue="Obj_to_ip - 3" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="970" tag="tblock_2" canDelete="false" indentLevel="1" text=" Obj_to_ip next;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="970" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="970" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="970" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="970" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="971" field_type="0" initialValue="Obj_to_ip - 1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="971" tag="tblock_3" canDelete="false" indentLevel="1" text=" Obj_to_ip prev;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="971" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="971" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="971" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="971" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader1004" parent_class="1004" fileExt=".h" fileName="obj_to_ip -3" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OBJ_TO_IP_-3_H&amp;#010;#define OBJ_TO_IP_-3_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;obj_to_ip - 2.h&quot;&amp;#010;#include &quot;obj_to_ip.h&quot;&amp;#010;#include &quot;olsr_node.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="1004" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class Obj_to_ip -3&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="Obj_to_ip -3 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="1005" tag="tblock_0" canDelete="false" indentLevel="1" text=" int Object_id;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="1006" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_node olsr_node;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="1007" tag="tblock_2" canDelete="false" indentLevel="1" text=" Obj_to_ip next;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="1008" tag="tblock_3" canDelete="false" indentLevel="1" text=" Obj_to_ip prev;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="1005" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="1005" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="1005" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="1005" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="1006" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="1006" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="1006" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="1006" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="1007" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="1007" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="1007" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="1007" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="1008" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="1008" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="1008" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="1008" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OBJ_TO_IP_-3_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			obj_to_ip -3.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name th!
 e file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="1005" field_type="0" initialValue="0" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="1005" tag="tblock_0" canDelete="false" indentLevel="1" text=" int Object_id;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="1005" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="1005" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="1005" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="1005" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="1006" field_type="0" initialValue="" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="1006" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_node olsr_node;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="1006" tag="hblock_tag_5" canDelete="false" indentLevel="1" classfield_id="1006" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="1006" tag="hblock_tag_6" canDelete="false" indentLevel="1" classfield_id="1006" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="1007" field_type="0" initialValue="Obj_to_ip - 3" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="1007" tag="tblock_2" canDelete="false" indentLevel="1" text=" Obj_to_ip next;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="1007" tag="hblock_tag_7" canDelete="false" indentLevel="1" classfield_id="1007" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="1007" tag="hblock_tag_8" canDelete="false" indentLevel="1" classfield_id="1007" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="1008" field_type="0" initialValue="Obj_to_ip - 2" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="1008" tag="tblock_3" canDelete="false" indentLevel="1" text=" Obj_to_ip prev;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="1008" tag="hblock_tag_9" canDelete="false" indentLevel="1" classfield_id="1008" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="1008" tag="hblock_tag_10" canDelete="false" indentLevel="1" classfield_id="1008" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader1127" parent_class="1127" fileExt=".h" fileName="olsr_con_list" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_CON_LIST_H&amp;#010;#define OLSR_CON_LIST_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="1127" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_con_list&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_con_list ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_CON_LIST_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_con_list.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.&amp;#010;   If you name t!
 he file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields/>
-    </classifiercodedocument>
-    <classifiercodedocument writeOutCode="true" package="" id="cppheader1234" parent_class="1234" fileExt=".h" fileName="olsr_con_list - 104.131.1.1:104.130.1.1" >
-     <textblocks>
-      <codeblockwithcomments tag="hashDefBlock" text="#ifndef OLSR_CON_LIST_-_104.131.1.1:104.130.1.1_H&amp;#010;#define OLSR_CON_LIST_-_104.131.1.1:104.130.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="includes" text="#include &lt;string>&amp;#010;#include &quot;olsr_con_list - 104.131.1.1:104.129.1.1.h&quot;&amp;#010;#include &quot;olsr_con_list.h&quot;&amp;#010;#include &quot;olsr_con.h&quot;&amp;#010;" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <codeblockwithcomments tag="using" writeOutText="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-      <hierarchicalcodeblock tag="namespace" canDelete="false" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" text="Namespace" />
-       </header>
-       <textblocks>
-        <codeblockwithcomments tag="enums" writeOutText="false" >
-         <header>
-          <cppcodedocumentation tag="" writeOutText="false" />
-         </header>
-        </codeblockwithcomments>
-        <cppheaderclassdeclarationblock parent_id="1234" tag="classDeclarationBlock" canDelete="false" >
-         <header>
-          <cppcodedocumentation tag="" text="Class olsr_con_list - 104.131.1.1:104.130.1.1&amp;#010;" />
-         </header>
-         <textblocks>
-          <hierarchicalcodeblock tag="publicBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Public stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="publicFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="pubMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks>
-                <codeblockwithcomments tag="emptyconstructor" writeOutText="false" indentLevel="1" text="olsr_con_list - 104.131.1.1:104.130.1.1 ( ) { }" >
-                 <header>
-                  <cppcodedocumentation tag="" indentLevel="1" text="Empty Constructor" />
-                 </header>
-                </codeblockwithcomments>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="pubStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="pubRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="protectedBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Protected stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="protectedFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks/>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="protMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="protStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="protRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-          <hierarchicalcodeblock tag="privateBlock" canDelete="false" >
-           <header>
-            <cppcodedocumentation tag="" text="Private stuff" />
-           </header>
-           <textblocks>
-            <hierarchicalcodeblock tag="privateFieldsDecl" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" text="Fields" />
-             </header>
-             <textblocks>
-              <ccfdeclarationcodeblock parent_id="1263" tag="tblock_0" canDelete="false" indentLevel="1" text=" olsr_con_list next_olsr_con_list;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-              <ccfdeclarationcodeblock parent_id="1264" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_con olsr_con;" >
-               <header>
-                <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-               </header>
-              </ccfdeclarationcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-            <hierarchicalcodeblock tag="privMethodsBlock" canDelete="false" indentLevel="1" >
-             <header>
-              <cppcodedocumentation tag="" indentLevel="1" />
-             </header>
-             <textblocks>
-              <hierarchicalcodeblock tag="constructionMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Constructors" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="accessorMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Accessor Methods" />
-               </header>
-               <textblocks>
-                <hierarchicalcodeblock tag="privStaticAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks/>
-                </hierarchicalcodeblock>
-                <hierarchicalcodeblock tag="privRegularAccessorMethods" canDelete="false" indentLevel="1" >
-                 <header>
-                  <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-                 </header>
-                 <textblocks>
-                  <codeaccessormethod accessType="0" parent_id="1263" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="1263" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="1263" tag="hblock_tag_2" canDelete="false" indentLevel="1" classfield_id="1263" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="0" parent_id="1264" tag="hblock_tag_3" canDelete="false" indentLevel="1" classfield_id="1264" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                  <codeaccessormethod accessType="1" parent_id="1264" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="1264" >
-                   <header>
-                    <cppcodedocumentation tag="" indentLevel="1" />
-                   </header>
-                  </codeaccessormethod>
-                 </textblocks>
-                </hierarchicalcodeblock>
-               </textblocks>
-              </hierarchicalcodeblock>
-              <hierarchicalcodeblock tag="operationMethods" canDelete="false" indentLevel="1" >
-               <header>
-                <cppcodedocumentation tag="" indentLevel="1" text="Operations" />
-               </header>
-               <textblocks/>
-              </hierarchicalcodeblock>
-             </textblocks>
-            </hierarchicalcodeblock>
-           </textblocks>
-          </hierarchicalcodeblock>
-         </textblocks>
-        </cppheaderclassdeclarationblock>
-       </textblocks>
-      </hierarchicalcodeblock>
-      <codeblockwithcomments tag="hashDefBlockEnd" text="#endif //OLSR_CON_LIST_-_104.131.1.1:104.130.1.1_H" >
-       <header>
-        <cppcodedocumentation tag="" writeOutText="false" />
-       </header>
-      </codeblockwithcomments>
-     </textblocks>
-     <header>
-      <codecomment tag="" text="/************************************************************************&amp;#010;  			olsr_con_list - 104.131.1.1:104.130.1.1.h - Copyright bigm&amp;#010;&amp;#010;Here you can write a license for your code, some comments or any other&amp;#010;information you want to have in your generated code. To to this simply&amp;#010;configure the &quot;headings&quot; directory in uml to point to a directory&amp;#010;where you have your heading files.&amp;#010;&amp;#010;or you can just replace the contents of this file with your own.&amp;#010;If you want to do this, this file is located at&amp;#010;&amp;#010;/usr/share/apps/umbrello/headings/heading.h&amp;#010;&amp;#010;-->Code Generators searches for heading files based on the file extension&amp;#010;   i.e. it will look for a file name ending in &quot;.h&quot; to include in C++ header&amp;#010;   files, and for a file name ending in &quot;.java&quot; to include in all generated&amp;#010;   java code.!
 &amp;#010;   If you name the file &quot;heading.&lt;extension>&quot;, Code Generator will always&amp;#010;   choose this file even if there are other files with the same extension in the&amp;#010;   directory. If you name the file something else, it must be the only one with that&amp;#010;   extension in the directory to guarantee that Code Generator will choose it.&amp;#010;&amp;#010;you can use variables in your heading files which are replaced at generation&amp;#010;time. possible variables are : author, date, time, filename and filepath.&amp;#010;just write %variable_name%&amp;#010;&amp;#010;This file was generated on Di Feb 28 2006 at 00:33:13&amp;#010;The original location of this file is &amp;#010;**************************************************************************/&amp;#010;" />
-     </header>
-     <classfields>
-      <codeclassfield parent_id="1263" field_type="0" initialValue="NULL" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="1263" tag="tblock_0" canDelete="false" indentLevel="1" text=" olsr_con_list next_olsr_con_list;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="1263" tag="hblock_tag_0" canDelete="false" indentLevel="1" classfield_id="1263" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="1263" tag="hblock_tag_2" canDelete="false" indentLevel="1" classfield_id="1263" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-      <codeclassfield parent_id="1264" field_type="0" initialValue="104.131.1.1:104.130.1.1" role_id="-1" writeOutMethods="true" listClassName="" >
-       <header>
-        <cppcodedocumentation tag="" />
-       </header>
-       <ccfdeclarationcodeblock parent_id="1264" tag="tblock_1" canDelete="false" indentLevel="1" text=" olsr_con olsr_con;" >
-        <header>
-         <cppcodedocumentation tag="" writeOutText="false" indentLevel="1" />
-        </header>
-       </ccfdeclarationcodeblock>
-       <codeaccessormethod accessType="0" parent_id="1264" tag="hblock_tag_3" canDelete="false" indentLevel="1" classfield_id="1264" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-       <codeaccessormethod accessType="1" parent_id="1264" tag="hblock_tag_4" canDelete="false" indentLevel="1" classfield_id="1264" >
-        <header>
-         <cppcodedocumentation tag="" indentLevel="1" />
-        </header>
-       </codeaccessormethod>
-      </codeclassfield>
-     </classfields>
-    </classifiercodedocument>
-   </codegenerator>
+   <codegenerator language="SQL" />
   </codegeneration>
  </XMI.extensions>
 </XMI>

Modified: trunk/apps/olsrs3d/olsrs3d.h
===================================================================
--- trunk/apps/olsrs3d/olsrs3d.h	2006-09-17 15:06:30 UTC (rev 401)
+++ trunk/apps/olsrs3d/olsrs3d.h	2006-09-17 16:02:40 UTC (rev 402)
@@ -41,6 +41,7 @@
 extern int	Olsr_node_inet_obj;
 extern int	Olsr_node_hna_net;
 extern int	Btn_close_obj;
+extern int	S3d_obj;
 extern int	Btn_close_id;
 extern int Olsr_node_count_obj;
 extern int Olsr_node_count;

Added: trunk/objs/s3d_berlios_de.3ds
===================================================================
(Binary files differ)


Property changes on: trunk/objs/s3d_berlios_de.3ds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From marec at mail.berlios.de  Sun Sep 17 18:03:20 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Sun, 17 Sep 2006 18:03:20 +0200
Subject: [S3d-svn] r403 - trunk/apps/olsrs3d
Message-ID: <200609171603.k8HG3KuX015767@sheep.berlios.de>

Author: marec
Date: 2006-09-17 18:03:19 +0200 (Sun, 17 Sep 2006)
New Revision: 403

Modified:
   trunk/apps/olsrs3d/main.c
Log:
s3d banner added - now complete

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-17 16:02:40 UTC (rev 402)
+++ trunk/apps/olsrs3d/main.c	2006-09-17 16:03:19 UTC (rev 403)
@@ -61,7 +61,7 @@
 int Output_block_counter = 0;
 int Output_block_completed = 0;
 
-int Olsr_node_obj, Olsr_node_inet_obj, Olsr_node_hna_net;
+int Olsr_node_obj, Olsr_node_inet_obj, Olsr_node_hna_net, S3d_obj;
 
 float Asp = 1.0;
 float Bottom = -1.0;
@@ -258,7 +258,8 @@
 	/* olsr node vanished */
 	if ( ( olsr_node->last_seen < Output_block_counter - 1 ) && ( olsr_node->visible ) ) {
 
-		if ( Debug ) printf( "olsr node vanished: %s\n", olsr_node->ip );
+		if ( Debug )
+			printf( "olsr node vanished: %s\n", olsr_node->ip );
 
 		Olsr_node_count--;
 
@@ -774,7 +775,7 @@
 		switch(key->keysym)
 		{
 			case S3DK_F1: /* help */
-				printf("S3DK_F1\n");
+
 				window_help();
 				break;
 
@@ -789,7 +790,7 @@
 				show_search_window();
 /*				set_return_point(CamPosition[0],CamPosition[1]);	/ * save the return position * /
 				set_node_root( Olsr_root );*/
-				
+
 				break;
 
 			case S3DK_c: /* color on/off */
@@ -810,7 +811,6 @@
 						RotateSpeed += 1.0;
 					else
 						RotateSpeed += 0.1;
-					printf("%f,\n",RotateSpeed);
 				}
 				break;
 
@@ -824,7 +824,6 @@
 						if(RotateSpeed > 0.2)
 							RotateSpeed -= 0.1;
 					}
-					printf("%f,\n",RotateSpeed);
 				}
 				break;
 
@@ -1107,7 +1106,8 @@
 
 	}
 
-	if ( Debug ) printf( "debug mode enabled ...\n" );
+	if ( Debug )
+		printf( "debug mode enabled ...\n" );
 
 	/* initialize obj2ip linked list */
 	lst_initialize();
@@ -1140,8 +1140,16 @@
 			Olsr_node_inet_obj = s3d_import_model_file( "objs/accesspoint_inet.3ds" );
 			Olsr_node_hna_net = s3d_import_model_file( "objs/internet.3ds" );
 			Btn_close_obj = s3d_import_model_file( "objs/btn_close.3ds" );
-/*			create_search_widget( 0, 0, 300 );*/
 
+			S3d_obj = s3d_import_model_file( "objs/s3d_berlios_de.3ds" );
+
+			s3d_translate( S3d_obj, 0.75, -0.75, -1 );
+			s3d_scale( S3d_obj, 0.07 );
+			s3d_link( S3d_obj, 0 );
+			s3d_flags_on( S3d_obj, S3D_OF_VISIBLE );
+
+			/* create_search_widget( 0, 0, 300 ); */
+
 			ZeroPoint = s3d_new_object();
 			Output_border[0] = Output_border[1] = Output_border[2] = Output_border[3] = -1;
 



From marec at mail.berlios.de  Sun Sep 17 18:20:16 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Sun, 17 Sep 2006 18:20:16 +0200
Subject: [S3d-svn] r404 - trunk/apps/olsrs3d
Message-ID: <200609171620.k8HGKGdC017273@sheep.berlios.de>

Author: marec
Date: 2006-09-17 18:20:15 +0200 (Sun, 17 Sep 2006)
New Revision: 404

Modified:
   trunk/apps/olsrs3d/main.c
Log:
olsrs3d help window fixed

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-17 16:03:19 UTC (rev 403)
+++ trunk/apps/olsrs3d/main.c	2006-09-17 16:20:15 UTC (rev 404)
@@ -115,18 +115,18 @@
 	s3dw_surface *infwin;
 	s3dw_button  *button;
 
-	infwin = s3dw_surface_new( "Help Window", 12, 14 );
+	infwin = s3dw_surface_new( "Help Window", 20, 19 );
 	s3dw_label_new(infwin,"C        - Colour On/Off",1,2);
-	s3dw_label_new(infwin,"R        - Rotation On/Off",1,3);
-	s3dw_label_new(infwin,"+        - Increase Rotation Speed",1,4);
-	s3dw_label_new(infwin,"-        - Decrease Rotation Speed",1,5);
-	s3dw_label_new(infwin,"S        - Search IP",1,6);
-	s3dw_label_new(infwin,"ESC      - Disable FollowMode",1,7);
-	s3dw_label_new(infwin,"PGUP     - Increase Drift Factor",1,8);
-	s3dw_label_new(infwin,"PGDOWN   - Decrease Drift Factor",1,9);
-	s3dw_label_new(infwin,"STRG + P - Decrease Drift Factor",1,9);
+	s3dw_label_new(infwin,"R        - Rotation On/Off",1,4);
+	s3dw_label_new(infwin,"+        - Increase Rotation Speed",1,5);
+	s3dw_label_new(infwin," -        - Decrease Rotation Speed",1,6);
+	s3dw_label_new(infwin,"S        - Search IP",1,8);
+	s3dw_label_new(infwin,"ESC      - Disable FollowMode",1,9);
+	s3dw_label_new(infwin,"PGUP     - Increase Drift Factor",1,11);
+	s3dw_label_new(infwin,"PGDOWN   - Decrease Drift Factor",1,12);
+	s3dw_label_new(infwin,"STRG + P - Reset Nodes",1,14);
 
-	button=s3dw_button_new(infwin,"OK",4,12);
+	button=s3dw_button_new(infwin,"OK",10,16);
 	button->onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 
@@ -830,7 +830,6 @@
 			case S3DK_p: /* strg + p -> reset nodes ( zeroPoint to 0,0,0 ) */
 				if (key->modifier&(S3D_KMOD_LCTRL|S3D_KMOD_RCTRL))
 				{
-
 					s3d_rotate(ZeroPoint, 0, 0, 0);
 					Zp_rotate = 0.0;
 				}
@@ -875,7 +874,7 @@
 
 	oid=(int)*((unsigned long *)evt->buf);
 
-	if( oid == Btn_close_id )
+/*	if( oid == Btn_close_id )
 	{
 		s3d_del_object(Btn_close_id);
 		s3d_del_object(Olsr_ip_label_obj);
@@ -913,7 +912,7 @@
 		s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
 		s3d_scale( Olsr_ip_label_obj, 0.2 );
 		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.2, -3.0 );
-		/*
+
 		cam_go=1;
 		if ( Olsr_ip_label_obj != -1 ) s3d_del_object( Olsr_ip_label_obj );
 		snprintf( ip_str, 35, "ip: %s", Olsr_node_pEtx->ip );
@@ -922,8 +921,8 @@
 		s3d_flags_on( Olsr_ip_label_obj, S3D_OF_VISIBLE );
 		s3d_scale( Olsr_ip_label_obj, 0.2 );
 		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
-		*/
-	}
+
+	}*/
 }
 
 void print_etx()



From dotslash at mail.berlios.de  Sun Sep 17 22:04:24 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 17 Sep 2006 22:04:24 +0200
Subject: [S3d-svn] r405 - in trunk: . apps/olsrs3d libs3dw
Message-ID: <200609172004.k8HK4OnT006529@sheep.berlios.de>

Author: dotslash
Date: 2006-09-17 22:04:23 +0200 (Sun, 17 Sep 2006)
New Revision: 405

Modified:
   trunk/
   trunk/apps/olsrs3d/main.c
   trunk/libs3dw/arrange.c
Log:
 r986 at balthasar:  dotslash | 2006-09-17 22:04:14 +0200
 - window move more to camera
 - 1 label become 2 O.o



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:900
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:986

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-17 16:20:15 UTC (rev 404)
+++ trunk/apps/olsrs3d/main.c	2006-09-17 20:04:23 UTC (rev 405)
@@ -116,7 +116,9 @@
 	s3dw_button  *button;
 
 	infwin = s3dw_surface_new( "Help Window", 20, 19 );
-	s3dw_label_new(infwin,"C        - Colour On/Off",1,2);
+
+	/*s3dw_label_new(infwin,"C        - Colour On/Off",1,2);*/
+	s3dw_label_new(infwin,"C",1,2); 						s3dw_label_new(infwin,"- Colour On/Off",3,2);
 	s3dw_label_new(infwin,"R        - Rotation On/Off",1,4);
 	s3dw_label_new(infwin,"+        - Increase Rotation Speed",1,5);
 	s3dw_label_new(infwin," -        - Decrease Rotation Speed",1,6);

Modified: trunk/libs3dw/arrange.c
===================================================================
--- trunk/libs3dw/arrange.c	2006-09-17 16:20:15 UTC (rev 404)
+++ trunk/libs3dw/arrange.c	2006-09-17 20:04:23 UTC (rev 405)
@@ -109,7 +109,7 @@
 		}
 	}
 }
-#define DIST	60.0
+#define DIST	30.0
 void s3dw_follow()
 {
 	s3dw_widget *w,*root=s3dw_getroot();



From dotslash at mail.berlios.de  Sun Sep 17 23:43:14 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 17 Sep 2006 23:43:14 +0200
Subject: [S3d-svn] r406 - in trunk: . server
Message-ID: <200609172143.k8HLhEA3015100@sheep.berlios.de>

Author: dotslash
Date: 2006-09-17 23:43:13 +0200 (Sun, 17 Sep 2006)
New Revision: 406

Modified:
   trunk/
   trunk/server/main.c
   trunk/server/shm.c
Log:
 r988 at balthasar:  dotslash | 2006-09-17 23:43:09 +0200
 - shm quickfix



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:986
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:988

Modified: trunk/server/main.c
===================================================================
--- trunk/server/main.c	2006-09-17 20:04:23 UTC (rev 405)
+++ trunk/server/main.c	2006-09-17 21:43:13 UTC (rev 406)
@@ -68,10 +68,9 @@
 {
 #ifdef SIGS
 	int ret,i;
-	struct timespec t={0,200*1000*1000}; /* 200 mili seconds */
+	struct timespec t={0,500*1000*1000}; /* 500 mili seconds */
 	if (signal(SIGCHLD, sigchld_handler) == SIG_ERR);
 	kidpid=fork();
-	running=1;
 	if (kidpid==-1)
 	{
 		errsf("rc_init()","*sobsob*, can't fork");

Modified: trunk/server/shm.c
===================================================================
--- trunk/server/shm.c	2006-09-17 20:04:23 UTC (rev 405)
+++ trunk/server/shm.c	2006-09-17 21:43:13 UTC (rev 406)
@@ -44,7 +44,7 @@
 extern int procs_n;
 struct t_shmcb waiting_comblock;
 
-key_t *data;
+key_t *data=NULL;
 char ftoken[]="/tmp/.s3d";
 int shmid;
 int mkey;	/* increasing key */
@@ -141,12 +141,15 @@
 	/* detach from the segment: */
 	s3dprintf(LOW,"shm_quit()...");
 	unlink(ftoken);
-	data[0]=data[1]=0;
-	s3dprintf(MED,"shm_quit():removing init block");
-	if (shmdt(data) == -1) 
-		errn("shm_quit():shmdt()",errno);
-	if (shmctl(shmid, IPC_RMID, NULL) == -1) 
-		errn("shm_quit():shmctl()",errno);
+	if (data!=NULL)
+	{
+		data[0]=data[1]=0;
+		s3dprintf(MED,"shm_quit():removing init block");
+		if (shmdt(data) == -1) 
+			errn("shm_quit():shmdt()",errno);
+		if (shmctl(shmid, IPC_RMID, NULL) == -1) 
+			errn("shm_quit():shmctl()",errno);
+	}
 	return(0);
 }
 int shm_remove(struct t_process *p)



From dotslash at mail.berlios.de  Mon Sep 18 00:11:53 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 00:11:53 +0200
Subject: [S3d-svn] r407 - in trunk: . server
Message-ID: <200609172211.k8HMBr9T018409@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 00:11:53 +0200 (Mon, 18 Sep 2006)
New Revision: 407

Modified:
   trunk/
   trunk/server/main.c
Log:
 r990 at balthasar:  dotslash | 2006-09-18 00:11:48 +0200
 - rcfile upgrade, now listing to SIGUSR1 - thanks marek



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:988
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:990

Modified: trunk/server/main.c
===================================================================
--- trunk/server/main.c	2006-09-17 21:43:13 UTC (rev 406)
+++ trunk/server/main.c	2006-09-17 22:11:53 UTC (rev 407)
@@ -44,6 +44,7 @@
 static char *rc=NULL;
 static char *homerc="~/.s3drc";
 static char *etcrc ="/etc/s3drc";
+static int father_done=0;
 char **s3drc[]={&rc,&homerc,&etcrc};
 
 static void mainloop(void);
@@ -64,12 +65,17 @@
 	}
 }
 #endif
+void sigusr_handler(int sig)
+{
+	s3dprintf(HIGH,"father told use he's done, so lets start to think about the rc file ...");
+	running=1;
+}
+
 int rc_init(void)
 {
 #ifdef SIGS
 	int ret,i;
-	struct timespec t={0,500*1000*1000}; /* 500 mili seconds */
-	if (signal(SIGCHLD, sigchld_handler) == SIG_ERR);
+	struct timespec t={0,10*1000*1000}; /* 10 mili seconds */
 	kidpid=fork();
 	if (kidpid==-1)
 	{
@@ -78,19 +84,23 @@
 	}
 	if (kidpid==0)
 	{
-		nanosleep(&t,NULL); 	/* giving the father lots of time to set his signal handler
-					 			 * and all his sockets up */
-		s3dprintf(VHIGH,"hello, i'm the kid and will start the rc file now!");
+	    if (signal(SIGUSR1, sigusr_handler) == SIG_ERR) 
+		        errn("init():signal()",errno);
+
+		/* giving the father lots of time to set his signal handler
+		 * and all his sockets up */
+		while (!running)  
+			nanosleep(&t,NULL); 	
 		for (i=0;i<(sizeof(s3drc)/sizeof(char **));i++)
 		{
 			if ((*s3drc[i])!=NULL)
 			{
 				s3dprintf(LOW,"[RC] launching %s",*s3drc[i]);
 				ret=system(*s3drc[i]);
-				s3dprintf(LOW,"[RC] system() said %d",ret);
+				s3dprintf(VLOW,"[RC] system() said %d",ret);
 				if (ret<128) 
 				{
-					s3dprintf(LOW,"[RC] system() did well, I guess. let's die clean now.");
+					s3dprintf(LOW,"V[RC] system() did well, I guess. let's die clean now.");
 					exit(0);
 				}
 			} 
@@ -107,6 +117,7 @@
 		}
 		exit(1);
 	} else {
+		if (signal(SIGCHLD, sigchld_handler) == SIG_ERR);
 		/* father just returns */
 	}	
 #endif
@@ -166,6 +177,7 @@
 	        errn("init():signal()",errno);
     if (signal(SIGTERM, sigint_handler) == SIG_ERR) 
 	        errn("init():signal()",errno);
+	kill(kidpid, SIGUSR1);
 #endif
 	return(0);
 }



From dotslash at mail.berlios.de  Mon Sep 18 00:39:23 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 00:39:23 +0200
Subject: [S3d-svn] r408 - in trunk: . libs3d
Message-ID: <200609172239.k8HMdNnY011387@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 00:39:21 +0200 (Mon, 18 Sep 2006)
New Revision: 408

Modified:
   trunk/
   trunk/libs3d/Makefile.am
Log:
 r992 at balthasar:  dotslash | 2006-09-18 00:39:09 +0200
 - build fix



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:990
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:992

Modified: trunk/libs3d/Makefile.am
===================================================================
--- trunk/libs3d/Makefile.am	2006-09-17 22:11:53 UTC (rev 407)
+++ trunk/libs3d/Makefile.am	2006-09-17 22:39:21 UTC (rev 408)
@@ -1,4 +1,4 @@
-SUBDIRS=. libg3d
+SUBDIRS= libg3d
 lib_LTLIBRARIES=	libs3d.la
 
 libs3d_la_SOURCES=	modelread.c callback.c error.c event.c fontselect.c \



From marec at mail.berlios.de  Mon Sep 18 01:11:45 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Mon, 18 Sep 2006 01:11:45 +0200
Subject: [S3d-svn] r409 - trunk/apps/olsrs3d
Message-ID: <200609172311.k8HNBjgZ007038@sheep.berlios.de>

Author: marec
Date: 2006-09-18 01:11:44 +0200 (Mon, 18 Sep 2006)
New Revision: 409

Modified:
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/search.c
Log:
olsrs3d help window fixed II (more labels added)
IP search on RETURN reenabled
IP search fixed

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-17 22:39:21 UTC (rev 408)
+++ trunk/apps/olsrs3d/main.c	2006-09-17 23:11:44 UTC (rev 409)
@@ -118,17 +118,27 @@
 	infwin = s3dw_surface_new( "Help Window", 20, 19 );
 
 	/*s3dw_label_new(infwin,"C        - Colour On/Off",1,2);*/
-	s3dw_label_new(infwin,"C",1,2); 						s3dw_label_new(infwin,"- Colour On/Off",3,2);
-	s3dw_label_new(infwin,"R        - Rotation On/Off",1,4);
-	s3dw_label_new(infwin,"+        - Increase Rotation Speed",1,5);
-	s3dw_label_new(infwin," -        - Decrease Rotation Speed",1,6);
-	s3dw_label_new(infwin,"S        - Search IP",1,8);
-	s3dw_label_new(infwin,"ESC      - Disable FollowMode",1,9);
-	s3dw_label_new(infwin,"PGUP     - Increase Drift Factor",1,11);
-	s3dw_label_new(infwin,"PGDOWN   - Decrease Drift Factor",1,12);
-	s3dw_label_new(infwin,"STRG + P - Reset Nodes",1,14);
+	s3dw_label_new(infwin,"c",1,2);
+	s3dw_label_new(infwin,"- Colour On/Off",6,2);
+	/*s3dw_label_new(infwin,"r        - Rotation On/Off",1,4);*/
+	s3dw_label_new(infwin,"r",1,4);
+	s3dw_label_new(infwin,"- Rotation On/Off",6,4);
+	s3dw_label_new(infwin,"+",1,5);
+	s3dw_label_new(infwin,"- Increase Rotation Speed",6,5);
+	s3dw_label_new(infwin,"-",1,6);
+	s3dw_label_new(infwin,"- Decrease Rotation Speed",6,6);
+	s3dw_label_new(infwin,"s",1,8);
+	s3dw_label_new(infwin,"- Search IP",6,8);
+	s3dw_label_new(infwin,"ESC",1,9);
+	s3dw_label_new(infwin,"- Disable FollowMode",6,9);
+	s3dw_label_new(infwin,"PGUP",1,11);
+	s3dw_label_new(infwin,"- Increase Drift Factor",6,11);
+	s3dw_label_new(infwin,"PGDOWN",1,12);
+	s3dw_label_new(infwin,"- Decrease Drift Factor",6,12);
+	s3dw_label_new(infwin,"STRG + p",1,14);
+	s3dw_label_new(infwin,"- Reset Nodes",6,14);
 
-	button=s3dw_button_new(infwin,"OK",10,16);
+	button=s3dw_button_new(infwin,"OK",9,16);
 	button->onclick = close_win;
 	s3dw_show(S3DWIDGET(infwin));
 
@@ -789,6 +799,7 @@
 			case S3DK_s: /* move to search widget, give widget focus */
 
 				set_search_status(WIDGET);							/* set status for mainloop */
+				set_node_root( Olsr_root );
 				show_search_window();
 /*				set_return_point(CamPosition[0],CamPosition[1]);	/ * save the return position * /
 				set_node_root( Olsr_root );*/

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2006-09-17 22:39:21 UTC (rev 408)
+++ trunk/apps/olsrs3d/search.c	2006-09-17 23:11:44 UTC (rev 409)
@@ -1,21 +1,21 @@
 /*
  * search.c
- * 
+ *
  * Copyright (C) 2006 Andreas Langer <andreas_lbg at gmx.de>
  *
  * This file is part of the olsrs3d, an olsr topology visualizer for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * s3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -40,7 +40,7 @@
 
 float	_return_point[2][3];				/* cam position before move to the widget */
 int		_search_status = NOTHING;			/* status of search */
-											
+
 void _search_node(s3dw_widget *dummy);
 void _new_search_node(s3dw_widget *dummy);
 void _abort_search(s3dw_widget *dummy);
@@ -54,7 +54,7 @@
 		  tmp_vec[3],
 		  diff_vec[3],
 		  angle;
-	
+
 	real_node_pos[0] =  (*search_node)->pos_vec[0] * cos( rotate * M_PI / 180.0 ) - (*search_node)->pos_vec[2] * -sin ( rotate * M_PI / 180.0 );
 	real_node_pos[1] =  (*search_node)->pos_vec[1];
 	real_node_pos[2] =  (*search_node)->pos_vec[0] * -sin( rotate * M_PI / 180.0) + (*search_node)->pos_vec[2] * cos ( rotate * M_PI / 180.0 );
@@ -62,15 +62,15 @@
 	cam_target[0] = ( real_node_pos[0] + 7);
 	cam_target[1] =   real_node_pos[1];
 	cam_target[2] = ( real_node_pos[2] + 7);
-	
+
 	cam_position_t[0]=( cam_position_t[0] * 4 + cam_target[0] ) / 5;
 	cam_position_t[1]=( cam_position_t[1] * 4 + cam_target[1] ) / 5;
 	cam_position_t[2]=( cam_position_t[2] * 4 + cam_target[2] ) / 5;
-	
+
 	tmp_vec[0] =  0.0;
 	tmp_vec[1] =  0.0;
 	tmp_vec[2] = -1.0;
-	
+
 	diff_vec[0] = cam_position_t[0] - real_node_pos[0];
 	diff_vec[1] = 0.0;
 	diff_vec[2] = cam_position_t[2] - real_node_pos[2];
@@ -78,7 +78,7 @@
 	/* angle = ( real_node_pos[0] > 0) ? ( 180 - ( 180 / M_PI * angle ) ) : ( 180 + ( 180 / M_PI * angle ) ); */
 	angle = 180 - ( 180 / M_PI * angle );
 	cam_position_r[1] = ( cam_position_r[1] * 4 + angle ) / 5;
-	
+
 	s3d_translate( 0, cam_position_t[0], cam_position_t[1], cam_position_t[2] );
 	s3d_rotate( 0, cam_position_r[0], cam_position_r[1], cam_position_r[2] );
 }
@@ -93,45 +93,46 @@
 void show_search_window()
 {
 	s3dw_button *search_button, *abort_button;
-	
+
 	_search_surface	= s3dw_surface_new( "Node Search", 17, 10 );
 	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
-	
+
 	s3dw_label_new( _search_surface, "Enter the IP of the node.", 1, 2);
 	s3dw_focus( S3DWIDGET( _search_input ) );
-	
+
 	search_button = s3dw_button_new( _search_surface, "Search", 11.5, 7 );
 	abort_button  = s3dw_button_new( _search_surface, "Abort", 1, 7 );
 	search_button->onclick = _new_search_node;
 	abort_button->onclick = _abort_search_window;
 
 	/* TODO calc position for ok button */
-	
-	s3dw_focus	( S3DWIDGET( _search_input ) );	
+
+	s3dw_focus	( S3DWIDGET( _search_input ) );
 	s3dw_focus	( S3DWIDGET( _search_surface ) );
 	s3dw_show	( S3DWIDGET( _search_surface ) );
 
+	_search_widget	= search_button;
 }
 
 /* public */
 void create_search_widget(float x, float y, float z)
 {
 	s3dw_button *search_button, *abort_button;
-	
+
 	_search_surface	= s3dw_surface_new( "Node Search", 17, 10 );
 	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
-	
+
 	s3dw_label_new( _search_surface, "Enter the IP of the node.", 1, 2);
 	s3dw_focus( S3DWIDGET( _search_input ) );
-	
+
 	search_button = s3dw_button_new( _search_surface, "Search", 11.5, 7 );
 	abort_button  = s3dw_button_new( _search_surface, "Abort", 1, 7 );
 	search_button->onclick = _search_node;
 	abort_button->onclick = _abort_search;
 
 	/* TODO calc position for ok button */
-	
-	s3dw_focus	( S3DWIDGET( _search_input ) );	
+
+	s3dw_focus	( S3DWIDGET( _search_input ) );
 	s3dw_focus	( S3DWIDGET( _search_surface ) );
 	s3dw_show	( S3DWIDGET( _search_surface ) );
 
@@ -154,7 +155,7 @@
 void move_to_search_widget(float cam_position_t[], float cam_position_r[])
 {
 	float target, current;
-	
+
 	set_search_status(WIDGET);
 	cam_position_t[0] = ( cam_position_t[0] * 4 + _search_widget->x ) / 5;
 	cam_position_t[1] = ( cam_position_t[1] * 4 + _search_widget->y ) / 5;
@@ -186,12 +187,12 @@
 	if( _search_widget->arz - cam_position_r[2] < -180 )
 		current -= 360;
 	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
-	
+
 	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
 	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
-	
-	if ( sqrt(  (( cam_position_t[0] - _search_widget->x)*( cam_position_t[0] - _search_widget->x)) + 
-				(( cam_position_t[1] - _search_widget->y)*( cam_position_t[1] - _search_widget->y)) + 
+
+	if ( sqrt(  (( cam_position_t[0] - _search_widget->x)*( cam_position_t[0] - _search_widget->x)) +
+				(( cam_position_t[1] - _search_widget->y)*( cam_position_t[1] - _search_widget->y)) +
 				(( cam_position_t[2] - _search_widget->z)*( cam_position_t[2] - _search_widget->z)) ) < 0.2 )
 	{
 		s3d_translate( 0, _search_widget->x, _search_widget->y, ( _search_widget->z - 10 ) );
@@ -234,12 +235,12 @@
 	if( _return_point[1][2] - cam_position_r[2] < -180 )
 		current -= 360;
 	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
-	
+
 	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
 	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
-	
-	if ( sqrt(  (( cam_position_t[0] - _return_point[0][0])*( cam_position_t[0] - _return_point[0][0])) + 
-				(( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) + 
+
+	if ( sqrt(  (( cam_position_t[0] - _return_point[0][0])*( cam_position_t[0] - _return_point[0][0])) +
+				(( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) +
 				(( cam_position_t[2] - _return_point[0][2])*( cam_position_t[2] - _return_point[0][2])) ) < 0.2 )
 	{
 		s3d_translate( 0, _return_point[0][0], _return_point[0][1], _return_point[0][2] );
@@ -249,18 +250,18 @@
 }
 
 /* public */
-/* TODO: WTF?! 
- * please fix: 
- *  - s is not initialized but still strlen() is used?! 
+/* TODO: WTF?!
+ * please fix:
+ *  - s is not initialized but still strlen() is used?!
  *  - s will vanish after the function is processed. global variable would be better
  *  - don't forget the terminating \0 after writing a key */
 void search_widget_write(int key)
 {
 	static char s[20];
 	int ln = strlen(s);
-	
+
 	if( key == S3DK_COMMA ) key = S3DK_PERIOD;
-	
+
 	if( key != S3DK_RETURN )
 	{
 		if( key == S3DK_BACKSPACE )
@@ -273,7 +274,7 @@
 		}
 		s3dw_input_change_text( _search_input, s );
 	} else {
-		_search_node( _search_widget );	
+		_new_search_node( _search_widget );
 	}
 }
 
@@ -310,19 +311,20 @@
 {
 	char *ip;
 	int result;
-	
+
 	search_node = &_node_root;
-	
+
 	ip = s3dw_input_gettext( _search_input );
-	
+
 	while ( (*search_node) != NULL )
 	{
 
 		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
 
-		if ( result == 0 ) 
+		printf( "ip: %s\n", (*search_node)->ip );
+		if ( result == 0 )
 			break;
-		
+
 		if ( result < 0 )
 			(*search_node) = (*search_node)->right;
 		else
@@ -336,7 +338,6 @@
 
 	if( (*search_node) != NULL )
 	{
-		window_error("Okay, following");
 		set_search_status( FOLLOW );
 	}
 	else
@@ -350,19 +351,19 @@
 {
 	char *ip;
 	int result;
-	
+
 	search_node = &_node_root;
-	
+
 	ip = s3dw_input_gettext( _search_input );
-	
+
 	while ( (*search_node) != NULL )
 	{
 
 		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
 
-		if ( result == 0 ) 
+		if ( result == 0 )
 			break;
-		
+
 		if ( result < 0 )
 			(*search_node) = (*search_node)->right;
 		else



From dotslash at mail.berlios.de  Mon Sep 18 01:55:03 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 01:55:03 +0200
Subject: [S3d-svn] r410 - in trunk: . libs3dw
Message-ID: <200609172355.k8HNt3CQ000717@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 01:55:02 +0200 (Mon, 18 Sep 2006)
New Revision: 410

Modified:
   trunk/
   trunk/libs3dw/TODO
Log:
 r996 at balthasar:  dotslash | 2006-09-18 01:54:52 +0200
 - TODO :D



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:992
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:996

Modified: trunk/libs3dw/TODO
===================================================================
--- trunk/libs3dw/TODO	2006-09-17 23:11:44 UTC (rev 409)
+++ trunk/libs3dw/TODO	2006-09-17 23:55:02 UTC (rev 410)
@@ -1,3 +1,6 @@
+- let widgets popup infront of the camera
+- blinking when creating? 
+- checkbox
+- hbox/vbox, aligning
 - focus colors, focus cycling
-- let widgets move
-- rotate widgets to camera
+



From dotslash at mail.berlios.de  Mon Sep 18 19:07:33 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 19:07:33 +0200
Subject: [S3d-svn] r411 - in trunk: . apps/dot_mcp
Message-ID: <200609181707.k8IH7Xnw004151@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 19:07:32 +0200 (Mon, 18 Sep 2006)
New Revision: 411

Modified:
   trunk/
   trunk/apps/dot_mcp/main.c
Log:
 r1001 at balthasar:  dotslash | 2006-09-18 19:07:27 +0200
 - egomode: F1 -> F2 ;D



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:996
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1001

Modified: trunk/apps/dot_mcp/main.c
===================================================================
--- trunk/apps/dot_mcp/main.c	2006-09-17 23:55:02 UTC (rev 410)
+++ trunk/apps/dot_mcp/main.c	2006-09-18 17:07:32 UTC (rev 411)
@@ -467,7 +467,7 @@
 	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
 	switch (keys->keysym)
 	{
-		case S3DK_F1:  ego_mode=(ego_mode+1)%2;
+		case S3DK_F2:  ego_mode=(ego_mode+1)%2;
 				 xdif=0;
 			     ydif=0;
 				 printf("ego mode %d\n",ego_mode);



From dotslash at mail.berlios.de  Mon Sep 18 19:32:28 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 19:32:28 +0200
Subject: [S3d-svn] r412 - in trunk: . libs3dw
Message-ID: <200609181732.k8IHWSm8021868@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 19:32:28 +0200 (Mon, 18 Sep 2006)
New Revision: 412

Modified:
   trunk/
   trunk/libs3dw/TODO
   trunk/libs3dw/event.c
   trunk/libs3dw/surface.c
Log:
 r1003 at balthasar:  dotslash | 2006-09-18 19:32:21 +0200
 - widgets popup infront of the user



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1001
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1003

Modified: trunk/libs3dw/TODO
===================================================================
--- trunk/libs3dw/TODO	2006-09-18 17:07:32 UTC (rev 411)
+++ trunk/libs3dw/TODO	2006-09-18 17:32:28 UTC (rev 412)
@@ -1,6 +1,3 @@
-- let widgets popup infront of the camera
-- blinking when creating? 
 - checkbox
 - hbox/vbox, aligning
 - focus colors, focus cycling
-

Modified: trunk/libs3dw/event.c
===================================================================
--- trunk/libs3dw/event.c	2006-09-18 17:07:32 UTC (rev 411)
+++ trunk/libs3dw/event.c	2006-09-18 17:32:28 UTC (rev 412)
@@ -46,6 +46,10 @@
 		_s3dw_cam->ax=_s3dw_cam->x=info->trans_x;
 		_s3dw_cam->ay=_s3dw_cam->y=info->trans_y;
 		_s3dw_cam->az=_s3dw_cam->z=info->trans_z;
+		_s3dw_cam->arx=_s3dw_cam->rx=info->rot_x;
+		_s3dw_cam->ary=_s3dw_cam->ry=info->rot_y;
+		_s3dw_cam->arz=_s3dw_cam->rz=info->rot_z;
+
 		_s3dw_cam->flags&=~S3DW_ARRANGED;
 		s3dw_ani_needarr();
 	}

Modified: trunk/libs3dw/surface.c
===================================================================
--- trunk/libs3dw/surface.c	2006-09-18 17:07:32 UTC (rev 411)
+++ trunk/libs3dw/surface.c	2006-09-18 17:32:28 UTC (rev 412)
@@ -26,6 +26,9 @@
 #include <s3dw_int.h>
 #include <stdlib.h> /* malloc() */
 #include <string.h> /* strdup() */
+#include <math.h>	/* cos(), sin() */
+#define POPUPDIST	40
+extern s3dw_widget *_s3dw_cam; /* for correct popup position */
 
 void s3dw_surface_draw(s3dw_widget *widget)
 {
@@ -108,6 +111,8 @@
 	s3d_link(surface->oid_title,surface->oid_tbar);
 	s3d_link(widget->oid,widget->parent->oid);
 	s3d_translate(surface->oid_title,0.5,0.2,0.1);
+	s3d_scale(widget->oid,	widget->as);
+	s3d_translate(widget->oid,	widget->ax, widget->ay, widget->az);
 }
 /* show the surface */
 void s3dw_surface_show(s3dw_widget *widget)
@@ -140,11 +145,14 @@
 	widget->height=height;
 	widget->as=0.01;
 	s3dw_arr_widgetcenter(widget,f1);
-	widget->x=-f1[0];
-	widget->y=-f1[1];
-	widget->z=-f1[2];
+	s3dw_widget_append(s3dw_getroot(),widget);
+	widget->x=-f1[0] + _s3dw_cam->x - sin( _s3dw_cam->ry * M_PI/180) * 	cos ( _s3dw_cam->rx *M_PI/180) * POPUPDIST;
+	widget->y=-f1[1] + _s3dw_cam->y + 								   	sin( _s3dw_cam->rx * M_PI/180 ) *POPUPDIST;
+	widget->z=-f1[2] + _s3dw_cam->z - cos( _s3dw_cam->ry * M_PI/180) * 	cos ( _s3dw_cam->rx *M_PI/180) * POPUPDIST;
+	widget->ax=widget->x;
+	widget->ay=widget->y;
+	widget->az=widget->z;
 	widget->flags|=S3DW_FOLLOW_CAM|S3DW_TURN_CAM;
-	s3dw_widget_append(s3dw_getroot(),widget);
 	s3dw_surface_draw(widget);
 	s3dw_ani_needarr();
 	s3dw_ani_add(widget);



From dotslash at mail.berlios.de  Mon Sep 18 20:02:57 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 20:02:57 +0200
Subject: [S3d-svn] r413 - in trunk: . libs3dw
Message-ID: <200609181802.k8II2vKR024058@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 20:02:57 +0200 (Mon, 18 Sep 2006)
New Revision: 413

Modified:
   trunk/
   trunk/libs3dw/arrange.c
Log:
 r1005 at balthasar:  dotslash | 2006-09-18 20:02:49 +0200
 - correcting rotation to user



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1003
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1005

Modified: trunk/libs3dw/arrange.c
===================================================================
--- trunk/libs3dw/arrange.c	2006-09-18 17:32:28 UTC (rev 412)
+++ trunk/libs3dw/arrange.c	2006-09-18 18:02:57 UTC (rev 413)
@@ -85,21 +85,29 @@
 			b[1]=0;
 			b[2]=w->z + op[2]  - _s3dw_cam->z;
 			ry=180*s3d_vector_angle(a,b)/M_PI;
+			if ((b[0]==0) && (b[1]==0) && (b[2]==0)) ry=0;
 			/* correct acos incompletness */
 			if (b[0]<0) ry=180-ry;
 			else 		ry=180+ry;
+
+			b[2]=sqrt(b[0]*b[0] + b[2]*b[2]);
+			b[1]=w->y + op[1]   - _s3dw_cam->y;
 			b[0]=0;
-			b[1]=w->y + op[1]   - _s3dw_cam->y;
-			b[2]=w->z + op[2]   - _s3dw_cam->z;
 			rx=180*s3d_vector_angle(a,b)/M_PI;
+			if ((b[0]==0) && (b[1]==0) && (b[2]==0)) rx=0;
 			if (b[1]>0) rx=180-rx;
 			else 		rx=180+rx;
-			if ((rx>90) && (rx<=180)) 
-				rx=180 - rx;
+			if 		((rx>90) && (rx<=180)) 	 rx=180 - rx;
 			else if ((rx>=180) && (rx<270))  rx=540 - rx ;
 
 			w->rx=rx;
 			w->ry=ry;
+			if ((w->arx - w->rx)>180)  w->arx-=360;
+			if ((w->arx - w->rx)<-180) w->arx+=360;
+			if ((w->ary - w->ry)>180)  w->ary-=360;
+			if ((w->ary - w->ry)<-180) w->ary+=360;
+
+
 			s3dw_arr_widgetcenter(w,np);
 			w->x-=np[0] - op[0];
 			w->y-=np[1] - op[1];



From dotslash at mail.berlios.de  Mon Sep 18 20:18:04 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 20:18:04 +0200
Subject: [S3d-svn] r414 - in trunk: . Documentation apps/s3d_x11gate libs3d
	libs3dw
Message-ID: <200609181818.k8III4DD025175@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 20:18:03 +0200 (Mon, 18 Sep 2006)
New Revision: 414

Added:
   trunk/libs3dw/lgpl.txt
Modified:
   trunk/
   trunk/Documentation/Makefile.am
   trunk/apps/s3d_x11gate/s3d_x11gate.c
   trunk/configure.ac
   trunk/libs3d/TODO
Log:
 r1007 at balthasar:  dotslash | 2006-09-18 20:17:58 +0200
 - fix some printfs in s3d_x11gate
 - fix autoconf stuff for release



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1005
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1007

Modified: trunk/Documentation/Makefile.am
===================================================================
--- trunk/Documentation/Makefile.am	2006-09-18 18:02:57 UTC (rev 413)
+++ trunk/Documentation/Makefile.am	2006-09-18 18:18:03 UTC (rev 414)
@@ -1,5 +1,5 @@
 #SUBDIRS		= s3dapi
 
-EXTRA_DIST	= s3drc.txt for_icon_designer.txt OPEN_PROBLEMS.txt \
-		  s3dapi/README s3dapi/bookinfo.docbook s3dapi/s3dapi.docbook
+EXTRA_DIST	=  README libs3d/libs3d.docbook s3d.docbook misc.docbook libs3dw/libs3dw.docbook \
+			   bookinfo.docbook server/server.docbook introduction.docbook
 

Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2006-09-18 18:02:57 UTC (rev 413)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2006-09-18 18:18:03 UTC (rev 414)
@@ -78,7 +78,6 @@
 	start.tv_usec 	=end.tv_usec;
 
 /*	image = XGetImage(dpy,window,0,0,width,height,AllPlanes,ZPixmap);*/
-	printf("dpy: %010p, window: %010p, image: %010p\n",dpy,window,image);
 	XShmGetImage(dpy, window, image, 0,0,0xffffffff);
 	gettimeofday(&end,NULL);
 	count[1]+=(end.tv_sec-start.tv_sec)*10000000 + end.tv_usec-start.tv_usec;
@@ -152,9 +151,6 @@
 	start.tv_usec 	=end.tv_usec;
 	iterations++;
 /*	XDestroyImage(image);*/
-	for (x=0;x<3;x++)
-		printf("[%d] %f\n",x,count[x]/iterations);
-
 /*	nanosleep(&t,NULL); */
 }
 void keypress(struct s3d_evt *event)

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-09-18 18:02:57 UTC (rev 413)
+++ trunk/configure.ac	2006-09-18 18:18:03 UTC (rev 414)
@@ -1,6 +1,6 @@
 dnl Process this file with autoconf to produce a configure script.
 AC_PREREQ(2.5)
-AC_INIT([s3d], [0.1])
+AC_INIT([s3d], [0.2rc1])
 AC_CONFIG_SRCDIR(server/main.c)
 
 AC_CANONICAL_HOST

Modified: trunk/libs3d/TODO
===================================================================
--- trunk/libs3d/TODO	2006-09-18 18:02:57 UTC (rev 413)
+++ trunk/libs3d/TODO	2006-09-18 18:18:03 UTC (rev 414)
@@ -1,7 +1,4 @@
 TODO:
 - key repeation
-- texture support for 3ds
 - shmat() return (char *) -1 or NULL?! data_ctos/data_stoc should
   really not be 0x0
-- 3ds reader won't work on linux ppc, probably lots of memory leaks
-- .max, .x, .obj files

Added: trunk/libs3dw/lgpl.txt
===================================================================
--- trunk/libs3dw/lgpl.txt	2006-09-18 18:02:57 UTC (rev 413)
+++ trunk/libs3dw/lgpl.txt	2006-09-18 18:18:03 UTC (rev 414)
@@ -0,0 +1,504 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+



From nichtsnutz at mail.berlios.de  Mon Sep 18 20:19:10 2006
From: nichtsnutz at mail.berlios.de (nichtsnutz at BerliOS)
Date: Mon, 18 Sep 2006 20:19:10 +0200
Subject: [S3d-svn] r415 - trunk/apps/olsrs3d
Message-ID: <200609181819.k8IIJA7m025273@sheep.berlios.de>

Author: nichtsnutz
Date: 2006-09-18 20:19:09 +0200 (Mon, 18 Sep 2006)
New Revision: 415

Modified:
   trunk/apps/olsrs3d/search.h
Log:
change license


Modified: trunk/apps/olsrs3d/search.h
===================================================================
--- trunk/apps/olsrs3d/search.h	2006-09-18 18:18:03 UTC (rev 414)
+++ trunk/apps/olsrs3d/search.h	2006-09-18 18:19:09 UTC (rev 415)
@@ -5,19 +5,19 @@
  *
  * This file is part of the olsrs3d, an olsr topology visualizer for s3d.
  * See http://s3d.berlios.de/ for more updates.
- * 
- * s3d Widgets is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2.1 of the License, or
+ *
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
- * s3d Widgets is distributed in the hope that it will be useful,
+ *
+ * s3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- * 
- * You should have received a copy of the GNU Lesser General Public License
- * along with the s3d Widgets; if not, write to the Free Software
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 



From dotslash at mail.berlios.de  Mon Sep 18 20:24:31 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 20:24:31 +0200
Subject: [S3d-svn] r416 - in trunk: . apps/olsrs3d
Message-ID: <200609181824.k8IIOVAZ025794@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 20:24:30 +0200 (Mon, 18 Sep 2006)
New Revision: 416

Modified:
   trunk/
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/net.c
   trunk/apps/olsrs3d/olsrs3d.h
   trunk/apps/olsrs3d/process.c
   trunk/apps/olsrs3d/search.c
   trunk/apps/olsrs3d/search.h
   trunk/apps/olsrs3d/structs.h
Log:
 r1011 at balthasar:  dotslash | 2006-09-18 20:24:20 +0200
 - some more political correctness in olsrs3d copyleft headers



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1007
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1011

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-18 18:19:09 UTC (rev 415)
+++ trunk/apps/olsrs3d/main.c	2006-09-18 18:24:30 UTC (rev 416)
@@ -19,7 +19,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
+ * along with olsrs3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 

Modified: trunk/apps/olsrs3d/net.c
===================================================================
--- trunk/apps/olsrs3d/net.c	2006-09-18 18:19:09 UTC (rev 415)
+++ trunk/apps/olsrs3d/net.c	2006-09-18 18:24:30 UTC (rev 416)
@@ -19,7 +19,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
+ * along with olsrs3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 

Modified: trunk/apps/olsrs3d/olsrs3d.h
===================================================================
--- trunk/apps/olsrs3d/olsrs3d.h	2006-09-18 18:19:09 UTC (rev 415)
+++ trunk/apps/olsrs3d/olsrs3d.h	2006-09-18 18:24:30 UTC (rev 416)
@@ -19,7 +19,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
+ * along with olsrs3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 

Modified: trunk/apps/olsrs3d/process.c
===================================================================
--- trunk/apps/olsrs3d/process.c	2006-09-18 18:19:09 UTC (rev 415)
+++ trunk/apps/olsrs3d/process.c	2006-09-18 18:24:30 UTC (rev 416)
@@ -19,7 +19,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
+ * along with olsrs3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2006-09-18 18:19:09 UTC (rev 415)
+++ trunk/apps/olsrs3d/search.c	2006-09-18 18:24:30 UTC (rev 416)
@@ -6,18 +6,18 @@
  * This file is part of the olsrs3d, an olsr topology visualizer for s3d.
  * See http://s3d.berlios.de/ for more updates.
  *
- * s3d is free software; you can redistribute it and/or modify
+ * olsrs3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * s3d is distributed in the hope that it will be useful,
+ * olsrs3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
+ * along with olsrs3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 

Modified: trunk/apps/olsrs3d/search.h
===================================================================
--- trunk/apps/olsrs3d/search.h	2006-09-18 18:19:09 UTC (rev 415)
+++ trunk/apps/olsrs3d/search.h	2006-09-18 18:24:30 UTC (rev 416)
@@ -6,18 +6,18 @@
  * This file is part of the olsrs3d, an olsr topology visualizer for s3d.
  * See http://s3d.berlios.de/ for more updates.
  *
- * s3d is free software; you can redistribute it and/or modify
+ * olsrs3d is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * s3d is distributed in the hope that it will be useful,
+ * olsrs3d is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
+ * along with olsrs3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 

Modified: trunk/apps/olsrs3d/structs.h
===================================================================
--- trunk/apps/olsrs3d/structs.h	2006-09-18 18:19:09 UTC (rev 415)
+++ trunk/apps/olsrs3d/structs.h	2006-09-18 18:24:30 UTC (rev 416)
@@ -19,7 +19,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with s3d; if not, write to the Free Software
+ * along with olsrs3d; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 



From dotslash at mail.berlios.de  Mon Sep 18 21:52:01 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 21:52:01 +0200
Subject: [S3d-svn] r417 - in trunk: . Documentation example
Message-ID: <200609181952.k8IJq1dw001573@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 21:52:01 +0200 (Mon, 18 Sep 2006)
New Revision: 417

Modified:
   trunk/
   trunk/Documentation/Makefile.am
   trunk/example/Makefile.am
Log:
 r1013 at balthasar:  dotslash | 2006-09-18 21:51:53 +0200
 - manpages will be installed
 - 3dsloader -> modelloader



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1011
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1013

Modified: trunk/Documentation/Makefile.am
===================================================================
--- trunk/Documentation/Makefile.am	2006-09-18 18:24:30 UTC (rev 416)
+++ trunk/Documentation/Makefile.am	2006-09-18 19:52:01 UTC (rev 417)
@@ -3,3 +3,4 @@
 EXTRA_DIST	=  README libs3d/libs3d.docbook s3d.docbook misc.docbook libs3dw/libs3dw.docbook \
 			   bookinfo.docbook server/server.docbook introduction.docbook
 
+man_MANS = manpages/s3d.1
\ No newline at end of file

Modified: trunk/example/Makefile.am
===================================================================
--- trunk/example/Makefile.am	2006-09-18 18:24:30 UTC (rev 416)
+++ trunk/example/Makefile.am	2006-09-18 19:52:01 UTC (rev 417)
@@ -4,7 +4,7 @@
 			nichtsnutz
 bin_PROGRAMS= filebrowser modelloader
 			
-3dsloader_SOURCES=		modelloader.c
+modelloader_SOURCES=	modelloader.c
 widgets_SOURCES=		widgets.c
 filebrowser_SOURCES=	filebrowser.c
 hudtest_SOURCES=		hudtest.c



From dotslash at mail.berlios.de  Mon Sep 18 22:08:11 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 22:08:11 +0200
Subject: [S3d-svn] r418 - in trunk: . Documentation/manpages
Message-ID: <200609182008.k8IK8B3u003138@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 22:08:10 +0200 (Mon, 18 Sep 2006)
New Revision: 418

Added:
   trunk/Documentation/manpages/s3d.1
Modified:
   trunk/
Log:
 r1015 at balthasar:  dotslash | 2006-09-18 21:52:40 +0200
 - this should be automatically generated ...



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1013
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1015

Added: trunk/Documentation/manpages/s3d.1
===================================================================
--- trunk/Documentation/manpages/s3d.1	2006-09-18 19:52:01 UTC (rev 417)
+++ trunk/Documentation/manpages/s3d.1	2006-09-18 20:08:10 UTC (rev 418)
@@ -0,0 +1,44 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve at ggi-project.org>.
+.TH "S3D" "1" "16 May 2006" "" ""
+
+.SH NAME
+s3d \- network display server
+.SH SYNOPSIS
+
+\fBs3d\fR [ \fB-g|--use-glut\fR ] [ \fB-s|--use-sdl\fR ] [ \fB-r|--rc\fR ] [ \fB-n|--no-rc\fR ] [ \fB-h|-?|--help\fR ]
+
+.SH "DESCRIPTION"
+.PP
+\fBs3d(1)\fR is a network display server which can be used as 3d desktop enviroment.
+.PP
+.SH "OPTIONS"
+.PP
+This program follows the usual GNU command line syntax. A summary of 
+the options supported by \fBs3d\fR is below. 
+.TP
+\fB-h, -?, --help\fR
+Show summary of options and exit. 
+.TP
+\fB-g, --use-glut\fR
+Tells s3d to use GLUT as graphics framework system. 
+.TP
+\fB-s, --use-sdl\fR
+Tells s3d to use SDL as graphics framework system. 
+.TP
+\fB-r, --rc\fR
+Use the specified file as rc-script. By default s3d uses ~/.s3drc as
+per-user rc-script and /etc/s3drc as system-wide rc-script
+.TP
+\fB-n, --no-rc\fR
+Don't use rc-scripts even if the exist in the apropriate locations. 
+.SH "SEE ALSO"
+.PP
+s3d project page on berlios  <URL:http://s3d.berlios.de/> 
+.SH "AUTHOR"
+.PP
+This manual page was written by Timo Schneider <timo.schneider at s2004.tu-chemnitz.de> 
+for the Debian project (but may be used by others).



From dotslash at mail.berlios.de  Mon Sep 18 22:08:13 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 22:08:13 +0200
Subject: [S3d-svn] r419 - in trunk: . libs3d/libg3d
Message-ID: <200609182008.k8IK8Dc2003197@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 22:08:13 +0200 (Mon, 18 Sep 2006)
New Revision: 419

Removed:
   trunk/libs3d/libg3d/config/
Modified:
   trunk/
Log:
 r1016 at balthasar:  dotslash | 2006-09-18 22:07:37 +0200
 - remove useless dir



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1015
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1016



From dotslash at mail.berlios.de  Mon Sep 18 22:08:15 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 22:08:15 +0200
Subject: [S3d-svn] r420 - in trunk: . libs3d/libg3d/plugins/import
Message-ID: <200609182008.k8IK8FT4003252@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 22:08:15 +0200 (Mon, 18 Sep 2006)
New Revision: 420

Modified:
   trunk/
   trunk/libs3d/libg3d/plugins/import/imp_3ds.c
Log:
 r1017 at balthasar:  dotslash | 2006-09-18 22:08:06 +0200
 - stdlib.h added



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1016
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1017

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds.c	2006-09-18 20:08:13 UTC (rev 419)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds.c	2006-09-18 20:08:15 UTC (rev 420)
@@ -23,6 +23,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
+#include <stdlib.h> /* exit() */
 
 #include <g3d/types.h>
 #include <g3d/read.h>



From dotslash at mail.berlios.de  Mon Sep 18 22:11:03 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 22:11:03 +0200
Subject: [S3d-svn] r421 - in trunk: . libs3d/libg3d/plugins/import
Message-ID: <200609182011.k8IKB3DL003869@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 22:11:03 +0200 (Mon, 18 Sep 2006)
New Revision: 421

Removed:
   trunk/libs3d/libg3d/plugins/import/img_bmp.c
Modified:
   trunk/
Log:
 r1021 at balthasar:  dotslash | 2006-09-18 22:10:54 +0200
 - what is bmp doing here? remove



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1017
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1021

Deleted: trunk/libs3d/libg3d/plugins/import/img_bmp.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/img_bmp.c	2006-09-18 20:08:15 UTC (rev 420)
+++ trunk/libs3d/libg3d/plugins/import/img_bmp.c	2006-09-18 20:11:03 UTC (rev 421)
@@ -1,108 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-
-#include <g3d/types.h>
-#include <g3d/read.h>
-
-gboolean plugin_load_image(G3DContext *context, const gchar *filename,
-	G3DImage *image, gpointer user_data)
-{
-	FILE *f;
-	guint32 filesize, offset, headsize, compression;
-	guint32 x, y;
-
-	f = fopen(filename, "r");
-	if(f == NULL)
-	{
-		g_printerr("couldn't open image file '%s': %s\n", filename,
-			strerror(errno));
-		return FALSE;
-	}
-
-	/* bitmap file always starts with 'BM' */
-	if(g3d_read_int16_le(f) != ('B' | ('M' << 8)))
-	{
-		g_printerr("bitmap magic not found: image seems to be corrupt\n");
-		return FALSE;
-	}
-
-	image->name = g_strdup(filename);
-
-	filesize = g3d_read_int32_le(f);      /* file size */
-	g3d_read_int32_le(f);                 /* 2 x UINT16 reserved */
-	offset   = g3d_read_int32_le(f);      /* offset of data */
-	headsize = g3d_read_int32_le(f);      /* size of header */
-	image->width  = g3d_read_int32_le(f); /* width */
-	image->height = g3d_read_int32_le(f); /* height */
-	g3d_read_int16_le(f);                               /* num of color planes */
-	image->depth  = g3d_read_int16_le(f); /* bits per pixel */
-	compression   = g3d_read_int32_le(f); /* compression */
-	g3d_read_int32_le(f);                 /* image size */
-	g3d_read_int32_le(f);                 /* v/res (dpi) */
-	g3d_read_int32_le(f);                 /* h/res (dpi) */
-
-	fseek(f, offset, SEEK_SET);
-
-#define ALL32BIT
-#ifndef ALL32BIT /* always 32bit for now.. */
-	image->pixeldata = g_malloc0(image->width*image->height*(image->depth/8));
-#else
-	image->pixeldata = g_malloc0(image->width * image->height * 4);
-#endif
-
-	for(y=image->height-1; y>=0; y--)
-	{
-#if DEBUG > 5
-		g_printerr("| ");
-#endif
-		for(x=0; x<image->width; x++)
-		{
-			switch(image->depth)
-			{
-				case 8:
-#ifndef ALL32BIT
-					image->pixeldata[y*image->width+x] = g3d_read_int8(f);
-#else
-					image->pixeldata[(y*image->width+x)*4+0] = g3d_read_int8(f);
-					image->pixeldata[(y*image->width+x)*4+3] = 0xFF;
-#endif
-#if DEBUG > 5
-					g_printerr("%2.2X ", image->pixeldata[y*image->width+x]);
-#endif
-					break;
-				case 24:
-					image->pixeldata[(y*image->width+x)*4+0] = g3d_read_int8(f);
-					image->pixeldata[(y*image->width+x)*4+1] = g3d_read_int8(f);
-					image->pixeldata[(y*image->width+x)*4+2] = g3d_read_int8(f);
-					image->pixeldata[(y*image->width+x)*4+3] = 0xFF;
-					break;
-				default:
-					break;
-			}
-		}
-#if DEBUG > 5
-		g_printerr("\n");
-#endif
-	}
-	image->depth = 32;
-#if DEBUG > 2
-	g_printerr("bitmap successfully loaded\n");
-#endif
-
-	return TRUE;
-}
-
-gchar *plugin_description(G3DContext *context)
-{ 
-	return g_strdup(
-		"Plugin to read Windows Bitmap (.bmp) images\n"
-		"(for use as textures or height fields)\n"
-		"Author: Markus Dahms");
-}
-
-gchar **plugin_extensions(G3DContext *context)
-{
-	return g_strsplit("bmp", ":", 0);
-}
-



From dotslash at mail.berlios.de  Mon Sep 18 22:16:15 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 22:16:15 +0200
Subject: [S3d-svn] r422 - in trunk: . libs3d/libg3d/plugins/import
Message-ID: <200609182016.k8IKGFoc004367@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 22:16:12 +0200 (Mon, 18 Sep 2006)
New Revision: 422

Removed:
   trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.c
   trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.h
Modified:
   trunk/
Log:
 r1023 at balthasar:  dotslash | 2006-09-18 22:16:09 +0200
 - automatically created with (f)lex, remove



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1021
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1023

Deleted: trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.c	2006-09-18 20:11:03 UTC (rev 421)
+++ trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.c	2006-09-18 20:16:12 UTC (rev 422)
@@ -1,2713 +0,0 @@
-#line 2 "imp_vrml_v1.c"
-
-#line 4 "imp_vrml_v1.c"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 31
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-#endif /* ! C99 */
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#endif /* ! FLEXINT_H */
-
-#ifdef __cplusplus
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* An opaque pointer. */
-#ifndef YY_TYPEDEF_YY_SCANNER_T
-#define YY_TYPEDEF_YY_SCANNER_T
-typedef void* yyscan_t;
-#endif
-
-/* For convenience, these vars (plus the bison vars far below)
-   are macros in the reentrant scanner. */
-#define yyin yyg->yyin_r
-#define yyout yyg->yyout_r
-#define yyextra yyg->yyextra_r
-#define yyleng yyg->yyleng_r
-#define yytext yyg->yytext_r
-#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
-#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
-#define yy_flex_debug yyg->yy_flex_debug_r
-
-int vrml_v1_yylex_init (yyscan_t* scanner);
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yyg->yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yyg->yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE vrml_v1_yyrestart(yyin ,yyscanner )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#define YY_BUF_SIZE 16384
-#endif
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-    #define YY_LESS_LINENO(n)
-    
-/* Return all but the first "n" matched characters back to the input stream. */
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		*yy_cp = yyg->yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef unsigned int yy_size_t;
-#endif
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-    
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via vrml_v1_yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- *
- * Returns the top of the stack, or NULL.
- */
-#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
-                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
-                          : NULL)
-
-/* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
- */
-#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]
-
-void vrml_v1_yyrestart (FILE *input_file ,yyscan_t yyscanner );
-void vrml_v1_yy_switch_to_buffer (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
-YY_BUFFER_STATE vrml_v1_yy_create_buffer (FILE *file,int size ,yyscan_t yyscanner );
-void vrml_v1_yy_delete_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
-void vrml_v1_yy_flush_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
-void vrml_v1_yypush_buffer_state (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
-void vrml_v1_yypop_buffer_state (yyscan_t yyscanner );
-
-static void vrml_v1_yyensure_buffer_stack (yyscan_t yyscanner );
-static void vrml_v1_yy_load_buffer_state (yyscan_t yyscanner );
-static void vrml_v1_yy_init_buffer (YY_BUFFER_STATE b,FILE *file ,yyscan_t yyscanner );
-
-#define YY_FLUSH_BUFFER vrml_v1_yy_flush_buffer(YY_CURRENT_BUFFER ,yyscanner)
-
-YY_BUFFER_STATE vrml_v1_yy_scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner );
-YY_BUFFER_STATE vrml_v1_yy_scan_string (yyconst char *yy_str ,yyscan_t yyscanner );
-YY_BUFFER_STATE vrml_v1_yy_scan_bytes (yyconst char *bytes,int len ,yyscan_t yyscanner );
-
-void *vrml_v1_yyalloc (yy_size_t ,yyscan_t yyscanner );
-void *vrml_v1_yyrealloc (void *,yy_size_t ,yyscan_t yyscanner );
-void vrml_v1_yyfree (void * ,yyscan_t yyscanner );
-
-#define yy_new_buffer vrml_v1_yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){ \
-        vrml_v1_yyensure_buffer_stack (yyscanner); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            vrml_v1_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){\
-        vrml_v1_yyensure_buffer_stack (yyscanner); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            vrml_v1_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
-
-/* Begin user sect3 */
-
-typedef unsigned char YY_CHAR;
-
-typedef int yy_state_type;
-
-#define yytext_ptr yytext_r
-
-static yy_state_type yy_get_previous_state (yyscan_t yyscanner );
-static yy_state_type yy_try_NUL_trans (yy_state_type current_state  ,yyscan_t yyscanner);
-static int yy_get_next_buffer (yyscan_t yyscanner );
-static void yy_fatal_error (yyconst char msg[] ,yyscan_t yyscanner );
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yyg->yytext_ptr = yy_bp; \
-	yyleng = (size_t) (yy_cp - yy_bp); \
-	yyg->yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yyg->yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 32
-#define YY_END_OF_BUFFER 33
-/* This struct is not used in this scanner,
-   but its presence is necessary. */
-struct yy_trans_info
-	{
-	flex_int32_t yy_verify;
-	flex_int32_t yy_nxt;
-	};
-static yyconst flex_int16_t yy_acclist[299] =
-    {   0,
-       33,   30,   32,   31,   32,   30,   32,   15,   30,   32,
-       30,   32,16411,   30,   32,16411,   30,   32,16411,   30,
-       32,16411,   30,   32,16411,   30,   32,16411,   26,   30,
-       32,   30,   32,   30,   32,   30,   32,   30,   32,   30,
-       32,   30,   32,   30,   32,   30,   32,   28,   30,   32,
-       29,   30,   32,    1,   30,   32,   30,   32,    4,   30,
-       32,    5,   31,   32,    4,   30,   32,    4,   15,   30,
-       32,    4,   30,   32,16411,    4,   30,   32,16411,    4,
-       30,   32,16411,    4,   30,   32,16411,    4,   30,   32,
-    16411,    4,   30,   32,16411,    4,   30,   32,16411,    4,
-
-       26,   30,   32,    4,   30,   32,    4,   30,   32,    4,
-       30,   32,    4,   30,   32,    4,   30,   32,    4,   30,
-       32,    4,   30,   32,    4,   30,   32,    4,   28,   30,
-       32,    4,   29,   30,   32,    6,   30,   32,    7,   31,
-       32,    6,   30,   32,    6,   15,   30,   32,    6,   30,
-       32,16411,    6,   30,   32,16411,    6,   30,   32,16411,
-        6,   30,   32,16411,    6,   30,   32,16411,    6,   30,
-       32,16411,    6,   26,   30,   32,    6,   30,   32,    6,
-       30,   32,    6,   30,   32,    6,   30,   32,    6,   30,
-       32,    6,   30,   32,    6,   30,   32,    6,   30,   32,
-
-        6,   28,   30,   32,    6,   29,   30,   32,   15,   15,
-       15,   14,   15,16411, 8219,16411,16411,16411,16411,16411,
-        1,    3,    3,16411,16411,16411,16411,16411,16411,16411,
-    16411,16411,16411,16411,16411,16411,16411,16411,16411,16411,
-    16411,16411,    9, 8219,16411,16411,16411,16411,   25,   22,
-    16411,    9,16411,16411,16411,16411,    2,16411,16411,16411,
-    16411,16411,16411,16411,   10, 8219,16411,16411,16411,16411,
-    16411,    8, 8219,   20,16411,16411,16411,   23,   12, 8219,
-    16411,16411,16411,16411,   16,   17,   21,16411,16411,   19,
-       24,   18,   13, 8219,16411,   11, 8219,   11
-
-    } ;
-
-static yyconst flex_int16_t yy_accept[276] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    2,    4,    6,
-        8,   11,   14,   17,   20,   23,   26,   29,   32,   34,
-       36,   38,   40,   42,   44,   46,   48,   51,   54,   57,
-       59,   62,   65,   68,   72,   76,   80,   84,   88,   92,
-       96,  100,  104,  107,  110,  113,  116,  119,  122,  125,
-      128,  132,  136,  139,  142,  145,  149,  153,  157,  161,
-      165,  169,  173,  177,  180,  183,  186,  189,  192,  195,
-      198,  201,  205,  209,  210,  211,  212,  213,  214,  214,
-      214,  215,  216,  217,  218,  219,  220,  221,  221,  221,
-      221,  221,  221,  221,  221,  221,  221,  221,  222,  222,
-
-      223,  225,  226,  227,  228,  229,  230,  230,  230,  230,
-      230,  230,  230,  230,  230,  230,  230,  231,  232,  233,
-      234,  235,  236,  236,  236,  236,  236,  236,  236,  236,
-      236,  236,  236,  236,  237,  238,  239,  240,  241,  242,
-      242,  242,  242,  242,  242,  242,  242,  242,  242,  242,
-      242,  243,  243,  243,  245,  246,  247,  248,  249,  249,
-      249,  249,  249,  249,  250,  250,  251,  251,  251,  251,
-      251,  252,  253,  254,  255,  256,  257,  257,  257,  257,
-      257,  257,  257,  257,  257,  258,  259,  260,  261,  262,
-      263,  263,  263,  263,  263,  263,  263,  263,  263,  264,
-
-      265,  265,  267,  268,  269,  269,  269,  269,  269,  269,
-      269,  269,  269,  270,  271,  272,  272,  274,  274,  274,
-      274,  274,  274,  274,  275,  275,  275,  276,  277,  278,
-      278,  278,  279,  279,  279,  279,  279,  279,  279,  281,
-      282,  283,  283,  283,  283,  283,  283,  283,  284,  285,
-      285,  286,  286,  287,  287,  287,  287,  287,  288,  289,
-      290,  290,  291,  291,  292,  292,  293,  293,  295,  296,
-      296,  296,  298,  299,  299
-    } ;
-
-static yyconst flex_int32_t yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    4,    1,    1,    5,    1,    1,    1,    1,    1,
-        1,    1,    1,    6,    7,    8,    1,    9,    9,    9,
-       10,    9,    9,    9,    9,    9,    9,    1,    1,    1,
-        1,    1,    1,    1,   11,   11,   12,   11,   11,   13,
-       14,   11,   15,   11,   11,   16,   17,   11,   11,   11,
-       11,   18,   19,   20,   11,   21,   11,   11,   11,   11,
-       22,    1,   23,    1,    1,    1,   24,   25,   26,   27,
-
-       28,   29,   30,   31,   32,   30,   30,   33,   34,   35,
-       36,   37,   30,   38,   39,   40,   41,   42,   30,   43,
-       44,   30,   45,    1,   46,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst flex_int32_t yy_meta[47] =
-    {   0,
-        1,    2,    2,    3,    1,    4,    5,    5,    3,    3,
-        6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
-        6,    1,    4,    6,    6,    6,    6,    7,    6,    6,
-        6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
-        6,    6,    6,    6,    6,    1
-    } ;
-
-static yyconst flex_int16_t yy_base[278] =
-    {   0,
-        0,   42,   81,    0,  127,    0,  619,  620,  620,   39,
-      172,  173,  179,  181,  182,  180,  183,  620,  584,  581,
-      584,  581,  590,  577,   19,  574,  620,  620,  590,  183,
-      620,  620,   42,    0,  185,  187,  193,  194,  188,  206,
-      197,  620,  576,  573,  576,  573,  582,  569,   22,  566,
-      620,  620,  620,  620,   45,    0,  190,  204,  198,  209,
-      192,  217,  620,  569,  566,  569,  566,  575,  562,   26,
-      559,  620,  620,    0,    0,   51,  620,    0,   52,  205,
-      237,  620,  242,  243,  244,  251,  248,  571,  559,  565,
-      561,  552,  559,  558,  561,  564,  568,  620,  251,   56,
-
-      249,  257,  256,  264,  270,  259,  549,  538,  546,  533,
-       34,  536,  534,  542,  531,  548,  272,  266,  262,  268,
-      280,  276,  536,  536,  521,  522,  522,  527,  518,  525,
-      515,  516,  538,  296,  316,  282,  312,  319,  318,  518,
-      537,  512,  518,  517,  505,  327,  512,  513,  508,  540,
-      320,  330,  333,  620,  339,  322,  334,  336,  503,  507,
-      512,  497,  513,  620,  348,  620,  508,  510,  509,  492,
-      335,  620,  343,  341,  344,  349,  500,  482,  495,  476,
-      470,  462,  459,  437,  620,  356,  367,  354,  368,  364,
-      436,  439,  428,  435,  422,  390,  269,  249,  365,  369,
-
-      373,  620,  386,  379,  242,  230,  236,  231,  230,  401,
-      228,  168,  396,  383,  393,  394,  620,  163,  413,  157,
-      157,   53,  423,  620,   46,   52,  403,  415,  404,   39,
-      440,  620,   38,   38,   45,   35,   26,  416,  620,  418,
-      432,  448,  451,   31,   25,   29,  454,  426,  436,  476,
-      620,  480,  620,  483,  486,  489,  492,  620,  455,  465,
-      513,  620,  516,  620,  519,  620,  461,  620,  522,  525,
-      528,  620,  620,  620,  571,  577,  580
-    } ;
-
-static yyconst flex_int16_t yy_def[278] =
-    {   0,
-      274,    1,  274,    3,  274,    5,  274,  274,  274,  274,
-      274,  275,  275,  275,  275,  275,  275,  274,  274,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-      274,  274,  274,   11,  275,  275,  275,  275,  275,  275,
-      275,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,   11,  275,  275,  275,  275,
-      275,  275,  274,  274,  274,  274,  274,  274,  274,  274,
-      274,  274,  274,   11,  276,   11,  274,   11,  277,  274,
-      275,  274,  275,  275,  275,  275,  275,  274,  274,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-
-      275,  275,  275,  275,  275,  275,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,  274,  275,  275,  275,  275,
-      275,  275,  274,  274,  274,  274,  274,  274,  274,  274,
-      274,  274,  274,  275,  275,  275,  275,  275,  275,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-      275,  274,  274,  274,  275,  275,  275,  275,  274,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-      275,  274,  275,  275,  275,  275,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,  275,  275,  275,  275,  275,
-      274,  274,  274,  274,  274,  274,  274,  274,  275,  275,
-
-      274,  274,  275,  275,  274,  274,  274,  274,  274,  274,
-      274,  274,  275,  275,  275,  274,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,  274,  275,  275,  275,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  275,
-      275,  274,  274,  274,  274,  274,  274,  275,  275,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  275,  275,
-      274,  274,  274,  274,  274,  274,  274,  274,  275,  274,
-      274,  274,  274,    0,  274,  274,  274
-    } ;
-
-static yyconst flex_int16_t yy_nxt[667] =
-    {   0,
-        8,    8,    9,    8,    8,    8,   10,    8,   11,   11,
-       12,   13,   12,   14,   15,   12,   16,   12,   17,   12,
-       12,    8,   18,   19,    8,   20,   21,   22,    8,    8,
-        8,    8,    8,   23,    8,    8,   24,    8,   25,   26,
-        8,    8,    8,    8,   27,   28,   29,   74,   74,   94,
-       74,   74,   94,   74,   74,   95,   94,   77,   95,   76,
-       76,  127,   95,  100,  100,  100,  256,  255,  254,  247,
-      246,  128,  245,  244,   77,  243,  242,  237,  236,  235,
-       30,   31,   31,   32,   31,   31,   31,   33,   31,   34,
-       34,   35,   36,   35,   37,   38,   35,   39,   35,   40,
-
-       35,   41,   31,   42,   43,   31,   44,   45,   46,   31,
-       31,   31,   31,   31,   47,   31,   31,   48,   31,   49,
-       50,   31,   31,   31,   31,   51,   52,   53,   53,   54,
-       53,   53,   53,   55,   53,   56,   56,   57,   58,   57,
-       59,   60,   57,   61,   57,   62,   57,   57,   53,   63,
-       64,   53,   65,   66,   67,   53,   53,   53,   53,   53,
-       68,   53,   53,   69,   53,   70,   71,   53,   53,   53,
-       53,   72,   73,   75,   75,   76,   80,   77,   76,   76,
-       78,   78,   80,   80,   80,   80,   80,   98,   80,  234,
-       80,   80,  233,   80,   77,   80,   80,   80,  230,   79,
-
-       80,   80,  226,   86,  100,  101,  101,   80,   80,   80,
-       87,   86,   80,   94,   83,   86,   85,   82,   84,   95,
-       80,   99,   83,   82,   82,   82,   82,   82,   85,   82,
-       84,   82,   82,   87,   82,   84,   82,   82,   82,   83,
-       80,   82,   82,   85,   87,   80,   80,   80,   82,   82,
-       82,   80,   80,   82,   80,   98,  100,  101,  101,   80,
-       80,   82,   80,  225,  222,   80,  221,   80,  220,   80,
-      104,   80,  219,   80,  218,   80,  212,  102,  103,   80,
-      211,   82,  122,   80,  106,   80,   82,   82,   82,   99,
-      105,  119,   82,   82,  117,   82,  118,  120,  134,   80,
-
-       82,   82,  135,   82,  136,  137,   82,  121,   82,  155,
-       82,  138,   82,  139,   82,   80,   82,  152,  152,  153,
-       82,   80,   80,   80,   82,   80,   82,  151,  165,  165,
-      165,  152,  152,  152,  152,  152,  153,   80,   80,   80,
-       82,  158,   80,  156,   80,  174,   80,   80,  166,  165,
-      165,  165,   80,  175,  171,  187,   82,  201,  186,   80,
-      154,  157,   82,   82,   82,  173,   82,   80,   80,  166,
-       80,   80,   80,  188,  172,  176,  201,  154,   82,   82,
-       82,  189,  216,   82,  190,   82,   80,   82,   82,   80,
-      200,  203,  213,   82,  214,  199,   80,  216,  202,   80,
-
-       82,  204,  223,  223,  223,  227,  238,   80,   82,   82,
-      228,   82,   82,   82,  231,  231,  231,  202,   80,  238,
-      215,   80,  224,  217,  223,  223,  223,   82,  210,   80,
-       82,  229,  241,  240,  232,   80,  209,   82,  217,   80,
-       82,  231,  231,  231,  224,  248,  208,  239,   82,  250,
-      250,  250,  252,  252,  252,  257,  257,  257,  267,   82,
-      239,  232,   82,  207,  267,  259,  206,  249,   80,  251,
-       82,  205,  253,  260,  198,  258,   82,  250,  250,  250,
-       82,  252,  252,  252,  261,  261,  261,  263,  263,  263,
-      265,  265,  265,  257,  257,  257,  197,  251,  269,  268,
-
-      196,  253,  195,  194,  262,  268,  193,  264,  192,   82,
-      266,  191,  185,  258,  261,  261,  261,  263,  263,  263,
-      265,  265,  265,  270,  270,  271,  270,  270,  270,  270,
-      270,  271,  184,  183,  262,  182,  181,  264,  180,  179,
-      266,  178,  177,  170,  169,  168,  167,  164,  163,  162,
-      161,  160,  159,  150,  149,  148,  147,  146,  145,  144,
-      143,  142,  141,  140,  133,  132,  272,  131,  130,  273,
-      129,  126,  272,   81,  125,  124,   81,   81,   75,   75,
-      123,   75,   79,   79,   79,  116,   79,  115,  114,  113,
-      112,  111,  110,  109,  108,  107,   96,   93,   92,   91,
-
-       90,   89,   88,   96,   93,   92,   91,   90,   89,   88,
-       97,   96,   93,   92,   91,   90,   89,   88,  274,    7,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,  274
-    } ;
-
-static yyconst flex_int16_t yy_chk[667] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    2,   10,   10,   25,
-       33,   33,   49,   55,   55,   25,   70,   79,   49,   76,
-       76,  111,   70,  100,  100,  100,  246,  245,  244,  237,
-      236,  111,  235,  234,   79,  233,  230,  226,  225,  222,
-        2,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
-        5,    5,    5,   11,   11,   11,   12,   11,   11,   11,
-       11,   11,   13,   16,   14,   15,   17,   30,   35,  221,
-       36,   39,  220,   57,   11,   61,   37,   38,  218,   11,
-
-       41,   59,  212,   16,   41,   41,   41,   58,   80,   40,
-       17,   39,   60,   30,   13,   61,   15,   12,   14,   30,
-       62,   30,   36,   13,   16,   14,   15,   17,   38,   35,
-       37,   36,   39,   40,   57,   59,   61,   37,   38,   58,
-       81,   41,   59,   60,   62,   83,   84,   85,   58,   80,
-       40,   87,  101,   60,   86,   99,  101,  101,  101,  103,
-      102,   62,  106,  211,  209,  119,  208,  104,  207,  118,
-       85,  120,  206,  105,  205,  117,  198,   83,   84,  122,
-      197,   81,  106,  121,   87,  136,   83,   84,   85,   99,
-       86,  104,   87,  101,  102,   86,  103,  105,  117,  134,
-
-      103,  102,  118,  106,  119,  120,  119,  105,  104,  136,
-      118,  121,  120,  122,  105,  137,  117,  135,  135,  135,
-      122,  139,  138,  151,  121,  156,  136,  134,  146,  146,
-      146,  152,  152,  152,  153,  153,  153,  157,  171,  158,
-      134,  139,  155,  137,  174,  156,  173,  175,  146,  165,
-      165,  165,  176,  157,  151,  173,  137,  188,  171,  186,
-      135,  138,  139,  138,  151,  155,  156,  190,  199,  165,
-      187,  189,  200,  174,  152,  158,  201,  153,  157,  171,
-      158,  175,  204,  155,  176,  174,  214,  173,  175,  203,
-      187,  189,  199,  176,  200,  186,  215,  216,  188,  213,
-
-      186,  190,  210,  210,  210,  213,  227,  229,  190,  199,
-      214,  187,  189,  200,  219,  219,  219,  201,  228,  238,
-      203,  240,  210,  204,  223,  223,  223,  214,  196,  248,
-      203,  215,  229,  228,  219,  241,  195,  215,  216,  249,
-      213,  231,  231,  231,  223,  240,  194,  227,  229,  242,
-      242,  242,  243,  243,  243,  247,  247,  247,  259,  228,
-      238,  231,  240,  193,  267,  248,  192,  241,  260,  242,
-      248,  191,  243,  249,  184,  247,  241,  250,  250,  250,
-      249,  252,  252,  252,  254,  254,  254,  255,  255,  255,
-      256,  256,  256,  257,  257,  257,  183,  250,  260,  259,
-
-      182,  252,  181,  180,  254,  267,  179,  255,  178,  260,
-      256,  177,  170,  257,  261,  261,  261,  263,  263,  263,
-      265,  265,  265,  269,  269,  269,  270,  270,  270,  271,
-      271,  271,  169,  168,  261,  167,  163,  263,  162,  161,
-      265,  160,  159,  150,  149,  148,  147,  145,  144,  143,
-      142,  141,  140,  133,  132,  131,  130,  129,  128,  127,
-      126,  125,  124,  123,  116,  115,  269,  114,  113,  270,
-      112,  110,  271,  275,  109,  108,  275,  275,  276,  276,
-      107,  276,  277,  277,  277,   97,  277,   96,   95,   94,
-       93,   92,   91,   90,   89,   88,   71,   69,   68,   67,
-
-       66,   65,   64,   50,   48,   47,   46,   45,   44,   43,
-       29,   26,   24,   23,   22,   21,   20,   19,    7,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,  274,  274,  274,  274,  274,
-      274,  274,  274,  274,  274,  274
-    } ;
-
-static int yy_looking_for_trail_begin = 0;
-static int yy_full_lp;
-static int *yy_full_state;
-#define YY_TRAILING_MASK 0x2000
-#define YY_TRAILING_HEAD_MASK 0x4000
-#define REJECT \
-{ \
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */ \
-yy_cp = yyg->yy_full_match; /* restore poss. backed-over text */ \
-yyg->yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \
-yyg->yy_state_ptr = yy_full_state; /* restore orig. state */ \
-yy_current_state = *yyg->yy_state_ptr; /* restore curr. state */ \
-++yyg->yy_lp; \
-goto find_rule; \
-}
-
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-#line 1 "imp_vrml_v1.l"
-/* $Id: imp_vrml_v1.l,v 1.1.2.2 2006/01/23 17:03:06 dahms Exp $ */
-/*
-    libg3d - 3D object loading library
-
-    Copyright (C) 2005, 2006  Markus Dahms <mad at automagically.de>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-
-#include <stdio.h>
-#include <string.h>
-#include <locale.h>
-#include <g3d/types.h>
-#include <g3d/material.h>
-#include <g3d/vector.h>
-#if DEBUG > 0
-#	define vrml_dump_hier(level, section) g_print("VRML: %.*s[%s]\n", \
-level * 3, "               ", section)
-#else
-#	define vrml_dump_hier(level, section) /* */
-#endif
-#define VRML_OTYPE_MAT                             0x0100
-#define VRML_OTYPE_MAT_AMBIENTCOLOR                0x0101
-#define VRML_OTYPE_MAT_DIFFUSECOLOR                0x0102
-#define VRML_OTYPE_MAT_SPECULARCOLOR               0x0103
-#define VRML_OTYPE_MAT_EMISSIVECOLOR               0x0104
-#define VRML_OTYPE_MAT_SHININESS                   0x0105
-#define VRML_OTYPE_MAT_TRANSPARENCY                0x0106
-#define VRML_OTYPE_COORD3                          0x0200
-#define VRML_OTYPE_COORD3_POINT                    0x0201
-#define VRML_OTYPE_IDXFACESET                      0x0300
-#define VRML_OTYPE_IDXFACESET_COORDIDX             0x0301
-#define VRML_OTYPE_IDXFACESET_MATIDX               0x0302
-#define VRML_OTYPE_MTRANS                          0x0400
-#define VRML_OTYPE_MTRANS_MATRIX                   0x0401
-#line 755 "imp_vrml_v1.c"
-
-#define INITIAL 0
-#define VRMLHEADER 1
-#define COMMENT 2
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-/* Holds the entire state of the reentrant scanner. */
-struct yyguts_t
-    {
-
-    /* User-defined. Not touched by flex. */
-    YY_EXTRA_TYPE yyextra_r;
-
-    /* The rest are the same as the globals declared in the non-reentrant scanner. */
-    FILE *yyin_r, *yyout_r;
-    size_t yy_buffer_stack_top; /**< index of top of stack. */
-    size_t yy_buffer_stack_max; /**< capacity of stack. */
-    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
-    char yy_hold_char;
-    int yy_n_chars;
-    int yyleng_r;
-    char *yy_c_buf_p;
-    int yy_init;
-    int yy_start;
-    int yy_did_buffer_switch_on_eof;
-    int yy_start_stack_ptr;
-    int yy_start_stack_depth;
-    int *yy_start_stack;
-    yy_state_type yy_last_accepting_state;
-    char* yy_last_accepting_cpos;
-
-    int yylineno_r;
-    int yy_flex_debug_r;
-
-    yy_state_type *yy_state_buf;
-    yy_state_type *yy_state_ptr;
-    char *yy_full_match;
-    int yy_lp;
-
-    char *yytext_r;
-    int yy_more_flag;
-    int yy_more_len;
-
-    }; /* end struct yyguts_t */
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int vrml_v1_yylex_destroy (yyscan_t yyscanner );
-
-int vrml_v1_yyget_debug (yyscan_t yyscanner );
-
-void vrml_v1_yyset_debug (int debug_flag ,yyscan_t yyscanner );
-
-YY_EXTRA_TYPE vrml_v1_yyget_extra (yyscan_t yyscanner );
-
-void vrml_v1_yyset_extra (YY_EXTRA_TYPE user_defined ,yyscan_t yyscanner );
-
-FILE *vrml_v1_yyget_in (yyscan_t yyscanner );
-
-void vrml_v1_yyset_in  (FILE * in_str ,yyscan_t yyscanner );
-
-FILE *vrml_v1_yyget_out (yyscan_t yyscanner );
-
-void vrml_v1_yyset_out  (FILE * out_str ,yyscan_t yyscanner );
-
-int vrml_v1_yyget_leng (yyscan_t yyscanner );
-
-char *vrml_v1_yyget_text (yyscan_t yyscanner );
-
-int vrml_v1_yyget_lineno (yyscan_t yyscanner );
-
-void vrml_v1_yyset_lineno (int line_number ,yyscan_t yyscanner );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int vrml_v1_yywrap (yyscan_t yyscanner );
-#else
-extern int vrml_v1_yywrap (yyscan_t yyscanner );
-#endif
-#endif
-
-    static void yyunput (int c,char *buf_ptr  ,yyscan_t yyscanner);
-    
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char *,yyconst char *,int ,yyscan_t yyscanner);
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * ,yyscan_t yyscanner);
-#endif
-
-#ifndef YY_NO_INPUT
-
-#ifdef __cplusplus
-static int yyinput (yyscan_t yyscanner );
-#else
-static int input (yyscan_t yyscanner );
-#endif
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		size_t n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
-\
-
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg , yyscanner)
-#endif
-
-/* end tables serialization structures and prototypes */
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int vrml_v1_yylex (yyscan_t yyscanner);
-
-#define YY_DECL int vrml_v1_yylex (yyscan_t yyscanner)
-#endif /* !YY_DECL */
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	if ( yyleng > 0 ) \
-		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
-				(yytext[yyleng - 1] == '\n'); \
-	YY_USER_ACTION
-
-/** The main scanner function which does all the work.
- */
-YY_DECL
-{
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-#line 62 "imp_vrml_v1.l"
-
-	G3DObject *object = NULL;
-	G3DFace *face;
-	G3DMaterial *material = NULL;
-	guint32 level = 0, off, otype = 0, sep_level = 0;
-	guint32 ohasmtrx = 0;
-	guint32 faceidx = 0, faceidxbuf[128];
-	guint32 matidx = 0;
-	gint32 tmps32, i;
-	gfloat matrix[16];
-
-#line 992 "imp_vrml_v1.c"
-
-	if ( yyg->yy_init )
-		{
-		yyg->yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-        if ( ! yyg->yy_state_buf )
-            yyg->yy_state_buf = (yy_state_type *)vrml_v1_yyalloc(((YY_BUF_SIZE + 2) * sizeof(yy_state_type))  ,yyscanner);
-
-		if ( ! yyg->yy_start )
-			yyg->yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			vrml_v1_yyensure_buffer_stack (yyscanner);
-			YY_CURRENT_BUFFER_LVALUE =
-				vrml_v1_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
-		}
-
-		vrml_v1_yy_load_buffer_state(yyscanner );
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yyg->yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yyg->yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yyg->yy_start;
-		yy_current_state += YY_AT_BOL();
-
-		yyg->yy_state_ptr = yyg->yy_state_buf;
-		*yyg->yy_state_ptr++ = yy_current_state;
-
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 275 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			*yyg->yy_state_ptr++ = yy_current_state;
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 620 );
-
-yy_find_action:
-		yy_current_state = *--yyg->yy_state_ptr;
-		yyg->yy_lp = yy_accept[yy_current_state];
-find_rule: /* we branch to this label when backing up */
-		for ( ; ; ) /* until we find what rule we matched */
-			{
-			if ( yyg->yy_lp && yyg->yy_lp < yy_accept[yy_current_state + 1] )
-				{
-				yy_act = yy_acclist[yyg->yy_lp];
-				if ( yy_act & YY_TRAILING_HEAD_MASK ||
-				     yy_looking_for_trail_begin )
-					{
-					if ( yy_act == yy_looking_for_trail_begin )
-						{
-						yy_looking_for_trail_begin = 0;
-						yy_act &= ~YY_TRAILING_HEAD_MASK;
-						break;
-						}
-					}
-				else if ( yy_act & YY_TRAILING_MASK )
-					{
-					yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;
-					yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;
-					}
-				else
-					{
-					yyg->yy_full_match = yy_cp;
-					yy_full_state = yyg->yy_state_ptr;
-					yy_full_lp = yyg->yy_lp;
-					break;
-					}
-				++yyg->yy_lp;
-				goto find_rule;
-				}
-			--yy_cp;
-			yy_current_state = *--yyg->yy_state_ptr;
-			yyg->yy_lp = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-do_action:	/* This label is used only to access EOF actions. */
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-case 1:
-YY_RULE_SETUP
-#line 73 "imp_vrml_v1.l"
-{
-	#if DEBUG > 0
-	g_print("VRML: comment:");
-	#endif
-	BEGIN COMMENT;
-}
-	YY_BREAK
-case 2:
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 5;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 80 "imp_vrml_v1.l"
-{
-	/* magic header */
-	#if DEBUG > 0
-	g_print("VRML: got header\n");
-	#endif
-	BEGIN VRMLHEADER;
-}
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 88 "imp_vrml_v1.l"
-{
-	#if DEBUG > 0
-	g_print("VRML: version %s\n", yytext + 1);
-	#endif
-}
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 94 "imp_vrml_v1.l"
-/* */
-	YY_BREAK
-case 5:
-/* rule 5 can match eol */
-YY_RULE_SETUP
-#line 96 "imp_vrml_v1.l"
-{
-	BEGIN INITIAL;
-}
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 100 "imp_vrml_v1.l"
-{
-	#if DEBUG > 0
-	g_print("%s", yytext);
-	#endif
-}
-	YY_BREAK
-case 7:
-/* rule 7 can match eol */
-YY_RULE_SETUP
-#line 106 "imp_vrml_v1.l"
-{
-	#if DEBUG > 0
-	g_print("\n");
-	#endif
-	BEGIN INITIAL;
-}
-	YY_BREAK
-case 8:
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 9;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 113 "imp_vrml_v1.l"
-{
-	vrml_dump_hier(level, "Separator");
-	if((object == NULL) || (object->vertex_count == 0))
-	{
-		object = g_new0(G3DObject, 1);
-		((G3DModel *)yyextra)->objects = g_slist_append(
-			((G3DModel *)yyextra)->objects, object);
-		sep_level = level;
-		ohasmtrx = 0;
-	}
-}
-	YY_BREAK
-case 9:
-/* rule 9 can match eol */
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 5;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 125 "imp_vrml_v1.l"
-{
-	vrml_dump_hier(level, "Group");
-}
-	YY_BREAK
-case 10:
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 8;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 129 "imp_vrml_v1.l"
-{
-	vrml_dump_hier(level, "Material");
-	if(object)
-	{
-		material = g3d_material_new();
-		material->name = g_strdup("object material");
-		object->materials = g_slist_append(object->materials, material);
-	}
-	otype = VRML_OTYPE_MAT;
-}
-	YY_BREAK
-case 11:
-/* rule 11 can match eol */
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 15;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 140 "imp_vrml_v1.l"
-{
-	vrml_dump_hier(level, "MatrixTransform");
-	otype = VRML_OTYPE_MTRANS;
-}
-	YY_BREAK
-case 12:
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 11;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 145 "imp_vrml_v1.l"
-{
-	vrml_dump_hier(level, "Coordinate3");
-	if(!object)
-	{
-		object = g_new0(G3DObject, 1);
-		object->name = g_strdup("VRML 1 object");
-		((G3DModel *)yyextra)->objects = g_slist_append(
-			((G3DModel *)yyextra)->objects, object);
-		ohasmtrx = 0;
-	}
-	otype = VRML_OTYPE_COORD3;
-}
-	YY_BREAK
-case 13:
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 14;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 158 "imp_vrml_v1.l"
-{
-	vrml_dump_hier(level, "IndexedFaceSet");
-	otype = VRML_OTYPE_IDXFACESET;
-}
-	YY_BREAK
-case 14:
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 163 "imp_vrml_v1.l"
-{
-	#if DEBUG > 3
-	g_print("# (0x%04x) %s\n", otype, yytext);
-	#endif
-	if((otype & 0xFF00) == VRML_OTYPE_MAT)
-	{
-		if(object == NULL) continue;
-		material = g_slist_nth_data(object->materials, matidx);
-		if(material == NULL)
-		{
-			material = g3d_material_new();
-			material->name = g_strdup_printf("material #%d", matidx);
-			object->materials = g_slist_append(object->materials, material);
-		}
-		matidx ++;
-		switch(otype)
-		{
-			case VRML_OTYPE_MAT_DIFFUSECOLOR:
-				if(sscanf(yytext, "%f%f%f",
-					&(material->r), &(material->g), &(material->b)) != 3)
-				{
-		#if DEBUG > 0
-					g_print("VRML1: failed to get ambient color");
-		#endif
-				}
-				break;
-
-			default:
-	#if DEBUG > 0
-				g_print("VRML: unhandled material property: 0x%02x (%s)\n",
-					otype, yytext);
-	#endif
-				break;
-		}
-	}
-	else if(otype == VRML_OTYPE_COORD3_POINT)
-	{
-		off = object->vertex_count;
-		object->vertex_count ++;
-		object->vertex_data = g_realloc(object->vertex_data,
-			object->vertex_count * 3 * sizeof(gfloat));
-
-	#if DEBUG > 3
-		g_print("VRML: object vertex count: %d\n", object->vertex_count);
-	#endif
-
-		if(sscanf(yytext, "%f%f%f",
-			&(object->vertex_data[off * 3 + 0]),
-			&(object->vertex_data[off * 3 + 1]),
-			&(object->vertex_data[off * 3 + 2])) != 3)
-		{
-			g_warning("VRML: failed to read vertex (%s)\n", yytext);
-		}
-		else
-		{
-	#if DEBUG > 3
-			if((object->vertex_data[off * 3 + 0] == 0.0) ||
-				(object->vertex_data[off * 3 + 1] == 0.0) ||
-				(object->vertex_data[off * 3 + 2] == 0.0))
-			{
-				g_print("VRML1: 0.0: %+2.2f %+2.2f %+2.2f (%s)\n",
-					object->vertex_data[off * 3 + 0],
-					object->vertex_data[off * 3 + 1],
-					object->vertex_data[off * 3 + 2],
-					yytext);
-			}
-	#endif
-			if(ohasmtrx)
-				g3d_vector_transform(
-					&(object->vertex_data[off * 3 + 0]),
-					&(object->vertex_data[off * 3 + 1]),
-					&(object->vertex_data[off * 3 + 2]),
-					matrix);
-		}
-	}
-	else if(otype == VRML_OTYPE_IDXFACESET_COORDIDX)
-	{
-		sscanf(yytext, "%i", &tmps32);
-		if(tmps32 == -1)
-		{
-			if(object == NULL) continue;
-
-			face = g_new0(G3DFace, 1);
-			face->material = material;
-			if(face->material == NULL)
-				face->material = g_slist_nth_data(
-					object->materials, 0);
-			if(face->material == NULL)
-				face->material = g_slist_nth_data(
-					((G3DModel *)yyextra)->materials, 0);
-			face->vertex_count = faceidx;
-			face->vertex_indices = g_new0(guint32, face->vertex_count);
-			for(i = 0; i < face->vertex_count; i ++)
-			{
-				if(faceidxbuf[i] >= object->vertex_count)
-				{
-					g_print("VRML: Face: index %d >= vertex count (%d)\n",
-						faceidxbuf[i], object->vertex_count);
-				}
-				else
-				{
-					face->vertex_indices[i] = faceidxbuf[i];
-				}
-			}
-
-			if(face->vertex_count >= 3)
-				object->faces = g_slist_prepend(object->faces, face);
-			faceidx = 0;
-		}
-		else
-		{
-	#if DEBUG > 3
-			if(tmps32 == 0)
-				g_print("VRML1: faceidx 0: %s\n", yytext);
-	#endif
-			faceidxbuf[faceidx] = tmps32;
-			faceidx ++;
-		}
-	}
-	else if(otype == VRML_OTYPE_IDXFACESET_MATIDX)
-	{
-		i = atoi(yytext);
-	#if DEBUG > 3
-		g_print("VRML1: looking for object material #%d\n", i);
-	#endif
-		material = g_slist_nth_data(object->materials, i);
-		if(material)
-		{
-	#if DEBUG > 3
-			g_print("VRML1: got material to update\n");
-	#endif
-			face = g_slist_nth_data(object->faces, faceidx);
-			if(face)
-			{
-				face->material = material;
-	#if DEBUG > 1
-				g_print("VRML1: updating material of face #%d\n", faceidx);
-	#endif
-			}
-		}
-		faceidx ++;
-	}
-}
-	YY_BREAK
-case 15:
-/* rule 15 can match eol */
-YY_RULE_SETUP
-#line 307 "imp_vrml_v1.l"
-{
-	if(otype == VRML_OTYPE_MTRANS_MATRIX)
-	{
-		if(sscanf(yytext, "%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f%f",
-			&matrix[0 * 4 + 0],
-			&matrix[1 * 4 + 0],
-			&matrix[2 * 4 + 0],
-			&matrix[3 * 4 + 0],
-
-			&matrix[0 * 4 + 1],
-            &matrix[1 * 4 + 1],
-            &matrix[2 * 4 + 1],
-            &matrix[3 * 4 + 1],
-
-			&matrix[0 * 4 + 2],
-            &matrix[1 * 4 + 2],
-            &matrix[2 * 4 + 2],
-            &matrix[3 * 4 + 2],
-
-			&matrix[0 * 4 + 3],
-            &matrix[1 * 4 + 3],
-            &matrix[2 * 4 + 3],
-            &matrix[3 * 4 + 3]) != 16)
-		{
-			g_warning("VRML: failed to read matrix line (%s)", yytext);
-		}
-	}
-}
-	YY_BREAK
-case 16:
-/* rule 16 can match eol */
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 12;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 336 "imp_vrml_v1.l"
-{
-	otype = VRML_OTYPE_MAT_AMBIENTCOLOR;
-}
-	YY_BREAK
-case 17:
-/* rule 17 can match eol */
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 12;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 340 "imp_vrml_v1.l"
-{
-	otype = VRML_OTYPE_MAT_DIFFUSECOLOR;
-}
-	YY_BREAK
-case 18:
-/* rule 18 can match eol */
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 13;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 344 "imp_vrml_v1.l"
-{
-	otype = VRML_OTYPE_MAT_SPECULARCOLOR;
-}
-	YY_BREAK
-case 19:
-/* rule 19 can match eol */
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 13;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 348 "imp_vrml_v1.l"
-{
-	otype = VRML_OTYPE_MAT_EMISSIVECOLOR;
-}
-	YY_BREAK
-case 20:
-/* rule 20 can match eol */
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 9;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 352 "imp_vrml_v1.l"
-{
-	otype = VRML_OTYPE_MAT_SHININESS;
-}
-	YY_BREAK
-case 21:
-/* rule 21 can match eol */
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 12;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 356 "imp_vrml_v1.l"
-{
-	otype = VRML_OTYPE_MAT_TRANSPARENCY;
-}
-	YY_BREAK
-case 22:
-/* rule 22 can match eol */
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 5;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 360 "imp_vrml_v1.l"
-{
-	otype = VRML_OTYPE_COORD3_POINT;
-}
-	YY_BREAK
-case 23:
-/* rule 23 can match eol */
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 10;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 364 "imp_vrml_v1.l"
-{
-	if(otype == VRML_OTYPE_IDXFACESET)
-		otype = VRML_OTYPE_IDXFACESET_COORDIDX;
-}
-	YY_BREAK
-case 24:
-/* rule 24 can match eol */
-*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
-yyg->yy_c_buf_p = yy_cp = yy_bp + 13;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 369 "imp_vrml_v1.l"
-{
-	#if DEBUG > 0
-	g_print("VRML1: materialIndex\n");
-	#endif
-	/*if(otype == VRML_OTYPE_IDXFACESET)*/
-		otype = VRML_OTYPE_IDXFACESET_MATIDX;
-}
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 377 "imp_vrml_v1.l"
-{
-	if(otype == VRML_OTYPE_MTRANS)
-	{
-		otype = VRML_OTYPE_MTRANS_MATRIX;
-		ohasmtrx = 1;
-	}
-}
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 385 "imp_vrml_v1.l"
-{
-	/* set to parent object */
-	otype &= 0xFF00;
-	matidx = 0;
-	faceidx = 0;
-}
-	YY_BREAK
-case 27:
-YY_RULE_SETUP
-#line 392 "imp_vrml_v1.l"
-{
-	vrml_dump_hier(level, yytext);
-}
-	YY_BREAK
-case 28:
-YY_RULE_SETUP
-#line 396 "imp_vrml_v1.l"
-{
-	level ++;
-}
-	YY_BREAK
-case 29:
-YY_RULE_SETUP
-#line 400 "imp_vrml_v1.l"
-{
-	#if DEBUG > 3
-	g_print("}\n");
-	#endif
-	level --;
-
-	if(material)
-		material = NULL;
-
-	if(object && (sep_level == level))
-	{
-		object = NULL;
-	}
-
-	/* reset object type */
-	otype = 0x0000;
-}
-	YY_BREAK
-case 30:
-YY_RULE_SETUP
-#line 418 "imp_vrml_v1.l"
-/* */
-	YY_BREAK
-case 31:
-/* rule 31 can match eol */
-YY_RULE_SETUP
-#line 419 "imp_vrml_v1.l"
-/* */
-	YY_BREAK
-case YY_STATE_EOF(INITIAL):
-case YY_STATE_EOF(VRMLHEADER):
-case YY_STATE_EOF(COMMENT):
-#line 421 "imp_vrml_v1.l"
-{
-	yyterminate();
-}
-	YY_BREAK
-case 32:
-YY_RULE_SETUP
-#line 425 "imp_vrml_v1.l"
-YY_FATAL_ERROR( "flex scanner jammed" );
-	YY_BREAK
-#line 1623 "imp_vrml_v1.c"
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yyg->yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * vrml_v1_yylex().  If so, then we have to assure
-			 * consistency between YY_CURRENT_BUFFER and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state( yyscanner );
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);
-
-			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yyg->yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yyg->yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer( yyscanner ) )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yyg->yy_did_buffer_switch_on_eof = 0;
-
-				if ( vrml_v1_yywrap(yyscanner ) )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yyg->yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yyg->yy_c_buf_p =
-					yyg->yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state( yyscanner );
-
-				yy_cp = yyg->yy_c_buf_p;
-				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yyg->yy_c_buf_p =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];
-
-				yy_current_state = yy_get_previous_state( yyscanner );
-
-				yy_cp = yyg->yy_c_buf_p;
-				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-} /* end of vrml_v1_yylex */
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-static int yy_get_next_buffer (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	register char *source = yyg->yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;
-
-	else
-		{
-			size_t num_to_read =
-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			yyg->yy_n_chars, num_to_read );
-
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
-		}
-
-	if ( yyg->yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			vrml_v1_yyrestart(yyin  ,yyscanner);
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yyg->yy_n_chars += number_to_move;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
-
-	return ret_val;
-}
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
-{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	yy_current_state = yyg->yy_start;
-	yy_current_state += YY_AT_BOL();
-
-	yyg->yy_state_ptr = yyg->yy_state_buf;
-	*yyg->yy_state_ptr++ = yy_current_state;
-
-	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 275 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		*yyg->yy_state_ptr++ = yy_current_state;
-		}
-
-	return yy_current_state;
-}
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
-{
-	register int yy_is_jam;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	register YY_CHAR yy_c = 1;
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 275 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 274);
-	if ( ! yy_is_jam )
-		*yyg->yy_state_ptr++ = yy_current_state;
-
-	return yy_is_jam ? 0 : yy_current_state;
-}
-
-    static void yyunput (int c, register char * yy_bp , yyscan_t yyscanner)
-{
-	register char *yy_cp;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-    yy_cp = yyg->yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yyg->yy_hold_char;
-
-	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yyg->yy_n_chars + 2;
-		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
-					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
-		register char *source =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
-
-		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
-			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
-
-		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-	yyg->yytext_ptr = yy_bp;
-	yyg->yy_hold_char = *yy_cp;
-	yyg->yy_c_buf_p = yy_cp;
-}
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (yyscan_t yyscanner)
-#else
-    static int input  (yyscan_t yyscanner)
-#endif
-
-{
-	int c;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	*yyg->yy_c_buf_p = yyg->yy_hold_char;
-
-	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
-			/* This was really a NUL. */
-			*yyg->yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yyg->yy_c_buf_p - yyg->yytext_ptr;
-			++yyg->yy_c_buf_p;
-
-			switch ( yy_get_next_buffer( yyscanner ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					vrml_v1_yyrestart(yyin ,yyscanner);
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( vrml_v1_yywrap(yyscanner ) )
-						return EOF;
-
-					if ( ! yyg->yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput(yyscanner);
-#else
-					return input(yyscanner);
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
-	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
-	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
-
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
-
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
-
-/** Immediately switch to a different input stream.
- * @param input_file A readable stream.
- * @param yyscanner The scanner object.
- * @note This function does not reset the start condition to @c INITIAL .
- */
-    void vrml_v1_yyrestart  (FILE * input_file , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	if ( ! YY_CURRENT_BUFFER ){
-        vrml_v1_yyensure_buffer_stack (yyscanner);
-		YY_CURRENT_BUFFER_LVALUE =
-            vrml_v1_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
-	}
-
-	vrml_v1_yy_init_buffer(YY_CURRENT_BUFFER,input_file ,yyscanner);
-	vrml_v1_yy_load_buffer_state(yyscanner );
-}
-
-/** Switch to a different input buffer.
- * @param new_buffer The new input buffer.
- * @param yyscanner The scanner object.
- */
-    void vrml_v1_yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	/* TODO. We should be able to replace this entire function body
-	 * with
-	 *		vrml_v1_yypop_buffer_state();
-	 *		vrml_v1_yypush_buffer_state(new_buffer);
-     */
-	vrml_v1_yyensure_buffer_stack (yyscanner);
-	if ( YY_CURRENT_BUFFER == new_buffer )
-		return;
-
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*yyg->yy_c_buf_p = yyg->yy_hold_char;
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
-		}
-
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	vrml_v1_yy_load_buffer_state(yyscanner );
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (vrml_v1_yywrap()) processing, but the only time this flag
-	 * is looked at is after vrml_v1_yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yyg->yy_did_buffer_switch_on_eof = 1;
-}
-
-static void vrml_v1_yy_load_buffer_state  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-	yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
-	yyg->yy_hold_char = *yyg->yy_c_buf_p;
-}
-
-/** Allocate and initialize an input buffer state.
- * @param file A readable stream.
- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * @param yyscanner The scanner object.
- * @return the allocated buffer state.
- */
-    YY_BUFFER_STATE vrml_v1_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
-{
-	YY_BUFFER_STATE b;
-    
-	b = (YY_BUFFER_STATE) vrml_v1_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in vrml_v1_yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) vrml_v1_yyalloc(b->yy_buf_size + 2 ,yyscanner );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in vrml_v1_yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	vrml_v1_yy_init_buffer(b,file ,yyscanner);
-
-	return b;
-}
-
-/** Destroy the buffer.
- * @param b a buffer created with vrml_v1_yy_create_buffer()
- * @param yyscanner The scanner object.
- */
-    void vrml_v1_yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	if ( ! b )
-		return;
-
-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		vrml_v1_yyfree((void *) b->yy_ch_buf ,yyscanner );
-
-	vrml_v1_yyfree((void *) b ,yyscanner );
-}
-
-#ifndef __cplusplus
-extern int isatty (int );
-#endif /* __cplusplus */
-    
-/* Initializes or reinitializes a buffer.
- * This function is sometimes called more than once on the same buffer,
- * such as during a vrml_v1_yyrestart() or at EOF.
- */
-    static void vrml_v1_yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)
-
-{
-	int oerrno = errno;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	vrml_v1_yy_flush_buffer(b ,yyscanner);
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-    /* If b is the current buffer, then vrml_v1_yy_init_buffer was _probably_
-     * called from vrml_v1_yyrestart() or through yy_get_next_buffer.
-     * In that case, we don't want to reset the lineno or column.
-     */
-    if (b != YY_CURRENT_BUFFER){
-        b->yy_bs_lineno = 1;
-        b->yy_bs_column = 0;
-    }
-
-        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-    
-	errno = oerrno;
-}
-
-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * @param yyscanner The scanner object.
- */
-    void vrml_v1_yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == YY_CURRENT_BUFFER )
-		vrml_v1_yy_load_buffer_state(yyscanner );
-}
-
-/** Pushes the new state onto the stack. The new state becomes
- *  the current state. This function will allocate the stack
- *  if necessary.
- *  @param new_buffer The new state.
- *  @param yyscanner The scanner object.
- */
-void vrml_v1_yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	if (new_buffer == NULL)
-		return;
-
-	vrml_v1_yyensure_buffer_stack(yyscanner);
-
-	/* This block is copied from vrml_v1_yy_switch_to_buffer. */
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*yyg->yy_c_buf_p = yyg->yy_hold_char;
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
-		}
-
-	/* Only push if top exists. Otherwise, replace top. */
-	if (YY_CURRENT_BUFFER)
-		yyg->yy_buffer_stack_top++;
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-
-	/* copied from vrml_v1_yy_switch_to_buffer. */
-	vrml_v1_yy_load_buffer_state(yyscanner );
-	yyg->yy_did_buffer_switch_on_eof = 1;
-}
-
-/** Removes and deletes the top of the stack, if present.
- *  The next element becomes the new top.
- *  @param yyscanner The scanner object.
- */
-void vrml_v1_yypop_buffer_state (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	if (!YY_CURRENT_BUFFER)
-		return;
-
-	vrml_v1_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
-	YY_CURRENT_BUFFER_LVALUE = NULL;
-	if (yyg->yy_buffer_stack_top > 0)
-		--yyg->yy_buffer_stack_top;
-
-	if (YY_CURRENT_BUFFER) {
-		vrml_v1_yy_load_buffer_state(yyscanner );
-		yyg->yy_did_buffer_switch_on_eof = 1;
-	}
-}
-
-/* Allocates the stack if it does not exist.
- *  Guarantees space for at least one push.
- */
-static void vrml_v1_yyensure_buffer_stack (yyscan_t yyscanner)
-{
-	int num_to_alloc;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-	if (!yyg->yy_buffer_stack) {
-
-		/* First allocation is just for 2 elements, since we don't know if this
-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
-		 * immediate realloc on the next call.
-         */
-		num_to_alloc = 1;
-		yyg->yy_buffer_stack = (struct yy_buffer_state**)vrml_v1_yyalloc
-								(num_to_alloc * sizeof(struct yy_buffer_state*)
-								, yyscanner);
-		
-		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
-		yyg->yy_buffer_stack_max = num_to_alloc;
-		yyg->yy_buffer_stack_top = 0;
-		return;
-	}
-
-	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){
-
-		/* Increase the buffer to prepare for a possible push. */
-		int grow_size = 8 /* arbitrary grow size */;
-
-		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
-		yyg->yy_buffer_stack = (struct yy_buffer_state**)vrml_v1_yyrealloc
-								(yyg->yy_buffer_stack,
-								num_to_alloc * sizeof(struct yy_buffer_state*)
-								, yyscanner);
-
-		/* zero only the new slots.*/
-		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
-		yyg->yy_buffer_stack_max = num_to_alloc;
-	}
-}
-
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object. 
- */
-YY_BUFFER_STATE vrml_v1_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
-{
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) vrml_v1_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in vrml_v1_yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	vrml_v1_yy_switch_to_buffer(b ,yyscanner );
-
-	return b;
-}
-
-/** Setup the input buffer state to scan a string. The next call to vrml_v1_yylex() will
- * scan from a @e copy of @a str.
- * @param str a NUL-terminated string to scan
- * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       vrml_v1_yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE vrml_v1_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)
-{
-    
-	return vrml_v1_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);
-}
-
-/** Setup the input buffer state to scan the given bytes. The next call to vrml_v1_yylex() will
- * scan from a @e copy of @a bytes.
- * @param bytes the byte buffer to scan
- * @param len the number of bytes in the buffer pointed to by @a bytes.
- * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE vrml_v1_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
-{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) vrml_v1_yyalloc(n ,yyscanner );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in vrml_v1_yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = vrml_v1_yy_scan_buffer(buf,n ,yyscanner);
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in vrml_v1_yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-}
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
-{
-    	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-}
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		yytext[yyleng] = yyg->yy_hold_char; \
-		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
-		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
-		*yyg->yy_c_buf_p = '\0'; \
-		yyleng = yyless_macro_arg; \
-		} \
-	while ( 0 )
-
-/* Accessor  methods (get/set functions) to struct members. */
-
-/** Get the user-defined data for this scanner.
- * @param yyscanner The scanner object.
- */
-YY_EXTRA_TYPE vrml_v1_yyget_extra  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yyextra;
-}
-
-/** Get the current line number.
- * @param yyscanner The scanner object.
- */
-int vrml_v1_yyget_lineno  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
-        if (! YY_CURRENT_BUFFER)
-            return 0;
-    
-    return yylineno;
-}
-
-/** Get the current column number.
- * @param yyscanner The scanner object.
- */
-int vrml_v1_yyget_column  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    
-        if (! YY_CURRENT_BUFFER)
-            return 0;
-    
-    return yycolumn;
-}
-
-/** Get the input stream.
- * @param yyscanner The scanner object.
- */
-FILE *vrml_v1_yyget_in  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yyin;
-}
-
-/** Get the output stream.
- * @param yyscanner The scanner object.
- */
-FILE *vrml_v1_yyget_out  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yyout;
-}
-
-/** Get the length of the current token.
- * @param yyscanner The scanner object.
- */
-int vrml_v1_yyget_leng  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yyleng;
-}
-
-/** Get the current token.
- * @param yyscanner The scanner object.
- */
-
-char *vrml_v1_yyget_text  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yytext;
-}
-
-/** Set the user-defined data. This data is never touched by the scanner.
- * @param user_defined The data to be associated with this scanner.
- * @param yyscanner The scanner object.
- */
-void vrml_v1_yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yyextra = user_defined ;
-}
-
-/** Set the current line number.
- * @param line_number
- * @param yyscanner The scanner object.
- */
-void vrml_v1_yyset_lineno (int  line_number , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-        /* lineno is only valid if an input buffer exists. */
-        if (! YY_CURRENT_BUFFER )
-           yy_fatal_error( "vrml_v1_yyset_lineno called with no buffer" , yyscanner); 
-    
-    yylineno = line_number;
-}
-
-/** Set the current column.
- * @param line_number
- * @param yyscanner The scanner object.
- */
-void vrml_v1_yyset_column (int  column_no , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-        /* column is only valid if an input buffer exists. */
-        if (! YY_CURRENT_BUFFER )
-           yy_fatal_error( "vrml_v1_yyset_column called with no buffer" , yyscanner); 
-    
-    yycolumn = column_no;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param in_str A readable stream.
- * @param yyscanner The scanner object.
- * @see vrml_v1_yy_switch_to_buffer
- */
-void vrml_v1_yyset_in (FILE *  in_str , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yyin = in_str ;
-}
-
-void vrml_v1_yyset_out (FILE *  out_str , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yyout = out_str ;
-}
-
-int vrml_v1_yyget_debug  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    return yy_flex_debug;
-}
-
-void vrml_v1_yyset_debug (int  bdebug , yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yy_flex_debug = bdebug ;
-}
-
-/* Accessor methods for yylval and yylloc */
-
-static int yy_init_globals (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    /* Initialization is the same as for the non-reentrant scanner.
-       This function is called once per scanner lifetime. */
-
-    yyg->yy_buffer_stack = 0;
-    yyg->yy_buffer_stack_top = 0;
-    yyg->yy_buffer_stack_max = 0;
-    yyg->yy_c_buf_p = (char *) 0;
-    yyg->yy_init = 1;
-    yyg->yy_start = 0;
-    yyg->yy_start_stack_ptr = 0;
-    yyg->yy_start_stack_depth = 0;
-    yyg->yy_start_stack = (int *) 0;
-
-    yyg->yy_state_buf = 0;
-    yyg->yy_state_ptr = 0;
-    yyg->yy_full_match = 0;
-    yyg->yy_lp = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = (FILE *) 0;
-    yyout = (FILE *) 0;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * vrml_v1_yylex_init()
-     */
-    return 0;
-}
-
-/* User-visible API */
-
-/* vrml_v1_yylex_init is special because it creates the scanner itself, so it is
- * the ONLY reentrant function that doesn't take the scanner as the last argument.
- * That's why we explicitly handle the declaration, instead of using our macros.
- */
-
-int vrml_v1_yylex_init(yyscan_t* ptr_yy_globals)
-
-{
-    if (ptr_yy_globals == NULL){
-        errno = EINVAL;
-        return 1;
-    }
-
-    *ptr_yy_globals = (yyscan_t) vrml_v1_yyalloc ( sizeof( struct yyguts_t ), NULL );
-
-    if (*ptr_yy_globals == NULL){
-        errno = ENOMEM;
-        return 1;
-    }
-
-    memset(*ptr_yy_globals,0,sizeof(struct yyguts_t));
-
-    return yy_init_globals ( *ptr_yy_globals );
-}
-
-/* vrml_v1_yylex_destroy is for both reentrant and non-reentrant scanners. */
-int vrml_v1_yylex_destroy  (yyscan_t yyscanner)
-{
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
-    /* Pop the buffer stack, destroying each element. */
-	while(YY_CURRENT_BUFFER){
-		vrml_v1_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
-		vrml_v1_yypop_buffer_state(yyscanner);
-	}
-
-	/* Destroy the stack itself. */
-	vrml_v1_yyfree(yyg->yy_buffer_stack ,yyscanner);
-	yyg->yy_buffer_stack = NULL;
-
-    /* Destroy the start condition stack. */
-        vrml_v1_yyfree(yyg->yy_start_stack ,yyscanner );
-        yyg->yy_start_stack = NULL;
-
-    vrml_v1_yyfree ( yyg->yy_state_buf , yyscanner);
-
-    /* Destroy the main struct (reentrant only). */
-    vrml_v1_yyfree ( yyscanner , yyscanner );
-    return 0;
-}
-
-/*
- * Internal utility routines.
- */
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
-{
-	register int i;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-}
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner)
-{
-	register int n;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-}
-#endif
-
-void *vrml_v1_yyalloc (yy_size_t  size , yyscan_t yyscanner)
-{
-	return (void *) malloc( size );
-}
-
-void *vrml_v1_yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
-{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-}
-
-void vrml_v1_yyfree (void * ptr , yyscan_t yyscanner)
-{
-	free( (char *) ptr );	/* see vrml_v1_yyrealloc() for (char *) cast */
-}
-
-#define YYTABLES_NAME "yytables"
-
-#undef YY_NEW_FILE
-#undef YY_FLUSH_BUFFER
-#undef yy_set_bol
-#undef yy_new_buffer
-#undef yy_set_interactive
-#undef yytext_ptr
-#undef YY_DO_BEFORE_ACTION
-
-#ifdef YY_DECL_IS_OURS
-#undef YY_DECL_IS_OURS
-#undef YY_DECL
-#endif
-#line 425 "imp_vrml_v1.l"
-
-
-
-

Deleted: trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.h	2006-09-18 20:11:03 UTC (rev 421)
+++ trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.h	2006-09-18 20:16:12 UTC (rev 422)
@@ -1,325 +0,0 @@
-#ifndef vrml_v1_yyHEADER_H
-#define vrml_v1_yyHEADER_H 1
-#define vrml_v1_yyIN_HEADER 1
-
-#line 6 "imp_vrml_v1.h"
-
-#line 8 "imp_vrml_v1.h"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 31
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-#endif /* ! C99 */
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#endif /* ! FLEXINT_H */
-
-#ifdef __cplusplus
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-/* An opaque pointer. */
-#ifndef YY_TYPEDEF_YY_SCANNER_T
-#define YY_TYPEDEF_YY_SCANNER_T
-typedef void* yyscan_t;
-#endif
-
-/* For convenience, these vars (plus the bison vars far below)
-   are macros in the reentrant scanner. */
-#define yyin yyg->yyin_r
-#define yyout yyg->yyout_r
-#define yyextra yyg->yyextra_r
-#define yyleng yyg->yyleng_r
-#define yytext yyg->yytext_r
-#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
-#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
-#define yy_flex_debug yyg->yy_flex_debug_r
-
-int vrml_v1_yylex_init (yyscan_t* scanner);
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef unsigned int yy_size_t;
-#endif
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-    
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-void vrml_v1_yyrestart (FILE *input_file ,yyscan_t yyscanner );
-void vrml_v1_yy_switch_to_buffer (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
-YY_BUFFER_STATE vrml_v1_yy_create_buffer (FILE *file,int size ,yyscan_t yyscanner );
-void vrml_v1_yy_delete_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
-void vrml_v1_yy_flush_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
-void vrml_v1_yypush_buffer_state (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
-void vrml_v1_yypop_buffer_state (yyscan_t yyscanner );
-
-YY_BUFFER_STATE vrml_v1_yy_scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner );
-YY_BUFFER_STATE vrml_v1_yy_scan_string (yyconst char *yy_str ,yyscan_t yyscanner );
-YY_BUFFER_STATE vrml_v1_yy_scan_bytes (yyconst char *bytes,int len ,yyscan_t yyscanner );
-
-void *vrml_v1_yyalloc (yy_size_t ,yyscan_t yyscanner );
-void *vrml_v1_yyrealloc (void *,yy_size_t ,yyscan_t yyscanner );
-void vrml_v1_yyfree (void * ,yyscan_t yyscanner );
-
-/* Begin user sect3 */
-
-#define yytext_ptr yytext_r
-
-#ifdef YY_HEADER_EXPORT_START_CONDITIONS
-#define INITIAL 0
-#define VRMLHEADER 1
-#define COMMENT 2
-
-#endif
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-static int yy_init_globals (yyscan_t yyscanner );
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int vrml_v1_yylex_destroy (yyscan_t yyscanner );
-
-int vrml_v1_yyget_debug (yyscan_t yyscanner );
-
-void vrml_v1_yyset_debug (int debug_flag ,yyscan_t yyscanner );
-
-YY_EXTRA_TYPE vrml_v1_yyget_extra (yyscan_t yyscanner );
-
-void vrml_v1_yyset_extra (YY_EXTRA_TYPE user_defined ,yyscan_t yyscanner );
-
-FILE *vrml_v1_yyget_in (yyscan_t yyscanner );
-
-void vrml_v1_yyset_in  (FILE * in_str ,yyscan_t yyscanner );
-
-FILE *vrml_v1_yyget_out (yyscan_t yyscanner );
-
-void vrml_v1_yyset_out  (FILE * out_str ,yyscan_t yyscanner );
-
-int vrml_v1_yyget_leng (yyscan_t yyscanner );
-
-char *vrml_v1_yyget_text (yyscan_t yyscanner );
-
-int vrml_v1_yyget_lineno (yyscan_t yyscanner );
-
-void vrml_v1_yyset_lineno (int line_number ,yyscan_t yyscanner );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int vrml_v1_yywrap (yyscan_t yyscanner );
-#else
-extern int vrml_v1_yywrap (yyscan_t yyscanner );
-#endif
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char *,yyconst char *,int ,yyscan_t yyscanner);
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * ,yyscan_t yyscanner);
-#endif
-
-#ifndef YY_NO_INPUT
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int vrml_v1_yylex (yyscan_t yyscanner);
-
-#define YY_DECL int vrml_v1_yylex (yyscan_t yyscanner)
-#endif /* !YY_DECL */
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-#undef YY_NEW_FILE
-#undef YY_FLUSH_BUFFER
-#undef yy_set_bol
-#undef yy_new_buffer
-#undef yy_set_interactive
-#undef yytext_ptr
-#undef YY_DO_BEFORE_ACTION
-
-#ifdef YY_DECL_IS_OURS
-#undef YY_DECL_IS_OURS
-#undef YY_DECL
-#endif
-#line 425 "imp_vrml_v1.l"
-
-
-#line 324 "imp_vrml_v1.h"
-#undef vrml_v1_yyIN_HEADER
-#endif /* vrml_v1_yyHEADER_H */



From dotslash at mail.berlios.de  Mon Sep 18 22:56:59 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 18 Sep 2006 22:56:59 +0200
Subject: [S3d-svn] r423 - in trunk: . Documentation server
Message-ID: <200609182056.k8IKuxqx007582@sheep.berlios.de>

Author: dotslash
Date: 2006-09-18 22:56:58 +0200 (Mon, 18 Sep 2006)
New Revision: 423

Modified:
   trunk/
   trunk/Documentation/Makefile.am
   trunk/configure.ac
   trunk/server/global.h
Log:
 r1025 at balthasar:  dotslash | 2006-09-18 22:56:55 +0200
 - some more cleanup for release ...



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1023
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1025

Modified: trunk/Documentation/Makefile.am
===================================================================
--- trunk/Documentation/Makefile.am	2006-09-18 20:16:12 UTC (rev 422)
+++ trunk/Documentation/Makefile.am	2006-09-18 20:56:58 UTC (rev 423)
@@ -1,6 +1,7 @@
 #SUBDIRS		= s3dapi
 
 EXTRA_DIST	=  README libs3d/libs3d.docbook s3d.docbook misc.docbook libs3dw/libs3dw.docbook \
-			   bookinfo.docbook server/server.docbook introduction.docbook
+			   bookinfo.docbook server/server.docbook introduction.docbook \
+			   manpages/s3d.1 manpages/s3dmanpage.sgml manpages/manpage.links manpages/manpage.refs
 
-man_MANS = manpages/s3d.1
\ No newline at end of file
+man_MANS = manpages/s3d.1

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-09-18 20:16:12 UTC (rev 422)
+++ trunk/configure.ac	2006-09-18 20:56:58 UTC (rev 423)
@@ -1,6 +1,6 @@
 dnl Process this file with autoconf to produce a configure script.
 AC_PREREQ(2.5)
-AC_INIT([s3d], [0.2rc1])
+AC_INIT([s3d], [0.1.1])
 AC_CONFIG_SRCDIR(server/main.c)
 
 AC_CANONICAL_HOST

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2006-09-18 20:16:12 UTC (rev 422)
+++ trunk/server/global.h	2006-09-18 20:56:58 UTC (rev 423)
@@ -38,7 +38,7 @@
 /*  server version */
 #define S3D_SERVER_MAJOR	0
 #define S3D_SERVER_MINOR	1
-#define S3D_SERVER_PATCH	0
+#define S3D_SERVER_PATCH	1
 #define S3D_SERVER_NAME 	"dotslash s3d server"
 
 #define MAXPLEN	65536



From marec at mail.berlios.de  Tue Sep 19 00:14:21 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Tue, 19 Sep 2006 00:14:21 +0200
Subject: [S3d-svn] r424 - trunk/apps/olsrs3d
Message-ID: <200609182214.k8IMELXE018090@sheep.berlios.de>

Author: marec
Date: 2006-09-19 00:14:21 +0200 (Tue, 19 Sep 2006)
New Revision: 424

Modified:
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/search.c
Log:
follow node onclick

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-18 20:56:58 UTC (rev 423)
+++ trunk/apps/olsrs3d/main.c	2006-09-18 22:14:21 UTC (rev 424)
@@ -877,6 +877,7 @@
 {
 	int oid,i;
 	char ip_str[50];
+	struct olsr_node *olsr_node;
 
 	s3dw_handle_click(evt);
 /*	if( get_search_status() == WIDGET )
@@ -887,6 +888,19 @@
 
 	oid=(int)*((unsigned long *)evt->buf);
 
+	if( get_search_status() != FOLLOW ){
+
+		olsr_node = NULL;
+		olsr_node = *lst_search(oid);
+
+		if ( olsr_node != NULL ) {
+			follow_node_by_click( olsr_node );
+		} else {
+			printf( "clicked obj not found(%i) ?!\n", oid );
+		}
+
+	}
+
 /*	if( oid == Btn_close_id )
 	{
 		s3d_del_object(Btn_close_id);

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2006-09-18 20:56:58 UTC (rev 423)
+++ trunk/apps/olsrs3d/search.c	2006-09-18 22:14:21 UTC (rev 424)
@@ -346,6 +346,12 @@
 		set_search_status( NOTHING );
 	}
 }
+/* public */
+void follow_node_by_click(struct olsr_node *olsr_node) {
+	(*search_node) = olsr_node;
+	set_search_status( FOLLOW );
+}
+
 /* private */
 void _search_node(s3dw_widget *dummy)
 {



From marec at mail.berlios.de  Tue Sep 19 00:35:36 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Tue, 19 Sep 2006 00:35:36 +0200
Subject: [S3d-svn] r425 - trunk/apps/olsrs3d
Message-ID: <200609182235.k8IMZafF008613@sheep.berlios.de>

Author: marec
Date: 2006-09-19 00:35:35 +0200 (Tue, 19 Sep 2006)
New Revision: 425

Modified:
   trunk/apps/olsrs3d/search.c
Log:
follow node onclick - fix crash

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2006-09-18 22:14:21 UTC (rev 424)
+++ trunk/apps/olsrs3d/search.c	2006-09-18 22:35:35 UTC (rev 425)
@@ -348,6 +348,7 @@
 }
 /* public */
 void follow_node_by_click(struct olsr_node *olsr_node) {
+	search_node = &_node_root;
 	(*search_node) = olsr_node;
 	set_search_status( FOLLOW );
 }



From marec at mail.berlios.de  Tue Sep 19 00:46:48 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Tue, 19 Sep 2006 00:46:48 +0200
Subject: [S3d-svn] r426 - trunk/apps/olsrs3d
Message-ID: <200609182246.k8IMkmi9027384@sheep.berlios.de>

Author: marec
Date: 2006-09-19 00:46:47 +0200 (Tue, 19 Sep 2006)
New Revision: 426

Modified:
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/olsrs3d.h
Log:
follow node onclick - fix oid search

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-18 22:35:35 UTC (rev 425)
+++ trunk/apps/olsrs3d/main.c	2006-09-18 22:46:47 UTC (rev 426)
@@ -877,7 +877,7 @@
 {
 	int oid,i;
 	char ip_str[50];
-	struct olsr_node *olsr_node;
+	struct Obj_to_ip *obj_to_ip_tmp;
 
 	s3dw_handle_click(evt);
 /*	if( get_search_status() == WIDGET )
@@ -890,13 +890,21 @@
 
 	if( get_search_status() != FOLLOW ){
 
-		olsr_node = NULL;
-		olsr_node = *lst_search(oid);
+		obj_to_ip_tmp = Obj_to_ip_head;
 
-		if ( olsr_node != NULL ) {
-			follow_node_by_click( olsr_node );
-		} else {
-			printf( "clicked obj not found(%i) ?!\n", oid );
+		while ( obj_to_ip_tmp != Obj_to_ip_end ) {
+
+			if ( obj_to_ip_tmp->id == oid ) {
+
+				follow_node_by_click( obj_to_ip_tmp->olsr_node );
+				break;
+
+			} else {
+
+				obj_to_ip_tmp = obj_to_ip_tmp->next;
+
+			}
+
 		}
 
 	}

Modified: trunk/apps/olsrs3d/olsrs3d.h
===================================================================
--- trunk/apps/olsrs3d/olsrs3d.h	2006-09-18 22:35:35 UTC (rev 425)
+++ trunk/apps/olsrs3d/olsrs3d.h	2006-09-18 22:46:47 UTC (rev 426)
@@ -35,7 +35,7 @@
 
 extern struct olsr_con *Con_begin;   /* begin of connection list */
 extern struct olsr_node *Olsr_root;   /* top of olsr node tree */
-extern struct Obj_to_ip *Obj_to_ip_head, *Obj_to_ip_end,*List_ptr;   /* struct list */
+extern struct Obj_to_ip *Obj_to_ip_head, *Obj_to_ip_end, *List_ptr;   /* struct list */
 
 extern int	Olsr_node_obj;
 extern int	Olsr_node_inet_obj;
@@ -73,4 +73,4 @@
 struct olsr_node **lst_search(int id);
 void print_etx( void );
 float dist(float p1[], float p2[]);
-void window_error(char *msg); 
+void window_error(char *msg);



From dotslash at mail.berlios.de  Tue Sep 19 01:05:47 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 19 Sep 2006 01:05:47 +0200
Subject: [S3d-svn] r427 - in trunk: . libs3dw
Message-ID: <200609182305.k8IN5leq009671@sheep.berlios.de>

Author: dotslash
Date: 2006-09-19 01:05:47 +0200 (Tue, 19 Sep 2006)
New Revision: 427

Modified:
   trunk/
   trunk/libs3dw/arrange.c
Log:
 r1032 at balthasar:  dotslash | 2006-09-19 01:05:30 +0200
 - increased widget distance treshold to 40



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1025
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1032

Modified: trunk/libs3dw/arrange.c
===================================================================
--- trunk/libs3dw/arrange.c	2006-09-18 22:46:47 UTC (rev 426)
+++ trunk/libs3dw/arrange.c	2006-09-18 23:05:47 UTC (rev 427)
@@ -117,7 +117,7 @@
 		}
 	}
 }
-#define DIST	30.0
+#define DIST	40.0
 void s3dw_follow()
 {
 	s3dw_widget *w,*root=s3dw_getroot();



From dotslash at mail.berlios.de  Tue Sep 19 16:00:18 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 19 Sep 2006 16:00:18 +0200
Subject: [S3d-svn] r428 - in trunk: . libs3d
Message-ID: <200609191400.k8JE0Ibj004765@sheep.berlios.de>

Author: dotslash
Date: 2006-09-19 16:00:18 +0200 (Tue, 19 Sep 2006)
New Revision: 428

Modified:
   trunk/
   trunk/libs3d/modelread.c
Log:
 r1034 at balthasar:  dotslash | 2006-09-19 16:00:13 +0200
 - absolute path to object searchpath added (I thought this was already commited before .. O_o)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1032
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1034

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2006-09-18 23:05:47 UTC (rev 427)
+++ trunk/libs3d/modelread.c	2006-09-19 14:00:18 UTC (rev 428)
@@ -50,7 +50,7 @@
 	char path[1024];
 	int oid;
 #ifndef OBJSDIR
-#define OBJSDIR 	"./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/"
+#define OBJSDIR 	":./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/"
 #endif
 
 	strncpy(searchpath,OBJSDIR,1023);



From dotslash at mail.berlios.de  Tue Sep 19 16:11:17 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 19 Sep 2006 16:11:17 +0200
Subject: [S3d-svn] r429 - in trunk: . libs3d/libg3d/plugins/import
Message-ID: <200609191411.k8JEBHg2005783@sheep.berlios.de>

Author: dotslash
Date: 2006-09-19 16:11:17 +0200 (Tue, 19 Sep 2006)
New Revision: 429

Modified:
   trunk/
   trunk/libs3d/libg3d/plugins/import/imp_3ds.c
   trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
Log:
 r1036 at balthasar:  dotslash | 2006-09-19 16:11:13 +0200
 - merge changes from libg3d back to s3d



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1034
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1036

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds.c	2006-09-19 14:00:18 UTC (rev 428)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds.c	2006-09-19 14:11:17 UTC (rev 429)
@@ -23,7 +23,6 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
-#include <stdlib.h> /* exit() */
 
 #include <g3d/types.h>
 #include <g3d/read.h>
@@ -42,6 +41,7 @@
 {
 	FILE *f;
 	gint32 nbytes, magic;
+	gboolean retval;
 	x3ds_global_data global;
 	x3ds_parent_data *parent;
 	long int fpos;
@@ -80,19 +80,18 @@
 	parent->id = magic;
 	parent->nb = nbytes;
 
-	x3ds_read_ctnr(&global, parent);
+	retval = x3ds_read_ctnr(&global, parent);
 
 	g_free(parent);
 
-	/*
-	x3ds_container(f, nbytes, context, model, NULL, 1, magic);
-	*/
+	fclose(f);
 
-	fclose(f);
 #if DEBUG > 0
-	g_printerr("imp_3ds.c: %s successfully loaded\n", filename);
+	if(retval)
+		g_printerr("imp_3ds.c: %s successfully loaded\n", filename);
 #endif
-	return TRUE;
+
+	return retval;
 }
 
 gchar *plugin_description(void)
@@ -134,12 +133,11 @@
 				x3ds_chunks[i].container ? 'c' : ' ',
 				x3ds_chunks[i].callback ? 'f' : ' ',
 				x3ds_chunks[i].desc, chunk_len);
-			
+
 			if (chunk_id==0)
 			{
 				g_printerr("error: bad chunk id\n");
-		/*		return FALSE;*/
-				exit(-1);
+				return FALSE;
 			}
 
 			subparent = g_new0(x3ds_parent_data, 1);
@@ -161,7 +159,11 @@
 
 			if(x3ds_chunks[i].container)
 			{
-				x3ds_read_ctnr(global, subparent);
+				if(x3ds_read_ctnr(global, subparent) == FALSE)
+				{
+					/* abort on error */
+					return FALSE;
+				}
 			}
 
 			if(subparent->nb)

Modified: trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-19 14:00:18 UTC (rev 428)
+++ trunk/libs3d/libg3d/plugins/import/imp_3ds_callbacks.c	2006-09-19 14:11:17 UTC (rev 429)
@@ -400,15 +400,13 @@
 /* smoothing groups */
 gboolean x3ds_cb_0x4150(x3ds_global_data *global, x3ds_parent_data *parent)
 {
-
 	G3DObject *object;
 	G3DFace *face;
 	GSList *oface;
 	gint32 i, j, k, n=0, polynum, group;
 	guint32 *smooth_list;
-	gfloat *pnormal_list, *vertex_normal_buf;			 	
+	gfloat *pnormal_list, *vertex_normal_buf;
 	gfloat a[3],b[3], *p0,*p1,*p2,*r;
-	gfloat len;
 
 	/* read data */
 	object = (G3DObject *)parent->object;
@@ -416,106 +414,119 @@
 
 	oface=object->faces;
 	polynum=0;
-	for (oface=object->faces; oface != NULL ; oface=oface->next) polynum++; /* count polygons */
+	for(oface = object->faces; oface != NULL ; oface = oface->next)
+		polynum++; /* count polygons */
 
-	pnormal_list=		g_new(float, 3*polynum);							/* polygon normal list */
-	vertex_normal_buf=	g_new0(float,3*object->vertex_count);				/* normals per vertice */
-	smooth_list = 		g_new(guint32, polynum);
-	for ( i=0 ; i<polynum ; i++ ) 
+	/* polygon normal list */
+	pnormal_list = g_new(float, 3 * polynum);
+	/* normals per vertice */
+	vertex_normal_buf = g_new0(float, 3 * object->vertex_count);
+
+	smooth_list = g_new(guint32, polynum);
+
+	for(i = 0 ; i < polynum ; i ++)
 		smooth_list[i] = g3d_read_int32_le(global->f);
+
 	parent->nb -= polynum * 4;
-	/* first, we calculate the normal by the polygon vertices (just vector product) */
-	i=0;
-	for (oface=object->faces; oface != NULL ; oface=oface->next)
+	/* first, we calculate the normal by the polygon vertices (just vector
+	 * product) */
+	i = 0;
+	for(oface = object->faces; oface != NULL ; oface=oface->next)
 	{
-		face=(G3DFace *)oface->data;
-		r=&(pnormal_list[i*3]);
-		p0=&(object->vertex_data[3* face->vertex_indices[0]]);
-		p1=&(object->vertex_data[3* face->vertex_indices[1]]);
-		p2=&(object->vertex_data[3* face->vertex_indices[2]]);
-		
+		face = (G3DFace *)oface->data;
+		r = &(pnormal_list[i*3]);
+		p0 = &(object->vertex_data[3 * face->vertex_indices[0]]);
+		p1 = &(object->vertex_data[3 * face->vertex_indices[1]]);
+		p2 = &(object->vertex_data[3 * face->vertex_indices[2]]);
+
 		a[0]=p1[0] - p0[0];
 		a[1]=p1[1] - p0[1];
 		a[2]=p1[2] - p0[2];
 		b[0]=p2[0] - p0[0];
 		b[1]=p2[1] - p0[1];
 		b[2]=p2[2] - p0[2];
-		r[0]=a[1]*b[2] - a[2]*b[1];
-		r[1]=a[2]*b[0] - a[0]*b[2];
-		r[2]=a[0]*b[1] - a[1]*b[0];
-	
-		len=sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);
-		if (len!=0.0F)
-		{
-			r[0]=r[0]/len;
-			r[1]=r[1]/len;
-			r[2]=r[2]/len;
-		} else {
-			r[0]=r[1]=r[2]=0.0F;
-		}
-		face->flags|=G3D_FLAG_FAC_NORMALS;
-		i++;
+
+		g3d_vector_normal(a[0], a[1], a[2], b[0], b[1], b[2],
+			&r[0], &r[1], &r[2]);
+
+		g3d_vector_unify(&r[0], &r[1], &r[2]);
+
+		face->flags |= G3D_FLAG_FAC_NORMALS;
+		i ++;
 	}
+
 	do {
 		/* find a suitable group. -1 means we've already taken care */
-		group=-1;
-		for (i=0;i<polynum;i++)
-			if ((group=smooth_list[i])!=-1) /* found a group */
+		group = -1;
+		for(i = 0; i < polynum; i ++)
+			if((group = smooth_list[i]) != -1) /* found a group */
 				break;
 		/* handle this group */
-		if (group!=-1)
+		if(group != -1)
 		{
-			/* SMOOTH */
-			/*  we add normals of the polygons's vertices so each vertex will finally have */
-			/*  the sum of the polygons normals where the vertex is part of. */
-
-			/* run0: clear the vertex_normal_buf for this group */
-			for (i=0;i<object->vertex_count*3;i++)
-				vertex_normal_buf[i]=0.0;
-			 /*  run1: add normals on themselves into the vertex_normal_buf */
-			i=0;
-			for (oface=object->faces; oface != NULL ; oface=oface->next)
+			/* SMOOTH
+			 *  we add normals of the polygons's vertices so each vertex will
+			 *  finally have
+			 *  the sum of the polygons normals where the vertex is part of.
+             *
+			 * run0: clear the vertex_normal_buf for this group */
+			for(i = 0; i < object->vertex_count * 3; i ++)
+				vertex_normal_buf[i] = 0.0;
+			/* run1: add normals on themselves into the vertex_normal_buf */
+			i = 0;
+			for(oface = object->faces; oface != NULL ; oface = oface->next)
 			{
-				face=(G3DFace *) oface->data;
-				if (smooth_list[i]==group)
+				face = (G3DFace *) oface->data;
+				if(smooth_list[i] == group)
 				{
-					for (j=0;j<3;j++) /* for all 3 vertices of the polygon */
+					/* for all 3 vertices of the polygon */
+					for(j = 0; j < 3; j ++)
 					{
-						k=face->vertex_indices[j];
-						for (n=0;n<3;n++)
-							vertex_normal_buf[ k*3+n ]+= pnormal_list[i*3 + n];
+						k = face->vertex_indices[j];
+						for(n = 0; n < 3; n ++)
+							vertex_normal_buf[k * 3 + n] +=
+								pnormal_list[i * 3 + n];
 					}
 				}
-				i++;
+				i ++;
 			}
-			i=0;
-			 /*  run2: apply to the final vertex buffer */
-			for (oface=object->faces; oface != NULL ; oface=oface->next)
+			i = 0;
+			/* run2: apply to the final vertex buffer */
+			for(oface = object->faces; oface != NULL ; oface = oface->next)
 			{
-				face=(G3DFace *)oface->data;
-				if (smooth_list[i]==group)
+				face = (G3DFace *)oface->data;
+				if(smooth_list[i] == group)
 				{
-					face->normals=g_new(gfloat,9);
-					for (j=0;j<3;j++)
+					face->normals = g_new(gfloat, 9);
+					for(j = 0; j < 3; j ++)
 					{
-						k=face->vertex_indices[j];
-						len=sqrt(	vertex_normal_buf[k*3]   * vertex_normal_buf[k*3]+
-									vertex_normal_buf[k*3+1] * vertex_normal_buf[k*3+1]+
-									vertex_normal_buf[k*3+2] * vertex_normal_buf[k*3+2]);
-						if (len==0.0F)   /*  this should not happen. well ... */
-								for (n=0;n<3;n++)	vertex_normal_buf[k*3 + n]=0;
-						else	for (n=0;n<3;n++)	vertex_normal_buf[k*3 + n]/=len; /* normalize it */
-						
-						if (len!=0.0) 	memcpy(face->normals +j*3, vertex_normal_buf+ 	k*3,sizeof(gfloat)*3);	/*  finally, we save the normal in our normal buffer */
-						else  			memcpy(face->normals +j*3, pnormal_list+i*3,sizeof(gfloat)*3);	/*  use the pbuf normal */
+						k = face->vertex_indices[j];
+
+						g3d_vector_unify(
+							&(vertex_normal_buf[k * 3 + 0]),
+							&(vertex_normal_buf[k * 3 + 1]),
+							&(vertex_normal_buf[k * 3 + 2]));
+
+						if(vertex_normal_buf[k * 3 + 0] != 0.0F)
+							/* finally, we save the normal in our normal
+							 * buffer */
+							memcpy(face->normals + j * 3,
+								vertex_normal_buf + k * 3,
+								sizeof(gfloat) * 3);
+						else
+							/* use the pbuf normal */
+							memcpy(face->normals + j * 3,
+								pnormal_list + i * 3,
+								sizeof(gfloat) * 3);
+
 					}
-					smooth_list[i]=-1; /* finished this polygon */
+					smooth_list[i] = -1; /* finished this polygon */
 				}
 				i++;
 			}
 			/* SMOOTH END */
 		}
-	} while (group!=-1);
+	} while (group != -1);
 
 	g_free(pnormal_list);
 	g_free(vertex_normal_buf);



From marec at mail.berlios.de  Tue Sep 19 22:40:28 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Tue, 19 Sep 2006 22:40:28 +0200
Subject: [S3d-svn] r430 - trunk/apps/olsrs3d
Message-ID: <200609192040.k8JKeSYt009852@sheep.berlios.de>

Author: marec
Date: 2006-09-19 22:40:28 +0200 (Tue, 19 Sep 2006)
New Revision: 430

Modified:
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/olsrs3d.h
   trunk/apps/olsrs3d/process.c
   trunk/apps/olsrs3d/search.c
Log:
- oid search in progress.c fixed - return NULL if not found
- move to node on double click

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-19 14:11:17 UTC (rev 429)
+++ trunk/apps/olsrs3d/main.c	2006-09-19 20:40:28 UTC (rev 430)
@@ -84,6 +84,8 @@
 int Btn_close_id = -1;
 
 int Btn_close_obj;
+int Last_Click_Time = 0;
+int Last_Click_Oid = 0;
 float Title_len;
 
 /***
@@ -158,6 +160,8 @@
 	s3dw_show(S3DWIDGET(infwin));
 
 }
+
+
 /***
  *
  * print error and exit
@@ -173,6 +177,18 @@
 
 
 
+unsigned int get_time(void) {
+
+	struct timeval tv;
+
+	gettimeofday(tv, NULL);
+
+	return tv.tv_sec * 1000 + tv.tv_usec / 1000;
+
+}
+
+
+
 /***
  *
  * calculate distance between 2 vectors => http://en.wikipedia.org/wiki/Euclidean_distance
@@ -875,9 +891,10 @@
 
 void object_click(struct s3d_evt *evt)
 {
-	int oid,i;
+	int oid, i;
 	char ip_str[50];
-	struct Obj_to_ip *obj_to_ip_tmp;
+	struct olsr_node *olsr_node;
+	struct timeval tv;
 
 	s3dw_handle_click(evt);
 /*	if( get_search_status() == WIDGET )
@@ -888,27 +905,20 @@
 
 	oid=(int)*((unsigned long *)evt->buf);
 
-	if( get_search_status() != FOLLOW ){
 
-		obj_to_ip_tmp = Obj_to_ip_head;
+	if ( ( get_search_status() != FOLLOW ) && ( Last_Click_Oid == oid ) && ( Last_Click_Time + 250 > get_time() ) ) {
 
-		while ( obj_to_ip_tmp != Obj_to_ip_end ) {
+		olsr_node = lst_search(oid);
 
-			if ( obj_to_ip_tmp->id == oid ) {
+		if ( olsr_node != NULL )
+			follow_node_by_click( olsr_node );
 
-				follow_node_by_click( obj_to_ip_tmp->olsr_node );
-				break;
+	}
 
-			} else {
+	Last_Click_Oid = oid;
+	Last_Click_Time = get_time();
 
-				obj_to_ip_tmp = obj_to_ip_tmp->next;
 
-			}
-
-		}
-
-	}
-
 /*	if( oid == Btn_close_id )
 	{
 		s3d_del_object(Btn_close_id);

Modified: trunk/apps/olsrs3d/olsrs3d.h
===================================================================
--- trunk/apps/olsrs3d/olsrs3d.h	2006-09-19 14:11:17 UTC (rev 429)
+++ trunk/apps/olsrs3d/olsrs3d.h	2006-09-19 20:40:28 UTC (rev 430)
@@ -60,9 +60,9 @@
 void lst_initialize();
 void lst_add(int id,struct olsr_node **olsr_node);
 void lst_del(int id);
-struct olsr_node **lst_search(int id);
+struct olsr_node *lst_search(int id);
 void lst_out();
-void move_lst_ptr(int *id);
+struct olsr_node *move_lst_ptr(int *id);
 int process_main();
 /* net */
 int net_init(char *host);
@@ -70,7 +70,6 @@
 int net_quit();
 /* main */
 void out_of_mem( void );
-struct olsr_node **lst_search(int id);
 void print_etx( void );
 float dist(float p1[], float p2[]);
 void window_error(char *msg);

Modified: trunk/apps/olsrs3d/process.c
===================================================================
--- trunk/apps/olsrs3d/process.c	2006-09-19 14:11:17 UTC (rev 429)
+++ trunk/apps/olsrs3d/process.c	2006-09-19 20:40:28 UTC (rev 430)
@@ -311,15 +311,17 @@
  *
  */
 
-void move_lst_ptr(int *id) {
+struct olsr_node *move_lst_ptr(int *id) {
 	/* printf("obj2ip: move for %d\n",*id); */
 	/* head to point at end or id lass then first element in linked list*/
-	if(Obj_to_ip_head->next == Obj_to_ip_head || *id < Obj_to_ip_head->next->id)
+	if(Obj_to_ip_head->next == Obj_to_ip_head || *id < Obj_to_ip_head->next->id) {
 		List_ptr = Obj_to_ip_head;
+		return NULL;
  	/* id is greather then last element in linked list */
-	else if(*id > Obj_to_ip_end->prev->id)
+	} else if(*id > Obj_to_ip_end->prev->id) {
 		List_ptr = Obj_to_ip_end->prev;
-	else {
+		return NULL;
+	} else {
 		/* printf("obj2ip: ok i search deeper ;-) for id=%d\n",*id); */
 		if((*id - (int) Obj_to_ip_head->next->id) <= ((int)(Obj_to_ip_end->prev->id)-*id)) {
 			List_ptr = Obj_to_ip_head;
@@ -340,6 +342,12 @@
 			}
 			List_ptr = List_ptr->prev;
 		}
+
+		if ( List_ptr->id == *id )
+			return List_ptr->olsr_node;
+		else
+			return NULL;
+
 		/* printf("obj2ip: found id to insert between %d--> .. <--%d to search/delete %d--> .. <--%d\n",List_ptr->id,List_ptr->next->next->id,List_ptr->prev->id,List_ptr->next->id); */
 	}
 }
@@ -357,14 +365,10 @@
  *
  */
 
-struct olsr_node **lst_search(int id) {
-	move_lst_ptr(&id);
-	/* TODO: return NULL when no node found */
-	/* if(id != List_ptr->id) */
-		/* printf("obj2ip: search id....id not found\n"); */
-	/* else */
-		/* printf("obj2ip: search found objekt_id=%d objekt_ip=%s\n",List_ptr->id,List_ptr->olsr_node->ip); */
-	return(&List_ptr->olsr_node);
+struct olsr_node *lst_search(int id) {
+
+	return( move_lst_ptr(&id) );
+
 }
 
 void lst_out() {

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2006-09-19 14:11:17 UTC (rev 429)
+++ trunk/apps/olsrs3d/search.c	2006-09-19 20:40:28 UTC (rev 430)
@@ -321,7 +321,6 @@
 
 		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
 
-		printf( "ip: %s\n", (*search_node)->ip );
 		if ( result == 0 )
 			break;
 



From dotslash at mail.berlios.de  Tue Sep 19 22:57:02 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 19 Sep 2006 22:57:02 +0200
Subject: [S3d-svn] r431 - in trunk: . libs3dw
Message-ID: <200609192057.k8JKv2d3011063@sheep.berlios.de>

Author: dotslash
Date: 2006-09-19 22:57:02 +0200 (Tue, 19 Sep 2006)
New Revision: 431

Modified:
   trunk/
   trunk/libs3dw/label.c
   trunk/libs3dw/widget.c
Log:
 r1040 at balthasar:  dotslash | 2006-09-19 22:56:51 +0200
 - labels are not buttons (of course) -> typo



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1036
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1040

Modified: trunk/libs3dw/label.c
===================================================================
--- trunk/libs3dw/label.c	2006-09-19 20:40:28 UTC (rev 430)
+++ trunk/libs3dw/label.c	2006-09-19 20:57:02 UTC (rev 431)
@@ -57,7 +57,7 @@
 	s3dw_widget *widget;
 	label=(s3dw_label *)malloc(sizeof(s3dw_label));
 	widget=s3dw_widget_new((s3dw_widget *)label);
-	widget->type=S3DW_TBUTTON;
+	widget->type=S3DW_TLABEL;
 	widget->x=posx;
 	widget->y=posy;
 	label->text=strdup(text);

Modified: trunk/libs3dw/widget.c
===================================================================
--- trunk/libs3dw/widget.c	2006-09-19 20:40:28 UTC (rev 430)
+++ trunk/libs3dw/widget.c	2006-09-19 20:57:02 UTC (rev 431)
@@ -50,6 +50,7 @@
 int s3dw_widget_event_click(s3dw_widget *widget, unsigned long oid)
 {
 	int i;
+	s3dprintf(VLOW,"processing click event for widget %010p of type %d, oid %d (%d), subobjects: %d",widget,widget->type, widget->oid, oid, widget->nobj);
 	if (s3dwcb_click[widget->type](widget,oid)) return(1);
 	for (i=0;i<widget->nobj;i++)
 		if (s3dw_widget_event_click(widget->pobj[i],oid)) return(1);



From dotslash at mail.berlios.de  Mon Sep 25 15:52:51 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 25 Sep 2006 15:52:51 +0200
Subject: [S3d-svn] r432 - in trunk: . server
Message-ID: <200609251352.k8PDqp4s005415@sheep.berlios.de>

Author: dotslash
Date: 2006-09-25 15:52:51 +0200 (Mon, 25 Sep 2006)
New Revision: 432

Modified:
   trunk/
   trunk/INSTALL
   trunk/configure.ac
   trunk/server/graphics.c
   trunk/server/main.c
Log:
 r1042 at balthasar:  dotslash | 2006-09-25 15:52:46 +0200
 - s3d --no-rc does not call kill(kidpid, SIGUSR1) if there is no kid
 - remove GLUT from autoconf recommendations (but it's still possible to select)
 - cleanup old INSTALL



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1040
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1042

Modified: trunk/INSTALL
===================================================================
--- trunk/INSTALL	2006-09-19 20:57:02 UTC (rev 431)
+++ trunk/INSTALL	2006-09-25 13:52:51 UTC (rev 432)
@@ -1,9 +1,28 @@
-### 1 Preparing 
 
+
+             ________
+            /        \________  _______
+            \         \       \|       \
+         ____\     ___/____   /|_       \
+        /     \     \    \    \ |        \
+        \            \____\_   \|         \
+         \___________/          \    |    /
+                 s3D \__________/________/
+				
+						INSTALL
+
+
+
+
+1. Preparing 
+------------
+
+
 Before being able to install s3d and the sample programs, you need to prepare
 the build, and compile s3d. 
 
-### 1.1 Subversion Checkout
+1.1. Subversion Checkout
+------------------------
 
 If you are using a version directly checked out from subversion, you will need
 to setup the GNU autotools first. The following assumes that automake 1.9,
@@ -26,7 +45,8 @@
 
 to learn about more configuration parameters.
 
-### 1.2 Preparing a Released Version
+1.2 Preparing a Released Version
+--------------------------------
 
 A released version of s3d contains a pregenerated configure script, which you
 can run directly:
@@ -37,7 +57,8 @@
 features you have to enable them with --enable-debug and --enable-profiling,
 respectively.
 
-### 2 Building
+2. Building
+-----------
 
 After configure has finished, you can start the build of s3d:
 
@@ -46,15 +67,23 @@
 in the root directory will compile server, client-lib and the examples
 for you.
 
-after that, go
 
-$ cd server
-$ ./s3d --no-rc
+3. Installing
+-------------
 
-fire up the server. if you're lucky, a window appears.now the s3d is listening 
-on port 6066. 
-now it's time to test some things. on another terminal:
+Because of the new plugins, things need to be installed before you can test. 
 
+$ make install
+
+installs s3d in the selected prefix (default /usr/local/*), you may need to become 
+root first.
+
+$ s3d --no-rc
+
+fires up the server. Uf you're lucky, a X11 window appears. Now the s3d is listening 
+on TCP port 6066. 
+Now it's time to test some things. on another terminal:
+
 $ cd examples
 $ ./3dsloader miu3ds/miu.3ds
 
@@ -62,17 +91,28 @@
 mouse-button pushed.
 now you can try the MCP, which is something like a windowmanager in X:
 
-$ cd examples
+$ cd apps/dot_mcp
 $ ./dot_mcp
 
 now you should get some fancy window decorations :D
 there are a few other examples, just play around
 
-### 3 Installing
+4. s3drc
+--------
 
-You can use the install target to install s3d into the selected prefix. 
+We recommend to make use of the .s3drc. The idea is the same as in .xinitrc,
+starting the window manager (the mcp) along with the server. When the .s3drc
+is finished, the server will go down with it (so you can press a "quit" button
+in the mcp).
 
-$ make install
+Give it a try:
 
-Depending on the selected prefix, you may need to become superuser first.
+$ cat << EOF > ~/.s3drc
+#!/bin/sh
+dot_mcp
+EOF
+$ s3d
 
+(note, this time without --no-rc)
+
+

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-09-19 20:57:02 UTC (rev 431)
+++ trunk/configure.ac	2006-09-25 13:52:51 UTC (rev 432)
@@ -92,8 +92,8 @@
 if test "x${HAVE_SDL}" = "xyes"; then
 	AC_DEFINE([G_SDL], 1, [Use SDL])
 fi
-if test "x${HAVE_glut}${HAVE_SDL}" = "x"; then
-	AC_MSG_ERROR([No OpenGL Framework found. Try installing GLUT or SDL, or both])
+if test "x${HAVE_SDL}" = "x"; then
+	AC_MSG_ERROR([Please install SDL.])
 fi
 
 AM_CONDITIONAL([BUILD_SDL], test x"${HAVE_SDL}" = xyes)

Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2006-09-19 20:57:02 UTC (rev 431)
+++ trunk/server/graphics.c	2006-09-25 13:52:51 UTC (rev 432)
@@ -355,11 +355,6 @@
 	GLfloat light0_diff[]={0.5,0.5,0.5,1.0};
 	GLfloat light0_amb[]={1.0,1.0,1.0,1.0};
 	
-/*
-	GLfloat wire_amb[]={0.1,0.3,0.1,0.5};
-	GLfloat wire_diff[]={0.1,0.3,0.1,0.5};
-	GLfloat wire_spec[]={1.0,1.0,1.0,0.5};
-*/
 	select_mode=0;
 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  /*  clear screen */
 	 /*  set up the cam ... */
@@ -385,20 +380,6 @@
 
  	glPushMatrix();  /*  save the cam */ 
 		render_by_mcp();
-/*
-#ifdef DEBUG
-#ifdef G_GLUT
-		glPushMatrix();
-			glRotatef(90,1.0,0.0,0.0);	
-			/ * set some evilish green color * /
-			glMaterialfv(GL_FRONT,GL_AMBIENT,wire_amb);
-			glMaterialfv(GL_FRONT,GL_SPECULAR,wire_spec);
-			glMaterialfv(GL_FRONT,GL_DIFFUSE,wire_diff);
-			
-			glutWireTorus(100,100,40,40);
-		glPopMatrix();
-#endif
-#endif*/
  	glPopMatrix();  /*  restore the cam */ 
 	glLoadIdentity();
 	glMultMatrixf(m);

Modified: trunk/server/main.c
===================================================================
--- trunk/server/main.c	2006-09-19 20:57:02 UTC (rev 431)
+++ trunk/server/main.c	2006-09-25 13:52:51 UTC (rev 432)
@@ -177,7 +177,8 @@
 	        errn("init():signal()",errno);
     if (signal(SIGTERM, sigint_handler) == SIG_ERR) 
 	        errn("init():signal()",errno);
-	kill(kidpid, SIGUSR1);
+	if (kidpid!=0)
+		kill(kidpid, SIGUSR1);
 #endif
 	return(0);
 }



From dotslash at mail.berlios.de  Mon Sep 25 18:41:38 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 25 Sep 2006 18:41:38 +0200
Subject: [S3d-svn] r433 - trunk
Message-ID: <200609251641.k8PGfcaE016097@sheep.berlios.de>

Author: dotslash
Date: 2006-09-25 18:41:36 +0200 (Mon, 25 Sep 2006)
New Revision: 433

Modified:
   trunk/
   trunk/INSTALL
Log:
 r1044 at balthasar:  dotslash | 2006-09-25 18:41:15 +0200
 - INSTALL



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1042
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1044

Modified: trunk/INSTALL
===================================================================
--- trunk/INSTALL	2006-09-25 13:52:51 UTC (rev 432)
+++ trunk/INSTALL	2006-09-25 16:41:36 UTC (rev 433)
@@ -25,8 +25,13 @@
 ------------------------
 
 If you are using a version directly checked out from subversion, you will need
-to setup the GNU autotools first. The following assumes that automake 1.9,
-autoconf 2.59 are available and installed into a directory listed in the $PATH
+to setup the GNU autotools first. The following assumes that 
+
+* automake 1.9 (1.4 is too old!)
+* autoconf 2.59 
+* libtool
+
+are available and installed into a directory listed in the $PATH
 environment variable.
 
 $ ./autogen.sh [--prefix=/some/where] [--disable-debug] [--enable-profiling]



From dotslash at mail.berlios.de  Mon Sep 25 19:10:57 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 25 Sep 2006 19:10:57 +0200
Subject: [S3d-svn] r434 - in trunk: . objs
Message-ID: <200609251710.k8PHAvca029423@sheep.berlios.de>

Author: dotslash
Date: 2006-09-25 19:10:56 +0200 (Mon, 25 Sep 2006)
New Revision: 434

Modified:
   trunk/
   trunk/objs/Makefile.am
Log:
 r1046 at balthasar:  dotslash | 2006-09-25 19:10:29 +0200
 - Makefile add s3d.berlios.de-object



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1044
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1046

Modified: trunk/objs/Makefile.am
===================================================================
--- trunk/objs/Makefile.am	2006-09-25 16:41:36 UTC (rev 433)
+++ trunk/objs/Makefile.am	2006-09-25 17:10:56 UTC (rev 434)
@@ -47,5 +47,6 @@
 	btn_minimize.3ds \
 	btn_rotate.3ds \
 	btn_maximize.3ds \
+	s3d_berlios_de.3ds \
 	AUTHORS
 



From dotslash at mail.berlios.de  Mon Sep 25 21:42:05 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 25 Sep 2006 21:42:05 +0200
Subject: [S3d-svn] r435 - in trunk: . libs3d/libg3d/plugins/import
Message-ID: <200609251942.k8PJg5ps011028@sheep.berlios.de>

Author: dotslash
Date: 2006-09-25 21:42:04 +0200 (Mon, 25 Sep 2006)
New Revision: 435

Added:
   trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.h
Modified:
   trunk/
Log:
 r1048 at balthasar:  dotslash | 2006-09-25 21:41:50 +0200
 - add it again (after all, it must be included in the distribution too ...)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1046
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1048

Added: trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.h
===================================================================
--- trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.h	2006-09-25 17:10:56 UTC (rev 434)
+++ trunk/libs3d/libg3d/plugins/import/imp_vrml_v1.h	2006-09-25 19:42:04 UTC (rev 435)
@@ -0,0 +1,325 @@
+#ifndef vrml_v1_yyHEADER_H
+#define vrml_v1_yyHEADER_H 1
+#define vrml_v1_yyIN_HEADER 1
+
+#line 6 "imp_vrml_v1.h"
+
+#line 8 "imp_vrml_v1.h"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 31
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* An opaque pointer. */
+#ifndef YY_TYPEDEF_YY_SCANNER_T
+#define YY_TYPEDEF_YY_SCANNER_T
+typedef void* yyscan_t;
+#endif
+
+/* For convenience, these vars (plus the bison vars far below)
+   are macros in the reentrant scanner. */
+#define yyin yyg->yyin_r
+#define yyout yyg->yyout_r
+#define yyextra yyg->yyextra_r
+#define yyleng yyg->yyleng_r
+#define yytext yyg->yytext_r
+#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
+#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
+#define yy_flex_debug yyg->yy_flex_debug_r
+
+int vrml_v1_yylex_init (yyscan_t* scanner);
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+void vrml_v1_yyrestart (FILE *input_file ,yyscan_t yyscanner );
+void vrml_v1_yy_switch_to_buffer (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
+YY_BUFFER_STATE vrml_v1_yy_create_buffer (FILE *file,int size ,yyscan_t yyscanner );
+void vrml_v1_yy_delete_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
+void vrml_v1_yy_flush_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
+void vrml_v1_yypush_buffer_state (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
+void vrml_v1_yypop_buffer_state (yyscan_t yyscanner );
+
+YY_BUFFER_STATE vrml_v1_yy_scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner );
+YY_BUFFER_STATE vrml_v1_yy_scan_string (yyconst char *yy_str ,yyscan_t yyscanner );
+YY_BUFFER_STATE vrml_v1_yy_scan_bytes (yyconst char *bytes,int len ,yyscan_t yyscanner );
+
+void *vrml_v1_yyalloc (yy_size_t ,yyscan_t yyscanner );
+void *vrml_v1_yyrealloc (void *,yy_size_t ,yyscan_t yyscanner );
+void vrml_v1_yyfree (void * ,yyscan_t yyscanner );
+
+/* Begin user sect3 */
+
+#define yytext_ptr yytext_r
+
+#ifdef YY_HEADER_EXPORT_START_CONDITIONS
+#define INITIAL 0
+#define VRMLHEADER 1
+#define COMMENT 2
+
+#endif
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (yyscan_t yyscanner );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int vrml_v1_yylex_destroy (yyscan_t yyscanner );
+
+int vrml_v1_yyget_debug (yyscan_t yyscanner );
+
+void vrml_v1_yyset_debug (int debug_flag ,yyscan_t yyscanner );
+
+YY_EXTRA_TYPE vrml_v1_yyget_extra (yyscan_t yyscanner );
+
+void vrml_v1_yyset_extra (YY_EXTRA_TYPE user_defined ,yyscan_t yyscanner );
+
+FILE *vrml_v1_yyget_in (yyscan_t yyscanner );
+
+void vrml_v1_yyset_in  (FILE * in_str ,yyscan_t yyscanner );
+
+FILE *vrml_v1_yyget_out (yyscan_t yyscanner );
+
+void vrml_v1_yyset_out  (FILE * out_str ,yyscan_t yyscanner );
+
+int vrml_v1_yyget_leng (yyscan_t yyscanner );
+
+char *vrml_v1_yyget_text (yyscan_t yyscanner );
+
+int vrml_v1_yyget_lineno (yyscan_t yyscanner );
+
+void vrml_v1_yyset_lineno (int line_number ,yyscan_t yyscanner );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int vrml_v1_yywrap (yyscan_t yyscanner );
+#else
+extern int vrml_v1_yywrap (yyscan_t yyscanner );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int ,yyscan_t yyscanner);
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * ,yyscan_t yyscanner);
+#endif
+
+#ifndef YY_NO_INPUT
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int vrml_v1_yylex (yyscan_t yyscanner);
+
+#define YY_DECL int vrml_v1_yylex (yyscan_t yyscanner)
+#endif /* !YY_DECL */
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+#undef YY_NEW_FILE
+#undef YY_FLUSH_BUFFER
+#undef yy_set_bol
+#undef yy_new_buffer
+#undef yy_set_interactive
+#undef yytext_ptr
+#undef YY_DO_BEFORE_ACTION
+
+#ifdef YY_DECL_IS_OURS
+#undef YY_DECL_IS_OURS
+#undef YY_DECL
+#endif
+#line 425 "imp_vrml_v1.l"
+
+
+#line 324 "imp_vrml_v1.h"
+#undef vrml_v1_yyIN_HEADER
+#endif /* vrml_v1_yyHEADER_H */



From dotslash at mail.berlios.de  Mon Sep 25 21:56:57 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 25 Sep 2006 21:56:57 +0200
Subject: [S3d-svn] r436 - in trunk: . apps/dot_mcp apps/olsrs3d libs3d
Message-ID: <200609251956.k8PJuvmR012227@sheep.berlios.de>

Author: dotslash
Date: 2006-09-25 21:56:56 +0200 (Mon, 25 Sep 2006)
New Revision: 436

Added:
   trunk/apps/dot_mcp/TODO
Modified:
   trunk/
   trunk/apps/olsrs3d/TODO
   trunk/libs3d/TODO
Log:
 r1050 at balthasar:  dotslash | 2006-09-25 21:56:33 +0200
 - TODO update



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1048
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1050

Added: trunk/apps/dot_mcp/TODO
===================================================================
--- trunk/apps/dot_mcp/TODO	2006-09-25 19:42:04 UTC (rev 435)
+++ trunk/apps/dot_mcp/TODO	2006-09-25 19:56:56 UTC (rev 436)
@@ -0,0 +1 @@
+- update navigation ... wasd is no good idea

Modified: trunk/apps/olsrs3d/TODO
===================================================================
--- trunk/apps/olsrs3d/TODO	2006-09-25 19:42:04 UTC (rev 435)
+++ trunk/apps/olsrs3d/TODO	2006-09-25 19:56:56 UTC (rev 436)
@@ -1,5 +1,4 @@
-	rotate text in cam-direction
-	search for vertices (text input?)
+	make detailed  error messages (just "connection reset" is not enough, at least "failed to connect to olsrd-daemon" should be printed)
 	show link times
 	add 3ds files for cubes, linksys wrt, internet node, hna node
 	add color mode without red & green colors

Modified: trunk/libs3d/TODO
===================================================================
--- trunk/libs3d/TODO	2006-09-25 19:42:04 UTC (rev 435)
+++ trunk/libs3d/TODO	2006-09-25 19:56:56 UTC (rev 436)
@@ -1,4 +1,5 @@
 TODO:
+- remove/correct libg3d error messages ...
 - key repeation
 - shmat() return (char *) -1 or NULL?! data_ctos/data_stoc should
   really not be 0x0



From dotslash at mail.berlios.de  Tue Sep 26 16:54:50 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 26 Sep 2006 16:54:50 +0200
Subject: [S3d-svn] r437 - in trunk: . apps/s3dfm
Message-ID: <200609261454.k8QEsodc012583@sheep.berlios.de>

Author: dotslash
Date: 2006-09-26 16:54:49 +0200 (Tue, 26 Sep 2006)
New Revision: 437

Added:
   trunk/apps/s3dfm/event.c
   trunk/apps/s3dfm/node.c
   trunk/apps/s3dfm/string.c
Modified:
   trunk/
   trunk/apps/s3dfm/Makefile.am
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/icon.c
   trunk/apps/s3dfm/main.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dfm/s3dfm.h
Log:
 r1061 at balthasar:  dotslash | 2006-09-26 16:54:42 +0200
 - rewriting - just a backup



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1050
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1061

Modified: trunk/apps/s3dfm/Makefile.am
===================================================================
--- trunk/apps/s3dfm/Makefile.am	2006-09-25 19:56:56 UTC (rev 436)
+++ trunk/apps/s3dfm/Makefile.am	2006-09-26 14:54:49 UTC (rev 437)
@@ -5,8 +5,9 @@
 s3dfminclude_HEADERS =  \
 	s3dfm.h
 s3dfm_SOURCES =  \
-	main.c box.c animation.c \
-	fs.c dialog.c parse.c icon.c
+	main.c box.c animation.c event.c \
+	fs.c dialog.c parse.c icon.c node.c \
+	string.c
 
 s3dfm_CPPFLAGS=		-I${top_srcdir}/libs3d -I${top_srcdir}/libs3dw
 s3dfm_LDADD=		${top_builddir}/libs3d/libs3d.la ${top_builddir}/libs3dw/libs3dw.la

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2006-09-25 19:56:56 UTC (rev 436)
+++ trunk/apps/s3dfm/animation.c	2006-09-26 14:54:49 UTC (rev 437)
@@ -22,19 +22,18 @@
  */
 
 #include "s3dfm.h"
-#include <s3dw.h>
 #include <stdio.h> 	 /*  printf(),NULL */
 #include <math.h>	 /*  fabs() */
 #define SCALE 	1
 
 /* the animation stack */
-static t_item *ani_s[MAXANI];
+static t_node *ani_s[MAXANI];
 static int ani_n=0;
-extern t_item root,cam;
+extern t_node root,cam;
 int moveon=1;
 
 /* get the scale for the rootbox zoom */
-float ani_get_scale(t_item *f)
+float ani_get_scale(t_node *f)
 {
 	float scale,s;
 	s=0.2;
@@ -53,14 +52,14 @@
 	return(scale);
 }
 /* center f for the viewer, therefore moving the root box ... */
-void ani_focus(t_item *f)
+void ani_focus(t_node *f)
 {
 	root.px=0.0;
 	root.py=0.0;
 	root.pz=0.0;
 	moveon=1;
 /*	printf("[Z]ooming to %s\n",f->name);*/
-	box_collapse_grandkids(f);
+/*	box_collapse_grandkids(f);*/
 	root.scale=ani_get_scale(f);
 	root.py-=1.5;
 /*	printf("[R]escaling to %f\n",root.scale);
@@ -76,8 +75,8 @@
 		ani_add(&cam);
 	}
 }
-/* is item f already on stack? */
-int ani_onstack(t_item *f)
+/* is node f already on stack? */
+int ani_onstack(t_node *f)
 {
 	int i;
 	for (i=0;i<ani_n;i++)
@@ -86,8 +85,8 @@
 	return(0);
 
 }
-/* add an item on the animation stack */
-void ani_add(t_item *f)
+/* add an node on the animation stack */
+void ani_add(t_node *f)
 {
 	if (ani_n<MAXANI)
 	{
@@ -101,7 +100,7 @@
 	else /* no place, finish now */
 		ani_finish(f,-1);
 }
-/* delete an item from the animation stack */
+/* delete an node from the animation stack */
 void ani_del(int i)
 {
 	if ((i>=0) && (i<ani_n))
@@ -114,14 +113,14 @@
 	}
 }
 /* well ... */
-void ani_doit(t_item *f)
+void ani_doit(t_node *f)
 {
-	s3d_translate(	f->block, f->dpx,f->dpy,f->dpz);
-	s3d_scale(		f->block, f->dscale);
+	s3d_translate(	f->oid, f->dpx,f->dpy,f->dpz);
+	s3d_scale(		f->oid, f->dscale);
 }
 
 /* finish an animation on the stack, stack index i */
-void ani_finish(t_item *f, int i)
+void ani_finish(t_node *f, int i)
 {
 	f->dpx= f->px;
 	f->dpy= f->py;
@@ -131,7 +130,7 @@
 	if (i!=-1)
 		ani_del(i);
 }
-void ani_iterate(t_item *f)
+void ani_iterate(t_node *f)
 {
 	f->dpx=(f->px + f->dpx*ZOOMS)/(ZOOMS+1);
 	f->dpy=(f->py + f->dpy*ZOOMS)/(ZOOMS+1);
@@ -141,7 +140,7 @@
 }
 
 /* checks if f is good enough */
-int ani_check(t_item *f)
+int ani_check(t_node *f)
 {
 	float x,y,z;
 	x=f->dpx - f->px;
@@ -155,7 +154,7 @@
 void ani_mate()
 {
 	int i;
-	t_item *f;
+	t_node *f;
 	s3dw_ani_mate();
 	for (i=0;i<ani_n;i++)
 	{

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2006-09-25 19:56:56 UTC (rev 436)
+++ trunk/apps/s3dfm/box.c	2006-09-26 14:54:49 UTC (rev 437)
@@ -26,39 +26,88 @@
 #include <math.h>	 /*  sin(),cos() */
 #include <string.h>  /*  strlen() */
 
+void box_draw(t_node *dir)
+{
+	box_buildblock(dir);
+	box_sidelabel(dir);
+    s3d_flags_on(dir->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+    s3d_flags_on(dir->objs.close,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+    s3d_flags_on(dir->objs.title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+    s3d_flags_on(dir->objs.select,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+    s3d_flags_on(dir->objs.titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	dir->disp=D_DIR;
+	box_draw_icons(dir);
 
-/* remove old items on the box */
-void box_dissolve(t_item *dir)
+}
+/* draw all the icons which are not displayed yet */
+void box_draw_icons(t_node *dir)
 {
-	if (dir->close!=-1)		{	s3d_del_object(dir->close);		dir->close=-1; }
-	if (dir->select!=-1)	{	s3d_del_object(dir->select);	dir->select=-1; }
-	if (dir->title!=-1)		{	s3d_del_object(dir->title);		dir->title=-1; }
-	if (dir->titlestr!=-1)	{	s3d_del_object(dir->titlestr);	dir->titlestr=-1; }
-	if (dir->block!=-1)			s3d_del_object(dir->block);
+	int i;
+	printf("box_draw_icons(%s, %d subs)\n",dir->name, dir->n_sub);
+	for (i=0;i<dir->n_sub;i++)
+	{
+		if (dir->sub[i]->disp==D_NONE)	icon_draw(dir->sub[i]);
+	}
+	box_order_icons(dir);
+}
+/* order the icons properly */
+void box_order_icons(t_node *dir)
+{
+	int dps,i;
+	dps=ceil(sqrt(dir->n_sub)); /* directories per line */
+	for (i=0;i<dir->n_sub;i++)
+	{
+		printf("ordering icon %s\n",dir->sub[i]->name);
+		dir->sub[i]->dpx = -1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
+		dir->sub[i]->dpy = 0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
+		dir->sub[i]->dpz = 1.0;
+		dir->sub[i]->scale = (float)1.0/((float)dps);
+		dir->sub[i]->dscale = 0.001;
+		dir->sub[i]->dpx = 0;
+		dir->sub[i]->dpy = 0;
+		dir->sub[i]->dpz = 1;
+		/* make a first setup so there is no flickering */
+		s3d_link(dir->sub[i]->oid,dir->oid); /* if it's already displayed, make sure it linked properly ... */
+		ani_doit(dir->sub[i]);
+		ani_add(dir->sub[i]); /* apply transformation */
+		s3d_flags_on(dir->sub[i]->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_on(dir->sub[i]->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 
+		
+	}
 }
 
+/* remove old items on the box */
+/*
+void box_dissolve(t_node *dir)
+{
+	if (dir->objs.close!=-1)		{	s3d_del_object(dir->objs.close);		dir->objs.close=-1; }
+	if (dir->objs.select!=-1)	{	s3d_del_object(dir->objs.select);	dir->objs.select=-1; }
+	if (dir->objs.title!=-1)		{	s3d_del_object(dir->objs.title);		dir->objs.title=-1; }
+	if (dir->objs.titlestr!=-1)	{	s3d_del_object(dir->objs.titlestr);	dir->objs.titlestr=-1; }
+	if (dir->oid!=-1)			s3d_del_object(dir->oid);
 
+}*/
 
+
+
 /* places the string at the left side of the cube */
-void box_sidelabel(t_item *dir)
+void box_sidelabel(t_node *dir)
 {
 
-	s3d_rotate(dir->str,0,90,0);
-	s3d_translate(dir->str,1.1,0.3,1);
-	s3d_scale(dir->str,(float)1.8/(dir->len));
-	s3d_scale(dir->str,(float)1.8/(dir->len));
-	s3d_link(dir->str,dir->block);
-	s3d_flags_on(dir->str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	s3d_rotate(dir->objs.str,0,90,0);
+	s3d_translate(dir->objs.str,1.1,0.3,1);
+	s3d_scale(dir->objs.str,(float)1.8/(dir->len));
+	s3d_scale(dir->objs.str,(float)1.8/(dir->len));
+	s3d_link(dir->objs.str,dir->oid);
+	s3d_flags_on(dir->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
 
 /* creates a big block which will hold files and subdirs on top */
-int box_buildblock(t_item *dir)
+int box_buildblock(t_node *dir)
 {
 	char fname[30];
 	char *fullname=fname;
-	t_item *d;
-	int i,j;
 	float len;
 	float vertices[]=
 			{-BHP,0,-BHP,
@@ -115,109 +164,80 @@
 	};
 /*	printf("new block for %s\n",dir->name);*/
 
-	dir->block=s3d_new_object();
-	s3d_push_vertices(dir->block,vertices,sizeof(vertices)/(3*sizeof(float)));
-	s3d_push_material(dir->block,
+	dir->oid=s3d_new_object();
+	
+	/* draw block outside */
+	s3d_push_vertices(dir->oid,vertices,sizeof(vertices)/(3*sizeof(float)));
+	s3d_push_material(dir->oid,
 						0.5,0.5,0.5,
 						0.5,0.5,0.5,
 						0.5,0.5,0.5
 					);
-	s3d_push_material(dir->block,
+	s3d_push_material(dir->oid,
 						0.5,0.5,0.6,
 						0.5,0.5,0.6,
 						0.5,0.5,0.6);
 
-	s3d_push_polygon(dir->block,4,6,5,1);
-	s3d_push_polygon(dir->block,4,7,6,1);
+	s3d_push_polygon(dir->oid,4,6,5,1);
+	s3d_push_polygon(dir->oid,4,7,6,1);
 
-	s3d_push_polygon(dir->block,0,4,5,0);
-	s3d_push_polygon(dir->block,0,5,1,0);
+	s3d_push_polygon(dir->oid,0,4,5,0);
+	s3d_push_polygon(dir->oid,0,5,1,0);
 	
-	s3d_push_polygon(dir->block,3,7,4,0);
-	s3d_push_polygon(dir->block,3,4,0,0);
+	s3d_push_polygon(dir->oid,3,7,4,0);
+	s3d_push_polygon(dir->oid,3,4,0,0);
 
-	s3d_push_polygon(dir->block,2,6,7,0);
-	s3d_push_polygon(dir->block,2,7,3,0);
+	s3d_push_polygon(dir->oid,2,6,7,0);
+	s3d_push_polygon(dir->oid,2,7,3,0);
 	
-	s3d_push_polygon(dir->block,8,9,10,0);
-	s3d_push_polygon(dir->block,8,10,11,0);
+	s3d_push_polygon(dir->oid,8,9,10,0);
+	s3d_push_polygon(dir->oid,8,10,11,0);
 
-	dir->close=s3d_new_object();
-	s3d_push_material(dir->close,
+	/* draw the select, close buttons ... */
+	dir->objs.close=s3d_new_object();
+	s3d_push_material(dir->objs.close,
 						0.5,0.3,0.3,
 						0.5,0.3,0.3,
 						0.5,0.3,0.3
 					);
-	s3d_push_vertices(dir->close,xvertices,sizeof(xvertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir->close,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
-	s3d_link(dir->close,dir->block);
+	s3d_push_vertices(dir->objs.close,xvertices,sizeof(xvertices)/(3*sizeof(float)));
+	s3d_push_polygons(dir->objs.close,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
+	s3d_link(dir->objs.close,dir->oid);
 	
-	dir->select=s3d_new_object();
-	s3d_push_material(dir->select,
+	dir->objs.select=s3d_new_object();
+	s3d_push_material(dir->objs.select,
 						0.1,0.1,0.3,
 						0.1,0.1,0.3,
 						0.1,0.1,0.3
 					);
-	s3d_push_vertices(dir->select,svertices,sizeof(svertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir->select,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
-	s3d_link(dir->select,dir->block);
+	s3d_push_vertices(dir->objs.select,svertices,sizeof(svertices)/(3*sizeof(float)));
+	s3d_push_polygons(dir->objs.select,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
+	s3d_link(dir->objs.select,dir->oid);
 	
-	dir->title=s3d_new_object();
-	s3d_push_material(dir->title,
+	/* draw the title string */
+	
+	dir->objs.title=s3d_new_object();
+	s3d_push_material(dir->objs.title,
 						0.3,0.3,0.3,
 						0.3,0.3,0.3,
 						0.3,0.3,0.3
 					);
-	s3d_push_vertices(dir->title,tvertices,sizeof(tvertices)/(3*sizeof(float)));
-	s3d_push_polygons(dir->title,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
-	s3d_link(dir->title,dir->block);
-	i=28;
-	fullname[29]=0;
-	d=dir;
-	do {
-		j=strlen(d->name)-1;
-		if (NULL!=(d->parent))
-		{
-			fullname[i]='/';
-			i--;
-		}
-		while ((i >= 0) && (j >= 0))
-		{
-			fullname[i]=d->name[j];
-			j--;
-			i--;
-		}
-		if (i<0) 
-			break;
-
-
-	} while ((d=d->parent)!=NULL);
-	if (i<0)
-		fullname[0]=fullname[1]='.';
-	else 
-		fullname=(char *)fullname+i+1; /* jump to start of the string */
-	dir->titlestr=s3d_draw_string(fullname,&len);
-	if (len>(1.6*5.0))
-		s3d_scale(dir->titlestr,1.6/len);
-	else
-		s3d_scale(dir->titlestr,0.2);
-	s3d_translate(dir->titlestr,-1.0,1.05,1.01);
-	s3d_link(dir->titlestr,dir->block);
+	s3d_push_vertices(dir->objs.title,tvertices,sizeof(tvertices)/(3*sizeof(float)));
+	s3d_push_polygons(dir->objs.title,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
+	s3d_link(dir->objs.title,dir->oid);
+	dots_at_start(fullname,30,dir);
+	dir->objs.titlestr=s3d_draw_string(fullname,&len);
+	if (len>(1.6*5.0))		s3d_scale(dir->objs.titlestr,1.6/len);
+	else					s3d_scale(dir->objs.titlestr,0.2);
+	s3d_translate(dir->objs.titlestr,-1.0,1.05,1.01);
+	s3d_link(dir->objs.titlestr,dir->oid);
 	dir->disp=D_DIR;
 /*	printf("FULLNAME is [%s]\n",fullname);*/
 	return(0);
 }
-int undisplay(t_item *dir)
-{
-	switch (dir->disp)
-	{
-		case D_DIR: return(box_undisplay(dir));break;
-		case D_ICON:return(icon_undisplay(dir));break;
-		default:	return(-1);
-	}
-}
 /* display a directoy on the top of another, draw it's icons etc ... */
-int box_expand(t_item *dir)
+/*
+int box_expand(t_node *dir)
 {
 	int i;
 	float  px,pz;
@@ -228,25 +248,25 @@
 	box_buildblock(dir);
 	if (dir->parent!=NULL)
 		dir->parent->dirs_opened++;
- /* count directories */
+ / * count directories * /
 	dirn=0;
-	for (i=0;i<dir->n_item;i++)
+	for (i=0;i<dir->n_sub;i++)
 	{
-		if (dir->list[i].type==T_FOLDER) dirn++;
+		if (dir->sub[i].type==T_FOLDER) dirn++;
 	}
 
-	/* draw icons, if necceasry */
-	for (i=0;i<dir->n_item;i++)
+	/ * draw icons, if necceasry * /
+	for (i=0;i<dir->n_sub;i++)
 	{
-		if (!dir->list[i].disp)	icon_draw(dir,i);
+		if (!dir->sub[i].disp)	icon_draw(dir,i);
 		else {
-			printf("link %d to the block %d of %s\n",dir->list[i].block,dir->block,dir->name);
-			s3d_link(dir->list[i].block,dir->block); /* if it's already displayed, make sure it linked properly ... */
+			printf("link %d to the block %d of %s\n",dir->sub[i].block,dir->oid,dir->name);
+			s3d_link(dir->sub[i].block,dir->oid); / * if it's already displayed, make sure it linked properly ... * /
 		}
 	}
 	if (dir->parent!=NULL)
 	{
-		s3d_link(dir->block,dir->parent->block);
+		s3d_link(dir->oid,dir->parent->block);
 		dir->dpx=0.0;
 		dir->dpy=BOXHEIGHT;
 		dir->dpz=0.0;
@@ -254,54 +274,48 @@
 		box_position_kids(dir->parent);
 		ani_doit(dir);
 	}
-	for (i=0;i<dir->n_item;i++)
-	{
-		s3d_flags_on(dir->list[i].block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(dir->list[i].str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	}
 	box_sidelabel(dir);
-    s3d_flags_on(dir->block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir->close,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir->title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir->select,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-    s3d_flags_on(dir->titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-	dir->disp=D_DIR;
 	return(0);
 }
-int box_undisplay(t_item *dir)
+
+*/
+int box_undisplay(t_node *dir)
 {
+	/*
 	int i;
-	t_item *par;
+	t_node *par;
 	printf("box_undisplay( %s )\n",dir->name);
-	for (i=0;i<dir->n_item;i++)
+	for (i=0;i<dir->n_sub;i++)
 	{
-		if (dir->list[i].disp==D_ICON)	icon_undisplay(&(dir->list[i]));
-		else if (dir->list[i].disp!=0)	
-				printf("not undisplaying: %s (disp = %d)\n",dir->list[i].name, dir->list[i].disp);
+		if (dir->sub[i].disp==D_ICON)	icon_undisplay(&(dir->sub[i]));
+		else if (dir->sub[i].disp!=0)	
+				printf("not undisplaying: %s (disp = %d)\n",dir->sub[i].name, dir->sub[i].disp);
 	}
-	if ((par=dir->parent)!=NULL) /* we can't do this on root.... */
+	if ((par=dir->parent)!=NULL) / * we can't do this on root.... * /
 	{
 		for (i=0;i<par->n_item;i++)
 			if (&par->list[i]==dir)
 				break;
-		if (i!=par->n_item) /* if it actually was in the parents item list */
+		if (i!=par->n_item) / * if it actually was in the parents item list * /
 		{
 			icon_draw(par,i);
-			s3d_flags_on(dir->block,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_on(dir->str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(dir->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(dir->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 		}
 		par->dirs_opened--;
 	} else {
-		/* we're root ... */
+		/ * we're root ... * /
 		box_dissolve(dir);
 	}
 	printf("[U]ndisplayed %s\n",dir->name);
-/*	dir->dirs_opened=0;*/
+/ * 	dir->dirs_opened=0;* /
 	dir->detached=0;
+	*/
 	return(0);
 }
 /* undisplay a directory, thus recursively removing the kids.*/
-int box_collapse(t_item *dir,int force)
+/*
+int box_collapse(t_node *dir,int force)
 {
 	int i;
 	int ret;
@@ -318,13 +332,13 @@
 		printf("[A]lready undisplayed %s, nothing to do ...\n",dir->name);
 		return(-1);
 	}
-	/* undisplaying kids. ret will be != 0 if any of the kids did not close correctly */
+	/ * undisplaying kids. ret will be != 0 if any of the kids did not close correctly * /
 	ret=0;
-	for (i=0;i<dir->n_item;i++)
-		if (dir->list[i].disp==D_DIR)
-			ret|=box_collapse(&dir->list[i],force);
+	for (i=0;i<dir->n_sub;i++)
+		if (dir->sub[i].disp==D_DIR)
+			ret|=box_collapse(&dir->sub[i],force);
 
-	if (ret && !force) return(ret); /* if anything got wrong, return here ... */
+	if (ret && !force) return(ret); / * if anything got wrong, return here ... * /
 	undisplay(dir);
 	if (dir->parent!=NULL)
 	{
@@ -332,67 +346,67 @@
 	}
 	return(ret);
 }
-/* only display dir and its kids, but nothing below. */
-int box_collapse_grandkids(t_item *dir)
+/ * only display dir and its kids, but nothing below. * /
+int box_collapse_grandkids(t_node *dir)
 {
 	int i,j;
-	t_item *kid;
-	for (i=0;i<dir->n_item;i++)
-		if (dir->list[i].disp==D_DIR)
+	t_node *kid;
+	for (i=0;i<dir->n_sub;i++)
+		if (dir->sub[i].disp==D_DIR)
 		{
-			kid=&dir->list[i];
+			kid=&dir->sub[i];
 			for (j=0;j<kid->n_item;j++)
 			if (kid->list[j].disp==D_DIR)
 				box_collapse(&kid->list[j],0);
 		}
 	return(0);
-}
+}*/
 /* orders the directory objects on top of its parent objects 
  * to be called after adding or removing things ...*/
-void box_position_kids(t_item *dir)
+void box_order_subdirs(t_node *dir)
 {
 	int i,j;
-	printf("box_position_kids( %s ): %d dirs opened\n",dir->name,dir->dirs_opened);
+	printf("box_order_subdirs( %s ): %d dirs opened\n",dir->name,dir->dirs_opened);
 	switch (dir->dirs_opened)
 	{
 		case 0: return;
 		case 1:
-			for (i=0;i<dir->n_item;i++)
+			for (i=0;i<dir->n_sub;i++)
 			{
-				if (dir->list[i].disp==D_DIR)
+				if (dir->sub[i]->disp==D_DIR)
 				{
-					dir->list[i].px=0.0;
-					dir->list[i].py=BOXHEIGHT+dir->list[i].detached*DETHEIGHT;
-					dir->list[i].pz=0.0;
-					dir->list[i].scale=0.2;
-					ani_add(&dir->list[i]);
+					dir->sub[i]->px=0.0;
+					dir->sub[i]->py=BOXHEIGHT+dir->sub[i]->detached*DETHEIGHT;
+					dir->sub[i]->pz=0.0;
+					dir->sub[i]->scale=0.2;
+					ani_add(dir->sub[i]);
 				}
 			}
 			break;
 		default:
 			j=0;
-			for (i=0;i<dir->n_item;i++)
+			for (i=0;i<dir->n_sub;i++)
 			{
-				if (dir->list[i].disp==D_DIR)
+				if (dir->sub[i]->disp==D_DIR)
 				{
-					dir->list[i].px=0.8 * sin(((float)j*2*M_PI)/((float)dir->dirs_opened));
-					dir->list[i].py=BOXHEIGHT+dir->list[i].detached*DETHEIGHT;
-					dir->list[i].pz=0.8 * cos(((float)j*2*M_PI)/((float)dir->dirs_opened));
-					dir->list[i].scale=0.2;
-					ani_add(&dir->list[i]);
+					dir->sub[i]->px=0.8 * sin(((float)j*2*M_PI)/((float)dir->dirs_opened));
+					dir->sub[i]->py=BOXHEIGHT+dir->sub[i]->detached*DETHEIGHT;
+					dir->sub[i]->pz=0.8 * cos(((float)j*2*M_PI)/((float)dir->dirs_opened));
+					dir->sub[i]->scale=0.2;
+					ani_add(dir->sub[i]);
 					j++;
 				}
 
 			}
 	}
 }
-void box_select(t_item *dir)
+void box_select(t_node *dir)
 {
 	dir->detached=dir->detached?0:1; /* swapping, not sure if !dir->detached would do the same .. */
 	if ((dir->type==T_FOLDER) && dir->disp)
 	{
 		if (dir->parent!=NULL)
-			box_position_kids(dir->parent);
+			box_order_subdirs(dir->parent);
 	} else {
 		/* nothing yet ... */
 	}

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2006-09-25 19:56:56 UTC (rev 436)
+++ trunk/apps/s3dfm/dialog.c	2006-09-26 14:54:49 UTC (rev 437)
@@ -1,5 +1,6 @@
 /*
  * dialog.c
+ *
  * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
  *
  * This file is part of s3dfm, a s3d file manager.
@@ -23,141 +24,37 @@
 
 #include "s3dfm.h"
 #include <s3d_keysym.h>
-#include <s3dw.h>
 #include <stdio.h> 	/* NULL, printf() */
 #include <string.h> /* strlen() */
 #include <stdlib.h> /* realloc(),malloc() */
 #include <errno.h>  /* errno */
 #include <sys/stat.h> /* mkdir() */
 #include <sys/types.h> /* mkdir() */
-extern t_item *focus;
-filelist fp={NULL,0};
-int typeinput=0;
-/* keyevent handler */
-void key_handler(struct s3d_evt *evt)
-{
-	struct s3d_key_event *keys=(struct s3d_key_event *)evt->buf;
-	char path[M_DIR];
-	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */	
-			printf("inputting text ...\n");
-			s3dw_handle_key(evt); 
-			return; 
-	}
-	get_path(focus,path);
-	switch (keys->keysym)
-	{
-		case 'i':
-		case 'I':
-				{
-				window_info(path);
-				}
-				break;
-		case 'r':
-		case 'R':
-				{/* refresh this window ... */
-					printf("[R]efreshing %s\n",focus->name);
-					parse_again(focus);
-					ani_focus(focus);
-				}
-				break;
-		case S3DK_F1:
-				window_help();
-				break;
-		case S3DK_F5:
-				window_copy(path);
-				break;
-		case S3DK_F6:
-				window_move(path);
-				break;
-		case S3DK_F7:
-				window_mkdir(path);
-				break;
 
+static s3dw_input	 *input;
+static filelist fp={NULL,0};
 
-	}
-	s3dw_handle_key(evt);
-}
+extern int typeinput;
 
-/* object click handler */
-void object_click(struct s3d_evt *evt)
-{
-	int oid;
-	t_item *f;
-	s3dw_handle_click(evt);
-	oid=(int)*((unsigned long *)evt->buf);
-	if (NULL!=(f=finditem(&root,oid)))
-	{
-		if (f->close==oid)
-		{
-			box_collapse(f,1);
-/*			if (f->parent!=NULL)
-				ani_focus(f->parent);*/
-			return;
-		}
-		if (f->select==oid)
-		{
-			printf("[S]electing %s\n",f->name);
-			box_select(f);
-			return;
-		}
-		if (f->type==T_FOLDER)
-		{
-			if (f->disp == D_DIR)
-			{
-				printf("[F]ound, Already displayed - ani_focus( %s )\n",f->name);
-			} else {
-				if (!f->parsed)	parse_dir(f);
-				box_expand(f);
-			}
-			focus=f;
-			ani_focus(f);
-		} else
-			printf("[F]ound, but %s is no folder\n",f->name);
-	} else {
-/*		printf("[C]ould not find :/\n");*/
-	}
-}
+
 void close_win(s3dw_widget *button)
 {
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 }
-/* add some dots to an integer value for better readability */
-void dotted_int(char *s,unsigned int i)
-{
-	char st[M_DIR];
-	int p;
-	p=0;
-	st[0]=0;
-	while (i>0)
-	{
-		if ((p+1)%4==0) {
-			st[p]='.';
-			p++;
-		}
-		st[p]=(i%10)+'0';
-		i=i/10;
-		p++;
-	}
-	if (p>0) p--;
-	st[p+1]=0;
-	for (i=0;i<p+1;i++)
-		s[i]=st[p-i];
-	s[p+1]=0;
-}
 /* add all selected dirs in the new filelist */
-int get_selected(filelist *fp, t_item *dir)
+int get_selected(filelist *fp, t_node *dir)
 {
 	int i;
 	char *s;
-	for (i=0;i<dir->n_item;i++)
+	for (i=0;i<dir->n_sub;i++)
 	{
-		if (dir->list[i].list!=NULL)	get_selected(fp,&(dir->list[i])); /* scan subdir */
-		if (dir->list[i].detached)
+		if (dir->sub[i]->sub!=NULL)	get_selected(fp,dir->sub[i]); /* scan subdir */
+		if (dir->sub[i]->detached)
 		{
 			fp->n++;
 			fp->p=realloc(fp->p,sizeof(char *) * fp->n);
 			s=malloc(M_DIR);
-			get_path(&(dir->list[i]),s);
+			node_path(dir->sub[i],s);
 			fp->p[fp->n - 1]=s;
 		}
 	}
@@ -255,7 +152,7 @@
 	for (i=0;i<fp.n;i++)
 		s3dw_label_new(infwin,fp.p[i],3,2+i);
 	s3dw_label_new(infwin,"to:",1,fp.n+3);
-	get_path(focus,destdir);
+	node_path(focus,destdir);
 	s3dw_label_new(infwin,destdir,3,fp.n+4);
 
 	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp.n+5);
@@ -266,24 +163,23 @@
 	s3dw_show(S3DWIDGET(infwin));
 
 }
-s3dw_input	 *input;
 void window_fs_mkdir(s3dw_widget *button)
 {
 	char *dir;
-	t_item *item;
+	t_node *item;
 	dir=s3dw_input_gettext(input);
 	printf("creating Directory ...%s\n",dir);
 	if (-1==mkdir(dir,0777)) /* umask ?! */
 		window_fs_errno("could not create directory");
 	else {
 		/* success, now refresh it */
-		item=get_item(dir);
+		item=node_getbypath(dir);
 		if (item==NULL)
 		{
 			printf("cannot refresh\n");
 		} else {
 			printf("refreshing %s\n",item->name);
-			parse_again(item);
+/*			parse_again(item);*/
 
 		}
 				

Added: trunk/apps/s3dfm/event.c
===================================================================
--- trunk/apps/s3dfm/event.c	2006-09-25 19:56:56 UTC (rev 436)
+++ trunk/apps/s3dfm/event.c	2006-09-26 14:54:49 UTC (rev 437)
@@ -0,0 +1,130 @@
+/*
+ * event.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "s3dfm.h"
+#include <s3d_keysym.h>
+#include <stdio.h> /* printf() */
+
+
+
+int typeinput=0;
+
+/* info packets handler, we're just interested in the cam */
+void event_oinfo(struct s3d_evt *hrmz)
+{
+	struct s3d_obj_info *inf;
+	inf=(struct s3d_obj_info *)hrmz->buf;
+	if ((inf->object==0) && (!ani_onstack(&cam)))
+	{
+		cam.dpx=inf->trans_x;
+		cam.dpy=inf->trans_y;
+		cam.dpz=inf->trans_z;
+	}
+	s3dw_object_info(hrmz);
+}
+
+/* keyevent handler */
+void event_key(struct s3d_evt *evt)
+{
+	struct s3d_key_event *keys=(struct s3d_key_event *)evt->buf;
+	char path[M_DIR];
+	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */	
+			printf("inputting text ...\n");
+			s3dw_handle_key(evt); 
+			return; 
+	}
+	node_path(focus,path);
+	switch (keys->keysym)
+	{
+		case 'i':
+		case 'I':
+				{
+				window_info(path);
+				}
+				break;
+		case 'r':
+		case 'R':
+				{/* refresh this window ... */
+					printf("[R]efreshing %s\n",focus->name);
+/*					parse_again(focus);*/
+					ani_focus(focus);
+				}
+				break;
+		case S3DK_F1:
+				window_help();
+				break;
+		case S3DK_F5:
+				window_copy(path);
+				break;
+		case S3DK_F6:
+				window_move(path);
+				break;
+		case S3DK_F7:
+				window_mkdir(path);
+				break;
+
+
+	}
+	s3dw_handle_key(evt);
+}
+
+/* object click handler */
+void event_click(struct s3d_evt *evt)
+{
+	int oid;
+	t_node *f;
+	s3dw_handle_click(evt);
+	oid=(int)*((unsigned long *)evt->buf);
+	if (NULL!=(f=node_getbyoid(&root,oid)))
+	{
+		if (f->objs.close==oid)
+		{
+/*			box_collapse(f,1);*/
+/*			if (f->parent!=NULL)
+				ani_focus(f->parent);*/
+			return;
+		}
+		if (f->objs.select==oid)
+		{
+			printf("[S]electing %s\n",f->name);
+			box_select(f);
+			return;
+		}
+		if (f->type==T_FOLDER)
+		{
+			if (f->disp == D_DIR)
+			{
+				printf("[F]ound, Already displayed - ani_focus( %s )\n",f->name);
+			} else {
+				if (!f->parsed)	parse_dir(f);
+/*				box_expand(f);*/
+			}
+			focus=f;
+			ani_focus(f);
+		} else
+			printf("[F]ound, but %s is no folder\n",f->name);
+	} else {
+/*		printf("[C]ould not find :/\n");*/
+	}
+}
+

Modified: trunk/apps/s3dfm/icon.c
===================================================================
--- trunk/apps/s3dfm/icon.c	2006-09-25 19:56:56 UTC (rev 436)
+++ trunk/apps/s3dfm/icon.c	2006-09-26 14:54:49 UTC (rev 437)
@@ -25,8 +25,8 @@
 #include <stdio.h> 	 /*  printf() */
 #include <math.h>	 /*  sin(),cos() */
 #include <string.h>  /*  strlen() */
-/* draws icon i in the block of dir */
-int icon_draw(t_item *dir,int i)
+/* draws icon dir, which is number i (used for nice coloring) */
+int icon_draw(t_node *dir)
 {
 	float vertices[]={	-1,-0.5,0,
 						-1, 0.5,0,
@@ -44,66 +44,56 @@
 				5,1,0,0,				5,0,4,0	
 				};
 	float len;
-	float d;
-	int dps;
-	printf("icon_draw( %s )\n",dir->list[i].name);
-	dps=ceil(sqrt(dir->n_item)); /* directories per line */
+	printf("icon_draw( %s )\n",dir->name);
 	/* find position for the new block in our directory box */
-	dir->list[i].dpx = dir->list[i].px=-1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
-	dir->list[i].dpy = dir->list[i].py=0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
-	dir->list[i].dpz = dir->list[i].pz=1.0;
-	dir->list[i].scale = dir->list[i].dscale = (float)1.0/((float)dps);
 	/* create the block */
-	box_dissolve(&(dir->list[i]));
-	dir->list[i].block=s3d_new_object();
-	s3d_push_vertices(dir->list[i].block,vertices,8);
-	d=((int)(((i+(dps+1)%2*(i/dps)))%2))*0.2;
-	switch (dir->list[i].type)
+	dir->oid=s3d_new_object();
+	s3d_push_vertices(dir->oid,vertices,8);
+	switch (dir->type)
 	{
 		case T_FOLDER:
-			s3d_push_material(dir->list[i].block,
-									0.4-d,0.4-d,0,
-									0.4-d,0.4-d,0,
-									0.4-d,0.4-d,0);
+			s3d_push_material(dir->oid,
+									0.4,0.4,0,
+									0.4,0.4,0,
+									0.4,0.4,0);
 			break;
 		default:
-			s3d_push_material(dir->list[i].block,
-									0,0,0.5-d,
-									0,0,0.5-d,
-									0,0,0.5-d);
+			s3d_push_material(dir->oid,
+									0,0,0.5,
+									0,0,0.5,
+									0,0,0.5);
 	};
-	s3d_push_polygons(dir->list[i].block,polys,10);
-	s3d_link(dir->list[i].block,dir->block);
+	s3d_push_polygons(dir->oid,polys,10);
 
 	/* draw and position the string */
-	if (dir->list[i].str==-1)
+	if (dir->objs.str==-1)
 	{
-		dir->list[i].str=s3d_draw_string(dir->list[i].name,&len);
+		dir->objs.str=s3d_draw_string(dir->name,&len);
 		if (len<2) len=2;
-		dir->list[i].len=len;
+		dir->len=len;
 	}
 	else 
-		len=dir->list[i].len;
-	s3d_scale(dir->list[i].str,(float)1.8/len);
-	s3d_translate(dir->list[i].str,-0.9,-0.3,0.1);
-	s3d_rotate(dir->list[i].str,0,0,0);
-	s3d_link(dir->list[i].str,dir->list[i].block);
-	ani_finish(&dir->list[i],-1); /* apply transformation */
-	dir->list[i].disp=D_ICON;
+		len=dir->len;
+	s3d_scale(dir->objs.str,(float)1.8/len);
+	s3d_translate(dir->objs.str,-0.9,-0.3,0.1);
+	s3d_rotate(dir->objs.str,0,0,0);
+	s3d_link(dir->objs.str,dir->oid);
+
+	dir->disp=D_ICON;
 	return(0);
 }
-int icon_undisplay(t_item *dir)
+int icon_undisplay(t_node *dir)
 {
 	printf("icon_undisplay( %s )\n",dir->name);
-	if (dir->block!=-1)
+	if (dir->oid!=-1)
 	{
-		s3d_del_object(dir->block);
-		dir->block=-1;
+		s3d_del_object(dir->oid);
+		dir->oid=-1;
 	}
-	if (dir->str!=-1)
+	if (dir->objs.str!=-1)
 	{
-		s3d_del_object(dir->str);
-		dir->str=-1;
+		s3d_del_object(dir->objs.str);
+		dir->objs.str=-1;
 	}
 	dir->disp=0;
 	return(0);

Modified: trunk/apps/s3dfm/main.c
===================================================================
--- trunk/apps/s3dfm/main.c	2006-09-25 19:56:56 UTC (rev 436)
+++ trunk/apps/s3dfm/main.c	2006-09-26 14:54:49 UTC (rev 437)
@@ -23,117 +23,11 @@
 
 
 #include "s3dfm.h"
-#include <s3dw.h>	 /* s3dw_ani_mate() */
-#include <stdio.h> 	 /*  printf() */
-#include <dirent.h>  /*  dirent */
-#include <stdlib.h>	 /*  malloc() */
 #include <string.h>  /*  strlen(), strncmp(), strrchr() */
 #include <time.h>	/* nanosleep() */
 static struct timespec t={0,33*1000*1000}; 
-t_item root,cam,*focus;
+t_node root,cam,*focus;
 
-/* save concatting 2 strings, this version takes argument n
- * as the size of the buffer of dest. */
-char *mstrncat(char *dest, const char *src, int n)
-{
-	int i,j;
-	dest[n-1]=0;						/* for malformed destinations */
-	j=0;
-	for (i=strlen(dest);i<(n-1);i++)
-	{
-		dest[i]=src[j]; 
-		if (dest[i]==0) break;
-		j++;
-	}
-	for (;i<n;i++)
-		dest[i]=0; /* pad the rest with zero */
-	return(dest);
-}
-/* same as strncpy, but have a terminating zero even if
- * source is too big */
-char *mstrncpy(char *dest, const char *src, int n)
-{
-	strncpy(dest,src,n);
-	dest[n-1]=0;
-	return(dest);
-}
-/* writes the path of dir into *path. path should be of type path[M_DIR] */
-void get_path(t_item *dir, char *path)
-{
-	if (dir->parent!=NULL)
-	{
-		get_path(dir->parent,path);
-		mstrncat(path,dir->name,M_DIR);
-		mstrncat(path,"/",M_DIR);
-	} else
-		mstrncpy(path,dir->name,M_DIR);
-}
-/* find the item to a path, return NULL if not parsed yet */
-t_item *get_item(char *path)
-{
-	char p[M_DIR];
-	char *s,*match;
-	t_item *cur;
-	int i;
-	
-	if (path==NULL) return NULL;
-	if (path[0]=='/')
-	{
-		strncpy(p,path,M_DIR);
-		s=p+1;
-		cur=&root;
-	} else return NULL; /* TODO: also process local paths. right now, we are to lazy */
-	printf("processing rest of string %s\n",s);
-	match=s;
-	while ((s=index(s,'/'))!=NULL) { /* while we have slashes inside */
-		s[0]=0; /* mark the slash with space */
-		s++;	/* move to the next */
-		/* parse ... */
-		printf("looking for a match for %s\n",match);
-		for (i=0;i<cur->n_item;i++)
-			if (0==strcmp(cur->list[i].name,match))
-			{ /* found !! */
-				cur=&(cur->list[i]); /* forward */
-				match=s; /* select next */
-				break;
-			}
-		if (i==cur->n_item) {
-			printf("found no match for %s :(\n",match);
-			return NULL; /* not found */
-		}
-	}
-	return(cur);
-}
-/* finds an item in the tree by oid */
-t_item *finditem(t_item *t, int oid)
-{
-	int i;
-	t_item *f;
-	if (t->block==oid)		return(t);
-	if (t->str==oid)		return(t);
-	if (t->close==oid)		return(t);
-	if (t->select==oid)		return(t);
-	if (t->title==oid)		return(t);
-	if (t->titlestr==oid)	return(t);
-	if (t->type==T_FOLDER)
-		for (i=0;i<t->n_item;i++)
-			if ((f=finditem(&(t->list[i]),oid))!=NULL)
-				return(f);
-	return(NULL);
-}
-/* info packets handler, we're just interested in the cam */
-void object_info(struct s3d_evt *hrmz)
-{
-	struct s3d_obj_info *inf;
-	inf=(struct s3d_obj_info *)hrmz->buf;
-	if ((inf->object==0) && (!ani_onstack(&cam)))
-	{
-		cam.dpx=inf->trans_x;
-		cam.dpy=inf->trans_y;
-		cam.dpz=inf->trans_z;
-	}
-	s3dw_object_info(hrmz);
-}
 void mainloop()
 {
 	ani_mate();
@@ -143,29 +37,26 @@
 int main (int argc, char **argv)
 {
 
-	s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
-	s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
-	s3d_set_callback(S3D_EVENT_KEY,key_handler);
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK,event_click);
+	s3d_set_callback(S3D_EVENT_OBJ_INFO,event_oinfo);
+	s3d_set_callback(S3D_EVENT_KEY,event_key);
 	if (!s3d_init(&argc,&argv,"s3dfm"))	
 	{
 		s3d_select_font("vera");
 
-		
+		node_init(&cam); /* a virtual object, just to push the cam throu our animation stack */
+		cam.oid=0;
 		/* set up file system representation */
 		node_init(&root);
 		strncpy(root.name,"/",M_NAME);
 		focus=&root;
 		root.dscale=0.1;
 		root.type=T_FOLDER;
-		root.str=s3d_draw_string(root.name,&root.len);
-		if (root.len<2) root.len=2;
 		parse_dir(&root);
-		box_expand(&root);
+		box_draw(&root);
 		ani_doit(&root);
 		ani_focus(&root);
 		
-		node_init(&cam); /* a virtual object, just to push the cam throu our animation stack */
-		cam.block=0;
 		
 		
 		s3d_mainloop(mainloop);

Added: trunk/apps/s3dfm/node.c
===================================================================
--- trunk/apps/s3dfm/node.c	2006-09-25 19:56:56 UTC (rev 436)
+++ trunk/apps/s3dfm/node.c	2006-09-26 14:54:49 UTC (rev 437)
@@ -0,0 +1,151 @@
+/*
+ * node.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "s3dfm.h"
+#include <string.h>	/* strncpy(), index() */
+#include <stdio.h>	/* printf() */
+/* find the node to a path, return NULL if not parsed yet */
+t_node *node_getbypath(char *path)
+{
+	char p[M_DIR];
+	char *s,*match;
+	t_node *cur;
+	int i;
+	
+	if (path==NULL) return NULL;
+	if (path[0]=='/')
+	{
+		strncpy(p,path,M_DIR);
+		s=p+1;
+		cur=&root;
+	} else return NULL; /* TODO: also process local paths. right now, we are to lazy */
+	printf("processing rest of string %s\n",s);
+	match=s;
+	while ((s=index(s,'/'))!=NULL) { /* while we have slashes inside */
+		s[0]=0; /* mark the slash with space */
+		s++;	/* move to the next */
+		/* parse ... */
+		printf("looking for a match for %s\n",match);
+		for (i=0;i<cur->n_sub;i++)
+			if (0==strcmp(cur->sub[i]->name,match))
+			{ /* found !! */
+				cur=cur->sub[i]; /* forward */
+				match=s; /* select next */
+				break;
+			}
+		if (i==cur->n_sub) {
+			printf("found no match for %s :(\n",match);
+			return NULL; /* not found */
+		}
+	}
+	return(cur);
+}
+/* finds an node in the tree by oid */
+t_node *node_getbyoid(t_node *t, int oid)
+{
+	int i;
+	t_node *f;
+	if (t->oid==oid)			return(t);
+	if (t->objs.str==oid)		return(t);
+	if (t->objs.close==oid)		return(t);
+	if (t->objs.select==oid)	return(t);
+	if (t->objs.title==oid)		return(t);
+	if (t->objs.titlestr==oid)	return(t);
+	if (t->type==T_FOLDER)
+		for (i=0;i<t->n_sub;i++)
+			if ((f=node_getbyoid(t->sub[i],oid))!=NULL)
+				return(f);
+	return(NULL);
+}
+/* writes the path of dir into *path. path should be of type path[M_DIR] */
+void node_path(t_node *dir, char *path)
+{
+	if (dir->parent!=NULL)
+	{
+		node_path(dir->parent,path);
+		mstrncat(path,dir->name,M_DIR);
+		mstrncat(path,"/",M_DIR);
+	} else
+		mstrncpy(path,dir->name,M_DIR);
+}
+/* clear the node */
+int node_init(t_node *dir)
+{
+	dir->parent=NULL;
+	dir->sub=NULL;
+	dir->n_sub=0;
+
+	dir->oid=-1;
+	dir->objs.str=-1;
+	dir->objs.close=-1;
+	dir->objs.select=-1;
+	dir->objs.title=-1;
+	dir->objs.titlestr=-1;
+
+	dir->len=0;
+	dir->disp=0;
+	dir->parsed=0;
+
+	dir->px=root.pz=0.0;
+	dir->dirs_opened=0;
+	dir->type=T_DUNO;
+	dir->px=dir->py=dir->pz=0.0;
+	dir->dpx=dir->dpy=dir->dpz=0.0;
+	dir->scale=dir->dscale=1.0;
+	dir->detached=0;
+
+	return(0);
+}
+/* general undisplay routine. does not handle anything recursively... */
+int node_undisplay(t_node *dir)
+{
+	switch (dir->disp)
+	{
+		case D_DIR: return(box_undisplay(dir));break;
+		case D_ICON:return(icon_undisplay(dir));break;
+		default:	return(-1);
+	}
+	dir->disp=0;
+}
+
+/* delete a node and all its kids internally, remove the graphics, reorder the parents etc ... */
+int node_delete(t_node *dir)
+{
+	/* TODO: IMPLEMENT IT, DAMNIT */
+	/*
+	int i;
+	printf("node_free( %s )\n",t->name);
+	switch (t->disp)
+	{
+			case D_DIR:  box_collapse(t,1); / * collapse this and its kids * /
+			case D_ICON: icon_undisplay(t);
+	}
+	if (t->n_item>0) {
+		for (i=0;i<t->n_item;i++)
+			node_free(&(t->sub[i]));
+		free(t->sub);
+	}
+	t->n_item=0;
+	*/
+	return(0);
+}

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2006-09-25 19:56:56 UTC (rev 436)
+++ trunk/apps/s3dfm/parse.c	2006-09-26 14:54:49 UTC (rev 437)
@@ -23,167 +23,93 @@
 
 
 #include "s3dfm.h"
-#include <s3dw.h>	 /* s3dw_ani_mate() */
-#include <stdio.h> 	 /*  printf() */
+#include <stdio.h>   /*  printf() */
 #include <dirent.h>  /*  dirent */
-#include <stdlib.h>	 /*  malloc() */
 #include <string.h>  /*  strlen(), strncmp(), strrchr() */
-#include <time.h>	/* nanosleep() */
+#include <stdlib.h>	 /*  realloc () */
 
 
-/* clear the dirs attributes */
-int node_init(t_item *dir)
+int parse_dir(t_node *dir)
 {
-	dir->parent=NULL;
-	dir->list=NULL;
-	dir->n_item=-1;
-
-	dir->block=-1;
-	dir->str=-1;
-	dir->close=-1;
-	dir->select=-1;
-	dir->title=-1;
-	dir->titlestr=-1;
-
-	dir->len=0;
-	dir->disp=0;
-	dir->parsed=0;
-
-	dir->px=root.pz=0.0;
-	dir->dirs_opened=0;
-	dir->type=T_DUNO;
-	dir->px=dir->py=dir->pz=0.0;
-	dir->dpx=dir->dpy=dir->dpz=0.0;
-	dir->scale=dir->dscale=1.0;
-	dir->detached=0;
-
-	return(0);
-}
-int parse_dir(t_item *dir)
-{
-	t_item *list;
 	struct dirent **namelist;
 	int n,i;
-	char *ext,*nstr;
+	int oldn;
+	DIR	 *dirhd=NULL;
+	char *ext,*nstr=NULL;
 	char path[M_DIR];
 	char ndir[M_DIR]; 
 	
-	printf("parse_dir( %s )",dir->name);
-/*	if (dir->parsed) return(-1);*/
-	get_path(dir,path);
-/*	printf("scanning %s\n",path);*/
+	printf("parse_dir( %s )\n",dir->name);
+	node_path(dir,path);
+	for (i=0;i<dir->n_sub;i++)
+	{
+		dir->sub[i]->check=1;
+	}
     n = i = scandir(path, &namelist, 0, alphasort);
-	
     if (n < 0)
 	{
         perror("scandir");
 		return(-1);
 	} else {
-		list=malloc(sizeof(t_item)*i);
-		dir->list=list;
-		dir->n_item=n;
+		oldn=dir->n_sub;
         while(n--) {
-			/* setup kids in the list */
-			node_init(&list[n]);
-			nstr=namelist[n]->d_name;
-			strncpy(list[n].name,nstr,M_NAME);
- 		    if ((0==strncmp(nstr,".",1)) && (strlen(nstr)==1))
-				list[n].type=T_LOCALDIR;
-			else if (0==strncmp(nstr,"..",strlen(nstr)<2?strlen(nstr):2))
-			   list[n].type=T_BACKDIR;
-			else {
-				ext=strrchr(nstr,'.');
-				strncpy(ndir,path,M_DIR);
-		    	strncat(ndir,namelist[n]->d_name,M_DIR);
-			    if ((namelist[n]->d_type==DT_DIR) ||
-					((namelist[n]->d_type==DT_UNKNOWN) && (opendir(ndir)!=NULL)))
-						list[n].type=T_FOLDER;
-				else 
-				{
-				   if (ext!=NULL)
-				   {
-					   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))
-							   list[n].type=T_GEOMETRY;
-					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))
-							   list[n].type=T_MUSIC;
-				   }
+			nstr = namelist[n]->d_name;
+			/* setup kids in the sub */
+			for (i=0;i<oldn;i++) /* see if it's already there */
+				if (dir->sub[i])
+				if (0==strcmp(namelist[n]->d_name,dir->sub[n]->name))
+					break;
+ 		    if ((0!=strcmp(nstr,".")) && (0!=strcmp(nstr,".."))) /* we don't care about those */
+			{
+				if (i==oldn)
+				{	/* it's new, add it, initialize it ... */
+					i=dir->n_sub;
+					/* i now holds the right index in sub, so we use dir->sub[i] 
+					 * to reference the new item now... */
+					dir->n_sub++;
+					dir->sub = realloc( dir->sub , dir->n_sub * sizeof(t_node *) );
+					dir->sub[i] = malloc(sizeof(t_node));
+					node_init(dir->sub[i]);
+					strncpy(dir->sub[i]->name,nstr,M_NAME);
+					dir->sub[i]->parent = dir;
 				}
+				/* find out the filetype ... very simple */
+				else {
+					ext=strrchr(nstr,'.');
+					strncpy(ndir,path,M_DIR);
+			    	strncat(ndir,namelist[n]->d_name,M_DIR);
+				    if ((namelist[n]->d_type==DT_DIR) ||
+						((namelist[n]->d_type==DT_UNKNOWN) && ((dirhd=opendir(ndir))!=NULL)))
+						{
+							dir->sub[i]->type=T_FOLDER;
+							closedir(dirhd);
+						}
+					else 
+					{
+					   if (ext!=NULL)
+					   {
+						   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))		   dir->sub[i]->type=T_GEOMETRY;
+						   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))	   dir->sub[i]->type=T_MUSIC;
+					   }	
+					}
+				}
+	
+				dir->sub[i]->check=0;
 			}
-			list[n].parent=dir;
-        	free(namelist[n]);
+	   	    free(namelist[n]);
 		}
 		free(namelist);
+		for (i=0;i<dir->n_sub;i++)
+			if (dir->sub[i]->check) 
+			/* not checked yet... that means the item is not in the reparsed directory, ie vanished.
+			 * so we're removing it from our queue */
+			{
+				node_delete(dir->sub[i]);
+				dir->n_sub--;
+				dir->sub[i]=dir->sub[dir->n_sub]; /* exchange with the last one */
+			}
 		dir->parsed=1;
    	}
 	return(0);
 }
-void parse_again(t_item *dir)
-{
-	int oldn,redisp;
-	t_item *oldlist;
-	int i,j;
-	oldlist=dir->list;
-	oldn   =dir->n_item;
-	redisp=0;
-	printf("parse_again( %s )\n",dir->name);
-	if (dir->disp==D_DIR)	/* undisplay it later */
-	{ 
-		box_undisplay(dir); 
-		redisp=1; 
-	}
-	parse_dir(dir);
 
-	printf("oldn = %d\n",oldn);
-	if (oldn>0)
-	{
-		/* find old, already displayed contents, and copy the data, or remove them if 
-		 * deleted */
-		
-		for (i=0;i<oldn;i++)
-		{
-			if (oldlist[i].disp == D_DIR)	/* old things expanded as directory */
-			{
-				/* see if it's also in the new list */
-				for (j=0;j<dir->n_item;j++)
-				{
-					if (0==strcmp(oldlist[i].name,dir->list[j].name))
-					{
-						printf("we still have %s - %s (%d,%d) , copy to new list ... \n",dir->list[j].name, oldlist[i].name,j,i);
-						memcpy(&(dir->list[j]),&oldlist[i],sizeof(t_item));
-						break; /* found */
-					}
-				}
-				if (j == dir->n_item) /* not found, collapse it */
-					node_free(&oldlist[i]);
-				else {}/* don't collapse it!! keep as it is */
-			} else node_free(&oldlist[i]);
-		}
-		free(oldlist);
-
-		printf("finished copying old content, redisplay if neccesary\n");
-		if (redisp)
-		{
-			printf("redisplay ... (opened: %d) ", dir->dirs_opened);
-			/* if it was displayed, redisplay it ... */
-			box_expand(dir);
-			printf("done (opened: %d)\n", dir->dirs_opened);
-		}
-	}	
-}
-void node_free(t_item *t)
-{
-	int i;
-	printf("node_free( %s )\n",t->name);
-	switch (t->disp)
-	{
-			case D_DIR:  box_collapse(t,1); /* collapse this and its kids */
-			case D_ICON: icon_undisplay(t);
-	}
-	if (t->n_item>0) {
-		for (i=0;i<t->n_item;i++)
-			node_free(&(t->list[i]));
-		free(t->list);
-	}
-	t->n_item=0;
-}
-

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2006-09-25 19:56:56 UTC (rev 436)
+++ trunk/apps/s3dfm/s3dfm.h	2006-09-26 14:54:49 UTC (rev 437)
@@ -23,6 +23,7 @@
 
 
 #include <s3d.h>
+#include <s3dw.h>
 #define T_DUNO		0
 #define T_LOCALDIR	1
 #define T_BACKDIR	2
@@ -45,82 +46,102 @@
 #define ZOOMS 		10
 /* zoomspeed */
 
-struct _t_item {
-	int str,close,select,title,titlestr;	/* object ids ...*/
-	int block;								/* oid of the block */
-	int dirs_opened;						/* how many directories are on the block */
-	int detached;							/* if it's detached ... */
-	char name[M_NAME];						/* name (e.g. file name) */
-	float len;
-	struct _t_item *parent;					/* parent item */
-	struct _t_item *list;					/* list of items  (if it's a subdir)*/
-	float px ,py ,pz ,scale;				/* state after animation */
-	float dpx,dpy,dpz,dscale;				/* current state in animation */
-	int n_item;								/* number of items in list ( = -1 for normal or not-expanded files) */
-	int type;								/* type, determined by extension or file type like dir, pipe, link etc */
-	int disp,parsed;						/* Flags for displayed/parsed items ... */
-#define D_ICON	1
-#define D_DIR	2
+struct _t_node {
+	char 			 name[M_NAME];						/* name (e.g. file name) */
+	struct _t_node 	*parent;							/* parent node */
+	struct _t_node 	**sub;								/* list of nodes  (if it's a subdir)*/
+	int 			 n_sub;								/* number of nodes in list ( = -1 for normal or not-expanded files) */
+	int 			 dirs_opened;						/* how many dirs are opened/displayed */
+	float 			 px ,py ,pz ,scale;					/* state after animation */
+	float 			 dpx,dpy,dpz,dscale;				/* current state in animation */
+	int 			 type;								/* type, determined by extension or file type like dir, pipe, link etc */
+	int 			 disp;								/* the type of how the node is displayed currently */
+#define D_NONE		0
+#define D_ICON		1
+#define D_DIR		2
+	int				 parsed,detached;					/* Flags for parsed/detached (selected) nodes ... */
+	int 			 oid;								/* main oid, e.g the block or icons oid */
+	float 			 len;								/* lenght ... TODO: of what? */
+	struct 			 {	
+		/* some objects which might be used ... if not, should be -1 */
+		int 		 close,select,title,titlestr; /* box decorations. */
+		int 		 str;						  
+		
+	} 				 objs;
+	int 			 check;							    /* check marker, for internal things */
 };
 struct _filelist {
 	char **p;
 	int n;
 };
 typedef struct _filelist filelist;
-typedef struct _t_item   t_item;
+typedef struct _t_node   t_node;
 
 
-extern t_item root;
-/* main.c */
-void get_path(t_item *dir, char *path);
-t_item *get_item(char *path);
-t_item *finditem(t_item *t, int oid);
-void mainloop();
-/* parse.c */
-int node_init(t_item *dir);
-void node_free(t_item *t);
-int parse_dir(t_item *dir);
-void parse_again(t_item *t);
+extern t_node root,cam; /* some global objects */
+extern t_node *focus;	/* the focused object */
+
+/* node.c */
+t_node 		*node_getbypath(char *path);
+void 		 node_path(t_node *dir, char *path);
+t_node 		*node_getbyoid(t_node *t, int oid);
+int 		 node_init(t_node *dir);
+int 		 node_delete(t_node *dir);
+int 		 node_undisplay(t_node *dir);
 /* animation.c */
-float ani_get_scale(t_item *f);
-void ani_focus(t_item *f);
-void ani_mate();
-void ani_add(t_item *f);
-void ani_del(int i);
-void ani_doit(t_item *f);
-void ani_finish(t_item *f, int i);
-void ani_iterate(t_item *f);
-int ani_check(t_item *f);
-int ani_onstack(t_item *f);
+float		 ani_get_scale(t_node *f);
+void 		 ani_focus(t_node *f);
+int 		 ani_onstack(t_node *f);
+void 		 ani_add(t_node *f);
+void 		 ani_del(int i);
+void 		 ani_doit(t_node *f);
+void 		 ani_finish(t_node *f, int i);
+void 		 ani_iterate(t_node *f);
+int 		 ani_check(t_node *f);
+void 		 ani_mate();
+/* event.c */
+void 		 event_click(struct s3d_evt *evt);
+void		 event_key(struct s3d_evt *evt);
+void		 event_oinfo(struct s3d_evt *hrmz);
 /* box.c */
-int box_collapse(t_item *dir,int force);
-int box_collapse_grandkids(t_item *dir);
-int box_expand(t_item *dir);
-int box_buildblock(t_item *dir);
-void box_dissolve(t_item *dir);
-int  box_undisplay(t_item *dir);
-void box_sidelabel(t_item *dir);
-void box_position_kids(t_item *dir);
-void box_select(t_item *dir);
+void	 	 box_draw(t_node *dir);
+void 	 	 box_draw_icons(t_node *dir);
+int 		 box_undisplay(t_node *dir);
+void  		 box_order_icons(t_node *dir);
+void	 	 box_sidelabel(t_node *dir);
+int 		 box_buildblock(t_node *dir);
+void		 box_select(t_node *dir);
+void 		 box_order_subdirs(t_node *dir);
+/* parse.c */
+int 		 parse_dir(t_node *dir);
 /* icon.c */
-int icon_draw(t_item *dir,int i);
-int icon_undisplay(t_item *dir);
+int 		 icon_draw(t_node *dir);
+int 		 icon_undisplay(t_node *dir);
+/* dialog.c */
+void		 close_win(s3dw_widget *button);
+void		 window_help();
+void		 window_fs_another();
+void		 window_fs_nothing();
+void		 window_fs_errno(char *errmsg);
+void		 window_fs_abort(s3dw_widget *button);
+void		 window_copy(char *path);
+void		 window_fs_mkdir(s3dw_widget *button);
+void		 window_mkdir(char *path);
+void		 window_move(char *path);
+void		 window_info(char *path);
+/* string.c */
+void 		 dots_at_start(char *s, unsigned int n, t_node *d);
+void		 dotted_int(char *s,unsigned int i);
+char		 *mstrncat(char *dest, const char *src, int n);
+char		 *mstrncpy(char *dest, const char *src, int n);
 /* fs.c */
-filelist *fl_new(char *path);
-void fl_del(filelist *fl);
-int fs_copy(char *source, char *dest);
-int fs_move(char *source, char *dest);
-int fs_unlink(char *dest);
-void fs_approx(char *source, int *files, int *dirs, int *bytes);
-int fs_fl_copy(filelist *fl, char *dest);
-int fs_fl_move(filelist *fl, char *dest);
-int fs_fl_unlink(filelist *fl);
-void fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes);
-/* dialog.c */
-void key_handler(struct s3d_evt *evt);
-void object_click(struct s3d_evt *evt);
-void window_info(char *path);
-void window_help();
-void window_copy(char *path);
-void window_move(char *path);
-void window_mkdir(char *path);
+filelist	 *fl_new(char *path);
+void		 fl_del(filelist *fl);
+void	 	 fs_fl_approx(filelist *fl, int *files, int *dirs, int *bytes);
+int			 fs_fl_copy(filelist *fl, char *dest);
+int			 fs_fl_move(filelist *fl, char *dest);
+int			 fs_fl_unlink(filelist *fl);
+void	 	 fs_approx(char *source, int *files, int *dirs, int *bytes);
+int			 fs_copy(char *source, char *dest);
+int			 fs_move(char *source, char *dest);
+int			 fs_unlink(char *dest);

Added: trunk/apps/s3dfm/string.c
===================================================================
--- trunk/apps/s3dfm/string.c	2006-09-25 19:56:56 UTC (rev 436)
+++ trunk/apps/s3dfm/string.c	2006-09-26 14:54:49 UTC (rev 437)
@@ -0,0 +1,100 @@
+/*
+ * string.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include "s3dfm.h"
+#include <string.h> /* strlen(), strncpy() */
+/* writes the path of the item d in string s with bufferlength n, 
+ * adds some dots to the beginning if its too long */ 
+void dots_at_start(char *s, unsigned int n, t_node *d)
+{
+	int i,j;
+	i=n-2;
+	s[n-1]=0;
+	do {
+		j=strlen(d->name)-1;
+		if (NULL!=(d->parent))
+		{
+			s[i]='/';
+			i--;
+		}
+		while ((i >= 0) && (j >= 0))
+		{
+			s[i]=d->name[j];
+			j--;
+			i--;
+		}
+		if (i<0) 
+			break;
+	} while ((d=d->parent)!=NULL);
+	if (i<0)			s[0]=s[1]='.';
+	else 				s=(char *)s+i+1; /* jump to start of the string */
+
+}
+/* add some dots to an integer value for better readability */
+void dotted_int(char *s,unsigned int i)
+{
+	char st[M_DIR];
+	int p;
+	p=0;
+	st[0]=0;
+	while (i>0)
+	{
+		if ((p+1)%4==0) {
+			st[p]='.';
+			p++;
+		}
+		st[p]=(i%10)+'0';
+		i=i/10;
+		p++;
+	}
+	if (p>0) p--;
+	st[p+1]=0;
+	for (i=0;i<p+1;i++)
+		s[i]=st[p-i];
+	s[p+1]=0;
+}
+/* save concatting 2 strings, this version takes argument n
+ * as the size of the buffer of dest. */
+char *mstrncat(char *dest, const char *src, int n)
+{
+	int i,j;
+	dest[n-1]=0;						/* for malformed destinations */
+	j=0;
+	for (i=strlen(dest);i<(n-1);i++)
+	{
+		dest[i]=src[j]; 
+		if (dest[i]==0) break;
+		j++;
+	}
+	for (;i<n;i++)
+		dest[i]=0; /* pad the rest with zero */
+	return(dest);
+}
+/* same as strncpy, but have a terminating zero even if
+ * source is too big */
+char *mstrncpy(char *dest, const char *src, int n)
+{
+	strncpy(dest,src,n);
+	dest[n-1]=0;
+	return(dest);
+}
+



From dotslash at mail.berlios.de  Tue Sep 26 18:16:23 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 26 Sep 2006 18:16:23 +0200
Subject: [S3d-svn] r438 - in trunk: . apps/s3dfm
Message-ID: <200609261616.k8QGGNkk020695@sheep.berlios.de>

Author: dotslash
Date: 2006-09-26 18:16:22 +0200 (Tue, 26 Sep 2006)
New Revision: 438

Modified:
   trunk/
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/event.c
   trunk/apps/s3dfm/icon.c
   trunk/apps/s3dfm/node.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dfm/s3dfm.h
Log:
 r1063 at balthasar:  dotslash | 2006-09-26 18:16:18 +0200
 - rewrite almost as functional as original ...



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1061
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1063

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2006-09-26 14:54:49 UTC (rev 437)
+++ trunk/apps/s3dfm/animation.c	2006-09-26 16:16:22 UTC (rev 438)
@@ -66,6 +66,7 @@
 	printf("px: %f py:%f pz: %f\n",root.px,root.py,root.pz);*/
 
 	ani_add(&root);
+	focus=f;
 	if (((cam.dpx-cam.px)* (cam.dpx-cam.px) + (cam.dpy-cam.py)* (cam.dpy-cam.py) 
 		  + (cam.dpz-cam.pz)* (cam.dpz-cam.pz))	> ( 10 * 10))
 	{

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2006-09-26 14:54:49 UTC (rev 437)
+++ trunk/apps/s3dfm/box.c	2006-09-26 16:16:22 UTC (rev 438)
@@ -30,6 +30,7 @@
 {
 	box_buildblock(dir);
 	box_sidelabel(dir);
+	ani_doit(dir);
     s3d_flags_on(dir->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
     s3d_flags_on(dir->objs.close,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
     s3d_flags_on(dir->objs.title,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
@@ -50,47 +51,8 @@
 	}
 	box_order_icons(dir);
 }
-/* order the icons properly */
-void box_order_icons(t_node *dir)
-{
-	int dps,i;
-	dps=ceil(sqrt(dir->n_sub)); /* directories per line */
-	for (i=0;i<dir->n_sub;i++)
-	{
-		printf("ordering icon %s\n",dir->sub[i]->name);
-		dir->sub[i]->dpx = -1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
-		dir->sub[i]->dpy = 0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
-		dir->sub[i]->dpz = 1.0;
-		dir->sub[i]->scale = (float)1.0/((float)dps);
-		dir->sub[i]->dscale = 0.001;
-		dir->sub[i]->dpx = 0;
-		dir->sub[i]->dpy = 0;
-		dir->sub[i]->dpz = 1;
-		/* make a first setup so there is no flickering */
-		s3d_link(dir->sub[i]->oid,dir->oid); /* if it's already displayed, make sure it linked properly ... */
-		ani_doit(dir->sub[i]);
-		ani_add(dir->sub[i]); /* apply transformation */
-		s3d_flags_on(dir->sub[i]->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(dir->sub[i]->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 
-		
-	}
-}
 
-/* remove old items on the box */
-/*
-void box_dissolve(t_node *dir)
-{
-	if (dir->objs.close!=-1)		{	s3d_del_object(dir->objs.close);		dir->objs.close=-1; }
-	if (dir->objs.select!=-1)	{	s3d_del_object(dir->objs.select);	dir->objs.select=-1; }
-	if (dir->objs.title!=-1)		{	s3d_del_object(dir->objs.title);		dir->objs.title=-1; }
-	if (dir->objs.titlestr!=-1)	{	s3d_del_object(dir->objs.titlestr);	dir->objs.titlestr=-1; }
-	if (dir->oid!=-1)			s3d_del_object(dir->oid);
-
-}*/
-
-
-
 /* places the string at the left side of the cube */
 void box_sidelabel(t_node *dir)
 {
@@ -178,21 +140,44 @@
 						0.5,0.5,0.6,
 						0.5,0.5,0.6);
 
+	/* top */
 	s3d_push_polygon(dir->oid,4,6,5,1);
 	s3d_push_polygon(dir->oid,4,7,6,1);
+	/* bottom */
+	s3d_push_polygon(dir->oid,8,11,3,1);
+	s3d_push_polygon(dir->oid,8,3,0,1);
 
+
+	/* left */
 	s3d_push_polygon(dir->oid,0,4,5,0);
 	s3d_push_polygon(dir->oid,0,5,1,0);
 	
+	/* back */
 	s3d_push_polygon(dir->oid,3,7,4,0);
 	s3d_push_polygon(dir->oid,3,4,0,0);
 
+	/* right */
 	s3d_push_polygon(dir->oid,2,6,7,0);
 	s3d_push_polygon(dir->oid,2,7,3,0);
 	
+	/* front */
 	s3d_push_polygon(dir->oid,8,9,10,0);
 	s3d_push_polygon(dir->oid,8,10,11,0);
+	/* left inner side */
+	s3d_push_polygon(dir->oid,1,5,9,0);
+	s3d_push_polygon(dir->oid,1,9,8,0);
 
+	/* right inner side */
+	s3d_push_polygon(dir->oid,2,11,10,0);
+	s3d_push_polygon(dir->oid,2,10,6,0);
+
+	/* top inner side */
+	s3d_push_polygon(dir->oid,9,5,6,0);
+	s3d_push_polygon(dir->oid,9,6,10,0);
+
+
+
+
 	/* draw the select, close buttons ... */
 	dir->objs.close=s3d_new_object();
 	s3d_push_material(dir->objs.close,
@@ -235,117 +220,95 @@
 /*	printf("FULLNAME is [%s]\n",fullname);*/
 	return(0);
 }
-/* display a directoy on the top of another, draw it's icons etc ... */
-/*
+/* display a directoy on the top of another */
 int box_expand(t_node *dir)
 {
-	int i;
-	float  px,pz;
-	int dirn;
-	px=pz=0.0;
 	printf("box_expand( %s )\n",dir->name);
-	if (dir->disp)		undisplay(dir);
-	box_buildblock(dir);
-	if (dir->parent!=NULL)
-		dir->parent->dirs_opened++;
- / * count directories * /
-	dirn=0;
-	for (i=0;i<dir->n_sub;i++)
+	switch (dir->disp)
 	{
-		if (dir->sub[i].type==T_FOLDER) dirn++;
+		case D_DIR:			return(0); /* already done */
+		case D_ICON:		icon_undisplay(dir); /* undisplay previously displayed types, like icons etc */
+			break;
+		case D_NONE:		break; /* ignore */
+		default:			return(-1); /* panic */
 	}
+	dir->dpx=0.0;
+	dir->dpy=BOXHEIGHT;
+	dir->dpz=0.0;
+	dir->dscale=0.01;
+	box_draw(dir);
 
-	/ * draw icons, if necceasry * /
-	for (i=0;i<dir->n_sub;i++)
+	/* initialize position on the parent */
+	if (dir->parent!=NULL)	
 	{
-		if (!dir->sub[i].disp)	icon_draw(dir,i);
-		else {
-			printf("link %d to the block %d of %s\n",dir->sub[i].block,dir->oid,dir->name);
-			s3d_link(dir->sub[i].block,dir->oid); / * if it's already displayed, make sure it linked properly ... * /
-		}
+		dir->parent->dirs_opened++;
+		s3d_link(dir->oid,dir->parent->oid);
+		box_order_subdirs(dir->parent);
 	}
-	if (dir->parent!=NULL)
-	{
-		s3d_link(dir->oid,dir->parent->block);
-		dir->dpx=0.0;
-		dir->dpy=BOXHEIGHT;
-		dir->dpz=0.0;
-		dir->dscale=0.0;
-		box_position_kids(dir->parent);
-		ani_doit(dir);
-	}
-	box_sidelabel(dir);
 	return(0);
 }
-
-*/
+/* remove s3d-objects of a directory node */
 int box_undisplay(t_node *dir)
 {
-	/*
-	int i;
-	t_node *par;
 	printf("box_undisplay( %s )\n",dir->name);
-	for (i=0;i<dir->n_sub;i++)
-	{
-		if (dir->sub[i].disp==D_ICON)	icon_undisplay(&(dir->sub[i]));
-		else if (dir->sub[i].disp!=0)	
-				printf("not undisplaying: %s (disp = %d)\n",dir->sub[i].name, dir->sub[i].disp);
-	}
-	if ((par=dir->parent)!=NULL) / * we can't do this on root.... * /
-	{
-		for (i=0;i<par->n_item;i++)
-			if (&par->list[i]==dir)
-				break;
-		if (i!=par->n_item) / * if it actually was in the parents item list * /
-		{
-			icon_draw(par,i);
-			s3d_flags_on(dir->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-			s3d_flags_on(dir->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		}
-		par->dirs_opened--;
-	} else {
-		/ * we're root ... * /
-		box_dissolve(dir);
-	}
+	if (dir->objs.close!=-1)		{	s3d_del_object(dir->objs.close);		dir->objs.close=-1; }
+	if (dir->objs.select!=-1)	{	s3d_del_object(dir->objs.select);	dir->objs.select=-1; }
+	if (dir->objs.title!=-1)		{	s3d_del_object(dir->objs.title);		dir->objs.title=-1; }
+	if (dir->objs.titlestr!=-1)	{	s3d_del_object(dir->objs.titlestr);	dir->objs.titlestr=-1; }
+	if (dir->oid!=-1)			s3d_del_object(dir->oid);
+	dir->disp=D_NONE;
+	return(0);
+}
+/* the opposite effect of box_expand, e.g. transforming the box back to an icon */
+int box_unexpand(t_node *dir)
+{
+	if (dir->parent==NULL) /* we can't do this on root.... */
+		return(-1);
+	box_undisplay(dir);
+	icon_draw(dir);
+	box_order_icons(dir->parent);
+	dir->parent->dirs_opened--;
 	printf("[U]ndisplayed %s\n",dir->name);
-/ * 	dir->dirs_opened=0;* /
-	dir->detached=0;
-	*/
 	return(0);
 }
+
 /* undisplay a directory, thus recursively removing the kids.*/
-/*
-int box_collapse(t_node *dir,int force)
+/* if force is 1, even the directory is removed even if it still have selected kids */
+int box_close(t_node *dir,int force)
 {
 	int i;
 	int ret;
-	printf("box_collapse( %s )\n",dir->name);
+	printf("box_close( %s )\n",dir->name);
 	if (&root==dir)
 	{
 		printf("won't undisplay root window ... \n");
 		return(-1);
 	}
-	if (dir->detached && !force)
-		return(1);
-	if (dir->disp!=D_DIR)
+	if (dir->detached && !force)	return(1);
+	if (dir->disp!=D_DIR) /* that should not be happening ... */
 	{
 		printf("[A]lready undisplayed %s, nothing to do ...\n",dir->name);
 		return(-1);
 	}
-	/ * undisplaying kids. ret will be != 0 if any of the kids did not close correctly * /
+	/* undisplaying kids. ret will be != 0 if any of the kids did not close correctly */
 	ret=0;
 	for (i=0;i<dir->n_sub;i++)
-		if (dir->sub[i].disp==D_DIR)
-			ret|=box_collapse(&dir->sub[i],force);
-
-	if (ret && !force) return(ret); / * if anything got wrong, return here ... * /
-	undisplay(dir);
-	if (dir->parent!=NULL)
+		if (dir->sub[i]->disp==D_DIR)
+			ret|=box_close(dir->sub[i],force);
+	if (ret && !force) 
 	{
-		box_position_kids(dir->parent);
+		box_order_subdirs(dir);
+		return(ret); /* if anything got wrong, return here ... */
+	} else {
+		/* also remove the icons */
+		for (i=0;i<dir->n_sub;i++)
+			if (dir->sub[i]->disp==D_ICON)
+				icon_undisplay(dir->sub[i]);
+		box_undisplay(dir);
 	}
 	return(ret);
 }
+/*
 / * only display dir and its kids, but nothing below. * /
 int box_collapse_grandkids(t_node *dir)
 {
@@ -400,14 +363,25 @@
 			}
 	}
 }
-void box_select(t_node *dir)
+/* order the icons properly */
+void box_order_icons(t_node *dir)
 {
-	dir->detached=dir->detached?0:1; /* swapping, not sure if !dir->detached would do the same .. */
-	if ((dir->type==T_FOLDER) && dir->disp)
+	int dps,i;
+	dps=ceil(sqrt(dir->n_sub)); /* directories per line */
+	for (i=0;i<dir->n_sub;i++)
 	{
-		if (dir->parent!=NULL)
-			box_order_subdirs(dir->parent);
-	} else {
-		/* nothing yet ... */
+		dir->sub[i]->px = -1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
+		dir->sub[i]->py = 0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
+		dir->sub[i]->pz = 1.0;
+		dir->sub[i]->scale = (float)1.0/((float)dps);
+		dir->sub[i]->dscale = dir->sub[i]->scale;
+		dir->sub[i]->dpx = dir->sub[i]->px;
+		dir->sub[i]->dpy = dir->sub[i]->py;
+		dir->sub[i]->dpz = dir->sub[i]->dpz;
+		/* make a first setup so there is no flickering */
+		s3d_link(dir->sub[i]->oid,dir->oid); /* if it's already displayed, make sure it linked properly ... */
+		ani_finish(dir->sub[i], -1);
+		s3d_flags_on(dir->sub[i]->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		s3d_flags_on(dir->sub[i]->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	}
 }

Modified: trunk/apps/s3dfm/event.c
===================================================================
--- trunk/apps/s3dfm/event.c	2006-09-26 14:54:49 UTC (rev 437)
+++ trunk/apps/s3dfm/event.c	2006-09-26 16:16:22 UTC (rev 438)
@@ -99,30 +99,34 @@
 	{
 		if (f->objs.close==oid)
 		{
-/*			box_collapse(f,1);*/
-/*			if (f->parent!=NULL)
-				ani_focus(f->parent);*/
+			box_close(f,1);
+			if (f->parent!=NULL)
+				ani_focus(f->parent);
 			return;
 		}
 		if (f->objs.select==oid)
 		{
 			printf("[S]electing %s\n",f->name);
-			box_select(f);
+			node_select(f);
 			return;
 		}
-		if (f->type==T_FOLDER)
+		switch (f->disp)
 		{
-			if (f->disp == D_DIR)
-			{
+			case D_DIR:
 				printf("[F]ound, Already displayed - ani_focus( %s )\n",f->name);
-			} else {
-				if (!f->parsed)	parse_dir(f);
-/*				box_expand(f);*/
-			}
-			focus=f;
-			ani_focus(f);
-		} else
-			printf("[F]ound, but %s is no folder\n",f->name);
+				ani_focus(f);
+				break;
+			case D_ICON:
+				if (f->type==T_FOLDER)
+				{
+					parse_dir(f);
+					box_expand(f);	
+					ani_focus(f);
+				} else {
+					node_select(f);
+				}
+				break;
+		}
 	} else {
 /*		printf("[C]ould not find :/\n");*/
 	}

Modified: trunk/apps/s3dfm/icon.c
===================================================================
--- trunk/apps/s3dfm/icon.c	2006-09-26 14:54:49 UTC (rev 437)
+++ trunk/apps/s3dfm/icon.c	2006-09-26 16:16:22 UTC (rev 438)
@@ -44,7 +44,6 @@
 				5,1,0,0,				5,0,4,0	
 				};
 	float len;
-	printf("icon_draw( %s )\n",dir->name);
 	/* find position for the new block in our directory box */
 	/* create the block */
 	dir->oid=s3d_new_object();
@@ -78,13 +77,11 @@
 	s3d_translate(dir->objs.str,-0.9,-0.3,0.1);
 	s3d_rotate(dir->objs.str,0,0,0);
 	s3d_link(dir->objs.str,dir->oid);
-
 	dir->disp=D_ICON;
 	return(0);
 }
 int icon_undisplay(t_node *dir)
 {
-	printf("icon_undisplay( %s )\n",dir->name);
 	if (dir->oid!=-1)
 	{
 		s3d_del_object(dir->oid);

Modified: trunk/apps/s3dfm/node.c
===================================================================
--- trunk/apps/s3dfm/node.c	2006-09-26 14:54:49 UTC (rev 437)
+++ trunk/apps/s3dfm/node.c	2006-09-26 16:16:22 UTC (rev 438)
@@ -149,3 +149,22 @@
 	*/
 	return(0);
 }
+/* node select handles click on the detach button. selected items can be moved, copied etc.*/
+void node_select(t_node *dir)
+{
+	printf("node_select(%s)\n",dir->name);
+	dir->detached=dir->detached?0:1; /* swapping, not sure if !dir->detached would do the same .. */
+	printf("dir->type = %d\n",dir->disp);
+	switch (dir->disp)
+	{
+		case D_DIR:
+			if (dir->parent!=NULL)
+				box_order_subdirs(dir->parent);
+			break;
+		case D_ICON:
+			dir->pz=dir->detached*0.2+1.0;
+			ani_add(dir);
+			break;
+		/* nothing yet ... */
+	}
+}

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2006-09-26 14:54:49 UTC (rev 437)
+++ trunk/apps/s3dfm/parse.c	2006-09-26 16:16:22 UTC (rev 438)
@@ -74,40 +74,36 @@
 					dir->sub[i]->parent = dir;
 				}
 				/* find out the filetype ... very simple */
-				else {
-					ext=strrchr(nstr,'.');
-					strncpy(ndir,path,M_DIR);
-			    	strncat(ndir,namelist[n]->d_name,M_DIR);
-				    if ((namelist[n]->d_type==DT_DIR) ||
-						((namelist[n]->d_type==DT_UNKNOWN) && ((dirhd=opendir(ndir))!=NULL)))
-						{
-							dir->sub[i]->type=T_FOLDER;
-							closedir(dirhd);
-						}
-					else 
-					{
-					   if (ext!=NULL)
-					   {
-						   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))		   dir->sub[i]->type=T_GEOMETRY;
-						   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))	   dir->sub[i]->type=T_MUSIC;
-					   }	
-					}
-				}
-	
-				dir->sub[i]->check=0;
+				ext=strrchr(nstr,'.');
+				strncpy(ndir,path,M_DIR);
+		    	strncat(ndir,namelist[n]->d_name,M_DIR);
+			    if ((namelist[n]->d_type==DT_DIR) || ((namelist[n]->d_type==DT_UNKNOWN) && ((dirhd=opendir(ndir))!=NULL)))
+				{
+					dir->sub[i]->type=T_FOLDER;
+					closedir(dirhd);
+				} else if (ext!=NULL)
+				   {
+					   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))		   dir->sub[i]->type=T_GEOMETRY;
+					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))	   dir->sub[i]->type=T_MUSIC;
+				   }	
+				dir->sub[i]->check=0; /* check=0 means we've already processed this item */
 			}
 	   	    free(namelist[n]);
 		}
 		free(namelist);
+		dir->check=0;
 		for (i=0;i<dir->n_sub;i++)
 			if (dir->sub[i]->check) 
-			/* not checked yet... that means the item is not in the reparsed directory, ie vanished.
-			 * so we're removing it from our queue */
 			{
+				/* not checked yet... that means the item is not in the reparsed directory, ie vanished.
+				 * so we're removing it from our queue */
 				node_delete(dir->sub[i]);
 				dir->n_sub--;
 				dir->sub[i]=dir->sub[dir->n_sub]; /* exchange with the last one */
+				dir->check=1;
 			}
+		/* if we removed something, then shrink the buffer accordingly .. */
+		if (dir->check)		dir->sub = realloc( dir->sub , dir->n_sub * sizeof(t_node *) );
 		dir->parsed=1;
    	}
 	return(0);

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2006-09-26 14:54:49 UTC (rev 437)
+++ trunk/apps/s3dfm/s3dfm.h	2006-09-26 16:16:22 UTC (rev 438)
@@ -81,13 +81,6 @@
 extern t_node root,cam; /* some global objects */
 extern t_node *focus;	/* the focused object */
 
-/* node.c */
-t_node 		*node_getbypath(char *path);
-void 		 node_path(t_node *dir, char *path);
-t_node 		*node_getbyoid(t_node *t, int oid);
-int 		 node_init(t_node *dir);
-int 		 node_delete(t_node *dir);
-int 		 node_undisplay(t_node *dir);
 /* animation.c */
 float		 ani_get_scale(t_node *f);
 void 		 ani_focus(t_node *f);
@@ -99,10 +92,6 @@
 void 		 ani_iterate(t_node *f);
 int 		 ani_check(t_node *f);
 void 		 ani_mate();
-/* event.c */
-void 		 event_click(struct s3d_evt *evt);
-void		 event_key(struct s3d_evt *evt);
-void		 event_oinfo(struct s3d_evt *hrmz);
 /* box.c */
 void	 	 box_draw(t_node *dir);
 void 	 	 box_draw_icons(t_node *dir);
@@ -110,13 +99,10 @@
 void  		 box_order_icons(t_node *dir);
 void	 	 box_sidelabel(t_node *dir);
 int 		 box_buildblock(t_node *dir);
-void		 box_select(t_node *dir);
 void 		 box_order_subdirs(t_node *dir);
-/* parse.c */
-int 		 parse_dir(t_node *dir);
-/* icon.c */
-int 		 icon_draw(t_node *dir);
-int 		 icon_undisplay(t_node *dir);
+int 		 box_expand(t_node *dir);
+int 		 box_unexpand(t_node *dir);
+int 		 box_close(t_node *dir,int force);
 /* dialog.c */
 void		 close_win(s3dw_widget *button);
 void		 window_help();
@@ -129,11 +115,10 @@
 void		 window_mkdir(char *path);
 void		 window_move(char *path);
 void		 window_info(char *path);
-/* string.c */
-void 		 dots_at_start(char *s, unsigned int n, t_node *d);
-void		 dotted_int(char *s,unsigned int i);
-char		 *mstrncat(char *dest, const char *src, int n);
-char		 *mstrncpy(char *dest, const char *src, int n);
+/* event.c */
+void 		 event_click(struct s3d_evt *evt);
+void		 event_key(struct s3d_evt *evt);
+void		 event_oinfo(struct s3d_evt *hrmz);
 /* fs.c */
 filelist	 *fl_new(char *path);
 void		 fl_del(filelist *fl);
@@ -144,4 +129,21 @@
 void	 	 fs_approx(char *source, int *files, int *dirs, int *bytes);
 int			 fs_copy(char *source, char *dest);
 int			 fs_move(char *source, char *dest);
-int			 fs_unlink(char *dest);
+int			 fs_unlink(char *dest);/* icon.c */
+int 		 icon_draw(t_node *dir);
+int 		 icon_undisplay(t_node *dir);
+/* node.c */
+t_node 		*node_getbypath(char *path);
+void 		 node_path(t_node *dir, char *path);
+t_node 		*node_getbyoid(t_node *t, int oid);
+int 		 node_init(t_node *dir);
+int 		 node_delete(t_node *dir);
+int 		 node_undisplay(t_node *dir);
+void		 node_select(t_node *dir);
+/* parse.c */
+int 		 parse_dir(t_node *dir);
+/* string.c */
+void 		 dots_at_start(char *s, unsigned int n, t_node *d);
+void		 dotted_int(char *s,unsigned int i);
+char		 *mstrncat(char *dest, const char *src, int n);
+char		 *mstrncpy(char *dest, const char *src, int n);



From dotslash at mail.berlios.de  Wed Sep 27 00:37:03 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 27 Sep 2006 00:37:03 +0200
Subject: [S3d-svn] r439 - in trunk: . apps/s3dfm
Message-ID: <200609262237.k8QMb3n6017515@sheep.berlios.de>

Author: dotslash
Date: 2006-09-27 00:37:02 +0200 (Wed, 27 Sep 2006)
New Revision: 439

Modified:
   trunk/
   trunk/apps/s3dfm/TODO
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/event.c
   trunk/apps/s3dfm/icon.c
   trunk/apps/s3dfm/node.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dfm/s3dfm.h
   trunk/apps/s3dfm/string.c
Log:
 r1065 at balthasar:  dotslash | 2006-09-27 00:36:51 +0200
 - display fixes (titlestring, sidestring)
 - some more cleanup



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1063
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1065

Modified: trunk/apps/s3dfm/TODO
===================================================================
--- trunk/apps/s3dfm/TODO	2006-09-26 16:16:22 UTC (rev 438)
+++ trunk/apps/s3dfm/TODO	2006-09-26 22:37:02 UTC (rev 439)
@@ -1,3 +1,5 @@
+- focus
+- let blocks fly in animation
 - copy
 - delete
 - create directories

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2006-09-26 16:16:22 UTC (rev 438)
+++ trunk/apps/s3dfm/animation.c	2006-09-26 22:37:02 UTC (rev 439)
@@ -160,13 +160,19 @@
 	for (i=0;i<ani_n;i++)
 	{
 		f=ani_s[i];
-		ani_iterate(f);
-		if (ani_check(f))
-		{
-			ani_finish(f,i);
-			i--; /* a new object is here now, take care in the next iteration */
+		if (f->oid==-1)
+		{ /* kick out bad animations */
+			ani_del(i);
+			i--;
 		} else {
-			ani_doit(f);
+			ani_iterate(f);
+			if (ani_check(f))
+			{
+				ani_finish(f,i);
+				i--; /* a new object is here now, take care in the next iteration */
+			} else {
+				ani_doit(f);
+			}
 		}
 	}
 }

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2006-09-26 16:16:22 UTC (rev 438)
+++ trunk/apps/s3dfm/box.c	2006-09-26 22:37:02 UTC (rev 439)
@@ -56,11 +56,17 @@
 /* places the string at the left side of the cube */
 void box_sidelabel(t_node *dir)
 {
-
+	float len;
+	if (dir->objs.str==-1)
+	{
+		dir->objs.str=s3d_draw_string(dir->name,&len);
+		if (len<2) len=2;
+		dir->objs.strlen=len;
+	}
 	s3d_rotate(dir->objs.str,0,90,0);
 	s3d_translate(dir->objs.str,1.1,0.3,1);
-	s3d_scale(dir->objs.str,(float)1.8/(dir->len));
-	s3d_scale(dir->objs.str,(float)1.8/(dir->len));
+	s3d_scale(dir->objs.str,(float)1.8/(dir->objs.strlen));
+	s3d_scale(dir->objs.str,(float)1.8/(dir->objs.strlen));
 	s3d_link(dir->objs.str,dir->oid);
 	s3d_flags_on(dir->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
@@ -210,8 +216,7 @@
 	s3d_push_vertices(dir->objs.title,tvertices,sizeof(tvertices)/(3*sizeof(float)));
 	s3d_push_polygons(dir->objs.title,bar_poly,sizeof(bar_poly)/(sizeof(unsigned long)*4));
 	s3d_link(dir->objs.title,dir->oid);
-	dots_at_start(fullname,30,dir);
-	dir->objs.titlestr=s3d_draw_string(fullname,&len);
+	dir->objs.titlestr=s3d_draw_string(dots_at_start(fullname,30,dir),&len);
 	if (len>(1.6*5.0))		s3d_scale(dir->objs.titlestr,1.6/len);
 	else					s3d_scale(dir->objs.titlestr,0.2);
 	s3d_translate(dir->objs.titlestr,-1.0,1.05,1.01);
@@ -251,24 +256,27 @@
 int box_undisplay(t_node *dir)
 {
 	printf("box_undisplay( %s )\n",dir->name);
-	if (dir->objs.close!=-1)		{	s3d_del_object(dir->objs.close);		dir->objs.close=-1; }
-	if (dir->objs.select!=-1)	{	s3d_del_object(dir->objs.select);	dir->objs.select=-1; }
-	if (dir->objs.title!=-1)		{	s3d_del_object(dir->objs.title);		dir->objs.title=-1; }
-	if (dir->objs.titlestr!=-1)	{	s3d_del_object(dir->objs.titlestr);	dir->objs.titlestr=-1; }
-	if (dir->oid!=-1)			s3d_del_object(dir->oid);
+	if (dir->objs.close!=-1)		{	s3d_del_object(dir->objs.close);	dir->objs.close=-1; }
+	if (dir->objs.select!=-1)		{	s3d_del_object(dir->objs.select);	dir->objs.select=-1; }
+	if (dir->objs.title!=-1)		{	s3d_del_object(dir->objs.title);	dir->objs.title=-1; }
+	if (dir->objs.titlestr!=-1)		{	s3d_del_object(dir->objs.titlestr);	dir->objs.titlestr=-1; }
+	if (dir->oid!=-1)				{	s3d_del_object(dir->oid);	}
+	/* keep this. icons also needs the *same* string */
+	/*	if (dir->objs.str!=-1)			{ 	s3d_del_object(dir->objs.str); dir->objs.str=-1;	}*/
 	dir->disp=D_NONE;
 	return(0);
 }
 /* the opposite effect of box_expand, e.g. transforming the box back to an icon */
 int box_unexpand(t_node *dir)
 {
+	printf("box_unexpand( %s )\n",dir->name);
 	if (dir->parent==NULL) /* we can't do this on root.... */
 		return(-1);
 	box_undisplay(dir);
 	icon_draw(dir);
+	dir->parent->dirs_opened--;
 	box_order_icons(dir->parent);
-	dir->parent->dirs_opened--;
-	printf("[U]ndisplayed %s\n",dir->name);
+	box_order_subdirs(dir->parent);
 	return(0);
 }
 
@@ -296,15 +304,15 @@
 		if (dir->sub[i]->disp==D_DIR)
 			ret|=box_close(dir->sub[i],force);
 	if (ret && !force) 
-	{
+	{	/* if anything got wrong, return here ... */
 		box_order_subdirs(dir);
-		return(ret); /* if anything got wrong, return here ... */
+		return(ret); 
 	} else {
 		/* also remove the icons */
 		for (i=0;i<dir->n_sub;i++)
 			if (dir->sub[i]->disp==D_ICON)
 				icon_undisplay(dir->sub[i]);
-		box_undisplay(dir);
+		box_unexpand(dir);
 	}
 	return(ret);
 }
@@ -359,7 +367,6 @@
 					ani_add(dir->sub[i]);
 					j++;
 				}
-
 			}
 	}
 }
@@ -370,18 +377,16 @@
 	dps=ceil(sqrt(dir->n_sub)); /* directories per line */
 	for (i=0;i<dir->n_sub;i++)
 	{
-		dir->sub[i]->px = -1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
-		dir->sub[i]->py = 0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
-		dir->sub[i]->pz = 1.0;
-		dir->sub[i]->scale = (float)1.0/((float)dps);
-		dir->sub[i]->dscale = dir->sub[i]->scale;
-		dir->sub[i]->dpx = dir->sub[i]->px;
-		dir->sub[i]->dpy = dir->sub[i]->py;
-		dir->sub[i]->dpz = dir->sub[i]->dpz;
-		/* make a first setup so there is no flickering */
-		s3d_link(dir->sub[i]->oid,dir->oid); /* if it's already displayed, make sure it linked properly ... */
-		ani_finish(dir->sub[i], -1);
-		s3d_flags_on(dir->sub[i]->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
-		s3d_flags_on(dir->sub[i]->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		if (dir->sub[i]->disp == D_ICON)
+		{
+			dir->sub[i]->px = -1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
+			dir->sub[i]->py = 0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
+			dir->sub[i]->pz = 1.0;
+			dir->sub[i]->scale = (float)1.0/((float)dps);
+			s3d_link(dir->sub[i]->oid,dir->oid);	 /* if it's already displayed, make sure it linked properly ... */
+			ani_finish(dir->sub[i], -1);			 /* copy to the current animation state */
+			s3d_flags_on(dir->sub[i]->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			s3d_flags_on(dir->sub[i]->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+		}
 	}
 }

Modified: trunk/apps/s3dfm/event.c
===================================================================
--- trunk/apps/s3dfm/event.c	2006-09-26 16:16:22 UTC (rev 438)
+++ trunk/apps/s3dfm/event.c	2006-09-26 22:37:02 UTC (rev 439)
@@ -100,8 +100,6 @@
 		if (f->objs.close==oid)
 		{
 			box_close(f,1);
-			if (f->parent!=NULL)
-				ani_focus(f->parent);
 			return;
 		}
 		if (f->objs.select==oid)

Modified: trunk/apps/s3dfm/icon.c
===================================================================
--- trunk/apps/s3dfm/icon.c	2006-09-26 16:16:22 UTC (rev 438)
+++ trunk/apps/s3dfm/icon.c	2006-09-26 22:37:02 UTC (rev 439)
@@ -69,10 +69,8 @@
 	{
 		dir->objs.str=s3d_draw_string(dir->name,&len);
 		if (len<2) len=2;
-		dir->len=len;
-	}
-	else 
-		len=dir->len;
+		dir->objs.strlen=len;
+	} else len=dir->objs.strlen;
 	s3d_scale(dir->objs.str,(float)1.8/len);
 	s3d_translate(dir->objs.str,-0.9,-0.3,0.1);
 	s3d_rotate(dir->objs.str,0,0,0);

Modified: trunk/apps/s3dfm/node.c
===================================================================
--- trunk/apps/s3dfm/node.c	2006-09-26 16:16:22 UTC (rev 438)
+++ trunk/apps/s3dfm/node.c	2006-09-26 22:37:02 UTC (rev 439)
@@ -101,11 +101,12 @@
 	dir->objs.select=-1;
 	dir->objs.title=-1;
 	dir->objs.titlestr=-1;
-
-	dir->len=0;
-	dir->disp=0;
+	dir->objs.strlen=0;
+	
+	dir->disp=D_NONE;
 	dir->parsed=0;
 
+	dir->check=0;
 	dir->px=root.pz=0.0;
 	dir->dirs_opened=0;
 	dir->type=T_DUNO;
@@ -152,9 +153,7 @@
 /* node select handles click on the detach button. selected items can be moved, copied etc.*/
 void node_select(t_node *dir)
 {
-	printf("node_select(%s)\n",dir->name);
 	dir->detached=dir->detached?0:1; /* swapping, not sure if !dir->detached would do the same .. */
-	printf("dir->type = %d\n",dir->disp);
 	switch (dir->disp)
 	{
 		case D_DIR:

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2006-09-26 16:16:22 UTC (rev 438)
+++ trunk/apps/s3dfm/parse.c	2006-09-26 22:37:02 UTC (rev 439)
@@ -57,7 +57,7 @@
 			/* setup kids in the sub */
 			for (i=0;i<oldn;i++) /* see if it's already there */
 				if (dir->sub[i])
-				if (0==strcmp(namelist[n]->d_name,dir->sub[n]->name))
+				if (0==strcmp(namelist[n]->d_name,dir->sub[i]->name))
 					break;
  		    if ((0!=strcmp(nstr,".")) && (0!=strcmp(nstr,".."))) /* we don't care about those */
 			{

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2006-09-26 16:16:22 UTC (rev 438)
+++ trunk/apps/s3dfm/s3dfm.h	2006-09-26 22:37:02 UTC (rev 439)
@@ -61,12 +61,13 @@
 #define D_DIR		2
 	int				 parsed,detached;					/* Flags for parsed/detached (selected) nodes ... */
 	int 			 oid;								/* main oid, e.g the block or icons oid */
-	float 			 len;								/* lenght ... TODO: of what? */
 	struct 			 {	
 		/* some objects which might be used ... if not, should be -1 */
 		int 		 close,select,title,titlestr; /* box decorations. */
-		int 		 str;						  
+		int 		 str;						  /* the name of the nodeas s3d object */
+		float		 strlen;					  /* the length of this string */
 		
+		
 	} 				 objs;
 	int 			 check;							    /* check marker, for internal things */
 };
@@ -143,7 +144,7 @@
 /* parse.c */
 int 		 parse_dir(t_node *dir);
 /* string.c */
-void 		 dots_at_start(char *s, unsigned int n, t_node *d);
 void		 dotted_int(char *s,unsigned int i);
-char		 *mstrncat(char *dest, const char *src, int n);
-char		 *mstrncpy(char *dest, const char *src, int n);
+char 		*dots_at_start(char *str, unsigned int n, t_node *d);
+char		*mstrncat(char *dest, const char *src, int n);
+char		*mstrncpy(char *dest, const char *src, int n);

Modified: trunk/apps/s3dfm/string.c
===================================================================
--- trunk/apps/s3dfm/string.c	2006-09-26 16:16:22 UTC (rev 438)
+++ trunk/apps/s3dfm/string.c	2006-09-26 22:37:02 UTC (rev 439)
@@ -20,12 +20,18 @@
  * along with s3dfm; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
+
+/* just a few helper functions which only operate on strings, so we put them 
+ * here ... */
+
 #include "s3dfm.h"
 #include <string.h> /* strlen(), strncpy() */
-/* writes the path of the item d in string s with bufferlength n, 
+
+/* writes the path of the item d in string str with bufferlength n, 
  * adds some dots to the beginning if its too long */ 
-void dots_at_start(char *s, unsigned int n, t_node *d)
+char *dots_at_start(char *str, unsigned int n, t_node *d)
 {
+	char *s=str;
 	int i,j;
 	i=n-2;
 	s[n-1]=0;
@@ -47,6 +53,7 @@
 	} while ((d=d->parent)!=NULL);
 	if (i<0)			s[0]=s[1]='.';
 	else 				s=(char *)s+i+1; /* jump to start of the string */
+	return(s);
 
 }
 /* add some dots to an integer value for better readability */



From dotslash at mail.berlios.de  Thu Sep 28 11:45:36 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 28 Sep 2006 11:45:36 +0200
Subject: [S3d-svn] r440 - in trunk: . apps/s3dfm
Message-ID: <200609280945.k8S9jabv021106@sheep.berlios.de>

Author: dotslash
Date: 2006-09-28 11:45:35 +0200 (Thu, 28 Sep 2006)
New Revision: 440

Added:
   trunk/apps/s3dfm/fly.c
   trunk/apps/s3dfm/focus.c
Modified:
   trunk/
   trunk/apps/s3dfm/Makefile.am
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/event.c
   trunk/apps/s3dfm/icon.c
   trunk/apps/s3dfm/main.c
   trunk/apps/s3dfm/node.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dfm/s3dfm.h
Log:
 r1069 at balthasar:  dotslash | 2006-09-28 11:45:22 +0200
 - use keyboard to select files



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1065
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1069

Modified: trunk/apps/s3dfm/Makefile.am
===================================================================
--- trunk/apps/s3dfm/Makefile.am	2006-09-26 22:37:02 UTC (rev 439)
+++ trunk/apps/s3dfm/Makefile.am	2006-09-28 09:45:35 UTC (rev 440)
@@ -7,7 +7,7 @@
 s3dfm_SOURCES =  \
 	main.c box.c animation.c event.c \
 	fs.c dialog.c parse.c icon.c node.c \
-	string.c
+	string.c fly.c focus.c
 
 s3dfm_CPPFLAGS=		-I${top_srcdir}/libs3d -I${top_srcdir}/libs3dw
 s3dfm_LDADD=		${top_builddir}/libs3d/libs3d.la ${top_builddir}/libs3dw/libs3dw.la

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2006-09-26 22:37:02 UTC (rev 439)
+++ trunk/apps/s3dfm/animation.c	2006-09-28 09:45:35 UTC (rev 440)
@@ -29,53 +29,7 @@
 /* the animation stack */
 static t_node *ani_s[MAXANI];
 static int ani_n=0;
-extern t_node root,cam;
-int moveon=1;
 
-/* get the scale for the rootbox zoom */
-float ani_get_scale(t_node *f)
-{
-	float scale,s;
-	s=0.2;
-	scale=1/s;
-	if (f->parent!=NULL)
-		scale=1/s*ani_get_scale(f->parent);
-	else
-		return(1.0);
-	root.px-=f->px;
-	root.pz-=f->pz;
-	root.py-=BOXHEIGHT+f->detached*DETHEIGHT;
-	root.px*=1/s;
-	root.py*=1/s;
-	root.pz*=1/s;
-	
-	return(scale);
-}
-/* center f for the viewer, therefore moving the root box ... */
-void ani_focus(t_node *f)
-{
-	root.px=0.0;
-	root.py=0.0;
-	root.pz=0.0;
-	moveon=1;
-/*	printf("[Z]ooming to %s\n",f->name);*/
-/*	box_collapse_grandkids(f);*/
-	root.scale=ani_get_scale(f);
-	root.py-=1.5;
-/*	printf("[R]escaling to %f\n",root.scale);
-	printf("px: %f py:%f pz: %f\n",root.px,root.py,root.pz);*/
-
-	ani_add(&root);
-	focus=f;
-	if (((cam.dpx-cam.px)* (cam.dpx-cam.px) + (cam.dpy-cam.py)* (cam.dpy-cam.py) 
-		  + (cam.dpz-cam.pz)* (cam.dpz-cam.pz))	> ( 10 * 10))
-	{
-		cam.px=0;
-		cam.py=0;
-		cam.pz=5;
-		ani_add(&cam);
-	}
-}
 /* is node f already on stack? */
 int ani_onstack(t_node *f)
 {

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2006-09-26 22:37:02 UTC (rev 439)
+++ trunk/apps/s3dfm/box.c	2006-09-28 09:45:35 UTC (rev 440)
@@ -38,8 +38,8 @@
     s3d_flags_on(dir->objs.titlestr,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	dir->disp=D_DIR;
 	box_draw_icons(dir);
+}
 
-}
 /* draw all the icons which are not displayed yet */
 void box_draw_icons(t_node *dir)
 {
@@ -70,7 +70,16 @@
 	s3d_link(dir->objs.str,dir->oid);
 	s3d_flags_on(dir->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
+/* gives another color for the focused box */
+void box_focus_color(t_node *dir, int on)
+{
+	
+	s3d_pep_material(dir->oid,
+						0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
+						0.5+on*0.3,0.5+on*0.3,0.5+on*0.3,
+						0.5+on*0.3,0.5+on*0.3,0.5+on*0.3);
 
+}
 /* creates a big block which will hold files and subdirs on top */
 int box_buildblock(t_node *dir)
 {
@@ -141,17 +150,13 @@
 						0.5,0.5,0.5,
 						0.5,0.5,0.5
 					);
-	s3d_push_material(dir->oid,
-						0.5,0.5,0.6,
-						0.5,0.5,0.6,
-						0.5,0.5,0.6);
 
 	/* top */
-	s3d_push_polygon(dir->oid,4,6,5,1);
-	s3d_push_polygon(dir->oid,4,7,6,1);
+	s3d_push_polygon(dir->oid,4,6,5,0);
+	s3d_push_polygon(dir->oid,4,7,6,0);
 	/* bottom */
-	s3d_push_polygon(dir->oid,8,11,3,1);
-	s3d_push_polygon(dir->oid,8,3,0,1);
+	s3d_push_polygon(dir->oid,8,11,3,0);
+	s3d_push_polygon(dir->oid,8,3,0,0);
 
 
 	/* left */
@@ -289,7 +294,7 @@
 	printf("box_close( %s )\n",dir->name);
 	if (&root==dir)
 	{
-		printf("won't undisplay root window ... \n");
+		printf("won't close down root box ... \n");
 		return(-1);
 	}
 	if (dir->detached && !force)	return(1);
@@ -298,7 +303,7 @@
 		printf("[A]lready undisplayed %s, nothing to do ...\n",dir->name);
 		return(-1);
 	}
-	/* undisplaying kids. ret will be != 0 if any of the kids did not close correctly */
+	/* closing kids. ret will be != 0 if any of the kids did not close correctly */
 	ret=0;
 	for (i=0;i<dir->n_sub;i++)
 		if (dir->sub[i]->disp==D_DIR)
@@ -309,9 +314,14 @@
 		return(ret); 
 	} else {
 		/* also remove the icons */
+		if (focus==dir)			focus_set(dir->parent);
 		for (i=0;i<dir->n_sub;i++)
 			if (dir->sub[i]->disp==D_ICON)
+			{
 				icon_undisplay(dir->sub[i]);
+				if (focus==dir->sub[i])
+					focus_set(dir->parent);
+			}
 		box_unexpand(dir);
 	}
 	return(ret);

Modified: trunk/apps/s3dfm/event.c
===================================================================
--- trunk/apps/s3dfm/event.c	2006-09-26 22:37:02 UTC (rev 439)
+++ trunk/apps/s3dfm/event.c	2006-09-28 09:45:35 UTC (rev 440)
@@ -67,7 +67,7 @@
 				{/* refresh this window ... */
 					printf("[R]efreshing %s\n",focus->name);
 /*					parse_again(focus);*/
-					ani_focus(focus);
+					focus_set(focus);
 				}
 				break;
 		case S3DK_F1:
@@ -82,8 +82,28 @@
 		case S3DK_F7:
 				window_mkdir(path);
 				break;
-
-
+		case S3DK_F10:
+				printf("focus %s\n",focus->name);
+				fly_set_absolute_position(focus);
+				break;
+		case S3DK_UP:
+		case S3DK_LEFT:
+		case S3DK_RIGHT:
+		case S3DK_DOWN:
+				focus_by_key(keys->keysym);
+				printf("pindex of focus = %d\n",focus->pindex);
+				break;
+		case S3DK_RETURN:
+		case S3DK_SPACE:
+				node_select(focus);
+				break;
+		case S3DK_BACKSPACE:
+				if (focus->disp==D_DIR)
+					box_close(focus,1);
+				else if (focus->parent!=NULL)
+						box_close(focus->parent,1);
+				break;
+				
 	}
 	s3dw_handle_key(evt);
 }
@@ -108,23 +128,7 @@
 			node_select(f);
 			return;
 		}
-		switch (f->disp)
-		{
-			case D_DIR:
-				printf("[F]ound, Already displayed - ani_focus( %s )\n",f->name);
-				ani_focus(f);
-				break;
-			case D_ICON:
-				if (f->type==T_FOLDER)
-				{
-					parse_dir(f);
-					box_expand(f);	
-					ani_focus(f);
-				} else {
-					node_select(f);
-				}
-				break;
-		}
+		node_select(f);
 	} else {
 /*		printf("[C]ould not find :/\n");*/
 	}

Added: trunk/apps/s3dfm/fly.c
===================================================================
--- trunk/apps/s3dfm/fly.c	2006-09-26 22:37:02 UTC (rev 439)
+++ trunk/apps/s3dfm/fly.c	2006-09-28 09:45:35 UTC (rev 440)
@@ -0,0 +1,54 @@
+/*
+ * fly.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "s3dfm.h"
+#include <stdio.h>	/* NULL */
+#include <string.h> /* strncpy() */
+static void _get_pos(t_node *work, t_node *f)
+{
+	if (f->parent!=NULL) _get_pos(work,f->parent);
+	work->px+=f->px										* work->scale;
+	work->pz+=f->pz										* work->scale;
+	work->py+=f->py										* work->scale;
+	printf("%s: %3.3f %3.3f %3.3f - %3.3f\n",f->name, f->px, f->py, f->pz, f->scale );
+	printf("### %3.3f %3.3f %3.3f - %3.3f)\n", work->px, work->py, work->pz, work->scale);
+
+	if (f->parent==NULL)	work->scale = f->scale;
+	else					work->scale = work->scale * f->scale;
+	
+}
+
+int fly_set_absolute_position(t_node *node)
+{
+	t_node work;
+	node_init(&work);
+	work.px = node->px;
+	work.py = node->py;
+	work.pz = node->pz;
+	printf("selected node %s: %3.3f %3.3f %3.3f, %3.3f\n",node->name, node->px, node->py, node->pz, node->scale);
+	work.parent = node->parent;
+	strncpy(work.name,node->name,M_NAME);
+	_get_pos(&work, node);
+	printf("absolute position: %f %f %f - %f\n", work.px, work.py, work.pz, work.scale);
+	return(0);
+}

Added: trunk/apps/s3dfm/focus.c
===================================================================
--- trunk/apps/s3dfm/focus.c	2006-09-26 22:37:02 UTC (rev 439)
+++ trunk/apps/s3dfm/focus.c	2006-09-28 09:45:35 UTC (rev 440)
@@ -0,0 +1,217 @@
+/*
+ * focus.c
+ * 
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dfm, a s3d file manager.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dfm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dfm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dfm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "s3dfm.h"
+#include <s3d_keysym.h>
+#include <stdio.h> /* printf() */
+#include <math.h>  /* ceil(), sqrt() */
+int moveon=1;
+
+/* get the scale for the rootbox zoom */
+float focus_get_scale(t_node *f)
+{
+	float scale,s;
+	if (f->disp==D_DIR)
+	{
+		s=0.2;
+		scale=1/s;
+		if (f->parent!=NULL)
+			scale=1/s*focus_get_scale(f->parent);
+		else
+			return(1.0);
+		root.px-=f->px;
+		root.pz-=f->pz;
+		root.py-=BOXHEIGHT+f->detached*DETHEIGHT;
+		root.px*=1/s;
+		root.py*=1/s;
+		root.pz*=1/s;
+		return(scale);
+	} else {
+		if (f->parent!=NULL)		return(focus_get_scale(f->parent));	/* icons etc */
+		else  						return(1.0);						/* that should never happen */
+	}
+	
+}
+/* center f for the viewer, therefore moving the root box ... */
+void focus_set(t_node *f)
+{
+	root.px=0.0;
+	root.py=0.0;
+	root.pz=0.0;
+	moveon=1;
+/*	printf("[Z]ooming to %s\n",f->name);*/
+/*	box_collapse_grandkids(f);*/
+	root.scale=focus_get_scale(f);
+	root.py-=1.5;
+/*	printf("[R]escaling to %f\n",root.scale);
+	printf("px: %f py:%f pz: %f\n",root.px,root.py,root.pz);*/
+
+	ani_add(&root);
+	node_focus_color(focus,0);
+	node_focus_color(f,1);
+	focus=f;
+	if (((cam.dpx-cam.px)* (cam.dpx-cam.px) + (cam.dpy-cam.py)* (cam.dpy-cam.py) 
+		  + (cam.dpz-cam.pz)* (cam.dpz-cam.pz))	> ( 10 * 10))
+	{
+		cam.px=0;
+		cam.py=0;
+		cam.pz=5;
+		ani_add(&cam);
+	}
+}
+
+/* uses a keysym to set the focus new */
+void focus_by_key(int keysym)
+{
+	int i,rowsize;
+	if (focus->pindex!=-1)
+	{
+		switch (focus->disp)
+		{
+			case D_DIR:
+				switch (keysym)
+				{
+					case S3DK_RIGHT:
+						/* cycle to the next directory on the ring */
+						for (i=focus->pindex-1;i>=0;i--)
+							if (focus->parent->sub[i]->disp==D_DIR)
+							{ /* found a directory before, cycle */
+								focus_set(focus->parent->sub[i]);
+								break;
+							}
+						if (i==-1) /* nothing found, wrap to the other side */
+						for (i=focus->parent->n_sub-1;i>=focus->pindex+1;i--)
+							if (focus->parent->sub[i]->disp==D_DIR)
+							{ /* found a directory before, cycle */
+								focus_set(focus->parent->sub[i]);
+								break;
+							}
+						break;
+					case S3DK_LEFT:
+						/* cycle to the next directory on the ring */
+						for (i=focus->pindex+1;i<focus->parent->n_sub;i++)
+							if (focus->parent->sub[i]->disp==D_DIR)
+							{ /* found a directory before, cycle */
+								focus_set(focus->parent->sub[i]);
+								break;
+							}
+						if (i==focus->parent->n_sub) /* nothing found, wrap to the other side */
+						for (i=0;i<focus->pindex;i++)
+							if (focus->parent->sub[i]->disp==D_DIR)
+							{ /* found a directory before, cycle */
+								focus_set(focus->parent->sub[i]);
+								break;
+							}
+						break;
+					case S3DK_UP:
+						/* go in the first entry of this directory, if possible */
+						if (focus->n_sub>0)
+							focus_set(focus->sub[0]);
+						break;
+					case S3DK_DOWN:
+						/* go to first icon entry of parent,  or parent itself */
+						for (i=focus->parent->n_sub-1;i>=0;i--)
+							if (focus->parent->sub[i]->disp==D_ICON)
+							{ /* found a directory before, cycle */
+								focus_set(focus->parent->sub[i]);
+								break;
+							}
+						if (i==0) /* no icons? go to parent. */
+							focus_set(focus->parent);
+						break;
+
+
+
+				}
+				break;
+			case D_ICON:
+				switch (keysym)
+				{
+					case S3DK_LEFT:
+						/* search for the next icon on the left side */
+						i=focus->pindex;
+						do {
+							i--;
+							if (i<0) i=focus->parent->n_sub-1;
+						} while (focus->parent->sub[i]->disp!=D_ICON);
+						focus_set(focus->parent->sub[i]);
+						break;
+					case S3DK_RIGHT:
+						/* search for the next icon on the right side */
+						i=focus->pindex;
+						do {
+							i++;
+							if (i>=focus->parent->n_sub) i=0;
+						} while (focus->parent->sub[i]->disp!=D_ICON);
+						focus_set(focus->parent->sub[i]);
+						break;
+					case S3DK_UP:
+						/* search for the next icon on the left side */
+						i=focus->pindex;
+						rowsize=ceil(sqrt(focus->parent->n_sub)); /* items per line */
+						do {
+							i+=rowsize;
+							if (i>=focus->parent->n_sub) break;
+						} while (focus->parent->sub[i]->disp!=D_ICON);
+						if (i>=focus->parent->n_sub) 
+						{
+							/* go to the first activated dir above ... */
+							for (i=0;i<focus->parent->n_sub;i++)
+								if (focus->parent->sub[i]->disp==D_DIR)
+								{ /* found a directory before, cycle */
+									focus_set(focus->parent->sub[i]);
+									break;
+								}
+						}
+						else		focus_set(focus->parent->sub[i]);
+						break;
+					case S3DK_DOWN:
+						/* search for the next icon on the left side */
+						i=focus->pindex;
+						rowsize=ceil(sqrt(focus->parent->n_sub)); /* items per line */
+						do {
+							i-=rowsize;
+							if (i<0) break;
+						} while (focus->parent->sub[i]->disp!=D_ICON);
+						if (i<0) 
+							focus_set(focus->parent);
+						else						
+							focus_set(focus->parent->sub[i]);
+						break;
+
+				}
+				break;
+		}
+	} else {
+		/* probably root */
+		switch (keysym)
+		{
+			case S3DK_UP:
+				/* go in the first entry of this directory, if possible */
+				if (focus->n_sub>0)
+					focus_set(focus->sub[0]);
+				break;
+		}
+	}
+
+}

Modified: trunk/apps/s3dfm/icon.c
===================================================================
--- trunk/apps/s3dfm/icon.c	2006-09-26 22:37:02 UTC (rev 439)
+++ trunk/apps/s3dfm/icon.c	2006-09-28 09:45:35 UTC (rev 440)
@@ -22,10 +22,34 @@
  */
 
 #include "s3dfm.h"
-#include <stdio.h> 	 /*  printf() */
-#include <math.h>	 /*  sin(),cos() */
-#include <string.h>  /*  strlen() */
-/* draws icon dir, which is number i (used for nice coloring) */
+#include <stdio.h> 	 /* printf() */
+#include <math.h>	 /* sin(),cos() */
+#include <string.h>  /* strlen() */
+#include <stdlib.h>  /* memcpy() */
+float icon_colors[T_TYPENUM][12]={
+		/* T_DUNO */
+	{	0,0,0.5,1.0,
+		0,0,0.5,1.0,
+		0,0,0.5,1.0 },
+		/* T_FOLDER */
+	{	0.4,0.4,0,1.0,
+		0.4,0.4,0,1.0,
+		0.4,0.4,0,1.0}};
+
+/* gives another color for the focused item */
+void icon_focus_color(t_node *dir, int on)
+{
+	float color[12];
+	int i;
+	memcpy(color,icon_colors[dir->type],sizeof(color));
+	if (on) for(i=0;i<3;i++) {
+			color[i*4 + 0]+=0.3;
+			color[i*4 + 1]+=0.3;
+			color[i*4 + 2]+=0.3;
+	}
+	s3d_pep_materials_a(dir->oid,color,1);
+}
+/* draws icon dir */
 int icon_draw(t_node *dir)
 {
 	float vertices[]={	-1,-0.5,0,
@@ -48,20 +72,7 @@
 	/* create the block */
 	dir->oid=s3d_new_object();
 	s3d_push_vertices(dir->oid,vertices,8);
-	switch (dir->type)
-	{
-		case T_FOLDER:
-			s3d_push_material(dir->oid,
-									0.4,0.4,0,
-									0.4,0.4,0,
-									0.4,0.4,0);
-			break;
-		default:
-			s3d_push_material(dir->oid,
-									0,0,0.5,
-									0,0,0.5,
-									0,0,0.5);
-	};
+	s3d_push_materials_a(dir->oid,icon_colors[dir->type],1);
 	s3d_push_polygons(dir->oid,polys,10);
 
 	/* draw and position the string */

Modified: trunk/apps/s3dfm/main.c
===================================================================
--- trunk/apps/s3dfm/main.c	2006-09-26 22:37:02 UTC (rev 439)
+++ trunk/apps/s3dfm/main.c	2006-09-28 09:45:35 UTC (rev 440)
@@ -55,7 +55,7 @@
 		parse_dir(&root);
 		box_draw(&root);
 		ani_doit(&root);
-		ani_focus(&root);
+		focus_set(&root);
 		
 		
 		

Modified: trunk/apps/s3dfm/node.c
===================================================================
--- trunk/apps/s3dfm/node.c	2006-09-26 22:37:02 UTC (rev 439)
+++ trunk/apps/s3dfm/node.c	2006-09-28 09:45:35 UTC (rev 440)
@@ -106,8 +106,8 @@
 	dir->disp=D_NONE;
 	dir->parsed=0;
 
+	dir->pindex=-1;
 	dir->check=0;
-	dir->px=root.pz=0.0;
 	dir->dirs_opened=0;
 	dir->type=T_DUNO;
 	dir->px=dir->py=dir->pz=0.0;
@@ -153,17 +153,35 @@
 /* node select handles click on the detach button. selected items can be moved, copied etc.*/
 void node_select(t_node *dir)
 {
+		
 	dir->detached=dir->detached?0:1; /* swapping, not sure if !dir->detached would do the same .. */
 	switch (dir->disp)
 	{
 		case D_DIR:
+			focus_set(dir);
 			if (dir->parent!=NULL)
 				box_order_subdirs(dir->parent);
 			break;
 		case D_ICON:
-			dir->pz=dir->detached*0.2+1.0;
-			ani_add(dir);
+			if (dir->type==T_FOLDER)
+			{
+				dir->detached=0;
+				parse_dir(dir);
+				box_expand(dir);
+			} else {
+				dir->pz=dir->detached*0.2+1.0;
+				ani_add(dir);
+			}
+			focus_set(dir);
 			break;
-		/* nothing yet ... */
 	}
 }
+/* change color etc if a node is focused */
+void node_focus_color(t_node *node, int on)
+{
+	switch (node->disp)
+	{
+		case D_DIR:  box_focus_color(node,on);	break;
+		case D_ICON: icon_focus_color(node,on); break;
+	}
+}

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2006-09-26 22:37:02 UTC (rev 439)
+++ trunk/apps/s3dfm/parse.c	2006-09-28 09:45:35 UTC (rev 440)
@@ -74,6 +74,8 @@
 					dir->sub[i]->parent = dir;
 				}
 				/* find out the filetype ... very simple */
+				dir->sub[i]->type=T_DUNO;
+				dir->sub[i]->pindex=i;
 				ext=strrchr(nstr,'.');
 				strncpy(ndir,path,M_DIR);
 		    	strncat(ndir,namelist[n]->d_name,M_DIR);
@@ -81,11 +83,11 @@
 				{
 					dir->sub[i]->type=T_FOLDER;
 					closedir(dirhd);
-				} else if (ext!=NULL)
+				} /*else if (ext!=NULL)
 				   {
 					   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))		   dir->sub[i]->type=T_GEOMETRY;
 					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))	   dir->sub[i]->type=T_MUSIC;
-				   }	
+				   }	*/
 				dir->sub[i]->check=0; /* check=0 means we've already processed this item */
 			}
 	   	    free(namelist[n]);
@@ -100,6 +102,7 @@
 				node_delete(dir->sub[i]);
 				dir->n_sub--;
 				dir->sub[i]=dir->sub[dir->n_sub]; /* exchange with the last one */
+				dir->sub[i]->pindex=i;
 				dir->check=1;
 			}
 		/* if we removed something, then shrink the buffer accordingly .. */

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2006-09-26 22:37:02 UTC (rev 439)
+++ trunk/apps/s3dfm/s3dfm.h	2006-09-28 09:45:35 UTC (rev 440)
@@ -25,11 +25,8 @@
 #include <s3d.h>
 #include <s3dw.h>
 #define T_DUNO		0
-#define T_LOCALDIR	1
-#define T_BACKDIR	2
-#define T_FOLDER	3
-#define T_GEOMETRY	4
-#define T_MUSIC		5
+#define T_FOLDER	1
+#define T_TYPENUM	2
 
 #define M_DIR		512
 #define M_NAME		256
@@ -61,6 +58,7 @@
 #define D_DIR		2
 	int				 parsed,detached;					/* Flags for parsed/detached (selected) nodes ... */
 	int 			 oid;								/* main oid, e.g the block or icons oid */
+	int 			 pindex;							/* the index in parents structure */
 	struct 			 {	
 		/* some objects which might be used ... if not, should be -1 */
 		int 		 close,select,title,titlestr; /* box decorations. */
@@ -83,8 +81,6 @@
 extern t_node *focus;	/* the focused object */
 
 /* animation.c */
-float		 ani_get_scale(t_node *f);
-void 		 ani_focus(t_node *f);
 int 		 ani_onstack(t_node *f);
 void 		 ani_add(t_node *f);
 void 		 ani_del(int i);
@@ -104,6 +100,7 @@
 int 		 box_expand(t_node *dir);
 int 		 box_unexpand(t_node *dir);
 int 		 box_close(t_node *dir,int force);
+void 		 box_focus_color(t_node *dir, int on);
 /* dialog.c */
 void		 close_win(s3dw_widget *button);
 void		 window_help();
@@ -120,6 +117,10 @@
 void 		 event_click(struct s3d_evt *evt);
 void		 event_key(struct s3d_evt *evt);
 void		 event_oinfo(struct s3d_evt *hrmz);
+/* focus.c */
+void 		 focus_by_key(int keysym);
+float		 focus_get_scale(t_node *f);
+void 		 focus_set(t_node *f);
 /* fs.c */
 filelist	 *fl_new(char *path);
 void		 fl_del(filelist *fl);
@@ -130,9 +131,11 @@
 void	 	 fs_approx(char *source, int *files, int *dirs, int *bytes);
 int			 fs_copy(char *source, char *dest);
 int			 fs_move(char *source, char *dest);
-int			 fs_unlink(char *dest);/* icon.c */
+int			 fs_unlink(char *dest);
+/* icon.c */
 int 		 icon_draw(t_node *dir);
 int 		 icon_undisplay(t_node *dir);
+void 		 icon_focus_color(t_node *dir, int on);
 /* node.c */
 t_node 		*node_getbypath(char *path);
 void 		 node_path(t_node *dir, char *path);
@@ -141,6 +144,7 @@
 int 		 node_delete(t_node *dir);
 int 		 node_undisplay(t_node *dir);
 void		 node_select(t_node *dir);
+void 		 node_focus_color(t_node *node, int on);
 /* parse.c */
 int 		 parse_dir(t_node *dir);
 /* string.c */
@@ -148,3 +152,5 @@
 char 		*dots_at_start(char *str, unsigned int n, t_node *d);
 char		*mstrncat(char *dest, const char *src, int n);
 char		*mstrncpy(char *dest, const char *src, int n);
+/* fly.c */
+int 		 fly_set_absolute_position(t_node *node);



From dotslash at mail.berlios.de  Thu Sep 28 12:35:08 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 28 Sep 2006 12:35:08 +0200
Subject: [S3d-svn] r441 - in trunk: . apps/dot_mcp apps/olsrs3d
	apps/s3d_x11gate apps/s3dfm apps/s3dvt example libs3d libs3dw
Message-ID: <200609281035.k8SAZ8RJ013148@sheep.berlios.de>

Author: dotslash
Date: 2006-09-28 12:35:05 +0200 (Thu, 28 Sep 2006)
New Revision: 441

Modified:
   trunk/
   trunk/apps/dot_mcp/main.c
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/search.c
   trunk/apps/olsrs3d/search.h
   trunk/apps/s3d_x11gate/s3d_x11gate.c
   trunk/apps/s3dfm/event.c
   trunk/apps/s3dfm/s3dfm.h
   trunk/apps/s3dvt/main.c
   trunk/example/filebrowser.c
   trunk/example/modelloader.c
   trunk/example/nichtsnutz.c
   trunk/example/ptrtest.c
   trunk/example/widgets.c
   trunk/libs3d/callback.c
   trunk/libs3d/s3d.h
   trunk/libs3dw/event.c
   trunk/libs3dw/s3dw.h
Log:
 r1071 at balthasar:  dotslash | 2006-09-28 12:34:56 +0200
 - events now return int, not void



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1069
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1071

Modified: trunk/apps/dot_mcp/main.c
===================================================================
--- trunk/apps/dot_mcp/main.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/apps/dot_mcp/main.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -241,9 +241,10 @@
 	} 
 	return(a);
 }
-void stop()
+int stop()
 {
 	s3d_quit();
+	return(0);
 }
 void place_apps()
 {
@@ -277,7 +278,7 @@
 	xa=s3d_vector_angle(v,u);
 	s3d_rotate(menu, 0 ,30,0); 
 }
-void mcp_object(struct s3d_evt *hrmz)
+int mcp_object(struct s3d_evt *hrmz)
 {
 	struct mcp_object *mo;
 	struct app *a;
@@ -311,6 +312,7 @@
 		}
 		place_apps();
 	}
+	return(0);
 }
 void app_init(struct app *a)
 {
@@ -348,24 +350,23 @@
 	else*/
 		place_apps();
 }
-void mcp_del_object(struct s3d_evt *hrmz)
+int mcp_del_object(struct s3d_evt *hrmz)
 {
 	struct mcp_object *mo;
-	printf("omg, something got deleted!!\n");
 	mo=(struct mcp_object *)hrmz->buf;
 	del_app(mo->object);
+	return(0);
 }
-void object_click(struct s3d_evt *hrmz)
+int object_click(struct s3d_evt *hrmz)
 {
 	struct app *a;
 	unsigned int i, oid;
 	oid=*((unsigned int *)hrmz->buf);
-	printf("%d got clicked\n",oid);
 	a=apps;i=0;
 	if (oid==rotate)
 	{
 		rot_flag=!rot_flag;
-		return;
+		return(0);
 	}
 	if (oid==reset)
 	{
@@ -377,26 +378,27 @@
 		if (oid==a->close_but)
 		{
 			del_app(a->oid);
-			return;
+			return(0);
 		} else 	if (oid==a->min_but)
 		{
 			if (a==focus)
 			{
 				set_focus(NULL); /* nothing is focused now */
 			}
-			return;
+			return(0);
 		} else 	if (((oid==a->title) || (oid==a->sphere)) || (oid==a->oid))
 		{
 			printf("giving focus to [%s], %d\n",a->name,oid);
 			set_focus(a);
-			return;
+			return(0);
 		}
 		i++;
 		a=a->next;
 	}
 	menu_click(oid);
+	return(0);
 }
-void object_info(struct s3d_evt *hrmz)
+int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz->buf;
@@ -424,6 +426,7 @@
 			place_apps(); /* replace apps */
 		}
 	}
+	return(0);
 }
 void mainloop()
 {
@@ -462,7 +465,7 @@
 	nanosleep(&t,NULL); 
 }
 
-void keydown(struct s3d_evt *event)
+int keydown(struct s3d_evt *event)
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
 	switch (keys->keysym)
@@ -477,8 +480,9 @@
 		case 's':ydif+= 1.0;break;
 		case 'd':xdif+= 1.0;break;
 	}
+	return(0);
 }
-void keyup(struct s3d_evt *event)
+int keyup(struct s3d_evt *event)
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
 	switch (keys->keysym)
@@ -488,6 +492,7 @@
 		case 's':ydif-= 1.0;break;
 		case 'd':xdif-= 1.0;break;
 	}
+	return(0);
 
 }
 

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/apps/olsrs3d/main.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -29,11 +29,12 @@
 #include <s3d.h>
 #include <s3d_keysym.h>
 #include <s3dw.h>
-#include <time.h>	      /* nanosleep() */
-#include <string.h>	/* strncpy() */
-#include <math.h>		/* sqrt() */
-#include <getopt.h>	/* getopt() */
-#include <stdlib.h>	/* exit() */
+#include <sys/time.h>	 /* gettimeofday() */
+#include <time.h>	     /* nanosleep() */
+#include <string.h>		 /* strncpy() */
+#include <math.h>		 /* sqrt() */
+#include <getopt.h>		 /* getopt() */
+#include <stdlib.h>		 /* exit() */
 #include "olsrs3d.h"
 #include "search.h"
 
@@ -181,7 +182,7 @@
 
 	struct timeval tv;
 
-	gettimeofday(tv, NULL);
+	gettimeofday(&tv, NULL);
 
 	return tv.tv_sec * 1000 + tv.tv_usec / 1000;
 
@@ -782,11 +783,10 @@
 
 }
 
-void stop() {
-
+int stop() {
 	s3d_quit();
 	net_quit();
-
+	return(0);
 }
 
 /***
@@ -795,7 +795,7 @@
  *
  ***/
 
-void keypress(struct s3d_evt *event) {
+int keypress(struct s3d_evt *event) {
 
 	struct s3d_key_event *key=(struct s3d_key_event *)event->buf;
 	if( get_search_status() != WIDGET )
@@ -881,6 +881,7 @@
 		if( (key->keysym >= S3DK_PERIOD && key->keysym <= S3DK_9) || key->keysym == S3DK_COMMA || key->keysym == S3DK_RETURN || key->keysym == S3DK_BACKSPACE )
 			search_widget_write( key->keysym );
 	}
+	return(0);
 }
 
 /***
@@ -889,12 +890,13 @@
  *
  ***/
 
-void object_click(struct s3d_evt *evt)
+int object_click(struct s3d_evt *evt)
 {
-	int oid, i;
+/*	int i
 	char ip_str[50];
+	struct timeval tv;*/
 	struct olsr_node *olsr_node;
-	struct timeval tv;
+	int oid;
 
 	s3dw_handle_click(evt);
 /*	if( get_search_status() == WIDGET )
@@ -968,6 +970,7 @@
 		s3d_translate( Olsr_ip_label_obj,-Left*3.0-(Title_len * 0.2)-0.15, -Bottom*3.0-1.0, -3.0 );
 
 	}*/
+	return(0);
 }
 
 void print_etx()
@@ -1087,7 +1090,7 @@
  *
  ***/
 
-void object_info(struct s3d_evt *hrmz)
+int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz->buf;
@@ -1113,14 +1116,15 @@
 
 	}
 	/* printf("%f %f %f\n",inf->trans_x,inf->trans_y,inf->trans_z); */
+	return(0);
 }
 
-void mbutton_press(struct s3d_evt *hrmz)
+int mbutton_press(struct s3d_evt *hrmz)
 {
 	struct s3d_but_info *inf;
 	inf=(struct s3d_but_info *)hrmz->buf;
 	printf("button %d, state %d\n", inf->button,inf->state);
-	return;
+	return(0);
 }
 
 int main( int argc, char *argv[] ) {

Modified: trunk/apps/olsrs3d/search.c
===================================================================
--- trunk/apps/olsrs3d/search.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/apps/olsrs3d/search.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -111,7 +111,7 @@
 	s3dw_focus	( S3DWIDGET( _search_surface ) );
 	s3dw_show	( S3DWIDGET( _search_surface ) );
 
-	_search_widget	= search_button;
+	_search_widget	= S3DWIDGET(search_button);
 }
 
 /* public */

Modified: trunk/apps/olsrs3d/search.h
===================================================================
--- trunk/apps/olsrs3d/search.h	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/apps/olsrs3d/search.h	2006-09-28 10:35:05 UTC (rev 441)
@@ -36,5 +36,6 @@
 void search_widget_write(int key);
 void set_node_root(struct olsr_node *root);
 void follow_node(float cam_position_t[], float cam_position_r[],float rotate);
+void follow_node_by_click(struct olsr_node *olsr_node);
 
 void show_search_window();

Modified: trunk/apps/s3d_x11gate/s3d_x11gate.c
===================================================================
--- trunk/apps/s3d_x11gate/s3d_x11gate.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/apps/s3d_x11gate/s3d_x11gate.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -153,7 +153,7 @@
 /*	XDestroyImage(image);*/
 /*	nanosleep(&t,NULL); */
 }
-void keypress(struct s3d_evt *event)
+int keypress(struct s3d_evt *event)
 {
 	int key;
 	int kc;
@@ -176,15 +176,17 @@
 	if (kc!=0)
 	    XTestFakeKeyEvent(dpy, kc, 1, 1);
 /*	    XTestFakeKeyEvent(dpy, kc, 0, 1);*/
+	return(0);
 
 }
-void mouseclick(struct s3d_evt *event)
+int mouseclick(struct s3d_evt *event)
 {
 	int i;
 	printf("thats it, collecting:\n");
 	for (i=0;i<3;i++)
 		printf("[%d] %f\n",i,count[i]/iterations);
 	exit(0);	
+	return(0);
 }
 int main(int argc, char **argv)
 {

Modified: trunk/apps/s3dfm/event.c
===================================================================
--- trunk/apps/s3dfm/event.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/apps/s3dfm/event.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -30,7 +30,7 @@
 int typeinput=0;
 
 /* info packets handler, we're just interested in the cam */
-void event_oinfo(struct s3d_evt *hrmz)
+int event_oinfo(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz->buf;
@@ -41,17 +41,18 @@
 		cam.dpz=inf->trans_z;
 	}
 	s3dw_object_info(hrmz);
+	return(0);
 }
 
 /* keyevent handler */
-void event_key(struct s3d_evt *evt)
+int event_key(struct s3d_evt *evt)
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)evt->buf;
 	char path[M_DIR];
 	if (typeinput) {	/* we have some inputfield now and want the s3dw to handle our input */	
 			printf("inputting text ...\n");
 			s3dw_handle_key(evt); 
-			return; 
+			return(0); 
 	}
 	node_path(focus,path);
 	switch (keys->keysym)
@@ -91,7 +92,6 @@
 		case S3DK_RIGHT:
 		case S3DK_DOWN:
 				focus_by_key(keys->keysym);
-				printf("pindex of focus = %d\n",focus->pindex);
 				break;
 		case S3DK_RETURN:
 		case S3DK_SPACE:
@@ -106,10 +106,11 @@
 				
 	}
 	s3dw_handle_key(evt);
+	return(0);
 }
 
 /* object click handler */
-void event_click(struct s3d_evt *evt)
+int event_click(struct s3d_evt *evt)
 {
 	int oid;
 	t_node *f;
@@ -120,17 +121,18 @@
 		if (f->objs.close==oid)
 		{
 			box_close(f,1);
-			return;
+			return(0);
 		}
 		if (f->objs.select==oid)
 		{
 			printf("[S]electing %s\n",f->name);
 			node_select(f);
-			return;
+			return(0);
 		}
 		node_select(f);
 	} else {
 /*		printf("[C]ould not find :/\n");*/
 	}
+	return(0);
 }
 

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/apps/s3dfm/s3dfm.h	2006-09-28 10:35:05 UTC (rev 441)
@@ -114,9 +114,9 @@
 void		 window_move(char *path);
 void		 window_info(char *path);
 /* event.c */
-void 		 event_click(struct s3d_evt *evt);
-void		 event_key(struct s3d_evt *evt);
-void		 event_oinfo(struct s3d_evt *hrmz);
+int 		 event_click(struct s3d_evt *evt);
+int			 event_key(struct s3d_evt *evt);
+int			 event_oinfo(struct s3d_evt *hrmz);
 /* focus.c */
 void 		 focus_by_key(int keysym);
 float		 focus_get_scale(t_node *f);

Modified: trunk/apps/s3dvt/main.c
===================================================================
--- trunk/apps/s3dvt/main.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/apps/s3dvt/main.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -395,7 +395,7 @@
 / * 		printf("\n"); * / 
 	}
 }*/
-void keypress(struct s3d_evt *event)
+int keypress(struct s3d_evt *event)
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)event->buf;
 	int key;
@@ -485,6 +485,7 @@
 			if ((char)keys->unicode)  /*  \0 is no good idea .. */
 				term_addchar((char)keys->unicode);
 	}
+	return(0);
 
 }
 int i=0;
@@ -511,9 +512,10 @@
 		paintit();
 	}
 }
-void stop(struct s3d_evt *event)
+int stop(struct s3d_evt *event)
 {
 	s3d_quit();
+	return(0);
 }
 unsigned int draw_background()
 {

Modified: trunk/example/filebrowser.c
===================================================================
--- trunk/example/filebrowser.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/example/filebrowser.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -178,7 +178,7 @@
 	return(0);
 }
 
-void object_click(struct s3d_evt *evt)
+int object_click(struct s3d_evt *evt)
 {
 	int i,oid;
 	char execstr[256];
@@ -197,25 +197,26 @@
 						printf("going into %s\n",item[i].name);
 						chdir(item[i].name);
 						display_dir(".",0,0,0,0);
-						return;
+						return(0);
 						break;
 				case T_GEOMETRY:
 						printf("loading geometry %s\n",item[i].name);
 						snprintf(execstr,256,"modelloader \"%s\"&\n",item[i].name);
 						system(execstr);
-						return;
+						return(0);
 						break;
 				case T_MOVIE:
 						printf("playing %s\n",item[i].name);
 						snprintf(execstr,256,"mplayer -vo s3d \"%s\"&\n",item[i].name);
 						system(execstr);
-						return;
+						return(0);
 						break;
 
 						
 			}
 		}
 	}
+	return(0);
 }
 void mainloop()
 {

Modified: trunk/example/modelloader.c
===================================================================
--- trunk/example/modelloader.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/example/modelloader.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -35,9 +35,10 @@
 	i++;
 	nanosleep(&t,NULL); 
 }
-void object_click(struct s3d_evt *evt)
+int object_click(struct s3d_evt *evt)
 {
 	s3d_quit();
+	return(0);
 }
 	
 int main (int argc, char **argv)

Modified: trunk/example/nichtsnutz.c
===================================================================
--- trunk/example/nichtsnutz.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/example/nichtsnutz.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -100,7 +100,7 @@
 	nanosleep(&t,NULL); 
 }
 
-void object_info(struct s3d_evt *hrmz)
+int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz->buf;
@@ -124,11 +124,12 @@
 			Left=-1.0;
 		}
 	}
+	return(0);
 }
 
 
 
-void keypress(struct s3d_evt *event)
+int keypress(struct s3d_evt *event)
 {
 	int key;
 	key=*((unsigned short *)event->buf);
@@ -147,6 +148,7 @@
 				}
 				break;
 	}
+	return(0);
 }
 
 

Modified: trunk/example/ptrtest.c
===================================================================
--- trunk/example/ptrtest.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/example/ptrtest.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -34,9 +34,10 @@
 float len=1.0;
 int alpha=0;
 static struct timespec t={0,10*1000*1000}; /* 100 mili seconds */
-void stop(struct s3d_evt *evt)
+int stop(struct s3d_evt *evt)
 {
 	s3d_quit();
+	return(0);
 }
 
 void mainloop()
@@ -49,7 +50,7 @@
 	s3d_rotate(0,sin(a)*30,alpha,0);
 	nanosleep(&t,NULL); 
 }
-void object_info(struct s3d_evt *hrmz)
+int object_info(struct s3d_evt *hrmz)
 {
 	struct s3d_obj_info *inf;
 	inf=(struct s3d_obj_info *)hrmz->buf;
@@ -73,8 +74,9 @@
 	{ /* of course, a link s3d_link(o,1 would be much easier ... */
 		s3d_translate(o,(inf->trans_x)*2.0,(inf->trans_y)*2.0,-2);
 	}
+	return(0);
 }
-void mbutton_press(struct s3d_evt *hrmz)
+int mbutton_press(struct s3d_evt *hrmz)
 {
 	struct s3d_but_info *inf;
 	char s[256];
@@ -88,6 +90,7 @@
 	s3d_link(o,0);			/* link to cam */
 /*	s3d_link(o,1);*/
 	s3d_flags_on(o,S3D_OF_VISIBLE);
+	return(0);
 }
 int main (int argc, char **argv)
 {

Modified: trunk/example/widgets.c
===================================================================
--- trunk/example/widgets.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/example/widgets.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -43,15 +43,15 @@
 /* you should always put the s3dw-handler in your own event handler,
  * if you want s3dw to react on clicks or keys ... and i'm sure you
  * want that ... */
-void click(struct s3d_evt *evt)
+int click(struct s3d_evt *evt)
 {
-	s3dw_handle_click(evt);
+	return(s3dw_handle_click(evt));
 }
 void key_button(s3dw_widget *button)
 {
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 }
-void key(struct s3d_evt *evt)
+int key(struct s3d_evt *evt)
 {
 	struct s3d_key_event *key=(struct s3d_key_event *)evt->buf;
 	char string[8];
@@ -73,6 +73,7 @@
 		/* of couse, show it */
 		s3dw_show(S3DWIDGET(miniwin));
 	}
+	return(0);
 
 }
 

Modified: trunk/libs3d/callback.c
===================================================================
--- trunk/libs3d/callback.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/libs3d/callback.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -24,7 +24,7 @@
 
 #include "s3d.h"
 #include "s3dlib.h"
-static void _s3d_ignore(struct s3d_evt *evt);
+static int _s3d_ignore(struct s3d_evt *evt);
 /*  the s3d callback list */
 /* i know it's ugly, but it's better to have ugly code somewhere than provoke
  * race conditions in the applications code */
@@ -50,7 +50,7 @@
 			NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL
 			};
 /* the ignore-handler ;) */
-static void _s3d_ignore(struct s3d_evt *evt)
+static int _s3d_ignore(struct s3d_evt *evt)
 {
 	/* do plain nothing */
 }

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/libs3d/s3d.h	2006-09-28 10:35:05 UTC (rev 441)
@@ -29,7 +29,7 @@
 	struct s3d_evt *next;
 };
 
-typedef void (*s3d_cb)(struct s3d_evt *);
+typedef int (*s3d_cb)(struct s3d_evt *);
 
 #define S3D_EVENT_OBJ_CLICK		1
 #define S3D_EVENT_KEY			2

Modified: trunk/libs3dw/event.c
===================================================================
--- trunk/libs3dw/event.c	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/libs3dw/event.c	2006-09-28 10:35:05 UTC (rev 441)
@@ -24,20 +24,19 @@
 #include <s3d.h>
 #include <s3dw.h>
 #include <s3dw_int.h>
-static int modkey;
 extern s3dw_widget *_s3dw_cam;
-void s3dw_handle_click(struct s3d_evt *evt)
+int s3dw_handle_click(struct s3d_evt *evt)
 {
 	unsigned long oid=*((unsigned long *)evt->buf);
-	s3dw_widget_event_click(s3dw_getroot(),oid);
+	return(s3dw_widget_event_click(s3dw_getroot(),oid));
 }
-void s3dw_handle_key(struct s3d_evt *evt)
+int s3dw_handle_key(struct s3d_evt *evt)
 {
 	struct s3d_key_event *keys=(struct s3d_key_event *)evt->buf;
-	s3dw_widget_event_key(s3dw_getroot(),keys);
+	return(s3dw_widget_event_key(s3dw_getroot(),keys));
 }
 
-void s3dw_object_info(struct s3d_evt *evt)
+int s3dw_object_info(struct s3d_evt *evt)
 {
 	struct s3d_obj_info *info=(struct s3d_obj_info *)evt->buf;
 	if (info->object==0) /* the _s3dw_cam */
@@ -53,4 +52,5 @@
 		_s3dw_cam->flags&=~S3DW_ARRANGED;
 		s3dw_ani_needarr();
 	}
+	return(0);
 }

Modified: trunk/libs3dw/s3dw.h
===================================================================
--- trunk/libs3dw/s3dw.h	2006-09-28 09:45:35 UTC (rev 440)
+++ trunk/libs3dw/s3dw.h	2006-09-28 10:35:05 UTC (rev 441)
@@ -137,8 +137,8 @@
 void 				 s3dw_show(s3dw_widget *widget);
 void 				 s3dw_focus(s3dw_widget *focus);
 
-void 				 s3dw_handle_click(struct s3d_evt *evt);
-void 				 s3dw_handle_key(struct s3d_evt *evt);
-void 				 s3dw_object_info(struct s3d_evt *evt);
+int 				 s3dw_handle_click(struct s3d_evt *evt);
+int 				 s3dw_handle_key(struct s3d_evt *evt);
+int 				 s3dw_object_info(struct s3d_evt *evt);
 
 void 				 s3dw_ani_mate();



From dotslash at mail.berlios.de  Thu Sep 28 18:22:57 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 28 Sep 2006 18:22:57 +0200
Subject: [S3d-svn] r442 - in trunk: . apps/s3dfm
Message-ID: <200609281622.k8SGMva3032555@sheep.berlios.de>

Author: dotslash
Date: 2006-09-28 18:22:56 +0200 (Thu, 28 Sep 2006)
New Revision: 442

Modified:
   trunk/
   trunk/apps/s3dfm/TODO
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/event.c
   trunk/apps/s3dfm/fly.c
   trunk/apps/s3dfm/fs.c
   trunk/apps/s3dfm/node.c
   trunk/apps/s3dfm/s3dfm.h
Log:
 r1073 at balthasar:  dotslash | 2006-09-28 18:22:51 +0200
 - selected targets (better, their icon copies) now levitate when e.g. pressing F5 to copy



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1071
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1073

Modified: trunk/apps/s3dfm/TODO
===================================================================
--- trunk/apps/s3dfm/TODO	2006-09-28 10:35:05 UTC (rev 441)
+++ trunk/apps/s3dfm/TODO	2006-09-28 16:22:56 UTC (rev 442)
@@ -1,4 +1,3 @@
-- focus
 - let blocks fly in animation
 - copy
 - delete

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2006-09-28 10:35:05 UTC (rev 441)
+++ trunk/apps/s3dfm/dialog.c	2006-09-28 16:22:56 UTC (rev 442)
@@ -32,7 +32,7 @@
 #include <sys/types.h> /* mkdir() */
 
 static s3dw_input	 *input;
-static filelist fp={NULL,0};
+static filelist *fp;
 
 extern int typeinput;
 
@@ -52,10 +52,12 @@
 		if (dir->sub[i]->detached)
 		{
 			fp->n++;
-			fp->p=realloc(fp->p,sizeof(char *) * fp->n);
+			fp->p=realloc(fp->p,sizeof(t_file) * fp->n);
 			s=malloc(M_DIR);
 			node_path(dir->sub[i],s);
-			fp->p[fp->n - 1]=s;
+			fp->p[fp->n - 1].name=s;
+			fp->p[fp->n - 1].anode=fly_create_anode(dir->sub[i]);
+			fp->p[fp->n - 1].size=0; /*TODO: later */
 		}
 	}
 	return(0);
@@ -81,7 +83,7 @@
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;
-	infwin=s3dw_surface_new("Error",12,8);
+	infwin=s3dw_surface_new("Error",20,8);
 	s3dw_label_new(infwin,"Sorry, another FS Action is in Progress",1,2);
 	button=s3dw_button_new(infwin,"OK",5,5);
 	button->onclick=close_win;
@@ -115,12 +117,8 @@
 
 void window_fs_abort(s3dw_widget *button)
 {
-	int i;
-	for (i=0;i<fp.n;i++)
-		free(fp.p[i]);
-	if (fp.p!=NULL) free(fp.p);
-	fp.n=0;
-	fp.p=NULL;
+	fl_del(fp);
+	fp=NULL;
 	typeinput=0;
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 }
@@ -133,31 +131,32 @@
 
 	int i,m;
 
-	if (fp.n!=0) 	{	window_fs_another(); 	return; }
-	fp.n=0;
-	fp.p=NULL;
-	get_selected(&fp,&root);
-	printf("selected %d nodes\n",fp.n);
-	if (fp.n == 0)	{	window_fs_nothing();	return;	}
+	if (fp!=NULL) 	{	window_fs_another(); 	return; }
+	fp=malloc(sizeof(filelist));
+	fp->n=0;
+	fp->p=NULL;
+	get_selected(fp,&root);
+	printf("selected %d nodes\n",fp->n);
+	if (fp->n == 0)	{	window_fs_nothing();	free(fp); fp=NULL;return;	}
 	m=10;
-	for (i=0;i<fp.n;i++)
+	for (i=0;i<fp->n;i++)
 	{
-		if (strlen(fp.p[i])>m) m=strlen(fp.p[i]);
-		printf("%d: %s\n",i,fp.p[i]);
+		if (strlen(fp->p[i].name)>m) m=strlen(fp->p[i].name);
+		printf("%d: %s\n",i,fp->p[i].name);
 	}
 
 	l=(m+3)*0.7;
-	infwin=s3dw_surface_new("Copy Window",l,fp.n+8);
+	infwin=s3dw_surface_new("Copy Window",l,fp->n+8);
 	s3dw_label_new(infwin,"Copy: ",1,1);
-	for (i=0;i<fp.n;i++)
-		s3dw_label_new(infwin,fp.p[i],3,2+i);
-	s3dw_label_new(infwin,"to:",1,fp.n+3);
+	for (i=0;i<fp->n;i++)
+		s3dw_label_new(infwin,fp->p[i].name,3,2+i);
+	s3dw_label_new(infwin,"to:",1,fp->n+3);
 	node_path(focus,destdir);
-	s3dw_label_new(infwin,destdir,3,fp.n+4);
+	s3dw_label_new(infwin,destdir,3,fp->n+4);
 
-	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp.n+5);
+	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp->n+5);
 	okbutton->onclick=window_fs_abort;
-	abortbutton=s3dw_button_new(infwin,"abort",l/2,fp.n+5);
+	abortbutton=s3dw_button_new(infwin,"abort",l/2,fp->n+5);
 	abortbutton->onclick=window_fs_abort;
 
 	s3dw_show(S3DWIDGET(infwin));
@@ -193,7 +192,7 @@
 	s3dw_button  *okbutton,*abortbutton;
 	char string1[M_DIR];
 	float l;
-	if (fp.n!=0) {window_fs_another(); return; }
+	if (fp!=NULL) {window_fs_another(); return; }
 	snprintf(string1,M_DIR,"Create Directory in %s",path);
 	l=strlen(string1)*0.7;
 	infwin=s3dw_surface_new("Create Directory",l,8);
@@ -203,9 +202,9 @@
 	s3dw_focus(S3DWIDGET(input));
 	s3dw_focus(S3DWIDGET(infwin));
 	typeinput=1;
-	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp.n+5);
+	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp->n+5);
 	okbutton->onclick=window_fs_mkdir;
-	abortbutton=s3dw_button_new(infwin,"abort",l/2,fp.n+5);
+	abortbutton=s3dw_button_new(infwin,"abort",l/2,fp->n+5);
 	abortbutton->onclick=window_fs_abort;
 	s3dw_show(S3DWIDGET(infwin));
 
@@ -215,7 +214,7 @@
 {
 	s3dw_surface *infwin;
 	s3dw_button  *button;
-	if (fp.n!=0) {window_fs_another(); return; }
+	if (fp!=NULL) {window_fs_another(); return; }
 	infwin=s3dw_surface_new("Info Window",20,8);
 	s3dw_label_new(infwin,"Sorry, moving is not implemented yet.. :(",1,2);
 	button=s3dw_button_new(infwin,"Too bad",7,5);

Modified: trunk/apps/s3dfm/event.c
===================================================================
--- trunk/apps/s3dfm/event.c	2006-09-28 10:35:05 UTC (rev 441)
+++ trunk/apps/s3dfm/event.c	2006-09-28 16:22:56 UTC (rev 442)
@@ -83,10 +83,6 @@
 		case S3DK_F7:
 				window_mkdir(path);
 				break;
-		case S3DK_F10:
-				printf("focus %s\n",focus->name);
-				fly_set_absolute_position(focus);
-				break;
 		case S3DK_UP:
 		case S3DK_LEFT:
 		case S3DK_RIGHT:

Modified: trunk/apps/s3dfm/fly.c
===================================================================
--- trunk/apps/s3dfm/fly.c	2006-09-28 10:35:05 UTC (rev 441)
+++ trunk/apps/s3dfm/fly.c	2006-09-28 16:22:56 UTC (rev 442)
@@ -30,9 +30,10 @@
 	work->px+=f->px										* work->scale;
 	work->pz+=f->pz										* work->scale;
 	work->py+=f->py										* work->scale;
+	/*
 	printf("%s: %3.3f %3.3f %3.3f - %3.3f\n",f->name, f->px, f->py, f->pz, f->scale );
 	printf("### %3.3f %3.3f %3.3f - %3.3f)\n", work->px, work->py, work->pz, work->scale);
-
+	*/
 	if (f->parent==NULL)	work->scale = f->scale;
 	else					work->scale = work->scale * f->scale;
 	
@@ -41,14 +42,41 @@
 int fly_set_absolute_position(t_node *node)
 {
 	t_node work;
-	node_init(&work);
-	work.px = node->px;
-	work.py = node->py;
-	work.pz = node->pz;
-	printf("selected node %s: %3.3f %3.3f %3.3f, %3.3f\n",node->name, node->px, node->py, node->pz, node->scale);
-	work.parent = node->parent;
-	strncpy(work.name,node->name,M_NAME);
+	work.px=0;
+	work.py=0;
+	work.pz=0;
+	work.scale=1.0;
 	_get_pos(&work, node);
-	printf("absolute position: %f %f %f - %f\n", work.px, work.py, work.pz, work.scale);
+	node->px=work.px;
+	node->py=work.py;
+	node->pz=work.pz;
+	node->scale=work.scale;
+	printf("node coordinates: %3.3f %3.3f %3.3f %3.3f\n",node->px,node->py,node->pz,node->scale);
 	return(0);
 }
+/* create a copy of *node as an icon (block) which can be moved for animation ... */
+t_node *fly_create_anode(t_node *node)
+{
+	t_node *work;
+	work=malloc(sizeof(t_node));
+	node_init(work);
+	work->parent = node->parent;
+	work->scale = node->scale;
+	work->px = node->px;
+	work->py = node->py;
+	work->pz = node->pz;
+	work->type = node->type;
+	strncpy(work->name,node->name,M_NAME);
+	fly_set_absolute_position(work);
+	icon_draw(work);
+
+	work->dpx=work->px;
+	work->dpy=work->py;
+	work->dpz=work->pz;
+	work->dscale=work->scale;
+	work->py=2*work->scale - work->py; /* invert */
+    s3d_flags_on(work->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+    s3d_flags_on(work->objs.str,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	ani_add(work);
+	return(work);
+}

Modified: trunk/apps/s3dfm/fs.c
===================================================================
--- trunk/apps/s3dfm/fs.c	2006-09-28 10:35:05 UTC (rev 441)
+++ trunk/apps/s3dfm/fs.c	2006-09-28 16:22:56 UTC (rev 442)
@@ -58,16 +58,16 @@
 	} else {
 		j=0;
 		fl->n=n-2 ; /* ignore . and .. */
-		fl->p=malloc(sizeof(char *)*fl->n);
+		fl->p=malloc(sizeof(t_file)*fl->n);
 		for (i=0;i<n;i++)
 		{
 			name=namelist[i]->d_name;
 			if (!((strcmp(name,".")==0) || (strcmp(name,"..")==0))) /* ignore */
 			{
-				fl->p[j]=malloc(strlen(name)+strlen(path)+2);
-				strcpy(fl->p[j],path);
-				strcat(fl->p[j],"/");
-				strcat(fl->p[j],name);
+				fl->p[j].name=malloc(strlen(name)+strlen(path)+2);
+				strcpy(fl->p[j].name,path);
+				strcat(fl->p[j].name,"/");
+				strcat(fl->p[j].name,name);
 				j++;
 			}
 			free(namelist[i]);
@@ -87,7 +87,14 @@
 	int i;
 	for (i=0;i<fl->n;i++)
 	{
-		free(fl->p[i]);
+		free(fl->p[i].name);
+		if (fl->p[i].anode!=NULL)
+		{
+		/* maybe let node_delete do that? */
+			/*node_delete(fl->p[i].anode);*/
+			icon_undisplay(fl->p[i].anode);
+			free(fl->p[i].anode);
+		}
 	}
 	free(fl);
 }
@@ -136,7 +143,7 @@
 
 	for (i=0;i<fl->n;i++)
 	{
-		fs_approx(fl->p[i],&sfiles,&sdirs,&sbytes);
+		fs_approx(fl->p[i].name,&sfiles,&sdirs,&sbytes);
 		*files+=		sfiles;
 		*dirs+=			sdirs;
 		*bytes+=		sbytes;
@@ -196,13 +203,13 @@
 	r=0;
 	for (i=0;i<fl->n;i++)
 	{
-		bname=basename(fl->p[i]);
+		bname=basename(fl->p[i].name);
 		sdest=malloc(strlen(dest)+strlen(bname)+2);
 
 		strcpy(sdest,dest);
 		strcat(sdest,"/");
 		strcat(sdest,bname);
-		r|=fs_copy(fl->p[i],sdest);
+		r|=fs_copy(fl->p[i].name,sdest);
 
 		free(sdest);
 	}
@@ -248,8 +255,8 @@
 	r=0;
 	for (i=0;i<fl->n;i++)
 	{
-		printf("-> atomic unlink %s\n",fl->p[i]);
-		r|=fs_unlink(fl->p[i]);
+		printf("-> atomic unlink %s\n",fl->p[i].name);
+		r|=fs_unlink(fl->p[i].name);
 	}
 	return(r);
 
@@ -283,13 +290,13 @@
 	r=0;
 	for (i=0;i<fl->n;i++)
 	{
-		bname=basename(fl->p[i]);
+		bname=basename(fl->p[i].name);
 		sdest=malloc(strlen(dest)+strlen(bname)+2);
 
 		strcpy(sdest,dest);
 		strcat(sdest,"/");
 		strcat(sdest,bname);
-		r|=fs_move(fl->p[i],sdest);
+		r|=fs_move(fl->p[i].name,sdest);
 
 		free(sdest);
 	}

Modified: trunk/apps/s3dfm/node.c
===================================================================
--- trunk/apps/s3dfm/node.c	2006-09-28 10:35:05 UTC (rev 441)
+++ trunk/apps/s3dfm/node.c	2006-09-28 16:22:56 UTC (rev 442)
@@ -83,8 +83,9 @@
 	if (dir->parent!=NULL)
 	{
 		node_path(dir->parent,path);
+		if (dir->parent->parent!=NULL)
+			mstrncat(path,"/",M_DIR);
 		mstrncat(path,dir->name,M_DIR);
-		mstrncat(path,"/",M_DIR);
 	} else
 		mstrncpy(path,dir->name,M_DIR);
 }
@@ -158,7 +159,11 @@
 	switch (dir->disp)
 	{
 		case D_DIR:
-			focus_set(dir);
+			if (focus!=dir)
+			{
+				dir->detached=dir->detached?0:1; /* swap again, we actually don't want to have it detachedf now. */
+				focus_set(dir);
+			}
 			if (dir->parent!=NULL)
 				box_order_subdirs(dir->parent);
 			break;

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2006-09-28 10:35:05 UTC (rev 441)
+++ trunk/apps/s3dfm/s3dfm.h	2006-09-28 16:22:56 UTC (rev 442)
@@ -69,12 +69,18 @@
 	} 				 objs;
 	int 			 check;							    /* check marker, for internal things */
 };
+struct _t_file {
+	char *name;
+	int size;
+	struct _t_node *anode;
+};
 struct _filelist {
-	char **p;
+	struct _t_file *p;
 	int n;
 };
 typedef struct _filelist filelist;
 typedef struct _t_node   t_node;
+typedef struct _t_file	 t_file;
 
 
 extern t_node root,cam; /* some global objects */
@@ -154,3 +160,4 @@
 char		*mstrncpy(char *dest, const char *src, int n);
 /* fly.c */
 int 		 fly_set_absolute_position(t_node *node);
+t_node 		*fly_create_anode(t_node *node);



From dotslash at mail.berlios.de  Thu Sep 28 19:07:08 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 28 Sep 2006 19:07:08 +0200
Subject: [S3d-svn] r443 - in trunk: . apps/s3dfm
Message-ID: <200609281707.k8SH78Vm030989@sheep.berlios.de>

Author: dotslash
Date: 2006-09-28 19:07:07 +0200 (Thu, 28 Sep 2006)
New Revision: 443

Modified:
   trunk/
   trunk/apps/s3dfm/animation.c
   trunk/apps/s3dfm/box.c
   trunk/apps/s3dfm/dialog.c
   trunk/apps/s3dfm/event.c
   trunk/apps/s3dfm/node.c
   trunk/apps/s3dfm/parse.c
   trunk/apps/s3dfm/s3dfm.h
Log:
 r1075 at balthasar:  dotslash | 2006-09-28 19:06:58 +0200
 - directory parse errors in windows
 - refreshing now works preoperly
 - implemented node_delete



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1073
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1075

Modified: trunk/apps/s3dfm/animation.c
===================================================================
--- trunk/apps/s3dfm/animation.c	2006-09-28 16:22:56 UTC (rev 442)
+++ trunk/apps/s3dfm/animation.c	2006-09-28 17:07:07 UTC (rev 443)
@@ -36,8 +36,8 @@
 	int i;
 	for (i=0;i<ani_n;i++)
 		if (ani_s[i]==f)
-			return(1);		/* already in list */
-	return(0);
+			return(i);		/* already in list */
+	return(-1);
 
 }
 /* add an node on the animation stack */
@@ -45,7 +45,7 @@
 {
 	if (ani_n<MAXANI)
 	{
-		if (ani_onstack(f))
+		if (-1!=ani_onstack(f))
 			return;		/* already in list */
 		ani_s[ani_n]=f;
 		ani_iterate(f);

Modified: trunk/apps/s3dfm/box.c
===================================================================
--- trunk/apps/s3dfm/box.c	2006-09-28 16:22:56 UTC (rev 442)
+++ trunk/apps/s3dfm/box.c	2006-09-28 17:07:07 UTC (rev 443)
@@ -277,6 +277,7 @@
 	printf("box_unexpand( %s )\n",dir->name);
 	if (dir->parent==NULL) /* we can't do this on root.... */
 		return(-1);
+	dir->detached=0;
 	box_undisplay(dir);
 	icon_draw(dir);
 	dir->parent->dirs_opened--;
@@ -319,6 +320,7 @@
 			if (dir->sub[i]->disp==D_ICON)
 			{
 				icon_undisplay(dir->sub[i]);
+				dir->detached=0;
 				if (focus==dir->sub[i])
 					focus_set(dir->parent);
 			}
@@ -391,7 +393,7 @@
 		{
 			dir->sub[i]->px = -1 +2*  ((float)((int)i%dps)+0.5)/((float)dps);
 			dir->sub[i]->py = 0.5+((float)((int)i/dps)+0.5)/((float)dps)-0.5;
-			dir->sub[i]->pz = 1.0;
+			dir->sub[i]->pz=dir->sub[i]->detached*0.2+1.0;
 			dir->sub[i]->scale = (float)1.0/((float)dps);
 			s3d_link(dir->sub[i]->oid,dir->oid);	 /* if it's already displayed, make sure it linked properly ... */
 			ani_finish(dir->sub[i], -1);			 /* copy to the current animation state */

Modified: trunk/apps/s3dfm/dialog.c
===================================================================
--- trunk/apps/s3dfm/dialog.c	2006-09-28 16:22:56 UTC (rev 442)
+++ trunk/apps/s3dfm/dialog.c	2006-09-28 17:07:07 UTC (rev 443)
@@ -117,8 +117,12 @@
 
 void window_fs_abort(s3dw_widget *button)
 {
-	fl_del(fp);
-	fp=NULL;
+	/* delete a filelist, if there was any */
+	if (fp!=NULL)
+	{
+		fl_del(fp);
+		fp=NULL;
+	}
 	typeinput=0;
 	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
 }
@@ -179,9 +183,7 @@
 		} else {
 			printf("refreshing %s\n",item->name);
 /*			parse_again(item);*/
-
 		}
-				
 	}
 	window_fs_abort(button); /* finish */
 
@@ -202,9 +204,9 @@
 	s3dw_focus(S3DWIDGET(input));
 	s3dw_focus(S3DWIDGET(infwin));
 	typeinput=1;
-	okbutton=s3dw_button_new(infwin,"OK",l/2-3,fp->n+5);
+	okbutton=s3dw_button_new(infwin,"OK",l/2-3,5);
 	okbutton->onclick=window_fs_mkdir;
-	abortbutton=s3dw_button_new(infwin,"abort",l/2,fp->n+5);
+	abortbutton=s3dw_button_new(infwin,"abort",l/2,5);
 	abortbutton->onclick=window_fs_abort;
 	s3dw_show(S3DWIDGET(infwin));
 

Modified: trunk/apps/s3dfm/event.c
===================================================================
--- trunk/apps/s3dfm/event.c	2006-09-28 16:22:56 UTC (rev 442)
+++ trunk/apps/s3dfm/event.c	2006-09-28 17:07:07 UTC (rev 443)
@@ -54,7 +54,7 @@
 			s3dw_handle_key(evt); 
 			return(0); 
 	}
-	node_path(focus,path);
+	node_path(node_getdir(focus),path);
 	switch (keys->keysym)
 	{
 		case 'i':
@@ -66,9 +66,14 @@
 		case 'r':
 		case 'R':
 				{/* refresh this window ... */
-					printf("[R]efreshing %s\n",focus->name);
-/*					parse_again(focus);*/
-					focus_set(focus);
+					t_node *node;
+					node=node_getdir(focus);
+					printf("[R]efreshing %s\n",node->name);
+					parse_dir(node);
+					box_draw_icons(node);
+					box_order_icons(node);
+					box_order_subdirs(node);
+					
 				}
 				break;
 		case S3DK_F1:

Modified: trunk/apps/s3dfm/node.c
===================================================================
--- trunk/apps/s3dfm/node.c	2006-09-28 16:22:56 UTC (rev 442)
+++ trunk/apps/s3dfm/node.c	2006-09-28 17:07:07 UTC (rev 443)
@@ -24,6 +24,7 @@
 #include "s3dfm.h"
 #include <string.h>	/* strncpy(), index() */
 #include <stdio.h>	/* printf() */
+#include <stdlib.h> /* free() */
 /* find the node to a path, return NULL if not parsed yet */
 t_node *node_getbypath(char *path)
 {
@@ -133,22 +134,28 @@
 /* delete a node and all its kids internally, remove the graphics, reorder the parents etc ... */
 int node_delete(t_node *dir)
 {
-	/* TODO: IMPLEMENT IT, DAMNIT */
-	/*
 	int i;
-	printf("node_free( %s )\n",t->name);
-	switch (t->disp)
+	if (dir->parent==NULL) 
 	{
-			case D_DIR:  box_collapse(t,1); / * collapse this and its kids * /
-			case D_ICON: icon_undisplay(t);
+		printf("won't delete root window!\n");
+		return(-1);
 	}
-	if (t->n_item>0) {
-		for (i=0;i<t->n_item;i++)
-			node_free(&(t->sub[i]));
-		free(t->sub);
+	/* delete all the kids */
+	if (dir->n_sub>0) {
+		for (i=0;i<dir->n_sub;i++)
+			node_delete(dir->sub[i]);
+		free(dir->sub);
 	}
-	t->n_item=0;
-	*/
+	/* move focus upward, this should go up with the recursion */
+	if (focus==dir)	focus_set(dir->parent); /* do this before deleting the contents, its better ... */
+	switch (dir->disp)
+	{
+			case D_DIR:  box_undisplay(dir);
+			case D_ICON: icon_undisplay(dir);
+	}
+
+	if (-1!=(i=ani_onstack(dir))) ani_del(i); /* tell animation stack too */
+	free(dir);
 	return(0);
 }
 /* node select handles click on the detach button. selected items can be moved, copied etc.*/
@@ -171,8 +178,8 @@
 			if (dir->type==T_FOLDER)
 			{
 				dir->detached=0;
-				parse_dir(dir);
-				box_expand(dir);
+				if (!parse_dir(dir))
+					box_expand(dir);
 			} else {
 				dir->pz=dir->detached*0.2+1.0;
 				ani_add(dir);
@@ -190,3 +197,9 @@
 		case D_ICON: icon_focus_color(node,on); break;
 	}
 }
+/* get the directory of a node */
+t_node *node_getdir(t_node *node)
+{
+	if (node->type==T_FOLDER) return(node);
+	else return(node->parent);
+}

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2006-09-28 16:22:56 UTC (rev 442)
+++ trunk/apps/s3dfm/parse.c	2006-09-28 17:07:07 UTC (rev 443)
@@ -48,7 +48,7 @@
     n = i = scandir(path, &namelist, 0, alphasort);
     if (n < 0)
 	{
-        perror("scandir");
+		window_fs_errno(path);
 		return(-1);
 	} else {
 		oldn=dir->n_sub;

Modified: trunk/apps/s3dfm/s3dfm.h
===================================================================
--- trunk/apps/s3dfm/s3dfm.h	2006-09-28 16:22:56 UTC (rev 442)
+++ trunk/apps/s3dfm/s3dfm.h	2006-09-28 17:07:07 UTC (rev 443)
@@ -151,6 +151,7 @@
 int 		 node_undisplay(t_node *dir);
 void		 node_select(t_node *dir);
 void 		 node_focus_color(t_node *node, int on);
+t_node		*node_getdir(t_node *node);
 /* parse.c */
 int 		 parse_dir(t_node *dir);
 /* string.c */



From dotslash at mail.berlios.de  Thu Sep 28 19:07:43 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 28 Sep 2006 19:07:43 +0200
Subject: [S3d-svn] r444 - in trunk: . libs3dw
Message-ID: <200609281707.k8SH7h1t002447@sheep.berlios.de>

Author: dotslash
Date: 2006-09-28 19:07:43 +0200 (Thu, 28 Sep 2006)
New Revision: 444

Modified:
   trunk/
   trunk/libs3dw/surface.c
Log:
 r1077 at balthasar:  dotslash | 2006-09-28 19:07:40 +0200
 - popup nearer to user 



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1075
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1077

Modified: trunk/libs3dw/surface.c
===================================================================
--- trunk/libs3dw/surface.c	2006-09-28 17:07:07 UTC (rev 443)
+++ trunk/libs3dw/surface.c	2006-09-28 17:07:43 UTC (rev 444)
@@ -27,7 +27,7 @@
 #include <stdlib.h> /* malloc() */
 #include <string.h> /* strdup() */
 #include <math.h>	/* cos(), sin() */
-#define POPUPDIST	40
+#define POPUPDIST	20
 extern s3dw_widget *_s3dw_cam; /* for correct popup position */
 
 void s3dw_surface_draw(s3dw_widget *widget)



