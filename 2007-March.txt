From dotslash at mail.berlios.de  Sat Mar  3 22:45:56 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 3 Mar 2007 22:45:56 +0100
Subject: [S3d-svn] r578 - in trunk: . config example libs3d server
Message-ID: <200703032145.l23Ljuq2020871@sheep.berlios.de>

Author: dotslash
Date: 2007-03-03 22:45:56 +0100 (Sat, 03 Mar 2007)
New Revision: 578

Added:
   trunk/config/openGL.m4
Modified:
   trunk/Makefile.am
   trunk/config.h.in
   trunk/configure.ac
   trunk/example/wiresphere.c
   trunk/libs3d/Makefile.am
   trunk/libs3d/shm.c
   trunk/server/Makefile.am
Log:
- use frescos opengl m4 check instead of old mdl (maybe it works better?)
- some minor changes

Modified: trunk/Makefile.am
===================================================================
--- trunk/Makefile.am	2007-02-10 13:08:24 UTC (rev 577)
+++ trunk/Makefile.am	2007-03-03 21:45:56 UTC (rev 578)
@@ -9,8 +9,7 @@
 
 EXTRA_DIST=	gpl.txt \
 		config/libtool15.m4 config/mdl_have_opengl.m4 \
-		config/pkg.m4 config/pthread.m4 config/sdl.m4 \
-		config/simage.m4
+		config/pkg.m4 config/pthread.m4 config/sdl.m4 
 
 dist_sysconf_DATA=	s3drc
 

Added: trunk/config/openGL.m4
===================================================================
--- trunk/config/openGL.m4	2007-02-10 13:08:24 UTC (rev 577)
+++ trunk/config/openGL.m4	2007-03-03 21:45:56 UTC (rev 578)
@@ -0,0 +1,60 @@
+dnl
+dnl This source file is a part of the Fresco Project.
+dnl Copyright (C) 1999 Stefan Seefeld <stefan at fresco.org> 
+dnl http://www.fresco.org
+dnl
+dnl This library is free software; you can redistribute it and/or
+dnl modify it under the terms of the GNU Library General Public
+dnl License as published by the Free Software Foundation; either
+dnl version 2 of the License, or (at your option) any later version.
+dnl
+dnl This library is distributed in the hope that it will be useful,
+dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
+dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+dnl Library General Public License for more details.
+dnl
+dnl You should have received a copy of the GNU Library General Public
+dnl License along with this library; if not, write to the
+dnl Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
+dnl MA 02139, USA.
+
+dnl
+dnl FRESCO_OPENGL_CHECK
+dnl
+AC_DEFUN([FRESCO_OPENGL_CHECK],
+  [AC_ARG_WITH(opengl-prefix,
+	       AC_HELP_STRING([--with-opengl-prefix],[Prefix for openGL]),
+               [opengl_prefix="$withval"])
+
+   dnl Check for opengl includes
+   if test x$opengl_prefix != x ; then
+     GL_CPPFLAGS=-I$opengl_prefix/include
+   fi
+   save_CPPFLAGS="$CPPFLAGS"
+   CPPFLAGS="$GL_CPPFLAGS $CPPFLAGS"
+   AC_CHECK_HEADER(GL/gl.h,,no_gl=yes)
+   AC_CHECK_HEADER(GL/glu.h,,no_gl=yes)
+   CPPFLAGS="$save_CPPFLAGS"
+   
+   dnl Check for opengl libs
+   if test "x$no_gl" = x ; then
+   
+     if test x$opengl_prefix != x ; then
+       GL_LIBS=-L$opengl_prefix/lib
+     fi
+     save_LDFLAGS="$LDFLAGS"
+     LDFLAGS="$GL_LIBS $LDFLAGS"
+     AC_CHECK_LIB(GL, glLoadIdentity, :, no_gl=yes)
+     AC_CHECK_LIB(GLU, gluNewTess, :, no_gl=yes, [-lGL])
+     LDFLAGS="$save_LDFLAGS"
+   fi
+   
+   if test "x$no_gl" = xyes ; then
+   
+     AC_SUBST(HAVE_GL, 0)
+   else
+     AC_SUBST(HAVE_GL, 1)
+     AC_SUBST(GL_CPPFLAGS, "$GL_CPPFLAGS")
+     AC_SUBST(GL_LIBS, "$GL_LIBS -lGL -lGLU")
+   fi
+])

Modified: trunk/config.h.in
===================================================================
--- trunk/config.h.in	2007-02-10 13:08:24 UTC (rev 577)
+++ trunk/config.h.in	2007-03-03 21:45:56 UTC (rev 578)
@@ -134,9 +134,6 @@
 /* Version number of package */
 #undef VERSION
 
-/* Define to 1 if the X Window System is missing or not being used. */
-#undef X_DISPLAY_MISSING
-
 /* Define like PROTOTYPES; this can be used by system headers. */
 #undef __PROTOTYPES
 

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2007-02-10 13:08:24 UTC (rev 577)
+++ trunk/configure.ac	2007-03-03 21:45:56 UTC (rev 578)
@@ -75,7 +75,9 @@
 AC_CHECK_LIBM
 AC_SUBST(LIBM)
 
- MDL_HAVE_OPENGL
+dnl #### MDL_HAVE_OPENGL
+FRESCO_OPENGL_CHECK
+
 AC_SEARCH_LIBS(glutInit, glut, [
 HAVE_glut="yes"
 GLUT_CFLAGS=

Modified: trunk/example/wiresphere.c
===================================================================
--- trunk/example/wiresphere.c	2007-02-10 13:08:24 UTC (rev 577)
+++ trunk/example/wiresphere.c	2007-03-03 21:45:56 UTC (rev 578)
@@ -111,7 +111,7 @@
 }
 int main (int argc, char **argv)
 {
-	if (!s3d_init(&argc,&argv,"clock"))	
+	if (!s3d_init(&argc,&argv,"wiresphere"))	
 	{
 		oid=wire_sphere(30,30);
 		s3d_scale(oid,10);

Modified: trunk/libs3d/Makefile.am
===================================================================
--- trunk/libs3d/Makefile.am	2007-02-10 13:08:24 UTC (rev 577)
+++ trunk/libs3d/Makefile.am	2007-03-03 21:45:56 UTC (rev 578)
@@ -8,6 +8,7 @@
 include_HEADERS= s3d.h s3d_keysym.h
 noinst_HEADERS=		config.h s3dlib.h sei_triangulate.h sei_interface.h
 
+# for proto.h
 
 libs3d_la_CPPFLAGS=	-I${top_srcdir}/server
 #fontconfig_lo_CFLAGS=	@FONTCONFIG_CFLAGS@

Modified: trunk/libs3d/shm.c
===================================================================
--- trunk/libs3d/shm.c	2007-02-10 13:08:24 UTC (rev 577)
+++ trunk/libs3d/shm.c	2007-03-03 21:45:56 UTC (rev 578)
@@ -132,8 +132,8 @@
 			s3dprintf(HIGH,"shm_writen():waited too long ...");
 			return(-1);
 		}
-		if (wait>10)
-			nanosleep(&t,NULL); 
+/*		if (wait>10)
+			nanosleep(&t,NULL); */
 	}
 	return(s - no_left);
 }
@@ -155,8 +155,8 @@
 			s3dprintf(HIGH,"shm_readn():waited too long ...");
 			return(-1);
 		}
-		if (wait>10)
-			nanosleep(&t,NULL); 
+/*		if (wait>10)
+			nanosleep(&t,NULL); */
 	}
 	return(s - no_left);
 }

Modified: trunk/server/Makefile.am
===================================================================
--- trunk/server/Makefile.am	2007-02-10 13:08:24 UTC (rev 577)
+++ trunk/server/Makefile.am	2007-03-03 21:45:56 UTC (rev 578)
@@ -22,6 +22,6 @@
 	allocate.c
 
 s3d_LDADD=	@LIBM@ @GL_LIBS@ ${MAYBE_SDL_LIBS} ${MAYBE_GLUT_LIBS}
-s3d_CFLAGS=	@GL_CFLAGS@ ${MAYBE_SDL_CFLAGS} ${MAYBE_GLUT_CFLAGS} ${DEVEL_CFLAGS} 
+s3d_CFLAGS=	@GL_CPPFLAGS@ ${MAYBE_SDL_CFLAGS} ${MAYBE_GLUT_CFLAGS} ${DEVEL_CFLAGS} 
 
 noinst_HEADERS=	config.h global.h proto.h



From dotslash at mail.berlios.de  Sat Mar  3 23:06:04 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 3 Mar 2007 23:06:04 +0100
Subject: [S3d-svn] r579 - trunk
Message-ID: <200703032206.l23M644v021823@sheep.berlios.de>

Author: dotslash
Date: 2007-03-03 23:06:03 +0100 (Sat, 03 Mar 2007)
New Revision: 579

Modified:
   trunk/configure.ac
Log:
- opengl, one more time.

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2007-03-03 21:45:56 UTC (rev 578)
+++ trunk/configure.ac	2007-03-03 22:06:03 UTC (rev 579)
@@ -77,6 +77,9 @@
 
 dnl #### MDL_HAVE_OPENGL
 FRESCO_OPENGL_CHECK
+if test "x$no_gl" = xyes ; then
+	AC_MSG_ERROR([Could not find OpenGL-Headers. Install OpenGL Headers or try --with-opengl-prefix])
+fi
 
 AC_SEARCH_LIBS(glutInit, glut, [
 HAVE_glut="yes"



From dotslash at mail.berlios.de  Sat Mar  3 23:15:41 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 3 Mar 2007 23:15:41 +0100
Subject: [S3d-svn] r580 - trunk/apps/s3dvt
Message-ID: <200703032215.l23MFfWM022277@sheep.berlios.de>

Author: dotslash
Date: 2007-03-03 23:15:41 +0100 (Sat, 03 Mar 2007)
New Revision: 580

Modified:
   trunk/apps/s3dvt/main.c
Log:
- add "\n"

Modified: trunk/apps/s3dvt/main.c
===================================================================
--- trunk/apps/s3dvt/main.c	2007-03-03 22:06:03 UTC (rev 579)
+++ trunk/apps/s3dvt/main.c	2007-03-03 22:15:41 UTC (rev 580)
@@ -583,7 +583,7 @@
 	{
 		if (s3d_select_font("vera"))
 		{
-			printf("font not found");
+			printf("font not found\n");
 			exit(-1);
 		}
 		b=draw_background();



From dotslash at mail.berlios.de  Sat Mar  3 23:19:23 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 3 Mar 2007 23:19:23 +0100
Subject: [S3d-svn] r581 - trunk/apps/s3dfm
Message-ID: <200703032219.l23MJNCP022415@sheep.berlios.de>

Author: dotslash
Date: 2007-03-03 23:19:23 +0100 (Sat, 03 Mar 2007)
New Revision: 581

Modified:
   trunk/apps/s3dfm/parse.c
Log:
- closedir() vs. opendir()

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2007-03-03 22:15:41 UTC (rev 580)
+++ trunk/apps/s3dfm/parse.c	2007-03-03 22:19:23 UTC (rev 581)
@@ -79,15 +79,16 @@
 				ext=strrchr(nstr,'.');
 				strncpy(ndir,path,M_DIR);
 		    	strncat(ndir,namelist[n]->d_name,M_DIR);
-			    if ((namelist[n]->d_type==DT_DIR) || ((namelist[n]->d_type==DT_UNKNOWN) && ((dirhd=opendir(ndir))!=NULL)))
-				{
-					dir->sub[i]->type=T_FOLDER;
-					closedir(dirhd);
-				} /*else if (ext!=NULL)
-				   {
-					   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))		   dir->sub[i]->type=T_GEOMETRY;
-					   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))	   dir->sub[i]->type=T_MUSIC;
-				   }	*/
+			    if ((namelist[n]->d_type==DT_DIR) || ((namelist[n]->d_type==DT_UNKNOWN)))
+					if ((dirhd=opendir(ndir))!=NULL))
+					{
+						dir->sub[i]->type=T_FOLDER;
+						closedir(dirhd);
+					} /*else if (ext!=NULL)
+					   {
+						   if (0==strncmp(ext,".3ds",strlen(ext)<4?strlen(ext):4))		   dir->sub[i]->type=T_GEOMETRY;
+						   else if (0==strncmp(ext,".mp3",strlen(ext)<4?strlen(ext):4))	   dir->sub[i]->type=T_MUSIC;
+						   }	*/
 				dir->sub[i]->check=0; /* check=0 means we've already processed this item */
 			}
 	   	    free(namelist[n]);



From dotslash at mail.berlios.de  Sat Mar  3 23:20:41 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 3 Mar 2007 23:20:41 +0100
Subject: [S3d-svn] r582 - trunk/apps/s3dfm
Message-ID: <200703032220.l23MKfEG022569@sheep.berlios.de>

Author: dotslash
Date: 2007-03-03 23:20:41 +0100 (Sat, 03 Mar 2007)
New Revision: 582

Modified:
   trunk/apps/s3dfm/parse.c
Log:
- again ...

Modified: trunk/apps/s3dfm/parse.c
===================================================================
--- trunk/apps/s3dfm/parse.c	2007-03-03 22:19:23 UTC (rev 581)
+++ trunk/apps/s3dfm/parse.c	2007-03-03 22:20:41 UTC (rev 582)
@@ -80,7 +80,7 @@
 				strncpy(ndir,path,M_DIR);
 		    	strncat(ndir,namelist[n]->d_name,M_DIR);
 			    if ((namelist[n]->d_type==DT_DIR) || ((namelist[n]->d_type==DT_UNKNOWN)))
-					if ((dirhd=opendir(ndir))!=NULL))
+					if ((dirhd=opendir(ndir))!=NULL)
 					{
 						dir->sub[i]->type=T_FOLDER;
 						closedir(dirhd);



From dotslash at mail.berlios.de  Sun Mar  4 21:25:20 2007
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 4 Mar 2007 21:25:20 +0100
Subject: [S3d-svn] r583 - in trunk: libs3d server
Message-ID: <200703042025.l24KPKUH017403@sheep.berlios.de>

Author: dotslash
Date: 2007-03-04 21:25:19 +0100 (Sun, 04 Mar 2007)
New Revision: 583

Modified:
   trunk/libs3d/s3dlib.h
   trunk/server/global.h
   trunk/server/shm.c
Log:
- disable shm on macos

Modified: trunk/libs3d/s3dlib.h
===================================================================
--- trunk/libs3d/s3dlib.h	2007-03-03 22:20:41 UTC (rev 582)
+++ trunk/libs3d/s3dlib.h	2007-03-04 20:25:19 UTC (rev 583)
@@ -24,6 +24,12 @@
 
 #include <stdint.h>
 #include "../config.h"
+#ifdef __APPLE__ 
+#ifdef SHM
+#undef SHM
+#endif
+#endif 
+
 #define VLOW	1
 #define	LOW		2
 #define MED		3

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2007-03-03 22:20:41 UTC (rev 582)
+++ trunk/server/global.h	2007-03-04 20:25:19 UTC (rev 583)
@@ -23,6 +23,11 @@
 
 
 #include "config.h"
+#ifdef __APPLE__ 
+#ifdef SHM
+#undef SHM
+#endif
+#endif 
 #include <stdint.h>		 /*  integer types */
 #ifdef SHM
 	#include <sys/shm.h> /* key_t */

Modified: trunk/server/shm.c
===================================================================
--- trunk/server/shm.c	2007-03-03 22:20:41 UTC (rev 582)
+++ trunk/server/shm.c	2007-03-04 20:25:19 UTC (rev 583)
@@ -226,9 +226,10 @@
 		new_p->con_type=CON_SHM;
 		memcpy(&new_p->shmsock,&waiting_comblock,sizeof(struct t_shmcb));
 		s3dprintf(HIGH,"shm_main():registered new connection (keys %d, %d) as pid %d",new_p->shmsock.key_ctos,new_p->shmsock.key_stoc, new_p->id);
-			s3dprintf(LOW,"shm_main():new client attached! allocating shm block for further clients ...");
-			shm_new_comblock(data);
-		}
+		s3dprintf(LOW,"shm_main():new client attached! allocating shm block for further clients ...");
+		if (shm_new_comblock(data))
+			return(1);
+	}
 	return(0);
 }
 int shm_prot_com_in(struct t_process *p)



From nichtsnutz at mail.berlios.de  Sat Mar 10 18:45:53 2007
From: nichtsnutz at mail.berlios.de (nichtsnutz at BerliOS)
Date: Sat, 10 Mar 2007 18:45:53 +0100
Subject: [S3d-svn] r584 - in trunk: . apps apps/meshs3d
Message-ID: <200703101745.l2AHjrxt019741@sheep.berlios.de>

Author: nichtsnutz
Date: 2007-03-10 18:45:52 +0100 (Sat, 10 Mar 2007)
New Revision: 584

Added:
   trunk/apps/meshs3d/
   trunk/apps/meshs3d/Makefile.am
   trunk/apps/meshs3d/main.c
   trunk/apps/meshs3d/meshs3d.h
   trunk/apps/meshs3d/net.c
   trunk/apps/meshs3d/process.c
Modified:
   trunk/apps/Makefile.am
   trunk/configure.ac
Log:
rewrite olsrs3d

Modified: trunk/apps/Makefile.am
===================================================================
--- trunk/apps/Makefile.am	2007-03-04 20:25:19 UTC (rev 583)
+++ trunk/apps/Makefile.am	2007-03-10 17:45:52 UTC (rev 584)
@@ -6,4 +6,4 @@
 MAYBE_S3DOSM=	s3dosm
 endif
 
-SUBDIRS =  ${MAYBE_X11GATE} ${MAYBE_S3DOSM} s3dvt olsrs3d dot_mcp s3dfm kism3d
+SUBDIRS =  ${MAYBE_X11GATE} ${MAYBE_S3DOSM} s3dvt olsrs3d dot_mcp s3dfm kism3d meshs3d

Added: trunk/apps/meshs3d/Makefile.am
===================================================================
--- trunk/apps/meshs3d/Makefile.am	2007-03-04 20:25:19 UTC (rev 583)
+++ trunk/apps/meshs3d/Makefile.am	2007-03-10 17:45:52 UTC (rev 584)
@@ -0,0 +1,15 @@
+bin_PROGRAMS=	meshs3d
+
+meshs3dincludedir = $(pkgincludedir)/meshs3d
+
+meshs3dinclude_HEADERS =  \
+	meshs3d.h
+	
+meshs3d_SOURCES =  \
+	main.c \
+	net.c \
+	process.c
+
+meshs3d_CPPFLAGS=	-pg -I$(top_srcdir)/libs3d -I$(top_srcdir)/libs3dw
+meshs3d_LDADD=		$(top_builddir)/libs3d/libs3d.la $(top_builddir)/libs3dw/libs3dw.la
+meshs3d_LDFLAGS=	-pg

Added: trunk/apps/meshs3d/main.c
===================================================================
--- trunk/apps/meshs3d/main.c	2007-03-04 20:25:19 UTC (rev 583)
+++ trunk/apps/meshs3d/main.c	2007-03-10 17:45:52 UTC (rev 584)
@@ -0,0 +1,227 @@
+/*
+ * main.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                         Marek Lindner <lindner_marek at yahoo.de>
+ *                         Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of meshs3d, an olsr/batman topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <stdio.h>
+#include <s3d.h>
+#include <s3d_keysym.h>
+#include <s3dw.h>
+#include <sys/time.h>
+#include <time.h>
+#include <string.h>
+#include <math.h>
+#include <getopt.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include "meshs3d.h"
+
+/* global vars */
+struct glob Global;
+
+void init_globals( void )
+{
+	Global.debug = 0;
+	Global.obj_node_hna = 0;
+	Global.obj_node_inet = 0;
+	Global.obj_node_normal = 0;
+	Global.obj_btn_close = 0;
+	Global.obj_s3d_url = 0;
+	Global.obj_zero_point = 0;
+		
+}
+
+
+void print_usage( void )
+{
+
+	printf( "Usage is olsrs3d [options] [-- [s3d options]]\n" );
+	printf( "olsrs3d options:\n" );
+	printf( "   -h\tprint this short help\n" );
+	printf( "   -d\tenable debug mode\n" );
+	printf( "   -H\tconnect to olsr node [default: localhost]\n" );
+	s3d_usage();
+}
+
+void mainloop()
+{
+
+	int net_result;   /* result of function net_main */
+//	char nc_str[20];
+//	float strLen;
+//
+//	/* calculate new movement vector */
+//	calc_olsr_node_mov();
+//
+//	/* prepare nodes */
+//	handle_olsr_node( Olsr_root );
+//
+//	/* move it */
+//	move_olsr_nodes();
+//
+//	/* if we have more or less nodes now - redraw node count */
+//	if ( Olsr_node_count != Last_olsr_node_count ) {
+//
+//		if ( Olsr_node_count_obj != -1 ) s3d_del_object( Olsr_node_count_obj );
+//		snprintf( nc_str, 20, "node count: %d", Olsr_node_count );
+//		Olsr_node_count_obj = s3d_draw_string( nc_str, &strLen );
+//		s3d_link( Olsr_node_count_obj, 0 );
+//		s3d_flags_on( Olsr_node_count_obj, S3D_OF_VISIBLE );
+//		s3d_scale( Olsr_node_count_obj, 0.2 );
+//		s3d_translate( Olsr_node_count_obj, -Left*3.0-(strLen * 0.2), -Bottom*3.0-0.5, -3.0 );
+//		Last_olsr_node_count = Olsr_node_count;
+//
+//	}
+//
+//	if ( Output_block_completed ) {
+//
+//		Output_block_counter++;
+//		Output_block_completed = 0;
+//
+//	}
+
+//	/* read data from socket */
+//	Net_read_count = 0;
+	while ( ( net_result = net_main() ) != 0 ) {
+		if ( net_result == -1 ) {
+			s3d_quit();
+			break;
+		}
+	}
+//
+//	/* rotate modus */
+//	if(RotateSwitch) {
+//		Zp_rotate = ( Zp_rotate + RotateSpeed ) > 360 ? 0.0 : ( Zp_rotate + RotateSpeed );
+//		s3d_rotate(ZeroPoint,0,Zp_rotate,0);
+//	}
+//
+//	/* calc for node description */
+//	CamPosition2[0][0]=  CamPosition[0][0]*cos(Zp_rotate*M_PI/180.0) - CamPosition[0][2] * sin (Zp_rotate*M_PI/180.0);
+//	CamPosition2[0][1]=  CamPosition[0][1];
+//	CamPosition2[0][2]=  CamPosition[0][0]*sin(Zp_rotate*M_PI/180.0) + CamPosition[0][2] * cos (Zp_rotate*M_PI/180.0);
+//
+//	/* check search status */
+///*	if( get_search_status() == WIDGET )
+//		move_to_search_widget( CamPosition[0], CamPosition[1] );*/
+//	if( get_search_status() == FOLLOW )
+//		follow_node( CamPosition[0], CamPosition[1], Zp_rotate );
+///*	if( get_search_status() == ABORT )
+//		move_to_return_point( CamPosition[0], CamPosition[1] );*/
+//
+//
+//	if( Olsr_ip_label_obj != -1 )
+//	{
+//		print_etx();
+//	}
+//	s3dw_ani_mate();
+//
+//	nanosleep( &sleep_time, NULL );
+//
+	return;
+
+}
+
+
+int main( int argc, char *argv[] ) {
+	int optchar;
+	char olsr_host[256];
+	
+	init_globals();
+	strncpy( olsr_host, "127.0.0.1", 256 );
+	lbuf[0] = '\0';
+
+	while ( ( optchar = getopt ( argc, argv, "dhH:" ) ) != -1 ) {
+
+		switch ( optchar ) {
+
+			case 'd':
+				Global.debug = 1;
+				break;
+
+			case 'H':
+				strncpy( olsr_host, optarg, 256 );
+				break;
+
+			case 'h':
+			default:
+				print_usage();
+				return (0);
+
+		}
+
+	}
+
+	if ( Global.debug )
+		printf( "debug mode enabled ...\n" );
+
+//	/* initialize obj2ip linked list */
+//	lst_initialize();
+
+	/* delete olsrs3d options */
+	while ( ( optind < argc ) && ( argv[optind][0] != '-' ) ) optind++;		/* optind may point to ip addr of '-H' */
+	optind--;
+	argv[optind] = argv[0];		/* save program path */
+	argc -= optind;				/* jump over olsrs3d options */
+	argv += optind;
+
+	/* set extern int optind = 0 for parse_args in io.c */
+	optind = 0;
+
+
+	if (!net_init(olsr_host))
+	{
+//		s3d_set_callback(S3D_EVENT_OBJ_INFO,object_info);
+//		s3d_set_callback(S3D_EVENT_OBJ_CLICK,object_click);
+//		s3d_set_callback(S3D_EVENT_KEY,keypress);
+//		s3d_set_callback(S3D_EVENT_QUIT,stop);
+
+		if (!s3d_init(&argc,&argv,"meshs3d"))
+		{
+
+			if (s3d_select_font("vera"))
+				printf("font not found\n");
+
+			Global.obj_node_normal = s3d_import_model_file( "objs/accesspoint.3ds" );
+			Global.obj_node_inet = s3d_import_model_file( "objs/accesspoint_inet.3ds" );
+			Global.obj_node_hna = s3d_import_model_file( "objs/internet.3ds" );
+			Global.obj_btn_close = s3d_import_model_file( "objs/btn_close.3ds" );
+
+			Global.obj_s3d_url = s3d_import_model_file( "objs/s3d_berlios_de.3ds" );
+
+			s3d_translate( Global.obj_s3d_url, 0.75, -0.75, -1 );
+			s3d_scale( Global.obj_s3d_url, 0.07 );
+			s3d_link( Global.obj_s3d_url, 0 );
+			s3d_flags_on( Global.obj_s3d_url, S3D_OF_VISIBLE );
+
+			/* create_search_widget( 0, 0, 300 ); */
+
+			Global.obj_zero_point = s3d_new_object();
+//			Output_border[0] = Output_border[1] = Output_border[2] = Output_border[3] = -1;
+
+			s3d_mainloop(mainloop);
+			s3d_quit();
+			net_quit();
+		}
+	}
+	return(0);
+}
\ No newline at end of file

Added: trunk/apps/meshs3d/meshs3d.h
===================================================================
--- trunk/apps/meshs3d/meshs3d.h	2007-03-04 20:25:19 UTC (rev 583)
+++ trunk/apps/meshs3d/meshs3d.h	2007-03-10 17:45:52 UTC (rev 584)
@@ -0,0 +1,115 @@
+/*
+ * meshs3d.h
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                         Marek Lindner <lindner_marek at yahoo.de>
+ *                         Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of meshs3d, an olsr/batman topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#define max(x,y) {((x)>(y)?(x):(y))}
+#define min(x,y) {((x)<(y)?(x):(y))}
+#define NAMEMAX		128
+#define MAXLINESIZE 1000		/* lines in a digraph just shouldn't get that longer ... */
+#define MAXDATASIZE 100			/* max number of bytes we can get at once  */
+
+/* linked list for the all connections */
+struct olsr_con 
+{
+	struct olsr_con *next_olsr_con;			/* pointer to next connection */
+	struct olsr_con *prev_olsr_con;			/* pointer to previous connection */
+	struct olsr_node *left_olsr_node;		/* pointer to left end point of the connection */
+	struct olsr_node *right_olsr_node;		/* pointer to right end point of the connection */
+	float left_etx;							/* etx of left olsr node */
+	float right_etx;						/* etx of right olsr node */
+	float left_etx_sqrt;					/* sqrt of etx of left olsr node */
+	float right_etx_sqrt;					/* sqrt etx of right olsr node */
+	int obj_id;								/* id of connection object in s3d */
+	int color;
+	float rgb;
+};
+
+
+/* linked list for the neighbours of each olsr node */
+struct olsr_neigh_list
+{
+	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
+	struct olsr_con *olsr_con;							/* pointer to the connection */
+};
+
+
+/* we contruct a binary tree to handle the nodes */
+struct olsr_node 
+{
+	struct olsr_node *left;
+	struct olsr_node *right;
+	char ip[NAMEMAX];				/* host ip */
+	int node_type;					/* normal = 0, internet gateway = 1, via hna announced network = 2 */
+	int node_type_modified;			/* node_type modified flag */
+	int last_seen;					/* last seen counter */
+	int visible;					/* is this node visible or vanished */
+	float pos_vec[3];				/* position vector in 3d "space" */
+	float mov_vec[3];				/* move vector */
+	int obj_id;						/* id of node object in s3d */
+	int desc_id;					/* id of node description object in s3d */
+	float desc_length;				/* length of node description object in s3d */
+	struct olsr_neigh_list *olsr_neigh_list;	/* pointer to first neighbour */
+};
+
+
+struct obj_to_ip
+{
+	int id;
+	struct olsr_node *olsr_node;
+	struct obj_to_ip *next;
+	struct obj_to_ip *prev;
+};
+
+struct glob {
+	int debug;
+	int	obj_node_normal;
+	int	obj_node_inet;
+	int	obj_node_hna;
+	int	obj_btn_close;
+	int	obj_s3d_url;
+	int obj_zero_point;
+};
+
+extern char lbuf[MAXLINESIZE];
+extern struct glob Global;
+
+/* process.c */
+//void lst_initialize();
+//void lst_add(int id,struct olsr_node **olsr_node);
+//void lst_del(int id);
+//struct olsr_node *lst_search(int id);
+//void lst_out();
+//struct olsr_node *move_lst_ptr(int *id);
+//int process_main();
+
+/* net.c */
+int net_init(char *host);
+int net_main();
+int net_quit();
+
+/* main */
+//void out_of_mem( void );
+//void print_etx( void );
+//float dist(float p1[], float p2[]);
+//void window_error(char *msg);

Added: trunk/apps/meshs3d/net.c
===================================================================
--- trunk/apps/meshs3d/net.c	2007-03-04 20:25:19 UTC (rev 583)
+++ trunk/apps/meshs3d/net.c	2007-03-10 17:45:52 UTC (rev 584)
@@ -0,0 +1,130 @@
+/*
+ * net.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                         Marek Lindner <lindner_marek at yahoo.de>
+ *                         Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of meshs3d, an olsr/batman topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <netdb.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <fcntl.h>
+#include "meshs3d.h"
+
+#define PORT 2004
+char buf[MAXDATASIZE];
+
+
+int sockfd, numbytes;
+
+int net_init(char *host)
+{
+    struct hostent *he;
+    struct sockaddr_in their_addr; /* connector's address information  */
+
+    if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
+        herror("gethostbyname");
+        return(1);
+    }
+
+    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
+        perror("socket");
+        return(1);
+    }
+
+    their_addr.sin_family = AF_INET;    /* host byte order  */
+    their_addr.sin_port = htons(PORT);  /* short, network byte order  */
+    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
+    memset(&(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
+
+    if (connect(sockfd, (struct sockaddr *)&their_addr,
+                                          sizeof(struct sockaddr)) == -1) {
+        perror("connect");
+        return(1);
+    }
+	fcntl(sockfd,F_SETFL, O_NONBLOCK);
+	return(0);
+}
+
+int net_main() {
+	static int net_read_count = 0;
+	
+	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
+		if (errno==EAGAIN)
+			return(0); /* well, that's okay ... */
+		perror("recv");
+		return(-1);
+	}
+
+	if (numbytes==0) {
+		printf("connection reset\n");
+		return(-1);
+	}
+
+	buf[numbytes] = '\0';
+
+	/* check for potential buffer overflow */
+	if ( ( strlen( lbuf ) + strlen( buf ) ) < MAXLINESIZE ) {
+
+		strncat( lbuf, buf, MAXLINESIZE );
+
+	} else {
+
+		/* hope that carriage return is now in buf */
+		if ( strlen( lbuf ) < MAXLINESIZE ) {
+
+			if ( Global.debug ) printf( "WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n" );
+			strncat( lbuf, buf, MAXLINESIZE - strlen( lbuf ) );
+
+		} else {
+
+			if ( Global.debug ) printf( "ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n" );
+			strncpy( lbuf, buf, MAXLINESIZE );
+
+		}
+
+	}
+
+	process_main();
+
+	if ( ++net_read_count > 5 ) {
+		net_read_count = 0;
+		return(0);   /* continue mainloop */
+	} else {
+		return(1);   /* continue reading data from socket */
+	}
+
+}
+
+int net_quit()
+{
+    close(sockfd);
+
+    return 0;
+}
+
+

Added: trunk/apps/meshs3d/process.c
===================================================================
--- trunk/apps/meshs3d/process.c	2007-03-04 20:25:19 UTC (rev 583)
+++ trunk/apps/meshs3d/process.c	2007-03-10 17:45:52 UTC (rev 584)
@@ -0,0 +1,527 @@
+/*
+ * process.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                         Marek Lindner <lindner_marek at yahoo.de>
+ *                         Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of meshs3d, an olsr/batman topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+#include <stdio.h> 	/* NULL */
+#include <string.h> 	/* strlen(), memmove() */
+#include <stdlib.h> 	/* rand(), malloc(), realloc(), free() */
+#include <s3d.h>
+#include <math.h>       /* sqrt() */
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include "meshs3d.h"
+
+
+char lbuf[MAXLINESIZE];
+
+
+
+/***
+ *
+ * create new or alter connection between 2 nodes
+ *
+ *   con_from =>   current node
+ *   con_to   =>   node to connect to
+ *   etx      =>   ETX
+ *
+ ***/
+
+//int add_olsr_con( struct olsr_node *con_from, struct olsr_node *con_to, float etx ) {
+//
+//	struct olsr_con **olsr_con = &Con_begin;
+//	struct olsr_con *prev_olsr_con = NULL;   /* previous olsr connection */
+//	struct olsr_neigh_list **olsr_neigh_list;
+//
+//	while ( (*olsr_con) != NULL ) {
+//
+//		/* connection already exists */
+//		if ( ( strncmp( (*olsr_con)->left_olsr_node->ip, con_from->ip, NAMEMAX ) == 0 ) && ( strncmp( (*olsr_con)->right_olsr_node->ip, con_to->ip, NAMEMAX ) == 0 ) ) {
+//			(*olsr_con)->left_etx = etx;
+//			(*olsr_con)->left_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
+//			break;
+//
+//		} else if ( ( strncmp( (*olsr_con)->right_olsr_node->ip, con_from->ip, NAMEMAX ) == 0 ) && ( strncmp( (*olsr_con)->left_olsr_node->ip, con_to->ip, NAMEMAX ) == 0 ) ) {
+//
+//			(*olsr_con)->right_etx = etx;
+//			(*olsr_con)->right_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
+//			break;
+//
+//		}
+//
+//		/* save previous olsr connection for later use */
+//		prev_olsr_con = (*olsr_con);
+//
+//		olsr_con = &(*olsr_con)->next_olsr_con;
+//
+//	}
+//
+//	/* new connection */
+//	if ( (*olsr_con) == NULL ) {
+//
+//		(*olsr_con) = malloc( sizeof( struct olsr_con ) );
+//		if ( (*olsr_con) == NULL ) out_of_mem();
+//
+//		/* create connection object */
+//		(*olsr_con)->obj_id = s3d_new_object();
+//
+//		/* add olsr node to new olsr connection in order to access the nodes from the connection list */
+//		(*olsr_con)->left_olsr_node = con_from;
+//		(*olsr_con)->right_olsr_node = con_to;
+//
+//		/* add connection color */
+//		(*olsr_con)->color = 0;
+//		s3d_push_material( (*olsr_con)->obj_id,
+//				  1.0,1.0,1.0,
+//				  1.0,1.0,1.0,
+//				  1.0,1.0,1.0);
+//
+//		/* add connection endpoints */
+//		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->left_olsr_node->pos_vec[0], (*olsr_con)->left_olsr_node->pos_vec[1], (*olsr_con)->left_olsr_node->pos_vec[2] );
+//		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->right_olsr_node->pos_vec[0], (*olsr_con)->right_olsr_node->pos_vec[1], (*olsr_con)->right_olsr_node->pos_vec[2] );
+//
+//		s3d_push_line( (*olsr_con)->obj_id, 0,1,0 );
+//
+//		s3d_flags_on( (*olsr_con)->obj_id, S3D_OF_VISIBLE );
+//
+//		s3d_link( (*olsr_con)->obj_id,  ZeroPoint );
+//
+//		/* HNA */
+//		if ( etx == -1000.00 ) {
+//
+//			(*olsr_con)->left_etx = etx;
+//			(*olsr_con)->left_etx_sqrt = 10.0;
+//			(*olsr_con)->right_etx = etx;
+//			(*olsr_con)->right_etx_sqrt = 10.0;
+//
+//		} else {
+//
+//			(*olsr_con)->left_etx = etx;
+//			(*olsr_con)->left_etx_sqrt = sqrt( etx );
+//			(*olsr_con)->right_etx = 999.0;
+//			(*olsr_con)->right_etx_sqrt = sqrt( 999.0 );
+//
+//		}
+//
+//		(*olsr_con)->next_olsr_con = NULL;
+//		(*olsr_con)->prev_olsr_con = prev_olsr_con;
+//
+//		/* add new olsr connection to olsr nodes in order to access the connection from the olsr node */
+//		olsr_neigh_list = &(*olsr_con)->left_olsr_node->olsr_neigh_list;
+//		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
+//		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
+//		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
+//		(*olsr_neigh_list)->olsr_con = (*olsr_con);
+//		(*olsr_neigh_list)->next_olsr_neigh_list = NULL;
+//
+//		olsr_neigh_list = &(*olsr_con)->right_olsr_node->olsr_neigh_list;
+//		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
+//		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
+//		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
+//		(*olsr_neigh_list)->olsr_con = (*olsr_con);
+//		(*olsr_neigh_list)->next_olsr_neigh_list = NULL;
+//
+//	}
+//
+//	return(0);
+//
+//}
+//
+//
+//
+///***
+// *
+// * get pointer to olsr node or create new node if node string could not be found
+// *
+// *   **node =>   pointer to current olsr_node
+// *   *ip    =>   node ip
+// *
+// *   return olsr node pointer
+// *
+// ***/
+//
+//void *get_olsr_node( struct olsr_node **olsr_node, char *ip ) {
+//
+//	int result;   /* result of strcmp */
+//
+//	while ( (*olsr_node) != NULL ) {
+//
+//		result = strncmp( (*olsr_node)->ip, ip, NAMEMAX );
+//
+//		/* we found the node */
+//		if ( result == 0 ) {
+//
+//			(*olsr_node)->last_seen = Output_block_counter;
+//
+//			/* former invisble (deleted) node */
+//			if ( (*olsr_node)->visible == 0 ) {
+//
+//				(*olsr_node)->node_type = 0;
+//				(*olsr_node)->node_type_modified = 1;
+//
+//				(*olsr_node)->visible = 1;
+//
+//				(*olsr_node)->mov_vec[0] = (*olsr_node)->mov_vec[1] = (*olsr_node)->mov_vec[2] = 0.0;
+//
+//				if ( Debug ) printf( "new olsr node: %s\n", (*olsr_node)->ip );
+//
+//				Olsr_node_count++;
+//
+//			}
+//
+//			return (*olsr_node);
+//
+//		}
+//
+//		/* the searched node must be in the subtree */
+//		if ( result < 0 ) {
+//			olsr_node = &(*olsr_node)->right;
+//		} else {
+//			olsr_node = &(*olsr_node)->left;
+//		}
+//
+//	}
+//
+//	/* if node is NULL we reached the end of the tree and must create a new olsr_node */
+//	if ( (*olsr_node) == NULL ) {
+//
+//		(*olsr_node) = malloc( sizeof( struct olsr_node ) );
+//		if ( (*olsr_node) == NULL ) out_of_mem();
+//
+//		(*olsr_node)->left = NULL;
+//		(*olsr_node)->right = NULL;
+//
+//		strncpy( (*olsr_node)->ip, ip, NAMEMAX );
+//
+//		(*olsr_node)->node_type = 0;
+//		(*olsr_node)->node_type_modified = 1;
+//
+//		(*olsr_node)->last_seen = Output_block_counter;
+//		(*olsr_node)->visible = 1;
+//
+//		if ( Debug ) printf( "new olsr node: %s\n", (*olsr_node)->ip );
+//
+//		Olsr_node_count++;
+//
+//		(*olsr_node)->pos_vec[0] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+//		(*olsr_node)->pos_vec[1] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+//		(*olsr_node)->pos_vec[2] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+//		(*olsr_node)->mov_vec[0] = (*olsr_node)->mov_vec[1] = (*olsr_node)->mov_vec[2] = 0.0;
+//
+//		(*olsr_node)->obj_id = -1;
+//		(*olsr_node)->desc_id = -1;
+//		(*olsr_node)->olsr_neigh_list = NULL;
+//
+//		return (*olsr_node);
+//
+//	}
+//	return(0);
+//}
+//
+///*
+// *
+// * initialize the struct for a linked list obj2ip
+// *
+// */
+//
+//void lst_initialize() {
+//	Obj_to_ip_head = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
+//	Obj_to_ip_end = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
+//	if(Obj_to_ip_head == NULL || Obj_to_ip_end == NULL)
+//		out_of_mem();
+//	Obj_to_ip_head->id = 0;
+//	Obj_to_ip_end->id = 0;
+//	Obj_to_ip_head->prev = Obj_to_ip_end->prev = Obj_to_ip_head;
+//	Obj_to_ip_head->next = Obj_to_ip_end->next = Obj_to_ip_end;
+//	List_ptr = Obj_to_ip_head;
+//}
+//
+///*
+// *
+// * add a link object_id to olsr_node, to get ip adress and coordinates per object_id
+// *                 id => object_id, returned from s3d_clone or s3d_new_object
+// *  **olsr_node => pointer to pointer of current olsr_node
+// *
+// */
+//
+//void lst_add(int id,struct olsr_node **olsr_node) {
+//	struct Obj_to_ip *new;
+//	new = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
+//	if(new == NULL)
+//		out_of_mem();
+//	new->id = id;
+//	new->olsr_node = *olsr_node;
+//	move_lst_ptr(&id);
+//	new->prev = List_ptr;
+//	new->next = List_ptr->next;
+//	List_ptr->next->prev = new;
+//	List_ptr->next = new;
+//	/* printf("obj2ip: add object %d between %d .. %d ip %s to list\n",new->id,new->prev->id,new->next->id,new->olsr_node->ip); */
+//}
+//
+///*
+// *void move_lst_ptr(int *id)
+// * remove element from obj2ip linked list
+// * id => object_id, returned from s3d_clone or s3d_new_object
+// *
+// */
+//
+//void lst_del(int id) {
+//	struct Obj_to_ip *del;
+//	move_lst_ptr(&id);
+//	if(id != List_ptr->id)
+//	{
+//		printf("obj2ip: remove id %d failed move_lst_ptr return id %d\n",id,List_ptr->next->id);
+//	} else {
+//		del = List_ptr;
+//		List_ptr->next->prev = List_ptr->prev;
+//		List_ptr->prev->next = List_ptr->next;
+//		/* printf("obj2ip: remove object %d --> %d <-- %d ip %s from list\n",List_ptr->prev->id,del->id,List_ptr->next->id,del->olsr_node->ip); */
+//		free(del);
+//	}
+//}
+//
+///*
+// *
+// * move the List_ptr one positon ahead the searched element
+// *	*id => pointer of object_id , returned from s3d_clone or s3d_new_object
+// *
+// */
+//
+//struct olsr_node *move_lst_ptr(int *id) {
+//	/* printf("obj2ip: move for %d\n",*id); */
+//	/* head to point at end or id lass then first element in linked list*/
+//	if(Obj_to_ip_head->next == Obj_to_ip_head || *id < Obj_to_ip_head->next->id) {
+//		List_ptr = Obj_to_ip_head;
+//		return NULL;
+// 	/* id is greather then last element in linked list */
+//	} else if(*id > Obj_to_ip_end->prev->id) {
+//		List_ptr = Obj_to_ip_end->prev;
+//		return NULL;
+//	} else {
+//		/* printf("obj2ip: ok i search deeper ;-) for id=%d\n",*id); */
+//		if((*id - (int) Obj_to_ip_head->next->id) <= ((int)(Obj_to_ip_end->prev->id)-*id)) {
+//			List_ptr = Obj_to_ip_head;
+//			/* printf("obj2ip: start at head id %d - %d <= %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id); */
+//			while(*id >= List_ptr->next->id) {
+//				/* printf("obj2ip: %d > %d move to ",*id,List_ptr->id); */
+//				List_ptr = List_ptr->next;
+//				/* printf("%d\n",List_ptr->id); */
+//			}
+//		} else {
+//			List_ptr = Obj_to_ip_end;
+//			/* printf("obj2ip: start at end id %d - %d > %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id);  */
+//			/*  do List_ptr = List_ptr->prev; while(*id > List_ptr->prev->id); */
+//			while(*id < List_ptr->prev->id) {
+//				/* printf("obj2ip: %d < %d move to ",*id,List_ptr->id); */
+//				List_ptr = List_ptr->prev;
+//				/* printf("%d\n",List_ptr->id); */
+//			}
+//			List_ptr = List_ptr->prev;
+//		}
+//
+//		if ( List_ptr->id == *id )
+//			return List_ptr->olsr_node;
+//		else
+//			return NULL;
+//
+//		/* printf("obj2ip: found id to insert between %d--> .. <--%d to search/delete %d--> .. <--%d\n",List_ptr->id,List_ptr->next->next->id,List_ptr->prev->id,List_ptr->next->id); */
+//	}
+//}
+//
+///*
+// *
+// * search a object_id in linked list and return pointer on struct olsr_node
+// *	id => object_id , returned from s3d_clone or s3d_new_object
+// *
+// * <example>
+// *     struct olsr_node *olsr_node;
+// *     olsr_node = *lst_search(oid);
+// *     printf("obj2ip: search return %s\n",olsr_node->ip);
+// * </example>
+// *
+// */
+//
+//struct olsr_node *lst_search(int id) {
+//
+//	return( move_lst_ptr(&id) );
+//
+//}
+//
+//void lst_out() {
+//	struct Obj_to_ip *ptr;
+//	ptr = Obj_to_ip_head;
+//	while(ptr != ptr->next) {
+//		printf("id-> %d\n",ptr->id);
+//		ptr = ptr->next;
+//	}
+//}
+//
+int process_main()
+{
+
+	int dn;
+	float f;
+	char *lbuf_ptr, *last_cr_ptr, *con_from, *con_from_end, *con_to, *con_to_end, *etx, *etx_end, *tmpChar;
+	struct olsr_node *olsr_node1;   /* pointer to olsr nodes */
+	struct olsr_node *olsr_node2;
+	int address;
+	char hna_name[NAMEMAX];
+	char hna_node[NAMEMAX];
+
+	lbuf_ptr = lbuf;
+	last_cr_ptr = NULL;
+
+	con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
+	dn = 0;
+
+	/*printf("---lbuf-start---\n%s\n---lbuf-end---\n",lbuf);*/
+
+	while ( (*lbuf_ptr) != '\0' )
+	{
+
+		/* printf( "%c",(*lbuf_ptr) ); */
+
+		if ( (*lbuf_ptr) == '\n' )
+		{
+
+			last_cr_ptr = lbuf_ptr;
+			con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
+			dn = 0;
+
+		}
+
+		if ( (*lbuf_ptr) == '"' )
+		{
+			switch ( dn )
+			{
+				case 0:
+					con_from = lbuf_ptr + 1;
+					break;
+				case 1:
+					con_from_end = lbuf_ptr;
+					break;
+				case 2:
+					con_to = lbuf_ptr + 1;
+					break;
+				case 3:
+					con_to_end = lbuf_ptr;
+					break;
+				case 4:
+					etx = lbuf_ptr + 1;
+					break;
+				case 5:
+					etx_end = lbuf_ptr;
+					break;
+			}
+
+			if ( ++dn == 6 )
+			{
+
+				/* terminate strings - but not before 6 times '"' */
+				(*con_from_end) = (*con_to_end) = (*etx_end) = '\0';
+
+				if( Global.debug ) printf( "con_from: %s, con_to: %s, etx: %s\n", con_from, con_to, etx );
+
+				/* announced network via HNA */
+				if ( strncmp( etx, "HNA", NAMEMAX ) == 0 )
+				{
+
+					/* connection to internet */
+					if ( strncmp( con_to, "0.0.0.0/0.0.0.0", NAMEMAX ) == 0 )
+					{
+
+//						olsr_node1 = get_olsr_node( &Olsr_root, con_from );
+
+						if ( olsr_node1->node_type != 1 )
+						{
+
+							olsr_node1->node_type = 1;
+							olsr_node1->node_type_modified = 1;
+							if ( Global.debug ) printf( "new internet: %s\n", olsr_node1->ip );
+
+						}
+
+					/* normal HNA */
+					} else {
+						memmove(hna_node,con_to,NAMEMAX);
+						if( (tmpChar = strchr(hna_node, (int)'/')))
+						{
+							tmpChar++;
+							address = (int)-inet_network(tmpChar);
+							sprintf(hna_name,"%d",(int)(32 - ceil(log(address)/log(2))));
+							strcpy(tmpChar,hna_name);
+						}
+
+//						olsr_node1 = get_olsr_node( &Olsr_root, con_from );
+//						olsr_node2 = get_olsr_node( &Olsr_root, hna_node );
+
+						if ( olsr_node2->node_type != 2 ) {
+
+							olsr_node2->node_type = 2;
+							olsr_node2->node_type_modified = 1;
+							if ( Global.debug ) printf( "new hna network: %s\n", olsr_node2->ip );
+
+						}
+//						if ( olsr_node1->visible && olsr_node2->visible )
+//							add_olsr_con( olsr_node1, olsr_node2, -1000.00 );
+
+					}
+
+				/* normal node */
+				} else {
+
+//					olsr_node1 = get_olsr_node( &Olsr_root, con_from );
+//					olsr_node2 = get_olsr_node( &Olsr_root, con_to );
+					f = strtod(etx,NULL);
+					if ( f < 1.0 )
+						f = 999.0;
+//					add_olsr_con( olsr_node1, olsr_node2, f );
+				}
+				/* remove zerobyte */
+				(*con_from_end) = (*con_to_end) = (*etx_end) = '"';
+
+				con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
+				dn = 0;
+				last_cr_ptr = lbuf_ptr;
+
+			}
+
+		} else if ( ( (*lbuf_ptr) == '}' ) && ( (*(lbuf_ptr + 1)) == '\n' ) ) {
+
+//			Output_block_completed = 1;
+
+		}
+
+		lbuf_ptr++;
+
+	}
+
+	if ( last_cr_ptr != NULL ) memmove( lbuf, last_cr_ptr + 1, strlen( last_cr_ptr ) );
+	/*printf("---memmove-lbuf-start---\n%s\n---memmove-lbuf-end---\n",lbuf);*/
+	return(0);
+
+}

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2007-03-04 20:25:19 UTC (rev 583)
+++ trunk/configure.ac	2007-03-10 17:45:52 UTC (rev 584)
@@ -209,6 +209,7 @@
 	libs3dw/Makefile
 	apps/Makefile
 	apps/olsrs3d/Makefile
+	apps/meshs3d/Makefile	
 	apps/s3d_x11gate/Makefile
 	apps/s3dvt/Makefile
 	apps/s3dfm/Makefile



