From dotslash at mail.berlios.de  Sat Dec  2 14:31:50 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 2 Dec 2006 14:31:50 +0100
Subject: [S3d-svn] r499 - trunk
Message-ID: <200612021331.kB2DVofB014465@sheep.berlios.de>

Author: dotslash
Date: 2006-12-02 14:31:50 +0100 (Sat, 02 Dec 2006)
New Revision: 499

Modified:
   trunk/
   trunk/config.h.in
   trunk/configure.ac
Log:
 r1190 at kero:  dotslash | 2006-12-02 14:31:46 +0100
 - proper gps checking with autohell



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1188
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1190

Modified: trunk/config.h.in
===================================================================
--- trunk/config.h.in	2006-11-30 22:47:08 UTC (rev 498)
+++ trunk/config.h.in	2006-12-02 13:31:50 UTC (rev 499)
@@ -6,6 +6,8 @@
 /* Use SDL */
 #undef G_SDL
 
+#undef HAVE_GPS
+
 /* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
    */
 #undef HAVE_DIRENT_H

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-11-30 22:47:08 UTC (rev 498)
+++ trunk/configure.ac	2006-12-02 13:31:50 UTC (rev 499)
@@ -121,7 +121,8 @@
  ### Sorry, you lack the libxml2 library to compile the s3dosm application."
 
 fi
-		
+
+	
 if test x"${HAVE_SQLITE3}" = xyes ; then
 	LIBSQLITE3_CFLAGS=""
 	LIBSQLITE3_LIBS="-lsqlite3"
@@ -136,7 +137,6 @@
 
 
 
-
 AM_CONDITIONAL([BUILD_S3DOSM], [test x"${HAVE_XML}" = xyes && test x"${HAVE_SQLITE3}" = xyes])
 
 SIM_AC_HAVE_SIMAGE_IFELSE([
@@ -148,8 +148,13 @@
 	WARNS="$WARNS
  ### Sorry, you lack the simage library to compile the s3dgps application."
 ])
+AC_CHECK_HEADER(gps.h, [HAVE_GPS=yes])
 AM_CONDITIONAL([BUILD_S3DGPS], [test x$HAVE_GPS = xyes && test x$sim_ac_simage_avail = xtrue])
 
+if test "x${HAVE_GPS}" = "xyes"; then
+	AC_DEFINE([HAVE_GPS], 1, [Have gps support])
+fi
+
 AC_CHECK_LIB(Xtst, main, [HAVE_Xtst=yes], [HAVE_Xtst=no], [$X_PRE_LIBS $X_LIBS $X_EXTRA_LIBS])
 if test x$HAVE_Xtst = xyes; then
 	XTST_CFLAGS=
@@ -167,7 +172,6 @@
 AC_ARG_WITH([examples], AS_HELP_STRING([--with-examples], [build examples]), [with_examples=$withval], [with_examples=yes])
 AM_CONDITIONAL([BUILD_EXAMPLES], [test x$with_examples = xyes])
 ########################################### LIBG3D ################
-AC_CONFIG_HEADERS(libs3d/libg3d/include/g3d/config.h)
 AM_PROG_LEX
 
 ## gtk-doc
@@ -216,7 +220,7 @@
 	AC_DEFINE([SIGS], 1, [Define if signal code should be compiled])
 fi
 
-AC_CONFIG_HEADER(config.h)
+AC_CONFIG_HEADERS(libs3d/libg3d/include/g3d/config.h config.h)
 AC_CONFIG_FILES([
 	Makefile
 	server/Makefile



From dotslash at mail.berlios.de  Sat Dec  2 15:38:45 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 2 Dec 2006 15:38:45 +0100
Subject: [S3d-svn] r500 - in trunk: . libs3d/libg3d/include/g3d
Message-ID: <200612021438.kB2EcjpK020545@sheep.berlios.de>

Author: dotslash
Date: 2006-12-02 15:38:45 +0100 (Sat, 02 Dec 2006)
New Revision: 500

Modified:
   trunk/
   trunk/configure.ac
   trunk/libs3d/libg3d/include/g3d/config.h.in
Log:
 r1192 at kero:  dotslash | 2006-12-02 15:38:41 +0100
 - sqlite3 now REALLY optional :)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1190
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1192

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-12-02 13:31:50 UTC (rev 499)
+++ trunk/configure.ac	2006-12-02 14:38:45 UTC (rev 500)
@@ -106,7 +106,7 @@
 PKG_CHECK_MODULES(FONTCONFIG, fontconfig >= 2.1.0, [:], [AC_MSG_ERROR([Please install fontconfig (version 2.1.0 or higher)])])
 PKG_CHECK_MODULES(FREETYPE, freetype2 >= 9.5.0, [:], [AC_MSG_ERROR([Please install freetype2 (version 9.5.0 or higher)])])
 
-PKG_CHECK_MODULES(SQLITE3, sqlite3 >= 3.0, [HAVE_SQLITE3="yes"], [])
+PKG_CHECK_MODULES(SQLITE3, sqlite3 >= 3.0, [HAVE_SQLITE3="yes"], [HAVE_SQLITE3="no"])
 # libxml2
 AM_PATH_XML2(2.0.0, [HAVE_XML="yes"], [])
 

Modified: trunk/libs3d/libg3d/include/g3d/config.h.in
===================================================================
--- trunk/libs3d/libg3d/include/g3d/config.h.in	2006-12-02 13:31:50 UTC (rev 499)
+++ trunk/libs3d/libg3d/include/g3d/config.h.in	2006-12-02 14:38:45 UTC (rev 500)
@@ -16,6 +16,9 @@
 /* Define to 1 if you have the <fcntl.h> header file. */
 #undef HAVE_FCNTL_H
 
+/* Have gps support */
+#undef HAVE_GPS
+
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 



From dotslash at mail.berlios.de  Sat Dec  2 15:55:06 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 2 Dec 2006 15:55:06 +0100
Subject: [S3d-svn] r501 - trunk
Message-ID: <200612021455.kB2Et6i0022256@sheep.berlios.de>

Author: dotslash
Date: 2006-12-02 15:55:06 +0100 (Sat, 02 Dec 2006)
New Revision: 501

Modified:
   trunk/
   trunk/configure.ac
Log:
 r1194 at kero:  dotslash | 2006-12-02 15:55:03 +0100
 - one more fix for gps (GPS_CFLAGS and GPS_LIBS were undefined in configure.ac)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1192
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1194

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-12-02 14:38:45 UTC (rev 500)
+++ trunk/configure.ac	2006-12-02 14:55:06 UTC (rev 501)
@@ -153,6 +153,11 @@
 
 if test "x${HAVE_GPS}" = "xyes"; then
 	AC_DEFINE([HAVE_GPS], 1, [Have gps support])
+	GPS_CFLAGS=
+	GPS_LIBS="-lgps"
+	AC_SUBST(GPS_CFLAGS)
+	AC_SUBST(GPS_LIBS)
+
 fi
 
 AC_CHECK_LIB(Xtst, main, [HAVE_Xtst=yes], [HAVE_Xtst=no], [$X_PRE_LIBS $X_LIBS $X_EXTRA_LIBS])



From dotslash at mail.berlios.de  Sat Dec  2 16:59:32 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 2 Dec 2006 16:59:32 +0100
Subject: [S3d-svn] r502 - in trunk: . apps/s3dgps
Message-ID: <200612021559.kB2FxWsU027960@sheep.berlios.de>

Author: dotslash
Date: 2006-12-02 16:59:31 +0100 (Sat, 02 Dec 2006)
New Revision: 502

Modified:
   trunk/
   trunk/apps/s3dgps/s3dgps.c
Log:
 r1196 at kero:  dotslash | 2006-12-02 16:59:28 +0100
 - fix for new gps header



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1194
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1196

Modified: trunk/apps/s3dgps/s3dgps.c
===================================================================
--- trunk/apps/s3dgps/s3dgps.c	2006-12-02 14:55:06 UTC (rev 501)
+++ trunk/apps/s3dgps/s3dgps.c	2006-12-02 15:59:31 UTC (rev 502)
@@ -24,9 +24,12 @@
 
 #include <s3d.h>
 #include <gps.h> 	/* gps_*() */
-#ifdef NMEA_CHANNELS
+#ifdef NMEA_CHANNELS 
 #define GPS_NEW
 #endif
+#ifdef SIRF_CHANNELS
+#define GPS_NEW
+#endif
 #include <stdio.h> 	/* printf() */
 #include <errno.h>  /* errno */
 #include <stdlib.h>	/* malloc(), free() */
@@ -213,24 +216,35 @@
 }
 void show_gpsdata(struct gps_data_t *dgps)
 {
-/*	if (!dgps->online) 
+	if (!dgps->online) 
 		printf("WARNING: no connection to gps device\n");
+#ifdef GPS_NEW
+	printf("[%d] lat/long: [%f|%f], altitude %f\n",frame,dgps->fix.latitude,dgps->fix.longitude,dgps->fix.altitude);
+	printf("speed [kph]: %f\n",dgps->fix.speed/KNOTS_TO_KPH);
+	printf("used %d/%d satellits\n",dgps->satellites_used,dgps->satellites);
+#else
 	printf("[%d] lat/long: [%f|%f], altitude %f\n",frame,dgps->latitude,dgps->longitude,dgps->altitude);
-	printf("speed [kph]: %f",dgps->speed/KNOTS_TO_KPH);
+	printf("speed [kph]: %f\n",dgps->speed/KNOTS_TO_KPH);
 	printf("used %d/%d satellits\n",dgps->satellites_used,dgps->satellites);
+
+#endif
 	switch (dgps->status)
 	{
-		case STATUS_NO_FIX:		printf("status: no fix");break;
-		case STATUS_FIX:		printf("status: fix");break;
-		case STATUS_DGPS_FIX:	printf("status: dgps fix");break;
+		case STATUS_NO_FIX:		printf("status: no fix\n");break;
+		case STATUS_FIX:		printf("status: fix\n");break;
+		case STATUS_DGPS_FIX:	printf("status: dgps fix\n");break;
 	}
+#ifdef GPS_NEW
+	switch (dgps->fix.mode)
+#else 
 	switch (dgps->mode)
+#endif
 	{
 		case MODE_NOT_SEEN:	printf("mode: not seen yet\n");break;
 		case MODE_NO_FIX:	printf("mode: no fix\n");break;
 		case MODE_2D:		printf("mode: 2d fix\n");break;
 		case MODE_3D:		printf("mode: 3d fix\n");break;
-	}*/
+	}
 }
 int lastfix=0;
 void show_position(struct gps_data_t *dgps)
@@ -382,7 +396,7 @@
 			
 			printf("connection established !!\n");
 			printf("query ...\n");
-			gps_query(dgps, "w+x\n");
+			gps_query(dgps, "rw+x\n");
 			printf("done\n");
 			s3d_mainloop(mainloop);
 			printf("done\n");



From dotslash at mail.berlios.de  Sat Dec  2 22:09:36 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 2 Dec 2006 22:09:36 +0100
Subject: [S3d-svn] r503 - in trunk: . apps/s3dosm
Message-ID: <200612022109.kB2L9a25032705@sheep.berlios.de>

Author: dotslash
Date: 2006-12-02 22:09:34 +0100 (Sat, 02 Dec 2006)
New Revision: 503

Added:
   trunk/apps/s3dosm/gps.c
Modified:
   trunk/
   trunk/apps/s3dosm/Makefile.am
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/http_fetcher.c
   trunk/apps/s3dosm/http_fetcher.h
   trunk/apps/s3dosm/main.c
   trunk/apps/s3dosm/nav.c
   trunk/apps/s3dosm/s3dosm.h
Log:
 r1198 at kero:  dotslash | 2006-12-02 22:08:53 +0100
 - gps support, showing your position



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1196
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1198

Modified: trunk/apps/s3dosm/Makefile.am
===================================================================
--- trunk/apps/s3dosm/Makefile.am	2006-12-02 15:59:31 UTC (rev 502)
+++ trunk/apps/s3dosm/Makefile.am	2006-12-02 21:09:34 UTC (rev 503)
@@ -5,9 +5,10 @@
 				  
 s3dosm_SOURCES =  \
 	main.c http_fetcher.c http_error_codes.c osm.c \
-	object.c draw.c kismet.c nav.c tag.c io.c db.c
+	object.c draw.c kismet.c nav.c tag.c io.c db.c \
+	gps.c
 
-s3dosm_CPPFLAGS=	-pg -I$(top_srcdir)/libs3d @LIBXML2_CFLAGS@ @LIBSQLITE3_CFLAGS@
-s3dosm_LDADD=		$(top_builddir)/libs3d/libs3d.la @LIBXML2_LIBS@ @LIBSQLITE3_LIBS@
+s3dosm_CPPFLAGS=	-pg -I$(top_srcdir)/libs3d @LIBXML2_CFLAGS@ @LIBSQLITE3_CFLAGS@ @GPS_CFLAGS@
+s3dosm_LDADD=		$(top_builddir)/libs3d/libs3d.la @LIBXML2_LIBS@ @LIBSQLITE3_LIBS@ @GPS_LIBS@
 s3dosm_LDFLAGS=		-pg
 

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-02 15:59:31 UTC (rev 502)
+++ trunk/apps/s3dosm/draw.c	2006-12-02 21:09:34 UTC (rev 503)
@@ -34,7 +34,7 @@
 	int vnum;
 };
 
-void calc_earth_to_eukl(float lon, float lat, float *x)
+void calc_earth_to_eukl(float lat, float lon, float *x)
 {
 	float la,lo;
 	la=lat*M_PI/180.0;
@@ -53,7 +53,7 @@
 		float x[3];
 		node_t *node=NODE_T(t);
 		node->vid=v->vnum;
-		calc_earth_to_eukl(node->lon,node->lat,x);
+		calc_earth_to_eukl(node->lat,node->lon,x);
 		s3d_push_vertex(v->oid,x[0],x[1],x[2]);
 		if (node->visible==2) /* something special */
 		{
@@ -168,8 +168,8 @@
 		nodelist_n=0;
 		snprintf(query,MAXQ,"SELECT longitude, latitude, altitude FROM node WHERE node_id IN (%d,%d);",waylist_p[i].node_from,waylist_p[i].node_to);
 		db_exec(query, insert_node,(void *)nodelist_p);
-		calc_earth_to_eukl(nodelist_p[0].lo,nodelist_p[0].la,x);
-		calc_earth_to_eukl(nodelist_p[1].lo,nodelist_p[1].la,x+3);
+		calc_earth_to_eukl(nodelist_p[0].la,nodelist_p[0].lo,x);
+		calc_earth_to_eukl(nodelist_p[1].la,nodelist_p[1].lo,x+3);
 		s3d_push_vertices(way_obj,x,2);
 		s3d_push_line(way_obj, vert,vert+1, 0);
 		vert+=2;
@@ -242,6 +242,13 @@
 	waylist_draw(); /* last way */
 	printf("[done]\n");
 }
+void draw_translate_icon(int user_icon, float la, float lo)
+{
+	float x[3];
+	calc_earth_to_eukl(la,lo,x);
+	s3d_translate(user_icon,x[0],x[1],x[2]);
+	s3d_rotate(user_icon,(90-la),lo,0);
+}
 void draw_osm()
 {
 	draw_ways("segment.layer_id=(SELECT layer_id FROM layer WHERE name='osm')");

Added: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2006-12-02 15:59:31 UTC (rev 502)
+++ trunk/apps/s3dosm/gps.c	2006-12-02 21:09:34 UTC (rev 503)
@@ -0,0 +1,202 @@
+/*
+ * gps.c
+ * 
+ * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dosm, a gps card application for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dosm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dosm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dosm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <s3d.h>
+#include "s3dosm.h"
+#include <stdio.h> 	/* printf() */
+int user_icon=-1,user_icon_rotator=-1;
+#ifdef HAVE_GPS
+#include <gps.h> 	/* gps_*() */
+#ifdef NMEA_CHANNELS
+#define GPS_NEW
+#endif
+#ifdef SIRF_CHANNELS
+#define GPS_NEW
+#endif
+
+#include <errno.h>  /* errno */
+#include <stdlib.h>	/* malloc(), free() */
+#include <string.h> /* strlen() */
+#include <stdio.h>		 /*  snprintf(), printf(), NULL */
+#include <time.h>	 /*  nanosleep(), struct tm, time_t...  */
+#include <math.h>	/* fabs(), finite () */
+static struct gps_data_t 	*dgps;
+static int 					 frame=0;
+static int 					 lastfix=0;
+static int 					 gps_active=0;
+static float 				 lat,lon,tlat,tlon;	/* we have the same in nav.c, this one is for the user icon ... */
+static float				 lat_old,lon_old;
+void 				 show_gpsdata(struct gps_data_t *dgps);
+void				 show_position(struct gps_data_t *dgps);
+
+void show_gpsdata(struct gps_data_t *dgps)
+{
+	if (!dgps->online) 
+		printf("WARNING: no connection to gps device\n");
+#ifdef GPS_NEW
+	printf("[%d] lat/long: [%f|%f], altitude %f\n",frame,dgps->fix.latitude,dgps->fix.longitude,dgps->fix.altitude);
+	printf("speed [kph]: %f\n",dgps->fix.speed/KNOTS_TO_KPH);
+	printf("used %d/%d satellits\n",dgps->satellites_used,dgps->satellites);
+	printf("################## = %f %f %f\n",dgps->fix.pitch, dgps->fix.roll, dgps->fix.dip);
+#else
+	printf("[%d] lat/long: [%f|%f], altitude %f\n",frame,dgps->latitude,dgps->longitude,dgps->altitude);
+	printf("speed [kph]: %f\n",dgps->speed/KNOTS_TO_KPH);
+	printf("used %d/%d satellits\n",dgps->satellites_used,dgps->satellites);
+
+#endif
+	switch (dgps->status)
+	{
+		case STATUS_NO_FIX:		printf("status: no fix\n");break;
+		case STATUS_FIX:		printf("status: fix\n");break;
+		case STATUS_DGPS_FIX:	printf("status: dgps fix\n");break;
+	}
+#ifdef GPS_NEW
+	switch (dgps->fix.mode)
+#else 
+	switch (dgps->mode)
+#endif
+	{
+		case MODE_NOT_SEEN:	printf("mode: not seen yet\n");break;
+		case MODE_NO_FIX:	printf("mode: no fix\n");break;
+		case MODE_2D:		printf("mode: 2d fix\n");break;
+		case MODE_3D:		printf("mode: 3d fix\n");break;
+	}
+}
+void show_position(struct gps_data_t *dgps)
+{
+	int fix=1;
+	float la,lo,heading;
+#ifdef GPS_NEW
+	if (!dgps->online) 
+		fix=0;
+	switch (dgps->fix.mode)
+	{
+		case MODE_NOT_SEEN:	fix=0;break;
+		case MODE_NO_FIX:	fix=0;break;
+	}
+	
+	la=dgps->fix.latitude;
+	lo=dgps->fix.longitude;
+
+#else
+	if (!dgps->online) 
+		fix=0;
+	switch (dgps->mode)
+	{
+		case MODE_NOT_SEEN:	fix=0;break;
+		case MODE_NO_FIX:	fix=0;break;
+	}
+	la=dgps->latitude;
+	lo=dgps->longitude;
+#endif
+	tlat=la;tlon=lo;
+	nav_center(la,lo);
+	heading=get_heading(lat_old,lon_old,la,lo);
+	if (!lastfix && fix) 		{s3d_flags_on(user_icon,S3D_OF_VISIBLE);s3d_scale(user_icon,1.0);}
+	if (lastfix && !fix)		{s3d_scale(user_icon,0.3);lat=tlat;lon=tlon;}
+	if (finitef(heading))		s3d_rotate(user_icon,0,heading,0);
+	lat_old=la;
+	lon_old=lo;
+	lastfix=fix;
+}
+int gps_init(char *gpshost)
+{
+	char *err_str;
+	dgps=gps_open(gpshost,"2947");
+    if (dgps==NULL) {
+		switch ( errno ) {
+			case NL_NOSERVICE: 	err_str = "can't get service entry"; break;
+			case NL_NOHOST: 	err_str = "can't get host entry"; break;
+			case NL_NOPROTO: 	err_str = "can't get protocol entry"; break;
+			case NL_NOSOCK: 	err_str = "can't create socket"; break;
+			case NL_NOSOCKOPT: 	err_str = "error SETSOCKOPT SO_REUSEADDR"; break;
+			case NL_NOCONNECT: 	err_str = "can't connect to host"; break;
+			default:           	err_str = "Unknown"; break;
+		}
+		printf("no connection to gpsd\n");
+		fprintf(stderr, "s3dosm: no gpsd running or network error: %d, %s\n"	,  errno, err_str);
+		return(-1);
+	}
+	user_icon=s3d_clone(icons[ICON_ARROW].oid);
+	user_icon_rotator=s3d_new_object();
+	s3d_link(user_icon,user_icon_rotator);
+	s3d_link(user_icon_rotator,oidy); 
+	tlat=lat=lat_old=0.0;
+	tlon=lon=lon_old=0.0;
+	gps_active=1;
+	gps_query(dgps, "w+x\n");
+	return(0);
+}
+int gps_main()
+{
+	if (gps_active && ((frame%6)==0))
+	{
+		if (gps_poll(dgps) < 0) 
+		{
+			printf("read error on server socket\n");
+			gps_quit();
+		}
+
+		/*show_gpsdata(dgps);*/
+		show_position(dgps);
+	}
+	if ((fabs(tlat-lat)>0.00001) && (fabs(tlon-lon)>0.00001)) {
+		if (lat==0.0 && lon==0.0) {
+			lat=tlat;
+			lon=tlon;
+		} else {
+			lat=(tlat+lat*3)/4;
+			lon=(tlon+lon*3)/4;
+		}
+	} else { tlat=lat;tlon=lon;}
+	draw_translate_icon(user_icon_rotator,lat,lon);
+	frame++;
+	return(0);
+}
+int gps_quit()
+{
+	if (gps_active)
+	{
+		printf("deactivating gps-connection ...\n");
+		gps_active=0;
+		gps_close(dgps);
+	}
+	return(0);
+}
+#else
+
+int gps_init(char *gpshost)
+{
+	printf("GPS support not compiled in!\n");
+	return(0);
+}
+int gps_main()
+{
+	return(0);
+}
+int gps_quit()
+{
+	return(0);
+}
+#endif

Modified: trunk/apps/s3dosm/http_fetcher.c
===================================================================
--- trunk/apps/s3dosm/http_fetcher.c	2006-12-02 15:59:31 UTC (rev 502)
+++ trunk/apps/s3dosm/http_fetcher.c	2006-12-02 21:09:34 UTC (rev 503)
@@ -124,7 +124,7 @@
 		strcat(requestBuf, "User-Agent: ");
 		strcat(requestBuf, DEFAULT_USER_AGENT);
 		strcat(requestBuf, "/");
-		strcat(requestBuf, VERSION);
+		strcat(requestBuf, HTTP_FETCHER_VERSION);
 		strcat(requestBuf, "\r\n");
 		}
 	else if(!hideUserAgent)
@@ -379,7 +379,7 @@
 	char ec64[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 	char *b64;
 	int i,j,c,len,n;
-	char o;
+	char o=0;
 	 /* base64 encode user and pass */
 	if ((user==NULL) || (pass==NULL)) /* bad input or request to clean up */
 	{

Modified: trunk/apps/s3dosm/http_fetcher.h
===================================================================
--- trunk/apps/s3dosm/http_fetcher.h	2006-12-02 15:59:31 UTC (rev 502)
+++ trunk/apps/s3dosm/http_fetcher.h	2006-12-02 21:09:34 UTC (rev 503)
@@ -29,7 +29,7 @@
 #define PORT_NUMBER 			80
 #define HTTP_VERSION 			"HTTP/1.1"
 #define DEFAULT_USER_AGENT		"HTTP Fetcher"
-#define	VERSION					"1.0"
+#define	HTTP_FETCHER_VERSION	"1.0"
 #define DEFAULT_READ_TIMEOUT	30		/* Seconds to wait before giving up
 										 *	when no data is arriving */
 	 

Modified: trunk/apps/s3dosm/main.c
===================================================================
--- trunk/apps/s3dosm/main.c	2006-12-02 15:59:31 UTC (rev 502)
+++ trunk/apps/s3dosm/main.c	2006-12-02 21:09:34 UTC (rev 503)
@@ -31,6 +31,8 @@
 {
 	struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
 	nanosleep(&t,NULL); 
+	gps_main();
+	nav_main();
 }
 int init(int argc, char **argv)
 {
@@ -40,12 +42,14 @@
 	nav_init();
 	nav_autocenter();
 	draw_all_layers();
+	gps_init("localhost");
 	return(0);
 }
 int quit()
 {
 	s3d_quit();
 	db_quit();
+	gps_quit();
 	return(0);
 }
 int main(int argc, char **argv)

Modified: trunk/apps/s3dosm/nav.c
===================================================================
--- trunk/apps/s3dosm/nav.c	2006-12-02 15:59:31 UTC (rev 502)
+++ trunk/apps/s3dosm/nav.c	2006-12-02 21:09:34 UTC (rev 503)
@@ -3,12 +3,15 @@
 #include <string.h>	/* strcmp() */
 #include <stdlib.h>	/* strtod() */
 #include <stdio.h>	/* printf() */
+#include <math.h>	/* fabs() */
 
 icon_t icons[ICON_NUM]={
 		{"objs/accesspoint.3ds",0},
 		{"objs/star.3ds",0},
+		{"objs/arrow2.3ds",0}
 	};
 int oidx, oidy;
+static float lat,lon,tlat,tlon;
 /* load icons, we want to clone each of them later */
 void nav_loadicons()
 {
@@ -21,6 +24,7 @@
 /* load rotation centers */
 void nav_init()
 {
+	lat=lon=tlat=tlon=0.0;
 	nav_loadicons();
 	oidx=s3d_new_object();
 	oidy=s3d_new_object();
@@ -29,11 +33,27 @@
 /* center to given latitude longitude */
 void nav_center(float la, float lo)
 {
+	tlat=la;
+	tlon=lo;
+}
+void nav_main()
+{
 	float x[3];
-	s3d_rotate(oidy,0,-lo,0);
-	s3d_rotate(oidx,-(90-la),0,0);
-	calc_earth_to_eukl(lo,la,x);
-	s3d_translate(oidx,0,-ESIZE*RESCALE,0);
+	if ((fabs(tlat-lat)>0.00001) && (fabs(tlon-lon)>0.00001))
+	{
+		if (lat==0.0 && lon==0.0)
+		{
+			lat=tlat;
+			lon=tlon;
+		} else {
+			lat=(tlat+lat*15)/16;
+			lon=(tlon+lon*15)/16;
+		}
+	} else { lat=tlat;lon=tlon;}
+	s3d_rotate(oidy,0,-lon,0);
+	s3d_rotate(oidx,-(90-lat),0,0);
+	calc_earth_to_eukl(lon,lat,x);
+	s3d_translate(oidx,0,-ESIZE*RESCALE- VIEWHEIGHT,0);
 	s3d_scale(oidx,RESCALE);
 }
 
@@ -51,6 +71,22 @@
 	}
 	return(0);
 }
+/* returns the heading in degress of position P1 -> P2 */
+float get_heading(float la1, float lo1, float la2, float lo2) {
+	float p1_north[3], p1[3], p2[3];
+	float dir[3],north[3];
+	float angle;
+	int i;
+	calc_earth_to_eukl(la1,lo1,p1);
+	calc_earth_to_eukl(la2,lo2,p2);
+	calc_earth_to_eukl(la1+1,lo1,p1_north);
+	for (i=0;i<3;i++)		north[i]=p1_north[i]-p1[i];
+	for (i=0;i<3;i++)		dir[i]=p2[i]-p1[i];
+	angle=s3d_vector_angle(dir,north);
+	angle=angle*180.0/M_PI;
+	if ((lo2>lo1) || (lo1-lo2>180.0))		angle=360-angle;
+	return(angle);
+}
 /* find some good center on our own */
 void nav_autocenter()
 {

Modified: trunk/apps/s3dosm/s3dosm.h
===================================================================
--- trunk/apps/s3dosm/s3dosm.h	2006-12-02 15:59:31 UTC (rev 502)
+++ trunk/apps/s3dosm/s3dosm.h	2006-12-02 21:09:34 UTC (rev 503)
@@ -1,6 +1,8 @@
 #include <sqlite3.h>
+#include "../../config.h"
 #define	ESIZE	637800		/* earth size */
-#define	RESCALE	1
+#define	RESCALE	0.5
+#define VIEWHEIGHT 3
 #define MAXQ	4096	
 #define QBUF	1024*128
 
@@ -46,6 +48,7 @@
 enum {
 	ICON_AP,
 	ICON_AP_OPEN,
+	ICON_ARROW,
 	ICON_NUM
 };
 enum {
@@ -130,12 +133,15 @@
 layer_t *load_kismet_file(char *filename);
 /* draw.c */
 void draw_all_layers();
-void calc_earth_to_eukl(float lon, float lat, float *x);
 int draw_layer(layer_t *layer);
+void calc_earth_to_eukl(float lat, float lon, float *x);
+void draw_translate_icon(int user_icon, float la, float lo);
 /* nav.c */
+void nav_main();
 void nav_init();
 void nav_center(float la, float lo);
 void nav_autocenter();
+float get_heading(float la1, float lo1, float la2, float lo2);
 extern int oidy;
 /* tag.c */
 void tag_add(object_t *obj,char *k, char *v);
@@ -156,3 +162,7 @@
 int db_insert_layer(char *layer_name);
 void db_flush();
 int callback(void *NotUsed, int argc, char **argv, char **azColName);
+/* gps.c */
+int gps_init(char *gpshost);
+int gps_main();
+int gps_quit();



From dotslash at mail.berlios.de  Sat Dec  2 22:09:40 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 2 Dec 2006 22:09:40 +0100
Subject: [S3d-svn] r504 - in trunk: . apps/s3dgps objs
Message-ID: <200612022109.kB2L9evw032764@sheep.berlios.de>

Author: dotslash
Date: 2006-12-02 22:09:39 +0100 (Sat, 02 Dec 2006)
New Revision: 504

Added:
   trunk/objs/arrow2.3ds
Modified:
   trunk/
   trunk/apps/s3dgps/s3dgps.c
   trunk/objs/Makefile.am
Log:
 r1199 at kero:  dotslash | 2006-12-02 22:09:30 +0100
 - add arrow for s3dosm



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1198
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1199

Modified: trunk/apps/s3dgps/s3dgps.c
===================================================================
--- trunk/apps/s3dgps/s3dgps.c	2006-12-02 21:09:34 UTC (rev 503)
+++ trunk/apps/s3dgps/s3dgps.c	2006-12-02 21:09:39 UTC (rev 504)
@@ -384,7 +384,7 @@
 				default:             	err_str = "Unknown"; break;
 			}
 			printf("no connection to gpsd\n");
-			fprintf( stderr, "xgps: no gpsd running or network error: %d, %s\n"	, errno, err_str);
+			fprintf( stderr, "%s: no gpsd running or network error: %d, %s\n"	, argv[0], errno, err_str);
 		} else {
 			parse_mapkoords();
 			load_icons();

Modified: trunk/objs/Makefile.am
===================================================================
--- trunk/objs/Makefile.am	2006-12-02 21:09:34 UTC (rev 503)
+++ trunk/objs/Makefile.am	2006-12-02 21:09:39 UTC (rev 504)
@@ -6,6 +6,7 @@
 	katze_tail.3ds \
 	sec_p.3ds \
 	arrow.3ds \
+	arrow2.3ds \
 	xyz.3ds \
 	geometry.3ds \
 	rotate.3ds \

Added: trunk/objs/arrow2.3ds
===================================================================
(Binary files differ)


Property changes on: trunk/objs/arrow2.3ds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From dotslash at mail.berlios.de  Sun Dec  3 00:27:32 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 3 Dec 2006 00:27:32 +0100
Subject: [S3d-svn] r505 - in trunk: . apps/dot_mcp
Message-ID: <200612022327.kB2NRWZS013412@sheep.berlios.de>

Author: dotslash
Date: 2006-12-03 00:27:31 +0100 (Sun, 03 Dec 2006)
New Revision: 505

Modified:
   trunk/
   trunk/apps/dot_mcp/main.c
Log:
 r1202 at kero:  dotslash | 2006-12-03 00:12:54 +0100
 - more --notorus option



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1199
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1202

Modified: trunk/apps/dot_mcp/main.c
===================================================================
--- trunk/apps/dot_mcp/main.c	2006-12-02 21:09:39 UTC (rev 504)
+++ trunk/apps/dot_mcp/main.c	2006-12-02 23:27:31 UTC (rev 505)
@@ -509,6 +509,7 @@
 
 	if (!s3d_init(&argc,&argv,"mcp"))	
 	{
+		if (!((argc>1) && (0==strcmp(argv[1],"--notorus"))))
 		greentorus(); /* just call ... */
 
 		if (s3d_select_font("vera"))



From dotslash at mail.berlios.de  Sun Dec  3 00:27:39 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 3 Dec 2006 00:27:39 +0100
Subject: [S3d-svn] r506 - in trunk: . apps/s3dosm
Message-ID: <200612022327.kB2NRdtW013526@sheep.berlios.de>

Author: dotslash
Date: 2006-12-03 00:27:39 +0100 (Sun, 03 Dec 2006)
New Revision: 506

Modified:
   trunk/
   trunk/apps/s3dosm/gps.c
   trunk/apps/s3dosm/main.c
Log:
 r1203 at kero:  dotslash | 2006-12-03 00:27:26 +0100
 - smoother gpspoint-following
 - read heading from gpsd if possible
 - write speed above the user icon



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1202
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1203

Modified: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2006-12-02 23:27:31 UTC (rev 505)
+++ trunk/apps/s3dosm/gps.c	2006-12-02 23:27:39 UTC (rev 506)
@@ -45,8 +45,10 @@
 static int 					 frame=0;
 static int 					 lastfix=0;
 static int 					 gps_active=0;
+static int					 gps_info=-1;
 static float 				 lat,lon,tlat,tlon;	/* we have the same in nav.c, this one is for the user icon ... */
 static float				 lat_old,lon_old;
+static float				 speed_old=0.0;
 void 				 show_gpsdata(struct gps_data_t *dgps);
 void				 show_position(struct gps_data_t *dgps);
 
@@ -83,10 +85,12 @@
 		case MODE_3D:		printf("mode: 3d fix\n");break;
 	}
 }
+#define BUFSIZE		1024
 void show_position(struct gps_data_t *dgps)
 {
 	int fix=1;
-	float la,lo,heading;
+	float la,lo,heading,speed,slen;
+	char buf[BUFSIZE+1];
 #ifdef GPS_NEW
 	if (!dgps->online) 
 		fix=0;
@@ -98,6 +102,8 @@
 	
 	la=dgps->fix.latitude;
 	lo=dgps->fix.longitude;
+	heading=dgps->fix.track;
+	speed=dgps->fix.speed;
 
 #else
 	if (!dgps->online) 
@@ -109,13 +115,32 @@
 	}
 	la=dgps->latitude;
 	lo=dgps->longitude;
+	heading=dgps->track;
+	speed=dgps->speed;
 #endif
 	tlat=la;tlon=lo;
 	nav_center(la,lo);
-	heading=get_heading(lat_old,lon_old,la,lo);
-	if (!lastfix && fix) 		{s3d_flags_on(user_icon,S3D_OF_VISIBLE);s3d_scale(user_icon,1.0);}
-	if (lastfix && !fix)		{s3d_scale(user_icon,0.3);lat=tlat;lon=tlon;}
-	if (finitef(heading))		s3d_rotate(user_icon,0,heading,0);
+	if (!finitef(heading)) {
+		heading=get_heading(lat_old,lon_old,la,lo);
+		if (!lastfix && fix) 		{s3d_flags_on(user_icon,S3D_OF_VISIBLE);s3d_scale(user_icon,1.0);}
+		if (lastfix && !fix)		{s3d_scale(user_icon,0.3);lat=tlat;lon=tlon;}
+		if (finitef(heading))		s3d_rotate(user_icon,0,heading,0);
+	}
+	if (finitef(speed)) {
+		/* print some information */
+		snprintf(buf,BUFSIZE,"speed: %3.2f km/h",speed*3.6);
+		speed_old=speed;
+	} else
+		snprintf(buf,BUFSIZE,"speed: NA (old: %3.2f km/h)",speed_old*3.6);
+
+	if (gps_info!=-1)	s3d_del_object(gps_info);
+	gps_info=s3d_draw_string(buf,&slen);
+	s3d_translate(gps_info,-slen/2,1,0);
+	s3d_link(gps_info, user_icon);
+	s3d_flags_on(gps_info,S3D_OF_VISIBLE);
+
+	
+	
 	lat_old=la;
 	lon_old=lo;
 	lastfix=fix;
@@ -166,8 +191,8 @@
 			lat=tlat;
 			lon=tlon;
 		} else {
-			lat=(tlat+lat*3)/4;
-			lon=(tlon+lon*3)/4;
+			lat=(tlat+lat*7)/8;
+			lon=(tlon+lon*7)/8;
 		}
 	} else { tlat=lat;tlon=lon;}
 	draw_translate_icon(user_icon_rotator,lat,lon);

Modified: trunk/apps/s3dosm/main.c
===================================================================
--- trunk/apps/s3dosm/main.c	2006-12-02 23:27:31 UTC (rev 505)
+++ trunk/apps/s3dosm/main.c	2006-12-02 23:27:39 UTC (rev 506)
@@ -36,6 +36,7 @@
 }
 int init(int argc, char **argv)
 {
+	s3d_select_font("vera");
 	if (db_init(":memory:")) return(-1);
 	if (db_create()) return(-1);
 	if (process_args(argc,argv)) return(-1);



From lazhur at mail.berlios.de  Sun Dec  3 12:36:09 2006
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 3 Dec 2006 12:36:09 +0100
Subject: [S3d-svn] r507 - trunk/libs3d
Message-ID: <200612031136.kB3Ba9qT021324@sheep.berlios.de>

Author: lazhur
Date: 2006-12-03 12:36:08 +0100 (Sun, 03 Dec 2006)
New Revision: 507

Modified:
   trunk/libs3d/fontselect.c
Log:
- fix segfault when fontconfig wasn't able to find any font


Modified: trunk/libs3d/fontselect.c
===================================================================
--- trunk/libs3d/fontselect.c	2006-12-02 23:27:39 UTC (rev 506)
+++ trunk/libs3d/fontselect.c	2006-12-03 11:36:08 UTC (rev 507)
@@ -43,13 +43,14 @@
 {
   FcPattern *pattern = 0, *match = 0;
   FcChar8 *file = 0;
+  FcResult result;
 
   pattern = FcNameParse((FcChar8 *)mask);
   FcConfigSubstitute(0,pattern,FcMatchPattern);
   FcDefaultSubstitute(pattern);
   s3dprintf(LOW,"Looking for font %s",mask);
 
-  if (!(match=FcFontMatch(0,pattern,0))) 
+  if (!(match=FcFontMatch(0,pattern,&result))) 
 	return NULL;
   if (FcPatternGetString(match,FC_FILE,0,&file)!=FcResultMatch)
 	return NULL;



From marec at mail.berlios.de  Mon Dec  4 00:46:52 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Mon, 4 Dec 2006 00:46:52 +0100
Subject: [S3d-svn] r508 - trunk/apps/kism3d
Message-ID: <200612032346.kB3Nkqk1028885@sheep.berlios.de>

Author: marec
Date: 2006-12-04 00:46:51 +0100 (Mon, 04 Dec 2006)
New Revision: 508

Modified:
   trunk/apps/kism3d/client.c
   trunk/apps/kism3d/gui.c
   trunk/apps/kism3d/kism3d.c
   trunk/apps/kism3d/kism3d.h
   trunk/apps/kism3d/network.c
Log:
clients added

Modified: trunk/apps/kism3d/client.c
===================================================================
--- trunk/apps/kism3d/client.c	2006-12-03 11:36:08 UTC (rev 507)
+++ trunk/apps/kism3d/client.c	2006-12-03 23:46:51 UTC (rev 508)
@@ -53,6 +53,8 @@
 	strncpy( wlan_client->mac, mac, 18 );
 	wlan_client->wlan_network = NULL;
 
+	wlan_client->props_changed = 1;
+
 	wlan_client->visible = 1;
 
 	wlan_client->pos_vec[0] = ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
@@ -61,7 +63,7 @@
 	wlan_client->mov_vec[0] = wlan_client->mov_vec[1] = wlan_client->mov_vec[2] = 0.0;
 
 	wlan_client->obj_id = -1;
-	wlan_client->desc_id = -1;
+	wlan_client->ip_id = -1;
 
 	list_add_tail(&wlan_client->list, &Client_list);
 
@@ -70,4 +72,3 @@
 }
 
 
-

Modified: trunk/apps/kism3d/gui.c
===================================================================
--- trunk/apps/kism3d/gui.c	2006-12-03 11:36:08 UTC (rev 507)
+++ trunk/apps/kism3d/gui.c	2006-12-03 23:46:51 UTC (rev 508)
@@ -34,10 +34,17 @@
 
 
 
-float CamPosition[2][3];	/* CamPosition[trans|rot][x-z] */
+float CamPosition[2][3];          /* CamPosition[trans|rot][x-z] */
 
+int Last_Click_Oid = 0;
+int Last_Click_Time = 0;
 
+void *Cam_target = NULL;
 
+int Client_obj;
+
+
+
 int wire_sphere(int slices, int stacks)
 {
 	int x,y,i,o;
@@ -106,8 +113,8 @@
 	return(o);
 }
 
-#define BSSID_SCALE		0.2
 
+
 int handle_networks() {
 
 	struct list_head *network_pos;
@@ -131,7 +138,7 @@
 			if ( wlan_network->obj_id == -1 ) {
 
 				wlan_network->obj_id = s3d_new_object();
-				wlan_network->wrsphr_id = wire_sphere(30,30);
+				wlan_network->wrsphr_id = wire_sphere( 30, 30 );
 				s3d_link( wlan_network->wrsphr_id, wlan_network->obj_id );
 				s3d_flags_on( wlan_network->wrsphr_id, S3D_OF_VISIBLE );
 
@@ -142,8 +149,8 @@
 			s3d_translate( wlan_network->wrsphr_id, 0, /*-6 + wlan_network->scale_fac*/ 0, 0);
 			s3d_scale( wlan_network->obj_id, wlan_network->scale_fac );
 
-			real_node_pos_x = sin( 2.0* M_PI * network_index / ((float) Num_networks ) ) * ( ( ( 1 * Num_networks ) / 2 * M_PI ) );
-			real_node_pos_z = cos( 2.0* M_PI * network_index / ((float) Num_networks ) ) * ( ( ( 1 * Num_networks ) / 2 * M_PI ) );
+			real_node_pos_x = sin( 2.0 * M_PI * network_index / ((float) Num_networks ) ) * ( ( ( 1 * Num_networks ) / 2 * M_PI ) );
+			real_node_pos_z = cos( 2.0 * M_PI * network_index / ((float) Num_networks ) ) * ( ( ( 1 * Num_networks ) / 2 * M_PI ) );
 
 			if ( ( fabs( wlan_network->pos_vec[0] - real_node_pos_x ) > 0.5 ) || ( fabs( wlan_network->pos_vec[2] - real_node_pos_z ) > 0.5 ) ) {
 
@@ -172,10 +179,22 @@
 
 					wlan_network->bssid_id = s3d_draw_string( wlan_network->bssid, &wlan_network->bssid_len );
 					s3d_link( wlan_network->bssid_id, wlan_network->obj_id );
-					s3d_translate( wlan_network->bssid_id, - wlan_network->bssid_len / 2, 2+ wlan_network->scale_fac, 0 );
-					s3d_scale( wlan_network->bssid_id, BSSID_SCALE );
+					s3d_translate( wlan_network->bssid_id, - wlan_network->bssid_len / 2, 2 + wlan_network->scale_fac, 0 );
+					s3d_scale( wlan_network->bssid_id, NETWORK_TEXT_SCALE );
 					s3d_flags_on( wlan_network->bssid_id, S3D_OF_VISIBLE );
 
+					wlan_network->click_id = s3d_new_object();
+					s3d_link( wlan_network->click_id, wlan_network->obj_id );
+					/* s3d_translate( wlan_network->bssid_id, - wlan_network->bssid_len / 2, 2+ wlan_network->scale_fac, 0 ); */
+					s3d_push_vertex( wlan_network->click_id, 0, 0, 0.1 );
+					s3d_push_vertex( wlan_network->click_id, wlan_network->bssid_len, 0, 0.1 );
+					s3d_push_vertex( wlan_network->click_id, wlan_network->bssid_len, 1, 0.1 );
+					s3d_push_vertex( wlan_network->click_id, 0, 1, 0.1 );
+					s3d_push_polygon( wlan_network->click_id, 0, 1, 2, 0 );
+					s3d_push_polygon( wlan_network->click_id, 0, 2, 3, 0 );
+
+					s3d_flags_on( wlan_network->click_id, S3D_OF_SELECTABLE | S3D_OF_VISIBLE );
+
 				}
 
 				wlan_network->ssid_id = s3d_draw_string( wlan_network->ssid, NULL );
@@ -211,7 +230,7 @@
 
 			s3d_rotate( wlan_network->bssid_id, 0, angle , 0 );
 
-			s3d_translate( wlan_network->bssid_id, -cos(angle_rad) * BSSID_SCALE * wlan_network->bssid_len / 2 ,2 , sin(angle_rad) * BSSID_SCALE * wlan_network->bssid_len / 2 );
+			s3d_translate( wlan_network->bssid_id, -cos(angle_rad) * NETWORK_TEXT_SCALE * wlan_network->bssid_len / 2 ,2 , sin(angle_rad) * NETWORK_TEXT_SCALE * wlan_network->bssid_len / 2 );
 
 			wlan_network->rotation = ( wlan_network->rotation + 1 ) % 360;
 			s3d_rotate( wlan_network->wrsphr_id, 0, wlan_network->rotation, 0 );
@@ -229,8 +248,124 @@
 
 
 
+int handle_clients() {
+
+	struct list_head *client_pos;
+	struct wlan_client *wlan_client;
+	float tmp_mov_vec[3], desc_norm_vec[3] = { 0, 0, -1 };
+	float angle, angle_rad;
+
+
+	pthread_mutex_lock( &Client_list_mutex );
+
+	list_for_each(client_pos, &Client_list) {
+
+		wlan_client = list_entry(client_pos, struct wlan_client, list);
+
+		if ( wlan_client->visible ) {
+
+			if ( wlan_client->obj_id == -1 ) {
+
+				wlan_client->obj_id = s3d_new_object();
+				wlan_client->symbol_id = s3d_clone( Client_obj );
+				s3d_link( wlan_client->symbol_id, wlan_client->obj_id );
+				s3d_flags_on( wlan_client->symbol_id, S3D_OF_VISIBLE );
+
+			}
+
+			if ( wlan_client->props_changed ) {
+
+				wlan_client->props_changed = 0;
+
+				if ( wlan_client->ip_id != -1 )
+					s3d_del_object( wlan_client->ip_id );
+
+				wlan_client->ip_id = s3d_draw_string( wlan_client->ip, &wlan_client->ip_len );
+				s3d_link( wlan_client->ip_id, wlan_client->obj_id );
+				s3d_translate( wlan_client->ip_id, - wlan_client->ip_len / 2, 2, 0 );
+				s3d_scale( wlan_client->ip_id, CLIENT_TEXT_SCALE );
+				s3d_flags_on( wlan_client->ip_id, S3D_OF_VISIBLE );
+
+			}
+
+			/* rotate network description so that it is always readable */
+			tmp_mov_vec[0] = CamPosition[0][0] - wlan_client->pos_vec[0];
+			tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
+			tmp_mov_vec[2] = CamPosition[0][2] - wlan_client->pos_vec[2];
+
+			angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
+
+			/* take care of inverse cosinus */
+			if ( tmp_mov_vec[0] > 0 ) {
+				angle_rad = 90.0/M_PI - angle;
+				angle = 180 - ( 180.0/M_PI * angle );
+			} else {
+				angle_rad = 90.0/M_PI + angle;
+				angle = 180 + ( 180.0/M_PI * angle );
+			}
+
+			s3d_rotate( wlan_client->ip_id, 0, angle , 0 );
+
+			s3d_translate( wlan_client->ip_id, -cos(angle_rad) * CLIENT_TEXT_SCALE * wlan_client->ip_len / 2 ,2 , sin(angle_rad) * CLIENT_TEXT_SCALE * wlan_client->ip_len / 2 );
+
+		}
+
+	}
+
+
+	pthread_mutex_unlock( &Client_list_mutex );
+
+	return(0);
+
+}
+
+
+
 /***
  *
+ * eventhandler when object clicked
+ *
+ ***/
+
+int object_click(struct s3d_evt *evt) {
+
+	struct list_head *network_pos;
+	struct wlan_network *wlan_network;
+	int clicked_id = (int)*((uint32_t *)evt->buf);
+
+
+	s3dw_handle_click( evt );
+
+
+	/* emulate double click */
+	if ( ( Last_Click_Oid == clicked_id ) && ( Last_Click_Time + 250 > get_time() ) ) {
+
+		list_for_each( network_pos, &Network_list ) {
+
+			wlan_network = list_entry(network_pos, struct wlan_network, list);
+
+			if ( wlan_network->click_id == clicked_id ) {
+
+				Cam_target = wlan_network;
+				break;
+
+			}
+
+		}
+
+	}
+
+	Last_Click_Oid = clicked_id;
+	Last_Click_Time = get_time();
+
+	return(0);
+
+}
+
+
+
+/***
+ *
  * eventhandler when object change by user
  * such as Cam
  *
@@ -267,7 +402,16 @@
 
 
 	handle_networks();
+	handle_clients();
 
+	if ( Cam_target != NULL ) {
+
+		/* move to network */
+		printf( "Moving to Network: %s, %s\n", ((struct wlan_network *)Cam_target)->bssid, ((struct wlan_network *)Cam_target)->ssid );
+		Cam_target = NULL;
+
+	}
+
 	if ( Kism3d_aborted )
 		s3d_quit();
 
@@ -288,7 +432,10 @@
 		} else {
 
 			s3d_set_callback( S3D_EVENT_OBJ_INFO, object_info );
+			s3d_set_callback( S3D_EVENT_OBJ_CLICK, object_click );
 
+			Client_obj = s3d_import_model_file( "objs/accesspoint.3ds" );
+
 			s3d_mainloop( mainloop );
 
 		}

Modified: trunk/apps/kism3d/kism3d.c
===================================================================
--- trunk/apps/kism3d/kism3d.c	2006-12-03 11:36:08 UTC (rev 507)
+++ trunk/apps/kism3d/kism3d.c	2006-12-03 23:46:51 UTC (rev 508)
@@ -30,6 +30,7 @@
 #include <errno.h>    /* errno */
 #include <unistd.h>   /* write() */
 #include <pthread.h>
+#include <sys/time.h> /* gettimeofday() */
 
 #include <sys/socket.h> /* inet_pton(), inet_aton() */
 #include <sys/types.h>
@@ -83,6 +84,18 @@
 
 
 
+unsigned int get_time( void ) {
+
+	struct timeval tv;
+
+	gettimeofday(&tv, NULL);
+
+	return tv.tv_sec * 1000 + tv.tv_usec / 1000;
+
+}
+
+
+
 void parse_buffer( struct kismet_src *kismet_src ) {
 
 	struct wlan_network *wlan_network;
@@ -228,7 +241,7 @@
 
 				pthread_mutex_unlock( &Network_list_mutex );
 
-// 				printf( "network found - bssid %s, type %s, channel %s, ssid '%s' <> '%s'\n", bssid, type, channel, ssid, wlan_network->ssid );
+				/* printf( "network found - bssid %s, type %s, channel %s, ssid '%s' <> '%s'\n", bssid, type, channel, ssid, wlan_network->ssid ); */
 
 			} else if ( strncmp( line_ptr, "*CLIENT: ", strlen( "*CLIENT: " ) ) == 0 ) {
 

Modified: trunk/apps/kism3d/kism3d.h
===================================================================
--- trunk/apps/kism3d/kism3d.h	2006-12-03 11:36:08 UTC (rev 507)
+++ trunk/apps/kism3d/kism3d.h	2006-12-03 23:46:51 UTC (rev 508)
@@ -28,6 +28,11 @@
 
 
 
+#define NETWORK_TEXT_SCALE 0.2
+#define CLIENT_TEXT_SCALE 0.2
+
+
+
 struct kismet_src {
 
 	struct list_head list;
@@ -53,10 +58,10 @@
 	int props_changed;
 	int visible;
 	float pos_vec[3];
-	float mov_vec[3];
 	int obj_id;
 	int wrsphr_id;
 	int bssid_id;
+	int click_id;
 	int ssid_id;
 	int misc_id;
 	int rotation;
@@ -73,17 +78,21 @@
 	char mac[18];
 	char ip[16];
 	struct wlan_network *wlan_network;
+	int props_changed;
 	int visible;
 	float pos_vec[3];
 	float mov_vec[3];
 	int obj_id;
-	int desc_id;
+	int symbol_id;
+	int ip_id;
+	float ip_len;
 
 };
 
 
 
 void *alloc_memory( int len );
+unsigned int get_time( void );
 struct wlan_network *get_wlan_network( char *bssid );
 struct wlan_network *find_wlan_network( char *bssid );
 struct wlan_client *get_wlan_client( char *mac );

Modified: trunk/apps/kism3d/network.c
===================================================================
--- trunk/apps/kism3d/network.c	2006-12-03 11:36:08 UTC (rev 507)
+++ trunk/apps/kism3d/network.c	2006-12-03 23:46:51 UTC (rev 508)
@@ -56,10 +56,7 @@
 
 	wlan_network->visible = 1;
 
-	wlan_network->pos_vec[0] = 0;
-	wlan_network->pos_vec[1] = 0;
-	wlan_network->pos_vec[2] = 0;
-	wlan_network->mov_vec[0] = wlan_network->mov_vec[1] = wlan_network->mov_vec[2] = 0.0;
+	wlan_network->pos_vec[0] = wlan_network->pos_vec[1] = wlan_network->pos_vec[2] = 0;
 
 	wlan_network->obj_id = -1;
 	wlan_network->bssid_id = -1;



From dotslash at mail.berlios.de  Mon Dec  4 23:20:32 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 4 Dec 2006 23:20:32 +0100
Subject: [S3d-svn] r509 - in trunk: . server
Message-ID: <200612042220.kB4MKWSw020765@sheep.berlios.de>

Author: dotslash
Date: 2006-12-04 23:20:31 +0100 (Mon, 04 Dec 2006)
New Revision: 509

Modified:
   trunk/
   trunk/server/graphics.c
   trunk/server/process.c
Log:
 r1209 at kero:  dotslash | 2006-12-04 23:19:46 +0100
 - allow S3D_OF_SELECTABLE-only objects, now you can click "invisible" surfaces :)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1203
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1209

Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2006-12-03 23:46:51 UTC (rev 508)
+++ trunk/server/graphics.c	2006-12-04 22:20:31 UTC (rev 509)
@@ -139,8 +139,7 @@
 		{
 			if (ap->object[j]!=NULL)
 			{
-				if (ap->object[j]->oflags&OF_VISIBLE)
-				if ((select_mode ==0 ) || (ap->object[j]->oflags&OF_SELECTABLE)) /* either select mode is off or it's selectable */
+				if (((select_mode==0) && ap->object[j]->oflags&OF_VISIBLE) || ((select_mode ==1 ) && (ap->object[j]->oflags&OF_SELECTABLE))) /* either select mode is off or it's selectable */
 				{
 					x.x=x.y=x.z=0.0f;
 					mySetMatrix(ap->object[j]->m); /* get into position ... */
@@ -181,7 +180,7 @@
 		o=p->object[i];
 		if (o!=NULL)
 		{
-			if (o->oflags&OF_VISIBLE)   /*  it's even visible ;) */
+			if ((select_mode==0 && o->oflags&OF_VISIBLE) || (select_mode==1 && o->oflags&OF_SELECTABLE))  /*  it's even visible ;) */
 			{
 				if (o->oflags&OF_VIRTUAL)  /*  we have an app here. */
 				{
@@ -223,18 +222,15 @@
 					render_virtual_object(p->object[o->n_vertex]); 
 					glPopMatrix();
 				} else { /* it's a "regular" mcp object */
-					if ((select_mode ==0 ) || (p->object[i]->oflags&OF_SELECTABLE)) /* either select mode is off or it's selectable */
+					if (select_mode==1)
 					{
-						if (select_mode==1)
-						{
-							s3dprintf(VLOW,"mcp object no. %d",i);
-							glLoadName(-1);
-							glPushName(i);
-						}
-						obj_render(p,i);
-						if (select_mode==1)
-							glPopName();
+						s3dprintf(VLOW,"mcp object no. %d",i);
+						glLoadName(-1);
+						glPushName(i);
 					}
+					obj_render(p,i);
+					if (select_mode==1)
+						glPopName();
 				}
 			}
 		}

Modified: trunk/server/process.c
===================================================================
--- trunk/server/process.c	2006-12-03 23:46:51 UTC (rev 508)
+++ trunk/server/process.c	2006-12-04 22:20:31 UTC (rev 509)
@@ -74,7 +74,7 @@
 	/* register the new process in the mcp */
 		if (-1!=(mcp_oid=obj_new(&procs_p[MCP])))
 		{
-			mcp_p->object[mcp_oid]->oflags|=OF_VIRTUAL|OF_VISIBLE;
+			mcp_p->object[mcp_oid]->oflags|=OF_VIRTUAL|OF_VISIBLE|OF_SELECTABLE;
 			mcp_p->object[mcp_oid]->n_mat=p->id;
 			
 	/* 		mcp_p->object[mcp_oid]->p_mat=(struct t_material *)new_p; */



From dotslash at mail.berlios.de  Mon Dec  4 23:20:34 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 4 Dec 2006 23:20:34 +0100
Subject: [S3d-svn] r510 - in trunk: . apps/kism3d libs3d
Message-ID: <200612042220.kB4MKYlA020824@sheep.berlios.de>

Author: dotslash
Date: 2006-12-04 23:20:34 +0100 (Mon, 04 Dec 2006)
New Revision: 510

Modified:
   trunk/
   trunk/apps/kism3d/gui.c
   trunk/libs3d/freetype.c
   trunk/libs3d/proto_out.c
Log:
 r1210 at kero:  dotslash | 2006-12-04 23:20:25 +0100
 - invisible clickpoints for kisms3d gui
 - small warning-fixes in libs3d



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1209
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1210

Modified: trunk/apps/kism3d/gui.c
===================================================================
--- trunk/apps/kism3d/gui.c	2006-12-04 22:20:31 UTC (rev 509)
+++ trunk/apps/kism3d/gui.c	2006-12-04 22:20:34 UTC (rev 510)
@@ -122,7 +122,8 @@
 	float tmp_mov_vec[3], desc_norm_vec[3] = { 0, 0, -1 };
 	float real_node_pos_x, real_node_pos_z, angle, angle_rad;
 	int network_index = 0;
-	char *label_str;
+	char label_str[101];	/* safe to do as long as we use strn* functions */
+	float maxlen,templen;
 
 
 	pthread_mutex_lock( &Network_list_mutex );
@@ -165,7 +166,13 @@
 			}
 
 			if ( wlan_network->props_changed ) {
+				snprintf( label_str, 100, "Type: %s, CH: %i, Clients: %i", ( wlan_network->type == 0 ? "Managed" : ( wlan_network->type == 1 ? "Ad-Hoc" : ( wlan_network->type == 2 ? "Prober" : "unknown" ) ) ), wlan_network->chan, wlan_network->num_wlan_clients );
 
+				/* determine our longest string which we draw */
+				maxlen=s3d_strlen(label_str);
+				if ((templen=s3d_strlen(wlan_network->ssid))  > maxlen ) maxlen=templen;
+				if ((templen=s3d_strlen(wlan_network->bssid)) > maxlen ) maxlen=templen;
+
 				wlan_network->props_changed = 0;
 
 				if ( wlan_network->ssid_id != -1 )
@@ -177,23 +184,26 @@
 
 				if ( wlan_network->bssid_id == -1 ) {
 
-					wlan_network->bssid_id = s3d_draw_string( wlan_network->bssid, &wlan_network->bssid_len );
+					wlan_network->bssid_id = s3d_draw_string( wlan_network->bssid, NULL );
+					/* NEW!! XXX NEW!! */
+					wlan_network->bssid_len= maxlen; /* we store maxlen here. the other strings might be longer, so we use the longest string for
+														calculating our rotation. TODO: maybe rename this field to something like textblock_width? :) */
 					s3d_link( wlan_network->bssid_id, wlan_network->obj_id );
-					s3d_translate( wlan_network->bssid_id, - wlan_network->bssid_len / 2, 2 + wlan_network->scale_fac, 0 );
+					s3d_translate( wlan_network->bssid_id, - maxlen / 2, 2 + wlan_network->scale_fac, 0 );
 					s3d_scale( wlan_network->bssid_id, NETWORK_TEXT_SCALE );
 					s3d_flags_on( wlan_network->bssid_id, S3D_OF_VISIBLE );
 
 					wlan_network->click_id = s3d_new_object();
-					s3d_link( wlan_network->click_id, wlan_network->obj_id );
-					/* s3d_translate( wlan_network->bssid_id, - wlan_network->bssid_len / 2, 2+ wlan_network->scale_fac, 0 ); */
-					s3d_push_vertex( wlan_network->click_id, 0, 0, 0.1 );
-					s3d_push_vertex( wlan_network->click_id, wlan_network->bssid_len, 0, 0.1 );
-					s3d_push_vertex( wlan_network->click_id, wlan_network->bssid_len, 1, 0.1 );
+					s3d_link( wlan_network->click_id, wlan_network->bssid_id );
+					s3d_push_material( wlan_network->click_id, 0,0,0,  0,0,0,  0,0,0);
 					s3d_push_vertex( wlan_network->click_id, 0, 1, 0.1 );
+					s3d_push_vertex( wlan_network->click_id, maxlen, 1, 0.1 );
+					s3d_push_vertex( wlan_network->click_id, maxlen, -2.5, 0.1 ); /* 3 lines of text + some mor space for low characters, like g,q,p ... */
+					s3d_push_vertex( wlan_network->click_id, 0, -2.5, 0.1 );
 					s3d_push_polygon( wlan_network->click_id, 0, 1, 2, 0 );
 					s3d_push_polygon( wlan_network->click_id, 0, 2, 3, 0 );
 
-					s3d_flags_on( wlan_network->click_id, S3D_OF_SELECTABLE | S3D_OF_VISIBLE );
+					s3d_flags_on( wlan_network->click_id, S3D_OF_SELECTABLE );
 
 				}
 
@@ -202,8 +212,6 @@
 				s3d_translate( wlan_network->ssid_id, 0, -1, 0 );
 				s3d_flags_on( wlan_network->ssid_id, S3D_OF_VISIBLE );
 
-				label_str = alloc_memory( 100 );
-				snprintf( label_str, 100, "Type: %s, CH: %i, Clients: %i", ( wlan_network->type == 0 ? "Managed" : ( wlan_network->type == 1 ? "Ad-Hoc" : ( wlan_network->type == 2 ? "Prober" : "unknown" ) ) ), wlan_network->chan, wlan_network->num_wlan_clients );
 
 				wlan_network->misc_id = s3d_draw_string( label_str, NULL );
 				s3d_link( wlan_network->misc_id, wlan_network->ssid_id );
@@ -336,7 +344,7 @@
 
 	s3dw_handle_click( evt );
 
-
+	printf("id which was clicked: %d\n",clicked_id);
 	/* emulate double click */
 	if ( ( Last_Click_Oid == clicked_id ) && ( Last_Click_Time + 250 > get_time() ) ) {
 

Modified: trunk/libs3d/freetype.c
===================================================================
--- trunk/libs3d/freetype.c	2006-12-04 22:20:31 UTC (rev 509)
+++ trunk/libs3d/freetype.c	2006-12-04 22:20:34 UTC (rev 510)
@@ -36,11 +36,11 @@
 #define FT_ERROR_START_LIST     {                           
 #define FT_ERROR_END_LIST       { 0, 0 } };                
                                                           
-const struct                                             
+const struct 
 {                                                       
     int          err_code;                             
-    const char*  err_msg                                        
-} ft_errors[] =                                                
+    const char*  err_msg;
+} ft_errors[] = 
                                                               
 #include FT_ERRORS_H                                         
 

Modified: trunk/libs3d/proto_out.c
===================================================================
--- trunk/libs3d/proto_out.c	2006-12-04 22:20:31 UTC (rev 509)
+++ trunk/libs3d/proto_out.c	2006-12-04 22:20:34 UTC (rev 510)
@@ -309,7 +309,7 @@
 }
 int s3d_push_textures(int object, uint16_t *tbuf, uint16_t n)
 {
-	uint16_t		buf[(MF_LEN+4)/2];
+	uint32_t		buf[(MF_LEN+4)/4];
 	uint16_t		*s,*d;
 
 	int					f,i,j,len=n*2*2;
@@ -320,7 +320,7 @@
 	f=len/(MF_LEN-4)+1;  /*  how many fragments? */
 
 	*((uint32_t *)buf)=htonl(object);
-	d=buf+2;
+	d=(uint16_t *)(buf+1);
 
 	for (i=0;i<f;i++)
 	{



From dotslash at mail.berlios.de  Mon Dec  4 23:28:26 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 4 Dec 2006 23:28:26 +0100
Subject: [S3d-svn] r511 - trunk/apps/s3dosm
Message-ID: <200612042228.kB4MSQY9021620@sheep.berlios.de>

Author: dotslash
Date: 2006-12-04 23:28:26 +0100 (Mon, 04 Dec 2006)
New Revision: 511

Modified:
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/gps.c
Log:
- change to some more reasonable colors
- old libgps from gpsd measures speed in knots, unlike the new one which uses meter/sec -> FIX

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-04 22:20:34 UTC (rev 510)
+++ trunk/apps/s3dosm/draw.c	2006-12-04 22:28:26 UTC (rev 511)
@@ -158,8 +158,8 @@
 		case 2:s3d_push_material(way_obj,0.5,0.5,0.8,	0.5,0.5,0.8,	0.5,0.5,0.8);	/* motorway_link*/
 		case 3:s3d_push_material(way_obj,1.0,0.6,0.2,	1.0,0.6,0.2, 	1.0,0.6,0.2);	/* primary */
 		case 4:s3d_push_material(way_obj,1.0,1.0,0.0,	1.0,1.0,0.0, 	1.0,1.0,0.0);	/* secondary */
-		case 5:s3d_push_material(way_obj,1.0,0.4,0.4,	1.0,0.4,0.4, 	1.0,0.4,0.4);	/* residential */
-		default:s3d_push_material(way_obj,1,1,1,		1,1,1,			1,1,1); /* default */
+		case 5:s3d_push_material(way_obj,1.0,1.0,1.0,	1.0,1.0,1.0, 	1.0,1.0,1.0);	/* residential */
+		default:s3d_push_material(way_obj,1,0.5,1,		1,0.5,1,		1,0.5,1); /* default */
 	}
 
 	for (i=0;i<waylist_n;i++)

Modified: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2006-12-04 22:20:34 UTC (rev 510)
+++ trunk/apps/s3dosm/gps.c	2006-12-04 22:28:26 UTC (rev 511)
@@ -116,31 +116,32 @@
 	la=dgps->latitude;
 	lo=dgps->longitude;
 	heading=dgps->track;
-	speed=dgps->speed;
+	speed=dgps->speed*KNOTS_TO_MPH/METERS_TO_MILES/3600; /* speed in knots -> miles per hour -> meter per hour -> meter per secon */
 #endif
 	tlat=la;tlon=lo;
-	nav_center(la,lo);
-	if (!finitef(heading)) {
-		heading=get_heading(lat_old,lon_old,la,lo);
-		if (!lastfix && fix) 		{s3d_flags_on(user_icon,S3D_OF_VISIBLE);s3d_scale(user_icon,1.0);}
-		if (lastfix && !fix)		{s3d_scale(user_icon,0.3);lat=tlat;lon=tlon;}
-		if (finitef(heading))		s3d_rotate(user_icon,0,heading,0);
-	}
-	if (finitef(speed)) {
-		/* print some information */
-		snprintf(buf,BUFSIZE,"speed: %3.2f km/h",speed*3.6);
-		speed_old=speed;
-	} else
-		snprintf(buf,BUFSIZE,"speed: NA (old: %3.2f km/h)",speed_old*3.6);
-
-	if (gps_info!=-1)	s3d_del_object(gps_info);
-	gps_info=s3d_draw_string(buf,&slen);
-	s3d_translate(gps_info,-slen/2,1,0);
-	s3d_link(gps_info, user_icon);
-	s3d_flags_on(gps_info,S3D_OF_VISIBLE);
-
+/*	if (fix) {*/
+		nav_center(la,lo);
+		if (!finitef(heading)) {
+			heading=get_heading(lat_old,lon_old,la,lo);
+			if (!lastfix && fix) 		{s3d_scale(user_icon,1.0);}
+			if (lastfix && !fix)		{s3d_scale(user_icon,0.3);lat=tlat;lon=tlon;}
+			if (finitef(heading))		s3d_rotate(user_icon,0,heading,0);
+		}
+		if (finitef(speed)) {
+			/* print some information */
+			snprintf(buf,BUFSIZE,"speed: %3.2f km/h",speed*3.6);
+			speed_old=speed;
+		} else
+			snprintf(buf,BUFSIZE,"speed: NA (old: %3.2f km/h)",speed_old*3.6);
 	
+		if (gps_info!=-1)	s3d_del_object(gps_info);
+		gps_info=s3d_draw_string(buf,&slen);
+		s3d_translate(gps_info,-slen/2,1,0);
+		s3d_link(gps_info, user_icon);
+		s3d_flags_on(gps_info,S3D_OF_VISIBLE);
+/*	}*/
 	
+	
 	lat_old=la;
 	lon_old=lo;
 	lastfix=fix;
@@ -167,6 +168,7 @@
 	user_icon_rotator=s3d_new_object();
 	s3d_link(user_icon,user_icon_rotator);
 	s3d_link(user_icon_rotator,oidy); 
+	s3d_flags_on(user_icon,S3D_OF_VISIBLE);
 	tlat=lat=lat_old=0.0;
 	tlon=lon=lon_old=0.0;
 	gps_active=1;



From marec at mail.berlios.de  Mon Dec  4 23:31:00 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Mon, 4 Dec 2006 23:31:00 +0100
Subject: [S3d-svn] r512 - in trunk: apps/kism3d libs3d
Message-ID: <200612042231.kB4MV00D022183@sheep.berlios.de>

Author: marec
Date: 2006-12-04 23:30:59 +0100 (Mon, 04 Dec 2006)
New Revision: 512

Modified:
   trunk/apps/kism3d/gui.c
   trunk/apps/kism3d/kism3d.c
   trunk/libs3d/s3d.h
   trunk/libs3d/vector.c
Log:
libs3d: s3d_angle_to_cam added
gui thread start better timed

Modified: trunk/apps/kism3d/gui.c
===================================================================
--- trunk/apps/kism3d/gui.c	2006-12-04 22:28:26 UTC (rev 511)
+++ trunk/apps/kism3d/gui.c	2006-12-04 22:30:59 UTC (rev 512)
@@ -119,7 +119,6 @@
 
 	struct list_head *network_pos;
 	struct wlan_network *wlan_network;
-	float tmp_mov_vec[3], desc_norm_vec[3] = { 0, 0, -1 };
 	float real_node_pos_x, real_node_pos_z, angle, angle_rad;
 	int network_index = 0;
 	char label_str[101];	/* safe to do as long as we use strn* functions */
@@ -220,22 +219,7 @@
 
 			}
 
-			/* rotate network description so that it is always readable */
-			tmp_mov_vec[0] = CamPosition[0][0] - wlan_network->pos_vec[0];
-			tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
-			tmp_mov_vec[2] = CamPosition[0][2] - wlan_network->pos_vec[2];
-
-			angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
-
-			/* take care of inverse cosinus */
-			if ( tmp_mov_vec[0] > 0 ) {
-				angle_rad = 90.0/M_PI - angle;
-				angle = 180 - ( 180.0/M_PI * angle );
-			} else {
-				angle_rad = 90.0/M_PI + angle;
-				angle = 180 + ( 180.0/M_PI * angle );
-			}
-
+			angle = s3d_angle_to_cam( wlan_network->pos_vec, CamPosition[0], &angle_rad );
 			s3d_rotate( wlan_network->bssid_id, 0, angle , 0 );
 
 			s3d_translate( wlan_network->bssid_id, -cos(angle_rad) * NETWORK_TEXT_SCALE * wlan_network->bssid_len / 2 ,2 , sin(angle_rad) * NETWORK_TEXT_SCALE * wlan_network->bssid_len / 2 );
@@ -260,7 +244,6 @@
 
 	struct list_head *client_pos;
 	struct wlan_client *wlan_client;
-	float tmp_mov_vec[3], desc_norm_vec[3] = { 0, 0, -1 };
 	float angle, angle_rad;
 
 
@@ -296,22 +279,7 @@
 
 			}
 
-			/* rotate network description so that it is always readable */
-			tmp_mov_vec[0] = CamPosition[0][0] - wlan_client->pos_vec[0];
-			tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
-			tmp_mov_vec[2] = CamPosition[0][2] - wlan_client->pos_vec[2];
-
-			angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
-
-			/* take care of inverse cosinus */
-			if ( tmp_mov_vec[0] > 0 ) {
-				angle_rad = 90.0/M_PI - angle;
-				angle = 180 - ( 180.0/M_PI * angle );
-			} else {
-				angle_rad = 90.0/M_PI + angle;
-				angle = 180 + ( 180.0/M_PI * angle );
-			}
-
+			angle = s3d_angle_to_cam( wlan_client->pos_vec, CamPosition[0], &angle_rad );
 			s3d_rotate( wlan_client->ip_id, 0, angle , 0 );
 
 			s3d_translate( wlan_client->ip_id, -cos(angle_rad) * CLIENT_TEXT_SCALE * wlan_client->ip_len / 2 ,2 , sin(angle_rad) * CLIENT_TEXT_SCALE * wlan_client->ip_len / 2 );

Modified: trunk/apps/kism3d/kism3d.c
===================================================================
--- trunk/apps/kism3d/kism3d.c	2006-12-04 22:28:26 UTC (rev 511)
+++ trunk/apps/kism3d/kism3d.c	2006-12-04 22:30:59 UTC (rev 512)
@@ -42,6 +42,7 @@
 DEFINE_LIST_HEAD(Network_list);
 DEFINE_LIST_HEAD(Client_list);
 
+pthread_t s3d_thread_id = NULL;
 pthread_mutex_t Network_list_mutex = PTHREAD_MUTEX_INITIALIZER;
 pthread_mutex_t Client_list_mutex = PTHREAD_MUTEX_INITIALIZER;
 
@@ -123,7 +124,7 @@
 
 			if ( strncmp( line_ptr, "*TIME: ", strlen( "*TIME: " ) ) == 0 ) {
 
-				if ( kismet_src->enable_level < 3 ) {
+				if ( kismet_src->enable_level < 4 ) {
 
 					switch ( kismet_src->enable_level ) {
 
@@ -155,6 +156,12 @@
 
 							break;
 
+						case 3:
+
+							if ( s3d_thread_id == NULL )
+								pthread_create( &s3d_thread_id, NULL, &gui_main, NULL );
+							break;
+
 					}
 
 					kismet_src->enable_level++;
@@ -348,7 +355,7 @@
 	/* struct wlan_network *wlan_network;
 	struct wlan_client *wlan_client; */
 	struct timeval tv;
-	pthread_t s3d_thread_id;
+// 	pthread_t s3d_thread_id;
 	int num_kismet_sources = 0, found_args = 1, max_sock = -1, res, status;
 	char *colon_ptr, buff[1000];
 	fd_set wait_sockets, tmp_wait_sockets;
@@ -457,9 +464,6 @@
 	}
 
 
-	pthread_create( &s3d_thread_id, NULL, &gui_main, NULL );
-
-
 	while ( ( num_kismet_sources > 0 ) && !( Kism3d_aborted ) ) {
 
 		tv.tv_sec = 0;

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2006-12-04 22:28:26 UTC (rev 511)
+++ trunk/libs3d/s3d.h	2006-12-04 22:30:59 UTC (rev 512)
@@ -5,17 +5,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -51,15 +51,15 @@
 #define	S3D_OF_VISIBLE			0x00000001
 #define	S3D_OF_SELECTABLE		0x00000002
 #define S3D_OF_POINTABLE		0x00000004
-struct mcp_object 
+struct mcp_object
 {
 	uint32_t object;
 	float trans_x,trans_y,trans_z;
 	float r;
 #define MCP_NEW_OBJECT	1
-	char name[256]; 
+	char name[256];
 };
-struct s3d_obj_info 
+struct s3d_obj_info
 {
 	uint32_t object;
 	uint32_t flags;
@@ -67,7 +67,7 @@
 	float rot_x,rot_y,rot_z;
 	float scale;
 	float r;
-	char name[256]; 
+	char name[256];
 };
 struct s3d_but_info
 {
@@ -90,20 +90,20 @@
 /* object manipulations */
 int s3d_push_vertex(int object, float x, float y, float z);
 int s3d_push_vertices(int object, float *vbuf, uint16_t n);
-int s3d_push_material( int object, 
+int s3d_push_material( int object,
 						float amb_r, float amb_g, float amb_b,
 						float spec_r, float spec_g, float spec_b,
 						float diff_r, float diff_g, float diff_b);
-int s3d_pep_material( int object, 
+int s3d_pep_material( int object,
 						float amb_r, float amb_g, float amb_b,
 						float spec_r, float spec_g, float spec_b,
 						float diff_r, float diff_g, float diff_b);
-int s3d_push_material_a( int object, 
+int s3d_push_material_a( int object,
 						float amb_r, float amb_g, float amb_b, float amb_a,
 						float spec_r, float spec_g, float spec_b, float spec_a,
 						float diff_r, float diff_g, float diff_b, float diff_a);
 int s3d_push_materials_a(int object, float *mbuf, uint16_t n);
-int s3d_pep_material_a( int object, 
+int s3d_pep_material_a( int object,
 						float amb_r, float amb_g, float amb_b, float amb_a,
 						float spec_r, float spec_g, float spec_b, float spec_a,
 						float diff_r, float diff_g, float diff_b, float diff_a);
@@ -164,6 +164,7 @@
 float s3d_vector_dot_product( float vector1[], float vector2[] );
 void s3d_vector_substract( float vector1[], float vector2[], float result_vector[] );
 float s3d_vector_angle( float vector1[], float vector2[] );
+float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad );
 
 /* event handlers */
 void s3d_push_event(struct s3d_evt *newevt);

Modified: trunk/libs3d/vector.c
===================================================================
--- trunk/libs3d/vector.c	2006-12-04 22:28:26 UTC (rev 511)
+++ trunk/libs3d/vector.c	2006-12-04 22:30:59 UTC (rev 512)
@@ -7,17 +7,17 @@
  *
  * This file is part of the s3d API, the API of s3d (the 3d network display server).
  * See http://s3d.berlios.de/ for more updates.
- * 
+ *
  * The s3d API is free software; you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation; either version 2.1 of the License, or
  * (at your option) any later version.
- * 
+ *
  * The s3d API is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU Lesser General Public License
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
@@ -36,6 +36,7 @@
  ***/
 
 float s3d_vector_length( float vector[] ) {
+
 	return ( sqrt( vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2] ) );
 
 }
@@ -56,6 +57,7 @@
 	result_vector[0] = vector2[0] - vector1[0];
 	result_vector[1] = vector2[1] - vector1[1];
 	result_vector[2] = vector2[2] - vector1[2];
+
 }
 
 /***
@@ -87,6 +89,43 @@
  ***/
 
 float s3d_vector_angle( float vector1[], float vector2[] ) {
+
 	return ( acos( s3d_vector_dot_product( vector1, vector2 ) / ( s3d_vector_length( vector1 ) * s3d_vector_length( vector2 ) ) ) );
 
 }
+
+/***
+ *
+ * rotate e.g. description text so that it is always readable
+ *
+ *   obj_id    =>   id of object
+ *   obj_pos   =>   position vector (x,y,z) of object
+ *   cam_pos   =>   position vector (x,y,z) of camera
+ *
+ *   return degree to rotate
+ *
+ ***/
+
+float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad ) {
+
+	float angle, tmp_mov_vec[3], desc_norm_vec[3] = { 0, 0, -1 };
+
+
+	tmp_mov_vec[0] = cam_pos[0] - obj_pos[0];
+	tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
+	tmp_mov_vec[2] = cam_pos[2] - obj_pos[2];
+
+	angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
+
+	/* take care of inverse cosinus */
+	if ( tmp_mov_vec[0] > 0 ) {
+		*angle_rad = 90.0/M_PI - angle;
+		angle = 180 - ( 180.0/M_PI * angle );
+	} else {
+		*angle_rad = 90.0/M_PI + angle;
+		angle = 180 + ( 180.0/M_PI * angle );
+	}
+
+	return angle;
+
+}



From marec at mail.berlios.de  Mon Dec  4 23:57:30 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Mon, 4 Dec 2006 23:57:30 +0100
Subject: [S3d-svn] r513 - in trunk: apps/kism3d libs3d
Message-ID: <200612042257.kB4MvUhV025059@sheep.berlios.de>

Author: marec
Date: 2006-12-04 23:57:30 +0100 (Mon, 04 Dec 2006)
New Revision: 513

Modified:
   trunk/apps/kism3d/gui.c
   trunk/apps/kism3d/kism3d.c
   trunk/apps/kism3d/kism3d.h
   trunk/libs3d/vector.c
Log:
move to network

Modified: trunk/apps/kism3d/gui.c
===================================================================
--- trunk/apps/kism3d/gui.c	2006-12-04 22:30:59 UTC (rev 512)
+++ trunk/apps/kism3d/gui.c	2006-12-04 22:57:30 UTC (rev 513)
@@ -43,8 +43,10 @@
 
 int Client_obj;
 
+struct timespec sleeptime = { 0, 100 * 1000 * 1000 };   /* 100 mili seconds */
 
 
+
 int wire_sphere(int slices, int stacks)
 {
 	int x,y,i,o;
@@ -168,10 +170,14 @@
 				snprintf( label_str, 100, "Type: %s, CH: %i, Clients: %i", ( wlan_network->type == 0 ? "Managed" : ( wlan_network->type == 1 ? "Ad-Hoc" : ( wlan_network->type == 2 ? "Prober" : "unknown" ) ) ), wlan_network->chan, wlan_network->num_wlan_clients );
 
 				/* determine our longest string which we draw */
-				maxlen=s3d_strlen(label_str);
-				if ((templen=s3d_strlen(wlan_network->ssid))  > maxlen ) maxlen=templen;
-				if ((templen=s3d_strlen(wlan_network->bssid)) > maxlen ) maxlen=templen;
+				maxlen = s3d_strlen( label_str );
 
+				if ( ( templen = s3d_strlen( wlan_network->ssid ) ) > maxlen )
+					maxlen = templen;
+
+				if ( ( templen = s3d_strlen( wlan_network->bssid ) ) > maxlen )
+					maxlen = templen;
+
 				wlan_network->props_changed = 0;
 
 				if ( wlan_network->ssid_id != -1 )
@@ -184,9 +190,7 @@
 				if ( wlan_network->bssid_id == -1 ) {
 
 					wlan_network->bssid_id = s3d_draw_string( wlan_network->bssid, NULL );
-					/* NEW!! XXX NEW!! */
-					wlan_network->bssid_len= maxlen; /* we store maxlen here. the other strings might be longer, so we use the longest string for
-														calculating our rotation. TODO: maybe rename this field to something like textblock_width? :) */
+					wlan_network->text_width = maxlen; /* the other strings might be longer, so we use the longest string for calculating our rotation. */
 					s3d_link( wlan_network->bssid_id, wlan_network->obj_id );
 					s3d_translate( wlan_network->bssid_id, - maxlen / 2, 2 + wlan_network->scale_fac, 0 );
 					s3d_scale( wlan_network->bssid_id, NETWORK_TEXT_SCALE );
@@ -222,7 +226,7 @@
 			angle = s3d_angle_to_cam( wlan_network->pos_vec, CamPosition[0], &angle_rad );
 			s3d_rotate( wlan_network->bssid_id, 0, angle , 0 );
 
-			s3d_translate( wlan_network->bssid_id, -cos(angle_rad) * NETWORK_TEXT_SCALE * wlan_network->bssid_len / 2 ,2 , sin(angle_rad) * NETWORK_TEXT_SCALE * wlan_network->bssid_len / 2 );
+			s3d_translate( wlan_network->bssid_id, -cos(angle_rad) * NETWORK_TEXT_SCALE * wlan_network->text_width / 2 ,2 , sin(angle_rad) * NETWORK_TEXT_SCALE * wlan_network->text_width / 2 );
 
 			wlan_network->rotation = ( wlan_network->rotation + 1 ) % 360;
 			s3d_rotate( wlan_network->wrsphr_id, 0, wlan_network->rotation, 0 );
@@ -312,7 +316,6 @@
 
 	s3dw_handle_click( evt );
 
-	printf("id which was clicked: %d\n",clicked_id);
 	/* emulate double click */
 	if ( ( Last_Click_Oid == clicked_id ) && ( Last_Click_Time + 250 > get_time() ) ) {
 
@@ -374,7 +377,7 @@
 
 void mainloop() {
 
-	struct timespec sleeptime = { 0, 100 * 1000 * 1000 };   /* 100 mili seconds */
+	float angle, diff_vec[3], tmp_vec[3] = { 0.0, 0.0, -1.0 };
 
 
 	handle_networks();
@@ -384,8 +387,26 @@
 
 		/* move to network */
 		printf( "Moving to Network: %s, %s\n", ((struct wlan_network *)Cam_target)->bssid, ((struct wlan_network *)Cam_target)->ssid );
-		Cam_target = NULL;
 
+		CamPosition[0][0] = ( CamPosition[0][0] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[0] + 7 ) / 5;
+		CamPosition[0][1] = ( CamPosition[0][1] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[1] ) / 5;
+		CamPosition[0][2] = ( CamPosition[0][2] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[2] + 7 ) / 5;
+
+		diff_vec[0] = CamPosition[0][0] - ((struct wlan_network *)Cam_target)->pos_vec[0] + 7;
+		diff_vec[1] = 0.0;
+		diff_vec[2] = CamPosition[0][2] - ((struct wlan_network *)Cam_target)->pos_vec[2] + 7;
+
+		angle = s3d_vector_angle( diff_vec, tmp_vec );
+		/* angle = ( real_node_pos[0] > 0) ? ( 180 - ( 180 / M_PI * angle ) ) : ( 180 + ( 180 / M_PI * angle ) ); */
+		angle = 180 - ( 180 / M_PI * angle );
+		CamPosition[1][1] = ( CamPosition[1][1] * 4 + angle ) / 5;
+
+		s3d_translate( 0, CamPosition[1][0], CamPosition[1][1], CamPosition[1][2] );
+		s3d_rotate( 0, CamPosition[1][0], CamPosition[1][1], CamPosition[1][2] );
+
+		/* TODO: need an abort if target is reached
+			Cam_target = NULL; */
+
 	}
 
 	if ( Kism3d_aborted )

Modified: trunk/apps/kism3d/kism3d.c
===================================================================
--- trunk/apps/kism3d/kism3d.c	2006-12-04 22:30:59 UTC (rev 512)
+++ trunk/apps/kism3d/kism3d.c	2006-12-04 22:57:30 UTC (rev 513)
@@ -42,10 +42,11 @@
 DEFINE_LIST_HEAD(Network_list);
 DEFINE_LIST_HEAD(Client_list);
 
-pthread_t s3d_thread_id = NULL;
+pthread_t s3d_thread_id;
 pthread_mutex_t Network_list_mutex = PTHREAD_MUTEX_INITIALIZER;
 pthread_mutex_t Client_list_mutex = PTHREAD_MUTEX_INITIALIZER;
 
+int thread_running = 0;
 int Kism3d_aborted = 0;
 int Num_networks = 0;
 
@@ -158,8 +159,13 @@
 
 						case 3:
 
-							if ( s3d_thread_id == NULL )
+							if ( !thread_running ) {
+
+								thread_running++;
 								pthread_create( &s3d_thread_id, NULL, &gui_main, NULL );
+
+							}
+
 							break;
 
 					}
@@ -355,7 +361,6 @@
 	/* struct wlan_network *wlan_network;
 	struct wlan_client *wlan_client; */
 	struct timeval tv;
-// 	pthread_t s3d_thread_id;
 	int num_kismet_sources = 0, found_args = 1, max_sock = -1, res, status;
 	char *colon_ptr, buff[1000];
 	fd_set wait_sockets, tmp_wait_sockets;

Modified: trunk/apps/kism3d/kism3d.h
===================================================================
--- trunk/apps/kism3d/kism3d.h	2006-12-04 22:30:59 UTC (rev 512)
+++ trunk/apps/kism3d/kism3d.h	2006-12-04 22:57:30 UTC (rev 513)
@@ -66,7 +66,7 @@
 	int misc_id;
 	int rotation;
 	int scale_fac;
-	float bssid_len;
+	float text_width;
 
 };
 

Modified: trunk/libs3d/vector.c
===================================================================
--- trunk/libs3d/vector.c	2006-12-04 22:30:59 UTC (rev 512)
+++ trunk/libs3d/vector.c	2006-12-04 22:57:30 UTC (rev 513)
@@ -108,7 +108,7 @@
 
 float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad ) {
 
-	float angle, tmp_mov_vec[3], desc_norm_vec[3] = { 0, 0, -1 };
+	float angle, tmp_mov_vec[3], desc_norm_vec[3] = { 0.0, 0.0, -1.0 };
 
 
 	tmp_mov_vec[0] = cam_pos[0] - obj_pos[0];



From dotslash at mail.berlios.de  Tue Dec  5 21:04:33 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 5 Dec 2006 21:04:33 +0100
Subject: [S3d-svn] r514 - trunk/apps/s3dosm
Message-ID: <200612052004.kB5K4Xd4027329@sheep.berlios.de>

Author: dotslash
Date: 2006-12-05 21:04:33 +0100 (Tue, 05 Dec 2006)
New Revision: 514

Modified:
   trunk/apps/s3dosm/draw.c
Log:
- conceptual code for proper streets

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-04 22:57:30 UTC (rev 513)
+++ trunk/apps/s3dosm/draw.c	2006-12-05 20:04:33 UTC (rev 514)
@@ -97,15 +97,26 @@
 	int seg_id;
 	int node_from_l,node_from_r;	/* vertex id's for corners */
 	int node_to_l,node_to_r;
-	
 };
 struct nodelist {
-	float la,lo,alt;		
+	int node_id;			/* (external counting) */
+	float la,lo,alt;		/* earth coords */
+	float x[3];				/* euclid coords */
 };
+struct adjlist {
+	int node_id;			/* node to which the segment leads to */
+	int seg_id;				/* segment which is involved to the node (both internal counting) */
+};
+/*
 struct nodelist nodelist_p[2];
 int				nodelist_n=0;
+*/
 
 struct waylist 	*waylist_p=NULL;
+struct nodelist	*nodelist_p=NULL;
+struct adjlist	*adjlist_p=NULL;
+int				nodelist_n=0;
+int				adjlist_n=0;
 int 			waylist_n=0;
 int 			waylist_bufn=0;
 
@@ -144,6 +155,7 @@
 	char query[MAXQ];
 	float x[6];
 	int i,vert=0;
+	int node_id;
 	int way_obj;
 	int waytype=0;
 /*	printf("way: %d - %d segments\n",lastid,waylist_n);*/
@@ -161,7 +173,66 @@
 		case 5:s3d_push_material(way_obj,1.0,1.0,1.0,	1.0,1.0,1.0, 	1.0,1.0,1.0);	/* residential */
 		default:s3d_push_material(way_obj,1,0.5,1,		1,0.5,1,		1,0.5,1); /* default */
 	}
+	/* put nodes of the graph into a list */
+	for (i=0;i<waylist_n*2;i++) {
+		if (waylist_n%2)		node_id=waylist_p[i/2].node_from;
+		else					node_id=waylist_p[i/2].node_to;
+		for (j=0;j<nodelist_n;j++)
+			if (nodelist_p[j]==node_id) break;
+		if (j==nodelist_n) { /* we still need to add this node */
+			nodelist_p[j].node_id=node_id;
+			nodelist_n++;
+			snprintf(query,MAXQ,"SELECT longitude, latitude, altitude FROM node WHERE node_id=%d;",node_id);
+			db_exec(query, insert_node,(void *)(nodelist_p+j));
+			calc_earth_to_eukl(nodelist_p[j].la,nodelist_p[j].lo,nodelist_p[j].x);
+		}
+	}
+	/* iterate for all nodes */
+	for (i=0;i<nodelist_n;i++)
+	{
+		/* find adjacent segments */
+			/* TODO */
+		if (adjlist_n>1)	/* more than one adjacent, need to order and calculate intersections */
+		{
+			/* TODO: order adjlist */
+			for (j=0;j<=adjlist_n;j++)
+			{
+				int adj_segid;
+				/* TODO: calc segpoints for j and j+1%adjlist_n */
+				s3d_push_vertices(oid,segpoint,1);
+				adj_seg=adjlist[j].seg_id;
+				if (nodelist_p[i].node_id==waylist[adj_seg].node_from)		waylist[adj_seg].node_from_r=vert;
+					else													waylist[adj_seg].node_to_l=vert;
+				vert++;
+				adj_seg=adjlist[(j+1)%adjlist_n].seg_id;
+				if (nodelist_p[i].node_id==waylist[adj_seg].node_from)		waylist[adj_seg].node_from_l=vert;
+					else													waylist[adj_seg].node_to_r=vert;
+				vert++;
+				}
+			}
+			if (adjlist_n>3) {
+				/* TODO: fill the intersection polygon */
+			}
+		} else {
+			/* endpoint */
+			/* TODO calculate segpoint and set to/from pointers appropriate */
+			adj_seg=adjlist[j].seg_id;
+			if (nodelist_p[i].node_id==waylist[adj_seg].node_from)	{
+				waylist[adj_seg].node_from_l=a;
+				waylist[adj_seg].node_from_r=b;
+			} else {
+				waylist[adj_seg].node_to_l=b;
+				waylist[adj_seg].node_to_r=a;
 
+			}
+		}
+	}
+	s3d_link(way_obj,oidy);
+	s3d_flags_on(way_obj,S3D_OF_VISIBLE);
+	waylist_n=0;
+
+
+/*			
 	for (i=0;i<waylist_n;i++)
 	{
 		float len;
@@ -182,17 +253,16 @@
 			printf("%f %f %f\n",nodelist_p[1].la, nodelist_p[1].lo, nodelist_p[1].alt);
 		}
 
-		s3d_link(way_obj,oidy);
 	}
-	s3d_flags_on(way_obj,S3D_OF_VISIBLE);
-	waylist_n=0;
-		
+*/		
 }
 void waylist_add(struct waylist *p)
 {
 	if (waylist_n>=waylist_bufn) {
 		waylist_bufn+=64;
 		waylist_p=realloc(waylist_p,sizeof(struct waylist)*waylist_bufn);
+		nodelist_p=realloc(nodelist_p,sizeof(struct nodelist)*waylist_bufn*2); /* we can have twice as many nodes as there are segments in a graph. */
+		adjlist_p=realloc(adjlist_p,sizeof(struct nodelist)*waylist_bufn*2);
 	}
 	waylist_p[waylist_n].node_to= p->node_to;
 	waylist_p[waylist_n].node_from= p->node_from;



From dotslash at mail.berlios.de  Tue Dec  5 21:09:45 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 5 Dec 2006 21:09:45 +0100
Subject: [S3d-svn] r515 - trunk/apps/s3dosm
Message-ID: <200612052009.kB5K9jap028705@sheep.berlios.de>

Author: dotslash
Date: 2006-12-05 21:09:45 +0100 (Tue, 05 Dec 2006)
New Revision: 515

Added:
   trunk/apps/s3dosm/test.osm
Log:
- forgot to add test.osm for some little testway

Added: trunk/apps/s3dosm/test.osm
===================================================================
--- trunk/apps/s3dosm/test.osm	2006-12-05 20:04:33 UTC (rev 514)
+++ trunk/apps/s3dosm/test.osm	2006-12-05 20:09:45 UTC (rev 515)
@@ -0,0 +1,40 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osm version='0.3' generator='JOSM'>
+  <node id='-1' lat='50.891018988764046' lon='12.966675794542537' />
+  <node id='-2' lat='50.88395382985554' lon='12.977273532905297' />
+  <node id='-3' lat='50.87100103852328' lon='12.983161165329053' />
+  <node id='-4' lat='50.87963623274479' lon='12.992973886035314' />
+  <node id='-5' lat='50.86040330016052' lon='12.998076500802568' />
+  <node id='-6' lat='50.86197333547352' lon='12.976881024077047' />
+  <node id='-7' lat='50.874533617977534' lon='12.96903084751204' />
+  <node id='-8' lat='50.898476656500804' lon='12.95058293258427' />
+  <node id='-9' lat='50.90397178009631' lon='12.966283285714287' />
+  <node id='-10' lat='50.88177030873789' lon='12.956949450195836' />
+  <node id='-11' lat='50.902652633007904' lon='12.988770134797761' />
+  <segment id='-12' from='-8' to='-1' />
+  <segment id='-13' from='-1' to='-2' />
+  <segment id='-14' from='-2' to='-3' />
+  <segment id='-15' from='-3' to='-5' />
+  <segment id='-16' from='-3' to='-4' />
+  <segment id='-17' from='-3' to='-6' />
+  <segment id='-18' from='-9' to='-1' />
+  <segment id='-19' from='-2' to='-7' />
+  <segment id='-20' from='-7' to='-3' />
+  <segment id='-21' from='-10' to='-1' />
+  <segment id='-22' from='-1' to='-11' />
+  <way id='-23'>
+    <seg id='-12' />
+    <seg id='-13' />
+    <seg id='-14' />
+    <seg id='-16' />
+    <seg id='-19' />
+    <seg id='-20' />
+    <seg id='-15' />
+    <seg id='-17' />
+    <seg id='-18' />
+  </way>
+  <way id='-24'>
+    <seg id='-21' />
+    <seg id='-22' />
+  </way>
+</osm>



From dotslash at mail.berlios.de  Tue Dec  5 22:35:19 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 5 Dec 2006 22:35:19 +0100
Subject: [S3d-svn] r516 - in trunk: . libs3d
Message-ID: <200612052135.kB5LZJMk014014@sheep.berlios.de>

Author: dotslash
Date: 2006-12-05 22:35:18 +0100 (Tue, 05 Dec 2006)
New Revision: 516

Modified:
   trunk/
   trunk/libs3d/s3d.h
   trunk/libs3d/vector.c
Log:
 r1222 at kero:  dotslash | 2006-12-05 22:01:11 +0100
 - add crossproduct to s3d lib



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1210
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1222

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2006-12-05 20:09:45 UTC (rev 515)
+++ trunk/libs3d/s3d.h	2006-12-05 21:35:18 UTC (rev 516)
@@ -165,6 +165,7 @@
 void s3d_vector_substract( float vector1[], float vector2[], float result_vector[] );
 float s3d_vector_angle( float vector1[], float vector2[] );
 float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad );
+void s3d_vector_cross_product( float vector1[], float vector2[], float result_vector[] );
 
 /* event handlers */
 void s3d_push_event(struct s3d_evt *newevt);

Modified: trunk/libs3d/vector.c
===================================================================
--- trunk/libs3d/vector.c	2006-12-05 20:09:45 UTC (rev 515)
+++ trunk/libs3d/vector.c	2006-12-05 21:35:18 UTC (rev 516)
@@ -77,6 +77,22 @@
 
 /***
  *
+ * calculate cross product of 2 vectors => http://en.wikipedia.org/wiki/Cross_product
+ *
+ *   vector1         =>   given vector1
+ *   vector2         =>   given vector2
+ *	 result_vector   =>   save resulting vector here
+ *   return dot product
+ *
+ ***/
+
+void s3d_vector_cross_product( float vector1[], float vector2[], float result_vector[] ) {
+	result_vector[0]=vector1[1] * vector2[2] - vector1[2] * vector2[1];
+	result_vector[1]=vector1[2] * vector2[0] - vector1[0] * vector2[2];
+	result_vector[2]=vector1[0] * vector2[1] - vector1[1] * vector2[0];
+}
+/***
+ *
  * calculate angle between 2 vectors => http://en.wikipedia.org/wiki/Vector_%28spatial%29#Dot_product
  *
  *   vector1   =>   given vector1



From dotslash at mail.berlios.de  Tue Dec  5 22:35:21 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 5 Dec 2006 22:35:21 +0100
Subject: [S3d-svn] r517 - in trunk: . apps/olsrs3d libs3d
Message-ID: <200612052135.kB5LZLTO014073@sheep.berlios.de>

Author: dotslash
Date: 2006-12-05 22:35:21 +0100 (Tue, 05 Dec 2006)
New Revision: 517

Modified:
   trunk/
   trunk/apps/olsrs3d/main.c
   trunk/libs3d/s3d.h
   trunk/libs3d/vector.c
Log:
 r1223 at kero:  dotslash | 2006-12-05 22:35:02 +0100
 - fix typo: substract -> substract



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1222
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1223

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-12-05 21:35:18 UTC (rev 516)
+++ trunk/apps/olsrs3d/main.c	2006-12-05 21:35:21 UTC (rev 517)
@@ -216,7 +216,7 @@
 
 /***
  *
- * calculate distance between 2 vectors and substract vector1 from vector2
+ * calculate distance between 2 vectors and subtract vector1 from vector2
  *  => http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction
  *
  *   p1   =>   vector of node 1

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2006-12-05 21:35:18 UTC (rev 516)
+++ trunk/libs3d/s3d.h	2006-12-05 21:35:21 UTC (rev 517)
@@ -162,7 +162,7 @@
 
 float s3d_vector_length( float vector[] );
 float s3d_vector_dot_product( float vector1[], float vector2[] );
-void s3d_vector_substract( float vector1[], float vector2[], float result_vector[] );
+void s3d_vector_subtract( float vector1[], float vector2[], float result_vector[] );
 float s3d_vector_angle( float vector1[], float vector2[] );
 float s3d_angle_to_cam( float obj_pos[], float cam_pos[], float *angle_rad );
 void s3d_vector_cross_product( float vector1[], float vector2[], float result_vector[] );

Modified: trunk/libs3d/vector.c
===================================================================
--- trunk/libs3d/vector.c	2006-12-05 21:35:18 UTC (rev 516)
+++ trunk/libs3d/vector.c	2006-12-05 21:35:21 UTC (rev 517)
@@ -52,7 +52,7 @@
  *
  ***/
 
-void s3d_vector_substract( float vector1[], float vector2[], float result_vector[] ) {
+void s3d_vector_subtract( float vector1[], float vector2[], float result_vector[] ) {
 
 	result_vector[0] = vector2[0] - vector1[0];
 	result_vector[1] = vector2[1] - vector1[1];



From dotslash at mail.berlios.de  Tue Dec  5 23:22:53 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 5 Dec 2006 23:22:53 +0100
Subject: [S3d-svn] r518 - in trunk: . apps/s3dosm
Message-ID: <200612052222.kB5MMrKi021661@sheep.berlios.de>

Author: dotslash
Date: 2006-12-05 23:22:52 +0100 (Tue, 05 Dec 2006)
New Revision: 518

Modified:
   trunk/
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/gps.c
Log:
 r1226 at kero:  dotslash | 2006-12-05 23:22:49 +0100
 - replace some of the TODO's with actual code in the way-drawing :)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1223
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1226

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-05 21:35:21 UTC (rev 517)
+++ trunk/apps/s3dosm/draw.c	2006-12-05 22:22:52 UTC (rev 518)
@@ -94,6 +94,7 @@
 static int lastid=-1;
 struct waylist {
 	int node_from,node_to;
+	int node_from_int,node_to_int;
 	int seg_id;
 	int node_from_l,node_from_r;	/* vertex id's for corners */
 	int node_to_l,node_to_r;
@@ -102,6 +103,8 @@
 	int node_id;			/* (external counting) */
 	float la,lo,alt;		/* earth coords */
 	float x[3];				/* euclid coords */
+	float normal[3];
+	float len;
 };
 struct adjlist {
 	int node_id;			/* node to which the segment leads to */
@@ -132,7 +135,6 @@
 			else if (0==strcmp(azColName[i],"altitude"))		np[nodelist_n].alt=strtod(argv[i],NULL);
 		}
 	}
-	nodelist_n++;
 	return(0);
 }
 int select_waytype(void *data, int argc, char **argv, char **azColName)
@@ -150,14 +152,15 @@
 	return(0);
 }
 /* draw waylist, clear the queue */
-void waylist_draw()
+void waylist_draw(char *filter)
 {
+	float len;
 	char query[MAXQ];
-	float x[6];
-	int i,vert=0;
+	int i,j,k,vert=0;
 	int node_id;
 	int way_obj;
 	int waytype=0;
+	int adj_seg;
 /*	printf("way: %d - %d segments\n",lastid,waylist_n);*/
 	way_obj=s3d_new_object();
 	if (lastid!=-1) {
@@ -166,7 +169,7 @@
 	}
 	switch (waytype)
 	{
-		case 1:s3d_push_material(way_obj,0.3,0.3,1,	0.3,0.3,1.0,	0.3,0.3,1.0);	/* motorway */
+		case 1:s3d_push_material(way_obj,0.3,0.3,1,		0.3,0.3,1.0,	0.3,0.3,1.0);	/* motorway */
 		case 2:s3d_push_material(way_obj,0.5,0.5,0.8,	0.5,0.5,0.8,	0.5,0.5,0.8);	/* motorway_link*/
 		case 3:s3d_push_material(way_obj,1.0,0.6,0.2,	1.0,0.6,0.2, 	1.0,0.6,0.2);	/* primary */
 		case 4:s3d_push_material(way_obj,1.0,1.0,0.0,	1.0,1.0,0.0, 	1.0,1.0,0.0);	/* secondary */
@@ -174,55 +177,122 @@
 		default:s3d_push_material(way_obj,1,0.5,1,		1,0.5,1,		1,0.5,1); /* default */
 	}
 	/* put nodes of the graph into a list */
+	nodelist_n=0;
 	for (i=0;i<waylist_n*2;i++) {
-		if (waylist_n%2)		node_id=waylist_p[i/2].node_from;
+		if (i%2)				node_id=waylist_p[i/2].node_from;
 		else					node_id=waylist_p[i/2].node_to;
 		for (j=0;j<nodelist_n;j++)
-			if (nodelist_p[j]==node_id) break;
+			if (nodelist_p[j].node_id==node_id) break;
 		if (j==nodelist_n) { /* we still need to add this node */
+			printf("[way %d] add node %d to nodelist as %d\n",lastid, node_id, nodelist_n);
 			nodelist_p[j].node_id=node_id;
+			snprintf(query,MAXQ,"SELECT longitude, latitude, altitude FROM node WHERE %s AND node_id=%d;",filter, node_id);
+			db_exec(query, insert_node,(void *)(nodelist_p));
+			calc_earth_to_eukl(nodelist_p[j].la,nodelist_p[j].lo,nodelist_p[j].x);
+			len=sqrt(nodelist_p[j].x[0]*nodelist_p[j].x[0] + nodelist_p[j].x[1]*nodelist_p[j].x[1] + nodelist_p[j].x[2]*nodelist_p[j].x[2]);
+			nodelist_p[j].normal[0]=nodelist_p[j].x[0]/len;
+			nodelist_p[j].normal[1]=nodelist_p[j].x[1]/len;
+			nodelist_p[j].normal[2]=nodelist_p[j].x[2]/len;
 			nodelist_n++;
-			snprintf(query,MAXQ,"SELECT longitude, latitude, altitude FROM node WHERE node_id=%d;",node_id);
-			db_exec(query, insert_node,(void *)(nodelist_p+j));
-			calc_earth_to_eukl(nodelist_p[j].la,nodelist_p[j].lo,nodelist_p[j].x);
-		}
+		} 
+		if (i%2)				waylist_p[i/2].node_from_int=j;
+		else					waylist_p[i/2].node_to_int=j;
 	}
 	/* iterate for all nodes */
 	for (i=0;i<nodelist_n;i++)
 	{
 		/* find adjacent segments */
-			/* TODO */
+		adjlist_n=0;
+		node_id=nodelist_p[i].node_id;
+		for (j=0;j<=waylist_n;j++)	{
+			if (waylist_p[j].node_from==node_id) {
+				adjlist_p[adjlist_n].node_id=waylist_p[j].node_to_int;
+				adjlist_p[adjlist_n].seg_id=j;
+				adjlist_n++;
+			} else  if (waylist_p[j].node_to==node_id) {
+				adjlist_p[adjlist_n].node_id=waylist_p[j].node_from_int;
+				adjlist_p[adjlist_n].seg_id=j;
+				adjlist_n++;
+			}
+		}
+		printf("[way %d] node %d (num %d in list) has %d adjacent nodes\n",lastid,node_id,i,adjlist_n);
+			
 		if (adjlist_n>1)	/* more than one adjacent, need to order and calculate intersections */
 		{
-			/* TODO: order adjlist */
-			for (j=0;j<=adjlist_n;j++)
+			if (adjlist_n>2) /* no ordering needed for 2 incoming segments */
 			{
-				int adj_segid;
+				/*
+				printf("[way %d] old order for node %d\n",lastid, node_id);
+				for (j=0;j<adjlist_n;j++) {
+					printf("adj %d: %d (real: %d)\n",j,adjlist_p[j].node_id,nodelist_p[adjlist_p[j].node_id].node_id);
+				}
+				*/
+				for (j=0;j<adjlist_n-2;j++)
+					for (k=j+2;k<adjlist_n;k++)
+					{
+						float test[3],normal[3],linevector[3];
+						/* (re)calc test direction */
+						s3d_vector_subtract(nodelist_p[adjlist_p[j].node_id].x,
+											nodelist_p[adjlist_p[j+1].node_id].x,
+												linevector);
+						s3d_vector_cross_product(
+												nodelist_p[adjlist_p[j].node_id].normal,
+												linevector,
+												normal); /* normal should look outside of our circle now. */
+						while (k<adjlist_n) {
+							/* determine on which side the point is. if its between our testvector, we'll need to swap. */
+							s3d_vector_subtract(nodelist_p[adjlist_p[j].node_id].x,
+												nodelist_p[adjlist_p[k].node_id].x,
+												test);
+							if (s3d_vector_dot_product(normal,test)>0) { /* same side, means adjacent line k is nearer to our point j
+																			than our point j+1 which is supposed to be the nearest point, 
+																			so we swap them and call a break to get the new test-normal */
+								struct adjlist swap;
+								memcpy(&swap,&(adjlist_p[j+1]),sizeof(struct adjlist));
+								memcpy(&(adjlist_p[j+1]),&(adjlist_p[k]),sizeof(struct adjlist));
+								memcpy(&(adjlist_p[k]),&swap,sizeof(struct adjlist));
+								break;
+							}
+							k++;
+						}
+					}
+				/*
+				printf("[way %d] new order for node %d\n",lastid, node_id);
+				for (j=0;j<adjlist_n;j++) {
+					printf("adj %d: %d (real: %d)\n",j,adjlist_p[j].node_id,nodelist_p[adjlist_p[j].node_id].node_id);
+				}
+				*/
+			}
+
+			for (j=0;j<adjlist_n;j++)
+			{
+				printf("calc intersection\n");
 				/* TODO: calc segpoints for j and j+1%adjlist_n */
-				s3d_push_vertices(oid,segpoint,1);
-				adj_seg=adjlist[j].seg_id;
-				if (nodelist_p[i].node_id==waylist[adj_seg].node_from)		waylist[adj_seg].node_from_r=vert;
-					else													waylist[adj_seg].node_to_l=vert;
+/*				s3d_push_vertices(way_obj,segpoint,1);*/
+				adj_seg=adjlist_p[j].seg_id;
+				if (nodelist_p[i].node_id==waylist_p[adj_seg].node_from)	waylist_p[adj_seg].node_from_r=vert;
+					else													waylist_p[adj_seg].node_to_l=vert;
 				vert++;
-				adj_seg=adjlist[(j+1)%adjlist_n].seg_id;
-				if (nodelist_p[i].node_id==waylist[adj_seg].node_from)		waylist[adj_seg].node_from_l=vert;
-					else													waylist[adj_seg].node_to_r=vert;
+				adj_seg=adjlist_p[(j+1)%adjlist_n].seg_id;
+				if (nodelist_p[i].node_id==waylist_p[adj_seg].node_from)	waylist_p[adj_seg].node_from_l=vert;
+					else													waylist_p[adj_seg].node_to_r=vert;
 				vert++;
-				}
 			}
 			if (adjlist_n>3) {
 				/* TODO: fill the intersection polygon */
 			}
 		} else {
+			int a,b;
+			printf("calc 2 endpoints\n");
 			/* endpoint */
 			/* TODO calculate segpoint and set to/from pointers appropriate */
-			adj_seg=adjlist[j].seg_id;
-			if (nodelist_p[i].node_id==waylist[adj_seg].node_from)	{
-				waylist[adj_seg].node_from_l=a;
-				waylist[adj_seg].node_from_r=b;
+			adj_seg=adjlist_p[0].seg_id;
+			if (nodelist_p[i].node_id==waylist_p[adj_seg].node_from)	{
+				waylist_p[adj_seg].node_from_l=a;
+				waylist_p[adj_seg].node_from_r=b;
 			} else {
-				waylist[adj_seg].node_to_l=b;
-				waylist[adj_seg].node_to_r=a;
+				waylist_p[adj_seg].node_to_l=b;
+				waylist_p[adj_seg].node_to_r=a;
 
 			}
 		}
@@ -269,12 +339,13 @@
 	waylist_n++;
 }
 
-int way_group(void *NotUsed, int argc, char **argv, char **azColName)
+int way_group(void *data, int argc, char **argv, char **azColName)
 {
 	int i;
 	int id=-1;
 	struct waylist p;
-	p.node_from=-1;
+	char *filter=(char *)data;
+	p.node_from=p.node_to=0;
 	p.node_to=-1;
 	p.seg_id=-1;
 	for(i=0; i<argc; i++){
@@ -288,8 +359,8 @@
 	}
 	if (p.node_from==p.node_to)	/* skip */
 		return(0);
-	if ((lastid!=id) && (id!=-1)) {
-		waylist_draw();
+	if ((lastid!=id) && (id!=0)) {
+		waylist_draw(filter);
 		/* flush/draw the list, add new  */
 /*		printf("new list: %d\n",id);*/
 		waylist_add(&p);
@@ -308,8 +379,8 @@
 	snprintf(query,MAXQ,"SELECT * FROM segment WHERE %s ORDER BY way_id;",filter);
 /*	snprintf(query,MAXQ,"SELECT DISTINCT way_id,segment.layer_id,node_id,node_from,node_to,longitude,latitude FROM segment JOIN node WHERE %s AND (node.node_id=segment.node_to OR node.node_id=segment.node_from) ORDER BY way_id;",filter);
 	printf("query: %s\n",query);*/
-	db_exec(query, way_group,0);
-	waylist_draw(); /* last way */
+	db_exec(query, way_group,filter);
+	waylist_draw(filter); /* last way */
 	printf("[done]\n");
 }
 void draw_translate_icon(int user_icon, float la, float lo)
@@ -321,7 +392,7 @@
 }
 void draw_osm()
 {
-	draw_ways("segment.layer_id=(SELECT layer_id FROM layer WHERE name='osm')");
+	draw_ways("layer_id=(SELECT layer_id FROM layer WHERE name='osm')");
 }
 void draw_all_layers()
 {

Modified: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2006-12-05 21:35:21 UTC (rev 517)
+++ trunk/apps/s3dosm/gps.c	2006-12-05 22:22:52 UTC (rev 518)
@@ -119,7 +119,7 @@
 	speed=dgps->speed*KNOTS_TO_MPH/METERS_TO_MILES/3600; /* speed in knots -> miles per hour -> meter per hour -> meter per secon */
 #endif
 	tlat=la;tlon=lo;
-/*	if (fix) {*/
+	if (fix) {
 		nav_center(la,lo);
 		if (!finitef(heading)) {
 			heading=get_heading(lat_old,lon_old,la,lo);
@@ -139,7 +139,7 @@
 		s3d_translate(gps_info,-slen/2,1,0);
 		s3d_link(gps_info, user_icon);
 		s3d_flags_on(gps_info,S3D_OF_VISIBLE);
-/*	}*/
+	}
 	
 	
 	lat_old=la;



From dotslash at mail.berlios.de  Thu Dec  7 21:50:38 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 7 Dec 2006 21:50:38 +0100
Subject: [S3d-svn] r519 - trunk/apps/s3dosm
Message-ID: <200612072050.kB7Koc1a000366@sheep.berlios.de>

Author: dotslash
Date: 2006-12-07 21:50:37 +0100 (Thu, 07 Dec 2006)
New Revision: 519

Modified:
   trunk/apps/s3dosm/draw.c
Log:
- nearly finished drawing algo for ways

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-05 22:22:52 UTC (rev 518)
+++ trunk/apps/s3dosm/draw.c	2006-12-07 20:50:37 UTC (rev 519)
@@ -151,6 +151,16 @@
 	}
 	return(0);
 }
+static float temp;
+#define		V_COPY(a,b)		a[0]=b[0];	a[1]=b[1];	a[2]=b[2];
+#define 	V_ADD(a,b,c)	c[0]=a[0]+b[0];	c[1]=a[1]+b[1];	c[2]=a[2]+b[2];
+#define 	V_SUB(a,b,c)	c[0]=a[0]-b[0];	c[1]=a[1]-b[1];	c[2]=a[2]-b[2];
+#define		V_DOT(a,b)		a[0]*b[0] + a[1]*b[1] + a[2] * b[2]
+#define		V_CROSS(a,b,c)	c[0]=a[1]*b[2] - a[2]*b[1];		c[1]=a[2]*b[0] - a[0]*b[2]; 	c[2]=a[0]*b[1] - a[1]*b[0];
+#define		V_LEN(a)		sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]);
+#define		V_SCAL(a,s)		a[0]=s*a[0];	a[1]=s*a[1];	a[2]=s*a[2];
+#define		V_NORM(a)		temp=V_LEN(a); V_SCAL(a,1/temp);
+
 /* draw waylist, clear the queue */
 void waylist_draw(char *filter)
 {
@@ -161,6 +171,13 @@
 	int way_obj;
 	int waytype=0;
 	int adj_seg;
+	float a[3],b[3],*left,*right,*swap;
+	float street_width=1; /* TODO: dynamically adjust? */
+	float an[3];		/* normal on the plane, orthogonal on the right side of the left segment */
+	float n[3];			/* the direction vector in which the intersecion should be placed */
+	float s[3];			/* intersection point */
+	float n_len,scale;
+
 /*	printf("way: %d - %d segments\n",lastid,waylist_n);*/
 	way_obj=s3d_new_object();
 	if (lastid!=-1) {
@@ -232,18 +249,11 @@
 					{
 						float test[3],normal[3],linevector[3];
 						/* (re)calc test direction */
-						s3d_vector_subtract(nodelist_p[adjlist_p[j].node_id].x,
-											nodelist_p[adjlist_p[j+1].node_id].x,
-												linevector);
-						s3d_vector_cross_product(
-												nodelist_p[adjlist_p[j].node_id].normal,
-												linevector,
-												normal); /* normal should look outside of our circle now. */
+						V_SUB(nodelist_p[adjlist_p[j].node_id].x,	nodelist_p[adjlist_p[j+1].node_id].x,	linevector);
+						V_CROSS(nodelist_p[adjlist_p[j].node_id].normal,	linevector,		normal); /* normal should look outside of our circle now. */
 						while (k<adjlist_n) {
 							/* determine on which side the point is. if its between our testvector, we'll need to swap. */
-							s3d_vector_subtract(nodelist_p[adjlist_p[j].node_id].x,
-												nodelist_p[adjlist_p[k].node_id].x,
-												test);
+							V_SUB(nodelist_p[adjlist_p[j].node_id].x,nodelist_p[adjlist_p[k].node_id].x,test);
 							if (s3d_vector_dot_product(normal,test)>0) { /* same side, means adjacent line k is nearer to our point j
 																			than our point j+1 which is supposed to be the nearest point, 
 																			so we swap them and call a break to get the new test-normal */
@@ -263,12 +273,37 @@
 				}
 				*/
 			}
+			left=a;
+			right=b;
+			V_SUB(nodelist_p[adjlist_p[0].node_id], nodelist_p[i].x, right);
+			V_NORM(right);
 
+
 			for (j=0;j<adjlist_n;j++)
 			{
+				swap=left;
+				left=right;			/* use last right segment as new left segment */
+				right=left;			/* get space for the next right segment */
+				V_SUB(nodelist_p[adjlist_p[(j+1)%adjlist_n].node_id], nodelist_p[i].x, right);
+				V_NORM(right);
+				V_CROSS(nodelist_p[i].normal, left ,an);	/* an is also normalized, as first and second argument are already length 1 */
+				V_ADD(left, right, n);						/* direction which our intersection is */
+				n_len=V_LEN(n);
+				if (n_len<0.001)
+				{	/* too low, don't use, just have intersection 90 degree of it. */
+					V_SCALE(an, street_width);		/* S = P + street_width * an */
+					V_ADD(nodelist_p[i].x, an, s);
+
+				} else {
+					V_COPY(s, nodelist_p[i].x);	/* s = P + (street_width/ ( n * an)) * n */
+					scale=V_DOT(n,an);	/* get cos (alpha/2), alpha is opposite angel of left and right segment */
+					V_SCALE(n,1/scale);
+					V_ADD(s, n, s);
+				}
+				
+				
 				printf("calc intersection\n");
-				/* TODO: calc segpoints for j and j+1%adjlist_n */
-/*				s3d_push_vertices(way_obj,segpoint,1);*/
+				s3d_push_vertices(way_obj,s,1);
 				adj_seg=adjlist_p[j].seg_id;
 				if (nodelist_p[i].node_id==waylist_p[adj_seg].node_from)	waylist_p[adj_seg].node_from_r=vert;
 					else													waylist_p[adj_seg].node_to_l=vert;
@@ -282,21 +317,39 @@
 				/* TODO: fill the intersection polygon */
 			}
 		} else {
-			int a,b;
 			printf("calc 2 endpoints\n");
 			/* endpoint */
-			/* TODO calculate segpoint and set to/from pointers appropriate */
+			V_SUB(nodelist_p[adjlist_p[0].node_id], nodelist_p[i].x, a);
+			V_NORM(a);
+			V_CROSS(nodelist_p[i].normal, a ,an);	/* an is also normalized, as first and second argument are already length 1 */
+
+			V_COPY(s,nodelist_p[i].normal);
+			V_ADD(s,an,s);
+			s3d_push_vertices(way_obj,an,s);
+			j=vert;
+			vert++;
+			V_SCAL(an,-1);
+			V_COPY(s,nodelist_p[i].normal);
+			V_ADD(s,an,s);
+			k=vert;
+			vert++;
+			
 			adj_seg=adjlist_p[0].seg_id;
 			if (nodelist_p[i].node_id==waylist_p[adj_seg].node_from)	{
-				waylist_p[adj_seg].node_from_l=a;
-				waylist_p[adj_seg].node_from_r=b;
+				waylist_p[adj_seg].node_from_l=j;
+				waylist_p[adj_seg].node_from_r=k;
 			} else {
-				waylist_p[adj_seg].node_to_l=b;
-				waylist_p[adj_seg].node_to_r=a;
-
+				waylist_p[adj_seg].node_to_l=k;
+				waylist_p[adj_seg].node_to_r=j;
 			}
 		}
 	}
+	for (i=0;i<waylist_n;i++) {
+		printf("drawing way from points %d %d %d %d\n",waylist_p[i].node_from_l, waylist_p[i].node_to_l, waylist_p[i].node_to_r,waylist_p[i].node_from_r);
+		s3d_push_polygon(way_obj, waylist_p[i].node_from_l, waylist_p[i].node_to_l, waylist_p[i].node_to_r, 0);
+		s3d_push_polygon(way_obj, waylist_p[i].node_from_l, waylist_p[i].node_to_r, waylist_p[i].node_from_r, 0);
+		
+	}
 	s3d_link(way_obj,oidy);
 	s3d_flags_on(way_obj,S3D_OF_VISIBLE);
 	waylist_n=0;



From dotslash at mail.berlios.de  Thu Dec  7 23:35:26 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 7 Dec 2006 23:35:26 +0100
Subject: [S3d-svn] r520 - in trunk: . apps/s3dosm
Message-ID: <200612072235.kB7MZQkN012722@sheep.berlios.de>

Author: dotslash
Date: 2006-12-07 23:35:26 +0100 (Thu, 07 Dec 2006)
New Revision: 520

Modified:
   trunk/
   trunk/apps/s3dosm/db.c
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/kismet.c
   trunk/apps/s3dosm/nav.c
   trunk/apps/s3dosm/s3dosm.h
Log:
 r1230 at kero:  dotslash | 2006-12-07 23:35:19 +0100
 - drawing segments works now. it's not too pretty right now but works and draws
   broad streets instead of plain lines



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1226
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1230

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2006-12-07 20:50:37 UTC (rev 519)
+++ trunk/apps/s3dosm/db.c	2006-12-07 22:35:26 UTC (rev 520)
@@ -62,7 +62,7 @@
 		}
 		return(tagid);
 	} else 
-		return(-1);
+		return(0);
 }
 int db_insert_node(node_t *node)
 {
@@ -70,7 +70,7 @@
 	char addquery[MAXQ];
 	tagid= db_insert_tags(node->base.tag_n,node->base.tag_p);
 	
-	if (node->base.id==-1) /* give own id */
+	if (node->base.id==0) /* give own id */
 		snprintf(addquery,MAXQ,"INSERT INTO node (layer_id, latitude, longitude, altitude, visible, tag_id) VALUES (%d, %f, %f, %f, %d, %d);",
 						(int)node->base.layerid,				node->lat,		node->lon,		node->alt,		node->visible, 		tagid);
 	else
@@ -87,7 +87,7 @@
 	char addquery[MAXQ];
 	tagid= db_insert_tags(seg->base.tag_n,seg->base.tag_p);
 
-/*	if (seg->base.id==-1) / * give own id * /
+/*	if (seg->base.id==0) / * give own id * /
 		snprintf(addquery,MAXQ,"INSERT INTO segment (layer_id, node_from, node_to, tag_id) VALUES (%d, %d, %d), %d;",
 						(int)seg->base.layerid,				(int)seg->from, (int)seg->to,	tagid );
 	else*/

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-07 20:50:37 UTC (rev 519)
+++ trunk/apps/s3dosm/draw.c	2006-12-07 22:35:26 UTC (rev 520)
@@ -34,14 +34,14 @@
 	int vnum;
 };
 
-void calc_earth_to_eukl(float lat, float lon, float *x)
+void calc_earth_to_eukl(float lat, float lon, float alt, float *x)
 {
 	float la,lo;
 	la=lat*M_PI/180.0;
 	lo=lon*M_PI/180.0;
-	x[0]=ESIZE*sin(lo) *cos(la);
-	x[1]=ESIZE*			sin(la);
-	x[2]=ESIZE*cos(lo) *cos(la);
+	x[0]=(ESIZE+alt)*sin(lo) *cos(la);
+	x[1]=(ESIZE+alt)*			sin(la);
+	x[2]=(ESIZE+alt)*cos(lo) *cos(la);
 }
 void draw_add_vertices(object_t *t, void *data)
 {
@@ -53,7 +53,7 @@
 		float x[3];
 		node_t *node=NODE_T(t);
 		node->vid=v->vnum;
-		calc_earth_to_eukl(node->lat,node->lon,x);
+		calc_earth_to_eukl(node->lat,node->lon,0,x);
 		s3d_push_vertex(v->oid,x[0],x[1],x[2]);
 		if (node->visible==2) /* something special */
 		{
@@ -142,11 +142,11 @@
 	int i;
 	for(i=0; i<argc; i++){
 		if (argv[i]) {
-			if (0==strcmp(argv[i],"motorway"))				*((int *) data)=1;	
-			else if (0==strcmp(argv[i],"motorway_link"))	*((int *) data)=2;	
+			if (0==strcmp(argv[i],"motorway"))				*((int *) data)=5;	
+			else if (0==strcmp(argv[i],"motorway_link"))	*((int *) data)=4;	
 			else if (0==strcmp(argv[i],"primary"))			*((int *) data)=3;	
-			else if (0==strcmp(argv[i],"secondary"))		*((int *) data)=4;	
-			else if (0==strcmp(argv[i],"residential"))		*((int *) data)=5;	
+			else if (0==strcmp(argv[i],"secondary"))		*((int *) data)=2;	
+			else if (0==strcmp(argv[i],"residential"))		*((int *) data)=1;	
 		}
 	}
 	return(0);
@@ -172,7 +172,7 @@
 	int waytype=0;
 	int adj_seg;
 	float a[3],b[3],*left,*right,*swap;
-	float street_width=1; /* TODO: dynamically adjust? */
+	float street_width; /* dynamically adjust? */
 	float an[3];		/* normal on the plane, orthogonal on the right side of the left segment */
 	float n[3];			/* the direction vector in which the intersecion should be placed */
 	float s[3];			/* intersection point */
@@ -186,13 +186,14 @@
 	}
 	switch (waytype)
 	{
-		case 1:s3d_push_material(way_obj,0.3,0.3,1,		0.3,0.3,1.0,	0.3,0.3,1.0);	/* motorway */
-		case 2:s3d_push_material(way_obj,0.5,0.5,0.8,	0.5,0.5,0.8,	0.5,0.5,0.8);	/* motorway_link*/
-		case 3:s3d_push_material(way_obj,1.0,0.6,0.2,	1.0,0.6,0.2, 	1.0,0.6,0.2);	/* primary */
-		case 4:s3d_push_material(way_obj,1.0,1.0,0.0,	1.0,1.0,0.0, 	1.0,1.0,0.0);	/* secondary */
-		case 5:s3d_push_material(way_obj,1.0,1.0,1.0,	1.0,1.0,1.0, 	1.0,1.0,1.0);	/* residential */
-		default:s3d_push_material(way_obj,1,0.5,1,		1,0.5,1,		1,0.5,1); /* default */
+		case 5:s3d_push_material(way_obj,0.2,0.2,0.6,		1.0,1.0,1.0,	0.3,0.3,1.0);	/* motorway */
+		case 4:s3d_push_material(way_obj,0.3,0.3,0.4,		1.0,1.0,1.0,	0.5,0.5,0.8);	/* motorway_link*/
+		case 3:s3d_push_material(way_obj,0.6,0.3,0.1,		1.0,1.0,1.0, 	1.0,0.6,0.2);	/* primary */
+		case 2:s3d_push_material(way_obj,0.6,0.6,0.0,		1.0,1.0,1.0, 	1.0,1.0,0.0);	/* secondary */
+		case 1:s3d_push_material(way_obj,0.6,0.6,0.6,		1.0,1.0,1.0, 	1.0,1.0,1.0);	/* residential */
+		default:s3d_push_material(way_obj,0.6,0.2,0.6,		1.0,1.0,1.0,	1.0,0.5,1.0); /* default */
 	}
+	street_width=0.5+waytype/10;
 	/* put nodes of the graph into a list */
 	nodelist_n=0;
 	for (i=0;i<waylist_n*2;i++) {
@@ -201,11 +202,11 @@
 		for (j=0;j<nodelist_n;j++)
 			if (nodelist_p[j].node_id==node_id) break;
 		if (j==nodelist_n) { /* we still need to add this node */
-			printf("[way %d] add node %d to nodelist as %d\n",lastid, node_id, nodelist_n);
+/*			printf("[way %d] add node %d to nodelist as %d\n",lastid, node_id, nodelist_n);*/
 			nodelist_p[j].node_id=node_id;
 			snprintf(query,MAXQ,"SELECT longitude, latitude, altitude FROM node WHERE %s AND node_id=%d;",filter, node_id);
 			db_exec(query, insert_node,(void *)(nodelist_p));
-			calc_earth_to_eukl(nodelist_p[j].la,nodelist_p[j].lo,nodelist_p[j].x);
+			calc_earth_to_eukl(nodelist_p[j].la,nodelist_p[j].lo,0+waytype/2,nodelist_p[j].x); /* elevate higher priority streets a little bit ... */
 			len=sqrt(nodelist_p[j].x[0]*nodelist_p[j].x[0] + nodelist_p[j].x[1]*nodelist_p[j].x[1] + nodelist_p[j].x[2]*nodelist_p[j].x[2]);
 			nodelist_p[j].normal[0]=nodelist_p[j].x[0]/len;
 			nodelist_p[j].normal[1]=nodelist_p[j].x[1]/len;
@@ -232,18 +233,11 @@
 				adjlist_n++;
 			}
 		}
-		printf("[way %d] node %d (num %d in list) has %d adjacent nodes\n",lastid,node_id,i,adjlist_n);
 			
 		if (adjlist_n>1)	/* more than one adjacent, need to order and calculate intersections */
 		{
 			if (adjlist_n>2) /* no ordering needed for 2 incoming segments */
 			{
-				/*
-				printf("[way %d] old order for node %d\n",lastid, node_id);
-				for (j=0;j<adjlist_n;j++) {
-					printf("adj %d: %d (real: %d)\n",j,adjlist_p[j].node_id,nodelist_p[adjlist_p[j].node_id].node_id);
-				}
-				*/
 				for (j=0;j<adjlist_n-2;j++)
 					for (k=j+2;k<adjlist_n;k++)
 					{
@@ -266,16 +260,10 @@
 							k++;
 						}
 					}
-				/*
-				printf("[way %d] new order for node %d\n",lastid, node_id);
-				for (j=0;j<adjlist_n;j++) {
-					printf("adj %d: %d (real: %d)\n",j,adjlist_p[j].node_id,nodelist_p[adjlist_p[j].node_id].node_id);
-				}
-				*/
 			}
 			left=a;
 			right=b;
-			V_SUB(nodelist_p[adjlist_p[0].node_id], nodelist_p[i].x, right);
+			V_SUB(nodelist_p[adjlist_p[0].node_id].x, nodelist_p[i].x, right);
 			V_NORM(right);
 
 
@@ -283,59 +271,63 @@
 			{
 				swap=left;
 				left=right;			/* use last right segment as new left segment */
-				right=left;			/* get space for the next right segment */
-				V_SUB(nodelist_p[adjlist_p[(j+1)%adjlist_n].node_id], nodelist_p[i].x, right);
+				right=swap;			/* get space for the next right segment */
+				V_SUB(nodelist_p[adjlist_p[(j+1)%adjlist_n].node_id].x, nodelist_p[i].x, right);
 				V_NORM(right);
 				V_CROSS(nodelist_p[i].normal, left ,an);	/* an is also normalized, as first and second argument are already length 1 */
 				V_ADD(left, right, n);						/* direction which our intersection is */
 				n_len=V_LEN(n);
-				if (n_len<0.001)
+
+				if (n_len<0.1)
 				{	/* too low, don't use, just have intersection 90 degree of it. */
-					V_SCALE(an, street_width);		/* S = P + street_width * an */
+					V_SCAL(an, -street_width);		/* S = P + street_width * an */
 					V_ADD(nodelist_p[i].x, an, s);
 
 				} else {
 					V_COPY(s, nodelist_p[i].x);	/* s = P + (street_width/ ( n * an)) * n */
+					V_SCAL(n,1/n_len);	/* normalize n first! */
 					scale=V_DOT(n,an);	/* get cos (alpha/2), alpha is opposite angel of left and right segment */
-					V_SCALE(n,1/scale);
+					V_SCAL(n,-street_width/scale);
 					V_ADD(s, n, s);
 				}
 				
 				
-				printf("calc intersection\n");
+/*				printf("calc intersection: %3.3f %3.3f %3.3f\n",s[0],s[1],s[2]);*/
 				s3d_push_vertices(way_obj,s,1);
-				adj_seg=adjlist_p[j].seg_id;
-				if (nodelist_p[i].node_id==waylist_p[adj_seg].node_from)	waylist_p[adj_seg].node_from_r=vert;
-					else													waylist_p[adj_seg].node_to_l=vert;
+				adj_seg=adjlist_p[j].seg_id;				/* left segment */
+				if (i==waylist_p[adj_seg].node_from_int)	waylist_p[adj_seg].node_from_r=vert;
+					else									waylist_p[adj_seg].node_to_l=vert;
+				adj_seg=adjlist_p[(j+1)%adjlist_n].seg_id;	/* right segment */
+				if (i==waylist_p[adj_seg].node_from_int)	waylist_p[adj_seg].node_from_l=vert;
+					else									waylist_p[adj_seg].node_to_r=vert;
 				vert++;
-				adj_seg=adjlist_p[(j+1)%adjlist_n].seg_id;
-				if (nodelist_p[i].node_id==waylist_p[adj_seg].node_from)	waylist_p[adj_seg].node_from_l=vert;
-					else													waylist_p[adj_seg].node_to_r=vert;
-				vert++;
 			}
-			if (adjlist_n>3) {
-				/* TODO: fill the intersection polygon */
+			if (adjlist_n>=3) {
+				/* we know that the last adjlist_n vertices set belong to our intersection here .. */
+				for (j=vert-adjlist_n+1;j<(vert-1);j++) 
+					s3d_push_polygon(way_obj, vert-adjlist_n, j, j+1,0 );
 			}
 		} else {
-			printf("calc 2 endpoints\n");
 			/* endpoint */
-			V_SUB(nodelist_p[adjlist_p[0].node_id], nodelist_p[i].x, a);
+			V_SUB(nodelist_p[adjlist_p[0].node_id].x, nodelist_p[i].x, a);
 			V_NORM(a);
 			V_CROSS(nodelist_p[i].normal, a ,an);	/* an is also normalized, as first and second argument are already length 1 */
+			V_SCAL(an, street_width);
 
-			V_COPY(s,nodelist_p[i].normal);
+			V_COPY(s,nodelist_p[i].x);
 			V_ADD(s,an,s);
-			s3d_push_vertices(way_obj,an,s);
+			s3d_push_vertices(way_obj,s,1);
 			j=vert;
 			vert++;
 			V_SCAL(an,-1);
-			V_COPY(s,nodelist_p[i].normal);
+			V_COPY(s,nodelist_p[i].x);
 			V_ADD(s,an,s);
+			s3d_push_vertices(way_obj,s,1);
 			k=vert;
 			vert++;
 			
 			adj_seg=adjlist_p[0].seg_id;
-			if (nodelist_p[i].node_id==waylist_p[adj_seg].node_from)	{
+			if (i==waylist_p[adj_seg].node_from_int)	{
 				waylist_p[adj_seg].node_from_l=j;
 				waylist_p[adj_seg].node_from_r=k;
 			} else {
@@ -345,7 +337,7 @@
 		}
 	}
 	for (i=0;i<waylist_n;i++) {
-		printf("drawing way from points %d %d %d %d\n",waylist_p[i].node_from_l, waylist_p[i].node_to_l, waylist_p[i].node_to_r,waylist_p[i].node_from_r);
+/*		printf("drawing way from points %d %d %d %d\n",waylist_p[i].node_from_l, waylist_p[i].node_to_l, waylist_p[i].node_to_r,waylist_p[i].node_from_r);*/
 		s3d_push_polygon(way_obj, waylist_p[i].node_from_l, waylist_p[i].node_to_l, waylist_p[i].node_to_r, 0);
 		s3d_push_polygon(way_obj, waylist_p[i].node_from_l, waylist_p[i].node_to_r, waylist_p[i].node_from_r, 0);
 		
@@ -353,31 +345,6 @@
 	s3d_link(way_obj,oidy);
 	s3d_flags_on(way_obj,S3D_OF_VISIBLE);
 	waylist_n=0;
-
-
-/*			
-	for (i=0;i<waylist_n;i++)
-	{
-		float len;
-		nodelist_n=0;
-		snprintf(query,MAXQ,"SELECT longitude, latitude, altitude FROM node WHERE node_id IN (%d,%d);",waylist_p[i].node_from,waylist_p[i].node_to);
-		db_exec(query, insert_node,(void *)nodelist_p);
-		calc_earth_to_eukl(nodelist_p[0].la,nodelist_p[0].lo,x);
-		calc_earth_to_eukl(nodelist_p[1].la,nodelist_p[1].lo,x+3);
-		s3d_push_vertices(way_obj,x,2);
-		s3d_push_line(way_obj, vert,vert+1, 0);
-		vert+=2;
-		len=sqrt( (x[0]-x[3])*(x[0]-x[3]) + (x[1]-x[4])*(x[1]-x[4]) + (x[2]-x[5])*(x[2]-x[5]));
-		if (len>1000.0)
-		{
-			printf("length of segment is %3.3f\n",len);
-			printf("segment id %d: from id %d to id %d\n",waylist_p[i].seg_id,waylist_p[i].node_from,waylist_p[i].node_to);
-			printf("segment no %d of way %d: %f %f %f -> ",i, lastid,nodelist_p[0].la, nodelist_p[0].lo, nodelist_p[0].alt);
-			printf("%f %f %f\n",nodelist_p[1].la, nodelist_p[1].lo, nodelist_p[1].alt);
-		}
-
-	}
-*/		
 }
 void waylist_add(struct waylist *p)
 {
@@ -408,14 +375,12 @@
 			else if (0==strcmp(azColName[i],"node_to"))			p.node_to=atoi(argv[i]);
 			else if (0==strcmp(azColName[i],"seg_id"))			p.seg_id=atoi(argv[i]);
 		}
-		/* 	printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");  */
 	}
 	if (p.node_from==p.node_to)	/* skip */
 		return(0);
 	if ((lastid!=id) && (id!=0)) {
 		waylist_draw(filter);
 		/* flush/draw the list, add new  */
-/*		printf("new list: %d\n",id);*/
 		waylist_add(&p);
 	} else {
 		/* add id to the list */
@@ -430,8 +395,6 @@
 {
 	char query[MAXQ];
 	snprintf(query,MAXQ,"SELECT * FROM segment WHERE %s ORDER BY way_id;",filter);
-/*	snprintf(query,MAXQ,"SELECT DISTINCT way_id,segment.layer_id,node_id,node_from,node_to,longitude,latitude FROM segment JOIN node WHERE %s AND (node.node_id=segment.node_to OR node.node_id=segment.node_from) ORDER BY way_id;",filter);
-	printf("query: %s\n",query);*/
 	db_exec(query, way_group,filter);
 	waylist_draw(filter); /* last way */
 	printf("[done]\n");
@@ -439,7 +402,7 @@
 void draw_translate_icon(int user_icon, float la, float lo)
 {
 	float x[3];
-	calc_earth_to_eukl(la,lo,x);
+	calc_earth_to_eukl(la,lo,0,x);
 	s3d_translate(user_icon,x[0],x[1],x[2]);
 	s3d_rotate(user_icon,(90-la),lo,0);
 }
@@ -450,8 +413,4 @@
 void draw_all_layers()
 {
 	draw_osm();
-/*	int i;
-	for (i=0;i<layerset.n;i++)
-		draw_layer(layerset.p[i]);
-	*/
 }

Modified: trunk/apps/s3dosm/kismet.c
===================================================================
--- trunk/apps/s3dosm/kismet.c	2006-12-07 20:50:37 UTC (rev 519)
+++ trunk/apps/s3dosm/kismet.c	2006-12-07 22:35:26 UTC (rev 520)
@@ -37,7 +37,7 @@
 	attr=cur->properties;
 
 	node->base.layerid=layerid;
-	node->base.id=-1;				/* let database decide */
+	node->base.id=0;				/* let database decide */
 	for (attr=cur->properties;attr;attr=attr->next)
 	{
 /*		if (0==strcmp((char *)attr->name,"number")) 		node->base.id=		strtol((char *)attr->children->content,NULL,10);

Modified: trunk/apps/s3dosm/nav.c
===================================================================
--- trunk/apps/s3dosm/nav.c	2006-12-07 20:50:37 UTC (rev 519)
+++ trunk/apps/s3dosm/nav.c	2006-12-07 22:35:26 UTC (rev 520)
@@ -52,7 +52,7 @@
 	} else { lat=tlat;lon=tlon;}
 	s3d_rotate(oidy,0,-lon,0);
 	s3d_rotate(oidx,-(90-lat),0,0);
-	calc_earth_to_eukl(lon,lat,x);
+	calc_earth_to_eukl(lon,lat,0,x);
 	s3d_translate(oidx,0,-ESIZE*RESCALE- VIEWHEIGHT,0);
 	s3d_scale(oidx,RESCALE);
 }
@@ -77,9 +77,9 @@
 	float dir[3],north[3];
 	float angle;
 	int i;
-	calc_earth_to_eukl(la1,lo1,p1);
-	calc_earth_to_eukl(la2,lo2,p2);
-	calc_earth_to_eukl(la1+1,lo1,p1_north);
+	calc_earth_to_eukl(la1,lo1,0,p1);
+	calc_earth_to_eukl(la2,lo2,0,p2);
+	calc_earth_to_eukl(la1+1,lo1,0,p1_north);
 	for (i=0;i<3;i++)		north[i]=p1_north[i]-p1[i];
 	for (i=0;i<3;i++)		dir[i]=p2[i]-p1[i];
 	angle=s3d_vector_angle(dir,north);

Modified: trunk/apps/s3dosm/s3dosm.h
===================================================================
--- trunk/apps/s3dosm/s3dosm.h	2006-12-07 20:50:37 UTC (rev 519)
+++ trunk/apps/s3dosm/s3dosm.h	2006-12-07 22:35:26 UTC (rev 520)
@@ -134,7 +134,7 @@
 /* draw.c */
 void draw_all_layers();
 int draw_layer(layer_t *layer);
-void calc_earth_to_eukl(float lat, float lon, float *x);
+void calc_earth_to_eukl(float lat, float lon, float alt, float *x);
 void draw_translate_icon(int user_icon, float la, float lo);
 /* nav.c */
 void nav_main();



From dotslash at mail.berlios.de  Fri Dec  8 11:25:15 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Fri, 8 Dec 2006 11:25:15 +0100
Subject: [S3d-svn] r521 - trunk/server
Message-ID: <200612081025.kB8APFx4015661@sheep.berlios.de>

Author: dotslash
Date: 2006-12-08 11:25:14 +0100 (Fri, 08 Dec 2006)
New Revision: 521

Modified:
   trunk/server/graphics_sdl.c
Log:
- use multisample stuff? (to test)

Modified: trunk/server/graphics_sdl.c
===================================================================
--- trunk/server/graphics_sdl.c	2006-12-07 22:35:26 UTC (rev 520)
+++ trunk/server/graphics_sdl.c	2006-12-08 10:25:14 UTC (rev 521)
@@ -22,6 +22,7 @@
  */
 
 #include "global.h"
+#define	AA_LEVEL	4
 
 #include <SDL_opengl.h>
 #include <SDL.h>
@@ -32,6 +33,7 @@
     SDL_Surface *GLwin = NULL;
     SDL_VideoInfo *VideoInfo;
     int rgb_size[3]; 				 /*  for SDL_GL attributes */
+    int buffers, samples;
 	s3dprintf(MED,"Using SDL driver ...");
 	
     SDLFlags = SDL_OPENGL | SDL_GL_DOUBLEBUFFER | SDL_HWPALETTE | SDL_RESIZABLE;
@@ -75,6 +77,11 @@
             default:
 				rgb_size[0] = 8;	rgb_size[1] = 8;	rgb_size[2] = 8;	break;
 	}
+	if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1 ))			s3dprintf(VHIGH,"error initializing multisampling");
+	if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, AA_LEVEL ))	s3dprintf(VHIGH,"no multisampling available");
+    SDL_GL_GetAttribute( SDL_GL_MULTISAMPLEBUFFERS, &buffers );
+    SDL_GL_GetAttribute( SDL_GL_MULTISAMPLESAMPLES, &samples );
+    s3dprintf(MED,"Buffers: %d Samples: %d", buffers, samples);
 
 	 /*  print some information */
 	s3dprintf(VLOW,"Screen BPP: %d", SDL_GetVideoSurface()->format->BitsPerPixel);



From dotslash at mail.berlios.de  Fri Dec  8 18:39:54 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Fri, 8 Dec 2006 18:39:54 +0100
Subject: [S3d-svn] r522 - in trunk: . server
Message-ID: <200612081739.kB8HdsRi002542@sheep.berlios.de>

Author: dotslash
Date: 2006-12-08 18:39:52 +0100 (Fri, 08 Dec 2006)
New Revision: 522

Modified:
   trunk/
   trunk/server/graphics_sdl.c
   trunk/server/main.c
Log:
 r1234 at kero:  dotslash | 2006-12-08 18:39:38 +0100
 - add multisampling 
 - fix argument handling



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1230
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1234

Modified: trunk/server/graphics_sdl.c
===================================================================
--- trunk/server/graphics_sdl.c	2006-12-08 10:25:14 UTC (rev 521)
+++ trunk/server/graphics_sdl.c	2006-12-08 17:39:52 UTC (rev 522)
@@ -22,7 +22,7 @@
  */
 
 #include "global.h"
-#define	AA_LEVEL	4
+int aa_level=4;
 
 #include <SDL_opengl.h>
 #include <SDL.h>
@@ -65,6 +65,11 @@
 /* 	SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5); */
 /* 	SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 ); */
 	SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
+	if (aa_level>0) {
+		if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1 ))			s3dprintf(VHIGH,"error initializing multisampling");
+		if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, aa_level ))	s3dprintf(VHIGH,"no multisampling available");
+	}
+
 	 /*  more opengl-init-stuff */
 	if ((GLwin = SDL_SetVideoMode(X_RES,Y_RES,16,SDLFlags))==NULL) 
 			errsf("SDL_SetVideoMode()",SDL_GetError());
@@ -77,11 +82,10 @@
             default:
 				rgb_size[0] = 8;	rgb_size[1] = 8;	rgb_size[2] = 8;	break;
 	}
-	if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1 ))			s3dprintf(VHIGH,"error initializing multisampling");
-	if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, AA_LEVEL ))	s3dprintf(VHIGH,"no multisampling available");
+
     SDL_GL_GetAttribute( SDL_GL_MULTISAMPLEBUFFERS, &buffers );
     SDL_GL_GetAttribute( SDL_GL_MULTISAMPLESAMPLES, &samples );
-    s3dprintf(MED,"Buffers: %d Samples: %d", buffers, samples);
+    s3dprintf(LOW,"Buffers: %d Samples: %d", buffers, samples);
 
 	 /*  print some information */
 	s3dprintf(VLOW,"Screen BPP: %d", SDL_GetVideoSurface()->format->BitsPerPixel);

Modified: trunk/server/main.c
===================================================================
--- trunk/server/main.c	2006-12-08 10:25:14 UTC (rev 521)
+++ trunk/server/main.c	2006-12-08 17:39:52 UTC (rev 522)
@@ -44,7 +44,8 @@
 static char *rc=NULL;
 static char *homerc="~/.s3drc";
 static char *etcrc ="/etc/s3drc";
-static int father_done=0;
+/*static int father_done=0;*/
+extern int aa_level;
 char **s3drc[]={&rc,&homerc,&etcrc};
 
 static void mainloop(void);
@@ -210,14 +211,15 @@
 	char				 c;
 	struct option long_options[] = 
 	{
-		{"help",0,0,'h'},
-		{"use-glut",0,0,'g'},
-		{"use-sdl",0,0,'s'},
-		{"rc",1,0,'r'},
-		{"no-rc",0,0,'n'},
+		{"multisample",		1,0,'m'},
+		{"rc",				1,0,'r'},
+		{"help",			0,0,'h'},
+		{"use-glut",		0,0,'g'},
+		{"use-sdl",			0,0,'s'},
+		{"no-rc",			0,0,'n'},
 		{0,0,0,0}
 	};
-	while (-1!=(c=getopt_long(argc,argv,"?hgsrn",long_options,&lopt_idx)))
+	while (-1!=(c=getopt_long(argc,argv,"?hgsnr:m:",long_options,&lopt_idx)))
 	{
 		switch (c)
 		{
@@ -240,6 +242,13 @@
 					s3dprintf(VHIGH,"using rc file: %s",optarg);
 					rc=optarg;
 					break;
+				case 'm':
+					aa_level=atoi(optarg);
+					if (aa_level>=0 || aa_level<=16)
+						s3dprintf(VHIGH,"aa_level: %d",aa_level);
+					else
+						errsf("process_args()","bad multisampling level");
+					break;
 				case 'n':
 					s3dprintf(VHIGH,"Using no rc file!");
 					norc=1;
@@ -249,6 +258,9 @@
 				case 'h':
 					s3dprintf(VHIGH,"usage: %s [options]",argv[0]);
 					s3dprintf(VHIGH,"s3d, the 3d server:");
+					s3dprintf(VHIGH," --multisample, -m:\tSpecify Multisampling level (antialiasing) if available.\n\t\t(value 1-16, default 4, 0 = off),");
+					s3dprintf(VHIGH," --rc, -r:\tspecify a rc (startup script)");
+					s3dprintf(VHIGH," --no-rc, -n:\tdon't use a rc file (useful for debugging mcp's)");
 #ifdef G_GLUT
 					s3dprintf(VHIGH," --use-glut, -g:\tuse GLUT as framework-system");
 #endif



From dotslash at mail.berlios.de  Fri Dec  8 19:08:44 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Fri, 8 Dec 2006 19:08:44 +0100
Subject: [S3d-svn] r523 - trunk/server
Message-ID: <200612081808.kB8I8i4c005223@sheep.berlios.de>

Author: dotslash
Date: 2006-12-08 19:08:35 +0100 (Fri, 08 Dec 2006)
New Revision: 523

Modified:
   trunk/server/graphics_sdl.c
Log:
- some workaround for systems (my notebook ;) behaving weird while trying to enable multisampling

Modified: trunk/server/graphics_sdl.c
===================================================================
--- trunk/server/graphics_sdl.c	2006-12-08 17:39:52 UTC (rev 522)
+++ trunk/server/graphics_sdl.c	2006-12-08 18:08:35 UTC (rev 523)
@@ -65,14 +65,24 @@
 /* 	SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5); */
 /* 	SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 ); */
 	SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
-	if (aa_level>0) {
-		if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1 ))			s3dprintf(VHIGH,"error initializing multisampling");
-		if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, aa_level ))	s3dprintf(VHIGH,"no multisampling available");
-	}
+	do {
+		if (aa_level>0) {
+			if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1 ))			s3dprintf(VHIGH,"error initializing multisampling");
+			if (SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, aa_level ))	s3dprintf(VHIGH,"no multisampling available");
+		}
 
-	 /*  more opengl-init-stuff */
-	if ((GLwin = SDL_SetVideoMode(X_RES,Y_RES,16,SDLFlags))==NULL) 
-			errsf("SDL_SetVideoMode()",SDL_GetError());
+		 /*  more opengl-init-stuff */
+		if ((GLwin = SDL_SetVideoMode(X_RES,Y_RES,16,SDLFlags))==NULL) 
+		{
+			if (aa_level>0) {
+				s3dprintf(MED,"retry without multisampling");
+				aa_level=0;
+				SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 0 );
+				SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 0 );
+			} else
+				errsf("SDL_SetVideoMode()",SDL_GetError());
+		}
+	} while (GLwin==0);
 	switch (SDL_GetVideoInfo()->vfmt->BitsPerPixel) {
 	    case 8:
 				rgb_size[0] = 3;	rgb_size[1] = 3;	rgb_size[2] = 2;	break;
@@ -82,11 +92,12 @@
             default:
 				rgb_size[0] = 8;	rgb_size[1] = 8;	rgb_size[2] = 8;	break;
 	}
+	if (aa_level >0) {
+	    SDL_GL_GetAttribute( SDL_GL_MULTISAMPLEBUFFERS, &buffers );
+	    SDL_GL_GetAttribute( SDL_GL_MULTISAMPLESAMPLES, &samples );
+	    s3dprintf(LOW,"Buffers: %d Samples: %d", buffers, samples);
+	}
 
-    SDL_GL_GetAttribute( SDL_GL_MULTISAMPLEBUFFERS, &buffers );
-    SDL_GL_GetAttribute( SDL_GL_MULTISAMPLESAMPLES, &samples );
-    s3dprintf(LOW,"Buffers: %d Samples: %d", buffers, samples);
-
 	 /*  print some information */
 	s3dprintf(VLOW,"Screen BPP: %d", SDL_GetVideoSurface()->format->BitsPerPixel);
 	s3dprintf(VLOW,"Vendor     : %s", glGetString( GL_VENDOR ) );



From dotslash at mail.berlios.de  Sun Dec 10 16:19:13 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 10 Dec 2006 16:19:13 +0100
Subject: [S3d-svn] r524 - in trunk: . libs3d
Message-ID: <200612101519.kBAFJDoZ010220@sheep.berlios.de>

Author: dotslash
Date: 2006-12-10 16:19:13 +0100 (Sun, 10 Dec 2006)
New Revision: 524

Modified:
   trunk/
   trunk/libs3d/modelread.c
Log:
 r1264 at kero:  dotslash | 2006-12-10 16:16:28 +0100
 - don't crash on NULL in s3d_import_model_file()



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1234
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1264

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2006-12-08 18:08:35 UTC (rev 523)
+++ trunk/libs3d/modelread.c	2006-12-10 15:19:13 UTC (rev 524)
@@ -49,6 +49,7 @@
 	char searchpath[1024];
 	char path[1024];
 	int oid;
+	if (fname==NULL) return(-1);
 #ifndef OBJSDIR
 #define OBJSDIR 	":./:../:../../:/usr/local/share/s3d/:/usr/share/s3d/"
 #endif



From dotslash at mail.berlios.de  Sun Dec 10 16:19:17 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 10 Dec 2006 16:19:17 +0100
Subject: [S3d-svn] r525 - in trunk: . apps/s3dosm
Message-ID: <200612101519.kBAFJHgM010278@sheep.berlios.de>

Author: dotslash
Date: 2006-12-10 16:19:16 +0100 (Sun, 10 Dec 2006)
New Revision: 525

Modified:
   trunk/
   trunk/apps/s3dosm/db.c
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/gps.c
   trunk/apps/s3dosm/kismet.c
   trunk/apps/s3dosm/nav.c
   trunk/apps/s3dosm/object.c
   trunk/apps/s3dosm/osm.c
   trunk/apps/s3dosm/s3dosm.h
Log:
 r1265 at kero:  dotslash | 2006-12-10 16:19:07 +0100
 - add kismet loader (again)
 - optimize osm/kismet parser for database read



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1264
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1265

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2006-12-10 15:19:13 UTC (rev 524)
+++ trunk/apps/s3dosm/db.c	2006-12-10 15:19:16 UTC (rev 525)
@@ -29,53 +29,39 @@
 #include <stdlib.h>	/* atoi() */
 static char qbuf[QBUF];
 static int qlen=0;
+static int tagid=1;		/* tagid, incremented with each new object */
 
-static int tagid;
 static sqlite3 *db;
 static char *dbFile=NULL;
 int db_exec(const char *query, sqlite3_callback callback, void *arg);
 static int db_getint(void *tagid, int argc, char **argv, char **azColName);
 
 /* TODO: remove '' for security reasons */
-char *clean_string(char *dirty)
+void clean_string(char *clean, char *dirty, int n)
 {
-	return(strdup(dirty));
+	strncpy(clean, dirty, n);
 }
-int db_insert_tags(int tag_n, tag_t *tag_p)
+int db_add_tag(object_t *obj, char *key, char *val)
 {
-	int i;
 	char tagquery[MAXQ];
-	char *mkey, *mval;
-	if (tag_n>0 && tag_p!=NULL)
-	{
-		 /* add tags */
-		tagid++;
-		tagquery[0]=0;
-		for (i=0;i<tag_n;i++)
-		{
-			mkey=clean_string(tag_p[i].k);
-			mval=clean_string(tag_p[i].v);
-			snprintf(tagquery,MAXQ,"INSERT INTO tag VALUES (%d, '%s','%s' );",tagid, mkey, mval);
-			db_exec(tagquery, NULL, 0);
-			free(mkey);
-			free(mval);
-		}
-		return(tagid);
-	} else 
-		return(0);
+	char mkey[MAXQ], mval[MAXQ];
+	clean_string(mkey,key,MAXQ);
+	clean_string(mval,val,MAXQ);
+	snprintf(tagquery,MAXQ,"INSERT INTO tag VALUES (%d, '%s','%s' );",(int)obj->tagid, mkey, mval);
+	db_exec(tagquery, NULL, 0);
+	return(0);
 }
 int db_insert_node(node_t *node)
 {
-	int tagid;
 	char addquery[MAXQ];
-	tagid= db_insert_tags(node->base.tag_n,node->base.tag_p);
+	node->base.tagid= tagid++;
 	
 	if (node->base.id==0) /* give own id */
 		snprintf(addquery,MAXQ,"INSERT INTO node (layer_id, latitude, longitude, altitude, visible, tag_id) VALUES (%d, %f, %f, %f, %d, %d);",
-						(int)node->base.layerid,				node->lat,		node->lon,		node->alt,		node->visible, 		tagid);
+						(int)node->base.layerid,				node->lat,		node->lon,		node->alt,		node->visible, 		(int)node->base.tagid);
 	else
 		snprintf(addquery,MAXQ,"INSERT INTO node VALUES (%d, %d, %f, %f, %f, %d, %d);",
-					(int)node->base.layerid,(int)node->base.id,	node->lat,		node->lon,		node->alt,		node->visible, 		tagid);
+					(int)node->base.layerid,(int)node->base.id,	node->lat,		node->lon,		node->alt,		node->visible, 		(int)node->base.tagid);
 
 	db_exec(addquery, NULL, 0);
 	return(0);
@@ -83,40 +69,48 @@
 
 int db_insert_segment(segment_t *seg)
 {
-	int tagid;
 	char addquery[MAXQ];
-	tagid= db_insert_tags(seg->base.tag_n,seg->base.tag_p);
+	seg->base.tagid=tagid++;
+	
 
+	if (seg->base.id==0) /* give own id */
+	{
+		printf("ugh, segment id is 0!\n");
+		exit(0);
+	}
 /*	if (seg->base.id==0) / * give own id * /
 		snprintf(addquery,MAXQ,"INSERT INTO segment (layer_id, node_from, node_to, tag_id) VALUES (%d, %d, %d), %d;",
 						(int)seg->base.layerid,				(int)seg->from, (int)seg->to,	tagid );
 	else*/
 		snprintf(addquery,MAXQ,"INSERT INTO segment (layer_id, seg_id, node_from, node_to, tag_id) VALUES (%d, %d, %d, %d, %d);",
-						(int)seg->base.layerid,(int)seg->base.id,(int)seg->from, (int)seg->to,	tagid );
+						(int)seg->base.layerid,(int)seg->base.id,(int)seg->from, (int)seg->to,	(int)seg->base.tagid );
 	db_exec(addquery, NULL, 0);
 
 	return(0);
 }
-int db_insert_way(way_t *way)
+int db_insert_way_only(way_t *way)
 {
-	int tagid,i;
 	char addquery[MAXQ];
-	tagid= db_insert_tags(way->base.tag_n,way->base.tag_p);
-	snprintf(addquery,MAXQ,"INSERT INTO way (layer_id, way_id, tag_id) VALUES (%d, %d, %d);",(int)way->base.layerid, (int)way->base.id, tagid );
+	way->base.tagid= tagid++;
+	snprintf(addquery,MAXQ,"INSERT INTO way (layer_id, way_id, tag_id) VALUES (%d, %d, %d);",(int)way->base.layerid, (int)way->base.id, (int)way->base.tagid );
 	db_exec(addquery, NULL, 0);
-	for (i=0;i<way->seg_n;i++) {
-		snprintf(addquery,MAXQ,"UPDATE segment SET way_id=%d WHERE seg_id=%d AND layer_id=%d;",(int)way->base.id,(int)way->seg_p[i],(int)way->base.layerid );
-		db_exec(addquery, NULL, 0);
-	}
 	return(0);
 }
+
+int db_insert_way_seg(way_t *way, int seg_n)
+{
+	char addquery[MAXQ];
+	snprintf(addquery,MAXQ,"UPDATE segment SET way_id=%d WHERE seg_id=%d AND layer_id=%d;",(int)way->base.id,seg_n,(int)way->base.layerid );
+	db_exec(addquery, NULL, 0);
+	return(0);
+}
 int db_insert_layer(char *layer_name)
 {
 	char findquery[MAXQ];
 	char addquery[MAXQ];
-	char *clayer;
+	char clayer[MAXQ];
 	int layerid=-1;
-	clayer=clean_string(layer_name);
+	clean_string(clayer,layer_name,MAXQ);
 	
 	snprintf(findquery, MAXQ, "SELECT layer_id FROM layer WHERE name='%s';", clayer);
     db_exec(findquery, db_getint, &layerid);
@@ -126,9 +120,9 @@
     	db_exec(addquery, NULL, 0);db_flush();
     	db_exec(findquery, db_getint, &layerid);
 	}
-	free(clayer);
 	return(layerid);
 }
+/*
 int db_insert_object(object_t *obj)
 {
 	if (obj==NULL)
@@ -139,17 +133,31 @@
 	switch (obj->type) {
 		case T_NODE:			return(db_insert_node((node_t *)obj));
 		case T_SEGMENT:			return(db_insert_segment((segment_t *)obj));
-		case T_WAY:				return(	db_insert_way((way_t *)obj));
+		case T_WAY:				return(db_insert_way((way_t *)obj));
 		default:break;
 	}
 	return(-1);
 }
-
+*/
 static int db_getint(void *tagid, int argc, char **argv, char **azColName){
   if (argv[0]!=NULL) 
 	  *((int *)tagid)=atoi(argv[0]);
   return 0;
 }
+static int db_getstr(void *string, int argc, char **argv, char **azColName) {
+	if (argv[0])
+		strncpy((char *)string,argv[0],MAXQ);
+	return(0);
+}
+int db_gettag(int tagid, char *field, char *target)
+{
+	char query[MAXQ];
+	target[0]=0;
+	snprintf(query,MAXQ,"SELECT tagvalue FROM tag WHERE tagkey='%s' AND tag_id=%d;",field,tagid);
+	db_exec(query, db_getstr,target);
+	return(target[0]==0);
+}
+
 int callback(void *NotUsed, int argc, char **argv, char **azColName){
   int i;
   for(i=0; i<argc; i++){

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-10 15:19:13 UTC (rev 524)
+++ trunk/apps/s3dosm/draw.c	2006-12-10 15:19:16 UTC (rev 525)
@@ -43,54 +43,47 @@
 	x[1]=(ESIZE+alt)*			sin(la);
 	x[2]=(ESIZE+alt)*cos(lo) *cos(la);
 }
-void draw_add_vertices(object_t *t, void *data)
+int draw_icon(void *data, int argc, char **argv, char **azColName) 
 {
-	struct vdata *v=data;
-	tag_t *tag;
+	int i,tagid=-1,oid;
+	char s[MAXQ];
+	float la, lo, alt;
+	float x[3];
+	la=lo=alt=0.0;
 	
-	if (t->type==T_NODE)
-	{
-		float x[3];
-		node_t *node=NODE_T(t);
-		node->vid=v->vnum;
-		calc_earth_to_eukl(node->lat,node->lon,0,x);
-		s3d_push_vertex(v->oid,x[0],x[1],x[2]);
-		if (node->visible==2) /* something special */
-		{
-			if (NULL!=(tag=tag_get(OBJECT_T(node), "amenity")))
-			{
-				if (0==(strcmp(tag->v,"wifi")))
-				{
-					tag_t *wtag,*ttag;
-					if (NULL!=(ttag=tag_get(OBJECT_T(node),"wifi_type"))) {
-						if (0==strcmp(ttag->v,"infrastructure"))
-						{	
-							if (NULL!=(wtag=tag_get(OBJECT_T(node), "wifi_wep")))
-								if (0==strcmp(wtag->v,"true"))
-									node->base.oid=s3d_clone(icons[ICON_AP_OPEN].oid);
-								else
-									node->base.oid=s3d_clone(icons[ICON_AP].oid);
-							else
-							node->base.oid=s3d_clone(icons[ICON_AP].oid);
-							s3d_translate(node->base.oid,x[0],x[1],x[2]);
-							s3d_link(node->base.oid,v->oid);
-							s3d_flags_on(node->base.oid,S3D_OF_VISIBLE);
-							s3d_rotate(node->base.oid,(90-node->lat),node->lon,0);
-							v->layer->visible=1;
-						} else { /* not an ap */
-						}
-					}
+	for(i=0; i<argc; i++) {
+		if (argv[i]) {
+			if (0==strcmp(azColName[i],"longitude"))			lo=strtod(argv[i],NULL);
+			else if (0==strcmp(azColName[i],"latitude"))		la=strtod(argv[i],NULL);
+			else if (0==strcmp(azColName[i],"altitude"))		alt=strtod(argv[i],NULL);
+			else if (0==strcmp(azColName[i],"tag_id")) 			tagid=atoi(argv[i]);
+		}
+	}
+	if (0==db_gettag(tagid, "amenity",s)) {
+		oid=-1;
+		if (0==strcmp(s,"wifi")) {					/* some wifi icon */
+			if (0==db_gettag(tagid, "wifi_type",s)) {
+				if (0==strcmp(s,"infrastructure")) {	/* access point */
+					if (0==db_gettag(tagid, "wifi_wep",s)) {
+						if (0==strcmp(s,"true"))	oid=s3d_clone(icons[ICON_AP_WPA].oid);
+						else						oid=s3d_clone(icons[ICON_AP_OPEN].oid);
+					} else oid=s3d_clone(icons[ICON_AP_OPEN].oid);	/* assuming open ap */
 				}
 			}
 		}
-		v->vnum++;
-		v->lonsum+=node->lon;
-		v->latsum+=node->lat;
-		v->n++;
-	}
+		if (oid!=-1) {
+			calc_earth_to_eukl(la,lo,0,x);
+			s3d_translate(oid,x[0],x[1],x[2]);
+			s3d_rotate(oid,(90-la),lo,0);
+			s3d_link(oid,oidy);
+			s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			/* TODO: update database */
+		}
+				
+	} 
+	return(0);
 }
 
-
 static int lastid=-1;
 struct waylist {
 	int node_from,node_to;
@@ -157,7 +150,7 @@
 #define 	V_SUB(a,b,c)	c[0]=a[0]-b[0];	c[1]=a[1]-b[1];	c[2]=a[2]-b[2];
 #define		V_DOT(a,b)		a[0]*b[0] + a[1]*b[1] + a[2] * b[2]
 #define		V_CROSS(a,b,c)	c[0]=a[1]*b[2] - a[2]*b[1];		c[1]=a[2]*b[0] - a[0]*b[2]; 	c[2]=a[0]*b[1] - a[1]*b[0];
-#define		V_LEN(a)		sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]);
+#define		V_LEN(a)		sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2])
 #define		V_SCAL(a,s)		a[0]=s*a[0];	a[1]=s*a[1];	a[2]=s*a[2];
 #define		V_NORM(a)		temp=V_LEN(a); V_SCAL(a,1/temp);
 
@@ -193,7 +186,7 @@
 		case 1:s3d_push_material(way_obj,0.6,0.6,0.6,		1.0,1.0,1.0, 	1.0,1.0,1.0);	/* residential */
 		default:s3d_push_material(way_obj,0.6,0.2,0.6,		1.0,1.0,1.0,	1.0,0.5,1.0); /* default */
 	}
-	street_width=0.5+waytype/10;
+	street_width=(0.5+waytype/10)/RESCALE;
 	/* put nodes of the graph into a list */
 	nodelist_n=0;
 	for (i=0;i<waylist_n*2;i++) {
@@ -206,7 +199,7 @@
 			nodelist_p[j].node_id=node_id;
 			snprintf(query,MAXQ,"SELECT longitude, latitude, altitude FROM node WHERE %s AND node_id=%d;",filter, node_id);
 			db_exec(query, insert_node,(void *)(nodelist_p));
-			calc_earth_to_eukl(nodelist_p[j].la,nodelist_p[j].lo,0+waytype/2,nodelist_p[j].x); /* elevate higher priority streets a little bit ... */
+			calc_earth_to_eukl(nodelist_p[j].la,nodelist_p[j].lo,0,nodelist_p[j].x); /* elevate higher priority streets a little bit ... */
 			len=sqrt(nodelist_p[j].x[0]*nodelist_p[j].x[0] + nodelist_p[j].x[1]*nodelist_p[j].x[1] + nodelist_p[j].x[2]*nodelist_p[j].x[2]);
 			nodelist_p[j].normal[0]=nodelist_p[j].x[0]/len;
 			nodelist_p[j].normal[1]=nodelist_p[j].x[1]/len;
@@ -233,7 +226,7 @@
 				adjlist_n++;
 			}
 		}
-			
+
 		if (adjlist_n>1)	/* more than one adjacent, need to order and calculate intersections */
 		{
 			if (adjlist_n>2) /* no ordering needed for 2 incoming segments */
@@ -276,17 +269,22 @@
 				V_NORM(right);
 				V_CROSS(nodelist_p[i].normal, left ,an);	/* an is also normalized, as first and second argument are already length 1 */
 				V_ADD(left, right, n);						/* direction which our intersection is */
+
+				V_CROSS(nodelist_p[i].normal, n, s);
+				V_CROSS(s, nodelist_p[i].normal, n); /* get n on the plane which is spanned by the points normal */
+
 				n_len=V_LEN(n);
 
-				if (n_len<0.1)
+				V_COPY(s, nodelist_p[i].x);	/* s = P + (street_width/ ( n * an)) * n */
+				V_SCAL(n,1/n_len);	/* normalize n first! */
+				scale=V_DOT(n,an);	/* get cos (alpha/2), alpha is opposite angel of left and right segment */
+
+				if ((n_len<0.1) || (fabs(scale)<0.1))
 				{	/* too low, don't use, just have intersection 90 degree of it. */
 					V_SCAL(an, -street_width);		/* S = P + street_width * an */
 					V_ADD(nodelist_p[i].x, an, s);
 
 				} else {
-					V_COPY(s, nodelist_p[i].x);	/* s = P + (street_width/ ( n * an)) * n */
-					V_SCAL(n,1/n_len);	/* normalize n first! */
-					scale=V_DOT(n,an);	/* get cos (alpha/2), alpha is opposite angel of left and right segment */
 					V_SCAL(n,-street_width/scale);
 					V_ADD(s, n, s);
 				}
@@ -337,13 +335,21 @@
 		}
 	}
 	for (i=0;i<waylist_n;i++) {
-/*		printf("drawing way from points %d %d %d %d\n",waylist_p[i].node_from_l, waylist_p[i].node_to_l, waylist_p[i].node_to_r,waylist_p[i].node_from_r);*/
-		s3d_push_polygon(way_obj, waylist_p[i].node_from_l, waylist_p[i].node_to_l, waylist_p[i].node_to_r, 0);
-		s3d_push_polygon(way_obj, waylist_p[i].node_from_l, waylist_p[i].node_to_r, waylist_p[i].node_from_r, 0);
-		
+		uint32_t	polys[8];
+		/* printf("drawing way from points %d %d %d %d\n",waylist_p[i].node_from_l, waylist_p[i].node_to_l, waylist_p[i].node_to_r,waylist_p[i].node_from_r);*/
+		polys[0]=waylist_p[i].node_from_l;
+		polys[1]=waylist_p[i].node_to_l;
+		polys[2]=waylist_p[i].node_to_r;
+		polys[3]=0;
+		polys[4]=waylist_p[i].node_from_l;
+		polys[5]=waylist_p[i].node_to_r;
+		polys[6]=waylist_p[i].node_from_r;
+		polys[7]=0;
+
+		s3d_push_polygons(way_obj, polys, 2);
 	}
 	s3d_link(way_obj,oidy);
-	s3d_flags_on(way_obj,S3D_OF_VISIBLE);
+	s3d_flags_on(way_obj,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	waylist_n=0;
 }
 void waylist_add(struct waylist *p)
@@ -390,6 +396,13 @@
 		
 	return 0;
 }
+void draw_translate_icon(int user_icon, float la, float lo)
+{
+	float x[3];
+	calc_earth_to_eukl(la,lo,1/RESCALE,x);
+	s3d_translate(user_icon,x[0],x[1],x[2]);
+	s3d_rotate(user_icon,(90-la),lo,0);
+}
 
 void draw_ways(char *filter)
 {
@@ -399,18 +412,23 @@
 	waylist_draw(filter); /* last way */
 	printf("[done]\n");
 }
-void draw_translate_icon(int user_icon, float la, float lo)
-{
-	float x[3];
-	calc_earth_to_eukl(la,lo,0,x);
-	s3d_translate(user_icon,x[0],x[1],x[2]);
-	s3d_rotate(user_icon,(90-la),lo,0);
-}
 void draw_osm()
 {
+	printf("draw_osm()\n");
 	draw_ways("layer_id=(SELECT layer_id FROM layer WHERE name='osm')");
 }
+void draw_kismet()
+{
+	char query[MAXQ];
+	char filter[]="layer_id=(SELECT layer_id FROM layer WHERE name='kismet')";
+	printf("[draw kismet]\n");
+	snprintf(query,MAXQ,"SELECT * FROM node WHERE %s;",filter);
+	db_exec(query, draw_icon,filter);
+	waylist_draw(filter); /* last way */
+	printf("[done]\n");
+}
 void draw_all_layers()
 {
 	draw_osm();
+	draw_kismet();
 }

Modified: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2006-12-10 15:19:13 UTC (rev 524)
+++ trunk/apps/s3dosm/gps.c	2006-12-10 15:19:16 UTC (rev 525)
@@ -120,11 +120,12 @@
 #endif
 	tlat=la;tlon=lo;
 	if (fix) {
+		printf("have a fix\n");
 		nav_center(la,lo);
 		if (!finitef(heading)) {
 			heading=get_heading(lat_old,lon_old,la,lo);
-			if (!lastfix && fix) 		{s3d_scale(user_icon,1.0);}
-			if (lastfix && !fix)		{s3d_scale(user_icon,0.3);lat=tlat;lon=tlon;}
+			if (!lastfix && fix) 		{s3d_scale(user_icon,1.0/RESCALE);}
+			if (lastfix && !fix)		{s3d_scale(user_icon,0.3/RESCALE);lat=tlat;lon=tlon;}
 			if (finitef(heading))		s3d_rotate(user_icon,0,heading,0);
 		}
 		if (finitef(speed)) {
@@ -169,6 +170,7 @@
 	s3d_link(user_icon,user_icon_rotator);
 	s3d_link(user_icon_rotator,oidy); 
 	s3d_flags_on(user_icon,S3D_OF_VISIBLE);
+	s3d_scale(user_icon,1.0/RESCALE);
 	tlat=lat=lat_old=0.0;
 	tlon=lon=lon_old=0.0;
 	gps_active=1;

Modified: trunk/apps/s3dosm/kismet.c
===================================================================
--- trunk/apps/s3dosm/kismet.c	2006-12-10 15:19:13 UTC (rev 524)
+++ trunk/apps/s3dosm/kismet.c	2006-12-10 15:19:16 UTC (rev 525)
@@ -22,55 +22,58 @@
  */
 
 #include "s3dosm.h"
+#include <math.h>			/* fabs() */
 #include <string.h>			/* strcmp() */
 #include <stdlib.h>			/* strtof(),strtod(),strtol() */
 #include <libxml/parser.h>
 #include <libxml/tree.h>
 static int layerid;
-object_t *parse_kismet_node(xmlNodePtr cur)
+void parse_kismet_node(xmlNodePtr cur)
 {
-	node_t *node;
+	node_t node;
 	xmlAttrPtr attr;
 	xmlNodePtr kids,gpskids;
 
-	node=node_new();
+	node_init(&node);
 	attr=cur->properties;
 
-	node->base.layerid=layerid;
-	node->base.id=0;				/* let database decide */
-	for (attr=cur->properties;attr;attr=attr->next)
-	{
-/*		if (0==strcmp((char *)attr->name,"number")) 		node->base.id=		strtol((char *)attr->children->content,NULL,10);
-		else */if (0==strcmp((char *)attr->name,"wep")) 		tag_add(OBJECT_T(node),"wifi_wep",(char *)attr->children->content);
-		else if (0==strcmp((char *)attr->name,"type")) 		tag_add(OBJECT_T(node),"wifi_type",(char *)attr->children->content);
-	}
+	node.base.layerid=layerid;
+	node.base.id=0;				/* let database decide */
+	node.visible=2;	/* something special */
 	for (kids=cur->children;kids;kids=kids->next)
 	{
-		if (0==strcmp((char *)kids->name,"SSID")) 			tag_add(OBJECT_T(node),"wifi_SSID",(char *)xmlNodeGetContent(kids->children));
-		if (0==strcmp((char *)kids->name,"BSSID")) 			tag_add(OBJECT_T(node),"wifi_BSSID",(char *)xmlNodeGetContent(kids->children));
 		if (0==strcmp((char *)kids->name,"gps-info"))
 		{
 			for (gpskids=kids->children;gpskids;gpskids=gpskids->next)
 			{
 				/* get median value */
-				if (0==strcmp((char *)gpskids->name,"min-lat")) 		node->lat=node->lat + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
-				if (0==strcmp((char *)gpskids->name,"max-lat")) 		node->lat=node->lat + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
-				if (0==strcmp((char *)gpskids->name,"min-lon")) 		node->lon=node->lon + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
-				if (0==strcmp((char *)gpskids->name,"max-lon")) 		node->lon=node->lon + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
-				if (0==strcmp((char *)gpskids->name,"min-alt")) 		node->alt=node->alt + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
-				if (0==strcmp((char *)gpskids->name,"max-alt")) 		node->alt=node->alt + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
+				if (0==strcmp((char *)gpskids->name,"min-lat")) 		node.lat=node.lat + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
+				if (0==strcmp((char *)gpskids->name,"max-lat")) 		node.lat=node.lat + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
+				if (0==strcmp((char *)gpskids->name,"min-lon")) 		node.lon=node.lon + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
+				if (0==strcmp((char *)gpskids->name,"max-lon")) 		node.lon=node.lon + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
+				if (0==strcmp((char *)gpskids->name,"min-alt")) 		node.alt=node.alt + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
+				if (0==strcmp((char *)gpskids->name,"max-alt")) 		node.alt=node.alt + strtod((char *)xmlNodeGetContent(gpskids->children),NULL)/2;
 			}
 		}
 	}
-	node->visible=2;	/* something special */
-	tag_add(OBJECT_T(node), "amenity", "wifi");
+	if ((fabs(node.lon)>0.01) || (fabs(node.lat)>0.01)) /* really, i don't want to discriminate anyone at 0 lat 0 lon running a wifi hotspot, even
+																	if it's in the middle of the ocean. i'm very sorry. */
+	{
 
-	if (node->base.id>0 && (node->lon!=0.0) && (node->lat!=0.0)) /* really, i don't want to discriminate anyone at 0 lat 0 lon running a wifi hotspot, even
-																	if it's in the middle of the ocean. i'm very sorry. */
-		return(OBJECT_T(node));
-	else {
-		node_free(node);
-		return(NULL);
+		db_insert_node(&node);
+		for (kids=cur->children;kids;kids=kids->next)
+		{
+			if (0==strcmp((char *)kids->name,"SSID")) 			db_add_tag(OBJECT_T(&node),"wifi_SSID",(char *)xmlNodeGetContent(kids->children));
+			if (0==strcmp((char *)kids->name,"BSSID")) 			db_add_tag(OBJECT_T(&node),"wifi_BSSID",(char *)xmlNodeGetContent(kids->children));
+		}
+		for (attr=cur->properties;attr;attr=attr->next)
+		{
+	/*		if (0==strcmp((char *)attr->name,"number")) 		node->base.id=		strtol((char *)attr->children->content,NULL,10);
+			else */if (0==strcmp((char *)attr->name,"wep")) 	db_add_tag(OBJECT_T(&node),"wifi_wep",(char *)attr->children->content);
+			else if (0==strcmp((char *)attr->name,"type")) 		db_add_tag(OBJECT_T(&node),"wifi_type",(char *)attr->children->content);
+		}
+
+		db_add_tag(OBJECT_T(&node), "amenity", "wifi");
 	}
 }
 
@@ -80,7 +83,6 @@
 	xmlDocPtr doc;
 	xmlNodePtr cur;
 	layer_t *layer=layer_new();
-	object_t *obj;
 	
 
 	doc = xmlReadMemory(buf, length, "noname.xml", NULL, 0);
@@ -102,9 +104,7 @@
 		{
 			if (0==strcmp((char *)cur->name,"wireless-network"))
 			{
-				if (NULL!=(obj=parse_kismet_node(cur)))
-					db_insert_object(obj);
-				else fprintf(stderr,"bad node\n"); 
+				parse_kismet_node(cur);
 			} 
 		}
 	}

Modified: trunk/apps/s3dosm/nav.c
===================================================================
--- trunk/apps/s3dosm/nav.c	2006-12-10 15:19:13 UTC (rev 524)
+++ trunk/apps/s3dosm/nav.c	2006-12-10 15:19:16 UTC (rev 525)
@@ -7,7 +7,8 @@
 
 icon_t icons[ICON_NUM]={
 		{"objs/accesspoint.3ds",0},
-		{"objs/star.3ds",0},
+		{"objs/noinetwep.3ds",0},
+		{"objs/noinetwpa.3ds",0},
 		{"objs/arrow2.3ds",0}
 	};
 int oidx, oidy;
@@ -18,6 +19,7 @@
 	int i;
 	for (i=0;i<ICON_NUM;i++)
 	{
+		printf("loading %s\n",icons[i].path);
 		icons[i].oid=s3d_import_model_file(icons[i].path);
 	}
 }

Modified: trunk/apps/s3dosm/object.c
===================================================================
--- trunk/apps/s3dosm/object.c	2006-12-10 15:19:13 UTC (rev 524)
+++ trunk/apps/s3dosm/object.c	2006-12-10 15:19:16 UTC (rev 525)
@@ -40,6 +40,7 @@
 	nobj->id=0;
 	nobj->oid=-1;
 	nobj->layerid=-1;
+	nobj->tagid=-1;
 	nobj->tag_n=0;
 	nobj->tag_p=NULL;
 	nobj->type=T_OBJECT;

Modified: trunk/apps/s3dosm/osm.c
===================================================================
--- trunk/apps/s3dosm/osm.c	2006-12-10 15:19:13 UTC (rev 524)
+++ trunk/apps/s3dosm/osm.c	2006-12-10 15:19:16 UTC (rev 525)
@@ -30,14 +30,10 @@
 static int layerid;
 int parse_osm_tags(object_t *obj, xmlNodePtr cur)
 {
-	
 	xmlNodePtr c;
 	xmlAttrPtr attr;
 	char *v,*k;
-	tag_t *t;
-	int n;
 	v=k=NULL;
-	n=0;
 	for (c=cur->children;c!=NULL; c=c->next)
 	{
 		if (0==strcmp((char *)c->name,"tag"))	{
@@ -46,158 +42,79 @@
 				if (0==strcmp((char *)attr->name,"k")) 				k=(char *)attr->children->content;
 				else if (0==strcmp((char *)attr->name,"v")) 		v=(char *)attr->children->content;
 			}
-			if (k==NULL || v==NULL)			printf("bad tag!!\n");
-			else 							n++;
-		}
-	}
-	obj->tag_n=n;
-	obj->tag_p=malloc(obj->tag_n*sizeof(tag_t));
-	n=0;
-	for (c=cur->children;c!=NULL; c=c->next)
-	{
-		if (0==strcmp((char *)c->name,"tag"))	{
-			for (attr=c->properties;attr;attr=attr->next)
-			{
-				if (0==strcmp((char *)attr->name,"k")) 				k=(char *)attr->children->content;
-				else if (0==strcmp((char *)attr->name,"v")) 		v=(char *)attr->children->content;
-			}
 			if (k!=NULL && v!=NULL)
-			{
-				t=&(obj->tag_p[n]);
-				t->ttype=TAG_UNKNOWN;
-				t->k=strdup(k);
-				t->v=strdup(v);
-				t->d.s=v;
-				if 		(0==strcmp(k,"name"))	t->ttype=TAG_NAME;
-
-				n++;
-			}
+				db_add_tag(obj, k, v);
 		}
 	}
-
-
-	
 	return(0);
 
 }
-object_t *parse_osm_way(xmlNodePtr cur)
+void parse_osm_way(xmlNodePtr cur)
 {
-	way_t *way;
+	way_t way;
 	xmlNodePtr kids;
 	xmlAttrPtr attr,kattr;
-	int n=0;
+	int seg;
 
-	way=way_new();
+	way_init(&way);
 	
-	way->base.layerid=layerid;
+	way.base.layerid=layerid;
 	for (attr=cur->properties;attr;attr=attr->next)
-		if (0==strcmp((char *)attr->name,"id")) 			way->base.id=	strtol((char *)attr->children->content,NULL,10);
-	/* count segments */
+		if (0==strcmp((char *)attr->name,"id")) 			way.base.id=	strtol((char *)attr->children->content,NULL,10);
+	db_insert_way_only(&way);
+	parse_osm_tags(OBJECT_T(&way),cur);
 	for (kids=cur->children;kids!=NULL;kids=kids->next)
 	{
-		if (0==strcmp((char *)kids->name,"seg"))			n++;
-	}
-	/* add segments in segment buffer */
-	if (n>0)
-	{
-		way->seg_n=n;
-		way->seg_p=malloc(sizeof(ID_T)*n);
-		n=0;
-		for (kids=cur->children;kids!=NULL;kids=kids->next)
-		{
-			if (0==strcmp((char *)kids->name,"seg"))	{
-				for (kattr=kids->properties;kattr;kattr=kattr->next)
-					if (0==strcmp((char *)kattr->name,"id")) 			way->seg_p[n]=	strtol((char *)kattr->children->content,NULL,10);
-				n++;
-			}
+		if (0==strcmp((char *)kids->name,"seg"))	{
+			seg=-1;
+			for (kattr=kids->properties;kattr;kattr=kattr->next)
+				if (0==strcmp((char *)kattr->name,"id")) 			seg=	strtol((char *)kattr->children->content,NULL,10);
+			db_insert_way_seg(&way,seg);
 		}
 	}
-
-	parse_osm_tags(OBJECT_T(way),cur);
-	if (way->base.id>0)
-		return(OBJECT_T(way));
-	else {
-		way_free(way);
-		return(NULL);
-	}
 }
-object_t *parse_osm_segment(xmlNodePtr cur)
+void parse_osm_segment(xmlNodePtr cur)
 {
-	segment_t *segment;
+	segment_t segment;
 	xmlAttrPtr attr;
 
-	segment=segment_new();
+	segment_init(&segment);
 	
-	segment->base.layerid=layerid;
+	segment.base.layerid=layerid;
 	for (attr=cur->properties;attr;attr=attr->next)
 	{
 		
-		if (0==strcmp((char *)attr->name,"id")) 			segment->base.id=	strtol((char *)attr->children->content,NULL,10);
-		else if (0==strcmp((char *)attr->name,"from")) 		segment->from=		strtod((char *)attr->children->content,NULL);
-		else if (0==strcmp((char *)attr->name,"to")) 		segment->to=		strtod((char *)attr->children->content,NULL);
+		if (0==strcmp((char *)attr->name,"id")) 			segment.base.id=	strtol((char *)attr->children->content,NULL,10);
+		else if (0==strcmp((char *)attr->name,"from")) 		segment.from=		strtod((char *)attr->children->content,NULL);
+		else if (0==strcmp((char *)attr->name,"to")) 		segment.to=			strtod((char *)attr->children->content,NULL);
 	}
-	parse_osm_tags(OBJECT_T(segment),cur);
-	if ((segment->base.id>0) && (segment->from>0) && (segment->to>0))
-		return(OBJECT_T(segment));
-	else {
-		segment_free(segment);
-		return(NULL);
+	if ((segment.base.id>0) && (segment.from>0) && (segment.to>0)) {
+		db_insert_segment(&segment);
+		parse_osm_tags(OBJECT_T(&segment),cur);
 	}
 }
-object_t *parse_osm_node(xmlNodePtr cur)
+void parse_osm_node(xmlNodePtr cur)
 {
-	node_t *node;
+	node_t node;
 	xmlAttrPtr attr;
 
-	node=node_new();
+	node_init(&node);
 	attr=cur->properties;
 	
-	node->base.layerid=layerid;
+	node.base.layerid=layerid;
 	for (attr=cur->properties;attr;attr=attr->next)
 	{
-		if (0==strcmp((char *)attr->name,"id")) 			node->base.id=		strtol((char *)attr->children->content,NULL,10);
-		else if (0==strcmp((char *)attr->name,"lat")) 		node->lat=			strtod((char *)attr->children->content,NULL);
-		else if (0==strcmp((char *)attr->name,"lon")) 		node->lon=			strtod((char *)attr->children->content,NULL);
-		else if (0==strcmp((char *)attr->name,"visible")) 	node->visible=		(0==strcmp((char *)attr->children->content,"true"))?1:0;
+		if (0==strcmp((char *)attr->name,"id")) 			node.base.id=		strtol((char *)attr->children->content,NULL,10);
+		else if (0==strcmp((char *)attr->name,"lat")) 		node.lat=			strtod((char *)attr->children->content,NULL);
+		else if (0==strcmp((char *)attr->name,"lon")) 		node.lon=			strtod((char *)attr->children->content,NULL);
+		else if (0==strcmp((char *)attr->name,"visible")) 	node.visible=		(0==strcmp((char *)attr->children->content,"true"))?1:0;
 		else if (0==strcmp((char *)attr->name,"time")) {}	/* TODO */
 	}
-	parse_osm_tags(OBJECT_T(node),cur);
-	if (node->base.id>0)
-		return(OBJECT_T(node));
-	else {
-		node_free(node);
-		return(NULL);
+	if (node.base.id>0) {
+		db_insert_node(&node);
+		parse_osm_tags(OBJECT_T(&node),cur);
 	}
 }
-
-void debug_obj(object_t *obj, void *dummy)
-{
-	int i;
-	way_t *way=WAY_T(obj);
-	node_t *node=NODE_T(obj);
-	segment_t *seg=SEGMENT_T(obj);
-	switch (obj->type)
-	{
-		case T_OBJECT:
-				printf("object %d\n",(int)obj->id);
-				break;
-		case T_NODE:
-				 printf("node %d [%f,%f,%f]\n",(int)obj->id,node->lon,node->lat,node->alt);
-				 break;
-		case T_SEGMENT:
-				 printf("segment %d [%d->%d]\n",(int)obj->id,(int)seg->from,(int)seg->to);
-				 break;
-		case T_WAY:
-				 printf("way %d [ ",(int)obj->id);
-				 for (i=0;i<way->seg_n;i++)
-					printf("%d ",(int)way->seg_p[i]);
-				 printf("]\n");
-				 break;
-				 
-	}
-	for (i=0;i<obj->tag_n;i++)
-		printf("tag %d: %s -> %s\n",i,obj->tag_p[i].k,obj->tag_p[i].v);
-}
 /* parse the osm input file */
 layer_t *parse_osm(char *buf, int length)
 {
@@ -226,13 +143,9 @@
 		if (cur->type==XML_ELEMENT_NODE)
 		{
 			obj=NULL;
-			if (0==strcmp((char *)cur->name,"node"))				obj=parse_osm_node(cur);
-			else if (0==strcmp((char *)cur->name,"segment"))		obj=parse_osm_segment(cur);
-			else if (0==strcmp((char *)cur->name,"way"))			obj=parse_osm_way(cur);
-			if (obj!=NULL)
-				db_insert_object(obj);
-			else
-				fprintf(stderr,"bad object\n");
+			if (0==strcmp((char *)cur->name,"node"))				parse_osm_node(cur);
+			else if (0==strcmp((char *)cur->name,"segment"))		parse_osm_segment(cur);
+			else if (0==strcmp((char *)cur->name,"way"))			parse_osm_way(cur);
 			if ((i++)%100==0) {printf(".");fflush(stdout);}
 		}
 	}

Modified: trunk/apps/s3dosm/s3dosm.h
===================================================================
--- trunk/apps/s3dosm/s3dosm.h	2006-12-10 15:19:13 UTC (rev 524)
+++ trunk/apps/s3dosm/s3dosm.h	2006-12-10 15:19:16 UTC (rev 525)
@@ -1,7 +1,7 @@
 #include <sqlite3.h>
 #include "../../config.h"
 #define	ESIZE	637800		/* earth size */
-#define	RESCALE	0.5
+#define	RESCALE	1
 #define VIEWHEIGHT 3
 #define MAXQ	4096	
 #define QBUF	1024*128
@@ -46,8 +46,9 @@
 	T_WAY
 };
 enum {
-	ICON_AP,
 	ICON_AP_OPEN,
+	ICON_AP_WEP,
+	ICON_AP_WPA,
 	ICON_ARROW,
 	ICON_NUM
 };
@@ -72,6 +73,7 @@
 struct _object_t {
 	ID_T 		 id;		/* id of this object */
 	ID_T		 layerid;
+	ID_T		 tagid;
 	int 		 oid;		/* s3d oid */
 	int 		 type;		/* type of this object */
 	/* avl stuff */
@@ -152,9 +154,12 @@
 int process_args(int argc, char **argv);
 /* db.c */
 int db_exec(const char *query, sqlite3_callback callback, void *arg);
+int db_add_tag(object_t *obj, char *key, char *val);
+int db_gettag(int tagid, char *field, char *target);
 int db_insert_node(node_t *node);
 int db_insert_segment(segment_t *seg);
-int db_insert_way(way_t *way);
+int db_insert_way_only(way_t *way);
+int db_insert_way_seg(way_t *way, int seg_n);
 int db_insert_object(object_t *obj);
 int db_init(char *dbFile);
 int db_quit();



From dotslash at mail.berlios.de  Sun Dec 10 22:05:06 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 10 Dec 2006 22:05:06 +0100
Subject: [S3d-svn] r526 - in trunk: . apps/s3dosm
Message-ID: <200612102105.kBAL5669026174@sheep.berlios.de>

Author: dotslash
Date: 2006-12-10 22:05:06 +0100 (Sun, 10 Dec 2006)
New Revision: 526

Added:
   trunk/apps/s3dosm/bbbikepol_to_osm.pl
Modified:
   trunk/
Log:
 r1269 at kero:  dotslash | 2006-12-10 22:05:01 +0100
 - bbbike to osm converter (watchout, perl!)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1265
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1269

Added: trunk/apps/s3dosm/bbbikepol_to_osm.pl
===================================================================
--- trunk/apps/s3dosm/bbbikepol_to_osm.pl	2006-12-10 15:19:16 UTC (rev 525)
+++ trunk/apps/s3dosm/bbbikepol_to_osm.pl	2006-12-10 21:05:06 UTC (rev 526)
@@ -0,0 +1,99 @@
+#!/usr/bin/env perl
+#
+# 
+# Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
+#
+# This file is part of s3dosm, a gps card application for s3d.
+# See http://s3d.berlios.de/ for more updates.
+# 
+# s3dosm is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# s3dosm is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with s3dosm; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#
+#
+# takes a bbbike[1] streetfile as input and converts it to some osm xml file format.
+# 
+# bbbike files are usually not in polar coordinate format, you will have to convert them first, e.g.
+# like this (from within your local bbbike checkout): 
+#
+#  perl ./miscsrc/convert_coordsys standard polar < data/strassen > /tmp/strassen.polar
+#
+#  [1]:	bbbike is the free Berlin bike map system: http://bbbike.sourceforge.net/
+#  		use the cvs download from sourceforge to retrieve the scripts and data.
+#  
+use Switch;
+$created_by="dotslashs crufty bbbike converter";
+$node_string="";
+$seg_string="";
+$way_string="";
+$id=1;
+( $sec, $min, $hour, $day, $month, $year ) = ( localtime ) [ 0, 1, 2, 3, 4, 5 ];
+%translate = ("HH","primary","H","secondary","N","residential", "NN","residential");
+$timestamp =sprintf("%04d-%02d-%02d %02d:%02d:%02d",1900+$year,$month,$day, $hour,$min,$sec);
+print "<?xml version='1.0' encoding='UTF-8'?>\n";
+print "<osm version='0.3' generator='$created_by'>\n";
+
+while (<>) {
+	if (/^\#/) {
+		next;
+	}
+	@array=split(/\t/,$_);
+	$name=$array[0];
+	$name=~ s/\'//eg;	# remove bad '
+	$name=~ s/([\x80-\xFF])/chr(0xC0|ord($1)>>6).chr(0x80|ord($1)&0x3F)/eg;	#latin1 -> utf8
+	($type, @coords)=split(/[\s]/,$array[1]);
+#		$type=shift(@coords);			# actually the first entry isn't some coord .. 	
+	if ($type eq"Pl") {	
+		($lo, $la)=split(/,/,$coords[0]);
+		$node_string.=" <node id='$id' timestamp='$timestamp' lat='$la' lon='$lo'>\n";
+		$node_string.="   <tag k='created_by' v='$created_by' />\n";
+		$node_string.="   <tag k='amenity' v='foo' />\n";
+		$node_string.="   <tag k='name' v='$name' />\n";
+		$node_string.=" </node>\n";
+			$id++;
+	} else {
+		@nodeid=(0,0);
+		@segs=();
+		foreach (@coords) {
+			($lo, $la)=split(/,/,$_);
+			$node_string.=" <node id='$id' timestamp='$timestamp' lat='$la' lon='$lo' />\n";
+			$nodeid[1]=$nodeid[0];
+			$nodeid[0]=$id;
+			$id++;
+			if ($nodeid[1]>0) {
+				$seg_string.=" <segment id='$id' from='".$nodeid[1]."' to='".$nodeid[0]."' />\n";
+				push(@segs,$id);
+				$id++;
+			}
+			
+		}
+		
+		$way_string.=" <way id='$id' timestamp='$timestamp'>\n";
+		foreach (@segs) {	$way_string.="   <seg id='$_' />\n";	}
+		$way_string.="   <tag k='name' v='$name' />\n";
+		$way_string.="   <tag k='motorcar' v='yes' />\n";
+		$way_string.="   <tag k='bicycle' v='yes' />\n";
+		$way_string.="   <tag k='foot' v='yes' />\n";
+		$way_string.="   <tag k='class' v='motorway' />\n";
+		$way_string.="   <tag k='highway' v='".$translate{$type}."' />\n";
+		$way_string.="   <tag k='created_by' v='$created_by' />\n";
+
+		$way_string.=" </way>\n";
+	}
+} 
+
+print $node_string;
+print $seg_string;
+print $way_string;
+print "</osm>\n";


Property changes on: trunk/apps/s3dosm/bbbikepol_to_osm.pl
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + text/script



From dotslash at mail.berlios.de  Mon Dec 11 17:22:14 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 11 Dec 2006 17:22:14 +0100
Subject: [S3d-svn] r527 - in trunk: libs3d server
Message-ID: <200612111622.kBBGMEOu021218@sheep.berlios.de>

Author: dotslash
Date: 2006-12-11 17:22:13 +0100 (Mon, 11 Dec 2006)
New Revision: 527

Modified:
   trunk/libs3d/modelread.c
   trunk/server/graphics.c
Log:
- fix object->faces==NULL bug in modelreader
- change shininess to 20

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2006-12-10 21:05:06 UTC (rev 526)
+++ trunk/libs3d/modelread.c	2006-12-11 16:22:13 UTC (rev 527)
@@ -160,7 +160,11 @@
 
 
 
-			oface = object->faces;
+			if (NULL==(oface = object->faces)) {
+				voff += object->vertex_count; /* increase vertex offset */
+				oitem = oitem->next;
+				continue;
+			}
 			npoly=0;
 			oldflags = ((G3DFace *) (oface->data))->flags;
 

Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2006-12-10 21:05:06 UTC (rev 526)
+++ trunk/server/graphics.c	2006-12-11 16:22:13 UTC (rev 527)
@@ -347,7 +347,7 @@
 	t_mtrx m;
 	GLfloat pos[]={0,50,50,1.0};
 	GLfloat light0_spec[]={0.7,0.7,0.7,0.0};
-	GLfloat light0_shininess[] ={50.0};
+	GLfloat light0_shininess[] ={10.0};
 	GLfloat light0_diff[]={0.5,0.5,0.5,1.0};
 	GLfloat light0_amb[]={1.0,1.0,1.0,1.0};
 	



From dotslash at mail.berlios.de  Mon Dec 11 17:36:35 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 11 Dec 2006 17:36:35 +0100
Subject: [S3d-svn] r528 - trunk/server
Message-ID: <200612111636.kBBGaZeT023018@sheep.berlios.de>

Author: dotslash
Date: 2006-12-11 17:36:35 +0100 (Mon, 11 Dec 2006)
New Revision: 528

Modified:
   trunk/server/graphics.c
Log:
- set shininess to same sound value

Modified: trunk/server/graphics.c
===================================================================
--- trunk/server/graphics.c	2006-12-11 16:22:13 UTC (rev 527)
+++ trunk/server/graphics.c	2006-12-11 16:36:35 UTC (rev 528)
@@ -49,7 +49,7 @@
 
 int graphics_init ()
 {
-	GLfloat shin[]={1.0};
+	GLfloat shin[]={16.0};
 	switch (frame_mode)
 	{
 #ifdef G_SDL
@@ -347,7 +347,7 @@
 	t_mtrx m;
 	GLfloat pos[]={0,50,50,1.0};
 	GLfloat light0_spec[]={0.7,0.7,0.7,0.0};
-	GLfloat light0_shininess[] ={10.0};
+	GLfloat light0_shininess[] ={1.0};
 	GLfloat light0_diff[]={0.5,0.5,0.5,1.0};
 	GLfloat light0_amb[]={1.0,1.0,1.0,1.0};
 	



From dotslash at mail.berlios.de  Mon Dec 11 17:58:40 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 11 Dec 2006 17:58:40 +0100
Subject: [S3d-svn] r529 - in trunk: . apps/s3dosm
Message-ID: <200612111658.kBBGweor026194@sheep.berlios.de>

Author: dotslash
Date: 2006-12-11 17:58:39 +0100 (Mon, 11 Dec 2006)
New Revision: 529

Modified:
   trunk/
   trunk/apps/s3dosm/db.c
   trunk/apps/s3dosm/draw.c
Log:
 r1275 at kero:  dotslash | 2006-12-11 17:58:33 +0100
 - debug output "+" for drawing streets
 - some hopefully useful indices



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1269
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1275

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2006-12-11 16:36:35 UTC (rev 528)
+++ trunk/apps/s3dosm/db.c	2006-12-11 16:58:39 UTC (rev 529)
@@ -231,11 +231,14 @@
 }
 int db_create()
 {
-	db_exec("CREATE TABLE node (layer_id INT, node_id INTEGER PRIMARY KEY, latitude DOUBLE PRECISION, longitude DOUBLE PRECISION, altitude DOUBLE PRECISION, visible BOOLEAN, tag_id INT, UNIQUE(layer_id,node_id));",NULL,0);
-	db_exec("CREATE TABLE segment (layer_id INT, seg_id INTEGER PRIMARY KEY, node_from INT, node_to INT, tag_id INT, way_id INT,UNIQUE(layer_id,seg_id));", NULL, 0);
-	db_exec("CREATE TABLE way (layer_id INTEGER, way_id INTEGER PRIMARY KEY, tag_id INT, UNIQUE(layer_id,way_id));", NULL, 0);
-	db_exec("CREATE TABLE layer (layer_id INTEGER PRIMARY KEY, name TEXT, UNIQUE(layer_id));", NULL, 0);
-	db_exec("CREATE TABLE tag (tag_id INT, tagkey TEXT, tagvalue TEXT);", NULL, 0);
+	db_exec("CREATE TABLE node (layer_id INT, node_id INTEGER , latitude DOUBLE PRECISION, longitude DOUBLE PRECISION, altitude DOUBLE PRECISION, visible BOOLEAN, tag_id INT, PRIMARY KEY(layer_id,node_id));",NULL,0);
+	db_exec("CREATE TABLE segment (layer_id INT, seg_id INTEGER, node_from INT, node_to INT, tag_id INT, way_id INT,PRIMARY KEY(layer_id,seg_id));", NULL, 0);
+	db_exec("CREATE TABLE way (layer_id INTEGER, way_id INTEGER, tag_id INT, PRIMARY KEY(layer_id,way_id));", NULL, 0);
+	db_exec("CREATE TABLE layer (layer_id INTEGER, name TEXT, PRIMARY KEY(layer_id));", NULL, 0);
+	db_exec("CREATE TABLE tag (tag_id INT, tagkey TEXT, tagvalue TEXT, PRIMARY KEY(tag_id, tagkey));", NULL, 0);
+	
+	db_exec("CREATE UNIQUE INDEX node_id_index ON node (node_id,layer_id);", NULL, 0);
+	db_exec("CREATE UNIQUE INDEX segment_id_index ON segment (seg_id,layer_id);", NULL, 0);
 	db_flush();
 	return(0);
 }

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-11 16:36:35 UTC (rev 528)
+++ trunk/apps/s3dosm/draw.c	2006-12-11 16:58:39 UTC (rev 529)
@@ -351,6 +351,8 @@
 	s3d_link(way_obj,oidy);
 	s3d_flags_on(way_obj,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	waylist_n=0;
+	printf("+");
+	fflush(stdout);
 }
 void waylist_add(struct waylist *p)
 {



From dotslash at mail.berlios.de  Mon Dec 11 18:03:35 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Mon, 11 Dec 2006 18:03:35 +0100
Subject: [S3d-svn] r530 - in trunk: . apps/s3dosm
Message-ID: <200612111703.kBBH3Z7b027022@sheep.berlios.de>

Author: dotslash
Date: 2006-12-11 18:03:34 +0100 (Mon, 11 Dec 2006)
New Revision: 530

Modified:
   trunk/
   trunk/apps/s3dosm/db.c
Log:
 r1277 at kero:  dotslash | 2006-12-11 18:03:32 +0100
 - don't use the indices, good primary keys are enough



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1275
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1277

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2006-12-11 16:58:39 UTC (rev 529)
+++ trunk/apps/s3dosm/db.c	2006-12-11 17:03:34 UTC (rev 530)
@@ -237,8 +237,11 @@
 	db_exec("CREATE TABLE layer (layer_id INTEGER, name TEXT, PRIMARY KEY(layer_id));", NULL, 0);
 	db_exec("CREATE TABLE tag (tag_id INT, tagkey TEXT, tagvalue TEXT, PRIMARY KEY(tag_id, tagkey));", NULL, 0);
 	
+	/*
 	db_exec("CREATE UNIQUE INDEX node_id_index ON node (node_id,layer_id);", NULL, 0);
 	db_exec("CREATE UNIQUE INDEX segment_id_index ON segment (seg_id,layer_id);", NULL, 0);
+	db_exec("CREATE UNIQUE INDEX tag_id_index ON tag (tag_id,tagkey);", NULL, 0);
+	*/
 	db_flush();
 	return(0);
 }



From dotslash at mail.berlios.de  Thu Dec 14 18:45:49 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 14 Dec 2006 18:45:49 +0100
Subject: [S3d-svn] r531 - trunk/server
Message-ID: <200612141745.kBEHjnn9017540@sheep.berlios.de>

Author: dotslash
Date: 2006-12-14 18:45:48 +0100 (Thu, 14 Dec 2006)
New Revision: 531

Modified:
   trunk/server/global.h
   trunk/server/graphics_glut.c
   trunk/server/graphics_sdl.c
   trunk/server/network.c
   trunk/server/shm.c
Log:
- adding SDL_SetTimer() call to interrupt endless reading-and-refilling loops

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2006-12-11 17:03:34 UTC (rev 530)
+++ trunk/server/global.h	2006-12-14 17:45:48 UTC (rev 531)
@@ -210,6 +210,9 @@
 int n_readn(struct t_process *p, uint8_t *str,int s);
 int n_writen(struct t_process *p, uint8_t *str,int s);
 int n_remove(struct t_process *p);
+#ifdef G_SDL
+int	net_turn_off(int interval);
+#endif
 /* tcp.c */
 int tcp_init(void);
 int tcp_quit(void);

Modified: trunk/server/graphics_glut.c
===================================================================
--- trunk/server/graphics_glut.c	2006-12-11 17:03:34 UTC (rev 530)
+++ trunk/server/graphics_glut.c	2006-12-14 17:45:48 UTC (rev 531)
@@ -29,6 +29,7 @@
 #include <stdio.h>		/* NULL */
 #include <GL/glut.h> 	 /*  all the glut functions */
 #include <GL/gl.h>		 /*  of course, the gl header */
+#include <stdlib.h>		/* atexit() */
 /*  glut version of graphics init ... */
 int graphics_init_glut()
 {

Modified: trunk/server/graphics_sdl.c
===================================================================
--- trunk/server/graphics_sdl.c	2006-12-11 17:03:34 UTC (rev 530)
+++ trunk/server/graphics_sdl.c	2006-12-14 17:45:48 UTC (rev 531)
@@ -37,7 +37,7 @@
 	s3dprintf(MED,"Using SDL driver ...");
 	
     SDLFlags = SDL_OPENGL | SDL_GL_DOUBLEBUFFER | SDL_HWPALETTE | SDL_RESIZABLE;
-    if (SDL_Init(SDL_INIT_VIDEO) < 0)  		
+    if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER) < 0)  		
 			errsf("SDL_Init()",SDL_GetError());
     if ((VideoInfo = (SDL_VideoInfo *)SDL_GetVideoInfo())==NULL)
 			errs("SDL_GetVIdeoInfo()",SDL_GetError());

Modified: trunk/server/network.c
===================================================================
--- trunk/server/network.c	2006-12-11 17:03:34 UTC (rev 530)
+++ trunk/server/network.c	2006-12-14 17:45:48 UTC (rev 531)
@@ -28,6 +28,9 @@
 #include <errno.h>		 /*  errno() */
 #include <unistd.h>		/* close(), read(),write() */
 #include <signal.h>		/* SIGPIPE,SIG_ERR,SIGIO */
+#ifdef G_SDL
+#include <SDL.h>	/* SDL_SetTimer() */
+#endif
 #ifdef SIGS
   #include <signal.h>	 /*  sighandler_t SIG_PIPE */
 #endif
@@ -78,6 +81,14 @@
 #endif
    return(0);
 }
+int					 turn;
+int	net_turn_off(int interval)
+{
+	s3dprintf(HIGH,"Warning: High traffic on Network, interrupting read.");
+	turn=0;
+	return(0);
+}
+
 /*  this basicly polls for new connection */
 int network_main()
 {
@@ -87,7 +98,14 @@
 	{
 #endif
 		tcp_pollport();	/*  this polls for new processes */
-		while (tcp_pollproc());  /*  if there is new data, loop please. this is for testing now, and should be combined with timing later .. */
+#ifdef G_SDL
+		SDL_SetTimer(50,(SDL_TimerCallback) net_turn_off);
+#endif
+		while (turn && tcp_pollproc());  /*  if there is new data, loop please. this is for testing now, and should be combined with timing later .. */
+#ifdef G_SDL
+		SDL_SetTimer(0,NULL);
+#endif
+
 #ifdef SIGS
 		sigio=0;
 #endif

Modified: trunk/server/shm.c
===================================================================
--- trunk/server/shm.c	2006-12-11 17:03:34 UTC (rev 530)
+++ trunk/server/shm.c	2006-12-14 17:45:48 UTC (rev 531)
@@ -23,6 +23,9 @@
 
 
 #include "global.h"
+#ifdef G_SDL
+#include <SDL.h>	/* SDL_SetTimer() */
+#endif
 #ifdef SHM
 #include <stdio.h>  /* printf(),fopen(),fclose() */
 #include <unistd.h>	/* unlink(),usleep() */
@@ -38,6 +41,7 @@
 #include <sys/types.h>
 #include <sys/ipc.h>
 #include <sys/shm.h>
+#include <time.h>	/* nanosleep() */
 
 extern uint8_t ibuf[MAXPLEN];
 extern struct t_process *procs_p;
@@ -166,6 +170,8 @@
 		errn("shm_quit():shmctl()",errno);
 	return(0);
 }
+
+extern int	turn;	/* set turn to 0 when timeslice is over */
 int shm_main()
 {
 	int 				 i/*,found*/;
@@ -174,8 +180,12 @@
 	struct shmid_ds		 d;
 /*	do*/ {
 /*		found=0;*/
+		turn=1;
 		for (i=0;i<procs_n;i++)
 		{
+#ifdef G_SDL
+			SDL_SetTimer(20,(SDL_TimerCallback) net_turn_off);
+#endif
 			if (procs_p[i].con_type==CON_SHM)
 			{
 				dai=(struct buf_t *) procs_p[i].shmsock.data_ctos;
@@ -184,7 +194,10 @@
 /*					found=1;*/
 					procs_p[i].shmsock.idle=0;
 					shm_prot_com_in(&procs_p[i]);
-					i--; /* evil hack: decrease i so it will be our turn again in the next round */
+					if (turn)
+						i--; /* evil hack: decrease i so it will be our turn again in the next round */
+					else
+						turn=1; /* don't decrease, it's next connections turn */
 				} else {
 					if (procs_p[i].shmsock.idle++>MAX_IDLE)
 					{ /* maybe the function timed out somehow ...? let's check ...*/
@@ -200,6 +213,9 @@
 				}
 			}
 		}
+#ifdef G_SDL
+		SDL_SetTimer(0,NULL);
+#endif
 	} /*while (found);*/
 	if ((data[0]==0) && (data[1]==0))
 	{
@@ -231,7 +247,8 @@
 	}
 	return(0);
 }
-#define SHM_MAXLOOP		10000
+#define SHM_MAXLOOP		20
+static	struct timespec t={0,1000*1000}; /* 1 mili seconds */
 int shm_writen(struct buf_t *rb,uint8_t *buf, int n)
 {
 	int no_left,no_written,wait=0;
@@ -247,7 +264,8 @@
 		{
 			s3dprintf(HIGH,"shm_writen():waited too long ...");
 			return(-1);
-		}
+		} 
+		if (wait>10)		nanosleep(&t,NULL); 	
 	}
 	return(n - no_left);
 }
@@ -269,6 +287,7 @@
 			s3dprintf(HIGH,"shm_readn():waited too long ...");
 			return(-1);
 		}
+		if (wait>10)		nanosleep(&t,NULL); 	
 	}
 	return(n - no_left);
 }



From dotslash at mail.berlios.de  Thu Dec 14 18:48:40 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 14 Dec 2006 18:48:40 +0100
Subject: [S3d-svn] r532 - in trunk: apps/s3dosm libs3d
Message-ID: <200612141748.kBEHmeFt025006@sheep.berlios.de>

Author: dotslash
Date: 2006-12-14 18:48:38 +0100 (Thu, 14 Dec 2006)
New Revision: 532

Modified:
   trunk/apps/s3dosm/gps.c
   trunk/libs3d/shm.c
Log:
- adjust sleeptime in client to a more sane value
- fix heading usage in s3dosm (but it still seems broken)

Modified: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2006-12-14 17:45:48 UTC (rev 531)
+++ trunk/apps/s3dosm/gps.c	2006-12-14 17:48:38 UTC (rev 532)
@@ -126,8 +126,8 @@
 			heading=get_heading(lat_old,lon_old,la,lo);
 			if (!lastfix && fix) 		{s3d_scale(user_icon,1.0/RESCALE);}
 			if (lastfix && !fix)		{s3d_scale(user_icon,0.3/RESCALE);lat=tlat;lon=tlon;}
-			if (finitef(heading))		s3d_rotate(user_icon,0,heading,0);
 		}
+		if (finitef(heading))		s3d_rotate(user_icon,0,heading,0); /* wrong rotation? */
 		if (finitef(speed)) {
 			/* print some information */
 			snprintf(buf,BUFSIZE,"speed: %3.2f km/h",speed*3.6);

Modified: trunk/libs3d/shm.c
===================================================================
--- trunk/libs3d/shm.c	2006-12-14 17:45:48 UTC (rev 531)
+++ trunk/libs3d/shm.c	2006-12-14 17:48:38 UTC (rev 532)
@@ -34,13 +34,12 @@
 #ifdef SHM
 
 #define SHM_SIZE 		sizeof(key_t)*2  		/* space for the keys */
-#define SHM_MAXLOOP		10000
+#define SHM_MAXLOOP		100
 #define RB_STD_SIZE		1024*512
-
 static struct buf_t *data_in,*data_out;
 static int shmid_in, shmid_out;
 static int shm_idle=0;
-struct timespec t={0,1*1000}; /* 1 micro second */
+struct timespec t={0,1000*1000}; /* 1 mili second */
 /* char ftoken[]="/tmp/.s3d_shm";*/
 
 int _shm_init(char *ftoken)



From dotslash at mail.berlios.de  Fri Dec 15 13:40:52 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Fri, 15 Dec 2006 13:40:52 +0100
Subject: [S3d-svn] r533 - trunk/apps/s3dosm
Message-ID: <200612151240.kBFCeqq8003513@sheep.berlios.de>

Author: dotslash
Date: 2006-12-15 13:40:52 +0100 (Fri, 15 Dec 2006)
New Revision: 533

Modified:
   trunk/apps/s3dosm/draw.c
Log:
- use proper zeropoints for ways to prevent big bounding spheres and therefore long picking latencies

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-14 17:48:38 UTC (rev 532)
+++ trunk/apps/s3dosm/draw.c	2006-12-15 12:40:52 UTC (rev 533)
@@ -169,6 +169,7 @@
 	float an[3];		/* normal on the plane, orthogonal on the right side of the left segment */
 	float n[3];			/* the direction vector in which the intersecion should be placed */
 	float s[3];			/* intersection point */
+	float point_zero[3]; /* we use point_zero so we don't have very big bounding spheres in s3d and speed up picking */
 	float n_len,scale;
 
 /*	printf("way: %d - %d segments\n",lastid,waylist_n);*/
@@ -209,6 +210,7 @@
 		if (i%2)				waylist_p[i/2].node_from_int=j;
 		else					waylist_p[i/2].node_to_int=j;
 	}
+	V_COPY(point_zero, nodelist_p[0].x);
 	/* iterate for all nodes */
 	for (i=0;i<nodelist_n;i++)
 	{
@@ -291,6 +293,7 @@
 				
 				
 /*				printf("calc intersection: %3.3f %3.3f %3.3f\n",s[0],s[1],s[2]);*/
+			V_SUB(s,point_zero,s);
 				s3d_push_vertices(way_obj,s,1);
 				adj_seg=adjlist_p[j].seg_id;				/* left segment */
 				if (i==waylist_p[adj_seg].node_from_int)	waylist_p[adj_seg].node_from_r=vert;
@@ -314,12 +317,14 @@
 
 			V_COPY(s,nodelist_p[i].x);
 			V_ADD(s,an,s);
+			V_SUB(s,point_zero,s); 
 			s3d_push_vertices(way_obj,s,1);
 			j=vert;
 			vert++;
 			V_SCAL(an,-1);
 			V_COPY(s,nodelist_p[i].x);
 			V_ADD(s,an,s);
+			V_SUB(s,point_zero,s);
 			s3d_push_vertices(way_obj,s,1);
 			k=vert;
 			vert++;
@@ -348,6 +353,7 @@
 
 		s3d_push_polygons(way_obj, polys, 2);
 	}
+	s3d_translate(way_obj,point_zero[0], point_zero[1], point_zero[2]); 
 	s3d_link(way_obj,oidy);
 	s3d_flags_on(way_obj,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	waylist_n=0;



From dotslash at mail.berlios.de  Sat Dec 16 11:54:33 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 16 Dec 2006 11:54:33 +0100
Subject: [S3d-svn] r534 - trunk/apps/s3dosm
Message-ID: <200612161054.kBGAsXTE027148@sheep.berlios.de>

Author: dotslash
Date: 2006-12-16 11:54:32 +0100 (Sat, 16 Dec 2006)
New Revision: 534

Modified:
   trunk/apps/s3dosm/gps.c
Log:
- fix heading - gps in livefeed now looks in the right direction :)

Modified: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2006-12-15 12:40:52 UTC (rev 533)
+++ trunk/apps/s3dosm/gps.c	2006-12-16 10:54:32 UTC (rev 534)
@@ -102,7 +102,7 @@
 	
 	la=dgps->fix.latitude;
 	lo=dgps->fix.longitude;
-	heading=dgps->fix.track;
+	heading=-dgps->fix.track;
 	speed=dgps->fix.speed;
 
 #else
@@ -115,7 +115,7 @@
 	}
 	la=dgps->latitude;
 	lo=dgps->longitude;
-	heading=dgps->track;
+	heading=-dgps->track;
 	speed=dgps->speed*KNOTS_TO_MPH/METERS_TO_MILES/3600; /* speed in knots -> miles per hour -> meter per hour -> meter per secon */
 #endif
 	tlat=la;tlon=lo;



From dotslash at mail.berlios.de  Sat Dec 16 14:37:09 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 16 Dec 2006 14:37:09 +0100
Subject: [S3d-svn] r535 - in trunk: . apps config
Message-ID: <200612161337.kBGDb9ik018374@sheep.berlios.de>

Author: dotslash
Date: 2006-12-16 14:37:09 +0100 (Sat, 16 Dec 2006)
New Revision: 535

Removed:
   trunk/apps/s3dgps/
   trunk/config/simage.m4
Modified:
   trunk/
   trunk/apps/Makefile.am
   trunk/configure.ac
Log:
 r1285 at kero:  dotslash | 2006-12-16 14:37:05 +0100
 - remove useless s3dgps program and simage dependency



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1277
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1285

Modified: trunk/apps/Makefile.am
===================================================================
--- trunk/apps/Makefile.am	2006-12-16 10:54:32 UTC (rev 534)
+++ trunk/apps/Makefile.am	2006-12-16 13:37:09 UTC (rev 535)
@@ -1,7 +1,3 @@
-if BUILD_S3DGPS
-MAYBE_S3DGPS=	s3dgps
-endif
-
 if BUILD_X11GATE
 MAYBE_X11GATE=	s3d_x11gate
 endif
@@ -10,4 +6,4 @@
 MAYBE_S3DOSM=	s3dosm
 endif
 
-SUBDIRS =  ${MAYBE_S3DGPS} ${MAYBE_X11GATE} ${MAYBE_S3DOSM} s3dvt olsrs3d dot_mcp s3dfm kism3d
+SUBDIRS =  ${MAYBE_X11GATE} ${MAYBE_S3DOSM} s3dvt olsrs3d dot_mcp s3dfm kism3d

Deleted: trunk/config/simage.m4
===================================================================
--- trunk/config/simage.m4	2006-12-16 10:54:32 UTC (rev 534)
+++ trunk/config/simage.m4	2006-12-16 13:37:09 UTC (rev 535)
@@ -1,109 +0,0 @@
-# **************************************************************************
-# SIM_AC_HAVE_SIMAGE_IFELSE( IF-FOUND, IF-NOT-FOUND )
-#
-# Description:
-#   This macro locates the simage development system.  If it is found, the
-#   set of variables listed below are set up as described and made available
-#   to the configure script.
-#
-#   The $sim_ac_simage_desired variable can be set to false externally to
-#   make SoXt default to be excluded.
-#
-# Autoconf Variables:
-# > $sim_ac_simage_desired   true | false (defaults to true)
-# < $sim_ac_simage_avail     true | false
-# < $sim_ac_simage_cppflags  (extra flags the compiler needs for simage)
-# < $sim_ac_simage_ldflags   (extra flags the linker needs for simage)
-# < $sim_ac_simage_libs      (link libraries the linker needs for simage)
-# < $sim_ac_simage_version   (the libsimage version)
-#
-# Authors:
-#   Morten Eriksen <mortene at coin3d.org>
-#   Lars J. Aas <larsa at coin3d.org>
-#
-# TODO:
-# - rework variable name convention
-# - clean up shell scripting redundancy
-# - support debug symbols simage library
-#
-
-AC_DEFUN([SIM_AC_HAVE_SIMAGE_IFELSE],
-[AC_PREREQ([2.14a])
-
-# official variables
-sim_ac_simage_avail=false
-sim_ac_simage_cppflags=
-sim_ac_simage_ldflags=
-sim_ac_simage_libs=
-sim_ac_simage_version=
-
-# internal variables
-: ${sim_ac_simage_desired=true}
-sim_ac_simage_extrapath=
-
-AC_ARG_WITH(
-  simage,
-  AC_HELP_STRING([--with-simage=DIR],
-                 [use simage for loading texture files]),
-  [case $withval in
-   yes) sim_ac_simage_desired=true ;;
-   no)  sim_ac_simage_desired=false ;;
-   *)   sim_ac_simage_desired=true
-        sim_ac_simage_extrapath=$withval ;;
-  esac],
-  [])
-
-if $sim_ac_simage_desired; then
-  sim_ac_path=$PATH
-  test -z "$sim_ac_simage_extrapath" ||
-    sim_ac_path=$sim_ac_simage_extrapath/bin:$sim_ac_path
-  test x"$prefix" = xNONE ||
-    sim_ac_path=$sim_ac_path:$prefix/bin
-
-  AC_PATH_PROG(sim_ac_simage_configcmd, simage-config, false, $sim_ac_path)
-
-  if test "X$sim_ac_simage_configcmd" = "Xfalse"; then :; else
-    test -n "$CONFIG" &&
-      $sim_ac_simage_configcmd --alternate=$CONFIG >/dev/null 2>/dev/null &&
-      sim_ac_simage_configcmd="$sim_ac_simage_configcmd --alternate=$CONFIG"
-  fi
-
-  if $sim_ac_simage_configcmd; then
-    sim_ac_simage_cppflags=`$sim_ac_simage_configcmd --cppflags`
-    sim_ac_simage_ldflags=`$sim_ac_simage_configcmd --ldflags`
-    sim_ac_simage_libs=`$sim_ac_simage_configcmd --libs`
-    sim_ac_simage_version=`$sim_ac_simage_configcmd --version`
-    AC_CACHE_CHECK([whether the simage library is available],
-      sim_cv_simage_avail,
-      [sim_ac_save_cppflags=$CPPFLAGS
-      sim_ac_save_ldflags=$LDFLAGS
-      sim_ac_save_libs=$LIBS
-      CPPFLAGS="$CPPFLAGS $sim_ac_simage_cppflags"
-      LDFLAGS="$LDFLAGS $sim_ac_simage_ldflags"
-      LIBS="$sim_ac_simage_libs $LIBS"
-      AC_TRY_LINK(
-        [#include <simage.h>],
-        [(void)simage_read_image(0L, 0L, 0L, 0L);],
-        [sim_cv_simage_avail=true],
-        [sim_cv_simage_avail=false])
-      CPPFLAGS=$sim_ac_save_cppflags
-      LDFLAGS=$sim_ac_save_ldflags
-      LIBS=$sim_ac_save_libs
-    ])
-    sim_ac_simage_avail=$sim_cv_simage_avail
-  else
-    locations=`IFS=:
-               for p in $sim_ac_path; do echo " -> $p/simage-config"; done`
-    AC_MSG_WARN([cannot find 'simage-config' at any of these locations:
-$locations])
-  fi
-fi
-
-if $sim_ac_simage_avail; then
-  ifelse([$1], , :, [$1])
-else
-  ifelse([$2], , :, [$2])
-fi
-])
-
-# EOF **********************************************************************

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-12-16 10:54:32 UTC (rev 534)
+++ trunk/configure.ac	2006-12-16 13:37:09 UTC (rev 535)
@@ -139,17 +139,7 @@
 
 AM_CONDITIONAL([BUILD_S3DOSM], [test x"${HAVE_XML}" = xyes && test x"${HAVE_SQLITE3}" = xyes])
 
-SIM_AC_HAVE_SIMAGE_IFELSE([
-	SIMAGE_CFLAGS=$sim_ac_simage_cppflags
-	SIMAGE_LIBS="$sim_ac_simage_ldflags $sim_ac_simage_libs"
-	AC_SUBST(SIMAGE_CFLAGS)
-	AC_SUBST(SIMAGE_LIBS)
-],[
-	WARNS="$WARNS
- ### Sorry, you lack the simage library to compile the s3dgps application."
-])
 AC_CHECK_HEADER(gps.h, [HAVE_GPS=yes])
-AM_CONDITIONAL([BUILD_S3DGPS], [test x$HAVE_GPS = xyes && test x$sim_ac_simage_avail = xtrue])
 
 if test "x${HAVE_GPS}" = "xyes"; then
 	AC_DEFINE([HAVE_GPS], 1, [Have gps support])
@@ -234,7 +224,6 @@
 	apps/Makefile
 	apps/olsrs3d/Makefile
 	apps/s3d_x11gate/Makefile
-	apps/s3dgps/Makefile
 	apps/s3dvt/Makefile
 	apps/s3dfm/Makefile
 	apps/kism3d/Makefile



From dotslash at mail.berlios.de  Sun Dec 17 16:30:24 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 17 Dec 2006 16:30:24 +0100
Subject: [S3d-svn] r536 - in trunk: . libs3d libs3d/libg3d/src libs3dw
Message-ID: <200612171530.kBHFUO7h000722@sheep.berlios.de>

Author: dotslash
Date: 2006-12-17 16:30:23 +0100 (Sun, 17 Dec 2006)
New Revision: 536

Modified:
   trunk/
   trunk/libs3d/libg3d/src/plugins.c
   trunk/libs3d/s3d.h
   trunk/libs3dw/label.c
   trunk/libs3dw/s3dw.h
Log:
 r1292 at kero:  dotslash | 2006-12-17 16:30:12 +0100
 - add s3dw_label_change_text()
 - add s3d[w]_h defines so we can ignore multiple loadings
   and include s3d.h in s3dw.h by default
 - chdir() patch in plugins, don't change our path when loading an object!!



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1285
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1292

Modified: trunk/libs3d/libg3d/src/plugins.c
===================================================================
--- trunk/libs3d/libg3d/src/plugins.c	2006-12-16 13:37:09 UTC (rev 535)
+++ trunk/libs3d/libg3d/src/plugins.c	2006-12-17 15:30:23 UTC (rev 536)
@@ -243,6 +243,7 @@
 	G3DPlugin *plugin;
 	gchar *lcext, *basename, *dirname;
 	gboolean retval;
+	char olddir[4096];
 
 	lcext = g3d_plugins_get_filetype(filename);
 	if(lcext == NULL)
@@ -266,6 +267,7 @@
 	basename = g_path_get_basename(filename);
 	dirname = g_path_get_dirname(filename);
 
+	getcwd(olddir,4096);
 	chdir(dirname);
 
 	retval = plugin->loadmodel_func(context, basename, model,
@@ -273,6 +275,7 @@
 
 	g_free(basename);
 	g_free(dirname);
+	chdir(olddir);
 
 	return retval;
 }

Modified: trunk/libs3d/s3d.h
===================================================================
--- trunk/libs3d/s3d.h	2006-12-16 13:37:09 UTC (rev 535)
+++ trunk/libs3d/s3d.h	2006-12-17 15:30:23 UTC (rev 536)
@@ -20,6 +20,8 @@
  * along with the s3d API; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
+#ifndef LIBS3D_H
+#define LIBS3D_H
 
 #include <stdint.h>  /* [u]intXX_t type definitions*/
 /* definitions */
@@ -184,3 +186,4 @@
 
 /* for apps which don't employ s3d_mainloop() */
 int s3d_net_check();
+#endif

Modified: trunk/libs3dw/label.c
===================================================================
--- trunk/libs3dw/label.c	2006-12-16 13:37:09 UTC (rev 535)
+++ trunk/libs3dw/label.c	2006-12-17 15:30:23 UTC (rev 536)
@@ -49,7 +49,21 @@
 {
     s3d_flags_off(widget->oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 }
+/* change label text */
+void s3dw_label_change_text(s3dw_label *label, char *text)
+{
+	s3dw_widget *widget=(s3dw_widget *)label;
+	uint32_t oid_text;
+	/* redraw the text ... */
+	free(label->text);
+	label->text=strdup(text);
+	s3dw_label_erase(widget);
+	s3dw_label_draw(widget);
+	if (widget->flags&S3DW_ONSCREEN)
+		s3dw_label_show(widget);
+}
 
+
 /* create a new label in the surface */
 s3dw_label *s3dw_label_new(s3dw_surface *surface, char *text, float posx, float posy)
 {

Modified: trunk/libs3dw/s3dw.h
===================================================================
--- trunk/libs3dw/s3dw.h	2006-12-16 13:37:09 UTC (rev 535)
+++ trunk/libs3dw/s3dw.h	2006-12-17 15:30:23 UTC (rev 536)
@@ -21,6 +21,11 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
+#ifndef LIBS3DW_H
+#define LIBS3DW_H
+#ifndef LIBS3D_H
+#include <s3d.h>
+#endif
 #include <stdint.h>  /* [u]intXX_t type definitions*/
 
 /* we want this widget visible, as long as the widgets below are also visible. 
@@ -160,6 +165,7 @@
 s3dw_textbox 		*s3dw_textbox_new(s3dw_surface *surface, char *text, float posx, float posy, float width, float height);
 char 				*s3dw_input_gettext(s3dw_input *input);
 void 				 s3dw_input_change_text(s3dw_input *input, char *text);
+void 				 s3dw_label_change_text(s3dw_label *label, char *text);
 s3dw_surface 		*s3dw_surface_new(char *title, float width, float height);
 
 s3dw_widget 		*s3dw_getroot();
@@ -180,3 +186,4 @@
 int 				 s3dw_object_info(struct s3d_evt *evt);
 
 void 				 s3dw_ani_mate();
+#endif



From dotslash at mail.berlios.de  Sun Dec 17 20:05:13 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 17 Dec 2006 20:05:13 +0100
Subject: [S3d-svn] r537 - in trunk: . libs3d
Message-ID: <200612171905.kBHJ5D57002465@sheep.berlios.de>

Author: dotslash
Date: 2006-12-17 20:05:11 +0100 (Sun, 17 Dec 2006)
New Revision: 537

Modified:
   trunk/
   trunk/libs3d/event.c
   trunk/libs3d/io.c
   trunk/libs3d/network.c
   trunk/libs3d/object_queue.c
   trunk/libs3d/proto_in.c
   trunk/libs3d/proto_out.c
   trunk/libs3d/s3dlib.h
Log:
 r1295 at kero:  dotslash | 2006-12-17 20:05:04 +0100
 - rewrite callback lock part in libs3d
 - wait for INIT packet before returning from s3d_init()
 - add s3d_ready variable to indicate s3d_init() is complete



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1292
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1295

Modified: trunk/libs3d/event.c
===================================================================
--- trunk/libs3d/event.c	2006-12-17 15:30:23 UTC (rev 536)
+++ trunk/libs3d/event.c	2006-12-17 19:05:11 UTC (rev 537)
@@ -34,25 +34,20 @@
 	struct s3d_evt *p;
 	s3d_cb cb;
 
-	s3dprintf(VLOW,"pushed event %d",newevt->event);
+	s3dprintf(VLOW,"pushed event %d, cb_lock = %d",newevt->event, cb_lock);
 	 /*  this will always be called for S3D_EVENT_NEW_OBJECT!! */
 	if (newevt->event==S3D_EVENT_NEW_OBJECT)
 	{
 		_queue_new_object(*((unsigned int *)newevt->buf));	
 	}
-	if (cb_lock)  /*  no recursive event-callbacks, please! */
+	if (cb_lock==0)  /*  no recursive event-callbacks, please! */
 	{	
-		cb_lock=2;  /*  we want our event processed after this finishs */
-	} else 	{
 		if (NULL!=(cb=s3d_get_callback(newevt->event)))
 		{
-			cb_lock=1;		 /*  on our way! lock it.. */
+			cb_lock++;		 /*  on our way! lock it.. */
 			cb(newevt);		 /*  .. and call it! */
-			if (cb_lock==2)  /*  there were other callbacks? we process: */
-			{
-				cb_lock=0;
-				s3d_process_stack();
-			}
+			cb_lock--;
+							 /* okay, no new callbacks, unlock now. */
 			free(newevt);
 			return;
 		}
@@ -110,40 +105,27 @@
 /*  this function checks the stack for callbacks. */
 void s3d_process_stack()
 {
-	struct s3d_evt *p,*pre,*t;
+	struct s3d_evt *p;
 	s3d_cb cb;
-	p=s3d_stack;
-	pre=NULL;
-	if (cb_lock!=0) /* can't do that now. */
+	if (cb_lock>0) /* can't do that now. */
 	{
-		cb_lock=2; /* request later processing */
+		
+		s3dprintf(VLOW,"cb_lock = %d, processing later",cb_lock);
 		return;
 	}
 	s3dprintf(VLOW,"processing stack ...");
-	while (p!=NULL)
-	{
-		
-		if ((cb=s3d_get_callback(p->event))!=NULL)
-		{
-			cb_lock=1;
+	while (NULL!=(p=s3d_pop_event())) {
+		if ((cb=s3d_get_callback(p->event))!=NULL) {
+			cb_lock++;
 			cb(p);
-			cb_lock=0;
-			if (pre!=NULL)   /*  there is a previous element */
-				pre->next=p->next;
-			else			 /*  it's the first element */
-				s3d_stack=p->next;
-			t=p->next;
-			 /*  free */
-			if (p->length>0) 
-				free(p->buf);
-			free(p);	
-			p=t;
+			cb_lock--;
+		} else {
+			/* kick out unprocessed event */
 			
 		}
-		else 
-		{
-			pre=p;
-			p=p->next;
-		}
+		 /*  free */
+		if (p->length>0) 
+			free(p->buf);
+		free(p);	
 	}
 }

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2006-12-17 15:30:23 UTC (rev 536)
+++ trunk/libs3d/io.c	2006-12-17 19:05:11 UTC (rev 537)
@@ -33,6 +33,7 @@
 #include <errno.h>		 /*  errno */
 #include <sys/socket.h>  /*  socket() */
 #include <getopt.h>		 /*  getopt() */
+#include <time.h>		 /*  nanosleep() */
 #ifdef SIGS
 #include <fcntl.h>		 /*  fcntl() */
 #include <signal.h>		 /*  signal.h, SIG_PIPE */
@@ -48,6 +49,7 @@
 /*  this file is the client-lib-implementation which holds the function to connect and control the server. */
 #ifdef SIGS
 int _s3d_sigio=0;
+int _s3d_ready=0;
 void sigint_handler(int sig, int code)  /*  ... ? */
 {
 	/*s3d_quit();*/ /* TODO: sometimes no clean quit ?!*/
@@ -109,7 +111,10 @@
 	char 				*s;
 	char 				 urlc[256];		 /*  this should be enough for an url */
 	char 				 buf[258]; 		 /*  server buffer */
+	int					 i;
+	struct timespec		 t={0,10*1000*1000}; /* 10 mili second */
 
+	cb_lock=1;	/* don't bother while initiating ... is set to 0 after INIT packet received. */
 	if (NULL!=(s=getenv("S3D")))
 	{
 		s3dprintf(VLOW,"at least we have the enviroment variable ... %s",s);
@@ -139,7 +144,6 @@
 	}
 	strncpy(buf,name,256);  /*  copy the name ... */
 	net_send(S3D_P_C_INIT,buf,strlen(buf));
-	cb_lock=2;
 
 	_queue_init();
 #ifdef SIGS
@@ -147,9 +151,16 @@
 		errdn(LOW,"s3d_init():signal()",errno);
     if (signal(SIGTERM, (sig_t)sigint_handler) == SIG_ERR)
 		errdn(LOW,"s3d_init():signal()",errno);
-
 #endif
-	return(0);
+	for (i=0;i<100;i++) {
+		s3d_net_check(); /* wait for init packet */
+		nanosleep(&t,NULL); 
+		if (_s3d_ready) {
+			cb_lock--;
+			return(0);
+		}
+	}
+	return(-1);
 }
 /*  shuts down the socket, clearing the stack */
 int s3d_quit()
@@ -179,15 +190,11 @@
 {
 	while (con_type!=CON_NULL)
 	{
-		if (f!=NULL)
-			f();
-		s3d_net_check();
-		if (cb_lock==2)  /*  there were other callbacks? we process: */
-		{
-			cb_lock=0;
-			s3d_process_stack();
-		}
-
+		cb_lock++;			/* no callbacks while we are in mainloop */
+		if (f!=NULL)	f();
+		cb_lock--;
+		s3d_process_stack();
+		s3d_net_check(); 	/* get any other packets we might have missed */	
 	}
 	return(0);
 }
@@ -214,13 +221,13 @@
 	if (fstat(fileno(fp),&bf))
 	{ errdn(VLOW,"s3d_open_file():fstat()",errno); return(-1);}
 	filesize=bf.st_size;
-	s3dprintf(VLOW, "opening %s, filesize is %d",fname, filesize);
+	s3dprintf(LOW, "opening %s, filesize is %d",fname, filesize);
 	if ((buf=malloc(filesize))==NULL)
 	{
 		errn("s3d_open_3ds_file():malloc()",errno);
 		exit(-1);
 	}
-	fread(buf, filesize, 1, fp);
+	fread(buf, 1, filesize, fp);
 	fclose(fp);
 	*pointer=buf;
 	return(filesize);

Modified: trunk/libs3d/network.c
===================================================================
--- trunk/libs3d/network.c	2006-12-17 15:30:23 UTC (rev 536)
+++ trunk/libs3d/network.c	2006-12-17 19:05:11 UTC (rev 537)
@@ -89,6 +89,7 @@
 			break;
 #endif
 	}
+	s3d_process_stack();
 	return(0);
 }
 int s3d_net_init(char *urlc)

Modified: trunk/libs3d/object_queue.c
===================================================================
--- trunk/libs3d/object_queue.c	2006-12-17 15:30:23 UTC (rev 536)
+++ trunk/libs3d/object_queue.c	2006-12-17 19:05:11 UTC (rev 537)
@@ -39,7 +39,6 @@
 static int requested;				 	/*  counter of how many addtional */
 									 	/*  objects have been requested */
 static struct timespec t={0,10*1000};	/* 10 micro seconds */
-extern int cb_lock;
 /*  initializes the object queue */
 int _queue_init()
 {
@@ -109,8 +108,6 @@
 			net_send(S3D_P_C_NEW_OBJ,NULL,0);
 			requested++;
 		}
-		if (!cb_lock)
-			cb_lock=1; /* please, no callbacks now. */
 		s3d_net_check();
 		nanosleep(&t,NULL); 
 	} while(j++<TIMEOUT);

Modified: trunk/libs3d/proto_in.c
===================================================================
--- trunk/libs3d/proto_in.c	2006-12-17 15:30:23 UTC (rev 536)
+++ trunk/libs3d/proto_in.c	2006-12-17 19:05:11 UTC (rev 537)
@@ -28,7 +28,6 @@
 #include <netinet/in.h>  /*  htons(),htonl() */
 #include <errno.h>		 /*  errno */
 #include <stdlib.h>		 /*  malloc(), free() */
-extern int cb_lock;
 /*  this proccesses the commands and pushes s3d-events, or does other things ;) */
 int net_prot_in(uint8_t opcode, uint16_t length, char *buf)
 {
@@ -40,8 +39,7 @@
 	{
 		case S3D_P_S_INIT:
 			s3dprintf(MED,"S3D_P_S_INIT: init!!");
-			cb_lock=0;
-/*			s3d_process_stack();*/
+			_s3d_ready=1;
 			break;
 		case S3D_P_S_QUIT:
 			s3dprintf(MED,"S3D_P_S_QUIT: server wants us to go. well ...");

Modified: trunk/libs3d/proto_out.c
===================================================================
--- trunk/libs3d/proto_out.c	2006-12-17 15:30:23 UTC (rev 536)
+++ trunk/libs3d/proto_out.c	2006-12-17 19:05:11 UTC (rev 537)
@@ -40,7 +40,13 @@
 /*  creates a new object */
 int s3d_new_object()
 {
-	return(_queue_want_object());  /*  TODO: well ... */
+	int oid;
+	int old_cb_lock;
+	
+	cb_lock++; /* please, no callbacks now. */
+	oid=_queue_want_object();
+	cb_lock--; /* no new callbacks and nothing happened */
+	return(oid);
 }
 /*  clones an object */
 int s3d_clone(int oid)

Modified: trunk/libs3d/s3dlib.h
===================================================================
--- trunk/libs3d/s3dlib.h	2006-12-17 15:30:23 UTC (rev 536)
+++ trunk/libs3d/s3dlib.h	2006-12-17 19:05:11 UTC (rev 537)
@@ -47,6 +47,9 @@
 #define RB_STD_SIZE		1024*512
 #define RB_OVERHEAD		sizeof(struct buf_t)
 /*  the callback buiffer: */
+extern int cb_lock;	/* holds the recursion depth */
+
+extern int _s3d_ready; /* is 1 after s3d_init() was sucessful */
 extern s3d_cb s3d_cb_list[MAX_CB];
 /*  some local prototypes: */
 /*  char *s3d_open_file(char *fname); */



From dotslash at mail.berlios.de  Sun Dec 17 20:07:12 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 17 Dec 2006 20:07:12 +0100
Subject: [S3d-svn] r538 - in trunk: . apps/s3dosm
Message-ID: <200612171907.kBHJ7CpQ002658@sheep.berlios.de>

Author: dotslash
Date: 2006-12-17 20:07:12 +0100 (Sun, 17 Dec 2006)
New Revision: 538

Added:
   trunk/apps/s3dosm/ui.c
Modified:
   trunk/
   trunk/apps/s3dosm/Makefile.am
   trunk/apps/s3dosm/db.c
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/io.c
   trunk/apps/s3dosm/kismet.c
   trunk/apps/s3dosm/main.c
   trunk/apps/s3dosm/nav.c
   trunk/apps/s3dosm/osm.c
   trunk/apps/s3dosm/s3dosm.h
Log:
 r1297 at kero:  dotslash | 2006-12-17 20:07:07 +0100
 - add ui.c for user interface
 - show loading window while loading files



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1295
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1297

Modified: trunk/apps/s3dosm/Makefile.am
===================================================================
--- trunk/apps/s3dosm/Makefile.am	2006-12-17 19:05:11 UTC (rev 537)
+++ trunk/apps/s3dosm/Makefile.am	2006-12-17 19:07:12 UTC (rev 538)
@@ -6,9 +6,9 @@
 s3dosm_SOURCES =  \
 	main.c http_fetcher.c http_error_codes.c osm.c \
 	object.c draw.c kismet.c nav.c tag.c io.c db.c \
-	gps.c
+	gps.c ui.c
 
-s3dosm_CPPFLAGS=	-pg -I$(top_srcdir)/libs3d @LIBXML2_CFLAGS@ @LIBSQLITE3_CFLAGS@ @GPS_CFLAGS@
-s3dosm_LDADD=		$(top_builddir)/libs3d/libs3d.la @LIBXML2_LIBS@ @LIBSQLITE3_LIBS@ @GPS_LIBS@
+s3dosm_CPPFLAGS=	-pg -I$(top_srcdir)/libs3d -I$(top_srcdir)/libs3dw @LIBXML2_CFLAGS@ @LIBSQLITE3_CFLAGS@ @GPS_CFLAGS@
+s3dosm_LDADD=		$(top_builddir)/libs3d/libs3d.la $(top_builddir)/libs3dw/libs3dw.la @LIBXML2_LIBS@ @LIBSQLITE3_LIBS@ @GPS_LIBS@
 s3dosm_LDFLAGS=		-pg
 

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2006-12-17 19:05:11 UTC (rev 537)
+++ trunk/apps/s3dosm/db.c	2006-12-17 19:07:12 UTC (rev 538)
@@ -34,7 +34,6 @@
 static sqlite3 *db;
 static char *dbFile=NULL;
 int db_exec(const char *query, sqlite3_callback callback, void *arg);
-static int db_getint(void *tagid, int argc, char **argv, char **azColName);
 
 /* TODO: remove '' for security reasons */
 void clean_string(char *clean, char *dirty, int n)
@@ -139,7 +138,7 @@
 	return(-1);
 }
 */
-static int db_getint(void *tagid, int argc, char **argv, char **azColName){
+int db_getint(void *tagid, int argc, char **argv, char **azColName){
   if (argv[0]!=NULL) 
 	  *((int *)tagid)=atoi(argv[0]);
   return 0;

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-17 19:05:11 UTC (rev 537)
+++ trunk/apps/s3dosm/draw.c	2006-12-17 19:07:12 UTC (rev 538)
@@ -26,14 +26,53 @@
 #include <stdio.h>	/* printf() */
 #include <string.h>	/* strcmp() */
 #include <stdlib.h> /* atoi(),malloc(), calloc(), free() */
-struct vdata{
-	layer_t *layer;
-	float lonsum,latsum;
-	int n;
-	int oid;
-	int vnum;
+
+static float temp;
+#define		V_COPY(a,b)		a[0]=b[0];	a[1]=b[1];	a[2]=b[2];
+#define 	V_ADD(a,b,c)	c[0]=a[0]+b[0];	c[1]=a[1]+b[1];	c[2]=a[2]+b[2];
+#define 	V_SUB(a,b,c)	c[0]=a[0]-b[0];	c[1]=a[1]-b[1];	c[2]=a[2]-b[2];
+#define		V_DOT(a,b)		a[0]*b[0] + a[1]*b[1] + a[2] * b[2]
+#define		V_CROSS(a,b,c)	c[0]=a[1]*b[2] - a[2]*b[1];		c[1]=a[2]*b[0] - a[0]*b[2]; 	c[2]=a[0]*b[1] - a[1]*b[0];
+#define		V_LEN(a)		sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2])
+#define		V_SCAL(a,s)		a[0]=s*a[0];	a[1]=s*a[1];	a[2]=s*a[2];
+#define		V_NORM(a)		temp=V_LEN(a); V_SCAL(a,1/temp);
+
+
+static int num_max;		/* how many results in our query? to calculate pecent done ... */
+static int num_done;	/* how many already done */
+
+static int lastid=-1;
+/* list element of a segment which is on our way */
+struct waylist {
+	int node_from,node_to;
+	int node_from_int,node_to_int;
+	int seg_id;
+	int node_from_l,node_from_r;	/* vertex id's for corners */
+	int node_to_l,node_to_r;
 };
+/* list element of a node which is to be drawn */
+struct nodelist {
+	int node_id;			/* (external counting) */
+	float la,lo,alt;		/* earth coords */
+	float x[3];				/* euclid coords */
+	float normal[3];
+	float len;
+};
+/* list element for adjacent nodes */
+struct adjlist {
+	int node_id;			/* node to which the segment leads to */
+	int seg_id;				/* segment which is involved to the node (both internal counting) */
+};
 
+struct waylist 	*waylist_p=NULL;
+struct nodelist	*nodelist_p=NULL;
+struct adjlist	*adjlist_p=NULL;
+int				nodelist_n=0;
+int				adjlist_n=0;
+int 			waylist_n=0;
+int 			waylist_bufn=0;
+
+
 void calc_earth_to_eukl(float lat, float lon, float alt, float *x)
 {
 	float la,lo;
@@ -50,7 +89,7 @@
 	float la, lo, alt;
 	float x[3];
 	la=lo=alt=0.0;
-	
+	num_done++;
 	for(i=0; i<argc; i++) {
 		if (argv[i]) {
 			if (0==strcmp(azColName[i],"longitude"))			lo=strtod(argv[i],NULL);
@@ -77,45 +116,13 @@
 			s3d_rotate(oid,(90-la),lo,0);
 			s3d_link(oid,oidy);
 			s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+			load_update_status((100.0*num_done)/(float)num_max);
 			/* TODO: update database */
 		}
 				
 	} 
 	return(0);
 }
-
-static int lastid=-1;
-struct waylist {
-	int node_from,node_to;
-	int node_from_int,node_to_int;
-	int seg_id;
-	int node_from_l,node_from_r;	/* vertex id's for corners */
-	int node_to_l,node_to_r;
-};
-struct nodelist {
-	int node_id;			/* (external counting) */
-	float la,lo,alt;		/* earth coords */
-	float x[3];				/* euclid coords */
-	float normal[3];
-	float len;
-};
-struct adjlist {
-	int node_id;			/* node to which the segment leads to */
-	int seg_id;				/* segment which is involved to the node (both internal counting) */
-};
-/*
-struct nodelist nodelist_p[2];
-int				nodelist_n=0;
-*/
-
-struct waylist 	*waylist_p=NULL;
-struct nodelist	*nodelist_p=NULL;
-struct adjlist	*adjlist_p=NULL;
-int				nodelist_n=0;
-int				adjlist_n=0;
-int 			waylist_n=0;
-int 			waylist_bufn=0;
-
 /* just fetches node information and puts it in some simple 6x float buffer */
 int insert_node(void *data, int argc, char **argv, char **azColName)
 {
@@ -144,16 +151,6 @@
 	}
 	return(0);
 }
-static float temp;
-#define		V_COPY(a,b)		a[0]=b[0];	a[1]=b[1];	a[2]=b[2];
-#define 	V_ADD(a,b,c)	c[0]=a[0]+b[0];	c[1]=a[1]+b[1];	c[2]=a[2]+b[2];
-#define 	V_SUB(a,b,c)	c[0]=a[0]-b[0];	c[1]=a[1]-b[1];	c[2]=a[2]-b[2];
-#define		V_DOT(a,b)		a[0]*b[0] + a[1]*b[1] + a[2] * b[2]
-#define		V_CROSS(a,b,c)	c[0]=a[1]*b[2] - a[2]*b[1];		c[1]=a[2]*b[0] - a[0]*b[2]; 	c[2]=a[0]*b[1] - a[1]*b[0];
-#define		V_LEN(a)		sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2])
-#define		V_SCAL(a,s)		a[0]=s*a[0];	a[1]=s*a[1];	a[2]=s*a[2];
-#define		V_NORM(a)		temp=V_LEN(a); V_SCAL(a,1/temp);
-
 /* draw waylist, clear the queue */
 void waylist_draw(char *filter)
 {
@@ -172,6 +169,8 @@
 	float point_zero[3]; /* we use point_zero so we don't have very big bounding spheres in s3d and speed up picking */
 	float n_len,scale;
 
+	if (waylist_n==0)	/* no nodes, no fun */
+		return;
 /*	printf("way: %d - %d segments\n",lastid,waylist_n);*/
 	way_obj=s3d_new_object();
 	if (lastid!=-1) {
@@ -357,8 +356,8 @@
 	s3d_link(way_obj,oidy);
 	s3d_flags_on(way_obj,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 	waylist_n=0;
-	printf("+");
-	fflush(stdout);
+
+	load_update_status((100.0*num_done)/(float)num_max);
 }
 void waylist_add(struct waylist *p)
 {
@@ -379,6 +378,7 @@
 	int id=-1;
 	struct waylist p;
 	char *filter=(char *)data;
+	num_done++;
 	p.node_from=p.node_to=0;
 	p.node_to=-1;
 	p.seg_id=-1;
@@ -401,7 +401,6 @@
 		waylist_add(&p);
 	}
 	lastid=id;
-		
 	return 0;
 }
 void draw_translate_icon(int user_icon, float la, float lo)
@@ -415,28 +414,33 @@
 void draw_ways(char *filter)
 {
 	char query[MAXQ];
+	num_done=0;
+	snprintf(query,MAXQ,"SELECT count(seg_id) FROM segment WHERE %s",filter);
+	db_exec(query, db_getint,&num_max);
 	snprintf(query,MAXQ,"SELECT * FROM segment WHERE %s ORDER BY way_id;",filter);
 	db_exec(query, way_group,filter);
 	waylist_draw(filter); /* last way */
-	printf("[done]\n");
 }
 void draw_osm()
 {
-	printf("draw_osm()\n");
+	load_window("Drawing Card ...");
 	draw_ways("layer_id=(SELECT layer_id FROM layer WHERE name='osm')");
 }
 void draw_kismet()
 {
 	char query[MAXQ];
 	char filter[]="layer_id=(SELECT layer_id FROM layer WHERE name='kismet')";
-	printf("[draw kismet]\n");
+	load_window("Drawing Access Points ...");
+	num_done=0;
+	snprintf(query,MAXQ,"SELECT count(node_id) FROM node WHERE %s",filter);
+	db_exec(query, db_getint,&num_max);
 	snprintf(query,MAXQ,"SELECT * FROM node WHERE %s;",filter);
 	db_exec(query, draw_icon,filter);
 	waylist_draw(filter); /* last way */
-	printf("[done]\n");
 }
 void draw_all_layers()
 {
 	draw_osm();
 	draw_kismet();
+	load_window_remove();
 }

Modified: trunk/apps/s3dosm/io.c
===================================================================
--- trunk/apps/s3dosm/io.c	2006-12-17 19:05:11 UTC (rev 537)
+++ trunk/apps/s3dosm/io.c	2006-12-17 19:07:12 UTC (rev 538)
@@ -53,6 +53,7 @@
 	int					 lopt_idx,i;
 	char				 c;
 	float				 minlat, minlon, maxlat, maxlon;
+	char 				 info[1024];
 	struct option long_options[] = 
 	{
 		{"help",0,0,'h'},
@@ -88,8 +89,11 @@
 	}
 	for (i=1;i<argc;i++)
 	{
-		if (strstr(argv[i],".osm")-argv[i]==strlen(argv[i])-4)
+		if (strstr(argv[i],".osm")-argv[i]==strlen(argv[i])-4) {
+			snprintf(info,1024,"loading OSM-File: %s",argv[i]);
+			load_window(info);
 			layerset_add(load_osm_file(argv[i]));
+		}
 		else if (strstr(argv[i],".xml")-argv[i]==strlen(argv[i])-4) /* might be osm or kismet xml */
 		{
 			char *file;
@@ -97,13 +101,20 @@
 			if (NULL==(file=read_file(argv[i],&fsize)))				
 				break;
 			if (NULL!=strstr(file,"<!DOCTYPE detection-run SYSTEM \"http://kismetwireless.net"))
+			{
+				snprintf(info,1024,"loading Kismet-File: %s",argv[i]);
+				load_window(info);
 				layerset_add(parse_kismet(file,fsize));
-			else if (NULL!=strstr(file,"<osm "))
+			}
+			else if (NULL!=strstr(file,"<osm ")) {
+				snprintf(info,1024,"loading OSM-File: %s",argv[i]);
+				load_window(info);
 				layerset_add(parse_osm(file,fsize));
+			}
 			free(file);
-					
 		}
 	}
+	load_window_remove();
 	return(0);
 }
 

Modified: trunk/apps/s3dosm/kismet.c
===================================================================
--- trunk/apps/s3dosm/kismet.c	2006-12-17 19:05:11 UTC (rev 537)
+++ trunk/apps/s3dosm/kismet.c	2006-12-17 19:07:12 UTC (rev 538)
@@ -81,8 +81,10 @@
 layer_t *parse_kismet(char *buf, int length)
 {
 	xmlDocPtr doc;
-	xmlNodePtr cur;
+	xmlNodePtr cur,c;
 	layer_t *layer=layer_new();
+	int i=0;
+	float n=0;
 	
 
 	doc = xmlReadMemory(buf, length, "noname.xml", NULL, 0);
@@ -97,7 +99,7 @@
 		return(NULL);
 	}
 	layerid=db_insert_layer("kismet");
-	printf("kismet layerid is %d\n",layerid);
+	for (c=cur->children;  c!=NULL;   c=c->next) 		n++; /* count */
 	for (cur=cur->children;cur!=NULL; cur=cur->next)
 	{
 		if (cur->type==XML_ELEMENT_NODE)
@@ -107,6 +109,8 @@
 				parse_kismet_node(cur);
 			} 
 		}
+		if ((i++)%10==0) load_update_status(100*((float)i)/n);
+
 	}
 	db_flush();
 	xmlFreeDoc(doc);

Modified: trunk/apps/s3dosm/main.c
===================================================================
--- trunk/apps/s3dosm/main.c	2006-12-17 19:05:11 UTC (rev 537)
+++ trunk/apps/s3dosm/main.c	2006-12-17 19:07:12 UTC (rev 538)
@@ -24,19 +24,35 @@
 
 #include <stdio.h>		 /*  snprintf(), printf(), NULL */
 #include <s3d.h>
+#include <s3dw.h>
 #include "s3dosm.h"
 #include <time.h>	 /*  nanosleep(), struct tm, time_t...  */
+static int ready=0;
 
 void mainloop()
 {
 	struct timespec t={0,100*1000*1000}; /* 100 mili seconds */
-	nanosleep(&t,NULL); 
-	gps_main();
-	nav_main();
+	if (ready) {
+		nanosleep(&t,NULL); 
+		gps_main();
+		nav_main();
+		s3dw_ani_mate();
+	} /* else {
+		s3d_net_check(); / * we are not yet in the mainloop of 
+							s3d_mainloop(), because ready==0, 
+							so we check protocol things ourselves.
+							This just prevents timing out from the server 
+							because map loading takes so long, you shouldn't take
+							this as good example and write proper threaded or
+							timesliced loaders :) * /
+		s3d_process_stack();
+	}
+	s3dw_ani_mate();*/
 }
 int init(int argc, char **argv)
 {
 	s3d_select_font("vera");
+	ui_init();
 	if (db_init(":memory:")) return(-1);
 	if (db_create()) return(-1);
 	if (process_args(argc,argv)) return(-1);
@@ -44,10 +60,12 @@
 	nav_autocenter();
 	draw_all_layers();
 	gps_init("localhost");
+	ready=1;
 	return(0);
 }
-int quit()
+int quit() 
 {
+	ready=0;
 	s3d_quit();
 	db_quit();
 	gps_quit();

Modified: trunk/apps/s3dosm/nav.c
===================================================================
--- trunk/apps/s3dosm/nav.c	2006-12-17 19:05:11 UTC (rev 537)
+++ trunk/apps/s3dosm/nav.c	2006-12-17 19:07:12 UTC (rev 538)
@@ -5,29 +5,12 @@
 #include <stdio.h>	/* printf() */
 #include <math.h>	/* fabs() */
 
-icon_t icons[ICON_NUM]={
-		{"objs/accesspoint.3ds",0},
-		{"objs/noinetwep.3ds",0},
-		{"objs/noinetwpa.3ds",0},
-		{"objs/arrow2.3ds",0}
-	};
 int oidx, oidy;
 static float lat,lon,tlat,tlon;
-/* load icons, we want to clone each of them later */
-void nav_loadicons()
-{
-	int i;
-	for (i=0;i<ICON_NUM;i++)
-	{
-		printf("loading %s\n",icons[i].path);
-		icons[i].oid=s3d_import_model_file(icons[i].path);
-	}
-}
 /* load rotation centers */
 void nav_init()
 {
 	lat=lon=tlat=tlon=0.0;
-	nav_loadicons();
 	oidx=s3d_new_object();
 	oidy=s3d_new_object();
 	s3d_link(oidy,oidx);

Modified: trunk/apps/s3dosm/osm.c
===================================================================
--- trunk/apps/s3dosm/osm.c	2006-12-17 19:05:11 UTC (rev 537)
+++ trunk/apps/s3dosm/osm.c	2006-12-17 19:07:12 UTC (rev 538)
@@ -119,9 +119,10 @@
 layer_t *parse_osm(char *buf, int length)
 {
 	xmlDocPtr doc;
-	xmlNodePtr cur;
+	xmlNodePtr cur,c;
 	layer_t *layer=layer_new();
 	object_t *obj;
+	float n=0;
 	int i=0;
 	
 
@@ -137,7 +138,7 @@
 		return(NULL);
 	}
 	layerid=db_insert_layer("osm");
-	printf("osm layerid is %d\n",layerid);
+	for (c=cur->children;  c!=NULL;   c=c->next) 		n++; /* count */
 	for (cur=cur->children;cur!=NULL; cur=cur->next)
 	{
 		if (cur->type==XML_ELEMENT_NODE)
@@ -146,10 +147,9 @@
 			if (0==strcmp((char *)cur->name,"node"))				parse_osm_node(cur);
 			else if (0==strcmp((char *)cur->name,"segment"))		parse_osm_segment(cur);
 			else if (0==strcmp((char *)cur->name,"way"))			parse_osm_way(cur);
-			if ((i++)%100==0) {printf(".");fflush(stdout);}
 		}
+		if ((i++)%200==0) 	load_update_status(100*((float)i)/n); /* report status */
 	}
-	printf("\n");
 	xmlFreeDoc(doc);
 	db_flush();
 

Modified: trunk/apps/s3dosm/s3dosm.h
===================================================================
--- trunk/apps/s3dosm/s3dosm.h	2006-12-17 19:05:11 UTC (rev 537)
+++ trunk/apps/s3dosm/s3dosm.h	2006-12-17 19:07:12 UTC (rev 538)
@@ -125,6 +125,8 @@
 void 		 segment_free(segment_t *segment);
 void 		 way_free(way_t *way);
 void 		 layerset_add(layer_t *layer);
+/* main.c */
+void mainloop();
 /* osm.c */
 void debug_obj(object_t *obj, void *dummy);
 layer_t *parse_osm(char *buf, int length);
@@ -156,6 +158,7 @@
 int db_exec(const char *query, sqlite3_callback callback, void *arg);
 int db_add_tag(object_t *obj, char *key, char *val);
 int db_gettag(int tagid, char *field, char *target);
+int db_getint(void *tagid, int argc, char **argv, char **azColName);
 int db_insert_node(node_t *node);
 int db_insert_segment(segment_t *seg);
 int db_insert_way_only(way_t *way);
@@ -171,3 +174,7 @@
 int gps_init(char *gpshost);
 int gps_main();
 int gps_quit();
+/* ui.c */
+int load_window(char *text);
+int load_window_remove();
+int load_update_status(float percent);

Added: trunk/apps/s3dosm/ui.c
===================================================================
--- trunk/apps/s3dosm/ui.c	2006-12-17 19:05:11 UTC (rev 537)
+++ trunk/apps/s3dosm/ui.c	2006-12-17 19:07:12 UTC (rev 538)
@@ -0,0 +1,113 @@
+/*
+ * ui.c
+ * 
+ * Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *
+ * This file is part of s3dosm, a gps card application for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3dosm is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3dosm is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3dosm; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <s3d.h>
+#include <s3dw.h>
+#include "s3dosm.h"
+#include <stdio.h>	/* NULL */
+icon_t icons[ICON_NUM]={
+		{"objs/accesspoint.3ds",0},
+		{"objs/noinetwep.3ds",0},
+		{"objs/noinetwpa.3ds",0},
+		{"objs/arrow2.3ds",0}
+	};
+
+/* load icons, we want to clone each of them later */
+void ui_loadicons()
+{
+	int i;
+	for (i=0;i<ICON_NUM;i++)
+		icons[i].oid=s3d_import_model_file(icons[i].path);
+}
+
+static s3dw_surface *loadwindow=NULL;
+static s3dw_label   *loadlabel=NULL;
+static s3dw_label   *loadstatus=NULL;
+
+int ui_click(struct s3d_evt *evt)
+{
+	int oid=(int)*((uint32_t *)evt->buf);
+	if (s3dw_handle_click(evt)) {
+		printf("s3dw got it?!\n");
+	}
+	printf("clicked object %d\n",oid);
+
+	return(0);
+}
+int ui_key(struct s3d_evt *evt)
+{
+/*	struct s3d_key_event *key=(struct s3d_key_event *)evt->buf;*/
+	s3dw_handle_key(evt);
+	return(0);
+}
+int ui_oinfo(struct s3d_evt *evt)
+{
+	s3dw_object_info(evt);	
+	return(0);
+}
+int ui_init()
+{
+	printf("ui_init() ...\n");
+	ui_loadicons();
+	s3d_set_callback(S3D_EVENT_OBJ_CLICK,ui_click);
+	s3d_set_callback(S3D_EVENT_KEY,ui_key);
+	s3d_set_callback(S3D_EVENT_OBJ_INFO,ui_oinfo);
+	return(0);
+}
+
+/* initialize the loadwindow or change its caption text */
+int load_window(char *text)
+{
+	if (loadwindow==NULL) /* create it */
+	{
+		loadwindow=s3dw_surface_new("Now loading ...",20,5);
+		loadlabel=s3dw_label_new(loadwindow,text,1,2);
+		loadstatus=s3dw_label_new(loadwindow,"",1,3);
+		s3dw_show(S3DWIDGET(loadwindow));
+	} else {
+		s3dw_label_change_text(loadlabel,text);
+		s3dw_label_change_text(loadstatus,"");
+	}
+	return(0);
+}
+/* remove it if still here */
+int load_window_remove()
+{
+	if (loadwindow!=NULL) {
+		s3dw_delete(S3DWIDGET(loadwindow));
+		loadwindow=NULL;
+		loadlabel=NULL;
+	}
+	return(0);
+}
+/* update the load status ... */
+int load_update_status(float percent)
+{
+	char text[128];
+	if (loadwindow!=NULL) {
+		snprintf(text,128,"%3.1f",percent);
+		s3dw_label_change_text(loadstatus,text);
+	}
+	mainloop();
+	return(0);
+}



From dotslash at mail.berlios.de  Sun Dec 17 20:54:33 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 17 Dec 2006 20:54:33 +0100
Subject: [S3d-svn] r539 - in trunk: . libs3dw
Message-ID: <200612171954.kBHJsXXq008605@sheep.berlios.de>

Author: dotslash
Date: 2006-12-17 20:54:32 +0100 (Sun, 17 Dec 2006)
New Revision: 539

Modified:
   trunk/
   trunk/libs3dw/animate.c
Log:
 r1299 at kero:  dotslash | 2006-12-17 20:54:29 +0100
 - asserting oid==0, type!=cam



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1297
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1299

Modified: trunk/libs3dw/animate.c
===================================================================
--- trunk/libs3dw/animate.c	2006-12-17 19:07:12 UTC (rev 538)
+++ trunk/libs3dw/animate.c	2006-12-17 19:54:32 UTC (rev 539)
@@ -71,9 +71,13 @@
 /* well ... */
 void s3dw_ani_doit(s3dw_widget *f)
 {
-	s3d_translate(	f->oid, f->ax,f->ay,f->az);
-	s3d_rotate(		f->oid, f->arx,f->ary,f->arz);
-	s3d_scale(		f->oid, f->as);
+	if ((f->oid == 0) && (f->type!=S3DW_TCAM)) {
+		s3dprintf(HIGH,"assert failed: weird, moving cam but its not a cam obeject?");
+	} else {
+		s3d_translate(	f->oid, f->ax,f->ay,f->az);
+		s3d_rotate(		f->oid, f->arx,f->ary,f->arz);
+		s3d_scale(		f->oid, f->as);
+	}
 }
 
 /* finish an animation on the stack, stack index i */



From dotslash at mail.berlios.de  Sun Dec 17 21:22:44 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 17 Dec 2006 21:22:44 +0100
Subject: [S3d-svn] r540 - in trunk: . apps/s3dosm
Message-ID: <200612172022.kBHKMiDs011490@sheep.berlios.de>

Author: dotslash
Date: 2006-12-17 21:22:44 +0100 (Sun, 17 Dec 2006)
New Revision: 540

Modified:
   trunk/
   trunk/apps/s3dosm/db.c
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/ui.c
Log:
 r1301 at kero:  dotslash | 2006-12-17 21:22:40 +0100
 - show window with street name on click



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1299
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1301

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2006-12-17 19:54:32 UTC (rev 539)
+++ trunk/apps/s3dosm/db.c	2006-12-17 20:22:44 UTC (rev 540)
@@ -59,7 +59,7 @@
 		snprintf(addquery,MAXQ,"INSERT INTO node (layer_id, latitude, longitude, altitude, visible, tag_id) VALUES (%d, %f, %f, %f, %d, %d);",
 						(int)node->base.layerid,				node->lat,		node->lon,		node->alt,		node->visible, 		(int)node->base.tagid);
 	else
-		snprintf(addquery,MAXQ,"INSERT INTO node VALUES (%d, %d, %f, %f, %f, %d, %d);",
+		snprintf(addquery,MAXQ,"INSERT INTO node (layer_id, node_id,latitude, longitude, altitude, visible, tag_id) VALUES (%d, %d, %f, %f, %f, %d, %d);",
 					(int)node->base.layerid,(int)node->base.id,	node->lat,		node->lon,		node->alt,		node->visible, 		(int)node->base.tagid);
 
 	db_exec(addquery, NULL, 0);
@@ -230,9 +230,9 @@
 }
 int db_create()
 {
-	db_exec("CREATE TABLE node (layer_id INT, node_id INTEGER , latitude DOUBLE PRECISION, longitude DOUBLE PRECISION, altitude DOUBLE PRECISION, visible BOOLEAN, tag_id INT, PRIMARY KEY(layer_id,node_id));",NULL,0);
+	db_exec("CREATE TABLE node (layer_id INT, node_id INTEGER , latitude DOUBLE PRECISION, longitude DOUBLE PRECISION, altitude DOUBLE PRECISION, visible BOOLEAN, tag_id INT, s3doid INT, PRIMARY KEY(layer_id,node_id));",NULL,0);
 	db_exec("CREATE TABLE segment (layer_id INT, seg_id INTEGER, node_from INT, node_to INT, tag_id INT, way_id INT,PRIMARY KEY(layer_id,seg_id));", NULL, 0);
-	db_exec("CREATE TABLE way (layer_id INTEGER, way_id INTEGER, tag_id INT, PRIMARY KEY(layer_id,way_id));", NULL, 0);
+	db_exec("CREATE TABLE way (layer_id INTEGER, way_id INTEGER, tag_id INT, s3doid INT, PRIMARY KEY(layer_id,way_id));", NULL, 0);
 	db_exec("CREATE TABLE layer (layer_id INTEGER, name TEXT, PRIMARY KEY(layer_id));", NULL, 0);
 	db_exec("CREATE TABLE tag (tag_id INT, tagkey TEXT, tagvalue TEXT, PRIMARY KEY(tag_id, tagkey));", NULL, 0);
 	

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-17 19:54:32 UTC (rev 539)
+++ trunk/apps/s3dosm/draw.c	2006-12-17 20:22:44 UTC (rev 540)
@@ -85,6 +85,8 @@
 int draw_icon(void *data, int argc, char **argv, char **azColName) 
 {
 	int i,tagid=-1,oid;
+	int nodeid=-1, layerid=-1;
+	char query[MAXQ];
 	char s[MAXQ];
 	float la, lo, alt;
 	float x[3];
@@ -96,6 +98,8 @@
 			else if (0==strcmp(azColName[i],"latitude"))		la=strtod(argv[i],NULL);
 			else if (0==strcmp(azColName[i],"altitude"))		alt=strtod(argv[i],NULL);
 			else if (0==strcmp(azColName[i],"tag_id")) 			tagid=atoi(argv[i]);
+			else if (0==strcmp(azColName[i],"node_id")) 		nodeid=atoi(argv[i]);
+			else if (0==strcmp(azColName[i],"layer_id")) 		layerid=atoi(argv[i]);
 		}
 	}
 	if (0==db_gettag(tagid, "amenity",s)) {
@@ -117,7 +121,8 @@
 			s3d_link(oid,oidy);
 			s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			load_update_status((100.0*num_done)/(float)num_max);
-			/* TODO: update database */
+			snprintf(query,MAXQ,"UPDATE node SET s3doid=%d WHERE node_id=%d AND layer=%d;",oid,nodeid,layerid);
+			db_exec(query, NULL, 0);
 		}
 				
 	} 
@@ -174,7 +179,7 @@
 /*	printf("way: %d - %d segments\n",lastid,waylist_n);*/
 	way_obj=s3d_new_object();
 	if (lastid!=-1) {
-		snprintf(query,MAXQ,"SELECT tagvalue FROM tag WHERE tag_id=(SELECT tag_id FROM way WHERE way_id=%d) AND tagkey='highway';",lastid);
+		snprintf(query,MAXQ,"SELECT tagvalue FROM tag WHERE tag_id=(SELECT tag_id FROM way WHERE way_id=%d AND %s) AND tagkey='highway';",lastid,filter);
 		db_exec(query, select_waytype, &waytype);
 	}
 	switch (waytype)
@@ -355,6 +360,9 @@
 	s3d_translate(way_obj,point_zero[0], point_zero[1], point_zero[2]); 
 	s3d_link(way_obj,oidy);
 	s3d_flags_on(way_obj,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+	snprintf(query,MAXQ,"UPDATE way SET s3doid=%d WHERE way_id=%d AND %s;",way_obj,lastid,filter);
+	db_exec(query, NULL, 0);
+
 	waylist_n=0;
 
 	load_update_status((100.0*num_done)/(float)num_max);

Modified: trunk/apps/s3dosm/ui.c
===================================================================
--- trunk/apps/s3dosm/ui.c	2006-12-17 19:54:32 UTC (rev 539)
+++ trunk/apps/s3dosm/ui.c	2006-12-17 20:22:44 UTC (rev 540)
@@ -25,6 +25,8 @@
 #include <s3dw.h>
 #include "s3dosm.h"
 #include <stdio.h>	/* NULL */
+#include <string.h> /* strcmp */
+#include <stdlib.h> /* atoi() */
 icon_t icons[ICON_NUM]={
 		{"objs/accesspoint.3ds",0},
 		{"objs/noinetwep.3ds",0},
@@ -44,13 +46,77 @@
 static s3dw_label   *loadlabel=NULL;
 static s3dw_label   *loadstatus=NULL;
 
+void key_button(s3dw_widget *button)
+{
+	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
+}
+
+int ui_getinfo_node(void *data, int argc, char **argv, char **azColName) {
+	int i,tagid=-1;
+	char type[MAXQ];
+	char name[MAXQ];
+	char string[128];
+	s3dw_surface *miniwin;
+	s3dw_button  *button;
+
+	for(i=0; i<argc; i++) {
+		if (argv[i]) {
+			if (0==strcmp(azColName[i],"tag_id")) 			tagid=atoi(argv[i]);
+		}
+	}
+	if (db_gettag(tagid, "amenity",type)) type[0]=0;
+	if (db_gettag(tagid, "name",name)) name[0]=0;
+	
+	miniwin=s3dw_surface_new("About node",30,6);
+	snprintf(string,128,"name: %s",name);
+	s3dw_label_new(miniwin,string,1,2);
+	snprintf(string,128,"type: %s",type);
+	s3dw_label_new(miniwin,string,1,4);
+	button=s3dw_button_new(miniwin,"OK",2,6);
+	button->onclick=key_button;
+	s3dw_show(S3DWIDGET(miniwin));
+
+	return(0);
+}
+int ui_getinfo_way(void *data, int argc, char **argv, char **azColName) {
+	int i,tagid=-1;
+	char name[MAXQ];
+	char string[128];
+	s3dw_surface *miniwin;
+	s3dw_button  *button;
+
+	for(i=0; i<argc; i++) {
+		if (argv[i]) {
+			if (0==strcmp(azColName[i],"tag_id")) 			tagid=atoi(argv[i]);
+		}
+	}
+	if (db_gettag(tagid, "name",name)) name[0]=0;
+	printf("reporting street %s\n",name);
+
+	miniwin=s3dw_surface_new("About street",30,6);
+	snprintf(string,128,"name: %s",name);
+	s3dw_label_new(miniwin,string,1,2);
+	button=s3dw_button_new(miniwin,"OK",2,4);
+	button->onclick=key_button;
+	s3dw_show(S3DWIDGET(miniwin));
+
+	return(0);
+}
+
 int ui_click(struct s3d_evt *evt)
 {
 	int oid=(int)*((uint32_t *)evt->buf);
+	char query[MAXQ];
 	if (s3dw_handle_click(evt)) {
 		printf("s3dw got it?!\n");
+	} else {
+		
+		snprintf(query,MAXQ,"SELECT * FROM node WHERE s3doid=%d;",oid);
+		db_exec(query, ui_getinfo_node, 0);
+		snprintf(query,MAXQ,"SELECT * FROM way WHERE s3doid=%d;",oid);
+		db_exec(query, ui_getinfo_way, 0);
+
 	}
-	printf("clicked object %d\n",oid);
 
 	return(0);
 }



From dotslash at mail.berlios.de  Wed Dec 20 23:11:40 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 20 Dec 2006 23:11:40 +0100
Subject: [S3d-svn] r541 - in trunk: . apps/s3dosm
Message-ID: <200612202211.kBKMBeZv013108@sheep.berlios.de>

Author: dotslash
Date: 2006-12-20 23:11:40 +0100 (Wed, 20 Dec 2006)
New Revision: 541

Added:
   trunk/apps/s3dosm/olsrdump_convert.pl
Modified:
   trunk/
Log:
 r1303 at kero:  dotslash | 2006-12-20 23:11:35 +0100
 - olsrdump perlscript (just to have it in the svn)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1301
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1303

Added: trunk/apps/s3dosm/olsrdump_convert.pl
===================================================================
--- trunk/apps/s3dosm/olsrdump_convert.pl	2006-12-17 20:22:44 UTC (rev 540)
+++ trunk/apps/s3dosm/olsrdump_convert.pl	2006-12-20 22:11:40 UTC (rev 541)
@@ -0,0 +1,57 @@
+#!/usr/bin/env perl
+#
+# 
+# Copyright (C) 2006 Simon Wunderlich <dotslash at packetmixer.de>
+#
+# This file is part of s3dosm, a gps card application for s3d.
+# See http://s3d.berlios.de/ for more updates.
+# 
+# s3dosm is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# s3dosm is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with s3dosm; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#
+# converts freifunk database dump to osm format, which can be loaded with s3dosm.
+# this is no useful script, so don't package it or something. :)
+#
+$created_by="dotslash";
+$node_string="";
+$seg_string="";
+$way_string="";
+$id=-1;
+( $sec, $min, $hour, $day, $month, $year ) = ( localtime ) [ 0, 1, 2, 3, 4, 5 ];
+$timestamp =sprintf("%04d-%02d-%02d %02d:%02d:%02d",1900+$year,$month,$day, $hour,$min,$sec);
+
+print "<?xml version='1.0' encoding='UTF-8'?>\n";
+print "<osm version='0.3' generator='$created_by'>\n";
+
+while (<>) {
+	@a=split(",");
+	$ip=$a[1];
+	$name=$a[4];
+	@co=split("[(\ )]",$a[6]);
+	$lo=$co[2];
+	$la=$co[3];
+	if ($a[0]=~/^INSERT/) {
+		$node_string.=" <node id='$id' timestamp='$timestamp' lat='$la' lon='$lo'>\n";
+		$node_string.="   <tag k='created_by' v='$created_by' />\n";
+		$node_string.="   <tag k='amenity' v='accesspoint' />\n";
+		$node_string.="   <tag k='accesspoint' v='freifunk' />\n";
+		$node_string.="   <tag k='name' v=$name />\n";
+		$node_string.="   <tag k='ip' v=$ip />\n";
+		$node_string.=" </node>\n";
+	}
+	$id--;
+}
+print $node_string;
+print "</osm>\n";


Property changes on: trunk/apps/s3dosm/olsrdump_convert.pl
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + text/script



From dotslash at mail.berlios.de  Thu Dec 21 14:46:55 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 21 Dec 2006 14:46:55 +0100
Subject: [S3d-svn] r542 - in trunk: . libs3d libs3dw server
Message-ID: <200612211346.kBLDktku024847@sheep.berlios.de>

Author: dotslash
Date: 2006-12-21 14:46:54 +0100 (Thu, 21 Dec 2006)
New Revision: 542

Removed:
   trunk/libs3d/libg3d/
Modified:
   trunk/
   trunk/config.h.in
   trunk/configure.ac
   trunk/libs3d/Makefile.am
   trunk/libs3d/io.c
   trunk/libs3d/modelread.c
   trunk/libs3dw/animate.c
   trunk/libs3dw/arrange.c
   trunk/server/Makefile.am
   trunk/server/network.c
   trunk/server/shm.c
Log:
 r1305 at kero:  dotslash | 2006-12-21 14:46:49 +0100
 - general cleanup of autohell things (somehow)
 - remove our old libg3d-fork, use it as external dependency, and using g3d_model_load_full()
 - telling which process uses too much network load
 - asserting oid 0 (cam) in widget library



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1303
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1305

Modified: trunk/config.h.in
===================================================================
--- trunk/config.h.in	2006-12-20 22:11:40 UTC (rev 541)
+++ trunk/config.h.in	2006-12-21 13:46:54 UTC (rev 542)
@@ -6,8 +6,6 @@
 /* Use SDL */
 #undef G_SDL
 
-#undef HAVE_GPS
-
 /* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
    */
 #undef HAVE_DIRENT_H
@@ -18,6 +16,9 @@
 /* Define to 1 if you have the <fcntl.h> header file. */
 #undef HAVE_FCNTL_H
 
+/* Have gps support */
+#undef HAVE_GPS
+
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-12-20 22:11:40 UTC (rev 541)
+++ trunk/configure.ac	2006-12-21 13:46:54 UTC (rev 542)
@@ -24,8 +24,8 @@
 AC_PROG_INSTALL
 AC_PROG_LN_S
 AC_PROG_MAKE_SET
-AC_PATH_X
-AC_PATH_XTRA
+dnl AC_PATH_X
+dnl AC_PATH_XTRA
 AC_PROG_LIBTOOL
 
 AC_HEADER_DIRENT
@@ -44,8 +44,10 @@
 AC_CHECK_FUNCS([select socket strerror strtod strtol shmget signal]) # XXX: the previous test should have established the existence of signal() already. just be safe here.
 
 WARNS=""
-CFLAGS="$CFLAGS $X_CFLAGS -Wall -pedantic"
-LIBS="$X_PRE_LIBS $X_LIBS $X_EXTRA_LIBS $LIBS"
+dnl CFLAGS="$CFLAGS $X_CFLAGS -Wall -pedantic"
+CFLAGS="$CFLAGS -Wall -pedantic"
+dnl LIBS="$X_PRE_LIBS $X_LIBS $X_EXTRA_LIBS $LIBS"
+LIBS="$LIBS"
 
 ###
 ### Optional features 
@@ -103,8 +105,10 @@
 
 dnl ##################################### LIBS3D #######################################
 
+PKG_CHECK_MODULES(G3D, libg3d >= 0.0.6, [:], [AC_MSG_ERROR([Please install libg3d 0.0.6 or higher. (https://gna.org/projects/libg3d/)])])
 PKG_CHECK_MODULES(FONTCONFIG, fontconfig >= 2.1.0, [:], [AC_MSG_ERROR([Please install fontconfig (version 2.1.0 or higher)])])
 PKG_CHECK_MODULES(FREETYPE, freetype2 >= 9.5.0, [:], [AC_MSG_ERROR([Please install freetype2 (version 9.5.0 or higher)])])
+AM_PATH_GLIB_2_0(2.0.0,,AC_MSG_ERROR([Please install glib >= 2.0]), gmodule gobject)
 
 PKG_CHECK_MODULES(SQLITE3, sqlite3 >= 3.0, [HAVE_SQLITE3="yes"], [HAVE_SQLITE3="no"])
 # libxml2
@@ -166,37 +170,14 @@
 
 AC_ARG_WITH([examples], AS_HELP_STRING([--with-examples], [build examples]), [with_examples=$withval], [with_examples=yes])
 AM_CONDITIONAL([BUILD_EXAMPLES], [test x$with_examples = xyes])
-########################################### LIBG3D ################
-AM_PROG_LEX
 
-## gtk-doc
-# GTK_DOC_CHECK
-
-# glib
-AM_PATH_GLIB_2_0(2.0.0,,AC_MSG_ERROR([glib >= 2.0 is needed]), gmodule gobject)
-
-# gdk-pixbuf
-#AM_PATH_GTK_2_0(2.0.0, have_gtk2=true)
-#if test "x$have_gtk2" = "xtrue" ; then
-#GDKPIXBUF_CFLAGS=$GTK_CFLAGS
-#GDKPIXBUF_LIBS=$GTK_LIBS
-#AC_SUBST(GDKPIXBUF_CFLAGS)
-#AC_SUBST(GDKPIXBUF_LIBS)
-#fi
-#AM_CONDITIONAL([HAVE_GDKPIXBUF], test "x$have_gtk2" = "xtrue")
-
-# AC_DEFINE_DIR(PLUGIN_DIR, libdir/$PACKAGE/plugins, [Plugin directory])
-
 AC_OUTPUT(
 )
 
-DBG_CFLAGS=""
-AC_SUBST(DBG_CFLAGS)
-DEBUG=0
-AC_SUBST(DEBUG)
-AC_DEFINE_DIR(PLUGIN_DIR, libdir/$PACKAGE/plugins, [Plugin directory])
-PLUGINS_LDFLAGS="-avoid-version -export-dynamic"
-AC_SUBST(PLUGINS_LDFLAGS)
+#DBG_CFLAGS=""
+#AC_SUBST(DBG_CFLAGS)
+#DEBUG=0
+#AC_SUBST(DEBUG)
 
 ###
 ### This part just defined some things in config.h
@@ -215,7 +196,7 @@
 	AC_DEFINE([SIGS], 1, [Define if signal code should be compiled])
 fi
 
-AC_CONFIG_HEADERS(libs3d/libg3d/include/g3d/config.h config.h)
+AC_CONFIG_HEADERS(config.h)
 AC_CONFIG_FILES([
 	Makefile
 	server/Makefile
@@ -232,21 +213,9 @@
 	example/Makefile
 	objs/Makefile
 	Documentation/Makefile
-	libs3d/libg3d/Makefile
-	libs3d/libg3d/include/Makefile
-	libs3d/libg3d/include/g3d/Makefile
-	libs3d/libg3d/plugins/Makefile
-	libs3d/libg3d/plugins/image/Makefile
-	libs3d/libg3d/plugins/import/Makefile
-	libs3d/libg3d/src/Makefile
-	libs3d/libg3d/libg3d.pc
 	s3drc])
 AC_OUTPUT
-# libg3d
-#	libs3d/libg3d/doc/Makefile
-#	libs3d/libg3d/doc/api/Makefile
-#	libs3d/libg3d/m4/Makefile
-#	libs3d/libg3d/tests/Makefile
+
 if test "x$WARNS" != x; then
 echo "
 --------------------------------------------------------------------------------

Modified: trunk/libs3d/Makefile.am
===================================================================
--- trunk/libs3d/Makefile.am	2006-12-20 22:11:40 UTC (rev 541)
+++ trunk/libs3d/Makefile.am	2006-12-21 13:46:54 UTC (rev 542)
@@ -1,4 +1,3 @@
-SUBDIRS= libg3d
 lib_LTLIBRARIES=	libs3d.la
 
 libs3d_la_SOURCES=	modelread.c callback.c error.c event.c fontselect.c \
@@ -9,9 +8,12 @@
 include_HEADERS= s3d.h s3d_keysym.h
 noinst_HEADERS=		config.h s3dlib.h sei_triangulate.h sei_interface.h
 
+
 libs3d_la_CPPFLAGS=	-I${top_srcdir}/server
-libs3d_la_CFLAGS=	@FONTCONFIG_CFLAGS@ @FREETYPE_CFLAGS@ -I$(top_srcdir)/libs3d/libg3d/include @GLIB_CFLAGS@
-libs3d_la_LIBADD=	@FONTCONFIG_LIBS@ @FREETYPE_LIBS@ @LIBM@ 
-libs3d_la_LDFLAGS=	$(top_builddir)/libs3d/libg3d/src/libg3d.la
+#fontconfig_lo_CFLAGS=	@FONTCONFIG_CFLAGS@
+#freetype_lo_CFLAGS=	@FREETYPE_CFLAGS@
+#modelread_lo_CFLAGS=	@GLIB_CFLAGS@ @G3D_CFLAGS@
+libs3d_la_CFLAGS=		@FONTCONFIG_CFLAGS@ @FREETYPE_CFLAGS@ @GLIB_CFLAGS@ @G3D_CFLAGS@
+libs3d_la_LIBADD=		@FONTCONFIG_LIBS@ @FREETYPE_LIBS@ @LIBM@ @G3D_LIBS@
 
 EXTRA_DIST=		lgpl.txt

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2006-12-20 22:11:40 UTC (rev 541)
+++ trunk/libs3d/io.c	2006-12-21 13:46:54 UTC (rev 542)
@@ -221,7 +221,7 @@
 	if (fstat(fileno(fp),&bf))
 	{ errdn(VLOW,"s3d_open_file():fstat()",errno); return(-1);}
 	filesize=bf.st_size;
-	s3dprintf(LOW, "opening %s, filesize is %d",fname, filesize);
+/*	s3dprintf(LOW, "opening %s, filesize is %d",fname, filesize);*/
 	if ((buf=malloc(filesize))==NULL)
 	{
 		errn("s3d_open_3ds_file():malloc()",errno);

Modified: trunk/libs3d/modelread.c
===================================================================
--- trunk/libs3d/modelread.c	2006-12-20 22:11:40 UTC (rev 541)
+++ trunk/libs3d/modelread.c	2006-12-21 13:46:54 UTC (rev 542)
@@ -136,7 +136,7 @@
 
 	context = g3d_context_new();
 	obj_id=-1;
-	model = g3d_model_load(context, file);
+	model = g3d_model_load_full(context, file, 0);
 
 	if ( model ) {
 

Modified: trunk/libs3dw/animate.c
===================================================================
--- trunk/libs3dw/animate.c	2006-12-20 22:11:40 UTC (rev 541)
+++ trunk/libs3dw/animate.c	2006-12-21 13:46:54 UTC (rev 542)
@@ -45,6 +45,11 @@
 /* add an item on the animation stack */
 void s3dw_ani_add(s3dw_widget *f)
 {
+
+	if ((f->oid == 0) && (f->type!=S3DW_TCAM)) {
+		s3dprintf(HIGH,"s3dw_ani_add() assert failed: weird, moving cam but its not a cam obeject?");
+		return;
+	}
 	if ((ani_n<MAXANI) && (animation_on))
 	{
 		if (s3dw_ani_onstack(f))
@@ -72,8 +77,11 @@
 void s3dw_ani_doit(s3dw_widget *f)
 {
 	if ((f->oid == 0) && (f->type!=S3DW_TCAM)) {
-		s3dprintf(HIGH,"assert failed: weird, moving cam but its not a cam obeject?");
+		s3dprintf(HIGH,"s3dw_ani_doit() assert failed: weird, moving cam but its not a cam obeject?");
 	} else {
+		if (f->oid==0) {
+			s3dprintf(HIGH,"moving cam");
+		}
 		s3d_translate(	f->oid, f->ax,f->ay,f->az);
 		s3d_rotate(		f->oid, f->arx,f->ary,f->arz);
 		s3d_scale(		f->oid, f->as);

Modified: trunk/libs3dw/arrange.c
===================================================================
--- trunk/libs3dw/arrange.c	2006-12-20 22:11:40 UTC (rev 541)
+++ trunk/libs3dw/arrange.c	2006-12-21 13:46:54 UTC (rev 542)
@@ -177,10 +177,10 @@
 	{
 		w1=root->pobj[i];
 		arranged=1;
-		for (j=0;j<root->nobj;j++)
-			if (i!=j)
+		for (j=0;j<root->nobj;j++) {
+			w2=root->pobj[j];
+			if ((i!=j) && ((w1->oid!=0) && (w2->oid!=0)))
 			{
-				w2=root->pobj[j];
 				s3dw_arr_widgetcenter(w1,f1);
 				s3dw_arr_widgetcenter(w2,f2);
 				len1=s3d_vector_length(f1);
@@ -225,6 +225,7 @@
 					}
 				}
 			}
+		}
 		if (arranged)
 			w1->flags|=S3DW_ARRANGED;
 	}

Modified: trunk/server/Makefile.am
===================================================================
--- trunk/server/Makefile.am	2006-12-20 22:11:40 UTC (rev 541)
+++ trunk/server/Makefile.am	2006-12-21 13:46:54 UTC (rev 542)
@@ -19,6 +19,6 @@
 	shm.c shm_ringbuf.c tcp.c user.c
 
 s3d_LDADD=	@LIBM@ @GL_LIBS@ ${MAYBE_SDL_LIBS} ${MAYBE_GLUT_LIBS}
-s3d_CFLAGS=	@GL_CFLAGS@ ${MAYBE_SDL_CFLAGS} ${MAYBE_GLUT_CFLAGS} ${DEVEL_CFLAGS} -I$(top_srcdir)/libs3d
+s3d_CFLAGS=	@GL_CFLAGS@ ${MAYBE_SDL_CFLAGS} ${MAYBE_GLUT_CFLAGS} ${DEVEL_CFLAGS} 
 
 noinst_HEADERS=	config.h global.h proto.h

Modified: trunk/server/network.c
===================================================================
--- trunk/server/network.c	2006-12-20 22:11:40 UTC (rev 541)
+++ trunk/server/network.c	2006-12-21 13:46:54 UTC (rev 542)
@@ -84,7 +84,7 @@
 int					 turn;
 int	net_turn_off(int interval)
 {
-	s3dprintf(HIGH,"Warning: High traffic on Network, interrupting read.");
+	s3dprintf(VLOW,"Warning: High traffic on Network, interrupting read.");
 	turn=0;
 	return(0);
 }

Modified: trunk/server/shm.c
===================================================================
--- trunk/server/shm.c	2006-12-20 22:11:40 UTC (rev 541)
+++ trunk/server/shm.c	2006-12-21 13:46:54 UTC (rev 542)
@@ -196,8 +196,10 @@
 					shm_prot_com_in(&procs_p[i]);
 					if (turn)
 						i--; /* evil hack: decrease i so it will be our turn again in the next round */
-					else
+					else {
+						s3dprintf(MED,"client %d [%s] seems to want to keep us busy ... ",i, procs_p[i].name);
 						turn=1; /* don't decrease, it's next connections turn */
+					}
 				} else {
 					if (procs_p[i].shmsock.idle++>MAX_IDLE)
 					{ /* maybe the function timed out somehow ...? let's check ...*/



From dotslash at mail.berlios.de  Thu Dec 21 15:34:42 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 21 Dec 2006 15:34:42 +0100
Subject: [S3d-svn] r543 - in trunk: . libs3d
Message-ID: <200612211434.kBLEYgc1002754@sheep.berlios.de>

Author: dotslash
Date: 2006-12-21 15:34:42 +0100 (Thu, 21 Dec 2006)
New Revision: 543

Modified:
   trunk/
   trunk/libs3d/io.c
Log:
 r1307 at kero:  dotslash | 2006-12-21 15:34:33 +0100
 - kill endlessloop in s3d_quit();



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1305
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1307

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2006-12-21 13:46:54 UTC (rev 542)
+++ trunk/libs3d/io.c	2006-12-21 14:34:42 UTC (rev 543)
@@ -166,23 +166,27 @@
 int s3d_quit()
 {
 	struct s3d_evt *ret;
-	net_send(S3D_P_C_QUIT,NULL,0);
-	switch (con_type)
-	{
+	if (con_type!=CON_NULL && _s3d_ready) {
+		net_send(S3D_P_C_QUIT,NULL,0);
+		switch (con_type)
+		{
 #ifdef TCP
-		case CON_TCP:_tcp_quit();break;
+			case CON_TCP:_tcp_quit();break;
 #endif
 #ifdef SHM
-		case CON_SHM:_shm_quit();break;
+			case CON_SHM:_shm_quit();break;
 #endif
+		}
+		con_type=CON_NULL;
+		_s3d_ready=0;
+		_queue_quit();
+		while (NULL!=(ret=s3d_pop_event())) s3d_delete_event(ret);  /*  clear the stack ... */
+		cb_lock=0; /* we don't care about old callbacks, now we just quit! */
+		ret=malloc(sizeof(struct s3d_evt));
+		ret->event=S3D_EVENT_QUIT;
+		ret->length=0;
+		s3d_push_event(ret);
 	}
-	con_type=CON_NULL;
-	_queue_quit();
-	while (NULL!=(ret=s3d_pop_event())) s3d_delete_event(ret);  /*  clear the stack ... */
-	ret=malloc(sizeof(struct s3d_evt));
-	ret->event=S3D_EVENT_QUIT;
-	ret->length=0;
-	s3d_push_event(ret);
 	return(0);
 }
 /*  apps should use that as main loop for their programs. */



From dotslash at mail.berlios.de  Thu Dec 21 17:23:56 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 21 Dec 2006 17:23:56 +0100
Subject: [S3d-svn] r544 - in trunk: . libs3d libs3dw
Message-ID: <200612211623.kBLGNu2x021940@sheep.berlios.de>

Author: dotslash
Date: 2006-12-21 17:23:56 +0100 (Thu, 21 Dec 2006)
New Revision: 544

Added:
   trunk/libs3d/libs3d.pc.in
   trunk/libs3dw/libs3dw.pc.in
Modified:
   trunk/
   trunk/configure.ac
Log:
 r1309 at kero:  dotslash | 2006-12-21 17:23:47 +0100
 - add package-config things for libs3d and libs3dw



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1307
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1309

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-12-21 14:34:42 UTC (rev 543)
+++ trunk/configure.ac	2006-12-21 16:23:56 UTC (rev 544)
@@ -1,6 +1,6 @@
 dnl Process this file with autoconf to produce a configure script.
 AC_PREREQ(2.5)
-AC_INIT([s3d], [0.1.1])
+AC_INIT([s3d], [0.2.0])
 AC_CONFIG_SRCDIR(server/main.c)
 
 AC_CANONICAL_HOST
@@ -213,6 +213,8 @@
 	example/Makefile
 	objs/Makefile
 	Documentation/Makefile
+	libs3d/libs3d.pc
+	libs3dw/libs3dw.pc
 	s3drc])
 AC_OUTPUT
 

Added: trunk/libs3d/libs3d.pc.in
===================================================================
--- trunk/libs3d/libs3d.pc.in	2006-12-21 14:34:42 UTC (rev 543)
+++ trunk/libs3d/libs3d.pc.in	2006-12-21 16:23:56 UTC (rev 544)
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libs3d
+Version: @VERSION@
+Description: Client library for the s3d server
+Requires: libg3d
+Libs: -L${libdir} -ls3d
+Cflags: -I${includedir}

Added: trunk/libs3dw/libs3dw.pc.in
===================================================================
--- trunk/libs3dw/libs3dw.pc.in	2006-12-21 14:34:42 UTC (rev 543)
+++ trunk/libs3dw/libs3dw.pc.in	2006-12-21 16:23:56 UTC (rev 544)
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libs3dw
+Version: @VERSION@
+Description: Widget library based on libs3d
+Requires: libs3d
+Libs: -L${libdir} -ls3dw
+Cflags: -I${includedir}



From marec at mail.berlios.de  Fri Dec 22 02:41:10 2006
From: marec at mail.berlios.de (marec at BerliOS)
Date: Fri, 22 Dec 2006 02:41:10 +0100
Subject: [S3d-svn] r545 - trunk/apps/kism3d
Message-ID: <200612220141.kBM1fA1R004445@sheep.berlios.de>

Author: marec
Date: 2006-12-22 02:41:08 +0100 (Fri, 22 Dec 2006)
New Revision: 545

Modified:
   trunk/apps/kism3d/gui.c
Log:
move to network on click

Modified: trunk/apps/kism3d/gui.c
===================================================================
--- trunk/apps/kism3d/gui.c	2006-12-21 16:23:56 UTC (rev 544)
+++ trunk/apps/kism3d/gui.c	2006-12-22 01:41:08 UTC (rev 545)
@@ -385,27 +385,26 @@
 
 	if ( Cam_target != NULL ) {
 
-		/* move to network */
-		printf( "Moving to Network: %s, %s\n", ((struct wlan_network *)Cam_target)->bssid, ((struct wlan_network *)Cam_target)->ssid );
+		/* move to target */
+		/* printf( "Moving to Network: %s, %s\n", ((struct wlan_network *)Cam_target)->bssid, ((struct wlan_network *)Cam_target)->ssid ); */
 
-		CamPosition[0][0] = ( CamPosition[0][0] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[0] + 7 ) / 5;
+		CamPosition[0][0] = ( CamPosition[0][0] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[0] + 10 ) / 5;
 		CamPosition[0][1] = ( CamPosition[0][1] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[1] ) / 5;
-		CamPosition[0][2] = ( CamPosition[0][2] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[2] + 7 ) / 5;
+		CamPosition[0][2] = ( CamPosition[0][2] * 4 + ((struct wlan_network *)Cam_target)->pos_vec[2] ) / 5;
 
-		diff_vec[0] = CamPosition[0][0] - ((struct wlan_network *)Cam_target)->pos_vec[0] + 7;
+		diff_vec[0] = CamPosition[0][0] - ((struct wlan_network *)Cam_target)->pos_vec[0];
 		diff_vec[1] = 0.0;
-		diff_vec[2] = CamPosition[0][2] - ((struct wlan_network *)Cam_target)->pos_vec[2] + 7;
+		diff_vec[2] = CamPosition[0][2] - ((struct wlan_network *)Cam_target)->pos_vec[2];
 
 		angle = s3d_vector_angle( diff_vec, tmp_vec );
-		/* angle = ( real_node_pos[0] > 0) ? ( 180 - ( 180 / M_PI * angle ) ) : ( 180 + ( 180 / M_PI * angle ) ); */
 		angle = 180 - ( 180 / M_PI * angle );
 		CamPosition[1][1] = ( CamPosition[1][1] * 4 + angle ) / 5;
 
-		s3d_translate( 0, CamPosition[1][0], CamPosition[1][1], CamPosition[1][2] );
+		s3d_translate( 0, CamPosition[0][0], CamPosition[0][1], CamPosition[0][2] );
 		s3d_rotate( 0, CamPosition[1][0], CamPosition[1][1], CamPosition[1][2] );
 
-		/* TODO: need an abort if target is reached
-			Cam_target = NULL; */
+		if ( ( fabs( diff_vec[0] ) < 11.0 ) && ( fabs( CamPosition[0][1] - ((struct wlan_network *)Cam_target)->pos_vec[1] ) < 1.0 ) && ( fabs( diff_vec[2] ) < 1.0 ) )
+			Cam_target = NULL;
 
 	}
 



From lazhur at mail.berlios.de  Fri Dec 22 22:48:24 2006
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Fri, 22 Dec 2006 22:48:24 +0100
Subject: [S3d-svn] r546 - in trunk/extras/distro/gentoo: . media-gfx/s3d
	media-gfx/s3d-svn media-gfx/s3d-svn/files media-libs
	media-libs/libg3d media-libs/libg3d/files
Message-ID: <200612222148.kBMLmOIR005947@sheep.berlios.de>

Author: lazhur
Date: 2006-12-22 22:48:23 +0100 (Fri, 22 Dec 2006)
New Revision: 546

Added:
   trunk/extras/distro/gentoo/media-libs/
   trunk/extras/distro/gentoo/media-libs/libg3d/
   trunk/extras/distro/gentoo/media-libs/libg3d/ChangeLog
   trunk/extras/distro/gentoo/media-libs/libg3d/Manifest
   trunk/extras/distro/gentoo/media-libs/libg3d/files/
   trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.3
   trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.5
   trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.6.20061222
   trunk/extras/distro/gentoo/media-libs/libg3d/files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2
   trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.3.ebuild
   trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.5.ebuild
   trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.20061222.ebuild
   trunk/extras/distro/gentoo/media-libs/libg3d/metadata.xml
Modified:
   trunk/extras/distro/gentoo/media-gfx/s3d-svn/Manifest
   trunk/extras/distro/gentoo/media-gfx/s3d-svn/files/digest-s3d-svn-9999
   trunk/extras/distro/gentoo/media-gfx/s3d-svn/s3d-svn-9999.ebuild
   trunk/extras/distro/gentoo/media-gfx/s3d/Manifest
   trunk/extras/distro/gentoo/media-gfx/s3d/s3d-0.1.1.ebuild
Log:
- Add libg3d as dependency for s3d-svn
- Insert libg3d ebuilds
- Add libgps as optional dependency for s3d-svn (via use flag)
- Add flex output for libg3d svn snapshot as workaround for autohell (like in official packages)
- Mark libg3d as blocker for current stable s3d release


Modified: trunk/extras/distro/gentoo/media-gfx/s3d/Manifest
===================================================================
--- trunk/extras/distro/gentoo/media-gfx/s3d/Manifest	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-gfx/s3d/Manifest	2006-12-22 21:48:23 UTC (rev 546)
@@ -1,8 +1,8 @@
 DIST s3d-0.1.1.tar.bz2 1737935 RMD160 88189600659dd4d184be044dd668597ab2b17334 SHA1 3765171848d519784a436468ac613c9bfe85c3ae SHA256 1e2be7c806deaaf07e7f00d018f6f08723a1b26332419a80e732c8b7a1a515e4
-EBUILD s3d-0.1.1.ebuild 811 RMD160 36bf79576e7d2a2ccf0cf89c4ed537ca51bc78ab SHA1 acbea5f89f40d0647b04eb995e4231182611faf8 SHA256 34f72a57351fd53658e44632f161e591b941b6a9e8c83c953845c298ddf855ae
-MD5 13108513bab3168db7b566ec750603a4 s3d-0.1.1.ebuild 811
-RMD160 36bf79576e7d2a2ccf0cf89c4ed537ca51bc78ab s3d-0.1.1.ebuild 811
-SHA256 34f72a57351fd53658e44632f161e591b941b6a9e8c83c953845c298ddf855ae s3d-0.1.1.ebuild 811
+EBUILD s3d-0.1.1.ebuild 831 RMD160 7ab28a5a7b10a86051ff35dec715524ddac33d98 SHA1 becb13dedb85a733431241c0985b285553b0df4b SHA256 661794ee708d800655fe6e4c568173d7c7f7996e7c1bda077d52028d88b9d841
+MD5 745d3278b3dc2e7ffa3e13fe8d670061 s3d-0.1.1.ebuild 831
+RMD160 7ab28a5a7b10a86051ff35dec715524ddac33d98 s3d-0.1.1.ebuild 831
+SHA256 661794ee708d800655fe6e4c568173d7c7f7996e7c1bda077d52028d88b9d841 s3d-0.1.1.ebuild 831
 MISC ChangeLog 148 RMD160 cb8db163c4842d0f8d8d4ad41ba7516765f1b0a3 SHA1 70661ac4033b04c51f6928f82d9903bfa86eb0b3 SHA256 e61b9d97b0c64076e833b27201c5eda91b02f5d885a37b5f4d005c03a44c405c
 MD5 31944463e2ea8d52f7172c7b838927be ChangeLog 148
 RMD160 cb8db163c4842d0f8d8d4ad41ba7516765f1b0a3 ChangeLog 148

Modified: trunk/extras/distro/gentoo/media-gfx/s3d/s3d-0.1.1.ebuild
===================================================================
--- trunk/extras/distro/gentoo/media-gfx/s3d/s3d-0.1.1.ebuild	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-gfx/s3d/s3d-0.1.1.ebuild	2006-12-22 21:48:23 UTC (rev 546)
@@ -16,6 +16,7 @@
 	>=sys-devel/libtool-1.5
 	"
 RDEPEND="!media-gfx/s3d-svn
+	!media-libs/libg3d
 	>=media-libs/libsdl-1.2.7
 	>=media-libs/freetype-2
 	>=dev-libs/glib-2

Modified: trunk/extras/distro/gentoo/media-gfx/s3d-svn/Manifest
===================================================================
--- trunk/extras/distro/gentoo/media-gfx/s3d-svn/Manifest	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-gfx/s3d-svn/Manifest	2006-12-22 21:48:23 UTC (rev 546)
@@ -1,7 +1,7 @@
-EBUILD s3d-svn-9999.ebuild 905 RMD160 34bd888b19648084ae8dc8e5d603f898a6e86774 SHA1 d228cd4a38efb52c06db1e680e5936c8ac7b55d8 SHA256 202c2a6c56bdfb6b9353dbfd755994e235cb0f9333f12d03d27c6fcabc87f447
-MD5 518f54a8fb0a29a9a3ec6e650da58480 s3d-svn-9999.ebuild 905
-RMD160 34bd888b19648084ae8dc8e5d603f898a6e86774 s3d-svn-9999.ebuild 905
-SHA256 202c2a6c56bdfb6b9353dbfd755994e235cb0f9333f12d03d27c6fcabc87f447 s3d-svn-9999.ebuild 905
+EBUILD s3d-svn-9999.ebuild 986 RMD160 8e237a2e5b13cb61449016e5eff0a9924d0270c3 SHA1 112dd0180beebd50a46584ae50d7024cca4935ec SHA256 a7311f9e57c595bdc77a7bbe4ead0f972222bd33f86a16a7ad4467fdc9ebaad0
+MD5 333cca4eef0cb4e7e7bf6478e7127993 s3d-svn-9999.ebuild 986
+RMD160 8e237a2e5b13cb61449016e5eff0a9924d0270c3 s3d-svn-9999.ebuild 986
+SHA256 a7311f9e57c595bdc77a7bbe4ead0f972222bd33f86a16a7ad4467fdc9ebaad0 s3d-svn-9999.ebuild 986
 MISC ChangeLog 295 RMD160 818b9134758d8a5d81be67d25ab990fe7cc71283 SHA1 529b5c00b3ad8067f06ce4bcc41d6a185fb2670d SHA256 cd5d36bee2dce3a94ce0f4f65ad7dc4ab8d299e48e57f48aa0a609eb06fe4885
 MD5 569601eaa0bbba92427ed05da0dfc050 ChangeLog 295
 RMD160 818b9134758d8a5d81be67d25ab990fe7cc71283 ChangeLog 295
@@ -10,6 +10,6 @@
 MD5 261031c8b7aca6f50babf7e44b35deb1 metadata.xml 239
 RMD160 236f28d8249f562b764e2d854580d8301b150418 metadata.xml 239
 SHA256 c0f08f1f0c1ce07df414cd87bf028a15cae639c89b2d636714d50d8aa77c370f metadata.xml 239
-MD5 68b329da9893e34099c7d8ad5cb9c940 files/digest-s3d-svn-9999 1
-RMD160 c0da025038ed83c687ddc430da9846ecb97f3998 files/digest-s3d-svn-9999 1
-SHA256 01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b files/digest-s3d-svn-9999 1
+MD5 d41d8cd98f00b204e9800998ecf8427e files/digest-s3d-svn-9999 0
+RMD160 9c1185a5c5e9fc54612808977ee8f548b2258d31 files/digest-s3d-svn-9999 0
+SHA256 e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 files/digest-s3d-svn-9999 0

Modified: trunk/extras/distro/gentoo/media-gfx/s3d-svn/files/digest-s3d-svn-9999
===================================================================
--- trunk/extras/distro/gentoo/media-gfx/s3d-svn/files/digest-s3d-svn-9999	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-gfx/s3d-svn/files/digest-s3d-svn-9999	2006-12-22 21:48:23 UTC (rev 546)
@@ -1 +0,0 @@
-

Modified: trunk/extras/distro/gentoo/media-gfx/s3d-svn/s3d-svn-9999.ebuild
===================================================================
--- trunk/extras/distro/gentoo/media-gfx/s3d-svn/s3d-svn-9999.ebuild	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-gfx/s3d-svn/s3d-svn-9999.ebuild	2006-12-22 21:48:23 UTC (rev 546)
@@ -1,6 +1,6 @@
 inherit subversion
 
-IUSE=""
+IUSE="gps"
 
 ESVN_REPO_URI="http://svn.berlios.de/svnroot/repos/s3d/trunk"
 ESVN_BOOTSTRAP="./autogen.sh --no-configure"
@@ -23,8 +23,10 @@
 	>=media-libs/libsdl-1.2.7
 	>=media-libs/freetype-2
 	>=dev-libs/glib-2
+	dev-libs/libxml2
 	media-fonts/ttf-bitstream-vera
 	media-libs/fontconfig
+	>=media-libs/libg3d-0.0.6
 	media-libs/mesa
 
 	|| ( 	(
@@ -37,6 +39,8 @@
 			x11-libs/libXtst )
 		virtual/x11 )
 
+	gps? ( sci-geosciences/gpsd )	
+
 	virtual/glut
 	"
 

Added: trunk/extras/distro/gentoo/media-libs/libg3d/ChangeLog
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/ChangeLog	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/ChangeLog	2006-12-22 21:48:23 UTC (rev 546)
@@ -0,0 +1,17 @@
+# ChangeLog for media-gfx/libg3d
+
+*libg3d-0.0.6.20061222 (22 Dec 2006)
+
+  22 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> libg3d-0.0.6.20061222.ebuild:
+  Add snapshot to build s3d-svn.
+
+*libg3d-0.0.3 (22 Dec 2006)
+
+  22 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> libg3d-0.0.3.ebuild:
+  Version bump.
+
+*libg3d-0.0.3 (22 Dec 2006)
+
+  22 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> libg3d-0.0.3.ebuild:
+  Initial import.
+

Added: trunk/extras/distro/gentoo/media-libs/libg3d/Manifest
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/Manifest	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/Manifest	2006-12-22 21:48:23 UTC (rev 546)
@@ -0,0 +1,35 @@
+AUX libg3d-0.0.6.20061222-missingflexheaders.patch.bz2 18052 RMD160 d0d096e454917ca6a6d7938e4075f6e941c2e869 SHA1 f84a33261fb2e8a3a9eb2f6696fafd13662bfe5a SHA256 0391c8d6e62b3ec7e03d9f954363b35cc39d78a757ca14b29effedb7f6b1713b
+MD5 1ca9ec4968c57570ea04f3ede657de36 files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2 18052
+RMD160 d0d096e454917ca6a6d7938e4075f6e941c2e869 files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2 18052
+SHA256 0391c8d6e62b3ec7e03d9f954363b35cc39d78a757ca14b29effedb7f6b1713b files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2 18052
+DIST libg3d-0.0.3.tar.gz 438414 RMD160 3c1158d0b8a9580b78808152eaa179286e852a9c SHA1 768608dfc78d88f53ffb4d520bd434fe8c362c44 SHA256 d8c08448586b4d6f70c5933c89877f81e8f31d7eea8f3497b0d12357134a71e0
+DIST libg3d-0.0.5.tar.gz 475879 RMD160 505474c8187bd97126327e1e6c9225f72c1bbdff SHA1 3c1453fe41d60fb4d8ffa69fbb41aa6df2faa50a SHA256 4d19ea782ef71d862fae99291b6355b1331a309f68674ae301a9e1fd68c8c32a
+EBUILD libg3d-0.0.3.ebuild 606 RMD160 a318c6923751577442f9b684dd881a6e126b2e9c SHA1 9ca4be706d0c022f2ebd15632c78823f4c8d6750 SHA256 fc8d0e24adaa09d52c1a3c4d2f3b1765a5e0e70362cfba689abb6a9b2b91b10d
+MD5 35fca5596ed05c3d8d9ca82b7ee7e7c8 libg3d-0.0.3.ebuild 606
+RMD160 a318c6923751577442f9b684dd881a6e126b2e9c libg3d-0.0.3.ebuild 606
+SHA256 fc8d0e24adaa09d52c1a3c4d2f3b1765a5e0e70362cfba689abb6a9b2b91b10d libg3d-0.0.3.ebuild 606
+EBUILD libg3d-0.0.5.ebuild 667 RMD160 65e4eba6ff273b66cf8b6ff16693f38d4e8fa5cb SHA1 adcd841e8c3afbac819eed804b62399cd4c4c7c9 SHA256 fecae46969199e5d852fa308c1eafcbfcc9fb9f846a2311367afde8a25752af6
+MD5 2180cc92be1d9ac65d14cf2fa5ceec3f libg3d-0.0.5.ebuild 667
+RMD160 65e4eba6ff273b66cf8b6ff16693f38d4e8fa5cb libg3d-0.0.5.ebuild 667
+SHA256 fecae46969199e5d852fa308c1eafcbfcc9fb9f846a2311367afde8a25752af6 libg3d-0.0.5.ebuild 667
+EBUILD libg3d-0.0.6.20061222.ebuild 912 RMD160 4140176144360366b7dd5b042207c462ab3e3aeb SHA1 2251930c85b3df5aab0390350f20ce8bfa81f6bb SHA256 ae4e03dda245e2660adf0ee9d59b7e20577ad1bb73c90ab0dd05d6c24d551f7f
+MD5 9870cec7558a12008d2ee0f138642c11 libg3d-0.0.6.20061222.ebuild 912
+RMD160 4140176144360366b7dd5b042207c462ab3e3aeb libg3d-0.0.6.20061222.ebuild 912
+SHA256 ae4e03dda245e2660adf0ee9d59b7e20577ad1bb73c90ab0dd05d6c24d551f7f libg3d-0.0.6.20061222.ebuild 912
+MISC ChangeLog 434 RMD160 8ae5dfbf992a75eb1f54c704f9a7a65b162f2e1c SHA1 34ddae58d819a00a64e3e99b3f06b240318519bf SHA256 44259a04f04114d1d9785e93ac88c252ea5a76bb23bde8a0ba4c452cb6a8ca20
+MD5 091461b75c05b62e0d86b9ebea829443 ChangeLog 434
+RMD160 8ae5dfbf992a75eb1f54c704f9a7a65b162f2e1c ChangeLog 434
+SHA256 44259a04f04114d1d9785e93ac88c252ea5a76bb23bde8a0ba4c452cb6a8ca20 ChangeLog 434
+MISC metadata.xml 239 RMD160 236f28d8249f562b764e2d854580d8301b150418 SHA1 76f167e3abff81e9535c16a637fd1e7f91d4fda3 SHA256 c0f08f1f0c1ce07df414cd87bf028a15cae639c89b2d636714d50d8aa77c370f
+MD5 261031c8b7aca6f50babf7e44b35deb1 metadata.xml 239
+RMD160 236f28d8249f562b764e2d854580d8301b150418 metadata.xml 239
+SHA256 c0f08f1f0c1ce07df414cd87bf028a15cae639c89b2d636714d50d8aa77c370f metadata.xml 239
+MD5 167d7c9af354501f79ef1bc3377716de files/digest-libg3d-0.0.3 238
+RMD160 5773a2974b9a56d67ce4f310ab90672fad9a028e files/digest-libg3d-0.0.3 238
+SHA256 8e52678fd08e00de76a2b2dd2fcda7a9569a4f38c480bbad763470fd5d327efe files/digest-libg3d-0.0.3 238
+MD5 5e38c09ab217ac68f78491c99aaebe4d files/digest-libg3d-0.0.5 238
+RMD160 b72684e7e6a5c2375fe3167ac92ab4149a0ad379 files/digest-libg3d-0.0.5 238
+SHA256 9e800635187be7c188bdacb3d4e321783f5226ef12b808b7353a62cf29dcd012 files/digest-libg3d-0.0.5 238
+MD5 d41d8cd98f00b204e9800998ecf8427e files/digest-libg3d-0.0.6.20061222 0
+RMD160 9c1185a5c5e9fc54612808977ee8f548b2258d31 files/digest-libg3d-0.0.6.20061222 0
+SHA256 e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 files/digest-libg3d-0.0.6.20061222 0

Added: trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.3
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.3	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.3	2006-12-22 21:48:23 UTC (rev 546)
@@ -0,0 +1,3 @@
+MD5 f4ecf652e437cba69d905ef8e13a71eb libg3d-0.0.3.tar.gz 438414
+RMD160 3c1158d0b8a9580b78808152eaa179286e852a9c libg3d-0.0.3.tar.gz 438414
+SHA256 d8c08448586b4d6f70c5933c89877f81e8f31d7eea8f3497b0d12357134a71e0 libg3d-0.0.3.tar.gz 438414

Added: trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.5
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.5	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.5	2006-12-22 21:48:23 UTC (rev 546)
@@ -0,0 +1,3 @@
+MD5 f089060580dcc5730128028c3554aac3 libg3d-0.0.5.tar.gz 475879
+RMD160 505474c8187bd97126327e1e6c9225f72c1bbdff libg3d-0.0.5.tar.gz 475879
+SHA256 4d19ea782ef71d862fae99291b6355b1331a309f68674ae301a9e1fd68c8c32a libg3d-0.0.5.tar.gz 475879

Added: trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.6.20061222
===================================================================

Added: trunk/extras/distro/gentoo/media-libs/libg3d/files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2
===================================================================
(Binary files differ)


Property changes on: trunk/extras/distro/gentoo/media-libs/libg3d/files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.3.ebuild
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.3.ebuild	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.3.ebuild	2006-12-22 21:48:23 UTC (rev 546)
@@ -0,0 +1,36 @@
+IUSE="gtk"
+
+SRC_URI="http://download.gna.org/${PN}/${P}.tar.gz"
+
+DESCRIPTION="library for loading 3D models of many file types"
+HOMEPAGE="https://gna.org/projects/libg3d/"
+
+LICENSE="GPL-2 LGPL"
+KEYWORDS="x86"
+SLOT="0"
+
+DEPEND="${RDEPEND}
+	>=sys-devel/autoconf-2.59
+	>=sys-devel/automake-1.9
+	sys-devel/flex
+	>=sys-devel/libtool-1.5
+	"
+RDEPEND="!<=media-gfx/s3d-0.1.1
+	>=dev-libs/glib-2
+
+	gtk? ( >=x11-libs/gtk+-2 )
+	"
+
+src_compile() {
+	econf \
+		$(use_enable gtk gtktest) \
+		--prefix=/usr/ \
+		|| die "econf failed"
+
+	emake || die "emake failed"
+}
+
+src_install() {
+	emake DESTDIR="${D}" install || die
+}
+

Added: trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.5.ebuild
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.5.ebuild	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.5.ebuild	2006-12-22 21:48:23 UTC (rev 546)
@@ -0,0 +1,38 @@
+IUSE="gtk xml"
+
+SRC_URI="http://download.gna.org/${PN}/${P}.tar.gz"
+
+DESCRIPTION="library for loading 3D models of many file types"
+HOMEPAGE="https://gna.org/projects/libg3d/"
+
+LICENSE="GPL-2 LGPL"
+KEYWORDS="x86"
+SLOT="0"
+
+DEPEND="${RDEPEND}
+	>=sys-devel/autoconf-2.59
+	>=sys-devel/automake-1.9
+	sys-devel/flex
+	>=sys-devel/libtool-1.5
+	"
+RDEPEND="!<=media-gfx/s3d-0.1.1
+	>=dev-libs/glib-2
+
+	gtk? ( >=x11-libs/gtk+-2 )
+	xml? ( dev-libs/libxml2 )
+	"
+
+src_compile() {
+	econf \
+		$(use_enable gtk gtktest) \
+		$(use_enable xml xmltest) \
+		--prefix=/usr/ \
+		|| die "econf failed"
+
+	emake || die "emake failed"
+}
+
+src_install() {
+	emake DESTDIR="${D}" install || die
+}
+

Added: trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.20061222.ebuild
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.20061222.ebuild	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.20061222.ebuild	2006-12-22 21:48:23 UTC (rev 546)
@@ -0,0 +1,49 @@
+inherit subversion eutils
+
+IUSE="gtk xml"
+
+ESVN_REPO_URI="http://svn.gna.org/svn/libg3d/trunk"
+ESVN_OPTIONS="--revision {2006-12-22}"
+ESVN_BOOTSTRAP="./autogen.sh"
+
+DESCRIPTION="library for loading 3D models of many file types"
+HOMEPAGE="https://gna.org/projects/libg3d/"
+
+LICENSE="GPL-2 LGPL"
+KEYWORDS="~x86 ~amd64"
+SLOT="0"
+
+DEPEND="${RDEPEND}
+	dev-util/gtk-doc
+	>=sys-devel/autoconf-2.59
+	>=sys-devel/automake-1.9
+	sys-devel/flex
+	>=sys-devel/libtool-1.5
+	"
+RDEPEND="!<=media-gfx/s3d-0.1.1
+	>=dev-libs/glib-2
+
+	gtk? ( >=x11-libs/gtk+-2 )
+	xml? ( dev-libs/libxml2 )
+	"
+
+src_unpack() {
+	subversion_src_unpack
+	cd "${S}"
+	epatch ${FILESDIR}/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2
+}
+
+src_compile() {
+	econf \
+		$(use_enable gtk gtktest) \
+		$(use_enable xml xmltest) \
+		--prefix=/usr/ \
+		|| die "econf failed"
+
+	emake || die "emake failed"
+}
+
+src_install() {
+	emake DESTDIR="${D}" install || die
+}
+

Added: trunk/extras/distro/gentoo/media-libs/libg3d/metadata.xml
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/metadata.xml	2006-12-22 01:41:08 UTC (rev 545)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/metadata.xml	2006-12-22 21:48:23 UTC (rev 546)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
+<pkgmetadata>
+  <herd>d0tslash</herd>
+    <maintainer>
+    <email>dotslash at packetmixer.de</email>
+  </maintainer>
+</pkgmetadata>



From lazhur at mail.berlios.de  Sat Dec 23 12:41:04 2006
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sat, 23 Dec 2006 12:41:04 +0100
Subject: [S3d-svn] r547 - in trunk/extras/distro/gentoo/media-libs/libg3d: .
	files
Message-ID: <200612231141.kBNBf43S031563@sheep.berlios.de>

Author: lazhur
Date: 2006-12-23 12:41:02 +0100 (Sat, 23 Dec 2006)
New Revision: 547

Added:
   trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.6
   trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.ebuild
Removed:
   trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.6.20061222
   trunk/extras/distro/gentoo/media-libs/libg3d/files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2
   trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.20061222.ebuild
Modified:
   trunk/extras/distro/gentoo/media-libs/libg3d/ChangeLog
   trunk/extras/distro/gentoo/media-libs/libg3d/Manifest
Log:
- libg3d version bump to 0.0.6
- remove libg3d snapshot and patches


Modified: trunk/extras/distro/gentoo/media-libs/libg3d/ChangeLog
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/ChangeLog	2006-12-22 21:48:23 UTC (rev 546)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/ChangeLog	2006-12-23 11:41:02 UTC (rev 547)
@@ -1,17 +1,25 @@
 # ChangeLog for media-gfx/libg3d
 
+*libg3d-0.0.6 (23 Dec 2006)
+
+  23 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> +libg3d-0.0.6.20061222.ebuild,
+  -files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2,
+  -libg3d-0.0.6.20061222.ebuild:
+  Version bump. Remove old snapshot.
+
 *libg3d-0.0.6.20061222 (22 Dec 2006)
 
-  22 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> libg3d-0.0.6.20061222.ebuild:
+  22 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> +libg3d-0.0.6.20061222.ebuild,
+  +files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2:
   Add snapshot to build s3d-svn.
 
 *libg3d-0.0.3 (22 Dec 2006)
 
-  22 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> libg3d-0.0.3.ebuild:
+  22 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> +libg3d-0.0.3.ebuild:
   Version bump.
 
 *libg3d-0.0.3 (22 Dec 2006)
 
-  22 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> libg3d-0.0.3.ebuild:
+  22 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> +libg3d-0.0.3.ebuild:
   Initial import.
 

Modified: trunk/extras/distro/gentoo/media-libs/libg3d/Manifest
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/Manifest	2006-12-22 21:48:23 UTC (rev 546)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/Manifest	2006-12-23 11:41:02 UTC (rev 547)
@@ -1,9 +1,6 @@
-AUX libg3d-0.0.6.20061222-missingflexheaders.patch.bz2 18052 RMD160 d0d096e454917ca6a6d7938e4075f6e941c2e869 SHA1 f84a33261fb2e8a3a9eb2f6696fafd13662bfe5a SHA256 0391c8d6e62b3ec7e03d9f954363b35cc39d78a757ca14b29effedb7f6b1713b
-MD5 1ca9ec4968c57570ea04f3ede657de36 files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2 18052
-RMD160 d0d096e454917ca6a6d7938e4075f6e941c2e869 files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2 18052
-SHA256 0391c8d6e62b3ec7e03d9f954363b35cc39d78a757ca14b29effedb7f6b1713b files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2 18052
 DIST libg3d-0.0.3.tar.gz 438414 RMD160 3c1158d0b8a9580b78808152eaa179286e852a9c SHA1 768608dfc78d88f53ffb4d520bd434fe8c362c44 SHA256 d8c08448586b4d6f70c5933c89877f81e8f31d7eea8f3497b0d12357134a71e0
 DIST libg3d-0.0.5.tar.gz 475879 RMD160 505474c8187bd97126327e1e6c9225f72c1bbdff SHA1 3c1453fe41d60fb4d8ffa69fbb41aa6df2faa50a SHA256 4d19ea782ef71d862fae99291b6355b1331a309f68674ae301a9e1fd68c8c32a
+DIST libg3d-0.0.6.tar.gz 490091 RMD160 3cd681bfd35f8faf60b57257f5173078e101b034 SHA1 7fba70067fe32e4eacda0ada1d7fee073422e76e SHA256 d3ea0037e56cee9d38ed55d81416d22ec960e65a85b9166f2b25bab8e7d22884
 EBUILD libg3d-0.0.3.ebuild 606 RMD160 a318c6923751577442f9b684dd881a6e126b2e9c SHA1 9ca4be706d0c022f2ebd15632c78823f4c8d6750 SHA256 fc8d0e24adaa09d52c1a3c4d2f3b1765a5e0e70362cfba689abb6a9b2b91b10d
 MD5 35fca5596ed05c3d8d9ca82b7ee7e7c8 libg3d-0.0.3.ebuild 606
 RMD160 a318c6923751577442f9b684dd881a6e126b2e9c libg3d-0.0.3.ebuild 606
@@ -12,14 +9,14 @@
 MD5 2180cc92be1d9ac65d14cf2fa5ceec3f libg3d-0.0.5.ebuild 667
 RMD160 65e4eba6ff273b66cf8b6ff16693f38d4e8fa5cb libg3d-0.0.5.ebuild 667
 SHA256 fecae46969199e5d852fa308c1eafcbfcc9fb9f846a2311367afde8a25752af6 libg3d-0.0.5.ebuild 667
-EBUILD libg3d-0.0.6.20061222.ebuild 912 RMD160 4140176144360366b7dd5b042207c462ab3e3aeb SHA1 2251930c85b3df5aab0390350f20ce8bfa81f6bb SHA256 ae4e03dda245e2660adf0ee9d59b7e20577ad1bb73c90ab0dd05d6c24d551f7f
-MD5 9870cec7558a12008d2ee0f138642c11 libg3d-0.0.6.20061222.ebuild 912
-RMD160 4140176144360366b7dd5b042207c462ab3e3aeb libg3d-0.0.6.20061222.ebuild 912
-SHA256 ae4e03dda245e2660adf0ee9d59b7e20577ad1bb73c90ab0dd05d6c24d551f7f libg3d-0.0.6.20061222.ebuild 912
-MISC ChangeLog 434 RMD160 8ae5dfbf992a75eb1f54c704f9a7a65b162f2e1c SHA1 34ddae58d819a00a64e3e99b3f06b240318519bf SHA256 44259a04f04114d1d9785e93ac88c252ea5a76bb23bde8a0ba4c452cb6a8ca20
-MD5 091461b75c05b62e0d86b9ebea829443 ChangeLog 434
-RMD160 8ae5dfbf992a75eb1f54c704f9a7a65b162f2e1c ChangeLog 434
-SHA256 44259a04f04114d1d9785e93ac88c252ea5a76bb23bde8a0ba4c452cb6a8ca20 ChangeLog 434
+EBUILD libg3d-0.0.6.ebuild 667 RMD160 65e4eba6ff273b66cf8b6ff16693f38d4e8fa5cb SHA1 adcd841e8c3afbac819eed804b62399cd4c4c7c9 SHA256 fecae46969199e5d852fa308c1eafcbfcc9fb9f846a2311367afde8a25752af6
+MD5 2180cc92be1d9ac65d14cf2fa5ceec3f libg3d-0.0.6.ebuild 667
+RMD160 65e4eba6ff273b66cf8b6ff16693f38d4e8fa5cb libg3d-0.0.6.ebuild 667
+SHA256 fecae46969199e5d852fa308c1eafcbfcc9fb9f846a2311367afde8a25752af6 libg3d-0.0.6.ebuild 667
+MISC ChangeLog 744 RMD160 cfa9459a21e921763694e6fafcc32b552e3de710 SHA1 7cd2f792b79be900a2f0d35af03cd8f1010b0f0c SHA256 fa40f1e610c0854461c3c6dfbb6886b228ee918a373594c4af84de49ed30ee51
+MD5 a418c82829d8fc37c1cc0d6860a63c0b ChangeLog 744
+RMD160 cfa9459a21e921763694e6fafcc32b552e3de710 ChangeLog 744
+SHA256 fa40f1e610c0854461c3c6dfbb6886b228ee918a373594c4af84de49ed30ee51 ChangeLog 744
 MISC metadata.xml 239 RMD160 236f28d8249f562b764e2d854580d8301b150418 SHA1 76f167e3abff81e9535c16a637fd1e7f91d4fda3 SHA256 c0f08f1f0c1ce07df414cd87bf028a15cae639c89b2d636714d50d8aa77c370f
 MD5 261031c8b7aca6f50babf7e44b35deb1 metadata.xml 239
 RMD160 236f28d8249f562b764e2d854580d8301b150418 metadata.xml 239
@@ -30,6 +27,6 @@
 MD5 5e38c09ab217ac68f78491c99aaebe4d files/digest-libg3d-0.0.5 238
 RMD160 b72684e7e6a5c2375fe3167ac92ab4149a0ad379 files/digest-libg3d-0.0.5 238
 SHA256 9e800635187be7c188bdacb3d4e321783f5226ef12b808b7353a62cf29dcd012 files/digest-libg3d-0.0.5 238
-MD5 d41d8cd98f00b204e9800998ecf8427e files/digest-libg3d-0.0.6.20061222 0
-RMD160 9c1185a5c5e9fc54612808977ee8f548b2258d31 files/digest-libg3d-0.0.6.20061222 0
-SHA256 e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 files/digest-libg3d-0.0.6.20061222 0
+MD5 f6f95b508e2a76671d1452accbbd487d files/digest-libg3d-0.0.6 238
+RMD160 8bc5b2042e461d43735114b9ac6c12b39c07648e files/digest-libg3d-0.0.6 238
+SHA256 e89fd3d46d79fe20a5f3ab19714bf18ba4f888544b3fc66e63f364742886b15c files/digest-libg3d-0.0.6 238

Added: trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.6
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.6	2006-12-22 21:48:23 UTC (rev 546)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.6	2006-12-23 11:41:02 UTC (rev 547)
@@ -0,0 +1,3 @@
+MD5 037f02240c8aadc2113c3b0fcd0fe004 libg3d-0.0.6.tar.gz 490091
+RMD160 3cd681bfd35f8faf60b57257f5173078e101b034 libg3d-0.0.6.tar.gz 490091
+SHA256 d3ea0037e56cee9d38ed55d81416d22ec960e65a85b9166f2b25bab8e7d22884 libg3d-0.0.6.tar.gz 490091

Deleted: trunk/extras/distro/gentoo/media-libs/libg3d/files/digest-libg3d-0.0.6.20061222
===================================================================

Deleted: trunk/extras/distro/gentoo/media-libs/libg3d/files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2
===================================================================
(Binary files differ)

Deleted: trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.20061222.ebuild
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.20061222.ebuild	2006-12-22 21:48:23 UTC (rev 546)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.20061222.ebuild	2006-12-23 11:41:02 UTC (rev 547)
@@ -1,49 +0,0 @@
-inherit subversion eutils
-
-IUSE="gtk xml"
-
-ESVN_REPO_URI="http://svn.gna.org/svn/libg3d/trunk"
-ESVN_OPTIONS="--revision {2006-12-22}"
-ESVN_BOOTSTRAP="./autogen.sh"
-
-DESCRIPTION="library for loading 3D models of many file types"
-HOMEPAGE="https://gna.org/projects/libg3d/"
-
-LICENSE="GPL-2 LGPL"
-KEYWORDS="~x86 ~amd64"
-SLOT="0"
-
-DEPEND="${RDEPEND}
-	dev-util/gtk-doc
-	>=sys-devel/autoconf-2.59
-	>=sys-devel/automake-1.9
-	sys-devel/flex
-	>=sys-devel/libtool-1.5
-	"
-RDEPEND="!<=media-gfx/s3d-0.1.1
-	>=dev-libs/glib-2
-
-	gtk? ( >=x11-libs/gtk+-2 )
-	xml? ( dev-libs/libxml2 )
-	"
-
-src_unpack() {
-	subversion_src_unpack
-	cd "${S}"
-	epatch ${FILESDIR}/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2
-}
-
-src_compile() {
-	econf \
-		$(use_enable gtk gtktest) \
-		$(use_enable xml xmltest) \
-		--prefix=/usr/ \
-		|| die "econf failed"
-
-	emake || die "emake failed"
-}
-
-src_install() {
-	emake DESTDIR="${D}" install || die
-}
-

Added: trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.ebuild
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.ebuild	2006-12-22 21:48:23 UTC (rev 546)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.ebuild	2006-12-23 11:41:02 UTC (rev 547)
@@ -0,0 +1,38 @@
+IUSE="gtk xml"
+
+SRC_URI="http://download.gna.org/${PN}/${P}.tar.gz"
+
+DESCRIPTION="library for loading 3D models of many file types"
+HOMEPAGE="https://gna.org/projects/libg3d/"
+
+LICENSE="GPL-2 LGPL"
+KEYWORDS="x86"
+SLOT="0"
+
+DEPEND="${RDEPEND}
+	>=sys-devel/autoconf-2.59
+	>=sys-devel/automake-1.9
+	sys-devel/flex
+	>=sys-devel/libtool-1.5
+	"
+RDEPEND="!<=media-gfx/s3d-0.1.1
+	>=dev-libs/glib-2
+
+	gtk? ( >=x11-libs/gtk+-2 )
+	xml? ( dev-libs/libxml2 )
+	"
+
+src_compile() {
+	econf \
+		$(use_enable gtk gtktest) \
+		$(use_enable xml xmltest) \
+		--prefix=/usr/ \
+		|| die "econf failed"
+
+	emake || die "emake failed"
+}
+
+src_install() {
+	emake DESTDIR="${D}" install || die
+}
+



From dotslash at mail.berlios.de  Sat Dec 23 15:19:21 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 23 Dec 2006 15:19:21 +0100
Subject: [S3d-svn] r548 - in trunk: . server
Message-ID: <200612231419.kBNEJLDN003062@sheep.berlios.de>

Author: dotslash
Date: 2006-12-23 15:19:20 +0100 (Sat, 23 Dec 2006)
New Revision: 548

Modified:
   trunk/
   trunk/server/shm.c
Log:
 r1319 at kero:  dotslash | 2006-12-23 15:19:16 +0100
 - seems to fix some race condition when calling sighandler while already doing quit() in shm



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1309
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1319

Modified: trunk/server/shm.c
===================================================================
--- trunk/server/shm.c	2006-12-23 11:41:02 UTC (rev 547)
+++ trunk/server/shm.c	2006-12-23 14:19:20 UTC (rev 548)
@@ -148,6 +148,7 @@
 	if (data!=NULL)
 	{
 		data[0]=data[1]=0;
+		data=0;
 		s3dprintf(MED,"shm_quit():removing init block");
 		if (shmdt(data) == -1) 
 			errn("shm_quit():shmdt()",errno);



From dotslash at mail.berlios.de  Sat Dec 23 22:53:43 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 23 Dec 2006 22:53:43 +0100
Subject: [S3d-svn] r549 - in trunk: . apps/olsrs3d
Message-ID: <200612232153.kBNLrhOU010213@sheep.berlios.de>

Author: dotslash
Date: 2006-12-23 22:53:42 +0100 (Sat, 23 Dec 2006)
New Revision: 549

Modified:
   trunk/
   trunk/apps/olsrs3d/main.c
Log:
 r1325 at kero:  dotslash | 2006-12-23 22:53:24 +0100
 - don't set x to zero if it's on the same point in dirt() , it's pointless :)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1319
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1325

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-12-23 14:19:20 UTC (rev 548)
+++ trunk/apps/olsrs3d/main.c	2006-12-23 21:53:42 UTC (rev 549)
@@ -230,14 +230,14 @@
 {
 	float d;
 	d=dist(p1,p2);
-	if (d!=0.0)
-	{
-		p3[0]=p2[0]-p1[0];
-		p3[1]=p2[1]-p1[1];
-		p3[2]=p2[2]-p1[2];
-	} else {
-		p3[0]=p2[0]=p1[0]=0.0;
+	while (d==0.0) { /* jitter it a bit */
+		p1[0]+=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
+		p1[1]+=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
+		p1[2]+=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
 	}
+	p3[0]=p2[0]-p1[0];
+	p3[1]=p2[1]-p1[1];
+	p3[2]=p2[2]-p1[2];
 	return(d);
 }
 



From dotslash at mail.berlios.de  Sat Dec 23 23:07:12 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sat, 23 Dec 2006 23:07:12 +0100
Subject: [S3d-svn] r550 - in trunk: . apps/olsrs3d
Message-ID: <200612232207.kBNM7CpL012230@sheep.berlios.de>

Author: dotslash
Date: 2006-12-23 23:07:12 +0100 (Sat, 23 Dec 2006)
New Revision: 550

Modified:
   trunk/
   trunk/apps/olsrs3d/main.c
Log:
 r1327 at kero:  dotslash | 2006-12-23 23:07:06 +0100
 - dirt() again (it's no good to jitter on big values - better jitter on the distance itself)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1325
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1327

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-12-23 21:53:42 UTC (rev 549)
+++ trunk/apps/olsrs3d/main.c	2006-12-23 22:07:12 UTC (rev 550)
@@ -230,14 +230,16 @@
 {
 	float d;
 	d=dist(p1,p2);
-	while (d==0.0) { /* jitter it a bit */
-		p1[0]+=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		p1[1]+=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
-		p1[2]+=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
+	if (d==0) {
+		p3[0]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
+		p3[1]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
+		p3[2]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
+		d=s3d_vector_length(p3);
+	} else {
+		p3[0]=p2[0]-p1[0];
+		p3[1]=p2[1]-p1[1];
+		p3[2]=p2[2]-p1[2];
 	}
-	p3[0]=p2[0]-p1[0];
-	p3[1]=p2[1]-p1[1];
-	p3[2]=p2[2]-p1[2];
 	return(d);
 }
 



From dotslash at mail.berlios.de  Sun Dec 24 00:09:07 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 24 Dec 2006 00:09:07 +0100
Subject: [S3d-svn] r551 - in trunk: . apps/s3dosm
Message-ID: <200612232309.kBNN97Fj020943@sheep.berlios.de>

Author: dotslash
Date: 2006-12-24 00:09:05 +0100 (Sun, 24 Dec 2006)
New Revision: 551

Added:
   trunk/apps/s3dosm/net.c
   trunk/apps/s3dosm/olsrs3d.c
   trunk/apps/s3dosm/olsrs3d.h
   trunk/apps/s3dosm/process.c
   trunk/apps/s3dosm/search.c
   trunk/apps/s3dosm/search.h
   trunk/apps/s3dosm/structs.h
Modified:
   trunk/
   trunk/apps/s3dosm/Makefile.am
   trunk/apps/s3dosm/db.c
   trunk/apps/s3dosm/draw.c
   trunk/apps/s3dosm/main.c
   trunk/apps/s3dosm/nav.c
   trunk/apps/s3dosm/s3dosm.h
   trunk/apps/s3dosm/ui.c
Log:
 r1329 at kero:  dotslash | 2006-12-24 00:08:59 +0100
 - s3dosm now working with olsrs3d data and can put nodes to its geo locations :)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1327
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1329

Modified: trunk/apps/s3dosm/Makefile.am
===================================================================
--- trunk/apps/s3dosm/Makefile.am	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/Makefile.am	2006-12-23 23:09:05 UTC (rev 551)
@@ -1,12 +1,12 @@
 bin_PROGRAMS=	s3dosm
 s3dosmincludedir = ${pkgincludedir}/s3dosm
 s3dosminclude_HEADERS =  \
-	s3dosm.h
+	s3dosm.h olsrs3d.h structs.h search.h
 				  
 s3dosm_SOURCES =  \
 	main.c http_fetcher.c http_error_codes.c osm.c \
 	object.c draw.c kismet.c nav.c tag.c io.c db.c \
-	gps.c ui.c
+	gps.c ui.c olsrs3d.c process.c net.c search.c
 
 s3dosm_CPPFLAGS=	-pg -I$(top_srcdir)/libs3d -I$(top_srcdir)/libs3dw @LIBXML2_CFLAGS@ @LIBSQLITE3_CFLAGS@ @GPS_CFLAGS@
 s3dosm_LDADD=		$(top_builddir)/libs3d/libs3d.la $(top_builddir)/libs3dw/libs3dw.la @LIBXML2_LIBS@ @LIBSQLITE3_LIBS@ @GPS_LIBS@

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/db.c	2006-12-23 23:09:05 UTC (rev 551)
@@ -39,6 +39,7 @@
 void clean_string(char *clean, char *dirty, int n)
 {
 	strncpy(clean, dirty, n);
+	clean[n-1]=0;
 }
 int db_add_tag(object_t *obj, char *key, char *val)
 {
@@ -121,33 +122,73 @@
 	}
 	return(layerid);
 }
-/*
-int db_insert_object(object_t *obj)
+static int found=0;
+/* tries to find node coordinates of ip, returns 1 if has found something */
+int db_olsr_check(char *ip, float *pos) {
+	char findquery[MAXQ];
+	char clean_ip[16];
+	float p[6];
+	char *s=NULL;
+	clean_string(clean_ip,ip,16);
+	if (NULL!=(s=strchr(clean_ip,'/')))  /* don't process ip's with subnet information */
+		*s=0; /* TERMINATING ZERO!! */
+	
+	snprintf(findquery, MAXQ, "SELECT latitude, longitude, altitude FROM node WHERE tag_id=(SELECT tag_id FROM tag WHERE tagkey='ip' AND tagvalue='%s');", clean_ip);
+	found=0;
+   	db_exec(findquery, db_getpoint, p);
+	if (found) { 
+		pos[0]=p[0];
+		pos[1]=p[1];
+		pos[2]=p[2];
+	}
+	return(found);	
+}
+/* initializes the starting point of nodes  by averaging its lon/lat */
+int db_olsr_node_init(float *pos) {
+   	db_exec("SELECT AVG(latitude) as latitude, AVG(longitude) as longitude, AVG(altitude) as altitude FROM node WHERE tag_id IN (SELECT tag_id FROM tag WHERE tagkey='ip');", db_getpoint, pos);
+	printf("pos = %3.3f %3.3f %3.3f\n",pos[0],pos[1],pos[2]);
+	return(0);	/* return 1 if something is found, 0 if pos[0] its still 0 */
+}
+
+
+/* expecting a 3x float vector, returns the points coordinates */
+int db_getpoint(void *data, int argc, char **argv, char **azColName)
 {
-	if (obj==NULL)
-	{
-		printf("NULL object, run away\n");
-		return(-1);
+	float lo=0.0,la=0.0,alt=0.0;
+	float *p=data;
+	int i;
+	for(i=0; i<argc; i++){
+		if (argv[i]) {
+			if (0==strcmp(azColName[i],"longitude"))			lo=strtod(argv[i],NULL);
+			else if (0==strcmp(azColName[i],"latitude"))		la=strtod(argv[i],NULL);
+			else if (0==strcmp(azColName[i],"altitude"))		alt=strtod(argv[i],NULL);
+		}
 	}
-	switch (obj->type) {
-		case T_NODE:			return(db_insert_node((node_t *)obj));
-		case T_SEGMENT:			return(db_insert_segment((segment_t *)obj));
-		case T_WAY:				return(db_insert_way((way_t *)obj));
-		default:break;
-	}
-	return(-1);
+	if (lo==0.0)	{	printf("missing lo\n");	exit(0);	}
+	if (la==0.0)	{	printf("missing la\n");	exit(0); 	}
+	calc_earth_to_eukl(la,lo,alt,p);
+	p[3]=la;
+	p[4]=lo;
+	p[5]=alt;
+	found=1;
+	return(0);
 }
-*/
+
+/* sqlite3-callback to get an integer of the database */
 int db_getint(void *tagid, int argc, char **argv, char **azColName){
   if (argv[0]!=NULL) 
 	  *((int *)tagid)=atoi(argv[0]);
   return 0;
 }
+
+/* sqlite3-callback to get a string of the database */
 static int db_getstr(void *string, int argc, char **argv, char **azColName) {
 	if (argv[0])
 		strncpy((char *)string,argv[0],MAXQ);
 	return(0);
 }
+/* get the value for a a certain tagid and keyvalue (field). Write into target, which has to be allocated with MAXQ bytes of space.
+ * Nothing is written when nothing is found. */
 int db_gettag(int tagid, char *field, char *target)
 {
 	char query[MAXQ];
@@ -176,6 +217,7 @@
 	}
 	return(SQLITE_OK!=rc); /* 0 = okay */
 }
+
 /* call this if you're finished with a few stackable operations */
 void db_flush()
 {

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/draw.c	2006-12-23 23:09:05 UTC (rev 551)
@@ -128,7 +128,7 @@
 	} 
 	return(0);
 }
-/* just fetches node information and puts it in some simple 6x float buffer */
+/* just fetches node information and puts in the nodelist */
 int insert_node(void *data, int argc, char **argv, char **azColName)
 {
 	struct nodelist *np=data;	/* get the nodepointer */

Modified: trunk/apps/s3dosm/main.c
===================================================================
--- trunk/apps/s3dosm/main.c	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/main.c	2006-12-23 23:09:05 UTC (rev 551)
@@ -36,6 +36,7 @@
 		nanosleep(&t,NULL); 
 		gps_main();
 		nav_main();
+		olsr_main();
 		s3dw_ani_mate();
 	} /* else {
 		s3d_net_check(); / * we are not yet in the mainloop of 
@@ -55,20 +56,23 @@
 	ui_init();
 	if (db_init(":memory:")) return(-1);
 	if (db_create()) return(-1);
+	olsr_parse_args(argc, argv); /* if it returns !=0, it was -h and should also be handled by process_args itself */
 	if (process_args(argc,argv)) return(-1);
 	nav_init();
 	nav_autocenter();
 	draw_all_layers();
 	gps_init("localhost");
+	olsr_init();
 	ready=1;
 	return(0);
 }
 int quit() 
 {
 	ready=0;
+	olsr_quit();
+	gps_quit();
 	s3d_quit();
 	db_quit();
-	gps_quit();
 	return(0);
 }
 int main(int argc, char **argv)

Modified: trunk/apps/s3dosm/nav.c
===================================================================
--- trunk/apps/s3dosm/nav.c	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/nav.c	2006-12-23 23:09:05 UTC (rev 551)
@@ -21,6 +21,33 @@
 	tlat=la;
 	tlon=lo;
 }
+void nav_campos(float campos[3], float earthpos[3])
+{
+
+	float tmp1[3],tmp2[3];
+	float alpha;
+	
+	tmp1[0]=campos[0];
+	tmp1[1]=campos[1] + ESIZE*RESCALE +VIEWHEIGHT;
+	tmp1[2]=campos[2];
+	
+	alpha= (90-lat) *M_PI/180.0;
+	tmp2[0]=  tmp1[0];
+	tmp2[1]=  tmp1[1]*cos(alpha) - tmp1[2] * sin (alpha);
+	tmp2[2]=  tmp1[1]*sin(alpha) + tmp1[2] * cos (alpha);
+	
+	alpha= lon *M_PI/180.0;
+	tmp1[0]=  tmp2[0]*cos(alpha) + tmp2[2] * sin (alpha);
+	tmp1[1]=  tmp2[1];
+	tmp1[2]=  - tmp2[0]*sin(alpha) + tmp2[2] * cos (alpha);
+
+
+
+	earthpos[0]=tmp1[0];
+	earthpos[1]=tmp1[1];
+	earthpos[2]=tmp1[2];
+
+}
 void nav_main()
 {
 	float x[3];

Added: trunk/apps/s3dosm/net.c
===================================================================
--- trunk/apps/s3dosm/net.c	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/net.c	2006-12-23 23:09:05 UTC (rev 551)
@@ -0,0 +1,129 @@
+/*
+ * net.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                         Marek Lindner <lindner_marek at yahoo.de>
+ *                         Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of olsrs3d, an olsr topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>	/* close() */
+#include <errno.h>
+#include <string.h> 	/* strlen(), memmove(), strncpy(), strncat() */
+#include <netdb.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <fcntl.h>		/* fnctl() */
+#include "olsrs3d.h"
+
+#define PORT 2004 		/* the port client will be connecting to  */
+char buf[MAXDATASIZE];
+
+
+int sockfd, numbytes;
+int net_init(char *host)
+{
+    struct hostent *he;
+    struct sockaddr_in their_addr; /* connector's address information  */
+
+    if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
+        herror("olsr_net:gethostbyname");
+        return(1);
+    }
+
+    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
+        perror("olsr_net:socket");
+        return(1);
+    }
+
+    their_addr.sin_family = AF_INET;    /* host byte order  */
+    their_addr.sin_port = htons(PORT);  /* short, network byte order  */
+    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
+    memset(&(their_addr.sin_zero), '\0', 8);  /* zero the rest of the struct */
+
+    if (connect(sockfd, (struct sockaddr *)&their_addr,
+                                          sizeof(struct sockaddr)) == -1) {
+        perror("olsr_net:connect");
+        return(1);
+    }
+	fcntl(sockfd,F_SETFL, O_NONBLOCK);
+	return(0);
+}
+
+int net_main() {
+
+	if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
+		if (errno==EAGAIN)
+			return(0); /* well, that's okay ... */
+		perror("recv");
+		return(-1);
+	}
+
+	if (numbytes==0) {
+		printf("connection reset\n");
+		return(-1);
+	}
+
+	buf[numbytes] = '\0';
+
+	/* check for potential buffer overflow */
+	if ( ( strlen( lbuf ) + strlen( buf ) ) < MAXLINESIZE ) {
+
+		strncat( lbuf, buf, MAXLINESIZE );
+
+	} else {
+
+		/* hope that carriage return is now in buf */
+		if ( strlen( lbuf ) < MAXLINESIZE ) {
+
+			if ( Debug ) printf( "WARNING: lbuf almost filled without *any* carriage return within that data !\nAppending truncated buf to lbuf to prevent buffer overflow.\n" );
+			strncat( lbuf, buf, MAXLINESIZE - strlen( lbuf ) );
+
+		} else {
+
+			if ( Debug ) printf( "ERROR: lbuf filled without *any* carriage return within that data !\nClearing lbuf to prevent buffer overflow.\n" );
+			strncpy( lbuf, buf, MAXLINESIZE );
+
+		}
+
+	}
+
+	process_main();
+
+	if ( ++Net_read_count > 5 ) {
+		return(0);   /* continue mainloop */
+	} else {
+		return(1);   /* continue reading data from socket */
+	}
+
+}
+
+int net_quit()
+{
+    close(sockfd);
+
+    return 0;
+}
+
+

Added: trunk/apps/s3dosm/olsrs3d.c
===================================================================
--- trunk/apps/s3dosm/olsrs3d.c	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/olsrs3d.c	2006-12-23 23:09:05 UTC (rev 551)
@@ -0,0 +1,1126 @@
+/*
+ * olsrs3d.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                         Marek Lindner <lindner_marek at yahoo.de>
+ *                         Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of olsrs3d, an olsr topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+
+#include <stdio.h>
+#include <s3d.h>
+#include <s3d_keysym.h>
+#include <s3dw.h>
+#include <sys/time.h>	 /* gettimeofday() */
+#include <time.h>	     /* nanosleep() */
+#include <string.h>		 /* strncpy() */
+#include <math.h>		 /* sqrt() */
+#include <getopt.h>		 /* getopt() */
+#include <stdlib.h>		 /* exit() */
+#include <stdint.h>		 /* uintXX_t */
+#include "olsrs3d.h"
+#include "s3dosm.h"
+#include "search.h"
+
+#define SPEED		10.0
+
+int Debug = 0;
+
+extern float olsr_node_init[6];
+extern int oidy; /* zeropoint of s3dosm to link to */
+static int olsr_ready=0; /* olsr is not initialized yet */
+
+char Olsr_host[256];   /* ip or hostname of olsr node with running dot_draw plugin */
+
+struct olsr_con *Con_begin = NULL;   /* begin of connection list */
+struct olsr_node *Olsr_root = NULL;   /* top of olsr node tree */
+struct Obj_to_ip *Obj_to_ip_head, *Obj_to_ip_end, *List_ptr;   /* needed pointer for linked list */
+
+int Olsr_node_count = 0, Last_olsr_node_count = -1;
+int Olsr_node_count_obj = -1;
+int Olsr_ip_label_obj = -1;
+int Output_border[4];
+int *Olsr_neighbour_label_obj = NULL;
+int Size;
+
+
+int Net_read_count;
+int Output_block_counter = 0;
+int Output_block_completed = 0;
+
+int Olsr_node_obj, Olsr_node_inet_obj, Olsr_node_hna_net, S3d_obj;
+
+float Asp = 1.0;
+float Bottom = -1.0;
+float Left = -1.0;
+
+float CamPosition[2][3];	/* CamPosition[trans|rot][x-z] */
+float CamPosition2[2][3];	/* CamPosition[trans|rot][x-z] */
+
+/* needed ? */
+/* float ZeroPosition[3] = {0,0,0};	 current position zero position */
+
+int ZeroPoint;   /* object zeropoint */
+int ColorSwitch = 0;   /* enable/disable colored olsr connections */
+float Factor = 0.6;	/* Factor in calc_olsr_node_mov */
+struct olsr_node *Olsr_node_pEtx;
+
+int Btn_close_id = -1;
+
+int Btn_close_obj;
+int Last_Click_Time = 0;
+int Last_Click_Oid = 0;
+float Title_len;
+
+/***
+ *
+ * print usage info
+ *
+ ***/
+
+void print_usage( void ) {
+
+	printf( "Usage is olsrs3d [options] [-- [s3d options]]\n" );
+	printf( "olsrs3d options:\n" );
+	printf( "   -h\tprint this short help\n" );
+	printf( "   -d\tenable debug mode\n" );
+	printf( "   -H\tconnect to olsr node [default: localhost]\n" );
+	s3d_usage();
+
+}
+
+
+void close_win(s3dw_widget *button) {
+	s3dw_delete(button->parent); /* parent =surface. this means close containing window */
+}
+
+
+
+void window_help() {
+
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+
+	infwin = s3dw_surface_new( "Help Window", 20, 19 );
+
+	/*s3dw_label_new(infwin,"C        - Colour On/Off",1,2);*/
+	s3dw_label_new(infwin,"c",1,2);
+	s3dw_label_new(infwin,"- Colour On/Off",6,2);
+	/*s3dw_label_new(infwin,"r        - Rotation On/Off",1,4);*/
+	s3dw_label_new(infwin,"r",1,4);
+	s3dw_label_new(infwin,"- Rotation On/Off",6,4);
+	s3dw_label_new(infwin,"+",1,5);
+	s3dw_label_new(infwin,"- Increase Rotation Speed",6,5);
+	s3dw_label_new(infwin,"-",1,6);
+	s3dw_label_new(infwin,"- Decrease Rotation Speed",6,6);
+	s3dw_label_new(infwin,"F3",1,8);
+	s3dw_label_new(infwin,"- Search IP",6,8);
+	s3dw_label_new(infwin,"ESC",1,9);
+	s3dw_label_new(infwin,"- Disable FollowMode",6,9);
+	s3dw_label_new(infwin,"PGUP",1,11);
+	s3dw_label_new(infwin,"- Increase Drift Factor",6,11);
+	s3dw_label_new(infwin,"PGDOWN",1,12);
+	s3dw_label_new(infwin,"- Decrease Drift Factor",6,12);
+	s3dw_label_new(infwin,"STRG + p",1,14);
+	s3dw_label_new(infwin,"- Reset Nodes",6,14);
+
+	button=s3dw_button_new(infwin,"OK",9,16);
+	button->onclick = close_win;
+	s3dw_show(S3DWIDGET(infwin));
+
+}
+
+
+void window_error(char *msg) {
+
+	s3dw_surface *infwin;
+	s3dw_button  *button;
+
+	infwin = s3dw_surface_new( "Error", 12, 6 );
+	s3dw_label_new(infwin,msg,1,2);
+
+	button=s3dw_button_new(infwin,"OK",4,4);
+	button->onclick = close_win;
+	s3dw_show(S3DWIDGET(infwin));
+
+}
+
+
+/***
+ *
+ * print error and exit
+ *
+ ***/
+
+void out_of_mem( void ) {
+
+	printf( "Sorry - you ran out of memory !\n" );
+	exit(8);
+
+}
+
+
+
+unsigned int get_time(void) {
+
+	struct timeval tv;
+
+	gettimeofday(&tv, NULL);
+
+	return tv.tv_sec * 1000 + tv.tv_usec / 1000;
+
+}
+
+
+
+/***
+ *
+ * calculate distance between 2 vectors => http://en.wikipedia.org/wiki/Euclidean_distance
+ *
+ *   p1   =>   vector of node 1
+ *   p2   =>   vector of node 2
+ *
+ *   return distance
+ *
+ ***/
+
+float dist(float p1[], float p2[])
+{
+	float p[3];
+	p[0]=p1[0]-p2[0];
+	p[1]=p1[1]-p2[1];
+	p[2]=p1[2]-p2[2];
+	return (sqrt(p[0]*p[0]   +  p[1]*p[1]  +  p[2]*p[2]));
+
+}
+
+
+
+/***
+ *
+ * calculate distance between 2 vectors and subtract vector1 from vector2
+ *  => http://en.wikipedia.org/wiki/Vector_%28spatial%29#Vector_addition_and_subtraction
+ *
+ *   p1   =>   vector of node 1
+ *   p2   =>   vector of node 2
+ *
+ *   return distance
+ *
+ ***/
+
+float dirt(float p1[], float p2[], float p3[])
+{
+	float d;
+	d=dist(p1,p2);
+	if (d==0) {
+		p3[0]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
+		p3[1]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
+		p3[2]=(( float ) 0.2 * rand() ) / RAND_MAX - 0.1;
+		d=s3d_vector_length(p3);
+	} else {
+		p3[0]=p2[0]-p1[0];
+		p3[1]=p2[1]-p1[1];
+		p3[2]=p2[2]-p1[2];
+	}
+	return(d);
+}
+
+
+
+/***
+ *
+ * calculate new movement of node by adding the product of the factor and the vector to the movement vector
+ *  => http://en.wikipedia.org/wiki/Vector_%28spatial%29#Scalar_multiplication
+ *
+ *   mov  =>   current mov vector
+ *   p    =>   vector of node
+ *   fac  =>   factor which is
+ *
+ ***/
+
+void mov_add(float mov[], float p[], float fac)
+{
+/*	if (fac>1000)
+		return;
+	fac=1000; */
+	mov[0]+=fac*p[0];
+	mov[1]+=fac*p[1];
+	mov[2]+=fac*p[2];
+}
+
+
+
+/***
+ *
+ * check whether is a new / modified / vanished node and handle it accordingly
+ *
+ *   *olsr_node =>   pointer to current olsr_node
+ *
+ ***/
+
+void handle_olsr_node( struct olsr_node *olsr_node ) {
+
+	float distance, angle, angle_rad;
+	float tmp_mov_vec[3], desc_norm_vec[3] = {0,0,-1};
+	struct olsr_node *other_node;
+	struct Obj_to_ip *Obj_to_ip_curr;
+	struct olsr_neigh_list *olsr_neigh_list, *prev_olsr_neigh_list, *other_node_neigh_list, *tmp_olsr_neigh_list;
+
+	/* no more nodes left */
+	if ( olsr_node == NULL ) return;
+
+	/* olsr node vanished */
+	if ( ( olsr_node->last_seen < Output_block_counter - 1 ) && ( olsr_node->visible ) ) {
+
+		if ( Debug )
+			printf( "olsr node vanished: %s\n", olsr_node->ip );
+
+		Olsr_node_count--;
+
+		olsr_node->visible = 0;
+
+		/* delete shape */
+		if ( olsr_node->obj_id != -1 ) {
+
+			/* remove element from ob2ip list */
+			lst_del( olsr_node->obj_id );
+			/* remove object from s3d server */
+			s3d_del_object( olsr_node->obj_id );
+
+			olsr_node->obj_id = -1;
+
+		}
+
+		if ( olsr_node->desc_id != -1 ) {
+
+			s3d_del_object( olsr_node->desc_id );
+			olsr_node->desc_id = -1;
+
+		}
+
+		/* delete olsr connections of this node */
+		olsr_neigh_list = olsr_node->olsr_neigh_list;
+
+		while ( olsr_neigh_list != NULL ) {
+
+			/* get connection list of 'other' node */
+			if ( olsr_neigh_list->olsr_con->left_olsr_node == olsr_node ) {
+				other_node = olsr_neigh_list->olsr_con->right_olsr_node;
+			} else {
+				other_node = olsr_neigh_list->olsr_con->left_olsr_node;
+			}
+
+			/* find this connection in 'other' nodes connection list ... */
+			prev_olsr_neigh_list = NULL;
+			other_node_neigh_list = other_node->olsr_neigh_list;
+
+			while ( other_node_neigh_list != NULL ) {
+
+				if ( other_node_neigh_list->olsr_con == olsr_neigh_list->olsr_con ) {
+
+					/* and delete it ! */
+					if ( prev_olsr_neigh_list != NULL ) {
+						/* is first, any or last element in the list */
+						prev_olsr_neigh_list->next_olsr_neigh_list = other_node_neigh_list->next_olsr_neigh_list;
+					} else {
+						/* the only element in the list */
+						other_node->olsr_neigh_list = NULL;
+					}
+
+					free( other_node_neigh_list );
+
+					break;
+
+				}
+
+				prev_olsr_neigh_list = other_node_neigh_list;
+				other_node_neigh_list = other_node_neigh_list->next_olsr_neigh_list;
+
+			}
+
+			s3d_del_object( olsr_neigh_list->olsr_con->obj_id );
+
+			/* delete connection */
+			if ( olsr_neigh_list->olsr_con->prev_olsr_con != NULL ) olsr_neigh_list->olsr_con->prev_olsr_con->next_olsr_con = olsr_neigh_list->olsr_con->next_olsr_con;
+			if ( olsr_neigh_list->olsr_con->next_olsr_con != NULL ) olsr_neigh_list->olsr_con->next_olsr_con->prev_olsr_con = olsr_neigh_list->olsr_con->prev_olsr_con;
+
+			tmp_olsr_neigh_list = olsr_neigh_list;
+
+			olsr_neigh_list = olsr_neigh_list->next_olsr_neigh_list;
+
+			free( tmp_olsr_neigh_list->olsr_con );
+			free( tmp_olsr_neigh_list );
+
+		}
+
+		olsr_node->olsr_neigh_list = NULL;
+
+	} else if ( olsr_node->visible ) {
+
+		/* olsr node shape has been modified */
+		if ( olsr_node->node_type_modified ) {
+			float lo, la;
+
+			/* delete old shape */
+			if ( olsr_node->obj_id != -1 ) {
+				/* remove element from ob2ip list */
+				lst_del( olsr_node->obj_id );
+				s3d_del_object( olsr_node->obj_id );
+			}
+
+			if ( olsr_node->desc_id != -1 ) s3d_del_object( olsr_node->desc_id );
+
+			/* create new shape */
+			if ( olsr_node->node_type == 1 ) {
+				/* olsr node offers internet access */
+				olsr_node->obj_id = s3d_clone( Olsr_node_inet_obj );
+			} else if ( olsr_node->node_type == 2 ) {
+				/* via hna announced network */
+				olsr_node->obj_id = s3d_clone( Olsr_node_hna_net );
+			} else {
+				/* normal olsr node */
+				olsr_node->obj_id = s3d_clone( Olsr_node_obj );
+			}
+			la=olsr_node_init[3];
+			lo=olsr_node_init[4];
+			s3d_rotate(olsr_node->obj_id,(90-la),lo,0);
+
+			s3d_flags_on( olsr_node->obj_id, S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
+
+			/* link newly created object to ZeroPoint */
+			s3d_link( olsr_node->obj_id, ZeroPoint );
+			/* add object_id and olsr_node to linked list */
+			lst_add(olsr_node->obj_id,&olsr_node);
+
+			/* create olsr node text and attach (link) it to the node */
+			olsr_node->desc_id = s3d_draw_string( olsr_node->ip, &olsr_node->desc_length );
+			s3d_link( olsr_node->desc_id, olsr_node->obj_id );
+			s3d_translate( olsr_node->desc_id, - olsr_node->desc_length / 2, -2, 0 );
+			s3d_flags_on( olsr_node->desc_id, S3D_OF_VISIBLE );
+
+			olsr_node->node_type_modified = 0;
+
+		}
+
+
+		/* rotate node description so that they are always readable */
+		tmp_mov_vec[0] = CamPosition2[0][0] - olsr_node->pos_vec[0];
+		tmp_mov_vec[1] = 0;   /* we are not interested in the y value */
+		tmp_mov_vec[2] = CamPosition2[0][2] - olsr_node->pos_vec[2];
+
+		angle = s3d_vector_angle( desc_norm_vec, tmp_mov_vec );
+
+		/* take care of inverse cosinus */
+		if ( tmp_mov_vec[0] > 0 ) {
+			angle_rad = 90.0/M_PI - angle;
+			angle = 180 - ( 180.0/M_PI * angle );
+		} else {
+			angle_rad = 90.0/M_PI + angle;
+			angle = 180 + ( 180.0/M_PI * angle );
+		}
+
+		s3d_rotate( olsr_node->desc_id, 0, angle , 0 );
+		s3d_translate( olsr_node->desc_id, -cos(angle_rad)*olsr_node->desc_length/2 ,-1.5, sin(angle_rad)*olsr_node->desc_length/2 );
+
+
+		/* drift away from unrelated nodes */
+		Obj_to_ip_curr = Obj_to_ip_head->next;
+		while ( Obj_to_ip_curr != Obj_to_ip_end ) {
+
+			/* myself ... */
+			if ( olsr_node != Obj_to_ip_curr->olsr_node ) {
+
+				olsr_neigh_list = olsr_node->olsr_neigh_list;
+				while ( olsr_neigh_list != NULL ) {
+
+					/* nodes are related */
+					if ( ( olsr_neigh_list->olsr_con->left_olsr_node->visible == 1 ) && ( olsr_neigh_list->olsr_con->right_olsr_node->visible == 1 ) ) {
+
+						if ( ( olsr_neigh_list->olsr_con->left_olsr_node == Obj_to_ip_curr->olsr_node ) || (  olsr_neigh_list->olsr_con->right_olsr_node == Obj_to_ip_curr->olsr_node ) ) break;
+
+					}
+
+					olsr_neigh_list = olsr_neigh_list->next_olsr_neigh_list;
+
+				}
+
+				/* nodes are not related - so drift */
+				if ( olsr_neigh_list == NULL ) {
+
+					distance = dirt( olsr_node->pos_vec, Obj_to_ip_curr->olsr_node->pos_vec, tmp_mov_vec );
+					if ( distance < 0.1 ) distance = 0.1;
+					mov_add( olsr_node->mov_vec, tmp_mov_vec,-10 / ( distance * distance ) );
+					mov_add( Obj_to_ip_curr->olsr_node->mov_vec, tmp_mov_vec, 10 / ( distance * distance ) );
+
+				}
+
+			}
+
+			Obj_to_ip_curr = Obj_to_ip_curr->next;
+
+		}
+
+	}
+
+	handle_olsr_node( olsr_node->left );
+	handle_olsr_node( olsr_node->right );
+
+}
+
+
+
+/***
+ *
+ * calculate movement vector of all olsr nodes
+ *
+ ***/
+
+void calc_olsr_node_mov( void ) {
+
+	float distance;
+	float tmp_mov_vec[3];
+	float f;
+	struct olsr_con *olsr_con = Con_begin;
+
+	while ( olsr_con != NULL ) {
+
+		distance = dirt( olsr_con->left_olsr_node->pos_vec, olsr_con->right_olsr_node->pos_vec, tmp_mov_vec );
+		f = ( ( olsr_con->left_etx_sqrt + olsr_con->left_etx_sqrt ) / 4.0 ) / distance;
+
+		/***
+		 * drift factor - 0.0 < factor < 1.0 ( best results: 0.3 < factor < 0.9
+		 * small factor: fast and strong drift to neighbours
+		 ***/
+		if ( f < Factor ) f = Factor;
+
+		mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, 1 / f - 1 );
+		mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, - ( 1 / f - 1 ) );
+
+		olsr_con = olsr_con->next_olsr_con;
+
+	}
+
+}
+
+
+
+/***
+ *
+ * move all olsr nodes and their connections
+ *
+ ***/
+
+void move_olsr_nodes( void ) {
+
+	float null_vec[3] = {0,0,0}, vertex_buf[6];
+	float target_vec[3];
+	float tmp_mov_vec[3];
+	float distance, etx, rgb;
+	struct olsr_con *olsr_con = Con_begin;
+	int n=0;
+	
+	while ( olsr_con != NULL ) {
+		n++;
+		/* move left olsr node if it has not been moved yet */
+		if ( !( ( olsr_con->left_olsr_node->mov_vec[0] == 0 ) && ( olsr_con->left_olsr_node->mov_vec[1] == 0 ) && ( olsr_con->left_olsr_node->mov_vec[2] == 0 ) ) && olsr_con->left_olsr_node->visible ) {
+			distance = dirt( olsr_con->left_olsr_node->pos_vec, olsr_node_init, tmp_mov_vec );
+			if (distance>5000)		printf("distance = %3.3f %s | %3.3f %3.3f %3.3f\n",distance,olsr_con->left_olsr_node->ip,
+							olsr_con->left_olsr_node->pos_vec[0],
+							olsr_con->left_olsr_node->pos_vec[1],
+							olsr_con->left_olsr_node->pos_vec[2]);
+
+
+			distance = dirt( olsr_con->left_olsr_node->pos_vec, null_vec, tmp_mov_vec );
+			target_vec[0]=olsr_con->left_olsr_node->pos_vec[0]/distance * (ESIZE+10);
+			target_vec[1]=olsr_con->left_olsr_node->pos_vec[1]/distance * (ESIZE+10);
+			target_vec[2]=olsr_con->left_olsr_node->pos_vec[2]/distance * (ESIZE+10);
+			distance = dirt( olsr_con->left_olsr_node->pos_vec, target_vec, tmp_mov_vec );
+			mov_add( olsr_con->left_olsr_node->mov_vec, tmp_mov_vec, distance );  /* move a little bit to earth height */
+
+			if ( ! olsr_con->left_olsr_node->static_node) {
+				if ( ( distance = dist( olsr_con->left_olsr_node->mov_vec, null_vec ) ) > 10.0 ) {
+					mov_add( olsr_con->left_olsr_node->pos_vec, olsr_con->left_olsr_node->mov_vec, 1.0/ ( ( float ) distance) );
+				} else {
+					mov_add( olsr_con->left_olsr_node->pos_vec, olsr_con->left_olsr_node->mov_vec, 0.1 );
+				}
+			}
+
+			s3d_translate( olsr_con->left_olsr_node->obj_id, olsr_con->left_olsr_node->pos_vec[0], olsr_con->left_olsr_node->pos_vec[1], olsr_con->left_olsr_node->pos_vec[2] );
+
+			/* reset movement vector */
+			olsr_con->left_olsr_node->mov_vec[0] = olsr_con->left_olsr_node->mov_vec[1] = olsr_con->left_olsr_node->mov_vec[2] = 0.0;
+
+		}
+
+		/* move right olsr node if it has not been moved yet */
+		if ( !( ( olsr_con->right_olsr_node->mov_vec[0] == 0 ) && ( olsr_con->right_olsr_node->mov_vec[1] == 0 ) && ( olsr_con->right_olsr_node->mov_vec[2] == 0 ) ) && olsr_con->right_olsr_node->visible ) {
+
+			distance = dirt( olsr_con->right_olsr_node->pos_vec, olsr_node_init, tmp_mov_vec );
+			if (distance>5000)		printf("distance = %3.3f %s| %3.3f %3.3f %3.3f\n",distance,olsr_con->right_olsr_node->ip,
+							olsr_con->right_olsr_node->pos_vec[0],
+							olsr_con->right_olsr_node->pos_vec[1],
+							olsr_con->right_olsr_node->pos_vec[2]);
+
+			distance = dirt( olsr_con->right_olsr_node->pos_vec, null_vec, tmp_mov_vec );
+			target_vec[0]=olsr_con->right_olsr_node->pos_vec[0]/distance * (ESIZE+10);
+			target_vec[1]=olsr_con->right_olsr_node->pos_vec[1]/distance * (ESIZE+10);
+			target_vec[2]=olsr_con->right_olsr_node->pos_vec[2]/distance * (ESIZE+10);
+			distance = dirt( olsr_con->right_olsr_node->pos_vec, target_vec, tmp_mov_vec );
+
+			mov_add( olsr_con->right_olsr_node->mov_vec, tmp_mov_vec, distance ); /* move a little bit to earth height */
+					
+			if ( ! olsr_con->right_olsr_node->static_node) {
+				distance = dist( olsr_con->right_olsr_node->mov_vec, null_vec );
+				if ( distance > 10.0 ) {
+					mov_add( olsr_con->right_olsr_node->pos_vec, olsr_con->right_olsr_node->mov_vec, 1.0/ ( ( float ) distance) );
+				} else {
+					mov_add( olsr_con->right_olsr_node->pos_vec, olsr_con->right_olsr_node->mov_vec, 0.1 );
+				}
+			}
+			s3d_translate( olsr_con->right_olsr_node->obj_id, olsr_con->right_olsr_node->pos_vec[0], olsr_con->right_olsr_node->pos_vec[1], olsr_con->right_olsr_node->pos_vec[2] );
+
+			/* reset movement vector */
+			olsr_con->right_olsr_node->mov_vec[0] = olsr_con->right_olsr_node->mov_vec[1] = olsr_con->right_olsr_node->mov_vec[2] = 0.0;
+
+		}
+
+
+		/* move connection between left and right olsr node */
+		vertex_buf[0] = olsr_con->left_olsr_node->pos_vec[0];
+		vertex_buf[1] = olsr_con->left_olsr_node->pos_vec[1];
+		vertex_buf[2] = olsr_con->left_olsr_node->pos_vec[2];
+		vertex_buf[3] = olsr_con->right_olsr_node->pos_vec[0];
+		vertex_buf[4] = olsr_con->right_olsr_node->pos_vec[1];
+		vertex_buf[5] = olsr_con->right_olsr_node->pos_vec[2];
+
+		s3d_pep_vertices( olsr_con->obj_id, vertex_buf, 2 );
+
+
+		if ( ColorSwitch ) {
+
+			/* HNA */
+			if ( olsr_con->left_etx == -1000.00 ) {
+
+				if(olsr_con->color != 1) {
+					s3d_pep_material( olsr_con->obj_id,
+								   0.0,0.0,1.0,
+								   0.0,0.0,1.0,
+								   0.0,0.0,1.0);
+					olsr_con->color = 1;
+				}
+
+			} else {
+
+				etx = ( olsr_con->left_etx + olsr_con->right_etx ) / 2.0;
+
+				/* very good link - bright blue */
+				if ( ( etx >= 1.0 ) && ( etx < 1.5 ) ) {
+
+					if(olsr_con->color != 2) {
+						s3d_pep_material( olsr_con->obj_id,
+								0.5,1.0,1.0,
+								0.5,1.0,1.0,
+								0.5,1.0,1.0);
+						olsr_con->color = 2;
+					}
+
+				/* good link - bright yellow */
+				} else if ( ( etx >= 1.5 ) && ( etx < 2.0 ) ) {
+
+					rgb = 2.0 - etx;
+					if( olsr_con->color != 3 || (olsr_con->color == 3 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
+						s3d_pep_material( olsr_con->obj_id,
+								1.0,1.0,rgb,
+								1.0,1.0,rgb,
+								1.0,1.0,rgb);
+						olsr_con->color = 3;
+
+						olsr_con->rgb =  rgb;
+					}
+
+				/* not so good link - orange */
+				} else if ( ( etx >= 2.0 ) && ( etx < 3.0 ) ) {
+
+					rgb = 1.5 - ( etx / 2.0 );
+					if( olsr_con->color != 4 || (olsr_con->color == 4 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10))) {
+						s3d_pep_material( olsr_con->obj_id,
+								1.0,rgb,0.0,
+								1.0,rgb,0.0,
+								1.0,rgb,0.0);
+						olsr_con->color = 4;
+
+						olsr_con->rgb = rgb;
+					}
+
+				/* bad link (almost dead) - brown */
+				} else if ( ( etx >= 3.0 ) && ( etx < 5.0 ) ) {
+
+					rgb = 1.75 - ( etx / 4.0 );
+
+					if( olsr_con->color != 5 || (olsr_con->color == 5 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
+
+						s3d_pep_material( olsr_con->obj_id,
+								rgb,rgb - 0.5,0.0,
+								rgb,rgb - 0.5,0.0,
+								rgb,rgb - 0.5,0.0);
+						olsr_con->color = 5;
+
+						olsr_con->rgb = rgb;
+					}
+
+				/* zombie link - grey */
+				} else if ( ( etx >= 5.0 ) && ( etx < 1000.0 ) ) {
+
+					rgb = 1000.0 / ( 1500.0 + etx );
+
+					if( olsr_con->color != 6 || (olsr_con->color == 6 && (int) rintf(olsr_con->rgb * 10) !=  (int) rintf(rgb * 10)) ) {
+
+						s3d_pep_material( olsr_con->obj_id,
+								rgb,rgb,rgb,
+								rgb,rgb,rgb,
+								rgb,rgb,rgb);
+						olsr_con->color = 6;
+
+						olsr_con->rgb = rgb;
+					}
+
+				/* wtf - dark grey */
+				} else {
+
+					if(olsr_con->color != 7) {
+						s3d_pep_material( olsr_con->obj_id,
+								0.3,0.3,0.3,
+								0.3,0.3,0.3,
+								0.3,0.3,0.3);
+						olsr_con->color = 7;
+					}
+
+				}
+
+			}
+
+		} else {
+
+			if(olsr_con->color != 0) {
+				s3d_pep_material( olsr_con->obj_id,
+							1.0,1.0,1.0,
+							1.0,1.0,1.0,
+							1.0,1.0,1.0);
+				olsr_con->color = 0;
+			}
+
+		}
+
+
+		olsr_con = olsr_con->next_olsr_con;
+
+	}
+
+}
+
+
+
+void olsr_main() {
+
+	int net_result;   /* result of function net_main */
+	char nc_str[20];
+	float strLen;
+	if (!olsr_ready) return;
+
+	/* calculate new movement vector */
+	calc_olsr_node_mov();
+
+	/* prepare nodes */
+	handle_olsr_node( Olsr_root );
+
+	/* move it */
+	move_olsr_nodes();
+
+	/* if we have more or less nodes now - redraw node count */
+	if ( Olsr_node_count != Last_olsr_node_count ) {
+
+		if ( Olsr_node_count_obj != -1 ) s3d_del_object( Olsr_node_count_obj );
+		snprintf( nc_str, 20, "node count: %d", Olsr_node_count );
+		Olsr_node_count_obj = s3d_draw_string( nc_str, &strLen );
+		s3d_link( Olsr_node_count_obj, 0 );
+		s3d_flags_on( Olsr_node_count_obj, S3D_OF_VISIBLE );
+		s3d_scale( Olsr_node_count_obj, 0.2 );
+		s3d_translate( Olsr_node_count_obj, -Left*3.0-(strLen * 0.2), -Bottom*3.0-0.5, -3.0 );
+		Last_olsr_node_count = Olsr_node_count;
+
+	}
+
+	if ( Output_block_completed ) {
+
+		Output_block_counter++;
+		Output_block_completed = 0;
+
+	}
+
+	/* read data from socket */
+	Net_read_count = 0;
+	while ( ( net_result = net_main() ) != 0 ) {
+		if ( net_result == -1 ) {
+			s3d_quit();
+			break;
+		}
+	}
+	nav_campos(CamPosition[0], CamPosition2[0]);
+	
+	/* calc for node description */
+
+	/* check search status */
+/*	if( get_search_status() == WIDGET )
+		move_to_search_widget( CamPosition[0], CamPosition[1] );*/
+	if( get_search_status() == FOLLOW )
+		follow_node( CamPosition[0], CamPosition[1], 0 );
+/*	if( get_search_status() == ABORT )
+		move_to_return_point( CamPosition[0], CamPosition[1] );*/
+
+
+	if( Olsr_ip_label_obj != -1 )
+	{
+		print_etx();
+	}
+
+
+	return;
+
+}
+
+/***
+ *
+ * eventhandler when key pressed
+ *
+ ***/
+
+int olsr_keypress(struct s3d_evt *event) {
+
+	struct s3d_key_event *key=(struct s3d_key_event *)event->buf;
+	if (!olsr_ready) return(0);
+	if( get_search_status() != WIDGET )
+	{
+		switch(key->keysym)
+		{
+			case S3DK_F1: /* help */
+
+				window_help();
+				break;
+
+			case S3DK_ESCAPE: /* abort action */
+
+				set_search_status( get_search_status() == WIDGET ? ABORT : NOTHING );
+				break;
+
+			case S3DK_F3: /* move to search widget, give widget focus */
+
+				set_search_status(WIDGET);							/* set status for mainloop */
+				set_node_root( Olsr_root );
+				show_search_window();
+/*				set_return_point(CamPosition[0],CamPosition[1]);	/ * save the return position * /
+				set_node_root( Olsr_root );*/
+
+				break;
+
+			case S3DK_c: /* color on/off */
+
+				ColorSwitch =  ColorSwitch ? 0 : 1;
+				break;
+
+
+			case S3DK_PAGEUP: /* change factor in calc_olsr_node_mov */
+
+				if(Factor < 0.9)
+					Factor += 0.1;
+				break;
+
+			case S3DK_PAGEDOWN: /* change factor in calc_olsr_node_mov */
+
+				if(Factor > 0.3)
+					Factor -= 0.1;
+				break;
+
+		}
+	} else {
+		if( (key->keysym >= S3DK_PERIOD && key->keysym <= S3DK_9) || key->keysym == S3DK_COMMA || key->keysym == S3DK_RETURN || key->keysym == S3DK_BACKSPACE )
+			search_widget_write( key->keysym );
+	}
+	return(0);
+}
+
+/***
+ *
+ * eventhandler when object clicked
+ *
+ ***/
+
+int olsr_object_click(struct s3d_evt *evt)
+{
+/*	int i
+	char ip_str[50];
+	struct timeval tv;*/
+	struct olsr_node *olsr_node;
+	int oid;
+	if (!olsr_ready) return(0);
+
+
+	oid=(int)*((uint32_t *)evt->buf);
+
+
+	if ( ( get_search_status() != FOLLOW ) && ( Last_Click_Oid == oid ) && ( Last_Click_Time + 250 > get_time() ) ) {
+
+		olsr_node = lst_search(oid);
+
+		if ( olsr_node != NULL ) 
+			follow_node_by_click( olsr_node );
+
+	}
+
+	Last_Click_Oid = oid;
+	Last_Click_Time = get_time();
+
+	return(0);
+}
+
+void print_etx()
+{
+	struct olsr_neigh_list *tmpNeighbour;
+	float p = 1.4;
+	int i;
+	float len = 0.0, max_len=0.0;
+
+	if( Olsr_neighbour_label_obj != NULL )
+	{
+		/* int n = sizeof(Olsr_neighbour_label_obj) / sizeof(int);*/
+		for(i=0; i < Size; i++)
+			s3d_del_object( Olsr_neighbour_label_obj[i] );
+		free(Olsr_neighbour_label_obj);
+		Olsr_neighbour_label_obj = NULL;
+	}
+
+	tmpNeighbour = Olsr_node_pEtx->olsr_neigh_list;
+
+	Size = 0;
+	while(tmpNeighbour != NULL)
+	{
+		Size++;
+		tmpNeighbour = tmpNeighbour->next_olsr_neigh_list;
+	}
+
+	Olsr_neighbour_label_obj = malloc(Size*sizeof(int));
+	tmpNeighbour = Olsr_node_pEtx->olsr_neigh_list;
+
+	for(i = 0; i < Size ;i++)
+	{
+		char nIpStr[60];
+		float mEtx = ( tmpNeighbour->olsr_con->left_etx + tmpNeighbour->olsr_con->right_etx ) / 2;
+
+		if( mEtx != -1000 )
+			snprintf(nIpStr, 60, "%15s --> %.2f",(strcmp(Olsr_node_pEtx->ip,tmpNeighbour->olsr_con->right_olsr_node->ip)?tmpNeighbour->olsr_con->right_olsr_node->ip:tmpNeighbour->olsr_con->left_olsr_node->ip),mEtx);
+		else
+			snprintf(nIpStr, 60, "%15s --> HNA",(strcmp(Olsr_node_pEtx->ip,tmpNeighbour->olsr_con->right_olsr_node->ip)?tmpNeighbour->olsr_con->right_olsr_node->ip:tmpNeighbour->olsr_con->left_olsr_node->ip));
+
+		Olsr_neighbour_label_obj[i] = s3d_draw_string( nIpStr, &len );
+		s3d_link(Olsr_neighbour_label_obj[i], 0);
+		s3d_flags_on(Olsr_neighbour_label_obj[i], S3D_OF_VISIBLE );
+		s3d_scale(Olsr_neighbour_label_obj[i], 0.2 );
+		s3d_translate(Olsr_neighbour_label_obj[i], -Left*3.0-(len * 0.2)-0.15, -Bottom*3.0-p, -3.0 );
+		tmpNeighbour = tmpNeighbour->next_olsr_neigh_list;
+		p += 0.2;
+		max_len = (len > max_len - 0.2)?len+0.2:max_len;
+		max_len = (Title_len > max_len - 0.2)?len+0.2:max_len;
+		/* printf("title: %f len: %f maxlen: %f %s\n",Title_len,len,max_len-0.2,nIpStr);*/
+	}
+
+	if( Btn_close_id != -1)
+	{
+		if( Output_border[0] == -1 )
+		{
+			for(i = 0; i < 4; i++)
+			{
+				Output_border[i] = s3d_new_object();
+				s3d_push_material( Output_border[i],
+					1.0,1.0,1.0,
+					1.0,1.0,1.0,
+					1.0,1.0,1.0);
+			}
+			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,			-Bottom*3.0-0.9, -3.0);
+			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
+
+			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-1.0, -3.0);
+			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
+
+			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,			-Bottom*3.0-p, 	-3.0);
+			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
+
+			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
+			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	-3.0);
+
+			s3d_push_line( Output_border[0], 0,1,0);
+			s3d_push_line( Output_border[1], 0,1,0);
+			s3d_push_line( Output_border[2], 0,1,0);
+			s3d_push_line( Output_border[3], 0,1,0);
+
+			s3d_flags_on( Output_border[0], S3D_OF_VISIBLE);
+			s3d_flags_on( Output_border[1], S3D_OF_VISIBLE);
+			s3d_flags_on( Output_border[2], S3D_OF_VISIBLE);
+			s3d_flags_on( Output_border[3], S3D_OF_VISIBLE);
+
+			s3d_link( Output_border[0], 0);
+			s3d_link( Output_border[1], 0);
+			s3d_link( Output_border[2], 0);
+			s3d_link( Output_border[3], 0);
+		} else {
+			s3d_pop_vertex(Output_border[0], 2);
+			s3d_pop_vertex(Output_border[1], 2);
+			s3d_pop_vertex(Output_border[2], 2);
+			s3d_pop_vertex(Output_border[3], 2);
+			s3d_push_vertex(Output_border[0], -Left*3.0-0.2,				-Bottom*3.0-0.9, -3.0);
+			s3d_push_vertex(Output_border[0], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
+
+			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-1.0, -3.0);
+			s3d_push_vertex(Output_border[1], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
+
+			s3d_push_vertex(Output_border[2], -Left*3.0-0.1,				-Bottom*3.0-p,	 -3.0);
+			s3d_push_vertex(Output_border[2], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p,	 -3.0);
+
+			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-0.9, -3.0);
+			s3d_push_vertex(Output_border[3], -Left*3.0-(max_len*0.2),	-Bottom*3.0-p, 	 -3.0);
+		}
+	}
+}
+
+
+
+/***
+ *
+ * eventhandler when object change by user
+ * such as Cam
+ *
+ ***/
+
+int olsr_object_info(struct s3d_evt *hrmz)
+{
+	struct s3d_obj_info *inf;
+	inf=(struct s3d_obj_info *)hrmz->buf;
+	if (!olsr_ready) return(0);
+	s3dw_object_info(hrmz);
+	if (inf->object==0)
+	{
+		CamPosition[0][0] = inf->trans_x;
+		CamPosition[0][1] = inf->trans_y;
+		CamPosition[0][2] = inf->trans_z;
+		CamPosition[1][0] = inf->rot_x;
+		CamPosition[1][1] = inf->rot_y;
+		CamPosition[1][2] = inf->rot_z;
+		Asp=inf->scale;
+		if (Asp>1.0) /* wide screen */
+		{
+			Bottom=-1.0;
+			Left=-Asp;
+		} else {  /* high screen */
+			Bottom=(-1.0/Asp);
+			Left=-1.0;
+
+		}
+
+	}
+	/* printf("%f %f %f\n",inf->trans_x,inf->trans_y,inf->trans_z); */
+	return(0);
+}
+
+int mbutton_press(struct s3d_evt *hrmz)
+{
+	struct s3d_but_info *inf;
+	inf=(struct s3d_but_info *)hrmz->buf;
+	printf("button %d, state %d\n", inf->button,inf->state);
+	return(0);
+}
+
+int olsr_parse_args(int argc, char **argv) {
+	int optchar;
+	strncpy( Olsr_host, "127.0.0.1", 256 );
+	lbuf[0] = '\0';   /* init lbuf */
+
+	while ( ( optchar = getopt ( argc, argv, "dhH:" ) ) != -1 ) {
+
+		switch ( optchar ) {
+
+			case 'd':
+				Debug = 1;
+				break;
+
+			case 'H':
+				strncpy( Olsr_host, optarg, 256 );
+				break;
+
+			case 'h':
+			default:
+				print_usage();
+				return (1);
+		}
+
+	}
+	return(0);
+}
+int olsr_init()
+{
+	if ( Debug )
+		printf( "debug mode enabled ...\n" );
+
+	/* initialize obj2ip linked list */
+	lst_initialize();
+
+	/* set extern int optind = 0 for parse_args in io.c */
+	optind = 0;
+	
+	Olsr_node_obj = s3d_import_model_file( "objs/accesspoint.3ds" );
+	Olsr_node_inet_obj = s3d_import_model_file( "objs/accesspoint_inet.3ds" );
+	Olsr_node_hna_net = s3d_import_model_file( "objs/internet.3ds" );
+	Btn_close_obj = s3d_import_model_file( "objs/btn_close.3ds" );
+
+	S3d_obj = s3d_import_model_file( "objs/s3d_berlios_de.3ds" );
+	s3d_translate( S3d_obj, 0.75, -0.75, -1 );
+	s3d_scale( S3d_obj, 0.07 );
+	s3d_link( S3d_obj, 0 );
+	s3d_flags_on( S3d_obj, S3D_OF_VISIBLE );
+
+	ZeroPoint = s3d_new_object();
+	Output_border[0] = Output_border[1] = Output_border[2] = Output_border[3] = -1;
+	db_olsr_node_init(olsr_node_init);
+
+	s3d_link(ZeroPoint, oidy);
+
+	/* create_search_widget( 0, 0, 300 ); */
+	if (net_init(Olsr_host)) return(1);
+	olsr_ready=1;
+	return(0);
+
+}
+int olsr_quit()
+{
+	if (!olsr_ready) return(0);
+	olsr_ready=0;
+	/* TODO: remove nodes and objects here */
+	net_quit();
+	return(0);
+}
+

Added: trunk/apps/s3dosm/olsrs3d.h
===================================================================
--- trunk/apps/s3dosm/olsrs3d.h	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/olsrs3d.h	2006-12-23 23:09:05 UTC (rev 551)
@@ -0,0 +1,75 @@
+/*
+ * olsrs3d.h
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                         Marek Lindner <lindner_marek at yahoo.de>
+ *                         Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of olsrs3d, an olsr topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "structs.h"
+
+
+#define max(x,y)((x)>(y)?(x):(y))
+#define min(x,y)((x)<(y)?(x):(y))
+
+
+
+extern int Debug;
+
+extern struct olsr_con *Con_begin;   /* begin of connection list */
+extern struct olsr_node *Olsr_root;   /* top of olsr node tree */
+extern struct Obj_to_ip *Obj_to_ip_head, *Obj_to_ip_end, *List_ptr;   /* struct list */
+
+extern int	Olsr_node_obj;
+extern int	Olsr_node_inet_obj;
+extern int	Olsr_node_hna_net;
+extern int	Btn_close_obj;
+extern int	S3d_obj;
+extern int	Btn_close_id;
+extern int Olsr_node_count_obj;
+extern int Olsr_node_count;
+extern int Last_olsr_node_count;
+extern int Net_read_count;
+extern int Output_block_counter;
+extern int Output_block_completed;
+extern int ZeroPoint;
+extern float CamPosition[2][3];
+extern float Bottom, Left;
+extern char lbuf[MAXLINESIZE];
+extern int Move_cam_target;
+extern int move_cam_to;
+
+/* process */
+void lst_initialize();
+void lst_add(int id,struct olsr_node **olsr_node);
+void lst_del(int id);
+struct olsr_node *lst_search(int id);
+void lst_out();
+struct olsr_node *move_lst_ptr(int *id);
+int process_main();
+/* net */
+int net_init(char *host);
+int net_main();
+int net_quit();
+/* main */
+void out_of_mem( void );
+void print_etx( void );
+float dist(float p1[], float p2[]);
+void window_error(char *msg);

Added: trunk/apps/s3dosm/process.c
===================================================================
--- trunk/apps/s3dosm/process.c	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/process.c	2006-12-23 23:09:05 UTC (rev 551)
@@ -0,0 +1,528 @@
+/*
+ * process.c
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                         Marek Lindner <lindner_marek at yahoo.de>
+ *                         Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of olsrs3d, an olsr topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+#include <stdio.h> 	/* NULL */
+#include <string.h> 	/* strlen(), memmove() */
+#include <stdlib.h> 	/* rand(), malloc(), realloc(), free() */
+#include <s3d.h>
+#include <math.h>       /* sqrt() */
+#include "olsrs3d.h"
+#include "s3dosm.h"	/* db_check_olsr() */
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+
+char lbuf[MAXLINESIZE];
+float olsr_node_init[6]={0,0,0,0,0,0};
+
+
+
+/***
+ *
+ * create new or alter connection between 2 nodes
+ *
+ *   con_from =>   current node
+ *   con_to   =>   node to connect to
+ *   etx      =>   ETX
+ *
+ ***/
+
+int add_olsr_con( struct olsr_node *con_from, struct olsr_node *con_to, float etx ) {
+
+	struct olsr_con **olsr_con = &Con_begin;
+	struct olsr_con *prev_olsr_con = NULL;   /* previous olsr connection */
+	struct olsr_neigh_list **olsr_neigh_list;
+
+	while ( (*olsr_con) != NULL ) {
+
+		/* connection already exists */
+		if ( ( strncmp( (*olsr_con)->left_olsr_node->ip, con_from->ip, NAMEMAX ) == 0 ) && ( strncmp( (*olsr_con)->right_olsr_node->ip, con_to->ip, NAMEMAX ) == 0 ) ) {
+			(*olsr_con)->left_etx = etx;
+			(*olsr_con)->left_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
+			break;
+
+		} else if ( ( strncmp( (*olsr_con)->right_olsr_node->ip, con_from->ip, NAMEMAX ) == 0 ) && ( strncmp( (*olsr_con)->left_olsr_node->ip, con_to->ip, NAMEMAX ) == 0 ) ) {
+
+			(*olsr_con)->right_etx = etx;
+			(*olsr_con)->right_etx_sqrt = (etx==-1000.00)? 10.0 : sqrt( etx ) ;
+			break;
+
+		}
+
+		/* save previous olsr connection for later use */
+		prev_olsr_con = (*olsr_con);
+
+		olsr_con = &(*olsr_con)->next_olsr_con;
+
+	}
+
+	/* new connection */
+	if ( (*olsr_con) == NULL ) {
+
+		(*olsr_con) = malloc( sizeof( struct olsr_con ) );
+		if ( (*olsr_con) == NULL ) out_of_mem();
+
+		/* create connection object */
+		(*olsr_con)->obj_id = s3d_new_object();
+
+		/* add olsr node to new olsr connection in order to access the nodes from the connection list */
+		(*olsr_con)->left_olsr_node = con_from;
+		(*olsr_con)->right_olsr_node = con_to;
+
+		/* add connection color */
+		(*olsr_con)->color = 0;
+		s3d_push_material( (*olsr_con)->obj_id,
+				  1.0,1.0,1.0,
+				  1.0,1.0,1.0,
+				  1.0,1.0,1.0);
+
+		/* add connection endpoints */
+		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->left_olsr_node->pos_vec[0], (*olsr_con)->left_olsr_node->pos_vec[1], (*olsr_con)->left_olsr_node->pos_vec[2] );
+		s3d_push_vertex( (*olsr_con)->obj_id, (*olsr_con)->right_olsr_node->pos_vec[0], (*olsr_con)->right_olsr_node->pos_vec[1], (*olsr_con)->right_olsr_node->pos_vec[2] );
+
+		s3d_push_line( (*olsr_con)->obj_id, 0,1,0 );
+
+		s3d_flags_on( (*olsr_con)->obj_id, S3D_OF_VISIBLE );
+
+		s3d_link( (*olsr_con)->obj_id,  ZeroPoint );
+
+		/* HNA */
+		if ( etx == -1000.00 ) {
+
+			(*olsr_con)->left_etx = etx;
+			(*olsr_con)->left_etx_sqrt = 10.0;
+			(*olsr_con)->right_etx = etx;
+			(*olsr_con)->right_etx_sqrt = 10.0;
+
+		} else {
+
+			(*olsr_con)->left_etx = etx;
+			(*olsr_con)->left_etx_sqrt = sqrt( etx );
+			(*olsr_con)->right_etx = 999.0;
+			(*olsr_con)->right_etx_sqrt = sqrt( 999.0 );
+
+		}
+
+		(*olsr_con)->next_olsr_con = NULL;
+		(*olsr_con)->prev_olsr_con = prev_olsr_con;
+
+		/* add new olsr connection to olsr nodes in order to access the connection from the olsr node */
+		olsr_neigh_list = &(*olsr_con)->left_olsr_node->olsr_neigh_list;
+		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
+		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
+		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
+		(*olsr_neigh_list)->olsr_con = (*olsr_con);
+		(*olsr_neigh_list)->next_olsr_neigh_list = NULL;
+
+		olsr_neigh_list = &(*olsr_con)->right_olsr_node->olsr_neigh_list;
+		while ( (*olsr_neigh_list) != NULL ) olsr_neigh_list = &(*olsr_neigh_list)->next_olsr_neigh_list;
+		(*olsr_neigh_list) = malloc( sizeof( struct olsr_neigh_list ) );
+		if ( (*olsr_neigh_list) == NULL ) out_of_mem();
+		(*olsr_neigh_list)->olsr_con = (*olsr_con);
+		(*olsr_neigh_list)->next_olsr_neigh_list = NULL;
+
+	}
+
+	return(0);
+
+}
+
+
+
+/***
+ *
+ * get pointer to olsr node or create new node if node string could not be found
+ *
+ *   **node =>   pointer to current olsr_node
+ *   *ip    =>   node ip
+ *
+ *   return olsr node pointer
+ *
+ ***/
+void *get_olsr_node( struct olsr_node **olsr_node, char *ip ) {
+
+	int result;   /* result of strcmp */
+
+	while ( (*olsr_node) != NULL ) {
+
+		result = strncmp( (*olsr_node)->ip, ip, NAMEMAX );
+
+		/* we found the node */
+		if ( result == 0 ) {
+
+			(*olsr_node)->last_seen = Output_block_counter;
+
+			/* former invisble (deleted) node */
+			if ( (*olsr_node)->visible == 0 ) {
+				(*olsr_node)->node_type = 0;
+				(*olsr_node)->node_type_modified = 1;
+
+				(*olsr_node)->visible = 1;
+
+				(*olsr_node)->mov_vec[0] = (*olsr_node)->mov_vec[1] = (*olsr_node)->mov_vec[2] = 0.0;
+
+				if ( Debug ) printf( "new olsr node: %s\n", (*olsr_node)->ip );
+
+				Olsr_node_count++;
+
+			}
+
+			return (*olsr_node);
+
+		}
+
+		/* the searched node must be in the subtree */
+		if ( result < 0 ) {
+			olsr_node = &(*olsr_node)->right;
+		} else {
+			olsr_node = &(*olsr_node)->left;
+		}
+
+	}
+
+	/* if node is NULL we reached the end of the tree and must create a new olsr_node */
+	if ( (*olsr_node) == NULL ) {
+
+		(*olsr_node) = malloc( sizeof( struct olsr_node ) );
+		if ( (*olsr_node) == NULL ) out_of_mem();
+
+		(*olsr_node)->left = NULL;
+		(*olsr_node)->right = NULL;
+
+		strncpy( (*olsr_node)->ip, ip, NAMEMAX );
+
+		(*olsr_node)->node_type = 0;
+		(*olsr_node)->node_type_modified = 1;
+
+		(*olsr_node)->last_seen = Output_block_counter;
+		(*olsr_node)->visible = 1;
+
+		if ( Debug ) printf( "new olsr node: %s\n", (*olsr_node)->ip );
+
+		Olsr_node_count++;
+
+		(*olsr_node)->pos_vec[0] = olsr_node_init[0]+ ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+		(*olsr_node)->pos_vec[1] = olsr_node_init[1]+ ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+		(*olsr_node)->pos_vec[2] = olsr_node_init[2]+ ( ( float ) 2.0 * rand() ) / RAND_MAX - 1.0;
+		(*olsr_node)->static_node=0;
+
+		if (db_olsr_check((*olsr_node)->ip,(*olsr_node)->pos_vec)) {
+			/* pos_vec will be overwritten if there is a database hit */
+			(*olsr_node)->static_node=1;
+		} 
+
+
+		(*olsr_node)->mov_vec[0] = (*olsr_node)->mov_vec[1] = (*olsr_node)->mov_vec[2] = 0.0;
+
+		(*olsr_node)->obj_id = -1;
+		(*olsr_node)->desc_id = -1;
+		(*olsr_node)->olsr_neigh_list = NULL;
+
+		return (*olsr_node);
+
+	}
+	return(0);
+}
+
+/*
+ *
+ * initialize the struct for a linked list obj2ip
+ *
+ */
+
+void lst_initialize() {
+	Obj_to_ip_head = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
+	Obj_to_ip_end = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
+	if(Obj_to_ip_head == NULL || Obj_to_ip_end == NULL)
+		out_of_mem();
+	Obj_to_ip_head->id = 0;
+	Obj_to_ip_end->id = 0;
+	Obj_to_ip_head->prev = Obj_to_ip_end->prev = Obj_to_ip_head;
+	Obj_to_ip_head->next = Obj_to_ip_end->next = Obj_to_ip_end;
+	List_ptr = Obj_to_ip_head;
+}
+
+/*
+ *
+ * add a link object_id to olsr_node, to get ip adress and coordinates per object_id
+ *                 id => object_id, returned from s3d_clone or s3d_new_object
+ *  **olsr_node => pointer to pointer of current olsr_node
+ *
+ */
+
+void lst_add(int id,struct olsr_node **olsr_node) {
+	struct Obj_to_ip *new;
+	new = (struct Obj_to_ip*) malloc(sizeof(struct Obj_to_ip));
+	if(new == NULL)
+		out_of_mem();
+	new->id = id;
+	new->olsr_node = *olsr_node;
+	move_lst_ptr(&id);
+	new->prev = List_ptr;
+	new->next = List_ptr->next;
+	List_ptr->next->prev = new;
+	List_ptr->next = new;
+	/* printf("obj2ip: add object %d between %d .. %d ip %s to list\n",new->id,new->prev->id,new->next->id,new->olsr_node->ip); */
+}
+
+/*
+ *void move_lst_ptr(int *id)
+ * remove element from obj2ip linked list
+ * id => object_id, returned from s3d_clone or s3d_new_object
+ *
+ */
+
+void lst_del(int id) {
+	struct Obj_to_ip *del;
+	move_lst_ptr(&id);
+	if(id != List_ptr->id)
+	{
+		printf("obj2ip: remove id %d failed move_lst_ptr return id %d\n",id,List_ptr->next->id);
+	} else {
+		del = List_ptr;
+		List_ptr->next->prev = List_ptr->prev;
+		List_ptr->prev->next = List_ptr->next;
+		/* printf("obj2ip: remove object %d --> %d <-- %d ip %s from list\n",List_ptr->prev->id,del->id,List_ptr->next->id,del->olsr_node->ip); */
+		free(del);
+	}
+}
+
+/*
+ *
+ * move the List_ptr one positon ahead the searched element
+ *	*id => pointer of object_id , returned from s3d_clone or s3d_new_object
+ *
+ */
+
+struct olsr_node *move_lst_ptr(int *id) {
+	/* printf("obj2ip: move for %d\n",*id); */
+	/* head to point at end or id lass then first element in linked list*/
+	if(Obj_to_ip_head->next == Obj_to_ip_head || *id < Obj_to_ip_head->next->id) {
+		List_ptr = Obj_to_ip_head;
+		return NULL;
+ 	/* id is greather then last element in linked list */
+	} else if(*id > Obj_to_ip_end->prev->id) {
+		List_ptr = Obj_to_ip_end->prev;
+		return NULL;
+	} else {
+		/* printf("obj2ip: ok i search deeper ;-) for id=%d\n",*id); */
+		if((*id - (int) Obj_to_ip_head->next->id) <= ((int)(Obj_to_ip_end->prev->id)-*id)) {
+			List_ptr = Obj_to_ip_head;
+			/* printf("obj2ip: start at head id %d - %d <= %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id); */
+			while(*id >= List_ptr->next->id) {
+				/* printf("obj2ip: %d > %d move to ",*id,List_ptr->id); */
+				List_ptr = List_ptr->next;
+				/* printf("%d\n",List_ptr->id); */
+			}
+		} else {
+			List_ptr = Obj_to_ip_end;
+			/* printf("obj2ip: start at end id %d - %d > %d - %d \n",*id,Obj_to_ip_head->next->id,Obj_to_ip_end->prev->id,*id);  */
+			/*  do List_ptr = List_ptr->prev; while(*id > List_ptr->prev->id); */
+			while(*id < List_ptr->prev->id) {
+				/* printf("obj2ip: %d < %d move to ",*id,List_ptr->id); */
+				List_ptr = List_ptr->prev;
+				/* printf("%d\n",List_ptr->id); */
+			}
+			List_ptr = List_ptr->prev;
+		}
+
+		if ( List_ptr->id == *id )
+			return List_ptr->olsr_node;
+		else
+			return NULL;
+
+		/* printf("obj2ip: found id to insert between %d--> .. <--%d to search/delete %d--> .. <--%d\n",List_ptr->id,List_ptr->next->next->id,List_ptr->prev->id,List_ptr->next->id); */
+	}
+}
+
+/*
+ *
+ * search a object_id in linked list and return pointer on struct olsr_node
+ *	id => object_id , returned from s3d_clone or s3d_new_object
+ *
+ * <example>
+ *     struct olsr_node *olsr_node;
+ *     olsr_node = *lst_search(oid);
+ *     printf("obj2ip: search return %s\n",olsr_node->ip);
+ * </example>
+ *
+ */
+
+struct olsr_node *lst_search(int id) {
+
+	return( move_lst_ptr(&id) );
+
+}
+
+void lst_out() {
+	struct Obj_to_ip *ptr;
+	ptr = Obj_to_ip_head;
+	while(ptr != ptr->next) {
+		printf("id-> %d\n",ptr->id);
+		ptr = ptr->next;
+	}
+}
+
+int process_main() {
+
+	int dn;
+	float f;
+	char *lbuf_ptr, *last_cr_ptr, *con_from, *con_from_end, *con_to, *con_to_end, *etx, *etx_end, *tmpChar;
+	struct olsr_node *olsr_node1;   /* pointer to olsr nodes */
+	struct olsr_node *olsr_node2;
+	int address;
+	char hna_name[NAMEMAX];
+	char hna_node[NAMEMAX];
+
+	lbuf_ptr = lbuf;
+	last_cr_ptr = NULL;
+
+	con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
+	dn = 0;
+
+	/*printf("---lbuf-start---\n%s\n---lbuf-end---\n",lbuf);*/
+
+	while ( (*lbuf_ptr) != '\0' ) {
+
+		/* printf( "%c",(*lbuf_ptr) ); */
+
+		if ( (*lbuf_ptr) == '\n' ) {
+
+			last_cr_ptr = lbuf_ptr;
+			con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
+			dn = 0;
+
+		}
+
+		if ( (*lbuf_ptr) == '"' ) {
+
+			switch ( dn ) {
+
+				case 0:
+					con_from = lbuf_ptr + 1;
+					break;
+				case 1:
+					con_from_end = lbuf_ptr;
+					break;
+				case 2:
+					con_to = lbuf_ptr + 1;
+					break;
+				case 3:
+					con_to_end = lbuf_ptr;
+					break;
+				case 4:
+					etx = lbuf_ptr + 1;
+					break;
+				case 5:
+					etx_end = lbuf_ptr;
+					break;
+
+			}
+
+			if ( ++dn == 6 ) {
+
+				/* terminate strings - but not before 6 times '"' */
+				(*con_from_end) = (*con_to_end) = (*etx_end) = '\0';
+
+				/* printf( "con_from: %s, con_to: %s, etx: %s\n", con_from, con_to, etx ); */
+
+				/* announced network via HNA */
+				if ( strncmp( etx, "HNA", NAMEMAX ) == 0 ) {
+
+					/* connection to internet */
+					if ( strncmp( con_to, "0.0.0.0/0.0.0.0", NAMEMAX ) == 0 ) {
+
+						olsr_node1 = get_olsr_node( &Olsr_root, con_from );
+
+						if ( olsr_node1->node_type != 1 ) {
+
+							olsr_node1->node_type = 1;
+							olsr_node1->node_type_modified = 1;
+							if ( Debug ) printf( "new internet: %s\n", olsr_node1->ip );
+
+						}
+
+					/* normal HNA */
+					} else {
+						memmove(hna_node,con_to,NAMEMAX);
+						if( (tmpChar = strchr(hna_node, (int)'/')))
+						{
+							tmpChar++;
+							address = (int)-inet_network(tmpChar);
+							sprintf(hna_name,"%d",(int)(32 - ceil(log(address)/log(2))));
+							strcpy(tmpChar,hna_name);
+						}
+
+						olsr_node1 = get_olsr_node( &Olsr_root, con_from );
+						olsr_node2 = get_olsr_node( &Olsr_root, hna_node );
+
+						if ( olsr_node2->node_type != 2 ) {
+
+							olsr_node2->node_type = 2;
+							olsr_node2->node_type_modified = 1;
+							if ( Debug ) printf( "new hna network: %s\n", olsr_node2->ip );
+
+						}
+						if ( olsr_node1->visible && olsr_node2->visible )
+							add_olsr_con( olsr_node1, olsr_node2, -1000.00 );
+
+					}
+
+				/* normal node */
+				} else {
+
+					olsr_node1 = get_olsr_node( &Olsr_root, con_from );
+					olsr_node2 = get_olsr_node( &Olsr_root, con_to );
+					f = strtod(etx,NULL);
+					if ( f < 1.0 )
+						f = 999.0;
+					add_olsr_con( olsr_node1, olsr_node2, f );
+				}
+				/* remove zerobyte */
+				(*con_from_end) = (*con_to_end) = (*etx_end) = '"';
+
+				con_from = con_from_end = con_to = con_to_end = etx = etx_end = NULL;
+				dn = 0;
+				last_cr_ptr = lbuf_ptr;
+
+			}
+
+		} else if ( ( (*lbuf_ptr) == '}' ) && ( (*(lbuf_ptr + 1)) == '\n' ) ) {
+
+			Output_block_completed = 1;
+
+		}
+
+		lbuf_ptr++;
+
+	}
+
+	if ( last_cr_ptr != NULL ) memmove( lbuf, last_cr_ptr + 1, strlen( last_cr_ptr ) );
+	/*printf("---memmove-lbuf-start---\n%s\n---memmove-lbuf-end---\n",lbuf);*/
+	return(0);
+
+}

Modified: trunk/apps/s3dosm/s3dosm.h
===================================================================
--- trunk/apps/s3dosm/s3dosm.h	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/s3dosm.h	2006-12-23 23:09:05 UTC (rev 551)
@@ -1,4 +1,5 @@
 #include <sqlite3.h>
+#include <s3d.h>	/* s3devt structure */
 #include "../../config.h"
 #define	ESIZE	637800		/* earth size */
 #define	RESCALE	1
@@ -145,6 +146,7 @@
 void nav_init();
 void nav_center(float la, float lo);
 void nav_autocenter();
+void nav_campos(float campos[3], float earthpos[3]);
 float get_heading(float la1, float lo1, float la2, float lo2);
 extern int oidy;
 /* tag.c */
@@ -155,10 +157,13 @@
 char *read_file(char *fname, int *fsize);
 int process_args(int argc, char **argv);
 /* db.c */
+int db_olsr_node_init(float *pos);
+int db_olsr_check(char *ip, float *pos);
 int db_exec(const char *query, sqlite3_callback callback, void *arg);
 int db_add_tag(object_t *obj, char *key, char *val);
 int db_gettag(int tagid, char *field, char *target);
 int db_getint(void *tagid, int argc, char **argv, char **azColName);
+int db_getpoint(void *data, int argc, char **argv, char **azColName);
 int db_insert_node(node_t *node);
 int db_insert_segment(segment_t *seg);
 int db_insert_way_only(way_t *way);
@@ -175,6 +180,17 @@
 int gps_main();
 int gps_quit();
 /* ui.c */
+int ui_init();
 int load_window(char *text);
 int load_window_remove();
 int load_update_status(float percent);
+/* olsrs3d.c */
+#define NODEHEIGHT	10
+int olsr_object_click(struct s3d_evt *evt);
+int olsr_object_info(struct s3d_evt *hrmz);
+int olsr_parse_args(int argc, char **argv);
+int olsr_keypress(struct s3d_evt *event);
+void olsr_main();
+int olsr_init();
+int olsr_quit();
+int olsr_parse_args(int argc, char **argv);

Added: trunk/apps/s3dosm/search.c
===================================================================
--- trunk/apps/s3dosm/search.c	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/search.c	2006-12-23 23:09:05 UTC (rev 551)
@@ -0,0 +1,387 @@
+/*
+ * search.c
+ *
+ * Copyright (C) 2006 Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of the olsrs3d, an olsr topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <s3d.h>
+#include <s3dw.h>
+#include <s3d_keysym.h>
+#include <math.h>
+#include <stdio.h>	/* TODO can remove then no more printf needed */
+#include <string.h>
+#include "olsrs3d.h"	/* for window_error(), structs */
+/* #include "structs.h"  already included by olsrs3d.h */
+#include "search.h"
+
+s3dw_surface	*_search_surface;
+s3dw_input		*_search_input;
+s3dw_widget		*_search_widget;
+
+struct olsr_node *_node_root = NULL;
+struct olsr_node **search_node = NULL;
+
+float	_return_point[2][3];				/* cam position before move to the widget */
+int		_search_status = NOTHING;			/* status of search */
+
+void _search_node(s3dw_widget *dummy);
+void _new_search_node(s3dw_widget *dummy);
+void _abort_search(s3dw_widget *dummy);
+
+
+/* public */
+void follow_node(float cam_position_t[], float cam_position_r[],float rotate)
+{
+	float real_node_pos[3],
+		  cam_target[3],
+		  tmp_vec[3],
+		  diff_vec[3],
+		  angle;
+
+	real_node_pos[0] =  (*search_node)->pos_vec[0] * cos( rotate * M_PI / 180.0 ) - (*search_node)->pos_vec[2] * -sin ( rotate * M_PI / 180.0 );
+	real_node_pos[1] =  (*search_node)->pos_vec[1];
+	real_node_pos[2] =  (*search_node)->pos_vec[0] * -sin( rotate * M_PI / 180.0) + (*search_node)->pos_vec[2] * cos ( rotate * M_PI / 180.0 );
+
+	cam_target[0] = ( real_node_pos[0] + 7);
+	cam_target[1] =   real_node_pos[1];
+	cam_target[2] = ( real_node_pos[2] + 7);
+
+	cam_position_t[0]=( cam_position_t[0] * 4 + cam_target[0] ) / 5;
+	cam_position_t[1]=( cam_position_t[1] * 4 + cam_target[1] ) / 5;
+	cam_position_t[2]=( cam_position_t[2] * 4 + cam_target[2] ) / 5;
+
+	tmp_vec[0] =  0.0;
+	tmp_vec[1] =  0.0;
+	tmp_vec[2] = -1.0;
+
+	diff_vec[0] = cam_position_t[0] - real_node_pos[0];
+	diff_vec[1] = 0.0;
+	diff_vec[2] = cam_position_t[2] - real_node_pos[2];
+	angle = s3d_vector_angle( diff_vec, tmp_vec );
+	/* angle = ( real_node_pos[0] > 0) ? ( 180 - ( 180 / M_PI * angle ) ) : ( 180 + ( 180 / M_PI * angle ) ); */
+	angle = 180 - ( 180 / M_PI * angle );
+	cam_position_r[1] = ( cam_position_r[1] * 4 + angle ) / 5;
+
+	s3d_translate( 0, cam_position_t[0], cam_position_t[1], cam_position_t[2] );
+	s3d_rotate( 0, cam_position_r[0], cam_position_r[1], cam_position_r[2] );
+}
+void _abort_search_window(s3dw_widget *bwidget)
+{
+	s3dw_delete(bwidget->parent); /* remove the window cointaining the button */
+	_search_surface=NULL;
+	_search_input=NULL;
+	_search_widget=NULL;
+	set_search_status(NOTHING);
+}
+void show_search_window()
+{
+	s3dw_button *search_button, *abort_button;
+
+	_search_surface	= s3dw_surface_new( "Node Search", 17, 10 );
+	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
+
+	s3dw_label_new( _search_surface, "Enter the IP of the node.", 1, 2);
+	s3dw_focus( S3DWIDGET( _search_input ) );
+
+	search_button = s3dw_button_new( _search_surface, "Search", 11.5, 7 );
+	abort_button  = s3dw_button_new( _search_surface, "Abort", 1, 7 );
+	search_button->onclick = _new_search_node;
+	abort_button->onclick = _abort_search_window;
+
+	/* TODO calc position for ok button */
+
+	s3dw_focus	( S3DWIDGET( _search_input ) );
+	s3dw_focus	( S3DWIDGET( _search_surface ) );
+	s3dw_show	( S3DWIDGET( _search_surface ) );
+
+	_search_widget	= S3DWIDGET(search_button);
+}
+
+/* public */
+void create_search_widget(float x, float y, float z)
+{
+	s3dw_button *search_button, *abort_button;
+
+	_search_surface	= s3dw_surface_new( "Node Search", 17, 10 );
+	_search_input	= s3dw_input_new( _search_surface, 15, 1, 4 );
+
+	s3dw_label_new( _search_surface, "Enter the IP of the node.", 1, 2);
+	s3dw_focus( S3DWIDGET( _search_input ) );
+
+	search_button = s3dw_button_new( _search_surface, "Search", 11.5, 7 );
+	abort_button  = s3dw_button_new( _search_surface, "Abort", 1, 7 );
+	search_button->onclick = _search_node;
+	abort_button->onclick = _abort_search;
+
+	/* TODO calc position for ok button */
+
+	s3dw_focus	( S3DWIDGET( _search_input ) );
+	s3dw_focus	( S3DWIDGET( _search_surface ) );
+	s3dw_show	( S3DWIDGET( _search_surface ) );
+
+	/* disabled for autofollowing mode */
+	/*_search_widget	= s3dw_getroot();
+	move_search_widget( x, y, z );
+
+	_search_widget->ary = 180;
+	s3d_rotate( _search_widget->oid, _search_widget->arx, _search_widget->ary, _search_widget->arz );*/
+}
+
+/* public */
+void move_search_widget(float x, float y, float z)
+{
+	_search_widget->x = x; _search_widget->y = y; _search_widget->z = z;
+	s3dw_moveit( _search_widget );
+}
+
+/* public */
+void move_to_search_widget(float cam_position_t[], float cam_position_r[])
+{
+	float target, current;
+
+	set_search_status(WIDGET);
+	cam_position_t[0] = ( cam_position_t[0] * 4 + _search_widget->x ) / 5;
+	cam_position_t[1] = ( cam_position_t[1] * 4 + _search_widget->y ) / 5;
+	cam_position_t[2] = ( cam_position_t[2] * 4 + ( _search_widget->z - 10 ) ) / 5;
+
+	target = _search_widget->arx;
+	current = cam_position_r[0];
+
+	if( _search_widget->arx - cam_position_r[0] > 180 )
+		target -= 360;
+	if( _search_widget->arx - cam_position_r[0] < -180 )
+		current -= 360;
+	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
+
+	target = _search_widget->ary;
+	current = cam_position_r[1];
+
+	if( _search_widget->ary - cam_position_r[1] > 180 )
+		target -= 360;
+	if( _search_widget->ary - cam_position_r[1] < -180 )
+		current -= 360;
+	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
+
+	target = _search_widget->arz;
+	current = cam_position_r[2];
+
+	if( _search_widget->arz - cam_position_r[2] > 180 )
+		target -= 360;
+	if( _search_widget->arz - cam_position_r[2] < -180 )
+		current -= 360;
+	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
+
+	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
+	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
+
+	if ( sqrt(  (( cam_position_t[0] - _search_widget->x)*( cam_position_t[0] - _search_widget->x)) +
+				(( cam_position_t[1] - _search_widget->y)*( cam_position_t[1] - _search_widget->y)) +
+				(( cam_position_t[2] - _search_widget->z)*( cam_position_t[2] - _search_widget->z)) ) < 0.2 )
+	{
+		s3d_translate( 0, _search_widget->x, _search_widget->y, ( _search_widget->z - 10 ) );
+		s3d_rotate( 0, _search_widget->arx, _search_widget->ary, _search_widget->arz );
+	}
+}
+
+/* public */
+void move_to_return_point(float cam_position_t[], float cam_position_r[])
+{
+	float target, current;
+
+	cam_position_t[0] = ( cam_position_t[0] * 4 + _return_point[0][0] ) / 5;
+	cam_position_t[1] = ( cam_position_t[1] * 4 + _return_point[0][1] ) / 5;
+	cam_position_t[2] = ( cam_position_t[2] * 4 + _return_point[0][2] ) / 5;
+
+	target = _return_point[1][0];
+	current = cam_position_r[0];
+
+	if( _return_point[1][0] - cam_position_r[0] > 180 )
+		target -= 360;
+	if( _return_point[1][0] - cam_position_r[0] < -180 )
+		current -= 360;
+	cam_position_r[0] = ( cam_position_r[0] * 4 + target ) / 5;
+
+	target = _return_point[1][1];
+	current = cam_position_r[1];
+
+	if( _return_point[1][1] - cam_position_r[1] > 180 )
+		target -= 360;
+	if( _return_point[1][1] - cam_position_r[1] < -180 )
+		current -= 360;
+	cam_position_r[1] = ( cam_position_r[1] * 4 + target ) / 5;
+
+	target = _return_point[1][2];
+	current = cam_position_r[2];
+
+	if( _return_point[1][2] - cam_position_r[2] > 180 )
+		target -= 360;
+	if( _return_point[1][2] - cam_position_r[2] < -180 )
+		current -= 360;
+	cam_position_r[2] = ( cam_position_r[2] * 4 + target ) / 5;
+
+	s3d_translate(0,cam_position_t[0],cam_position_t[1],cam_position_t[2]);
+	s3d_rotate(0,cam_position_r[0],cam_position_r[1],cam_position_r[2]);
+
+	if ( sqrt(  (( cam_position_t[0] - _return_point[0][0])*( cam_position_t[0] - _return_point[0][0])) +
+				(( cam_position_t[1] - _return_point[0][1])*( cam_position_t[1] - _return_point[0][1])) +
+				(( cam_position_t[2] - _return_point[0][2])*( cam_position_t[2] - _return_point[0][2])) ) < 0.2 )
+	{
+		s3d_translate( 0, _return_point[0][0], _return_point[0][1], _return_point[0][2] );
+		s3d_rotate( 0, _return_point[1][0], _return_point[1][1], _return_point[1][2] );
+		set_search_status(NOTHING);
+	}
+}
+
+/* public */
+/* TODO: WTF?!
+ * please fix:
+ *  - s is not initialized but still strlen() is used?!
+ *  - s will vanish after the function is processed. global variable would be better
+ *  - don't forget the terminating \0 after writing a key */
+void search_widget_write(int key)
+{
+	static char s[20];
+	int ln = strlen(s);
+
+	if( key == S3DK_COMMA ) key = S3DK_PERIOD;
+
+	if( key != S3DK_RETURN )
+	{
+		if( key == S3DK_BACKSPACE )
+		{
+			if( ln > 0 )
+				s[ln-1] = '\0';
+		} else {
+			if( ln < 20 )
+				s[ln] = key;
+		}
+		s3dw_input_change_text( _search_input, s );
+	} else {
+		_new_search_node( _search_widget );
+	}
+}
+
+/* public */
+void set_return_point(float cam_position_t[], float cam_position_r[])
+{
+	int i;
+	for( i = 0; i < 3; i++ )
+		_return_point[0][i] = cam_position_t[i];
+	for( i = 0; i < 3; i++ )
+		_return_point[1][i] = cam_position_r[i];
+}
+
+/* public */
+int get_search_status(void)
+{
+	return _search_status;
+}
+
+/* public */
+void set_search_status(int stat)
+{
+	/* TODO check if stat between 0-3 else debug printf */
+	_search_status = stat;
+}
+
+/* public */
+void set_node_root(struct olsr_node *root)
+{
+	_node_root = root;
+}
+/* private */
+void _new_search_node(s3dw_widget *dummy)
+{
+	char *ip;
+	int result;
+
+	search_node = &_node_root;
+
+	ip = s3dw_input_gettext( _search_input );
+
+	while ( (*search_node) != NULL )
+	{
+
+		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
+
+		if ( result == 0 )
+			break;
+
+		if ( result < 0 )
+			(*search_node) = (*search_node)->right;
+		else
+			(*search_node) = (*search_node)->left;
+	}
+	s3dw_delete(dummy->parent); /* remove the window cointaining the button */
+	_search_surface=NULL;
+	_search_input=NULL;
+	_search_widget=NULL;
+
+
+	if( (*search_node) != NULL )
+	{
+		set_search_status( FOLLOW );
+	}
+	else
+	{
+		window_error("Sorry, could not find...");
+		set_search_status( NOTHING );
+	}
+}
+/* public */
+void follow_node_by_click(struct olsr_node *olsr_node) {
+	search_node = &_node_root;
+	(*search_node) = olsr_node;
+	set_search_status( FOLLOW );
+}
+
+/* private */
+void _search_node(s3dw_widget *dummy)
+{
+	char *ip;
+	int result;
+
+	search_node = &_node_root;
+
+	ip = s3dw_input_gettext( _search_input );
+
+	while ( (*search_node) != NULL )
+	{
+
+		result = strncmp( (*search_node)->ip, ip, NAMEMAX );
+
+		if ( result == 0 )
+			break;
+
+		if ( result < 0 )
+			(*search_node) = (*search_node)->right;
+		else
+			(*search_node) = (*search_node)->left;
+	}
+
+	if( (*search_node) != NULL )
+		set_search_status( FOLLOW );
+}
+
+/* private */
+void _abort_search(s3dw_widget *dummy)
+{
+	set_search_status(ABORT);
+}

Added: trunk/apps/s3dosm/search.h
===================================================================
--- trunk/apps/s3dosm/search.h	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/search.h	2006-12-23 23:09:05 UTC (rev 551)
@@ -0,0 +1,41 @@
+/*
+ * search.h
+ *
+ * Copyright (C) 2006 Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of the olsrs3d, an olsr topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#define NOTHING 0		/* nothing ;) */
+#define ABORT 1			/* widget has no focus */
+#define WIDGET 2		/* focus on widget */
+#define FOLLOW 3		/* follow search result */
+
+void create_search_widget(float x, float y, float z);
+void move_search_widget(float x, float y, float z);
+void move_to_search_widget(float cam_position_t[], float cam_position_r[]);
+void move_to_return_point(float cam_position_t[], float cam_position_r[]);
+void set_return_point(float cam_position_t[], float cam_position_r[]);
+int get_search_status(void);
+void set_search_status(int stat);
+void search_widget_write(int key);
+void set_node_root(struct olsr_node *root);
+void follow_node(float cam_position_t[], float cam_position_r[],float rotate);
+void follow_node_by_click(struct olsr_node *olsr_node);
+
+void show_search_window();

Added: trunk/apps/s3dosm/structs.h
===================================================================
--- trunk/apps/s3dosm/structs.h	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/structs.h	2006-12-23 23:09:05 UTC (rev 551)
@@ -0,0 +1,82 @@
+/*
+ * structs.h
+ *
+ * Copyright (C) 2004-2006 Simon Wunderlich <dotslash at packetmixer.de>
+ *                         Marek Lindner <lindner_marek at yahoo.de>
+ *                         Andreas Langer <andreas_lbg at gmx.de>
+ *
+ * This file is part of olsrs3d, an olsr topology visualizer for s3d.
+ * See http://s3d.berlios.de/ for more updates.
+ *
+ * olsrs3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * olsrs3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with olsrs3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#define NAMEMAX		128
+#define MAXLINESIZE 1000		/* lines in a digraph just shouldn't get that longer ... */
+#define MAXDATASIZE 100			/* max number of bytes we can get at once  */
+
+/* linked list for the all connections */
+struct olsr_con 
+{
+	struct olsr_con *next_olsr_con;			/* pointer to next connection */
+	struct olsr_con *prev_olsr_con;			/* pointer to previous connection */
+	struct olsr_node *left_olsr_node;		/* pointer to left end point of the connection */
+	struct olsr_node *right_olsr_node;		/* pointer to right end point of the connection */
+	float left_etx;							/* etx of left olsr node */
+	float right_etx;						/* etx of right olsr node */
+	float left_etx_sqrt;					/* sqrt of etx of left olsr node */
+	float right_etx_sqrt;					/* sqrt etx of right olsr node */
+	int obj_id;								/* id of connection object in s3d */
+	int color;
+	float rgb;
+};
+
+
+/* linked list for the neighbours of each olsr node */
+struct olsr_neigh_list
+{
+	struct olsr_neigh_list *next_olsr_neigh_list;		/* pointer to next neighbour */
+	struct olsr_con *olsr_con;							/* pointer to the connection */
+};
+
+
+/* we contruct a binary tree to handle the nodes */
+struct olsr_node 
+{
+	struct olsr_node *left;
+	struct olsr_node *right;
+	char ip[NAMEMAX];				/* host ip */
+	int static_node;				/* static nodes have some known geolocation and won't move */
+	int node_type;					/* normal = 0, internet gateway = 1, via hna announced network = 2 */
+	int node_type_modified;			/* node_type modified flag */
+	int last_seen;					/* last seen counter */
+	int visible;					/* is this node visible or vanished */
+	float pos_vec[3];				/* position vector in 3d "space" */
+	float mov_vec[3];				/* move vector */
+	int obj_id;						/* id of node object in s3d */
+	int desc_id;					/* id of node description object in s3d */
+	float desc_length;				/* length of node description object in s3d */
+	struct olsr_neigh_list *olsr_neigh_list;	/* pointer to first neighbour */
+};
+
+
+struct Obj_to_ip
+{
+	int id;
+	struct olsr_node *olsr_node;
+	struct Obj_to_ip *next;
+	struct Obj_to_ip *prev;
+};
+

Modified: trunk/apps/s3dosm/ui.c
===================================================================
--- trunk/apps/s3dosm/ui.c	2006-12-23 22:07:12 UTC (rev 550)
+++ trunk/apps/s3dosm/ui.c	2006-12-23 23:09:05 UTC (rev 551)
@@ -107,33 +107,30 @@
 {
 	int oid=(int)*((uint32_t *)evt->buf);
 	char query[MAXQ];
-	if (s3dw_handle_click(evt)) {
-		printf("s3dw got it?!\n");
-	} else {
-		
-		snprintf(query,MAXQ,"SELECT * FROM node WHERE s3doid=%d;",oid);
-		db_exec(query, ui_getinfo_node, 0);
-		snprintf(query,MAXQ,"SELECT * FROM way WHERE s3doid=%d;",oid);
-		db_exec(query, ui_getinfo_way, 0);
+	if (s3dw_handle_click(evt)) return(0);
+	if (olsr_object_click(evt)) return(0);
+	snprintf(query,MAXQ,"SELECT * FROM node WHERE s3doid=%d;",oid);
+	db_exec(query, ui_getinfo_node, 0);
+	snprintf(query,MAXQ,"SELECT * FROM way WHERE s3doid=%d;",oid);
+	db_exec(query, ui_getinfo_way, 0);
 
-	}
-
 	return(0);
 }
 int ui_key(struct s3d_evt *evt)
 {
 /*	struct s3d_key_event *key=(struct s3d_key_event *)evt->buf;*/
-	s3dw_handle_key(evt);
+	if (s3dw_handle_key(evt)) return(0);
+	if (olsr_keypress(evt)) return(0);
 	return(0);
 }
 int ui_oinfo(struct s3d_evt *evt)
 {
 	s3dw_object_info(evt);	
+	olsr_object_info(evt);
 	return(0);
 }
 int ui_init()
 {
-	printf("ui_init() ...\n");
 	ui_loadicons();
 	s3d_set_callback(S3D_EVENT_OBJ_CLICK,ui_click);
 	s3d_set_callback(S3D_EVENT_KEY,ui_key);



From dotslash at mail.berlios.de  Sun Dec 24 00:36:57 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 24 Dec 2006 00:36:57 +0100
Subject: [S3d-svn] r552 - in trunk: . apps/s3dosm libs3d
Message-ID: <200612232336.kBNNavDh011862@sheep.berlios.de>

Author: dotslash
Date: 2006-12-24 00:36:51 +0100 (Sun, 24 Dec 2006)
New Revision: 552

Modified:
   trunk/
   trunk/apps/s3dosm/io.c
   trunk/apps/s3dosm/process.c
   trunk/libs3d/io.c
Log:
 r1331 at kero:  dotslash | 2006-12-24 00:36:47 +0100
 - initialize optind=0 so we can call getopt_long() multiple times



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1329
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1331

Modified: trunk/apps/s3dosm/io.c
===================================================================
--- trunk/apps/s3dosm/io.c	2006-12-23 23:09:05 UTC (rev 551)
+++ trunk/apps/s3dosm/io.c	2006-12-23 23:36:51 UTC (rev 552)
@@ -60,6 +60,7 @@
 		{"osm",1,0,'o'},
 		{0,0,0,0}
 	};
+	optind=0;
 	while (-1!=(c=getopt_long(argc,argv,"?ho",long_options,&lopt_idx)))
 	{
 		switch (c)
@@ -89,6 +90,7 @@
 	}
 	for (i=1;i<argc;i++)
 	{
+		printf("argument %d: %s\n",i,argv[i]);
 		if (strstr(argv[i],".osm")-argv[i]==strlen(argv[i])-4) {
 			snprintf(info,1024,"loading OSM-File: %s",argv[i]);
 			load_window(info);

Modified: trunk/apps/s3dosm/process.c
===================================================================
--- trunk/apps/s3dosm/process.c	2006-12-23 23:09:05 UTC (rev 551)
+++ trunk/apps/s3dosm/process.c	2006-12-23 23:36:51 UTC (rev 552)
@@ -233,6 +233,10 @@
 		if (db_olsr_check((*olsr_node)->ip,(*olsr_node)->pos_vec)) {
 			/* pos_vec will be overwritten if there is a database hit */
 			(*olsr_node)->static_node=1;
+			/* little elevation over the earth */
+			(*olsr_node)->pos_vec[0] *= (ESIZE + 5) / ESIZE;
+			(*olsr_node)->pos_vec[1] *= (ESIZE + 5) / ESIZE;
+			(*olsr_node)->pos_vec[2] *= (ESIZE + 5) / ESIZE;
 		} 
 
 

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2006-12-23 23:09:05 UTC (rev 551)
+++ trunk/libs3d/io.c	2006-12-23 23:36:51 UTC (rev 552)
@@ -76,6 +76,7 @@
 		{0,0,0,0}
 	};
 	if ((argc==NULL) || (argv==NULL)) return(0); /* nothing to parse */
+	optind=0;
 	while (-1!=(c=getopt_long(*argc,*argv,"?h",long_options,&lopt_idx)))
 	{
 		switch (c)
@@ -97,6 +98,7 @@
 			return(-1);
 		}
 	}
+	optind=0;
 	if (*argc>0)
 	{
 		*argc-=(optind-1); 				 /*  hide s3d-options */



From dotslash at mail.berlios.de  Sun Dec 24 00:52:38 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 24 Dec 2006 00:52:38 +0100
Subject: [S3d-svn] r553 - in trunk: . apps/s3dosm
Message-ID: <200612232352.kBNNqcHZ003643@sheep.berlios.de>

Author: dotslash
Date: 2006-12-24 00:52:30 +0100 (Sun, 24 Dec 2006)
New Revision: 553

Modified:
   trunk/
   trunk/apps/s3dosm/db.c
   trunk/apps/s3dosm/process.c
Log:
 r1333 at kero:  dotslash | 2006-12-24 00:52:25 +0100
 - add some elevation to the nodes (dirty hack)



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1331
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1333

Modified: trunk/apps/s3dosm/db.c
===================================================================
--- trunk/apps/s3dosm/db.c	2006-12-23 23:36:51 UTC (rev 552)
+++ trunk/apps/s3dosm/db.c	2006-12-23 23:52:30 UTC (rev 553)
@@ -122,6 +122,7 @@
 	}
 	return(layerid);
 }
+#define MAGIC	1337 /* just to elevate the nodes a little bit */
 static int found=0;
 /* tries to find node coordinates of ip, returns 1 if has found something */
 int db_olsr_check(char *ip, float *pos) {
@@ -134,17 +135,21 @@
 		*s=0; /* TERMINATING ZERO!! */
 	
 	snprintf(findquery, MAXQ, "SELECT latitude, longitude, altitude FROM node WHERE tag_id=(SELECT tag_id FROM tag WHERE tagkey='ip' AND tagvalue='%s');", clean_ip);
-	found=0;
+	found=MAGIC;
    	db_exec(findquery, db_getpoint, p);
-	if (found) { 
+	if (found==1) { 
 		pos[0]=p[0];
 		pos[1]=p[1];
 		pos[2]=p[2];
+		found=0;
+		return(1);
 	}
-	return(found);	
+	found=0;
+	return(0);	
 }
 /* initializes the starting point of nodes  by averaging its lon/lat */
 int db_olsr_node_init(float *pos) {
+	found=0;
    	db_exec("SELECT AVG(latitude) as latitude, AVG(longitude) as longitude, AVG(altitude) as altitude FROM node WHERE tag_id IN (SELECT tag_id FROM tag WHERE tagkey='ip');", db_getpoint, pos);
 	printf("pos = %3.3f %3.3f %3.3f\n",pos[0],pos[1],pos[2]);
 	return(0);	/* return 1 if something is found, 0 if pos[0] its still 0 */
@@ -166,6 +171,7 @@
 	}
 	if (lo==0.0)	{	printf("missing lo\n");	exit(0);	}
 	if (la==0.0)	{	printf("missing la\n");	exit(0); 	}
+	if (found==MAGIC) alt=2;
 	calc_earth_to_eukl(la,lo,alt,p);
 	p[3]=la;
 	p[4]=lo;

Modified: trunk/apps/s3dosm/process.c
===================================================================
--- trunk/apps/s3dosm/process.c	2006-12-23 23:36:51 UTC (rev 552)
+++ trunk/apps/s3dosm/process.c	2006-12-23 23:52:30 UTC (rev 553)
@@ -234,9 +234,6 @@
 			/* pos_vec will be overwritten if there is a database hit */
 			(*olsr_node)->static_node=1;
 			/* little elevation over the earth */
-			(*olsr_node)->pos_vec[0] *= (ESIZE + 5) / ESIZE;
-			(*olsr_node)->pos_vec[1] *= (ESIZE + 5) / ESIZE;
-			(*olsr_node)->pos_vec[2] *= (ESIZE + 5) / ESIZE;
 		} 
 
 



From dotslash at mail.berlios.de  Sun Dec 24 11:54:15 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Sun, 24 Dec 2006 11:54:15 +0100
Subject: [S3d-svn] r554 - in trunk: . server
Message-ID: <200612241054.kBOAsFtW005934@sheep.berlios.de>

Author: dotslash
Date: 2006-12-24 11:54:15 +0100 (Sun, 24 Dec 2006)
New Revision: 554

Added:
   trunk/server/allocate.c
Modified:
   trunk/
   trunk/server/Makefile.am
   trunk/server/global.h
   trunk/server/object.c
Log:
 r1337 at kero:  dotslash | 2006-12-24 11:54:09 +0100
 - add allocate.c to find heap corruptions (thanks marek)
 - don't use GL_COMPILE_AND_EXECUTE, first GL_COMPILE, then glCallList()



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1333
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:1337

Modified: trunk/server/Makefile.am
===================================================================
--- trunk/server/Makefile.am	2006-12-23 23:52:30 UTC (rev 553)
+++ trunk/server/Makefile.am	2006-12-24 10:54:15 UTC (rev 554)
@@ -16,7 +16,8 @@
 	$(MAYBE_GLUT) $(MAYBE_SDL) \
 	main.c matrix.c mcp.c navigation.c \
 	network.c object.c process.c proto.c \
-	shm.c shm_ringbuf.c tcp.c user.c
+	shm.c shm_ringbuf.c tcp.c user.c \
+	allocate.c
 
 s3d_LDADD=	@LIBM@ @GL_LIBS@ ${MAYBE_SDL_LIBS} ${MAYBE_GLUT_LIBS}
 s3d_CFLAGS=	@GL_CFLAGS@ ${MAYBE_SDL_CFLAGS} ${MAYBE_GLUT_CFLAGS} ${DEVEL_CFLAGS} 

Added: trunk/server/allocate.c
===================================================================
--- trunk/server/allocate.c	2006-12-23 23:52:30 UTC (rev 553)
+++ trunk/server/allocate.c	2006-12-24 10:54:15 UTC (rev 554)
@@ -0,0 +1,262 @@
+/*
+ * allocate.c
+ *
+ * Copyright (C) 2006 	Marek Lindner <lindner_marek at yahoo.de>
+ * 						Simon Wunderlich <dotslash at packetmixer.de>
+ * 						(probably more people from the batman project)
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/* this file is taken from the batman project (www.open-mesh.net/batman)
+ * to find heap corruptions... */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "allocate.h"
+
+#define DEBUG_MALLOC
+
+#define MAGIC_NUMBER 0x12345678
+
+#if defined DEBUG_MALLOC
+
+struct chunkHeader *chunkList = NULL;
+
+struct chunkHeader
+{
+	struct chunkHeader *next;
+	unsigned int length;
+	int tag;
+	unsigned int magicNumber;
+};
+
+struct chunkTrailer
+{
+	unsigned int magicNumber;
+};
+
+void checkIntegrity(void)
+{
+	struct chunkHeader *walker;
+	struct chunkTrailer *chunkTrailer;
+	unsigned char *memory;
+
+	for (walker = chunkList; walker != NULL; walker = walker->next)
+	{
+		if (walker->magicNumber != MAGIC_NUMBER)
+		{
+			fprintf(stderr, "Invalid magic number in header: %08x, tag = %d\n", walker->magicNumber, walker->tag);
+			exit(1);
+		}
+
+		memory = (unsigned char *)walker;
+
+		chunkTrailer = (struct chunkTrailer *)(memory + sizeof(struct chunkHeader) + walker->length);
+
+		if (chunkTrailer->magicNumber != MAGIC_NUMBER)
+		{
+			fprintf(stderr, "Invalid magic number in header: %08x, tag = %d\n", chunkTrailer->magicNumber, walker->tag);
+			exit(1);
+		}
+	}
+}
+
+void checkLeak(void)
+{
+	struct chunkHeader *walker;
+
+	for (walker = chunkList; walker != NULL; walker = walker->next)
+		fprintf(stderr, "Memory leak detected, tag = %d\n", walker->tag);
+}
+
+void *debugMalloc(unsigned int length, int tag)
+{
+	unsigned char *memory;
+	struct chunkHeader *chunkHeader;
+	struct chunkTrailer *chunkTrailer;
+	unsigned char *chunk;
+
+// 	printf("sizeof(struct chunkHeader) = %u, sizeof (struct chunkTrailer) = %u\n", sizeof (struct chunkHeader), sizeof (struct chunkTrailer));
+
+	memory = malloc(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer));
+
+	if (memory == NULL)
+	{
+		fprintf(stderr, "Cannot allocate %u bytes, tag = %d\n", (unsigned int)(length + sizeof(struct chunkHeader) + sizeof(struct chunkTrailer)), tag);
+		exit(1);
+	}
+
+	chunkHeader = (struct chunkHeader *)memory;
+	chunk = memory + sizeof(struct chunkHeader);
+	chunkTrailer = (struct chunkTrailer *)(memory + sizeof(struct chunkHeader) + length);
+
+	chunkHeader->length = length;
+	chunkHeader->tag = tag;
+	chunkHeader->magicNumber = MAGIC_NUMBER;
+
+	chunkTrailer->magicNumber = MAGIC_NUMBER;
+
+	chunkHeader->next = chunkList;
+	chunkList = chunkHeader;
+
+	return chunk;
+}
+
+void *debugRealloc(void *memoryParameter, unsigned int length, int tag)
+{
+	unsigned char *memory;
+	struct chunkHeader *chunkHeader;
+	struct chunkTrailer *chunkTrailer;
+	unsigned char *result;
+	unsigned int copyLength;
+
+	if (memoryParameter) { /* if memoryParameter==NULL, realloc() should work like malloc() !! */
+		memory = memoryParameter;
+		chunkHeader = (struct chunkHeader *)(memory - sizeof(struct chunkHeader));
+	
+		if (chunkHeader->magicNumber != MAGIC_NUMBER)
+		{
+			fprintf(stderr, "Invalid magic number in header: %08x, tag = %d\n", chunkHeader->magicNumber, chunkHeader->tag);
+			exit(1);
+		}
+	
+		chunkTrailer = (struct chunkTrailer *)(memory + chunkHeader->length);
+	
+		if (chunkTrailer->magicNumber != MAGIC_NUMBER)
+		{
+			fprintf(stderr, "Invalid magic number in header: %08x, tag = %d\n", chunkTrailer->magicNumber, chunkHeader->tag);
+			exit(1);
+		}
+	}
+	
+
+	result = debugMalloc(length, tag);
+	if (memoryParameter) {
+		copyLength = length;
+
+		if (copyLength > chunkHeader->length)
+			copyLength = chunkHeader->length;
+	
+		memcpy(result, memoryParameter, copyLength);
+		debugFree(memoryParameter);
+	}
+
+
+	return result;
+}
+
+void debugFree(void *memoryParameter)
+{
+	unsigned char *memory;
+	struct chunkHeader *chunkHeader;
+	struct chunkTrailer *chunkTrailer;
+	struct chunkHeader *walker;
+	struct chunkHeader *previous;
+
+	memory = memoryParameter;
+	chunkHeader = (struct chunkHeader *)(memory - sizeof(struct chunkHeader));
+
+	if (chunkHeader->magicNumber != MAGIC_NUMBER)
+	{
+		fprintf(stderr, "Invalid magic number in header: %08x, tag = %d\n", chunkHeader->magicNumber, chunkHeader->tag);
+		exit(1);
+	}
+
+	previous = NULL;
+
+	for (walker = chunkList; walker != NULL; walker = walker->next)
+	{
+		if (walker == chunkHeader)
+			break;
+
+		previous = walker;
+	}
+
+	if (walker == NULL)
+	{
+		fprintf(stderr, "Double free detected, tag = %d\n", chunkHeader->tag);
+		exit(1);
+	}
+
+	if (previous == NULL)
+		chunkList = walker->next;
+
+	else
+		previous->next = walker->next;
+
+	chunkTrailer = (struct chunkTrailer *)(memory + chunkHeader->length);
+
+	if (chunkTrailer->magicNumber != MAGIC_NUMBER)
+	{
+		fprintf(stderr, "Invalid magic number in header: %08x, tag = %d\n", chunkTrailer->magicNumber, chunkHeader->tag);
+		exit(1);
+	}
+
+	free(chunkHeader);
+}
+
+#else
+
+void checkIntegrity(void)
+{
+}
+
+void checkLeak(void)
+{
+}
+
+void *debugMalloc(unsigned int length, int tag)
+{
+	void *result;
+
+	result = malloc(length);
+
+	if (result == NULL)
+	{
+		fprintf(stderr, "Cannot allocate %u bytes, tag = %d\n", length, tag);
+		exit(1);
+	}
+
+	return result;
+}
+
+void *debugRealloc(void *memory, unsigned int length, int tag)
+{
+	void *result;
+
+	result = realloc(memory, length);
+
+	if (result == NULL)
+	{
+		fprintf(stderr, "Cannot re-allocate %u bytes, tag = %d\n", length, tag);
+		exit(1);
+	}
+
+	return result;
+}
+
+void debugFree(void *memory)
+{
+	free(memory);
+}
+
+#endif

Modified: trunk/server/global.h
===================================================================
--- trunk/server/global.h	2006-12-23 23:52:30 UTC (rev 553)
+++ trunk/server/global.h	2006-12-24 10:54:15 UTC (rev 554)
@@ -373,3 +373,16 @@
 /* cull.c */
 void cull_get_planes(void);
 int  cull_sphere_in_frustum(struct t_vertex *center, float radius);
+
+/* allocate.c */
+#if DEBUG <= VLOW
+#include <stdlib.h>
+void checkIntegrity(void);
+void checkLeak(void);
+void *debugMalloc(unsigned int length, int tag);
+void *debugRealloc(void *memory, unsigned int length, int tag);
+void debugFree(void *memoryParameter);
+#define malloc(x)		debugMalloc(x,42)
+#define free(x)			debugFree(x);
+#define realloc(x,y)	debugRealloc(x,y,42)
+#endif

Modified: trunk/server/object.c
===================================================================
--- trunk/server/object.c	2006-12-23 23:52:30 UTC (rev 553)
+++ trunk/server/object.c	2006-12-24 10:54:15 UTC (rev 554)
@@ -1689,10 +1689,9 @@
 /*	into_position(p,obj,0);*/
 	if (obj->oflags&OF_SYSTEM)		return(-1); 					/* can't render system objects */
 	if (obj->oflags&OF_CLONE)		obj=p->object[obj->n_vertex]; 	/* it's a clone - draw the clone! */
-	if (obj->dplist)				glCallList(obj->dplist);		/* we have done that before, call the GLList */
-	else {
+	if (!obj->dplist) {
 		obj->dplist=glGenLists(1);
-		if (obj->dplist)	glNewList(obj->dplist,GL_COMPILE_AND_EXECUTE);
+		if (obj->dplist)	glNewList(obj->dplist,GL_COMPILE); /* only compile and calling later should save time. maybe. */
 		 else 				s3dprintf(LOW,"couldn't get a new list :/");
 		omat=-1;
 		for (pn=0; pn<obj->n_poly; pn++)  /*  cycle throu our polygons ... */
@@ -1817,6 +1816,8 @@
 		}
 		if (obj->dplist) glEndList();
 	}
+	if (obj->dplist)
+		glCallList(obj->dplist);		/* call the just compiled ore old display list */
 	glPopMatrix();
 	return(0);
 }



From lazhur at mail.berlios.de  Sun Dec 24 11:59:10 2006
From: lazhur at mail.berlios.de (lazhur at BerliOS)
Date: Sun, 24 Dec 2006 11:59:10 +0100
Subject: [S3d-svn] r555 - trunk/extras/distro/gentoo/media-libs/libg3d
Message-ID: <200612241059.kBOAxA7e006338@sheep.berlios.de>

Author: lazhur
Date: 2006-12-24 11:59:10 +0100 (Sun, 24 Dec 2006)
New Revision: 555

Modified:
   trunk/extras/distro/gentoo/media-libs/libg3d/ChangeLog
   trunk/extras/distro/gentoo/media-libs/libg3d/Manifest
   trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.ebuild
Log:
- Mark amd64 as stable in libg3d-0.0.6.ebuild


Modified: trunk/extras/distro/gentoo/media-libs/libg3d/ChangeLog
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/ChangeLog	2006-12-24 10:54:15 UTC (rev 554)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/ChangeLog	2006-12-24 10:59:10 UTC (rev 555)
@@ -1,8 +1,11 @@
 # ChangeLog for media-gfx/libg3d
 
+  23 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> libg3d-0.0.6.ebuild:
+  Mark amd64 as stable.
+
 *libg3d-0.0.6 (23 Dec 2006)
 
-  23 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> +libg3d-0.0.6.20061222.ebuild,
+  23 Dec 2006; Sven Eckelmann <sven.eckelmann at gmx.de> +libg3d-0.0.6.ebuild,
   -files/libg3d-0.0.6.20061222-missingflexheaders.patch.bz2,
   -libg3d-0.0.6.20061222.ebuild:
   Version bump. Remove old snapshot.

Modified: trunk/extras/distro/gentoo/media-libs/libg3d/Manifest
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/Manifest	2006-12-24 10:54:15 UTC (rev 554)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/Manifest	2006-12-24 10:59:10 UTC (rev 555)
@@ -9,14 +9,14 @@
 MD5 2180cc92be1d9ac65d14cf2fa5ceec3f libg3d-0.0.5.ebuild 667
 RMD160 65e4eba6ff273b66cf8b6ff16693f38d4e8fa5cb libg3d-0.0.5.ebuild 667
 SHA256 fecae46969199e5d852fa308c1eafcbfcc9fb9f846a2311367afde8a25752af6 libg3d-0.0.5.ebuild 667
-EBUILD libg3d-0.0.6.ebuild 667 RMD160 65e4eba6ff273b66cf8b6ff16693f38d4e8fa5cb SHA1 adcd841e8c3afbac819eed804b62399cd4c4c7c9 SHA256 fecae46969199e5d852fa308c1eafcbfcc9fb9f846a2311367afde8a25752af6
-MD5 2180cc92be1d9ac65d14cf2fa5ceec3f libg3d-0.0.6.ebuild 667
-RMD160 65e4eba6ff273b66cf8b6ff16693f38d4e8fa5cb libg3d-0.0.6.ebuild 667
-SHA256 fecae46969199e5d852fa308c1eafcbfcc9fb9f846a2311367afde8a25752af6 libg3d-0.0.6.ebuild 667
-MISC ChangeLog 744 RMD160 cfa9459a21e921763694e6fafcc32b552e3de710 SHA1 7cd2f792b79be900a2f0d35af03cd8f1010b0f0c SHA256 fa40f1e610c0854461c3c6dfbb6886b228ee918a373594c4af84de49ed30ee51
-MD5 a418c82829d8fc37c1cc0d6860a63c0b ChangeLog 744
-RMD160 cfa9459a21e921763694e6fafcc32b552e3de710 ChangeLog 744
-SHA256 fa40f1e610c0854461c3c6dfbb6886b228ee918a373594c4af84de49ed30ee51 ChangeLog 744
+EBUILD libg3d-0.0.6.ebuild 673 RMD160 7b7cd299dd52e2d1bc144cda1f291002a10a4444 SHA1 0e54709b17c807bbd32242331e080278a60daa01 SHA256 52329c3fa783661ffbd41d846a58208e8cf935eec116633ad497445506172b7c
+MD5 308bc3d4836f9ae1fef1ec26b2810310 libg3d-0.0.6.ebuild 673
+RMD160 7b7cd299dd52e2d1bc144cda1f291002a10a4444 libg3d-0.0.6.ebuild 673
+SHA256 52329c3fa783661ffbd41d846a58208e8cf935eec116633ad497445506172b7c libg3d-0.0.6.ebuild 673
+MISC ChangeLog 835 RMD160 17388ce0404ccfa8c24aba354c84ea80e3f7e741 SHA1 793fc91993282fe848cda93290aa30f89bfd53cc SHA256 ab9068b8c43c89667261596ad3cbab278ddcbb6ad72d8bc07af47b55a3180f34
+MD5 0b4ef44260884042fdb448c4a4616a38 ChangeLog 835
+RMD160 17388ce0404ccfa8c24aba354c84ea80e3f7e741 ChangeLog 835
+SHA256 ab9068b8c43c89667261596ad3cbab278ddcbb6ad72d8bc07af47b55a3180f34 ChangeLog 835
 MISC metadata.xml 239 RMD160 236f28d8249f562b764e2d854580d8301b150418 SHA1 76f167e3abff81e9535c16a637fd1e7f91d4fda3 SHA256 c0f08f1f0c1ce07df414cd87bf028a15cae639c89b2d636714d50d8aa77c370f
 MD5 261031c8b7aca6f50babf7e44b35deb1 metadata.xml 239
 RMD160 236f28d8249f562b764e2d854580d8301b150418 metadata.xml 239

Modified: trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.ebuild
===================================================================
--- trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.ebuild	2006-12-24 10:54:15 UTC (rev 554)
+++ trunk/extras/distro/gentoo/media-libs/libg3d/libg3d-0.0.6.ebuild	2006-12-24 10:59:10 UTC (rev 555)
@@ -6,7 +6,7 @@
 HOMEPAGE="https://gna.org/projects/libg3d/"
 
 LICENSE="GPL-2 LGPL"
-KEYWORDS="x86"
+KEYWORDS="x86 amd64"
 SLOT="0"
 
 DEPEND="${RDEPEND}



From dotslash at mail.berlios.de  Tue Dec 26 00:02:27 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 26 Dec 2006 00:02:27 +0100
Subject: [S3d-svn] r556 - trunk/apps/s3dosm
Message-ID: <200612252302.kBPN2RXI017303@sheep.berlios.de>

Author: dotslash
Date: 2006-12-26 00:02:26 +0100 (Tue, 26 Dec 2006)
New Revision: 556

Modified:
   trunk/apps/s3dosm/olsrs3d.c
Log:
- first try to connect to olsr-net, then initialize. s3dosm is supposed to work without olsr-connection

Modified: trunk/apps/s3dosm/olsrs3d.c
===================================================================
--- trunk/apps/s3dosm/olsrs3d.c	2006-12-24 10:59:10 UTC (rev 555)
+++ trunk/apps/s3dosm/olsrs3d.c	2006-12-25 23:02:26 UTC (rev 556)
@@ -1086,6 +1086,7 @@
 	if ( Debug )
 		printf( "debug mode enabled ...\n" );
 
+	if (net_init(Olsr_host)) return(1);
 	/* initialize obj2ip linked list */
 	lst_initialize();
 
@@ -1110,7 +1111,6 @@
 	s3d_link(ZeroPoint, oidy);
 
 	/* create_search_widget( 0, 0, 300 ); */
-	if (net_init(Olsr_host)) return(1);
 	olsr_ready=1;
 	return(0);
 



From dotslash at mail.berlios.de  Tue Dec 26 20:56:05 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 26 Dec 2006 20:56:05 +0100
Subject: [S3d-svn] r557 - trunk/server
Message-ID: <200612261956.kBQJu5pm016471@sheep.berlios.de>

Author: dotslash
Date: 2006-12-26 20:56:05 +0100 (Tue, 26 Dec 2006)
New Revision: 557

Added:
   trunk/server/allocate.h
Log:
- forgot to add allocate.h - sorry

Added: trunk/server/allocate.h
===================================================================
--- trunk/server/allocate.h	2006-12-25 23:02:26 UTC (rev 556)
+++ trunk/server/allocate.h	2006-12-26 19:56:05 UTC (rev 557)
@@ -0,0 +1,33 @@
+/*
+ * allocate.h
+ *
+ * Copyright (C) 2006 	Marek Lindner <lindner_marek at yahoo.de>
+ * 						Simon Wunderlich <dotslash at packetmixer.de>
+ * 						(probably more people from the batman project)
+ *
+ * This file is part of s3d, a 3d network display server.
+ * See http://s3d.berlios.de/ for more updates.
+ * 
+ * s3d is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * s3d is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with s3d; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/* this file is taken from the batman project (www.open-mesh.net/batman)
+ * to find heap corruptions... */
+
+void checkIntegrity(void);
+void checkLeak(void);
+void *debugMalloc(unsigned int length, int tag);
+void *debugRealloc(void *memory, unsigned int length, int tag);
+void debugFree(void *memoryParameter);



From dotslash at mail.berlios.de  Tue Dec 26 21:12:44 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 26 Dec 2006 21:12:44 +0100
Subject: [S3d-svn] r558 - trunk/libs3dw
Message-ID: <200612262012.kBQKCirG018541@sheep.berlios.de>

Author: dotslash
Date: 2006-12-26 21:12:43 +0100 (Tue, 26 Dec 2006)
New Revision: 558

Modified:
   trunk/libs3dw/root.c
   trunk/libs3dw/s3dw_int.h
Log:
- use extern for callback typedefs - why are there no warnings on my gcc?

Modified: trunk/libs3dw/root.c
===================================================================
--- trunk/libs3dw/root.c	2006-12-26 19:56:05 UTC (rev 557)
+++ trunk/libs3dw/root.c	2006-12-26 20:12:43 UTC (rev 558)
@@ -26,6 +26,13 @@
 #include <s3dw_int.h>
 #include <stdlib.h> /* malloc() */
 #include <stdio.h>   /* printf() */
+s3dw_callback 		s3dwcb_show[S3DW_NTYPES];
+s3dw_callback 		s3dwcb_hide[S3DW_NTYPES];
+s3dw_callback 		s3dwcb_destroy[S3DW_NTYPES];
+s3dw_click_callback s3dwcb_click[S3DW_NTYPES];
+s3dw_key_callback	s3dwcb_key[S3DW_NTYPES];
+
+
 static s3dw_widget *root=NULL;
 extern s3dw_widget *_s3dw_cam;
 

Modified: trunk/libs3dw/s3dw_int.h
===================================================================
--- trunk/libs3dw/s3dw_int.h	2006-12-26 19:56:05 UTC (rev 557)
+++ trunk/libs3dw/s3dw_int.h	2006-12-26 20:12:43 UTC (rev 558)
@@ -27,11 +27,11 @@
 /* constructor and handler callbacks */
 typedef int (*s3dw_click_callback)(s3dw_widget *, uint32_t);
 typedef int (*s3dw_key_callback)(  s3dw_widget *, struct s3d_key_event *);
-s3dw_callback 		s3dwcb_show[S3DW_NTYPES];
-s3dw_callback 		s3dwcb_hide[S3DW_NTYPES];
-s3dw_callback 		s3dwcb_destroy[S3DW_NTYPES];
-s3dw_click_callback s3dwcb_click[S3DW_NTYPES];
-s3dw_key_callback	s3dwcb_key[S3DW_NTYPES];
+extern s3dw_callback 		s3dwcb_show[S3DW_NTYPES];
+extern s3dw_callback 		s3dwcb_hide[S3DW_NTYPES];
+extern s3dw_callback 		s3dwcb_destroy[S3DW_NTYPES];
+extern s3dw_click_callback s3dwcb_click[S3DW_NTYPES];
+extern s3dw_key_callback	s3dwcb_key[S3DW_NTYPES];
 
 /* root.c */
 s3dw_widget *s3dw_getroot();



From dotslash at mail.berlios.de  Tue Dec 26 21:24:45 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 26 Dec 2006 21:24:45 +0100
Subject: [S3d-svn] r559 - trunk/apps/kism3d
Message-ID: <200612262024.kBQKOjBA019456@sheep.berlios.de>

Author: dotslash
Date: 2006-12-26 21:24:45 +0100 (Tue, 26 Dec 2006)
New Revision: 559

Modified:
   trunk/apps/kism3d/kism3d.h
Log:
- include pthread.h in kism3d

Modified: trunk/apps/kism3d/kism3d.h
===================================================================
--- trunk/apps/kism3d/kism3d.h	2006-12-26 20:12:43 UTC (rev 558)
+++ trunk/apps/kism3d/kism3d.h	2006-12-26 20:24:45 UTC (rev 559)
@@ -24,6 +24,7 @@
 
 
 #include "list.h"
+#include <pthread.h>
 #include <netinet/in.h>   /* sockaddr_in */
 
 



From dotslash at mail.berlios.de  Tue Dec 26 23:48:08 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Tue, 26 Dec 2006 23:48:08 +0100
Subject: [S3d-svn] r560 - trunk
Message-ID: <200612262248.kBQMm8Ei000817@sheep.berlios.de>

Author: dotslash
Date: 2006-12-26 23:48:07 +0100 (Tue, 26 Dec 2006)
New Revision: 560

Modified:
   trunk/configure.ac
Log:
- comment out AC_OUTPUT()

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-12-26 20:24:45 UTC (rev 559)
+++ trunk/configure.ac	2006-12-26 22:48:07 UTC (rev 560)
@@ -171,8 +171,8 @@
 AC_ARG_WITH([examples], AS_HELP_STRING([--with-examples], [build examples]), [with_examples=$withval], [with_examples=yes])
 AM_CONDITIONAL([BUILD_EXAMPLES], [test x$with_examples = xyes])
 
-AC_OUTPUT(
-)
+#AC_OUTPUT(
+#)
 
 #DBG_CFLAGS=""
 #AC_SUBST(DBG_CFLAGS)



From dotslash at mail.berlios.de  Wed Dec 27 00:12:35 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 27 Dec 2006 00:12:35 +0100
Subject: [S3d-svn] r561 - trunk
Message-ID: <200612262312.kBQNCZ5A004280@sheep.berlios.de>

Author: dotslash
Date: 2006-12-27 00:12:35 +0100 (Wed, 27 Dec 2006)
New Revision: 561

Modified:
   trunk/configure.ac
Log:
- remove (comment out) MDL_HAVE_OPENGL - not properly parsed by auto* anyways

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-12-26 22:48:07 UTC (rev 560)
+++ trunk/configure.ac	2006-12-26 23:12:35 UTC (rev 561)
@@ -75,7 +75,7 @@
 AC_CHECK_LIBM
 AC_SUBST(LIBM)
 
-MDL_HAVE_OPENGL
+# MDL_HAVE_OPENGL
 AC_SEARCH_LIBS(glutInit, glut, [
 HAVE_glut="yes"
 GLUT_CFLAGS=



From dotslash at mail.berlios.de  Wed Dec 27 00:50:11 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 27 Dec 2006 00:50:11 +0100
Subject: [S3d-svn] r563 - trunk
Message-ID: <200612262350.kBQNoB8A017897@sheep.berlios.de>

Author: dotslash
Date: 2006-12-27 00:50:09 +0100 (Wed, 27 Dec 2006)
New Revision: 563

Modified:
   trunk/configure.ac
Log:
- repair it, add MDL-OpenGL again  - sorry

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-12-26 23:47:37 UTC (rev 562)
+++ trunk/configure.ac	2006-12-26 23:50:09 UTC (rev 563)
@@ -75,7 +75,7 @@
 AC_CHECK_LIBM
 AC_SUBST(LIBM)
 
-# MDL_HAVE_OPENGL
+ MDL_HAVE_OPENGL
 AC_SEARCH_LIBS(glutInit, glut, [
 HAVE_glut="yes"
 GLUT_CFLAGS=



From dotslash at mail.berlios.de  Wed Dec 27 12:31:56 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 27 Dec 2006 12:31:56 +0100
Subject: [S3d-svn] r564 - trunk/server
Message-ID: <200612271131.kBRBVup1012747@sheep.berlios.de>

Author: dotslash
Date: 2006-12-27 12:31:53 +0100 (Wed, 27 Dec 2006)
New Revision: 564

Modified:
   trunk/server/main.c
Log:
- patch for apple - need NSA* stuff

Modified: trunk/server/main.c
===================================================================
--- trunk/server/main.c	2006-12-26 23:50:09 UTC (rev 563)
+++ trunk/server/main.c	2006-12-27 11:31:53 UTC (rev 564)
@@ -147,6 +147,9 @@
 /*  this initalizes all components.  */
 int init() 
 {
+#define	__APPLE__
+	NSApplicationLoad();
+#endif
 #ifdef SIGS
 	if (!norc)
 		rc_init();



From dotslash at mail.berlios.de  Wed Dec 27 13:09:47 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 27 Dec 2006 13:09:47 +0100
Subject: [S3d-svn] r565 - trunk/libs3d
Message-ID: <200612271209.kBRC9l82031813@sheep.berlios.de>

Author: dotslash
Date: 2006-12-27 13:09:46 +0100 (Wed, 27 Dec 2006)
New Revision: 565

Modified:
   trunk/libs3d/io.c
Log:
- ignore unknown args in libs3d

Modified: trunk/libs3d/io.c
===================================================================
--- trunk/libs3d/io.c	2006-12-27 11:31:53 UTC (rev 564)
+++ trunk/libs3d/io.c	2006-12-27 12:09:46 UTC (rev 565)
@@ -77,6 +77,7 @@
 	};
 	if ((argc==NULL) || (argv==NULL)) return(0); /* nothing to parse */
 	optind=0;
+	opterr=0;	/* we don't want to be bothered if there is some error */
 	while (-1!=(c=getopt_long(*argc,*argv,"?h",long_options,&lopt_idx)))
 	{
 		switch (c)
@@ -91,11 +92,14 @@
 				}
 			}
 			break;
-		case '?':
 		case 'h':
 			printf("usage: %s [options]",(*argv)[0]);
 			s3d_usage();
 			return(-1);
+		case '?':
+		default:
+			/* ignore args which are not for us, but maybe the app which builds on us */
+			break;
 		}
 	}
 	optind=0;



From dotslash at mail.berlios.de  Wed Dec 27 19:40:27 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 27 Dec 2006 19:40:27 +0100
Subject: [S3d-svn] r566 - trunk/apps/s3dosm
Message-ID: <200612271840.kBRIeRQF007772@sheep.berlios.de>

Author: dotslash
Date: 2006-12-27 19:40:26 +0100 (Wed, 27 Dec 2006)
New Revision: 566

Modified:
   trunk/apps/s3dosm/gps.c
   trunk/apps/s3dosm/io.c
   trunk/apps/s3dosm/net.c
   trunk/apps/s3dosm/olsrs3d.c
Log:
- organize argument handling in s3dosm

Modified: trunk/apps/s3dosm/gps.c
===================================================================
--- trunk/apps/s3dosm/gps.c	2006-12-27 12:09:46 UTC (rev 565)
+++ trunk/apps/s3dosm/gps.c	2006-12-27 18:40:26 UTC (rev 566)
@@ -161,7 +161,7 @@
 			case NL_NOCONNECT: 	err_str = "can't connect to host"; break;
 			default:           	err_str = "Unknown"; break;
 		}
-		printf("no connection to gpsd\n");
+/*		printf("no connection to gpsd\n");*/
 		fprintf(stderr, "s3dosm: no gpsd running or network error: %d, %s\n"	,  errno, err_str);
 		return(-1);
 	}

Modified: trunk/apps/s3dosm/io.c
===================================================================
--- trunk/apps/s3dosm/io.c	2006-12-27 12:09:46 UTC (rev 565)
+++ trunk/apps/s3dosm/io.c	2006-12-27 18:40:26 UTC (rev 566)
@@ -50,7 +50,7 @@
 
 int process_args(int argc, char **argv)
 {
-	int					 lopt_idx,i;
+	int					 lopt_idx=0,i;
 	char				 c;
 	float				 minlat, minlon, maxlat, maxlon;
 	char 				 info[1024];
@@ -61,6 +61,7 @@
 		{0,0,0,0}
 	};
 	optind=0;
+	opterr=0;
 	while (-1!=(c=getopt_long(argc,argv,"?ho",long_options,&lopt_idx)))
 	{
 		switch (c)
@@ -74,8 +75,8 @@
 						return(-1);
 					}
 					break;
+				case 'h':
 				case '?':
-				case 'h':
 					printf("\nUSAGE: %s [options] [files]\n\n",argv[0]);
 					printf("options:\n");
 					printf("\t--osm, -o MINLAT,MINLON,MAXLAT,MAXLON:\n");
@@ -86,6 +87,8 @@
 					printf("\t+ Opemstreetmap .osm files\n\n");
 					s3d_usage();	/* add s3d usage */
 					return(-1);
+				default:
+					break;
 		}
 	}
 	for (i=1;i<argc;i++)

Modified: trunk/apps/s3dosm/net.c
===================================================================
--- trunk/apps/s3dosm/net.c	2006-12-27 12:09:46 UTC (rev 565)
+++ trunk/apps/s3dosm/net.c	2006-12-27 18:40:26 UTC (rev 566)
@@ -64,6 +64,7 @@
 
     if (connect(sockfd, (struct sockaddr *)&their_addr,
                                           sizeof(struct sockaddr)) == -1) {
+		fprintf(stderr,"Can't connect to host %s\n",host);
         perror("olsr_net:connect");
         return(1);
     }

Modified: trunk/apps/s3dosm/olsrs3d.c
===================================================================
--- trunk/apps/s3dosm/olsrs3d.c	2006-12-27 12:09:46 UTC (rev 565)
+++ trunk/apps/s3dosm/olsrs3d.c	2006-12-27 18:40:26 UTC (rev 566)
@@ -1059,6 +1059,7 @@
 	int optchar;
 	strncpy( Olsr_host, "127.0.0.1", 256 );
 	lbuf[0] = '\0';   /* init lbuf */
+	opterr=0;
 
 	while ( ( optchar = getopt ( argc, argv, "dhH:" ) ) != -1 ) {
 
@@ -1076,6 +1077,9 @@
 			default:
 				print_usage();
 				return (1);
+			case '?':
+				/* not handled by olsr-part */
+				break;
 		}
 
 	}



From dotslash at mail.berlios.de  Wed Dec 27 21:14:19 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 27 Dec 2006 21:14:19 +0100
Subject: [S3d-svn] r567 - trunk/server
Message-ID: <200612272014.kBRKEJlp019449@sheep.berlios.de>

Author: dotslash
Date: 2006-12-27 21:14:18 +0100 (Wed, 27 Dec 2006)
New Revision: 567

Modified:
   trunk/server/main.c
Log:
-__APPLE__ is also defined by $other architectures? remove it again ...

Modified: trunk/server/main.c
===================================================================
--- trunk/server/main.c	2006-12-27 18:40:26 UTC (rev 566)
+++ trunk/server/main.c	2006-12-27 20:14:18 UTC (rev 567)
@@ -147,9 +147,11 @@
 /*  this initalizes all components.  */
 int init() 
 {
+	/*
 #define	__APPLE__
 	NSApplicationLoad();
 #endif
+	*/
 #ifdef SIGS
 	if (!norc)
 		rc_init();



From dotslash at mail.berlios.de  Wed Dec 27 21:15:36 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 27 Dec 2006 21:15:36 +0100
Subject: [S3d-svn] r568 - trunk/apps/s3dosm
Message-ID: <200612272015.kBRKFahb020362@sheep.berlios.de>

Author: dotslash
Date: 2006-12-27 21:15:35 +0100 (Wed, 27 Dec 2006)
New Revision: 568

Modified:
   trunk/apps/s3dosm/io.c
Log:
- one more argument repair

Modified: trunk/apps/s3dosm/io.c
===================================================================
--- trunk/apps/s3dosm/io.c	2006-12-27 20:14:18 UTC (rev 567)
+++ trunk/apps/s3dosm/io.c	2006-12-27 20:15:35 UTC (rev 568)
@@ -62,7 +62,7 @@
 	};
 	optind=0;
 	opterr=0;
-	while (-1!=(c=getopt_long(argc,argv,"?ho",long_options,&lopt_idx)))
+	while (-1!=(c=getopt_long(argc,argv,"dH:?ho",long_options,&lopt_idx)))
 	{
 		switch (c)
 		{
@@ -93,7 +93,6 @@
 	}
 	for (i=1;i<argc;i++)
 	{
-		printf("argument %d: %s\n",i,argv[i]);
 		if (strstr(argv[i],".osm")-argv[i]==strlen(argv[i])-4) {
 			snprintf(info,1024,"loading OSM-File: %s",argv[i]);
 			load_window(info);



From dotslash at mail.berlios.de  Wed Dec 27 21:26:52 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Wed, 27 Dec 2006 21:26:52 +0100
Subject: [S3d-svn] r569 - trunk/apps/s3dosm
Message-ID: <200612272026.kBRKQqP5022399@sheep.berlios.de>

Author: dotslash
Date: 2006-12-27 21:26:52 +0100 (Wed, 27 Dec 2006)
New Revision: 569

Modified:
   trunk/apps/s3dosm/net.c
Log:
- more verbosity for olsr-part when failing

Modified: trunk/apps/s3dosm/net.c
===================================================================
--- trunk/apps/s3dosm/net.c	2006-12-27 20:15:35 UTC (rev 568)
+++ trunk/apps/s3dosm/net.c	2006-12-27 20:26:52 UTC (rev 569)
@@ -48,11 +48,13 @@
     struct sockaddr_in their_addr; /* connector's address information  */
 
     if ((he=gethostbyname(host)) == NULL) {  /* get the host info  */
+		fprintf(stderr,"Can't connect to host %s\n",host);
         herror("olsr_net:gethostbyname");
         return(1);
     }
 
     if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
+		fprintf(stderr,"Can't connect to host %s\n",host);
         perror("olsr_net:socket");
         return(1);
     }



From dotslash at mail.berlios.de  Thu Dec 28 20:46:05 2006
From: dotslash at mail.berlios.de (dotslash at BerliOS)
Date: Thu, 28 Dec 2006 20:46:05 +0100
Subject: [S3d-svn] r570 - trunk/apps/s3dosm
Message-ID: <200612281946.kBSJk55G005958@sheep.berlios.de>

Author: dotslash
Date: 2006-12-28 20:46:05 +0100 (Thu, 28 Dec 2006)
New Revision: 570

Modified:
   trunk/apps/s3dosm/draw.c
Log:
- can't update node id - table is locked

Modified: trunk/apps/s3dosm/draw.c
===================================================================
--- trunk/apps/s3dosm/draw.c	2006-12-27 20:26:52 UTC (rev 569)
+++ trunk/apps/s3dosm/draw.c	2006-12-28 19:46:05 UTC (rev 570)
@@ -86,7 +86,7 @@
 {
 	int i,tagid=-1,oid;
 	int nodeid=-1, layerid=-1;
-	char query[MAXQ];
+/*	char query[MAXQ];*/
 	char s[MAXQ];
 	float la, lo, alt;
 	float x[3];
@@ -121,8 +121,8 @@
 			s3d_link(oid,oidy);
 			s3d_flags_on(oid,S3D_OF_VISIBLE|S3D_OF_SELECTABLE);
 			load_update_status((100.0*num_done)/(float)num_max);
-			snprintf(query,MAXQ,"UPDATE node SET s3doid=%d WHERE node_id=%d AND layer=%d;",oid,nodeid,layerid);
-			db_exec(query, NULL, 0);
+/*			snprintf(query,MAXQ,"UPDATE node SET s3doid=%d WHERE node_id=%d AND layer_id=%d;",oid,nodeid,layerid);
+			db_exec(query, NULL, 0);*/
 		}
 				
 	} 
@@ -423,7 +423,7 @@
 {
 	char query[MAXQ];
 	num_done=0;
-	snprintf(query,MAXQ,"SELECT count(seg_id) FROM segment WHERE %s",filter);
+	snprintf(query,MAXQ,"SELECT count(seg_id) FROM segment WHERE %s;",filter);
 	db_exec(query, db_getint,&num_max);
 	snprintf(query,MAXQ,"SELECT * FROM segment WHERE %s ORDER BY way_id;",filter);
 	db_exec(query, way_group,filter);
@@ -440,11 +440,10 @@
 	char filter[]="layer_id=(SELECT layer_id FROM layer WHERE name='kismet')";
 	load_window("Drawing Access Points ...");
 	num_done=0;
-	snprintf(query,MAXQ,"SELECT count(node_id) FROM node WHERE %s",filter);
+	snprintf(query,MAXQ,"SELECT count(node_id) FROM node WHERE %s;",filter);
 	db_exec(query, db_getint,&num_max);
 	snprintf(query,MAXQ,"SELECT * FROM node WHERE %s;",filter);
 	db_exec(query, draw_icon,filter);
-	waylist_draw(filter); /* last way */
 }
 void draw_all_layers()
 {



