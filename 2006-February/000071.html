<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [S3d-svn] r75 - in trunk: . client example
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/s3d-svn/2006-February/index.html" >
   <LINK REL="made" HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r75%20-%20in%20trunk%3A%20.%20client%20example&In-Reply-To=%3C200602171447.k1HElrY8001620%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000070.html">
   <LINK REL="Next"  HREF="000072.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[S3d-svn] r75 - in trunk: . client example</H1>
    <B>dotslash at BerliOS</B> 
    <A HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r75%20-%20in%20trunk%3A%20.%20client%20example&In-Reply-To=%3C200602171447.k1HElrY8001620%40sheep.berlios.de%3E"
       TITLE="[S3d-svn] r75 - in trunk: . client example">dotslash at berlios.de
       </A><BR>
    <I>Fri Feb 17 15:47:53 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000070.html">[S3d-svn] r74 - trunk/apps/olsrs3d
</A></li>
        <LI>Next message: <A HREF="000072.html">[S3d-svn] r76 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#71">[ date ]</a>
              <a href="thread.html#71">[ thread ]</a>
              <a href="subject.html#71">[ subject ]</a>
              <a href="author.html#71">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dotslash
Date: 2006-02-17 15:47:50 +0100 (Fri, 17 Feb 2006)
New Revision: 75

Added:
   trunk/client/sei_construct.c
   trunk/client/sei_interface.h
   trunk/client/sei_misc.c
   trunk/client/sei_monotone.c
   trunk/client/sei_tri.c
   trunk/client/sei_triangulate.h
Removed:
   trunk/client/tesselate.c
Modified:
   trunk/
   trunk/CREDITS
   trunk/ChangeLog
   trunk/client/3dsread.c
   trunk/client/Makefile.am
   trunk/client/config.h
   trunk/client/freetype.c
   trunk/example/strtest.c
Log:
 <A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">r91 at balthasar</A>:  dotslash | 2006-02-17 15:47:42 +0100
 Using Seidels algorithm for triangulating fonts



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:47
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:91

Modified: trunk/CREDITS
===================================================================
--- trunk/CREDITS	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/CREDITS	2006-02-17 14:47:50 UTC (rev 75)
@@ -2,6 +2,10 @@
 	- culling code adapted from Ruud van Gaal
 client/freetype.c
 	- tesselation things come from the OpenGL redbook
+client/sei_*.c
+	Implementation of the fast polygon triangulation algorithm
+	by R.Seidel (1991),  implementation by Narkhede A. and 
+	Manocha D. 	(1994)
 apps/s3dvt/s3dvt.c
 	- much of the code comes from glterm by &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">helly at gmx.net</A>&gt;
 example/miu3ds/*

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/ChangeLog	2006-02-17 14:47:50 UTC (rev 75)
@@ -1,3 +1,8 @@
+2006-02-17	Simon Wunderlich - &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;
+	- abadoning my own tries and the glu-tesselator 
+	  for triangulating the fonts and using public
+	  domain code for seidels algorithm by Narkhede A. and
+	  Manocha D.
 2006-01-30	Andreas Kohn - &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">andreas at syndrom23.de</A>&gt;
 	- rework larger parts of the build infrastructure, 
 	  use automake and libtool.

Modified: trunk/client/3dsread.c
===================================================================
--- trunk/client/3dsread.c	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/client/3dsread.c	2006-02-17 14:47:50 UTC (rev 75)
@@ -35,7 +35,7 @@
 		r[1]=n[1]/len;
 		r[2]=n[2]/len;
 	} else {
-		errds(LOW,&quot;normal()&quot;,&quot;couldn't calc normal&quot;);
+		dprintf(VLOW,&quot;normal(): couldn't calc normal&quot;);
 		r[0]=r[1]=r[2]=0.0F;
 	}
 }

Modified: trunk/client/Makefile.am
===================================================================
--- trunk/client/Makefile.am	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/client/Makefile.am	2006-02-17 14:47:50 UTC (rev 75)
@@ -2,9 +2,10 @@
 
 libs3d_la_SOURCES=	3dsread.c callback.c error.c event.c fontselect.c \
 			freetype.c io.c network.c object_queue.c proto_in.c \
-			proto_out.c shm.c shm_ringbuf.c tesselate.c tcp.c
+			proto_out.c shm.c shm_ringbuf.c tcp.c \
+			sei_construct.c sei_misc.c sei_monotone.c sei_tri.c
 			
-pkginclude_HEADERS=	config.h s3d.h s3dlib.h
+pkginclude_HEADERS=	config.h s3d.h s3dlib.h sei_triangulate.h sei_interface.h
 
 libs3d_la_CPPFLAGS=	-I${top_srcdir}/server
 libs3d_la_CFLAGS=	@FONTCONFIG_CFLAGS@ @FREETYPE_CFLAGS@ @GL_CFLAGS@

Modified: trunk/client/config.h
===================================================================
--- trunk/client/config.h	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/client/config.h	2006-02-17 14:47:50 UTC (rev 75)
@@ -4,3 +4,4 @@
 /*  our level of debug messages */
 #define DEBUG			LOW	 /*  standard debug level */
 #define SHM_MAX_IDLE	200	/* maximum wait for server timeout */
+#define	SEI_SS			200	/* seidel algorithm maximum point number */

Modified: trunk/client/freetype.c
===================================================================
--- trunk/client/freetype.c	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/client/freetype.c	2006-02-17 14:47:50 UTC (rev 75)
@@ -5,7 +5,6 @@
 #include &lt;netinet/in.h&gt;  /*  htonl(), htons() */
 #include &quot;ft2build.h&quot;
 #include FT_FREETYPE_H
-#include &lt;GL/glu.h&gt;  /*  gluTess* */
 #ifndef CALLBACK 
 #define CALLBACK
 #endif
@@ -17,137 +16,27 @@
 static int ft_init=0;
 static int face_init=0;
 
-static GLUtesselator *tobj;
 static int v_off; 	 /*  the vertex number offset, to have the right vertex numbers for each character */
 static int f_oid;	 /*  the oid of our font string */
-static int algo;	 /*  how the order of the vertex points should be interpreted (in the tesselator callbacks) */
-static GLdouble *point;	 /*  the point of the outline points */
-static int *pk,pn;		 /*  the index buffer and it's size */
 static int ch;
 struct t_buf tess_buf[256];
 
-int _s3d_init_tessbuf();
-int _s3d_clear_tessbuf();
-int _s3d_add_tessbuf(unsigned short a);
-int _s3d_draw_tessbuf(int oid,unsigned short a,int *voff, float *xoff);
-/*  callbacks */
-static void CALLBACK cb_vertex(GLdouble *v)
-{
-/* 	dprintf(LOW,&quot;point is at %010p, while v is %010p, vertex nr. %d&quot;,point,v,v_off+(v-point)/3); */
-	pk[pn]=v_off+(v-point)/3;
-	pn++;
-}
-/*  taken from tess.c/ redbook source code */
-static void CALLBACK cb_combine (GLdouble coords[3], 
-                     GLdouble *vertex_data[4],
-                     GLfloat weight[4], GLdouble **dataOut )
-{
-   GLdouble *vertex;
-   int i;
 
-   vertex = (GLdouble *) malloc(6 * sizeof(GLdouble));
 
-   vertex[0] = coords[0];
-   vertex[1] = coords[1];
-   vertex[2] = coords[2];
-   for (i = 3; i &lt; 7; i++)
-      vertex[i] = weight[0] * vertex_data[0][i] 
-                  + weight[1] * vertex_data[1][i]
-                  + weight[2] * vertex_data[2][i] 
-                  + weight[3] * vertex_data[3][i];
-   dprintf(LOW,&quot;combining ...&quot;);
-   *dataOut = vertex;
-}
-
-static void CALLBACK cb_error(GLenum errorCode)
-{
-   const GLubyte *estring;
-
-   estring = gluErrorString(errorCode);
-   errds(HIGH,&quot;cb_error()&quot;,&quot;Tessellation Error: %s\n&quot;, estring);
-/*    exit(0); */
-}
-static void CALLBACK cb_begin(GLenum which)
-{
-	algo=which;
-	pn=0;
-}
-static void CALLBACK cb_end(GLenum which)
-{
-   int i;
-   int poff=tess_buf[ch].pn;
-   switch (algo)
-   {
-		case GL_TRIANGLES:
-			tess_buf[ch].pn+=pn/3;
-			tess_buf[ch].pbuf=realloc(tess_buf[ch].pbuf,tess_buf[ch].pn*sizeof(unsigned long)*4);
-			for (i=0;i&lt;(pn/3);i++)
-			{
-				tess_buf[ch].pbuf[(poff+i)*4]=	pk[i*3];
-				tess_buf[ch].pbuf[(poff+i)*4+1]=pk[i*3+1];
-				tess_buf[ch].pbuf[(poff+i)*4+2]=pk[i*3+2];
-				tess_buf[ch].pbuf[(poff+i)*4+3]=0;
-/* 				s3d_push_polygon(f_oid,pk[i*3],pk[i*3+1],pk[i*3+2],0); */
-			}
-			break;
-		case GL_TRIANGLE_FAN:
-			tess_buf[ch].pn+=pn-2;
-			tess_buf[ch].pbuf=realloc(tess_buf[ch].pbuf,tess_buf[ch].pn*sizeof(unsigned long)*4);
-/* 			for (i=1;i&lt;(pn-1);i++) */
-			for (i=0;i&lt;(pn-2);i++)
-			{
-				tess_buf[ch].pbuf[(poff+i)*4]=	pk[0];
-				tess_buf[ch].pbuf[(poff+i)*4+1]=pk[i+1];
-				tess_buf[ch].pbuf[(poff+i)*4+2]=pk[i+2];
-				tess_buf[ch].pbuf[(poff+i)*4+3]=0;
-/* 				s3d_push_polygon(f_oid,pk[0],pk[i],pk[i+1],0); */
-			}	
-			break;
-		case GL_TRIANGLE_STRIP:
-			tess_buf[ch].pn+=pn-2;
-			tess_buf[ch].pbuf=realloc(tess_buf[ch].pbuf,tess_buf[ch].pn*sizeof(unsigned long)*4);
-		   	for (i=0;i&lt;(pn-2);i++)
-		   	{
-				if (i%2)
-				{
-					tess_buf[ch].pbuf[(poff+i)*4]=	pk[i];
-					tess_buf[ch].pbuf[(poff+i)*4+1]=pk[i+2];
-					tess_buf[ch].pbuf[(poff+i)*4+2]=pk[i+1];
-					tess_buf[ch].pbuf[(poff+i)*4+3]=0;
-/* 					s3d_push_polygon(f_oid,pk[i],pk[i+2],pk[i+1],0); */
-				} else {
-					tess_buf[ch].pbuf[(poff+i)*4]=	pk[i];
-					tess_buf[ch].pbuf[(poff+i)*4+1]=pk[i+1];
-					tess_buf[ch].pbuf[(poff+i)*4+2]=pk[i+2];
-					tess_buf[ch].pbuf[(poff+i)*4+3]=0;
-/* 					s3d_push_polygon(f_oid,pk[i],pk[i+1],pk[i+2],0); */
-				}
-		   }
-		   break;
-		default: 
-		    errds(MED,&quot;cb_end()&quot;,&quot;tesselation method not supported&quot;);
-   }
-/*    dprintf(LOW,&quot;character [%c]: %d + %d polys&quot;,ch,poff,tess_buf[ch].pn-poff); */
-}
-
-/*  that's about the callback functions, now the init for the tesselator */
-/*  and the truetype part ... */
+/*  initialize truetype and tess_buf ... */
 int s3d_ft_init()
 {
 	int error= FT_Init_FreeType( &amp;library);
+	int i;
 	if (error)
 		return (-1);
-   tobj = gluNewTess();
-      gluTessProperty(tobj, GLU_TESS_WINDING_RULE,
-                   GLU_TESS_WINDING_POSITIVE);
-   gluTessCallback(tobj, GLU_TESS_VERTEX,	(GLvoid (*) ())cb_vertex);
-   gluTessCallback(tobj, GLU_TESS_BEGIN,	(GLvoid (*) ())cb_begin);
-   gluTessCallback(tobj, GLU_TESS_END,		(GLvoid (*) ())cb_end);
-   gluTessCallback(tobj, GLU_TESS_ERROR,	(GLvoid (*) ())cb_error);
-   gluTessCallback(tobj, GLU_TESS_COMBINE,  (GLvoid (*) ())cb_combine);
-   _s3d_init_tessbuf();
+    ft_init=1;
+	for (i=0; i&lt;256;i++)
+	{
+		tess_buf[i].vbuf=NULL;
+		tess_buf[i].pbuf=NULL;
+	}
 
-   ft_init=1;
 	return(0);
 }
 
@@ -177,16 +66,6 @@
 	}
 	return(0);
 }
-int _s3d_init_tessbuf()
-{
-	int i;
-	for (i=0; i&lt;256;i++)
-	{
-		tess_buf[i].vbuf=NULL;
-		tess_buf[i].pbuf=NULL;
-	}
-	return(0);
-}
 
 int _s3d_clear_tessbuf()
 {
@@ -198,62 +77,22 @@
 	}
 	return(0);
 }
-/*  tessaltes a character and adds it to the buffer */
+
+/* renders a character with seidels algorithm and stores it in the tess_buf for later
+ * usage */
 int _s3d_add_tessbuf(unsigned short a)
 {
 	float norm;
-	int j,c;
-	if (FT_Load_Char(face,a,	FT_LOAD_NO_BITMAP|FT_LOAD_NO_SCALE))
-	{
-		errds(VHIGH,&quot;s3d_add_tessbuf():FT_Load_Char()&quot;,&quot;can't load character&quot;);
-		return(-1);
-	} 
-	norm=1.0/face-&gt;glyph-&gt;metrics.vertAdvance;
-	ch=a;
-	v_off=0;
-	if (face-&gt;glyph-&gt;outline.n_points)
-	{
-		j=0;
-		tess_buf[a].vn=face-&gt;glyph-&gt;outline.n_points;
-		tess_buf[a].vbuf=malloc(sizeof(float)*face-&gt;glyph-&gt;outline.n_points*3);
-		point=(GLdouble *)malloc(sizeof(GLdouble)*face-&gt;glyph-&gt;outline.n_points*3);
-		pk=(int *)malloc(sizeof(int)*face-&gt;glyph-&gt;outline.n_points); 
-			 /*  our list which is to be filled with the array of vertex-indices for each  */
-			 /*  convex polygon .... */
-		gluTessBeginPolygon(tobj, NULL);
-		for (c=0;c&lt;face-&gt;glyph-&gt;outline.n_contours;c++)
-		{
-      		gluTessBeginContour(tobj);
-			while (j&lt;(face-&gt;glyph-&gt;outline.contours[c]+1))
-			{
-				point[j*3]=(GLdouble)(face-&gt;glyph-&gt;outline.points[j].x)*norm;
-				point[j*3+1]=(GLdouble)face-&gt;glyph-&gt;outline.points[j].y*norm;
-				point[j*3+2]=0.0;
-				tess_buf[a].vbuf[j*3]=point[j*3];
-				tess_buf[a].vbuf[j*3+1]=point[j*3+1];
-				tess_buf[a].vbuf[j*3+2]=point[j*3+2];
+	int i,j,k,c,start;
+	int np,pos,diff,cpos,mpos;
+	double vertices[SEI_SS+1][2];
+	int triangles[SEI_SS*2][3]; /* more than enough ... */
+	int ncontours,ncon;
+	int cntr[SEI_SS];
+	char used[SEI_SS];
+	int map[SEI_SS+1];
+	
 
-/* 				s3d_push_vertex(f_oid,point[j*3],point[j*3+1],point[j*3+2]); */
-       	 		gluTessVertex(tobj, &amp;point[j*3],&amp;point[j*3]);
-				j++;
-			}
-      		gluTessEndContour(tobj);
-		}
-   		gluTessEndPolygon(tobj);
-		
-/* 		v_off+=face-&gt;glyph-&gt;outline.n_points; */
-		free(pk);
-		free(point);
-	}
-	tess_buf[a].xoff=1.0*face-&gt;glyph-&gt;metrics.horiAdvance*norm;
-	return(0);
-}
-/*  tesselates a character and adds it to the buffer, without glu */
-int _s3d_add_tessbuf_new(unsigned short a)
-{
-	float norm;
-	int j,c,start;
-	struct tessp_t *tessp;
 	if (FT_Load_Char(face,a,	FT_LOAD_NO_BITMAP|FT_LOAD_NO_SCALE))
 	{
 		errds(VHIGH,&quot;s3d_add_tessbuf():FT_Load_Char()&quot;,&quot;can't load character&quot;);
@@ -262,37 +101,107 @@
 	norm=1.0/face-&gt;glyph-&gt;metrics.vertAdvance;
 	ch=a;
 	v_off=0;
-	if (face-&gt;glyph-&gt;outline.n_points)
+	if ((face-&gt;glyph-&gt;outline.n_points&gt;0) &amp;&amp; (face-&gt;glyph-&gt;outline.n_points&lt;SEI_SS))
 	{
-		j=0;
 		tess_buf[a].vn=face-&gt;glyph-&gt;outline.n_points;
 		tess_buf[a].vbuf=malloc(sizeof(float)*face-&gt;glyph-&gt;outline.n_points*3);
-		tess_buf[a].pbuf=malloc(sizeof(unsigned long)*face-&gt;glyph-&gt;outline.n_points*4); /* should be enough ... */
-		tessp=malloc(sizeof(struct tessp_t)*tess_buf[a].vn);
 		
-			 /*  our list which is to be filled with the array of vertex-indices for each  */
-			 /*  convex polygon .... */
-		for (c=0;c&lt;face-&gt;glyph-&gt;outline.n_contours;c++)
+		j=0;
+		ncontours=face-&gt;glyph-&gt;outline.n_contours;
+		for (c=0;c&lt;ncontours;c++)
 		{
 			start=j; 	/* first point */
-			while (j&lt;(face-&gt;glyph-&gt;outline.contours[c]+1))
+			i=0;
+			ncon=face-&gt;glyph-&gt;outline.contours[c]; /* position of the end of ths contour */
+			cntr[c]=ncon-j+1;
+			while (j&lt;(ncon+1))
 			{
-				tess_buf[a].vbuf[j*3]=face-&gt;glyph-&gt;outline.points[j].x*norm;
-				tess_buf[a].vbuf[j*3+1]=face-&gt;glyph-&gt;outline.points[j].y*norm;
-				tess_buf[a].vbuf[j*3+2]=0.0;
-				tessp[j].prev=j-1;
-				tessp[j].next=j+1;
-				tessp[j].done=0;
+				/* vertices have reverse order in seidels algorithm, outer contours go anticlockwise, inner contours clockwise */
+				pos=ncon-i;
+				tess_buf[a].vbuf[pos*3]		=vertices[pos+1][0]=face-&gt;glyph-&gt;outline.points[j].x*norm;
+				tess_buf[a].vbuf[pos*3+1]	=vertices[pos+1][1]=face-&gt;glyph-&gt;outline.points[j].y*norm;
+				map[pos+1]=pos;
+				tess_buf[a].vbuf[pos*3+2]	=0;
 				j++;
+				i++;
 			}
-			tessp[j-1].next=start;	/* last one */
-			tessp[start].prev=j-1;  /* first one */
 		}
-		_s3d_tesselate(tessp,&amp;tess_buf[a]);
+		k=0; /* polygon counter */
+		/* iterate while there are untriangulated outlines left. this is neccesary
+		 * because seidel will only operate on ONE outline at once (number of holes is not 
+		 * limited though) */
+		tess_buf[a].pbuf=malloc(sizeof(unsigned long)*4*(face-&gt;glyph-&gt;outline.n_points+2*face-&gt;glyph-&gt;outline.n_contours)); 
+		do {
+			np=sei_triangulate_polygon(ncontours, cntr, vertices, triangles);
+			dprintf(VLOW,&quot;[F]ound %d polygons&quot;,np);
+			memset(used,0,ncontours);
+			for (i=0;i&lt;np;i++)
+			{
+				tess_buf[a].pbuf[k*4]=  map[triangles[i][0]];
+				tess_buf[a].pbuf[k*4+1]=map[triangles[i][1]];
+				tess_buf[a].pbuf[k*4+2]=map[triangles[i][2]];
+				tess_buf[a].pbuf[k*4+3]=0;
+				dprintf(VLOW,&quot;TRIANG: %d %d %d = %d %d %d&quot;,	triangles[i][0],triangles[i][1],triangles[i][2], 
+															map[triangles[i][0]], map[triangles[i][1]], map[triangles[i][2]]);
+				for (j=0;j&lt;3;j++)
+				{
+					cpos=1;
+					for (c=0;c&lt;ncontours;c++)
+					{
+						cpos+=cntr[c];
+						if (triangles[i][j]&lt;cpos)
+						{
+							dprintf(VLOW,&quot;point %d in contour line %d (cpos = %d) used&quot;,triangles[i][j],c,cpos);
+							used[c]=1;
+							break;
+						}
+					}
+				}
+				k++;
+			}
+			j=1;
+			for (c=0;c&lt;ncontours;c++)
+			{
+				j&amp;=used[c];
+			}
+			if (j) 
+				dprintf(VLOW,&quot;all contours used&quot;);
+			else 
+			{
+				dprintf(VLOW,&quot;not all contours used, restarting&quot;);
+				diff=0;
+				ncon=0; /* number of actually unused contours */
+				cpos=1; /* position of source vertices */
+				mpos=1; /* position of dest vertices */
+				for (c=0;c&lt;ncontours;c++)
+				{
+					if (!used[c])
+					{
+					  /* not used, move it to new end */
+						dprintf(VLOW,&quot;contour %d (%d) not used!!&quot;,c,cntr[c]);
+						cntr[ncon]=cntr[c];
+						ncon++;
+						if (cpos!=mpos)
+						{
+							for (i=0;i&lt;cntr[c];i++)
+							{
+								vertices[mpos+i][0]=vertices[cpos+i][0];
+								vertices[mpos+i][1]=vertices[cpos+i][1];
+								map[mpos+i]=map[cpos+i];
+							}
+						}
+					}
+					cpos+=cntr[c];
+				}
+			}
+			ncontours=ncon;
+		} while (!j);
+		tess_buf[a].pn=k;
 	}
 	tess_buf[a].xoff=1.0*face-&gt;glyph-&gt;metrics.horiAdvance*norm;
 	return(0);
 }
+
 int _s3d_draw_tessbuf(int oid,unsigned short a,int *voff, float *xoff)
 {
 	float *vbuf;
@@ -404,7 +313,7 @@
 }
 int s3d_ft_quit()
 {
-	gluDeleteTess(tobj);
+	_s3d_clear_tessbuf();
 	FT_Done_FreeType(library);
 	ft_init=0;
 	return(0);

Added: trunk/client/sei_construct.c
===================================================================
--- trunk/client/sei_construct.c	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/client/sei_construct.c	2006-02-17 14:47:50 UTC (rev 75)
@@ -0,0 +1,1055 @@
+#include &lt;sei_triangulate.h&gt;
+#include &lt;math.h&gt;
+
+
+node_t qs[QSIZE];		/* Query structure */
+trap_t tr[TRSIZE];		/* Trapezoid structure */
+segment_t seg[SEGSIZE];		/* Segment table */
+
+static int q_idx;
+static int tr_idx;
+
+/* Return a new node to be added into the query tree */
+static int newnode()
+{
+  if (q_idx &lt; QSIZE)
+    return q_idx++;
+  else
+    {
+      errs(&quot;sei:newnode()&quot;,&quot;Query-table overflow&quot;);
+      return -1;
+    }
+}
+
+/* Return a free trapezoid */
+static int newtrap()
+{
+  if (tr_idx &lt; TRSIZE)
+    {
+      tr[tr_idx].lseg = -1;
+      tr[tr_idx].rseg = -1;
+      tr[tr_idx].state = ST_VALID;
+      return tr_idx++;
+    }
+  else
+    {
+      errs(&quot;sei:newtrap()&quot;,&quot;Trapezoid-table overflow&quot;);
+      return -1;
+    }
+}
+
+
+/* Return the maximum of the two points into the yval structure */
+static int _max(yval, v0, v1)
+     point_t *yval;
+     point_t *v0;
+     point_t *v1;
+{
+  if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
+    *yval = *v0;
+  else if (FP_EQUAL(v0-&gt;y, v1-&gt;y))
+    {
+      if (v0-&gt;x &gt; v1-&gt;x + C_EPS)
+	*yval = *v0;
+      else
+	*yval = *v1;
+    }
+  else
+    *yval = *v1;
+  
+  return 0;
+}
+
+
+/* Return the minimum of the two points into the yval structure */
+static int _min(yval, v0, v1)
+     point_t *yval;
+     point_t *v0;
+     point_t *v1;
+{
+  if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
+    *yval = *v0;
+  else if (FP_EQUAL(v0-&gt;y, v1-&gt;y))
+    {
+      if (v0-&gt;x &lt; v1-&gt;x)
+	*yval = *v0;
+      else
+	*yval = *v1;
+    }
+  else
+    *yval = *v1;
+  
+  return 0;
+}
+
+
+int _greater_than(v0, v1)
+     point_t *v0;
+     point_t *v1;
+{
+  if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
+    return TRUE;
+  else if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
+    return FALSE;
+  else
+    return (v0-&gt;x &gt; v1-&gt;x);
+}
+
+
+int _equal_to(v0, v1)
+     point_t *v0;
+     point_t *v1;
+{
+  return (FP_EQUAL(v0-&gt;y, v1-&gt;y) &amp;&amp; FP_EQUAL(v0-&gt;x, v1-&gt;x));
+}
+
+int _greater_than_equal_to(v0, v1)
+     point_t *v0;
+     point_t *v1;
+{
+  if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
+    return TRUE;
+  else if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
+    return FALSE;
+  else
+    return (v0-&gt;x &gt;= v1-&gt;x);
+}
+
+int _less_than(v0, v1)
+     point_t *v0;
+     point_t *v1;
+{
+  if (v0-&gt;y &lt; v1-&gt;y - C_EPS)
+    return TRUE;
+  else if (v0-&gt;y &gt; v1-&gt;y + C_EPS)
+    return FALSE;
+  else
+    return (v0-&gt;x &lt; v1-&gt;x);
+}
+
+
+/* Initilialise the query structure (Q) and the trapezoid table (T) 
+ * when the first segment is added to start the trapezoidation. The
+ * query-tree starts out with 4 trapezoids, one S-node and 2 Y-nodes
+ *    
+ *                4
+ *   -----------------------------------
+ *  		  \
+ *  	1	   \        2
+ *  		    \
+ *   -----------------------------------
+ *                3
+ */
+
+static int init_query_structure(segnum)
+     int segnum;
+{
+  int i1, i2, i3, i4, i5, i6, i7, root;
+  int t1, t2, t3, t4;
+  segment_t *s = &amp;seg[segnum];
+
+  q_idx = tr_idx = 1;
+  memset((void *)tr, 0, sizeof(tr));
+  memset((void *)qs, 0, sizeof(qs));
+
+  i1 = newnode();
+  qs[i1].nodetype = T_Y;
+  _max(&amp;qs[i1].yval, &amp;s-&gt;v0, &amp;s-&gt;v1); /* root */
+  root = i1;
+
+  qs[i1].right = i2 = newnode();
+  qs[i2].nodetype = T_SINK;
+  qs[i2].parent = i1;
+
+  qs[i1].left = i3 = newnode();
+  qs[i3].nodetype = T_Y;
+  _min(&amp;qs[i3].yval, &amp;s-&gt;v0, &amp;s-&gt;v1); /* root */
+  qs[i3].parent = i1;
+  
+  qs[i3].left = i4 = newnode();
+  qs[i4].nodetype = T_SINK;
+  qs[i4].parent = i3;
+  
+  qs[i3].right = i5 = newnode();
+  qs[i5].nodetype = T_X;
+  qs[i5].segnum = segnum;
+  qs[i5].parent = i3;
+  
+  qs[i5].left = i6 = newnode();
+  qs[i6].nodetype = T_SINK;
+  qs[i6].parent = i5;
+
+  qs[i5].right = i7 = newnode();
+  qs[i7].nodetype = T_SINK;
+  qs[i7].parent = i5;
+
+  t1 = newtrap();		/* middle left */
+  t2 = newtrap();		/* middle right */
+  t3 = newtrap();		/* bottom-most */
+  t4 = newtrap();		/* topmost */
+
+  tr[t1].hi = tr[t2].hi = tr[t4].lo = qs[i1].yval;
+  tr[t1].lo = tr[t2].lo = tr[t3].hi = qs[i3].yval;
+  tr[t4].hi.y = (double) (INFINITY);
+  tr[t4].hi.x = (double) (INFINITY);
+  tr[t3].lo.y = (double) -1* (INFINITY);
+  tr[t3].lo.x = (double) -1* (INFINITY);
+  tr[t1].rseg = tr[t2].lseg = segnum;
+  tr[t1].u0 = tr[t2].u0 = t4;
+  tr[t1].d0 = tr[t2].d0 = t3;
+  tr[t4].d0 = tr[t3].u0 = t1;
+  tr[t4].d1 = tr[t3].u1 = t2;
+  
+  tr[t1].sink = i6;
+  tr[t2].sink = i7;
+  tr[t3].sink = i4;
+  tr[t4].sink = i2;
+
+  tr[t1].state = tr[t2].state = ST_VALID;
+  tr[t3].state = tr[t4].state = ST_VALID;
+
+  qs[i2].trnum = t4;
+  qs[i4].trnum = t3;
+  qs[i6].trnum = t1;
+  qs[i7].trnum = t2;
+
+  s-&gt;is_inserted = TRUE;
+  return root;
+}
+
+
+/* Retun TRUE if the vertex v is to the left of line segment no.
+ * segnum. Takes care of the degenerate cases when both the vertices
+ * have the same y--cood, etc.
+ */
+
+static int is_left_of(segnum, v)
+     int segnum;
+     point_t *v;
+{
+  segment_t *s = &amp;seg[segnum];
+  double area;
+  
+  if (_greater_than(&amp;s-&gt;v1, &amp;s-&gt;v0)) /* seg. going upwards */
+    {
+      if (FP_EQUAL(s-&gt;v1.y, v-&gt;y))
+	{
+	  if (v-&gt;x &lt; s-&gt;v1.x)
+	    area = 1.0;
+	  else
+	    area = -1.0;
+	}
+      else if (FP_EQUAL(s-&gt;v0.y, v-&gt;y))
+	{
+	  if (v-&gt;x &lt; s-&gt;v0.x)
+	    area = 1.0;
+	  else
+	    area = -1.0;
+	}
+      else
+	area = CROSS(s-&gt;v0, s-&gt;v1, (*v));
+    }
+  else				/* v0 &gt; v1 */
+    {
+      if (FP_EQUAL(s-&gt;v1.y, v-&gt;y))
+	{
+	  if (v-&gt;x &lt; s-&gt;v1.x)
+	    area = 1.0;
+	  else
+	    area = -1.0;
+	}
+      else if (FP_EQUAL(s-&gt;v0.y, v-&gt;y))
+	{
+	  if (v-&gt;x &lt; s-&gt;v0.x)
+	    area = 1.0;
+	  else
+	    area = -1.0;
+	}
+      else
+	area = CROSS(s-&gt;v1, s-&gt;v0, (*v));
+    }
+  
+  if (area &gt; 0.0)
+    return TRUE;
+  else 
+    return FALSE;
+}
+
+
+
+/* Returns true if the corresponding endpoint of the given segment is */
+/* already inserted into the segment tree. Use the simple test of */
+/* whether the segment which shares this endpoint is already inserted */
+
+static int inserted(segnum, whichpt)
+     int segnum;
+     int whichpt;
+{
+  if (whichpt == FIRSTPT)
+    return seg[seg[segnum].prev].is_inserted;
+  else
+    return seg[seg[segnum].next].is_inserted;
+}
+
+/* This is query routine which determines which trapezoid does the 
+ * point v lie in. The return value is the trapezoid number. 
+ */
+
+int locate_endpoint(v, vo, r)
+     point_t *v;
+     point_t *vo;
+     int r;
+{
+  node_t *rptr = &amp;qs[r];
+  
+  switch (rptr-&gt;nodetype)
+    {
+    case T_SINK:
+      return rptr-&gt;trnum;
+      
+    case T_Y:
+      if (_greater_than(v, &amp;rptr-&gt;yval)) /* above */
+	return locate_endpoint(v, vo, rptr-&gt;right);
+      else if (_equal_to(v, &amp;rptr-&gt;yval)) /* the point is already */
+	{			          /* inserted. */
+	  if (_greater_than(vo, &amp;rptr-&gt;yval)) /* above */
+	    return locate_endpoint(v, vo, rptr-&gt;right);
+	  else 
+	    return locate_endpoint(v, vo, rptr-&gt;left); /* below */	    
+	}
+      else
+	return locate_endpoint(v, vo, rptr-&gt;left); /* below */
+
+    case T_X:
+      if (_equal_to(v, &amp;seg[rptr-&gt;segnum].v0) || 
+	       _equal_to(v, &amp;seg[rptr-&gt;segnum].v1))
+	{
+	  if (FP_EQUAL(v-&gt;y, vo-&gt;y)) /* horizontal segment */
+	    {
+	      if (vo-&gt;x &lt; v-&gt;x)
+		return locate_endpoint(v, vo, rptr-&gt;left); /* left */
+	      else
+		return locate_endpoint(v, vo, rptr-&gt;right); /* right */
+	    }
+
+	  else if (is_left_of(rptr-&gt;segnum, vo))
+	    return locate_endpoint(v, vo, rptr-&gt;left); /* left */
+	  else
+	    return locate_endpoint(v, vo, rptr-&gt;right); /* right */
+	}
+      else if (is_left_of(rptr-&gt;segnum, v))
+	return locate_endpoint(v, vo, rptr-&gt;left); /* left */
+      else
+	return locate_endpoint(v, vo, rptr-&gt;right); /* right */	
+
+    default:
+      errs(&quot;sei:locate_endpoint()&quot;,&quot;Haggu!!!! (whatever)&quot;);
+      break;
+    }
+}
+
+
+/* Thread in the segment into the existing trapezoidation. The 
+ * limiting trapezoids are given by tfirst and tlast (which are the
+ * trapezoids containing the two endpoints of the segment. Merges all
+ * possible trapezoids which flank this segment and have been recently
+ * divided because of its insertion
+ */
+
+static int merge_trapezoids(segnum, tfirst, tlast, side)
+     int segnum;
+     int tfirst;
+     int tlast;
+     int side;
+{
+  int t, tnext, cond;
+  int ptnext;
+
+  /* First merge polys on the LHS */
+  t = tfirst;
+  while ((t &gt; 0) &amp;&amp; _greater_than_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo))
+    {
+      if (side == S_LEFT)
+	cond = ((((tnext = tr[t].d0) &gt; 0) &amp;&amp; (tr[tnext].rseg == segnum)) ||
+		(((tnext = tr[t].d1) &gt; 0) &amp;&amp; (tr[tnext].rseg == segnum)));
+      else
+	cond = ((((tnext = tr[t].d0) &gt; 0) &amp;&amp; (tr[tnext].lseg == segnum)) ||
+		(((tnext = tr[t].d1) &gt; 0) &amp;&amp; (tr[tnext].lseg == segnum)));
+      
+      if (cond)
+	{
+	  if ((tr[t].lseg == tr[tnext].lseg) &amp;&amp;
+	      (tr[t].rseg == tr[tnext].rseg)) /* good neighbours */
+	    {			              /* merge them */
+	      /* Use the upper node as the new node i.e. t */
+	      
+	      ptnext = qs[tr[tnext].sink].parent;
+	      
+	      if (qs[ptnext].left == tr[tnext].sink)
+		qs[ptnext].left = tr[t].sink;
+	      else
+		qs[ptnext].right = tr[t].sink;	/* redirect parent */
+	      
+	      
+	      /* Change the upper neighbours of the lower trapezoids */
+	      
+	      if ((tr[t].d0 = tr[tnext].d0) &gt; 0)
+		if (tr[tr[t].d0].u0 == tnext)
+		  tr[tr[t].d0].u0 = t;
+		else if (tr[tr[t].d0].u1 == tnext)
+		  tr[tr[t].d0].u1 = t;
+	      
+	      if ((tr[t].d1 = tr[tnext].d1) &gt; 0)
+		if (tr[tr[t].d1].u0 == tnext)
+		  tr[tr[t].d1].u0 = t;
+		else if (tr[tr[t].d1].u1 == tnext)
+		  tr[tr[t].d1].u1 = t;
+	      
+	      tr[t].lo = tr[tnext].lo;
+	      tr[tnext].state = ST_INVALID; /* invalidate the lower */
+				            /* trapezium */
+	    }
+	  else		    /* not good neighbours */
+	    t = tnext;
+	}
+      else		    /* do not satisfy the outer if */
+	t = tnext;
+      
+    } /* end-while */
+       
+  return 0;
+}
+
+
+/* Add in the new segment into the trapezoidation and update Q and T
+ * structures. First locate the two endpoints of the segment in the
+ * Q-structure. Then start from the topmost trapezoid and go down to
+ * the  lower trapezoid dividing all the trapezoids in between .
+ */
+
+static int add_segment(segnum)
+     int segnum;
+{
+  segment_t s;
+  segment_t *so = &amp;seg[segnum];
+  int tu, tl, sk, tfirst, tlast, tnext;
+  int tfirstr, tlastr, tfirstl, tlastl;
+  int i1, i2, t, t1, t2, tn;
+  point_t tpt;
+  int tritop = 0, tribot = 0, is_swapped = 0;
+  int tmptriseg;
+
+  s = seg[segnum];
+  if (_greater_than(&amp;s.v1, &amp;s.v0)) /* Get higher vertex in v0 */
+    {
+      int tmp;
+      tpt = s.v0;
+      s.v0 = s.v1;
+      s.v1 = tpt;
+      tmp = s.root0;
+      s.root0 = s.root1;
+      s.root1 = tmp;
+      is_swapped = TRUE;
+    }
+
+  if ((is_swapped) ? !inserted(segnum, LASTPT) :
+       !inserted(segnum, FIRSTPT))     /* insert v0 in the tree */
+    {
+      int tmp_d;
+
+      tu = locate_endpoint(&amp;s.v0, &amp;s.v1, s.root0);
+      tl = newtrap();		/* tl is the new lower trapezoid */
+      tr[tl].state = ST_VALID;
+      tr[tl] = tr[tu];
+      tr[tu].lo.y = tr[tl].hi.y = s.v0.y;
+      tr[tu].lo.x = tr[tl].hi.x = s.v0.x;
+      tr[tu].d0 = tl;      
+      tr[tu].d1 = 0;
+      tr[tl].u0 = tu;
+      tr[tl].u1 = 0;
+
+      if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
+	tr[tmp_d].u0 = tl;
+      if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
+	tr[tmp_d].u1 = tl;
+
+      if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
+	tr[tmp_d].u0 = tl;
+      if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
+	tr[tmp_d].u1 = tl;
+
+      /* Now update the query structure and obtain the sinks for the */
+      /* two trapezoids */ 
+      
+      i1 = newnode();		/* Upper trapezoid sink */
+      i2 = newnode();		/* Lower trapezoid sink */
+      sk = tr[tu].sink;
+      
+      qs[sk].nodetype = T_Y;
+      qs[sk].yval = s.v0;
+      qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
+      qs[sk].left = i2;
+      qs[sk].right = i1;
+
+      qs[i1].nodetype = T_SINK;
+      qs[i1].trnum = tu;
+      qs[i1].parent = sk;
+
+      qs[i2].nodetype = T_SINK;
+      qs[i2].trnum = tl;
+      qs[i2].parent = sk;
+
+      tr[tu].sink = i1;
+      tr[tl].sink = i2;
+      tfirst = tl;
+    }
+  else				/* v0 already present */
+    {       /* Get the topmost intersecting trapezoid */
+      tfirst = locate_endpoint(&amp;s.v0, &amp;s.v1, s.root0);
+      tritop = 1;
+    }
+
+
+  if ((is_swapped) ? !inserted(segnum, FIRSTPT) :
+       !inserted(segnum, LASTPT))     /* insert v1 in the tree */
+    {
+      int tmp_d;
+
+      tu = locate_endpoint(&amp;s.v1, &amp;s.v0, s.root1);
+
+      tl = newtrap();		/* tl is the new lower trapezoid */
+      tr[tl].state = ST_VALID;
+      tr[tl] = tr[tu];
+      tr[tu].lo.y = tr[tl].hi.y = s.v1.y;
+      tr[tu].lo.x = tr[tl].hi.x = s.v1.x;
+      tr[tu].d0 = tl;      
+      tr[tu].d1 = 0;
+      tr[tl].u0 = tu;
+      tr[tl].u1 = 0;
+
+      if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
+	tr[tmp_d].u0 = tl;
+      if (((tmp_d = tr[tl].d0) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
+	tr[tmp_d].u1 = tl;
+
+      if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u0 == tu))
+	tr[tmp_d].u0 = tl;
+      if (((tmp_d = tr[tl].d1) &gt; 0) &amp;&amp; (tr[tmp_d].u1 == tu))
+	tr[tmp_d].u1 = tl;
+      
+      /* Now update the query structure and obtain the sinks for the */
+      /* two trapezoids */ 
+      
+      i1 = newnode();		/* Upper trapezoid sink */
+      i2 = newnode();		/* Lower trapezoid sink */
+      sk = tr[tu].sink;
+      
+      qs[sk].nodetype = T_Y;
+      qs[sk].yval = s.v1;
+      qs[sk].segnum = segnum;	/* not really reqd ... maybe later */
+      qs[sk].left = i2;
+      qs[sk].right = i1;
+
+      qs[i1].nodetype = T_SINK;
+      qs[i1].trnum = tu;
+      qs[i1].parent = sk;
+
+      qs[i2].nodetype = T_SINK;
+      qs[i2].trnum = tl;
+      qs[i2].parent = sk;
+
+      tr[tu].sink = i1;
+      tr[tl].sink = i2;
+      tlast = tu;
+    }
+  else				/* v1 already present */
+    {       /* Get the lowermost intersecting trapezoid */
+      tlast = locate_endpoint(&amp;s.v1, &amp;s.v0, s.root1);
+      tribot = 1;
+    }
+  
+  /* Thread the segment into the query tree creating a new X-node */
+  /* First, split all the trapezoids which are intersected by s into */
+  /* two */
+
+  t = tfirst;			/* topmost trapezoid */
+  
+  while ((t &gt; 0) &amp;&amp; 
+	 _greater_than_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo))
+				/* traverse from top to bot */
+    {
+      int t_sav, tn_sav;
+      sk = tr[t].sink;
+      i1 = newnode();		/* left trapezoid sink */
+      i2 = newnode();		/* right trapezoid sink */
+      
+      qs[sk].nodetype = T_X;
+      qs[sk].segnum = segnum;
+      qs[sk].left = i1;
+      qs[sk].right = i2;
+
+      qs[i1].nodetype = T_SINK;	/* left trapezoid (use existing one) */
+      qs[i1].trnum = t;
+      qs[i1].parent = sk;
+
+      qs[i2].nodetype = T_SINK;	/* right trapezoid (allocate new) */
+      qs[i2].trnum = tn = newtrap();
+      tr[tn].state = ST_VALID;
+      qs[i2].parent = sk;
+
+      if (t == tfirst)
+	tfirstr = tn;
+      if (_equal_to(&amp;tr[t].lo, &amp;tr[tlast].lo))
+	tlastr = tn;
+
+      tr[tn] = tr[t];
+      tr[t].sink = i1;
+      tr[tn].sink = i2;
+      t_sav = t;
+      tn_sav = tn;
+
+      /* error */
+
+      if ((tr[t].d0 &lt;= 0) &amp;&amp; (tr[t].d1 &lt;= 0)) /* case cannot arise */
+	{
+      errs(&quot;sei:add_segment()&quot;,&quot;error&quot;);
+	  break;
+	}
+      
+      /* only one trapezoid below. partition t into two and make the */
+      /* two resulting trapezoids t and tn as the upper neighbours of */
+      /* the sole lower trapezoid */
+      
+      else if ((tr[t].d0 &gt; 0) &amp;&amp; (tr[t].d1 &lt;= 0))
+	{			/* Only one trapezoid below */
+	  if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0))
+	    {			/* continuation of a chain from abv. */
+	      if (tr[t].usave &gt; 0) /* three upper neighbours */
+		{
+		  if (tr[t].uside == S_LEFT)
+		    {
+		      tr[tn].u0 = tr[t].u1;
+		      tr[t].u1 = -1;
+		      tr[tn].u1 = tr[t].usave;
+		      
+		      tr[tr[t].u0].d0 = t;
+		      tr[tr[tn].u0].d0 = tn;
+		      tr[tr[tn].u1].d0 = tn;
+		    }
+		  else		/* intersects in the right */
+		    {
+		      tr[tn].u1 = -1;
+		      tr[tn].u0 = tr[t].u1;
+		      tr[t].u1 = tr[t].u0;
+		      tr[t].u0 = tr[t].usave;
+
+		      tr[tr[t].u0].d0 = t;
+		      tr[tr[t].u1].d0 = t;
+		      tr[tr[tn].u0].d0 = tn;		      
+		    }
+		  
+		  tr[t].usave = tr[tn].usave = 0;
+		}
+	      else		/* No usave.... simple case */
+		{
+		  tr[tn].u0 = tr[t].u1;
+		  tr[t].u1 = tr[tn].u1 = -1;
+		  tr[tr[tn].u0].d0 = tn;
+		}
+	    }
+	  else 
+	    {			/* fresh seg. or upward cusp */
+	      int tmp_u = tr[t].u0;
+	      int td0, td1;
+	      if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp; 
+		  ((td1 = tr[tmp_u].d1) &gt; 0))
+		{		/* upward cusp */
+		  if ((tr[td0].rseg &gt; 0) &amp;&amp;
+		      !is_left_of(tr[td0].rseg, &amp;s.v1))
+		    {
+		      tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
+		      tr[tr[tn].u0].d1 = tn;
+		    }
+		  else		/* cusp going leftwards */
+		    { 
+		      tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
+		      tr[tr[t].u0].d0 = t;
+		    }
+		}
+	      else		/* fresh segment */
+		{
+		  tr[tr[t].u0].d0 = t;
+		  tr[tr[t].u0].d1 = tn;
+		}	      
+	    }
+	  
+	  if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp; 
+	      FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot)
+	    {		/* bottom forms a triangle */
+
+	      if (is_swapped)	
+		tmptriseg = seg[segnum].prev;
+	      else
+		tmptriseg = seg[segnum].next;
+	      
+	      if ((tmptriseg &gt; 0) &amp;&amp; is_left_of(tmptriseg, &amp;s.v0))
+		{
+				/* L-R downward cusp */
+		  tr[tr[t].d0].u0 = t;
+		  tr[tn].d0 = tr[tn].d1 = -1;
+		}
+	      else
+		{
+				/* R-L downward cusp */
+		  tr[tr[tn].d0].u1 = tn;
+		  tr[t].d0 = tr[t].d1 = -1;
+		}
+	    }
+	  else
+	    {
+	      if ((tr[tr[t].d0].u0 &gt; 0) &amp;&amp; (tr[tr[t].d0].u1 &gt; 0))
+		{
+		  if (tr[tr[t].d0].u0 == t) /* passes thru LHS */
+		    {
+		      tr[tr[t].d0].usave = tr[tr[t].d0].u1;
+		      tr[tr[t].d0].uside = S_LEFT;
+		    }
+		  else
+		    {
+		      tr[tr[t].d0].usave = tr[tr[t].d0].u0;
+		      tr[tr[t].d0].uside = S_RIGHT;
+		    }		    
+		}
+	      tr[tr[t].d0].u0 = t;
+	      tr[tr[t].d0].u1 = tn;
+	    }
+	  
+	  t = tr[t].d0;
+	}
+
+
+      else if ((tr[t].d0 &lt;= 0) &amp;&amp; (tr[t].d1 &gt; 0))
+	{			/* Only one trapezoid below */
+	  if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0))
+	    {			/* continuation of a chain from abv. */
+	      if (tr[t].usave &gt; 0) /* three upper neighbours */
+		{
+		  if (tr[t].uside == S_LEFT)
+		    {
+		      tr[tn].u0 = tr[t].u1;
+		      tr[t].u1 = -1;
+		      tr[tn].u1 = tr[t].usave;
+		      
+		      tr[tr[t].u0].d0 = t;
+		      tr[tr[tn].u0].d0 = tn;
+		      tr[tr[tn].u1].d0 = tn;
+		    }
+		  else		/* intersects in the right */
+		    {
+		      tr[tn].u1 = -1;
+		      tr[tn].u0 = tr[t].u1;
+		      tr[t].u1 = tr[t].u0;
+		      tr[t].u0 = tr[t].usave;
+
+		      tr[tr[t].u0].d0 = t;
+		      tr[tr[t].u1].d0 = t;
+		      tr[tr[tn].u0].d0 = tn;		      
+		    }
+		  
+		  tr[t].usave = tr[tn].usave = 0;
+		}
+	      else		/* No usave.... simple case */
+		{
+		  tr[tn].u0 = tr[t].u1;
+		  tr[t].u1 = tr[tn].u1 = -1;
+		  tr[tr[tn].u0].d0 = tn;
+		}
+	    }
+	  else 
+	    {			/* fresh seg. or upward cusp */
+	      int tmp_u = tr[t].u0;
+	      int td0, td1;
+	      if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp; 
+		  ((td1 = tr[tmp_u].d1) &gt; 0))
+		{		/* upward cusp */
+		  if ((tr[td0].rseg &gt; 0) &amp;&amp;
+		      !is_left_of(tr[td0].rseg, &amp;s.v1))
+		    {
+		      tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
+		      tr[tr[tn].u0].d1 = tn;
+		    }
+		  else 
+		    {
+		      tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
+		      tr[tr[t].u0].d0 = t;
+		    }
+		}
+	      else		/* fresh segment */
+		{
+		  tr[tr[t].u0].d0 = t;
+		  tr[tr[t].u0].d1 = tn;
+		}
+	    }
+	  
+	  if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp; 
+	      FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot)
+	    {		/* bottom forms a triangle */
+	      int tmpseg;
+
+	      if (is_swapped)	
+		tmptriseg = seg[segnum].prev;
+	      else
+		tmptriseg = seg[segnum].next;
+
+	      if ((tmpseg &gt; 0) &amp;&amp; is_left_of(tmpseg, &amp;s.v0))
+		{
+		  /* L-R downward cusp */
+		  tr[tr[t].d1].u0 = t;
+		  tr[tn].d0 = tr[tn].d1 = -1;
+		}
+	      else
+		{
+		  /* R-L downward cusp */
+		  tr[tr[tn].d1].u1 = tn;
+		  tr[t].d0 = tr[t].d1 = -1;
+		}
+	    }		
+	  else
+	    {
+	      if ((tr[tr[t].d1].u0 &gt; 0) &amp;&amp; (tr[tr[t].d1].u1 &gt; 0))
+		{
+		  if (tr[tr[t].d1].u0 == t) /* passes thru LHS */
+		    {
+		      tr[tr[t].d1].usave = tr[tr[t].d1].u1;
+		      tr[tr[t].d1].uside = S_LEFT;
+		    }
+		  else
+		    {
+		      tr[tr[t].d1].usave = tr[tr[t].d1].u0;
+		      tr[tr[t].d1].uside = S_RIGHT;
+		    }		    
+		}
+	      tr[tr[t].d1].u0 = t;
+	      tr[tr[t].d1].u1 = tn;
+	    }
+	  
+	  t = tr[t].d1;
+	}
+
+      /* two trapezoids below. Find out which one is intersected by */
+      /* this segment and proceed down that one */
+      
+      else
+	{
+	  int tmpseg = tr[tr[t].d0].rseg;
+	  double y0, yt;
+	  point_t tmppt;
+	  int tnext, i_d0, i_d1;
+
+	  i_d0 = i_d1 = FALSE;
+	  if (FP_EQUAL(tr[t].lo.y, s.v0.y))
+	    {
+	      if (tr[t].lo.x &gt; s.v0.x)
+		i_d0 = TRUE;
+	      else
+		i_d1 = TRUE;
+	    }
+	  else
+	    {
+	      tmppt.y = y0 = tr[t].lo.y;
+	      yt = (y0 - s.v0.y)/(s.v1.y - s.v0.y);
+	      tmppt.x = s.v0.x + yt * (s.v1.x - s.v0.x);
+	      
+	      if (_less_than(&amp;tmppt, &amp;tr[t].lo))
+		i_d0 = TRUE;
+	      else
+		i_d1 = TRUE;
+	    }
+	  
+	  /* check continuity from the top so that the lower-neighbour */
+	  /* values are properly filled for the upper trapezoid */
+
+	  if ((tr[t].u0 &gt; 0) &amp;&amp; (tr[t].u1 &gt; 0))
+	    {			/* continuation of a chain from abv. */
+	      if (tr[t].usave &gt; 0) /* three upper neighbours */
+		{
+		  if (tr[t].uside == S_LEFT)
+		    {
+		      tr[tn].u0 = tr[t].u1;
+		      tr[t].u1 = -1;
+		      tr[tn].u1 = tr[t].usave;
+		      
+		      tr[tr[t].u0].d0 = t;
+		      tr[tr[tn].u0].d0 = tn;
+		      tr[tr[tn].u1].d0 = tn;
+		    }
+		  else		/* intersects in the right */
+		    {
+		      tr[tn].u1 = -1;
+		      tr[tn].u0 = tr[t].u1;
+		      tr[t].u1 = tr[t].u0;
+		      tr[t].u0 = tr[t].usave;
+
+		      tr[tr[t].u0].d0 = t;
+		      tr[tr[t].u1].d0 = t;
+		      tr[tr[tn].u0].d0 = tn;		      
+		    }
+		  
+		  tr[t].usave = tr[tn].usave = 0;
+		}
+	      else		/* No usave.... simple case */
+		{
+		  tr[tn].u0 = tr[t].u1;
+		  tr[tn].u1 = -1;
+		  tr[t].u1 = -1;
+		  tr[tr[tn].u0].d0 = tn;
+		}
+	    }
+	  else 
+	    {			/* fresh seg. or upward cusp */
+	      int tmp_u = tr[t].u0;
+	      int td0, td1;
+	      if (((td0 = tr[tmp_u].d0) &gt; 0) &amp;&amp; 
+		  ((td1 = tr[tmp_u].d1) &gt; 0))
+		{		/* upward cusp */
+		  if ((tr[td0].rseg &gt; 0) &amp;&amp;
+		      !is_left_of(tr[td0].rseg, &amp;s.v1))
+		    {
+		      tr[t].u0 = tr[t].u1 = tr[tn].u1 = -1;
+		      tr[tr[tn].u0].d1 = tn;
+		    }
+		  else 
+		    {
+		      tr[tn].u0 = tr[tn].u1 = tr[t].u1 = -1;
+		      tr[tr[t].u0].d0 = t;
+		    }
+		}
+	      else		/* fresh segment */
+		{
+		  tr[tr[t].u0].d0 = t;
+		  tr[tr[t].u0].d1 = tn;
+		}
+	    }
+	  
+	  if (FP_EQUAL(tr[t].lo.y, tr[tlast].lo.y) &amp;&amp; 
+	      FP_EQUAL(tr[t].lo.x, tr[tlast].lo.x) &amp;&amp; tribot)
+	    {
+	      /* this case arises only at the lowest trapezoid.. i.e.
+		 tlast, if the lower endpoint of the segment is
+		 already inserted in the structure */
+	      
+	      tr[tr[t].d0].u0 = t;
+	      tr[tr[t].d0].u1 = -1;
+	      tr[tr[t].d1].u0 = tn;
+	      tr[tr[t].d1].u1 = -1;
+
+	      tr[tn].d0 = tr[t].d1;
+	      tr[t].d1 = tr[tn].d1 = -1;
+	      
+	      tnext = tr[t].d1;	      
+	    }
+	  else if (i_d0)
+				/* intersecting d0 */
+	    {
+	      tr[tr[t].d0].u0 = t;
+	      tr[tr[t].d0].u1 = tn;
+	      tr[tr[t].d1].u0 = tn;
+	      tr[tr[t].d1].u1 = -1;
+	      
+	      /* new code to determine the bottom neighbours of the */
+	      /* newly partitioned trapezoid */
+	      
+	      tr[t].d1 = -1;
+
+	      tnext = tr[t].d0;
+	    }
+	  else			/* intersecting d1 */
+	    {
+	      tr[tr[t].d0].u0 = t;
+	      tr[tr[t].d0].u1 = -1;
+	      tr[tr[t].d1].u0 = t;
+	      tr[tr[t].d1].u1 = tn;
+
+	      /* new code to determine the bottom neighbours of the */
+	      /* newly partitioned trapezoid */
+	      
+	      tr[tn].d0 = tr[t].d1;
+	      tr[tn].d1 = -1;
+	      
+	      tnext = tr[t].d1;
+	    }	    
+	  
+	  t = tnext;
+	}
+      
+      tr[t_sav].rseg = tr[tn_sav].lseg  = segnum;
+    } /* end-while */
+  
+  /* Now combine those trapezoids which share common segments. We can */
+  /* use the pointers to the parent to connect these together. This */
+  /* works only because all these new trapezoids have been formed */
+  /* due to splitting by the segment, and hence have only one parent */
+
+  tfirstl = tfirst; 
+  tlastl = tlast;
+  merge_trapezoids(segnum, tfirstl, tlastl, S_LEFT);
+  merge_trapezoids(segnum, tfirstr, tlastr, S_RIGHT);
+
+  seg[segnum].is_inserted = TRUE;
+  return 0;
+}
+
+
+/* Update the roots stored for each of the endpoints of the segment.
+ * This is done to speed up the location-query for the endpoint when
+ * the segment is inserted into the trapezoidation subsequently
+ */
+static int find_new_roots(segnum)
+     int segnum;
+{
+  segment_t *s = &amp;seg[segnum];
+  
+  if (s-&gt;is_inserted)
+    return 0;
+
+  s-&gt;root0 = locate_endpoint(&amp;s-&gt;v0, &amp;s-&gt;v1, s-&gt;root0);
+  s-&gt;root0 = tr[s-&gt;root0].sink;
+
+  s-&gt;root1 = locate_endpoint(&amp;s-&gt;v1, &amp;s-&gt;v0, s-&gt;root1);
+  s-&gt;root1 = tr[s-&gt;root1].sink;  
+  return 0;
+}
+
+
+/* Main routine to perform trapezoidation */
+int construct_trapezoids(nseg)
+     int nseg;
+{
+  register int i;
+  int root, h;
+  
+  /* Add the first segment and get the query structure and trapezoid */
+  /* list initialised */
+
+  root = init_query_structure(choose_segment());
+
+  for (i = 1; i &lt;= nseg; i++)
+    seg[i].root0 = seg[i].root1 = root;
+  
+  for (h = 1; h &lt;= math_logstar_n(nseg); h++)
+    {
+      for (i = math_N(nseg, h -1) + 1; i &lt;= math_N(nseg, h); i++)
+	add_segment(choose_segment());
+      
+      /* Find a new root for each of the segment endpoints */
+      for (i = 1; i &lt;= nseg; i++)
+	find_new_roots(i);
+    }
+  
+  for (i = math_N(nseg, math_logstar_n(nseg)) + 1; i &lt;= nseg; i++)
+    add_segment(choose_segment());
+
+  return 0;
+}
+
+

Added: trunk/client/sei_interface.h
===================================================================
--- trunk/client/sei_interface.h	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/client/sei_interface.h	2006-02-17 14:47:50 UTC (rev 75)
@@ -0,0 +1,10 @@
+#ifndef __interface_h
+#define __interface_h
+
+#define TRUE 1
+#define FALSE 0
+
+extern int triangulate_polygon(int, int *, double (*)[2], int (*)[3]);
+extern int is_point_inside_polygon(double *);
+
+#endif /* __interface_h */

Added: trunk/client/sei_misc.c
===================================================================
--- trunk/client/sei_misc.c	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/client/sei_misc.c	2006-02-17 14:47:50 UTC (rev 75)
@@ -0,0 +1,75 @@
+#include &lt;sei_triangulate.h&gt;
+#include &lt;sys/time.h&gt;
+#include &lt;math.h&gt;
+
+
+static int choose_idx;
+static int permute[SEGSIZE];
+double mlog2(double x) {
+  return log(x)/log(2);
+}
+
+/* Generate a random permutation of the segments 1..n */
+int generate_random_ordering(n)
+     int n;
+{
+  struct timeval tval;
+  struct timezone tzone;
+  register int i;
+  int m, st[SEGSIZE], *p;
+  
+  choose_idx = 1;
+  gettimeofday(&amp;tval, &amp;tzone);
+  srand48(tval.tv_sec);
+
+  for (i = 0; i &lt;= n; i++)
+    st[i] = i;
+
+  p = st;
+  for (i = 1; i &lt;= n; i++, p++)
+    {
+      m = lrand48() % (n + 1 - i) + 1;
+      permute[i] = p[m];
+      if (m != 1)
+	p[m] = p[1];
+    }
+  return 0;
+}
+
+  
+/* Return the next segment in the generated random ordering of all the */
+/* segments in S */
+int choose_segment()
+{
+  int i;
+
+  errds(VLOW,&quot;sei:choose_segment()&quot;,&quot;%d&quot;, permute[choose_idx]);
+  return permute[choose_idx++];
+}
+
+/* Get log*n for given n */
+int math_logstar_n(n)
+     int n;
+{
+  register int i;
+  double v;
+  
+  for (i = 0, v = (double) n; v &gt;= 1; i++)
+    v = mlog2(v);
+  
+  return (i - 1);
+}
+  
+
+int math_N(n, h)
+     int n;
+     int h;
+{
+  register int i;
+  double v;
+
+  for (i = 0, v = (int) n; i &lt; h; i++)
+    v = mlog2(v);
+  
+  return (int) ceil((double) 1.0*n/v);
+}

Added: trunk/client/sei_monotone.c
===================================================================
--- trunk/client/sei_monotone.c	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/client/sei_monotone.c	2006-02-17 14:47:50 UTC (rev 75)
@@ -0,0 +1,718 @@
+#include &lt;sei_triangulate.h&gt;
+#include &lt;math.h&gt;
+
+#define CROSS_SINE(v0, v1) ((v0).x * (v1).y - (v1).x * (v0).y)
+#define LENGTH(v0) (sqrt((v0).x * (v0).x + (v0).y * (v0).y))
+
+static monchain_t mchain[TRSIZE]; /* Table to hold all the monotone */
+				  /* polygons . Each monotone polygon */
+				  /* is a circularly linked list */
+
+static vertexchain_t vert[SEGSIZE]; /* chain init. information. This */
+				    /* is used to decide which */
+				    /* monotone polygon to split if */
+				    /* there are several other */
+				    /* polygons touching at the same */
+				    /* vertex  */
+
+static int mon[SEGSIZE];	/* contains position of any vertex in */
+				/* the monotone chain for the polygon */
+static int visited[TRSIZE];
+static int chain_idx, op_idx, mon_idx;
+
+
+static int triangulate_single_polygon(int, int, int, int (*)[3]);
+static int traverse_polygon(int, int, int, int);
+
+/* Function returns TRUE if the trapezoid lies inside the polygon */
+static int inside_polygon(t)
+     trap_t *t;
+{
+  int rseg = t-&gt;rseg;
+
+  if (t-&gt;state == ST_INVALID)
+    return 0;
+
+  if ((t-&gt;lseg &lt;= 0) || (t-&gt;rseg &lt;= 0))
+    return 0;
+  
+  if (((t-&gt;u0 &lt;= 0) &amp;&amp; (t-&gt;u1 &lt;= 0)) || 
+      ((t-&gt;d0 &lt;= 0) &amp;&amp; (t-&gt;d1 &lt;= 0))) /* triangle */
+    return (_greater_than(&amp;seg[rseg].v1, &amp;seg[rseg].v0));
+  
+  return 0;
+}
+
+
+/* return a new mon structure from the table */
+static int newmon()
+{
+  return ++mon_idx;
+}
+
+
+/* return a new chain element from the table */
+static int new_chain_element()
+{
+  return ++chain_idx;
+}
+
+
+static double get_angle(vp0, vpnext, vp1)
+     point_t *vp0;
+     point_t *vpnext;
+     point_t *vp1;
+{
+  point_t v0, v1;
+  
+  v0.x = vpnext-&gt;x - vp0-&gt;x;
+  v0.y = vpnext-&gt;y - vp0-&gt;y;
+
+  v1.x = vp1-&gt;x - vp0-&gt;x;
+  v1.y = vp1-&gt;y - vp0-&gt;y;
+
+  if (CROSS_SINE(v0, v1) &gt;= 0)	/* sine is positive */
+    return DOT(v0, v1)/LENGTH(v0)/LENGTH(v1);
+  else
+    return (-1.0 * DOT(v0, v1)/LENGTH(v0)/LENGTH(v1) - 2);
+}
+
+
+/* (v0, v1) is the new diagonal to be added to the polygon. Find which */
+/* chain to use and return the positions of v0 and v1 in p and q */ 
+static int get_vertex_positions(v0, v1, ip, iq)
+     int v0;
+     int v1;
+     int *ip;
+     int *iq;
+{
+  vertexchain_t *vp0, *vp1;
+  register int i;
+  double angle, temp;
+  int tp, tq;
+
+  vp0 = &amp;vert[v0];
+  vp1 = &amp;vert[v1];
+  
+  /* p is identified as follows. Scan from (v0, v1) rightwards till */
+  /* you hit the first segment starting from v0. That chain is the */
+  /* chain of our interest */
+  
+  angle = -4.0;
+  for (i = 0; i &lt; 4; i++)
+    {
+      if (vp0-&gt;vnext[i] &lt;= 0)
+	continue;
+      if ((temp = get_angle(&amp;vp0-&gt;pt, &amp;(vert[vp0-&gt;vnext[i]].pt), 
+			    &amp;vp1-&gt;pt)) &gt; angle)
+	{
+	  angle = temp;
+	  tp = i;
+	}
+    }
+
+  *ip = tp;
+
+  /* Do similar actions for q */
+
+  angle = -4.0;
+  for (i = 0; i &lt; 4; i++)
+    {
+      if (vp1-&gt;vnext[i] &lt;= 0)
+	continue;      
+      if ((temp = get_angle(&amp;vp1-&gt;pt, &amp;(vert[vp1-&gt;vnext[i]].pt), 
+			    &amp;vp0-&gt;pt)) &gt; angle)
+	{
+	  angle = temp;
+	  tq = i;
+	}
+    }
+
+  *iq = tq;
+
+  return 0;
+}
+
+  
+/* v0 and v1 are specified in anti-clockwise order with respect to 
+ * the current monotone polygon mcur. Split the current polygon into 
+ * two polygons using the diagonal (v0, v1) 
+ */
+static int make_new_monotone_poly(mcur, v0, v1)
+     int mcur;
+     int v0;
+     int v1;
+{
+  int p, q, ip, iq;
+  int mnew = newmon();
+  int i, j, nf0, nf1;
+  vertexchain_t *vp0, *vp1;
+  
+  vp0 = &amp;vert[v0];
+  vp1 = &amp;vert[v1];
+
+  get_vertex_positions(v0, v1, &amp;ip, &amp;iq);
+
+  p = vp0-&gt;vpos[ip];
+  q = vp1-&gt;vpos[iq];
+
+  /* At this stage, we have got the positions of v0 and v1 in the */
+  /* desired chain. Now modify the linked lists */
+
+  i = new_chain_element();	/* for the new list */
+  j = new_chain_element();
+
+  mchain[i].vnum = v0;
+  mchain[j].vnum = v1;
+
+  mchain[i].next = mchain[p].next;
+  mchain[mchain[p].next].prev = i;
+  mchain[i].prev = j;
+  mchain[j].next = i;
+  mchain[j].prev = mchain[q].prev;
+  mchain[mchain[q].prev].next = j;
+
+  mchain[p].next = q;
+  mchain[q].prev = p;
+
+  nf0 = vp0-&gt;nextfree;
+  nf1 = vp1-&gt;nextfree;
+
+  vp0-&gt;vnext[ip] = v1;
+
+  vp0-&gt;vpos[nf0] = i;
+  vp0-&gt;vnext[nf0] = mchain[mchain[i].next].vnum;
+  vp1-&gt;vpos[nf1] = j;
+  vp1-&gt;vnext[nf1] = v0;
+
+  vp0-&gt;nextfree++;
+  vp1-&gt;nextfree++;
+
+  errds(VLOW,&quot;sei:make_poly()&quot;,&quot;: mcur = %d, (v0, v1) = (%d, %d)&quot;, 			
+	  mcur, v0, v1);
+  errds(VLOW,&quot;sei:make_poly()&quot;,&quot;next posns = (p, q) = (%d, %d)&quot;, p, q);
+
+  mon[mcur] = p;
+  mon[mnew] = i;
+  return mnew;
+}
+
+/* Main routine to get monotone polygons from the trapezoidation of 
+ * the polygon.
+ */
+
+int monotonate_trapezoids(n)
+     int n;
+{
+  register int i;
+  int tr_start;
+
+  memset((void *)vert, 0, sizeof(vert));
+  memset((void *)visited, 0, sizeof(visited));
+  memset((void *)mchain, 0, sizeof(mchain));
+  memset((void *)mon, 0, sizeof(mon));
+  
+  /* First locate a trapezoid which lies inside the polygon */
+  /* and which is triangular */
+  for (i = 0; i &lt; TRSIZE; i++)
+    if (inside_polygon(&amp;tr[i]))
+      break;
+  tr_start = i;
+  
+  /* Initialise the mon data-structure and start spanning all the */
+  /* trapezoids within the polygon */
+
+#if 0
+  for (i = 1; i &lt;= n; i++)
+    {
+      mchain[i].prev = i - 1;
+      mchain[i].next = i + 1;
+      mchain[i].vnum = i;
+      vert[i].pt = seg[i].v0;
+      vert[i].vnext[0] = i + 1;	/* next vertex */
+      vert[i].vpos[0] = i;	/* locn. of next vertex */
+      vert[i].nextfree = 1;
+    }
+  mchain[1].prev = n;
+  mchain[n].next = 1;
+  vert[n].vnext[0] = 1;
+  vert[n].vpos[0] = n;
+  chain_idx = n;
+  mon_idx = 0;
+  mon[0] = 1;			/* position of any vertex in the first */
+				/* chain  */
+
+#else
+
+  for (i = 1; i &lt;= n; i++)
+    {
+      mchain[i].prev = seg[i].prev;
+      mchain[i].next = seg[i].next;
+      mchain[i].vnum = i;
+      vert[i].pt = seg[i].v0;
+      vert[i].vnext[0] = seg[i].next; /* next vertex */
+      vert[i].vpos[0] = i;	/* locn. of next vertex */
+      vert[i].nextfree = 1;
+    }
+
+  chain_idx = n;
+  mon_idx = 0;
+  mon[0] = 1;			/* position of any vertex in the first */
+				/* chain  */
+
+#endif
+  
+  /* traverse the polygon */
+  if (tr[tr_start].u0 &gt; 0)
+    traverse_polygon(0, tr_start, tr[tr_start].u0, TR_FROM_UP);
+  else if (tr[tr_start].d0 &gt; 0)
+    traverse_polygon(0, tr_start, tr[tr_start].d0, TR_FROM_DN);
+  
+  /* return the number of polygons created */
+  return newmon();
+}
+
+
+/* recursively visit all the trapezoids */
+static int traverse_polygon(mcur, trnum, from, dir)
+     int mcur;
+     int trnum;
+     int from;
+     int dir;
+{
+  trap_t *t = &amp;tr[trnum];
+  int howsplit, mnew;
+  int v0, v1, v0next, v1next;
+  int retval, tmp;
+  int do_switch = FALSE;
+
+  if ((trnum &lt;= 0) || visited[trnum])
+    return 0;
+
+  visited[trnum] = TRUE;
+  
+  /* We have much more information available here. */
+  /* rseg: goes upwards   */
+  /* lseg: goes downwards */
+
+  /* Initially assume that dir = TR_FROM_DN (from the left) */
+  /* Switch v0 and v1 if necessary afterwards */
+
+
+  /* special cases for triangles with cusps at the opposite ends. */
+  /* take care of this first */
+  if ((t-&gt;u0 &lt;= 0) &amp;&amp; (t-&gt;u1 &lt;= 0))
+    {
+      if ((t-&gt;d0 &gt; 0) &amp;&amp; (t-&gt;d1 &gt; 0)) /* downward opening triangle */
+	{
+	  v0 = tr[t-&gt;d1].lseg;
+	  v1 = t-&gt;lseg;
+	  if (from == t-&gt;d1)
+	    {
+	      do_switch = TRUE;
+	      mnew = make_new_monotone_poly(mcur, v1, v0);
+	      traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+	      traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);	    
+	    }
+	  else
+	    {
+	      mnew = make_new_monotone_poly(mcur, v0, v1);
+	      traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+	      traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+	    }
+	}
+      else
+	{
+	  retval = SP_NOSPLIT;	/* Just traverse all neighbours */
+	  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+	  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+	  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+	  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+	}
+    }
+  
+  else if ((t-&gt;d0 &lt;= 0) &amp;&amp; (t-&gt;d1 &lt;= 0))
+    {
+      if ((t-&gt;u0 &gt; 0) &amp;&amp; (t-&gt;u1 &gt; 0)) /* upward opening triangle */
+	{
+	  v0 = t-&gt;rseg;
+	  v1 = tr[t-&gt;u0].rseg;
+	  if (from == t-&gt;u1)
+	    {
+	      do_switch = TRUE;
+	      mnew = make_new_monotone_poly(mcur, v1, v0);
+	      traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+	      traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);	    
+	    }
+	  else
+	    {
+	      mnew = make_new_monotone_poly(mcur, v0, v1);
+	      traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+	      traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+	    }
+	}
+      else
+	{
+	  retval = SP_NOSPLIT;	/* Just traverse all neighbours */
+	  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+	  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+	  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+	  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+	}
+    }
+  
+  else if ((t-&gt;u0 &gt; 0) &amp;&amp; (t-&gt;u1 &gt; 0)) 
+    {
+      if ((t-&gt;d0 &gt; 0) &amp;&amp; (t-&gt;d1 &gt; 0)) /* downward + upward cusps */
+	{
+	  v0 = tr[t-&gt;d1].lseg;
+	  v1 = tr[t-&gt;u0].rseg;
+	  retval = SP_2UP_2DN;
+	  if (((dir == TR_FROM_DN) &amp;&amp; (t-&gt;d1 == from)) ||
+	      ((dir == TR_FROM_UP) &amp;&amp; (t-&gt;u1 == from)))
+	    {
+	      do_switch = TRUE;
+	      mnew = make_new_monotone_poly(mcur, v1, v0);
+	      traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+	      traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+	      traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+	      traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+	    }
+	  else
+	    {
+	      mnew = make_new_monotone_poly(mcur, v0, v1);
+	      traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+	      traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+	      traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+	      traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);	      
+	    }
+	}
+      else			/* only downward cusp */
+	{
+	  if (_equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;lseg].v1))
+	    {
+	      v0 = tr[t-&gt;u0].rseg;
+	      v1 = seg[t-&gt;lseg].next;
+
+	      retval = SP_2UP_LEFT;
+	      if ((dir == TR_FROM_UP) &amp;&amp; (t-&gt;u0 == from))
+		{
+		  do_switch = TRUE;
+		  mnew = make_new_monotone_poly(mcur, v1, v0);
+		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+		}
+	      else
+		{
+		  mnew = make_new_monotone_poly(mcur, v0, v1);
+		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+		}
+	    }
+	  else
+	    {
+	      v0 = t-&gt;rseg;
+	      v1 = tr[t-&gt;u0].rseg;	
+	      retval = SP_2UP_RIGHT;
+	      if ((dir == TR_FROM_UP) &amp;&amp; (t-&gt;u1 == from))
+		{
+		  do_switch = TRUE;
+		  mnew = make_new_monotone_poly(mcur, v1, v0);
+		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+		}
+	      else
+		{
+		  mnew = make_new_monotone_poly(mcur, v0, v1);
+		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+		}
+	    }
+	}
+    }
+  else if ((t-&gt;u0 &gt; 0) || (t-&gt;u1 &gt; 0)) /* no downward cusp */
+    {
+      if ((t-&gt;d0 &gt; 0) &amp;&amp; (t-&gt;d1 &gt; 0)) /* only upward cusp */
+	{
+	  if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;lseg].v0))
+	    {
+	      v0 = tr[t-&gt;d1].lseg;
+	      v1 = t-&gt;lseg;
+	      retval = SP_2DN_LEFT;
+	      if (!((dir == TR_FROM_DN) &amp;&amp; (t-&gt;d0 == from)))
+		{
+		  do_switch = TRUE;
+		  mnew = make_new_monotone_poly(mcur, v1, v0);
+		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+		}
+	      else
+		{
+		  mnew = make_new_monotone_poly(mcur, v0, v1);
+		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);	      
+		}
+	    }
+	  else
+	    {
+	      v0 = tr[t-&gt;d1].lseg;
+	      v1 = seg[t-&gt;rseg].next;
+
+	      retval = SP_2DN_RIGHT;	    
+	      if ((dir == TR_FROM_DN) &amp;&amp; (t-&gt;d1 == from))
+		{
+		  do_switch = TRUE;
+		  mnew = make_new_monotone_poly(mcur, v1, v0);
+		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+		}
+	      else
+		{
+		  mnew = make_new_monotone_poly(mcur, v0, v1);
+		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+		}
+	    }
+	}
+      else			/* no cusp */
+	{
+	  if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;lseg].v0) &amp;&amp;
+	      _equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;rseg].v0))
+	    {
+	      v0 = t-&gt;rseg;
+	      v1 = t-&gt;lseg;
+	      retval = SP_SIMPLE_LRDN;
+	      if (dir == TR_FROM_UP)
+		{
+		  do_switch = TRUE;
+		  mnew = make_new_monotone_poly(mcur, v1, v0);
+		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+		}
+	      else
+		{
+		  mnew = make_new_monotone_poly(mcur, v0, v1);
+		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+		}
+	    }
+	  else if (_equal_to(&amp;t-&gt;hi, &amp;seg[t-&gt;rseg].v1) &amp;&amp;
+		   _equal_to(&amp;t-&gt;lo, &amp;seg[t-&gt;lseg].v1))
+	    {
+	      v0 = seg[t-&gt;rseg].next;
+	      v1 = seg[t-&gt;lseg].next;
+
+	      retval = SP_SIMPLE_LRUP;
+	      if (dir == TR_FROM_UP)
+		{
+		  do_switch = TRUE;
+		  mnew = make_new_monotone_poly(mcur, v1, v0);
+		  traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;d0, trnum, TR_FROM_UP);
+		}
+	      else
+		{
+		  mnew = make_new_monotone_poly(mcur, v0, v1);
+		  traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);
+		  traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+		  traverse_polygon(mnew, t-&gt;u0, trnum, TR_FROM_DN);
+		  traverse_polygon(mnew, t-&gt;u1, trnum, TR_FROM_DN);
+		}
+	    }
+	  else			/* no split possible */
+	    {
+	      retval = SP_NOSPLIT;
+	      traverse_polygon(mcur, t-&gt;u0, trnum, TR_FROM_DN);
+	      traverse_polygon(mcur, t-&gt;d0, trnum, TR_FROM_UP);
+	      traverse_polygon(mcur, t-&gt;u1, trnum, TR_FROM_DN);
+	      traverse_polygon(mcur, t-&gt;d1, trnum, TR_FROM_UP);	      	      
+	    }
+	}
+    }
+
+  return retval;
+}
+
+
+/* For each monotone polygon, find the ymax and ymin (to determine the */
+/* two y-monotone chains) and pass on this monotone polygon for greedy */
+/* triangulation. */
+/* Take care not to triangulate duplicate monotone polygons */
+
+int triangulate_monotone_polygons(nvert, nmonpoly, op)
+     int nvert;
+     int nmonpoly;
+     int op[][3];
+{
+  register int i;
+  point_t ymax, ymin;
+  int p, vfirst, posmax, posmin, v;
+  int vcount, processed;
+
+
+  op_idx = 0;
+  for (i = 0; i &lt; nmonpoly; i++)
+    {
+      vcount = 1;
+      processed = FALSE;
+      vfirst = mchain[mon[i]].vnum;
+      ymax = ymin = vert[vfirst].pt;
+      posmax = posmin = mon[i];
+      mchain[mon[i]].marked = TRUE;
+      p = mchain[mon[i]].next;
+      while ((v = mchain[p].vnum) != vfirst)
+	{
+	 if (mchain[p].marked)
+	   {
+	     processed = TRUE;
+	     break;		/* break from while */
+	   }
+	 else
+	   mchain[p].marked = TRUE;
+
+	  if (_greater_than(&amp;vert[v].pt, &amp;ymax))
+	    {
+	      ymax = vert[v].pt;
+	      posmax = p;
+	    }
+	  if (_less_than(&amp;vert[v].pt, &amp;ymin))
+	    {
+	      ymin = vert[v].pt;
+	      posmin = p;
+	    }
+	  p = mchain[p].next;
+	  vcount++;
+       }
+
+      if (processed)		/* Go to next polygon */
+	continue;
+      
+      if (vcount == 3)		/* already a triangle */
+	{
+	  op[op_idx][0] = mchain[p].vnum;
+	  op[op_idx][1] = mchain[mchain[p].next].vnum;
+	  op[op_idx][2] = mchain[mchain[p].prev].vnum;
+	  op_idx++;
+	}
+      else			/* triangulate the polygon */
+	{
+	  v = mchain[mchain[posmax].next].vnum;
+	  if (_equal_to(&amp;vert[v].pt, &amp;ymin))
+	    {			/* LHS is a single line */
+	      triangulate_single_polygon(nvert, posmax, TRI_LHS, op);
+	    }
+	  else
+	    triangulate_single_polygon(nvert, posmax, TRI_RHS, op);
+	}
+    }
+  
+  for (i = 0; i &lt; op_idx; i++)
+    errds(VLOW,&quot;sei:triangulate_monotone_polygons()&quot;,&quot;tri #%d: (%d, %d, %d)\n&quot;, i, op[i][0], op[i][1],
+	   op[i][2]);
+  return op_idx;
+}
+
+
+/* A greedy corner-cutting algorithm to triangulate a y-monotone 
+ * polygon in O(n) time.
+ * Joseph O-Rourke, Computational Geometry in C.
+ */
+static int triangulate_single_polygon(nvert, posmax, side, op)
+     int nvert;
+     int posmax;
+     int side;
+     int op[][3];
+{
+  register int v;
+  int rc[SEGSIZE], ri = 0;	/* reflex chain */
+  int endv, tmp, vpos;
+  
+  if (side == TRI_RHS)		/* RHS segment is a single segment */
+    {
+      rc[0] = mchain[posmax].vnum;
+      tmp = mchain[posmax].next;
+      rc[1] = mchain[tmp].vnum;
+      ri = 1;
+      
+      vpos = mchain[tmp].next;
+      v = mchain[vpos].vnum;
+      
+      if ((endv = mchain[mchain[posmax].prev].vnum) == 0)
+	endv = nvert;
+    }
+  else				/* LHS is a single segment */
+    {
+      tmp = mchain[posmax].next;
+      rc[0] = mchain[tmp].vnum;
+      tmp = mchain[tmp].next;
+      rc[1] = mchain[tmp].vnum;
+      ri = 1;
+
+      vpos = mchain[tmp].next;
+      v = mchain[vpos].vnum;
+
+      endv = mchain[posmax].vnum;
+    }
+  
+  while ((v != endv) || (ri &gt; 1))
+    {
+      if (ri &gt; 0)		/* reflex chain is non-empty */
+	{
+	  if (CROSS(vert[v].pt, vert[rc[ri - 1]].pt, 
+		    vert[rc[ri]].pt) &gt; 0)
+	    {			/* convex corner: cut if off */
+	      op[op_idx][0] = rc[ri - 1];
+	      op[op_idx][1] = rc[ri];
+	      op[op_idx][2] = v;
+	      op_idx++;	     
+	      ri--;
+	    }
+	  else		/* non-convex */
+	    {		/* add v to the chain */
+	      ri++;
+	      rc[ri] = v;
+	      vpos = mchain[vpos].next;
+	      v = mchain[vpos].vnum;
+	    }
+	}
+      else			/* reflex-chain empty: add v to the */
+	{			/* reflex chain and advance it  */
+	  rc[++ri] = v;
+	  vpos = mchain[vpos].next;
+	  v = mchain[vpos].vnum;
+	}
+    } /* end-while */
+  
+  /* reached the bottom vertex. Add in the triangle formed */
+  op[op_idx][0] = rc[ri - 1];
+  op[op_idx][1] = rc[ri];
+  op[op_idx][2] = v;
+  op_idx++;	     
+  ri--;
+  
+  return 0;
+}
+
+

Added: trunk/client/sei_tri.c
===================================================================
--- trunk/client/sei_tri.c	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/client/sei_tri.c	2006-02-17 14:47:50 UTC (rev 75)
@@ -0,0 +1,131 @@
+#include &lt;sei_triangulate.h&gt;
+#include &lt;sys/time.h&gt;
+
+
+static int initialise(n)
+     int n;
+{
+  register int i;
+
+  for (i = 1; i &lt;= n; i++)
+    seg[i].is_inserted = FALSE;
+
+  generate_random_ordering(n);
+  
+  return 0;
+}
+
+/* Input specified as contours.
+ * Outer contour must be anti-clockwise.
+ * All inner contours must be clockwise.
+ *  
+ * Every contour is specified by giving all its points in order. No
+ * point shoud be repeated. i.e. if the outer contour is a square,
+ * only the four distinct endpoints shopudl be specified in order.
+ *  
+ * ncontours: #contours
+ * cntr: An array describing the number of points in each
+ *	 contour. Thus, cntr[i] = #points in the i'th contour.
+ * vertices: Input array of vertices. Vertices for each contour
+ *           immediately follow those for previous one. Array location
+ *           vertices[0] must NOT be used (i.e. i/p starts from
+ *           vertices[1] instead. The output triangles are
+ *	     specified  w.r.t. the indices of these vertices.
+ * triangles: Output array to hold triangles.
+ *  
+ * Enough space must be allocated for all the arrays before calling
+ * this routine
+ */
+
+
+int sei_triangulate_polygon(ncontours, cntr, vertices, triangles)
+     int ncontours;
+     int cntr[];
+     double (*vertices)[2];
+     int (*triangles)[3];
+{
+  register int i;
+  int nmonpoly, ccount, npoints, genus;
+  int n;
+
+  memset((void *)seg, 0, sizeof(seg));
+  ccount = 0;
+  i = 1;
+  
+  while (ccount &lt; ncontours)
+    {
+      int j;
+      int first, last;
+
+      npoints = cntr[ccount];
+      first = i;
+      last = first + npoints - 1;
+      for (j = 0; j &lt; npoints; j++, i++)
+	{
+	  seg[i].v0.x = vertices[i][0];
+	  seg[i].v0.y = vertices[i][1];
+
+	  if (i == last)
+	    {
+	      seg[i].next = first;
+	      seg[i].prev = i-1;
+	      seg[i-1].v1 = seg[i].v0;
+	    }
+	  else if (i == first)
+	    {
+	      seg[i].next = i+1;
+	      seg[i].prev = last;
+	      seg[last].v1 = seg[i].v0;
+	    }
+	  else
+	    {
+	      seg[i].prev = i-1;
+	      seg[i].next = i+1;
+	      seg[i-1].v1 = seg[i].v0;
+	    }
+	  
+	  seg[i].is_inserted = FALSE;
+	}
+      
+      ccount++;
+    }
+  
+  genus = ncontours - 1;
+  n = i-1;
+
+  initialise(n);
+  construct_trapezoids(n);
+  nmonpoly = monotonate_trapezoids(n);
+  return(triangulate_monotone_polygons(n, nmonpoly, triangles));
+}
+
+
+/* This function returns TRUE or FALSE depending upon whether the 
+ * vertex is inside the polygon or not. The polygon must already have
+ * been triangulated before this routine is called.
+ * This routine will always detect all the points belonging to the 
+ * set (polygon-area - polygon-boundary). The return value for points 
+ * on the boundary is not consistent!!!
+ */
+
+int is_point_inside_polygon(vertex)
+     double vertex[2];
+{
+  point_t v;
+  int trnum, rseg;
+  trap_t *t;
+
+  v.x = vertex[0];
+  v.y = vertex[1];
+  
+  trnum = locate_endpoint(&amp;v, &amp;v, 1);
+  t = &amp;tr[trnum];
+  
+  if (t-&gt;state == ST_INVALID)
+    return FALSE;
+  
+  if ((t-&gt;lseg &lt;= 0) || (t-&gt;rseg &lt;= 0))
+    return FALSE;
+  rseg = t-&gt;rseg;
+  return _greater_than_equal_to(&amp;seg[rseg].v1, &amp;seg[rseg].v0);
+}

Added: trunk/client/sei_triangulate.h
===================================================================
--- trunk/client/sei_triangulate.h	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/client/sei_triangulate.h	2006-02-17 14:47:50 UTC (rev 75)
@@ -0,0 +1,163 @@
+#ifndef _triangulate_h
+#define _triangulate_h
+
+#include &lt;sys/types.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &quot;s3d.h&quot;
+#include &quot;s3dlib.h&quot;
+
+typedef struct {
+  double x, y;
+} point_t, vector_t;
+
+
+/* Segment attributes */
+
+typedef struct {	
+  point_t v0, v1;		/* two endpoints */
+  int is_inserted;		/* inserted in trapezoidation yet ? */
+  int root0, root1;		/* root nodes in Q */
+  int next;			/* Next logical segment */
+  int prev;			/* Previous segment */
+} segment_t;
+
+
+/* Trapezoid attributes */
+
+typedef struct {
+  int lseg, rseg;		/* two adjoining segments */
+  point_t hi, lo;		/* max/min y-values */
+  int u0, u1;
+  int d0, d1;
+  int sink;			/* pointer to corresponding in Q */
+  int usave, uside;		/* I forgot what this means */
+  int state;
+} trap_t;
+
+
+/* Node attributes for every node in the query structure */
+
+typedef struct {
+  int nodetype;			/* Y-node or S-node */
+  int segnum;
+  point_t yval;
+  int trnum;
+  int parent;			/* doubly linked DAG */
+  int left, right;		/* children */
+} node_t;
+
+
+typedef struct {
+  int vnum;
+  int next;			/* Circularly linked list  */
+  int prev;			/* describing the monotone */
+  int marked;			/* polygon */
+} monchain_t;			
+
+
+typedef struct {
+  point_t pt;
+  int vnext[4];			/* next vertices for the 4 chains */
+  int vpos[4];			/* position of v in the 4 chains */
+  int nextfree;
+} vertexchain_t;
+
+#ifdef DEBUG
+#undef DEBUG
+#endif
+/* Node types */
+
+#define T_X     1
+#define T_Y     2
+#define T_SINK  3
+
+
+#define SEGSIZE SEI_SS	/* max# of segments. Determines how */
+						/* many points can be specified as */
+						/* input. If your datasets have large */
+						/* number of points, increase this */
+						/* value accordingly. */
+
+#define QSIZE   8*SEGSIZE	/* maximum table sizes */
+#define TRSIZE  4*SEGSIZE	/* max# trapezoids */
+
+
+#define TRUE  1
+#define FALSE 0
+
+
+#define FIRSTPT 1		/* checking whether pt. is inserted */ 
+#define LASTPT  2
+
+
+#define INFINITY 1&lt;&lt;30
+#define C_EPS 1.0e-7		/* tolerance value: Used for making */
+							/* all decisions about collinearity or */
+							/* left/right of segment. Decrease */
+							/* this value if the input points are */
+							/* spaced very close together */
+
+
+#define S_LEFT 1		/* for merge-direction */
+#define S_RIGHT 2
+
+
+#define ST_VALID 1		/* for trapezium state */
+#define ST_INVALID 2
+
+
+#define SP_SIMPLE_LRUP 1	/* for splitting trapezoids */
+#define SP_SIMPLE_LRDN 2
+#define SP_2UP_2DN     3
+#define SP_2UP_LEFT    4
+#define SP_2UP_RIGHT   5
+#define SP_2DN_LEFT    6
+#define SP_2DN_RIGHT   7
+#define SP_NOSPLIT    -1	
+
+#define TR_FROM_UP 1		/* for traverse-direction */
+#define TR_FROM_DN 2
+
+#define TRI_LHS 1
+#define TRI_RHS 2
+
+
+#define MAX(a, b) (((a) &gt; (b)) ? (a) : (b))
+#define MIN(a, b) (((a) &lt; (b)) ? (a) : (b))
+
+#define CROSS(v0, v1, v2) (((v1).x - (v0).x)*((v2).y - (v0).y) - \
+			   ((v1).y - (v0).y)*((v2).x - (v0).x))
+
+#define DOT(v0, v1) ((v0).x * (v1).x + (v0).y * (v1).y)
+
+#define FP_EQUAL(s, t) (fabs(s - t) &lt;= C_EPS)
+
+
+
+/* Global variables */
+
+extern node_t qs[QSIZE];		/* Query structure */
+extern trap_t tr[TRSIZE];		/* Trapezoid structure */
+extern segment_t seg[SEGSIZE];		/* Segment table */
+
+
+/* Functions */
+
+extern int monotonate_trapezoids(int);
+extern int triangulate_monotone_polygons(int, int, int (*)[3]);
+
+extern int _greater_than(point_t *, point_t *);
+extern int _equal_to(point_t *, point_t *);
+extern int _greater_than_equal_to(point_t *, point_t *);
+extern int _less_than(point_t *, point_t *);
+extern int locate_endpoint(point_t *, point_t *, int);
+extern int construct_trapezoids(int);
+
+extern int generate_random_ordering(int);
+extern int choose_segment(void);
+extern int read_segments(char *, int *);
+extern int math_logstar_n(int);
+extern int math_N(int, int);
+
+#endif /* triangulate_h */

Deleted: trunk/client/tesselate.c
===================================================================
--- trunk/client/tesselate.c	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/client/tesselate.c	2006-02-17 14:47:50 UTC (rev 75)
@@ -1,153 +0,0 @@
-#include &lt;unistd.h&gt; /* sleep */
-
-#include &quot;s3d.h&quot;
-#include &quot;s3dlib.h&quot;
-
-static int _s3d_tesssub(struct tessp_t *t, struct t_buf *b,int s);
-static int _s3d_addtri(struct tessp_t *t, struct t_buf *b,int p, int i, int n);
-
-
-static void tessdebug(struct tessp_t *t, struct t_buf *b)
-{
-	int i,n,p;
-	for (i=0;i&lt;b-&gt;vn;i++)
-	{
-		n=t[i].next;
-		p=t[i].prev;
-		if ((i==n) &amp;&amp; (i==p))
-			dprintf(HIGH,&quot;[D]ebug %d %d %d [done]&quot;,p,i,n);
-		else
-			dprintf(HIGH,&quot;[D]ebug %d %d %d %3.3f %3.3f&quot;,p,i,n,b-&gt;vbuf[i*3]*10,b-&gt;vbuf[i*3+1]*10);
-	}
-}
-
-#define POINT_DIR(p,i,n) 	((b-&gt;vbuf[i*3]-b-&gt;vbuf[p*3]) * (b-&gt;vbuf[p*3+1]-b-&gt;vbuf[n*3+1]) - (b-&gt;vbuf[i*3+1]-b-&gt;vbuf[p*3+1]) * (b-&gt;vbuf[p*3]-b-&gt;vbuf[n*3]))
-static int _s3d_addtri(struct tessp_t *t, struct t_buf *b,int p, int i, int n)
-{
-	int j,jp,nn,jn,jp2;
-	float d1, d2, d3;
-	dprintf(HIGH,&quot;[P]rocessing polygon %d %d %d&quot;,p,i,n);
-	/* check if there is a point in the triangle ... */
-	for (j=0;j&lt;b-&gt;vn;j++)
-	{
-		if ((j!=i) &amp;&amp; (j!=n) &amp;&amp; (j!=p))
-		{
-			d1=POINT_DIR(p,i,j);
-			d2=POINT_DIR(i,n,j);
-			d3=POINT_DIR(n,p,j);
-			if ((d1&gt;0) &amp;&amp; (d2&gt;0) &amp;&amp; (d3&gt;0))
-					{
-						dprintf(HIGH,&quot;%d between, break!&quot;,j);
-						if (j==t[p].prev)
-						{
-							dprintf(HIGH,&quot;[I]solating %d (%d -&gt; %d)&quot;,p,j,i);
-							if (_s3d_addtri(t,b,j,p,i))
-							{
-								t[p].next=p; /* p is out now ... */
-								t[p].prev=p; 
-							}
-						} else if ((t[n].next)==j)
-						{
-							/* we only need one polygon here */
-							dprintf(HIGH,&quot;[I]solating %d (%d -&gt; %d)&quot;,n,i,j);
-							if (_s3d_addtri(t,b,i,n,j))
-							{
-								t[n].next=n; /* n is out now ... */
-								t[n].prev=n; 
-							}
-
-						} else {
-							jp=t[j].prev;
-							nn=t[n].next;
-							/* we need 2 polygons to split properly */
-							dprintf(HIGH,&quot;[1]rerouting (%d -&gt; %d)&quot;,i,j);
-							t[n].next=j;
-							t[j].prev=n;
-							_s3d_addtri(t,b,i,n,j);
-							jn=t[j].next;
-							jp2=t[j].prev;
-							dprintf(HIGH,&quot;[2]rerouting (%d -&gt; %d)&quot;,jp,n);
-							/* redo */
-							t[j].prev=jp;
-							t[n].next=nn;
-							
-							t[j].next=n;
-							t[n].prev=j;
-							_s3d_addtri(t,b,jp,j,n);
-							t[j].next=jn;
-							t[j].prev=jp2;
-						}
-						return(0);
-					}
-		}
-	}
-	/* there wasn't anything  between, we can savely build the polygon .... */
-	dprintf(HIGH,&quot;[B]uilding polygon %d %d %d [nr. %d]&quot;,p,i,n,b-&gt;pn);
-	t[p].next=n;
-	t[n].prev=p;
-	b-&gt;pbuf[b-&gt;pn*4]=p;
-	b-&gt;pbuf[b-&gt;pn*4+1]=i;
-	b-&gt;pbuf[b-&gt;pn*4+2]=n;
-	b-&gt;pbuf[b-&gt;pn*4+3]=0;
-	b-&gt;pn+=1;
-
-	return(1);
-}
-static int _s3d_tesssub(struct tessp_t *t, struct t_buf *b,int s)
-{
-	int i,n,p;
-	int good=0;
-	i=s;
-	while ((n=t[i].next)!=(p=t[i].prev)) /* while polygon n &gt; 3 */
-	{
-		dprintf(HIGH,&quot;[L]ooking at %d [[%d]] %d&quot;,p,i,n);
-		/* find direction */
-		if ((POINT_DIR(p,i,n))&gt;0)
-		{
-			good=1;
-			/* good direction */
-/*			dprintf(HIGH,&quot;direction correct, polygon possible!!&quot;);*/
-			if (_s3d_addtri(t,b,p,i,n))
-			{
-				/* regular out */
-				t[i].next=i;
-				t[i].prev=i; 
-			}
-/*			dprintf(HIGH,&quot;[F]inished polygon %d %d %d&quot;,p,i,n);*/
-		} else {
-			i=t[i].next;
-			if ((i==s) &amp;&amp; (good==0)) 
-			{
-				dprintf(HIGH,&quot;Everything is bad, returning&quot;);
-				return(-1);
-			}
-			dprintf(HIGH,&quot;sorry, bad direction, next one is %d&quot;,i);
-			/* bad direction */
-/*			done=0;*/
-		}
-		sleep(1);
-	}
-	/* handle the last line */
-	dprintf(HIGH,&quot;[L]ine handling %d %d %d&quot;,p,i,n);
-	t[i].next=i;
-	t[i].prev=i;
-	t[n].next=n;
-	t[n].prev=n;
-	return(0);
-}
-int _s3d_tesselate(struct tessp_t *t,struct t_buf *b)
-{
-	int i,g;
-	tessdebug(t,b);
-	b-&gt;pn=0;
-	do {
-		g=0;
-		for (i=0;i&lt;b-&gt;vn;i++) 
-		{ /* go through the points ... */
-			if (!(t[i].next==i)) /* looping to itself, nothing to do*/
-				g+=_s3d_tesssub(t,b,i); /* found unfinished polygon, starting here ... */
-		}
-	} while (g&gt;0);
-	dprintf(HIGH,&quot;tesselation done&quot;);
-	return(0);
-}

Modified: trunk/example/strtest.c
===================================================================
--- trunk/example/strtest.c	2006-02-16 23:59:44 UTC (rev 74)
+++ trunk/example/strtest.c	2006-02-17 14:47:50 UTC (rev 75)
@@ -18,8 +18,8 @@
 	if (!s3d_init(&amp;argc,&amp;argv,&quot;clock&quot;))	
 	{
 		s3d_select_font(&quot;vera&quot;);
-		o=s3d_draw_string(&quot;o&quot;,NULL);
-//		o=s3d_draw_string(&quot;T&quot;,NULL);
+		o=s3d_draw_string(&quot;The lazy fox is bored enough to jump over everything it sees. weird, isn't it?!&quot;,NULL); 
+/*		o=s3d_draw_string(&quot;i&quot;,NULL);*/
 		s3d_flags_on(o,S3D_OF_VISIBLE);
 
 		s3d_set_callback(S3D_EVENT_OBJ_CLICK,	(s3d_cb)stop);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000070.html">[S3d-svn] r74 - trunk/apps/olsrs3d
</A></li>
	<LI>Next message: <A HREF="000072.html">[S3d-svn] r76 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#71">[ date ]</a>
              <a href="thread.html#71">[ thread ]</a>
              <a href="subject.html#71">[ subject ]</a>
              <a href="author.html#71">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/s3d-svn">More information about the S3d-svn
mailing list</a><br>
</body></html>
