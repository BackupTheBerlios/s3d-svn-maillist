<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [S3d-svn] r86 - in trunk: . apps/dot_mcp apps/olsrs3d
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/s3d-svn/2006-February/index.html" >
   <LINK REL="made" HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r86%20-%20in%20trunk%3A%20.%20apps/dot_mcp%20apps/olsrs3d&In-Reply-To=%3C200602181301.k1ID1B4m000105%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000081.html">
   <LINK REL="Next"  HREF="000083.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[S3d-svn] r86 - in trunk: . apps/dot_mcp apps/olsrs3d</H1>
    <B>dotslash at BerliOS</B> 
    <A HREF="mailto:s3d-svn%40lists.berlios.de?Subject=Re%3A%20%5BS3d-svn%5D%20r86%20-%20in%20trunk%3A%20.%20apps/dot_mcp%20apps/olsrs3d&In-Reply-To=%3C200602181301.k1ID1B4m000105%40sheep.berlios.de%3E"
       TITLE="[S3d-svn] r86 - in trunk: . apps/dot_mcp apps/olsrs3d">dotslash at berlios.de
       </A><BR>
    <I>Sat Feb 18 14:01:11 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000081.html">[S3d-svn] r85 - in trunk: . client
</A></li>
        <LI>Next message: <A HREF="000083.html">[S3d-svn] r87 - in trunk: . client example
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#82">[ date ]</a>
              <a href="thread.html#82">[ thread ]</a>
              <a href="subject.html#82">[ subject ]</a>
              <a href="author.html#82">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dotslash
Date: 2006-02-18 14:01:04 +0100 (Sat, 18 Feb 2006)
New Revision: 86

Modified:
   trunk/
   trunk/ChangeLog
   trunk/apps/dot_mcp/dot_mcp.c
   trunk/apps/olsrs3d/main.c
   trunk/apps/olsrs3d/net.c
   trunk/apps/olsrs3d/process.c
Log:
 <A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">r111 at balthasar</A>:  dotslash | 2006-02-18 14:00:55 +0100
 - removed c++ style comments in olsrs3d
 - fixed dot_mcp
 



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:105
   + bf2c72c7-850b-0410-b9e4-c1fddb578f10:/s3d-trunk:111

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2006-02-17 23:21:36 UTC (rev 85)
+++ trunk/ChangeLog	2006-02-18 13:01:04 UTC (rev 86)
@@ -1,3 +1,5 @@
+2006-02-18	Simon Wunderlich - &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;	
+	- removed c++ styles in olsrs3d
 2006-02-17	Simon Wunderlich - &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/s3d-svn">dotslash at packetmixer.de</A>&gt;	
 	- gintl() and gints() added in 3dsread.c, hopefully
 	  improving endianess compatibility

Modified: trunk/apps/dot_mcp/dot_mcp.c
===================================================================
--- trunk/apps/dot_mcp/dot_mcp.c	2006-02-17 23:21:36 UTC (rev 85)
+++ trunk/apps/dot_mcp/dot_mcp.c	2006-02-18 13:01:04 UTC (rev 86)
@@ -351,10 +351,10 @@
 					1,1,1,0.2,
 					1,1,1,0.2,
 					1,1,1,0.2);*/
-		min_but=s3d_import_3ds_file(&quot;objs/cubeyholes.3ds&quot;);
-		rotate=s3d_import_3ds_file(&quot;objs/rotate.3ds&quot;);
-		close_but=s3d_import_3ds_file(&quot;objs/spikeybla.3ds&quot;);
-		sphere=s3d_import_3ds_file(&quot;objs/ringsystem.3ds&quot;);
+		min_but=s3d_import_3ds_file(&quot;cubeyholes.3ds&quot;);
+		rotate=s3d_import_3ds_file(&quot;rotate.3ds&quot;);
+		close_but=s3d_import_3ds_file(&quot;spikeybla.3ds&quot;);
+		sphere=s3d_import_3ds_file(&quot;ringsystem.3ds&quot;);
 		s3d_mainloop(mainloop);
 		s3d_quit();
 	}

Modified: trunk/apps/olsrs3d/main.c
===================================================================
--- trunk/apps/olsrs3d/main.c	2006-02-17 23:21:36 UTC (rev 85)
+++ trunk/apps/olsrs3d/main.c	2006-02-18 13:01:04 UTC (rev 86)
@@ -206,7 +206,7 @@
 	while ( Obj_to_ip_curr != Obj_to_ip_end ) {
 
 		/* myself ... */
-// 		if ( strncmp( Obj_to_ip_curr-&gt;olsr_node-&gt;ip, olsr_node-&gt;ip, NAMEMAX ) != 0 ) {
+/* 		if ( strncmp( Obj_to_ip_curr-&gt;olsr_node-&gt;ip, olsr_node-&gt;ip, NAMEMAX ) != 0 ) {*/
 
 			olsr_con_list = olsr_node-&gt;olsr_con_list;
 			while ( olsr_con_list != NULL ) {
@@ -230,7 +230,7 @@
 
 			Obj_to_ip_curr = Obj_to_ip_curr-&gt;next;
 
-// 		}
+/* 		} */
 
 	}
 
@@ -408,76 +408,76 @@
 	int i,j,o,r;
 	float d,gd,f,m[3];
 	float z[3]={0,0,0};
-// 	for (i=0;i&lt;max;i++)
-// 	{
-// 		node[i].mov[0]=
-// 		node[i].mov[1]=
-// 		node[i].mov[2]=0.0;
-// 	}
+/* 	for (i=0;i&lt;max;i++)
+ 	{
+ 		node[i].mov[0]=
+ 		node[i].mov[1]=
+ 		node[i].mov[2]=0.0;
+ 	} */
 
-	// calculate new movement vector
+	/* calculate new movement vector */
 	calc_olsr_node_mov();
 
-	// prepare nodes
+	/* prepare nodes */
 	handle_olsr_node( Olsr_root );
 
-	// move it
+	/* move it */
 	move_olsr_nodes();
 
-	/*	for (i=0;i&lt;max;i++)*/
-	/*	{*/
-	/*		for (j=i+1;j&lt;max;j++)*/
-	/*		{*/
-	/*			if (i!=j)*/
-	/*			{*/
-	/*				gd=adj[i*max+j];*/
-	/*				d=dirt(node[i].pos,node[j].pos,m);*/
-	/*				if (gd==0.0)*/	/* points are not connected */
-	/*				{*/
-/*					printf(&quot;distance between i and j: %f\n&quot;,d);*/
-	/*					if (d&lt;0.1) d=0.1;*/
-	/*					mov_add(node[j].mov,m,100/(d*d));*/
-	/*					mov_add(node[i].mov,m,-100/(d*d));*/
-	/*				} else {*/ /* connected!! */
+	/*	for (i=0;i&lt;max;i++)
+		{
+			for (j=i+1;j&lt;max;j++)
+			{
+				if (i!=j)
+				{
+					gd=adj[i*max+j];
+					d=dirt(node[i].pos,node[j].pos,m);
+					if (gd==0.0)*/	/* points are not connected 
+					{
+					printf(&quot;distance between i and j: %f\n&quot;,d);
+						if (d&lt;0.1) d=0.1;
+						mov_add(node[j].mov,m,100/(d*d));
+						mov_add(node[i].mov,m,-100/(d*d));
+					} else { / * connected!! * /
 
-	/*					f=(gd)/d;*/
-	/*					if (f&lt;0.3) f=0.3;*/
-	/*					mov_add(node[i].mov,m,1/f-1);*/
-	/*					mov_add(node[j].mov,m,-(1/f-1));*/
-/*					printf(&quot;distance between %d and %d: %f / %f = %f\n&quot;,i,j,gd,d,f);*/
-	/*				}*/
-	/*			}*/
-	/*		}*/
-	/*		d=dirt(node[i].pos,z,m);*/
-/*		mov_add(node[i].mov,m,d/100); * move a little bit to point zero */
-/*		mov_add(node[i].mov,m,1); * move a little bit to point zero */
-/*	}
-	/* move it!! */
-// 	for (i=0;i&lt;max;i++)
-// 	{
-/*		printf(&quot;applying move vector for point %d: %f:%f:%f\n&quot;,i,node[i].mov[0],node[i].mov[1],node[i].mov[2]);*/
-// 		if ((d=dist(node[i].mov,z))&gt;10.0)
-// 			mov_add(node[i].pos,node[i].mov,1.0/((float )d)); /* normalize */
-// 		else
-// 			mov_add(node[i].pos,node[i].mov,0.1);
-// 		s3d_translate(node[i].obj,node[i].pos[0],node[i].pos[1],node[i].pos[2]);
-// 		for (j=i+1;j&lt;max;j++)
-// 			if ((o=adj_obj[max*i+j])!=-1)
-// 			{
-// 				s3d_pop_vertex(o,6);
-/*				s3d_pop_polygon(o,2);*/
-// 				s3d_push_vertex(o,node[i].pos[0],	 node[i].pos[1],node[i].pos[2]);
-// 				s3d_push_vertex(o,node[i].pos[0]+0.2,node[i].pos[1],node[i].pos[2]);
-// 				s3d_push_vertex(o,node[i].pos[0]--&gt;id0.2,node[i].pos[1],node[i].pos[2]);
+						f=(gd)/d;
+						if (f&lt;0.3) f=0.3;
+						mov_add(node[i].mov,m,1/f-1);
+						mov_add(node[j].mov,m,-(1/f-1));
+					printf(&quot;distance between %d and %d: %f / %f = %f\n&quot;,i,j,gd,d,f);
+					}
+				}
+			}
+			d=dirt(node[i].pos,z,m);
+		mov_add(node[i].mov,m,d/100); * move a little bit to point zero 
+		mov_add(node[i].mov,m,1); * move a little bit to point zero 
+	}
+	/ * move it!! * /
+ 	for (i=0;i&lt;max;i++)
+ 	{
+/ *		printf(&quot;applying move vector for point %d: %f:%f:%f\n&quot;,i,node[i].mov[0],node[i].mov[1],node[i].mov[2]); * /
+ 		if ((d=dist(node[i].mov,z))&gt;10.0)
+ 			mov_add(node[i].pos,node[i].mov,1.0/((float )d)); / * normalize * /
+ 		else
+ 			mov_add(node[i].pos,node[i].mov,0.1);
+ 		s3d_translate(node[i].obj,node[i].pos[0],node[i].pos[1],node[i].pos[2]);
+ 		for (j=i+1;j&lt;max;j++)
+ 			if ((o=adj_obj[max*i+j])!=-1)
+ 			{
+ 				s3d_pop_vertex(o,6);
+/ *				s3d_pop_polygon(o,2);* /
+ 				s3d_push_vertex(o,node[i].pos[0],	 node[i].pos[1],node[i].pos[2]);
+ 				s3d_push_vertex(o,node[i].pos[0]+0.2,node[i].pos[1],node[i].pos[2]);
+ 				s3d_push_vertex(o,node[i].pos[0]--&gt;id0.2,node[i].pos[1],node[i].pos[2]);
+				
+ 				s3d_push_vertex(o,node[j].pos[0],	 node[j].pos[1],node[j].pos[2]);
+ 				s3d_push_vertex(o,node[j].pos[0],node[j].pos[1]+0.2,node[j].pos[2]);
+ 				s3d_push_vertex(o,node[j].pos[0],node[j].pos[1]-0.2,node[j].pos[2]);
 
-// 				s3d_push_vertex(o,node[j].pos[0],	 node[j].pos[1],node[j].pos[2]);
-// 				s3d_push_vertex(o,node[j].pos[0],node[j].pos[1]+0.2,node[j].pos[2]);
-// 				s3d_push_vertex(o,node[j].pos[0],node[j].pos[1]-0.2,node[j].pos[2]);
-
-/*				s3d_push_polygon(o,0,4,5,0);
-				s3d_push_polygon(o,3,1,2,0);*/
-// 			}
-// 	}
+/ *				s3d_push_polygon(o,0,4,5,0);
+				s3d_push_polygon(o,3,1,2,0);* /
+ 			}
+ 	} */
 	while (0!=(r=net_main()))
 		if (r==-1)
 		{
@@ -644,8 +644,9 @@
 	struct Obj_to_ip *del;
 	move_lst_ptr(&amp;id);
 	if(id != List_ptr-&gt;id)
+	{
 		/* printf(&quot;obj2ip: remove id %d failed move_lst_ptr return id %d\n&quot;,id,List_ptr-&gt;next-&gt;id); */
-	else {
+	} else {
 		del = List_ptr;
 		List_ptr-&gt;next-&gt;prev = List_ptr-&gt;prev;
 		List_ptr-&gt;prev-&gt;next = List_ptr-&gt;next;
@@ -681,8 +682,8 @@
 			}
 		} else {
 			List_ptr = Obj_to_ip_end;
-			/* printf(&quot;obj2ip: start at end id %d - %d &gt; %d - %d \n&quot;,*id,Obj_to_ip_head-&gt;next-&gt;id,Obj_to_ip_end-&gt;prev-&gt;id,*id); */
-			//do List_ptr = List_ptr-&gt;prev; while(*id &gt; List_ptr-&gt;prev-&gt;id);
+			/* printf(&quot;obj2ip: start at end id %d - %d &gt; %d - %d \n&quot;,*id,Obj_to_ip_head-&gt;next-&gt;id,Obj_to_ip_end-&gt;prev-&gt;id,*id);  */
+			/*  do List_ptr = List_ptr-&gt;prev; while(*id &gt; List_ptr-&gt;prev-&gt;id); */
 			while(*id &lt; List_ptr-&gt;prev-&gt;id) {
 				/* printf(&quot;obj2ip: %d &lt; %d move to &quot;,*id,List_ptr-&gt;id); */
 				List_ptr = List_ptr-&gt;prev;

Modified: trunk/apps/olsrs3d/net.c
===================================================================
--- trunk/apps/olsrs3d/net.c	2006-02-17 23:21:36 UTC (rev 85)
+++ trunk/apps/olsrs3d/net.c	2006-02-18 13:01:04 UTC (rev 86)
@@ -57,7 +57,7 @@
 		return(-1);
 	}
     buf[numbytes] = '\0';
-// 	strncat(lbuf,buf,MAXLINESIZE);
+/* 	strncat(lbuf,buf,MAXLINESIZE); */
 	strncpy(lbuf,buf,MAXLINESIZE);
 	process_main();
 	return(1);

Modified: trunk/apps/olsrs3d/process.c
===================================================================
--- trunk/apps/olsrs3d/process.c	2006-02-17 23:21:36 UTC (rev 85)
+++ trunk/apps/olsrs3d/process.c	2006-02-18 13:01:04 UTC (rev 86)
@@ -295,26 +295,27 @@
 	float 	*swap_adj;
 	int  	*swap_adj_obj;
 	char	nc_str[20];
-// 	printf(&quot;committing input ... \n&quot;);
+/* 	printf(&quot;committing input ... \n&quot;);
 
-	/* remove old adjacent objects ... */
-// 	for (i=0;i&lt;max;i++)
-// 		for (j=i+1;j&lt;max;j++)
-// 			if (adj_obj[i*max+j]!=-1)
-// 				if (new_adj_obj[i*new_max+j]==-1)
-// 				{
-// /*					printf(&quot;old link does not exist anymore ...\n&quot;);*/
-// 					/* this link does not exist anymore ... */
-// 					s3d_del_object(adj_obj[i*max+j]);
-// 				}
-	/* swap the matrices */
-// 	swap_adj=adj;
-// 	swap_adj_obj=adj_obj;
-//
-// 	adj=new_adj;
-// 	adj_obj=new_adj_obj;
+	/ * remove old adjacent objects ... * /
+ 	for (i=0;i&lt;max;i++)
+ 		for (j=i+1;j&lt;max;j++)
+ 			if (adj_obj[i*max+j]!=-1)
+ 				if (new_adj_obj[i*new_max+j]==-1)
+ 				{
+   / *				printf(&quot;old link does not exist anymore ...\n&quot;);* /
+ 					/ * this link does not exist anymore ... * /
+ 					s3d_del_object(adj_obj[i*max+j]);
+ 				}
+	/ * swap the matrices * /
+ 	swap_adj=adj;
+ 	swap_adj_obj=adj_obj;
 
+ 	adj=new_adj;
+ 	adj_obj=new_adj_obj;
+	*/
 
+
 	/* if we have more nodes redraw node count */
 	/* what if we have less nodes ?? */
 	if (new_max&gt;max)
@@ -331,162 +332,169 @@
 
 	}
 
-
-// 	new_adj=swap_adj;
-// 	new_adj_obj=swap_adj_obj;
+/*
+ 	new_adj=swap_adj;
+ 	new_adj_obj=swap_adj_obj;
+ 	*/
 	/* setting new maxsize */
 	max=new_max;
 	/* resetting the input-matrices*/
-// 	for (i=0;i&lt;max;i++)
-// 	for (j=0;j&lt;max;j++)
-// 	{
-// 		new_adj[i*max+j]=0.0;
-// 		new_adj_obj[i*max+j]=-1;
-// 	}
+	/*
+ 	for (i=0;i&lt;max;i++)
+ 	for (j=0;j&lt;max;j++)
+ 	{
+ 		new_adj[i*max+j]=0.0;
+ 		new_adj_obj[i*max+j]=-1;
+ 	}
+ 	*/
 	return(0);
 }
-// int parse_line( int lbuf_index ) {
-//
-// // 	int line_length;
-// 	char *lbuf_ptr;
-// // 	char *data[3];   // in this order: ip_from, ip_to, label
-// 	char *lbuf_ptr, *con_from, *con_to, *etx;
-// 	char *con_from;
-// 	char *con_to;
-// 	char *etx;
-//
-// 	struct olsr_node *olsr_node1;   // pointer to olsr nodes
-// 	struct olsr_node *olsr_node2;
-//
-// // 	line_length = strlen( lbuf[lbuf_index] );
-// 	lbuf_ptr = &amp;lbuf[lbuf_index];
-//
-// 	int i,dn,n1,n2;
-// 	float f;
-// // 	data[0]=data[1]=data[2]=NULL;
-// 	/*lbuf[n]='\0';  we don't need this one anyway */
-//
-// 	dn=0;
-// 	while ( (*lbuf_ptr) != '\0' ) {
-//
-// 		switch ( (*lbuf_ptr) ) {
-// // 			printf( &quot;%c&quot;, (*lbuf_ptr) );
-// 			case '&quot;':
-// 				if (dn&lt;6)
-// 				{
-// 					if ( !(dn%2) ) { /* starts */
-// 						switch ( dn ) {
-// 							case 0:
-// 								con_from = lbuf_ptr;
-// 								break;
-// 							case 2:
-// 								con_to = lbuf_ptr;
-// 								break;
-// 							case 4:
-// 								etx = lbuf_ptr;
-// 								break;
-// 						}
-// // 						*data[(dn/2)] = (*lbuf_ptr);
-// 					} else { /* ends */
-// 						(*lbuf_ptr) = '\0'; /* string terminator!! */
-// 					}
-// 				}
-// 				dn++;
-//
-// 				break;
-// // 			case '}':
-// // 				if (!(dn%2))	/* we don't end the input inside of strings ... this won't happen anyway, I guess */
-// // 					commit_input();
-// // 				break;
-// 		}
-// 		lbuf_ptr++;
-// 	}
-// 	if (dn&gt;=6)
-// 	{
-// /*		printf(&quot;######link from [%s] to [%s], label [%s]\n&quot;,data[0],data[1],data[2]);*/
-// 		/* announced network via HNA */
-// 		if ( strncmp( etx, &quot;HNA&quot;, NAMEMAX ) == 0 ) {
-//
-// 			/* connection to internet */
-// 			if ( strncmp( con_to, &quot;0.0.0.0/0.0.0.0&quot;, NAMEMAX ) == 0 ) {
-//
-// 				olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );
-//
-// 				if ( olsr_node1-&gt;node_type != 1 ) {
-//
-// 					olsr_node1-&gt;node_type = 1;
-// 					olsr_node1-&gt;node_type_modified = 1;
-// 					if ( Debug ) printf( &quot;new internet: %s\n&quot;, olsr_node1-&gt;ip );
-//
-// 				}
-//
-// 			/* normal HNA */
-// 			} else {
-//
-// 				olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );
-// 				olsr_node2 = get_olsr_node( &amp;Olsr_root, con_to );
-//
-// 				if ( olsr_node2-&gt;node_type != 2 ) {
-//
-// 					olsr_node2-&gt;node_type = 2;
-// 					olsr_node2-&gt;node_type_modified = 1;
-// 					if ( Debug ) printf( &quot;new hna network: %s\n&quot;, olsr_node2-&gt;ip );
-//
-// 				}
-//
-// 				add_olsr_con( olsr_node1, olsr_node2, -1000.00 );
-//
-// 			}
-//
-//
-//
-// 		/* normal node */
-// 		} else {
-// // 			n1=get_node_num(data[0]);
-// // 			n2=get_node_num(data[1]);
-// 			olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );
-// 			olsr_node2 = get_olsr_node( &amp;Olsr_root, con_to );
-// 			f=10.0+strtod(etx,NULL)/10.0;
-// /*		printf(&quot;######link from %d to %d, %f, %d\n&quot;,n1,n2,f, f&gt;=10);*/
-// 			if (f&gt;=5) /* just to prevent ascii to float converting inconsistency ... */
-// // 				add_adj(n1,n2,f);
-// 				add_olsr_con( olsr_node1, olsr_node2, f );
-// 		}
-// 	}
-// 	return(0);
-// }
-// int process_main()
-// {
-// 	int i,l;
-// 	i=0;
-// 	l=strlen(lbuf);
-// 	while (i&lt;l)
-// 	{
-// 		if ((lbuf[i])=='\n')
-// 		{
-// 			parse_line(i);
-// 			memmove(lbuf,lbuf+i+1,MAXLINESIZE-i-1);
-// 			process_main(); /* well, we don't have to do this the recursive way here, but who cares ... */
-// 			return(0);
-// 		}
-// 		i++;
-// 	}
-// 	return(0);
-// }
+/*
+ int parse_line( int lbuf_index ) {
 
+ / * 	int line_length; * /
+ 	char *lbuf_ptr;
+ / * 	char *data[3];  * / / * in this order: ip_from, ip_to, label * /
+ 	char *lbuf_ptr, *con_from, *con_to, *etx;
+ 	char *con_from;
+ 	char *con_to;
+ 	char *etx;
+
+ 	struct olsr_node *olsr_node1;   / * pointer to olsr nodes * /
+ 	struct olsr_node *olsr_node2;
+
+ / * 	line_length = strlen( lbuf[lbuf_index] ); * /
+ 	lbuf_ptr = &amp;lbuf[lbuf_index];
+
+ 	int i,dn,n1,n2;
+ 	float f;
+ / * 	data[0]=data[1]=data[2]=NULL; * /
+ 	/ *lbuf[n]='\0';  we don't need this one anyway * /
+
+ 	dn=0;
+ 	while ( (*lbuf_ptr) != '\0' ) {
+
+ 		switch ( (*lbuf_ptr) ) {
+ / * 			printf( &quot;%c&quot;, (*lbuf_ptr) ); * /
+ 			case '&quot;':
+ 				if (dn&lt;6)
+ 				{
+ 					if ( !(dn%2) ) { / * starts * /
+ 						switch ( dn ) {
+ 							case 0:
+ 								con_from = lbuf_ptr;
+ 								break;
+ 							case 2:
+ 								con_to = lbuf_ptr;
+ 								break;
+							case 4:
+ 								etx = lbuf_ptr;
+ 								break;
+ 						}
+ / * 						*data[(dn/2)] = (*lbuf_ptr); * /
+ 					} else { / * ends * /
+ 						(*lbuf_ptr) = '\0'; / * string terminator!! * /
+ 					}
+ 				}
+ 				dn++;
+
+ 				break;
+ / * 			case '}':
+  				if (!(dn%2))	 / * we don't end the input inside of strings ... this won't happen anyway, I guess * /
+  					commit_input();
+ 				break;
+  * /
+ 		}
+ 		lbuf_ptr++;
+ 	}
+ 	if (dn&gt;=6)
+ 	{
+  / *		printf(&quot;######link from [%s] to [%s], label [%s]\n&quot;,data[0],data[1],data[2]);* /
+ 		/ * announced network via HNA * /
+ 		if ( strncmp( etx, &quot;HNA&quot;, NAMEMAX ) == 0 ) {
+
+ 			/ * connection to internet * /
+ 			if ( strncmp( con_to, &quot;0.0.0.0/0.0.0.0&quot;, NAMEMAX ) == 0 ) {
+
+ 				olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );
+
+ 				if ( olsr_node1-&gt;node_type != 1 ) {
+
+ 					olsr_node1-&gt;node_type = 1;
+ 					olsr_node1-&gt;node_type_modified = 1;
+ 					if ( Debug ) printf( &quot;new internet: %s\n&quot;, olsr_node1-&gt;ip );
+
+ 				}
+
+ 			/ * normal HNA * /
+ 			} else {
+
+ 				olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );
+ 				olsr_node2 = get_olsr_node( &amp;Olsr_root, con_to );
+
+ 				if ( olsr_node2-&gt;node_type != 2 ) {
+						
+ 					olsr_node2-&gt;node_type = 2;
+ 					olsr_node2-&gt;node_type_modified = 1;
+ 					if ( Debug ) printf( &quot;new hna network: %s\n&quot;, olsr_node2-&gt;ip );
+
+ 				}
+
+ 				add_olsr_con( olsr_node1, olsr_node2, -1000.00 );
+
+ 			}
+
+
+
+ 		/ * normal node * /
+ 		} else {
+				/ *
+ 	 			n1=get_node_num(data[0]);
+  				n2=get_node_num(data[1]);
+  			* /
+ 			olsr_node1 = get_olsr_node( &amp;Olsr_root, con_from );
+ 			olsr_node2 = get_olsr_node( &amp;Olsr_root, con_to );
+ 			f=10.0+strtod(etx,NULL)/10.0;
+	 / *		printf(&quot;######link from %d to %d, %f, %d\n&quot;,n1,n2,f, f&gt;=10);* /
+ 			if (f&gt;=5) / * just to prevent ascii to float converting inconsistency ... * /
+ / * 				add_adj(n1,n2,f);* /
+ 				add_olsr_con( olsr_node1, olsr_node2, f );
+ 		}
+ 	}
+ 	return(0);
+ }
+ int process_main()
+ {
+ 	int i,l;
+ 	i=0;
+ 	l=strlen(lbuf);
+ 	while (i&lt;l)
+ 	{
+ 		if ((lbuf[i])=='\n')
+ 		{
+ 			parse_line(i);
+ 			memmove(lbuf,lbuf+i+1,MAXLINESIZE-i-1);
+ 			process_main(); / * well, we don't have to do this the recursive way here, but who cares ... * /
+ 			return(0);
+ 		}
+ 		i++;
+ 	}
+ 	return(0);
+ }
+*/
 int process_main() {
 
 	int dn;
 	float f;
 	char *lbuf_ptr, *con_from, *con_to, *etx;
-	struct olsr_node *olsr_node1;   // pointer to olsr nodes
+	struct olsr_node *olsr_node1;   /* pointer to olsr nodes */
 	struct olsr_node *olsr_node2;
 
 	lbuf_ptr = lbuf;
 
 	while ( (*lbuf_ptr) != '\0' ) {
 
-// 		printf( &quot;%c&quot;,(*lbuf_ptr) );
+/* 		printf( &quot;%c&quot;,(*lbuf_ptr) ); */
 
 		if ( (*lbuf_ptr) == '\n' ) {
 
@@ -516,7 +524,7 @@
 
 			if ( ++dn == 6 ) {
 
-// 				printf( &quot;con_from: %s, con_to: %s, etx: %s\n&quot;, con_from, con_to, etx );
+/* 				printf( &quot;con_from: %s, con_to: %s, etx: %s\n&quot;, con_from, con_to, etx ); */
 
 				/* announced network via HNA */
 				if ( strncmp( etx, &quot;HNA&quot;, NAMEMAX ) == 0 ) {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000081.html">[S3d-svn] r85 - in trunk: . client
</A></li>
	<LI>Next message: <A HREF="000083.html">[S3d-svn] r87 - in trunk: . client example
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#82">[ date ]</a>
              <a href="thread.html#82">[ thread ]</a>
              <a href="subject.html#82">[ subject ]</a>
              <a href="author.html#82">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/s3d-svn">More information about the S3d-svn
mailing list</a><br>
</body></html>
